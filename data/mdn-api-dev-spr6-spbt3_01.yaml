- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: RESTful Web Service Fundamentals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful Web服务基础
- en: In this chapter, we will go through the fundamentals of RESTful APIs (or REST
    APIs for short) and their design paradigms. We will take a brief look at the history
    of REST, learn how resources are formed, and understand methods and status codes
    before we move on to exploring **Hypermedia As The Engine Of Application State**
    (**HATEOAS**). These basics should provide a solid platform to enable you to develop
    a RESTful web service. You will also learn the best practices for designing **application
    programming** **interfaces** (**APIs**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨RESTful API（或简称为REST API）的基本原理及其设计范式。在继续探讨**超媒体作为应用程序状态引擎**（**HATEOAS**）之前，我们将简要回顾REST的历史，了解资源是如何形成的，并理解方法和状态码。这些基础知识应该为您提供一个坚实的基础，以使您能够开发RESTful
    Web服务。您还将学习设计**应用程序编程****接口**（**APIs**）的最佳实践。
- en: This chapter will also introduce a sample e-commerce app, which will be used
    throughout the book as you learn about the different aspects of API development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将介绍一个示例电子商务应用程序，该应用程序将在本书中作为您学习API开发不同方面的示例使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing REST APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍REST API
- en: Handling resources and **Uniform Resource** **Identifiers** (**URIs**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理资源和**统一资源标识符**（**URIs**）
- en: Exploring **Hypertext Transfer Protocol** (**HTTP**) methods and status codes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索**超文本传输协议**（**HTTP**）方法和状态码
- en: What is HATEOAS?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HATEOAS是什么？
- en: Best practices for designing REST APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计REST API的最佳实践
- en: Overview of an e-commerce app (our sample app)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务应用程序概述（我们的示例应用程序）
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any specific software. However, knowledge of HTTP
    is necessary.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要任何特定的软件。然而，了解HTTP是必要的。
- en: Introducing REST APIs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍REST API
- en: An API is how a piece of code communicates with another piece of code. You might
    have already written and consumed APIs for your programs; for example, Java provides
    APIs through classes wrapped in different modules, such as collection, input/output,
    and streams.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: API是代码与代码之间通信的方式。您可能已经为您的程序编写和消费过API；例如，Java通过不同模块中的类提供API，例如集合、输入/输出和流。
- en: Java’s SDK APIs allow one part of a program to communicate with another part
    of a program. You can write a function and then expose it with public access modifiers
    so that other classes can use it. That function signature is an API for that class.
    However, APIs that are exposed using these classes or libraries only allow internal
    communication inside a single application or an individual service. So, what happens
    when two or more applications (or services) want to communicate with each other,
    or, in other words, you would like to integrate two or more services? This is
    where system-wide APIs help us.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java的SDK API允许程序的一部分与程序的另一部分进行通信。您可以编写一个函数，然后通过公共访问修饰符公开它，以便其他类可以使用它。该函数签名是该类的API。然而，使用这些类或库公开的API仅允许单个应用程序或单个服务内部的内部通信。那么，当两个或多个应用程序（或服务）想要相互通信时，或者换句话说，您想要集成两个或多个服务时，会发生什么呢？这就是系统级API帮助我们的时候。
- en: Historically, there were different ways to integrate one application with another
    – RPC, **Simple Object Access Protocol** (**SOAP**)-based services, and more.
    The integration of apps has become an integral part of software architectures,
    especially after the boom of the cloud and mobile phones. You now have social
    logins, such as Facebook, Google, and GitHub, which means you can develop your
    application even without writing an independent login module and get around security
    issues such as storing passwords securely.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，有几种不同的方法可以将一个应用程序与另一个应用程序集成——RPC、基于**简单对象访问协议**（**SOAP**）的服务等等。应用程序的集成已成为软件架构的一个基本组成部分，尤其是在云计算和移动电话的繁荣之后。现在您有了社交登录，如Facebook、Google和GitHub，这意味着您可以在不编写独立的登录模块的情况下开发您的应用程序，并绕过诸如安全存储密码等问题。
- en: These social logins provide APIs using REST and GraphQL. Currently, REST is
    the most popular, and it has become the standard for writing APIs for integration
    and web app consumption. We’ll also discuss GraphQL in detail in the final chapters
    of this book (in [*Chapter 13*](B19349_13.xhtml#_idTextAnchor288), *Getting Started
    with GraphQL*, and [*Chapter 14*](B19349_14.xhtml#_idTextAnchor313), *GraphQL
    API Development* *and Testing*).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些社交登录提供了使用REST和GraphQL的API。目前，REST是最受欢迎的，并且已经成为编写集成和Web应用消费API的标准。我们还将详细讨论GraphQL，这将在本书的最后一章（[第13章](B19349_13.xhtml#_idTextAnchor288)，*开始使用GraphQL*）和[第14章](B19349_14.xhtml#_idTextAnchor313)，*GraphQL
    API开发和测试*）中进行讨论。
- en: '**REST** stands for **REpresentational State Transfer**, which is a style of
    software architecture. Web services that adhere to the REST style are called RESTful
    web services. In the following sections, we will take a quick look at the history
    of REST to understand its fundamentals.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**表征状态转移**，这是一种软件架构风格。遵循REST风格的Web服务被称为RESTful Web服务。在接下来的章节中，我们将简要回顾REST的历史，以了解其基本原理。'
- en: The history of REST
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST的历史
- en: Before the adoption of REST, when the internet was just starting to become widely
    known and Yahoo and Hotmail were the popular mail and social messaging apps, there
    was no standard software architecture that offered a homogenous way to integrate
    with web applications. People were using SOAP-based web services, which, ironically,
    were not simple at all.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用REST之前，当互联网刚开始广为人知，Yahoo和Hotmail是流行的邮件和社交消息应用时，没有一种标准的软件架构能够提供一种统一的方式来与Web应用集成。人们使用基于SOAP的Web服务，讽刺的是，它们并不简单。
- en: Then came the light. Roy Fielding, in his doctoral research, *Architectural
    Styles and the Design of Network-Based Software Architectures* ([https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)),
    came up with REST in 2000\. REST’s architecture style allowed any server to communicate
    with any other server over the network. It simplified communication and made integration
    easier. REST was made to work on top of HTTP, which enables it to be used all
    over the web and in internal networks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随后出现了曙光。Roy Fielding在他的博士研究中，《网络软件架构的风格及其设计》（[https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)），在2000年提出了REST。REST的架构风格允许任何服务器通过网络与任何其他服务器进行通信。它简化了通信，使集成更容易。REST被设计在HTTP之上工作，这使得它可以在整个Web和内部网络上使用。
- en: eBay was the first to exploit REST-based APIs. It introduced the REST API with
    selected partners in November 2000\. Later, Amazon, Delicious (a site-bookmarking
    web app), and Flickr (the photo-sharing app) started providing REST-based APIs.
    Then, **Amazon Web Services** (**AWS**) took advantage of Web 2.0 (with the invention
    of REST) and provided REST APIs to developers for AWS cloud consumption in 2006.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: eBay是第一个利用基于REST的API的公司。它在2000年11月与选定的合作伙伴推出了REST API。后来，Amazon、Delicious（一个网站书签应用）和Flickr（照片分享应用）开始提供基于REST的API。然后，**亚马逊网络服务**（**AWS**）利用Web
    2.0（随着REST的发明）在2006年为开发者提供了AWS云消费的REST API。
- en: Later, Facebook, Twitter, Google, and other companies started using it. Nowadays
    (in 2023), you will hardly find any web applications that have been developed
    without a REST API. However, the GraphQL-based API for mobile apps is getting
    close in terms of popularity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Facebook、Twitter、Google和其他公司开始使用它。如今（2023年），你几乎找不到没有开发REST API的Web应用。然而，基于GraphQL的移动应用API在受欢迎程度上正在接近。
- en: REST fundamentals
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST基本原理
- en: REST works on top of the HTTP protocol. Each URI works as an API resource. Therefore,
    we should use nouns as endpoints instead of verbs. RPC-style endpoints use verbs,
    for example, `/api/v1/getPersons`. In comparison, in REST, this endpoint could
    be simply written as `/api/v1/persons`. You must be wondering, then, how we can
    differentiate between the different actions performed on a REST resource. This
    is where HTTP methods help us. We can make our HTTP methods act as verbs, for
    example, `GET`, `DELETE`, `POST` (for creating), `PUT` (for modifying), and `PATCH`
    (for partial updating). We’ll discuss this in more detail later. For now, the
    `getPerson` RPC-style endpoint is translated into `GET /api/v1/persons` in REST.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: REST 在 HTTP 协议之上工作。每个 URI 都作为一个 API 资源。因此，我们应该使用名词作为端点而不是动词。RPC 风格的端点使用动词，例如，`/api/v1/getPersons`。相比之下，在
    REST 中，这个端点可以简单地写成 `/api/v1/persons`。你可能想知道，那么我们如何区分在 REST 资源上执行的不同操作。这就是 HTTP
    方法帮我们的地方。我们可以让我们的 HTTP 方法充当动词，例如，`GET`、`DELETE`、`POST`（用于创建）、`PUT`（用于修改）和 `PATCH`（用于部分更新）。我们将在稍后详细讨论这个问题。现在，`getPerson`
    RPC 风格的端点在 REST 中被翻译成 `GET /api/v1/persons`。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The REST endpoint is a unique URI that represents a REST resource. For example,
    `https://demo.app/api/v1/persons` is a REST endpoint. Additionally, `/api/v1/persons`
    is the endpoint path and `persons` is the REST resource.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: REST 端点是表示 REST 资源的唯一的 URI。例如，`https://demo.app/api/v1/persons` 是一个 REST 端点。此外，`/api/v1/persons`
    是端点路径，`persons` 是 REST 资源。
- en: Here, there is client and server communication. Therefore, REST is based on
    the *client-server* concept. The client calls the REST API and the server responds.
    REST allows a client (that is, a program, web service, or UI app) to talk to a
    remotely (or locally) running server (or web service) using HTTP requests and
    responses. The client sends an API command wrapped in an HTTP request to the web
    service. This HTTP request may contain a payload (or input) in the form of query
    parameters, headers, or request bodies. The called web service responds with a
    success/failure indicator and the response data wrapped inside the HTTP response.
    The HTTP status code normally denotes the status, and the response body contains
    the response data. For example, an HTTP status code of `200 OK` normally represents
    success.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在客户端和服务器之间的通信。因此，REST 基于 *客户端-服务器* 概念。客户端调用 REST API，服务器响应。REST 允许客户端（即程序、Web
    服务或 UI 应用程序）通过 HTTP 请求和响应与远程（或本地）运行的服务器（或 Web 服务）进行通信。客户端将 API 命令封装在 HTTP 请求中发送到
    Web 服务。这个 HTTP 请求可能包含以查询参数、头或请求体形式的数据负载（或输入）。被调用的 Web 服务以成功/失败指示器和封装在 HTTP 响应中的响应数据作为响应。HTTP
    状态码通常表示状态，响应体包含响应数据。例如，HTTP 状态码 `200 OK` 通常表示成功。
- en: From a REST perspective, an HTTP request is self-descriptive and has enough
    context for the server to process it. Therefore, REST calls are *stateless*. States
    are either managed on the client side or on the server side. A REST API does not
    maintain its state. It only transfers states from the server to the client or
    vice versa. This is why it is called *REpresentational State Transfer*, or REST
    for short.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从 REST 的角度来看，HTTP 请求是自描述的，并且有足够的信息供服务器处理。因此，REST 调用是无状态的。状态要么在客户端管理，要么在服务器端管理。REST
    API 不维护其状态。它只从服务器传输状态到客户端或反之亦然。这就是为什么它被称为 *REpresentational State Transfer*，或简称
    REST。
- en: REST also makes use of HTTP cache control, which makes REST APIs *cacheable*.
    Therefore, the client can also cache the representation (that is, the HTTP response)
    because every representation is self-descriptive.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: REST 还使用了 HTTP 缓存控制，这使得 REST API 可**缓存**。因此，客户端也可以缓存表示（即 HTTP 响应），因为每个表示都是自描述的。
- en: 'REST operates using three key components:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: REST 使用三个关键组件进行操作：
- en: Resources and URIs
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源和统一资源标识符（URIs）
- en: HTTP methods
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: HATEOAS
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HATEOAS
- en: 'A sample REST call in plain text looks like the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 REST 调用以纯文本形式看起来如下所示：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `/licenses` path denotes the licenses resource. `GET` is an HTTP method.
    `2` at the end of the first line denotes the HTTP protocol version. The second
    line shares the host to call.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`/licenses` 路径表示许可证资源。`GET` 是一个 HTTP 方法。第一行末尾的 `2` 表示 HTTP 协议版本。第二行共享了要调用的主机。
- en: 'GitHub responds with a JSON object. The status is `200 OK` and the JSON object
    is wrapped in a response body, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 以 JSON 对象的形式响应。状态是 `200 OK`，JSON 对象被封装在响应体中，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you note the third line in this response, it tells you the value of the content
    type. It is good practice to have JSON as the content type for both the request
    and the response.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意这个响应的第三行，它告诉你内容类型的值。对于请求和响应，将JSON作为内容类型是一个好习惯。
- en: Now that we have familiarized ourselves with the fundamentals of REST, we are
    going to dive a bit deeper into REST’s first concept, resources and URIs, and
    learn what they are and how they are generally used.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了REST的基础知识，我们将更深入地探讨REST的第一个概念，资源和URI，并了解它们是什么以及它们通常是如何使用的。
- en: Handling resources and URIs
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理资源和URI
- en: Every document on the **World Wide Web** (**WWW**) is represented as a resource
    in terms of HTTP. This resource is represented as a URI, which is an endpoint
    that represents a unique resource on a server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在**万维网**（**WWW**）上的每个文档都作为HTTP术语下的资源表示。这个资源被表示为一个URI，它是一个代表服务器上唯一资源的端点。
- en: Roy Fielding in his doctoral research states that a URI is known by many names
    – a WWW address, a **Universal Document Identifier** (**UDI**), a URI, a **Uniform
    Resource Locator** (**URL**), and a **Uniform Resource** **Name** (**URN**).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伊·菲尔丁在他的博士研究中指出，URI有多个名称——WWW地址、**通用文档标识符**（**UDI**）、URI、**统一资源定位符**（**URL**）和**统一资源名称**（**URN**）。
- en: 'So, what is a URI? A URI is a string (that is, a sequence of characters) that
    identifies a resource by its location, name, or both (in the WWW world). There
    are two types of URIs: URLs and URNs.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是URI？URI是一个字符串（即字符序列），通过其位置、名称或两者（在WWW世界中）来标识资源。URI有两种类型：URL和URN。
- en: URLs are widely used and even known to non-developer users. URLs are not only
    restricted to HTTP but are also used for many other protocols, such as FTP, JDBC,
    and MAILTO. A URL is an identifier that identifies the network location of a resource.
    We will go into more detail in the later sections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: URL被广泛使用，甚至非开发用户也知道。URL不仅限于HTTP，还用于许多其他协议，如FTP、JDBC和MAILTO。URL是一个标识符，用于标识资源的网络位置。我们将在后面的章节中详细介绍。
- en: The URI syntax
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URI语法
- en: 'The URI syntax is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: URI语法如下：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As per the syntax, the following is the list of components of a URI:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据语法，以下是一个URI组件的列表：
- en: '`:`). `scheme` starts with a letter and is followed by any combination of digits,
    letters, periods (`.`), hyphens (`-`), or plus characters (`+`).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:`)。`scheme`以字母开头，后跟任何组合的数字、字母、点（`.`）、连字符（`-`）或加号（`+`）。'
- en: Scheme examples include HTTP, HTTPS, MAILTO, FILE, and FTP. URI schemes must
    be registered with the **Internet Assigned Numbers** **Authority** (**IANA**).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 方案示例包括HTTP、HTTPS、MAILTO、FILE和FTP。URI方案必须向**互联网数字分配机构**（**IANA**）注册。
- en: '`//`. It consists of the following optional subfields:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`)。它由以下可选子字段组成：'
- en: '`:`).'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:`)。'
- en: '`/`). In the preceding GitHub REST API example, `/licenses` is the path.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`)。在上面的GitHub REST API示例中，`/licenses`是路径。'
- en: '`?`). The query component contains a query string of non-hierarchical data.
    Each parameter is separated by an ampersand (`&`) in the query component and parameter
    values are assigned using an equals (`=`) operator.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`)。查询组件包含非分层数据的查询字符串。查询组件中的每个参数由一个与号（`&`）分隔，参数值使用等号（`=`）运算符分配。'
- en: '`#`). The fragment component includes a fragment identifier that gives direction
    to a secondary resource.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#`)。片段组件包含一个片段标识符，为次要资源提供方向。'
- en: 'The following list contains examples of URIs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表包含了一些URI的示例：
- en: '[www.packt.com](http://www.packt.com): This doesn’t contain the scheme. It
    just contains the domain name. There is no port either, which means it points
    to the default port.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.packt.com](http://www.packt.com): 这不包含方案。它只包含域名。也没有端口，这意味着它指向默认端口。'
- en: '`index.html`: This contains no scheme nor authority. It only contains the path.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`: 这不包含方案和授权信息。它只包含路径。'
- en: '[https://www.packt.com/index.html](https://www.packt.com/index.html): This
    contains the scheme, authority, and path.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packt.com/index.html](https://www.packt.com/index.html): 这包含方案、授权信息和路径。'
- en: 'Here are some examples of different scheme URIs:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不同方案URI的示例：
- en: '[mailto:support@packt.com](mailto:support@packt.com)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mailto:support@packt.com](mailto:support@packt.com)'
- en: '[telnet://192.168.0.1:23/](telnet://192.168.0.1:23/)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[telnet://192.168.0.1:23/](telnet://192.168.0.1:23/)'
- en: '[ldap://[2020:ab9::9]/c=AB?objectClass?obj](ldap://[2020:ab9::9]/c=AB?objectClass?obj)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ldap://[2020:ab9::9]/c=AB?objectClass?obj](ldap://[2020:ab9::9]/c=AB?objectClass?obj)'
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'From a REST perspective, the path component of a URI is very important because
    it represents the resource path and your API endpoint paths are formed based on
    it. For example, take a look at the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从REST的角度来看，URI的路径组件非常重要，因为它代表了资源路径，你的API端点路径就是基于它形成的。例如，看看以下内容：
- en: '`GET https://www.domain.com/api/v1/order/1`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET https://www.domain.com/api/v1/order/1`'
- en: Here, `/api/v1/order/1` represents the path and `GET` represents the HTTP method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`/api/v1/order/1`代表路径，`GET`代表HTTP方法。
- en: What is a URL?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是URL？
- en: If you look closely, most of the URI examples mentioned earlier can also be
    called URLs. A URI is an identifier; on the other hand, a URL is not only an identifier,
    but it also tells you how to get to it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，前面提到的许多URI示例也可以称为URL。URI是一个标识符；另一方面，URL不仅是一个标识符，它还告诉你如何到达它。
- en: Request for Comments (RFC)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请求评论（RFC）
- en: As per RFC-3986 on URIs ([https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)),
    the term URL refers to the subset of URIs that, in addition to identifying a resource,
    provide a means of locating the resource by describing its primary access mechanism
    (for example, its network *location*).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC-3986关于URI的说明（[https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)），术语URL指的是URI的子集，除了标识资源外，还提供了一种通过描述其主要访问机制（例如，其网络*位置*）来定位资源的方法。
- en: A URL represents the full web address of a resource, including the protocol
    name (the scheme), the hostname port (in case the HTTP port is not `80`; for HTTPS,
    the default port is `443`), part of the authority component, the path, and optional
    query and fragment subcomponents.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: URL代表资源的完整网络地址，包括协议名称（方案）、主机名端口（如果HTTP端口不是`80`；对于HTTPS，默认端口是`443`）、授权组件的一部分、路径以及可选的查询和片段子组件。
- en: What is a URN?
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是URN？
- en: 'URNs are not commonly used. They are also a type of URI that starts with a
    scheme – `urn`. The following URN example is directly taken from RFC-3986 for
    URIs ([https://www.ietf.org/rfc/rfc3986.txt](https://www.ietf.org/rfc/rfc3986.txt)):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: URN并不常用。它们也是一种以方案`urn`开头的URI。以下URN示例直接取自RFC-3986关于URI的文档（[https://www.ietf.org/rfc/rfc3986.txt](https://www.ietf.org/rfc/rfc3986.txt)）：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example follows the `"urn:" <NID> ":" <NSS>` syntax, where `<NID>` is the
    namespace identifier, and `<NSS>` is the namespace-specific string. We are not
    going to use URNs in our REST implementation. However, you can read more about
    them at RFC-2141 ([https://tools.ietf.org/html/rfc2141](https://tools.ietf.org/html/rfc2141)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例遵循`"urn:" <NID> ":" <NSS>`语法，其中`<NID>`是命名空间标识符，`<NSS>`是命名空间特定字符串。我们不会在我们的REST实现中使用URN。然而，你可以在RFC-2141中了解更多关于它们的信息（[https://tools.ietf.org/html/rfc2141](https://tools.ietf.org/html/rfc2141)）。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As per RFC-3986 on URIs ([https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)),
    the term URN has been used historically to refer to both URIs under the “*urn”*
    scheme RFC-2141, which are required to remain globally unique and persistent even
    when the resource ceases to exist or becomes unavailable, and to any other URI
    with the properties of a name.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC-3986关于URI的说明（[https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)），术语URN在历史上被用来指代“*urn*”方案RFC-2141下的URI，这些URI即使在资源不再存在或不可用的情况下也必须保持全球唯一性和持久性，以及任何具有名称属性的其他URI。
- en: 'Now that you understand the difference between a URI and a URN and how they
    make up URIs, let’s learn about the second concept that makes up REST: HTTP methods
    and status codes.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了URI和URN之间的区别以及它们如何构成URI，让我们学习REST的第二个概念：HTTP方法和状态码。
- en: Exploring HTTP methods and status codes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索HTTP方法和状态码
- en: 'HTTP provides various HTTP methods. However, you are primarily going to use
    only five of them. To begin with, you want to have **Create**, **Read**, **Update**,
    and **Delete** (**CRUD**) operations associated with HTTP methods:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP提供了各种HTTP方法。然而，你主要将只使用其中的五个。首先，你希望将**创建**、**读取**、**更新**和**删除**（**CRUD**）操作与HTTP方法相关联：
- en: '`POST`: Create or search'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: 创建或搜索'
- en: '`GET`: Read'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 读取'
- en: '`PUT`: Update'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 更新'
- en: '`DELETE`: Delete'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 删除'
- en: '`PATCH`: Partial update'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`: 部分更新'
- en: Some organizations also provide the `HEAD` method for scenarios where you just
    want to retrieve the header responses from the REST endpoints. You can hit any
    GitHub API with the `HEAD` operation to retrieve only headers; for example, `curl
    --``head https://api.github.com/users`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织也提供了`HEAD`方法，用于仅想从REST端点检索头部响应的场景。你可以使用`HEAD`操作对任何GitHub API进行操作以仅检索头部；例如，`curl
    --head https://api.github.com/users`。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: REST has no requirement that specifies which method should be used for which
    operation. However, widely used industry guidelines and practices suggest following
    certain rules.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: REST 没有规定应该使用哪种方法来进行哪种操作。然而，广泛使用的行业指南和实践建议遵循某些规则。
- en: Let’s discuss each method in detail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论每种方法。
- en: POST
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST
- en: The HTTP `POST` method is normally what you want to associate with creating
    resource operations. However, there are certain exceptions when you might want
    to use the `POST` method for read operations. However, it should be put into practice
    after a well-thought-out process. One such exception is a search operation where
    the filter criteria have too many parameters, which might cross the `GET` call’s
    length limit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `POST` 方法通常与创建资源操作相关联。然而，在某些情况下，你可能希望使用 `POST` 方法进行读取操作。但是，这应该在经过深思熟虑的过程后实施。一个这样的例外是搜索操作，其中过滤条件有太多参数，可能会超过
    `GET` 调用的长度限制。
- en: A `GET` query string has a limit of 256 characters. Additionally, the HTTP `GET`
    method is limited to a maximum of 2,048 characters minus the number of characters
    in the actual path. On the other hand, the `POST` method is not limited by the
    size of the URL for submitting name and value pairs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 查询字符串的长度限制为 256 个字符。此外，HTTP `GET` 方法在提交名称和值对时，其长度限制为最多 2,048 个字符减去实际路径中的字符数。另一方面，`POST`
    方法在提交名称和值对时不受 URL 大小的限制。'
- en: You may also want to use the `POST` method with HTTPS for a read call if the
    submitted input parameters contain any private or secure information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提交的输入参数包含任何私有或安全信息，你也可以使用 HTTPS 与 `POST` 方法进行读取调用。
- en: For successful create operations, you can respond with the `201 Created` status,
    and for successful search or read operations, you should use the `200 OK` or `204
    No Content` status codes, although the call is made using the HTTP `POST` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成功的创建操作，你可以响应 `201 Created` 状态码，而对于成功的搜索或读取操作，你应该使用 `200 OK` 或 `204 No Content`
    状态码，尽管调用是使用 HTTP `POST` 方法进行的。
- en: For failed operations, REST responses may have different error status codes
    based on the error type, which we will look at later in this section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于失败的操作，REST 响应可能根据错误类型具有不同的错误状态码，我们将在本节稍后讨论。
- en: GET
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET
- en: The HTTP `GET` method is what you usually want to associate with read resource
    operations. Similarly, you must have observed the GitHub `GET /licenses` call
    that returns the available licenses in the GitHub system. Additionally, successful
    `GET` operations should be associated with the `200 OK` status code if the response
    contains data, or `204 No Content` if the response contains no data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `GET` 方法通常与读取资源操作相关联。同样，你可能已经观察到 GitHub `GET /licenses` 调用，该调用返回 GitHub
    系统中可用的许可证。此外，如果响应包含数据，成功的 `GET` 操作应与 `200 OK` 状态码相关联；如果响应不包含数据，则应与 `204 No Content`
    状态码相关联。
- en: PUT
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PUT
- en: The HTTP `PUT` method is what you usually want to associate with update resource
    operations. Additionally, successful update operations should be associated with
    a `200 OK` status code if the response contains data, or `204 No Content` if the
    response contains no data. Some developers use the `PUT` HTTP method to replace
    existing resources. For example, GitHub API v3 uses `PUT` to replace the existing
    resource.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `PUT` 方法通常与更新资源操作相关联。此外，如果响应包含数据，成功的更新操作应与 `200 OK` 状态码相关联；如果响应不包含数据，则应与
    `204 No Content` 状态码相关联。一些开发者使用 `PUT` HTTP 方法来替换现有资源。例如，GitHub API v3 使用 `PUT`
    来替换现有资源。
- en: DELETE
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DELETE
- en: The HTTP `DELETE` method is what you want to associate with resource deletion
    operations. GitHub does not provide the `DELETE` operation on the `licenses` resource.
    However, if you assume it exists, it will certainly look very similar to `DELETE
    / licenses/agpl-3.0`. A successful `DELETE` call should delete the resource associated
    with the `agpl-3.0` key. Additionally, successful `DELETE` operations should be
    associated with the `204 No Content` status code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `DELETE` 方法通常与资源删除操作相关联。GitHub 不在 `licenses` 资源上提供 `DELETE` 操作。然而，如果你假设它存在，它肯定会看起来非常类似于
    `DELETE / licenses/agpl-3.0`。一个成功的 `DELETE` 调用应该删除与 `agpl-3.0` 键关联的资源。此外，成功的 `DELETE`
    操作应与 `204 No Content` 状态码相关联。
- en: PATCH
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PATCH
- en: The HTTP `PATCH` method is what you want to associate with partial update resource
    operations. Additionally, successful `PATCH` operations should be associated with
    a `200 OK` status code. `PATCH` is relatively new as compared to other HTTP operations.
    In fact, a few years ago, Spring did not have state-of-the-art support for this
    method for REST implementation due to the old Java HTTP library. However, currently,
    Spring provides built-in support for the `PATCH` method in REST implementation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `PATCH` 方法是您想要与部分更新资源操作相关联的方法。此外，成功的`PATCH`操作应与`200 OK`状态代码相关联。与其它HTTP操作相比，`PATCH`相对较新。实际上，几年前，由于旧的Java
    HTTP库，Spring在REST实现中并没有对这种方法提供最先进的支持。然而，目前，Spring在REST实现中为`PATCH`方法提供了内置支持。
- en: HTTP status codes
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: 'There are five categories of HTTP status codes, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态代码有五个类别，如下所示：
- en: Informational responses (`100`–`199`)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息性响应 (`100`–`199`)
- en: Successful responses (`200`–`299`)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功响应 (`200`–`299`)
- en: Redirects (`300`–`399`)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向 (`300`–`399`)
- en: Client errors (`400`–`499`)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端错误 (`400`–`499`)
- en: Server errors (`500`–`599`)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器错误 (`500`–`599`)
- en: 'You can view a complete list of status codes at MDN Web Docs ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status))
    or RFC-7231 ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)).
    However, you can find the most commonly used REST response status codes in the
    following table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在MDN Web Docs（[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)）或RFC-7231（[https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)）中查看状态代码的完整列表。然而，您可以在以下表格中找到最常用的REST响应状态代码：
- en: '| **HTTP** **Status Code** | **Description** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP** **状态码** | **描述** |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `200 OK` | For successful requests other than those already created. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `200 OK` | 对于除已创建之外的成功请求。|'
- en: '| `201 Created` | For successful creation requests. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `201 已创建` | 用于成功创建请求。|'
- en: '| `202 Accepted` | The request has been received but not yet acted upon. This
    is used when the server accepts the request, but the response cannot be sent immediately,
    for example, in batch processing. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `202 已接受` | 请求已接收但尚未处理。当服务器接受请求但不能立即发送响应时使用，例如在批量处理中。|'
- en: '| `204` `No Content` | For successful operations that contain no data in the
    response. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `204` `无内容` | 用于响应中不包含数据的成功操作。|'
- en: '| `304` `Not Modified` | This is used for caching. The server responds to the
    client that the resource is not modified; therefore, the same cache resource can
    be used. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `304` `未修改` | 用于缓存。服务器向客户端响应资源未修改；因此，可以使用相同的缓存资源。|'
- en: '| `400` `Bad Request` | This is for failed operations when input parameters
    either are incorrect or missing or the request itself is incomplete. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `400` `错误请求` | 当输入参数不正确或缺失或请求本身不完整时操作失败的错误。|'
- en: '| `401 Unauthorized` | This is for operations that have failed due to unauthenticated
    requests. The specification says it’s unauthorized, but semantically, it means
    unauthenticated. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `401 未授权` | 由于未认证请求而失败的错误。规范称其为未授权，但从语义上讲，它表示未认证。|'
- en: '| `403 Forbidden` | This is for failed operations that the invoker is not authorized
    to perform. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `403 禁止` | 当调用者未授权执行操作时操作失败的错误。|'
- en: '| `404` `Not Found` | This is for failed operations when the requested resource
    doesn’t exist. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `404` `未找到` | 当请求的资源不存在时操作失败的错误。|'
- en: '| `405 Method` `Not Allowed` | This is for failed operations when the method
    is not allowed for the requested resource. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `405 方法不允许` | 当请求的资源不允许使用该方法时操作失败的错误。|'
- en: '| `409 Conflict` | This is for failed operations when an attempt is made for
    a duplicate create operation. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `409 冲突` | 当尝试重复创建操作时，操作失败的错误。|'
- en: '| `429 Too` `Many Requests` | This is for failed operations when a user sends
    too many requests in a given amount of time (rate limiting). |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `429 请求过多` | 当用户在给定时间内发送过多请求时（速率限制）操作失败的错误。|'
- en: '| `500 Internal` `Server Error` | This is for failed operations due to server
    errors. It’s a generic error. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `500 内部服务器错误` | 由于服务器错误导致的操作失败。这是一个通用错误。|'
- en: '| `502` `Bad Gateway` | This is for failed operations when upstream server
    calls fail, for example, when an app calls a third-party payment service, but
    the call fails. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `502` `错误网关` | 当上游服务器调用失败时操作失败的错误，例如，当应用程序调用第三方支付服务但调用失败时。|'
- en: '| `503` `Service Unavailable` | This is for failed operations when something
    unexpected has happened at the server, for example, an overload or a service fails.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `503` `Service Unavailable` | 这是在服务器发生意外情况时失败的操作，例如过载或服务失败。 |'
- en: We have discussed the key components of REST, such as endpoints in the form
    of URIs, methods, and status codes. Let’s explore HATEOAS, the backbone of REST
    concepts that differentiates it from RPC style.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了REST的关键组件，例如以URI形式表示的端点、方法和状态码。让我们探索HATEOAS，这是REST概念的核心，它将REST与RPC风格区分开来。
- en: What is HATEOAS?
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是HATEOAS？
- en: With HATEOAS, RESTful web services provide information dynamically through hypermedia.
    Hypermedia is a part of the content that you receive from a REST call response.
    This hypermedia content contains links to different types of media, such as text,
    images, and videos.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HATEOAS，RESTful网络服务通过超媒体动态提供信息。超媒体是您从REST调用响应中接收到的内容的一部分。此超媒体内容包含指向不同类型媒体的链接，例如文本、图像和视频。
- en: 'Hypermedia links can be contained either in HTTP headers or the response body.
    If you look at GitHub APIs, you will find that GitHub APIs provide hypermedia
    links in both headers and the response body. GitHub uses the header named `Link`
    to contain the paging-related links. Additionally, if you look at the responses
    of GitHub APIs, you’ll also find other resource-related links with keys that have
    a postfix of `url`. Let’s look at an example. We’ll hit the `GET` `/users` resource
    and analyze the response:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体链接可以包含在HTTP头或响应体中。如果您查看GitHub API，您会发现GitHub API在头和响应体中都提供了超媒体链接。GitHub使用名为`Link`的头部来包含分页相关的链接。此外，如果您查看GitHub
    API的响应，您还会找到其他与资源相关的链接，其键具有`url`后缀。让我们看一个例子。我们将调用`GET` `/users`资源并分析响应：
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command execution provides an output similar to the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令执行会输出类似于以下内容：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding output, you’ll find that the `Link` header contains the pagination
    information. Links to the `next` page and the `first` page are given as a part
    of the response. Additionally, you can find many URLs in the response body, such
    as `avatar_url` or `followers_url`, which provide links to other hypermedia.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，您会发现`Link`头包含分页信息。`next`页和`first`页的链接作为响应的一部分给出。此外，您还可以在响应体中找到许多URL，例如`avatar_url`或`followers_url`，它们提供了指向其他超媒体的链接。
- en: REST clients should possess a generic understanding of hypermedia so they can
    interact with RESTful web services without having any specific knowledge of how
    to interact with the server. You just call any static REST API endpoint, and you
    will receive the dynamic links as a part of the response to interact further.
    REST allows clients to dynamically navigate to the appropriate resource by traversing
    the links. It empowers machines, as REST clients can navigate to different resources
    in a similar way to how humans look at a web page and click on any link. Put simply,
    the REST client uses these links to navigate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: REST客户端应该具备对超媒体的一般理解，这样他们就可以与RESTful网络服务交互，而无需了解如何与服务器交互的任何特定知识。您只需调用任何静态REST
    API端点，就会收到作为响应一部分的动态链接，以便进一步交互。REST允许客户端通过遍历链接动态导航到适当的资源。它赋予机器能力，因为REST客户端可以以类似于人类查看网页并点击任何链接的方式导航到不同的资源。简单来说，REST客户端使用这些链接进行导航。
- en: 'HATEOAS is a very important concept of REST. It is one of the concepts that
    differentiate REST from RPC. Even Roy Fielding was so concerned with certain REST
    API implementations that he published the following blog on his website in 2008:
    *REST APIs must be* *hypertext-driven* ([https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS是REST的一个非常重要的概念。它是将REST与RPC区分开来的概念之一。甚至Roy Fielding对某些REST API实现如此关注，以至于他在2008年在他的网站上发布了以下博客：*REST
    API必须是* *超文本驱动的* ([https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven))。
- en: You must be wondering what the difference between hypertext and hypermedia is.
    Essentially, hypermedia is just an extended version of hypertext.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定想知道超文本和超媒体之间的区别。本质上，超媒体只是超文本的扩展版本。
- en: What is the difference between hypermedia and hypertext?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体和超文本之间的区别是什么？
- en: 'As Roy Fielding states: *“When I say hypertext, I mean the simultaneous presentation
    of information and controls such that the information becomes the affordance through
    which the user (or automaton) obtains choices and selects actions. Hypermedia
    is just an expansion on what text means to include temporal anchors within a media
    stream; most researchers have dropped the distinction. Hypertext does not need
    to be HTML on a browser. Machines can follow links when they understand the data
    format and* *relationship types.”*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Roy Fielding所说：“当我提到超文本时，我指的是信息与控制的同步呈现，使得信息成为用户（或自动机）获得选择和选择行动的便利性。超媒体只是对文本含义的扩展，包括在媒体流中的时间锚点；大多数研究人员已经放弃了这种区别。超文本不需要在浏览器上使用HTML。当机器理解数据格式和关系类型时，它们可以跟随链接。”
- en: Now that you are familiar with REST, let’s explore REST best practices in the
    next section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经熟悉了REST，那么让我们在下一节中探讨REST的最佳实践。
- en: Best practices for designing REST APIs
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计REST API的最佳实践
- en: It is too early to talk about the best practices for implementing APIs. APIs
    are designed first and implemented later. Therefore, you’ll find design-related
    best practices mentioned in the next sections. You’ll also find best practices
    for going forward during REST API implementation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论实施API的最佳实践还为时尚早。API首先被设计，然后才被实施。因此，你将在下一节中找到与设计相关的最佳实践。你也会找到在REST API实施过程中的前进最佳实践。
- en: Using nouns and not verbs when naming a resource in the endpoint path
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在端点路径中命名资源时使用名词而不是动词
- en: We previously discussed HTTP methods. HTTP methods use verbs. Therefore, it
    would be redundant to use verbs yourself, and it would make your call look like
    an RPC endpoint, for example, `GET /getlicenses`. In REST, we should always use
    the resource name because, according to REST, you transfer the states and not
    the instructions. For example, let’s take another look at the GitHub license API,
    which retrieves licenses. It is `GET /licenses`. That is perfect. Let’s assume
    that if you use verbs for this endpoint, then it will be `GET /getlicenses`. It
    will still work, but semantically, it doesn’t follow REST because it conveys the
    processing instruction rather than state transfer. Therefore, only use resource
    names.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了HTTP方法。HTTP方法使用动词。因此，自己使用动词将是多余的，并且会使你的调用看起来像RPC端点，例如，`GET /getlicenses`。在REST中，我们应该始终使用资源名称，因为根据REST，你传递的是状态而不是指令。例如，让我们再次看看GitHub许可证API，它检索许可证。它是`GET
    /licenses`。这是完美的。假设如果你为这个端点使用动词，那么它将是`GET /getlicenses`。它仍然可以工作，但从语义上讲，它不遵循REST，因为它传达的是处理指令而不是状态传输。因此，只使用资源名称。
- en: 'However, GitHub’s public API only offers `read` operations on the `licenses`
    resource, out of all the CRUD operations. If we need to design the rest of the
    operations, their paths should look like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GitHub的公共API只提供了对`licenses`资源的`read`操作，在所有CRUD操作中。如果我们需要设计其余的操作，它们的路径应该看起来像以下这样：
- en: '`POST /licenses`: This is for creating a new license.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /licenses`：这是用于创建一个新的许可证。'
- en: '`PATCH /licenses/{license_key}`: This is for partial updates. Here, the path
    has a parameter (that is, an identifier) that makes the path dynamic. Here, the
    license key is a unique value in the license collection and is being used as an
    identifier. Each license will have a unique key. This call should make the update
    in the given license. Please remember that GitHub uses `PUT` for the replacement
    of the resource.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH /licenses/{license_key}`：这是用于部分更新。在这里，路径有一个参数（即标识符），这使得路径是动态的。在这里，许可证密钥是许可证集合中的一个唯一值，并被用作标识符。每个许可证都将有一个唯一的密钥。这个调用应该在给定的许可证中进行更新。请记住，GitHub使用`PUT`来替换资源。'
- en: '`DELETE /licenses/{license_key}`: This is for retrieving license information.
    You can try this with any licenses that you receive in the response to the `GET
    /licenses` call. One example is `GET /licenses/agpl-3.0`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /licenses/{license_key}`：这是用于检索许可证信息。你可以尝试使用`GET /licenses`调用响应中收到的任何许可证。一个例子是`GET
    /licenses/agpl-3.0`。'
- en: You can see how having a noun in the resource path with the HTTP methods sorts
    out any ambiguity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在资源路径中包含名词以及HTTP方法是如何消除任何歧义的。
- en: Using the plural form for naming the collection resource in the endpoint path
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在端点路径中使用复数形式来命名集合资源
- en: If you observe the GitHub license API, you might find that a resource name is
    given in the plural form. It is a good practice to use the plural form if the
    resource represents a collection. Therefore, we can use `/licenses` instead of
    `/license`. A `GET` call returns the collection of licenses. GitHub doesn’t allow
    create, update, or delete public operations on a licensed resource. Hypothetically,
    if it allowed this, then a `POST` call would create a new license in the existing
    license collection. Similarly, for `DELETE` and `PATCH` calls, a license key is
    used to identify the specific license for performing delete and minor update operations
    respectively.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察GitHub许可证API，您可能会发现资源名称以复数形式给出。如果资源表示一个集合，使用复数形式是一个好习惯。因此，我们可以使用`/licenses`而不是`/license`。一个`GET`调用返回许可证集合。GitHub不允许在受许可的资源上执行创建、更新或删除公共操作。假设它允许这样做，那么一个`POST`调用将在现有的许可证集合中创建一个新的许可证。同样，对于`DELETE`和`PATCH`调用，使用许可证密钥来识别执行删除和轻微更新操作的具体许可证。
- en: Using hypermedia (HATEOAS)
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用超媒体（HATEOAS）
- en: Hypermedia (that is, links to other resources) makes the REST client’s job easier.
    There are two advantages if you provide explicit URL links in a response. First,
    the REST client is not required to construct the REST URLs on their own. Second,
    any upgrade in the endpoint path will be taken care of automatically and this,
    therefore, makes upgrades easier for clients and developers
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体（即，指向其他资源的链接）使REST客户端的工作变得更简单。如果您在响应中提供显式的URL链接，有两个优点。首先，REST客户端不需要自己构建REST
    URL。其次，端点路径的任何升级都将自动处理，这使得客户端和开发者的升级更容易。
- en: Versioning your APIs
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的API进行版本控制
- en: The versioning of APIs is key for future upgrades. Over time, APIs keep changing,
    and you may have customers who are still using an older version. Therefore, you
    need to support multiple versions of APIs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: API的版本控制对于未来的升级至关重要。随着时间的推移，API会不断变化，您可能会有仍在使用旧版本的客户。因此，您需要支持API的多个版本。
- en: 'There are different ways you can version your APIs:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用不同的方式对API进行版本控制：
- en: '*Using headers*: The GitHub API uses this approach. You can add an `Accept`
    header that tells you which API version should serve the request; for example,
    consider the following:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用头部*：GitHub API使用这种方法。您可以添加一个`Accept`头部，告诉您应该使用哪个API版本来处理请求；例如，考虑以下内容：'
- en: '[PRE6]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This approach gives you the advantage of setting the default version. If there
    is no `Accept` header, it should lead to the default version. However, if a REST
    client that uses a versioning header is not changed after a recent upgrade of
    APIs, it may break the functionality. Therefore, it is recommended that you use
    a versioning header.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法让您有设置默认版本的优点。如果没有`Accept`头部，它应该指向默认版本。然而，如果使用版本控制头部的REST客户端在API最近升级后没有更改，它可能会破坏功能。因此，建议您使用版本控制头部。
- en: '*Using an endpoint path*: In this approach, you add a version in the endpoint
    path itself; for example, `https://demo.app/api/v1/persons`. Here, `v1` denotes
    that version `1` is being added to the path itself.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用端点路径*：在这种方法中，您在端点路径本身中添加一个版本；例如，`https://demo.app/api/v1/persons`。在这里，`v1`表示正在将版本`1`添加到路径本身。'
- en: You cannot set default versioning out of the box. However, you can overcome
    this limitation by using other methods, such as request forwarding. Clients always
    use the intended versions of the APIs in this approach.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法直接设置默认版本控制。但是，您可以通过使用其他方法，例如请求转发，来克服这一限制。在这种方法中，客户端始终使用API的预期版本。
- en: Based on your preferences and views, you can choose either of the preceding
    approaches for versioning. However, the important point is that you should always
    use versioning.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的偏好和观点，您可以选择上述任何一种方法进行版本控制。然而，重要的是您应该始终使用版本控制。
- en: Nesting resources
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源嵌套
- en: 'Consider this very interesting question: how are you going to construct the
    endpoint for resources that are nested or have a certain relationship? Let’s take
    a look at some examples of customer resources from an e-commerce perspective:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个非常有趣的问题：您将如何构建嵌套或具有特定关系的资源的端点？让我们从电子商务的角度来看一些客户资源的示例：
- en: '`GET /customers/1/addresses`: This returns the collection of addresses for
    customer `1`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /customers/1/addresses`：这返回客户`1`的地址集合'
- en: '`GET /customers/1/addresses/2`: This returns the second address of customer
    `1`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /customers/1/addresses/2`：这返回客户`1`的第二个地址'
- en: '`POST /customers/1/addresses`: This adds a new address to customer `1`’s addresses'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /customers/1/addresses`：这为客户`1`的地址添加一个新的地址'
- en: '`PUT /customers/1/addresses/2`: This replaces the second address of customer
    `1`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /customers/1/addresses/2`: 这将替换客户 `1` 的第二个地址'
- en: '`PATCH /customers/1/addresses/2`: This partially updates the second address
    of customer `1`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH /customers/1/addresses/2`: 这将部分更新客户 `1` 的第二个地址'
- en: '`DELETE /customers/1/addresses/2`: This deletes the second address of customer
    `1`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /customers/1/addresses/2`: 这将删除客户 `1` 的第二个地址'
- en: So far so good. Now, can we have an altogether separate address resource endpoint
    (`GET /addresses/2`)? It makes sense, and you can do that if there is a relationship
    that requires it; for example, orders and payments. Instead of `/orders/1/payments/1`,
    you might prefer a separate `/payments/1` endpoint. In the microservice world,
    this makes more sense; for instance, you would have two separate RESTful web services
    for both orders and payments.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。现在，我们可以有一个完全独立的地址资源端点（`GET /addresses/2`）吗？这很有意义，如果您有需要这种关系的场景，您就可以这样做；例如，订单和支付。您可能会更喜欢一个单独的
    `/payments/1` 端点，而不是 `/orders/1/payments/1`。在微服务世界中，这更有意义；例如，您将有两个独立的 RESTful
    网络服务，分别用于订单和支付。
- en: Now, if you combine this approach with hypermedia, it makes things easier. When
    you make a REST API request to customer `1`, it will provide the customer 1 data
    and address links as hypermedia (that is, links). The same applies to orders.
    For orders, the payment link will be available as hypermedia.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您将这种方法与超媒体结合使用，会使事情变得更容易。当您向客户 `1` 发送 REST API 请求时，它将提供客户 1 的数据和地址链接作为超媒体（即链接）。对订单也是如此。对于订单，支付链接将以超媒体的形式提供。
- en: However, in some cases, you might wish to have a complete response in a single
    request rather than using the hypermedia-provided URLs to fetch the related resource.
    This reduces your web hits. However, there is no rule of thumb. For a flag operation,
    it makes sense to use the nested endpoint approach; for example, `PUT /gist/2/star`
    (which adds a star) and `DELETE /gist/2/star` (which undoes the star) in the case
    of the GitHub API.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，您可能希望在一个请求中有一个完整的响应，而不是使用超媒体提供的 URL 来获取相关资源。这减少了您的网络请求。但是，没有固定的规则。对于标志操作，使用嵌套端点方法是有意义的；例如，GitHub
    API 中的 `PUT /gist/2/star`（添加星标）和 `DELETE /gist/2/star`（撤销星标）。
- en: Additionally, in some scenarios, you might not find a suitable resource name
    when multiple resources are involved, for example, in a search operation. In that
    case, you should use a `direct/search` endpoint. This is an exception.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些场景中，当涉及多个资源时，您可能找不到合适的资源名称，例如在搜索操作中。在这种情况下，您应使用 `direct/search` 端点。这是一个例外。
- en: Securing APIs
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护 API
- en: 'Securing your API is another expectation that requires diligent attention.
    Here are some recommendations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 保护您的 API 是另一个需要仔细注意的期望。以下是一些建议：
- en: Always use HTTPS for encrypted communication.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用 HTTPS 进行加密通信。
- en: Always look for OWASP’s top API security threats and vulnerabilities. These
    can be found on their website (`https://owasp.org/www-project-api-security/`)
    or their GitHub repository (`https://github.com/OWASP/API-Security`).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是寻找 OWASP 的顶级 API 安全威胁和漏洞。这些可以在他们的网站上找到（`https://owasp.org/www-project-api-security/`）或他们的
    GitHub 仓库（`https://github.com/OWASP/API-Security`）。
- en: Secure REST APIs should have authentication in place. REST APIs are stateless;
    therefore, REST APIs should not use cookies or sessions. Instead, they should
    be secured using JWT or OAuth 2.0-based tokens.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全的 REST API 应该有身份验证。REST API 是无状态的；因此，REST API 不应使用 cookies 或会话。相反，它们应使用 JWT
    或 OAuth 2.0 基于的令牌进行保护。
- en: Maintaining documentation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护文档
- en: Documentation should be easily accessible and up to date with the latest implementation
    with their respective versioning. It is always good to provide sample code and
    examples. It makes the developer’s integration job easier.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 文档应易于访问，并与其相应的版本保持最新。提供示例代码和示例总是很好的，这可以使开发者的集成工作更容易。
- en: A change log or a release log should list all the affected libraries, and if
    some APIs are deprecated, then replacement APIs or workarounds should be elaborated
    upon inside the documentation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 变更日志或发布日志应列出所有受影响的库，如果某些 API 已弃用，则应在文档中详细说明替代 API 或解决方案。
- en: Complying with recommended status codes
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵守推荐的 HTTP 状态码
- en: We have already learned about status codes in the *Exploring HTTP methods and
    status codes* section. Please follow the same guidelines discussed there.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 *探索 HTTP 方法与状态码* 部分学习了状态码。请遵循那里讨论的相同指南。
- en: Ensuring caching
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保缓存
- en: 'HTTP already provides a caching mechanism. You just have to provide additional
    headers in the REST API response. Then, the REST client makes use of the validation
    to make sure whether to make a call or use the cached response. There are two
    ways to do this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP已经提供了一个缓存机制。你只需要在REST API响应中提供额外的头。然后，REST客户端利用验证来确保是否进行调用或使用缓存响应。有两种方法可以做到这一点：
- en: '`If-None-Match`, which contains the `ETag` value. When the server receives
    this request and finds that the hash or checksum value of the resource representation
    value is different from `If-None-Match`, only then should it return the response
    with a new representation and this hash value in the `ETag` header. If it finds
    them to be equal, then the server should simply respond with a `304 (Not Modified)`
    status code.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`If-None-Match`，其中包含`ETag`值。当服务器接收到这个请求并发现资源表示值的哈希或校验和与`If-None-Match`不同时，只有在这种情况下，它才应该返回带有新表示和此哈希值在`ETag`头中的响应。如果它发现它们相等，那么服务器应该简单地以`304
    (Not Modified)`状态码响应。'
- en: '`ETag` way. However, instead of using the hash or checksum, it uses the timestamp
    value in RFC-1123 ([http://www.ietf.org/rfc/rfc1123.txt](http://www.ietf.org/rfc/rfc1123.txt))
    in the format: `Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT`. It is less accurate
    than `ETag` and should only be used as a fallback.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ETag`方式。然而，它不使用哈希或校验和，而是使用RFC-1123中的时间戳值（[http://www.ietf.org/rfc/rfc1123.txt](http://www.ietf.org/rfc/rfc1123.txt)），格式为：`Last-Modified:
    Wed, 21 Oct 2015 07:28:00 GMT`。它比`ETag`不准确，应该仅作为后备使用。'
- en: In the `Last-Modified` approach, the client sends the `If-Modified-Since` header
    with the value received in the `Last-Modified` response header. The server compares
    the resource-modified timestamp value with the `If-Modified-Since` header value
    and sends a `304` status if there is a match; otherwise, it sends the response
    with a new `Last-Modified` header.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Last-Modified`方法中，客户端发送包含在`Last-Modified`响应头中的值的`If-Modified-Since`头。服务器将资源修改时间戳值与`If-Modified-Since`头值进行比较，如果匹配，则发送`304`状态码；否则，它发送带有新`Last-Modified`头的响应。
- en: Maintaining the rate limit
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维持速率限制
- en: 'Maintaining the rate limit is important if you want to prevent the overuse
    of APIs. The HTTP status code `429 Too Many Requests` is used when the rate limit
    is infringed. Currently, there is no standard to communicate any warning to the
    client before the rate limit goes over. However, there is a popular way to communicate
    about it using response headers. These response headers are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 维持速率限制对于防止API过度使用非常重要。当速率限制被违反时，使用HTTP状态码`429 Too Many Requests`。目前，没有标准在速率限制超过之前向客户端发出任何警告。然而，有一种流行的使用响应头来沟通的方式。以下是一些响应头：
- en: '`X-Ratelimit-Limit`: The number of allowed requests in the current period,
    for example, `X-Ratelimit-Limit: 60`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Ratelimit-Limit`：当前周期内允许的请求数量，例如，`X-Ratelimit-Limit: 60`。'
- en: '`X-Ratelimit-Remaining`: The number of remaining requests in the current period,
    for example, `X-Ratelimit-Remaining: 55`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Ratelimit-Remaining`：当前周期内剩余的请求数量，例如，`X-Ratelimit-Remaining: 55`。'
- en: '`X-Ratelimit-Reset`: The number of seconds left in the current period, for
    example, `X-Ratelimit-Reset: 1601299930`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Ratelimit-Reset`：当前周期内剩余的秒数，例如，`X-Ratelimit-Reset: 1601299930`。'
- en: '`X-Ratelimit-Used`: The number of requests used in the current period, for
    example, `X-Ratelimit-Used: 5`. This information then might be used by the client
    to keep track of the total number of available API calls for the given period.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Ratelimit-Used`：当前周期内使用的请求数量，例如，`X-Ratelimit-Used: 5`。然后，客户端可能会使用此信息来跟踪给定周期内可用的总API调用数。'
- en: So far, we have discussed various concepts related to REST. Next, let me introduce
    you to the app we will be building in this book using these concepts.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了与REST相关的各种概念。接下来，让我向您介绍本书中将使用这些概念构建的应用程序。
- en: Introducing our e-commerce app
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍我们的电子商务应用
- en: 'The e-commerce app we will be building will be a simple online shopping application
    with the following features for users:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的电子商务应用将是一个简单的在线购物应用程序，具有以下用户功能：
- en: Browsing through the products
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览产品
- en: Adding/removing/updating the products in the cart
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加/删除/更新购物车中的产品
- en: Placing an order
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下订单
- en: Modifying the shipping address
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改送货地址
- en: Support for a single currency
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持单一货币
- en: 'E-commerce is a very popular domain. If we look at the features, we can divide
    the application into the following subdomains using bounded contexts:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 电子商务是一个非常受欢迎的领域。如果我们看看功能，我们可以使用边界上下文将应用程序划分为以下子域：
- en: '`users` RESTful web service, which provides REST APIs for user management.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users` RESTful网络服务，它为用户管理提供REST API。'
- en: '`carts` RESTful web service, which provides REST APIs for cart management.
    Users can perform CRUD operations on cart items.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`carts` RESTful网络服务，它为购物车管理提供REST API。用户可以对购物车项目执行CRUD操作。'
- en: '`products` RESTful web service, which provides REST APIs to search and retrieve
    the products.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`products` RESTful网络服务，它提供用于搜索和检索产品的REST API。'
- en: '`orders` RESTful web service, which provides REST APIs for users to place orders.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orders` RESTful网络服务，它为用户下订单提供REST API。'
- en: '`payments` RESTful web service, which provides REST APIs for payment processing.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payments` RESTful网络服务，它提供用于支付处理的REST API。'
- en: '`shippings` RESTful web service, which provides REST APIs for order tracking
    and shipping.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shippings` RESTful网络服务，它为订单跟踪和运输提供REST API。'
- en: 'Here’s a visual representation of our app’s architecture:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们应用程序架构的视觉表示：
- en: '![Figure 1.1 – The e-commerce app architecture](img/Figure_01.1_B19349.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 电子商务应用程序架构](img/Figure_01.1_B19349.jpg)'
- en: Figure 1.1 – The e-commerce app architecture
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 电子商务应用程序架构
- en: We’ll implement a RESTful web service for each of the subdomains. We’ll keep
    the implementation simple, and we will focus on learning these concepts throughout
    this book.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个子域实现一个RESTful网络服务。我们将保持实现简单，并在整本书中专注于学习这些概念。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the basic concepts of the REST architecture
    style and its key concepts – resources, URI, HTTP methods, and HATEOAS. Now, you
    know how REST, which is based on HTTP, simplifies and makes the integration of
    different applications and services easier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了REST架构风格的基本概念及其关键概念——资源、URI、HTTP方法和HATEOAS。现在，您知道了基于HTTP的REST如何简化并使不同应用程序和服务的集成更容易。
- en: We also explored the different HTTP concepts that allow you to write REST APIs
    in a meaningful way. We also learned why HATEOAS is an integral part of REST implementation.
    Additionally, we learned the best practices for designing REST APIs. We also went
    through an overview of our e-commerce app. This sample app will be used throughout
    the book.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了不同的HTTP概念，这些概念允许您以有意义的方式编写REST API。我们还学习了为什么HATEOAS是REST实现的一个基本组成部分。此外，我们还学习了设计REST
    API的最佳实践。我们还概述了我们的电子商务应用程序。这个示例应用程序将在整本书中使用。
- en: The REST concepts you learned in this chapter will provide the foundation for
    REST implementation. Now, you can make use of the best practices you learned in
    this chapter to design and implement state-of-the-art REST APIs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中学习的REST概念将为REST实现提供基础。现在，您可以使用本章学到的最佳实践来设计和实现最先进的REST API。
- en: In the next chapter, you’ll learn about the fundamentals of the Spring Framework.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习Spring框架的基本知识。
- en: Questions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why have RESTful web services become so popular and, arguably, the industry
    standard?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么RESTful网络服务变得如此流行，并且可以说是行业标准？
- en: What is the difference between RPC and REST?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RPC和REST之间的区别是什么？
- en: How would you explain HATEOAS?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何解释HATEOAS？
- en: What error codes should be used for server-related issues?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪些错误代码来处理与服务器相关的问题？
- en: Should verbs be used to form REST endpoints, and why?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用动词来形成REST端点，为什么？
- en: Answers
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: RESTful services became popular because they work on top of HTTP, which is the
    backbone of the internet. You don’t need separate protocol implementations such
    as SOAP. You can use existing web technologies to implement the REST APIs with
    simple application integration compared to other technologies available. REST
    APIs make application integration simpler than other technologies available at
    the time.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RESTful服务之所以流行，是因为它们建立在HTTP之上，而HTTP是互联网的骨干。您不需要单独的协议实现，如SOAP。您可以使用现有的网络技术，与其他技术相比，通过简单的应用程序集成来实现REST
    API。REST API使应用程序集成比当时可用的其他技术更简单。
- en: RESTful services work on REST, which works on web resources. Resources represent
    domain models. Actions are defined using HTTP methods, which are performed on
    web resources. REST also allows clients to perform actions based on links available
    through HATEOAS implementation, like a human who can navigate in the browser.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务基于REST架构，而REST架构又基于网络资源。资源代表领域模型。操作通过HTTP方法定义，并在网络资源上执行。REST还允许客户端根据通过HATEOAS实现提供的链接执行操作，就像人类可以在浏览器中导航一样。
- en: 'RPC is more like functions that perform actions. RPC endpoints are directly
    formed based on verbs that lead to separate URLs for each action. Whereas REST
    URLs represent nouns and could be the same for different operations, for example:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RPC更像是执行动作的函数。RPC端点是直接基于动词形成的，每个动作都有自己的URL。而REST URL代表名词，可能对不同操作相同，例如：
- en: '[PRE7]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With HATEOAS, RESTful web services provide information dynamically through hypermedia.
    Hypermedia is the part of the content you receive from a REST call response. This
    hypermedia content contains links to different types of media such as text, images,
    and videos. Machines, aka REST clients/browsers, can follow links when they understand
    the data format and relationship types.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用HATEOAS，RESTful网络服务通过超媒体动态提供信息。超媒体是你从REST调用响应中接收到的内容的一部分。这种超媒体内容包含指向不同类型媒体（如文本、图像和视频）的链接。机器，即REST客户端/浏览器，在理解数据格式和关系类型时可以跟随链接。
- en: Status code `500` should be used for generic server errors. The `502` status
    code should be used when an upstream server fails. Status code `503` is for unexpected
    server events such as an overload.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应使用状态码`500`表示通用服务器错误。当上游服务器失败时，应使用状态码`502`。状态码`503`用于意外的服务器事件，例如过载。
- en: Verbs should not be used to form REST endpoints. Instead, you should use the
    noun that represents the domain model as a resource. HTTP methods are used to
    define the actions performed on resources, such as `POST` for creating and `GET`
    for retrieving.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动词不应用于形成REST端点。相反，你应该使用代表领域模型的名词作为资源。HTTP方法用于定义对资源执行的操作，例如`POST`用于创建和`GET`用于检索。
- en: Further reading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Architectural Styles and the Design of Network-based Software* *Architectures*:
    [https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络软件架构的设计与架构风格*：[https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)'
- en: 'The URI Generic Syntax (*RFC-3986*): [https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI通用语法（*RFC-3986*）：[https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986)
- en: 'The URN Syntax (*RFC-2141*): [https://tools.ietf.org/html/rfc2141](https://tools.ietf.org/html/rfc2141)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URN语法（*RFC-2141*）：[https://tools.ietf.org/html/rfc2141](https://tools.ietf.org/html/rfc2141)
- en: 'HTTP Response Status Codes – *RFC* *7231*: [https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP响应状态码 – *RFC* *7231*：[https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)
- en: 'HTTP Response Status Codes – Mozilla Developer Network: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP响应状态码 – Mozilla开发者网络：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- en: '*REST APIs* *must* *be* *hypertext-driven*: [https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*REST API*必须*由超文本驱动*：[https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
- en: 'The RFC for the URI template: [https://tools.ietf.org/html/rfc6570](https://tools.ietf.org/html/rfc6570)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI模板的RFC：[https://tools.ietf.org/html/rfc6570](https://tools.ietf.org/html/rfc6570)
- en: 'The OWASP API security project: [https://owasp.org/www-project-api-security/](https://owasp.org/www-project-api-security/)
    and [https://github.com/OWASP/API-Security](https://github.com/OWASP/API-Security)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP API安全项目：[https://owasp.org/www-project-api-security/](https://owasp.org/www-project-api-security/)
    和 [https://github.com/OWASP/API-Security](https://github.com/OWASP/API-Security)
