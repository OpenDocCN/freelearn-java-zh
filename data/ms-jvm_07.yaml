- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Memory Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: This chapter explores the intricate realm of memory management within the JVM.
    Understanding the inner workings of memory allocation and utilization is paramount
    for Java developers seeking to optimize their applications for performance and
    scalability. As the heartbeat of any Java program, the JVM’s memory management
    system juggles various components, including the heap, stack, and garbage collection
    mechanisms, each playing a crucial role in the efficient execution of Java applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 JVM 内部内存管理的复杂领域。理解内存分配和利用的内部机制对于寻求优化应用程序性能和可扩展性的 Java 开发者至关重要。作为任何 Java
    程序的心脏，JVM 的内存管理系统处理各种组件，包括堆、栈和垃圾回收机制，每个组件都在 Java 应用程序的高效执行中扮演着关键角色。
- en: Throughout this chapter, we’ll delve into the intricacies of these components,
    unraveling the mysteries of how the JVM dynamically allocates and manages memory
    resources. We’ll explore the foundational concepts behind the heap, where objects
    reside and are managed by the garbage collector, and the stack, which handles
    method calls and local variables. This journey through memory management demystifies
    the complexities of garbage collection algorithms, shedding light on best practices
    for efficient object memory allocation. By the end of this chapter, you will have
    not only grasped the fundamental principles governing memory management in the
    JVM but also acquired practical insights to fine-tune your Java applications for
    optimal memory utilization. Whether you’re a seasoned Java developer or a newcomer
    to the language, this exploration promises to be a gateway to mastering the art
    of memory management in the Java ecosystem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨这些组件的复杂性，揭示 JVM 如何动态分配和管理内存资源的奥秘。我们将探讨堆的基础概念，其中对象驻留并由垃圾回收器管理，以及栈，它处理方法调用和局部变量。通过这次内存管理之旅，我们将揭开垃圾回收算法的复杂性，并阐明高效对象内存分配的最佳实践。到本章结束时，你不仅将掌握
    JVM 内存管理的根本原则，还将获得实际见解，以优化你的 Java 应用程序以实现最佳内存利用。无论你是经验丰富的 Java 开发者还是 Java 语言的新手，这次探索都将是掌握
    Java 生态系统内存管理艺术的门户。
- en: 'In this chapter, we’ll explore the topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Memory management in the JVM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 中的内存管理
- en: Program counter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序计数器
- en: Java stack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 栈
- en: Native method stacks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生方法栈
- en: Method area
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法区
- en: Heap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: Code Cache and JIT
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码缓存和 JIT
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下要求：
- en: Java 21
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 21
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-05](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-05)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 GitHub 仓库位于 - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-05](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-05)
- en: Memory management in the JVM
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM 中的内存管理
- en: In this enlightening exploration of memory management within the JVM, we’ll
    delve into the intricacies of memory allocation and utilization, recognizing the
    pivotal role memory plays in the life cycle of a Java application. Once your Java
    code has been compiled into bytecode, the journey into memory management begins.
    As the bytecode executes, it invokes the JVM, the cornerstone of Java’s platform
    independence, which steps forward to claim the necessary memory from the underlying
    system. We’ll explore the mechanisms by which the JVM interacts with the system,
    acquiring the memory needed for efficient program execution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次对 JVM 内部内存管理的启发式探索中，我们将深入研究内存分配和利用的复杂性，认识到内存在一个 Java 应用程序生命周期中的关键作用。一旦你的
    Java 代码被编译成字节码，内存管理的旅程就开始了。随着字节码的执行，它调用 JVM，Java 平台独立性的基石，它向前迈出，从底层系统获取必要的内存以实现程序的高效执行。
- en: Within the rich memory landscape of the JVM, crucial components such as the
    heap and the stack come into play. The heap, a dynamic area where objects are
    stored, undergoes garbage collection to reclaim memory occupied by objects no
    longer in use. The stack manages method calls and local variables, providing a
    structured and efficient way to handle memory during program execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 丰富的内存景观中，堆和栈等关键组件发挥作用。堆是一个动态区域，用于存储对象，并通过垃圾回收来回收不再使用的对象的内存。栈管理方法调用和局部变量，为程序执行期间处理内存提供了一种结构化和高效的方式。
- en: A distinctive feature of the JVM is its ability to dynamically adapt to changing
    memory needs. The garbage collector, which is integral to the JVM, identifies
    and reclaims memory occupied by unreferenced objects. This dynamic memory management
    ensures optimal resource utilization, enhancing the overall performance of your
    Java programs. One of the most significant differences between Java and languages
    such as C/C++ is that in Java, memory assignment and cleanup are managed automatically
    by the JVM. It alleviates developers from the burden of explicit memory management
    tasks. However, while you don’t need to concern yourself with memory management,
    understanding the underlying memory structures and their management by the JVM,
    as explained in this chapter, is crucial for effective Java development.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 的一个独特特性是其能够动态适应不断变化的内存需求。垃圾收集器，作为 JVM 的核心组成部分，识别并回收未引用对象占用的内存。这种动态内存管理确保了资源的最优利用，提高了
    Java 程序的整体性能。Java 与 C/C++ 等语言之间最显著的区别之一是，在 Java 中，内存分配和清理由 JVM 自动管理。这减轻了开发者进行显式内存管理任务的负担。然而，尽管您不需要担心内存管理，但理解本章中解释的底层内存结构和
    JVM 的管理，对于有效的 Java 开发至关重要。
- en: Understanding how the JVM interfaces with the system is vital to obtaining the
    required memory. We’ll delve into the communication protocols and mechanisms that
    enable the JVM to allocate and release memory seamlessly, ensuring a harmonious
    integration with the underlying operating system. Armed with this knowledge, you’ll
    be better equipped to optimize your code for memory efficiency, contributing to
    your Java applications’ enhanced performance and scalability. So, let’s embark
    on this journey into the heart of the JVM’s memory management, where every byte
    matters!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 JVM 如何与系统交互对于获取所需的内存至关重要。我们将深入探讨使 JVM 能够无缝分配和释放内存的通信协议和机制，确保与底层操作系统的和谐集成。掌握这些知识，您将更好地为优化代码以实现内存效率做好准备，从而提高
    Java 应用程序的性能和可扩展性。因此，让我们开始这段探索 JVM 内存管理的旅程，在这里，每一个字节都至关重要！
- en: 'In this exploration, our focus is on unraveling the intricate memory architecture
    of the JVM, with a specific emphasis on its key components: the method area, the
    heap, Java stacks, the **program counter** (**PC**) register, and native method
    stacks. Collectively, these elements orchestrate the dynamic execution of Java
    programs, each playing a unique role in managing class-level information, object
    allocation, method execution, program flow control, and the integration of native
    code. As we delve into the nuances of these memory areas, we aim to provide a
    comprehensive understanding of how the JVM handles memory, enabling developers
    to optimize their code for enhanced performance and scalability. So, let’s embark
    on this journey through the JVM’s memory landscape, where each memory area has
    its role in shaping the runtime behavior of Java applications.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次探索中，我们的重点是揭示 JVM 复杂的内存架构，特别关注其关键组件：方法区、堆、Java 栈、**程序计数器**（**PC**）寄存器和本地方法栈。这些元素共同协调
    Java 程序的动态执行，每个元素在管理类级信息、对象分配、方法执行、程序流程控制和本地代码集成中扮演着独特的角色。随着我们深入探讨这些内存区域的细微差别，我们的目标是提供一个全面的了解，了解
    JVM 如何处理内存，使开发者能够优化代码以实现更好的性能和可扩展性。因此，让我们开始这段穿越 JVM 内存景观的旅程，其中每个内存区域都在塑造 Java
    应用程序的运行时行为中扮演着其独特的角色。
- en: The method area is a critical segment of the JVM’s memory architecture. It is
    a repository for class-level data that houses method code, static variables, and
    the constant pool. Each loaded class has its dedicated space in the method area,
    making it a shared resource among all threads in the JVM. This area is indispensable
    for the efficient management of class-related information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 方法区是 JVM 内存架构的关键部分。它是类级数据的存储库，包含方法代码、静态变量和常量池。每个加载的类在方法区中都有其专用的空间，使其成为 JVM 中所有线程的共享资源。这个区域对于高效管理类相关信息至关重要。
- en: On the other hand, the heap is a dynamic and shared memory space where the JVM
    allocates memory for objects during runtime. All objects, irrespective of their
    scope, reside in the heap. It plays a pivotal role in garbage collection, ensuring
    that unreferenced objects are identified and their memory is reclaimed to prevent
    resource exhaustion.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，堆是一个动态且共享的内存空间，JVM 在运行时为对象分配内存。所有对象，无论其作用域如何，都驻留在堆中。它在垃圾收集中发挥着关键作用，确保未引用的对象被识别，其内存被回收，以防止资源耗尽。
- en: Java stacks are employed for the execution of Java methods. Each thread in a
    Java application possesses its stack, containing the method call stack and local
    variables. The stack is fundamental for managing method calls, providing a clean
    and isolated environment for executing each thread.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java栈用于Java方法的执行。Java应用程序中的每个线程都拥有自己的栈，包含方法调用栈和局部变量。栈对于管理方法调用，为每个线程提供干净和隔离的执行环境至关重要。
- en: The PC register is a small yet significant area within a thread’s memory. It
    stores the address of the currently executing instruction, maintaining the program’s
    flow by indicating the next instruction to be executed. The PC register is crucial
    for upholding the sequential order of program execution within a thread.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PC寄存器是线程内存中的一个虽小但重要的区域。它存储当前正在执行的指令的地址，通过指示下一个要执行的指令来维持程序的流程。PC寄存器对于维护线程内程序执行的顺序至关重要。
- en: Additionally, native method stacks are dedicated memory areas for native methods
    written in languages such as C or C++. These stacks operate separately from the
    Java stacks and handle the execution of native code, facilitating seamless integration
    between Java and native languages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本地方法栈是为用C或C++等语言编写的本地方法专设的内存区域。这些栈独立于Java栈运行，并处理本地代码的执行，促进Java与本地语言的无缝集成。
- en: 'Within the intricate architecture of the JVM, the allocation and management
    of memory are orchestrated by several distinct areas. This visual representation
    captures the dynamic interplay of key memory components, showcasing the **method
    area**, **heap**, **Java stacks**, **PC registers**, and **native** **method stacks**:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM复杂的架构中，内存的分配和管理由几个不同的区域协同完成。这个视觉表示捕捉了关键内存组件的动态互动，展示了**方法区域**、**堆**、**Java栈**、**PC寄存器**和**本地**
    **方法栈**：
- en: '![Figure 5.1: The JVM running and its memory](img/B22030_05_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：运行中的JVM及其内存](img/B22030_05_01.jpg)'
- en: 'Figure 5.1: The JVM running and its memory'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：运行中的JVM及其内存
- en: In the forthcoming sections, we will delve into the intricacies of these memory
    areas within the JVM. Our exploration will encompass understanding how the method
    area manages class-level information, the dynamic nature of the heap and its role
    in object allocation, the significance of Java stacks in method execution, the
    function of the PC register in controlling program flow, and how native methods
    are handled through native method stacks. By the chapter’s conclusion, you will
    comprehensively understand the JVM’s memory architecture and how these components
    collaboratively facilitate the execution of Java programs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨JVM内这些内存区域的复杂性。我们的探索将包括理解方法区域如何管理类级信息，堆的动态特性及其在对象分配中的作用，Java栈在方法执行中的重要性，PC寄存器在控制程序流程中的功能，以及本地方法如何通过本地方法栈处理。到本章结束时，您将全面理解JVM的内存架构以及这些组件如何协同促进Java程序的执行。
- en: As we conclude our exploration into the diverse memory areas within the JVM,
    we’ve gained valuable insights into the dynamic interplay of components such as
    the method area, heap, Java stacks, PC register, and native method stacks. Understanding
    these elements is pivotal for developers seeking to optimize memory usage and
    enhance the performance of their Java applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束对JVM内各种内存区域的探索，我们获得了关于方法区域、堆、Java栈、PC寄存器和本地方法栈等组件动态互动的有价值见解。理解这些元素对于寻求优化内存使用并提高其Java应用程序性能的开发者至关重要。
- en: In the next section, we will focus on a crucial aspect of the JVM’s inner workings
    – the PC. It plays a central role in guiding the flow of program execution, storing
    the address of the currently executing instruction. Join us in the upcoming section
    as we unravel the significance of the PC register, delving into its function and
    impact on the seamless execution of Java programs. This journey through the intricate
    layers of the JVM promises to deepen our understanding of its core mechanisms,
    empowering us to write more efficient and robust Java code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将关注JVM内部工作的重要方面——PC。它在指导程序执行流程中扮演着核心角色，存储当前正在执行的指令的地址。请加入我们，在即将到来的章节中，我们将揭示PC寄存器的重要性，深入探讨其功能和在Java程序无缝执行中的影响。这次对JVM复杂层级的探索将加深我们对核心机制的理解，使我们能够编写更高效和健壮的Java代码。
- en: Program counter
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序计数器
- en: Our focus sharpens on the PC within the JVM, a crucial component intricately
    tied to the execution flow. Unique for each thread, the PC serves as a guidepost,
    carrying essential information about the ongoing instruction execution. Join us
    as we delve into the nuances of the PC, unraveling its role in managing program
    flow, and understanding its significance in both native and non-native method
    executions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的关注点聚焦于JVM内部的PC（程序计数器），这是一个与执行流程紧密相连的关键组件。对于每个线程来说，PC都是独一无二的，它充当一个指南针，携带有关当前指令执行的基本信息。请加入我们，深入了解PC的微妙之处，揭示其在管理程序流程中的作用，并理解其在本地和非本地方法执行中的重要性。
- en: The PC is a specialized register that’s created for every thread within the
    JVM. It carries crucial data, primarily as a pointer and a return address. This
    dynamic duo holds the key to understanding the ongoing execution state of the
    thread. The pointer directs the thread to the next instruction to be executed,
    while the return address ensures a seamless return to the previous execution point
    after method completion.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: PC是JVM中为每个线程创建的专用寄存器。它携带关键数据，主要是作为指针和返回地址。这对动态组合是理解线程当前执行状态的关键。指针指导线程执行下一个指令，而返回地址确保在方法完成后无缝返回到之前的执行点。
- en: Distinguishing native and non-native methods is crucial in understanding the
    PC’s behavior. The PC’s value is clearly defined in non-native methods, representing
    the instruction address. However, in the context of native methods, the PC transforms
    into a pointer, showcasing its adaptability in accommodating the diverse nature
    of method executions within the JVM.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解PC的行为时，区分本地和非本地方法至关重要。在非本地方法中，PC的值明确定义，代表指令地址。然而，在本地方法的情况下，PC转变为指针，展示了其在适应JVM内方法执行多样性的适应性。
- en: 'The following visual representation offers a glimpse into the intricate dance
    of thread execution within the JVM, with a particular focus on the PC. The figure
    vividly illustrates how the PC, which is unique to each thread, carries critical
    information such as a return address and a pointer to guide the thread through
    its execution path. In the realm of native methods, the PC takes on a mysterious
    quality, represented by an unknown value, symbolizing the dynamic nature of its
    role in navigating between Java code and native executions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下视觉表示提供了对JVM内线程执行复杂舞蹈的洞察，特别关注PC。该图生动地说明了PC如何携带关键信息，如返回地址和指针，引导线程通过其执行路径。在本地方法领域，PC呈现出一种神秘的性质，由未知值表示，象征着其在导航Java代码和本地执行之间的动态角色。
- en: '![Figure 5.2: A PC that might have returnAddress or an unknown value](img/B22030_05_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：可能包含returnAddress或未知值的PC](img/B22030_05_02.jpg)'
- en: 'Figure 5.2: A PC that might have returnAddress or an unknown value'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：可能包含returnAddress或未知值的PC
- en: The PC’s role in managing the thread’s execution is paramount. It acts as a
    sentinel, constantly updating to reflect the current instruction in progress.
    As threads navigate method calls, the PC ensures a smooth transition between instructions,
    orchestrating the program flow precisely.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PC在管理线程执行中的作用至关重要。它充当一个哨兵，不断更新以反映当前正在进行的指令。当线程在方法调用之间导航时，PC确保指令之间的平稳过渡，精确地编排程序流程。
- en: Beyond its role in execution control, the PC has implications for code optimization.
    While the JVM implementation controls the PC, developers can still influence code
    optimization by understanding how the PC operates. This understanding allows developers
    to optimize their code strategically, aligning with the JVM’s execution model
    to enhance performance and efficiency. While direct control over the PC might
    be limited, insights into its behavior empower developers to write code better
    suited for the JVM’s execution, ultimately leading to improved application performance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在执行控制中的作用外，PC对代码优化也有影响。虽然JVM实现控制PC，但开发者可以通过理解PC的工作方式来影响代码优化。这种理解使开发者能够有策略地优化代码，与JVM的执行模型相匹配，以提升性能和效率。尽管对PC的直接控制可能有限，但对PC行为的洞察使开发者能够编写更适合JVM执行的代码，从而最终提高应用程序的性能。
- en: As we conclude our exploration of the PC and its pivotal role in guiding thread
    execution within the JVM, we find ourselves on the brink of unraveling yet another
    layer of the JVM’s intricacies. Join us in the upcoming session as we delve into
    the dynamic world of the Java stack. This essential component is central in managing
    method calls, providing dedicated spaces for call stacks and local variables within
    each thread. Understanding the Java stack is paramount for developers seeking
    to optimize their code for efficient execution. So, let’s seamlessly transition
    from exploring the PC to a deep dive into the Java stack, where each method call
    leaves its mark, shaping the robust architecture of Java applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对 PC 及其在 JVM 内引导线程执行中的关键作用的探索之后，我们发现自己正站在揭开 JVM 精妙复杂性的另一层的边缘。请加入我们即将到来的会议，我们将深入探讨
    Java 栈的动态世界。这个基本组件在管理方法调用中起着核心作用，为每个线程提供调用栈和局部变量的专用空间。对于寻求优化其代码以实现高效执行的开发者来说，理解
    Java 栈至关重要。因此，让我们无缝地从探索 PC 转向深入挖掘 Java 栈，每个方法调用都会留下痕迹，塑造 Java 应用程序的强大架构。
- en: Java stack
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 栈
- en: In this section, we’ll delve into the intricacies of the Java stack – a fundamental
    component within the JVM. Like the PC, the Java stack is a private register exclusive
    to each thread, functioning as a repository for method execution information.
    This section delves into the Java stack’s operation, drawing parallels with classical
    languages such as C and shedding light on its role in storing local variables,
    partial results, method invocations, and results.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨 Java 栈的复杂性——这是 JVM 内的一个基本组件。与 PC 一样，Java 栈是每个线程专有的私有寄存器，作为方法执行信息的存储库。本节深入探讨了
    Java 栈的操作，将其与经典语言如 C 进行比较，并阐明了其在存储局部变量、部分结果、方法调用和结果中的作用。
- en: Like classical languages such as C, the Java stack operates by storing frames,
    each encapsulating crucial information related to method execution. These frames
    hold parameters, local variables, and other essential data. The Java stack’s functionality
    extends beyond direct variable modifications; instead, it gracefully inserts and
    removes frames to accommodate the evolving state of thread execution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 C 这样的经典语言，Java 栈通过存储帧来操作，每个帧封装了与方法执行相关的关键信息。这些帧包含参数、局部变量和其他必要数据。Java 栈的功能不仅限于直接修改变量；相反，它优雅地插入和删除帧以适应线程执行的演变状态。
- en: When a thread calls a method, the Java stack undergoes a dynamic transformation
    by inserting a new frame. This frame encapsulates details such as parameters and
    local variables, orchestrating a dedicated space for the method’s execution. As
    the method concludes, whether in a normal fashion or due to an exception, the
    frame is discarded. This life cycle ensures a well-organized and efficient execution
    environment within the Java stack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程调用一个方法时，Java 栈通过插入一个新的帧进行动态转换。这个帧封装了诸如参数和局部变量等详细信息，为方法的执行提供了一个专用空间。当方法正常结束或由于异常而结束时，该帧被丢弃。这种生命周期确保了
    Java 栈内一个组织良好且高效的执行环境。
- en: The Java stack’s flexibility is underscored by its ability to be fixed or dynamically
    determined in size. This feature allows for tailored resource allocation based
    on the specific needs of the executing Java application, contributing to optimized
    memory utilization.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Java 栈的灵活性体现在其大小可以是固定的或动态确定的。这一特性允许根据执行 Java 应用程序的具体需求进行定制资源分配，从而有助于优化内存利用。
- en: 'The fundamental building block of the Java stack is the frame. This unit comes
    into existence upon creating a method and ceases to exist when the method concludes,
    whether by normal completion or due to an exception. Each frame encapsulates key
    components, including a list of local variables, a stack of operations, and references
    to the current class and method. This tripartite structure divides the frame into
    three essential parts:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Java 栈的基本构建块是帧。这个单元在创建方法时出现，在方法正常完成或由于异常而结束时消失。每个帧封装了关键组件，包括局部变量列表、操作栈以及当前类和方法的引用。这种三分结构将帧分为三个基本部分：
- en: '**Local variables**: The stack variables section within the frame is a storage
    space for local variables. These variables are specific to the method currently
    in execution and are crucial for storing intermediate results and parameters relevant
    to the method’s functionality.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量**：帧内的栈变量部分是局部变量的存储空间。这些变量仅针对当前执行的方法，对于存储中间结果和与方法功能相关的参数至关重要。'
- en: '**Operand stack**: Operating in tandem with the stack variables, the stack
    operand section houses the stack of operations. This stack is instrumental in
    managing the flow of operations within the method, facilitating the execution
    of instructions, and ensuring a structured approach to method execution.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作数栈**：与栈变量协同工作，操作数部分包含操作栈。这个栈在管理方法内的操作流程、执行指令和确保方法执行的结构化方法中起着关键作用。'
- en: '**Frame data**: This section encapsulates critical information about the method’s
    execution context. It includes references to the current class and method, providing
    the necessary contextual information for the JVM to navigate the program’s structure
    effectively.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧数据**：这一部分封装了关于方法执行上下文的关键信息。它包括对当前类和方法的引用，为JVM有效地导航程序结构提供必要上下文信息。'
- en: This tripartite division of the frame into local variables, stack operand, and
    frame data is pivotal for maintaining the integrity and functionality of the Java
    stack. It ensures systematic information organization, allowing for efficient
    method execution and seamless handling of variables and operations within the
    JVM’s memory architecture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将帧分为局部变量、操作数栈和帧数据的三部分划分对于维护Java栈的完整性和功能性至关重要。它确保了系统化的信息组织，允许高效的方法执行和无缝处理JVM内存架构中的变量和操作。
- en: Each frame within the Java stack incorporates a crucial reference to the runtime
    constant pool corresponding to the type of the current method. This inclusion
    supports the dynamic linking of method code, a process essential for translating
    symbolic references in class file code. Symbolic references, denoting methods
    to be invoked and variables to be accessed, undergo dynamic linking to transform
    into concrete references during runtime. This dynamic linking process involves
    resolving undefined symbols and potentially loading classes as needed. The outcome
    is a translation of variable accesses into precise offsets within storage structures
    linked to the runtime location of these variables. This late binding mechanism
    enhances adaptability and reduces the likelihood of code breakage when modifications
    are made to other classes that a method may use.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Java栈中的每个帧都包含对当前方法类型的运行时常量池的引用。这一包含支持方法代码的动态链接，这是一个将类文件代码中的符号引用转换为运行时具体引用的过程。符号引用，表示要调用的方法和要访问的变量，在运行时通过动态链接转换为具体引用。这个动态链接过程涉及解析未定义的符号，并在需要时加载类。结果是变量访问被转换为与这些变量运行时位置相关联的存储结构中的精确偏移量。这种后期绑定机制增强了适应性，并减少了在修改方法可能使用的其他类时代码损坏的可能性。
- en: 'The following visual representation briefly overviews the Java stack’s core
    unit: the frame. This fundamental building block, created with the inception of
    a method and dismantled upon method termination, encapsulates three key components:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下视觉表示简要概述了Java栈的核心单元：帧。这个基本构建块在方法创建时生成，在方法终止时拆除，封装了三个关键组件：
- en: '**Stack variables**: Stores method-specific local variables'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈变量**：存储方法特定的局部变量'
- en: '**Stack operand**: Manages a stack of operations for method execution'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作数栈**：管理方法执行的操作栈'
- en: '**Frame data**: Contains crucial references to the current class and method'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧数据**：包含对当前类和方法的至关重要的引用'
- en: 'Together, these elements define the structure of the frame and play a pivotal
    role in orchestrating efficient and organized method execution within the JVM,
    as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素共同定义了帧的结构，并在JVM中组织高效和有序的方法执行中发挥着关键作用，如下所示：
- en: '![Figure 5.3: A Java stack representation](img/B22030_05_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：Java栈表示](img/B22030_05_03.jpg)'
- en: 'Figure 5.3: A Java stack representation'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：Java栈表示
- en: A frame within the JVM serves as a fundamental unit for storing data, handling
    partial results, dynamic linking, returning values for methods, and managing exceptions.
    Its life cycle is tightly bound to method invocations, with a new frame created
    each time a method is invoked and subsequently destroyed upon the completion of
    that invocation, whether it concludes normally or abruptly due to an uncaught
    exception. These frames are allocated from the thread’s JVM stack and possess
    distinct arrays of local variables, operand stacks, and references to the runtime
    constant pool of the class associated with the current method. Implementation-specific
    details, such as debugging information, can be appended to a frame, offering extended
    functionality.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: JVM中的帧是存储数据、处理部分结果、动态链接、返回方法值和管理异常的基本单元。其生命周期与方法调用紧密绑定，每次方法被调用时创建一个新的帧，在调用完成后（无论是正常结束还是由于未捕获的异常而突然结束）随后被销毁。这些帧从线程的JVM栈中分配，具有局部变量、操作数栈和与当前方法关联的类的运行时常量池的引用的独立数组。可以将特定于实现的详细信息（如调试信息）附加到帧上，提供扩展功能。
- en: The sizes of the local variable array and operand stack are predetermined at
    compile-time and accompany the method’s code. Consequently, the frame’s size relies
    solely on the JVM’s implementation, allowing for concurrent memory allocation
    during method invocation. In the realm of a given thread’s control, only one frame
    – the active frame for the executing method – is designated as the current frame,
    with operations on local variables and the operand stack predominantly referencing
    this frame. As a method invokes another or concludes its execution, the current
    frame evolves, passing results back to the previous frame. Importantly, frames
    are thread-local, ensuring they remain inaccessible to other threads.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量数组和操作数栈的大小在编译时预先确定，并伴随方法的代码。因此，帧的大小完全依赖于JVM的实现，允许在方法调用期间进行并发内存分配。在给定线程的控制范围内，只有一个帧——执行方法的当前活动帧——被指定为当前帧，对局部变量和操作数栈的操作主要引用此帧。当方法调用另一个方法或完成其执行时，当前帧会演变，将结果返回给上一个帧。重要的是，帧是线程局部的，确保它们对其他线程不可访问。
- en: A StackOverflow error is an exception when the call stack, a region of memory
    used to manage method calls in a program, exceeds its maximum limit. A method
    calls itself in recursive programming, creating a new stack frame for each invocation.
    Each stack frame contains information about the method’s state, including local
    variables and return addresses.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: StackOverflow错误是在调用栈，一个用于管理程序中方法调用的内存区域，超过其最大限制时发生的异常。在递归编程中，方法会调用自身，为每次调用创建一个新的栈帧。每个栈帧包含有关方法状态的信息，包括局部变量和返回地址。
- en: As the method calls itself repeatedly, new stack frames are created and pushed
    onto the call stack. If this recursion goes too deep without returning, it can
    consume all the available memory for the call stack, leading to a StackOverflow
    error. This error serves as a safeguard to prevent a program from running indefinitely
    and potentially crashing the system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法自身反复调用时，新的栈帧被创建并推入调用栈。如果没有返回而递归太深，它可能会消耗调用栈的所有可用内存，导致StackOverflow错误。这个错误作为保护措施，防止程序无限运行并可能崩溃系统。
- en: The StackOverflow error practically demonstrates how the call stack works in
    programming. Each method call pushes a new frame onto the stack, and when the
    stack becomes too deep, it results in an error. To avoid this error, programmers
    can optimize their recursive algorithms to use less stack space or switch to iterative
    solutions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: StackOverflow错误实际上展示了编程中调用栈的工作方式。每次方法调用都会将一个新的帧推入栈中，当栈变得太深时，就会导致错误。为了避免这种错误，程序员可以优化他们的递归算法以使用更少的栈空间，或者切换到迭代解决方案。
- en: The StackWalker API ([https://openjdk.org/jeps/259](https://openjdk.org/jeps/259))
    API that was introduced in Java provides a standardized and efficient way to walk
    through the execution stack. It allows developers to access information about
    the stack frames, including class instances, without capturing the entire stack
    trace. This API offers more flexibility and performance than methods such as `Throwable::getStackTrace`
    or `Thread::getStackTrace`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Java中引入的StackWalker API（[https://openjdk.org/jeps/259](https://openjdk.org/jeps/259)）提供了一种标准化和高效的方法来遍历执行栈。它允许开发者访问有关栈帧的信息，包括类实例，而无需捕获整个堆栈跟踪。此API比`Throwable::getStackTrace`或`Thread::getStackTrace`等方法提供了更多的灵活性和性能。
- en: 'StackWalker is particularly useful for scenarios where you must traverse selected
    frames on the execution stack efficiently and access class instances of each frame.
    It helps address the limitations of existing APIs by allowing lazy access to stack
    frame information and filtering of frames, making it a valuable tool for tasks
    such as the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: StackWalker在必须高效地遍历执行堆栈上的选定帧并访问每个帧的类实例的场景中特别有用。它通过允许延迟访问堆栈帧信息和过滤帧来帮助解决现有API的限制，成为以下任务等的有价值工具：
- en: Determining the immediate caller’s class for caller-sensitive APIs
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定调用敏感API的立即调用者的类
- en: Filtering out specific implementation classes in the stack
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆栈中过滤特定的实现类
- en: Finding protection domains and privileged frames
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找保护域和特权帧
- en: Generating stack traces for throwable objects and implementing debugging features
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可抛出对象生成堆栈跟踪并实现调试功能
- en: StackOverflow errors are a practical outcome of recursive programming when the
    call stack becomes too deep. The StackWalker API, introduced in Java, provides
    an efficient and flexible way to traverse and access information from the execution
    stack, addressing limitations in existing stack-tracing methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用栈变得太深时，StackOverflow错误是递归编程的实用结果。Java中引入的StackWalker API提供了一种高效灵活的方式来遍历和访问执行堆栈的信息，解决了现有堆栈跟踪方法的限制。
- en: In the intricate tapestry of the JVM, each frame harbors an array of variables
    known as its local variables. The length of this array is predetermined at compile
    time and embedded in the binary representation of the associated class or interface,
    accompanying the method code within the frame. A single local variable can accommodate
    Boolean, byte, char, short, int, float, reference, or returnAddress values, while
    pairs of local variables can collectively hold values of long or double types.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM错综复杂的织锦中，每个帧都包含一个称为其局部变量的变量数组。这个数组的长度在编译时预先确定，并嵌入到相关类或接口的二进制表示中，与帧内的方法代码一起。单个局部变量可以容纳布尔型、字节型、字符型、短整型、整型、浮点型、引用型或returnAddress值，而一对局部变量可以共同持有长或双类型值。
- en: Local variables
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量
- en: Local variables are accessed through indexing, with the index of the first local
    variable being zero. The JVM’s addressing mechanism allows integers to serve as
    indices in the local variable array and are only valid if the integer falls between
    zero and one less than the array’s size. Importantly, values of the long or double
    type span two consecutive local variables, which necessitates using the lesser
    index for addressing. While storing in the second variable is permissible, it
    invalidates the contents of the first.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量通过索引访问，第一个局部变量的索引为零。JVM的寻址机制允许整数作为局部变量数组的索引，并且只有当整数在零和数组大小减一之间时才有效。重要的是，长或双类型值跨越两个连续的局部变量，这需要使用较小的索引进行寻址。虽然存储在第二个变量中是允许的，但它会破坏第一个变量的内容。
- en: The JVM showcases its remarkable flexibility through its capacity to accommodate
    non-even indices (n) when handling long and double values, which deviates from
    the traditional concept of 64-bit alignment in the local variables array. This
    adaptability empowers implementors to decide how to represent these values, leveraging
    the allocation of the two reserved local variables. This unique feature of the
    JVM enables it to seamlessly adapt to various system architectures, including
    32-bit and 64-bit systems, optimizing memory utilization and performance based
    on the specific hardware configurations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JVM通过其处理长和双值时能够容纳非偶数索引（n）的能力展示了其非凡的灵活性，这与局部变量数组中传统的64位对齐概念相背离。这种适应性使实现者能够决定如何表示这些值，利用两个保留局部变量的分配。这个独特的JVM特性使其能够无缝适应各种系统架构，包括32位和64位系统，根据特定的硬件配置优化内存利用率和性能。
- en: Practically, local variables play a vital role in method invocation. For class
    method invocation, parameters find their place in consecutive local variables,
    commencing from local variable 0\. In the case of instance method invocation,
    local variable 0 acts as the conduit for passing a reference to the invoking object
    (akin to `this` in Java), with subsequent parameters residing in consecutive local
    variables starting from index 1\. This systematic use of local variables ensures
    the effective passing of parameters during method execution within the JVM.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，局部变量在方法调用中扮演着至关重要的角色。对于类方法调用，参数依次占据连续的局部变量位置，从局部变量 0 开始。在实例方法调用的情况下，局部变量
    0 作为传递调用对象引用（类似于 Java 中的 `this`）的通道，后续参数从索引 1 开始依次位于连续的局部变量中。这种系统性的局部变量使用确保了在
    JVM 中方法执行时参数的有效传递。
- en: 'The following visual representation shows the dynamic choreography of local
    variables within the JVM. This figure encapsulates the local variables within
    each frame, portraying the organized spaces for Boolean, byte, char, short, int,
    float, reference, returnAddress, long, and double types. Notably, pairs of local
    variables seamlessly accommodate long or double values, challenging traditional
    alignment norms with non-even indexing flexibility. Here, we can see how the JVM
    efficiently employs local variables during method invocation, systematically arranging
    parameters in consecutive local variables. This concise visual offers a clear
    roadmap for understanding the nuanced interplay of values within the JVM’s memory
    architecture:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下视觉表示展示了 JVM 中局部变量的动态编排。此图封装了每个帧中的局部变量，描绘了布尔型、字节型、字符型、短整型、整型、浮点型、引用型、返回地址型、长整型和双精度型类型的有序空间。值得注意的是，成对的局部变量无缝地容纳了长或双精度值，挑战了传统的对齐规范，提供了非偶数索引的灵活性。在这里，我们可以看到
    JVM 如何在方法调用中高效地使用局部变量，系统地安排参数在连续的局部变量中。这个简洁的视觉图为我们理解 JVM 内存架构中值的微妙互动提供了清晰的路线图：
- en: '![Figure 5.4: Local variables representation](img/B22030_05_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：局部变量表示](img/B22030_05_04.jpg)'
- en: 'Figure 5.4: Local variables representation'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：局部变量表示
- en: 'In concluding our exploration of local variables within bytecode, we’ve peeled
    back the layers of method execution, witnessing how these variables serve as dynamic
    containers for values, parameters, and references. This understanding sets the
    groundwork for our next section: *Operand stacks*. As we transition, anticipate
    an in-depth examination of how the operand stack interfaces with local variables,
    directing the flow of operations and ensuring the seamless execution of methods
    within the intricate dance of the JVM. Join us as we unravel the pivotal role
    of operand stacks in the symphony of bytecode execution.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索字节码中局部变量的过程中，我们揭开了方法执行的层层面纱，见证了这些变量如何作为值、参数和引用的动态容器。这种理解为我们下一节奠定了基础：*操作数栈*。随着我们的过渡，期待对操作数栈如何与局部变量接口、指导操作流程以及确保
    JVM 繁琐操作中方法无缝执行进行深入探讨。加入我们，一起揭开操作数栈在字节码执行交响曲中的关键作用。
- en: Operand stacks
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作数栈
- en: Within the intricate structure of the JVM, each frame boasts a **last-in-first-out**
    (**LIFO**) stack known as the operand stack. This session peels back the layers
    of bytecode execution to unveil the role of operand stacks in managing data during
    method execution.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 的复杂结构中，每个帧都拥有一个称为操作数栈的**后进先出**（**LIFO**）栈。本节将揭开字节码执行层层的面纱，揭示操作数栈在方法执行过程中管理数据的作用。
- en: The maximum depth of the operand stack is a compile-time decision that’s intricately
    intertwined with the method’s code. This depth parameter shapes the operand stack’s
    behavior within each frame.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数栈的最大深度是一个编译时决定，它与方法的代码紧密相连。这个深度参数决定了每个帧中操作数栈的行为。
- en: While often referred to simply as the operand stack, it’s essential to recognize
    its dynamic nature. Starting empty upon frame creation, the operand stack becomes
    a dynamic repository for constants, local variables, field values, and method
    results.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常简称为操作数栈，但认识到其动态特性至关重要。在帧创建时，操作数栈为常量、局部变量、字段值和方法结果提供了一个动态的存储库。
- en: The JVM supplies instructions to load, manipulate, and store values on the operand
    stack. Operations range from loading constants to intricate computations. For
    instance, the `iadd` instruction adds two int values, necessitating their presence
    as the top two values on the operand stack.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 提供指令来加载、操作和存储操作数栈上的值。操作范围从加载常量到复杂的计算。例如，`iadd` 指令将两个整型值相加，需要它们作为操作数栈上顶部两个值的存在。
- en: The operand stack enforces strict type constraints to maintain integrity. Each
    entry can hold any JVM type, including long or double values. Type-appropriate
    operations are essential, preventing, for example, the treatment of two int values
    as a long.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数栈强制执行严格的类型约束以保持完整性。每个条目可以持有任何 JVM 类型，包括长整型或双精度浮点型值。适当的类型操作是必要的，例如，防止将两个整型值视为长整型。
- en: The depth of an operand stack at any given moment reflects the cumulative contributions
    of its values. Type-specific units, such as two units for long or double, shape
    the associated depth.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定时刻的操作数栈深度反映了其值的累积贡献。特定类型的单元，如长整型或双精度浮点型需要两个单元，塑造了相关的深度。
- en: 'The following visual representation unveils the operand stack dynamics in the
    realm of integers within the JVM. Picture an operand stack initiated with two
    values, 10 and 20, poised for addition. As the bytecode execution unfolds, the
    `iadd` instruction orchestrates the addition operation, summing up these integers.
    Witness the seamless flow of values on the operand stack, capturing the transformation
    of 10 and 20 into the final result of **30**. This illustrative snapshot encapsulates
    the essence of operand stack manipulation, showcasing the fluid exchange and computation
    of values within the intricate dance of bytecode execution:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下视觉表示揭示了 JVM 中整型领域的操作数栈动态。想象一个以两个值 10 和 20 开始的操作数栈，准备进行加法运算。随着字节码的执行展开，`iadd`
    指令协调加法操作，将这些整数相加。见证操作数栈上值的无缝流动，捕捉了 10 和 20 转变为最终结果 **30** 的变化。这个说明性的快照封装了操作数栈操作的本质，展示了在字节码执行复杂舞蹈中值的流动和计算：
- en: '![Figure 5.5: The operand stack of int a + int b](img/B22030_05_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：整型 a + 整型 b 的操作数栈](img/B22030_05_05.jpg)'
- en: 'Figure 5.5: The operand stack of int a + int b'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：整型 a + 整型 b 的操作数栈
- en: 'This figure shows operand stacks handling double values within the JVM. Picture
    an operand stack initialized with two double values, 10.10 and 20.20, poised for
    addition. However, unlike integers, doubles occupy a larger size in the operand
    stack due to their inherent nature. As the bytecode’s execution unfolds, the relevant
    instructions orchestrate the addition operation, seamlessly handling the larger
    size of double values. Witness the transformation of 10.10 and 20.20 into the
    final result of 30.30, reflecting the arithmetic operation and the nuanced accommodation
    of double values within the operand stack. The following figure captures the intricacies
    of operand stack dynamics, emphasizing the size considerations essential for handling
    diverse data types in the JVM:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了 JVM 内处理双精度浮点数的操作数栈。想象一个初始化了两个双精度浮点值，10.10 和 20.20，准备进行加法运算的操作数栈。然而，与整数不同，由于它们固有的性质，双精度浮点数在操作数栈中占据更大的空间。随着字节码的执行展开，相关的指令协调加法操作，无缝地处理双精度浮点数更大的大小。见证
    10.10 和 20.20 转变为最终结果 30.30，反映了算术操作和操作数栈中对双精度浮点数的细微适应。以下图捕捉了操作数栈动态的复杂性，强调了在 JVM
    中处理不同数据类型时必要的尺寸考虑：
- en: '![Figure 5.6: The operand stack of double a + double b](img/B22030_05_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：双精度浮点数 a + 双精度浮点数 b 的操作数栈](img/B22030_05_06.jpg)'
- en: 'Figure 5.6: The operand stack of double a + double b'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：双精度浮点数 a + 双精度浮点数 b 的操作数栈
- en: As we conclude our exploration of operand stacks, we’ve unraveled the intricate
    dance of values within the JVM, witnessing their dynamic exchange and computation.
    From integers to doubles, the operand stack is a versatile stage for bytecode
    execution. Now, our journey leads us to the heart of method execution – the Java
    stack. In the next session, we will dissect the Java stack at the bytecode level,
    delving into how it orchestrates the flow of method calls, manages frames, and
    navigates the intricacies of the call stack. Join us as we embark on a deeper
    dive into the stack-based architecture of the JVM, unlocking the layers that define
    the journey of method invocation and execution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对操作数堆栈的探索告一段落，我们已经揭开了JVM内部值之间错综复杂的舞蹈，见证了它们的动态交换和计算。从整数到双精度浮点数，操作数堆栈是字节码执行的多功能舞台。现在，我们的旅程引领我们进入方法执行的核心——Java堆栈。在下一节中，我们将深入剖析字节码级别的Java堆栈，探讨它是如何协调方法调用流程、管理帧以及导航调用堆栈的复杂性。加入我们，一起深入探索JVM的基于堆栈的架构，解锁定义方法调用和执行旅程的层级。
- en: Java stack at the bytecode
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码中的Java堆栈
- en: When we explored Java’s internal mechanics, we shifted our focus to a pivotal
    aspect – the Java stack at the bytecode level. We’ve already delved into the intricate
    world of bytecode execution, unraveling how Java instructions translate into low-level
    operations within the JVM. If you’re keen on delving deeper into bytecode specifics,
    we encourage you to revisit [*Chapter 3*](B22030_03_split_000.xhtml#_idTextAnchor042).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索Java的内部机制时，我们将焦点转向一个关键方面——字节码级别的Java堆栈。我们已经深入探讨了字节码执行的复杂世界，揭示了Java指令如何转换为JVM内部的低级操作。如果你对字节码的细节感兴趣，我们鼓励你回顾[*第3章*](B22030_03_split_000.xhtml#_idTextAnchor042)。
- en: Now, our journey takes us to scrutinizing the Java stack, a fundamental component
    in the JVM’s stack-based architecture. This section is designed to dissect the
    Java stack’s role in managing method calls, handling frames, and navigating the
    call stack. It’s a journey into the core of method execution, shedding light on
    how the JVM organizes and executes Java code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的旅程带我们深入剖析Java堆栈，这是JVM基于堆栈架构中的基本组件。本节旨在剖析Java堆栈在管理方法调用、处理帧和导航调用堆栈中的作用。这是一次深入方法执行核心的旅程，揭示了JVM如何组织和执行Java代码。
- en: So, join us as we navigate the Java stack in bytecode, revealing the layers
    that shape the intricacies of method invocation and execution. For those eager
    to deepen their understanding of Java’s internal workings, this section explores
    the stack-based foundations of Java’s runtime environment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，加入我们，在字节码中导航Java堆栈，揭示塑造方法调用和执行复杂性的层级。对于那些渴望深入了解Java内部工作原理的人，本节探讨了Java运行时环境的基于堆栈的基础。
- en: 'Let’s create a Java class named `Math` that encapsulates various arithmetic
    operations, showcasing static and instance methods. Our class will feature fundamental
    operations such as addition, multiplication, subtraction, and division while employing
    integer and double data types:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Math`的Java类，它封装了各种算术操作，展示了静态和实例方法。我们的类将包括基本的操作，如加法、乘法、减法和除法，同时使用整数和双精度浮点数数据类型：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the class definition is complete, we can compile it using the `javac` command.
    Subsequently, we can inspect the bytecode representation of the `Math` class using
    the `javap` command with the `-verbose` flag. This insightful exploration into
    the generated bytecode allows us to delve into the low-level instructions the
    JVM interprets to execute arithmetic operations. Join us in this hands-on journey
    to uncover the bytecode intricacies of both static and instance methods, providing
    a deeper understanding of their implementation within the JVM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成类定义，我们可以使用`javac`命令编译它。随后，我们可以使用带有`-verbose`标志的`javap`命令检查`Math`类的字节码表示。这种对生成的字节码的深入探索使我们能够深入了解JVM解释以执行算术操作的低级指令。加入我们这个动手之旅，揭示静态和实例方法的字节码复杂性，提供对它们在JVM中实现的更深入理解。
- en: We’ll meticulously analyze the bytecode that’s generated for each method within
    our `Math` class. Bytecode, the intermediate representation of Java code that
    the JVM comprehends, unfolds with insights into each method’s low-level operations.
    Let’s meticulously dissect the bytecode for our arithmetic operations, delving
    into the stack, local variables, and argument size for two methods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仔细分析我们 `Math` 类中每个方法生成的字节码。字节码是 JVM 理解的 Java 代码的中间表示，它揭示了每个方法低级操作的见解。让我们仔细剖析我们的算术操作的字节码，深入研究两个方法的栈、局部变量和参数大小。
- en: 'First, we will explore the sum using an integer; as you can see, the arg size
    is three because, beyond the parameter, there is also the instance, once it is
    not a static method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用整数来探索总和；正如你所见，参数大小为三个，因为除了参数之外，还有一个实例，一旦它不是一个静态方法：
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Descriptor**: **(II)I**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述符**: **(II)I**'
- en: '**Flags**: **(0x0000)**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**: **(0x0000)**'
- en: '**Code explanation**:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码解释**:'
- en: '[PRE2]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Analysis**:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**:'
- en: '**locals=3** indicates that the method has three local variables. In this case,
    it includes the instance and the two parameters.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**locals=3** 表示该方法有三个局部变量。在这种情况下，它包括实例和两个参数。'
- en: '**stack=2** signifies that the maximum stack size during method execution is
    2, accommodating the values pushed onto the stack.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stack=2** 表示方法执行期间的最大栈大小为 2，容纳推入栈的值。'
- en: '**args_size=3** denotes that three arguments are passed to the method.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**args_size=3** 表示该方法传递了三个参数。'
- en: This method is a multiply operation that’s declared as static. In Java, when
    a method is static, it belongs to the class itself, not to instances of the class.
    Therefore, static methods don’t have a reference to an instance of the class,
    unlike instance methods.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是一个声明为静态的乘法操作。在 Java 中，当一个方法是静态的，它属于类本身，而不是类的实例。因此，静态方法没有对类实例的引用，与实例方法不同。
- en: In method descriptors, `args_size` specifies the total number of arguments the
    method expects when it’s invoked. For instance methods, one of those arguments
    is reserved for the instance itself, commonly referred to as `this` in Java. However,
    in static methods, this instance argument is not present because static methods
    are not associated with any particular instance of the class. Consequently, static
    methods have “one less `args_size`” because they don’t require the instance argument
    that instance methods do.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法描述符中，`args_size` 指定了方法被调用时期望的总参数数。对于实例方法，其中之一是为实例本身保留的，在 Java 中通常称为 `this`。然而，在静态方法中，这个实例参数不存在，因为静态方法与类的任何特定实例无关。因此，静态方法比实例方法少一个
    `args_size`，因为它们不需要实例方法所需的实例参数。
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Descriptor**: **(II)I**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述符**: **(II)I**'
- en: '**Flags**: **(****0x0008) ACC_STATIC**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**: **(****0x0008) ACC_STATIC**'
- en: '**Code explanation**:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码解释**:'
- en: '[PRE4]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Analysis**:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**:'
- en: '**locals=2** indicates that the method has two local variables, corresponding
    to the two parameters'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**locals=2** 表示该方法有两个局部变量，对应于两个参数。'
- en: '**stack=2** signifies that the maximum stack size during method execution is
    2'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stack=2** 表示方法执行期间的最大栈大小为 2'
- en: '**args_size=2** denotes that two arguments are passed to the method'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**args_size=2** 表示该方法传递了两个参数'
- en: By observing the bytecode characteristics of the provided methods, we can see
    that operations involving `double` and `long` data types result in a doubling
    of both stack size and local variables. This is because these data types occupy
    two spaces, necessitating increased allocation in memory. As we further explore
    bytecode intricacies, we lay the groundwork for optimizing and refining Java applications
    within the confines of the JVM’s interpretation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察提供的方法的字节码特征，我们可以看到涉及 `double` 和 `long` 数据类型的操作会导致栈大小和局部变量的加倍。这是因为这些数据类型占用两个空间，需要增加内存分配。随着我们进一步探索字节码的复杂性，我们为在
    JVM 解释的范围内优化和改进 Java 应用程序奠定了基础。
- en: By unraveling the bytecode’s size characteristics, including the stack, local
    variables, and argument size for each method, we understand the memory management
    and execution intricacies embedded within these operations. This exploration lays
    the groundwork for optimizing and refining Java applications as we navigate the
    JVM’s bytecode interpretation depths.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解开每个方法的字节码大小特征，包括栈、局部变量和参数大小，我们理解了这些操作中嵌入的内存管理和执行复杂性。这次探索为我们导航 JVM 字节码解释的深度，优化和改进
    Java 应用程序奠定了基础。
- en: In delving into the Java stack, we’ve unraveled the intricacies of method execution
    within the JVM. Understanding the stack’s role as a private register for each
    thread, accommodating frames, and facilitating the storage of local variables
    and partial results is pivotal in navigating the landscape of Java memory management.
    We explored various methods and observed how the stack dynamically adjusts to
    method invocations, managing parameters, local variables, and method results.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究 Java 栈时，我们揭示了 JVM 中方法执行的复杂性。理解栈作为每个线程的私有寄存器的作用，容纳帧，并促进局部变量和部分结果的存储，对于导航
    Java 内存管理领域至关重要。我们探讨了各种方法，并观察了栈如何动态调整以适应方法调用，管理参数、局部变量和方法结果。
- en: 'This comprehension sets the stage for what we’ll cover next: native method
    stacks. Native methods, which bridge the gap between Java and platform-specific
    functionality, introduce a layer of complexity to the JVM’s memory model. Join
    us in the upcoming session as we dissect the mechanics of native method invocation,
    exploring how native method stacks contribute to the seamless integration of Java
    applications with underlying platform capabilities.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理解为我们接下来要讨论的内容奠定了基础：本地方法栈。本地方法，它们在 Java 和平台特定功能之间架起桥梁，给 JVM 的内存模型引入了一层复杂性。请加入我们即将到来的会议，我们将剖析本地方法调用的机制，探讨本地方法栈如何有助于
    Java 应用程序与底层平台能力的无缝集成。
- en: Native method stacks
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地方法栈
- en: 'In the JVM realm, the execution of native methods, those penned in languages
    beyond Java’s domain, introduces a distinctive memory management facet: native
    method stacks. These stacks, often synonymous with “C stacks,” serve as the scaffolding
    for the execution of native methods and may even be leveraged by JVM interpreters
    implemented in languages such as C.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 领域，执行本地方法，即用超出 Java 范围的语言编写的语言，引入了一个独特的内存管理方面：本地方法栈。这些栈通常与“C 栈”同义，是本地方法执行的基础结构，甚至可能被用
    C 等语言实现的 JVM 解释器所利用。
- en: A JVM implementation employing native method stacks may allocate these stacks
    per thread, aligning with the thread’s creation. The flexibility of these stacks
    can manifest in either fixed sizes or dynamic resizing to accommodate the demands
    of the computation. When fixed, each native method stack’s size can be independently
    determined upon creation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 采用本地方法栈的 JVM 实现可能会为每个线程分配这些栈，与线程的创建同步。这些栈的灵活性可以表现为固定大小或动态调整以适应计算需求。当固定时，每个本地方法栈的大小可以在创建时独立确定。
- en: For fine-tuning and optimization, JVM implementations might offer control over
    the initial, maximum, and minimum sizes of native method stacks, empowering programmers
    or users to tailor the runtime environment to specific requirements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了微调和优化，JVM 实现可能提供对本地方法栈的初始大小、最大大小和最小大小的控制，使程序员或用户能够根据特定要求定制运行时环境。
- en: However, treading into the domain of native method stacks isn’t without its
    caveats. The JVM sets forth exceptional conditions associated with these stacks.
    `StackOverflowError` looms if a thread’s computation demands a more giant native
    method stack than what’s allowed. This error can also affect the Java stack, not
    just the native memory stack, and occurs when the call stack becomes too deep
    due to excessive method invocations. Additionally, attempts at dynamic expansion
    may encounter `OutOfMemoryError` if the system fails to furnish the required memory,
    either during expansion or the creation of an initial native method stack for
    a new thread. These exceptional conditions highlight the importance of efficient
    memory management within the JVM, affecting both native and Java stacks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，涉足本地方法栈领域并非没有风险。JVM 对这些栈提出了异常条件。如果线程的计算需求超过了允许的更大的本地方法栈，就会出现 `StackOverflowError`。这个错误也可能影响
    Java 栈，而不仅仅是本地内存栈，并且发生在调用栈由于方法调用过多而变得太深时。此外，如果系统在扩展期间或为新的线程创建初始本地方法栈时无法提供所需的内存，动态扩展尝试可能会遇到
    `OutOfMemoryError`。这些异常条件突出了 JVM 中高效内存管理的重要性，这影响到本地和 Java 栈。
- en: In unraveling the intricacies of native method stacks, we’ve navigated a crucial
    layer of the JVM’s memory management, which is essential for executing native
    methods and bridging the gap between Java and other languages. As we conclude
    our exploration of these specialized stacks, our journey seamlessly transitions
    to the heart of the JVM’s internal workings – the method area. This pivotal region
    is the repository for class and method information and a dynamic space where method
    invocations and their corresponding frames come to life. Join us in the next section
    as we delve into the method area, unveiling the repository that shapes the foundation
    for executing Java applications within the JVM.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在解开原生方法栈的复杂性时，我们已经导航了JVM内存管理的关键层，这对于执行原生方法和架起Java与其他语言之间的桥梁至关重要。随着我们探索这些专用栈的结束，我们的旅程无缝过渡到JVM内部工作的核心——方法区。这个关键区域是类和方法信息的存储库，是一个动态空间，其中方法调用及其对应的帧得以实现。请加入我们，在下一节中我们将深入探讨方法区，揭示其作为类和方法信息存储库的角色，并为在JVM中无缝执行Java应用程序奠定基础。
- en: Method area
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法区
- en: Within the complex architecture of the JVM, the method area serves as a shared
    space accessible to all JVM threads, much like the storage for compiled code in
    traditional languages or the “text” segment in an operating system process. This
    essential region contains structures unique to each class, including the runtime
    constant pool, data for fields and methods, and the code for methods and constructors.
    It also accommodates unique class, interface, and instance initialization methods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM的复杂架构中，方法区作为一个所有JVM线程都可以访问的共享空间，类似于传统语言中编译代码的存储或操作系统进程中的“文本”段。这个基本区域包含每个类的独特结构，包括运行时常量池、字段和方法的数据，以及方法和构造函数的代码。它还容纳了独特的类、接口和实例初始化方法。
- en: Created at the inception of the virtual machine, the method area, while logically
    part of the heap, may differ in garbage collection and compaction policies. This
    specification does not dictate its implementation specifics, such as location
    and management policies, offering flexibility to JVM implementations. The method
    area’s size, whether fixed or dynamic, can be controlled by the programmer or
    user, providing flexibility in tuning the runtime environment. However, the potential
    exceptional condition of `OutOfMemoryError` looms if memory allocation within
    the method area cannot satisfy a request. Join us as we embark on a detailed exploration
    of the method area, unraveling its role as the repository for class and method
    information, and setting the stage for the seamless execution of Java applications
    within the JVM.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机创建之初，方法区虽然逻辑上是堆的一部分，但在垃圾收集和压缩策略上可能有所不同。此规范并未指定其实施的具体细节，例如位置和管理策略，为JVM实现提供了灵活性。方法区的大小，无论是固定的还是动态的，都可以由程序员或用户控制，为调整运行时环境提供灵活性。然而，如果方法区内的内存分配无法满足请求，`OutOfMemoryError`这种潜在的异常情况就会出现。请加入我们，我们将详细探索方法区，揭示其在类和方法信息存储库中的作用，并为在JVM中无缝执行Java应用程序做好准备。
- en: Nestled within the JVM’s intricate architecture, the method area emerges as
    a shared realm among all JVM threads, akin to the compiled code storage in conventional
    languages or the “text” segment in an operating system process. This vital space
    is the repository for per-class structures, housing the runtime constant pool,
    field and method data, and the code for methods and constructors. Special methods
    intricately linked to class, interface initialization, and instance initialization
    find their abode within this domain.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 被安置在JVM错综复杂的架构之中，方法区成为所有JVM线程共享的领域，类似于传统语言中的编译代码存储或操作系统进程中的“文本”段。这个至关重要的空间是每个类结构的存储库，包括运行时常量池、字段和方法数据，以及方法和构造函数的代码。与类、接口初始化和实例初始化紧密相连的特殊方法也在此领域内找到其归宿。
- en: Initiated at the birth of the virtual machine, the method area, though logically
    part of the heap, may diverge in garbage collection and compaction policies. Its
    implementation specifics, including location and management policies, grant flexibility
    to JVM implementations. The method area’s size, whether fixed or dynamic, can
    be fine-tuned by the programmer or user, offering control over the runtime environment.
    However, an imminent `OutOfMemoryError` looms as a potential exceptional condition
    if memory allocation within the method area falls short.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 方法区在虚拟机诞生时启动，虽然逻辑上属于堆的一部分，但在垃圾收集和压缩策略上可能存在差异。其实现细节，包括位置和管理策略，为JVM的实现提供了灵活性。方法区的大小，无论是固定的还是动态的，都可以由程序员或用户进行微调，从而控制运行时环境。然而，如果方法区内的内存分配不足，即将出现`OutOfMemoryError`这一潜在的异常情况。
- en: As we unravel the layers of the method area, delving into its role as the repository
    for class and method information, we pave the way for the seamless execution of
    Java applications within the JVM. Join us on this exploration that not only demystifies
    the intricacies of the method area but also sets the stage for our next journey
    into the expansive terrain of the heap – a critical component in the dynamic memory
    management orchestration of the JVM.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们层层揭开方法区的面纱，深入探究其在存储类和方法信息方面的作用，我们为在JVM内无缝执行Java应用程序铺平了道路。加入我们的探索之旅，这不仅揭开了方法区的复杂性，也为我们进入堆的广阔领域奠定了基础——堆是JVM动态内存管理编排中的关键组件。
- en: Heap
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: At the heart of the JVM lies the heap, a shared space among all JVM threads,
    and the dynamic runtime data area responsible for allocating memory to all class
    instances and arrays. As a foundational component created during virtual machine
    startup, the heap plays a pivotal role in executing Java applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的核心是堆，它是所有JVM线程共享的空间，也是负责为所有类实例和数组分配内存的动态运行时数据区。作为虚拟机启动期间创建的基础组件，堆在执行Java应用程序中扮演着至关重要的角色。
- en: An automatic storage management system, commonly known as a garbage collector,
    orchestrates memory management within the heap. Notably, objects in the heap are
    never explicitly deallocated, relying on the automatic system to reclaim storage.
    The JVM remains agnostic to a specific storage management technique, allowing
    flexibility in its implementation to cater to varied system requirements. The
    heap’s size can be fixed or dynamically adjusted based on computational needs,
    expanding or contracting as necessary. This adaptability, combined with non-contiguous
    memory allocation, ensures efficient utilization.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自动存储管理系统，通常称为垃圾收集器，在堆内协调内存管理。值得注意的是，堆中的对象永远不会被显式释放，而是依赖于自动系统来回收存储。JVM对特定的存储管理技术保持中立，允许其实现在满足不同系统需求时的灵活性。堆的大小可以是固定的或根据计算需求动态调整，根据需要扩展或收缩。这种适应性，结合非连续内存分配，确保了高效的利用。
- en: By empowering JVM implementations with flexibility, programmers and users can
    control the heap’s initial, maximum, and minimum sizes. However, the looming exceptional
    condition is `OutOfMemoryError`, which is triggered when a computation demands
    more heap space than the automatic storage management system can provide. Join
    us on this exploration of the heap, where we’ll uncover its critical role in dynamically
    managing memory and understanding the nuances of its configuration for optimized
    Java application execution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过赋予JVM实现灵活性，程序员和用户可以控制堆的初始大小、最大大小和最小大小。然而，即将出现的异常情况是`OutOfMemoryError`，当计算需要比自动存储管理系统能提供的堆空间更多时，它会被触发。加入我们对堆的探索之旅，我们将揭示其在动态管理内存和优化Java应用程序执行配置中的关键作用。
- en: 'The following figure shows the birth of an object, its inception marking the
    creation of a reference – a pointer to the essence encapsulated within:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了对象的诞生，其诞生标志着引用的创建——指向封装在其中的本质的指针：
- en: '![Figure 5.7: Heap overview](img/B22030_05_07.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7：堆概述](img/B22030_05_07.jpg)'
- en: 'Figure 5.7: Heap overview'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：堆概述
- en: 'As the reference extends its influence, two subtle pointers come into play,
    delineating the path to essential domains:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 随着引用影响力的扩展，两个微妙的指针开始发挥作用，划定了通往基本领域的路径：
- en: '**Object pool**: A reservoir of detailed information, the object pool harbors
    the intricacies that breathe life into the object'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象池**：一个详细信息的宝库，对象池承载着赋予对象生命力的复杂性'
- en: '**Method area**: Nestled within, the constant pool within the method area stands
    as a repository of class details – attributes, methods, encapsulations – offering
    a comprehensive view of the object’s origins'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法区域**：其中，方法区域内的常量池作为一个类细节的仓库——属性、方法、封装等，提供了一个关于对象起源的全面视角'
- en: This figure captures the symbiosis between instances, references, and the heap’s
    intricate web of memory allocation. Join us in deciphering this symphony of memory,
    where objects find their abode, and the threads converge in a collective memory
    space, painting a vivid tableau of Java’s dynamic runtime environment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此图捕捉了实例、引用和堆内存分配复杂网络之间的共生关系。加入我们，解读这个内存交响曲，其中对象找到它们的归宿，线程在集体内存空间中汇聚，描绘出Java动态运行环境的生动图景。
- en: With the birth of an instance, its essence finds a dwelling within the heap
    – a shared memory space threading through the very fabric of JVM. This dynamic
    realm, collectively accessed by threads, not only stores object information but
    also boasts a sophisticated memory reclamation mechanism, skillfully maneuvering
    objects to sidestep the perils of space fragmentation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个实例诞生时，其本质在堆中找到了一个栖息地——一个穿过JVM结构的共享内存空间。这个动态领域，由线程共同访问，不仅存储对象信息，还拥有复杂的内存回收机制，巧妙地操纵对象以规避空间碎片化的风险。
- en: 'The representation of reference type variables within the heap diverges from
    primitive types, akin to the pointer mechanisms in C/C++. These reference objects,
    devoid of detailed information, act as pointers, directing toward the reservoir
    of object information. In essence, a reference object comprises two succinct pointers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型变量在堆中的表示与原始类型不同，类似于C/C++中的指针机制。这些引用对象缺乏详细的信息，充当指针，指向对象信息的储藏库。本质上，一个引用对象包含两个简洁的指针：
- en: One aligns with the object pool, housing the coveted details
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与对象池对齐，容纳了渴望的细节
- en: The other extends toward the constant pool, a treasure trove of class insights
    encompassing attributes, methods, encapsulations, and more, gracefully nestled
    within the method area
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个则延伸至常量池，这是一个充满类洞察力的宝库，包括属性、方法、封装等，优雅地嵌入在方法区域
- en: 'Venturing into the representation of vectors within this dynamic expanse, they
    echo the behavior of reference variables. However, vectors adorn themselves with
    two additional fields:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动态空间中探索向量的表示，它们与引用变量的行为相呼应。然而，向量还装饰了两个额外的字段：
- en: '**Size**: An indicator defining the vector’s dimensions'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：定义向量维度的指标'
- en: '**Reference list**: A curated compilation of pointers, weaving connections
    to the objects nestled within this vector'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考列表**：精心整理的指针汇编，将这些指针编织成与这个向量中嵌套的对象之间的联系'
- en: As we traverse this intricate landscape, envisioning the symbiotic relationship
    between instances, references, and pools, an illustrative depiction unveils the
    dance of memory within the heap – where objects find residence, and threads share
    a collective memory space.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们穿越这个复杂的地形时，想象实例、引用和池之间的共生关系，一个说明性的描绘揭示了堆内存中的记忆之舞——对象找到它们的居所，线程共享一个集体内存空间。
- en: As we delve into the intricacies of the heap, understanding its dynamic nature
    and the vital role it plays in memory allocation, our journey converges on the
    seamless interplay between the method area and the heap. Collectively, these integral
    components form the backbone of the JVM’s memory management, shaping the runtime
    environment for Java applications. Join us in the next section as we navigate
    this symbiotic relationship, exploring the interaction and synergy between the
    heap and the method area in the realm of the JVM’s internal workings.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究堆的复杂性时，理解其动态性质和在内存分配中的关键作用，我们的旅程汇聚于方法区域和堆之间的无缝互动。这些基本组件共同构成了JVM内存管理的骨架，塑造了Java应用程序的运行环境。在下一节中，我们将一起探索这种共生关系，探讨堆和方法区域在JVM内部运作领域的互动和协同作用。
- en: As we conclude our exploration of the heap, the heartbeat of shared memory among
    threads, we prepare to delve into the dynamic realms of the Code Cache and **just-in-time**
    (**JIT**) compilation. In the next section, we’ll unravel the intricacies of code
    execution optimization, where the Code Cache plays a pivotal role in storing compiled
    code snippets. Join us as we journey into the world of adaptive and efficient
    runtime performance, unlocking the mechanisms that enhance the execution speed
    of Java applications. Welcome to the realm of Code Cache and JIT, where the magic
    of optimized code unfolds.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束对线程间共享内存的心跳——堆的探索，我们准备深入到代码缓存和**即时编译**（**JIT**）的动态领域。在下一节中，我们将揭示代码执行优化的复杂性，其中代码缓存在存储编译代码片段方面发挥着关键作用。请加入我们的旅程，一起探索自适应和高效的运行时性能，解锁提升Java应用程序执行速度的机制。欢迎来到代码缓存和JIT的领域，这里优化代码的魔法正在展开。
- en: Code Cache and JIT
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码缓存和JIT
- en: In this section, we’ll unravel the dynamic duo of Code Cache and JIT compilation,
    pivotal components that elevate the runtime performance of Java applications to
    new heights. The Code Cache serves as a sanctuary for brilliance – housing compiled
    code snippets ready to be executed optimally. As Java applications run, the JIT
    compilation engine translates Java bytecode into native machine code, dynamically
    generating optimized versions of frequently executed methods. These gems of compiled
    code find their haven in the Code Cache, ensuring swift access for subsequent
    invocations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将揭示代码缓存和JIT编译的动态组合，这两个关键组件将Java应用程序的运行时性能提升到新的高度。代码缓存作为一个避风港，容纳着准备优化的编译代码片段。随着Java应用程序的运行，JIT编译引擎将Java字节码转换为本地机器代码，动态生成频繁执行方法的优化版本。这些编译代码的瑰宝在代码缓存中找到了它们的归宿，确保后续调用时能够快速访问。
- en: Code Cache, the powerhouse behind runtime optimization, plays a pivotal role
    in enhancing the execution speed of Java applications. Let’s explore its intricacies
    to understand the magic it brings to Java programming.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 代码缓存，作为运行时优化的动力源泉，在提升Java应用程序执行速度方面发挥着关键作用。让我们探索其复杂性，了解它为Java编程带来的魔法。
- en: 'In the dynamic landscape of Java runtime optimization, the Code Cache emerges
    as a central protagonist, orchestrating a symphony of compiled brilliance to enhance
    the execution speed of applications. Let’s embark on a journey to unravel the
    intricacies of Code Cache dynamics, delving into the mechanisms that make it a
    powerhouse within the JVM:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java运行时优化的动态景观中，代码缓存成为了一个核心主角，指挥着编译精粹的交响乐，以提升应用程序的执行速度。让我们开始一段旅程，揭示代码缓存动态的复杂性，深入了解使其在JVM内部成为强大动力的机制：
- en: '**Compilation sanctuary**: As Java applications execute, the JIT compilation
    engine dynamically translates Java bytecode into native machine code. The compiled
    code, representing optimized versions of frequently executed methods, aka hotspots,
    finds its haven in the Code Cache.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译避风港**：随着Java应用程序的执行，JIT编译引擎动态地将Java字节码转换为本地机器代码。代表频繁执行方法优化版本的编译代码，即热点，在代码缓存中找到了它们的避风港。'
- en: '**Optimized code storage**: The Code Cache serves as a repository for compiled
    brilliance, storing these optimized code snippets for swift access during subsequent
    invocations. It acts as a dynamic storage space, adapting to the evolving needs
    of the application as it runs.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化代码存储**：代码缓存作为一个编译精粹的仓库，存储这些优化代码片段，以便在后续调用时快速访问。它作为一个动态存储空间，根据应用程序运行时的演变需求进行调整。'
- en: '**Management of hotspots**: The Code Cache is particularly adept at managing
    hotspots – code sections that are frequently executed during the application’s
    runtime. By focusing on these hotspots, the Code Cache ensures that the most crucial
    pathways undergo efficient and tailored optimization.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热点管理**：代码缓存特别擅长于管理热点——在应用程序运行时频繁执行的代码段。通过关注这些热点，代码缓存确保最关键路径经历高效和定制的优化。'
- en: '**Space utilization**: The Code Cache dynamically adjusts its size based on
    the demands of the executing application. This adaptive resizing mechanism ensures
    that the most relevant and frequently used code segments find their place within
    the cache.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间利用率**：代码缓存根据执行应用程序的需求动态调整其大小。这种自适应调整大小的机制确保最相关和最频繁使用的代码段在缓存中找到它们的位置。'
- en: '**Swift access and execution**: The optimized code snippets stored in the Code
    Cache enable swift access during subsequent method invocations, contributing to
    the overall performance boost of the Java application.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速访问和执行**：存储在代码缓存中的优化代码片段能够在后续方法调用时实现快速访问，从而有助于提升Java应用程序的整体性能。'
- en: Understanding the dynamics of the Code Cache unveils its crucial role in the
    JIT compilation process, contributing significantly to the efficiency and adaptability
    of Java applications. As we delve into the intricacies of runtime optimization,
    the Code Cache emerges as a cornerstone, ensuring that the compiled brilliance
    is readily available for the application’s accelerated execution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 了解代码缓存的动态特性揭示了它在即时编译过程中的关键作用，对Java应用程序的效率和适应性做出了重大贡献。随着我们深入探讨运行时优化的复杂性，代码缓存成为了一个基石，确保编译出的卓越性能能够迅速应用于应用程序的加速执行。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the intricate mechanisms that govern the execution
    of Java applications within the JVM. From understanding the intricacies of memory
    management, exploring the Java stack, and unraveling the mysteries of native method
    stacks, to witnessing the dynamic compilation prowess of the JIT compiler and
    the crucial role played by the Code Cache, our journey has been one of decoding
    the inner workings of a Java application in action.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了在JVM中执行Java应用程序的复杂机制。从理解内存管理的复杂性，探索Java堆栈，揭示原生方法栈的奥秘，到见证即时编译器动态编译的能力以及代码缓存所扮演的关键角色，我们的旅程就是解码正在运行的Java应用程序的内部工作原理。
- en: 'As we bid farewell to the realm of code execution dynamics, our next destination
    awaits, where we’ll explore a fundamental aspect of runtime management: the garbage
    collector. Join us in the upcoming chapter as we unravel the intricacies of memory
    cleanup and resource management, which is essential for maintaining the health
    and efficiency of Java applications. The garbage collector beckons, promising
    insights into how the JVM gracefully handles memory de-allocation and ensures
    the longevity of Java applications. Let’s embark on the next chapter to uncover
    the secrets of garbage collection in the dynamic landscape of the JVM.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们告别代码执行动态领域时，我们的下一个目的地即将到来，我们将探索运行时管理的一个基本方面：垃圾收集器。请加入我们即将到来的章节，我们将揭示内存清理和资源管理的复杂性，这对于维护Java应用程序的健康和效率至关重要。垃圾收集器在召唤，承诺揭示JVM如何优雅地处理内存解分配并确保Java应用程序的持久性。让我们开始下一章，揭开JVM动态环境中垃圾收集的秘密。
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章知识的掌握：
- en: What is the primary role of the Code Cache in the JVM?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码缓存在JVM中的主要作用是什么？
- en: Storage for object instances
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象实例的存储
- en: A repository for compiled code
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码的存储库
- en: Memory cleanup and resource management
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存清理和资源管理
- en: Dynamic adjustment of heap size
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆大小的动态调整
- en: What does the Java stack store for each thread in the JVM?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM中Java堆栈为每个线程存储了什么？
- en: Compiled code snippets
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码片段
- en: Garbage collector information
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾收集器信息
- en: Frames, local variables, and the operand stack
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帧和局部变量以及操作数栈
- en: Native method stacks
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原生方法栈
- en: Which memory area is shared among all JVM threads and stores the runtime constant
    pool, field and method data, and method code?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个内存区域在所有JVM线程之间共享，并存储运行时常量池、字段和方法数据以及方法代码？
- en: Heap
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆
- en: Method area
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法区
- en: Code Cache
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码缓存
- en: Native method stack
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原生方法栈
- en: Which memory area in the JVM is responsible for storing class instances and
    arrays, with memory reclaimed by a garbage collector?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM中哪个内存区域负责存储类实例和数组，其内存由垃圾收集器回收？
- en: Code Cache
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码缓存
- en: Native method stack
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原生方法栈
- en: Java stack
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java堆栈
- en: Heap
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆
- en: What is the primary purpose of the Java stack in the JVM?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM中Java堆栈的主要作用是什么？
- en: Storage for compiled code snippets
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码片段的存储
- en: A repository for object instances
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象实例的存储库
- en: Dynamic adjustment of heap size
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆大小的动态调整
- en: To store frames, local variables, and the operand stack for each thread
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于存储每个线程的帧、局部变量和操作数栈
- en: Answers
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章问题的答案：
- en: B. A repository for compiled code
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 编译代码的存储库
- en: C. Frames, local variables, and the operand stack
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 帧和局部变量以及操作数栈
- en: B. Method area
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 方法区
- en: D. Heap
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. 堆
- en: D. To store frames, local variables, and the operand stack for each thread
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. 用于存储每个线程的帧、局部变量和操作数栈
