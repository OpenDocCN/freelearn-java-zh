- en: Securing Access to APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护API访问
- en: In this chapter, we will see how we can secure access to the APIs and web pages
    exposed by the edge server introduced in the previous chapter. We will learn to
    use HTTPS to protect against eavesdropping on external access to our APIs and
    also how to use OAuth 2.0 and OpenID Connect to authenticate and authorize users
    and client applications to access our APIs. Finally, we will study the use of
    HTTP basic authentication to secure access to the discovery service, Netflix Eureka.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何保护前一章中引入的边缘服务器暴露的API和网页。我们将学习使用HTTPS来防止对API的外部访问进行窃听，并了解如何使用OAuth
    2.0和OpenID Connect对用户和客户端应用程序访问我们的API进行认证和授权。最后，我们将研究使用HTTP基本认证来保护对Netflix Eureka发现服务的访问。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to the OAuth 2.0 and OpenID Connect standards
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍OAuth 2.0和OpenID Connect标准
- en: A general discussion on how to secure the system landscape
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何保护系统架构的一般讨论
- en: Adding an authorization server to our system landscape
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的系统架构中添加一个授权服务器
- en: Protecting external communication with HTTPS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTPS保护外部通信
- en: Securing access to the discovery service, Netflix Eureka
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护对Netflix Eureka发现服务的访问
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0和OpenID Connect对API访问进行认证和授权
- en: Testing with the local authorization server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地授权服务器进行测试
- en: Testing with an OpenID Connect provider, Auth0
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Auth0的OpenID Connect提供者进行测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but modifying them so they run on another platform such as Linux or Windows should
    be straightforward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在MacBook Pro上使用macOS Mojave运行的，但是修改它们以便在另一个平台如Linux或Windows上运行应该是很直接的。
- en: No new tools need to be installed in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中不需要安装任何新工具。
- en: The source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11)。
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. The following commands can be used to perform these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够按照书中描述运行命令，将源代码下载到一个文件夹中，并设置一个环境变量`$BOOK_HOME`，使其指向该文件夹。可以使用以下命令来执行这些步骤：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.3, and Spring 5.1.5, that is, the latest available version of the Spring
    components at the time of writing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用Spring Cloud 2.1.0, SR1（也称为**Greenwich**版本），Spring
    Boot 2.1.3和Spring 5.1.5，即在编写时可用的Spring组件的最新版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: '`spring-cloud/eureka-server`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/eureka-server`'
- en: '`spring-cloud/gateway`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/gateway`'
- en: '`spring-cloud/authorization-server`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/authorization-server`'
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter11`,
    but are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter11`中的源代码，但在许多情况下，都编辑了源代码中与主题无关的部分，例如注释、导入和日志声明。
- en: If you want to see the changes applied to the source code in [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), *Secure
    Access to APIs*, that is, to see what it took to secure access to the APIs in
    the microservice landscape, you can compare it with the source code for [Chapter
    10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml), *Using Spring Cloud Gateway to
    Hide Microservices Behind an Edge Server*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter10` and `$BOOK_HOME/Chapter11`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看源代码中在[第11章](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml)，*API的安全访问*中应用的改动，也就是查看在微服务架构中为API安全访问所付出的努力，你可以将其与[第10章](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml)，*使用Spring
    Cloud Gateway将微服务隐藏在边缘服务器后面*的源代码进行对比。你可以使用你喜欢的`diff`工具，比较两个文件夹，`$BOOK_HOME/Chapter10`和`$BOOK_HOME/Chapter11`。
- en: Introduction to OAuth 2.0 and OpenID Connect
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OAuth 2.0和OpenID Connect
- en: Before introducing OAuth 2.0 and OpenID Connect, let's clarify what we mean
    with authentication and authorization. **Authentication** means identifying a
    user by validating credentials supplied by the user, such as a username and password.
    **Authorization** is about giving access to various parts of, in our case, an
    API to an authenticated, that is, an identified user. In our case, a user will
    be assigned a set of privileges based on OAuth 2.0 scopes, as explained hereinafter.
    The microservices will be based on these privileges determine whether the user
    is allowed to access an API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍OAuth 2.0和OpenID Connect之前，让我们先澄清我们所说的认证和授权是什么意思。**认证**意味着通过验证用户提供的凭据来识别用户，例如用户名和密码。**授权**是关于给予认证用户，也就是已识别用户，访问我们这里所说的API的不同部分的权限。在我们这里，一个用户将被分配一组基于OAuth
    2.0范围的特权，如下所述。微服务将基于这些特权来确定用户是否被允许访问一个API。
- en: '**OAuth 2.0** is an open standard for authorization, and **OpenID Connect** is
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users based on the authentication performed by the authorization server. Let''s
    look briefly at OAuth 2.0 and OpenID Connect separately to get an initial understanding
    of their purposes!'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth 2.0**是一个开放标准的授权协议，而**OpenID Connect**是OAuth 2.0的一个补充，它允许客户端应用程序基于授权服务器执行的认证来验证用户身份。让我们简要地分别了解OAuth
    2.0和OpenID Connect，以获得它们目的的初步理解！'
- en: Introduction to OAuth 2.0
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OAuth 2.0
- en: '**OAuth** *2.0* is a widely accepted open standard for authorization that enables
    a user to give consent for a third-party client application to access protected
    resources in the name of the user.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth** *2.0* 是一个广泛接受的开源标准授权协议，它允许用户授权第三方客户端应用以用户的名义访问受保护的资源。'
- en: So, what does this mean?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这意味着什么呢？
- en: 'Let''s start with sorting out the concepts used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来梳理一下所使用的概念：
- en: '**Resource owner**: The end user.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：终端用户。'
- en: '**Client**: The third-party client application, for example, a web app or a
    native mobile app, that wants to call some protected APIs in the name of the end
    user.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：第三方客户端应用程序，例如，一个网络应用或一个原生移动应用，它想要以终端用户的名义调用一些受保护的API。'
- en: '**Resource server**: The server that exposes the APIs that we want to protect.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：暴露我们想要保护的API的服务器。'
- en: '**Authorization server:** The authorization server issues tokens to the client
    after the resource owner, that is, the end user, has been authenticated. The management
    of user information and the authentication of users are typically delegated, behind
    the scenes, to an **Identity Provider** (**IdP**).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：在资源所有者，即终端用户被认证后，向客户端发放令牌的服务器。用户信息的管理和用户的认证通常是在幕后委托给一个**身份提供者**（**IdP**）。'
- en: A client is registered in the authorization server and is given a **client ID** and
    a **client secret**. The client secret must be protected by the client, like a
    password. A client also gets registered with a set of allowed **redirect-URIs** that
    the authorization server will use after a user has been authenticated to send
    **grant codes** and **tokens** that have been issued back to the client application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在授权服务器中注册，并获得一个**客户端ID**和一个**客户端密钥**。客户端密钥必须像密码一样受到客户端的保护。客户端还会获得一组允许的**重定向URI**，授权服务器在用户被认证后使用这些URI将**授权码**和**令牌**发送回客户端应用程序。
- en: The following is an example by way of illustration. Let's say that a user accesses
    a third-party client application and the client application wants to call a protected
    API to serve the user. To be allowed to access these APIs, the client application
    needs a way to tell the APIs that it is acting in the name of the user. To avoid
    solutions where the user must share their credentials with the client application
    for authentication, an **access token** is issued by an authorization server that
    gives the client application limited access to a selected set of APIs in the name
    of the user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个说明性的例子。假设一个用户访问了一个第三方客户端应用程序，并且客户端应用程序想要调用一个受保护的 API 来为用户服务。为了允许访问这些 API，客户端应用程序需要一种方式来告诉
    API 它是在用户的名义下操作。为了避免用户必须与客户端应用程序共享他们的凭据以进行身份验证的解决方案，授权服务器会发放一个 **访问令牌**，该令牌允许客户端应用程序在用户的名义下访问一组选定的
    API。
- en: This means that the user never has to reveal their credentials to the client
    application. The user can also give consent to the client application to access
    specific APIs on behalf of the user. An access token represents a time-constrained
    set of access rights, expressed as a *scope* in OAuth 2.0 terms. A **refresh token**
    can also be issued to a client application by the authorization server. A refresh
    token can be used by the client application to obtain new access tokens without
    having to involve the user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户永远不需要向客户端应用程序透露他们的凭据。用户还可以给予客户端应用程序访问代表用户的具体 API 的权限。访问令牌代表了一组时间受限的访问权限，在
    OAuth 2.0 术语中表达为 *scope*。一个 **刷新令牌** 也可以由授权服务器发放给客户端应用程序。客户端应用程序可以使用刷新令牌来获取新的访问令牌，而无需涉及用户。
- en: 'The OAuth 2.0 specification defines four authorization grant flows for issuing
    access tokens, explained as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 规格定义了四种授权 grant 流程，用于发放访问令牌，如下解释：
- en: '**Authorization Code grant flow**: This is the safest, but also the most complex,
    grant flow. This grant flow requires that the user interact with the authorization
    server using a web browser for authentication and giving consent to the client
    application, as illustrated by the following diagram:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权码 grant 流程**：这是最安全，也是最复杂的 grant 流程。此流程需要用户通过网络浏览器与授权服务器进行交互，以进行身份验证和对客户端应用程序给予同意，如下面的图示：'
- en: '![](img/186b42c1-4690-4407-99c1-c0f71c1894c4.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186b42c1-4690-4407-99c1-c0f71c1894c4.png)'
- en: 'Explanations for this diagram are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此图的解释如下：
- en: The client application initiates the grant flow by sending the user to the authorization
    server in the web browser.
  id: totrans-48
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序通过在网络浏览器中发送用户到授权服务器来启动授权流程。
- en: The authorization server will authenticate the user and ask for the user's consent.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将会验证用户并请求用户的同意。
- en: The authorization server will redirect the user back to the client application
    with a grant code. The authorization server will use the redirect-URI specified
    by the client in step 1 to know where to send the grant code. Since the grant
    code is passed back to the client application using the web browser, that is,
    to an insecure environment where malicious JavaScript code potentially can pick
    up the grant code, it is only allowed to be used once and only during a short
    time period.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将会把用户通过一个 grant code 重定向回客户端应用程序。授权服务器将会使用客户端在第一步中指定的 redirect-URI 来知道重定向的位置。由于
    grant code 是通过网络浏览器，也就是到一个不安全的环境中，恶意 JavaScript 代码可能获取 grant code，因此 grant code
    仅允许使用一次，并且只在短时间内有效。
- en: To exchange the grant code for an access token, the client application is expected
    to call the authorization server again, using server-side code. The client application
    must present its client ID and client secret together with the grant code for
    the authorization server.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了用 grant code 换取访问令牌，客户端应用程序预计需要再次调用授权服务器，使用服务器端代码。客户端应用程序必须向授权服务器提供其客户端 ID
    和客户端密钥以及 grant code。
- en: The authorization server issues an access token and sends it back to the client
    application. The authorization server can also, optionally, issue and return a
    refresh token.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器发放一个访问令牌并将其发送回客户端应用程序。授权服务器还可以选择性地发放并返回一个刷新令牌。
- en: Using the access token, the client can send a request to the protected API exposed
    by the resource server.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用访问令牌，客户端可以向资源服务器公开的受保护 API 发送请求。
- en: The resource server validates the access token and serves the request in the
    event of a successful validation. Steps 6 and 7 can be repeated as long as the
    access token is valid. When the lifetime of the access token has expired, the
    client can use their refresh token to acquire a new access token.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器在验证访问令牌成功后验证访问令牌并处理请求。只要访问令牌有效，步骤6和7可以重复进行。当访问令牌的寿命过期时，客户端可以使用他们的刷新令牌来获取新的访问令牌。
- en: '**Implicit grant flow**: This flow is also web browser-based, but intended
    for client applications that are not able to keep a client secret protected, for
    example, a single-page web application. It gets an access token back from the
    authorization server instead of a grant code, but cannot request a refresh token,
    since it is using the implicit grant flow that is less secure than the code grant
    flow.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式授权流**：这个流程也是基于网络浏览器的，但旨在为无法保护客户端密钥的客户端应用程序，例如单页网络应用程序。它从授权服务器获取访问令牌，而不是授权代码，但由于它使用的是比代码授权流安全性较低的隐式授权流，因此无法请求刷新令牌。'
- en: '**Resource Owner Password Credentials grant flow**: If a client application
    can''t interact with a web browser, it can fall back on this grant flow. In this
    grant flow, the user must share their credentials with the client application
    and the client application will use these credentials to acquire an access token.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者密码凭证授权流**：如果客户端应用程序不能与网络浏览器进行交互，它可以回退到这个授权流。在这个授权流中，用户必须与客户端应用程序共享他们的凭据，并且客户端应用程序将使用这些凭据来获取访问令牌。'
- en: '**Client Credentials grant flow:** In the case where a client application needs
    to call an API unrelated to a specific user, it can use this grant flow to acquire
    an access token using its own client ID and client secret.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端凭证授权流**：当客户端应用程序需要调用与特定用户无关的API时，它可以使用这个授权流来使用自己的客户端ID和客户端密钥获取访问令牌。'
- en: When it comes to automating tests against APIs that are protected by OAuth 2.0,
    the **Resource Owner Password Credentials grant flow** is very handy since it
    doesn't require manual interaction using a web browser. We will use this later
    on in this chapter with our test script; see the *Changes in the test script* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到针对受OAuth 2.0保护的API进行自动化测试时，**资源所有者密码凭证授权流**非常方便，因为它不需要使用网络浏览器进行手动交互。我们稍后将在本章中使用这个授权流与我们的测试脚本一起使用；请参阅*测试脚本的变化*部分。
- en: 'The full specification can be found here: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749).
    There are also a number of additional specifications that detail various aspects
    of OAuth 2.0; for an overview, refer to [https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的规范可以在这里找到：[https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)。还有许多其他规范详细说明了OAuth
    2.0的各种方面；要了解概况，请参阅[https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/)。
- en: One additional specification that is worth some extra attention is *RFC 7636
    – Proof Key for Code Exchange by OAuth Public Clients (PKCE), *[https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636).
    This specification describes how an otherwise insecure public client, such as
    a mobile native app or desktop application, can utilize the code grant flow by
    adding an extra layer of security.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得额外关注的标准是*RFC 7636 – OAuth 公共客户端（PKCE）代码交换证明密钥*[https://tools.ietf.org/html/rfc7636]。这个标准描述了如何通过添加一个额外的安全层来使一个通常不安全的公共客户端（如移动原生应用或桌面应用）利用代码授权流。
- en: Securing access to the discovery service, Netflix Eureka
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护发现服务，Netflix Eureka的安全性
- en: Previously, we learned to protect external communication with HTTPS. Now we
    will use HTTP basic authentication to restrict access to the APIs and web pages
    on the discovery server, Netflix Eureka; that is, we will require a user to supply
    a username and password to get access. Changes are required both on the Eureka
    server and in the Eureka clients described as follows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们学习了用HTTPS保护外部通信。现在我们将使用HTTP基本认证来限制对发现服务器上API和网页的访问，即要求用户提供用户名和密码以获得访问权限。需要在Eureka服务器以及下面描述的Eureka客户端上进行更改。
- en: Introducing OpenID Connect
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OpenID Connect
- en: '**OpenID Connect** (abbreviated to **OIDC**) is, as has already been mentioned,
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users. OIDC adds an extra token, an ID token, that the client application gets
    back from the authorization server after a completed grant flow.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenID Connect**（缩写为**OIDC**）正如前面已经提到的，是OAuth 2.0的一个补充，使客户端应用程序能够验证用户身份。OIDC添加了一个额外的令牌，即ID令牌，客户端应用程序在完成授权流程后从授权服务器获得。'
- en: The ID token is encoded as a **JSON Web Token** (**JWT**) and contains a number
    of claims, such as the ID and email address of the user. The ID token is digitally
    signed using JSON web signatures. This makes it possible for a client application
    to trust the information in the ID token by validating the digital signature using
    public keys from the authorization server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 身份令牌编码为**JSON Web Token**（**JWT**），包含用户ID和电子邮件地址等声明。身份令牌使用JSON Web签名进行数字签名。这使得客户端应用程序可以通过使用授权服务器提供的公钥验证数字签名来信任身份令牌中的信息。
- en: Optionally, access tokens can also be encoded and signed in the same way as
    ID tokens, but it is not mandatory according to the specification. Finally, OIDC
    defines a **discovery endpoint**, which is a standardized way to establish URLs
    to important endpoints, such as initiating a grant flow, getting the public keys
    to verify a digitally signed JWT token, and a **user-info endpoint**, which can
    be used to get extra information about an authenticated user given an access token
    for that user.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，访问令牌也可以以与ID令牌相同的方式进行编码和签名，但根据规范这不是强制性的。最后，OIDC定义了一个**发现端点**，这是建立重要端点的URL的标准方式，例如启动授权流程、获取验证数字签名JWT令牌的公钥，以及一个**用户信息端点**，可以使用该端点根据用户的访问令牌获取额外信息。
- en: For an overview of the available specifications, see [https://openid.net/developers/specs/](https://openid.net/developers/specs/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的规范，请参阅[https://openid.net/developers/specs/](https://openid.net/developers/specs/)。
- en: This concludes our introduction to the OAuth 2.0 and OpenID Connect standards.
    In the next section, we will get a high-level view of how the system landscape
    will be secured.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对OAuth 2.0和OpenID Connect标准的介绍。在下一节中，我们将了解系统景观将如何得到保护的高级视图。
- en: Securing the system landscape
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护系统景观
- en: 'To secure the system landscape as described in the introduction to this chapter,
    we will perform the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保本章介绍的系统景观的安全，我们将执行以下步骤：
- en: Encrypt external requests and responses to and from our external API using HTTPS
    to protect against eavesdropping
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTPS对发往我们外部API的外部请求和响应进行加密，以防止窃听
- en: Authenticate and authorize users and client applications that access our APIs
    using OAuth 2.0 and OpenID Connect
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0和OpenID Connect对访问我们API的用户和客户端应用程序进行身份验证和授权
- en: Secure access to the discovery service, Netflix Eureka, using HTTP basic authentication
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP基本认证访问发现服务Netflix Eureka
- en: We will only apply HTTPS for external communication to our edge server, using
    plain HTTP for communication inside our system landscape.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将为边缘服务器的外部通信应用HTTPS，而将系统景观内部的通信使用普通HTTP。
- en: In the chapter on service mesh ([Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml),
    *Using a Service Mesh to Improve Observability and Management*) that will appear
    later in this book, we will see how we can get help from a service mesh product
    to automatically provision HTTPS to secure communication inside a system landscape.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书稍后的第18章（[第18章](422649a4-94bc-48ae-b92b-e3894c014962.xhtml)，*使用服务网格提高可观测性和管理*)中，我们将看到如何借助服务网格产品自动为系统景观内的通信提供HTTPS加密。
- en: For test purposes, we will add a local OAuth *2.0* authorization server to our
    system landscape. All external communication with the authorization server will
    be routed through the edge server. The edge server and the product-composite service
    will act as OAuth 2.0 resource servers; that is, they will require a valid OAuth
    2.0 access token to allow access.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 出于测试目的，我们将在我们的系统景观中添加一个本地OAuth *2.0* 授权服务器。所有与授权服务器的外部通信将通过边缘服务器路由。边缘服务器和产品组合服务将作为OAuth
    2.0资源服务器运行；也就是说，它们将要求有效的OAuth 2.0访问令牌才能访问。
- en: To minimize the overhead of validating access tokens, we will assume that they
    are encoded as signed JWT tokens and that the authorization server exposes an
    endpoint that the resource servers can use to access the public keys, also known
    as `jwk-set`, required to validate the signing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化验证访问令牌的开销，我们将假设它们以签名JWT令牌的形式编码，并且授权服务器暴露了一个端点，资源服务器可以使用该端点访问验证签名所需的公钥，也称为`jwk-set`。
- en: 'The system landscape will look like the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 系统景观将如下所示：
- en: '![](img/c45c1b73-3816-4923-aca4-414cef12a865.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c45c1b73-3816-4923-aca4-414cef12a865.png)'
- en: 'From the preceding diagram, we can note that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以注意到：
- en: HTTPS is used for external communication, while plain text HTTP is used inside
    the system landscape.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部通信使用HTTPS，而系统景观内部使用明文HTTP。
- en: The local OAuth 2.0 authorization server will be accessed externally through
    the edge server.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地OAuth 2.0授权服务器将通过边缘服务器外部访问。
- en: Both the edge server and the product composite microservice will validate access
    tokens as signed JWT tokens.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边缘服务器和产品复合微服务都将验证作为签名JWT令牌的访问令牌。
- en: The edge server and the product composite microservice will get the authorization
    server's public keys from its `jwk-set` endpoint, and use them to validate the
    signature of the JWT-based access tokens.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边缘服务器和产品复合微服务将从授权服务器的`jwk-set`端点获取其公钥，并使用它们验证基于JWT的访问令牌的签名。
- en: Note that we will focus on securing access to APIs over HTTP, not on covering
    general best practices for securing web applications, for example, managing web
    application security risks pointed out by the *Category:OWASP Top Ten Project*.
    Refer to [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)
    for more information on the OWASP Top Ten.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将重点关注通过HTTP保护API的访问，而不是涵盖通用最佳实践来保护网络应用程序，例如，管理由*类别：OWASP前十名项目*指出的网络应用程序安全风险。有关OWASP前十名的更多信息，请参阅[https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)。
- en: With this overview of how the system landscape will be secured, let's start
    by adding a local authorization server to the system landscape.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了系统景观如何得到保护的概述之后，让我们首先在系统景观中添加一个本地授权服务器。
- en: Adding an authorization server to our system landscape
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的系统景观中添加授权服务器
- en: To be able to run tests locally and fully automated with APIs that are secured
    using OAuth 2.0 and OpenID Connect, we will add an OAuth 2.0-based authorization
    server to our system landscape. Spring Security 5.1 does not, unfortunately, provide
    an authorization server out of the box. But there is a legacy project (currently
    in maintenance mode), Spring Security OAuth, that provides an authorization server that
    we can use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够本地运行并完全自动化地与使用OAuth 2.0和OpenID Connect保护的API进行测试，我们将向我们的系统景观中添加一个基于OAuth
    2.0的授权服务器。Spring Security 5.1不幸地没有提供开箱即用的授权服务器。但是有一个遗留项目（目前处于维护模式），Spring Security
    OAuth，提供了一个我们可以使用的授权服务器。
- en: In fact, in the samples provided by Spring Security 5.1, a project using the
    authorization server from Spring Security OAuth is available. It is configured
    to use JWT-encoded access tokens, and it also exposes an endpoint for a **JSON
    Web Key Set** (**JWKS**) (part of the OpenID Connect Discovery standard), a set
    of keys containing the public keys that can be used by resource servers to verify
    JWT tokens issued by the authorization server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在Spring Security 5.1提供的示例中，一个使用来自Spring Security OAuth的授权服务器的项目是可用的。它被配置为使用JWT编码的访问令牌，并且它还暴露了一个**JSON
    Web密钥集**（**JWKS**）（OpenID Connect发现标准的组成部分）的端点，这是一组包含资源服务器可以用来验证由授权服务器发行的JWT令牌的公钥的密钥。
- en: So, even if it isn't a full-blown OpenID Connect provider, it is suitable for
    use together with tests that we want to be able to run locally and in a fully
    automated manner.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使它不是一个完整的OpenID Connect提供者，它也适合与我们可以本地运行并完全自动化的测试一起使用。
- en: For more details on planned support for OAuth 2.0 in Spring Security, refer
    to [https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security](https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring Security中计划支持OAuth 2.0的更多详细信息，请参阅[https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security](https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security)。
- en: The authorization server in the Spring Security sample projects is available
    here: [https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver](https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security示例项目中，授权服务器可以在这里找到：[https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver](https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver)。
- en: The Spring Security sample project configures two OAuth clients, `reader` and
    `writer`, where the `reader` client is granted a read scope, and the `writer`
    client is granted both a read and a write scope. Both clients are configured to
    have the secret set to `secret`; refer to the `configure()` method in the `sample.AuthorizationServerConfiguration` class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security示例项目配置了两个OAuth客户端，`reader`和`writer`，其中`reader`客户端被授予了读取作用域，而`writer`客户端则被授权了读取和写入作用域。两个客户端都配置为将机密设置为`secret`；参考`sample.AuthorizationServerConfiguration`类中的`configure()`方法。
- en: 'The following changes have been applied to the sample project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改已应用于示例项目：
- en: A Eureka client has been added in the same way as for the other microservices.
    See [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery
    Using Netflix Eureka and Ribbon;* refer to the *Connecting microservices to a
    Netflix Eureka server* section.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经在与其它微服务相同的方式下添加了一个Eureka客户端。参见[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)，*使用Netflix
    Eureka和Ribbon添加服务发现；* 参考*将微服务连接到Netflix Eureka服务器*部分。
- en: Spring Boot Actuator has been added to get access to the `health` endpoint.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了Spring Boot Actuator以获取对`health`端点的访问。
- en: A Dockerfile has been added to be able to run the authorization server as a
    Docker container.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个Dockerfile，以便能够以Docker容器的形式运行授权服务器。
- en: The Gradle build file, `spring-security-samples-boot-oauth2authorizationserver.gradle`,
    has been changed to become more like the `build.gradle` files used in the source
    code of this book.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-samples-boot-oauth2authorizationserver.gradle`构建文件已更改为与本书源代码中使用的`build.gradle`文件更加相似。'
- en: 'The configuration in the `sample/AuthorizationServerConfiguration` class has
    been changed as follows:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample/AuthorizationServerConfiguration`类中的配置已经按照以下方式更改：'
- en: 'Support has been added for the grant types: `code`, `authorization_code`, and
    `implicit`.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经添加了对以下授权类型的支持：`code`、`authorization_code`和`implicit`。
- en: The names of the scopes, `message:read` and `message:write`, have been changed to
    `product:read` and `product:write`.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域的名称`message:read`和`message:write`已经被改成了`product:read`和`product:write`。
- en: The username of the user registered in the authorization server has been changed
    to `magnus`, with the password `password`; refer to the `userDetailsService()`
    method in the `UserConfig` class (found in the `sample/AuthorizationServerConfiguration.java` file).
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在授权服务器中注册的用户用户名已更改为`magnus`，密码为`password`；参考`UserConfig`类中的`userDetailsService()`方法（在`sample/AuthorizationServerConfiguration.java`文件中找到）。
- en: The source code for the authorization server is available in `$BOOK_HOME/Chapter11/spring-cloud/authorization-server`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器的源代码可以在`$BOOK_HOME/Chapter11/spring-cloud/authorization-server`中找到。
- en: 'To incorporate the authorization server in the system landscape, a number of
    changes have been applied. The authorization server has been added to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将授权服务器整合到系统景观中，已经应用了一系列更改。已将授权服务器添加到以下内容中：
- en: The common build file, `settings.gradle`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用的构建文件`settings.gradle`
- en: The three Docker Compose files, `docker-compose*.yml`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个Docker Compose文件`docker-compose*.yml`
- en: 'The edge server, `spring-cloud/gateway`:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器，`spring-cloud/gateway`：
- en: A health check has been added to `HealthCheckConfiguration`.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`HealthCheckConfiguration`中添加了一个健康检查。
- en: A route for URIs starting with `/oauth/` has been added.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个以`/oauth/`开头的URI路由。
- en: With an understanding of how a local authorization server is added to the system
    landscape, let's move on and see how we can protect external communication from eavesdropping
    using HTTPS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了如何在系统景观中添加一个本地授权服务器之后，让我们继续探讨如何使用HTTPS来保护外部通信免遭窃听。
- en: Protecting external communication with HTTPS
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTPS保护外部通信
- en: 'In this section, we will learn how to prevent eavesdropping on external communication,
    for example from the internet, via the public APIs exposed by the edge server. We
    will use HTTPS to encrypt communication. To use HTTPS, we need to do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何防止通过边缘服务器公开的公共API窃听外部通信，例如来自互联网的通信。我们将使用HTTPS来加密通信。要使用HTTPS，我们需要执行以下操作：
- en: '**Create a certificate**: We will create our own self-signed certificate, sufficient
    for development purposes.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建证书**：我们将创建自己的自签名证书，足够用于开发目的。'
- en: '**Configure the edge server**: It has to be configured to accept only HTTPS-based
    external traffic using the certificate.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置边缘服务器**：必须配置它只接受基于HTTPS的外部流量并使用证书。'
- en: 'The self-signed certificate is created with the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名的证书是通过以下命令创建的：
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The source code comes with a sample certificate file, so you don't need to run
    this command to run the following examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码附带一个示例证书文件，所以你不需要运行这个命令来运行以下示例。
- en: The command will ask for a number of parameters. When asked for a password,
    I entered `password`. For the rest of the parameters, I simply entered an empty
    value to accept the default value. The certificate file created, `edge.p12`, is
    placed in the `gateway` projects folder, `src/main/resources/keystore`. This means
    that the certificate file will be placed in the `.jar` file when it is built and
    will be available on the classpath in runtime at: `keystore/edge.p12`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将询问多个参数。当询问密码时，我输入了`password`。对于其他参数，我简单地输入了一个空值来接受默认值。创建的证书文件`edge.p12`放在`gateway`项目的`src/main/resources/keystore`文件夹中。这意味着当它被构建时，证书文件将被放在`.jar`文件中，并在运行时类路径上可用的位置：`keystore/edge.p12`。
- en: Providing certificates using the classpath is sufficient during development,
    but not applicable to other environments, for example, a production environment.
    The following shows how we can replace this certificate with an external certificate
    at runtime!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中使用类路径提供证书是足够的，但不适用于其他环境，例如生产环境。以下是如何在运行时用外部证书替换此证书的示例！
- en: 'To configure the edge server to use the certificate and HTTPS, the following
    is added to `application.yml` in the `gateway` project:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置边缘服务器使用证书和HTTPS，以下内容添加到`gateway`项目的`application.yml`中：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the explanations for the preceding source code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面源代码的解释：
- en: The path to the certificate is specified in the `server.ssl.key-store` parameter,
    and is set to the `classpath:keystore/edge.p12` value. This means that the certificate
    will be picked up on the classpath from the location, `keystore/edge.p12`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的路径在`server.ssl.key-store`参数中指定，设置为`classpath:keystore/edge.p12`的值。这意味着证书将从类路径上的位置`keystore/edge.p12`加载。
- en: The password for the certificate is specified in the `server.ssl.key-store-password` parameter.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的密码在`server.ssl.key-store-password`参数中指定。
- en: To indicate that the edge server talks HTTPS and not HTTP, we also change the
    port from `8080` to `8443` in the `server.port` parameter.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了指示边缘服务器使用HTTPS而不是HTTP，我们还在`server.port`参数中将端口从`8080`更改为`8443`。
- en: 'In addition to these changes in the edge server, changes are also required
    in the following files to reflect the changes to the port and HTTP protocol:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在边缘服务器中的这些更改外，还需要在以下文件中进行更改，以反映端口和HTTP协议的变化：
- en: The three Docker Compose files, `docker-compose*.yml`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个Docker Compose文件，`docker-compose*.yml`
- en: The test script, `test-em-all.bash`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试脚本，`test-em-all.bash`
- en: Providing certificates using the classpath is as already mentioned previously
    only sufficient during development; let's see how we can replace this certificate
    with an external certificate in runtime!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用类路径提供证书仅适用于开发；让我们看看我们如何在运行时用外部证书替换这个证书！
- en: Replacing a self-signed certificate in runtime
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时替换自签名证书
- en: Placing a self-signed certificate in the `.jar` file is only useful for development.
    For a working solution in runtime environments, for example, for test or production,
    it must be possible to use certificates signed by authorized **CAs** (short for
    **Certificate Authorities**).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将自签名证书放在`.jar`文件中仅适用于开发。对于运行时环境的工作解决方案，例如用于测试或生产，必须能够使用由授权**CA**（简称**证书颁发机构**）签名的证书。
- en: It must also be possible to specify the certificates to be used during runtime
    without the need to rebuild the `.jar` files and, when using Docker, the Docker
    image that contains the `.jar` file. When using Docker Compose to manage the Docker
    container, we can map a volume in the Docker container to a certificate that resides
    on the Docker host. We can also set up environment variables for the Docker container
    that points to the new certificate in the Docker volume.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还必须能够在不需要重新构建`.jar`文件的情况下指定在运行时使用的证书，并且在使用Docker时，能够在包含`.jar`文件的Docker镜像中指定证书。当使用Docker
    Compose管理Docker容器时，我们可以在Docker容器中映射一个卷到位于Docker宿主机上的证书。我们还可以为Docker容器设置环境变量，指向Docker卷中的新证书。
- en: In [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction to
    Kubernetes*, we will learn about Kubernetes, where we will see more powerful solutions
    for how to handle secrets, such as certificates, that are suitable for running
    Docker containers in a cluster; that is, where containers are scheduled on a group
    of Docker hosts and not on a single Docker host.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)，《Kubernetes简介》中，我们将学习Kubernetes，在那里我们将看到更适合在集群中运行Docker容器的处理秘密（如证书）的更强大解决方案；也就是说，容器调度在Docker宿主机的组上，而不是单个Docker宿主机上。
- en: The changes described in this topic have **not** been applied to the source
    code in the book's GitHub repository; that is, you need to make them yourself
    to see them in action!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题描述的更改没有应用到书籍GitHub仓库中的源代码中；也就是说，你需要亲自做出这些更改才能看到它们的作用！
- en: 'To replace the certificate packaged in the `.jar` file, perform the following
    steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换`.jar`文件中的证书，请执行以下步骤：
- en: 'Create a second certificate and set the password to `testtest`, when asked
    for it:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个证书，并将密码设置为`testtest`：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Update the Docker Compose file, `docker-compose.yml`, with environment variables
    for the location and password for the new certificate and a volume that maps to
    the folder where the new certificate is placed. The configuration of the edge
    server will look like the following after the change:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`docker-compose.yml`文件，用新的证书位置和密码以及映射到新证书放置文件夹的卷的环境变量。更改后，边缘服务器的配置将如下所示：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the edge server is up and running, it needs to be restarted with the following
    commands:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果边缘服务器正在运行，它需要使用以下命令重新启动：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `docker-compose restart gateway` command might look like a good candidate
    for restarting the `gateway` service, but it actually does not take changes in
    `docker-compose.yml` into consideration. Hence, it is not a useful command in
    this case.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose restart gateway`命令看起来像是重启`gateway`服务的不错选择，但实际上并没有考虑`docker-compose.yml`中的更改。因此，在这个情况下，它不是一个有用的命令。'
- en: The new certificate is now in use!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 新的证书现在正在使用中！
- en: This concludes the section on how to protect external communication with HTTPS.
    In the next section we will learn how to secure access to the discovery service,
    Netflix Eureka, using HTTP basic authentication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何使用HTTPS保护外部通信的内容。下一节我们将学习如何使用HTTP基本认证保护Netflix Eureka发现服务。
- en: Changes in the Eureka server
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eureka服务器的变化
- en: 'To protect the Eureka servers, the following changes have been applied:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护Eureka服务器，已经应用了以下更改：
- en: 'A dependency in `build.gradle` has been added to Spring Security:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.gradle`中添加了Spring Security依赖项：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Security configuration has been added to the `se.magnus.springcloud.eurekaserver.SecurityConfig` class:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`se.magnus.springcloud.eurekaserver.SecurityConfig`类中添加了安全配置：'
- en: 'The user is defined as follows:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义如下：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `username` and `password` are injected into the constructor from the configuration
    file:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`和`password`从配置文件中注入到构造函数中：'
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All APIs and web pages are protected using HTTP basic authentication by means
    of the following definition:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有API和网页都通过以下定义使用HTTP基本认证进行保护：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Credentials for the user are set up in the configuration file, `application.yml`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户凭据在配置文件`application.yml`中设置：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the test class, `se.magnus.springcloud.eurekaserver.EurekaServerApplicationTests`,
    uses the credentials from the configuration file when testing the APIs of the
    Eureka server:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试类`se.magnus.springcloud.eurekaserver.EurekaServerApplicationTests`在测试Eureka服务器的API时使用了配置文件中的凭据：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding are the steps required for restricting access to the APIs and
    web pages of the discovery server, Netflix Eureka. It will now use HTTP basic
    authentication and require a user to supply a username and password to get access. In
    the next section, we will learn how to configure Netflix Eureka clients so that
    they pass credentials when accessing the Netflix Eureka server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的是限制对发现服务器Netflix Eureka的API和网页访问所需的步骤，现在它将使用HTTP基本认证，并要求用户提供用户名和密码以获取访问权限。在下一节中，我们将学习如何配置Netflix
    Eureka客户端，以便在访问Netflix Eureka服务器时传递凭据。
- en: Changes in Eureka clients
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改Eureka客户端
- en: 'For Eureka clients, the credentials have to be specified in the connection
    URL for the Eureka server. This is specified in each client''s configuration file,
    `application.yml`, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Eureka客户端，凭据必须指定在Eureka服务器的连接URL中。这在每个客户端的配置文件`application.yml`中如下指定：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will see this configuration in use by Netflix Eureka clients when we test
    the secured system landscape in the *Testing with the local authorization server* section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Netflix Eureka客户端测试受保护的系统架构时看到这个配置的使用，在*使用本地授权服务器进行测试*一节中。
- en: In the next section, we will learn how to add credentials when we manually access
    the Netflix Eureka server, either using its API or its Web pages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在手动访问Netflix Eureka服务器时添加凭据，无论是使用其API还是其网页。
- en: Testing the protected Eureka server
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试受保护的Eureka服务器
- en: Once the protected Eureka server is up and running, we have to supply valid
    credentials to be able to access its APIs and web pages.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦受保护的Eureka服务器运行起来，我们必须提供有效的凭据，才能访问其API和网页。
- en: 'For example, asking the Eureka server for registered instances can be done
    by means of the following `curl` command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过以下`curl`命令向Eureka服务器请求注册实例：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A sample response is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例响应：
- en: '![](img/6d901aa7-4296-49ed-ba1d-eae67342dced.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d901aa7-4296-49ed-ba1d-eae67342dced.png)'
- en: 'When accessing the web page on `https://localhost:8443/eureka/web`, we first
    have to accept an insecure connection, since our certificate is self-signed, and
    next we have to supply valid credentials, as specified in the preceding configuration
    files:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问`https://localhost:8443/eureka/web`网页时，我们首先必须接受一个不安全的连接，因为我们的证书是自签名的，接下来我们必须提供有效的凭据，如前面配置文件中所指定：
- en: '![](img/e043650f-1b2b-479f-a3c6-57ff2aa0d767.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e043650f-1b2b-479f-a3c6-57ff2aa0d767.png)'
- en: 'Following a successful login, we will see the familiar web page from the Eureka
    server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，我们将看到Eureka服务器的熟悉网页：
- en: '![](img/46c6f213-a33d-4599-9fdf-9715968c6537.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46c6f213-a33d-4599-9fdf-9715968c6537.png)'
- en: This concludes the section on how to restrict access to the Netflix Eureka server.
    In the next section we will learn how to use OAuth 2.0 and OpenID Connect to authenticate
    and authorize access to APIs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节关于如何限制对Netflix Eureka服务器的访问就此结束。在下一节中，我们将学习如何使用OAuth 2.0和OpenID Connect对API的访问进行身份验证和授权。
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0和OpenID Connect对API访问进行身份验证和授权
- en: 'With the authorization server in place, we can enhance the edge server and
    the `product-composite` service so they become OAuth 2.0 resource servers; that
    is, they require a valid access token to allow access. We will configure the edge
    server to accept any access token it can validate using the signature provided
    by the authorization server. The `product-composite` service will also require
    the access token to contain some OAuth 2.0 scopes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在授权服务器就位之后，我们可以增强边缘服务器和`product-composite`服务，使它们成为OAuth 2.0资源服务器；也就是说，它们需要一个有效的访问令牌才能允许访问。我们将配置边缘服务器，接受任何可以使用授权服务器提供的签名验证的访问令牌。`product-composite`服务也将要求访问令牌包含一些OAuth
    2.0范围：
- en: The `product:read` scope will be required for accessing the read-only APIs.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product:read`范围将用于访问只读API。'
- en: The `product:write` scope will be required for accessing the create and delete
    APIs.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product:write`范围将用于访问创建和删除API。'
- en: We also need to enhance our test script, `test-em-all.bash`, so that it acquires
    access tokens before it runs the tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须增强我们的测试脚本，`test-em-all.bash`，以便在运行测试之前获取访问令牌。
- en: Changes in both the edge server and the product-composite service
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务器和product-composite服务的变化
- en: 'The following changes have been applied:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改已应用：
- en: 'Spring Security 5.1 dependencies have been added to `build.gradle` to support
    OAuth 2.0 resource servers:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.gradle`中已添加Spring Security 5.1依赖项，以支持OAuth 2.0资源服务器：'
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Security configurations have been added to the `se.magnus.springcloud.gateway.SecurityConfig`
    and `se.magnus.microservices.composite.product.SecurityConfig` classes:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经向`se.magnus.springcloud.gateway.SecurityConfig`和`se.magnus.microservices.composite.product.SecurityConfig`类添加了安全配置：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Explanations for the preceding source code are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面源代码的解释如下：
- en: '`.pathMatchers("/actuator/**").permitAll()` is used to allow access to URLs
    that should be unprotected, for example, the `actuator` endpoints in this case.
    Refer to the source code for URLs that are treated as unprotected. Be careful
    about which URLs are exposed unprotected. For example, the `actuator` endpoints
    should be protected before going to production:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.pathMatchers("/actuator/**").permitAll()`用于允许访问不应受保护的URL，例如，此处的`actuator`端点。参阅源代码以了解被视为不受保护的URL。小心哪些URL暴露为不受保护。例如，在上线之前，`actuator`端点应该受到保护：'
- en: '`.anyExchange().authenticated()` ensures that the user is authenticated before
    being allowed access to all other URLs.'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.anyExchange().authenticated()`确保在允许访问所有其他URL之前，用户已进行身份验证。'
- en: '`.oauth2ResourceServer().jwt()` specifies that authentication and authorization
    will be based on a JWT-encoded OAuth 2.0 access token.'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.oauth2ResourceServer().jwt()`指定基于JWT编码的OAuth 2.0访问令牌进行身份验证和授权。'
- en: 'The endpoint of the authorization server''s `jwk-set` endpoint has been registered
    in the configuration file, `application.yml`:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经在配置文件`application.yml`中注册了授权服务器的`jwk-set`端点的地址：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these changes applied to both the edge server and the `product-composite`
    service to make them act as OAuth 2.0 resource servers, we also need to make some
    changes that only apply to the `product-composite` service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使边缘服务器和`product-composite`服务作为OAuth 2.0资源服务器行动，我们对它们进行了这些更改，同时还需对仅适用于`product-composite`服务进行一些更改。
- en: Changes in the product-composite service
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品组合服务中的更改
- en: 'In addition to the common changes applied in the previous section, the following
    changes have also been applied to the `product-composite` service:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面部分应用的常见更改外，还向`product-composite`服务应用了以下更改：
- en: 'The security configuration has been refined by requiring OAuth 2.0 scopes in
    the access token in order to allow access:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经通过要求访问令牌中具有OAuth 2.0范围来细化安全配置，以允许访问：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By convention, OAuth 2.0 scopes should be prefixed with `SCOPE_` when checked
    for authority using Spring Security.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，在Spring Security中检查权限时，OAuth 2.0范围应前缀为`SCOPE_`。
- en: A method, `logAuthorizationInfo()`, has been added to log relevant parts from
    the JWT-encoded access token upon each call to the API. The access token can be
    acquired using the standard Spring Security, `SecurityContext`, which, in a reactive
    environment, can be acquired using the static helper method, `ReactiveSecurityContextHolder.getContext()`.
    Refer to the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class for
    details.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个方法，`logAuthorizationInfo()`，用于在每次调用API时记录JWT编码访问令牌的相关部分。可以使用标准Spring Security，`SecurityContext`获取访问令牌，在反应式环境中，可以使用静态帮助方法`ReactiveSecurityContextHolder.getContext()`获取。有关详细信息，请参阅`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl`类。
- en: 'The use of OAuth has been disabled when running Spring-based integration tests.
    To prevent the OAuth machinery from kicking in when we are running integration
    tests, we disable it as follows:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于Spring的集成测试中，已禁用了OAuth的使用。为了防止在运行集成测试时OAuth机制启动，我们按照如下方式禁用它：
- en: 'A security configuration, `TestSecurityConfig`, is added to be used during
    tests that permit access to all resources:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个安全配置`TestSecurityConfig`，用于在测试期间允许访问所有资源：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In each Spring integration test class, we configure `TestSecurityConfig` to
    override the existing security configuration with the following:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个Spring集成测试类中，我们配置了`TestSecurityConfig`以用以下内容覆盖现有的安全配置：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With these changes in place, both the edge server and the `product-composite`
    service can act as OAuth 2.0 resource servers. The last step we need to take to
    introduce the usage of OAuth 2.0 and OpenID Connect is to update the test script
    so it acquires access tokens and uses them when running the tests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改，边缘服务器和`product-composite`服务都可以作为OAuth 2.0资源服务器。为了引入OAuth 2.0和OpenID Connect的使用，我们需要采取的最后一步是更新测试脚本，使其在运行测试时获取访问令牌并使用它们。
- en: Changes in the test script
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试脚本中的更改
- en: 'To start with, we need to acquire an access token before we can call any of
    the APIs, except the health API. This is done using the OAuth 2.0 password flow.
    To be able to call the create and delete APIs, we acquire an access token as the
    `writer` client, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在调用任何API（除了健康API）之前获取访问令牌，这使用OAuth 2.0密码流完成。为了能够调用创建和删除API，我们以`writer`客户端的身份获取访问令牌，如下所示：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To verify that the scope-based authorization works, two tests have been added
    to the test script:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证基于范围的授权是否有效，在测试脚本中添加了两个测试：
- en: The first test calls an API without supplying an access token. The API is expected
    to return the 401 Unauthorized HTTP status.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试调用API时没有提供访问令牌。API预期返回401未授权HTTP状态。
- en: The other test calls an updating API using the `reader` client, which is only
    granted a read scope. The API is expected to return the 403 Forbidden HTTP status.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个测试使用`reader`客户端调用更新API，该客户端仅授予读取范围。API预期返回403禁止HTTP状态。
- en: 'For the full source code, see `test-em-all.bash`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅`test-em-all.bash`：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the test scripts updated to acquire and use OAuth 2.0 access tokens, we
    are ready to try them out in the next section!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 更新测试脚本以获取和使用OAuth 2.0访问令牌后，我们准备在下一节中尝试它们！
- en: Testing with the local authorization server
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地授权服务器进行测试
- en: 'In this section we will try out the secured system landscape; that is, we will
    test all the security components together. We will use the local authorization
    server to issue access tokens. The following tests will be performed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试使用受保护的系统环境；也就是说，我们将一起测试所有的安全组件。我们将使用本地授权服务器来发放访问令牌。以下测试将执行：
- en: First, we build from source and run the test script to ensure that everything
    fits together.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从源代码构建并运行测试脚本，以确保一切都能配合在一起。
- en: 'Next, we learn how to acquire access tokens using OAuth 2.0 grant flows: password,
    implicit, and code grant flows.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用OAuth 2.0授权流获取访问令牌：密码、隐式和代码授权流。
- en: Finally, we will use access tokens to call APIs. We will also verify that an
    access token issued for a reader client can't be used to call an updating API.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用访问令牌来调用API。我们还将验证，为读者客户端颁发的访问令牌不能用于调用更新API。
- en: Building and running the automated tests
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行自动化测试
- en: 'To build and run automated tests, we perform the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行自动化测试，我们执行以下步骤：
- en: 'First, build Docker images with the following commands:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令启动Docker中的系统环境并运行常规测试：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the new negative tests at the end that verify that we get a 401 Unauthorized
    code back when not authenticated, and 403 Forbidden when not authorized.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后的新增的负面测试，验证当我们没有认证时返回401未授权代码，以及当我们没有授权时返回403禁止。
- en: Acquiring access tokens
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取访问令牌
- en: 'Now we can acquire access tokens using the various grant flows defined by OAuth
    2.0\. We will try out the following grant flows: password, implicit, and code
    grant.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用OAuth 2.0定义的各种授权流来获取访问令牌。我们将尝试以下授权流：密码、隐式和代码授权。
- en: Acquiring access tokens using the password grant flow
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密码授权流获取访问令牌
- en: 'To get an access token for the `writer` client, that is, with both the `product:read` and `product:write` scopes,
    issue the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取`writer`客户端的访问令牌，即具有`product:read`和`product:write`范围的访问令牌，请发出以下命令：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The client identifies itself using HTTP basic authentication, passing its `writer`
    client ID, and its secret, `secret`. It sends the credentials of the resource
    owners, that is the end user, using the `username` and `password` parameters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用HTTP基本认证来标识自己，传递其`writer`客户端ID和其秘密`secret`。它使用`username`和`password`参数发送资源所有者的凭据，即终端用户。
- en: 'A sample response is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例响应：
- en: '![](img/aabd7ac5-4ce6-4f92-ae33-0393200e9116.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aabd7ac5-4ce6-4f92-ae33-0393200e9116.png)'
- en: 'Set the value of the `access_token` field in the response as the access token
    in an environment variable:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中将`access_token`字段的值设置为环境变量中的访问令牌：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get an access token for the `reader` client, that is, with only the `product:read`
    scope, simply replace `writer` with `reader` in the preceding command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`reader`客户端获取访问令牌，即只有`product:read`范围，只需在前面的命令中将`writer`替换为`reader`：
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Acquiring access tokens using the implicit grant flow
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐式授权流获取访问令牌
- en: 'To acquire an access token using the implicit grant flow, we need to involve
    a web browser. Open the URL in a web browser that accepts the use of self-signed
    certificates, for example, Chrome. Then perform the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用隐式授权流获取访问令牌，我们需要涉及一个网络浏览器。打开接受自我签名的证书的网络浏览器，例如Chrome。然后执行以下步骤：
- en: 'To get an access token for the `reader` client open the URL, `https://localhost:8443/oauth/authorize?response_type=token&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=48532`.
    When asked to login by the web browser, use the credentials specified in the configuration
    of the authorization server, for example, `magnus` and `password`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取`reader`客户端的访问令牌，请打开以下URL：`https://localhost:8443/oauth/authorize?response_type=token&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=48532`。当网络浏览器要求登录时，请使用授权服务器配置中指定的凭据，例如`magnus`和`password`：
- en: '![](img/8faa69da-b3b7-4720-90c3-894d5b351ca0.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8faa69da-b3b7-4720-90c3-894d5b351ca0.png)'
- en: 'Next, you will be asked to authorize the `reader` client to call the APIs in
    your name:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将被要求授权`reader`客户端以您的名义调用API：
- en: '![](img/db2552db-ce24-484a-9eae-48e8a08c4e70.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db2552db-ce24-484a-9eae-48e8a08c4e70.png)'
- en: 'Finally, we will get the following response:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将得到以下响应：
- en: '![](img/fedc6ade-fe6a-4abb-839d-c654eea7bd1f.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fedc6ade-fe6a-4abb-839d-c654eea7bd1f.png)'
- en: 'This might, at first glance, look a bit disappointing. The URL that the authorization
    server sent back to the web browser is based on the redirect-URI specified by
    the client in the initial request. Copy the URL into a text editor and you will
    find something similar to the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能乍一看有点令人失望。授权服务器返回给网络浏览器的URL基于客户端在初始请求中指定的重定向-URI。将URL复制到文本编辑器中，您会发现类似于以下内容的东西：
- en: '`http://my.redirect.uri/#access_token=eyJh...C8pw&token_type=bearer&state=48532&expires_in=599999999&jti=8956b38b-36ea-4888-80dc-685b49f20f91`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://my.redirect.uri/#access_token=eyJh...C8pw&token_type=bearer&state=48532&expires_in=599999999&jti=8956b38b-36ea-4888-80dc-685b49f20f91`'
- en: Great! We can find the access token in the new URL in the `access_token` request
    parameter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们可以在新URL中的`access_token`请求参数中找到访问令牌。
- en: 'Save the access token in an environment variable, as shown:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将访问令牌保存到环境变量中，如下所示：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To get an access token for the `writer` client, you can use the following URL:
    `https://localhost:8443/oauth/authorize?response_type=token&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=95372`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取`writer`客户端的访问令牌，您可以使用以下URL：`https://localhost:8443/oauth/authorize?response_type=token&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=95372`。
- en: You are already authenticated, so you do not need to log in again, but you must
    give your consent to the `writer` client.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经认证，因此不需要再次登录，但您必须给予`writer`客户端同意。
- en: Note that no client secret is required; that is, the implicit grant flow is
    not very secure.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不需要客户端密钥；也就是说，隐式授权流并不非常安全。
- en: Any application can claim that it is the `writer` client and can ask for the
    user's consent to use the requested scopes to access APIs in the name of the user,
    so beware!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序都可以声称它是`writer`客户端，并可以要求用户同意使用请求的范围以用户的身份访问API，所以要小心！
- en: Acquiring access tokens using the code grant flow
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码授权流获取访问令牌
- en: Finally, let's try out the most secure grant flow in OAuth 2.0 – the code grant
    flow!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试OAuth 2.0中最安全的授权流——代码授权流！
- en: When it comes to the code grant flow, things are a bit more complicated in order
    to make the flow more secure. In the first insecure step, we will use the web
    browser to acquire a code that can be used only once, when it is exchanged with
    an access token. The code shall be passed from the web browser to a secure layer,
    for example, server-side code, which can make a new request the authorization
    server again to exchange the code with an access token. In this exchange, the
    server has to supply a client secret to verify its origin.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 至于代码授权流，为了使流程更加安全，事情变得有点复杂。在第一个不安全步骤中，我们将使用网络浏览器获取一个只能使用一次的代码，当它与访问令牌交换时。代码应从网络浏览器传递到安全层，例如服务器端代码，它可以再次向授权服务器发起新请求以交换代码和访问令牌。在此交换中，服务器必须提供客户端密钥以验证其来源。
- en: To get a code for the `reader` client, use the following URL in the web browser: `https://localhost:8443/oauth/authorize?response_type=code&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=35725`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取`reader`客户端的代码，请在网络浏览器中使用以下URL：`https://localhost:8443/oauth/authorize?response_type=code&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=35725`。
- en: This time, you will get back a much shorter URL, for example, `http://my.redirect.uri/?code=T2pxvW&state=72489`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你将得到一个更短的URL，例如，`http://my.redirect.uri/?code=T2pxvW&state=72489`。
- en: 'Extract the authorization code from the `code` parameter and define an environment
    variable, `CODE`, with its value:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从`code`参数中提取授权代码，并定义一个名为`CODE`的环境变量，其值为它的值：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, pretend you are the backend server that exchanges the authorization code
    with an access token using the following `curl` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设你是后端服务器，使用以下`curl`命令将授权代码与访问令牌进行交换：
- en: '[PRE29]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A sample response is as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 示例响应如下：
- en: '![](img/b06c2376-bab9-452d-8081-fce44ce0b426.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b06c2376-bab9-452d-8081-fce44ce0b426.png)'
- en: 'Finally, save the access token in an environment variable as previously:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像之前一样将访问令牌保存到环境变量中：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To get a code for the `writer` client, use the following URL: `https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=72489`[.](https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=message:read+message:write&state=72489)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取`writer`客户端的代码，请使用以下URL：`https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=72489`[.](https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=message:read+message:write&state=72489)
- en: Calling protected APIs using access tokens
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问令牌调用受保护的API
- en: Now, let's use the access tokens we have acquired to call the protected APIs!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们已经获取的访问令牌来调用受保护的API！
- en: 'First, call an API to retrieve a composite product without a valid access token:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调用一个API来检索没有有效访问令牌的复合产品：
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It should return the following response:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该返回以下响应：
- en: '![](img/a11b7747-9134-464d-956b-8d9ea3ee632b.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a11b7747-9134-464d-956b-8d9ea3ee632b.png)'
- en: The error message clearly states that the access token is invalid!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息清楚地指出访问令牌无效！
- en: 'Next, try using the API to retrieve a composite product using one of the access
    tokens acquired for the `reader` client from the previous section:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试使用API检索复合产品，使用之前为`reader`客户端获取的其中一个访问令牌：
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we will get the `200 OK` status code and the expected response body will
    be returned:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将得到`200 OK`状态码，并将返回预期的响应体：
- en: '![](img/35945d10-f681-4265-99d7-8c71e352e889.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35945d10-f681-4265-99d7-8c71e352e889.png)'
- en: 'If we try to access an updating API, for example, the delete API, with an access
    token acquired for the `reader` client, the call will fail:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用为`reader`客户端获取的访问令牌访问更新API，例如删除API，调用将失败：
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It will fail with a response similar to the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它将失败，响应类似于以下内容：
- en: '![](img/41ac8596-5ddd-4a60-a2f4-48f0ec0e69e9.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41ac8596-5ddd-4a60-a2f4-48f0ec0e69e9.png)'
- en: If we repeat the call to the delete API, but with an access token acquired for
    the `writer` client, the call will succeed with 200 OK in the response.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复调用删除API，但使用的是为`writer`客户端获取的访问令牌，那么调用将成功，响应为200 OK。
- en: The delete operation should return `200` even if the product with the specified
    product ID does not exist in the underlying database, since the delete operation
    is idempotent, as described in [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*. Refer to the *Adding new APIs* section.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作即使 underlying database 中不存在具有指定product ID的产品，也应该返回`200`，因为删除操作如[第6章](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml)中所述，是幂等的，*添加持久性*。参考*添加新API*部分。
- en: 'If you look into the log output using the `docker-compose logs -f product-composite` command, you
    should be able to find authorization information such as the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`docker-compose logs -f product-composite`命令查看日志输出，你应该能够找到如下授权信息：
- en: '![](img/fa8061ea-8387-4bda-b2bd-ad5bab5f2230.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa8061ea-8387-4bda-b2bd-ad5bab5f2230.png)'
- en: This information was extracted by the new method, `logAuthorizationInfo()`,
    in the `product-composite` service from the JWT-encoded access token; that is,
    the `product-composite` service did not need to communicate with the authorization
    server to get this information!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息是通过`product-composite`服务中的新方法`logAuthorizationInfo()`从JWT编码的访问令牌中提取的；也就是说，`product-composite`服务不需要与授权服务器通信就能获取这些信息！
- en: With these tests, we have seen how to acquire an access token with the various
    grant flows, that is, password, implicit, and code grant flow. We have also seen
    how scopes can be used to limit what a client can do with a specific access token,
    for example only use is for reading operations.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试，我们看到了如何使用各种授权流获取访问令牌，即密码、隐式和代码授权流。我们还看到了如何使用范围来限制客户端可以使用特定访问令牌执行的操作，例如只用于阅读操作。
- en: In the next section, we will replace the local authorization server used in
    this section to an external OpenID Connect provider.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将用外部OpenID Connect提供商替换本节中使用的本地授权服务器。
- en: Testing with an OpenID Connect provider – Auth0
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenID Connect提供商进行测试 - Auth0
- en: So, the OAuth dance works fine with an authorization server we control ourselves.
    But what happens if we replace it with a certified OpenID Connect provider? In
    theory, it should work out of the box. Let's find out, shall we?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，与我们自己控制的授权服务器一起，OAuth舞蹈运行良好。但如果我们用一个认证的OpenID Connect提供商来替换它呢？从理论上讲，它应该可以即插即用。让我们来找出答案，好吗？
- en: 'For a list of certified implementations of OpenID Connect, refer to [https://openid.net/developers/certified/](https://openid.net/developers/certified/).
    We will use Auth0, [https://auth0.com/](https://auth0.com/), for our tests with
    an OpenID provider. To be able to use Auth0 instead of our own authorization server,
    we will go through the following topics:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看OpenID Connect的认证实现列表，请参阅[https://openid.net/developers/certified/](https://openid.net/developers/certified/)。我们将使用Auth0进行OpenID提供者的测试。[https://auth0.com/](https://auth0.com/)。为了能够使用Auth0而不是我们自己的授权服务器，我们将讨论以下主题：
- en: Setting up an account with an OAuth client and a user in Auth0
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Auth0中设置带有OAuth客户端和用户的账户
- en: Applying the changes required to use Auth0 as an OpenID provider and running
    the test script to verify whether it is working
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用所需更改以使用Auth0作为OpenID提供商并运行测试脚本来验证它是否正常工作
- en: 'Acquiring access tokens using the following:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下方法获取访问令牌：
- en: Password grant flow
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码授权流
- en: Implicit grant flow
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式授权流
- en: Authorization code grant flow
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权代码授权流
- en: Calling protected APIs using the access tokens.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问令牌调用受保护的API。
- en: Using the **user info** endpoint to get more information about a user.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**用户信息**端点获取有关用户的更多信息。
- en: Let us understand each of them in the following sections.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的章节中理解每一个概念。
- en: Setting up an account and OAuth 2.0 client in Auth0
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Auth0中设置账户和OAuth 2.0客户端
- en: 'Perform the following steps to sign up for a free account in Auth0, configure
    both an OAuth 2.0 client and the `product-composite` API, and finally register
    a user:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在Auth0中注册免费账户，配置OAuth 2.0客户端和`product-composite` API，最后注册用户：
- en: Open the URL, [https://auth0.com](https://auth0.com), in your browser.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开URL，[https://auth0.com](https://auth0.com)。
- en: 'Click on the SIGN UP button:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击SIGN UP按钮：
- en: Sign up with an account of your choice.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的账户注册。
- en: After a successful sign-up, you will be asked to create a tenant domain.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册成功后，您将被要求创建一个租户域。
- en: Enter the name of the tenant of your choice, in my case: `dev-ml.eu.auth0.com`.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入您选择的租户名称，在我的情况下：`dev-ml.eu.auth0.com`。
- en: Fill in information about your account as requested.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写有关您账户的信息。
- en: Following sign-up, you will be directed to your dashboard. Select the Applications
    tab (on the left) to see the default client application that was created for you
    during the sign-up process.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册后，您将被引导到您的仪表板。在左侧选择应用程序标签，以查看在注册过程中为您创建的默认客户端应用程序。
- en: 'Click on the Default App to configure it:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击默认应用进行配置：
- en: Copy the Client ID and Client Secret; you will need them later on.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`Client ID`和`Client Secret`；稍后您需要它们。
- en: As Application Type, select Machine to Machine.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为应用程序类型，选择机器对机器。
- en: As Token Endpoint Authentication Method, select POST.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为令牌端点认证方法，选择POST。
- en: Enter `http://my.redirect.uri` as the allowed callback URL.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`http://my.redirect.uri`作为允许的回调URL输入。
- en: Click on Show Advanced Settings, go to the Grant Types tab, deselect Client
    Credentials, and select the Password box.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示高级设置，转到授权类型标签，取消选中客户端凭据，选择密码框。
- en: Click on SAVE CHANGES.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击SAVE CHANGES。
- en: 'Now define authorizations for our API:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为我们的API定义授权：
- en: Click on the APIs tab (on the left) and click on the + CREATE API button.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的APIs标签，然后点击+ CREATE API按钮。
- en: Name the API `product-composite`, give it the identifier `https://localhost:8443/product-composite`,
    and click on the CREATE button.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将API命名为`product-composite`，给它一个标识符`https://localhost:8443/product-composite`，然后单击CREATE按钮。
- en: Click on the Permissions tab and create two permissions (that is, OAuth scopes)
    for `product:read` and `product:write`.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“权限”标签页，为`product:read`和`product:write`创建两个权限（即，OAuth范围）。
- en: 'Next, create a user:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个用户：
- en: Click on the Users & Roles and -> Users tab (on the left) and then on the +
    CREATE YOUR FIRST USER button.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“用户与角色”->“用户”标签页（在左侧），然后点击“创建您的第一个用户”按钮。
- en: Enter an `email` and `password` of your preference and click on the SAVE button.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您喜欢的`email`和`password`，然后点击“保存”按钮。
- en: Look for a verification mail from Auth0 in the Inbox for the email address you
    supplied.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找Auth0发送到您提供的电子邮件地址的邮箱中的验证邮件。
- en: 'Finally, validate your Default Directory setting, used for the password grant
    flow:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，验证用于密码授予流的默认目录设置：
- en: Click on your tenant profile in the upper-right corner and select Settings.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的上传箭头旁边的租户配置文件，选择设置。
- en: In the tab named General, scroll down to the field named Default Directory and
    verify that it contains the `Username-Password-Authentication` value. If not,
    update the field and save the change.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为“常规”的标签页中，滚动到名为“默认目录”的字段，并验证它包含`Username-Password-Authentication`值。如果没有，更新字段并保存更改。
- en: That's it! Note that both the default app and the API get a client ID and secret.
    We will use the client ID and secret for the default app; that is, the OAuth client.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这么多！请注意，默认应用和API都获得一个客户端ID和一个秘密。我们将使用默认应用的客户端ID和秘密；即OAuth客户端。
- en: With an Auth0 account created and configured we can move on and apply the necessary
    configuration changes in the system landscape.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并配置了Auth0账户后，我们可以继续在系统架构中应用必要的配置更改。
- en: Applying the necessary changes to use Auth0 as an OpenID provider
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将必要的更改应用于使用Auth0作为OpenID提供者
- en: In this section we will learn what configuration changes are required to be
    able to replace the local authorization server with Auth0\. We only need to change
    the configuration for the two services that act as OAuth resource servers, the
    `product-composite`, and the `gateway` services. We also need to change our test
    script a bit, so that it acquires the access tokens from Auth0 instead of from
    our local authorization server. Let's start with the OAuth resource servers, that
    is, the `product-composite` and the `gateway` services.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习需要进行哪些配置更改，才能用Auth0替换本地授权服务器。我们只需要更改作为OAuth资源服务器的两个服务的配置，即`product-composite`和`gateway`服务。我们还需要稍微更改测试脚本，以便它从Auth0获取访问令牌，而不是从我们的本地授权服务器获取。让我们从OAuth资源服务器开始，即`product-composite`和`gateway`服务。
- en: The changes described in this topic have **not** been applied to the source
    code in the book's Git repository; that is, you need to make them yourself to
    see them in action!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题中描述的更改**尚未**应用于书中Git仓库中的源代码；也就是说，您需要自己进行这些更改以亲眼看到它们的作用！
- en: Changing the configuration in the OAuth resource servers
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OAuth资源服务器中更改配置
- en: When using an OpenID Connect provider, we only have to configure the base URI
    to the standardized discovery endpoint in the OAuth resource servers, that is,
    the `product-composite` and the `gateway` service. Spring Security will use the
    information in the response from the discovery endpoint to configure the resource
    server.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用OpenID Connect提供者时，我们只需要在OAuth资源服务器中配置基础URI到标准的发现端点，即`product-composite`和`gateway`服务。Spring
    Security将使用来自发现端点的响应中的信息来配置资源服务器。
- en: 'In the `product-composite` and `gateway` projects, make the following change
    to the `resource/application.yml` file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`product-composite`和`gateway`项目中，对`resource/application.yml`文件进行以下更改：
- en: 'Now find the following property setting:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在找到以下属性设置：
- en: '[PRE34]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Replace it with:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换：
- en: '[PRE35]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Note**: Replace `${TENANT_DOMAIN_NAME}` in the preceding configuration with
    your tenant domain name; in my case, it is `dev-ml.eu.auth0.com`, and do not forget
    the trailing `/`!'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：用您的租户域名替换前一个配置中的`${TENANT_DOMAIN_NAME}`；在我的情况下，它是`dev-ml.eu.auth0.com`，不要忘记结尾的`/`！'
- en: 'If you are curious, you can see what''s in the discovery document by running
    the following command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，可以通过运行以下命令查看发现文档中的内容：
- en: '`curl https://${TENANT_DOMAIN_NAME}/.well-known/openid-configuration -s | jq`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl https://${TENANT_DOMAIN_NAME}/.well-known/openid-configuration -s | jq`'
- en: 'Rebuild the `product-composite` and `gateway` services as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式重新构建`product-composite`和`gateway`服务：
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the `product-composite` and the `gateway` service updated, we can move
    on and also update the test script.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了`product-composite`和`gateway`服务后，我们还可以继续更新测试脚本。
- en: Changing the test script so it acquires access tokens from Auth0
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改测试脚本以从Auth0获取访问令牌
- en: We also need to update the test script so it acquires access tokens from the
    Auth0 OIDC provider. This is done by performing the following changes in `test-em-all.bash`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新测试脚本，使其从Auth0 OIDC提供者获取访问令牌。这可以通过在`test-em-all.bash`中执行以下更改来实现。
- en: 'Take the following command:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令：
- en: '[PRE37]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace it with this command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下命令替换它：
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, replace `${TENANT_DOMAIN_NAME}`, `${USER_EMAIL}`, `${USER_PASSWORD}`,
    `${CLIENT_ID}`, and `${CLIENT_SECRET}` in the preceding command with the values
    you collected during the registration process in Auth0, as described previously.
    Then, take the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用之前在Auth0注册过程中收集的值替换`${TENANT_DOMAIN_NAME}`、`${USER_EMAIL}`、`${USER_PASSWORD}`、`${CLIENT_ID}`和`${CLIENT_SECRET}`，然后使用以下命令：
- en: '[PRE39]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Replace it with this command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下命令替换它：
- en: '[PRE40]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Apply the preceding changes to the command. Also note that we only require the
    `product:read` scope and not the `product:write` scope. This is to simulate a
    client with read-only access.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的更改应用到命令中。同时注意我们只要求`product:read`作用域，而不需要`product:write`作用域。这是为了模拟只具有读取权限的客户端。
- en: Now access tokens are issued by Auth0 instead of our local authorization server,
    and our API implementations can verify that the access tokens (have been correctly
    signed by Auth0 and have not expired), using information from Auth0's discovery
    service flagged in the `application.yml` files. The API implementations can, as
    before, use the scopes in the access tokens to authorize the client to perform
    the call to the API, or not.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问令牌是由Auth0签发，而不是我们的本地授权服务器，我们的API实现可以验证访问令牌（是否由Auth0正确签名且未过期），使用`application.yml`文件中标记的Auth0发现服务提供的信息。与之前一样，API实现可以使用访问令牌中的作用域来授权客户端调用API或不允许调用。
- en: Now we have all the required changes in place, let's run some tests to verify
    that we can acquire access tokens from Auth0.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实施了所有必需的更改，让我们运行一些测试来验证我们是否可以从Auth0获取访问令牌。
- en: Running the test script with Auth0 as the OpenID Connect provider
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Auth0作为OpenID Connect提供者运行测试脚本
- en: Now, we are ready to give Auth0 a try!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备尝试Auth0！
- en: 'Run the usual tests against Auth0 with the following command:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令对Auth0进行常规测试：
- en: '[PRE41]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the logs (using the `docker-compose logs -f product-composite` command), you
    will be able to find authorization information from the access tokens issued by
    Auth0:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中（使用`docker-compose logs -f product-composite`命令），你将能够找到Auth0签发的访问令牌的授权信息：
- en: 'From calls using an access token with both the `product:read` and `product:write`
    scopes, we will see that both scopes are listed as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同时带有`product:read`和`product:write`作用域的访问令牌时，我们会看到两个作用域都按如下列出：
- en: '![](img/9c98cb07-9e00-4611-8c25-0db0aa384d1d.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c98cb07-9e00-4611-8c25-0db0aa384d1d.png)'
- en: 'From calls using an access token with only the `product:read` scope, we will
    see that only that scope is listed as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用带有`product:read`作用域的访问令牌时，我们会看到只列出该作用域如下：
- en: '![](img/568e2fc6-35fa-43e1-8247-1d2b9cad167f.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](img/568e2fc6-35fa-43e1-8247-1d2b9cad167f.png)'
- en: As we can see from the log output, we now get information regarding the intended
    audience for this access token. To strengthen security, we could add a test to
    our service that verifies that its URL, `https://localhost:8443/product-composite`
    in this case, is part of the audience list. This would prevent the situation where
    someone tries to use an access token issued for another purpose to get access
    to our API.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志输出中，我们可以看到我们现在得到了关于这个访问令牌打算面向的受众的信息。为了加强安全，我们可以在我们的服务中添加一个测试，验证其URL，在本例中为`https://localhost:8443/product-composite`，是否是受众列表的一部分。这将防止有人尝试使用为其他目的签发的访问令牌来获取对我们的API的访问。
- en: With the automated tests working together with Auth0, we can move on and learn
    how to acquire access tokens using the different types of grant flow. Let's start
    with the password grant flow.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 有了与Auth0集成的自动化测试，我们可以继续学习如何使用不同类型的授权流获取访问令牌。让我们从密码授权流开始。
- en: Acquiring access tokens using the password grant flow
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密码授权流获取访问令牌
- en: In this section we will learn how to acquire an access token from Auth0 using
    the password grant flow.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用密码授权流从Auth0获取访问令牌。
- en: 'If you want to acquire an access token from Auth0 yourself, you can do so by
    running the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己想要从Auth0获取访问令牌，你可以通过运行以下命令来实现：
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Following the instruction in the *Calling protected APIs using the access tokens* section, you
    should be able to call the APIs using the acquired access token. The next grant
    flow we'll try out is the implicit grant flow.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*使用访问令牌调用受保护的API*节中的说明，你应该能够使用获取的访问令牌调用API。我们接下来要尝试的授权流程是隐式授权流程。
- en: Acquiring access tokens using the implicit grant flow
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐式授权流程获取访问令牌
- en: In this section, we will learn how to acquire an access token from Auth0 using
    the implicit grant flow.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用隐式授权流程从Auth0获取访问令牌。
- en: 'If you want to try out the more involved implicit grant flow, you can open
    the following URL in a web browser:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试更复杂的隐式授权流程，你可以在网页浏览器中打开下面的链接：
- en: '[PRE43]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Replace `${TENANT_DOMAIN_NAME}` and `${CLIENT_ID}` in the preceding URL with
    the tenant domain name and client ID you collected during the registration process
    in Auth0 as described previously.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面URL中的`${TENANT_DOMAIN_NAME}`和`${CLIENT_ID}`替换为你在Auth0注册过程中收集的租户域名和客户端ID。
- en: 'Let''s have a look at the following steps:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Auth0 should present the following login screen:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Auth0应该显示以下登录屏幕：
- en: '![](img/51fa7e05-b536-4ae8-8108-403cb016fa7f.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51fa7e05-b536-4ae8-8108-403cb016fa7f.png)'
- en: 'Following a successful login, Auth0 will ask you to give the client application
    your consent:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录成功后，Auth0会要求你给予客户端应用程序你的同意：
- en: '![](img/88af32b9-cb29-4cea-afba-1e337b85d14f.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88af32b9-cb29-4cea-afba-1e337b85d14f.png)'
- en: 'The access token is now in the URL in the browser, just like when we tried
    out the implicit flow in our local authorization server:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌现在在浏览器中的URL里，就像我们在本地授权服务器中尝试隐式流程时一样：
- en: '![](img/2124688f-d39d-431b-982b-6f5f786ac8d7.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2124688f-d39d-431b-982b-6f5f786ac8d7.png)'
- en: To get an access token that corresponds to the `reader` client, remove the `product:write` scope from
    the preceding URL that we used to initiate the implicit grant flow.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取对应于`reader`客户端的访问令牌，需要从前面的URL中移除`product:write`范围，这个URL是我们用来启动隐式授权流程的。
- en: Now that we know how to acquire an access token using the implicit grant flow,
    we can move on to the third and last grant flow that we will try out, the authorization
    code grant flow.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何使用隐式授权流程获取访问令牌，我们可以继续尝试第三个也是最后一个授权流程，即授权码授权流程。
- en: Acquiring access tokens using the authorization code grant flow
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用授权码授权流程获取访问令牌
- en: 'Finally, we come to the most secure grant flow – the authorization code grant
    flow. We will follow the same procedure as with the local authorization server;
    that is, we first acquire code and then exchange it for an access token. Get the
    code by opening the following URL in a web browser, as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了最安全的授权流程——授权码授权流程。我们将遵循与本地授权服务器相同的程序；也就是说，我们首先获取代码，然后用它来换取访问令牌。通过在网页浏览器中打开下面的链接来获取代码，如下所示：
- en: '[PRE44]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Replace `${TENANT_DOMAIN_NAME}` and `${CLIENT_ID}` in the preceding URL with
    the tenant domain name and client ID you collected during the registration process
    in Auth0 as described previously.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面URL中的`${TENANT_DOMAIN_NAME}`和`${CLIENT_ID}`替换为你在Auth0注册过程中收集的租户域名和客户端ID。
- en: 'Expect a redirect attempt in the web browser to a URL as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 期望在网页浏览器中会尝试重定向到一个如下所示的URL：
- en: '[PRE45]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Extract the code and run the following command to get the access token:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 提取代码并运行以下命令以获取访问令牌：
- en: '[PRE46]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replace `${TENANT_DOMAIN_NAME}`, `${CLIENT_ID}`, `${CLIENT_SECRET}`, and `${CODE}` in
    the preceding URL with the tenant domain name, client ID, and the client code
    you collected during the registration process in Auth0 as described previously.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面URL中的`${TENANT_DOMAIN_NAME}`、`${CLIENT_ID}`、`${CLIENT_SECRET}`和`${CODE}`替换为你在Auth0注册过程中收集的租户域名、客户端ID和客户端密钥。
- en: Now that we have learned how to acquire access tokens using all three types
    of grant flows, we are ready to try calling the external API using an access token
    acquired from Auth0 in the next section.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经学会了使用三种类型的授权流程获取访问令牌，我们准备在下一节中尝试使用从Auth0获取的访问令牌调用外部API。
- en: Calling protected APIs using the Auth0 access tokens
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Auth0访问令牌调用受保护的API
- en: In this section, we will see how we can use an access token acquired from Auth0
    to call the external API.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用从Auth0获取的访问令牌调用外部API。
- en: We can use access tokens issued by Auth0 to call our APIs  just like when we
    used access tokens issued by our local authorization server.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Auth0发行的访问令牌来调用我们的API，就像我们之前使用本地授权服务器发行的访问令牌一样。
- en: 'For a read-only API, execute the following command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只读API，执行以下命令：
- en: '[PRE47]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For an updating API, execute the following command:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更新的API，执行以下命令：
- en: '[PRE48]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we have requested both scopes, `product:read` and `product:write`, both
    the preceding API calls are expected to return 200 OK.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们请求了两个范围，`product:read`和`product:write`，所以预计前面的API调用都会返回200 OK。
- en: Getting extra information about the user
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取关于用户的其他信息
- en: As you can see in the log output, the ID of the subject, that is, the user,
    is a bit cryptic, for example, `auth0|5ca0b73c97f31e11bc85a5e6`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在日志输出中看到的，主题（即用户）的ID有点难以理解，例如，`auth0|5ca0b73c97f31e11bc85a5e6`。
- en: 'If you want your API implementation to know a bit more about the user, it can
    call Auth0''s `userinfo_endpoint` as described in the response to the discovery
    request made previously:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要你的API实现了解更多关于用户的信息，它可以调用Auth0的`userinfo_endpoint`，如前所述的发现请求的响应：
- en: '[PRE49]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Replace `${TENANT_DOMAIN_NAME}` in the preceding command with the tenant domain
    name you collected during the registration process in Auth0 as described previously.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中将`${TENANT_DOMAIN_NAME}`替换为你之前在Auth0注册过程中收集的租户域名。
- en: 'A sample response is as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例响应：
- en: '![](img/85766cca-2c09-4b6a-9ead-a450d32154af.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85766cca-2c09-4b6a-9ead-a450d32154af.png)'
- en: This endpoint can also be used to verify that the user hasn't revoked the access
    token in Auth0.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点还可以用于验证用户是否在Auth0中撤销了访问令牌。
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令关闭系统架构，结束测试：
- en: '[PRE50]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This concludes the section where we have learned how to replace the local OAuth
    2.0 Authorization server, only used for tests, with an external alternative. We
    have also seen how to reconfigure the microservice landscape to validate access
    tokens using an external OIDC provider.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们已经学会了如何用一个外部的替代品替换掉只用于测试的本地OAuth 2.0授权服务器。我们还看到了如何重新配置微服务架构，使用外部的OIDC提供者来验证访问令牌。
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to use Spring Security to protect our APIs.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Spring Security保护我们的API。
- en: We have seen how easy it is to enable HTTPS to prevent eavesdropping by third
    parties using Spring Security. With Spring Security, we have also learned that
    it is straightforward to restrict access and the discovery server, Netflix Eureka,
    using HTTP basic authentication. Finally, we have seen how we can use Spring Security
    to simplify the use of OAuth 2.0 and OpenID Connect to allow third-party client
    applications to access our APIs in the name of a user, but without requiring that
    the user share credentials with the client application. We have learned both how
    to set up a local OAuth 2.0 authorization server based on Spring Security and
    also how to change the configuration so that an external OpenID Connect provider,
    Auth0, can be used instead.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过Spring Security启用HTTPS来防止第三方监听。通过Spring Security，我们还了解到，限制访问和发现服务器Netflix
    Eureka非常简单，使用HTTP基本认证。最后，我们看到了如何使用Spring Security简化OAuth 2.0和OpenID Connect的使用，允许第三方客户端应用程序以用户的名义访问我们的API，而无需要求用户与客户端应用程序共享凭据。我们已经学习了如何基于Spring
    Security设置本地OAuth 2.0授权服务器，以及如何更改配置，以便使用外部的OpenID Connect提供者Auth0。
- en: One concern, however, is how to manage the configuration required. Many small
    pieces of configuration must be set up for the microservices involved and the
    configuration must be synchronized to match. Added to the scattered configuration
    is the fact that some of the configuration contains sensitive information, such
    as credentials or certificates. It seems like we need a better way to handle the
    configuration for a number of cooperating microservices and also a solution for
    how to handle sensitive parts of the configuration.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个关注点是如何管理所需的配置。对于涉及其中的微服务，必须设置许多小的配置项，并且这些配置必须同步以匹配。除了分散的配置之外，还有一些配置包含敏感信息，例如凭据或证书。看来我们需要一种更好的方法来处理多个协作微服务的配置，同时也需要一个解决方案来处理配置中的敏感部分。
- en: In the next chapter, we will explore the Spring Cloud Configuration server and
    see how it can be used to handle these types of requirement.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Spring Cloud Configuration服务器，并了解如何使用它来处理这些类型的需求。
- en: Questions
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the benefits and shortcomings of using self-signed certificates?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自签名证书的好处和缺点是什么？
- en: What is the purpose of OAuth 2.0 authorization codes?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth 2.0授权码的目的是什么？
- en: What is the purpose of OAuth 2.0 scopes?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是OAuth 2.0范围的目的？
- en: What does it mean when a token is a JWT token?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个令牌是一个JWT令牌时，这意味着什么？
- en: How can we trust the information that is stored in a JWT token?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何信任存储在JWT（JSON Web Token）令牌中的信息？
- en: Is it suitable to use the OAuth 2.0 authorization code grant flow with a native
    mobile app?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于原生移动应用，使用OAuth 2.0授权码授权流是否合适？
- en: What does OpenID Connect add to OAuth 2.0?
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开放ID连接（OpenID Connect）为OAuth 2.0增加了什么？
