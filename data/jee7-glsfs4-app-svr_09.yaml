- en: Chapter 9. Securing Java EE Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：保护 Java EE 应用程序
- en: In this chapter, we will cover how to secure Java EE applications by taking
    advantage of GlassFish's built-in security features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何通过利用 GlassFish 的内置安全功能来保护 Java EE 应用程序。
- en: Java EE security relies on the **Java Authentication and Authorization Service**
    (**JAAS**) API. As we will see, securing Java EE applications requires very little
    coding for the most part. Securing an application is achieved by setting up users
    and security groups to a security realm in the application server and then configuring
    our applications to rely on a specific security realm for authentication and authorization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 安全性依赖于 **Java 身份验证和授权服务**（**JAAS**）API。正如我们将看到的，保护 Java EE 应用程序大部分情况下不需要编写太多代码。通过在应用程序服务器中设置用户和安全组到安全实体，然后配置我们的应用程序依赖于特定的安全实体以进行身份验证和授权，从而实现应用程序的保护。
- en: 'Some of the topics we will cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的一些主题包括：
- en: Admin realms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理实体
- en: File realms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件实体
- en: Certificate realms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书实体
- en: Creating self-signed security certificates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自签名安全证书
- en: JDBC realms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC 实体
- en: Custom realms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义实体
- en: Security realms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全实体
- en: Security realms are, in essence, collections of users and related security groups.
    A user can belong to one or more security groups. The groups that the user belongs
    to define what actions the system will allow the user to perform. For example,
    an application can have regular users that can only use basic application functionality,
    and it can have administrators that, in addition to being able to use basic application
    functionality, can add additional users to the system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 安全实体本质上是由用户和相关安全组组成的集合。用户可以属于一个或多个安全组。用户所属的组定义了系统将允许用户执行哪些操作。例如，一个应用程序可以有普通用户，他们只能使用基本应用程序功能，还可以有管理员，除了可以使用基本应用程序功能外，还可以向系统中添加其他用户。
- en: Security realms store user information (user name, password, and security groups).
    Therefore, applications don't need to implement this functionality and can simply
    be configured to obtain this information from a security realm. A security realm
    can be used by more than one application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安全实体存储用户信息（用户名、密码和安全组）。因此，应用程序不需要实现此功能，只需配置即可从安全实体获取此信息。一个安全实体可以被多个应用程序使用。
- en: Predefined security realms
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义安全实体
- en: 'GlassFish comes preconfigured with three predefined security realms: **admin-realm**,
    **file**, and **certificate**. The **admin-realm** is used to manage the user''s
    access to the GlassFish web console and shouldn''t be used for other applications.
    The **file** realm stores user information in a file. The **certificate** realm
    looks for a client-side certificate to authenticate the user.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish 默认配置了三个预定义的安全实体：**admin-realm**、**file** 和 **certificate**。**admin-realm**
    用于管理用户对 GlassFish 网络控制台的访问，不应用于其他应用程序。**file** 实体将用户信息存储在文件中。**certificate** 实体查找客户端证书以验证用户。
- en: 'The following screenshot shows the predefined realms in the GlassFish web console:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 GlassFish 网络控制台中的预定义实体：
- en: '![Predefined security realms](img/6886EN_09_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![预定义安全实体](img/6886EN_09_01.jpg)'
- en: In addition to the predefined security realms, we can add additional realms
    with very little effort. We will cover how to do this later in this chapter, but
    first let's discuss GlassFish's predefined security realms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预定义的安全实体外，我们可以轻松地添加额外的实体。我们将在本章后面介绍如何做到这一点，但首先让我们讨论 GlassFish 的预定义安全实体。
- en: The admin-realm
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: admin 实体
- en: The admin-realm has a predefined user called **admin**, which belongs to a predefined
    group called **asadmin**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: admin 实体有一个预定义的用户名为 **admin**，它属于一个预定义的组名为 **asadmin**。
- en: 'To illustrate how to add users to a realm, let''s add a new user to the admin-realm.
    This will allow an additional user to log in to the GlassFish web console. In
    order to add a user to admin-realm, log in to the GlassFish web console and expand
    the **Configurations** node on the left-hand side. Then expand the **server-config**
    node, followed by the **Security** node. Then expand the **Realms** node and click
    on **admin-realm**. The main area of the page should look like the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何向实体添加用户，让我们向 admin 实体添加一个新用户。这将允许额外的用户登录到 GlassFish 网络控制台。为了向 admin 实体添加用户，请登录到
    GlassFish 网络控制台，并展开左侧的 **配置** 节点。然后展开 **server-config** 节点，接着是 **安全** 节点。然后展开
    **实体** 节点并点击 **admin-realm**。页面主要区域应如下截图所示：
- en: '![The admin-realm](img/6886EN_09_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![admin 实体](img/6886EN_09_02.jpg)'
- en: 'To add a user to the realm, click on the button to the top-left labeled **Manage
    Users**. The main area of the page should now look like the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要将用户添加到文件域，请单击左上角标有**管理用户**的按钮。页面主区域现在应该看起来像以下截图：
- en: '![The admin-realm](img/6886EN_09_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![管理员域](img/6886EN_09_03.jpg)'
- en: 'To add a new user to the realm, simply click on the **New...** button to the
    top-left of the screen and then enter the new user information as shown in the
    following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新用户添加到域中，只需单击屏幕左上角的**新建...**按钮，然后输入新用户信息，如下截图所示：
- en: '![The admin-realm](img/6886EN_09_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![管理员域](img/6886EN_09_04.jpg)'
- en: As shown in this screenshot, we added a new user named `root`, added this user
    to the `asadmin` group, and entered this user's password.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如此截图所示，我们添加了一个名为`root`的新用户，将该用户添加到`asadmin`组，并输入了该用户的密码。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GlassFish web console will only allow users in the **asadmin** group to
    log in. Failing to add our user to this security group will prevent him/her from
    logging in to the console.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish网络控制台将只允许**asadmin**组中的用户登录。未能将我们的用户添加到这个安全组将阻止他/她登录到控制台。
- en: 'We can now see our newly created user in the list of admin-realm users, as
    can be seen in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在管理员域用户列表中看到我们新创建的用户，如下截图所示：
- en: '![The admin-realm](img/6886EN_09_05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![管理员域](img/6886EN_09_05.jpg)'
- en: We have successfully added a new user for the GlassFish web console. We can
    test this new account by logging in to the console with this new user's credentials.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功为GlassFish网络控制台添加了新用户。我们可以通过使用新用户的凭据登录控制台来测试这个新账户。
- en: The file realm
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件域
- en: 'The second predefined realm in GlassFish is the file realm. This realm stores
    user information encrypted in a text file. Adding users to this realm is very
    similar to adding users to **admin-realm**. We can add a user by navigating to
    **Configurations** | **server-config** | **Security** | **Realm**. Under the **Realm**
    node, click on **file**, then on the **Manage Users** button, and finally on the
    **New...** button. The main area of the page should look like the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish的第二个预定义域是文件域。该域以加密文本文件的形式存储用户信息。将用户添加到该域与将用户添加到**管理员域**非常相似。我们可以通过导航到**配置**
    | **服务器配置** | **安全** | **域**来添加用户。在**域**节点下，单击**文件**，然后单击**管理用户**按钮，最后单击**新建...**按钮。页面主区域应该看起来像以下截图：
- en: '![The file realm](img/6886EN_09_06.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![文件域](img/6886EN_09_06.jpg)'
- en: Since this realm is meant to be used for our applications, we can come up with
    our own groups. Groups are useful to give the same permissions to several users.
    For example, all users requiring administrative permissions can be added to an
    admin group (the name of the group is, of course, arbitrary).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此域旨在用于我们的应用程序，我们可以创建自己的组。组对于给多个用户赋予相同的权限非常有用。例如，所有需要管理权限的用户都可以添加到管理员组（组名当然是任意的）。
- en: In this example, we added a user with the user ID `peter` to the groups `appuser`
    and `appadmin`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将用户ID为`peter`的用户添加到了`appuser`和`appadmin`组。
- en: 'Clicking on the **OK** button should save the new user and take us to the user
    list for this realm, as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**确定**按钮应保存新用户并带我们到该域的用户列表，如下截图所示：
- en: '![The file realm](img/6886EN_09_07.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![文件域](img/6886EN_09_07.jpg)'
- en: 'Clicking on the **New...** button allows us to add additional users to the
    realm. Let''s add an additional user named `joe` belonging only to the `appuser`
    group, as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**新建...**按钮允许我们向域中添加更多用户。以下截图显示了如何添加名为`joe`的额外用户，他仅属于`appuser`组：
- en: '![The file realm](img/6886EN_09_08.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![文件域](img/6886EN_09_08.jpg)'
- en: As we have seen in this section, adding users to the file realm is very simple.
    We will now illustrate how to authenticate and authorize users via the file realm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节所示，将用户添加到文件域非常简单。现在我们将说明如何通过文件域进行用户认证和授权。
- en: Basic authentication via the file realm
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过文件域进行基本认证
- en: In the previous section, we covered how to add users to the file realm and how
    to assign these users to groups. In this section, we will illustrate how to secure
    a web application so that only properly authenticated and authorized users can
    access it. This web application will use the file realm for user access control.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了如何将用户添加到文件域以及如何将这些用户分配到组中。在本节中，我们将说明如何保护一个网络应用程序，以确保只有经过适当认证和授权的用户才能访问它。这个网络应用程序将使用文件域进行用户访问控制。
- en: 'The application will consist of a few very simple JSF pages. All authentication
    logic is taken care of by the application server; therefore, the only place we
    need to make modifications in order to secure the application is in its deployment
    descriptors, `web.xml` and `glassfish-web.xml`. We will first discuss `web.xml`,
    which is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将包含几个非常简单的JSF页面。所有认证逻辑都由应用服务器处理；因此，为了确保应用程序的安全，我们只需要在其部署描述符中做出修改，即`web.xml`和`glassfish-web.xml`。我们首先讨论`web.xml`，如下所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `<security-constraint>` element defines who can access pages matching a
    certain URL pattern. The URL pattern of the pages is defined inside the `<url-pattern>`
    element, which, as shown in the example, must be nested inside a `<web-resource-collection>`
    element. Roles allowed to access the pages are defined in the `<role-name>` element,
    which must be nested inside an `<auth-constraint>` element.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`<security-constraint>`元素定义了谁可以访问与特定URL模式匹配的页面。页面的URL模式在`<url-pattern>`元素中定义，如示例所示，它必须嵌套在`<web-resource-collection>`元素内部。允许访问页面的角色在`<role-name>`元素中定义，它必须嵌套在`<auth-constraint>`元素内部。'
- en: In our example, we define two sets of pages to be protected. The first set of
    pages are those whose URLs start with `/admin`. These pages can be accessed only
    by users belonging to the admin group. The second set of pages are the rest of
    the pages, defined by the URL pattern of `/*`. Only users with the role `user`
    can access these pages. It is worth noting that the second set of pages is a superset
    of the first set, that is, any page whose URL matches `/admin/*` also matches
    `/*`. In cases like these, the most specific case wins. In this particular case,
    users with the role `user` (and without the role `admin`) will not be able to
    access any page whose URL starts with `/admin`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们定义了两组需要保护的页面。第一组页面是那些URL以`/admin`开头的页面。只有属于admin组的用户可以访问这些页面。第二组页面是其余的页面，由`/*`的URL模式定义。只有具有`user`角色的用户可以访问这些页面。值得注意的是，第二组页面是第一组页面的超集，也就是说，任何URL匹配`/admin/*`的页面也匹配`/*`。在这种情况下，最具体的案例获胜。在这个特定的情况下，具有`user`角色（但没有`admin`角色）的用户将无法访问任何以`/admin`开头的页面。
- en: The next element we need to add to `web.xml` in order to protect our pages is
    the `<login-config>` element. This element must contain an `<auth-method>` element,
    which defines the authorization method for the application. Valid values for this
    element include `BASIC`, `DIGEST`, `FORM`, and `CLIENT-CERT`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的页面，我们需要在`web.xml`中添加的下一个元素是`<login-config>`元素。此元素必须包含一个`<auth-method>`元素，它定义了应用程序的授权方法。此元素的合法值包括`BASIC`、`DIGEST`、`FORM`和`CLIENT-CERT`。
- en: '`BASIC` indicates that basic authentication will be used. This type of authentication
    will result in a browser-generated pop up prompting the user for a username and
    password to be displayed the first time a user tries to access a protected page.
    Unless using the HTTPS protocol, when using basic authentication, the user''s
    credentials are Base64 encoded, not encrypted. It would be fairly easy for an
    attacker to decode these credentials; therefore, using basic authentication is
    not recommended.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`BASIC`表示将使用基本认证。这种认证方式会导致浏览器生成一个弹出窗口，提示用户输入用户名和密码，以便在用户第一次尝试访问受保护页面时显示。除非使用HTTPS协议，否则在使用基本认证时，用户的凭据将以Base64编码，而不是加密。攻击者解码这些凭据相对容易；因此，不建议使用基本认证。'
- en: The `DIGEST` authentication value is similar to basic authentication, except
    that it uses an MD5 digest to encrypt the user credentials instead of sending
    them Base64 encoded.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`DIGEST`认证值与基本认证类似，不同之处在于它使用MD5摘要来加密用户凭据，而不是以Base64编码的形式发送。'
- en: The `FORM` authentication value uses a custom HTML or JSP page containing an
    HTML form with the username and password fields. The values in the form are then
    checked against the security realm for user authentication and authorization.
    Unless using HTTPS, user credentials are sent in clear text when using form-based
    authentication; therefore, using HTTPS is recommended since it encrypts the data.
    We will cover setting up GlassFish to use HTTPS later in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`FORM`认证值使用包含用户名和密码字段的HTML或JSP自定义页面。然后，表单中的值将与安全领域进行核对，以进行用户认证和授权。除非使用HTTPS，否则在使用基于表单的认证时，用户凭据将以明文形式发送；因此，建议使用HTTPS，因为它可以加密数据。我们将在本章后面介绍如何设置GlassFish以使用HTTPS。'
- en: The `CLIENT-CERT` authentication value uses client-side certificates to authenticate
    and authorize the user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLIENT-CERT`认证值使用客户端证书来验证和授权用户。'
- en: The `<realm-name>` element of `<login-config>` indicates what security realm
    to use to authenticate and authorize the user. In this particular example, we
    are using the file realm.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`<login-config>`中的`<realm-name>`元素指示用于身份验证和授权用户的安全域。在这个特定示例中，我们使用的是文件域。'
- en: All of the `web.xml` elements we have discussed in this section can be used
    with any security realm; they are not tied to the file realm. The only thing that
    ties our application to the file realm is the value of the `<realm-name>` element.
    Something else to keep in mind is that not all authentication methods are supported
    by all realms. The file realm supports only basic and form-based authentication.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中讨论的所有`web.xml`元素都可以与任何安全域一起使用；它们并不局限于文件域。将我们的应用程序与文件域联系在一起的是`<realm-name>`元素的值。还需要注意的是，并非所有身份验证方法都受所有域支持。文件域仅支持基本和基于表单的身份验证。
- en: 'Before we can successfully authenticate our users, we need to link the user
    roles defined in `web.xml` with the groups defined in the realm. We accomplish
    this in the `glassfish-web.xml` deployment descriptor as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够成功验证用户之前，我们需要将`web.xml`中定义的用户角色与域中定义的组链接起来。我们通过以下方式在`glassfish-web.xml`部署描述符中完成此操作：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As can be seen in the preceding example, the `glassfish-web.xml` deployment
    descriptor can have one or more `<security-role-mapping>` elements. One of these
    elements is needed for each role defined in each `<auth-constraint>` tag in `web.xml`.
    The `<role-name>` subelement indicates the role to map. Its value must match the
    value of the corresponding `<role-name>` element in `web.xml`. The `<group-name>`
    subelement must match the value of a security group in the realm used to authenticate
    users in the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`glassfish-web.xml`部署描述符可以有一个或多个`<security-role-mapping>`元素。对于`web.xml`中每个`<auth-constraint>`标签中定义的每个角色，都需要这些元素中的一个。`<role-name>`子元素指示要映射的角色。其值必须与`web.xml`中相应的`<role-name>`元素的值匹配。《group-name>`子元素必须与用于在应用程序中身份验证用户的安全域中的安全组值匹配。
- en: In this example, the first `<security-role-mapping>` element maps the `admin`
    role defined in the application's `web.xml` deployment descriptor to the `appadmin`
    group we created when adding users to the file realm earlier in the chapter. The
    second `<security-role-mapping>` element maps the `user` role in `web.xml` to
    the `appuser` group in the file realm.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，第一个`<security-role-mapping>`元素将应用程序的`web.xml`部署描述符中定义的`admin`角色映射到我们在本章前面添加用户到文件域时创建的`appadmin`组。第二个`<security-role-mapping>`元素将`web.xml`中的`user`角色映射到文件域中的`appuser`组。
- en: 'As mentioned earlier, there is nothing we need to do in our code in order to
    authenticate and authorize users. All we need to do is modify the application''s
    deployment descriptors as described in this section. Since our application is
    nothing but a few simple pages, we will not show the source code for them. The
    structure of our application is shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不需要在我们的代码中进行任何操作以进行身份验证和授权用户。我们只需要修改本节中描述的应用程序的部署描述符。由于我们的应用程序只是几个简单的页面，因此我们将不会展示它们的源代码。我们应用程序的结构如下截图所示：
- en: '![Basic authentication via the file realm](img/6886EN_09_09.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![通过文件域进行基本身份验证](img/6886EN_09_09.jpg)'
- en: Based on the way we set up our application in the deployment descriptors, users
    with the role `user` will be able to access the two pages at the root of the application
    (`index.xhtml` and `random.xhtml`). Only users with the role `admin` will be able
    to access any pages under the `admin` folder, which in this particular case is
    a single page named `index.xhtml`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在部署描述符中设置的应用程序方式，具有`user`角色的用户将能够访问应用程序根目录下的两个页面（`index.xhtml`和`random.xhtml`）。只有具有`admin`角色的用户才能访问`admin`文件夹下的任何页面，在这个特定情况下是一个名为`index.xhtml`的单页。
- en: 'After packaging and deploying our application and pointing the browser to the
    URL of any of its pages, we should see a pop up asking for a **User Name** and
    **Password**, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包和部署我们的应用程序并将浏览器指向其任何页面的URL之后，我们应该看到一个弹出窗口，要求输入**用户名**和**密码**，如下截图所示：
- en: '![Basic authentication via the file realm](img/6886EN_09_10.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![通过文件域进行基本身份验证](img/6886EN_09_10.jpg)'
- en: 'After entering the correct username and password, we are directed to the page
    we were attempting to see, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入正确的用户名和密码后，我们将被引导到我们试图查看的页面，如下所示：
- en: '![Basic authentication via the file realm](img/6886EN_09_11.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![通过文件域进行基本身份验证](img/6886EN_09_11.jpg)'
- en: At this point, the user can navigate to any page he/she is allowed to access
    in the application, either by following links or by typing in the URL in the browser,
    without having to reenter his/her username and password.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，用户可以导航到应用程序中他/她被允许访问的任何页面，无论是通过跟随链接还是通过在浏览器中输入URL，而无需重新输入用户名和密码。
- en: 'Note that we logged in as the user `joe`; this user belongs only to the `user`
    role. Therefore, he does not have access to any page that starts with `/admin`
    as the URL. If `joe` tries to access one of these pages, he will get an HTTP error
    reporting **HTTP Status 403-Forbidden**, as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们以用户`joe`的身份登录；此用户仅属于`user`角色。因此，他没有访问以`/admin`开头的任何页面的权限。如果`joe`尝试访问这些页面之一，他将收到一个显示**HTTP状态403-禁止访问**的HTTP错误，如下面的截图所示：
- en: '![Basic authentication via the file realm](img/6886EN_09_12.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![通过文件域进行基本身份验证](img/6886EN_09_12.jpg)'
- en: 'Only users belonging to the `admin` role can see pages that match the URL shown
    in the screenshot. When we were adding users to the file realm, we added a user
    named `peter` that had this role. If we log in as `peter`, we will be able to
    see the requested page. For basic authentication, the only possible way to log
    out of the application is to close the browser. Therefore, to log in as `peter`,
    we need to close and reopen the browser. Once logged in as Peter, we will see
    a window as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 只有属于`admin`角色的用户才能看到截图中显示的URL匹配的页面。当我们向文件域添加用户时，我们添加了一个名为`peter`的用户，他拥有这个角色。如果我们以`peter`的身份登录，我们将能够看到请求的页面。对于基本身份验证，退出应用程序的唯一可能方法是关闭浏览器。因此，要登录为`peter`，我们需要关闭并重新打开浏览器。一旦以Peter的身份登录，我们将看到如下所示的窗口：
- en: '![Basic authentication via the file realm](img/6886EN_09_13.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![通过文件域进行基本身份验证](img/6886EN_09_13.jpg)'
- en: As mentioned before, one disadvantage of the basic authentication method we
    used in this example is that login information is not encrypted. One way to get
    around this is to use the HTTPS (HTTP over SSL) protocol. When using this protocol,
    all information between the browser and the server is encrypted.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在本例中使用的基本身份验证方法的一个缺点是登录信息没有加密。一种解决方法是通过使用HTTPS（SSL上的HTTP）协议。当使用此协议时，浏览器和服务器之间的所有信息都会被加密。
- en: 'The easiest way to use HTTPS is by modifying the application''s `web.xml` deployment
    descriptor as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTPS最简单的方法是修改应用程序的`web.xml`部署描述符，如下所示：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, all we need to do to have the application be accessed only through
    HTTPS is to add a `<user-data-constraint>` element containing a nested `<transport-guarantee>`
    element to each set of pages we want to encrypt. Sets of pages to be protected
    are declared in the `<security-constraint>` elements in the `web.xml` deployment
    descriptor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，为了让应用程序仅通过HTTPS访问，我们只需在每个想要加密的页面集中添加一个包含嵌套的`<transport-guarantee>`元素的`<user-data-constraint>`元素。需要保护的页面集在`web.xml`部署描述符中的`<security-constraint>`元素中声明。
- en: Now, when we access the application through the (unsecure) HTTP port (by default,
    it is 8080), the request is automatically forwarded to the (secure) HTTPS port
    (by default, 8181).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们通过（不安全的）HTTP端口（默认为8080）访问应用程序时，请求将被自动转发到（安全的）HTTPS端口（默认为8181）。
- en: In our example, we set the value of the `<transport-guarantee>` element to `CONFIDENTIAL`.
    This has the effect of encrypting all the data between the browser and the server.
    Also, if the request is made through the unsecured HTTP port, it is automatically
    forwarded to the secured HTTPS port.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将`<transport-guarantee>`元素的值设置为`CONFIDENTIAL`。这会加密浏览器和服务器之间的所有数据。此外，如果请求是通过未加密的HTTP端口发出的，它将被自动转发到安全的HTTPS端口。
- en: Another valid value for the `<transport-guarantee>` element is `INTEGRAL`. When
    using this value, the integrity of the data between the browser and the server
    is guaranteed. In other words, the data cannot be changed in transit. When using
    this value, requests made over HTTP are not automatically forwarded to HTTPS.
    If a user attempts to access a secure page via HTTP when this value is used, the
    browser will deny the request and return a 403 (Access Denied) error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`<transport-guarantee>`元素的另一个有效值是`INTEGRAL`。当使用此值时，浏览器和服务器之间数据的完整性得到保证。换句话说，数据在传输过程中不能被更改。当使用此值时，通过HTTP发出的请求不会自动转发到HTTPS。如果用户尝试在设置此值时通过HTTP访问安全页面，浏览器将拒绝请求并返回403（访问被拒绝）错误。'
- en: The third and last valid value for the `<transport-guarantee>` element is `NONE`.
    When using this value, no guarantees are made about the integrity or confidentiality
    of the data. The `NONE` value is the default value used when the `<transport-guarantee>`
    element is not present in the application's `web.xml` deployment descriptor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`<transport-guarantee>`元素的第三个也是最后一个有效值是`NONE`。当使用此值时，不对数据的完整性和机密性做出任何保证。`NONE`值是在`<transport-guarantee>`元素未出现在应用程序的`web.xml`部署描述符中时使用的默认值。'
- en: 'After making the preceding modifications to the `web.xml` deployment descriptor,
    redeploying the application, and pointing the browser to any of the pages in the
    application, we should see the following warning page when accessing our application
    on Firefox:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`web.xml`部署描述符进行前面的修改后，重新部署应用程序，并将浏览器指向应用程序中的任何页面，当我们在Firefox上访问我们的应用程序时，我们应该看到以下警告页面：
- en: '![Basic authentication via the file realm](img/6886EN_09_14.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![通过文件域进行基本身份验证](img/6886EN_09_14.jpg)'
- en: 'After expanding the **I Understand the Risks** node and clicking on the button
    labeled **Add Exception...**, we should see a window similar to the one shown
    in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在展开**我了解风险**节点并单击标有**添加异常...**的按钮后，我们应该看到一个类似于以下截图的窗口：
- en: '![Basic authentication via the file realm](img/6886EN_09_15.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![通过文件域进行基本身份验证](img/6886EN_09_15.jpg)'
- en: 'After clicking on the button labeled **Confirm Security Exception**, we are
    prompted for a username and password. After entering the appropriate credentials,
    we are allowed access to the requested page as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在单击标有**确认安全异常**的按钮后，我们会提示输入用户名和密码。在输入适当的凭据后，我们被允许访问请求的页面，如下面的截图所示：
- en: '![Basic authentication via the file realm](img/6886EN_09_16.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![通过文件域进行基本身份验证](img/6886EN_09_16.jpg)'
- en: The reason we see this warning is that, in order for a server to use the HTTPS
    protocol, it must have an SSL certificate. Typically, SSL certificates are issued
    by **Certificate Authorities** (**CA**) such as Verisign or Thawte. These certificate
    authorities digitally sign the certificate. By doing this, they certify that the
    server belongs to the entity it claims it belongs to.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到此警告的原因是，为了使服务器能够使用HTTPS协议，它必须有一个SSL证书。通常，SSL证书由**证书颁发机构**（**CA**）如Verisign或Thawte颁发。这些证书颁发机构对证书进行数字签名。通过这样做，他们证明服务器属于它声称属于的实体。
- en: A digital certificate from one of these certificate authorities typically costs
    around USD 400 and expires after a year. Since the cost of these certificates
    may be prohibitive for development or testing purposes, GlassFish comes preconfigured
    with a self-signed SSL certificate. Since this certificate has not been signed
    by a certificate authority, the browser shows a warning window when we try to
    access a secured page via HTTPS.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些证书颁发机构之一获得的数字证书通常花费约400美元，并在一年后到期。由于这些证书的成本可能对开发或测试目的来说过高，GlassFish预先配置了一个自签名的SSL证书。由于此证书未由证书颁发机构签名，当我们尝试通过HTTPS访问受保护页面时，浏览器会显示警告窗口。
- en: Notice the URL in the screenshot. The protocol is set to HTTPS, and the port
    is 8181\. The URL we pointed the browser to was `http://localhost:8080/filerealmauthhttps`,
    because of the modifications we made to the application's `web.xml` deployment
    descriptor, the request was automatically redirected to this URL. Of course, users
    may directly type in the secure URL and it will work without a problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意截图中的URL。协议设置为HTTPS，端口号为8181。我们指向浏览器的URL是`http://localhost:8080/filerealmauthhttps`，因为我们修改了应用程序的`web.xml`部署描述符，请求被自动重定向到这个URL。当然，用户可以直接输入安全的URL，它将没有问题工作。
- en: Any data transferred over HTTPS is encrypted, including the username and password
    entered in the pop-up window generated by the browser. Using HTTPS allows us to
    safely use basic authentication. However, basic authentication has a disadvantage,
    which is that the only way that users can log out of the application is to close
    the browser. If we need to allow users to log out of the application without closing
    the browser, we need to use form-based authentication.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTPS传输的所有数据都是加密的，包括在浏览器生成的弹出窗口中输入的用户名和密码。使用HTTPS允许我们安全地使用基本身份验证。然而，基本身份验证有一个缺点，那就是用户注销应用程序的唯一方式是关闭浏览器。如果我们需要允许用户在不关闭浏览器的情况下注销应用程序，我们需要使用基于表单的身份验证。
- en: Form-based authentication
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于表单的身份验证
- en: 'We need to make some modifications to the application''s `web.xml` deployment
    descriptor to use form-based authentication, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改应用的`web.xml`部署描述符，以便使用基于表单的认证，如下所示：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When using form-based authentication, we simply use `FORM` as the value of the
    `<auth-method>` element in `web.xml`. When using this authentication method, we
    need to provide a login page and a login error page. We indicate the URLs for
    the login and login error pages as the values of the `<form-login-page>` and `<form-error-page>`
    elements, respectively. As we can see in the example, these elements must be nested
    inside the `<form-login-config>` element.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于表单的认证时，我们只需在`web.xml`中将`<auth-method>`元素的值设置为`FORM`。使用此认证方法时，我们需要提供一个登录页面和一个登录错误页面。我们将登录和登录错误页面的URL分别作为`<form-login-page>`和`<form-error-page>`元素的值。正如我们在示例中所看到的，这些元素必须嵌套在`<form-login-config>`元素内部。
- en: 'The markup for the login page for our application is shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的登录页面标记如下所示：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note that even though our login page is a JSF page, it uses a standard
    `<form>` tag as opposed to the JSF-specific `<h:form>` tag. The reason for this
    is that the form's action attribute value must be `j_security_check` and it is
    not possible to set this attribute in the JSF `<h:form>` tag. Similarly, the input
    fields in the form are standard HTML fields, as opposed to their JSF-specific
    counterparts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们的登录页面是一个JSF页面，但它使用的是标准的`<form>`标签，而不是JSF特定的`<h:form>`标签。这样做的原因是表单的`action`属性值必须是`j_security_check`，而在JSF的`<h:form>`标签中无法设置此属性。同样，表单中的输入字段是标准的HTML字段，而不是它们的JSF特定对应字段。
- en: The login page for an application using form-based authentication must contain
    a form whose method is `POST` and whose action is `j_security_check`. We don't
    need to implement the authentication code as it is supplied by the application
    server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于表单认证的应用的登录页面必须包含一个方法为`POST`且行为为`j_security_check`的表单。我们不需要实现认证代码，因为这是由应用服务器提供的。
- en: The form in the login page must contain a text field named `j_username`. This
    text field is meant to hold the username. Additionally, the form must contain
    a password field named `j_password`, meant for the password. Of course, the form
    must contain a submit button to submit the data to the server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面中的表单必须包含一个名为`j_username`的文本字段。这个文本字段是用来存放用户名的。此外，表单还必须包含一个名为`j_password`的密码字段，用于存放密码。当然，表单必须包含一个提交按钮，以便将数据提交到服务器。
- en: The only requirement for a login page is for it to have a form whose attributes
    match those in our example, and the `j_username` and `j_password` input fields
    as described in the preceding paragraph.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于登录页面，唯一的要求是它必须有一个与我们的示例中属性匹配的表单，以及前一段中描述的`j_username`和`j_password`输入字段。
- en: There are no special requirements for the error page. Of course, it should show
    an error message telling the user that login was unsuccessful. However, it can
    contain anything we wish. The error page for our application simply tells the
    user that there was an error logging in and links back to the login page to give
    the user a chance to log back in.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误页面，没有特殊要求。当然，它应该显示一个错误消息，告诉用户登录失败。然而，它可以包含任何我们希望的内容。我们应用的错误页面只是告诉用户登录时出现了错误，并链接回登录页面，给用户一个重新登录的机会。
- en: 'In addition to a login page and a login error page, we added a CDI named bean
    to our application. This allows us to implement the logout functionality, something
    that wasn''t possible when we were using basic authentication. The code to implement
    the logout functionality is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了登录页面和登录错误页面之外，我们还向应用中添加了一个CDI命名bean。这允许我们实现注销功能，这是我们使用基本认证时无法实现的。实现注销功能的代码如下：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first few lines of the logout method are meant to get a reference to the
    `HttpSession` object. Once we obtain this object, all we need to do is invalidate
    the session by invoking its `invalidate()` method. In our code, we redirect the
    response to the index page. Since the session is invalid at this point, the security
    mechanism automatically directs the user to the login page.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 登出方法的前几行是为了获取`HttpSession`对象的引用。一旦我们获得这个对象，我们只需要调用它的`invalidate()`方法来使会话无效。在我们的代码中，我们将响应重定向到首页。由于此时会话已经无效，安全机制会自动将用户重定向到登录页面。
- en: 'We are now ready to test form-based authentication. After building our application,
    deploying it, and pointing the browser to any of its pages, we should see our
    login page rendered in the browser as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试基于表单的身份验证了。在构建我们的应用程序、部署它并将浏览器指向其任何页面后，我们应该在浏览器中看到我们的登录页面，如下面的截图所示：
- en: '![Form-based authentication](img/6886EN_09_17.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![基于表单的身份验证](img/6886EN_09_17.jpg)'
- en: 'If we submit invalid credentials, we are automatically forwarded to the login
    error page, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提交无效凭据，我们将自动转发到登录错误页面，如下面的截图所示：
- en: '![Form-based authentication](img/6886EN_09_18.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![基于表单的身份验证](img/6886EN_09_18.jpg)'
- en: 'We can click on the **Try again** link to try again. After entering the valid
    credentials, we are allowed into the application. The following screenshot shows
    the screen after a successful login:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击**重试**链接再次尝试。在输入有效凭据后，我们被允许进入应用程序。以下截图显示了成功登录后的屏幕：
- en: '![Form-based authentication](img/6886EN_09_19.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![基于表单的身份验证](img/6886EN_09_19.jpg)'
- en: As we can see, we added a **Logout** link to the page. This link directs the
    user to the `logout()` method of our CDI named bean, which, as mentioned before,
    simply invalidates the session. From the user's point of view, this link will
    simply log them out and direct them to the login screen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在页面上添加了一个**注销**链接。此链接将用户导向我们的CDI命名bean的`logout()`方法，正如之前提到的，这仅仅是无效化会话。从用户的角度来看，此链接将简单地让他们注销并导向登录屏幕。
- en: The certificate realm
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 证书领域
- en: The certificate realm uses client-side certificates for authentication. Just
    like server-side certificates, client-side certificates are typically obtained
    from a certificate authority such as Verisign or Thawte. These certificate authorities
    verify that the certificate really belongs to who it says it belongs to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 证书领域使用客户端证书进行身份验证。就像服务器端证书一样，客户端证书通常从证书颁发机构如Verisign或Thawte获取。这些证书颁发机构验证证书确实属于它所说的所有者。
- en: Obtaining a certificate from a certificate authority costs money and takes some
    time. It might not be practical to obtain a certificate from one of the certificate
    authorities when we are developing and/or testing our application. Fortunately,
    we can create self-signed certificates for testing purposes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从证书颁发机构获取证书需要付费并花费一些时间。在我们开发和/或测试应用程序时，从证书颁发机构之一获取证书可能并不实用。幸运的是，我们可以为测试目的创建自签名证书。
- en: Creating self-signed certificates
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建自签名证书
- en: We can create self-signed certificates with little effort with the **keytool**
    utility included with the **Java Development Kit** (**JDK**).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用包含在**Java开发工具包**（**JDK**）中的**keytool**实用程序轻松创建自签名证书。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will only briefly cover some of the keytool utility features, specifically
    the features that are necessary to create and import self-signed certificates
    into GlassFish and the browser. To learn more about the keytool utility, refer
    to [http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html](http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍一些keytool实用程序的关键功能，特别是创建和将自签名证书导入GlassFish和浏览器所必需的功能。要了解更多关于keytool实用程序的信息，请参阅[http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html](http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html)。
- en: 'You can generate a self-signed certificate by typing in the following command
    in the command line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在命令行中输入以下命令来生成自签名证书：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command assumes that the keytool utility is in the system path. This tool
    can be found in the `bin` directory under the directory where JDK is installed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令假设keytool实用程序在系统路径中。此工具可以在JDK安装目录下的`bin`目录中找到。
- en: Substitute the values for the `-storepass` and `-keypass` parameters with your
    own password. Both of these passwords must be the same in order to successfully
    use the certificate to authenticate the client. You may choose any value for the
    `-alias` parameter. You may also choose any value for the `-keystore` parameter.
    However, the value must end in `.p12`, since this command generates a file that
    needs to be imported into the web browser, and it won't be recognized unless it
    has the `.p12` extension.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将`-storepass`和`-keypass`参数的值替换为您自己的密码。这两个密码必须相同，才能成功使用证书对客户端进行身份验证。您可以为`-alias`参数选择任何值。您也可以为`-keystore`参数选择任何值。但是，值必须以`.p12`结尾，因为此命令生成的文件需要导入到网络浏览器中，并且如果没有`.p12`扩展名，则不会被识别。
- en: 'After entering the above command from the command line, keytool will prompt
    for some information as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中输入上述命令后，keytool 将提示以下信息：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After entering the data for each prompt, keytool will generate the certificate.
    It will be stored in the current directory, and the name of the file will be the
    value we used for the `-keystore` parameter (`client_keystore.p12` in the example).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个提示中输入数据后，keytool 将生成证书。它将被存储在当前目录中，文件名将是用于 `-keystore` 参数的值（例如示例中的 `client_keystore.p12`）。
- en: 'To be able to use this certificate to authenticate ourselves, we need to import
    it into the browser. The procedure, although similar, varies from browser to browser.
    In Firefox, this can be accomplished by going to the **Preferences** menu, clicking
    on the **Advanced** icon at the top of the pop-up window that appears, and then
    clicking on the **Certificates** tab as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用此证书来验证我们自身，我们需要将其导入到浏览器中。虽然过程类似，但每个浏览器的具体步骤可能不同。在 Firefox 中，可以通过转到**首选项**菜单，点击出现的弹出窗口顶部的**高级**图标，然后点击**证书**选项卡来完成，如下面的截图所示：
- en: '![Creating self-signed certificates](img/6886EN_09_20.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![创建自签名证书](img/6886EN_09_20.jpg)'
- en: 'We then need to navigate to **View Certificates** | **Your Certificates** |
    **Import** on the window that appears. Then navigate and select our certificate
    from the directory in which it was created. At this point, Firefox will ask us
    for the password used to encrypt the certificate; in our example, we used `wonttellyou`
    as the password. After entering the password, we should see a pop-up window confirming
    that our certificate was successfully imported. We should then see it in the list
    of certificates, as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导航到出现的窗口中的**查看证书** | **你的证书** | **导入**。然后导航并从创建它的目录中选择我们的证书。此时，Firefox 将要求我们输入用于加密证书的密码；在我们的例子中，我们使用
    `wonttellyou` 作为密码。输入密码后，我们应该看到一个弹出窗口确认我们的证书已成功导入。然后我们应该在证书列表中看到它，如下面的截图所示：
- en: '![Creating self-signed certificates](img/6886EN_09_21.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![创建自签名证书](img/6886EN_09_21.jpg)'
- en: We have now added our certificate to Firefox so that it can be used to authenticate
    us. If you are using another browser, the procedure will be similar. Consult your
    browser's documentation for details.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的证书添加到 Firefox 中，以便它可以用来验证我们。如果你使用的是其他浏览器，则过程将类似。请查阅浏览器文档以获取详细信息。
- en: 'The certificate we created in the previous step needs to be exported into a
    format that GlassFish can understand. We can accomplish this by running the following
    command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中创建的证书需要导出为 GlassFish 可以理解的格式。我们可以通过运行以下命令来完成此操作：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The value for the `-alias`, `-keystore`, and `-storepass` parameters must match
    the values used in the previous command. You may choose any value for the `-file`
    parameter, but it is recommended for the value to end in the `.cer` extension.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`-alias`、`-keystore` 和 `-storepass` 参数的值必须与之前命令中使用的值匹配。对于 `-file` 参数，你可以选择任何值，但建议以
    `.cer` 扩展名结尾。'
- en: Since our certificate was not issued by a certificate authority, GlassFish by
    default will not recognize it as a valid certificate. GlassFish knows what certificates
    to trust based on the certificate authority that created them. This is implemented
    through the storing of certificates for these various authorities in a keystore
    named `cacerts.jks`. This keystore can be found at `[glassfish installation directory]/glassfish/domains/domain1/config/cacerts.jks`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的证书不是由证书颁发机构签发的，GlassFish 默认情况下不会将其识别为有效证书。GlassFish 根据创建它们的证书颁发机构知道哪些证书可以信任。这是通过将这些不同机构的证书存储在名为
    `cacerts.jks` 的密钥库中实现的。此密钥库位于 `[glassfish 安装目录]/glassfish/domains/domain1/config/cacerts.jks`。
- en: 'In order for GlassFish to accept our certificate, we need to import it into
    the `cacerts` keystore. This can be accomplished by issuing the following command
    from the command line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 GlassFish 接受我们的证书，我们需要将其导入到 `cacerts` 密钥库中。这可以通过从命令行发出以下命令来完成：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, keytool will display the following certificate information in
    the command line and ask us if we want to trust it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，keytool 将在命令行中显示以下证书信息，并询问我们是否信任它：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once we add the certificate to the `cacerts.jks` keystore, we need to restart
    the domain for the change to take effect.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将证书添加到 `cacerts.jks` 密钥库中，我们需要重新启动域以使更改生效。
- en: What we are effectively doing here is adding ourselves as a certificate authority
    that GlassFish will trust. This, of course, should not be done in a production
    system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在这里做的是将自己添加为GlassFish将信任的证书颁发机构。当然，这不应该在生产系统中进行。
- en: The value for the `-file` parameter must match the value we used for this same
    parameter when we exported the certificate.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`-file` 参数的值必须与我们导出证书时使用的此参数的值匹配。'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that `changeit` is the default password for the `-keypass` and `-storepass`
    parameters for the `cacerts.jks` keystore. This value can be changed by issuing
    the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`changeit` 是 `-keypass` 和 `-storepass` 参数的 `cacerts.jks` 仓库的默认密码。此值可以通过以下命令更改：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command will prompt for the existing as well as the new master password.
    The `–savemasterpassword=true` parameter is optional; it saves the master password
    into a file called `master-password` in the root directory of the domain. If we
    don't use this parameter when changing the master password, then we will need
    to enter the master password every time we want to start the domain.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将提示输入现有密码和新密码。`–savemasterpassword=true` 参数是可选的；它将主密码保存到域根目录下名为 `master-password`
    的文件中。如果我们更改主密码时不使用此参数，那么每次我们想要启动域时都需要输入主密码。
- en: Now that we have created a self-signed certificate, imported it into our browser,
    and established ourselves as a certificate authority that GlassFish will trust,
    we are ready to develop an application that will use client-side certificates
    for authentication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个自签名证书，将其导入到我们的浏览器中，并确立了自己作为GlassFish将信任的证书颁发机构，我们已准备好开发一个将使用客户端证书进行认证的应用程序。
- en: Configuring applications to use the certificate realm
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置应用程序使用证书领域
- en: 'Since we are taking advantage of Java EE security features, we don''t need
    to modify any code in order to use the security realm. All we need to do is modify
    the application''s configuration on its deployment descriptors, `web.xml` and
    `glassfish-web.xml`, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用Java EE安全功能，我们不需要修改任何代码即可使用安全领域。我们只需要修改应用程序的配置，即其部署描述符 `web.xml` 和 `glassfish-web.xml`，如下所示：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The main difference between this `web.xml` deployment descriptor and the one
    we saw in the previous section is the contents of the `<login-config>` element.
    In this case, we declared `CLIENT-CERT` as the authorization method and `certificate`
    as the realm to use to authenticate. This will have the effect of GlassFish asking
    the browser for a client certificate before allowing a user into the application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中我们看到的 `web.xml` 部署描述符相比，这个 `web.xml` 部署描述符的主要区别在于 `<login-config>` 元素的内容。在这种情况下，我们声明
    `CLIENT-CERT` 为授权方法，并将 `certificate` 作为用于认证的领域。这将导致 GlassFish 在允许用户进入应用程序之前要求浏览器提供一个客户端证书。
- en: When using client certificate authentication, the request must always be made
    via HTTPS. Therefore, it is a good idea to add the `<transport-guarantee>` element
    with a value of `CONFIDENTIAL` to the `web.xml` deployment descriptor. Recall
    from the previous section that this has the effect of forwarding any requests
    through the HTTP port to the HTTPS port. If we don't add this value to the `web.xml`
    deployment descriptor, any requests through the HTTP port will fail, since client
    certificate authentication cannot be done through the HTTP protocol.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用客户端证书认证时，请求必须始终通过 HTTPS 进行。因此，将 `<transport-guarantee>` 元素添加到 `web.xml` 部署描述符中，并设置其值为
    `CONFIDENTIAL` 是一个好主意。回想一下，上一节中提到这会将任何请求通过 HTTP 端口转发到 HTTPS 端口。如果我们不将此值添加到 `web.xml`
    部署描述符中，任何通过 HTTP 端口的请求都会失败，因为客户端证书认证不能通过 HTTP 协议完成。
- en: 'Notice that we declared that only users with the role `user` can access any
    page in the system. We did this by adding the role `user` to the `<role-name>`
    element nested inside the `<auth-constraint>` element of the `<security-constraint>`
    element in the `web.xml` deployment descriptor. In order to allow access to authorized
    users, we need to add them to this role. This is done in the `glassfish-web.xml`
    deployment descriptor as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们声明只有具有 `user` 角色的用户可以访问系统中的任何页面。我们通过将 `user` 角色添加到 `web.xml` 部署描述符中 `<security-constraint>`
    元素的 `<auth-constraint>` 元素内部的 `<role-name>` 元素来做到这一点。为了允许授权用户访问，我们需要将他们添加到这个角色中。这通过以下方式在
    `glassfish-web.xml` 部署描述符中完成：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This assignment is done by mapping the principal user to a role in a `<security-role-mapping>`
    element in the `glassfish-web.xml` deployment descriptor; its `<role-name>` subelement
    must contain the role name, and the `<principal-name>` subelement must contain
    the username. This username is taken from the certificate.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此分配是通过将主要用户映射到`glassfish-web.xml`部署描述符中的`<security-role-mapping>`元素中的角色来完成的；其`<role-name>`子元素必须包含角色名称，而`<principal-name>`子元素必须包含用户名。此用户名来自证书。
- en: 'If you are not sure of the name to use, it can be obtained from the certificate
    with the keytool utility as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定要使用的名称，可以使用keytool实用工具从证书中获取，如下所示：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The value to use as `<principal-name>` is the line after `Owner:`. Please note
    that the value of `<principal-name>` must be in the same line as its open and
    closing elements `(<principal-name>` and `</principal-name>`). If there are newline
    or carriage return characters before or after the value, they are interpreted
    as being part of the value and validation will fail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`<principal-name>`使用的值是`Owner:`之后的行。请注意，`<principal-name>`的值必须与其开放和关闭元素`(<principal-name>`和`</principal-name>`)在同一行。如果值前后有换行符或回车符，它们将被解释为值的一部分，验证将失败。
- en: Since our application has a single user and a single role, we are ready to deploy
    it. If we had more users, we would have to add additional `<security-role-mapping>`
    elements to our `glassfish-web.xml` deployment descriptor, at least one per user.
    If we had users that belong to more than one role, then we would add a `<security-role-mapping>`
    element for each role the user belongs to, using the `<principal-name>` value
    corresponding to the user's certificate for each one of them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序只有一个用户和一个角色，我们已经准备好部署它。如果我们有更多用户，我们必须在`glassfish-web.xml`部署描述符中添加额外的`<security-role-mapping>`元素，至少每个用户一个。如果我们有属于多个角色的用户，那么我们将为用户所属的每个角色添加一个`<security-role-mapping>`元素，使用与每个用户的证书对应的`<principal-name>`值。
- en: 'We are now ready to test our application. After we deploy it and point the
    browser to any page in the application, we should see a screen like the following
    (assuming the browser hasn''t been configured to provide a default certificate
    any time a server requests one):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好测试我们的应用程序。在我们部署它并将浏览器指向应用程序中的任何页面后，我们应该看到如下屏幕（假设浏览器尚未配置为在服务器请求证书时提供默认证书）：
- en: '![Configuring applications to use the certificate realm](img/6886EN_09_22.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![配置应用程序以使用证书域](img/6886EN_09_22.jpg)'
- en: 'After clicking on the **OK** button, we are allowed to access the application,
    as shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**按钮后，我们就可以访问应用程序，如下面的截图所示：
- en: '![Configuring applications to use the certificate realm](img/6886EN_09_23.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![配置应用程序以使用证书域](img/6886EN_09_23.jpg)'
- en: Before allowing access to the application, GlassFish checks the certificate
    authority that issued the certificate (since we self-signed the certificate, the
    owner of the certificate and the certificate authority are the same), checking
    against the list of trusted certificate authorities. Since we added ourselves
    as a trusted authority by importing our self-signed certificate into the `cacerts.jks`
    keystore, GlassFish recognizes the certificate authority as a valid one. It then
    gets the principal name from the certificate and compares it against entries in
    the application's `glassfish-web.xml` file. Since we added ourselves to this deployment
    descriptor and gave ourselves a valid role, we are allowed into the application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在允许访问应用程序之前，GlassFish会检查颁发证书的证书颁发机构（由于我们自签了证书，证书所有者和证书颁发机构是相同的），并对照受信任的证书颁发机构列表进行检查。由于我们将自己作为受信任的权威机构通过将我们的自签名证书导入`cacerts.jks`密钥库中，GlassFish识别证书颁发机构为有效的。然后它从证书中获取主体名称，并将其与应用程序`glassfish-web.xml`文件中的条目进行比较。由于我们将自己添加到这个部署描述符中，并给自己分配了一个有效角色，因此我们被允许进入应用程序。
- en: Defining additional realms
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义额外的域
- en: In addition to the three preconfigured security realms we discussed in the previous
    section, we can create additional realms for application authentication. We can
    create realms that behave exactly like the file realm or admin-realm. We can also
    create realms that behave like the certificate realm. Additionally, we can create
    realms that use other methods of authentication. We can authenticate users against
    an LDAP database and against a relational database and, when GlassFish is installed
    on a Solaris server, use Solaris authentication within GlassFish. Also, if none
    of the predefined authentication mechanisms fit our needs, we can implement our
    own.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一节中讨论的三个预配置的安全域之外，我们还可以为应用程序身份验证创建额外的域。我们可以创建与文件域或admin域行为完全相同的域。我们还可以创建与证书域行为相似的域。此外，我们还可以创建使用其他身份验证方法的域。我们可以对LDAP数据库和关系数据库进行用户身份验证，当GlassFish安装在Solaris服务器上时，在GlassFish中使用Solaris身份验证。此外，如果预定义的身份验证机制不符合我们的需求，我们可以实现自己的。
- en: Defining additional file realms
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义额外的文件域
- en: In the administration console, expand the **Configurations** node, followed
    by the **server-config** node, and then the **Security** node. Click on the **Realms**
    node and then on the **New...** button on the resulting page in the main area
    of the web console.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理控制台中，展开**配置**节点，然后是**server-config**节点，接着是**安全**节点。点击**域**节点，然后在Web控制台主区域的结果页面上的**新...**按钮。
- en: 'We should now see a screen like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该看到如下屏幕：
- en: '![Defining additional file realms](img/6886EN_09_24.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![定义额外的文件域](img/6886EN_09_24.jpg)'
- en: All we need to do to create an additional realm is enter a unique name for it
    in the **Name** field, pick `com.sun.enterprise.security.auth.realm.file.FileRealm`
    for the **Class Name** field, and enter a value for the **JAAS Context** and **Key
    File** fields; the value for the **Key File** field must be the absolute path
    to a file where user information will be stored and, for the file realm, the value
    for the **JAAS Context** field must always be `fileRealm`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建一个额外的域，只需在**名称**字段中为其输入一个唯一的名称，为**类名**字段选择`com.sun.enterprise.security.auth.realm.file.FileRealm`，并为**JAAS上下文**和**密钥文件**字段输入值；**密钥文件**字段的值必须是存储用户信息的文件的绝对路径，对于文件域，**JAAS上下文**字段的值必须始终是`fileRealm`。
- en: After entering all of the required information, we can click on the **OK** button
    and our new realm will be created. We can then use it just like the predefined
    file realm. Applications wanting to authenticate against this new realm must use
    its name as the value of the `<realm-name>` element in the application's `web.xml`
    deployment descriptor.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入所有必要的信息后，我们可以点击**确定**按钮，我们的新域将被创建。然后我们可以像使用预定义的文件域一样使用它。希望对此新域进行身份验证的应用程序必须使用其名称作为应用程序的`web.xml`部署描述符中`<realm-name>`元素的价值。
- en: 'Alternatively, a custom file realm can be added from the command line via the
    `asadmin` utility by executing the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过`asadmin`实用程序从命令行添加自定义文件域，通过执行以下命令：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `create-auth-realm` argument tells `asadmin` that we want to create a new
    security realm. The value of the `--classname` parameter corresponds to the security
    realm class name. Notice that it matches the value we selected above in the web
    console. The `--property` parameter allows us to pass properties and their values;
    the value of this parameter must be a colon (`:`) separated list of properties
    and their values. The last argument of this command is the name we wish to give
    our security realm.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-auth-realm`参数告诉`asadmin`我们想要创建一个新的安全域。`--classname`参数的值对应于安全域类名。请注意，它与我们在Web控制台上选择的值相匹配。`--property`参数允许我们传递属性及其值；此参数的值必须是属性及其值的冒号（`:`）分隔列表。此命令的最后一个参数是我们希望给我们的安全域起的名字。'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although it is easier to set up security realms via the web console, doing it
    through the `asadmin` command-line utility has the advantage that it is easily
    scriptable, allowing us to save this command in a script and easily configure
    several GlassFish instances.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过Web控制台设置安全域更容易，但通过`asadmin`命令行工具进行操作的优势在于它易于脚本化，允许我们将此命令保存在脚本中，并轻松配置多个GlassFish实例。
- en: Defining additional certificate realms
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义额外的证书域
- en: 'To define an additional certificate realm, we simply need to enter its name
    in the **Name** field and pick `com.sun.enterprise.security.auth.realm.certificate.CertificateRealm`
    as the value of the `Class Name` field and then click on **OK** to create our
    new realm, as shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个额外的证书领域，我们只需在**名称**字段中输入其名称，并将`com.sun.enterprise.security.auth.realm.certificate.CertificateRealm`作为`类名`字段的值，然后点击**确定**创建我们的新领域，如下面的屏幕截图所示：
- en: '![Defining additional certificate realms](img/6886EN_09_25.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![定义额外的证书领域](img/6886EN_09_25.jpg)'
- en: Applications wanting to use this new realm for authentication must use its name
    as the value of the `<realm-name>` element in the `web.xml` deployment descriptor
    and specify `CLIENT-CERT` as the value of its `<auth-method>` element. Of course,
    client certificates must be present and configured as explained in the *Configuring
    applications to use the certificate realm* section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 希望使用这个新领域进行身份验证的应用程序必须在`web.xml`部署描述符中的`<realm-name>`元素中使用其名称，并将其`<auth-method>`元素的值指定为`CLIENT-CERT`。当然，客户端证书必须存在并按照*配置应用程序以使用证书领域*部分中所述进行配置。
- en: 'Alternatively, a custom certificate realm can be created on the command line
    via the `asadmin` utility by executing the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过`asadmin`实用程序在命令行上创建自定义证书领域，执行以下命令：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we don't need to pass any properties as we had to when we created
    the custom file realm. Therefore, all we need to do is pass the appropriate value
    to the `--classname` parameter and specify the new security realm name.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要传递任何属性，就像我们创建自定义文件领域时必须做的那样。因此，我们只需要传递适当的值给`--classname`参数，并指定新的安全领域名称。
- en: Defining an LDAP realm
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义LDAP领域
- en: 'We can easily set up a realm to authenticate against an **LDAP** (**Lightweight
    Directory Access Protocol**) database. In order to do this, we need to, in addition
    to the obvious step of entering a name for the realm, select `com.sun.enterprise.security.auth.realm.ldap.LDAPRealm`
    as the **Class Name** value for a new realm. We then need to enter a URL for the
    directory server in the **Directory** field and the base distinguished name to
    be used to search user data as the value of the **Base DN** field, as shown in
    the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松设置一个领域以对**LDAP**（**轻量级目录访问协议**）数据库进行身份验证。为此，我们除了输入领域名称这一明显步骤外，还需要将`com.sun.enterprise.security.auth.realm.ldap.LDAPRealm`作为新领域的**类名**值。然后，我们需要在**目录**字段中输入目录服务器的URL，以及用作搜索用户数据的**基础DN**字段的值，如下面的屏幕截图所示：
- en: '![Defining an LDAP realm](img/6886EN_09_26.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![定义LDAP领域](img/6886EN_09_26.jpg)'
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of this writing, GlassFish had a bug that prevents LDAP realms from
    being added successfully from the web admin console. In this section, we explain
    what should happen, not what actually happens. Hopefully, by the time you read
    this, the issue will be fixed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，GlassFish存在一个错误，阻止从Web管理控制台成功添加LDAP领域。在本节中，我们解释了应该发生什么，而不是实际发生了什么。希望在你阅读本文时，问题已经得到解决。
- en: Adding an LDAP realm from the command line, as explained later in this section,
    works properly though.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节稍后所述，从命令行添加LDAP领域的方法是正确的。
- en: After creating an LDAP realm, applications can use it to authenticate against
    the LDAP database. The name of the realm needs to be used as the value of the
    `<realm-name>` element in the application's `web.xml` deployment descriptor. The
    value of the `<auth-method>` element must be either `BASIC` or `FORM`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建LDAP领域后，应用程序可以使用它来对LDAP数据库进行身份验证。领域的名称需要用作应用程序`web.xml`部署描述符中`<realm-name>`元素的值。`<auth-method>`元素的值必须是`BASIC`或`FORM`。
- en: Users and roles in the LDAP database can be mapped to groups in the application's
    `glassfish-web.xml` deployment descriptor using the `<principal-name>`, `<role-name>`,
    and `<group-name>` elements as discussed earlier in this chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP数据库中的用户和角色可以使用本章前面讨论的`<principal-name>`、`<role-name>`和`<group-name>`元素映射到应用程序的`glassfish-web.xml`部署描述符中的组。
- en: 'To create an LDAP realm from the command line, we need to use the following
    syntax:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行创建LDAP领域，我们需要使用以下语法：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that, in this case, the value of the `--property` parameter is between
    quotes. This is necessary because we need to escape some of the characters in
    its value, such as all the colons and equal signs. To escape these special characters,
    we simply prefix them with a backslash (`\`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，`--property` 参数的值在引号之间。这是必要的，因为我们需要转义其值中的某些字符，例如所有冒号和等号。为了转义这些特殊字符，我们只需在它们前面加上反斜杠（`\`）。
- en: Defining a Solaris realm
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 Solaris 领域
- en: 'When GlassFish is installed on a Solaris server, it can take advantage of the
    operating system authentication mechanism via a Solaris Realm. There are no special
    properties for this type of realm; all we need to do to create one is pick a name
    for it and select `com.sun.enterprise.security.auth.realm.solaris.SolarisRealm`
    as the value of the **Class Name** field and enter `solarisRealm` as the value
    of the **JAAS Context** field, as shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GlassFish 安装在 Solaris 服务器上时，它可以通过 Solaris 领域利用操作系统的认证机制。此类领域没有特殊属性；我们只需为它选择一个名称，并将
    `com.sun.enterprise.security.auth.realm.solaris.SolarisRealm` 作为 **类名** 字段的值，将
    `solarisRealm` 作为 **JAAS 上下文** 字段的值，如以下截图所示：
- en: '![Defining a Solaris realm](img/6886EN_09_27.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![定义 Solaris 领域](img/6886EN_09_27.jpg)'
- en: The **JAAS Context** field must be set to `solarisRealm`. After adding the realm,
    applications can authenticate against it using basic or form-based authentication.
    Operating system groups and users can be mapped to application roles defined in
    the application's `web.xml` deployment descriptor via the `<principal-name>`,
    `<role-name>`, and `<group-name>` elements in its `glassfish-web.xml` deployment
    descriptor.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**JAAS 上下文** 字段必须设置为 `solarisRealm`。添加领域后，应用程序可以使用基本认证或基于表单的认证对其进行认证。操作系统组和用户可以通过应用程序的
    `glassfish-web.xml` 部署描述符中的 `<principal-name>`、`<role-name>` 和 `<group-name>`
    元素映射到应用程序中定义的应用程序角色。'
- en: 'A Solaris realm can be created from the command line by executing the following
    command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行以下命令从命令行创建 Solaris 领域：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Defining a JDBC realm
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 JDBC 领域
- en: Another type of realm we can create is a JDBC realm. This type of realm uses
    user information stored in database tables for user authentication.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建的另一种领域类型是 JDBC 领域。这种类型的领域使用存储在数据库表中的用户信息进行用户认证。
- en: 'In order to illustrate how to authenticate against a JDBC realm, we need to
    create a database to hold user information. The following entity-relationship
    diagram shows an example database we could use to authenticate against a JDBC
    realm:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何对 JDBC 领域进行认证，我们需要创建一个数据库来存储用户信息。以下实体关系图显示了我们可以用来对 JDBC 领域进行认证的示例数据库：
- en: '![Defining a JDBC realm](img/6886EN_09_28.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![定义 JDBC 领域](img/6886EN_09_28.jpg)'
- en: Our database consists of three tables. A `USERS` table holding user information
    and a `GROUPS` table holding group information are two of them. Since there is
    a many-to-many relationship between `USERS` and `GROUPS`, we need to add a join
    table to preserve data normalization. The name of this third table is `USER_GROUPS`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库由三个表组成。一个是存储用户信息的 `USERS` 表，另一个是存储组信息的 `GROUPS` 表。由于 `USERS` 和 `GROUPS`
    之间存在多对多关系，我们需要添加一个连接表以保持数据规范化。这个第三个表的名称是 `USER_GROUPS`。
- en: Notice that the `PASSWORD` column of the `USERS` table is of type `CHAR(32)`.
    The reason we chose this type instead of `VARCHAR` is that we will be hashing
    passwords using the MD5 hashing algorithm, and these hashes are always 32 characters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`USERS` 表的 `PASSWORD` 列是 `CHAR(32)` 类型。我们选择这种类型而不是 `VARCHAR` 的原因是我们将使用 MD5
    散列算法来散列密码，而这些散列总是 32 个字符。
- en: 'Passwords can be easily encrypted in the expected format by using the `java.security.MessageDigest`
    class included with the JDK. The following example code will accept a clear-text
    password and create an MD5 hash out of it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 JDK 包含的 `java.security.MessageDigest` 类轻松地将密码以预期格式加密。以下示例代码将接受明文密码并从中创建一个
    MD5 散列：
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The main functionality of the preceding class is defined in its `encryptPassword()`
    method. It basically accepts a clear-text string and digests it using the MD5
    algorithm using the `digest()` method of an instance of `java.security.MessageDigest`.
    It then encodes the digest as a series of hexadecimal numbers. This encoding is
    necessary because GlassFish by default expects MD5-digested passwords to be hex
    encoded.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类的主要功能在其 `encryptPassword()` 方法中定义。它基本上接受一个明文字符串，并使用 `java.security.MessageDigest`
    实例的 `digest()` 方法使用 MD5 算法对其进行散列。然后，它将散列编码为一系列十六进制数字。这种编码是必要的，因为 GlassFish 默认期望
    MD5 散列的密码是十六进制编码的。
- en: When using JDBC realms, application users and groups are not added to the realm
    via the GlassFish console. Instead, they are added by inserting data into the
    appropriate tables.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 JDBC 域时，应用程序用户和组不是通过 GlassFish 控制台添加到域中的。相反，它们是通过向适当的表中插入数据来添加的。
- en: Once we have the database that will hold user credentials in place, we are ready
    to create a new JDBC realm.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了将保存用户凭据的数据库，我们就可以创建一个新的 JDBC 域。
- en: 'We can create a JDBC realm by entering its name in the **Name** field of the
    **New Realm** form in the GlassFish web console and then selecting `com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm`
    as the value of the **Class Name** field, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 GlassFish 网络控制台的**新域**表单的**名称**字段中输入其名称来创建一个 JDBC 域，然后选择 `com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm`
    作为**类名**字段的值，如下截图所示：
- en: '![Defining a JDBC realm](img/6886EN_09_29.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![定义 JDBC 域](img/6886EN_09_29.jpg)'
- en: 'There are a number of other properties we need to set for our new JDBC realm,
    as shown in the following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的新 JDBC 域设置一些其他属性，如下截图所示：
- en: '![Defining a JDBC realm](img/6886EN_09_30.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![定义 JDBC 域](img/6886EN_09_30.jpg)'
- en: The **JAAS Context** field must be set to `jdbcRealm` for JDBC realms. The value
    of the **JNDI** property must be the JNDI name of the data source corresponding
    to the database that contains the realm's user and group data. The value of the
    **User Table** property must be the name of the table that contains username and
    password information.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**JAAS 上下文**字段必须设置为 `jdbcRealm` 以用于 JDBC 域。**JNDI**属性值必须是包含域用户和组数据的数据库对应的数据源的
    JNDI 名称。**用户表**属性值必须是包含用户名和密码信息的表的名称。'
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that, in the preceding screenshot, we used `V_USER_ROLE` as the value
    for the **User Table** property. `V_USER_ROLE` is a database view that contains
    both user and group information. We didn't use the `USERS` table directly because
    GlassFish assumes that both the user table and the group table contain a column
    containing the username. Doing this results in having duplicate data. To avoid
    this situation, we created a view that we could use as the value of both the **User
    Table** and **Group Table** (to be discussed shortly) properties.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的截图中，我们使用了 `V_USER_ROLE` 作为**用户表**属性的值。`V_USER_ROLE` 是一个包含用户和组信息的数据库视图。我们没有直接使用
    `USERS` 表，因为 GlassFish 假设用户表和组表都包含一个包含用户名的列。这样做会导致数据重复。为了避免这种情况，我们创建了一个视图，我们可以将其用作**用户表**和**组表**（稍后讨论）属性的值。
- en: The **User Name Column** property must contain the column in the **User Table**
    property that contains the usernames. The **Password Column** property value must
    be the name of the column in the **User Table** property that contains the user's
    password. The value of the **Group Table** property must be the name of the table
    containing user groups. The **Group Name Column** property must contain the name
    of the column in the **Group Table** property containing user group names.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户名列**属性必须包含在**用户表**属性中包含用户名的列。**密码列**属性值必须是**用户表**属性中包含用户密码的列的名称。**组表**属性值必须是包含用户组的表的名称。**组名列**属性必须包含在**组表**属性中包含用户组名称的列的名称。'
- en: All other properties are optional and, in most cases, left blank. Of special
    interest is the **Digest Algorithm** property. This property allows us to specify
    the message digest algorithm to use to hash the user's password. Valid values
    for this property include all algorithms supported by the JDK. These algorithms
    are MD2, MD5, SHA-1, SHA-256, SHA-384, and SHA-512\. Additionally, if we wish
    to store user passwords in clear text, we can do so by using the value `none`
    for this property.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他属性都是可选的，在大多数情况下留空。特别值得注意的是**摘要算法**属性。此属性允许我们指定用于散列用户密码的消息摘要算法。此属性的合法值包括
    JDK 所支持的所有算法。这些算法包括 MD2、MD5、SHA-1、SHA-256、SHA-384 和 SHA-512。此外，如果我们希望以明文形式存储用户密码，我们可以通过为此属性使用值
    `none` 来实现。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MD2, MD5, and SHA-1 are not very secure, and in most cases should not be used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: MD2、MD5 和 SHA-1 并不是很安全，在大多数情况下不应使用。
- en: Once we have defined our JDBC realm, we need to configure our application via
    its `web.xml` and `glassfish-web.xml` deployment descriptors. Configuring an application
    to rely on a JDBC realm for authorization and authentication is done just like
    when using any other type of realm.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的 JDBC 域，我们需要通过其 `web.xml` 和 `glassfish-web.xml` 部署描述符来配置我们的应用程序。配置应用程序以依赖
    JDBC 域进行授权和认证的方式与使用任何其他类型的域相同。
- en: In addition to declaring that we will rely on the JDBC realm for authentication
    and authorization, just like with other types of realms, we need to map the roles
    defined in the `web.xml` deployment descriptor to security group names. This is
    accomplished in the `glassfish-web.xml` deployment descriptor.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 除了声明我们将依赖 JDBC 域进行认证和授权之外，就像使用其他类型的域一样，我们还需要将 `web.xml` 部署描述符中定义的角色映射到安全组名称。这可以在
    `glassfish-web.xml` 部署描述符中完成。
- en: 'A JDBC realm can be created from the command line by executing the following
    command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行以下命令从命令行创建 JDBC 域：
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Defining custom realms
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义自定义域
- en: 'Although the predefined realm types should cover the vast majority of cases,
    we can create custom realm types if the provided ones don''t meet our needs. Doing
    so involves coding custom `Realm` and `LoginModule` classes. Let''s first discuss
    the custom `Realm` class as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管预定义的域类型应该涵盖绝大多数情况，但如果我们提供的类型不符合我们的需求，我们可以创建定制的域类型。这样做需要编写定制的 `Realm` 和 `LoginModule`
    类。让我们首先讨论定制的 `Realm` 类如下：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our custom `Realm` class must extend `com.sun.enterprise.security.auth.realm.IASRealm`.
    This class can be found inside the `security.jar` file, and therefore this JAR
    file must be added to the CLASSPATH before our `Realm` class can be successfully
    compiled.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制 `Realm` 类必须扩展 `com.sun.enterprise.security.auth.realm.IASRealm`。此类位于 `security.jar`
    文件中，因此必须在我们的 `Realm` 类成功编译之前将此 JAR 文件添加到 CLASSPATH 中。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `security.jar` file can be found under `[glassfish installation directory]/glassfish/modules`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`security.jar` 文件可以在 `[glassfish 安装目录]/glassfish/modules` 下找到。'
- en: 'When using Maven or Ivy dependency management, this JAR file can be found in
    the following repository:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Maven 或 Ivy 依赖管理时，此 JAR 文件可以在以下存储库中找到：
- en: '[http://download.java.net/maven/glassfish](http://download.java.net/maven/glassfish)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://download.java.net/maven/glassfish](http://download.java.net/maven/glassfish)'
- en: The group ID is `org.glassfish.security` and the artifact ID is `security`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 组 ID 是 `org.glassfish.security`，而工件 ID 是 `security`。
- en: Our class must override a method called `getGroupNames()`. This method takes
    a single string as a parameter and returns an `Enumeration` parameter. The `String`
    parameter is for the username of the user that is attempting to log in to the
    realm. The `Enumeration` parameter must contain a collection of strings indicating
    what groups the user belongs to. In our simple example, we simply hardcoded the
    groups. In a real application, these groups would be obtained from some kind of
    persistent storage (database, file, and so on).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重写一个名为 `getGroupNames()` 的方法。该方法接受一个字符串作为参数，并返回一个 `Enumeration` 参数。`String`
    参数用于尝试登录域的用户的用户名。`Enumeration` 参数必须包含一个字符串集合，指示用户属于哪些组。在我们的简单示例中，我们只是硬编码了这些组。在实际应用程序中，这些组将从某种持久存储（数据库、文件等）中获取。
- en: The next method our `Realm` class must override is the `getAuthType()` method.
    This method must return a `String` containing a description of the type of authentication
    used by this realm.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重写的下一个 `Realm` 类方法的是 `getAuthType()` 方法。该方法必须返回一个包含此域所使用的认证类型描述的 `String`。
- en: The `getGroupNames()` and `getAuthType()` methods are declared as abstract in
    the `IASRealm` (parent) class. Although the `getJAASContext()` method is not abstract,
    we should nevertheless override it, since the value it returns is used to determine
    the type of authentication to use from the application server's `login.conf` file.
    The return value of this method is used to map the realm to the corresponding
    login module.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGroupNames()` 和 `getAuthType()` 方法在 `IASRealm`（父）类中被声明为抽象的。尽管 `getJAASContext()`
    方法不是抽象的，但我们仍然应该重写它，因为返回的值用于确定从应用程序服务器的 `login.conf` 文件中使用的认证类型。此方法的返回值用于将域映射到相应的登录模块。'
- en: 'Finally, our `Realm` class must contain a method to authenticate the user.
    We are free to call it anything we want. Additionally, we can use as many parameters
    of any type as we wish. Our simple example has the values for a single username
    and password hardcoded. Again, a real application would obtain valid credentials
    from some kind of persistent storage. This method is meant to be called from the
    corresponding login module class as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的 `Realm` 类必须包含一个用于认证用户的方法。我们可以自由地给它起任何名字。此外，我们可以使用任何类型的任意数量的参数。我们的简单示例将单个用户名和密码的值硬编码。再次强调，一个真实的应用程序会从某种持久存储中获取有效的凭证。这个方法是从相应的登录模块类中调用的，如下所示：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our login module class must extend `com.sun.appserv.security.AppservPasswordLoginModule`.
    This class is also inside the `security.jar` file. Our login module class only
    needs to override a single method, namely `authenticateUser()`. This method takes
    no parameters and must throw a `LoginException` if user authentication is unsuccessful.
    The `_currentRealm` variable is defined in the parent class and is of type `com.sun.enterprise.security.auth.realm`.
    The `Realm` class is the parent of all `Realm` classes. This variable is initialized
    before the `authenticateUser()` method is executed. The `LoginModule` class must
    verify that this class is of the expected type (`SimpleRealm` in our example).
    If it is not, a `LoginException` must be thrown.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录模块类必须扩展 `com.sun.appserv.security.AppservPasswordLoginModule`。这个类也位于 `security.jar`
    文件中。我们的登录模块类只需要重写一个方法，即 `authenticateUser()`。这个方法不接受任何参数，如果用户认证失败，必须抛出 `LoginException`
    异常。`_currentRealm` 变量在父类中定义，其类型为 `com.sun.enterprise.security.auth.realm`。`Realm`
    类是所有 `Realm` 类的父类。这个变量在执行 `authenticateUser()` 方法之前被初始化。`LoginModule` 类必须验证这个类是否为预期的类型（在我们的例子中是
    `SimpleRealm`）。如果不是，必须抛出 `LoginException` 异常。
- en: Two other variables that are defined in the parent class and initialized before
    the `authenticateUser()` method is executed are `_username` and `_password`. These
    variables contain the credentials the user entered in the login form (for form-based
    authentication) or pop-up window (for basic authentication). Our example simply
    passes these values to the `Realm` class so that it can verify the user credentials.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `authenticateUser()` 方法之前定义并初始化的两个其他变量是 `_username` 和 `_password`。这些变量包含用户在登录表单（对于基于表单的认证）或弹出窗口（对于基本认证）中输入的凭证。在我们的例子中，我们简单地将这些值传递给
    `Realm` 类，以便它可以验证用户凭证。
- en: The `authenticateUser()` method must call the parent class's `commitUserAuthentication()`
    method upon successful authentication. This method takes an array of string objects
    containing the group the user belongs to. Our example simply invokes the `getGroupNames()`
    method defined in the `Realm` class and adds the elements of the `Enumeration`
    parameter it returns to an array; it then passes that array to `commitUserAuthentication()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功认证后，`authenticateUser()` 方法必须调用父类的 `commitUserAuthentication()` 方法。这个方法接受一个包含用户所属组的字符串对象数组。在我们的例子中，我们简单地调用
    `Realm` 类中定义的 `getGroupNames()` 方法，并将它返回的 `Enumeration` 参数的元素添加到一个数组中；然后将这个数组传递给
    `commitUserAuthentication()`。
- en: GlassFish is unaware of the existence of our custom realm and login module classes.
    We need to add these classes to GlassFish's CLASSPATH. The easiest way to do this
    is to copy the JAR file containing our custom realm and login module at `[glassfish
    installation directory]/glassfish/domains/domain1/lib`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish 对我们的自定义领域和登录模块类不存在认知。我们需要将这些类添加到 GlassFish 的 CLASSPATH 中。最简单的方法是将包含我们的自定义领域和登录模块的
    JAR 文件复制到 `[glassfish 安装目录]/glassfish/domains/domain1/lib`。
- en: 'The last step we need to follow before we can authenticate applications against
    our custom realm is to add our new custom realm to the domain''s `login.conf`
    file as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以对我们的自定义领域进行应用程序认证之前，我们需要遵循的最后一步是将我们的新自定义领域添加到域的 `login.conf` 文件中，如下所示：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The value before the opening brace must match the return value of the `getJAASContext()`
    method defined in the `Realm` class. It is in this file that the `Realm` and `LoginModule`
    classes are linked to each other. The GlassFish domain needs to be restarted for
    this change to take effect.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 开括号前的值必须与 `Realm` 类中定义的 `getJAASContext()` 方法的返回值匹配。在这个文件中，`Realm` 和 `LoginModule`
    类被链接在一起。GlassFish 域需要重新启动才能使这个更改生效。
- en: 'We are now ready to use our custom realm to authenticate users in our applications.
    We need to add a new realm of the type we created via GlassFish''s admin console
    as shown in the following screenshot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用我们的自定义领域在我们的应用程序中验证用户。我们需要通过GlassFish的管理控制台添加我们创建的新领域类型，如下截图所示：
- en: '![Defining custom realms](img/6886EN_09_31.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![定义自定义领域](img/6886EN_09_31.jpg)'
- en: 'To create our realm, as usual, we need to give it a name. Instead of selecting
    a class name from the dropdown, we need to type it into the text field. Our custom
    realm didn''t have any properties; therefore, we don''t have to add any in this
    example. If it did, they would be added by clicking on the **Add Property** button
    and entering the property name and corresponding value. Our realm would then get
    the properties by overriding the `init()` method from its parent class. This method
    has the following signature:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的领域，像往常一样，我们需要给它一个名称。而不是从下拉菜单中选择类名，我们需要将其输入到文本字段中。我们的自定义领域没有任何属性；因此，在这个例子中我们不需要添加任何属性。如果有，它们将通过点击**添加属性**按钮并输入属性名称和相应的值来添加。然后，我们的领域将通过覆盖其父类的`init()`方法来获取属性。此方法具有以下签名：
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The instance of `java.util.Properties` it takes as a parameter would be prepopulated
    with the properties entered in the page shown in the screenshot (our custom realm
    doesn't have any properties, but for those that do, properties are entered the
    page shown in the screenshot).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为参数接受的`java.util.Properties`实例将预先填充截图所示页面中输入的属性（我们的自定义领域没有任何属性，但对于那些有属性的情况，属性是在截图所示的页面中输入的）。
- en: Once we have added the pertinent information for our new custom realm, we can
    use it just like we use any of the predefined realms. Applications need to specify
    its name as the value of the `<realm-name>` element of the application's `web.xml`
    deployment descriptor. Nothing extraordinary needs to be done at the application
    level.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为我们的新自定义领域添加了相关信息，我们就可以像使用任何预定义领域一样使用它。应用程序需要指定其名称作为应用程序`web.xml`部署描述符中`<realm-name>`元素的值。在应用程序级别不需要做任何特别的事情。
- en: 'Just like with standard realms, custom realms can be added via the `asadmin`
    command-line utility, for example, for our custom realm, we would execute the
    following command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标准领域一样，可以通过`asadmin`命令行实用程序添加自定义领域，例如，对于我们的自定义领域，我们将执行以下命令：
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to use GlassFish's default realms to authenticate
    our web applications. We covered the file realm, which stores user information
    in a flat file, and the certificate realm, which requires client-side certificates
    for user authentication.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用GlassFish的默认领域来验证我们的Web应用程序。我们介绍了文件领域，它将用户信息存储在平面文件中，以及证书领域，它要求客户端证书进行用户身份验证。
- en: We then covered how to create additional realms that behave just like the default
    realms by using the realm classes included with GlassFish.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了如何使用GlassFish包含的领域类创建行为类似于默认领域的额外领域。
- en: We also covered how to use additional `Realm` classes included in GlassFish
    to create realms that authenticate against an LDAP database, against a relational
    database, and how to create realms that integrate with a Solaris server's authentication
    mechanism.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何使用GlassFish中包含的额外`Realm`类来创建针对LDAP数据库、关系数据库进行身份验证的领域，以及如何创建与Solaris服务器身份验证机制集成的领域。
- en: Finally, we covered how to create custom `Realm` classes for cases where the
    included ones don't fit our needs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了如何为那些内置的领域不满足我们需求的情况创建自定义`Realm`类。
- en: In the next chapter, we will cover SOAP web services with JAX-WS.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍使用JAX-WS的SOAP Web服务。
