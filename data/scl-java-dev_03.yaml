- en: Chapter 3. Understanding the Scala Ecosystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。理解 Scala 生态系统
- en: Learning a new language also means getting acquainted with a new ecosystem of
    frameworks and tools. The good news is, in Scala, we can largely inherit the very
    rich and mature set of available tools and libraries from Java. In this chapter,
    we are going to cover the major novelties and additions to the existing ecosystem
    that we, as Java developers, are already familiar with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门新语言也意味着熟悉一套新的框架和工具生态系统。好消息是，在 Scala 中，我们可以大量继承来自 Java 的非常丰富和成熟的工具和库集。在本章中，我们将介绍我们作为
    Java 开发者已经熟悉的现有生态系统的重大新特性添加。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Code editing environments—also known as IDEs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编辑环境——也称为 IDE
- en: SBT—a tool specific to Scala to build, test, and execute code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT——一个针对 Scala 的特定工具，用于构建、测试和执行代码
- en: Utilities as plugins to SBT to integrate with the Java ecosystem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实用工具作为插件集成到 SBT 中，以与 Java 生态系统集成
- en: Scala Worksheets—a novel approach to interactive programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala Worksheets——一种新颖的交互式编程方法
- en: Working with HTTP and interacting with external web-based services, including
    the introduction of "for comprehensions"—a useful Scala construct
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 和与外部基于 Web 的服务交互，包括介绍“for comprehensions”——一个有用的 Scala 构造
- en: Typesafe Activator—a convenient tool to bootstrap projects quickly
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Typesafe Activator——一个方便的工具，可以快速启动项目
- en: Using Scala for scripting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Scala 进行脚本编写
- en: Inheriting Java Integrated Development Environments (IDEs)
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承 Java 集成开发环境（IDE）
- en: 'Scala is supported on all the three major Java IDEs: Eclipse-based (including
    all the different versions of Eclipse, Typesafe''s own bundled version known as
    Scala IDE as well as more commercial IDEs such as SpringSourceSTS), IntelliJ IDEA,
    and NetBeans. This means that you can just keep working as you used to with Java,
    for instance, running Scala JUnit tests inside the IDE, directly debugging or
    remote debugging. The extended Scala support on all of these platforms will provide
    you with the very useful autocompletion feature and instant feedback on the various
    types that are inferred by the compiler. In [Chapter 2](ch02.html "Chapter 2. Code
    Integration"), *Code Integration*, we used NetBeans mostly because it had a convenient,
    small, and ready-to-use database and embedded tools to reverse engineer this database
    into a RESTful API in Java. As the usage of Eclipse targets a larger audience
    and is also the reference IDE that Typesafe provides support to, we are going
    to use it for the following chapters as our main development environment.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 支持所有三个主要的 Java 集成开发环境（IDE）：基于 Eclipse 的（包括所有不同版本的 Eclipse，Typesafe 自带的捆绑版本称为
    Scala IDE，以及更多商业 IDE，如 SpringSourceSTS），IntelliJ IDEA 和 NetBeans。这意味着你可以像以前使用
    Java 一样继续工作，例如，在 IDE 中运行 Scala JUnit 测试，直接调试或远程调试。在这些平台上扩展的 Scala 支持将为你提供非常有用的自动完成功能和编译器推断的各种类型的即时反馈。在[第
    2 章](ch02.html "第 2 章。代码集成")中，*代码集成*，我们主要使用 NetBeans，因为它有一个方便、小巧且现成的数据库和嵌入式工具，可以将此数据库逆向工程为
    Java 的 RESTful API。由于 Eclipse 的使用目标受众更广，也是 Typesafe 提供支持的参考 IDE，因此我们将使用它作为以下章节的主要开发环境。
- en: From the [scala-ide.org](http://scala-ide.org) website, you can download and
    install the Scala IDE for Eclipse either as the bundled version that supports
    Scala or the Scala plugin through the use of update sites (as you would do in
    Java for installing any other Eclipse plugin into an existing environment). All
    instructions to install either the bundled or the plugin versions are very well
    explained on this site, so we won't spend much time here repeating this process.
    Instructions to install IDEA and NetBeans are available from [http://www.jetbrains.com/](http://www.jetbrains.com/)
    and [http://www.netbeans.org/](http://www.netbeans.org/), respectively.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [scala-ide.org](http://scala-ide.org) 网站下载并安装 Scala IDE for Eclipse，无论是支持
    Scala 的捆绑版本还是 Scala 插件，都可以通过使用更新站点（就像您在 Java 中安装任何其他 Eclipse 插件到现有环境中所做的那样）。安装捆绑或插件版本的说明在此网站上解释得非常详细，所以我们不会花太多时间在这里重复这个过程。安装
    IDEA 和 NetBeans 的说明分别可在 [http://www.jetbrains.com/](http://www.jetbrains.com/)
    和 [http://www.netbeans.org/](http://www.netbeans.org/) 找到。
- en: Building with Simple Build Tool (SBT)
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单构建工具（SBT）进行构建
- en: A major addition to the Java ecosystem when dealing with Scala is **Simple Build
    Tool** (**SBT**), a flexible build system written in Scala that also powers both
    Typesafe Activator, which we used in the previous chapters, and the Play framework
    that we will cover later on in this book. In contrast to the existing XML formats
    used by Ant and Maven in Java environments, SBT build definitions are written
    in Scala in the form of a **Domain Specific Language** (**DSL**), having the benefit
    of compile-time checking. As we will see in this section, SBT provides a number
    of additional convenient features. In addition to its dependency management ability
    based on Ivy and supporting Maven-format repositories, SBT offers both incremental
    compilation and an interactive shell (that is, the REPL we were using earlier).
    It also supports continuous testing and deployment, and integrates with many Scala
    test frameworks, making it the de facto build tool for the Scala community.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 Scala 时，Java 生态系统的一个主要补充是 **Simple Build Tool**（**SBT**），这是一个用 Scala 编写的灵活的构建系统，它还驱动了我们在前几章中使用的
    Typesafe Activator，以及我们将在本书后面部分介绍的 Play 框架。与 Java 环境中 Ant 和 Maven 使用的现有 XML 格式相比，SBT
    构建定义是以 Scala 的形式编写的 **领域特定语言**（**DSL**），具有编译时检查的优势。正如我们将在本节中看到的那样，SBT 提供了许多额外的便利功能。除了基于
    Ivy 的依赖管理能力以及支持 Maven 格式存储库之外，SBT 还提供增量编译和交互式外壳（即我们之前使用的 REPL）。它还支持持续测试和部署，并与许多
    Scala 测试框架集成，使其成为 Scala 社区的实际构建工具。
- en: Getting started with SBT
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 SBT
- en: SBT consists of a single `.jar` archive as well as a very small start script.
    Therefore, it can be installed and run on any platform that supports JVM. Installation
    instructions are available at [http://www.scala-sbt.org/](http://www.scala-sbt.org/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SBT 由一个单独的 `.jar` 存档以及一个非常小的启动脚本组成。因此，它可以在支持 JVM 的任何平台上安装和运行。安装说明可在 [http://www.scala-sbt.org/](http://www.scala-sbt.org/)
    找到。
- en: Creating a sample project
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建示例项目
- en: 'Once SBT is in your path (we used Version 0.13.0 at the time of writing this
    book), create a directory called `SampleProject` anywhere in your filesystem by
    entering the following commands in a terminal window:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 SBT 被添加到你的路径中（在撰写本书时，我们使用了版本 0.13.0），在任何文件系统中创建一个名为 `SampleProject` 的目录，通过在终端窗口中输入以下命令：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To end the SBT session, enter the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束 SBT 会话，请输入以下命令：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create a `build.sbt` file under the project root. This file gathers
    information about the project, that is, the equivalent of the Maven's `.pom` file
    in the Java world except that `build.sbt` compiles to Scala rather than being
    XML. The whole file structure of the project is illustrated in a diagram later
    on, once we have added some library dependencies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目根目录下创建一个 `build.sbt` 文件。此文件收集有关项目的信息，即在 Java 世界中相当于 Maven 的 `.pom` 文件，但
    `build.sbt` 编译成 Scala 而不是 XML。项目的整个文件结构将在稍后通过图表展示，一旦我们添加了一些库依赖项。
- en: 'Open and edit `build.sbt` to fill out the basic information as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打开并编辑 `build.sbt` 以填写以下基本信息：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the extra line between each statement is important. The `.sbt` files
    are not Scala programs; they are a list of Scala expressions, where a blank line
    is the delimiter between these expressions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个陈述之间的额外空行很重要。`.sbt` 文件不是 Scala 程序；它们是一系列 Scala 表达式，其中空白行是这些表达式之间的分隔符。
- en: We are now going to import our empty project into our IDE before we start writing
    some code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们将把我们的空项目导入到我们的 IDE 中。
- en: Importing the project in Eclipse, IntelliJ IDEA, and NetBeans
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Eclipse、IntelliJ IDEA 和 NetBeans 中导入项目
- en: 'The `sbteclipse` plugin is available to adapt a pure SBT project to an Eclipse
    project. You just need to create a `plugins.sbt` file under the `project/` directory
    and type the following line into it to import the `sbteclipse` plugin:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbteclipse` 插件可用于将纯 SBT 项目适配为 Eclipse 项目。你只需在 `project/` 目录下创建一个 `plugins.sbt`
    文件，并将以下行输入到其中以导入 `sbteclipse` 插件：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding given string is a way in SBT to express a dependency to a Maven
    library; it is the equivalent to what you would normally write into a `pom` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之前给出的字符串是 SBT 中表达对 Maven 库依赖的一种方式；它相当于你通常会在 `pom` 文件中写入的内容：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You see, downloading libraries and their dependencies in SBT is pretty much
    the same as working with Maven; they will be fetched from Maven repositories (Maven
    central and some other common repositories are already referenced by default in
    SBT; this is why you do not have to write them explicitly).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，在 SBT 中下载库及其依赖项与使用 Maven 几乎相同；它们将从 Maven 仓库（Maven central 和一些其他常用仓库在 SBT
    中默认引用；这就是为什么你不需要明确写出它们）中获取。
- en: Note that eventually you should use a different version number as this plugin
    evolves from time to time. The current version is available together with the
    plugin documentation at [https://github.com/typesafehub/sbteclipse](https://github.com/typesafehub/sbteclipse).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最终你应该使用不同的版本号，因为这个插件随着时间的推移而演变。当前版本与插件文档一起在 [https://github.com/typesafehub/sbteclipse](https://github.com/typesafehub/sbteclipse)
    中提供。
- en: 'Once `SampleProject/project/plugins.sbt` is present in your project, you can
    simply execute the following command to generate an Eclipse compliant project
    (still from the root of the project):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `SampleProject/project/plugins.sbt` 出现在你的项目中，你只需简单地执行以下命令即可生成一个 Eclipse 兼容的项目（仍然从项目的根目录开始）：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now just start your Eclipse IDE if you haven't already done so, then select
    **File** |**Import...**. Navigate to **General** | **Existing Projects into Workspace**.
    Browse to the root directory of your project as you would do in Java and click
    on **OK**. Then, click on **Finish** to complete the import of the project, which
    will appear in the **Project Explorer** window.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你还没有这样做，请启动你的 Eclipse IDE，然后选择 **文件** | **导入...**。导航到 **通用** | **将现有项目导入工作区**。浏览到你的项目根目录，就像在
    Java 中做的那样，然后点击 **确定**。然后，点击 **完成** 以完成项目的导入，它将出现在 **项目资源管理器** 窗口中。
- en: '**IntelliJ** also has its plugin, which is available at [https://github.com/mpeltonen/sbt-idea](https://github.com/mpeltonen/sbt-idea).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**IntelliJ** 也拥有其插件，可在 [https://github.com/mpeltonen/sbt-idea](https://github.com/mpeltonen/sbt-idea)
    找到。'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that for the various IDEs, there are two plugin concepts: **SBT plugins**
    for particular IDEs and **IDE plugins** for SBT.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于各种 IDE，有两个插件概念：**特定 IDE 的 SBT 插件**和**SBT 的 IDE 插件**。
- en: The sbteclipse, sbt-idea, and nbsbt ([https://github.com/dcaoyuan/nbscala/wiki/SbtIntegrationInNetBeans](https://github.com/dcaoyuan/nbscala/wiki/SbtIntegrationInNetBeans))
    plugins are all SBT plugins that require modifications to your `plugins.sbt` file.
    When you run the appropriate SBT command, they generate project files to be used
    by Eclipse, IntelliJ, or NetBeans. When you update your SBT files, you may need
    to rerun the plugin in order to update your IDE configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: sbteclipse、sbt-idea 和 nbsbt ([https://github.com/dcaoyuan/nbscala/wiki/SbtIntegrationInNetBeans](https://github.com/dcaoyuan/nbscala/wiki/SbtIntegrationInNetBeans))
    插件都是需要修改你的 `plugins.sbt` 文件的 SBT 插件。当你运行适当的 SBT 命令时，它们会生成用于 Eclipse、IntelliJ 或
    NetBeans 的项目文件。当你更新你的 SBT 文件时，你可能需要重新运行插件以更新你的 IDE 配置。
- en: However, if an IntelliJ user browses the available IntelliJ plugins, then they
    will see a different Scala plugin there ([http://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA](http://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA)).
    This is an add-on for IntelliJ, rather than an add-on for SBT. It helps IntelliJ
    to configure itself around an SBT project automatically, without the need for
    any modification to your SBT files or extra commands. This approach is arguably
    more popular in the IntelliJ community.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个 IntelliJ 用户浏览可用的 IntelliJ 插件，那么他们将在那里看到一个不同的 Scala 插件（[http://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA](http://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA)）。这是一个
    IntelliJ 的附加组件，而不是 SBT 的附加组件。它帮助 IntelliJ 自动配置其自身以适应 SBT 项目，无需修改你的 SBT 文件或额外的命令。这种方法在
    IntelliJ 社区中可能更受欢迎。
- en: 'If you use Maven and Eclipse in the Java world, then this is pretty much the
    same story as the m2eclipse Eclipse plugin versus the eclipse: eclipse Maven plugin.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Maven 和 Java 世界中的 Eclipse，那么这与 m2eclipse Eclipse 插件与 eclipse Maven 插件的故事大致相同。
- en: 'Similar to Eclipse, you should edit a `plugins.sbt` file under `project/` and
    place the dependency to the `sbt-idea` plugin as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Eclipse 类似，你应该在 `project/` 下的 `plugins.sbt` 文件中编辑，并将对 `sbt-idea` 插件的依赖项放置如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The command to create an IntelliJ-compliant project is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 IntelliJ 兼容项目的命令如下：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth noting that as of IntelliJ IDEA 13, the IDEA Scala plugin natively
    supports SBT and doesn't require the external plugin to work. Refer to the IntelliJ
    documentation on how to import an SBT project into the IDE.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，截至IntelliJ IDEA 13，IDEA Scala插件原生支持SBT，无需外部插件即可工作。请参阅IntelliJ文档了解如何将SBT项目导入IDE。
- en: 'Sometimes newer versions of the plugin that are not present (yet) in the default
    Maven repositories exist. In this case, you have to add such a repository for
    SBT to be able to upload the plugin/library. You can do this by having an extra
    line as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，插件的新版本尚未出现在默认的Maven存储库中。在这种情况下，您必须为SBT添加这样一个存储库，以便能够上传插件/库。您可以通过添加以下额外的行来完成此操作：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since Scala Version 2.10+, NetBeans also has its plugin:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Scala版本2.10+以来，NetBeans也有其插件：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The plugin itself can be downloaded and built from a GitHub repository as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件本身可以从GitHub存储库下载和构建，如下所示：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `publish-local` command will deploy it locally on your filesystem. Then,
    creating the files for your project is done using the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish-local`命令将在您的文件系统上本地部署它。然后，使用以下命令创建您项目的文件：'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are going to continue the chapter adopting Eclipse as our IDE, but most of
    the tools should also work under the other IDEs. Moreover, if you need additional
    integration with other editors such as ENSIME and Sublime Text, browse the documentation
    at [http://www.scala-sbt.org](http://www.scala-sbt.org).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续本章，采用Eclipse作为我们的IDE，但大多数工具也应该在其他IDE下工作。此外，如果您需要与其他编辑器（如ENSIME和Sublime
    Text）的额外集成，请浏览[http://www.scala-sbt.org](http://www.scala-sbt.org)的文档。
- en: Once the project is imported into Eclipse, you will notice that the file structure
    is the same as for Maven projects; source files have the default directories `src/main/scala`
    and `src/test/scala`, and this is the same structure for Java too.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目被导入到Eclipse中，您会注意到文件结构与Maven项目相同；源文件有默认目录`src/main/scala`和`src/test/scala`，这与Java的结构也相同。
- en: Creating a web application that runs on a servlet container
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在servlet容器上运行的Web应用创建
- en: 'Among the growing list of available SBT plugins is the xsbt-web-plugin (available
    at [https://github.com/JamesEarlDouglas/xsbt-web-plugin](https://github.com/JamesEarlDouglas/xsbt-web-plugin)),
    a useful plugin to create traditional web apps that runs on a servlet container
    (such as Jetty). As for the plugins we''ve previously seen, installation consists
    of adding single line to the `plugins.sbt` file as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用的SBT插件日益增长列表中，xsbt-web-plugin（可在[https://github.com/JamesEarlDouglas/xsbt-web-plugin](https://github.com/JamesEarlDouglas/xsbt-web-plugin)找到）是一个有用的插件，用于创建在servlet容器（如Jetty）上运行的传统的Web应用。至于我们之前看到的插件，安装只需在`plugins.sbt`文件中添加一行，如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, add the following line to the `build.sbt` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下行添加到`build.sbt`文件中：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also need to include Jetty in the container classpath as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将Jetty包含在容器类路径中，如下所示：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The whole minimal `build.sbt` file is given as a summary, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 整个最小`build.sbt`文件如下总结：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we have updated our build file with new dependencies, we need to rerun `sbteclipse`
    to update the Eclipse files for our project. This operation can be achieved by
    re-entering from the SBT command prompt:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经更新了构建文件中的新依赖项，我们需要重新运行`sbteclipse`来更新项目的Eclipse文件。此操作可以通过从SBT命令提示符重新进入来实现：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s now write a tiny servlet in Scala in the IDE to exhibit our small sample
    logic, which mimics the Java syntax. Right-click on the root of the project in
    the **Package Explorer** window, and select **Refresh** to make sure the new dependencies
    are picked up. The whole structure of the project is shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在IDE中用Scala编写一个微型的servlet，以展示我们的简单示例逻辑，它模仿Java语法。在**包资源管理器**窗口中右键单击项目根目录，选择**刷新**以确保新依赖项被获取。项目的整个结构如下截图所示：
- en: '![Creating a web application that runs on a servlet container](img/3637_03_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![在servlet容器上运行的Web应用创建](img/3637_03_05.jpg)'
- en: 'We can now start editing a new Scala file under `src/main/scala` (in a new
    `com.samples` package) as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`src/main/scala`（在一个新的`com.samples`包中）下开始编辑一个新的Scala文件，如下所示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we need to add a `web.xml` file as we would normally do in Java to
    configure the servlet deployment (to be put under the `src/main/webapp/WEB-INF`
    directory) as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个`web.xml`文件，就像我们在Java中通常所做的那样，以配置servlet部署（应放在`src/main/webapp/WEB-INF`目录下），如下所示：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From the root of the project, in our command prompt, we are now ready to deploy
    and execute our little example in the Jetty container by invoking `sbt` as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目根目录开始，在我们的命令提示符中，我们现在可以调用 `sbt` 来部署和执行我们在 Jetty 容器中的小示例，如下所示：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, the container will listen on localhost at port 8080.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器将在本地的 8080 端口上监听。
- en: 'You can now open `http://localhost:8080/` on a web browser and verify whether
    we get the Hello, world! message as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在网页浏览器中打开 `http://localhost:8080/` 并验证是否得到以下截图所示的 Hello, world! 消息：
- en: '![Creating a web application that runs on a servlet container](img/3637_03_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个在 servlet 容器上运行的 Web 应用程序](img/3637_03_06.jpg)'
- en: 'You may also run the `package` command from SBT that will assemble a `.war`
    archive and put it under `target/scala-2.10/sampleproject_2.10-1.0.war` as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从 SBT 运行 `package` 命令，这将组装一个 `.war` 归档并将其放置在 `target/scala-2.10/sampleproject_2.10-1.0.war`
    下，如下所示：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using sbt-assembly to build a single .jar archive
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sbt-assembly 构建单个 .jar 归档
- en: The sbt-assembly plugin can gather all your project code and its dependencies
    into a single `.jar` file that can be published into a repository or deployed
    on other environments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: sbt-assembly 插件可以将你的项目代码及其依赖项收集到一个单独的 `.jar` 文件中，该文件可以发布到仓库或部署到其他环境中。
- en: 'Installing the plugin consists of adding sbt-assembly as a dependency in `project/assembly.sbt`
    (from SBT 0.13), as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安装插件包括将 sbt-assembly 添加为 `project/assembly.sbt` 中的依赖项（从 SBT 0.13 开始），如下所示：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To be able to run the assembly command within SBT, you just need to create
    an `assembly.sbt` file in the project root directory as shown in the following
    code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SBT 中运行 assembly 命令，你只需在项目根目录下创建一个 `assembly.sbt` 文件，如下代码片段所示：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Assembly settings are documented at [https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly).
    They enable you to modify, for example, the `jarName` or the `outputPath`, variables
    as well as skipping tests during the assembly phase or setting a main class explicitly
    if you wish to create a runnable `.jar` file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有关汇编设置的文档请参阅 [https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly)。它们允许你修改，例如，`jarName`
    或 `outputPath` 变量，以及在汇编阶段跳过测试或显式设置主类，如果你希望创建可运行的 `.jar` 文件的话。
- en: Formatting code with Scalariform
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Scalariform 格式化代码
- en: Automatic code formatting is a useful feature not only for its ability to apply
    the same formatting rules to code written by various individuals but also to make
    the differences appear more consistently in a source management tool.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自动代码格式化是一个有用的功能，不仅因为它能够将相同的格式化规则应用于由不同个人编写的代码，而且还使差异在源管理工具中更加一致。
- en: 'The Scala IDE for Eclipse uses Scalariform as its code formatter, which is
    also available as an sbt-plugin that can be added to the `plugins.sbt` file as
    follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Scala IDE for Eclipse 使用 Scalariform 作为其代码格式化工具，该工具也作为 sbt-plugin 插件提供，可以添加到
    `plugins.sbt` 文件中，如下所示：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you have it in place, Scalariform will format your source code automatically
    whenever you run `compile` or `test:compile` in SBT.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，Scalariform 将在运行 SBT 中的 `compile` 或 `test:compile` 时自动格式化你的源代码。
- en: In Eclipse, formatting code is performed the same way as with Java, that is,
    right-clicking in the editor and then navigating to **Source** | **Format** (or
    *Ctrl* + *Shift* + *F*).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse 中，格式化代码的方式与 Java 相同，即右键单击编辑器，然后导航到 **源** | **格式化**（或 *Ctrl* + *Shift*
    + *F*）。
- en: Experimenting with Scala Worksheets
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试 Scala 工作表
- en: In the previous chapters, we had run the REPL as an interactive environment
    to experiment and get immediate feedback when entering the Scala syntax. This
    allowed us to very quickly write some small algorithms and get the right syntax
    to make things work. Although the SBT console provides programmers with a `:replay`
    command to rerun what has already been written in the session, wouldn't it be
    nice to be able to save our experiments for later use, as part of our project
    ? This is exactly what **Scala Worksheets** are all about.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们曾将 REPL 作为交互式环境运行，以便在输入 Scala 语法时进行实验并获得即时反馈。这使我们能够非常快速地编写一些小算法，并得到正确的语法使事物工作。尽管
    SBT 控制台为程序员提供了一个 `:replay` 命令来重新运行会话中已经编写的内容，但能够将我们的实验保存下来以供以后使用，作为我们项目的一部分，岂不是更好？这正是
    **Scala 工作表** 的全部意义。
- en: Scala Worksheet is an innovative feature of the Scala support for Eclipse that
    brings an interactive environment, that is, a REPL in the context of a project.
    This feature is also now available on the Scala support for IntelliJ.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Scala工作表是Scala对Eclipse支持的独特功能，它带来一个交互式环境，即在项目上下文中的REPL。此功能现在也适用于Scala对IntelliJ的支持。
- en: Let's go to our small servlet sample in Eclipse to try it out.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去我们的Eclipse中的小型servlet示例中尝试一下。
- en: 'To start a worksheet, right-click on any package or source file and navigate
    to **New** | **Scala Worksheet** (or if not present in the drop-down list, navigate
    to **Other...** | **Scala Wizards** | **Scala Worksheet**), as shown in the following
    screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动工作表，右键单击任何包或源文件，然后导航到**新建** | **Scala工作表**（如果不在下拉列表中，导航到**其他...** | **Scala向导**
    | **Scala工作表**），如下面的截图所示：
- en: '![Experimenting with Scala Worksheets](img/3637_03_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![实验Scala工作表](img/3637_03_07.jpg)'
- en: 'We will choose, for example, the current `com.samples` package. Click on **Next**
    and enter a name for your worksheet: `experiment`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将选择当前的`com.samples`包。点击**下一步**并为你的工作表输入一个名称：`experiment`。
- en: This will create a file named `experiment.sc` that is saved within the source
    code but as it is not a `.scala` file, it will not be in conflict with the rest
    of our current code base nor be present in the deployed `.jar` archive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`experiment.sc`的文件，它保存在源代码中，但由于它不是一个`.scala`文件，因此它不会与我们的当前代码库冲突，也不会出现在部署的`.jar`归档中。
- en: 'The default page looks like the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认页面看起来像以下代码片段：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Everything after the `>` sign on each statement is the result of the evaluation
    that gets (re)evaluated as soon as you save the Worksheet file. You may try out
    a few statements, for instance, by replacing the `println` statement with a few
    lines, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句后面的`>`符号之后的内容是评估的结果，一旦你保存Worksheet文件，这些结果就会被（重新）评估。你可以尝试一些语句，例如，通过替换`println`语句为几行，如下所示：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As soon as you save it (*Ctrl* + *S*), the style sheet will display statement
    evaluations on the right-hand side as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你保存它（*Ctrl* + *S*），样式表将在右侧显示语句评估，如下面的截图所示：
- en: '![Experimenting with Scala Worksheets](img/3637OS_03_08.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![实验Scala工作表](img/3637OS_03_08.jpg)'
- en: Working with HTTP
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP进行工作
- en: As Scala can import and invoke Java classes as well as extend them, many of
    the Scala libraries available as part of the Scala ecosystem are only a thin layer
    on top of robust and mature Java libraries, to either provide additional features
    or simplify their usage by adding some syntactic sugar.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Scala可以导入和调用Java类，也可以扩展它们，因此Scala生态系统中的许多库只是建立在强大且成熟的Java库之上的一个薄层，要么提供额外的功能，要么通过添加一些语法糖来简化它们的用法。
- en: One such example is the Scala dispatch library (available at [http://dispatch.databinder.net/Dispatch.html](http://dispatch.databinder.net/Dispatch.html)),
    a useful library to achieve HTTP interaction based on Apache's robust HttpClient.
    Let's run a little dispatch session in the REPL.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的例子之一是Scala分发库（可在[http://dispatch.databinder.net/Dispatch.html](http://dispatch.databinder.net/Dispatch.html)找到），这是一个基于Apache强大HttpClient的HTTP交互的有用库。让我们在REPL中运行一个小型的分发会话。
- en: 'As dispatch is an external library; we first need to import it into our SBT
    project to be able to use it from the REPL console. Add the dispatch dependency
    to the `build.sbt` file of the `SampleProject` so that it looks like the following
    code snippet (make sure to have a blank line between statements in `build.sbt`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分发是一个外部库；我们首先需要将其导入到我们的SBT项目中，以便能够在REPL控制台中使用它。将分发依赖项添加到`SampleProject`的`build.sbt`文件中，使其看起来像以下代码片段（确保在`build.sbt`中的语句之间有一个空白行）：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Restart the REPL to make the libraries available, and import them into the
    session as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动REPL以使库可用，并按以下方式将它们导入会话中：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s make a basic request to an online geolocation service, where the REST
    API is a simple `GET` request to the `freegeoip.net/{format}/{ip_or_hostname}`
    URL as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向在线地理位置服务发送一个基本请求，其中REST API是一个简单的`GET`请求到`freegeoip.net/{format}/{ip_or_hostname}`
    URL，如下所示：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we will send the `GET` request through HTTP and take the response as a
    string (wrapping XML as this is what we ask as response format from the service):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过HTTP发送`GET`请求，并将响应作为字符串接收（将XML包装起来，这是我们要求的服务响应格式）：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice the result type of `dispatch.Future[String]` returned by the interpreter.
    The previous versions of dispatch were synchronous (and still available under
    the library name, `dispatch-classic`) but the latest versions such as the one
    we are using cope with modern development practices, namely asynchrony. We will
    study the asynchronous Scala code later in [Chapter 8](ch08.html "Chapter 8. Essential
    Properties of Modern Applications – Asynchrony and Concurrency"), *Essential Properties
    of Modern Applications – Asynchrony and Concurrency*, but similar to Java, `Future`
    acts as a placeholder for a computation that does not block. This means that we
    can continue the flow of the program without waiting for the variable to be populated,
    which is convenient when invoking potentially long-running method calls (such
    as a REST service). Note, however, that here `dispatch.Future` is a different
    implementation than `java.util.concurrent.Future`, which is found in the standard
    Java library.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到解释器返回的`dispatch.Future[String]`的结果类型。之前版本的dispatch是同步的（并且仍然在`dispatch-classic`库名下可用），但最新版本，如我们正在使用的版本，处理现代开发实践，即异步。我们将在[第8章](ch08.html
    "第8章. 现代应用程序的基本属性 – 异步和并发")中学习异步Scala代码，*现代应用程序的基本属性 – 异步和并发*，但与Java类似，`Future`充当一个不阻塞的计算占位符。这意味着我们可以在等待变量填充之前继续程序的流程，这在调用可能长时间运行的方法调用（如REST服务）时非常方便。然而，请注意，这里的`dispatch.Future`与Java标准库中的`java.util.concurrent.Future`是不同的实现。
- en: 'To read and display the result of our HTTP request, we can just type the following
    command lines:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取和显示我们的HTTP请求的结果，我们只需输入以下命令行：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Calling `result()` here is the syntactic sugar for actually calling the `result.apply()`
    method, a convenient way to make code look elegant in many situations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里调用`result()`实际上是调用`result.apply()`方法的语法糖，这是一种在许多情况下使代码看起来优雅的便捷方式。
- en: Dispatch provides a lot of ways to handle both the request, such as adding headers
    and parameters, and the processing of the response such as handling the response
    as XML or JSON, splitting into two different handlers or dealing with streams.
    To exhibit these behaviors, we are going to call another online service as an
    example, the **Groupon** service. Groupon is a service that offers discount coupons
    when you buy a product or service such as holidays, beauty products, and so on
    in a variety of categories. The Groupon API can be queried to gather offerings
    within a geographic location determined by either city or coordinates (latitude
    and longitude).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Dispatch提供了许多处理请求和响应的方式，例如添加头和参数，以及将响应作为XML或JSON处理，分割成两个不同的处理器或处理流。为了展示这些行为，我们将以调用另一个在线服务为例，即**Groupon**服务。Groupon是一个提供折扣券的服务，当你在各种类别中购买产品或服务（如假期、美容产品等）时，可以提供折扣券。Groupon
    API可以查询以收集由城市或坐标（纬度和经度）确定的地理位置内的提供信息。
- en: 'To be able to experiment with the API, upon registration to the [http://www.groupon.com/pages/api](http://www.groupon.com/pages/api)
    URL, you should obtain a unique `client_id` key that authenticates you and that
    you have to pass along whenever you call the API. Let''s illustrate this in the
    REPL:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够实验API，在注册到[http://www.groupon.com/pages/api](http://www.groupon.com/pages/api)
    URL后，你应该获得一个唯一的`client_id`密钥，该密钥用于验证你，并且每次调用API时都必须传递。让我们在REPL中演示这一点：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The REPL limits the amount of output for better readability. Instead of getting
    the response as a string, let''s handle it as XML:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: REPL限制了输出的数量以获得更好的可读性。而不是将响应作为字符串获取，让我们将其作为XML处理：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time our result is more structured as it is represented as an XML tree.
    We can print it in a better format by applying a `PrettyPrinter` object that will
    make the output fit within a width of 90 characters with an indentation of 2:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们的结果是更结构化的，因为它被表示为一个XML树。我们可以通过应用一个`PrettyPrinter`对象来以更好的格式打印它，该对象将输出宽度限制在90个字符，缩进为2：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Extracting partial information from our XML structure can be achieved by applying
    the `map` transformations including XPath expressions. XPath expressions are useful
    to navigate through XML elements to retain only the relevant parts. We can progressively
    extract pieces of XML and return them as collections such as `Lists` or `Seqs`
    (sequences), as shown in the following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的XML结构中提取部分信息可以通过应用`map`转换，包括XPath表达式来实现。XPath表达式对于在XML元素间导航以保留相关部分非常有用。我们可以逐步提取XML片段，并将它们作为`Lists`或`Seqs`（序列）等集合返回，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we got back a sequence of city names for which there are coupons available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们得到了一个城市名称序列，这些城市有优惠券可用。
- en: Scala's for comprehension
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 的 for comprehension
- en: 'Instead of applying successive `map` transformations to extract XML, in Scala,
    we can use a powerful construct that represents the silver bullet of iterations
    called `for comprehension` or `for expression`. Unlike the `for` loops found in
    Java and used for iterating, `for comprehension` returns a result. They are specified
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 Scala 中应用连续的 `map` 转换以提取 XML 不同，我们可以使用一个强大的结构，称为 `for comprehension` 或 `for
    expression`，它是迭代的银弹。与在 Java 中找到并用于迭代的 `for` 循环不同，`for comprehension` 返回一个结果。它们如下指定：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, `sequence` can contain the following components:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`sequence` 可以包含以下组件：
- en: '**Generators**: They drive the iteration and are written in the following form:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器**：它们驱动迭代，如下所示：'
- en: '[PRE36]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As for Java loops, `element` represents a local variable bound to the current
    element of the iteration whereas `collection` represents the data to be iterated.
    Moreover, the first generator (there needs to be at least one) determines the
    type of the result. For example, if the input collection is a `List` or a `Vector`,
    the `for comprehension` will yield a `List` or a `Vector`, respectively.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像 Java 循环一样，`element` 代表绑定到迭代当前元素的局部变量，而 `collection` 代表要迭代的集合。此外，第一个生成器（至少需要有一个）决定了结果类型。例如，如果输入集合是
    `List` 或 `Vector`，则 `for comprehension` 将分别产生 `List` 或 `Vector`。
- en: '**Filters**: They control the iteration and are written in the following form:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：它们控制迭代，如下所示：'
- en: '[PRE37]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding expression must evaluate to a Boolean value. Filters can be defined
    either on the same line as generators or separately.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的表达式必须评估为布尔值。过滤器可以定义在生成器所在的同一行，也可以单独定义。
- en: '**Definitions**: They are local variable definitions and are written in the
    following form:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义**：它们是局部变量定义，如下所示：'
- en: '[PRE38]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: They are intermediate values that can contribute to compute the result.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们是中间值，可以有助于计算结果。
- en: 'A `for comprehension` construct is much easier to visualize with a few concrete
    examples:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用几个具体的例子，`for comprehension` 结构更容易可视化：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have transformed `List[Int]` into `List[String]` using only one generator.
    Using two generators is illustrated in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅使用一个生成器就将 `List[Int]` 转换成了 `List[String]`。使用两个生成器的示例如下所示：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can add a filter on any generator. For instance, if we want to retain only
    the uppercase characters of every word, we can write as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何生成器上添加过滤器。例如，如果我们只想保留每个单词的大写字母，我们可以这样写：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the following example, we illustrate how to add a local variable definition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们说明了如何添加局部变量定义：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Going back to our HTTP Groupon service, we can now extract names of cities
    using `for comprehension` as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 HTTP Groupon 服务，我们现在可以使用 `for comprehension` 提取城市名称，如下所示：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To be able to query the second part of the API to retrieve special discount
    deals for a specific area, we also need the latitude and longitude information
    from the queried cities. Let''s do that by returning a tuple including three elements,
    the first one being the name, the second being the latitude, and the third being
    the longitude:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够查询 API 的第二部分以检索特定区域的特殊折扣优惠，我们还需要从查询的城市中获取经纬度信息。让我们通过返回一个包含三个元素的元组来完成这个操作，第一个元素是名称，第二个元素是纬度，第三个元素是经度：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Out of the list of returned cities, we might be interested in just one for
    now. Let''s retrieve only the location for Honolulu using the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的城市列表中，我们可能现在只对其中一个感兴趣。让我们使用以下命令检索檀香山的地理位置：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `find` method in the preceding code takes a predicate as a parameter. As
    its return type is an `Option` value, we can retrieve its content by invoking
    `getOrElse` where we can write a default value in case the `find` method does
    not return any match.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的 `find` 方法接受一个谓词作为参数。由于其返回类型是 `Option` 值，我们可以通过调用 `getOrElse` 来检索其内容，在
    `find` 方法不返回任何匹配项的情况下，我们可以在这里写入默认值。
- en: 'An alternative representation could be done using pattern matching, briefly
    described in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within
    Your Project"), *Programming Interactively within Your Project*, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用模式匹配来表示另一种表示形式，这在 [第 1 章](ch01.html "第 1 章。在项目中交互式编程") 中简要描述，即 *在项目中交互式编程*，如下所示：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The regular syntax of pattern matching normally uses the `match` keyword before
    all the `case` alternatives, so here it is a simplified notation where the `match`
    keyword is implicit. The underscore (`_`) as well as the `city` variable given
    in `case` are wildcards in the pattern matching. We could have given these underscores
    variable names but it is not necessary as we are not using them in the predicate
    (that is, `city == "Honolulu"`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配的常规语法通常在所有 `case` 选项之前使用 `match` 关键字，所以这里是一个简化的表示，其中 `match` 关键字是隐式的。下划线（`_`）以及
    `case` 中给出的 `city` 变量在模式匹配中是通配符。我们本可以给这些下划线变量命名，但这是不必要的，因为我们没有在谓词中使用它们（即 `city
    == "Honolulu"`）。
- en: 'Let''s now create a request to query for all the deals that match a particular
    geographic area:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个请求来查询所有匹配特定地理区域的交易：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'An alternative to handle data as tuples is to define case classes to encapsulate
    elements in a convenient and reusable way. We can, therefore, define a `Deal`
    class and rewrite our previous `for comprehension` statement returning the `Deal`
    instances instead of tuples:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据作为元组的一个替代方案是定义案例类以方便和可重用地封装元素。因此，我们可以定义一个 `Deal` 类，并重写我们之前的 `for comprehension`
    语句，返回 `Deal` 实例而不是元组：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we did previously for retrieving cities, we can now retrieve deals via HTTP
    GET and parse XML this time for the particular city of Honolulu, knowing its latitude
    and longitude, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前用于检索城市一样，我们现在可以通过 HTTP GET 获取交易，这次解析特定城市的 XML，比如檀香山，知道它的纬度和经度，如下所示：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `<<?` operator means that we attach input parameters of a `GET` method
    to the `dealsByGeoArea` request. The `Map` object contains the parameters. It
    is equivalent to the normal representation of HTTP GET where we put the input
    parameters as key/value pairs in the URL (that is, `request_url?param1=value1;param2=value2`).
    This is in contrast with the `<<` operator, which would have specified a `POST`
    request. Creating a structured sequence of `Deal` instances out of the raw XML
    produced by the `dealsInHonolulu()` service call can be written as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<?` 操作符表示我们将 `GET` 方法的输入参数附加到 `dealsByGeoArea` 请求中。`Map` 对象包含这些参数。这相当于 HTTP
    GET 的常规表示，我们将输入参数作为键/值对放在 URL 中（即 `request_url?param1=value1;param2=value2`）。这与
    `<<` 操作符形成对比，后者会指定一个 `POST` 请求。从 `dealsInHonolulu()` 服务调用产生的原始 XML 中创建一个结构化的 `Deal`
    实例序列可以写成如下：'
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Sorting the list of deals by their category is only a matter of applying a
    `groupBy` method on the collection as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按类别对交易列表进行排序只是对集合应用 `groupBy` 方法的问题，如下所示：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice how the `groupBy` method is a very convenient way of applying the `Map`
    part of a **MapReduce** job operating on a collection, in our case creating a
    `Map` object where keys are the tags or categories of the Groupon deals and values
    are a list of the deals that belong to the specific category. A possible tiny
    `Reduce` operation on the `Map` object can, for example, consist of counting the
    number of deals for each category, using the `mapValues` method that transforms
    the values of this (key,value) store:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `groupBy` 方法是应用在集合上的 **MapReduce** 作业的 `Map` 部分的一个非常方便的方法，在我们的例子中，创建一个 `Map`
    对象，其中键是 Groupon 交易的标签或类别，值是特定类别所属的交易列表。对 `Map` 对象的可能的小型 `Reduce` 操作可以包括使用 `mapValues`
    方法来转换这个（键，值）存储的值，从而计算每个类别的交易数量：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The example we went through only explores the surface of what we can do with
    HTTP tools such as dispatch and much more is described in their documentation.
    The direct interaction with the REPL greatly enhances the learning curve of such
    APIs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才的例子只探索了我们可以用 HTTP 工具（如 dispatch）做什么的表面，更多内容可以在它们的文档中找到。与 REPL 的直接交互极大地增强了此类
    API 的学习曲线。
- en: There are several excellent alternatives of lightweight frameworks for dealing
    with HTTP interaction, and in the case of dispatch, we have only looked at the
    client side of things. Lightweight REST APIs can, therefore, be constructed by
    frameworks such as Unfiltered, Finagle, Scalatra, or Spray to name a few. Spray
    is currently being architected again to become the HTTP layer of the Play framework
    (on top of Akka); technologies we are going to cover later on in this book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 HTTP 交互的轻量级框架有很多优秀的替代方案，在派发的情况下，我们只看了客户端的事情。因此，可以通过 Unfiltered、Finagle、Scalatra
    或 Spray 等框架构建轻量级 REST API（仅举几个例子）。Spray 目前正在重新设计，以成为 Play 框架（基于 Akka）的 HTTP 层；我们将在本书后面的章节中介绍这些技术。
- en: Taking advantage of Typesafe Activator
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 Typesafe Activator
- en: To be able to run an interactive programming session in the previous chapters,
    we have downloaded and installed a tool named **Typesafe Activator**. Running
    either as a command-line tool or through a web browser, the activator lets us
    create and execute a sample project out of a template, in this case, a minimal
    `hello-scala` project. From it, we have accessed the SBT console, which acts as
    a REPL.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在前面的章节中运行交互式编程会话，我们已经下载并安装了一个名为**Typesafe Activator**的工具。无论是作为命令行工具还是通过网页浏览器运行，激活器都允许我们从一个模板中创建和执行一个示例项目，在这种情况下，是一个最小的`hello-scala`项目。从中，我们访问了SBT控制台，它充当REPL。
- en: Typesafe Activator can be seen as a lightweight IDE powered by SBT. It provides
    many project templates that programmers can reuse as a starting point in their
    new development project.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Typesafe Activator可以被视为由SBT驱动的轻量级IDE。它提供了许多项目模板，程序员可以将它们作为新开发项目的起点进行重用。
- en: Creating an application based on activator templates
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于激活器模板创建应用程序
- en: 'Open a command terminal window and go to the directory where you extracted
    the activator, then enter the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个命令终端窗口，转到你提取激活器的目录，然后输入以下命令：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You need to enter a name for your new project as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要按照以下方式输入你新项目的名称：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Version 1.0.13 that we are using already contains 76 templates combining diverse
    technologies and frameworks together to make some interesting demo projects, but
    this list is increasing quickly (from 38 to 76 between Version 1.0.0 and 1.0.13,
    which are only a few months apart).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的1.0.13版本已经包含了76个模板，这些模板结合了不同的技术和框架，以创建一些有趣的演示项目，但这个列表正在迅速增长（从1.0.0版本到1.0.13版本，这两个版本之间只相隔几个月，从38个增加到76个）。
- en: 'For now, let''s take a look at the `play-java-spring` template, a project sample
    in Java, so that we can feel comfortable with the code it contains. Therefore,
    enter its name when prompted for the name of the template to be used:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`play-java-spring`模板，这是一个Java项目样本，这样我们就可以熟悉其中包含的代码。因此，当提示输入要使用的模板名称时，输入其名称：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The activator creates a SBT project, meaning you can edit `build.sbt` or `plugins.sbt`
    to add dependencies, repositories (that is, resolvers) as well as SBT plugins.
    We can, for example, reuse the `addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin"
    % "2.4.0")` line in `plugins.sbt` that we stated earlier to be able to create
    Eclipse project files and import the project into our Scala IDE.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 激活器创建了一个SBT项目，这意味着你可以编辑`build.sbt`或`plugins.sbt`来添加依赖项、仓库（即，解析器）以及SBT插件。例如，我们可以重用之前在`plugins.sbt`中提到的`addSbtPlugin("com.typesafe.sbteclipse"
    % "sbteclipse-plugin" % "2.4.0")`行，以便能够创建Eclipse项目文件并将项目导入我们的Scala IDE。
- en: 'First, let''s execute the program to see what it does:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们执行程序来看看它做了什么：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As the sample is based on the Play framework (that we will cover in later chapters),
    the following is displayed to indicate that the web application is deployed on
    localhost at port 9000:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于示例基于Play框架（我们将在后面的章节中介绍），以下显示表明Web应用程序已部署在本地主机的9000端口：
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Open a browser at localhost:9000 to visualize the very basic web form of the
    sample and submit a couple of entries to be stored in the tiny database, as shown
    in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地主机9000上打开浏览器，以可视化示例的基本Web表单，并提交一些条目以存储在小型数据库中，如下面的截图所示：
- en: '![Creating an application based on activator templates](img/3637_03_01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![基于激活器模板创建应用程序](img/3637_03_01.jpg)'
- en: This web application takes an input from a simple HTML form and saves `Bar`
    objects into a small database through JPA.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Web应用程序从简单的HTML表单中获取输入，并通过JPA将`Bar`对象保存到小型数据库中。
- en: 'To take a look at the code that is part of this template; we can run it through
    the activator by first pressing *Ctrl* + *D* in the command window to interrupt
    the current execution, and then, enter the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此模板中包含的代码，我们可以通过在命令窗口中首先按*Ctrl* + *D*来中断当前执行，然后输入以下命令：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After a few seconds, a browser page should open at `http://localhost:8888/app/javasample/`
    displaying the activator user interface specifically targeted to this application.
    Click on the **Code view & Open in IDE** item and navigate to the `app/models/Bar.java`
    file by double-clicking on the items on the left-hand side panel, as shown in
    the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，浏览器页面应该会在`http://localhost:8888/app/javasample/`打开，显示专门针对此应用程序的激活器用户界面。点击**代码视图
    & 在IDE中打开**项，通过在左侧面板上双击项目来导航到`app/models/Bar.java`文件，如下面的截图所示：
- en: '![Creating an application based on activator templates](img/3637_03_02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![基于activator模板创建应用程序](img/3637_03_02.jpg)'
- en: The browser displays a JPA-annotated entity as we are used to working with typically
    in the Eclipse IDE with colored and formatted syntax. The panel on the right-hand
    side leaves room for a tutorial, a precious feature to quickly understand the
    code and start modifying it. The top menu enables you to compile, run, or test
    the application from within the browser. You can open some of the other source
    files to identify the structure of the code, although we will cover play web applications
    in detail later on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器显示了一个JPA注解的实体，正如我们通常在Eclipse IDE中使用彩色和格式化的语法进行工作一样。右侧的面板为教程留出了空间，这是一个快速理解代码并开始修改它的宝贵功能。顶部菜单允许你在浏览器中编译、运行或测试应用程序。你可以打开其他一些源文件来识别代码的结构，尽管我们将在稍后详细介绍Play
    Web应用程序。
- en: In summary, Typesafe Activator is a way to get you started in just minutes and
    is very flexible as you can run activator projects directly as SBT projects, therefore,
    having the possibility to generate IDE-specific files to continue working in Eclipse,
    IDEA, or NetBeans if you wish to.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Typesafe Activator是一种只需几分钟就能让你开始使用的方法，并且非常灵活，因为你可以直接将activator项目作为SBT项目运行，因此，如果你愿意，有生成IDE特定文件以在Eclipse、IDEA或NetBeans中继续工作的可能性。
- en: The REPL as a scripting engine
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL作为脚本引擎
- en: 'To deal with interoperability with programs written in scripting languages,
    the Java community process has defined *JSR-223*, *Scripting for the JavaTM Platform*,
    a Java specification request that makes it possible to execute scripts written
    in other languages (such as Groovy, JavaScript, Ruby, or Jython to name of few)
    from within a Java program. For instance, we can write a Java program embedding
    a basic JavaScript snippet as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理与用脚本语言编写的程序之间的互操作性，Java社区流程定义了*JSR-223*，*JavaTM平台脚本*，这是一个Java规范请求，使得在Java程序中执行用其他语言（如Groovy、JavaScript、Ruby或Jython等）编写的脚本成为可能。例如，我们可以编写一个嵌入基本JavaScript片段的Java程序，如下所示：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will get the following output from the IDE:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在IDE中获得以下输出：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Starting from Scala''s upcoming Version 2.11, this very convenient functionality
    will let you interpret scripts written in Scala as well. The following is an example
    that we can just run directly in the REPL (taken from the [scala-lang.org](http://scala-lang.org)
    documentation):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从Scala即将推出的2.11版本开始，这个非常方便的功能将允许你解释用Scala编写的脚本。以下是一个可以直接在REPL中运行的示例（摘自[scala-lang.org](http://scala-lang.org)文档）：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The engine context can bind the `n` variable to the integer value `5`, which
    can be invoked in the one-liner script which consists of a `foreach` lambda expression.
    The script, in this case, is only a side effect and does not return any interesting
    value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎上下文可以将`n`变量绑定到整数值`5`，这可以在由`foreach` lambda表达式组成的单行脚本中调用。在这种情况下，脚本只是一个副作用，不返回任何有趣的价值。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered some of the major differences between the Java
    and Scala ecosystems, and it is noticed that apart from SBT and REPL, which are
    not found in the Java world, we are able to reuse all the Java libraries, tools,
    and frameworks. We have seen that this `group % artifact % version` format used
    to load dependencies in SBT is the same as that of Java's Maven, and in fact,
    SBT, by default, is similar to most of the Maven repositories (for example, Maven
    Central). We can, therefore, feel confident that the vast majority of our Java
    skills are reusable, and they make the transition easier at least as long as the
    ecosystem is concerned. We voluntarily omitted talking about the testing ecosystem
    as this is the main topic of our next chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些Java和Scala生态系统之间的主要差异，并注意到，除了SBT和REPL（在Java世界中找不到）之外，我们能够重用所有Java库、工具和框架。我们了解到，用于在SBT中加载依赖项的`group
    % artifact % version`格式与Java的Maven相同，实际上，SBT默认情况下与大多数Maven仓库（例如Maven Central）相似。因此，我们可以有信心，我们的大部分Java技能都是可重用的，并且至少在生态系统方面使过渡变得更容易。我们自愿省略了关于测试生态系统的讨论，因为这将是我们下一章的主要内容。
