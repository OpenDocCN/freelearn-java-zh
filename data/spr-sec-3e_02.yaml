- en: Getting Started with Spring Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Spring Security
- en: In this chapter, we'll apply a minimal Spring Security configuration to start
    addressing our first finding-inadvertent privilege escalation due to a lack of
    URL protection, and general authentication from the security audit discussed in
    [Chapter 1](01.html), *Anatomy of an Unsafe Application*. We will then build on
    the basic configuration to provide a customized experience for our users. This
    chapter is intended to get you up and running with Spring Security and to provide
    a foundation for any other security-related tasks you will need to perform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对Spring Security应用最小的配置来开始解决我们的第一个发现-由于缺乏URL保护而不经意间提升了权限，以及第[1章](01.html)中讨论的安全审计*不安全应用程序的剖析*中的通用认证。然后，我们将在此基础上构建，为我们的用户提供定制化的体验。本章旨在让您开始使用Spring
    Security，并为您提供执行任何其他安全相关任务的基础。
- en: 'During the course of this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Implementing a basic level of security on the JBCP calendar application, using
    the automatic configuration option in Spring Security
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JBCP日历应用程序上实现基本的安全性，使用Spring Security中的自动配置选项
- en: Learning how to customize both the login and logout experience
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何定制登录和登出体验
- en: Configuring Spring Security to restrict access differently, depending on the
    URL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Security以根据URL不同地限制访问
- en: Leveraging the expression-based access controls of Spring Security
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Spring Security的表达式基础访问控制
- en: Conditionally displaying basic information about the logged-in user using the
    JSP library in Spring Security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security中的JSP库条件性地显示有关登录用户的基本信息
- en: Determining the user's default location after login, based on their role
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户的角色确定登录后用户的默认位置
- en: Hello Spring Security
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，Spring Security
- en: Although Spring Security can be extremely difficult to configure, the creators
    of the product have been thoughtful and have provided us with a very simple mechanism
    to enable much of the software's functionality with a strong baseline. From this
    baseline, additional configuration will allow for a fine level of detailed control
    over the security behavior of the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Spring Security的配置可能非常复杂，但该产品的创建者考虑周到，为我们提供了一个非常简单的机制，通过这个机制可以以一个强有力的基础启用软件的大部分功能。从这个基础出发，进一步的配置将允许对应用程序的安全行为进行细粒度的详细控制。
- en: We'll start with our unsecured calendar application from [Chapter 1](01.html),
    *Anatomy of an Unsafe Application*, and turn it into a site that's secured with
    a rudimentary username and password authentication. This authentication serves
    merely to illustrate the steps involved in enabling Spring Security for our web
    application; you'll see that there are some obvious flaws in this approach that
    will lead us to make further configuration refinements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第[1章](01.html)的*不安全应用程序的剖析*中的未受保护的日历应用程序开始，将其转变为一个使用基本用户名和密码认证的安全网站。这种认证仅仅是为了说明启用我们的Web应用程序的Spring
    Security步骤；您将看到这种方法中有明显的缺陷，这将导致我们进行进一步的配置细化。
- en: Importing the sample application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入示例应用程序
- en: We encourage you to import the `chapter02.00-calendar` project into your IDE,
    and follow along by obtaining the source code from this chapter, as described
    in the *Getting started with JBCP calendar sample code* section in the Appendix,
    *Additional Reference Material*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您将`chapter02.00-calendar`项目导入您的IDE，并通过从本章获取源代码来跟随，如附录*附加参考资料*中的*使用JBCP日历示例代码*一节所述。
- en: For each chapter, you will find multiple revisions of the code that represent
    checkpoints within the book. This makes it easy to compare your work to the correct
    answers as you go. At the beginning of each chapter, we will import the first
    revision of that chapter as a starting point. For example, in this chapter, we
    start with `chapter02.00-calendar`, and the first checkpoint will be `chapter02.01-calendar`.
    In Appendix, *Additional Reference Material,* so be sure to refer to it for details.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个章节，您会发现有代表书中检查点的代码多个版本。这使得您可以很容易地将您的作品与正确答案进行比较。在每个章节的开头，我们将导入该章节的第一个版本作为起点。例如，在本章中，我们从`chapter02.00-calendar`开始，第一个检查点将是`chapter02.01-calendar`。在附录*附加参考资料*中，所以一定要查阅它以获取详细信息。
- en: Updating your dependencies
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新您的依赖项
- en: The first step is to update the project's dependencies to include the necessary
    Spring Security JAR files. Update the Gradle `build.gradle` file (from the sample
    application you imported previously) to include the Spring Security JAR files
    that we will use in the following few sections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更新项目的依赖关系，以包括必要的Spring Security JAR文件。更新从之前导入的示例应用程序中获取的Gradle `build.gradle`文件，以包括我们将在接下来的几节中使用的Spring
    Security JAR文件。
- en: Throughout the book, we will be demonstrating how to provide the required dependencies
    using Gradle. The `build.gradle` file is located in the root of the project and
    represents all that is needed to build the project (including the project's dependencies).
    Remember that Gradle will download the transitive dependencies for each listed
    dependency. So, if you are using another mechanism to manage dependencies, ensure
    that you also include the transitive dependencies. When managing the dependencies
    manually, it is useful to know that the Spring Security reference includes a list
    of its transitive dependencies. A link to the Spring Security reference can be
    found in the *Supplementary Materials* section in the *Supplementary materials*
    section in the Appendix, *Additional Reference Material*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将演示如何使用Gradle提供所需的依赖项。`build.gradle`文件位于项目的根目录中，代表构建项目所需的所有内容（包括项目的依赖项）。请记住，Gradle将为列出的每个依赖项下载传递依赖项。所以，如果您使用另一种机制来管理依赖项，请确保您也包括了传递依赖项。在手动管理依赖项时，了解Spring
    Security参考资料中包括其传递依赖项的列表是有用的。可以在附录中的*补充材料*部分的*附加参考资料*中找到Spring Security参考资料的链接。
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下的代码片段：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using Spring 4.3 and Spring Security 4.2
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring 4.3和Spring Security 4.2
- en: Spring 4.2 is used consistently. Our sample applications provide an example
    of the former option, which means that no additional work is required by you.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 4.2是一致使用的。我们提供的示例应用程序展示了前一个选项的示例，这意味着您不需要进行任何额外的工作。
- en: 'In the following code, we present an example fragment of what is added to the
    Gradle `build.gradle` file to utilize the dependency management feature of Gradle;
    this ensures that correct Spring version is used throughout the entire application.
    We are going to leverage the Spring IO **bill of materials** (**BOM**) dependency,
    which will ensure that all the dependency versions imported by the BOM will work
    together correctly:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们展示了添加到Gradle `build.gradle`文件的一个示例片段，以利用Gradle的依赖管理功能；这确保了整个应用程序中使用正确的Spring版本。我们将利用Spring
    IO **物料清单**（**BOM**）依赖，这将确保通过BOM导入的所有依赖版本正确地一起工作：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are using Spring Tool Suite, any time you update the `build.gradle` file,
    ensure you right-click on the project and navigate to Gradle | Refresh Gradle
    Project¦ and select OK to update all the dependencies.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Spring Tool Suite，每次更新`build.gradle`文件时，请确保您右键点击项目，导航到Gradle | 刷新Gradle项目，并选择确定以更新所有依赖项。
- en: For more information about how Gradle handles transitive dependencies, as well
    as the BOM, refer to the Gradle documentation, which is listed in the *Supplementary
    materials* section, in Appendix, *Additional Reference Material*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Gradle如何处理传递依赖项以及BOM的信息，请参考附录中*补充材料*部分列出的Gradle文档。
- en: Implementing a Spring Security XML configuration file
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Spring Security XML配置文件
- en: The next step in the configuration process is to create a Java configuration
    file representing all Spring Security components required to cover standard web
    requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 配置过程的下一步是创建一个Java配置文件，代表所有用于覆盖标准Web请求的Spring Security组件。
- en: 'Create a new Java file in the `src/main/java/com/packtpub/springsecurity/configuration/`
    directory with the name `SecurityConfig.java`, and the following content. Among
    other things, the following file demonstrates user login requirements for every
    page in our application, provides a login page, authenticates the user, and requires
    the logged-in user to be associated with a role called `USER` for every URL element:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main/java/com/packtpub/springsecurity/configuration/`目录下创建一个新的Java文件，命名为`SecurityConfig.java`，并包含以下内容。此文件展示了我们应用程序中每个页面对用户登录的要求，提供了一个登录页面，对用户进行了身份验证，并要求登录的用户对每个URL元素关联一个名为`USER`的角色：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you are using Spring Tool Suite, you can easily review `WebSecurityConfigurerAdapter`
    by using *F3*. Remember that the next checkpoint (`chapter02.01-calendar`) has
    a working solution, so the file can be copied from there as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Spring Tool Suite，你可以通过按 *F3* 轻松查看 `WebSecurityConfigurerAdapter`。记住，下一个检查点（`chapter02.01-calendar`）有一个可行的解决方案，所以文件也可以从那里复制。
- en: This is the only Spring Security configuration required to get our web application
    secured with a minimal standard configuration. This style of configuration, using
    a Spring Security-specific Java configuration, is known as **Java Config**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是确保我们的 Web 应用程序使用最小标准配置安全所需的唯一 Spring Security 配置。这种使用 Spring Security 特定 Java
    配置的配置方式被称为**Java 配置**。
- en: Let's take a minute to break this configuration apart so we can get a high-level
    idea of what is happening. In the `configure(HttpSecurity)` method, the `HttpSecurity`
    object creates a Servlet Filter, which ensures that the currently logged-in user
    is associated with the appropriate role. In this instance, the filter will ensure
    that the user is associated with `ROLE_USER`. It is important to understand that
    the name of the role is arbitrary. Later, we will create a user with `ROLE_ADMIN`
    and will allow this user to have access to additional URLs that our current user
    does not have access to.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟来分析这个配置，以便我们能了解发生了什么。在 `configure(HttpSecurity)` 方法中，`HttpSecurity` 对象创建了一个
    Servlet 过滤器，该过滤器确保当前登录的用户与适当的角色关联。在这个实例中，过滤器将确保用户与 `ROLE_USER` 关联。重要的是要理解，角色的名称是任意的。稍后，我们将创建一个具有
    `ROLE_ADMIN` 的用户，并允许此用户访问当前用户无法访问的额外 URL。
- en: In the `configure(AuthenticationManagerBuilder)` method, the `AuthenticationManagerBuilder`
    object is how Spring Security authenticates the user. In this instance, we utilize
    an in-memory data store to compare a username and password.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `configure(AuthenticationManagerBuilder)` 方法中，`AuthenticationManagerBuilder`
    对象是 Spring Security 认证用户的方式。在这个实例中，我们使用内存数据存储来比较用户名和密码。
- en: Our example and explanation of what is happening are a bit contrived. An in-memory
    authentication store would not work in a production environment. However, it allows
    us to get things up and running quickly. We will incrementally improve our understanding
    of Spring Security as we update our application to use production quality security
    throughout this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给出的例子和解释有些牵强。一个内存中的认证存储在生产环境中是行不通的。然而，它让我们能够快速启动。随着本书的进行，我们将逐步改进对 Spring Security
    的理解，同时更新我们的应用程序以使用生产级别的安全配置。
- en: General support for **Java Configuration** was added to Spring Framework in
    Spring 3.1\. Since Spring Security 3.2 release, there has been Spring Security
    Java Configuration support, which enables users to easily configure Spring Security
    without the use of any XML. If you are familiar with [Chapter 6](07.html), *LDAP
    Directory Services*, and the Spring Security documentation, then you should find
    quite a few similarities between it and **Security Java Configuration** support.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Spring 3.1 开始，对 **Java 配置** 的通用支持已添加到 Spring 框架中。自从 Spring Security 3.2 发布以来，就有了
    Spring Security Java 配置支持，这使用户能够不使用任何 XML 轻松配置 Spring Security。如果你熟悉第 6 章 [LDAP
    目录服务](07.html) 和 Spring Security 文档，那么你应该会在它和 **Security Java Configuration**
    支持之间找到很多相似之处。
- en: Updating your web.xml file
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新你的 web.xml 文件
- en: The next steps involve a series of updates to the `web.xml` file. Some of the
    steps have already been performed because the application was already using Spring
    MVC. However, we will go over these requirements to ensure that more fundamental
    Spring requirements are understood, in the event that you are using Spring Security
    in an application that is not Spring-enabled.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤涉及对 `web.xml` 文件进行一系列更新。有些步骤已经完成，因为应用程序已经使用 Spring MVC。然而，我们会回顾这些要求，以确保在您使用不支持
    Spring 的应用程序中理解更基本的 Spring 要求。
- en: The ContextLoaderListener class
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ContextLoaderListener 类
- en: 'The first step of updating the `web.xml` file is to remove it and replace it
    with `javax.servlet.ServletContainerInitializer`, which is the preferred approach
    to Servlet 3.0+ initialization. Spring MVC provides the `o.s.w.WebApplicationInitializer`
    interface, which leverages this mechanism. In Spring MVC, the preferred approach
    is to extend `o.s.w.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer`.
    The `WebApplicationInitializer` class is polymorphically `o.s.w.context.AbstractContextLoaderInitializer`
    and uses the abstract `createRootApplicationContext()` method to create a root
    `ApplicationContext`, then delegates it to `ContextLoaderListener`, which is registered
    in the `ServletContext` instance, as shown in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`web.xml`文件的第一步是删除它，并用`javax.servlet.ServletContainerInitializer`替换它，这是Servlet
    3.0+初始化的首选方法。Spring MVC提供了`o.s.w.WebApplicationInitializer`接口，利用这一机制。在Spring MVC中，首选的方法是扩展`o.s.w.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer`。`WebApplicationInitializer`类是多态的`o.s.w.context.AbstractContextLoaderInitializer`，并使用抽象的`createRootApplicationContext()`方法创建一个根`ApplicationContext`，然后将其委托给`ContextLoaderListener`，后者注册在`ServletContext`实例中，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The updated configuration will now load `SecurityConfig.class` from the classpath
    of the WAR file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的配置现在将从此WAR文件的类路径中加载`SecurityConfig.class`。
- en: ContextLoaderListener versus DispatcherServlet
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ContextLoaderListener与DispatcherServlet对比
- en: 'The `o.s.web.servlet.DispatcherServlet` interface specifies configuration classes
    to be loaded on their own using the `getServletConfigClasses()` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.web.servlet.DispatcherServlet`接口指定了通过`getServletConfigClasses()`方法独立加载的配置类：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `DispatcherServlet` class creates `o.s.context.ApplicationContext`, which
    is a child of the root `ApplicationContext` interface. Typically, Spring MVC-specific
    components are initialized in the `ApplicationContext` interface of `DispatcherServlet`,
    while the rest are loaded by `ContextLoaderListener`. It is important to know
    that beans in a child `ApplicationContext` (such as those created by `DispatcherServlet`)
    can reference beans of the parent `ApplicationContext` (such as those created
    by `ContextLoaderListener`). However, the parent `ApplicationContext` interface
    cannot refer to beans of the child `ApplicationContext`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`类创建了`o.s.context.ApplicationContext`，它是根`ApplicationContext`接口的子接口。通常，Spring
    MVC特定组件是在`DispatcherServlet`的`ApplicationContext`接口中初始化的，而其余的则是由`ContextLoaderListener`加载的。重要的是要知道，子`ApplicationContext`中的Bean（如由`DispatcherServlet`创建的）可以引用父`ApplicationContext`中的Bean（如由`ContextLoaderListener`创建的），但父`ApplicationContext`接口不能引用子`ApplicationContext`中的Bean。'
- en: 'This is illustrated in the following diagram, in which **Child Beans** can
    refer to **Root Beans**, but **Root Beans** cannot refer to **Child Beans**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了**子Bean**可以引用**根Bean**，但**根Bean**不能引用**子Bean**：
- en: '![](img/51f10ca9-eaa2-4b05-a6a9-2cf02949886c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51f10ca9-eaa2-4b05-a6a9-2cf02949886c.png)'
- en: As in most use cases of Spring Security, we do not need Spring Security to refer
    to any of the MVC-declared beans. Therefore, we have decided to have `ContextLoaderListener`
    initialize all configurations of Spring Security.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数Spring Security的使用场景一样，我们不需要Spring Security引用任何MVC声明的Bean。因此，我们决定让`ContextLoaderListener`初始化所有Spring
    Security的配置。
- en: The springSecurityFilterChain filter
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: springSecurityFilterChain过滤器
- en: 'The next step is to configure `springSecurityFilterChain` to intercept all
    requests by creating an implementation of `AbstractSecurityWebApplicationInitializer`.
    It is critical for `springSecurityFilterChain` to be declared first, to ensure
    the request is secured prior to any other logic being invoked. To ensure `springSecurityFilterChain`
    gets loaded first, we can use `@Order(1)` as shown in the following configuration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置`springSecurityFilterChain`以拦截所有请求，通过创建`AbstractSecurityWebApplicationInitializer`的实现。确保`springSecurityFilterChain`首先声明至关重要，以确保在调用任何其他逻辑之前请求是安全的。为了确保`springSecurityFilterChain`首先加载，我们可以使用如下配置中的`@Order(1)`：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `SecurityWebAppInitializer` class will automatically register the `springSecurityFilterChain`
    filter for every URL in your application and will add `ContextLoaderListener`,
    which loads `SecurityConfig`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityWebAppInitializer`类将自动为应用程序中的每个URL注册`springSecurityFilterChain`过滤器，并将添加`ContextLoaderListener`，后者加载`SecurityConfig`。'
- en: The DelegatingFilterProxy class
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DelegatingFilterProxy类
- en: 'The `o.s.web.filter.DelegatingFilterProxy` class is a Servlet Filter provided
    by Spring Web that will delegate all work to a Spring bean from the `ApplicationContext`
    root, which must implement `javax.servlet.Filter`. Since by default the bean is
    looked up by name, using the `<filter-name>` value, we must ensure we use `springSecurityFilterChain`
    as the value of `<filter-name>`. The pseudocode for how `o.s.web.filter.DelegatingFilterProxy`
    works for our `web.xml` file can be found in the following code snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.web.filter.DelegatingFilterProxy`类是Spring Web提供的Servlet过滤器，它将所有工作委派给`ApplicationContext`根目录下的一个Spring
    bean，该bean必须实现`javax.servlet.Filter`。由于默认情况下是通过名称查找bean，使用`<filter-name>`值，我们必须确保我们使用`springSecurityFilterChain`作为`<filter-name>`的值。我们可以在以下代码片段中找到`o.s.web.filter.DelegatingFilterProxy`类对于我们`web.xml`文件的工作伪代码：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The FilterChainProxy class
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FilterChainProxy`类'
- en: 'When working in conjunction with Spring Security, `o.s.web.filter.DelegatingFilterProxy`
    will delegate to the `o.s.s.web.FilterChainProxy` interface of Spring Security,
    which was created in our minimal `security.xml` file. The `FilterChainProxy` class
    allows Spring Security to conditionally apply any number of Servlet Filters to
    the servlet request. We will learn more about each of the Spring Security filters,
    and their roles in ensuring that our application is properly secured, throughout
    the rest of the book. The pseudocode for how `FilterChainProxy` works are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Spring Security一起使用时，`o.s.web.filter.DelegatingFilterProxy`将委派给Spring Security的`o.s.s.web.FilterChainProxy`接口，该接口是在我们的最小`security.xml`文件中创建的。`FilterChainProxy`类允许Spring
    Security条件性地将任意数量的Servlet过滤器应用于Servlet请求。我们将在书的其余部分了解更多关于Spring Security过滤器的内容，以及它们在确保我们的应用程序得到适当保护方面的作用。`FilterChainProxy`的工作伪代码如下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Due to the fact that both `DelegatingFilterProxy` and `FilterChainProxy` are
    the front door to Spring Security, when used in a web application, you would add
    a debug point when trying to figure out what is happening.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`DelegatingFilterProxy`和`FilterChainProxy`都是Spring Security的前门，当在Web应用程序中使用时，您会在尝试了解发生了什么时添加一个调试点。
- en: Running a secured application
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行受保护的应用程序
- en: 'If you have not already done so, restart the application and visit `http://localhost:8080/`.
    You will be presented with the following screen:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请重新启动应用程序并访问`http://localhost:8080/`。您将看到以下屏幕：
- en: '![](img/f21bbf6c-69e2-4013-8263-8048fc161cc3.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f21bbf6c-69e2-4013-8263-8048fc161cc3.png)'
- en: Great job! We've implemented a basic layer of security in our application using
    Spring Security. At this point, you should be able to log in using `user1@example.com`
    as User and `user1` as Password. You'll see the calendar welcome page, which describes
    at a high level what to expect from the application in terms of security.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们使用Spring Security在应用程序中实现了一个基本的安全层。在此阶段，您应该能够使用`user1@example.com`作为用户和`user1`作为密码登录。您将看到日历欢迎页面，该页面从高层次描述了应用程序在安全性方面的预期。
- en: Your code should now look like `chapter02.01-calendar`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter02.01-calendar`。
- en: Common problems
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Many users have trouble with the initial implementation of Spring Security in
    their application. A few common issues and suggestions are listed next. We want
    to ensure that you can run the example application and follow along!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户在将Spring Security首次实现到他们的应用程序时遇到了麻烦。下面列出了一些常见问题和建议。我们希望确保您能够运行示例应用程序并跟随教程！
- en: Make sure you can build and deploy the application before putting Spring Security
    in place.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将Spring Security放入应用程序之前，请确保您能够构建和部署应用程序。
- en: Review some introductory samples and documentation on your servlet container
    if needed.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有需要，请回顾一些关于您Servlet容器的入门示例和文档。
- en: It's usually easiest to use an IDE, such as Eclipse, to run your servlet container.
    Not only is deployment typically seamless, but the console log is also readily
    available to review for errors. You can also set breakpoints at strategic locations,
    to be triggered by exceptions to better diagnose errors.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常使用IDE（如Eclipse）运行您的Servlet容器是最简单的。不仅部署通常是无缝的，控制台日志也易于查看以查找错误。您还可以在战略位置设置断点，以便在异常触发时更好地诊断错误。
- en: Make sure the versions of Spring and Spring Security that you're using match
    and that there aren't any unexpected Spring JARs remaining as part of your application.
    As previously mentioned, when using Gradle, it can be a good idea to declare the
    Spring dependencies in the dependency management section.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请确保您使用的Spring和Spring Security版本匹配，并且没有意外的Spring JAR作为您应用程序的一部分残留。如前所述，当使用Gradle时，最好在依赖管理部分声明Spring依赖项。
- en: A little bit of polish
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稍微加工一下
- en: Stop at this point and think about what we've just built. You may have noticed
    some obvious issues that will require some additional work and knowledge of the
    Spring Security product before our application is production-ready. Try to make
    a list of the changes that you think are required before this security implementation
    is ready to roll out on the public-facing website.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 停在这个步骤，思考一下我们刚刚构建的内容。你可能已经注意到了一些明显的问题，这需要一些额外的工作和了解Spring Security产品知识，我们的应用程序才能准备好上线。尝试列出一个你认为在安全实现准备好公开面对网站之前需要做的更改清单。
- en: 'Applying the Hello World Spring Security implementation was blindingly fast
    and has provided us with a login page, username, and password-based authentication,
    as well as the automatic interception of URLs in our calendar application. However,
    there are gaps between what the automatic configuration setup provides and what
    our end goal is, which are listed as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用Hello World Spring Security实现速度之快让人眼花缭乱，并为我们提供了登录页面、用户名和基于密码的认证，以及在我们日历应用程序中自动拦截URL。然而，自动配置设置提供的与我们最终目标之间的差距如下所述：
- en: While the login page is helpful, it's completely generic and doesn't look like
    the rest of our JBCP calendar application. We should add a login form that's integrated
    with our application's look and feel.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然登录页面很有帮助，但它完全通用，与我们JBCP日历应用程序的其余部分看起来不一样。我们应该添加一个与应用程序外观和感觉集成的登录表单。
- en: There is no obvious way for a user to log out. We've locked down all pages in
    the application, including the Welcome page, which a potential user may want to
    browse anonymously. We'll need to redefine the roles required to accommodate anonymous,
    authenticated, and administrative users.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户没有明显的方式登出。我们已经锁定了应用程序中的所有页面，包括欢迎页面，潜在的用户可能想以匿名方式浏览该页面。我们需要重新定义所需的角色以适应匿名、认证和行政用户。
- en: We do not display any contextual information to indicate to the user that they
    are authenticated. It would be nice to display a greeting similar to welcome `user1@example.com`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有显示任何上下文信息来告知用户他们已经认证。如果能显示一个类似于欢迎`user1@example.com`的问候语会很好。
- en: 'We''ve had to hardcode the username, password, and role information of the
    user in the `SecurityConfig` configuration file. Recall this section of the `configure(AuthenticationManagerBuilder)`
    method we added:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不在`SecurityConfig`配置文件中硬编码用户的用户名、密码和角色信息。回想一下我们添加的`configure(AuthenticationManagerBuilder)`方法的这一部分：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the username and password are right there in the file. It's
    unlikely that we'd want to add a new declaration to the file for every user of
    the system! To address this, we'll need to update the configuration with another
    type of authentication.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以看到用户名和密码就在文件里。我们不太可能想要为系统中的每个用户在文件中添加一个新的声明！为了解决这个问题，我们需要用另一种认证方式更新配置。
- en: We'll explore different authentication options throughout the first half of
    the book.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的第一半中探索不同的认证选项。
- en: Configuring logout
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出配置
- en: 'The `HttpSecurity` configuration of Spring Security automatically adds support
    for logging the user out. All that is needed is to create a link that points to
    `/j_spring_security_logout`. However, we will demonstrate how to customize the
    URL used to log the user out by performing the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security的`HttpSecurity`配置自动添加了对用户登出的支持。所需的所有操作是创建一个指向`/j_spring_security_logout`的链接。然而，我们将演示如何通过执行以下步骤自定义用于用户登出的URL：
- en: 'Update the Spring Security configuration as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下更新Spring Security配置：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You have to provide a link for the user to click on that will log them out.
    We will update the `header.html` file so that the `Logout` link appears on every
    page:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须为用户提供一个可以点击的链接以登出。我们将更新`header.html`文件，以便在每一页上出现`Logout`链接：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last step is to update the `login.html` file to display a message indicating
    logout was successful when the `logout` parameter is present:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是更新`login.html`文件，当`logout`参数存在时，显示一条表示登出成功的消息：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Your code should now look like `chapter02.02-calendar`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter02.02-calendar`。
- en: The page isn't redirecting properly
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面没有正确重定向。
- en: 'If you have not already, restart the application and visit `http://localhost:8080`
    in Firefox; you will see an error, as shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这么做，重启应用程序并在Firefox中访问`http://localhost:8080`；你会看到一个错误，如下面的屏幕截图所示：
- en: '![](img/4c6fdfaa-ef71-4e5a-aac8-ba674db7d23f.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c6fdfaa-ef71-4e5a-aac8-ba674db7d23f.png)'
- en: 'What went wrong? The problem is, since Spring Security is no longer rendering
    the login page, we must allow everyone (not just the `USER` role) to access the
    Login page. Without granting access to the Login page, the following happens:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 哪里出了问题？问题在于，由于Spring Security不再渲染登录页面，我们必须允许所有人（而不仅仅是`USER`角色）访问登录页面。如果不允许访问登录页面，会发生以下情况：
- en: We request the Welcome page in the browser.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中请求欢迎页面。
- en: Spring Security sees that the Welcome page requires the `USER` role and that
    we are not authenticated, so it redirects the browser to the Login page.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security发现欢迎页面需要`USER`角色，而我们尚未认证，因此它将浏览器重定向到登录页面。
- en: The browser requests the Login page.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器请求登录页面。
- en: Spring Security sees that the Login page requires the `USER` role and that we
    are still not authenticated, so it redirects the browser to the Login page again.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security发现登录页面需要`USER`角色，而我们还没有认证，所以它将浏览器重定向到登录页面。
- en: The browser requests the Login page again.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器再次请求登录页面。
- en: 'Spring Security sees that the Login page requires the `USER` role, as shown
    in the following diagram:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security发现登录页面需要`USER`角色，如图所示：
- en: '![](img/f7a75dc4-9fcf-44ab-be04-4402b50a9123.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7a75dc4-9fcf-44ab-be04-4402b50a9123.png)'
- en: The process could just keep repeating indefinitely. Fortunately for us, Firefox
    realizes that there are too many redirects occurring, stops performing the redirect,
    and displays a very informative error message. In the next section, we will learn
    how to fix this error by configuring URLs differently, depending on the access
    that they require.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程可能会无限重复。幸运的是，Firefox意识到发生了太多重定向，停止执行重定向，并显示一个非常有用的错误信息。在下一节中，我们将学习如何通过配置不同的URL来修复此错误，这些URL根据它们需要的访问权限不同。
- en: Expression-based authorization
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于表达式的授权。
- en: 'You may have noticed that granting access to everyone was not nearly as concise
    as we may have liked. Fortunately, Spring Security can leverage **Spring Expression
    Language** (**SpEL**) to determine whether a user has authorization. In the following
    code snippet, you can see the updates when using SpEL with Spring Security:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，允许所有人访问远不如我们期望的简洁。幸运的是，Spring Security可以利用**Spring表达式语言**（**SpEL**）来确定用户是否有授权。在下面的代码片段中，你可以看到使用SpEL与Spring
    Security时的更新：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may notice that the `/events/` security constraint is brittle. For example,
    the `/events` URL is not protected by Spring Security to restrict the `ADMIN`
    role. This demonstrates the need to ensure that we provide multiple layers of
    security. We will exploit this sort of weakness in [Chapter 11](12.html), *Fine-Grained
    Access Control*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`/events/`的安全约束很脆弱。例如，`/events` URL不受Spring Security的保护，以限制`ADMIN`角色。这证明了我们需要确保提供多层次的安全性。我们将在第11章中利用这种弱点，进行*细粒度访问控制*。
- en: Changing the `access` attribute from `hasAnyRole('ANONYMOUS', 'USER')` to `permitAll()`
    might not seem like much, but this only scratches the surface of the power of
    Spring Security's expressions. We will go into much greater detail about access
    control and Spring expressions in the second half of the book. Go ahead and verify
    that the updates work by running the application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将`access`属性从`hasAnyRole('ANONYMOUS', 'USER')`更改为`permitAll()`可能看起来并不重要，但这只是Spring
    Security表达式强大功能的冰山一角。我们将在书的第二部分更详细地讨论访问控制和Spring表达式。运行应用程序以验证更新是否有效。
- en: Your code should now look like `chapter02.04-calendar`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter02.04-calendar`。
- en: Conditionally displaying authentication information
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有条件地显示认证信息。
- en: 'Currently, our application has no indication as to whether we are logged in
    or not. In fact, it appears as though we are always logged in since the `Logout`
    link is always displayed. In this section, we will demonstrate how to display
    the authenticated user''s username and conditionally display portions of the page
    using Thymeleaf''s Spring Security tag library. We do so by performing the following
    steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序没有关于我们是否登录的任何指示。事实上，它看起来好像我们总是登录，因为`Logout`链接总是显示。在本节中，我们将演示如何使用Thymeleaf的Spring
    Security标签库显示认证用户的用户名，并根据条件显示页面的部分内容。我们通过执行以下步骤来实现：
- en: 'Update your dependencies to include the `thymeleaf-extras-springsecurity4`
    JAR file. Since we are using Gradle, we will add a new dependency declaration
    in our `build.gradle` file, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的依赖项，包括`thymeleaf-extras-springsecurity4` JAR文件。由于我们正在使用Gradle，我们将在`build.gradle`文件中添加一个新的依赖项声明，如下所示：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to add `SpringSecurityDialect` to the Thymeleaf engine as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要如下向 Thymeleaf 引擎添加 `SpringSecurityDialect`：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the `header.html` file to leverage the Spring Security tag library.
    You can find the updates as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `header.html` 文件以利用 Spring Security 标签库。你可以按照如下方式找到更新：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `sec:authorize` attribute determines whether the user is authenticated with
    the `isAuthenticated()`value, and displays the HTML node if the user is authenticated,
    and hides the node in the event that the user is not authenticated. The `access`
    attribute should be rather familiar from the `antMatcher().access()` element.
    In fact, both components leverage the same SpEL support. There are attributes
    in the Thymeleaf tag libraries that do not use expressions. However, using SpEL
    is typically the preferred method since it is more powerful.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`sec:authorize` 属性确定用户是否以 `isAuthenticated()` 值认证，并在用户认证时显示 HTML 节点，如果用户没有认证，则隐藏节点。`access`
    属性应该非常熟悉，来自 `antMatcher().access()` 元素。实际上，这两个组件都利用了相同的 SpEL 支持。Thymeleaf 标签库中有不使用表达式的属性。然而，使用
    SpEL 通常是更受欢迎的方法，因为它更强大。'
- en: The `sec:authentication` attribute will look up the current `o.s.s.core.Authentication`
    object. The `property` attribute will find the principal attribute of the `o.s.s.core.Authentication`,object,
    which in this case is `o.s.s.core.userdetails.UserDetails`. It then obtains the
    `UserDetails` username property and renders it to the page. Don't worry if the
    details of this are confusing. We are going to go over this in more detail in
    [Chapter 3](03.html), *Custom Authentication*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`sec:authentication` 属性将查找当前的 `o.s.s.core.Authentication` 对象。`property` 属性将找到
    `o.s.s.core.Authentication` 对象的 `principal` 属性，在这个例子中是 `o.s.s.core.userdetails.UserDetails`。然后它获取
    `UserDetails` 的 `username` 属性并将其渲染到页面。如果这些细节让你感到困惑，不要担心。我们将在[第3章](03.html) *自定义认证*
    中更详细地介绍这一点。'
- en: If you haven't done so already, restart the application to see the updates we
    have made. At this point, you may realize that we are still displaying links we
    do not have access to. For example, `user1@example.com` should not see a link
    to the All Events page. Rest assured, we'll fix this when we cover the tags in
    greater detail in [Chapter 11](12.html), *Fine-Grained Access Control*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请重新启动应用程序以查看我们所做的更新。此时，你可能会意识到我们仍在显示我们没有访问权的链接。例如，`user1@example.com`
    不应该看到“所有事件”页面的链接。请放心，当我们详细介绍标签时，我们将在[第11章](12.html) *细粒度访问控制* 中解决这个问题。
- en: 'Your code should now look like this: `chapter02.05-calendar`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像这样：`chapter02.05-calendar`。
- en: Customizing behavior after login
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录后的行为自定义。
- en: We have already discussed how to customize a user's experience during login,
    but sometimes it is necessary to customize the behavior after login. In this section,
    we will discuss how Spring Security behaves after login and will provide a simple
    mechanism to customize this behavior.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何自定义用户在登录过程中的体验，但有时在登录后自定义行为是必要的。在本节中，我们将讨论 Spring Security 在登录后的行为，并提供一个简单的方法来自定义此行为。
- en: In the default configuration, Spring Security has two different flows after
    successful authentication. The first scenario occurs if a user never visits a
    resource that requires authentication. In this instance, after a successful login
    attempt, the user will be sent to the `defaultSuccessUrl()` method chained to
    the `formLogin()` method. If left undefined, `defaultSuccessUrl()` will be the
    context root of the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置中，Spring Security 在成功认证后有两个不同的流程。第一个场景是如果一个用户从未访问过需要认证的资源。在这种情况下，成功登录后，用户将被发送到
    `defaultSuccessUrl()` 方法，该方法链接到 `formLogin()` 方法。如果未定义，`defaultSuccessUrl()` 将是应用程序的上下文根。
- en: If a user requests a protected page before being authenticated, Spring Security
    will remember the last protected page that was accessed prior to authenticating,
    using `o.s.s.web.savedrequest.RequestCache`. Upon successful authentication, Spring
    Security will send the user to the last protected page that was accessed prior
    to authentication. For example, if an unauthenticated user requests the My Events
    page, they will be sent to the Login page.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在认证之前请求了一个受保护的页面，Spring Security 将使用 `o.s.s.web.savedrequest.RequestCache`
    记住在认证之前访问的最后一個受保护的页面。在认证成功后，Spring Security 会将用户发送到在认证之前访问的最后一個受保护的页面。例如，如果一个未认证的用户请求“我的事件”页面，他们将被发送到登录页面。
- en: After successful authentication, they will be sent to the previously requested
    My Events page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 成功认证后，他们将被发送到之前请求的“我的事件”页面。
- en: 'A common requirement is to customize Spring Security to send the user to a
    different `defaultSuccessUrl()` method, depending on the user''s role. Let''s
    take a look at how this can be accomplished by performing the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是自定义Spring Security，使其根据用户的角色发送用户到不同的`defaultSuccessUrl()`方法。让我们来看看如何通过执行以下步骤来实现这一点：
- en: 'The first step is to configure the `defaultSuccessUrl()` method chained after
    the `formLogin()` method. Go ahead and update the `security.xml` file to use `/default`
    instead of the context root:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是配置`defaultSuccessUrl()`方法，它在`formLogin()`方法之后链式调用。大胆地更新`security.xml`文件，使用`/default`而不是上下文根：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next step is to create a controller that processes `/default`. In the following
    code, you will find a sample Spring MVC controller, `DefaultController`, which
    demonstrates how to redirect administrators to the All Events page and other users
    to the Welcome page. Create a new file in the following location:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个处理`/default`的控制器。在下面的代码中，你会发现一个示例Spring MVC控制器`DefaultController`，它演示了如何将管理员重定向到所有事件页面，并将其他用户重定向到欢迎页面。在以下位置创建一个新的文件：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In Spring Tool Suite, you can use *Shift* + *Ctrl* + *O* to automatically add
    the missing imports.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Tool Suite中，你可以使用*Shift* + *Ctrl* + *O* 来自动添加缺少的导入。
- en: There are a few things to point out about `DefaultController` and how it works.
    The first is that Spring Security makes the `HttpServletRequest` parameter aware
    of the currently logged-in user. In this instance, we are able to inspect which
    role the user belongs to without relying on any of Spring Security's APIs. This
    is good because if Spring Security's APIs change or we decide we want to switch
    our security implementation, we have less code that needs to be updated. It should
    also be noted that while we implement this controller with a Spring MVC controller,
    our `defaultSuccessUrl()` method can be handled by any controller implementation
    (for example, Struts, a standard servlet, and so on) if we desire.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`DefaultController`及其工作方式有一点需要注意。首先是Spring Security使`HttpServletRequest`参数意识到当前登录的用户。在这个实例中，我们能够不依赖Spring
    Security的任何API来检查用户属于哪个角色。这是好的，因为如果Spring Security的API发生变化，或者我们决定要切换我们的安全实现，我们需要更新的代码就会更少。还应注意的是，尽管我们用Spring
    MVC控制器实现这个控制器，但我们的`defaultSuccessUrl()`方法如果需要，可以由任何控制器实现（例如，Struts，一个标准的servlet等）处理。
- en: 'If you wish to always go to the `defaultSuccessUrl()` method, you can leverage
    the second parameter to the `defaultSuccessUrl()` method, which is a `Boolean`
    for always use. We will not do this in our configuration, but you can see an example
    of it as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望总是去到`defaultSuccessUrl()`方法，你可以利用`defaultSuccessUrl()`方法的第二个参数，这是一个`Boolean`用于始终使用。我们不会在我们的配置中这样做，但你可以如下看到一个例子：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You are now ready to give it a try. Restart the application and go directly
    to the My Events page, then log in; you will see that you are on the My Events
    page.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以尝试一下了。重新启动应用程序并直接转到我的事件页面，然后登录；你会发现你在我的事件页面。
- en: Next, log out and try logging in as `user1@example.com`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，退出并尝试以`user1@example.com`的身份登录。
- en: You should be on the Welcome page. Log out and log in as `admin1@example.com`,
    and you will be
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在欢迎页面。退出并以`admin1@example.com`的身份登录，然后你会被
- en: sent to the All Events page.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被发送到所有事件页面。
- en: Your code should now look like `chapter02.06-calendar`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter02.06-calendar`。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have applied a very basic Spring Security configuration,
    explained how to customize the user's login and logout experience, and demonstrated
    how to display basic information, such as a username, in our web application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经应用了非常基础的Spring Security配置，解释了如何自定义用户的登录和登出体验，并演示了如何在我们的网络应用程序中显示基本信息，例如用户名。
- en: In the next chapter, we will discuss how authentication in Spring Security works
    and how we can customize it to our needs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Spring Security中的认证是如何工作的，以及我们如何可以根据自己的需求来定制它。
