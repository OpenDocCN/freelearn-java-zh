- en: Custom Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义认证
- en: In [Chapter 2](02.html), *Getting Started with Spring Security*, we demonstrated
    how to use an in-memory datastore to authenticate the user. In this chapter, we'll
    explore how to solve some common, real-world problems by extending Spring Security's
    authentication support to use our existing set of APIs. Through this exploration,
    we'll get an understanding of each of the building blocks that Spring Security
    uses in order to authenticate users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](02.html)，*使用Spring Security入门*，我们展示了如何使用内存中的数据存储来认证用户。在本章中，我们将探讨如何通过将Spring
    Security的认证支持扩展到使用我们现有的API集来解决一些常见的世界问题。通过这种探索，我们将了解Spring Security用于认证用户所使用的每个构建块。
- en: 'During the course of this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Leverage Spring Security's annotations and Java-based configuration
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Spring Security的注解和基于Java的配置
- en: Discovering how to obtain the details of the currently logged-in user
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现如何获取当前登录用户的具体信息
- en: Adding the ability to log in after creating a new account
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建新账户后添加登录的能力
- en: Learning the simplest method for indicating to Spring Security, that a user
    is authenticated
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习向Spring Security指示用户已认证的最简单方法
- en: Creating custom `UserDetailsService` and `AuthenticationProvider` implementations
    that properly decouple the rest of the application from Spring Security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义`UserDetailsService`和`AuthenticationProvider`实现，以适当地将应用程序的其他部分与Spring Security解耦
- en: Adding domain-based authentication to demonstrate how to authenticate with more
    than just a username and password
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加基于域的认证，以演示如何使用不仅仅是用户名和密码进行认证
- en: JBCP calendar architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JBCP日历架构
- en: In Appendix, *Additional Reference Material*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录中，*附加参考资料*。
- en: Since this chapter is about integrating Spring Security with custom users and
    APIs, we will start with a quick introduction to the domain model within the JBCP
    calendar application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章是关于将Spring Security与自定义用户和API集成的，我们将从对JBCP日历应用程序中的域模型的快速介绍开始。
- en: The CalendarUser object
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日历用户对象
- en: 'Our calendar application uses a domain object named `CalendarUser`, which contains
    information about our users, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日历应用程序使用一个名为`CalendarUser`的域对象，其中包含有关我们的用户的信息，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Event object
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件对象
- en: 'Our application has an `Event` object that contains information about each
    event, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有一个`Event`对象，其中包含有关每个事件的详细信息，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The CalendarService interface
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日历服务接口
- en: 'Our application contains a `CalendarService` interface that can be used to
    access and store our domain objects. The code for `CalendarService` is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序包含一个`CalendarService`接口，可以用来访问和存储我们的域对象。`CalendarService`的代码如下：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We won't go over the methods used in `CalendarService`, but they should be fairly
    straightforward. If you would like details about what each method does, please
    consult the Javadoc in the sample code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会讨论`CalendarService`中使用的方法，但它们应该是相当直接的。如果您想了解每个方法的作用，请查阅示例代码中的Javadoc。
- en: The UserContext interface
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户上下文接口
- en: 'Like most applications, our application requires us to interact with the currently
    logged-in user. We have created a very simple interface called `UserContext` to
    manage the currently logged-in user as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数应用程序一样，我们的应用程序需要与我们当前登录的用户进行交互。我们创建了一个非常简单的接口，名为`UserContext`，用于管理当前登录的用户，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that our application can call `UserContext.getCurrentUser()` to obtain
    the details of the currently logged-in user. It can also call `UserContext.setCurrentUser(CalendarUser)`
    to specify which user is logged in. Later in this chapter, we will explore how
    we can write an implementation of this interface that uses Spring Security to
    access our current user and obtain their details using `SecurityContextHolder`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的应用程序可以调用`UserContext.getCurrentUser()`来获取当前登录用户的信息。它还可以调用`UserContext.setCurrentUser(CalendarUser)`来指定哪个用户已登录。在本章后面，我们将探讨如何编写实现此接口的实现，该实现使用Spring
    Security访问我们当前的用户并使用`SecurityContextHolder`获取他们的详细信息。
- en: 'Spring Security provides quite a few different methods for authenticating a
    user. However, the net result is that Spring Security will populate `o.s.s.core.context.SecurityContext`
    with `o.s.s.core.Authentication`. The `Authentication` object represents all the
    information we gathered at the time of authentication (username, password, roles,
    and so on). The `SecurityContext` interface is then set on the `o.s.s.core.context.SecurityContextHolder`
    interface. This means that Spring Security and developers can use `SecurityContextHolder`
    to obtain information about the currently logged-in user. An example of obtaining
    the current username is illustrated as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了很多不同的方法来验证用户。然而，最终结果是Spring Security会将`o.s.s.core.context.SecurityContext`填充为`o.s.s.core.Authentication`。`Authentication`对象代表了我们在认证时收集的所有信息（用户名、密码、角色等）。然后`SecurityContext`接口被设置在`o.s.s.core.context.SecurityContextHolder`接口上。这意味着Spring
    Security和开发者可以使用`SecurityContextHolder`来获取关于当前登录用户的信息。以下是一个获取当前用户名的示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It should be noted that `null` checks should always be done on the `Authentication`
    object, as this could be `null` if the user is not logged in.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，应该始终对`Authentication`对象进行`null`检查，因为如果用户没有登录，这个对象可能是`null`。
- en: The SpringSecurityUserContext interface
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`SpringSecurityUserContext`接口'
- en: The current `UserContext` implementation, `UserContextStub`, is a stub that
    always returns the same user. This means that the My Events page will always display
    the same user no matter who is logged in. Let's update our application to utilize
    the current Spring Security user's username, to determine which events to display
    on the My Events page.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的`UserContext`实现`UserContextStub`是一个总是返回相同用户的存根。这意味着无论谁登录，My Events页面都会显示相同的用户。让我们更新我们的应用程序，利用当前Spring
    Security用户的用户名，来确定在My Events页面上显示哪些事件。
- en: You should be starting with the sample code in `chapter03.00-calendar`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter03.00-calendar`中的示例代码开始。
- en: 'Take a look at the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤操作：
- en: The first step is to comment out the `@Component` attribute on `UserContextStub`,
    so that our application no longer uses our scanned results.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将`UserContextStub`上的`@Component`属性注释掉，以便我们的应用程序不再使用我们的扫描结果。
- en: The `@Component` annotation is used in conjunction with the `@ComponentScan`
    annotation found in `com/packtpub/springsecurity/web/configuration/WebMvcConfig.java`,
    to automatically create a Spring bean rather than creating an explicit XML or
    Java configuration for each bean. You can learn more about the classpath of Spring
    scanning in the Spring Reference link at [http://static.springsource.org/spring/docs/current/spring-framework-reference/html/](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`注解与在`com/packtpub/springsecurity/web/configuration/WebMvcConfig.java`中找到的`@ComponentScan`注解一起使用，用于自动创建Spring
    bean，而不是为每个bean创建显式的XML或Java配置。您可以在[http://static.springsource.org/spring/docs/current/spring-framework-reference/html/](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/)中了解更多关于Spring扫描类路径的信息。'
- en: 'Take a look at the following code snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下代码片段：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next step is to utilize `SecurityContext` to obtain the currently logged-in
    user. We have included `SpringSecurityUserContext` within this chapter's code,
    which is wired up with the necessary dependencies but contains no actual functionality.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是利用`SecurityContext`来获取当前登录的用户。在本章的代码中，我们包含了`SpringSecurityUserContext`，它已经集成了必要的依赖项，但没有任何实际功能。
- en: 'Open the `SpringSecurityUserContext.java` file and add the `@Component` annotation.
    Next, replace the `getCurrentUser` implementation, as illustrated in the following
    code snippet:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SpringSecurityUserContext.java`文件，添加`@Component`注解。接下来，替换`getCurrentUser`实现，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our code obtains the username from the current Spring Security `Authentication`
    object and utilizes that to look up the current `CalendarUser` object by email
    address. Since our Spring Security username is an email address, we are able to
    use the email address to link `CalendarUser` with the Spring Security user. Note
    that if we were to link accounts, we would normally want to do this with a key
    that we generated rather than something that may change (that is, an email address).
    We follow the good practice of returning only our domain object to the application.
    This ensures that our application is only aware of our `CalendarUser` object and
    thus is not coupled to Spring Security.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码从当前Spring Security的`Authentication`对象中获取用户名，并利用该用户名通过电子邮件地址查找当前的`CalendarUser`对象。由于我们的Spring
    Security用户名是一个电子邮件地址，因此我们能够使用电子邮件地址将`CalendarUser`与Spring Security用户关联起来。请注意，如果我们打算关联账户，通常我们希望能够用我们生成的键来做这件事，而不是可能改变的东西（也就是说，电子邮件地址）。我们遵循只向应用程序返回我们的域对象的良好实践。这确保了我们的应用程序只认识我们的`CalendarUser`对象，从而与Spring
    Security解耦。
- en: This code may seem eerily similar to when we used the `sec:authorize="isAuthenticated()"`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能看起来与我们使用`sec:authorize="isAuthenticated()"`时出奇地相似。
- en: tag attribute in [Chapter 2](02.html), *Getting Started with Spring Security,*
    to display the current user's username. In fact, the Spring Security tag library
    uses `SecurityContextHolder` in the same manner as we have done here. We could
    use our `UserContext` interface to place the current user on `HttpServletRequest`
    and thus remove our dependency on the Spring Security tag library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](02.html)*Spring Security入门*中使用的`tag`属性，来显示当前用户的用户名。实际上，Spring Security标签库正是像我们在这里一样使用`SecurityContextHolder`。我们本可以使用我们的`UserContext`接口将当前用户放在`HttpServletRequest`上，从而摆脱对Spring
    Security标签库的依赖。
- en: Start up the application, visit `http://localhost:8080/`, and log in with `admin1@example.com`
    as the username and `admin1` as the password.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序，访问`http://localhost:8080/`，并使用`admin1@example.com`作为用户名和`admin1`作为密码登录。
- en: Visit the My Events page, and you will see that only the events for that current
    user, who is the owner or the attendee, are displayed.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问我的事件页面，您将看到只显示当前用户的那些事件，该用户是所有者或参与者。
- en: Try creating a new event; you will observe that the owner of the event is now
    associated with the logged-in user.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试创建一个新事件；您会观察到事件的所有者现在与登录的用户相关联。
- en: Log out of the application and repeat these steps with `user1@example.com` as
    the username and `user1` as the password.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出应用程序，然后用`user1@example.com`作为用户名和`user1`作为密码重复这些步骤。
- en: Your code should now look like `chapter03.01-calendar`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter03.01-calendar`。
- en: Logging in new users using SecurityContextHolder
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SecurityContextHolder登录新用户
- en: A common requirement is to allow users to create a new account and then automatically
    log them in to the application. In this section, we'll describe the simplest method
    for indicating that a user is authenticated, by utilizing `SecurityContextHolder`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是允许用户创建一个新的账户，然后自动登录到应用程序。在本节中，我们将描述最简单的方法来指示用户已认证，通过利用`SecurityContextHolder`。
- en: Managing users in Spring Security
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Security中管理用户
- en: The application provided in [Chapter 1](01.html), *Anatomy of an Unsafe Application*,
    provides a mechanism for creating a new `CalendarUser` object, so it should be
    fairly trivial to create our `CalendarUser` object after a user signs up. However,
    Spring Security has no knowledge of `CalendarUser`. This means that we will need
    to add a new user in Spring Security too. Don't worry, we will remove the need
    for the dual maintenance of users later in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](01.html)*一个不安全应用程序的剖析*中提供的应用程序，提供了一个创建新的`CalendarUser`对象的机制，因此，在用户注册后，创建我们的`CalendarUser`对象应该相对简单。然而，Spring
    Security对`CalendarUser`一无所知。这意味着我们还需要在Spring Security中添加一个新的用户。别担心，我们会在本章后面消除对用户双重维护的需要。
- en: Spring Security provides an `o.s.s.provisioning.UserDetailsManager` interface
    for managing users. Remember our in-memory Spring Security configuration?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了一个`o.s.s.provisioning.UserDetailsManager`接口来管理用户。还记得我们的内存中的Spring
    Security配置吗？
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `.inMemoryAuthentication()` method creates an in-memory implementation of
    `UserDetailsManager`, named `o.s.s.provisioning.InMemoryUserDetailsManager`, which
    can be used to create a new Spring Security user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`.inMemoryAuthentication()`方法创建了一个名为`o.s.s.provisioning.InMemoryUserDetailsManager`的内存实现`UserDetailsManager`，该实现可以用来创建一个新的Spring
    Security用户。'
- en: While converting from an XML configuration to a Java-based configuration in
    Spring Security, there is currently a limitation with the Spring Security DSL
    where exposing multiple beans is not currently supported. There is a JIRA opened
    for this issue at [https://jira.spring.io/browse/SPR-13779.](https://jira.spring.io/browse/SPR-13779)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当从XML配置转换为基于Java的配置时，Spring Security中存在一个限制，即Spring Security DSL目前不支持暴露多个bean。关于这个问题已经打开了一个JIRA，链接为[https://jira.spring.io/browse/SPR-13779.](https://jira.spring.io/browse/SPR-13779)
- en: 'Let''s see how we can manage users in Spring Security by performing the following
    steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过执行以下步骤来管理Spring Security中的用户：
- en: 'In order to expose `UserDetailsManager` using a Java-based configuration, we
    need to create `InMemoryUserDetailsManager` outside of the `WebSecurityConfigurerAdapter`
    DSL:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过基于Java的配置暴露`UserDetailsManager`，我们需要在`WebSecurityConfigurerAdapter` DSL之外创建`InMemoryUserDetailsManager`：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we have an exposed `UserDetailsManager` interface in our Spring configuration,
    all we need to do is update our existing `CalendarService` implementation, `DefaultCalendarService`,
    to add a user in Spring Security. Make the following updates to the `DefaultCalendarService.java`
    file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在Spring配置中暴露了`UserDetailsManager`接口，我们所需要做的就是更新我们现有的`CalendarService`实现，`DefaultCalendarService`，以在Spring
    Security中添加用户。对`DefaultCalendarService.java`文件进行以下更新：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In order to leverage `UserDetailsManager`, we first convert `CalendarUser` into
    the `UserDetails` object of Spring Security.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了利用`UserDetailsManager`，我们首先将`CalendarUser`转换为Spring Security的`UserDetails`对象。
- en: Later, we use `UserDetailsManager` to save the `UserDetails` object. The conversion
    is necessary because Spring Security has no understanding of how to save our custom
    `CalendarUser` object, so we must map `CalendarUser` to an object Spring Security
    understands. You will notice that the `GrantedAuthority` object corresponds to
    the `authorities` attribute of our `SecurityConfig` file. We hardcode this for
    simplicity and due to the fact that there is no concept of roles in our existing
    system.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后来，我们使用`UserDetailsManager`来保存`UserDetails`对象。转换是必要的，因为Spring Security不知道如何保存我们的自定义`CalendarUser`对象，所以我们必须将`CalendarUser`映射到Spring
    Security理解的对象。您会注意到`GrantedAuthority`对象对应于我们`SecurityConfig`文件中的`authorities`属性。我们为了简单起见并因为我们的现有系统没有角色概念而硬编码这个值。
- en: Logging in a new user to an application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录新用户到应用程序
- en: 'Now that we are able to add new users to the system, we need to indicate that
    the user is authenticated. Update `SpringSecurityUserContext` to set the current
    user on the `SecurityContextHolder` object of Spring Security, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够向系统添加新用户，我们需要指示用户已认证。更新`SpringSecurityUserContext`以在Spring Security的`SecurityContextHolder`对象上设置当前用户，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first step we perform is to convert our `CalendarUser` object into the `UserDetails`
    object of Spring Security. This is necessary because, just as Spring Security
    didn't know how to save our custom `CalendarUser` object, Spring Security also
    does not understand how to make security decisions with our custom `CalendarUser`
    object. We use Spring Security's `o.s.s.core.userdetails.UserDetailsService` interface
    to obtain the same `UserDetails` object we saved with `UserDetailsManager`. The
    `UserDetailsService` interface provides a subset, lookup by username, of the functionality
    provided by Spring Security's `UserDetailsManager` object that we have already
    seen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先执行的步骤是将我们的`CalendarUser`对象转换为Spring Security的`UserDetails`对象。这是必要的，因为正如Spring
    Security不知道如何保存我们的自定义`CalendarUser`对象一样，Spring Security也不理解如何使用我们的自定义`CalendarUser`对象做出安全决策。我们使用Spring
    Security的`o.s.s.core.userdetails.UserDetailsService`接口来获取我们通过`UserDetailsManager`保存的相同的`UserDetails`对象。`UserDetailsService`接口提供了`UserDetailsManager`对象的功能的一个子集，通过用户名查找。
- en: Next, we create a `UsernamePasswordAuthenticationToken` object and place `UserDetails`,
    the password, and `GrantedAuthority` in it. Lastly, we set the authentication
    on `SecurityContextHolder`. In a web application, Spring Security will automatically
    associate the `SecurityContext` object in `SecurityContextHolder` to our HTTP
    session for us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`UsernamePasswordAuthenticationToken`对象，并将`UserDetails`、密码和`GrantedAuthority`放入其中。最后，我们在`SecurityContextHolder`上设置认证。在Web应用程序中，Spring
    Security会自动将`SecurityContext`对象与`SecurityContextHolder`中的HTTP会话关联起来。
- en: It is important that Spring Security must not be instructed to ignore a URL
    (that is, using the `permitAll()` method), as discussed in [Chapter 2](02.html),
    *Getting Started with Spring Security*, in which `SecurityContextHolder` is accessed
    or set. This is because Spring Security will ignore the request and thus not persist
    `SecurityContext` for subsequent requests. The proper method to allow access to
    the URL in which `SecurityContextHolder` is used is to specify the `access` attribute
    of the `antMatchers()` method (that is, `antMatchers(¦).permitAll()`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，Spring Security不能被指示忽略一个URL（即使用`permitAll()`方法），正如在[第2章](02.html)《开始使用Spring
    Security》中讨论的那样，其中访问或设置了`SecurityContextHolder`。这是因为Spring Security将忽略该请求，因此不会为后续请求持久化`SecurityContext`。允许访问使用`SecurityContextHolder`的URL的正确方法是指定`antMatchers()`方法的`access`属性（即`antMatchers(¦).permitAll()`）。
- en: 'It is worth mentioning that we could have converted `CalendarUser` by creating
    a new `o.s.s.core.userdetails.User` object directly, instead of looking it up
    in `UserDetailsService`. For example, the following code would also authenticate
    the user:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们本可以直接通过创建一个新的`o.s.s.core.userdetails.User`对象来转换`CalendarUser`，而不是在`UserDetailsService`中查找。例如，下面的代码也可以认证用户：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The advantage of this approach is that there is no need to hit the datastore
    again. In our case, the datastore is an in-memory datastore, but this could be
    backed by a database, which could have some security implications. The disadvantage
    of this approach is that we do not get to reuse the code much. Since this method
    is invoked infrequently, we opt for reusing the code. In general, it is best to
    evaluate each situation separately to determine which approach makes the most
    sense.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于，我们无需再次访问数据存储。在我们这个案例中，数据存储是一个内存中的数据存储，但这也可能是由一个数据库支持的，这可能会带来一些安全风险。这种方法的一个缺点是我们无法复用代码太多。由于这种方法调用不频繁，我们选择复用代码。通常，最佳做法是单独评估每种情况，以确定哪种方法最合适。
- en: Updating SignupController
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新SignupController
- en: 'The application has a `SignupController` object, which is what processes the
    HTTP request to create a new `CalendarUser` object. The last step is to update
    `SignupController` to create our user and then indicate that they are logged in.
    Make the following updates to `SignupController`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有一个`SignupController`对象，该对象处理创建新的`CalendarUser`对象的HTTP请求。最后一步是更新`SignupController`以创建我们的用户，然后指示他们已经登录。对`SignupController`进行以下更新：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you have not done so already, restart the application, visit `http://localhost:8080/`,
    create a new user, and see that the new user is automatically logged in.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这么做，请重新启动应用程序，访问`http://localhost:8080/`，创建一个新的用户，并查看新用户是否自动登录。
- en: Your code should now look like `chapter03.02-calendar`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter03.02-calendar`。
- en: Creating a custom UserDetailsService object
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义UserDetailsService对象
- en: While we are able to link our domain model (`CalendarUser`) with Spring Security's
    domain model (`UserDetails`), we have to maintain multiple representations of
    the user. To resolve this dual maintenance, we can implement a custom `UserDetailsService`
    object to translate our existing `CalendarUser` domain model into an implementation
    of Spring Security's `UserDetails` interface. By translating our `CalendarUser`
    object into `UserDetails`, Spring Security can make security decisions using our
    custom domain model. This means that we will no longer need to manage two different
    representations of a user.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们能够将我们的领域模型（`CalendarUser`）与Spring Security的领域模型（`UserDetails`）关联起来，但我们不得不维护用户的多个表示。为了解决这种双重维护，我们可以实现一个自定义的`UserDetailsService`对象，将我们现有的`CalendarUser`领域模型转换为Spring
    Security`UserDetails`接口的实现。通过将我们的`CalendarUser`对象转换为`UserDetails`，Spring Security可以使用我们的自定义领域模型做出安全决策。这意味着我们将不再需要管理用户的两种不同表示。
- en: The CalendarUserDetailsService class
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日历用户详细信息服务类
- en: 'Up to this point, we have needed two different representations of users: one
    for Spring Security to make security decisions, and one for our application to
    associate our domain objects to. Create a new class named `CalendarUserDetailsService`
    that will make Spring Security aware of our `CalendarUser` object. This will ensure
    that Spring Security can make decisions based upon our domain model. Create a
    new file named `CalendarUserDetailsService.java`, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要两种不同的用户表示：一种用于Spring Security做出安全决策，另一种用于我们的应用程序将我们的领域对象关联起来。创建一个名为`CalendarUserDetailsService`的新类，使Spring
    Security意识到我们的`CalendarUser`对象。这将确保Spring Security可以根据我们的领域模型做出决策。按照如下方式创建一个名为`CalendarUserDetailsService.java`的新文件：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Within Spring Tool Suite, you can use *Shift*+*Ctrl*+*O* to easily add the missing
    imports. Alternatively, you can copy the code from the next checkpoint (`chapter03.03-calendar`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Tool Suite中，您可以使用*Shift*+*Ctrl*+*O*快捷键轻松添加缺少的导入。另外，您还可以从下一个检查点（`chapter03.03-calendar`）复制代码。
- en: Here, we utilize `CalendarUserDao` to obtain `CalendarUser` by using the email
    address. We take care not to return a `null` value; instead, a `UsernameNotFoundException`
    exception should be thrown, as returning `null` breaks the `UserDetailsService`
    interface.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`CalendarUserDao`通过电子邮件地址获取`CalendarUser`。我们确保不返回`null`值；相反，应该抛出`UsernameNotFoundException`异常，因为返回`null`会破坏`UserDetailsService`接口。
- en: We then convert `CalendarUser` into `UserDetails`, implemented by the user,
    as we did in the previous sections.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`CalendarUser`转换为由用户实现的`UserDetails`。
- en: We now utilize a utility class named `CalendarUserAuthorityUtils` that we provided
    in the sample code. This will create `GrantedAuthority` based on the email address
    so that we can support users and administrators. If the email starts with `admin`,
    the user is treated as `ROLE_ADMIN, ROLE_USER`. Otherwise, the user is treated
    as `ROLE_USER`. Of course, we would not do this in a real application, but it's
    this simplicity that allows us to focus on this lesson.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们利用提供的示例代码中提供的工具类`CalendarUserAuthorityUtils`。这将根据电子邮件地址创建`GrantedAuthority`，以便我们可以支持用户和管理员。如果电子邮件地址以`admin`开头，则用户被视为`ROLE_ADMIN,
    ROLE_USER`。否则，用户被视为`ROLE_USER`。当然，在实际应用程序中我们不会这样做，但正是这种简单性让我们能够专注于本课。
- en: Configuring UserDetailsService
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置UserDetailsService
- en: 'Now that we have a new `UserDetailsService` object, let''s update the Spring
    Security configuration to utilize it. Our `CalendarUserDetailsService` class is
    added to our Spring configuration automatically, since we leverage classpath scanning
    and the `@Component` annotation. This means we only need to update Spring Security
    to refer to the `CalendarUserDetailsService` class we just created. We are also
    able to remove the `configure()` and `userDetailsService()` methods, Spring Security''s
    in-memory implementation of `UserDetailsService`, since we are now providing our
    own `UserDetailsService` implementation. Update the `SecurityConfig.java` file,
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个新的`UserDetailsService`对象，让我们更新Spring Security配置以使用它。由于我们利用类路径扫描和`@Component`注解，我们的`CalendarUserDetailsService`类自动添加到Spring配置中。这意味着我们只需要更新Spring
    Security以引用我们刚刚创建的`CalendarUserDetailsService`类。我们还可以删除`configure()`和`userDetailsService()`方法，因为我们现在提供了自己的`UserDetailsService`实现。按照如下方式更新`SecurityConfig.java`文件：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Removing references to UserDetailsManager
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除对UserDetailsManager的引用
- en: 'We need to remove the code we added in `DefaultCalendarService` that used `UserDetailsManager`
    to synchronize the Spring Security `o.s.s.core.userdetails.User` interface and
    `CalendarUser`. First, the code is not necessary, since Spring Security now refers
    to `CalendarUserDetailsService`. Second, since we removed the `inMemoryAuthentication()`
    method, there is no `UserDetailsManager` object defined in our Spring configuration.
    Go ahead and remove all references to `UserDetailsManager` found in `DefaultCalendarService`.
    The updates will look similar to the following sample snippets:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要删除在`DefaultCalendarService`中使用`UserDetailsManager`进行同步的代码，该代码将Spring Security的`o.s.s.core.userdetails.User`接口和`CalendarUser`同步。首先，由于Spring
    Security现在引用`CalendarUserDetailsService`，所以这段代码是不必要的。其次，由于我们移除了`inMemoryAuthentication()`方法，我们Spring配置中没有定义`UserDetailsManager`对象。删除在`DefaultCalendarService`中找到的所有对`UserDetailsManager`的引用。更新将类似于以下示例片段：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Start up the application and see that Spring Security's in-memory `UserDetailsManager`
    object is no longer necessary (we removed it from our `SecurityConfig.java` file).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并查看Spring Security的内存中`UserDetailsManager`对象已不再必要（我们已将其从我们的`SecurityConfig.java`文件中删除）。
- en: Your code should now look like `chapter03.03-calendar`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter03.03-calendar`。
- en: The CalendarUserDetails object
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日历用户详细信息对象
- en: 'We have successfully eliminated the need to manage both Spring Security users
    and our `CalendarUser` objects. However, it is still cumbersome for us to continually
    need to translate between the two objects. Instead, we will create a `CalendarUserDetails`
    object, which can be referred to as both `UserDetails` and `CalendarUser`. Update
    `CalendarUserDetailsService` to use `CalendarUserDetails`, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功消除了同时管理Spring Security用户和我们自己的`CalendarUser`对象的需求。然而，我们仍然需要不断在两者之间进行转换，这很麻烦。相反，我们将创建一个`CalendarUserDetails`对象，该对象可以被称为`UserDetails`和`CalendarUser`。使用以下代码更新`CalendarUserDetailsService`：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next section, we will see that our application can now refer to the principal
    authentication on the current `CalendarUser` object. However, Spring Security
    can continue to treat `CalendarUserDetails` as a `UserDetails` object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到我们的应用程序现在可以引用当前`CalendarUser`对象的主体认证。然而，Spring Security仍然可以将`CalendarUserDetails`视为一个`UserDetails`对象。
- en: The SpringSecurityUserContext simplifications
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化`SpringSecurityUserContext`
- en: 'We have updated `CalendarUserDetailsService` to return a `UserDetails` object
    that extends `CalendarUser` and implements `UserDetails`. This means that, rather
    than having to translate between the two objects, we can simply refer to a `CalendarUser`
    object. Update `SpringSecurityUserContext` as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了`CalendarUserDetailsService`，使其返回一个扩展了`CalendarUser`并实现了`UserDetails`的`UserDetails`对象。这意味着，我们不需要在两个对象之间进行转换，只需简单地引用一个`CalendarUser`对象。按照以下方式更新`SpringSecurityUserContext`：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The updates no longer require the use of `CalendarUserDao` or Spring Security's
    `UserDetailsService` interface. Remember our `loadUserByUsername` method from
    the previous section? The result of this method call becomes the principal of
    the authentication. Since our updated `loadUserByUsername` method returns an object
    that extends `CalendarUser`, we can safely cast the principal of the `Authentication`
    object to `CalendarUser`. We can pass a `CalendarUser` object as the principal
    into the constructor for `UsernamePasswordAuthenticationToken` when invoking the
    `setCurrentUser` method. This allows us to still cast the principal to a `CalendarUser`
    object when invoking the `getCurrentUser` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更新不再需要使用`CalendarUserDao`或Spring Security的`UserDetailsService`接口。还记得我们上一节中的`loadUserByUsername`方法吗？这个方法调用的结果成为认证的主体。由于我们更新的`loadUserByUsername`方法返回一个扩展了`CalendarUser`的对象，我们可以安全地将`Authentication`对象的主体转换为`CalendarUser`。当调用`setCurrentUser`方法时，我们可以将一个`CalendarUser`对象作为主体传递给`UsernamePasswordAuthenticationToken`构造函数。这允许我们在调用`getCurrentUser`方法时仍然将主体转换为`CalendarUser`对象。
- en: Displaying custom user attributes
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示自定义用户属性
- en: 'Now that `CalendarUser` is populated into Spring Security''s authentication,
    we can update our UI to display the name of the current user rather than the email
    address. Update the `header.html` file with the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`CalendarUser`已经填充到Spring Security的认证中，我们可以更新我们的UI来显示当前用户的姓名，而不是电子邮件地址。使用以下代码更新`header.html`文件：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Internally, the `"${#authentication.getPrincipal().getName()}"` tag attribute
    executes the following code. Observe that the highlighted values correlate to
    the `property` attribute of the authentication tag we specified in the `header.html`
    file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 内部地，`"${#authentication.getPrincipal().getName()}"`标签属性执行以下代码。请注意，高亮显示的值与我们在`header.html`文件中指定的认证标签的`property`属性相关联：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Restart the application, visit `http://localhost:8080/`, and log in to view
    the updates. Instead of seeing the current user's email, you should now see their
    first and last names.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重启应用程序，访问`http://localhost:8080/`，登录以查看更新。 Instead of seeing the current user's
    email, you should now see their first and last names.（您现在应该看到的是当前用户的姓名，而不是电子邮件地址。）
- en: Your code should now look like `chapter03.04-calendar`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter03.04-calendar`。
- en: Creating a custom AuthenticationProvider object
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义的`AuthenticationProvider`对象
- en: Spring Security delegates to an `AuthenticationProvider` object to determine
    whether a user is authenticated or not. This means we can write custom `AuthenticationProvider`
    implementations to inform Spring Security how to authenticate in different ways.
    The good news is that Spring Security provides quite a few `AuthenticationProvider`
    objects, so more often than not you will not need to create one. In fact, up until
    this point, we have been utilizing Spring Security's `o.s.s.authentication.dao.DaoAuthenticationProvider`
    object, which compares the username and password returned by `UserDetailsService`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security委托一个`AuthenticationProvider`对象来确定用户是否已认证。这意味着我们可以编写自定义的`AuthenticationProvider`实现来告知Spring
    Security如何以不同方式进行认证。好消息是Spring Security提供了一些`AuthenticationProvider`对象，所以大多数时候你不需要创建一个。事实上，到目前为止，我们一直在使用Spring
    Security的`o.s.s.authentication.dao.DaoAuthenticationProvider`对象，它比较`UserDetailsService`返回的用户名和密码。
- en: CalendarUserAuthenticationProvider
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日历用户认证提供者
- en: Throughout the rest of this section, we are going to create a custom `AuthenticationProvider`
    object named `CalendarUserAuthenticationProvider` that will replace `CalendarUserDetailsService`.
    Then, we will use `CalendarUserAuthenticationProvider` to consider an additional
    parameter to support authenticating users from multiple domains.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文节的其余部分，我们将创建一个名为`CalendarUserAuthenticationProvider`的自定义`AuthenticationProvider`对象，它将替换`CalendarUserDetailsService`。然后，我们将使用`CalendarUserAuthenticationProvider`来考虑一个额外的参数，以支持来自多个域的用户认证。
- en: We must use an `AuthenticationProvider` object rather than `UserDetailsService`,
    because the `UserDetails` interface has no concept of a domain parameter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用一个`AuthenticationProvider`对象而不是`UserDetailsService`，因为`UserDetails`接口没有领域参数的概念。
- en: 'Create a new class named `CalendarUserAuthenticationProvider`, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CalendarUserAuthenticationProvider`的新类，如下所示：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Remember that you can use *Shift*+*Ctrl*+*O* within Eclipse to easily add the
    missing imports. Alternatively, you can copy the implementation from `chapter03.05-calendar`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在Eclipse中你可以使用*Shift*+*Ctrl*+*O*快捷键轻松添加缺失的导入。另外，你也可以从`chapter03.05-calendar`中复制实现。
- en: Before Spring Security can invoke the `authenticate` method, the `supports`
    method must return `true` for the `Authentication` class that will be passed in.
    In this case, `AuthenticationProvider` can authenticate a username and password.
    We do not accept subclasses of `UsernamePasswordAuthenticationToken`, since there
    may be additional fields that we do not know how to validate.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security可以调用`authenticate`方法之前，`supports`方法必须对将要传递进去的`Authentication`类返回`true`。在这个例子中，`AuthenticationProvider`可以认证用户名和密码。我们不接受`UsernamePasswordAuthenticationToken`的子类，因为可能有我们不知道如何验证的额外字段。
- en: The `authenticate` method accepts an `Authentication` object as an argument
    that represents an authentication request. In practical terms, it is the input
    from the user that we need to attempt to validate. If authentication fails, the
    method should throw an `o.s.s.core.AuthenticationException` exception. If authentication
    succeeds, it should return an `Authentication` object that contains the proper
    `GrantedAuthority` objects for the user. The returned `Authentication` object
    will be set on `SecurityContextHolder`. If authentication cannot be determined,
    the method should return `null`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate`方法接受一个代表认证请求的`Authentication`对象作为参数。在实际中，它是我们需要尝试验证的用户输入。如果认证失败，该方法应该抛出一个`o.s.s.core.AuthenticationException`异常。如果认证成功，它应该返回一个包含用户适当的`GrantedAuthority`对象的`Authentication`对象。返回的`Authentication`对象将被设置在`SecurityContextHolder`上。如果无法确定认证，该方法应该返回`null`。'
- en: The first step in authenticating the request is to extract the information from
    the `Authentication` object that we need to authenticate the user. In our case,
    we extract the username and look up `CalendarUser` by email address, just as `CalendarUserDetailsService`
    did. If the provided username and password match `CalendarUser`, we will return
    a `UsernamePasswordAuthenticationToken` object with proper `GrantedAuthority`.
    Otherwise, we will throw an `AuthenticationException` exception.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 认证请求的第一步是从我们需要的`Authentication`对象中提取信息以认证用户。在我们这个案例中，我们提取用户名并通过电子邮件地址查找`CalendarUser`，就像`CalendarUserDetailsService`所做的那样。如果提供的用户名和密码匹配`CalendarUser`，我们将返回一个带有适当`GrantedAuthority`的`UsernamePasswordAuthenticationToken`对象。否则，我们将抛出一个`AuthenticationException`异常。
- en: Remember how the login page leveraged `SPRING_SECURITY_LAST_EXCEPTION` to explain
    why login failed? The message for the `AuthenticationException` exception thrown
    in `AuthenticationProvider` is the last `AuthenticationException` exception and
    will be displayed on our login page in the event of a failed login.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得登录页面是如何利用`SPRING_SECURITY_LAST_EXCEPTION`解释登录失败的原因吗？`AuthenticationProvider`中抛出的`AuthenticationException`异常的消息是最后一个`AuthenticationException`异常，在登录失败时会在我们的登录页面上显示。
- en: Configuring the CalendarUserAuthenticationProvider object
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置`CalendarUserAuthenticationProvider`对象
- en: 'Let''s perform the following steps to configure `CalendarUserAuthenticationProvider`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来配置`CalendarUserAuthenticationProvider`：
- en: 'Update the `SecurityConfig.java` file to refer to our newly created `CalendarUserAuthenticationProvider`
    object, and remove the reference to `CalendarUserDetailsService`, as shown in
    the following code snippet:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`SecurityConfig.java`文件以引用我们新创建的`CalendarUserAuthenticationProvider`对象，并删除对`CalendarUserDetailsService`的引用，如下代码片段所示：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Restart the application and ensure everything is still working. As a user, we
    do not notice anything different. However, as a developer, we know that `CalendarUserDetails`
    is no longer required; we are still able to display the current user's first and
    last names, and Spring Security is still able to leverage `CalendarUser` for authentication.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启应用程序并确保一切仍然正常工作。作为用户，我们并没有察觉到任何不同。然而，作为开发者，我们知道`CalendarUserDetails`已经不再需要；我们仍然能够显示当前用户的姓名和姓氏，Spring
    Security仍然能够利用`CalendarUser`进行认证。
- en: Your code should now look like `chapter03.05-calendar`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter03.05-calendar`。
- en: Authenticating with different parameters
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同参数进行认证
- en: One of the strengths of `AuthenticationProvider` is that it can authenticate
    with any parameters you wish. For example, maybe your application uses a random
    identifier for authentication, or perhaps it is a multitenant application and
    requires a username, password, and domain. In the following section, we will update
    `CalendarUserAuthenticationProvider` to support multiple domains.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthenticationProvider`的一个优点是它可以接受任何你想要的参数进行认证。例如，也许你的应用程序使用一个随机标识符进行认证，或者也许它是一个多租户应用程序，需要用户名、密码和域名。在下一节中，我们将更新`CalendarUserAuthenticationProvider`以支持多个域名。'
- en: A domain is a way to scope our users. For example, if we deploy our application
    once but have multiple clients using the same deployment, each client may want
    a user with the username `admin`. By adding a domain to our user object, we can
    ensure that each user is distinct and still supports this requirement.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 域名是一种定义用户范围的方式。例如，如果我们一次性部署了一个应用但多个客户都在使用这个部署，每个客户可能都需要一个名为`admin`的用户。通过在用户对象中添加一个域名，我们可以确保每个用户都是独一无二的，同时还能满足这一需求。
- en: The DomainUsernamePasswordAuthenticationToken class
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`DomainUsernamePasswordAuthenticationToken`类'
- en: 'When a user authenticates, Spring Security submits an `Authentication` object
    to `AuthenticationProvider` with the information provided by the user. The current
    `UsernamePasswordAuthentication` object only contains a username and password
    field. Create a `DomainUsernamePasswordAuthenticationToken` object that contains
    a `domain` field, as shown in the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进行认证时，Spring Security会将一个`Authentication`对象提交给`AuthenticationProvider`，其中包含用户提供的信息。当前的`UsernamePasswordAuthentication`对象只包含用户名和密码字段。创建一个包含`domain`字段的`DomainUsernamePasswordAuthenticationToken`对象，如下代码片段所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Updating CalendarUserAuthenticationProvider
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`CalendarUserAuthenticationProvider`
- en: 'Let''s take a look at the following steps for updating the `CalendarUserAuthenticationProvider.java`
    file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看更新`CalendarUserAuthenticationProvider.java`文件以下步骤：
- en: 'Now, we need to update `CalendarUserAuthenticationProvider` to utilize the
    domain field as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`CalendarUserAuthenticationProvider`以使用域名字段，如下所示：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We first update the `supports` method so that Spring Security will pass `DomainUsernamePasswordAuthenticationToken`
    into our `authenticate` method.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先更新`supports`方法，以便Spring Security会将`DomainUsernamePasswordAuthenticationToken`传递到我们的`authenticate`方法中。
- en: We then use the domain information to create our email address and authenticate,
    as we had previously done. Admittedly, this example is contrived. However, the
    example is able to illustrate how to authenticate with an additional parameter.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们利用域名信息来创建我们的电子邮件地址和进行认证，就像我们之前所做的那样。坦白说，这个例子有些牵强。然而，这个例子能够说明如何使用一个附加参数进行认证。
- en: The `CalendarUserAuthenticationProvider` interface can now use the new domain
    field. However, there is no way for a user to specify the domain. For this, we
    must update our `login.html` file.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`CalendarUserAuthenticationProvider`接口可以利用新的域字段了。然而，用户无法指定域。为此，我们必须更新我们的`login.html`文件。
- en: Adding domain to the login page
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在登录页面上添加域
- en: 'Open up the `login.html` file and add a new input named `domain`, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`login.html`文件，添加一个名为`domain`的新输入，如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, a domain will be submitted when users attempt to log in. However, Spring
    Security is unaware of how to use that domain to create a `DomainUsernamePasswordAuthenticationToken`
    object and pass it into `AuthenticationProvider`. To fix this, we will need to
    create `DomainUsernamePasswordAuthenticationFilter`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户尝试登录时，将提交域。然而，Spring Security不知道如何使用这个域来创建一个`DomainUsernamePasswordAuthenticationToken`对象并将其传递给`AuthenticationProvider`。为了解决这个问题，我们需要创建`DomainUsernamePasswordAuthenticationFilter`。
- en: The DomainUsernamePasswordAuthenticationFilter class
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`DomainUsernamePasswordAuthenticationFilter`类'
- en: 'Spring Security provides a number of servlet filters that act as controllers
    for authenticating users. The filters are invoked as one of the delegates of the
    `FilterChainProxy` object that we discussed in [Chapter 2](02.html), *Getting
    Started with Spring Security*. Previously, the `formLogin()` method instructed
    Spring Security to use `o.s.s.web.authentication.UsernamePasswordAuthenticationFilter`
    to act as a login controller. The filter''s job is to perform the following tasks:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了一系列作为用户认证控制器的servlet过滤器。这些过滤器作为`FilterChainProxy`对象的代理之一，我们在[第2章](02.html)中讨论过，*Spring
    Security入门*。以前，`formLogin()`方法指导Spring Security使用`o.s.s.web.authentication.UsernamePasswordAuthenticationFilter`作为登录控制器。过滤器的工作是执行以下任务：
- en: Obtain a username and password from the HTTP request.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从HTTP请求中获取用户名和密码。
- en: Create a `UsernamePasswordAuthenticationToken` object with the information obtained
    from the HTTP request.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从HTTP请求中获取的信息创建一个`UsernamePasswordAuthenticationToken`对象。
- en: Request that Spring Security validates `UsernamePasswordAuthenticationToken`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求Spring Security验证`UsernamePasswordAuthenticationToken`。
- en: If the token is validated, it will set the authentication returned to it on
    `SecurityContextHolder`, just as we did when a new user signed up for an account.
    We will need to extend `UsernamePasswordAuthenticationFilter` to leverage our
    newly created `DoainUsernamePasswordAuthenticationToken` object.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果验证令牌，它将在`SecurityContextHolder`上设置返回的认证，就像我们为新用户注册账户时所做的那样。我们需要扩展`UsernamePasswordAuthenticationFilter`以利用我们新创建的`DoainUsernamePasswordAuthenticationToken`对象。
- en: 'Create a `DomainUsernamePasswordAuthenticationFilter` object, as follows:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`DomainUsernamePasswordAuthenticationFilter`对象，如下所示：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The new `DomainUsernamePasswordAuthenticationFilter` object will perform the
    following tasks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`DomainUsernamePasswordAuthenticationFilter`对象将执行以下任务：
- en: Obtain a username, password, and domain from the `HttpServletRequest` method.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`HttpServletRequest`方法获取用户名、密码和域。
- en: Create our `DomainUsernamePasswordAuthenticationToken` object with information
    obtained from the HTTP request.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从HTTP请求中获取的信息创建我们的`DomainUsernamePasswordAuthenticationToken`对象。
- en: Request that Spring Security validates `DomainUsernamePasswordAuthenticationToken`.
    The work is delegated to `CalendarUserAuthenticationProvider`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求Spring Security验证`DomainUsernamePasswordAuthenticationToken`。工作委托给`CalendarUserAuthenticationProvider`。
- en: If the token is validated, its superclass will set the authentication returned
    by `CalendarUserAuthenticationProvider` on `SecurityContextHolder`, just as we
    did to authenticate a user after they created a new account.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果验证令牌，其超类将在`SecurityContextHolder`上设置由`CalendarUserAuthenticationProvider`返回的认证，就像我们在用户创建新账户后进行认证一样。
- en: Updating our configuration
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的配置
- en: 'Now that we have created all the code required for an additional parameter,
    we need to configure Spring Security to be aware of it. The following code snippet
    includes the required updates to our `SecurityConfig.java` file to support our
    additional parameter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有需要的额外参数的代码，我们需要配置Spring Security使其能够意识到这个参数。以下代码片段包括了我们`SecurityConfig.java`文件以支持我们的额外参数所需的必要更新：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code snippet configures standard beans in our Spring Security
    configuration. We have shown this to demonstrate that it can be done. However,
    throughout much of the rest of the book, we include standard bean configuration
    in its own file, as this makes the configuration less verbose. If you are having
    trouble, or prefer not to type all of this, you may copy it from `chapter03.06-calendar`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码段配置了我们在 Spring Security 配置中的标准 bean。我们展示这个是为了表明它是可以做到的。然而，在本书的其余部分，我们将标准
    bean 配置放在自己的文件中，因为这样可以减少配置的冗余。如果你遇到困难，或者不喜欢输入所有这些内容，你可以从 `chapter03.06-calendar`
    复制它。
- en: 'The following are a few highlights from the configuration updates:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些配置更新的亮点：
- en: We overrode `defaultAuthenticationEntryPoint` and added a reference to `o.s.s.web.authentication.LoginUrlAuthenticationEntryPoint`,
    which determines what happens when a request for a protected resource occurs and
    the user is not authenticated. In our case, we are redirected to a login page.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们覆盖了 `defaultAuthenticationEntryPoint`，并添加了对 `o.s.s.web.authentication.LoginUrlAuthenticationEntryPoint`
    的引用，它决定了当请求受保护的资源且用户未认证时会发生什么。在我们这个案例中，我们被重定向到了一个登录页面。
- en: We removed the `formLogin()` method and used a `.addFilterAt()` method to insert
    our custom filter into `FilterChainProxy`. The position indicates the order in
    which the delegates of `FilterChain` are considered and cannot overlap with another
    filter, but can replace the filter at the current position. We replaced `UsernamePasswordAuthenticationFilter`
    with our custom filter.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们移除了 `formLogin()` 方法，并使用 `.addFilterAt()` 方法将我们的自定义过滤器插入到 `FilterChainProxy`
    中。这个位置表示 `FilterChain` 代理的委托考虑的顺序，且不能与另一个过滤器重叠，但可以替换当前位置的过滤器。我们用自定义过滤器替换了 `UsernamePasswordAuthenticationFilter`。
- en: We added the configuration for our custom filter, which refers to the authentication
    manager created by the `configure(AuthenticationManagerBuilder)` method.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为我们的自定义过滤器添加了配置，该配置引用了由 `configure(AuthenticationManagerBuilder)` 方法创建的认证管理器。
- en: 'Take a look at the following diagram for your reference:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表供您参考：
- en: '![](img/7dcf22b3-a3c3-465c-981e-eadbf92a70c2.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dcf22b3-a3c3-465c-981e-eadbf92a70c2.png)'
- en: 'You can now restart the application and try the following steps, depicted in
    the preceding diagram, to understand how all the pieces fit together:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以重新启动应用程序，并尝试以下步骤，如前所示的图表，来理解所有部分是如何组合在一起的：
- en: Visit `http://localhost:8080/events`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:8080/events`。
- en: Spring Security will intercept the secured URL and use the `LoginUrlAuthenticationEntryPoint`
    object to process it.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security 将拦截受保护的 URL 并使用 `LoginUrlAuthenticationEntryPoint` 对象来处理它。
- en: The `LoginUrlAuthenticationEntryPoint` object will send the user to the login
    page. Enter `admin1` as the username, `example.com` as the domain, and `admin1`
    as the password.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoginUrlAuthenticationEntryPoint` 对象将会把用户重定向到登录页面。输入用户名 `admin1`，域名 `example.com`，以及密码
    `admin1`。'
- en: The `DomainUsernamePasswordAuthenticationFilter` object will intercept the process
    of the login request. It will then obtain the username, domain, and password from
    the HTTP request and create a `DomainUsernamePasswordAuthenticationToken` object.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DomainUserPasswordAuthenticationFilter` 对象将拦截登录请求的过程。然后它将从 HTTP 请求中获取用户名、域名和密码，并创建一个
    `DomainUsernamePasswordAuthenticationToken` 对象。'
- en: The `DomainUsernamePasswordAuthenticationFilter` object submits `DomainUsernamePasswordAuthenticationToken`
    to `CalendarUserAuthenticationProvider`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DomainUserPasswordAuthenticationFilter` 对象提交 `DomainUsernamePasswordAuthenticationToken`
    到 `CalendarUserAuthenticationProvider`。'
- en: The `CalendarUserAuthenticationProvider` interface validates `DomainUsernamePasswordAuthenticationToken`
    and then returns an authenticated `DomainUsernamePasswordAuthenticationToken`
    object (that is, `isAuthenticated()` returns `true`).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CalendarUserAuthenticationProvider` 接口验证 `DomainUsernamePasswordAuthenticationToken`，然后返回一个认证的
    `DomainUsernamePasswordAuthenticationToken` 对象（也就是说，`isAuthenticated()` 返回 `true`）。'
- en: The `DomainUserPasswordAuthenticationFilter` object updates `SecurityContext`
    with `DomainUsernamePasswordAuthenticationToken` and places it on `SecurityContextHolder`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DomainUserPasswordAuthenticationFilter` 对象用 `DomainUsernamePasswordAuthenticationToken`
    更新 `SecurityContext`，并将其放在 `SecurityContextHolder` 上。'
- en: Your code should look like `chapter03.06-calendar`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像 `chapter03.06-calendar`。
- en: Which authentication method to use?
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应该使用哪种认证方式？
- en: 'We have covered the three main methods of authenticating, so which one is the
    best? Like all solutions, each comes with its pros and cons. You can find a summary
    of when to use a specific type of authentication by referring to the following
    list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了认证的三种主要方法，那么哪一种最好呢？像所有解决方案一样，每种方法都有其优点和缺点。你可以通过参考以下列表来找到特定类型认证的使用情况：
- en: '`SecurityContextHolder`: Interacting directly with `SecurityContextHolder`
    is certainly the easiest way of authenticating a user. It works well when you
    are authenticating a newly created user or authenticating in an unconventional
    way. By using `SecurityContextHolder` directly, we do not have to interact with
    so many Spring Security layers. The downside is that we do not get some of the
    more advanced features that Spring Security provides automatically. For example,
    if we want to send the user to the previously requested page after logging in,
    we would have to manually integrate that into our controller.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecurityContextHolder`：直接与`SecurityContextHolder`交互无疑是认证用户的最简单方式。当你正在认证一个新创建的用户或以非传统方式进行认证时，它工作得很好。通过直接使用`SecurityContextHolder`，我们不必与Spring
    Security的许多层进行交互。缺点是我们无法获得Spring Security自动提供的一些更高级的功能。例如，如果我们想在登录后把用户发送到之前请求的页面，我们还需要手动将此集成到我们的控制器中。'
- en: '`UserDetailsService`: Creating a custom `UserDetailsService` object is an easy
    mechanism that allows for Spring Security to make security decisions based on
    our custom domain model. It also provides a mechanism to hook into other Spring
    Security features. For example, Spring Security requires `UserDetailsService`
    in order to use the built-in remember-me support covered in [Chapter 7](08.html),
    *Remember-Me Services*. The `UserDetailsService` object does not work when authentication
    is not based on a username and password.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserDetailsService`：创建一个自定义的`UserDetailsService`对象是一个简单的机制，它允许Spring Security根据我们自定义的领域模型做出安全决策。它还提供了一种机制，以便与其他Spring
    Security特性进行钩接。例如，Spring Security在使用第[7章](08.html)*记住我服务*中介绍的内置记住我支持时需要`UserDetailsService`。当认证不是基于用户名和密码时，`UserDetailsService`对象不起作用。'
- en: '`AuthenticationProvider`: This is the most flexible method for extending Spring
    Security. It allows a user to authenticate with any parameters that we wish. However,
    if we wish to leverage features such as Spring Security''s remember-me, we will
    still need `UserDetailsService`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationProvider`：这是扩展Spring Security最灵活的方法。它允许用户使用任何我们希望的参数进行认证。然而，如果我们希望利用如Spring
    Security的记住我等特性，我们仍然需要`UserDetailsService`。'
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has used real-world problems to introduce the basic building blocks
    used in Spring Security. It also demonstrates to us how we can make Spring Security
    authenticate against our custom domain objects by extending those basic building
    blocks. In short, we have learned that the `SecurityContextHolder` interface is
    the central location for determining the current user. Not only can it be used
    by developers to access the current user, but also to set the currently logged-in
    user.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过实际问题介绍了Spring Security中使用的基本构建块。它还向我们展示了如何通过扩展这些基本构建块使Spring Security针对我们的自定义领域对象进行认证。总之，我们了解到`SecurityContextHolder`接口是确定当前用户的核心位置。它不仅可以被开发者用来访问当前用户，还可以设置当前登录的用户。
- en: We also explored how to create custom `UserDetailsService` and `AuthenticationProvider`
    objects and how to perform authentication with more than just a username and password.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何创建自定义的`UserDetailsService`和`AuthenticationProvider`对象，以及如何使用不仅仅是用户名和密码进行认证。
- en: In the next chapter, we will explore some of the built-in support for JDBC-based
    authentication.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些基于JDBC的认证的内置支持。
