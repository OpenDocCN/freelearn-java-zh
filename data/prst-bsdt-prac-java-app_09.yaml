- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Persistence Practices – Exploring Polyglot Persistence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化实践 – 探索多语言持久化
- en: Software development has become more complex, requiring way more integration,
    and we need to innovate simultaneously to make our lives easier. One good option
    is to take advantage of several databases with polyglot persistence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发已经变得更加复杂，需要更多的集成，我们需要同时创新来使我们的生活更轻松。一个好的选择是利用多语言持久化来利用几个数据库。
- en: When we talk about persistence solutions, there are around 400, with different
    types, structures, and particular behavior that make sense in specific cases.
    The philosophy of polyglot persistence is to use the tool to find the right solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论持久化解决方案时，大约有400种，它们具有不同的类型、结构和特定行为，这些行为在特定情况下是有意义的。多语言持久化的哲学是使用工具来找到正确的解决方案。
- en: This chapter will introduce the principle of polyglot persistence and how to
    use it with Java.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍多语言持久化的原理以及如何使用Java来实现它。
- en: 'We will discuss the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主题：
- en: The trade-offs of polyglot persistence
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言持久化的权衡
- en: Understanding **Domain-Driven Design** (**DDD**) and Jakarta
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**领域驱动设计**（DDD）和Jakarta
- en: Jakarta Data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta Data
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for the chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Java 17
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17
- en: Git
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的IDE
- en: The source code for the chapter is available at [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-09](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-09).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-09](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-09)找到。
- en: The trade-offs of polyglot persistence
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言持久化的权衡
- en: Polyglot persistence is an approach to data storage in which multiple types
    of databases are used together to address different needs within an application.
    The term **polyglot** refers to the use of various languages or tools, and in
    this context, it refers to the use of multiple types of databases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言持久化是一种数据存储方法，其中使用多种类型的数据库来满足应用程序内的不同需求。术语**多语言**指的是使用各种语言或工具，在这个上下文中，它指的是使用多种类型的数据库。
- en: In traditional monolithic applications, a single database is typically used
    to store all data types. However, this approach can become less effective as applications
    become more complex. Polyglot persistence, however, allows developers to choose
    the best database for each use case based on factors such as scalability, data
    structure, and query requirements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的单体应用程序中，通常使用单个数据库来存储所有数据类型。然而，随着应用程序变得更加复杂，这种方法可能会变得不那么有效。然而，多语言持久化允许开发者根据可扩展性、数据结构和查询需求等因素为每个用例选择最佳的数据库。
- en: For example, a social media platform might use a document database such as MongoDB
    to store user profiles and activity feeds, a graph database such as Neo4j to analyze
    social connections, and a relational database such as MySQL to manage transactions
    and payments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个社交媒体平台可能会使用文档数据库MongoDB来存储用户资料和活动流，使用图数据库Neo4j来分析社交关系，以及使用关系数据库MySQL来管理交易和支付。
- en: By leveraging multiple databases, polyglot persistence can help improve an application’s
    performance, scalability, and flexibility. However, it also comes with additional
    complexity in managing data consistency, migrations, and backups across multiple
    systems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用多个数据库，多语言持久化可以帮助提高应用程序的性能、可扩展性和灵活性。然而，它也带来了在多个系统之间管理数据一致性、迁移和备份的额外复杂性。
- en: 'The idea of polyglots is always good and provides several opportunities for
    an application. The core idea is sound: taking advantage of a database in the
    perfect scenario is terrific. But, even with polyglot persistence, there are trade-offs,
    as with any software architecture decision.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言的理念总是好的，并为应用程序提供了几个机会。核心思想是合理的：在最佳场景下利用数据库是极好的。但是，即使有多语言持久化，也存在权衡，就像任何软件架构决策一样。
- en: More databases also mean greater cost and infrastructure knowledge to handle
    specific persistence solutions. Please be aware of this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的数据库也意味着更大的成本和基础设施知识来处理特定的持久化解决方案。请留意这一点。
- en: In Java, more databases mean more dependencies in the application, which might
    *add to the jar-hell headache*. The microservices approach will help you in this
    situation, *where each database in your environment has its own interface*; it
    also helps to isolate the technology from the business.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，更多的数据库意味着应用程序中更多的依赖项，这可能会*加剧jar-hell的头痛*。微服务方法将帮助您在这种情况下，*其中您环境中的每个数据库都有自己的接口*；它还有助于将技术从业务中隔离出来。
- en: From a code design perspective, there is the Ports and Adapters pattern, or
    the Hexagonal model, where you can isolate the core logic of an application from
    the persistence layer. However, as mentioned, more layers mean more code overall,
    which means concerns about maintainability and bugs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码设计角度来看，有端口和适配器模式，或者六边形模型，您可以在其中将应用程序的核心逻辑与持久化层隔离开来。然而，正如提到的，更多的层意味着更多的代码，这意味着对可维护性和错误的担忧。
- en: Starting simply with three layers, as in the **Model-View-Controller** (**MVC**)
    architectural pattern, and isolating them is a good start, such as beginning with
    a monolith instead of microservices. When the need arises, go for it and refactor
    the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单的三层开始，如**模型-视图-控制器**（**MVC**）架构模式，并将它们隔离开来是一个良好的开始，例如从单体而不是微服务开始。当需要时，就去做，并重构代码。
- en: Sometimes, we only need some of these layers for our applications; starting
    with enough architecture is an excellent way to manage risk in your architecture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只需要这些层中的某些层来满足我们的应用程序；从足够的架构开始是一个管理架构风险的绝佳方式。
- en: Recognizing the abstraction from/to the business layer and avoiding coupling
    it with the persistence layer as much as possible is crucial to an evolutionary
    architecture.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 识别从/到业务层的抽象，并尽可能避免将其与持久化层耦合，对于进化式架构至关重要。
- en: Common sense and pragmatism are the best formulas to define the best pattern
    for each scenario. As advice, think of software as a long-term project; we don’t
    need to design a sophisticated Netflix-style architecture on the first day.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 常识和实用主义是定义每个场景最佳模式的最佳公式。作为建议，将软件视为一个长期项目；我们不需要在第一天就设计一个复杂的Netflix风格的架构。
- en: 'Based on the best practices, enjoying, taking advantage of, and exploring databases
    to take advantage of your system is possible. In the following figure, based on
    James Serra’s article *What is Polyglot Persistence?* ([https://www.jamesserra.com/archive/2015/07/what-is-polyglot-persistence/](https://www.jamesserra.com/archive/2015/07/what-is-polyglot-persistence/)),
    you can get more context for which database is best suited to or a good candidate
    for a given scenario. It describes what type of database is recommended to address
    recurrent and key requirements of the listed use cases:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基于最佳实践，享受、利用和探索数据库以充分利用您的系统是可能的。在以下图中，基于James Serra的文章《什么是多语言持久性？》([https://www.jamesserra.com/archive/2015/07/what-is-polyglot-persistence/](https://www.jamesserra.com/archive/2015/07/what-is-polyglot-persistence/))，您可以获得更多关于哪种数据库最适合或是一个给定场景的良好候选者的上下文。它描述了推荐使用哪种类型的数据库来满足列出的用例的常见和关键需求：
- en: '![Figure 9.1 – Use cases and database types](img/Figure_9.01_B19375.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 用例和数据库类型](img/Figure_9.01_B19375.jpg)'
- en: Figure 9.1 – Use cases and database types
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 用例和数据库类型
- en: Those are some possibilities of database uses based on the type; when we talk
    about NoSQL, remember that in some classes, there is particular behavior that
    makes sense and is worth using.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基于类型的数据库使用的一些可能性；当我们谈论NoSQL时，请记住，在某些类别中，有一些有意义的特定行为，值得使用。
- en: For long-term applications, migration is possible. The isolation can help you
    in the polyglot journey. The following section will introduce **DDD**, its impacts
    on the persistence layer, and how Jakarta can help us on this journey.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长期应用程序，迁移是可能的。隔离可以帮助您在多语言之旅中。下一节将介绍**DDD**，它对持久化层的影响以及Jakarta如何帮助我们在这段旅程中。
- en: Understanding DDD and Jakarta
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解DDD和Jakarta
- en: DDD is an approach to software development that focuses on understanding the
    problem domain and modeling it in code. DDD is based on the idea that the problem
    domain should be the primary focus of development and that the software should
    be designed to reflect the underlying domain concepts and processes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: DDD是一种软件开发方法，它侧重于理解问题域并在代码中对它进行建模。DDD基于这样的理念，即问题域应该是开发的主要焦点，并且软件应该被设计成反映底层域概念和流程。
- en: DDD distinguishes between strategic and tactical design. Strategic design refers
    to the overall architecture and organization of the software, while tactical design
    refers to the detailed design of individual components and modules.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 区分了战略设计和战术设计。战略设计指的是软件的整体架构和组织，而战术设计指的是单个组件和模块的详细设计。
- en: In strategic design, DDD emphasizes the importance of defining a clear and consistent
    domain model that represents the business concepts and processes in the problem
    domain. This model should be independent of any particular technology or implementation
    and should be based on a deep understanding of the domain. Strategic design also
    involves defining bounded contexts and specific domain areas with well-defined
    boundaries modeled separately from other parts of the domain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在战略设计中，DDD 强调定义一个清晰且一致的领域模型的重要性，该模型代表问题域中的业务概念和流程。此模型应独立于任何特定技术或实现，并基于对领域深入的理解。战略设计还涉及定义边界上下文和具有明确边界的特定领域区域，这些区域与其他领域部分分别建模。
- en: Tactical design, on the other hand, focuses on the details of how individual
    components and modules are designed and implemented. DDD uses patterns and techniques
    such as aggregates, entities, value objects, and repositories to model and manipulate
    the domain objects in the tactical design.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，战术设计专注于单个组件和模块的设计和实现细节。DDD 使用诸如聚合、实体、值对象和存储库等模式和技巧来在战术设计中建模和操作领域对象。
- en: 'DDD can significantly impact the different layers of a software application,
    including the presentation layer, application layer, domain layer, and persistence
    layer. Here’s a brief overview of how DDD can apply to and impact each layer:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 可以显著影响软件应用的各个层次，包括表示层、应用层、领域层和持久层。以下是 DDD 如何应用于并影响每一层的简要概述：
- en: '**The presentation layer**: DDD can impact the presentation layer by providing
    a clear and consistent domain model that can be used to guide the design of user
    interfaces and user interactions. The presentation layer should reflect the domain
    model. It should provide a user-friendly interface that enables users to interact
    with the application in a way that makes sense from a domain perspective.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：DDD 通过提供清晰且一致的领域模型来影响表示层，该模型可用于指导用户界面和用户交互的设计。表示层应反映领域模型。它应提供一个用户友好的界面，使用户能够从领域角度以有意义的方式与应用程序交互。'
- en: '**The application layer**: DDD can impact the application layer by providing
    a clear and consistent set of services and operations that reflects the business
    processes and workflows in the domain. The application layer should be designed
    to support the domain model and should provide a layer of abstraction, which enables
    the domain layer to focus on business logic rather than implementation details.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：DDD 通过提供一组清晰且一致的服务和操作，这些服务和操作反映了领域中的业务流程和工作流，从而影响应用层。应用层的设计应支持领域模型，并提供一层抽象，使领域层能够专注于业务逻辑而不是实现细节。'
- en: '**The domain layer**: DDD has the most significant impact on the domain layer,
    which is the heart of the application. In the domain layer, DDD emphasizes the
    importance of modeling the domain using a rich and expressive language that reflects
    the business concepts and processes. The domain layer should be designed to be
    independent of any specific technology or implementation and focused on encapsulating
    business logic and domain knowledge.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域层**：DDD 对领域层的影响最为显著，领域层是应用的核心。在领域层，DDD 强调使用丰富且表达力强的语言来建模领域的重要性，这种语言反映了业务概念和流程。领域层的设计应独立于任何特定技术或实现，并专注于封装业务逻辑和领域知识。'
- en: '**The persistence layer**: DDD can also impact the persistence layer by providing
    a clear and consistent way of mapping domain objects to the database. DDD emphasizes
    repositories, which provide a layer of abstraction between the domain layer and
    the persistence layer. Repositories enable the domain layer to focus on business
    logic rather than database access and provide a way to ensure that domain objects
    are persisted and retrieved consistently and reliably.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久层**：DDD 还可以通过提供将领域对象映射到数据库的清晰且一致的方式来影响持久层。DDD 强调存储库，它为领域层和持久层之间提供了一层抽象。存储库使领域层能够专注于业务逻辑而不是数据库访问，并提供了一种确保领域对象一致且可靠地持久化和检索的方法。'
- en: Overall, DDD can significantly impact the design and architecture of a software
    application and can help ensure that the application is focused on the problem
    domain rather than implementation details. DDD can help create more maintainable
    and scalable software that is adaptable to changing business requirements by providing
    a clear and consistent domain model and a set of design patterns and techniques.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，领域驱动设计（DDD）可以显著影响软件应用的设计和架构，并有助于确保应用专注于问题域而不是实现细节。DDD可以通过提供清晰和一致的领域模型以及一系列设计模式和技巧，帮助创建更易于维护和可扩展的软件，使其能够适应不断变化的企业需求。
- en: The repository pattern is a design pattern that provides a layer of abstraction
    between the domain layer and the persistence layer. The repository pattern encapsulates
    the logic for accessing and persisting domain objects. It provides a way to ensure
    that domain objects are stored and retrieved consistently and reliably.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式是一种设计模式，它为域层和持久层之间提供了一个抽象层。存储库模式封装了访问和持久化领域对象的逻辑。它提供了一种确保领域对象一致和可靠地存储和检索的方法。
- en: Using repositories, the domain layer can be designed to be independent of the
    persistence layer. It can be focused on modeling business processes and workflows
    using rich and expressive language. The repository pattern can significantly impact
    the persistence layer by enabling the domain layer to focus on business logic
    and domain knowledge rather than implementation details such as database access
    and querying.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储库，域层可以被设计成独立于持久层。它可以专注于使用丰富和表达性强的语言来建模业务流程和工作流。存储库模式可以通过使域层专注于业务逻辑和领域知识，而不是数据库访问和查询等实现细节，从而对持久层产生重大影响。
- en: The repository pattern is typically implemented as an interface in the domain
    layer, with a concrete implementation in the persistence layer. The repository
    interface defines a set of methods for storing, retrieving, and querying domain
    objects. The concrete implementation provides the actual implementation of these
    methods using the persistence technology of choice (such as a relational or NoSQL
    database).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式通常在域层实现为一个接口，在持久层有一个具体的实现。存储库接口定义了一组用于存储、检索和查询领域对象的方法。具体的实现提供了使用所选持久化技术（如关系型或NoSQL数据库）的实际方法实现。
- en: One of the key benefits of the repository pattern is that it enables the domain
    layer to be decoupled from the persistence layer, making the application more
    modular and easier to maintain. By separating concerns and encapsulating logic,
    the repository pattern can ensure that the application is more flexible and adaptable
    to changing requirements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式的一个关键好处是它使域层能够与持久层解耦，使应用更加模块化且易于维护。通过分离关注点和封装逻辑，存储库模式可以确保应用更加灵活且能够适应不断变化的需求。
- en: The repository pattern is often compared to the **Data Access Object** (**DAO**)
    pattern, another design pattern for accessing and persisting data. The main difference
    between a repository and a DAO is a repository is designed to encapsulate the
    logic for accessing and persisting domain objects. In contrast, a DAO is designed
    to encapsulate general logic for accessing and persisting data. The following
    figure shows the sequence starting from the controller to the database and returning
    to the controller.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式通常与**数据访问对象**（**DAO**）模式相比较，这是另一种用于访问和持久化数据的模式。存储库与DAO之间的主要区别在于，存储库被设计用来封装访问和持久化领域对象的逻辑。相比之下，DAO被设计用来封装访问和持久化数据的通用逻辑。以下图显示了从控制器开始到数据库，然后返回控制器的序列。
- en: '![Figure 9.2 – Sequence from the controller to the database](img/Figure_9.02_B19375.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 控制器到数据库的序列](img/Figure_9.02_B19375.jpg)'
- en: Figure 9.2 – Sequence from the controller to the database
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 控制器到数据库的序列
- en: In other words, a DAO is typically focused on low-level details, such as database
    connections, transactions, and SQL statements. In contrast, a repository focuses
    on the domain model’s higher-level concerns. While both patterns can be used for
    persistence, the repository pattern is often considered more aligned with the
    principles of DDD, as it provides a way to ensure that the persistence layer is
    designed to support the domain model and business logic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，DAO通常关注底层细节，如数据库连接、事务和SQL语句。相比之下，仓库关注领域模型的更高层次关注点。虽然这两种模式都可以用于持久化，但仓库模式通常被认为更符合DDD的原则，因为它提供了一种确保持久化层设计以支持领域模型和业务逻辑的方法。
- en: Where does the data come from? We don’t need to know the source of the database,
    whether it comes from SQL, NoSQL, or a web service. The client does need to know.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据从哪里来？我们不需要知道数据库的来源，无论是来自SQL、NoSQL还是Web服务。客户端需要知道。
- en: The following figure shows this idea, where we have the business layer injecting
    a persistence layer, and it does matter where the data source comes from; it might
    be coming from all of the sources simultaneously.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这个想法，其中我们有一个业务层注入持久化层，并且数据源来自哪里很重要；它可能来自所有这些来源同时。
- en: '![Figure 9.3 – A DDD repository representation](img/Figure_9.03_B19375.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – DDD仓库表示](img/Figure_9.03_B19375.jpg)'
- en: Figure 9.3 – A DDD repository representation
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – DDD仓库表示
- en: Let’s see some code to explore the capabilities of Jakarta Data in the first
    version that released the repository feature. As with MicroStream, we’ll start
    with Java SE and then move the application to Jakarta EE. We’ll create two CRUD
    operations using both the `Developer` and `Airplane` entities, where the second
    will handle simple pagination code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码，以探索Jakarta Data在发布仓库功能的第一个版本中的功能。与MicroStream一样，我们将从Java SE开始，然后将应用程序迁移到Jakarta
    EE。我们将使用`Developer`和`Airplane`实体创建两个CRUD操作，其中第二个将处理简单的分页代码。
- en: Jakarta Data
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta Data
- en: Designing an application with multiple database systems is one of the hardest
    things to do in the software world. Fortunately, there is a specification that
    makes it easier to implement polyglot persistence in Java. It is a persistence-agnostic
    API that connects to different types of databases and storage sources seamlessly.
    The API offered by Jakarta Data enables convenient access to data technologies,
    making it possible for Java developers to divide their persistence and model concerns
    into distinct features. For instance, a repository interface can be created with
    a query method that the framework will implement.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件世界中，设计一个具有多个数据库系统的应用程序是其中最难的事情之一。幸运的是，有一个规范使得在Java中实现多语言持久化变得更加容易。这是一个持久化无关的API，可以无缝连接到不同类型的数据库和存储源。Jakarta
    Data提供的API使得方便访问数据技术成为可能，使得Java开发者能够将持久化和模型关注点划分为不同的特性。例如，可以创建一个具有查询方法的仓库接口，该接口将由框架实现。
- en: Exploring agnostic design patterns is one of the goals of Jakarta Data; the
    first feature of this specification is the DDD repository pattern. The objective
    of the repository is to facilitate polyglot persistence without impacting the
    business.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 探索无知的（agnostic）设计模式是Jakarta Data的目标之一；本规范的第一个特性是DDD仓库模式。仓库的目标是便于多语言持久化而不影响业务。
- en: 'Starting with dependencies, from now on, we’ll add only the API; then, we’ll
    start to explain the implementations. So, we’ll include the Jakarta Data dependency:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从依赖关系开始，从现在起，我们只会添加API；然后，我们将开始解释实现。所以，我们将包含Jakarta Data依赖项：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will create both the `Developer` and `Airline` entities. In the Jakarta
    Data API, we must define the entity and its IDs using `@Entity` and `@Id`, respectively.
    Hey, how about adding other fields? It varies with the implementation; for example,
    in JPA, this is enough, whereas in Jakarta NoSQL, we need to identify the other
    fields with the `@``Column` annotation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`Developer`和`Airline`实体。在Jakarta Data API中，我们必须使用`@Entity`和`@Id`分别定义实体及其ID。嘿，要不要添加其他字段？这取决于实现方式；例如，在JPA中，这已经足够了，而在Jakarta
    NoSQL中，我们需要使用`@Column`注解来标识其他字段：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have the entities; the next step is the persistence layer with a repository.
    Once we have two different entities, we’ll create two separate repositories.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了实体；下一步是使用仓库的持久化层。一旦我们有两个不同的实体，我们将创建两个独立的仓库。
- en: 'This interface provides several methods the user doesn’t need to implement;
    the vendor will implement them. The first one relates to the `Developer` entity
    and uses the most basic repository: `CrudDataRepository`. Furthermore, there is
    the method that uses querying, where you can, using the convention, create queries
    that you don’t need to implement; the vendor will implement them.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口提供了用户不需要实现的方法；供应商将实现它们。第一个与 `Developer` 实体相关，并使用最基本的仓库：`CrudDataRepository`。此外，还有一个使用查询的方法，你可以使用约定创建不需要实现查询；供应商将实现它们。
- en: '`DeveloperRepository` is the Developer repository, an interface that extends
    `CrudDataRepository`. Now we will go through several methods; furthermore, we
    will create a query to find by language using the `findByLanguage` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeveloperRepository` 是开发者仓库，一个扩展了 `CrudDataRepository` 的接口。现在我们将介绍几个方法；此外，我们将创建一个查询，使用
    `findByLanguage` 方法按语言查找：'
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next step is the `Airplane` repository, so we have our `Hangar`, but wait!?
    Should it be `AirplaneRepository` instead? We have a convention of using the `Repository`
    suffix. However, you can use the collection of the entity, such as `Garage` for
    a collection of cars or `Team` for a collection of players.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是 `Airplane` 仓库，所以我们有了我们的 `Hangar`，但是等等！它应该是 `AirplaneRepository` 吗？我们有一个使用
    `Repository` 后缀的约定。然而，你可以使用实体的集合，例如 `Garage` 用于汽车集合或 `Team` 用于球员集合。
- en: 'The `Hangar` interface extends a different interface, this time, `PageableRepository`.
    It is a specialization that enables pagination resources. It uses the query method
    and returns a `Page` interface to work with a slice of information on airplanes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hangar` 接口扩展了不同的接口，这次是 `PageableRepository`。这是一个专门化的接口，它使得分页资源成为可能。它使用查询方法，并返回一个
    `Page` 接口来处理飞机信息的一小部分：'
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we have both code repositories ready for execution. Starting with
    the `Developer` repository, we’ll create developers, find them by ID, delete them
    by ID, and use the method we made, which is querying by language:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有两个代码仓库都准备好了执行。从 `Developer` 仓库开始，我们将创建开发者，通过 ID 查找他们，通过 ID 删除他们，并使用我们创建的方法，即按语言查询：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to execute the pagination resource with pagination in our
    Hangar. Once we have a few airplanes added, we’ll include pagination with a size
    of two elements. In the real world, the number is more considerable. It will vary
    based on the area and context; it is often between 10 and 100:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在我们的 Hangar 中执行分页资源，并使用分页。一旦我们添加了几架飞机，我们将包含大小为两个元素的分页。在现实世界中，这个数字更为可观。它将根据区域和上下文而变化；通常在
    10 到 100 之间：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have both running on Java SE; let’s move on to the next stage, which is
    pushing the same code to `MicroProfile` to create a microservice. In the chapter
    about `MicroStream` in [*Chapter 8*](B19375_08.xhtml#_idTextAnchor151), we explained
    the CDI engine/core; we’ll follow the same principle – copy/paste the same code
    and change the access to make it a rest resource instead of a Java SE application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都在 Java SE 上运行；让我们继续到下一个阶段，即将相同的代码推送到 `MicroProfile` 以创建一个微服务。在第 8 章[*第 8
    章*](B19375_08.xhtml#_idTextAnchor151)中，我们解释了 CDI 引擎/核心；我们将遵循相同的原理——复制/粘贴相同的代码，并更改访问权限，使其成为一个
    REST 资源而不是 Java SE 应用程序：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We showed the pure API, but how about the implementations? To display the number
    of options, we have a repository that illustrates an implementation of the particular
    behavior to each example in our `git` remote. You can try out, run, and get a
    feel for the difference between vendors and persistence solutions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了纯 API，但关于实现呢？为了展示选项的数量，我们有一个仓库，它展示了在我们的 `git` 远程中对每个示例的特定行为的实现。你可以尝试，运行，并感受供应商和持久化解决方案之间的差异。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Polyglot persistence is a good path to advance most enterprise applications.
    It is possible to explore SQL, NoSQL, or any persistence solution with this approach.
    However, as with any architectural decision, pay attention to the trade-offs;
    an abstraction can ensure that the choice of database will not impact the business
    perspective.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言持久化是大多数企业应用进步的好路径。使用这种方法，可以探索 SQL、NoSQL 或任何持久化解决方案。然而，与任何架构决策一样，要注意权衡；一个抽象可以确保数据库的选择不会影响业务视角。
- en: Jakarta Data helps standardize behavior and code patterns. It helps us build
    a universe of capabilities out of several persistence solutions. It is promising
    solution to increase the capabilities around data persistence patterns on Java,
    and it is open for help and feedback; join us to make our lives even easier when
    working with this tool.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 雅加达数据（Jakarta Data）有助于标准化行为和代码模式。它帮助我们利用多种持久化解决方案构建一个功能宇宙。它是提高Java数据持久化模式能力的一个有前景的解决方案，并且欢迎帮助和反馈；加入我们，让使用这个工具的工作生活变得更加便捷。
- en: It’s now time to explore, at an architectural level, the integration practices
    that allow us to explore the best out-of-data integration patterns in modern cloud-oriented
    solutions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在架构层面探索那些允许我们探索现代云导向解决方案中最佳数据集成模式的集成实践了。
