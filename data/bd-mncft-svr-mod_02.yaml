- en: Chapter 2. Learning the Bukkit API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：学习Bukkit API
- en: 'In this chapter, you will be introduced to the **Bukkit** **API** and learn
    what it allows you to accomplish through programming plugins for a Spigot server.
    By the end of the chapter, you will most likely have numerous ideas for plugins
    that you will eventually be able to create yourself. This chapter will cover the
    following topics in detail:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解**Bukkit** **API**，并学习通过为Spigot服务器编写插件编程可以完成什么。到本章结束时，您可能会有很多关于插件的想法，您最终将能够自己创建它们。本章将详细介绍以下主题：
- en: Understanding the purpose of an API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解API的目的
- en: Finding the documentation of the Bukkit API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找Bukkit API的文档
- en: Navigating through Javadocs to find specific information
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Javadocs中导航以查找特定信息
- en: Reading and understanding the documentation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读和理解文档
- en: Exploring and learning the features of the Bukkit API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和学习Bukkit API的功能
- en: Introduction to APIs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API简介
- en: '**API** stands for **Application Programming Interface**. An API helps control
    how various software components are used. As mentioned in the previous chapter,
    Spigot includes the Minecraft code in a form that is easy for developers to utilize
    when creating plugins. Spigot has a lot of code that we need not access in order
    to create plugins. It also includes code that we should not tamper with, as it
    may cause the server to become unstable. Bukkit provides us with the interfaces
    that we can use to properly modify the game while restricting access to other
    portions of the code. An **interface** is essentially a shell of a class. It includes
    methods, but the methods are empty. The Spigot server contains classes for each
    interface. The classes implement the interfaces and fill each method with the
    appropriate code.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**代表**应用程序编程接口**。API帮助控制各种软件组件的使用方式。正如前一章所述，Spigot将Minecraft代码以开发者易于利用的形式包含在内，以便在创建插件时使用。Spigot包含大量我们不需要访问的代码，以便创建插件。它还包括我们不应篡改的代码，因为这可能会导致服务器变得不稳定。Bukkit为我们提供了可以用来正确修改游戏并限制对代码其他部分的访问的接口。**接口**本质上是一个类的壳。它包括方法，但方法是空的。Spigot服务器包含每个接口的类。这些类实现了接口，并用适当的代码填充每个方法。'
- en: To explain this better, let's imagine the Bukkit API as a menu to a pizza shop.
    The menu contains different types of pizza, such as pepperoni, Hawaiian, and meat
    lovers. These menu items represent the interfaces within the API, with each interface
    having a method named `makePizza`. At this point, these pizzas cannot be eaten,
    because they are merely a concept. They are just items on a menu. But let's say
    that a pizza shop named *All You Need is Pizza* decides to open up and they use
    this menu, or API. This pizza shop can represent CraftBukkit. The pizza shop creates
    recipes for each item on the menu. This is equivalent to writing code for each
    `makePizza` method within the three interfaces. Thus, these recipes are the classes
    that implement the interfaces. However, these classes are still just a concept.
    It is not until the `makePizza` method is called that you have an instance of
    that class. This instance, or object, will be the tangible pizza that you can
    actually eat. Now, imagine that there is another pizza shop named *Crazy Little
    Thing Called Pizza*, which opens across the street from *All You Need is Pizza*.
    This new pizza shop will represent Spigot. Crazy Little Thing Called Pizza uses
    the exact same menu, or API, as All You Need is Pizza. However, its recipes, or
    implementations of the methods, may be different.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这一点，让我们想象Bukkit API就像一家披萨店的菜单。菜单包含不同类型的披萨，如意大利辣肠披萨、夏威夷披萨和肉食爱好者披萨。这些菜单项代表API中的接口，每个接口都有一个名为`makePizza`的方法。在这个阶段，这些披萨不能吃，因为它们只是一个概念。它们只是菜单上的项目。但假设一家名为“所有你需要的是披萨”的披萨店决定开业，并使用这个菜单或API。这家披萨店可以代表CraftBukkit。披萨店为菜单上的每个项目创建食谱。这相当于为三个接口中的每个`makePizza`方法编写代码。因此，这些食谱是实现接口的类。然而，这些类仍然只是一个概念。只有在调用`makePizza`方法时，您才有这个类的实例。这个实例，或对象，将是您可以真正食用的有形披萨。现在，想象另一家名为“疯狂的小东西叫披萨”的披萨店在“所有你需要的是披萨”的对面开业。这家新披萨店将代表Spigot。“疯狂的小东西叫披萨”使用与“所有你需要的是披萨”完全相同的菜单或API。然而，它的食谱，或方法的实现，可能不同。
- en: 'Using this same analogy, we can see the benefit of the API. As a customer,
    I can take a look at the menu and assemble an order. For example, I want to order
    a pepperoni pizza and a meat lovers pizza. Since I created my order based on the
    menu and both pizza shops implemented the same menu, either restaurant is able
    to fulfill my order. Likewise, a developer creates a plugin based on the Bukkit
    API. Both **CraftBukkit** and **Spigot** utilize the **Bukkit API**. Therefore,
    they will both support the plugin. The following diagram explains this relation
    between pizza and code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个相同的类比，我们可以看到 API 的好处。作为一个客户，我可以查看菜单并组装一个订单。例如，我想点一个辣味披萨和一个肉食爱好者披萨。由于我的订单是基于菜单，并且两家披萨店都实施了相同的菜单，所以任何一家餐厅都能满足我的订单。同样，开发者基于
    Bukkit API 创建插件。**CraftBukkit** 和 **Spigot** 都使用 **Bukkit API**。因此，它们都将支持该插件。以下图表解释了披萨和代码之间的这种关系：
- en: '![Introduction to APIs](img/00011.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![API 简介](img/00011.jpeg)'
- en: Basically, Bukkit acts as a bridge between a plugin and the Spigot server. The
    Spigot team adds new classes, methods, and so on to the API as new features develop
    in Minecraft, but the preexisting code rarely changes. This ensures that Bukkit
    plugins will still function correctly months, or even years, from now even though
    new versions of Minecraft/Spigot are released. For example, if Minecraft were
    to change how an entity's health is handled, we would not see any difference.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Bukkit 在插件和 Spigot 服务器之间充当桥梁。随着 Minecraft 中新功能的开发，Spigot 团队会向 API 中添加新的类、方法等，但现有的代码很少改变。这确保了即使
    Minecraft/Spigot 发布了新版本，Bukkit 插件仍然可以正确运行数月甚至数年。例如，如果 Minecraft 改变了实体生命值处理的方式，我们不会看到任何差异。
- en: The Spigot jar will account for this change by filling the `getHeath` method
    with the updated code. Then, when the plugin calls the `getHealth` method, it
    will function exactly as it had before the update. The addition of new Minecraft
    features, such as new items, is another example of how great the Bukkit API is.
    Let's say that we've created a plugin that gives food an expiration date. To check
    whether an item is food, we'll use the `isEdible` method. Minecraft continues
    to create new items. If one of these new items is **Pumpkin Bread**, Spigot will
    flag that type of item as edible and will therefore be given an expiration date
    by our plugin. A year from now, new food items will still be given expiration
    dates without us needing to change any of our code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Spigot jar 会通过将更新后的代码填充到 `getHeath` 方法中来处理这种变化。然后，当插件调用 `getHealth` 方法时，它将像更新前一样正常工作。新
    Minecraft 功能（如新物品）的添加是 Bukkit API 优秀的另一个例子。假设我们创建了一个给食物添加保质期的插件。要检查一个物品是否是食物，我们将使用
    `isEdible` 方法。Minecraft 继续创建新物品。如果这些新物品中有一个是 **南瓜面包**，Spigot 将将该类型物品标记为可食用，因此我们的插件将为其设置保质期。一年后，即使我们不需要更改任何代码，新的食物物品仍然会被赋予保质期。
- en: The Bukkit API documentation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bukkit API 文档
- en: Documentation of the Bukkit API can be found at [hub.spigotmc.org/javadocs/bukkit/](http://hub.spigotmc.org/javadocs/bukkit/).
    The Bukkit.jar file that you built in [Chapter 1](part0014_split_000.html#DB7S1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 1. Deploying a Spigot Server"), *Deploying a Spigot Server* also contains
    the Spigot API, which can be found at [hub.spigotmc.org/javadocs/spigot/](http://hub.spigotmc.org/javadocs/spigot/).
    The Spigot API is a **superset** of the Bukkit API, which means that it contains
    all the classes, interfaces, and so on that are present in the Bukkit API, as
    well as some additional classes that are unique to the Spigot project. If you
    want your plugin to support Spigot and CraftBukkit servers, then you will want
    to develop by using the Bukkit API. If you choose to only support Spigot servers,
    then you can develop using the Spigot API. In this book, we will refer to the
    Bukkit API. However, using the Spigot API will yield the same results.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Bukkit API 的文档可以在 [hub.spigotmc.org/javadocs/bukkit/](http://hub.spigotmc.org/javadocs/bukkit/)
    找到。你在 [第 1 章](part0014_split_000.html#DB7S1-b66e70deee6e4ed481db4b113e303f23 "第
    1 章。部署 Spigot 服务器") 中构建的 Bukkit.jar 文件，*部署 Spigot 服务器* 也包含了 Spigot API，可以在 [hub.spigotmc.org/javadocs/spigot/](http://hub.spigotmc.org/javadocs/spigot/)
    找到。Spigot API 是 Bukkit API 的 **超集**，这意味着它包含了在 Bukkit API 中存在的所有类、接口等，以及一些仅属于 Spigot
    项目的独特类。如果你想你的插件支持 Spigot 和 CraftBukkit 服务器，那么你将希望使用 Bukkit API 进行开发。如果你选择只支持 Spigot
    服务器，那么你可以使用 Spigot API 进行开发。在这本书中，我们将参考 Bukkit API。然而，使用 Spigot API 将产生相同的结果。
- en: Navigating through the Bukkit API documentation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Bukkit API 文档中导航
- en: We can go through the Bukkit API documentation to get a general idea of what
    we can modify on a Spigot server. Server-side plugins are different from client-side
    mods in that we are limited with what we are able to modify in the game using
    server-side plugins. For example, we cannot create a new type of block, but we
    can make lava blocks rain from the sky. We cannot make zombies look and sound
    like dinosaurs, but we can put a zombie on a leash, change its name to Fido, and
    have it not burn in the daylight. For the most part, you cannot change the visual
    aspect of the game, but you can change how it functions. This ensures that everyone
    who connects to the server with a standard Minecraft client will have the same
    experience.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过Bukkit API文档来了解我们可以在Spigot服务器上修改什么。服务器端插件与客户端模组不同，因为我们使用服务器端插件在游戏中修改的能力有限。例如，我们无法创建新的方块类型，但我们可以让熔岩方块从天空中落下。我们无法让僵尸看起来和听起来像恐龙，但我们可以给僵尸套上绳索，将其名字改为Fido，并让它不在白天燃烧。大部分情况下，你无法改变游戏的外观，但你可以在功能上做出改变。这确保了所有使用标准Minecraft客户端连接到服务器的玩家都将有相同的体验。
- en: 'For some more examples on what we can do, let''s have a look at the various
    pages of the API''s documentation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解更多我们可以做什么的例子，让我们看看API文档的各个页面：
- en: '![Navigating through the Bukkit API documentation](img/00012.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![通过Bukkit API文档导航](img/00012.jpeg)'
- en: You will see that the classes and interfaces within the API are selectable in
    the lower left section of the **Javadoc**. Selecting a package in the upper left
    narrows the choices in the section below it. Each type, such as a class or interface,
    is organized into a package. These packages help group similar classes together.
    For example, `Cow`, `Player`, and `Zombie` are all types of entities and thus
    can be found in the `org.bukkit.entity` package. So, if I were to say that the
    `World` interface can be found at `org.bukkit.World`, then you will know that
    you can find `World` within the `org.bukkit` package. Knowing this will help you
    find the classes or interfaces that you are looking for. You can always use *Ctrl
    + F* to search for a specific word on the webpage. This can help in finding a
    specific class in a long list.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到API中的类和接口在**Javadoc**的左下角是可选的。在左上角选择一个包将缩小下面部分的选项。每种类型，如类或接口，都组织在一个包中。这些包有助于将类似的类分组在一起。例如，`Cow`、`Player`和`Zombie`都是实体类型，因此可以在`org.bukkit.entity`包中找到。所以，如果我说`World`接口可以在`org.bukkit.World`找到，那么你就会知道你可以在`org.bukkit`包中找到`World`。了解这一点将帮助你找到你正在寻找的类或接口。你始终可以使用*Ctrl
    + F*在网页上搜索特定的单词。这有助于在长列表中找到特定的类。
- en: 'Let''s look at the `World` class and see what it has to offer. The classes
    are listed in alphabetical order. So, we will find **World** near the end of the
    list within the `org.bukkit` package. When you click on the `World` class link,
    all of its methods will be displayed in the main column of the site under the
    **Method Summary** header, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`World`类，看看它有哪些功能。类按字母顺序列出。因此，我们将在`org.bukkit`包的末尾找到**World**类。当你点击`World`类的链接时，所有的方法将在网站主列中的**方法摘要**标题下显示，如下面的截图所示：
- en: '![Navigating through the Bukkit API documentation](img/00013.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![通过Bukkit API文档导航](img/00013.jpeg)'
- en: A `World` object is an entire world on your server. By default, a Minecraft
    server has multiple worlds, including the main world, nether world, and end world.
    Spigot even allows you to add additional worlds. The methods that are listed in
    the `World` class can be applied to the specific world object. For example, the
    `Bukkit.getWorlds` method will give you a list of all the worlds that are on the
    server; each one is unique. Therefore, if you call the `getName` method on the
    first world, it may return `world` while, calling the same method on the second
    world may return `world_nether`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`World`对象是服务器上的整个世界。默认情况下，Minecraft服务器有多个世界，包括主世界、下界世界和末地世界。Spigot甚至允许你添加额外的世界。`World`类中列出的方法可以应用于特定的世界对象。例如，`Bukkit.getWorlds`方法将给你一个服务器上所有世界的列表；每个都是唯一的。因此，如果你在第一个世界上调用的`getName`方法可能返回`world`，而在第二个世界上调用的相同方法可能返回`world_nether`。'
- en: Understanding the Java documentation
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java文档
- en: 'Let''s look at a method that is included in the `World` class to see what information
    it provides us. Click on the link to view the `createExplosion(Location loc, float
    power, boolean setFire)` method. You will be brought to a method description that
    is similar to the one shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `World` 类中包含的一个方法，看看它提供了哪些信息。点击链接查看 `createExplosion(Location loc, float
    power, boolean setFire)` 方法。你将被带到与以下截图类似的方法描述：
- en: '![Understanding the Java documentation](img/00014.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Java 文档](img/00014.jpeg)'
- en: 'The screenshot explains each parameter and the return value for the method.
    This method requires that we pass three parameters to it, which is explained as
    follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 截图解释了该方法每个参数和返回值。此方法需要我们传递三个参数，具体解释如下：
- en: Where the explosion should take place
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爆炸应该发生的位置
- en: How powerful the explosion should be
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爆炸应该有多强大
- en: Whether the explosion should cause the surrounding blocks to ignite in flames
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否爆炸应该导致周围的方块着火
- en: If the returned value is `void`, then the method will not send any information
    back to us. In this example, the method returns a `boolean` value. On reading
    the documentation, you will learn that the returned value is whether or not the
    explosion actually occurred. If another plugin prevented the explosion from happening,
    then the `createExplosion` method will return `false`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回值是 `void`，则该方法不会向我们发送任何信息。在这个例子中，该方法返回一个 `boolean` 值。在阅读文档时，你会了解到返回值表示爆炸是否实际发生。如果另一个插件阻止了爆炸的发生，那么
    `createExplosion` 方法将返回 `false`。
- en: Exploring the Bukkit API
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Bukkit API
- en: 'Now that you are familiar with the Bukkit API documentation, I advise you to
    look through it on your own. You will find interesting methods; many of these
    methods will spark ideas for cool plugins that you may want to make. Note that
    there may be additional links to view more methods for an object. For example,
    a `Player` is a type of **LivingEntity**. Therefore, you can call a **LivingEntity**
    method on a `Player` object. This inheritance is shown after the method summary,
    as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 Bukkit API 文档，我建议你自己浏览一下。你会发现有趣的方法；其中许多方法会激发你制作酷炫插件的灵感。请注意，可能会有额外的链接查看该对象的其他方法。例如，`Player`
    是 `**LivingEntity**` 类型的一种。因此，你可以在 `Player` 对象上调用 `**LivingEntity**` 方法。这种继承关系在方法摘要之后显示，如下面的截图所示：
- en: '![Exploring the Bukkit API](img/00015.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![探索 Bukkit API](img/00015.jpeg)'
- en: 'If you are ever going to try and think up an idea for a plugin, browsing through
    the API documentation will surely give you some ideas. I suggest reading the class
    pages, listed as follows, as they will be the classes that you will frequently
    use in your future plugins:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算尝试想出一个插件的想法，浏览 API 文档肯定会给你一些灵感。我建议阅读以下列出的类页面，因为它们将是你在未来插件中经常使用的类：
- en: '| Class | Package | Description |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 包 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `World` | `org.bukkit` | A world on the server |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `World` | `org.bukkit` | 服务器上的一个世界 |'
- en: '| `Player` | `org.bukkit.entity` | A person who is playing on the server |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Player` | `org.bukkit.entity` | 在服务器上玩的人 |'
- en: '| `Entity` | `org.bukkit.entity` | A player, mob, item, projectile, vehicle,
    and so on |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Entity` | `org.bukkit.entity` | 玩家、怪物、物品、投射物、车辆等 |'
- en: '| `Block` | `org.bukkit.block` | A specific block in the world, such as a dirt
    block or a chest |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Block` | `org.bukkit.block` | 世界中的特定块，例如泥土块或箱子 |'
- en: '| `Inventory` | `org.bukkit.inventory` | The inventory of a player, chest,
    furnace, and so on |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `Inventory` | `org.bukkit.inventory` | 玩家、箱子、熔炉等的库存 |'
- en: '| `ItemStack` | `org.bukkit.inventory` | An item that is in an inventory, which
    includes how many items are present |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `ItemStack` | `org.bukkit.inventory` | 存储在库存中的物品，包括物品的数量 |'
- en: '| `Location` | `org.bukkit` | The location of an entity or a block |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `Location` | `org.bukkit` | 实体或方块的位置 |'
- en: '| `Material` | `org.bukkit` | The type of a block or item, such as `DIRT`,
    `STONE`, or `DIAMOND_SWORD` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `Material` | `org.bukkit` | 块或物品的类型，例如 `DIRT`、`STONE` 或 `DIAMOND_SWORD` |'
- en: '| `Bukkit` | `org.bukkit` | Contains many useful methods that can be called
    from anywhere in your code |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `Bukkit` | `org.bukkit` | 包含许多可以在代码的任何地方调用的有用方法 |'
- en: Now that you understand how to read the Bukkit Java documentation, you can find
    answers to the various questions that you may have. For example, what if you want
    to find out which methods you would call to get the Block that is at `x:20 y:64
    z:14` in the world that is named "world"?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何阅读Bukkit Java文档，你可以找到你可能有的各种问题的答案。例如，如果你想找出调用哪些方法来获取名为"world"的世界中`x:20
    y:64 z:14`位置的Block，你会怎么做？
- en: First, you will need to retrieve the correct `World` object. The initial place
    that you may check is the Bukkit class, as listed in the previous table. You may
    check there because you can call these methods from anywhere in your code. Another
    option is to view the uses of the `World` class. This can be done by clicking
    on the **Use** link at the top of the **World** page. There, you can see all the
    methods that return a `World` object as well as methods that accept a `World`
    object as a parameter. To aid in searching through a page, remember that you can
    use *Ctrl + F*. Searching for *name* will lead you to the `Bukkit.getWorld` method,
    which takes the name of the world as a parameter and returns the actual `World`
    object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要检索正确的`World`对象。你可能检查的第一个地方是Bukkit类，如前表所示。你可以检查那里，因为你可以从你的代码的任何地方调用这些方法。另一个选项是查看`World`类的使用情况。这可以通过点击**World**页面顶部的**Use**链接来完成。在那里，你可以看到所有返回`World`对象的方法以及接受`World`对象作为参数的方法。为了帮助你在页面上搜索，请记住你可以使用*Ctrl
    + F*。搜索*name*将带你到`Bukkit.getWorld`方法，该方法接受世界的名称作为参数并返回实际的`World`对象。
- en: Once you have the `World` object, you will want to find a method that will give
    you the `Block` at a specific location. You could navigate to the World page and
    use *Ctrl + F* to search for *block*, *location*, *x*, *y*, or *z*. If none of
    these help you find a useful method, then you can always view the uses of Block
    in a way that is similar to how we viewed the uses of World. Either way, you will
    find the `World.getBlockAt` method, which can be called on the `World` object
    that you discovered in the previous step.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了`World`对象，你将想要找到一个方法来获取特定位置的`Block`。你可以导航到世界页面，并使用*Ctrl + F*来搜索*block*、*location*、*x*、*y*或*z*。如果这些都没有帮助你找到有用的方法，那么你总是可以以类似于我们查看World使用方式的方式来查看Block的使用。无论如何，你都会找到`World.getBlockAt`方法，这个方法可以在你上一步发现的`World`对象上调用。
- en: 'The following are a few additional challenges to guide you while exploring
    the Bukkit API on your own and becoming familiar with it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些额外的挑战，以指导你在自己探索Bukkit API并熟悉它时：
- en: Which method would you call to check what time it is in a world?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会调用哪个方法来检查一个世界中的时间是什么时候？
- en: Which methods would you call to send a message to the player whose name is Steve?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会调用哪些方法来向名为Steve的玩家发送消息？
- en: Which methods would you call to check whether the material of a block is flammable?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会调用哪些方法来检查一个块的材质是否可燃？
- en: Which method would you call to check whether a player has diamonds in their
    inventory?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会调用哪个方法来检查玩家是否在他们的库存中有钻石？
- en: Which methods would you call to check whether a player is holding an item that
    is edible?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会调用哪些方法来检查玩家是否持有可食用的物品？
- en: Summary
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you have any trouble figuring out any of the problems mentioned in the challenges
    or with any other portion of the Bukkit API you can ask help from the Spigot forums
    ([www.spigotmc.org/forums](http://www.spigotmc.org/forums)), the official IRC
    channel for Spigot ([www.spigotmc.org/pages/irc](http://www.spigotmc.org/pages/irc)),
    and the Minecraft forums ([www.minecraftforum.net](http://www.minecraftforum.net)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在解决挑战中提到的任何问题或Bukkit API的任何其他部分遇到困难，你可以从Spigot论坛([www.spigotmc.org/forums](http://www.spigotmc.org/forums))、Spigot的官方IRC频道([www.spigotmc.org/pages/irc](http://www.spigotmc.org/pages/irc))和Minecraft论坛([www.minecraftforum.net](http://www.minecraftforum.net))寻求帮助。
- en: You can also contact me directly or visit my website at [www.codisimus.com](http://www.codisimus.com).
    I am always interested in helping out a fellow developer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接联系我或访问我的网站[www.codisimus.com](http://www.codisimus.com)。我总是乐于帮助其他开发者。
- en: You now have the knowledge required to begin programming your own Bukkit plugins.
    As we did in this chapter, we will have to refer to the documentation to find
    the required information. Being able to navigate and understand the API documentation
    will speed up the process of coding. If you are ever unsure of a section of the
    API, you now know how to find the information that you need. In the next chapter,
    we'll use the Bukkit API to begin writing code to create your first Bukkit plugin.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有了开始编写自己的Bukkit插件所需的知识。正如我们在本章中所做的那样，我们将不得不参考文档来查找所需的信息。能够导航并理解API文档将加快编码过程。如果你对API的某个部分感到不确定，你现在知道如何找到你需要的信息。在下一章中，我们将使用Bukkit
    API来开始编写代码，创建你的第一个Bukkit插件。
