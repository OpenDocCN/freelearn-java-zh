- en: Chapter 7. JSF and AJAX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：JSF 和 AJAX
- en: JSF and AJAX have been a great team for a long time. The potential of this combination
    has been heavily exploited by many JSF extensions (Ajax4Jsf, OmniFaces, PrimeFaces,
    RichFaces, ICEfaces, and so on) that provide many AJAX built-in components, extend
    AJAX default capabilities, increase AJAX security and reliability, and add more
    control to developers who need to manipulate the *bowels* of AJAX mechanism.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 和 AJAX 已经是长期以来的优秀搭档。这种组合的潜力被许多 JSF 扩展（Ajax4Jsf、OmniFaces、PrimeFaces、RichFaces、ICEfaces
    等）充分利用，它们提供了许多 AJAX 内置组件，扩展了 AJAX 默认功能，增加了 AJAX 的安全性和可靠性，并为需要操作 AJAX 机制“内部”的开发者提供了更多控制。
- en: 'By default, JSF contains a JavaScript library that encapsulates AJAX methods
    for dealing with AJAX requests or responses. This library can be loaded in the
    following two ways:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JSF 包含一个 JavaScript 库，该库封装了处理 AJAX 请求或响应的 AJAX 方法。此库可以通过以下两种方式加载：
- en: Using the `<f:ajax>` tag, the built-in AJAX library is loaded implicitly.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `<f:ajax>` 标签，隐式加载内置 AJAX 库。
- en: Using `jsf.ajax.request()`, the AJAX library is loaded explicitly and developers
    have access to AJAX code. This approach is commonly used when the default AJAX
    behavior must be altered. It should be performed only by developers with high
    expertise, because modifying the default AJAX behavior may lead to undesirable
    issues and gaps.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `jsf.ajax.request()`，显式加载 AJAX 库，开发者可以访问 AJAX 代码。这种方法通常用于必须更改默认 AJAX 行为时。这应由具有高度专业知识的开发者执行，因为修改默认
    AJAX 行为可能会导致不希望的问题和漏洞。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: A brief overview of the JSF-AJAX lifecycle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF-AJAX 生命周期的简要概述
- en: A simple JSF-AJAX example
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的 JSF-AJAX 示例
- en: How the `execute`, `render`, `listener`, and `event` attributes work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute`、`render`、`listener` 和 `event` 属性如何工作'
- en: Monitoring AJAX state on client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端监控 AJAX 状态
- en: Monitoring AJAX errors on client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端监控 AJAX 错误
- en: Grouping components under the `<f:ajax>` tag
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `<f:ajax>` 标签下分组组件
- en: Updating input fields with AJAX after a validation error
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验证错误后使用 AJAX 更新输入字段
- en: Mixing AJAX and flow scope
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合 AJAX 和流程作用域
- en: How postback and AJAX work together
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台提交和 AJAX 如何协同工作
- en: How to determine whether a request is AJAX or non-AJAX
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确定请求是 AJAX 还是非 AJAX
- en: How AJAX and `<f:param>` work
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX 和 `<f:param>` 如何工作
- en: Queue control for AJAX requests
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX 请求的队列控制
- en: How `jsf.js` can be loaded explicitly
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何显式加载 `jsf.js`
- en: How to write an AJAX progress bar / indicator
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写 AJAX 进度条 / 指示器
- en: A brief overview of the JSF-AJAX lifecycle
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF-AJAX 生命周期的简要概述
- en: AJAX's request-response cycle is characterized by **partial processing** and
    **partial rendering** stages; this means that AJAX partially affects the current
    view. As such, requests are not typical JSF requests, they follow a different
    lifecycle dictated by the `javax.faces.context.PartialViewContext` class. The
    methods of this class know how to deal with AJAX requests, which means that they
    are responsible for solving partial processing and rendering of the component
    tree.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 的请求-响应周期以 **部分处理** 和 **部分渲染** 阶段为特征；这意味着 AJAX 部分影响了当前视图。因此，请求不是典型的 JSF
    请求，它们遵循由 `javax.faces.context.PartialViewContext` 类指定的不同生命周期。这个类的方法知道如何处理 AJAX
    请求，这意味着它们负责解决组件树的部分处理和渲染。
- en: 'The kernel of an AJAX request is represented by two attributes of the `<f:ajax>`
    tag: `execute` and `render`. The `execute` attribute indicates the components
    that should be processed on the server (partial processing), while the `render`
    attribute indicates the components that should be rendered (or re-rendered) on
    the client (partial rendering).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 请求的核心由 `<f:ajax>` 标签的两个属性表示：`execute` 和 `render`。`execute` 属性指示应在服务器上处理的组件（部分处理），而
    `render` 属性指示应在客户端渲染（或重新渲染）的组件（部分渲染）。
- en: In the upcoming sections, you will see many examples of how these attributes
    works.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将看到许多这些属性如何工作的示例。
- en: A simple JSF-AJAX example to get started
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 JSF-AJAX 示例以开始学习
- en: 'The simplest JSF-AJAX example can be written in a matter of a few seconds.
    Let''s consider a JSF form with an input text and a button that sends the user
    input to the server. The user input (a string) is converted by the server to uppercase
    and is displayed to the user in an output text component. Next, you can ajaxify
    this scenario as shown in the following example code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的JSF-AJAX示例可以在几秒钟内编写。让我们考虑一个包含输入文本和按钮的JSF表单，该按钮将用户输入发送到服务器。服务器将用户输入（一个字符串）转换为大写，并在输出文本组件中显示给用户。接下来，您可以将此场景ajax化，如下面的示例代码所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The presence of the `<f:ajax>` tag is sufficient to transform this request into
    an AJAX request. Well, it is true that this request is not very useful because
    we did not specify which components should be executed and what components should
    be re-rendered. But the good part is that you will not receive any errors; JSF
    will use the default values for the `execute` and `render` attributes, which ask
    JSF to process the element that triggered the request and to re-render nothing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:ajax>`标签的存在足以将此请求转换为AJAX请求。好吧，这个请求确实不是很实用，因为我们没有指定哪些组件应该执行以及哪些组件应该重新渲染。但好处是您不会收到任何错误；JSF将使用`execute`和`render`属性的默认值，这将要求JSF处理触发请求的元素，并重新渲染无内容。'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When the `execute` or `render` attribute is missing, JSF will process the element
    that triggered the request and re-render nothing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当`execute`或`render`属性缺失时，JSF将处理触发请求的元素，并重新渲染无内容。
- en: 'Adding the `execute` attribute with the value of the `inputText` ID (`nameInputId`)
    tag will tell JSF to pass to the server the user input. This means that the user
    input will be available in the `ajaxAction` method and will be converted to uppercase.
    You can check the effect of this method in the application server log because
    it is not visible on the client side, since the `render` attribute still defaults
    to nothing. Therefore, you need to add the `render` attribute and indicate the
    IDs of the components that should be re-rendered; in this case, the output text
    with the ID `nameOutputId`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 添加具有`inputText` ID（`nameInputId`）标签值的`execute`属性将告诉JSF将用户输入传递到服务器。这意味着用户输入将在`ajaxAction`方法中可用，并将其转换为大写。您可以在应用程序服务器日志中检查此方法的效果，因为它在客户端不可见，因为`render`属性仍然默认为无。因此，您需要添加`render`属性并指明应重新渲染的组件ID；在这种情况下，具有ID
    `nameOutputId`的输出文本：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Done! This is a simple and functional AJAX application. You can find the complete
    code in the code bundle of this chapter, named `ch7_1`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！这是一个简单且功能性的AJAX应用程序。您可以在本章的代码包中找到完整的代码，命名为`ch7_1`。
- en: The JSF-AJAX attributes
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF-AJAX属性
- en: In this section, you will see what the main attributes supported by `<f:ajax>`
    are. We start with `execute` and `render`, continue with `listener` and `event`,
    and finish with `onevent` and `onerror`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将看到`<f:ajax>`支持的主要属性。我们从`execute`和`render`开始，继续到`listener`和`event`，最后是`onevent`和`onerror`。
- en: The execute and render attributes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行和渲染属性
- en: 'In the previous example, the `execute` and `render` attributes affect a single
    component indicated by its ID. When multiple components are affected, we can specify
    a list of IDs separated by space, or we can use the following keywords:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`execute`和`render`属性影响一个由其ID指定的单个组件。当多个组件受到影响时，我们可以指定由空格分隔的ID列表，或者我们可以使用以下关键字：
- en: '`@form`: This keyword refers to all component IDs in the form that contains
    the AJAX component. If it is present in the `execute` attribute, then the entire
    `<h:form>` is submitted and processed. In case of the `render` attribute, the
    entire `<h:form>` is rendered.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@form`：此关键字指代包含AJAX组件的表单中所有组件的ID。如果它存在于`execute`属性中，则整个`<h:form>`将被提交和处理。在`render`属性的情况下，整个`<h:form>`将被渲染。'
- en: '`@this`: This keyword refers to the ID of the element that triggers the request
    (default when `execute` is missing). For the `execute` attribute, `@this` will
    submit and process only the component that contains the AJAX component, while
    for the `render` attribute, it will render only the component that contains the
    AJAX component.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@this`：此关键字指代触发请求的元素的ID（当`execute`缺失时默认）。对于`execute`属性，`@this`将仅提交和处理包含AJAX组件的组件，而对于`render`属性，它将仅渲染包含AJAX组件的组件。'
- en: '`@none`: No component will be processed/re-rendered. But for the `execute`
    attribute, JSF will still execute the lifecycle, including its phase listeners;
    while for the `render` attribute, JSF will perform the *Render Response* phase,
    including firing any `preRenderView` events. This is the default value for the
    `render` attribute.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@none`: 没有组件将被处理/重新渲染。但对于 `execute` 属性，JSF 仍将执行生命周期，包括其阶段监听器；而对于 `render`
    属性，JSF 将执行 *Render Response* 阶段，包括触发任何 `preRenderView` 事件。这是 `render` 属性的默认值。'
- en: '`@all`: This keyword represents all components IDs. For `execute`, all components
    in a page are submitted and processed—like a full page submit. For the `render`
    attribute, JSF will render all components in the page; this will update the page,
    but will allow preserving some client-side states outside the JSF.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@all`: 这个关键字代表所有组件 ID。对于 `execute`，页面上的所有组件都将被提交和处理——就像一个完整的页面提交。对于 `render`
    属性，JSF 将渲染页面上的所有组件；这将更新页面，但允许保留一些 JSF 外部的客户端状态。'
- en: 'Depending on the application''s needs, these keywords and component IDs can
    be mixed to obtain cool AJAX requests. For example, go through the following AJAX
    requests:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的需求，这些关键字和组件 ID 可以混合使用以获得酷炫的 AJAX 请求。例如，通过以下 AJAX 请求：
- en: 'Process and re-render the current form using the following code:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码处理并重新渲染当前表单：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Process form, re-render none, as follows:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理表单，不重新渲染任何内容，按照以下方式：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Process the element that triggers the request and re-renders the form, as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式处理触发请求的元素并重新渲染表单：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Process the form and re-render all as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式处理表单并重新渲染所有内容：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Process the form and re-render the components with IDs `nameInputId phoneInputId`
    inside the form as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式处理表单并重新渲染表单内具有 `nameInputId phoneInputId` ID 的组件：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can continue with many other examples, but I think you got the idea.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用许多其他示例，但我认为你已经明白了这个概念。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The keywords (`@form`, `@this`, `@all`, and `@none`) and component IDs can be
    mixed in the same value of the `render` and `execute` attribute. Don't forget
    to separate them with spaces.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字（`@form`、`@this`、`@all` 和 `@none`）和组件 ID 可以在 `render` 和 `execute` 属性的相同值中混合使用。别忘了用空格将它们分开。
- en: The complete application can be seen in the code bundle of this chapter, and
    is named as `ch7_2`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，命名为 `ch7_2`。
- en: 'A special case consists in re-rendering components outside the form that contains
    the AJAX element that triggers the request. Take a look at the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊情况是重新渲染包含触发请求的 AJAX 元素的表单外的组件。看看以下示例：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the `:` notation for updating components outside the form, which contains
    the element that triggers the AJAX request. This notation represents the default
    separator returned by the `UINamingContainer.getSeparatorChar` method. This can
    be specified via the `javax.faces.SEPARATOR_CHAR` context parameter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `:` 符号来更新表单外的组件，其中包含触发 AJAX 请求的元素。这个符号表示 `UINamingContainer.getSeparatorChar`
    方法返回的默认分隔符。这可以通过 `javax.faces.SEPARATOR_CHAR` 上下文参数来指定。
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_3`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，命名为 `ch7_3`。
- en: The listener attribute
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听器属性
- en: 'Another important attribute of `<f:ajax>` is named `listener`. This attribute
    indicates a server-side method that should be executed when an AJAX request is
    fired by a client action. For example, you can do this using the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:ajax>` 的另一个重要属性名为 `listener`。此属性指示当客户端动作触发 AJAX 请求时应执行的服务器端方法。例如，你可以使用以下代码来做这件事：'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Well, using the `listener` attribute you can transform the preceding code into
    the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，使用 `listener` 属性，你可以将前面的代码转换为以下代码：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An obvious question arises here. What is the difference between these two and
    why should I use `listener` and not `action`? Well, there are a few differences
    between these two, and the following are the most important ones:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里出现了一个明显的问题。这两个之间有什么区别，为什么我应该使用 `listener` 而不是 `action`？好吧，这两个之间有一些区别，以下是最重要的几个：
- en: A server-side method called through the `action` attribute can return `String`
    representing a navigation case (outcome), while a server-side method called through
    `listener` cannot provide a navigation case.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `action` 属性调用的服务器端方法可以返回表示导航情况（结果）的 `String`，而通过 `listener` 调用的服务器端方法不能提供导航情况。
- en: If the client disables JavaScript in the browser configuration, the `listener`
    attribute will not work anymore—the server-side method will not be called. The
    `action` attribute still works.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端在浏览器配置中禁用了 JavaScript，`listener` 属性将不再起作用——服务器端方法将不会被调用。`action` 属性仍然有效。
- en: Components that do not support the `action` attribute can use `listener` instead.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持 `action` 属性的组件可以使用 `listener` 代替。
- en: 'The server-side method called through the `listener` attribute accepts an argument
    of type `AjaxBehaviorEvent`, which represents the component behavior specific
    to AJAX. This is not accepted in case of the `action` attribute. For example,
    refer to the following code:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `listener` 属性调用的服务器端方法接受一个类型为 `AjaxBehaviorEvent` 的参数，它表示 AJAX 特定的组件行为。在
    `action` 属性的情况下不接受。例如，参考以下代码：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the client behavior (the `ClientBehavior` interface) is responsible
    for generating reusable JavaScript code that can be added to JSF components. The
    AJAX (`<f:ajax>`) is a client-side behavior, which means it is always attached
    as a behavior to another UI component(s). You can find more details about `ClientBehavior`
    in the *Working with client behavior functionality* section in [Chapter 5](ch05.html
    "Chapter 5. JSF Configurations Using XML Files and Annotations – Part 2"), *JSF
    Configurations Using XML Files and Annotations – Part 2*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，客户端行为（`ClientBehavior` 接口）负责生成可重用的 JavaScript 代码，这些代码可以添加到 JSF 组件中。AJAX (`<f:ajax>`)
    是客户端行为，这意味着它始终作为行为附加到另一个 UI 组件（s）。你可以在第 5 章（[Chapter 5](ch05.html "Chapter 5. JSF
    Configurations Using XML Files and Annotations – Part 2")）的“使用客户端行为功能”部分中找到更多关于
    `ClientBehavior` 的信息，*JSF Configurations Using XML Files and Annotations – Part
    2*。
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_4`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，名称为 `ch7_4`。
- en: The event attribute
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件属性
- en: Each AJAX request is fired by an event indicating a user or programmatic action.
    JSF defines default events based on the parent components; according to documentation
    "The default event is `action` for `ActionSource` components such as `<h:commandButton>`,
    and `valueChange` for `EditableValueHolder` components such as `<h:inputText>`".
    Most of the time, the default events are exactly what you need, but in case that
    you want to explicitly set an event for a component, you can use the `event` attribute.
    Some of the most common values for this attribute are `click`, `focus`, `blur`,
    `keyup`, and `mouseover`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 AJAX 请求都是由一个表示用户或程序性操作的事件触发的。JSF 根据父组件定义默认事件；根据文档，“对于 `<h:commandButton>`
    等`ActionSource`组件，默认事件是 `action`，而对于 `<h:inputText>` 等`EditableValueHolder`组件，默认事件是
    `valueChange`”。大多数情况下，默认事件正是你所需要的，但如果你想要为组件显式设置一个事件，可以使用 `event` 属性。此属性的常见值包括
    `click`、`focus`、`blur`、`keyup` 和 `mouseover`。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not confuse these events with JavaScript events, which are prefixed with
    the `on` notation (`onclick`, `onkeyup`, `onblur`, and so on). The JavaScript
    events are *behind* AJAX events; or, with other words, AJAX events are based on
    JavaScript events. For example, AJAX `click` event is based on the `onclick` JavaScript
    event.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这些事件与带有 `on` 前缀的 JavaScript 事件混淆（例如 `onclick`、`onkeyup`、`onblur` 等）。JavaScript
    事件位于 AJAX 事件之后；或者换句话说，AJAX 事件基于 JavaScript 事件。例如，AJAX `click` 事件基于 `onclick` JavaScript
    事件。
- en: 'In the following code, the event that triggers the AJAX action is `keyup`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，触发 AJAX 动作的事件是 `keyup`：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_5`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，名称为 `ch7_5`。
- en: The onevent attribute – monitoring AJAX state on client
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onevent 属性 - 在客户端监控 AJAX 状态
- en: During an AJAX request, JSF is capable of calling a client-defined JavaScript
    method and passing an object named `data` to it, containing information about
    the current state of the request. The JavaScript function is called when the request
    begins, completes, and succeeds.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AJAX 请求期间，JSF 能够调用客户端定义的 JavaScript 方法，并将一个名为 `data` 的对象传递给它，其中包含有关请求当前状态的信息。当请求开始、完成和成功时，调用
    JavaScript 函数。
- en: 'The `data` objects encapsulate the following properties:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 对象封装了以下属性：'
- en: '`type`: This property gives the type of the AJAX call, `event`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 这个属性给出了 AJAX 调用的类型，`event`'
- en: '`status`: This property returns the `begin`, `complete`, or `success` status
    (can be used to implement an indeterminate progress bar).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 这个属性返回 `begin`、`complete` 或 `success` 状态（可用于实现不确定进度条）。'
- en: Note
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When the `status` property has the value `begin`, which means that the AJAX
    request has not been sent yet. When it equals `complete`, it means that the AJAX
    response has successfully reached to the client, but it hasn't been processed
    yet. If the received response is successfully processed (without errors), the
    `status` value becomes `success`.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`status`属性值为`begin`时，表示AJAX请求尚未发送。当它等于`complete`时，表示AJAX响应已成功到达客户端，但尚未被处理。如果接收到的响应成功处理（没有错误），则`status`值变为`success`。
- en: '`source`: This property returns the DOM element representing the source of
    the AJAX event'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`: 这个属性返回表示AJAX事件源的DOM元素'
- en: '`responseXML`: This is the AJAX response in XML format'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseXML`: 这是以XML格式表示的AJAX响应'
- en: '`responseText`: This is the AJAX response in text format'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseText`: 这是以文本格式表示的AJAX响应'
- en: '`responseCode`: This is the AJAX response code'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseCode`: 这是以AJAX响应代码'
- en: 'You need to indicate the name of the JavaScript method through the `onevent`
    attribute (in `jsf.js`, the JavaScript method representing implementation of this
    attribute is named `addOnEvent`(callback)):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要通过`onevent`属性指示JavaScript方法的名称（在`jsf.js`中，表示此属性实现的JavaScript方法命名为`addOnEvent`(回调)）：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, the `ajaxMonitoring` function can use the `data` object and its properties
    to accomplish different client-side tasks. For example, the following implementation
    feeds up some `div` tags with details about the AJAX request:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`ajaxMonitoring`函数可以使用`data`对象及其属性来完成不同的客户端任务。例如，以下实现向一些`div`标签中填充有关AJAX请求的详细信息：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the following figure, you can see a possible output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，您可以看到可能的输出：
- en: '![The onevent attribute – monitoring AJAX state on client](img/6466EN_07_01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![onevent属性 – 在客户端监控AJAX状态](img/6466EN_07_01.jpg)'
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_21`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，命名为`ch7_21`。
- en: The onerror attribute – monitoring AJAX errors on client
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onerror属性 - 在客户端监控AJAX错误
- en: 'In the preceding section, you saw how to monitor the state of AJAX requests
    using a client-defined JavaScript function and the `data` object. Based on the
    same technique, we can obtain information about the possible errors that can occur
    during AJAX requests. The passed `data` object encapsulates the following properties
    (notice that this is the same `data` object from the preceding section; therefore
    you still have access to those properties): `description`, `errorName`, and `errorMessage`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您看到了如何使用客户端定义的JavaScript函数和`data`对象来监控AJAX请求的状态。基于同样的技术，我们可以获取有关在AJAX请求过程中可能发生的错误的信息。传递的`data`对象封装了以下属性（请注意，这是前面章节中的同一个`data`对象；因此您仍然可以访问这些属性）：`description`、`errorName`和`errorMessage`。
- en: 'The `data.type` property will be `error` and the `data.status` property will
    be one of the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.type`属性将为`error`，而`data.status`属性将为以下之一：'
- en: '`serverError`: This is the response of the AJAX request that contains an error'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serverError`: 这包含错误的AJAX请求的响应'
- en: '`malformedXML`: This is an XML well-formed error'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malformedXML`: 这是一个XML格式错误'
- en: '`httpError`: This is a valid HTTP error'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpError`: 这是一个有效的HTTP错误'
- en: '`emptyResponse`: This is a server-side code that did not provide a response'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptyResponse`: 这是一段服务器端代码，没有提供响应'
- en: 'The name of the JavaScript method is indicated through the `onerror` attribute
    (in `jsf.js`, the JavaScript method representing implementation of this attribute
    is named `addOnError` (callback)). So at this point, we can update the application
    from the previous section to report errors on the client as well, as shown in
    the following code (note that `onevent` and `onerror` calls the same method, `ajaxMonitoring`;
    however this is not mandatory as you can use separate JavaScript methods as well):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript方法的名称通过`onerror`属性指示（在`jsf.js`中，表示此属性实现的JavaScript方法命名为`addOnError`（回调））。因此，在此点，我们可以更新前面章节中的应用程序，以在客户端报告错误，如下面的代码所示（请注意，`onevent`和`onerror`调用同一个方法`ajaxMonitoring`；然而这并非强制性的，您也可以使用单独的JavaScript方法）：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can test this code by adding an intentional error, such as calling
    nonexistent server-side method, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过添加一个故意的错误来测试此代码，例如调用不存在的服务器端方法，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A possible output is shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了可能的输出：
- en: '![The onerror attribute – monitoring AJAX errors on client](img/6466EN_07_02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![onerror属性 – 在客户端监控AJAX错误](img/6466EN_07_02.jpg)'
- en: The complete application can be found in code bundle of this chapter, and is
    named `ch7_6`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，命名为 `ch7_6`。
- en: Grouping components under <f:ajax> tag
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `<f:ajax>` 标签下分组组件
- en: 'Sometimes, it may be useful to group multiple components under the same `<f:ajax>`
    tag. For example, the following code snippet groups two `<h:inputText>` components
    under the same `<f:ajax>` tag (you can nest other components as well):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将多个组件分组在同一个 `<f:ajax>` 标签下可能很有用。例如，以下代码片段将两个 `<h:inputText>` 组件分组在同一个 `<f:ajax>`
    标签下（您也可以嵌套其他组件）：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, how does it work? When you click either of the input components, an AJAX
    request is fired for the input component and one for the form (two requests in
    our example) and all the components in the form are re-rendered. Since the `click`
    event will generate AJAX requests/responses, you will not be able to enter keys
    in those `<h:inputText>` unless you are using the *Tab* key to gain focus in each
    `<h:inputText>` component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？当您点击任何一个输入组件时，会为输入组件和表单（在我们的例子中是两个请求）发起一个 AJAX 请求，并且表单中的所有组件都会重新渲染。由于
    `click` 事件会生成 AJAX 请求/响应，除非您使用 *Tab* 键在每个 `<h:inputText>` 组件中获取焦点，否则您将无法在那些 `<h:inputText>`
    中输入键。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The components grouped under `<f:ajax>` can still use inner (or locally used)
    `<f:ajax>` tags. In this case, the effect is cumulative. Of course, you have to
    be extra careful when you use this technique, because undesired behaviors may
    occur.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<f:ajax>` 标签下分组的组件仍然可以使用内部（或本地使用）的 `<f:ajax>` 标签。在这种情况下，效果是累积的。当然，当您使用这种技术时，必须格外小心，因为可能会出现不期望的行为。
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_7`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，命名为 `ch7_7`。
- en: Updating input fields with AJAX after validation error
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在验证错误后使用 AJAX 更新输入字段
- en: Updating input fields with AJAX after validation error is a very old, well-known,
    and annoying issue for JSF developers. When an AJAX request fails in the validation
    phase, there is no built-in way to update the input fields with some valid values
    because JSF does not allow access to the model value after a validation error
    (usually, you want to clear up those fields or provide some default values, or
    even some old values provided by the same user). Of course, JSF developers found
    different workarounds, or used other libraries, such as PrimeFaces or OmniFaces,
    but a JSF solution was required.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证错误后使用 AJAX 更新输入字段是 JSF 开发者非常古老、众所周知且令人烦恼的问题。当 AJAX 请求在验证阶段失败时，没有内置的方法可以更新输入字段以包含一些有效值，因为
    JSF 不允许在验证错误后访问模型值（通常，您希望清除这些字段或提供一些默认值，甚至是一些由同一用户提供的旧值）。当然，JSF 开发者找到了不同的解决方案，或者使用了其他库，如
    PrimeFaces 或 OmniFaces，但需要一个 JSF 解决方案。
- en: 'Starting with JSF 2.2, all components that should be re-rendered (components
    indicated in the `render` attribute) will be reset if we set the `resetValues`
    attribute to `true`. The easiest way to understand this is to proceed with a comparison
    test. First, let''s use an AJAX request without `resetValues`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.2 开始，如果我们将 `resetValues` 属性设置为 `true`，则应该重新渲染的所有组件（在 `render` 属性中指示的组件）将被重置。理解这一点最简单的方法是通过比较测试。首先，让我们使用没有
    `resetValues` 的 AJAX 请求：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s suppose that a valid value for our input field is an alphanumeric string
    (with respect to the [^a-zA-Z0-9] pattern). In the following screenshot, on the
    left-hand side, you can see the AJAX result after inserting a valid value, and
    on the right-hand side, you can see the AJAX result after inserting an invalid
    value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们输入字段的合法值是一个字母数字字符串（与 [^a-zA-Z0-9] 模式相关）。在下面的截图中，在左侧，您可以看到插入有效值后的 AJAX 结果，而在右侧，您可以看到插入无效值后的
    AJAX 结果：
- en: '![Updating input fields with AJAX after validation error](img/6466EN_07_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![在验证错误后使用 AJAX 更新输入字段](img/6466EN_07_03.jpg)'
- en: As you can see in the preceding screenshot, on the right-hand side, the invalid
    value was not reset. The invalid value retains and is very annoying.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，在右侧，无效的值没有被重置。无效的值被保留，这非常令人烦恼。
- en: 'Next, we proceed with the same case, but we add the `resetValues` attribute:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续同样的案例，但添加了 `resetValues` 属性：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we repeat the test. In the following screenshot, on the left-hand side,
    the submitted value is valid, while on the right-hand side, it is invalid:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重复测试。在下面的截图中，左侧的提交值是有效的，而右侧的值是无效的：
- en: '![Updating input fields with AJAX after validation error](img/6466EN_07_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![在验证错误后使用 AJAX 更新输入字段](img/6466EN_07_04.jpg)'
- en: Now, when the submitted value was invalid, the input field was reset (in this
    case, cleared).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当提交的值无效时，输入字段会被重置（在这种情况下，会被清除）。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From this example, you may misunderstand that `resetValues` works as a clear
    (empty) field's action. Well, it does not! When an input field is reset, the valid
    value that replaces the invalid one is related to the managed bean (the renderer
    will pick up the value from the bean). If the managed bean is in the request scope,
    the replacer (valid value) will be the one used for initialization of corresponding
    property (which may be anything, not just an empty string). But, if the managed
    bean is in view scope, then the replacer will be the currently valid value of
    the corresponding property, which may be the initialization value, or the previous
    valid value inserted by the user (of course, altered or not altered in a server-side
    method).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，您可能会误解 `resetValues` 的工作原理就像是一个清除（空）字段的动作。实际上，它不是这样！当一个输入字段被重置时，替换无效值的有效值与托管Bean（渲染器将从Bean中获取值）相关。如果托管Bean在请求作用域中，替换者（有效值）将是用于初始化相应属性（这可能是一切，而不仅仅是空字符串）的值。但如果托管Bean在视图作用域中，那么替换者将是相应属性的当前有效值，这可能是最初的值，或者是用户插入的先前有效值（当然，在服务器端方法中可能已更改或未更改）。
- en: Keep this note in mind while testing the complete application available in the
    code bundle of this chapter, named `ch7_8_1`. By default, this application comes
    with a request scoped managed bean, but you can easily transform it into a view
    scoped for more tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试本章代码包中名为 `ch7_8_1` 的完整应用程序时，请记住这个注意事项。默认情况下，此应用程序包含一个请求作用域的托管Bean，但您可以轻松将其转换为视图作用域以进行更多测试。
- en: 'Besides the `resetValues` attribute for AJAX requests, JSF 2.2 comes with a
    tag, named `<f:resetValues>`, for non-AJAX requests. Basically, this is an action
    listener that can be easily attached to any `ActionSource` instance (for example,
    `<h:commandButton>`). The effect will consist of resetting all components that
    are given in its `render` attribute (use only component IDs, not keywords such
    as `@form`, `@all`, and so on):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于AJAX请求的 `resetValues` 属性外，JSF 2.2 还提供了一个名为 `<f:resetValues>` 的标签，用于非AJAX请求。基本上，这是一个可以轻松附加到任何
    `ActionSource` 实例（例如，`<h:commandButton>`）的动作监听器。其效果将包括重置其 `render` 属性中给出的所有组件（仅使用组件ID，而不是如
    `@form`、`@all` 等关键字）：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_8_2`. This tag is not recognized in all JSF 2.2 (Mojarra and MyFaces)
    versions, therefore you have to test it in order to be sure that you can use it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，并命名为 `ch7_8_2`。此标签在所有JSF 2.2（Mojarra和MyFaces）版本中可能不被识别，因此您必须进行测试以确保可以使用它。
- en: The Cancel and Clear buttons
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消和清除按钮
- en: 'Buttons of type **Cancel** (which resets the form''s fields to the initial
    state or to the most recent valid state) and **Clear** (which clears up the form''s
    fields) are not very popular in web applications, but sometimes they can be useful
    to end users. When implementing the **Cancel**/**Clear** buttons, you need to
    find a way to skip the *Process Validation* phase (which is needed for the **Submit**
    button). The motivation is simple: when a user cancels/clears a form''s values,
    we certainly don''t need valid values in order to accomplish these tasks; therefore,
    no validation is needed.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 **取消**（将表单的字段重置到初始状态或最近的合法状态）和 **清除**（清除表单的字段）的按钮在Web应用程序中并不常见，但有时它们对最终用户可能很有用。在实现
    **取消**/**清除**按钮时，您需要找到一种方法来跳过 **过程验证** 阶段（这是 **提交** 按钮所需的）。动机很简单：当用户取消/清除表单的值时，我们当然不需要有效的值来完成这些任务；因此，不需要验证。
- en: In non-AJAX requests, a common technique consists of using the `immediate="true"`
    attribute, which, for command components (for example, `<h:commandButton>`), will
    transfer the invocation of action in *Apply Request Values* phase. This attribute
    is available for AJAX requests as well, but AJAX provides a better solution for
    these kinds of tasks. Instead of using `immediate="true"`, we can use the `@this`
    keyword. Furthermore, we can use the `resetValues` feature to simplify and fortify
    the **Cancel**/**Clear** buttons.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在非AJAX请求中，一种常见的技巧是使用 `immediate="true"` 属性，对于命令组件（例如，`<h:commandButton>`），它将在
    **应用请求值** 阶段转移动作的调用。此属性也适用于AJAX请求，但AJAX为这些任务提供了更好的解决方案。我们不需要使用 `immediate="true"`，而是可以使用
    `@this` 关键字。此外，我们可以使用 `resetValues` 功能来简化并加强 **取消**/**清除** 按钮。
- en: 'Now, let''s look at some scenarios. We will keep things simple, therefore we
    need a form with a single input field and three buttons: **Submit**, **Cancel**,
    and **Clear**. The validator will allow only alphanumeric characters (with respect
    to the `[^a-zA-Z0-9]` pattern).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些场景。我们将保持简单，因此我们需要一个带有单个输入字段和三个按钮（**提交**、**取消**和**清除**）的表单。验证器将只允许字母数字字符（根据`[^a-zA-Z0-9]`模式）。
- en: Value submitted to a view scoped managed bean
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交给视图作用域管理器的值
- en: 'In this case, run the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，运行以下代码：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Press the **Submit** button. In case of an invalid value, you will see a specific
    error message (`<h:message>`), and `resetValues` will reset the input field to
    the initial value (empty string or some suggestion) or the most recent valid value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**提交**按钮。如果值无效，你将看到一个特定的错误消息（`<h:message>`），并且`resetValues`将输入字段重置为初始值（空字符串或一些建议）或最近的合法值。
- en: Press the **Cancel** button. Since we are using `execute="@this"`, the input
    field will not be processed on the server; therefore no validation happens. The
    re-render process will have the same effect as `resetValues` for the input field,
    but will clear the `<h:message>` tag as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**取消**按钮。由于我们使用`execute="@this"`，输入字段将不会在服务器上处理；因此不会发生验证。重新渲染过程对输入字段的效果与`resetValues`相同，但也会清除`<h:message>`标签。
- en: 'Press the **Clear** button. This button uses `execute="@this"`, too. But, instead
    of resetting the input field to `resetValues`, it clears up the input field and
    `<h:message>`. For this, an additional method is needed in the managed bean as
    follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**清除**按钮。此按钮也使用`execute="@this"`，但它不是将输入字段重置为`resetValues`，而是清除输入字段和`<h:message>`。为此，在管理器中需要添加一个额外的方法，如下所示：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_9_1`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，命名为`ch7_9_1`。
- en: 'As a simple tip and trick, for the **Clear** button you may want to use a place
    holder as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小技巧，对于**清除**按钮，你可能想使用占位符如下：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Value submitted to a request scoped managed bean
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交给请求作用域管理器的值
- en: Since the submitted value is not persisted across multiple AJAX requests, the
    `resetValues` method and the **Cancel** button will reset the input field to the
    initialization value (empty string or suggestion). The **Cancel** button will
    also reset the `<h:message>` tag. The **Clear** button will clear up input text
    and `<h:message>`. Of course, under some circumstances (such as using an empty
    string for initialization), the **Cancel** and **Clear** buttons will do the same
    thing; therefore, you can drop one of them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提交的值不会在多个AJAX请求之间持久化，`resetValues`方法和**取消**按钮将输入字段重置为初始化值（空字符串或建议）。**取消**按钮还将重置`<h:message>`标签。**清除**按钮将清除输入文本和`<h:message>`。当然，在某些情况下（例如使用空字符串进行初始化），**取消**和**清除**按钮将执行相同的功能；因此，你可以去掉其中一个。
- en: The complete application can be seen in the code bundle of this chapter, and
    is named `ch7_9_2`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中看到，命名为`ch7_9_2`。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More examples of how to use `resetValues` and implement the **Cancel** and
    **Clear** buttons can be found in the source code that accompanies this book.
    A set of examples using the `keyup` event in an input field with cancel/clear
    facilities contain the following applications: `ch7_9_3`, `ch7_9_4`, `ch7_9_5`,
    and `ch7_9_6`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用`resetValues`和实现**取消**和**清除**按钮的更多示例可以在本书附带的源代码中找到。使用具有取消/清除功能的输入字段中的`keyup`事件的一组示例包含以下应用：`ch7_9_3`、`ch7_9_4`、`ch7_9_5`和`ch7_9_6`。
- en: 'Everything seems to work pretty straightforward, but there is an issue that
    we have to fix. Let''s take a closer look at the following code (there is nothing
    tricky in it):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎一切都很直接，但有一个问题我们必须修复。让我们仔细看看以下代码（其中没有复杂的地方）：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's focus on the submit process. When we submit a valid name and surname,
    the form is re-rendered and everything looks as expected, but if one value (or
    both) is invalid, then the input fields are not reset and the corresponding error
    messages appear. This is normal since the `resetValues` method is not present;
    therefore, the first thought would be to add `resetValues="true"` to `<f:ajax>`
    that corresponds to the **Submit** button. However, this will not work as expected,
    because nothing happens in case of invalid values. While you may think that the
    input fields will be reset for invalid values, you will be surprised to see that
    everything remains unchanged and the invalid values are still there after re-render.
    The cause seems to be the presence of `@form` in the `render` attribute of the
    **Submit** button. If you replace this with the components IDs that should be
    re-rendered (`nameId`, `msgNameId`, `surnameId`, and `msgSurnameId`), the `resetValues`
    method works perfectly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注提交过程。当我们提交一个有效的名字和姓氏时，表单会重新渲染，一切看起来都很正常，但如果一个值（或两个）是无效的，那么输入字段不会重置，并且会显示相应的错误消息。这是正常的，因为
    `resetValues` 方法不存在；因此，第一个想法可能是将 `resetValues="true"` 添加到对应于 **提交** 按钮的 `<f:ajax>`
    中。然而，这不会按预期工作，因为在无效值的情况下没有任何操作。虽然你可能认为输入字段会重置为无效值，但你可能会惊讶地看到在重新渲染后一切保持不变，无效值仍然存在。原因似乎是在
    **提交** 按钮的 `render` 属性中存在 `@form`。如果你用应该重新渲染的组件 ID（`nameId`、`msgNameId`、`surnameId`
    和 `msgSurnameId`）替换它，`resetValues` 方法将完美工作。
- en: But, what you can do if there are many input fields and you don't want to list
    all the components IDs? Or you just want to use the `@form` keyword in the `render`
    attribute? In this case, you should be aware that the invalid input fields will
    not be automatically reset (the `resetValues` method is useless) and the end user
    should manually cancel/clear input fields by clicking on the **Cancel** or **Clear**
    button. While the **Cancel** button works fine, there is a big *Oops!* for the
    **Clear** button because JSF will not clear the input fields that are not executed
    (listed in the `execute` attribute) and are re-rendered (listed in the `render`
    attribute), unless you submit only valid values. In other words, if the name is
    valid and the surname is not (or any other combination involving invalid values),
    then after submit and clear, the input field for the name is not cleared.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你有很多输入字段，而且不想列出所有组件的 ID，或者你只想在 `render` 属性中使用 `@form` 关键字？在这种情况下，你应该知道无效的输入字段将不会自动重置（`resetValues`
    方法无效），并且最终用户应该通过点击 **取消** 或 **清除** 按钮手动取消/清除输入字段。虽然 **取消** 按钮工作正常，但 **清除** 按钮有一个大
    **Oops!**，因为 JSF 不会清除未执行（列在 `execute` 属性中）且重新渲染（列在 `render` 属性中）的输入字段，除非你只提交有效值。换句话说，如果名字是有效的，而姓氏不是（或任何涉及无效值的组合），那么在提交和清除后，名字的输入字段不会被清除。
- en: 'One solution to this problem is given on OmniFaces ([https://code.google.com/p/omnifaces/](https://code.google.com/p/omnifaces/)),
    which provides an action listener named `org.omnifaces.eventlistener.ResetInputAjaxActionListener`
    ([http://showcase.omnifaces.org/eventlisteners/ResetInputAjaxActionListener](http://showcase.omnifaces.org/eventlisteners/ResetInputAjaxActionListener)).
    This listener is capable of fixing the **Clear** button and other issues of the
    same category:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一可以在 OmniFaces ([https://code.google.com/p/omnifaces/](https://code.google.com/p/omnifaces/))
    上找到，它提供了一个名为 `org.omnifaces.eventlistener.ResetInputAjaxActionListener` 的动作监听器
    ([http://showcase.omnifaces.org/eventlisteners/ResetInputAjaxActionListener](http://showcase.omnifaces.org/eventlisteners/ResetInputAjaxActionListener))。这个监听器能够修复
    **清除** 按钮和其他同一类的问题：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_9_7`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，该代码包命名为 `ch7_9_7`。
- en: Mixing AJAX and flow scope
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合 AJAX 和流程作用域
- en: AJAX requests are usually associated with beans in view scope (`@ViewScoped`),
    which means that data can be persisted (stored) over multiple AJAX requests as
    long as the current view is not destroyed by a navigation case (or other causes).
    A flow is defined as a collection of logical related pages/views; therefore AJAX
    cannot survive across flow transitions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 请求通常与视图作用域中的 beans 相关（`@ViewScoped`），这意味着只要当前视图没有被导航情况（或其他原因）销毁，数据就可以在多个
    AJAX 请求中持久化（存储）。一个流程被定义为逻辑相关页面/视图的集合；因此，AJAX 无法在流程转换中存活。
- en: 'For better understanding, we will adapt the application developed in [Chapter
    3](ch03.html "Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication"),
    *JSF Scopes – Lifespan and Use in Managed Beans Communication* (the `ch3_7_3`
    application, which you need to be familiar with) to support AJAX requests in the
    `registration.xhtml` view (the first page in flow). The main idea is to write
    a view scoped bean that may populate the player name and surname defined in the
    flow scoped bean, `RegistrationBean`. The view-scoped bean, named `ViewRegistrationBean`,
    will randomly generate a name-surname pair and will present them as a suggestion
    to the end user. The user can provide the name and surname or he can choose to
    use the suggested ones. So, the flow-scoped bean looks like the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们将适应在[第3章](ch03.html "第3章。JSF作用域 – 在管理Bean通信中的生命周期和使用")中开发的*JSF作用域
    – 在管理Bean通信中的生命周期和使用*（`ch3_7_3`应用程序，你需要熟悉）以支持`registration.xhtml`视图（流程中的第一页）中的AJAX请求。主要思想是编写一个视图范围内的bean，该bean可能填充在流程范围内的bean中定义的玩家姓名和姓氏。名为`ViewRegistrationBean`的视图范围内的bean将随机生成一个姓名-姓氏对，并将它们作为建议呈现给最终用户。用户可以提供姓名和姓氏，或者他/她可以选择使用建议的姓名和姓氏。因此，流程范围内的bean看起来如下所示：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the `getReturnValue` method represents a flow return (exits flow),
    while the `registrationAction` method navigates to the next page in the flow.
    Both of them will break down the current view.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`getReturnValue`方法代表流程返回（退出流程），而`registrationAction`方法在流程中导航到下一页。两者都将破坏当前视图。
- en: 'Next, the view-scoped bean is the method annotated with `@PostConstruct` that
    will help us to see if AJAX uses the same instance of this bean over multiple
    requests:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，视图范围内的bean是使用`@PostConstruct`注解的方法，它将帮助我们查看AJAX是否在多个请求中使用了此bean的相同实例：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can easily monitor the values of name and surname by displaying them in
    `registration.xhtml` using the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`registration.xhtml`中使用以下代码轻松监控姓名和姓氏的值：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, two buttons will fire AJAX requests. One button will call the server-side
    method `credentialsUpperCase` (from flow-scoped bean, `RegistrationBean`) and
    the other one will call the server-side method `generateCredentials` (from view-scoped
    bean, `ViewRegistrationBean`). In both cases, we will re-render the player name
    and surname from the beans as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将有两个按钮触发AJAX请求。一个按钮将调用服务器端方法`credentialsUpperCase`（来自流程范围内的bean，`RegistrationBean`），另一个按钮将调用服务器端方法`generateCredentials`（来自视图范围内的bean，`ViewRegistrationBean`）。在这两种情况下，我们将按照以下方式重新渲染bean中的玩家姓名和姓氏：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, the end user can register to the tournament in two ways: by manually inserting
    the name and surname through the input fields and register by pressing the first
    button (the result will be the inserted name and surname in uppercase), or he/she
    can choose to use the suggested name and surname and register by pressing the
    second button (the result will be the random name and surname in uppercase).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最终用户可以通过两种方式注册比赛：通过手动在输入字段中插入姓名和姓氏并通过按下第一个按钮（结果将是插入的姓名和姓氏的大写形式）注册，或者他/她可以选择使用建议的姓名和姓氏，并通过按下第二个按钮（结果将是随机姓名和姓氏的大写形式）注册。
- en: 'A few important things can be noticed here, which are listed as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以注意到一些重要的事情，如下列所示：
- en: Firing AJAX requests, by pressing the first button, will put the submitted name
    and surname in the flow scope (manually entered or imported from random suggestion)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按下第一个按钮触发AJAX请求，将提交的姓名和姓氏放入流程范围（手动输入或从随机建议导入）。
- en: Firing AJAX requests, by pressing the second button, will assign the suggested
    name and surname to their counterparts in the flow-scoped bean. It will not generate
    new names and surnames for each request, since we are in the same view across
    multiple AJAX requests, and the `init` method is called only when a new instance
    of the `ViewRegistrationBean` bean is created.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按下第二个按钮触发AJAX请求，将分配建议的姓名和姓氏到流程范围内的bean的对应部分。由于我们在多个AJAX请求中处于相同的视图，并且`init`方法仅在创建`ViewRegistrationBean`bean的新实例时调用，因此它不会为每个请求生成新的姓名和姓氏。
- en: If we exit and re-enter in the flow, the persisted name and surname lose their
    values. When we exit from the flow, we reach the flow-scope boundaries, which
    means a new `RegistrationBean` instance must be created when entering in the flow
    again. Moreover, this outcome will change the current view; therefore, a new instance
    of `ViewRegistrationBean` is also needed.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们退出并重新进入流程，持久化的姓名和姓氏将失去它们的值。当我们退出流程时，我们达到流程作用域的边界，这意味着在再次进入流程时必须创建一个新的`RegistrationBean`实例。此外，此结果将改变当前视图；因此，还需要一个新的`ViewRegistrationBean`实例。
- en: When we navigate to the next page in the flow, the submitted name and surname
    have the same values because they were persisted in flow scope; while the suggested
    name and surname are randomly generated again, the outcome has changed the view,
    even if we are in the same flow, as shown in the following screenshot:![Mixing
    AJAX and flow scope](img/6466EN_07_05.jpg)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在流程中导航到下一页时，提交的姓名和姓氏具有相同的值，因为它们已在流程作用域中持久化；而建议的姓名和姓氏再次随机生成，结果已改变视图，即使我们处于同一流程中，如下截图所示：![混合AJAX和流程作用域](img/6466EN_07_05.jpg)
- en: Now you know how AJAX works with flow scope combined with view scope. The complete
    application can be found in the code bundle of this chapter, which is named `ch7_10`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了AJAX如何与视图作用域结合使用。完整的应用程序可以在本章的代码包中找到，该代码包命名为`ch7_10`。
- en: Postback and AJAX
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回发和AJAX
- en: Throughout this book, we have mentioned the postback request several times.
    For those who are not familiar with it, or just need a quick reminder, let's say
    that JSF recognizes the initial request and the postback request.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们多次提到了回发请求。对于不熟悉它的人，或者只是需要快速提醒的人，让我们说JSF识别初始请求和回发请求。
- en: '**Initial request** (for example, `HTTP GET`) is the first request that the
    browser sends for loading the page. You can obtain such a request by accessing
    the application URL in a browser or by following a link (it can be a link to any
    page of the application). Moreover, the initial request happens in `page_B` when
    `page_A` contains a redirection (`faces-redirect=true`) to `page_B` (this is not
    true for forwarding mechanism). This kind of request is processed in *Restore
    View* phase and *Render Response* phase.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始请求**（例如，`HTTP GET`）是浏览器为加载页面发送的第一个请求。您可以通过在浏览器中访问应用程序URL或通过跟随链接（可以是应用程序任何页面的链接）来获取此类请求。此外，当`page_A`包含重定向（`faces-redirect=true`）到`page_B`时，初始请求发生在`page_B`（这不适用于转发机制）。此类请求在*恢复视图*阶段和*渲染响应*阶段进行处理。'
- en: '**Postback request** happens when we click on a button/link for submitting
    a form. Unlike the initial request, the postback request passes through all the
    phases.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**回发请求**发生在我们点击按钮/链接提交表单时。与初始请求不同，回发请求会通过所有阶段。'
- en: 'JSF provides a method named `isPostback` that returns a Boolean value: it returns
    `true` for postback request and `false` for initial request. Speaking in the code
    lines, we can:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: JSF提供了一个名为`isPostback`的方法，它返回一个布尔值：对于回发请求返回`true`，对于初始请求返回`false`。在代码行中，我们可以：
- en: 'Check the initial/postback request in a managed bean using the following code:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码在管理Bean中检查初始/回发请求：
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Check the initial/postback request in the page using the following code:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码在页面中检查初始/回发请求：
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For example, you can check the initial/postback request for AJAX with a simple
    application. The JSF page is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用一个简单的应用程序检查AJAX的初始/回发请求。JSF页面如下：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The managed bean is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Bean如下：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code is very simple; therefore we can jump directly to inspect the initial/postback
    requests, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单；因此，我们可以直接跳转到检查初始/回发请求，如下所示：
- en: '**First request**: The first page of the application is loaded by accessing
    the application URL. The client side indicates an initial request as it is shown
    in the following screenshot on the left-hand side, and the server side indicates
    the same, as shown in the same screenshot on the right-hand side:![Postback and
    AJAX](img/6466EN_07_06.jpg)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一次请求**：通过访问应用程序URL来加载应用程序的第一个页面。客户端将初始请求指示如下截图左侧所示，服务器端也以相同的指示，如下截图右侧所示：![回发和AJAX](img/6466EN_07_06.jpg)'
- en: '**Second request**: The **Click Me!** button is clicked for the first time
    (the result is `true` for the second time, third time, and so on). The client
    side (in the browser) indicates a postback request as it is shown in the following
    screenshot on the left-hand side, and the server side indicates the same as shown
    in the same screenshot on the right-hand side:![Postback and AJAX](img/6466EN_07_07.jpg)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二次请求**：**点击我！**按钮第一次被点击（第二次、第三次等的结果为`true`）。客户端（在浏览器中）如以下截图左侧所示，表明这是一个回发请求，服务器端如同一截图右侧所示：![回发和AJAX](img/6466EN_07_07.jpg)'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It would be useful to know when the request is initial or postback. For example,
    you may want to accomplish a task a single time, at initial request (for example,
    the initialization tasks), or every time, except for the first time (for example,
    display a message, which is not proper to appear when a page is displayed as a
    result of the initial request).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 了解请求是初始的还是回发可能会有用。例如，您可能希望在初始请求（例如，初始化任务）时仅完成一次任务，或者每次都完成，除了第一次（例如，显示一条消息，这在由于初始请求而显示页面时并不合适）。
- en: Postback request's conditional rendering/executing
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回发请求的条件渲染/执行
- en: 'We can use initial/postback request detection to conditionally render UI components
    (of course, you can use it for partial processing also). Take a look at the following
    code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用初始/回发请求检测来有条件地渲染UI组件（当然，您也可以用于部分处理）。看看以下代码：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So, let''s see how it works! When the page is loaded, we have an initial request
    (`#{facesContext.postback}` returns `false`), which means that the server response
    will contain something like the following code snippet (we need to focus on the
    `<f:ajax>` component):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看它是如何工作的！当页面加载时，我们有一个初始请求（`#{facesContext.postback}`返回`false`），这意味着服务器响应将包含如下代码片段（我们需要关注`<f:ajax>`组件）：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On the server side, the log line from the `getRequest_number` method will also
    reveal an initial request. Moreover, notice that the reported request number is
    `1`, which is the initial value of the `request_number` property.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，`getRequest_number`方法的日志行也会揭示一个初始请求。此外，请注意，报告的请求号是`1`，这是`request_number`属性的初始值。
- en: 'Next, let''s click once on the **Click Me!** button. Now, the AJAX request
    will look like the following line of code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们点击一次**点击我！**按钮。现在，AJAX请求将看起来像以下代码行：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The highlighted code provides important information! This is a postback request,
    but the `render` attribute contains the ID of the `<h:form>` component, not the
    ID of the `<h:panelGrid>` component (as you may have thought); this happens because
    the `#{facesContext.postback}` expression was evaluated to `false` in the previous
    request. So, with the first click on our button, AJAX will not re-render the `<h:panelGrid>`
    component. Meanwhile, on the server side, the `request_number` property was successfully
    incremented to `2`; however for the end user, it still appears as `1`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码提供了重要信息！这是一个回发请求，但`render`属性包含`<h:form>`组件的ID，而不是`<h:panelGrid>`组件的ID（正如您可能认为的那样）；这是因为`#{facesContext.postback}`表达式在上一个请求中评估为`false`。所以，在我们的按钮第一次点击时，AJAX不会重新渲染`<h:panelGrid>`组件。同时，在服务器端，`request_number`属性已成功增加到`2`；然而，对于最终用户来说，它仍然显示为`1`。
- en: 'Now, the server response for this AJAX will contain the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个AJAX的服务器响应将包含以下代码：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that the `postbackId`, which is the `<h:panelGrid>` ID, is present in
    the response. The next click (the second click) on the button will generate the
    next AJAX request:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`postbackId`，即`<h:panelGrid>`的ID，存在于响应中。按钮的第二次点击（第二次点击）将生成下一个AJAX请求：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, when the AJAX request completes, the `<h:panelGrid>` component will be
    re-rendered. The `request_number` property reaches the value `3`, and it will
    be displayed on the client side. Further AJAX requests will be the postback requests.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当AJAX请求完成时，`<h:panelGrid>`组件将被重新渲染。`request_number`属性达到值`3`，并将显示在客户端。进一步的AJAX请求将是回发请求。
- en: 'In the following screenshot, you can see the initial request, first click on
    the button and second click from client and server sides:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以查看初始请求，首先点击按钮，然后从客户端和服务器端进行第二次点击：
- en: '![Postback request''s conditional rendering/executing](img/6466EN_07_08.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![回发请求的条件渲染/执行](img/6466EN_07_08.jpg)'
- en: It would be helpful to know this behavior of AJAX with initial/postback requests—it
    is not a bug. Of course, once you know this *issue*, there are many workarounds
    depending on what you really want to accomplish.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 了解AJAX与初始/回发请求的行为会有所帮助——这不是一个错误。当然，一旦你知道这个*问题*，就有很多解决方案取决于你真正想要实现的目标。
- en: Further, you can try to test the `execute` attribute in a similar approach.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以尝试以类似的方式测试`execute`属性。
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_11`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，该代码包命名为`ch7_11`。
- en: Is it a non-AJAX request?
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是一个非AJAX请求吗？
- en: 'JSF can answer this question by inspecting request headers or checking the
    `PartialViewContext.isAjaxRequest` method. The request headers that provide information
    about the request type are `Faces-Request` and `X-Requested-With`. For an AJAX
    request, the `Faces-Request` header will have the value `partial/ajax`, while
    the `X-Requested-With` request type will have the value `XMLHttpRequest` (in JSF
    2.2, `X-Requested-With` doesn''t seem to work; however, for the sake of completeness,
    you can test them again). In the following screenshot, you can see the headers
    of a typical JSF 2.2 AJAX request:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: JSF可以通过检查请求头或调用`PartialViewContext.isAjaxRequest`方法来回答这个问题。提供有关请求类型信息的请求头是`Faces-Request`和`X-Requested-With`。对于AJAX请求，`Faces-Request`头将具有值`partial/ajax`，而`X-Requested-With`请求类型将具有值`XMLHttpRequest`（在JSF
    2.2中，`X-Requested-With`似乎不起作用；然而，为了完整性，您可以再次测试它们）。在下面的屏幕截图中，您可以查看典型JSF 2.2 AJAX请求的头部：
- en: '![Is it a non-AJAX request?](img/6466EN_07_09.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![这是一个非AJAX请求吗？](img/6466EN_07_09.jpg)'
- en: 'In a managed bean, you can determine the type of the request, as shown in the
    following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个管理Bean中，您可以确定请求的类型，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, on a JSF page, you can write the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在JSF页面上，您可以编写以下代码：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_12`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，该代码包命名为`ch7_12`。
- en: AJAX and <f:param>
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX和<f:param>
- en: 'The `<f:param>` tag can be used to pass request parameters to a managed bean.
    Since we have discussed this tag in detail in [Chapter 2](ch02.html "Chapter 2. Communication
    in JSF"), *Communication in JSF*, we can continue here with an example of using
    it inside `<f:ajax>`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:param>`标签可以用来将请求参数传递给一个管理Bean。由于我们已经在[第2章](ch02.html "第2章。JSF中的通信")中详细讨论了这个标签，*JSF中的通信*，我们可以在这里通过一个示例继续使用它，在`<f:ajax>`内部使用它：'
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Remember that the parameter that was passed is available in the request parameter
    map:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，传递的参数在请求参数映射中可用：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that `<f:param>` can be used with buttons and links only. Trying
    to add `<f:param>` in inputs will not work. Further details are available in [Chapter
    2](ch02.html "Chapter 2. Communication in JSF"), *Communication in JSF*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`<f:param>`只能与按钮和链接一起使用。尝试在输入中添加`<f:param>`将不会起作用。更多详细信息请参阅[第2章](ch02.html
    "第2章。JSF中的通信")，*JSF中的通信*。
- en: The complete application can be found in the code bundle of this chapter, which
    is named `ch7_13`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，该代码包命名为`ch7_13`。
- en: Queue control for AJAX requests
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX请求排队控制
- en: Queuing AJAX requests on the client side is a common practice meant to ensure
    that only one request is processed at a time. The goal of this approach is to
    protect the server from being overwhelmed and the client browser from blocking
    or receiving AJAX responses in an undefined order. While AJAX queuing is available
    in JSF 2.0, queue control for AJAX is available starting with JSF 2.2.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端排队AJAX请求是一种常见的做法，旨在确保一次只处理一个请求。这种方法的目的是保护服务器免受压垮，并防止客户端浏览器阻塞或以未定义的顺序接收AJAX响应。虽然AJAX排队在JSF
    2.0中可用，但AJAX排队控制从JSF 2.2开始提供。
- en: In order to provide AJAX queue control, JSF 2.2 introduced an attribute named
    `delay` for the `<f:ajax>` tag. The value of this attribute is a string that represents
    a number of milliseconds (defaults to `none`). During this time interval, only
    the most recent request is actually sent to the server, while the rest of them
    are ignored. In other words, JSF will wait *n* milliseconds until the most recent
    AJAX request is executed. By default, it will not wait.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供AJAX排队控制，JSF 2.2为`<f:ajax>`标签引入了一个名为`delay`的属性。此属性的值是一个表示毫秒数的字符串（默认为`none`）。在此时间间隔内，只有最新的请求实际上被发送到服务器，其余的请求被忽略。换句话说，JSF将等待*n*毫秒，直到最新的AJAX请求被执行。默认情况下，它不会等待。
- en: Here is an example of using the default `delay` attribute, and an explicit delay
    of 1000 milliseconds. In order to point out the delay effect, we've built a simple
    application that sends an AJAX request (submit an input text value) on the `keyup`
    event, and waits for a suggestion text as a server response. In the following
    screenshot, you can compare the number of entered keys until the server responds
    with the first suggestion text. In both the cases, this is the first triggered
    AJAX request. It is obvious that in the second case, a number of seven requests
    (keystrokes) were not sent because they were fired during the1000 milliseconds
    range. Generally speaking, every time a new key is entered, prior AJAX requests
    are removed, and only the last request is taken into account.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用默认`delay`属性和显式延迟1000毫秒的示例。为了突出延迟效果，我们构建了一个简单的应用程序，该应用程序在`keyup`事件上发送AJAX请求（提交输入文本值），并等待服务器响应建议文本。在下面的屏幕截图中，您可以比较输入的键数，直到服务器响应第一个建议文本。在这两种情况下，这是第一个触发的AJAX请求。很明显，在第二种情况下，由于在1000毫秒范围内触发，因此没有发送七个请求（按键）。一般来说，每次输入新键时，都会删除之前的AJAX请求，只考虑最后一个请求。
- en: '![Queue control for AJAX requests](img/6466EN_07_10.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![AJAX请求队列控制](img/6466EN_07_10.jpg)'
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_14`. You may also want to check out the *Customizing jsf.js* section,
    where you'll see the `delay` attribute at work.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，命名为`ch7_14`。您还可以查看*自定义jsf.js*部分，在那里您将看到`delay`属性的作用。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can disable the effect of the `delay` attribute by setting its value to
    `none`. This is the default value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其值设置为`none`来禁用`delay`属性的效果。这是默认值。
- en: Explicit loading of jsf.js
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式加载jsf.js
- en: The AJAX mechanism used by JSF is encapsulated in a JavaScript file, named `jsf.js`.
    This file is available in the `javax.faces` library. When we are using `<f:ajax>`,
    this file is loaded behind the scene without any explicit requirements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: JSF使用的AJAX机制封装在一个名为`jsf.js`的JavaScript文件中。此文件位于`javax.faces`库中。当我们使用`<f:ajax>`时，此文件在幕后自动加载，无需任何明确要求。
- en: 'However, `jsf.js` can be loaded explicitly with any of the following methods:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以使用以下任何一种方法显式加载`jsf.js`：
- en: 'Using the `<h:outputScript>` component as follows:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用如下`<h:outputScript>`组件：
- en: '[PRE42]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using the `@ResourceDependency` keyword as follows:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用如下`@ResourceDependency`关键字：
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Focusing on `<h:outputScript>`, you can attach AJAX to a component as shown
    in the following example code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于`<h:outputScript>`，您可以将AJAX附加到组件，如下面的示例代码所示：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `jsf.ajax.request` method defined in `jsf.js` is capable of dealing with
    AJAX requests. It takes the following three parameters:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jsf.js`中定义的`jsf.ajax.request`方法能够处理AJAX请求。它接受以下三个参数：
- en: '`source`: This is the DOM element (for example, `<h:commandButton>`, `<h:commandLink>`,
    and so on) that triggers the AJAX request (this is a mandatory parameter)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：这是触发AJAX请求的DOM元素（例如`<h:commandButton>`、`<h:commandLink>`等）（这是一个必填参数）'
- en: '`event`: This is an optional parameter representing the DOM event that triggers
    the request'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`：这是一个可选参数，表示触发请求的DOM事件'
- en: '`options`: This is an optional parameter that can contain the values: `execute`,
    `render`, `onevent`, `onerror`, `delay`, and `params`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这是一个可选参数，可以包含以下值：`execute`、`render`、`onevent`、`onerror`、`delay`和`params`。'
- en: The complete application for explicitly loading the `jsf.js` file is available
    in the code bundle of this chapter, which is named `ch7_15`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 显式加载`jsf.js`文件的完整应用程序可在本章的代码包中找到，命名为`ch7_15`。
- en: Depicting the params value
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述params值
- en: While the `execute`, `render`, `delay`, `onevent`, and `onerror` values are
    very well known from previous sections, the `params` value is something new, so
    let's give it some attention. The `params` value is actually an object that allows
    us to add supplementary parameters into the request.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`execute`、`render`、`delay`、`onevent`和`onerror`值在前面章节中非常熟悉，但`params`值是新的，所以让我们关注一下。`params`值实际上是一个对象，允许我们向请求中添加补充参数。
- en: 'For example, the following code is a fancy solution for sending a JavaScript
    JSON object to a managed bean. The code is straightforward as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码是将JavaScript JSON对象发送到管理员的优雅解决方案。代码如下：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'On the server side, the `params` value is available in the request parameter
    map as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，`params`值如下在请求参数映射中可用：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_16`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，名称为`ch7_16`。
- en: Non-UICommand components and jsf.ajax.request
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非UICommand组件和jsf.ajax.request
- en: The `<f:ajax>` tag is far more popular than `jsf.ajax.request`. This is absolutely
    normal, since `<f:ajax>` fits more natural in *context* and is much more easy
    to use and understand. Moreover, `<f:ajax>` supports the `listener` attribute,
    which allows us to call the server-side methods even when the `<f:ajax>` tag is
    nested in other components than in `UICommand`. By default, `jsf.ajax.request`
    cannot do that!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:ajax>`标签比`jsf.ajax.request`更受欢迎。这是绝对正常的，因为`<f:ajax>`在*上下文*中更自然，且使用和理解起来更加容易。此外，`<f:ajax>`支持`listener`属性，允许我们在`<f:ajax>`标签嵌套在其他组件而不是`UICommand`时调用服务端方法。默认情况下，`jsf.ajax.request`无法做到这一点！'
- en: 'For example, let''s say that we have a table (`<h:dataTable>`) that displays
    a `Map` object containing several tennis players (the `Map` key is an integer
    of type: `1`, `2`,`3`, ... *n*, and the `Map` value is the player name):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个表格（`<h:dataTable>`），它显示包含多个网球运动员的`Map`对象（`Map`键是整数类型：`1`、`2`、`3`、...
    *n*，`Map`值是运动员姓名）：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we want to add a column labeled **Delete** that contains a delete icon
    for each row, as shown in the following screenshot:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要添加一个标记为**删除**的列，其中包含每行的删除图标，如下面的截图所示：
- en: '![Non-UICommand components and jsf.ajax.request](img/6466EN_07_11.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![非UICommand组件和jsf.ajax.request](img/6466EN_07_11.jpg)'
- en: 'We want to capture the client-side `onclick` event and trigger an AJAX request
    using `jsf.ajax.request` for each icon. The idea is to send the player number
    (`1`, `2`, `3`, ... *n*) to a server-side method named `deletePlayerAction`. This
    method will find and delete the record from the `Map` object and when the table
    is re-rendered, the corresponding row will disappear. So, the code can be written
    as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望捕获客户端的`onclick`事件，并使用`jsf.ajax.request`为每个图标触发AJAX请求。想法是将玩家编号（`1`、`2`、`3`、...
    *n*）发送到名为`deletePlayerAction`的服务端方法。此方法将从`Map`对象中查找并删除记录，当表格重新渲染时，相应的行将消失。因此，代码可以写成如下：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can use the `params` value to send the player number to delete; this will
    be available through the request parameter map. But the big issue here is that
    we can't call the server-side method, `deletePlayerAction`, because we don't have
    a `UICommand` component (such as a button) and `jsf.ajax.request` doesn't have
    a `listener` value for the `options` parameter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`params`值发送玩家编号以进行删除；这将通过请求参数映射可用。但这里的大问题是，我们无法调用服务端方法`deletePlayerAction`，因为我们没有`UICommand`组件（如按钮）且`jsf.ajax.request`没有为`options`参数提供`listener`值。
- en: 'Well, the solution comes from the JSF extensions such as PrimeFaces (check
    `<p:remoteCommand>`), OmniFaces (check `<o:commandScript>`), or RichFaces (check
    `<a4j:jsfFunction>`), but you can also solve the problem through pure JSF. First,
    you need to add a `UICommand` component that is not visible, such as a `<h:commandLink>`
    tag, as added in the following code snippet:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，解决方案来自JSF扩展，如PrimeFaces（检查`<p:remoteCommand>`）、OmniFaces（检查`<o:commandScript>`）或RichFaces（检查`<a4j:jsfFunction>`），但你也可以通过纯JSF解决这个问题。首先，你需要添加一个不可见的`UICommand`组件，例如添加到以下代码片段中的`<h:commandLink>`标签：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we bind the AJAX request to this `UICommand` component, as shown in the
    following code snippet:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将AJAX请求绑定到这个`UICommand`组件，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'At this moment, when we click on a delete icon, the server-side method is executed.
    The code of this method is pretty simple, which is as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，当我们点击删除图标时，将执行服务端方法。此方法的代码相当简单，如下所示：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Done! The complete application can be found in the code bundle of this chapter,
    which is named `ch7_17`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序可以在本章的代码包中找到，名称为`ch7_17`。
- en: 'Of course, as the section name suggests, this was an example of using `jsf.ajax.request`,
    not the best solution to this scenario. Nevertheless, there are simple solutions
    for this, such as using a `<h:commandLink>` tag in conjunction with the icon and
    ajaxify the link (proposed by Michael Muller at [http://blog.mueller-bruehl.de/tutorial-web-development/](http://blog.mueller-bruehl.de/tutorial-web-development/)),
    The following code snippet shows this approach:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如章节名称所暗示的，这是一个使用`jsf.ajax.request`的示例，但并不是解决此场景的最佳方案。尽管如此，对此问题有简单的解决方案，例如使用与图标结合的`<h:commandLink>`标签并将链接ajax化（由Michael
    Muller在[http://blog.mueller-bruehl.de/tutorial-web-development/](http://blog.mueller-bruehl.de/tutorial-web-development/)提出），以下代码片段展示了这种方法：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The complete example can be found in the code bundle of this chapter named `ch7_18`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，命名为`ch7_18`。
- en: Customizing jsf.js
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制jsf.js
- en: The biggest advantage of explicitly loading `jsf.js` is the fact that we can
    customize the AJAX mechanism by altering the default code. First, we need to isolate
    the default `jsf.js` file in a separate place—you can easily save it in a folder
    such as `resources/default/js` in the web pages folder. Afterwards, you can edit
    the JavaScript file and perform the desired modifications. Of course, modify this
    code only if you really know what you are doing, because you may cause undesired
    issues! It is not recommended that you modify the code, unless you really need
    to.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 明确加载`jsf.js`的最大优点是我们可以通过修改默认代码来自定义AJAX机制。首先，我们需要将默认的`jsf.js`文件隔离到单独的位置——你可以在网页文件夹中的`resources/default/js`文件夹中轻松保存它。之后，你可以编辑JavaScript文件并执行所需的修改。当然，只有在你真正了解你在做什么的情况下才修改此代码，因为你可能会引起不期望的问题！除非你真的需要，否则不建议修改代码。
- en: 'As an example, we can modify the Mojarra, the `jsf.js` code to see how the
    AJAX queue works. More precisely, to see how requests are added in queue and removed
    from queue depending on the `delay` value, perform the following steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以修改Mojarra的`jsf.js`代码，以了解AJAX队列是如何工作的。更确切地说，为了了解根据`delay`值，请求是如何添加到队列中和从队列中移除的，请执行以下步骤：
- en: 'In `jsf.js`, find the `enqueue` function. This function is called by JSF to
    add an AJAX request in queue:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jsf.js`中找到`enqueue`函数。这个函数被JSF调用，用于将AJAX请求添加到队列中：
- en: '[PRE53]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Modify this function to call a JavaScript custom function and pass to it the
    AJAX queue:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改这个函数以调用一个JavaScript自定义函数，并将AJAX队列传递给它：
- en: '[PRE54]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Do the same thing in the `dequeue` function. This function is called by JSF
    to remove an AJAX request from the queue:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dequeue`函数中也做同样的事情。这个函数被JSF调用，用于从队列中移除AJAX请求：
- en: '[PRE55]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Modify this function to call the same JavaScript custom function:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改这个函数以调用相同的JavaScript自定义函数：
- en: '[PRE56]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'At this point, a JavaScript custom function will be called every time an AJAX
    request is added/removed in/from the queue and the current queue will be passed
    in. Each entry in the queue is an AJAX request; therefore, we can loop the queue
    and extract information about each of them:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，每当AJAX请求被添加/移除到队列中时，都会调用一个JavaScript自定义函数，并将当前队列传递进去。队列中的每个条目都是一个AJAX请求；因此，我们可以遍历队列并提取有关每个请求的信息：
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Each request object has a suit of properties, which can be easily seen in the
    following code (this is extracted directly from the `jsf.js` source code):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求对象都有一套属性，你可以在以下代码中轻松看到（这是直接从`jsf.js`源代码中提取的）：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'All you have to do now is to trigger some AJAX requests and monitor the queue
    report generated in the `monitorQueue` function. As you can see in the following
    code, each button has a different `delay` value:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要做的就是触发一些AJAX请求，并监控`monitorQueue`函数生成的队列报告。正如你可以在以下代码中看到的那样，每个按钮都有一个不同的`delay`值：
- en: '[PRE59]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, all AJAX requests are referring the same server-side method,
    `ajaxAction`. This method can easily simulate some business logic by sleeping
    for a random number of milliseconds for each request, as shown in the following
    code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有AJAX请求都引用了同一个服务器端方法`ajaxAction`。这个方法可以通过为每个请求随机休眠一定数量的毫秒来轻松模拟一些业务逻辑，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Once you know how to monitor the queue content, you can go further and alter
    its content by queuing only certain requests, changing their priority of execution,
    accepting a limited number of entries in queue, and so on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道如何监控队列内容，你可以进一步修改它，例如通过仅排队某些请求，改变它们的执行优先级，接受队列中的有限条目等。
- en: The complete application can be found in the code bundle of this chapter, and
    is named `ch7_19`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以在本章的代码包中找到，命名为`ch7_19`。
- en: AJAX and the progress bar/indicator
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX和进度条/指示器
- en: While testing on `localhost`, AJAX requests seem pretty fast, but in real production
    environments they cannot be solved as fast because many aspects slow down the
    process (Internet connection speed, number of concurrent users, and so on).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地测试时，AJAX请求似乎非常快，但在实际的生产环境中，它们不能这么快地解决，因为许多方面都会减慢这个过程（互联网连接速度、并发用户数量等）。
- en: A common practice consists of using a progress bar/indicator that signals the
    user that requests are being processed and he/she should wait until the AJAX response
    is received and rendered accordingly. For example, PrimeFaces provides a cool
    determinate progress bar for upload tasks (`<p:fileUpload>`) and an indeterminate
    progress indicator for any other AJAX request (check `<p:ajaxStatus>`). RichFaces
    also have similar capabilities.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的做法是使用进度条/指示器来通知用户请求正在处理中，他/她应该等待直到收到AJAX响应并相应地渲染。例如，PrimeFaces为上传任务（`<p:fileUpload>`）提供了一个酷炫的确定进度条，并为任何其他AJAX请求提供了一个不确定的进度指示器（检查`<p:ajaxStatus>`）。RichFaces也有类似的功能。
- en: 'In the next chapter, you will see how to implement a progress bar for upload
    tasks. Without writing a custom component, such as `<p:ajaxStatus>`, we can easily
    implement a progress indicator using the `onevent` attribute, the `data` object,
    and a small piece of CSS, as shown in the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到如何实现上传任务的进度条。无需编写自定义组件，如`<p:ajaxStatus>`，我们可以通过使用`onevent`属性、`data`对象和一小段CSS，轻松实现进度指示器，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the following screenshot, you can see an example of running the complete
    application, named `ch7_20` in the code bundle of this chapter:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到本章代码包中名为`ch7_20`的完整应用程序的运行示例：
- en: '![AJAX and the progress bar/indicator](img/6466EN_07_12.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![AJAX和进度条/指示器](img/6466EN_07_12.jpg)'
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered the AJAX support in JSF 2.2 Core. Besides common
    tasks such as using `render`, `execute`, `listener`, and other attributes, you
    learned how to use AJAX with JSF 2.2 flow scope, how to use the JSF 2.2 `delay`
    attribute, and how to update input fields with AJAX after validation error, using
    the new JSF 2.2 `resetValues` attribute and the `<f:resetValues>` tag. Moreover,
    you saw how to use postback with AJAX, how to determine if a request is AJAX or
    non-AJAX, customize jsf.js, how to write a progress bar/indicator, how to create
    the **Cancel**/**Clear** buttons, how to monitor AJAX queue, and so on.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了JSF 2.2核心的AJAX支持。除了使用`render`、`execute`、`listener`和其他属性等常见任务外，您还学习了如何使用JSF
    2.2流程作用域进行AJAX，如何使用JSF 2.2的`delay`属性，以及如何在验证错误后使用新的JSF 2.2 `resetValues`属性和`<f:resetValues>`标签更新输入字段。此外，您还看到了如何使用AJAX进行回发，如何确定请求是AJAX还是非AJAX，自定义jsf.js，如何编写进度条/指示器，如何创建**取消**/**清除**按钮，如何监控AJAX队列等。
- en: In conclusion, JSF framework (including major extensions, such as PrimeFaces,
    OmniFaces, RichFaces, ICEfaces, and so on) has the most comprehensive and easy-to-use
    AJAX capabilities.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，JSF框架（包括主要扩展，如PrimeFaces、OmniFaces、RichFaces、ICEfaces等）具有最全面且易于使用的AJAX功能。
- en: See you in the next chapter, where we will cover the JSF 2.2 support for HTML5
    and the new upload mechanism.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您在下一章中，我们将介绍JSF 2.2对HTML5的支持以及新的上传机制。
