- en: Spring Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring最佳实践
- en: In the previous chapters, we discussed a number of Spring Projects--Spring MVC,
    Spring Boot, Spring Cloud, Spring Cloud Data Flow, and Spring Reactive. The challenges
    with enterprise application development do not end with choosing the right framework.
    One of the biggest challenges is the appropriate use of the frameworks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了一些Spring项目--Spring MVC、Spring Boot、Spring Cloud、Spring Cloud Data
    Flow和Spring Reactive。企业应用程序开发的挑战并不仅仅是选择正确的框架。最大的挑战之一是正确使用这些框架。
- en: 'In this chapter, we will discuss the best practices of enterprise application
    development with the Spring Framework. We talk about best practices related to
    the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论使用Spring框架进行企业应用程序开发的最佳实践。我们将讨论以下相关的最佳实践：
- en: The structure of enterprise applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业应用程序的结构
- en: Spring configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring配置
- en: Managing dependency versions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理依赖版本
- en: Exception handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Unit testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Session management
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理
- en: Caching
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Logging
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Maven standard directory layout
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven标准目录布局
- en: Maven defines a standard directory layout for all projects. Once all projects
    adopt this layout, it allows developers to switch between projects with ease.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Maven为所有项目定义了标准目录布局。一旦所有项目采用了这种布局，开发人员就可以轻松地在项目之间切换。
- en: 'The following screenshot shows an example directory layout for a web project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个Web项目的示例目录布局：
- en: '![](img/77e1c8cb-2c06-43ea-9210-4edd6be11c53.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77e1c8cb-2c06-43ea-9210-4edd6be11c53.png)'
- en: 'The following are some of the important standard directories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的标准目录：
- en: '`src/main/java`: All application-related source code'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/java`：所有与应用程序相关的源代码'
- en: '`src/main/resources`: All application-related resources--Spring context files,
    property files, logging configuration, and so on'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/resources`：所有与应用程序相关的资源--Spring上下文文件、属性文件、日志配置等'
- en: '`src/main/webapp`: All resources related to the web application--view files
    (JSP, view templates, static content, and so on)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/webapp`：与Web应用程序相关的所有资源--视图文件（JSP、视图模板、静态内容等）'
- en: '`src/test/java`: All unit testing code'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/test/java`：所有单元测试代码'
- en: '`src/test/resources`: All resources related to unit testing'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/test/resources`：所有与单元测试相关的资源'
- en: Layered architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层架构
- en: One of the core design aims is **Separation of Concerns** (**SoC**). One of
    the good practices, irrespective of the size of an application or microservice,
    is to create a layered architecture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注点分离**（SoC）是核心设计目标之一。无论应用程序或微服务的大小如何，创建分层架构都是一种良好的实践。'
- en: 'Each layer in a layered architecture has one concern, and it should implement
    it well. Layering the applications also helps in simplifying unit tests. The code
    in each layer can be completely unit tested by mocking out the following layer.
    The following figure shows some of the important layers in a typical microservice/web
    application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构中的每一层都有一个关注点，并且应该很好地实现它。分层应用程序还有助于简化单元测试。每个层中的代码可以通过模拟以下层来完全进行单元测试。以下图显示了典型微服务/
    Web应用程序中一些重要的层：
- en: '![](img/e19c9390-8813-4d6b-8ecb-9ae44c96be43.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e19c9390-8813-4d6b-8ecb-9ae44c96be43.png)'
- en: 'The layers shown in the previous diagram are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图表中显示的层如下：
- en: '**Presentation layer**: In a microservice, the presentation layer is where
    the Rest Controllers reside. In a typical web application, this layer would also
    contain the view-related content--JSPs, templates, and static content. The presentation
    layer talks to the services layer.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**呈现层**：在微服务中，呈现层是Rest控制器所在的地方。在典型的Web应用程序中，该层还包含与视图相关的内容--JSP、模板和静态内容。呈现层与服务层交互。'
- en: '**Services layer**: This acts a facade to the business layer. Different views--mobile,
    web, and tablets, this might need different kinds of data. The Services layer
    understands their needs and provides the right data based on the presentation
    layer.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务层**：这充当业务层的外观。不同的视图--移动、Web和平板电脑，可能需要不同类型的数据。服务层了解它们的需求，并根据呈现层提供正确的数据。'
- en: '**Business layer**: This is where all the business logic is. Another best practice
    is to the put most of the business logic into the Domain Model. The business layer
    talks to data layer to get the data and add business logic on top of it.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务层**：这是所有业务逻辑的地方。另一个最佳实践是将大部分业务逻辑放入领域模型中。业务层与数据层交互以获取数据，并在其上添加业务逻辑。'
- en: '**Persistence layer**: This takes care of retrieving and storing data to the
    database. This layer typically contains the JPA mappings or the JDBC code.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久层**：负责从数据库中检索和存储数据。该层通常包含JPA映射或JDBC代码。'
- en: Recommended practices
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐实践
- en: It is recommended that you have different Spring contexts for each of the layers.
    This helps in separating concerns of each layer. This also helps in unit testing
    code for the specific layer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 建议为每个层使用不同的Spring上下文。这有助于分离每个层的关注点。这也有助于针对特定层的单元测试代码。
- en: 'An application `context.xml` can be used to import contexts from all the layers.
    This can be context that is loaded when an application is run. Some of the possible
    spring context names are listed as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序`context.xml`可用于从所有层导入上下文。这可以是在应用程序运行时加载的上下文。以下是一些可能的Spring上下文名称：
- en: '`application-context.xml`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application-context.xml`'
- en: '`presentation-context.xml`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`presentation-context.xml`'
- en: '`services-context.xml`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services-context.xml`'
- en: '`business-context.xml`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`business-context.xml`'
- en: '`persistence-context.xml`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persistence-context.xml`'
- en: Separate API and impl for important layers
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要层的API和实现分离
- en: 'Another best practice to ensure loosely coupled application layers is to have
    separate API and implementation modules in each layer. The following screenshot
    shows the data layer with two submodules--API and impl:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保应用程序层之间松耦合的另一个最佳实践是在每个层中拥有单独的API和实现模块。以下截图显示了具有两个子模块--API和impl的数据层：
- en: '![](img/51c87159-b8f4-442c-ad92-f7a2f3e9774d.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51c87159-b8f4-442c-ad92-f7a2f3e9774d.png)'
- en: 'The data `pom.xml` defines two child modules:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据`pom.xml`定义了两个子模块：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `api` module is used to define the interface that the data layer offers.
    The `impl` module is used to create the implementation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`api`模块用于定义数据层提供的接口。`impl`模块用于创建实现。'
- en: The business layer should be built using the API from the data layer. The business
    layer should not depend on the implementation (the `impl` module) of the data
    layer. This helps in creating a clear separation between the two layers. The implementation
    of the data layer can be changed without affecting the business layer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层应该使用数据层的API进行构建。业务层不应该依赖于数据层的实现（`impl`模块）。这有助于在两个层之间创建清晰的分离。数据层的实现可以更改而不影响业务层。
- en: 'The following snippet shows an extract from the `pom.xml` file of the business
    layer:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了业务层`pom.xml`文件中的一部分内容：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While the `data-api` dependency has the default scope--compile--the `data-impl`
    dependency has a scope runtime. This ensures that the `data-impl` module is not
    available during the compilation of business layer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`data-api`依赖项具有默认范围--compile--，但`data-impl`依赖项具有运行时范围。这确保了在编译业务层时`data-impl`模块不可用。
- en: While separate `API` and `impl` can be implemented for all layers, it is recommended
    that you use it at least for the business layer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以为所有层实现单独的`API`和`impl`，但建议至少在业务层中使用。
- en: Exception handling
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'There are two types of exceptions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的异常：
- en: '**Checked exceptions**: When a service method throws this exception, all the
    consumer methods should either handle or throw the exception'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已检查的异常**：当服务方法抛出此异常时，所有使用者方法应该处理或抛出异常'
- en: '**Unchecked exceptions**: The consumer method is not required to handle or
    throw the exception thrown by the service method'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未经检查的异常**：使用者方法不需要处理或抛出服务方法抛出的异常'
- en: '`RuntimeException` and all its subclasses are unchecked exceptions. All other
    exceptions are checked exceptions.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeException`及其所有子类都是未经检查的异常。所有其他异常都是已检查的异常。'
- en: 'Checked exceptions can make your code cumbersome to read. Take a look at the
    following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 已检查的异常会使您的代码难以阅读。请看以下示例：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The declaration of the execute method in the `PreparedStatement` class is shown
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreparedStatement`类中execute方法的声明如下所示：'
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`SQLException` is a checked exception. So, any method that calls the `execute()`
    method should either handle the exception or throw it. In the preceding example,
    we are handling the exception using a `try-catch` block.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLException`是一个已检查的异常。因此，调用`execute()`方法的任何方法都应该处理异常或抛出异常。在前面的示例中，我们使用`try-catch`块处理异常。'
- en: Spring's approach to exception handling
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring对异常处理的方法
- en: 'Spring takes a different approach to this problem. It makes most of the exceptions
    unchecked. The code becomes simple:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Spring对这个问题采取了不同的方法。它使大多数异常变成了未经检查的。代码变得简单：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The update method in `JDBCTemplate` does not declare throwing any exception.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`JDBCTemplate`中的update方法不声明抛出任何异常。'
- en: The recommended approach
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐的方法
- en: We recommend an approach very similar to the one used by Spring Framework. When
    deciding what exceptions to throw from a method, always think about the consumer
    of the method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议采用与Spring框架类似的方法。在决定从方法中抛出什么异常时，始终要考虑方法的使用者。
- en: Can the consumer of the method do something about the exception?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的使用者是否能对异常做些什么？
- en: In the preceding example, if the execution of the query failed, the `consumer`
    method would not be able to do anything except show an error page to the user.
    In that kind of a scenario, we should not complicate things and force the consumer
    to handle the exception.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果查询执行失败，`consumer`方法将无法做任何事情，除了向用户显示错误页面。在这种情况下，我们不应该复杂化事情并强制使用者处理异常。
- en: 'We recommend the following approach to exception handling in applications:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在应用程序中采用以下异常处理方法：
- en: Think about the consumer. If the consumer of the method cannot do anything useful
    (except logging or showing an error page) about the exception, make it unchecked.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用者。如果方法的使用者除了记录日志或显示错误页面外无法做任何有用的事情，就将其设置为未经检查的异常。
- en: In the topmost layer, typically the presentation layer, have `catch all` exception
    handling to display an error page or to send an error response to the consumer.
    Refer to `@ControllerAdvice` in [Chapter 3,](fbc94f01-19b5-4ff2-8955-5bee445b71f5.xhtml)
    *Building Web Application with Spring MVC* for more details about implementing
    catch all exception handling.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最顶层，通常是表示层，要有`catch all`异常处理来显示错误页面或向使用者发送错误响应。有关实现`catch all`异常处理的更多详细信息，请参阅[第3章](fbc94f01-19b5-4ff2-8955-5bee445b71f5.xhtml)中的*使用Spring
    MVC构建Web应用程序*中的`@ControllerAdvice`。
- en: Keeping your Spring configuration light
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持Spring配置的轻量级
- en: One of the problems with Spring before annotations was the size of the application
    context XML files. Application context XML files ran into hundreds of lines (sometimes,
    even thousands of lines). However, with annotations, there is no need for such
    long application context XML files anymore.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在注解之前的一个问题是应用程序上下文XML文件的大小。应用程序上下文XML文件有时会有数百行（有时甚至有数千行）。然而，使用注解后，就不再需要这样长的应用程序上下文XML文件了。
- en: We recommend that you use component scans to locate and autowire the beans instead
    of manually wiring the beans in XML files. Keep your application context XML files
    very small. We recommend that you use Java `@Configuration` wherever some framework-related
    configuration is needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用组件扫描来定位和自动装配bean，而不是在XML文件中手动装配bean。保持应用程序上下文XML文件非常小。我们建议您在需要一些与框架相关的配置时使用Java
    `@Configuration`。
- en: Using the basePackageClasses attribute in ComponentScan
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ComponentScan中使用basePackageClasses属性
- en: 'When using component scan, we recommend that you use the `basePackageClasses`
    attribute. The following snippet shows an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用组件扫描时，建议使用`basePackageClasses`属性。以下片段显示了一个示例：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `basePackageClasses` attribute is the type-safe alternative to `basePackages()`
    in order to specify the packages to scan for the annotated components. The package
    of each specified class will be scanned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`basePackageClasses`属性是`basePackages()`的类型安全替代，用于指定要扫描注释组件的包。将扫描每个指定类的包。'
- en: This will ensure that even when the package is renamed or moved, the component
    scan would work as expected.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保即使包被重命名或移动，组件扫描也能正常工作。
- en: Not using version numbers in schema references
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模式引用中不使用版本号
- en: 'Spring can recognize the correct version of the schemas from the dependencies.
    Hence, it is not necessary to use version numbers in the schema references anymore.
    The class snippet shows an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Spring可以从依赖项中识别出正确的模式版本。因此，在模式引用中不再需要使用版本号。类片段显示了一个例子：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Preferring constructor injection over setter injection for mandatory dependencies
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先使用构造函数注入而不是setter注入进行强制依赖项
- en: 'There are two kinds of dependencies for beans:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: bean有两种依赖项：
- en: '**Mandatory dependencies**: These are dependencies that you want to be available
    for the bean. If the dependency is not available, you would want the context to
    fail loading up.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制依赖项**：这些是您希望对bean可用的依赖项。如果依赖项不可用，您希望上下文加载失败。'
- en: '**Optional dependencies**: These are dependencies that are optional. They are
    not always available. It''s fine to load the context even if these are not available.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选依赖项**：这些是可选的依赖项。它们并不总是可用。即使这些依赖项不可用，加载上下文也是可以的。'
- en: 'We recommend that you wire mandatory dependencies using constructor injection
    instead of setter injection. This would ensure that the context would fail to
    load if the mandatory dependency is missing. The following snippet shows an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用构造函数注入而不是setter注入来连接强制依赖项。这将确保如果缺少强制依赖项，则上下文将无法加载。以下片段显示了一个例子：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An extract from the Spring documentation ([https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-constructor-injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-constructor-injection))
    is presented as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Spring文档的摘录（[https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-constructor-injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-constructor-injection)）如下所示：
- en: The Spring team generally advocates constructor injection as it enables one
    to implement application components as immutable objects and ensure that the required
    dependencies are not null. Furthermore, constructor-injected components are always
    returned to the client (calling) code in a fully initialized state. As a side
    note, a large number of constructor arguments is a bad code smell, implying that
    the class likely has too many responsibilities and should be refactored to better
    address proper Separation of Concerns. Setter injection should primarily only
    be used for optional dependencies that can be assigned reasonable default values
    within the class. Otherwise, not-null checks must be performed everywhere the
    code uses the dependency. One benefit of setter injection is that setter methods
    make objects of that class amenable to reconfiguration or re-injection later.
    Management through [JMX MBeans](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#jmx)
    is therefore a compelling use case for setter injection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Spring团队通常倡导构造函数注入，因为它使我们能够将应用程序组件实现为不可变对象，并确保所需的依赖项不为空。此外，构造函数注入的组件始终以完全初始化的状态返回给客户端（调用）代码。另外，大量的构造函数参数是糟糕的代码味道，意味着该类可能具有太多的责任，应该进行重构以更好地处理关注点的分离。主要应该仅将setter注入用于可以在类内分配合理默认值的可选依赖项。否则，代码使用依赖项的地方必须执行非空检查。setter注入的一个好处是setter方法使该类的对象能够在以后重新配置或重新注入。因此，通过[JMX
    MBeans](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#jmx)进行管理是setter注入的一个引人注目的用例。
- en: Managing dependency versions for Spring Projects
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Spring项目管理依赖项版本
- en: 'If you are using Spring Boot, then the simplest option to manage dependency
    versions is to use `spring-boot-starter-parent` as the parent POM. This is the
    option we used in all our project examples in this book:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Spring Boot，则管理依赖项版本的最简单选项是将`spring-boot-starter-parent`用作父POM。这是我们在本书中所有项目示例中使用的选项：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Versions of more than 200 dependencies are managed by `spring-boot-starter-parent`.
    Before a Spring Boot release, it is ensured that all the versions of these dependencies
    play well together. The following are some of the dependency versions that are
    managed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-parent`管理了200多个依赖项的版本。在Spring Boot发布之前，确保这些依赖项的所有版本能够很好地协同工作。以下是一些受管依赖项的版本：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is recommended that you do not override any of the versions of the managed
    dependencies in the project POM file. This ensures that when we upgrade our Spring
    Boot version, we would get the latest version upgrades of all the dependencies.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您不要覆盖项目POM文件中受管依赖项的任何版本。这样可以确保当我们升级Spring Boot版本时，我们将获得所有依赖项的最新版本升级。
- en: 'Sometimes, you have to use a custom corporate POM as a parent POM. The following
    snippet shows how to manage dependency versions in this scenario:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您必须使用自定义公司POM作为父POM。以下片段显示了如何在这种情况下管理依赖项版本：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are not using Spring Boot, then you can manage all basic Spring dependencies
    using Spring BOM:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用Spring Boot，则可以使用Spring BOM管理所有基本的Spring依赖项：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Unit testing
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: While the basic aim of unit testing is to find defects, approaches for writing
    unit tests for each of the layers are different. In this section, we will take
    a quick look at unit testing examples and best practices for different layers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试的基本目的是查找缺陷，但各层编写单元测试的方法是不同的。在本节中，我们将快速查看各层的单元测试示例和最佳实践。
- en: The business layer
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务层
- en: When writing tests for the business layer, we recommend that you avoid using
    Spring Framework in the unit tests. This will ensure that your tests are framework
    independent and will run faster.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在为业务层编写测试时，我们建议您避免在单元测试中使用Spring框架。这将确保您的测试是框架无关的，并且运行速度更快。
- en: 'The following is an example of a unit test written without using Spring Framework:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在不使用Spring框架的情况下编写的单元测试的示例：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Spring Framework is used to wire dependencies in the running application. However,
    in your unit tests, using the `@InjectMocks` Mockito annotation in combination
    with `@Mock` is the best option.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架用于在运行应用程序中连接依赖关系。然而，在您的单元测试中，使用`@InjectMocks` Mockito注解与`@Mock`结合使用是最佳选择。
- en: Web layer
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web层
- en: Unit tests for web layers involve testing the Controllers--REST and otherwise.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Web层的单元测试涉及测试控制器--REST和其他。
- en: 'We recommend the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议以下操作：
- en: Using Mock MVC for web layers built on Spring MVC
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建在Spring MVC上的Web层中使用Mock MVC
- en: Jersey Test Framework is a good choice for REST Services built using Jersey
    and JAX-RS
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jersey测试框架是使用Jersey和JAX-RS构建的REST服务的不错选择
- en: 'A quick example of setting up the Mock MVC framework is shown as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Mock MVC框架的一个快速示例如下所示：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using `@WebMvcTest` will allow us to use autowire `MockMvc` and execute web
    requests. A great feature of `@WebMVCTest` is that it only instantiates the controller
    components. All other Spring components are expected to be mocked and can be autowired
    using `@MockBean`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@WebMvcTest`将允许我们使用自动装配`MockMvc`并执行Web请求。`@WebMVCTest`的一个很棒的特性是它只实例化控制器组件。所有其他Spring组件都预期被模拟，并可以使用`@MockBean`进行自动装配。
- en: The data layer
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层
- en: 'Spring Boot offers a simple annotation `@DataJpaTest` for data layer unit tests.
    A simple example is listed as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为数据层单元测试提供了一个简单的注解`@DataJpaTest`。一个简单的示例如下所示：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`@DataJpaTest` may also inject a `TestEntityManager` bean, which provides an
    alternative to the standard JPA `entityManager` specifically designed for tests.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DataJpaTest`也可能注入一个`TestEntityManager` bean，它提供了一个专门为测试设计的替代标准JPA `entityManager`。'
- en: If you want to use `TestEntityManager` outside of `@DataJpaTest`, you can also
    use the `@AutoConfigureTestEntityManager` annotation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在`@DataJpaTest`之外使用`TestEntityManager`，您也可以使用`@AutoConfigureTestEntityManager`注解。
- en: Data JPA tests are run against an embedded database by default. This ensures
    that tests can be run as many times as you would want without affecting the database.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数据JPA测试默认针对嵌入式数据库运行。这确保了测试可以运行多次而不影响数据库。
- en: Other best practices
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他最佳实践
- en: We recommend that you follow the Test-Driven Development (TDD) approach to develop
    code. Writing tests before code results in a clear understanding of the complexity
    and dependencies of the code unit being written. In my experience, this leads
    to better design and better code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您遵循测试驱动开发（TDD）的方法来开发代码。在编写代码之前编写测试可以清楚地了解正在编写的代码单元的复杂性和依赖关系。根据我的经验，这会导致更好的设计和更好的代码。
- en: The best projects that I worked on recognize that unit tests are more important
    than the source code. Applications evolve. Architectures of a few years back are
    legacy today. By having great unit tests, we can continuously refactor and improve
    our projects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与的最好的项目认识到单元测试比源代码更重要。应用程序会不断发展。几年前的架构今天已经是遗留的。通过拥有出色的单元测试，我们可以不断重构和改进我们的项目。
- en: 'A few guidelines are listed as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指导方针列如下：
- en: Unit tests should be readable. Other developers should be able to understand
    the test in less than 15 seconds. Aim for tests that serve as documentation for
    code.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该易读。其他开发人员应该能够在不到15秒的时间内理解测试。力求编写作为代码文档的测试。
- en: Unit tests should fail only when there is a defect in the production code. This
    seems simple. However, if unit tests use external data, they can fail when external
    data changes. Over a period of time, developers lose confidence in unit tests.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试只有在生产代码中存在缺陷时才应该失败。这似乎很简单。然而，如果单元测试使用外部数据，它们可能会在外部数据更改时失败。随着时间的推移，开发人员对单元测试失去信心。
- en: Unit tests should run fast. Slow tests are run infrequently, losing all benefits
    associated with unit testing.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该运行得很快。慢测试很少运行，失去了单元测试的所有好处。
- en: Unit tests should be run as part of Continuous Integration. As soon as there
    is a commit in the version control, the build (with unit tests) should run and
    notify developers in case of failures.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该作为持续集成的一部分运行。一旦在版本控制中提交，构建（包括单元测试）应该运行并在失败时通知开发人员。
- en: Integration testing
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: While unit tests test a specific layer, integration tests are used to test the
    code in multiple layers. To keep the tests repeatable, we recommend that you use
    an embedded database instead of a real database for integration tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试测试特定层，但集成测试用于测试多个层中的代码。为了保持测试的可重复性，我们建议您在集成测试中使用嵌入式数据库而不是真实数据库。
- en: We recommend that you create a separate profile for integration tests using
    an embedded database. This ensures that each developer has their own database
    to run the tests against. Let's look at few simple examples.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您为使用嵌入式数据库的集成测试创建一个单独的配置文件。这样可以确保每个开发人员都有自己的数据库来运行测试。让我们看几个简单的例子。
- en: 'The `application.properties` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.properties`文件：'
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `application-production.properties` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`application-production.properties`文件：'
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `application-integration-test.properties` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`application-integration-test.properties`文件：'
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We would need to include the H2 driver dependency in the test scope, as shown
    in the following snippet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在测试范围内包含H2驱动程序依赖项，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'An example integration test using the `@ActiveProfiles("integration-test")`
    is shown as follows. The integration tests will now run using an embedded database:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@ActiveProfiles("integration-test")`的集成测试示例如下所示。集成测试现在将使用嵌入式数据库运行：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Integration tests are critical to be able to continuously deliver working software.
    The features Spring Boot provides make it easy to implement integration tests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试对于能够持续交付可工作软件至关重要。Spring Boot提供的功能使得实现集成测试变得容易。
- en: Spring Session
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Session
- en: Managing the session state is one of the important challenges in distributing
    and scaling web applications. HTTP is a stateless protocol. The state of the user
    interactions with web applications is typically managed in HttpSession.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 管理会话状态是分发和扩展Web应用程序中的重要挑战之一。HTTP是一种无状态协议。用户与Web应用程序的交互状态通常在HttpSession中管理。
- en: It is important to have as little data as possible in a session. Focus on identifying
    and removing data that is not needed in the session.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在会话中尽可能少地保存数据是很重要的。专注于识别和删除会话中不需要的数据。
- en: 'Consider a distributed application with three instances, as shown here. Each
    of these instances has its own local session copy:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有三个实例的分布式应用程序，如下所示。每个实例都有自己的本地会话副本：
- en: '![](img/78a17650-50c7-4644-b871-65f467952a99.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78a17650-50c7-4644-b871-65f467952a99.png)'
- en: Imagine a user is being currently served from `App Instance 1`. Imagine if `App
    Instance 1` goes down and the load balancer sends the user to `App Instance 2`.
    `App Instance 2` is not aware of the session state that was available with `App
    Instance 1`. The user has to log in and start off again. That's not a good user
    experience.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，用户当前正在从`App Instance 1`提供服务。假设`App Instance 1`关闭，负载均衡器将用户发送到`App Instance
    2`。`App Instance 2`不知道`App Instance 1`中可用的会话状态。用户必须重新登录并重新开始。这不是一个良好的用户体验。
- en: 'Spring Session provides features to externalize your session store. Instead
    of using the local HttpSession, Spring Session provides alternatives to store
    the session state to different data stores:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Session提供了将会话存储外部化的功能。Spring Session提供了将会话状态存储到不同数据存储的替代方法，而不是使用本地HttpSession：
- en: '![](img/1befe8b9-05f2-45a6-8a0a-fb71a5e8e655.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1befe8b9-05f2-45a6-8a0a-fb71a5e8e655.png)'
- en: Spring Session also provides a clear Separation of Concerns. The application
    code remains the same irrespective of the session data store being used. We can
    switch between session data stores through configuration.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Session还提供了明确的关注点分离。无论使用哪种会话数据存储，应用程序代码都保持不变。我们可以通过配置在会话数据存储之间切换。
- en: Example
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: In this example, we will connect Spring Session to use a Redis session store.
    While the code to put data into session remains the same, the data would be stored
    to Redis instead of HTTP Session.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将连接Spring Session以使用Redis会话存储。虽然将数据放入会话的代码保持不变，但数据将存储到Redis而不是HTTP会话中。
- en: 'There are three simple steps involved:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及三个简单的步骤：
- en: Add dependencies for Spring Session.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Spring Session的依赖项。
- en: Configure Filter to replace HttpSession with Spring Session.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置过滤器以用Spring Session替换HttpSession。
- en: Enable filtering for Tomcat by extending `AbstractHttpSessionApplicationInitializer`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展`AbstractHttpSessionApplicationInitializer`启用Tomcat的过滤。
- en: Adding dependencies for Spring Session
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Spring Session的依赖项
- en: 'The dependencies needed for Spring Session connecting to a Redis store are
    `spring-session-data-redis` and `lettuce-core`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Redis存储的Spring Session所需的依赖项是`spring-session-data-redis`和`lettuce-core`：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Configuring Filter to replacing HttpSession with Spring Session
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置过滤器以用Spring Session替换HttpSession
- en: 'The following configuration creates a Servlet Filter to replace `HTTPSession`
    with a Session implementation from Spring Session--Redis Data Store in this example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置创建了一个Servlet过滤器，用Spring Session中的会话实现替换`HTTPSession`--在此示例中为Redis数据存储：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Enabling filtering for Tomcat by extending AbstractHttpSessionApplicationInitializer
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过扩展AbstractHttpSessionApplicationInitializer启用Tomcat的过滤
- en: 'In the previous step, Servlet Filter needs to be enabled on every request to
    the Servlet Container (Tomcat). The following snippet shows the code involved:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中，需要在每个请求到Servlet容器（Tomcat）上启用Servlet过滤器。以下代码段显示了涉及的代码：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That''s all the configuration you would need. The great thing with Spring Session
    is the fact that your application code talking to `HTTPSession` does not change!
    You can continue using the HttpSession interface, but in the background, Spring
    Session ensures that the session data is stored to an external data store - Redis
    in this example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要的所有配置。Spring Session的好处在于，您的应用程序代码与`HTTPSession`通信不会改变！您可以继续使用HttpSession接口，但在后台，Spring
    Session确保会话数据存储到外部数据存储--在此示例中为Redis：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Spring Session provides simple options to connect to an external session store.
    Backing up your session on an external session store ensures that your user can
    fail over even when one of your application instances goes down.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Session提供了连接到外部会话存储的简单选项。在外部会话存储上备份会话可以确保用户即使在一个应用程序实例关闭时也能故障转移。
- en: Caching
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching is essential in order to build a performant application. You would not
    want to hit the external service or the database all the time. Data that does
    not change frequently can be cached.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是构建高性能应用程序的必要条件。您不希望一直访问外部服务或数据库。不经常更改的数据可以被缓存。
- en: 'Spring provides transparent mechanisms to connect and use a Cache. The following
    steps are involved in enabling a cache on an application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了透明的机制来连接和使用缓存。启用应用程序缓存涉及以下步骤：
- en: Add the Spring Boot Starter Cache dependency.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Spring Boot Starter Cache依赖项。
- en: Add caching annotations.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加缓存注释。
- en: Let's discuss these in detail.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这些。
- en: Adding the Spring Boot Starter Cache dependency
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Spring Boot Starter Cache依赖项
- en: 'The following snippet shows the `spring-boot-starter-cache` dependency. Itt
    brings in all the dependencies and auto-configuration needed to configure a cache:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段显示了`spring-boot-starter-cache`依赖项。它引入了配置缓存所需的所有依赖项和自动配置：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding caching annotations
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加缓存注释
- en: 'The next step is to add the caching annotations, indicating when something
    needs to be added or removed from the cache. The following snippet shows an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加缓存注释，指示何时需要向缓存中添加或删除内容。以下代码段显示了一个示例：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Some of the annotations that are supported are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的一些注释如下：
- en: '`Cacheable`: Used to cache the result of a method invocation. The default implementation
    constructs the key based on the parameters passed to the method. The method will
    not be invoked if the value is found in the cache.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存：用于缓存方法调用的结果。默认实现根据传递给方法的参数构造键。如果在缓存中找到值，则不会调用该方法。
- en: '`CachePut`: Similar to `@Cacheable`. A significant difference is that the method
    is always invoked and the result is put in a cache.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CachePut`：类似于 `@Cacheable`。一个重要的区别是该方法总是被调用，并且结果被放入缓存中。'
- en: '`CacheEvict`: Triggers an evict for a specific element from the cache. Typically
    done when an element is deleted or updated.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CacheEvict`：触发从缓存中清除特定元素。通常在元素被删除或更新时执行。'
- en: 'A few other important things to note about Spring Caching are as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Spring缓存的另外一些重要事项如下：
- en: The default cache used is ConcurrentHashMap
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认使用的缓存是ConcurrentHashMap
- en: The Spring Caching abstraction is JSR-107-compliant
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring缓存抽象符合JSR-107标准
- en: Other caches that can be auto-configured include EhCache, Redis, and Hazelcast
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以自动配置的其他缓存包括EhCache、Redis和Hazelcast
- en: Logging
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Spring and Spring Boot depend on the Commons Logging API. They are not dependent
    on any other logging frameworks. Spring Boot provides starters to simplify the
    configuration of specific logging frameworks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Spring和Spring Boot依赖于Commons Logging API。它们不依赖于任何其他日志记录框架。Spring Boot提供了starter来简化特定日志记录框架的配置。
- en: Logback
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logback
- en: 'Starter `spring-boot-starter-logging` is all that you need to use the Logback
    framework. This dependency is the default logging included in most of the starters,
    including `spring-boot-starter-web`. The dependency is shown as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Starter `spring-boot-starter-logging` 是使用Logback框架所需的全部内容。这个依赖是大多数starter中包含的默认日志记录。包括
    `spring-boot-starter-web`。依赖关系如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following snippet shows logback and related dependencies included in `spring-boot-starter-logging`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了 `spring-boot-starter-logging` 中包含的logback和相关依赖项：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Log4j2
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Log4j2
- en: 'To use Log4j2, we need to use the starter `spring-boot-starter-log4j2`. When
    we use starters such as `spring-boot-starter-web`, we need to ensure that we exclude
    the dependency in `spring-boot-starter-logging`. The following snippet shows the
    details:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Log4j2，我们需要使用starter `spring-boot-starter-log4j2`。当我们使用 `spring-boot-starter-web`
    等starter时，我们需要确保在 `spring-boot-starter-logging` 中排除该依赖项。以下片段显示了详细信息：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following snippet shows the dependencies used in the `spring-boot-starter-log4j2`
    starter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了 `spring-boot-starter-log4j2` starter 中使用的依赖项：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Framework independent configuration
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架独立配置
- en: 'Irrespective of the logging framework used, Spring Boot allows a few basic
    configuration options in application properties. A few examples are shown as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种日志记录框架，Spring Boot都允许在应用程序属性中进行一些基本配置选项。一些示例如下所示：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the age of microservices, irrespective of the framework you use for logging,
    we recommend that you log to the console (instead of a file) and use a centralized
    logging store tool to capture logs from all microservice instances.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务时代，无论您使用哪种框架进行日志记录，我们建议您将日志记录到控制台（而不是文件），并使用集中式日志存储工具来捕获所有微服务实例的日志。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some of the best practices in developing Spring-based
    applications. We covered best practices in structuring our projects--layering,
    following the Maven standard directory layout, and using `api` and implementation
    modules. We also discussed how to keep our Spring configuration to a minimum.
    We looked at best practices related to logging, caching, session management, and
    exception handling.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了开发基于Spring的应用程序的一些最佳实践。我们涵盖了在项目结构化方面的最佳实践--分层、遵循Maven标准目录布局，并使用`api`和implementation模块。我们还讨论了如何将Spring配置保持最小化的最佳实践。我们还讨论了与日志记录、缓存、会话管理和异常处理相关的最佳实践。
