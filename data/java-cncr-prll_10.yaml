- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Synchronizing Java’s Concurrency with Cloud Auto-Scaling Dynamics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步Java的并发与云自动扩展动态
- en: In the era of cloud computing, **auto-scaling** has become a crucial strategy
    for managing resource utilization and ensuring optimal application performance.
    As Java remains a prominent language for developing enterprise applications, understanding
    how to effectively synchronize Java’s concurrency models with cloud auto-scaling
    dynamics is essential.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算时代，**自动扩展**已成为管理资源利用率和确保应用性能最优的关键策略。鉴于Java仍然是开发企业应用的主要语言，了解如何有效地同步Java的并发模型与云自动扩展动态至关重要。
- en: This chapter delves into the intricacies of leveraging Java’s concurrency tools
    and best practices to build scalable and efficient applications in cloud environments.
    Through practical examples and real-world case studies, you will learn how to
    design and optimize Java applications for auto-scaling, implement monitoring and
    alerting mechanisms, and integrate with popular cloud-native tools and services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了利用Java的并发工具和最佳实践在云环境中构建可扩展和高效应用的复杂性。通过实际示例和真实案例研究，您将学习如何设计和优化Java应用程序以实现自动扩展，实施监控和警报机制，以及与流行的云原生工具和服务集成。
- en: The first practical application explored in this chapter is the development
    of a Kubernetes-based, auto-scaling Java application that simulates an e-commerce
    order processing service. Building upon this foundation, the chapter then introduces
    a second practical example focused on creating a serverless real-time analytics
    pipeline using Java and AWS services.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先探讨的实际应用是开发一个基于Kubernetes的自动扩展Java应用程序，该应用程序模拟电子商务订单处理服务。在此基础上，本章接着介绍第二个实际示例，专注于使用Java和AWS服务创建一个无服务器实时分析管道。
- en: By the end of this chapter, readers will have a comprehensive understanding
    of how to harness the power of Java’s concurrency models to build robust, scalable,
    and cost-effective applications that can seamlessly adapt to the dynamic nature
    of cloud environments. They will be equipped with the knowledge and skills to
    tackle the challenges of auto-scaling and ensure optimal performance and resource
    utilization in their Java-based systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，读者将全面了解如何利用Java的并发模型构建强大、可扩展且成本效益高的应用，这些应用可以无缝适应云环境的动态特性。他们将具备解决自动扩展挑战的知识和技能，以确保Java系统的最佳性能和资源利用率。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Fundamentals of cloud auto-scaling – mechanisms and motivations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云自动扩展的基本原理 – 机制和动机
- en: Java’s concurrency models – alignment with scaling strategies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的并发模型 – 与扩展策略的一致性
- en: Optimizing Java applications for cloud scalability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化Java应用程序以实现云可扩展性
- en: Monitoring and managing Java processes during auto-scaling events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自动扩展事件期间监控和管理Java进程
- en: Real-world case studies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实案例研究
- en: Real-world deployments of Java-based systems in auto-scaling environments
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自动扩展环境中基于Java的系统实际部署
- en: Advanced topics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级主题
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You’ll need the following installed to follow along with this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装以下内容才能跟随本章内容：
- en: '**Docker**: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)'
- en: '**AWS Command Line Interface (****CLI)**: [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS命令行界面 (CLI)**: [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)'
- en: '**AWS Serverless Application** **Model (SAM) CLI**: Installing the AWS SAM
    CLI - AWS Serverless Application Model ([amazon.com](http://amazon.com))'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS无服务器应用程序模型 (SAM) CLI**：安装AWS SAM CLI - AWS无服务器应用程序模型 ([amazon.com](http://amazon.com))'
- en: '**Kubernetes CLI (****kubectl)**: [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes CLI (kubectl)**: [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)'
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Fundamentals of cloud auto-scaling – mechanisms and motivations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云自动扩展的基本原理 – 机制和动机
- en: In the ever-evolving landscape of cloud computing, auto-scaling has emerged
    as a pivotal feature, enabling applications to dynamically adjust their resources
    to meet varying demands. This section delves into the core concepts and advantages
    of cloud auto-scaling, providing a comprehensive understanding of how it enhances
    scalability, cost-effectiveness, and resource utilization.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算不断演变的领域中，自动扩展已成为一个关键特性，使应用程序能够动态调整其资源以满足不断变化的需求。本节深入探讨了云自动扩展的核心概念和优势，全面了解它是如何增强可扩展性、成本效益和资源利用率的。
- en: Definition and core concepts
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和核心概念
- en: Cloud auto-scaling automatically adjusts the amount of computational resources
    in a server farm based on CPU, memory, and network usage, ensuring optimal performance
    and cost efficiency. **Dynamic resource allocation** is a key concept where resources
    are added or removed based on real-time demand. Scaling can be done vertically
    (scaling up/down) by adjusting the capacity of existing instances, or horizontally
    (scaling out/in) by adding or removing instances to handle changes in workload.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 云自动扩展会根据CPU、内存和网络使用情况自动调整服务器农场中的计算资源量，确保最佳性能和成本效率。**动态资源分配**是一个关键概念，其中资源根据实时需求进行添加或移除。扩展可以通过调整现有实例的容量来实现垂直扩展（向上/向下扩展），或者通过添加或移除实例来处理工作负载的变化，实现水平扩展（向外/向内扩展）。
- en: Auto-scaling relies on predefined metrics and threshold-based triggers to initiate
    scaling actions. Load balancing distributes traffic evenly across instances for
    improved performance and reliability. Auto-scaling policies define rules for when
    and how scaling actions occur, either reactively or proactively. Continuous monitoring
    using tools such as AWS CloudWatch, Google Cloud Monitoring, and Azure Monitor
    is crucial for triggering scaling actions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展依赖于预定义的指标和基于阈值的触发器来启动扩展操作。负载均衡将流量均匀地分配到实例上，以改善性能和可靠性。自动扩展策略定义了何时以及如何进行扩展操作，可以是反应性的或主动的。使用AWS
    CloudWatch、Google Cloud Monitoring和Azure Monitor等工具进行持续监控对于触发扩展操作至关重要。
- en: For example, an e-commerce website experiencing a surge in traffic during a
    holiday sale can leverage auto-scaling to automatically launch additional server
    instances to handle the increased load and prevent slowdowns or crashes. When
    the sale ends and traffic decreases, the extra instances are terminated to save
    costs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在假日促销期间，一个电子商务网站可能会经历流量激增，可以利用自动扩展自动启动额外的服务器实例来处理增加的负载，防止减速或崩溃。当促销结束时，流量减少，额外的实例将被终止以节省成本。
- en: Advantages of cloud auto-scaling
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云自动扩展的优势
- en: Cloud auto-scaling offers several benefits that enhance the performance, efficiency,
    and cost effectiveness of applications. Scalability is a key advantage, providing
    the ability to dynamically adjust resource allocation in response to changing
    demand through elasticity. Elasticity enables applications to adapt by automatically
    adjusting allocated resources (scaling up/down) and the number of instances (scaling
    out/in) based on predefined metrics and thresholds, ensuring optimal performance,
    cost efficiency, and resource utilization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 云自动扩展提供了几个增强应用程序性能、效率和成本效益的益处。可扩展性是一个关键优势，它通过弹性提供动态调整资源分配的能力，以应对不断变化的需求。弹性使应用程序能够通过自动调整分配的资源（向上/向下扩展）和实例数量（向外/向内扩展）来适应，根据预定义的指标和阈值确保最佳性能、成本效益和资源利用率。
- en: Auto-scaling promotes cost effectiveness through a pay-as-you-go model, where
    resources are only allocated as needed, avoiding costs associated with over-provisioning.
    Automation reduces the need for manual monitoring and scaling, lowering operational
    overhead and labor costs. Enhanced resource utilization ensures resources are
    used efficiently, reducing waste, while integrated load balancing distributes
    traffic evenly across instances, preventing bottlenecks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展通过按需付费的模式促进成本效益，其中资源仅在需要时分配，避免了过度配置相关的成本。自动化减少了手动监控和扩展的需求，降低了运营成本和人力成本。增强的资源利用率确保资源得到有效利用，减少浪费，而集成的负载均衡则将流量均匀地分配到实例上，防止瓶颈。
- en: Auto-scaling improves reliability and availability by ensuring there are always
    enough instances to handle the load, reducing the risk of downtime. It can also
    improve an application’s resilience to localized failures or outages by automatically
    scaling in different regions or availability zones. Flexibility and agility enable
    applications to quickly adapt to changes in workload or user demand, crucial for
    applications with unpredictable traffic patterns, while developers and IT teams
    can focus on core business activities thanks to auto-scaling’s automated nature.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展通过确保始终有足够的实例来处理负载，从而提高可靠性和可用性，降低停机风险。它还可以通过在不同地区或可用区自动扩展来提高应用程序对局部故障或中断的弹性。灵活性和敏捷性使应用程序能够快速适应工作负载或用户需求的变化，这对于具有不可预测流量模式的应用程序至关重要，而开发人员和IT团队则可以由于自动扩展的自动化特性而专注于核心业务活动。
- en: For example, a start-up launching a suddenly popular mobile app can leverage
    cloud auto-scaling to handle the influx of users without performance degradation,
    while only incurring costs proportional to actual resource usage. The ability
    to scale up (vertically) and scale out (horizontally) ensures optimal performance
    and cost efficiency. By leveraging cloud auto-scaling, businesses can ensure their
    applications perform optimally, are cost efficient, and can quickly adapt to changing
    demands, which is essential in today’s fast-paced digital landscape.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一家初创公司推出一款突然流行的移动应用时，可以利用云自动扩展来处理用户激增，而不会降低性能，同时只产生与实际资源使用成比例的成本。向上扩展（垂直扩展）和向外扩展（水平扩展）的能力确保了最佳性能和成本效率。通过利用云自动扩展，企业可以确保其应用程序性能最佳、成本效益高，并能快速适应不断变化的需求，这在当今快节奏的数字景观中至关重要。
- en: Triggers and conditions for auto-scaling
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动扩展的触发器和条件
- en: Auto-scaling in a cloud environment is driven by various triggers and conditions
    that ensure applications maintain optimal performance and resource utilization.
    Understanding these triggers helps in setting up effective auto-scaling policies
    that respond appropriately to changes in demand.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 云环境中的自动扩展是由各种触发器和条件驱动的，确保应用程序保持最佳性能和资源利用率。了解这些触发器有助于设置有效的自动扩展策略，以便适当地响应需求的变化。
- en: 'Common triggers for auto-scaling are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展的常见触发器如下：
- en: '**CPU utilization**:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU利用率**:'
- en: '**High CPU usage**: When CPU usage exceeds a certain threshold (e.g., 70-80%)
    over a specified period, additional instances are launched to handle the increased
    load'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU使用率高**：当CPU使用率在指定时间段内超过一定阈值（例如，70-80%）时，会启动额外的实例来处理增加的负载'
- en: '**Low CPU usage**: When CPU usage drops below a lower threshold (e.g., 20-30%),
    instances are terminated to save costs'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU使用率低**：当CPU使用率低于较低阈值（例如，20-30%）时，实例将被终止以节省成本'
- en: '**Memory utilization**:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存利用率**：'
- en: '**High memory usage**: Similar to CPU usage, high memory utilization triggers
    the addition of more instances to ensure the application remains responsive'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用率高**：与CPU使用率类似，高内存利用率会触发添加更多实例，以确保应用程序保持响应'
- en: '**Low memory usage**: If memory usage is consistently low, reducing the number
    of instances helps optimize costs'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用率低**：如果内存使用率持续较低，减少实例数量有助于优化成本'
- en: '**Network traffic**:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络流量**：'
- en: '**Inbound/outbound traffic**: High levels of incoming or outgoing network traffic
    can trigger scaling actions to ensure sufficient bandwidth and processing power'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入站/出站流量**：高水平的入站或出站网络流量可以触发扩展操作，以确保足够的带宽和处理能力'
- en: '**Latency**: Increased network latency can also be a trigger, prompting the
    system to scale out to maintain low response times'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：增加的网络延迟也可以是一个触发器，促使系统扩展以保持低响应时间'
- en: '**Disk** **input/output (I/O)**:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘** **输入/输出（I/O）**：'
- en: '**High disk I/O operations**: Intensive read/write operations to disk can necessitate
    scaling out to distribute the load across more instances'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高磁盘I/O操作**：对磁盘的密集读写操作可能需要扩展到更多实例以分散负载'
- en: '**Disk space utilization**: Scaling actions can be triggered if available disk
    space is running low, ensuring that the application does not run into storage
    issues'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘空间利用率**：如果可用磁盘空间不足，可能会触发扩展操作，以确保应用程序不会遇到存储问题'
- en: '**Custom metrics**:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义指标**：'
- en: '**Application-specific metrics**: Metrics such as the number of active users,
    requests per second, or transaction rates can be used to trigger scaling actions.
    These metrics are tailored to the specific needs of the application.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定于应用程序的指标**：如活跃用户数量、每秒请求数或交易率等指标可以用来触发缩放操作。这些指标是根据应用程序的具体需求定制的。'
- en: '**Error rates**: An increase in error rates or failed requests can prompt scaling
    to handle the load more effectively or to isolate faulty instances.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误率**：错误率或失败请求的增加可以促使缩放更有效地处理负载或隔离故障实例。'
- en: 'Let’s now look at the conditions for effective auto-scaling:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看有效自动缩放的条件：
- en: '**Threshold levels**:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阈值级别**：'
- en: '**Setting appropriate thresholds**: Define upper and lower thresholds for key
    metrics to trigger scaling actions. These thresholds should be based on historical
    data and performance benchmarks.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置适当的阈值**：为关键指标定义上限和下限，以触发缩放操作。这些阈值应基于历史数据和性能基准。'
- en: '**Hysteresis**: Implementing hysteresis (a delay between scaling actions) helps
    prevent rapid fluctuations in scaling (thrashing) by adding a buffer time before
    scaling up or down.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滞后性**：通过在缩放操作之间添加缓冲时间，实现滞后性（滞后）有助于防止缩放（抖动）的快速波动。'
- en: '**Cooldown periods**: After a scaling action is performed, a cooldown period
    allows the system to stabilize before another scaling action is triggered. This
    prevents over-scaling and ensures that the metrics accurately reflect the system’s
    needs.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷却期**：在执行缩放操作后，冷却期允许系统在触发另一个缩放操作之前稳定下来。这防止了过度缩放并确保指标准确反映系统的需求。'
- en: '**Predictive scaling**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测性缩放**：'
- en: '**Trend analysis**: Using historical data and **machine learning** (**ML**)
    algorithms, predictive scaling anticipates future demand and scales resources
    proactively rather than reactively'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势分析**：使用历史数据和**机器学习**（**ML**）算法，预测性缩放可以预测未来的需求并主动缩放资源，而不是被动反应。'
- en: '**Scheduled scaling**: Scaling actions can be scheduled based on known patterns,
    such as increased traffic during business hours or specific events.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划缩放**：可以根据已知的模式，如工作时间的流量增加或特定事件，安排缩放操作。'
- en: '**Resource limits**:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制**：'
- en: '**Maximum and minimum limits**: Define the maximum and minimum number of instances
    to prevent excessive scaling that could lead to resource wastage or insufficient
    capacity'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大和最小限制**：定义最大和最小实例数量，以防止过度缩放，这可能导致资源浪费或容量不足。'
- en: '**Resource constraints**: Consider budgetary constraints and ensure that scaling
    actions do not exceed cost limits'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制**：考虑预算限制，并确保缩放操作不超过成本限制。'
- en: '**Health checks**:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康检查**：'
- en: '**Instance health monitoring**: Regular health checks ensure that only healthy
    instances are kept in the pool. Unhealthy instances are replaced to maintain application
    reliability.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例健康监控**：定期健康检查确保只保留健康的实例在池中。不健康的实例被替换以保持应用程序的可靠性。'
- en: '**Graceful degradation**: Implementing mechanisms for graceful degradation
    ensures that the application can still function, albeit with reduced performance,
    when scaling thresholds are reached.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优雅降级**：实现优雅降级机制确保在达到缩放阈值时，应用程序仍然可以运行，尽管性能有所降低。'
- en: An example scenario would be an online gaming platform experiencing varying
    levels of user activity throughout the day. During peak hours, CPU and memory
    utilization increase significantly. By setting auto-scaling policies based on
    these metrics, the platform can automatically add more instances to handle the
    load. Conversely, during off-peak hours, the platform scales down to save costs,
    ensuring optimal resource utilization at all times.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例场景是一个在线游戏平台在一天中经历不同级别的用户活动。在高峰时段，CPU和内存利用率显著增加。通过根据这些指标设置自动缩放策略，平台可以自动添加更多实例来处理负载。相反，在非高峰时段，平台会缩小规模以节省成本，确保始终优化资源利用率。
- en: Understanding the triggers and conditions for auto-scaling allows businesses
    to configure their cloud environments effectively, ensuring applications remain
    responsive, reliable, and cost efficient. This proactive approach to resource
    management is essential for maintaining high performance in dynamic and unpredictable
    usage scenarios.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 理解自动缩放的触发条件和条件，使企业能够有效地配置其云环境，确保应用程序保持响应、可靠且成本效益。这种主动的资源管理方法对于在动态和不可预测的使用场景中保持高性能至关重要。
- en: A guide to setting memory utilization triggers for auto-scaling
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动缩放设置内存利用率触发器的指南
- en: 'Auto-scaling is a critical component for maintaining optimal application performance
    and resource utilization in cloud environments. This section provides a detailed
    guide on setting memory utilization triggers for auto-scaling, focusing on two
    popular auto-scaling solutions: **AWS auto-scaling** services and **Kubernetes-Based
    Event Driven Autoscaling** (**KEDA**) for Kubernetes. The first part covers the
    implementation using AWS services, and the second part introduces KEDA, a Kubernetes-based
    project supported by the Cloud Native Computing Foundation, for event-driven auto-scaling.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展是维护云环境中最佳应用程序性能和资源利用率的关键组件。本节提供了设置自动扩展内存利用率触发的详细指南，重点关注两种流行的自动扩展解决方案：**AWS
    自动扩展**服务和针对 Kubernetes 的**基于事件的自动扩展**（**KEDA**）。第一部分涵盖了使用 AWS 服务实现的实施，第二部分介绍了
    KEDA，这是一个由云原生计算基金会支持、基于 Kubernetes 的项目，用于事件驱动的自动扩展。
- en: AWS auto-scaling services
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS 自动扩展服务
- en: In this section, we will explore how to set up memory utilization triggers for
    auto-scaling using AWS auto-scaling services. AWS provides robust tools and services
    to automatically adjust the number of running instances based on the current demand,
    ensuring that your application performs optimally while maintaining cost efficiency.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用 AWS 自动扩展服务设置自动扩展的内存利用率触发器。AWS 提供了强大的工具和服务，可以根据当前需求自动调整运行实例的数量，确保您的应用程序在保持成本效率的同时表现最佳。
- en: High memory usage
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高内存使用
- en: 'Let’s dive in to see how to set high memory usage:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解如何设置高内存使用量：
- en: '**Determine** **the threshold**:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定** **阈值**：'
- en: '**Analyze historical data**: Review past performance metrics to identify typical
    memory usage patterns. Determine the average and peak memory usage levels.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析历史数据**：回顾过去的性能指标，以确定典型的内存使用模式。确定平均和峰值内存使用水平。'
- en: '**Set a threshold**: A common practice is to set a high memory usage threshold
    between 70% and 85%. This range helps ensure there is enough buffer to add new
    instances before memory constraints impact performance.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置阈值**：常见的做法是在 70% 到 85% 之间设置高内存使用阈值。这个范围有助于确保在内存限制影响性能之前有足够的缓冲空间来添加新实例。'
- en: '**Configure the** **auto-scaling policy**:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置** **自动扩展策略**：'
- en: '**Choose a metric**: Use cloud provider-specific metrics such as Amazon CloudWatch
    (AWS), Azure Monitor, or Google Cloud Monitoring to track memory usage.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择一个指标**：使用云提供商特定的指标，例如 Amazon CloudWatch（AWS）、Azure Monitor 或 Google Cloud
    Monitoring 来跟踪内存使用。'
- en: '**Set the alarm**: Create an alarm that triggers when memory usage exceeds
    the defined threshold using the AWS CLI:'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置警报**：使用 AWS CLI 创建一个当内存使用量超过定义的阈值时触发的警报：'
- en: '[PRE0]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command creates a CloudWatch alarm with the specified parameters to monitor
    the memory utilization of instances within a specified auto-scaling group. The
    alarm is triggered when the average memory utilization exceeds 75% over two consecutive
    5-minute periods (300 seconds each).
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令创建了一个具有指定参数的 CloudWatch 警报，用于监控指定自动扩展组内实例的内存利用率。当连续两个 5 分钟周期（每个 300 秒）的平均内存利用率超过
    75% 时，警报被触发。
- en: '**Define** **scaling actions**:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义** **扩展操作**：'
- en: '**Scaling up**: Specify the action to take when the threshold is breached,
    such as adding a specified number of instances.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扩展**：当阈值被突破时，指定要采取的操作，例如添加指定数量的实例。'
- en: '**Cooldown period**: Set a cooldown period (e.g., 300 seconds) to allow the
    system to stabilize before evaluating further scaling actions.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**冷却期**：设置一个冷却期（例如，300秒），以便在评估进一步的扩展操作之前允许系统稳定。'
- en: 'Directly run this command using AWS CLI:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直接使用 AWS CLI 运行此命令：
- en: '[PRE1]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This script defines a scaling policy for an AWS auto-scaling group to address
    high memory usage. When the average memory utilization across the group’s instances
    exceeds a predefined threshold, the policy triggers a scale-out event, adding
    two new instances to the group. To maintain the system stability and prevent overly
    aggressive scaling, a cooldown period of 300 seconds (5 minutes) is enforced after
    each scale-out event.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此脚本定义了一个 AWS 自动扩展组的扩展策略，以解决高内存使用问题。当组内实例的平均内存利用率超过预定义的阈值时，策略触发扩展事件，向组中添加两个新实例。为了保持系统稳定性和防止过度激进的扩展，在每个扩展事件之后强制执行
    300 秒（5 分钟）的冷却期。
- en: Low memory usage
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 低内存使用
- en: 'Let’s dive in to see how to set low memory usage:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解如何设置低内存使用量：
- en: '**Determine** **the threshold**:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定** **阈值**：'
- en: '**Analyze historical data**: Identify periods of low memory usage and the minimum
    memory requirements for your application to function correctly.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析历史数据**：确定低内存使用量周期和应用程序正确运行所需的最小内存需求。'
- en: '**Set a threshold**: Set the low memory usage threshold between 20% and 40%.
    This helps ensure instances are not terminated prematurely, which could affect
    performance.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置阈值**：将低内存使用阈值设置为 20% 到 40% 之间。这有助于确保实例不会被过早终止，从而可能影响性能。'
- en: '**Configure the** **auto-scaling policy**:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置** **自动扩展策略**：'
- en: '**Choose a metric**: Use the same cloud provider-specific metrics to monitor
    low memory usage.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择一个指标**：使用相同的云提供商特定指标来监控低内存使用。'
- en: '**Set the alarm**: Create an alarm that triggers when memory usage falls below
    the defined threshold using the AWS CLI.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置警报**：使用 AWS CLI 创建一个当内存使用量低于定义的阈值时触发的警报。'
- en: 'Directly run this command using AWS CLI:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直接使用 AWS CLI 运行此命令：
- en: '[PRE2]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Define** **scaling actions**:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义** **扩展操作**：'
- en: '**Scaling down**: Specify the action to take when the low memory threshold
    is reached, such as removing a specified number of instances.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**缩减规模**：当达到低内存阈值时，指定要采取的操作，例如移除指定数量的实例。'
- en: '**Cooldown period**: Set a cooldown period (e.g., 300 seconds) to allow the
    system to stabilize before further scaling actions.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**冷却期**：设置一个冷却期（例如，300 秒），以便在进一步的扩展操作之前让系统稳定下来。'
- en: 'Directly run this command using AWS CLI:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直接使用 AWS CLI 运行此命令：
- en: '[PRE3]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: KEDA
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KEDA
- en: In addition to the cloud provider-specific auto-scaling services we just discussed,
    the open-source project KEDA provides a generic and extensible auto-scaling solution
    for Kubernetes environments. KEDA allows developers to define scalable targets
    based on various event sources, including cloud services, messaging queues, and
    custom metrics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才讨论的特定于云提供商的自动扩展服务外，开源项目 KEDA 为 Kubernetes 环境提供了一个通用且可扩展的自动扩展解决方案。KEDA
    允许开发人员根据各种事件源定义可扩展的目标，包括云服务、消息队列和自定义指标。
- en: KEDA operates as a Kubernetes operator, running as a deployment on the Kubernetes
    cluster. It provides a `ScaledObject`, which defines the scaling behavior for
    a Kubernetes deployment or service. The `ScaledObject` resource specifies the
    event source, scaling metrics, and scaling parameters, allowing KEDA to automatically
    scale the target workload based on the defined criteria.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: KEDA 作为 Kubernetes 操作员运行，在 Kubernetes 集群上作为部署运行。它提供了一个 `ScaledObject`，该对象定义了
    Kubernetes 部署或服务的扩展行为。`ScaledObject` 资源指定了事件源、扩展指标和扩展参数，允许 KEDA 根据定义的标准自动扩展目标工作负载。
- en: 'KEDA supports a wide range of event sources, including the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: KEDA 支持广泛的触发器源，包括以下内容：
- en: Cloud services (AWS **Simple Queue Service** or **SQS**, Azure Queue Storage,
    Google PubSub, etc.)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务（AWS **简单队列服务** 或 **SQS**，Azure Queue Storage，Google PubSub 等）
- en: Databases (PostgreSQL, MongoDB, etc.)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库（PostgreSQL，MongoDB 等）
- en: Messaging systems (RabbitMQ, Apache Kafka, etc.)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息系统（RabbitMQ，Apache Kafka 等）
- en: Custom metrics (Prometheus, Stackdriver, etc.)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义指标（Prometheus，Stackdriver 等）
- en: By integrating KEDA into your Java-based Kubernetes applications, you can benefit
    from a generic and extensible auto-scaling solution that seamlessly adapts to
    the demands of your cloud-native infrastructure. KEDA’s event-driven approach
    and support for a variety of data sources make it a powerful tool for building
    scalable and responsive Java applications in Kubernetes environments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 KEDA 集成到你的基于 Java 的 Kubernetes 应用程序中，你可以从一种通用且可扩展的自动扩展解决方案中受益，该解决方案可以无缝适应你的云原生基础设施的需求。KEDA
    的事件驱动方法和对各种数据源的支持使其成为在 Kubernetes 环境中构建可扩展和响应式 Java 应用程序的有力工具。
- en: Setting up KEDA and auto-scaling in an AWS environment
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 AWS 环境中设置 KEDA 和自动扩展
- en: 'To demonstrate how KEDA can be used for auto-scaling in an AWS environment,
    let’s walk through a practical example of setting it up in a Kubernetes cluster
    and integrating it with AWS services:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 KEDA 如何在 AWS 环境中用于自动扩展，让我们通过一个实际示例来设置它在 Kubernetes 集群中的配置，并将其与 AWS 服务集成：
- en: '**Install KEDA** **using Helm**:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 Helm **安装 KEDA**：'
- en: '[PRE4]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'apiVersion: v1'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'apiVersion: v1'
- en: 'kind: Secret'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'kind: Secret'
- en: 'metadata:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: aws-sqs-credentials'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'name: aws-sqs-credentials'
- en: 'type: Opaque'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'type: 不透明'
- en: 'stringData:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'stringData:'
- en: 'AWS_ACCESS_KEY_ID: "<your-access-key-id>"'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'AWS_ACCESS_KEY_ID: "<你的访问密钥 ID>"'
- en: 'Application Deployment (sqs-queue-consumer-deployment.yaml):'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序部署（sqs-queue-consumer-deployment.yaml）：
- en: '[PRE5]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'apiVersion: keda.sh/v1alpha1'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'apiVersion: keda.sh/v1alpha1'
- en: 'kind: ScaledObject'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'kind: ScaledObject'
- en: 'metadata:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: sqs-queue-scaledobject'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'name: sqs-queue-scaledobject'
- en: 'spec:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'scaleTargetRef:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'scaleTargetRef:'
- en: 'name: sqs-queue-consumer'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'name: sqs-queue-consumer'
- en: 'minReplicaCount: 1'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'minReplicaCount: 1'
- en: 'maxReplicaCount: 10'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '最大副本数: 10'
- en: 'triggers:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 触发器：
- en: '- type: aws-sqs-queue'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 类型: aws-sqs-queue'
- en: 'metadata:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'queueURL: "<your-sqs-queue-url>"'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '队列URL: "<your-sqs-queue-url>"'
- en: 'awsAccessKeyID: "<your-access-key-id>"'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'awsAccessKeyID: "<your-access-key-id>"'
- en: 'awsSecretAccessKey: "<your-secret-access-key>"'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'awsSecretAccessKey: "<your-secret-access-key>"'
- en: 'queueLength: "5"'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '队列长度: "5"'
- en: '[PRE6]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Deploy the configuration files:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署配置文件：
- en: '[PRE8]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Verify** **the setup**:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证** **设置**：'
- en: '**Check KEDA metrics server**: Ensure the KEDA metrics server is running:'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查KEDA度量服务器**：确保KEDA度量服务器正在运行：'
- en: '[PRE9]'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Monitor the scaling behavior**: Watch the deployment to see how it scales
    based on the SQS queue length.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控扩展行为**：观察部署以查看它是如何根据SQS队列长度进行扩展的。'
- en: '[PRE10]'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Integrating KEDA into your Kubernetes-based applications provides a powerful
    and flexible way to manage auto-scaling based on events. This enhances the efficiency
    and responsiveness of your applications, ensuring they can handle varying workloads
    effectively.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将KEDA集成到基于Kubernetes的应用程序中提供了一种强大且灵活的方式来根据事件管理自动扩展。这提高了应用程序的效率和响应能力，确保它们能够有效地处理不断变化的工作负载。
- en: We’ve explored the core concepts of cloud auto-scaling, including its mechanisms,
    advantages, and the triggers and conditions that drive scaling decisions. We’ve
    also provided a guide on setting memory utilization triggers. This knowledge is
    crucial for creating cloud-based applications that can dynamically adapt to changing
    workloads, ensuring optimal performance while managing costs effectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了云自动扩展的核心概念，包括其机制、优势以及驱动扩展决策的触发器和条件。我们还提供了一份关于设置内存利用率触发的指南。这些知识对于创建能够动态适应不断变化的工作负载的云应用程序至关重要，同时确保在有效管理成本的同时实现最佳性能。
- en: Understanding these principles is essential in today’s digital landscape, where
    applications must handle unpredictable traffic patterns and resource demands.
    Mastering these concepts equips you to design resilient, efficient, and cost-effective
    cloud applications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些原则在当今的数字景观中至关重要，因为在今天，应用程序必须处理不可预测的交通模式和资源需求。掌握这些概念使你能够设计出具有弹性、高效和成本效益的云应用程序。
- en: Next, we’ll explore how Java’s concurrency models align with these scaling strategies.
    We’ll examine how Java’s rich set of concurrency tools can be used to create applications
    that seamlessly integrate with cloud auto-scaling, enabling efficient resource
    utilization and improved performance in dynamic environments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Java的并发模型如何与这些扩展策略相一致。我们将检查Java丰富的并发工具如何用于创建与云自动扩展无缝集成的应用程序，从而在动态环境中实现高效的资源利用和性能提升。
- en: Java’s concurrency models – alignment with scaling strategies
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java的并发模型 – 与扩展策略的一致性
- en: Java’s concurrency models offer powerful tools that align with auto-scaling
    strategies, enabling applications to dynamically adjust resource allocation based
    on real-time demand. Let’s explore how Java’s concurrency utilities support auto-scaling.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Java的并发模型提供了与自动扩展策略相一致的有力工具，使应用程序能够根据实时需求动态调整资源分配。让我们探讨Java的并发工具如何支持自动扩展。
- en: '`ExecutorService` efficiently manages thread pools, allowing dynamic adjustment
    of active threads to match the workload. `CompletableFuture` enables asynchronous
    programming, facilitating non-blocking operations that scale with demand. **Parallel
    streams** harness the power of multiple CPU cores to process data streams in parallel,
    enhancing performance.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`有效地管理线程池，允许动态调整活动线程以匹配工作负载。`CompletableFuture`使异步编程成为可能，促进与需求成比例的非阻塞操作。**并行流**利用多个CPU核心的强大功能，并行处理数据流，从而提高性能。'
- en: 'To demonstrate the practical application of these concurrency tools in auto-scaling,
    let’s walk through a simple example. We will implement an auto-scaling solution
    that dynamically adjusts the number of worker threads based on the load:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这些并发工具在自动扩展中的实际应用，让我们通过一个简单的示例进行操作。我们将实现一个动态调整工作线程数量的自动扩展解决方案：
- en: 'Set up `ExecutorService`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`ExecutorService`：
- en: '[PRE11]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It initializes `ExecutorService` with a fixed thread pool size specified by
    `initialPoolSize`.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它使用`initialPoolSize`指定的固定线程池大小初始化`ExecutorService`。
- en: 'Load monitoring:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负载监控：
- en: '[PRE12]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code creates `ScheduledExecutorService`, which periodically checks the
    current load and adjusts the thread pool size accordingly. The task runs at a
    fixed interval defined by `monitoringInterval`, starting immediately. It measures
    the load using `getCurrentLoad()` and adjusts the thread pool size using `adjustThreadPoolSize(executorService,
    currentLoad)`. This mechanism dynamically scales resources based on real-time
    workload, ensuring efficient handling of varying demands.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码创建 `ScheduledExecutorService`，周期性地检查当前负载并根据需要调整线程池大小。任务以由 `monitoringInterval`
    定义的固定间隔运行，立即开始。它使用 `getCurrentLoad()` 测量负载，并使用 `adjustThreadPoolSize(executorService,
    currentLoad)` 调整线程池大小。此机制根据实时工作负载动态扩展资源，确保高效处理不断变化的需求。
- en: 'Adjust the thread pool size:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整线程池大小：
- en: '[PRE13]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `adjustThreadPoolSize()` method adjusts the size of the thread pool based
    on the current load. It takes two parameters: `ExecutorService` and an `integer
    load`. The method calculates the optimal pool size using `calculateOptimalPoolSize(load)`.
    It then sets the core pool size and the maximum pool size of `ThreadPoolExecutor`
    to the new pool size. This adjustment ensures that the thread pool dynamically
    matches the current workload, optimizing resource utilization and maintaining
    application performance.'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`adjustThreadPoolSize()` 方法根据当前负载调整线程池的大小。它接受两个参数：`ExecutorService` 和一个 `integer
    load`。该方法使用 `calculateOptimalPoolSize(load)` 计算最佳池大小。然后，它将 `ThreadPoolExecutor`
    的核心池大小和最大池大小设置为新的池大小。这种调整确保线程池动态匹配当前工作负载，优化资源利用并保持应用程序性能。'
- en: 'Handle the tasks with `CompletableFuture`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CompletableFuture` 处理任务：
- en: '[PRE14]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `CompletableFuture.runAsync()` method runs a task asynchronously using the
    provided `ExecutorService`. It takes a lambda expression, which represents the
    task to be executed and `ExecutorService` as parameters. This allows the task
    to run in a separate thread managed by `ExecutorService`, enabling non-blocking
    execution.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CompletableFuture.runAsync()` 方法使用提供的 `ExecutorService` 异步运行一个任务。它接受一个 lambda
    表达式，代表要执行的任务，以及 `ExecutorService` 作为参数。这允许任务在由 `ExecutorService` 管理的单独线程中运行，从而实现非阻塞执行。'
- en: By utilizing these concurrency tools, we can create a responsive and efficient
    auto-scaling solution that adapts to changing workloads in real-time. This approach
    not only optimizes resource utilization but also enhances the overall performance
    and reliability of cloud-based applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些并发工具，我们可以创建一个响应迅速且高效的自动扩展解决方案，实时适应不断变化的工作负载。这种方法不仅优化了资源利用，还提高了基于云的应用程序的整体性能和可靠性。
- en: Having explored how concurrency tools empower cloud applications, let’s now
    delve into strategies for optimizing Java applications to thrive in the dynamic
    cloud landscape.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了并发工具如何赋予云应用程序能力之后，现在让我们深入了解优化 Java 应用程序以在动态云环境中茁壮成长的方法。
- en: Optimizing Java applications for cloud scalability – best practices
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化 Java 应用程序以适应云可扩展性 – 最佳实践
- en: As cloud environments demand efficient and scalable applications, optimizing
    Java applications for cloud scalability is crucial. This section focuses on best
    practices, resource management techniques, and a practical code example to demonstrate
    how to optimize Java applications for auto-scaling.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于云环境要求高效且可扩展的应用程序，优化 Java 应用程序以适应云可扩展性至关重要。本节重点介绍最佳实践、资源管理技术以及一个实际代码示例，以展示如何优化
    Java 应用程序以实现自动扩展。
- en: 'To enhance Java application scalability in cloud environments, it is essential
    to follow best design practices, which are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在云环境中提高 Java 应用程序的扩展性，必须遵循最佳设计实践，如下所述：
- en: '**Microservices architecture**: Break down applications into smaller, independently
    deployable services. This allows for better resource allocation and easier scaling.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**：将应用程序分解成更小、可独立部署的服务。这有助于更好地分配资源并简化扩展。'
- en: '`CompletableFuture` can help manage tasks without blocking the main thread.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture` 可以帮助管理任务而不会阻塞主线程。'
- en: '**Stateless services**: Design services to be stateless wherever possible.
    Stateless services are easier to scale because they do not require session information
    to be shared between instances.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态服务**：尽可能设计无状态服务。无状态服务更容易扩展，因为它们不需要在实例之间共享会话信息。'
- en: '**Load balancing**: Implement load balancing to distribute incoming requests
    evenly across multiple instances of your application. This prevents any single
    instance from becoming a bottleneck.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：实现负载均衡，以均匀地分配到应用程序多个实例的传入请求。这防止任何单个实例成为瓶颈。'
- en: '**Caching**: Use caching mechanisms to reduce the load on backend services
    and databases. This can significantly improve response times and reduce latency.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：使用缓存机制来减轻后端服务和数据库的负载。这可以显著提高响应时间并减少延迟。'
- en: '**Containerization**: Use containers (e.g., Docker) to package applications
    and their dependencies. Containers provide consistency across different environments
    and simplify scaling and deployment.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化**：使用容器（例如，Docker）打包应用程序及其依赖项。容器在不同环境中提供一致性，并简化了扩展和部署。'
- en: In the next section, we will look at an example to see how it works in real-world
    applications.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过一个示例来了解它在实际应用中的工作方式。
- en: Code example – best practices in optimizing a Java application for auto-scaling
    with AWS services and Docker
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 - 使用 AWS 服务和 Docker 优化 Java 应用程序以实现自动扩展的最佳实践
- en: To demonstrate best practices in optimizing a Java application for auto-scaling,
    we will create a real-world example using AWS services and Docker. This example
    will involve deploying a Java application to AWS using CloudFormation, Docker
    for containerization, and various AWS services to manage and scale the application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示优化 Java 应用程序以实现自动扩展的最佳实践，我们将创建一个使用 AWS 服务和 Docker 的真实世界示例。此示例将涉及使用 CloudFormation、Docker
    容器化和各种 AWS 服务来管理和扩展应用程序。
- en: 'Let’s look at the following diagram:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![Figure 10.1: Deployment workflow for a Java application on AWS with auto-scaling](img/B20937_10_01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1：在 AWS 上部署具有自动扩展功能的 Java 应用程序的部署工作流程](img/B20937_10_01.jpg)'
- en: 'Figure 10.1: Deployment workflow for a Java application on AWS with auto-scaling'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：在 AWS 上部署具有自动扩展功能的 Java 应用程序的部署工作流程
- en: 'The diagram illustrates the architecture of an auto-scaling Java application
    deployed on AWS using Amazon **Elastic Container Service** (**ECS**), Fargate,
    and CloudFormation. These steps and code blocks are designed to guide developers
    through the process of containerizing a Java application, deploying it on AWS,
    and ensuring it can scale automatically to handle varying loads. Before diving
    into the development process, it’s essential to understand the purpose and sequence
    of these steps to ensure a smooth and efficient deployment. This preparation involves
    creating and configuring necessary AWS resources, building and pushing Docker
    images, and setting up infrastructure as code using CloudFormation to automate
    the entire process. Here are the steps to do so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图表说明了在 AWS 上使用 Amazon **弹性容器服务**（**ECS**）、Fargate 和 CloudFormation 部署的自动扩展 Java
    应用程序的架构。这些步骤和代码块旨在指导开发人员通过容器化 Java 应用程序、在 AWS 上部署它并确保它可以自动扩展以处理不同负载的过程。在深入开发过程之前，了解这些步骤的目的和顺序对于确保平稳和高效的部署至关重要。这种准备涉及创建和配置必要的
    AWS 资源、构建和推送 Docker 镜像，并使用 CloudFormation 设置基础设施代码以自动化整个过程。以下是执行这些步骤的方法：
- en: '**Step 1**: **Dockerize the** **Java application**:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1**：**容器化 Java 应用程序**：'
- en: 'Create a simple Java application and package:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的 Java 应用程序并打包：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a Dockerfile to containerize the Java application:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Dockerfile 来容器化 Java 应用程序：
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Step 2: Define the infrastructure** **Using CloudFormation**:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：定义基础设施** **使用 CloudFormation**：'
- en: Create a CloudFormation template to define the required AWS resources. The CloudFormation
    template defines the necessary resources for deploying and managing a Dockerized
    Java application on AWS ECS with auto-scaling. The following is a breakdown of
    the template into sections, each explaining a specific resource.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 CloudFormation 模板来定义所需的 AWS 资源。CloudFormation 模板定义了在 AWS ECS 上部署和管理具有自动扩展功能的
    Docker 化 Java 应用程序所需的资源。以下是对模板的分解，每个部分都解释了特定的资源。
- en: First is the ECS cluster. This section creates an Amazon ECS cluster named `auto-scaling-cluster`.
    An ECS cluster is a logical grouping of tasks or services, providing the environment
    where your containerized application runs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是 ECS 集群。本节创建了一个名为 `auto-scaling-cluster` 的 Amazon ECS 集群。ECS 集群是任务或服务的逻辑分组，为您的容器化应用程序提供运行环境。
- en: 'Next is the ECS task definition that specifies how Docker containers should
    be run on Amazon ECS. It defines various parameters and configurations for the
    containerized application, such as the required resources, network settings, and
    logging options. Here’s a breakdown of the task definition:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 ECS 任务定义，它指定了如何在 Amazon ECS 上运行 Docker 容器。它定义了容器化应用程序的各种参数和配置，例如所需资源、网络设置和日志选项。以下是任务定义的分解：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This section of the CloudFormation template is focused on creating an ECS cluster.
    Let’s break down each component:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本节CloudFormation模板的重点是创建一个ECS集群。让我们分解每个组件：
- en: '`Resources`: This is the main section where we declare the different AWS resources
    we want to create.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources`：这是主要部分，我们在这里声明我们想要创建的不同AWS资源。'
- en: '`ECSCluster`: This is the name we give to this particular resource within our
    template. We can reference it later using this name.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ECSCluster`：这是我们给模板中这个特定资源的名称。我们可以在以后使用此名称引用它。'
- en: '`Type: AWS::ECS::Cluster`: This specifies that we’re creating an ECS cluster
    resource, which is a logical grouping of container instances on which we can place
    tasks.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type: AWS::ECS::Cluster`：这指定了我们正在创建一个ECS集群资源，这是一个容器实例的逻辑分组，我们可以在其上放置任务。'
- en: '`Properties`: This is where we define the configuration details of the cluster.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Properties`：这是我们定义集群配置细节的地方。'
- en: '`ClusterName: auto-scaling-cluster`: This is the name we’re assigning to the
    ECS cluster. It’s a good practice to choose a descriptive name that reflects the
    purpose of the cluster.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterName: auto-scaling-cluster`：这是我们分配给ECS集群的名称。选择一个反映集群目的的描述性名称是一个好习惯。'
- en: 'The ECS task definition specifies how Docker containers should be run on Amazon
    ECS. It defines various parameters and configurations for the containerized application,
    such as the required resources, network settings, and logging options. Here’s
    a breakdown of the task definition:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ECS任务定义指定了如何在Amazon ECS上运行Docker容器。它定义了容器化应用程序的各种参数和配置，例如所需资源、网络设置和日志选项。以下是任务定义的分解：
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This section defines the ECS task, which specifies how Docker containers should
    be run on ECS. The task definition auto-scaling-task includes the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本节定义了ECS任务，它指定了如何在ECS上运行Docker容器。任务定义自动扩展任务包括以下内容：
- en: '`awsvpc` for Fargate tasks'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awsvpc`用于Fargate任务'
- en: '**CPU and memory**: It allocates 256 CPU units and 512 MB of memory'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU和内存**：它分配了256个CPU单位和512MB的内存'
- en: '`auto-scaling-container` that runs the Docker image specified by `<your-docker-image-repo-url>`,
    exposes port `8080`, and configures logging to AWS CloudWatch'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto-scaling-container`运行由`<your-docker-image-repo-url>`指定的Docker镜像，暴露端口`8080`，并将日志配置为AWS
    CloudWatch'
- en: 'Now, we move on to ECS service. The ECS service is responsible for managing
    and running the ECS tasks defined in the task definition. It ensures that the
    specified number of tasks are maintained and running correctly. Here’s a detailed
    breakdown of the ECS service definition:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转向ECS服务。ECS服务负责管理和运行在任务定义中定义的ECS任务。它确保保持并正确运行指定数量的任务。以下是ECS服务定义的详细分解：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This section creates an ECS service that manages and runs the ECS tasks defined
    in the task definition. The service does the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节创建了一个ECS服务，用于管理和运行在任务定义中定义的ECS任务。该服务执行以下操作：
- en: It runs in the ECS cluster referenced by `ECSCluster`
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在由`ECSCluster`引用的ECS集群中运行
- en: It has a desired count of 1 task
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它期望有1个任务
- en: It uses the Fargate launch type
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用Fargate启动类型
- en: It uses the network configuration specified, including subnets and security
    groups
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用指定的网络配置，包括子网和安全组
- en: 'The auto-scaling target section defines how the ECS service scales in response
    to demand. This configuration ensures that the application can handle varying
    loads efficiently by automatically adjusting the number of running tasks. Here
    is the code for the auto-scaling target:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展目标部分定义了ECS服务如何根据需求进行扩展。此配置确保应用程序可以通过自动调整运行任务的数量来有效地处理不同的负载。以下是自动扩展目标的代码：
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This section specifies the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本节指定以下内容：
- en: '`MaxCapacity` and `MinCapacity` define the range for the number of tasks, with
    a minimum of 1 and a maximum of 10'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxCapacity`和`MinCapacity`定义了任务数量的范围，最小为1，最大为10'
- en: '`ResourceId` identifies the ECS service to be scaled, constructed from the
    ECS cluster and service names'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceId`标识要扩展的ECS服务，由ECS集群和服务名称构建'
- en: '`RoleARN` uses a specific **identity and access management** (**IAM**) role
    that grants permissions to Application auto-scaling to manage ECS service scaling'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoleARN`使用特定的**身份和访问管理**（**IAM**）角色，该角色授予应用程序自动扩展管理ECS服务扩展的权限'
- en: '`ScalableDimension` and `ServiceNamespace` indicate the ECS service’s desired
    count as the scalable dimension within the ECS namespace'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScalableDimension`和`ServiceNamespace`指示ECS服务在ECS命名空间内的期望计数作为可扩展维度'
- en: 'The auto-scaling policy section outlines the rules and conditions under which
    the ECS service will scale. This policy leverages AWS’s Application auto-scaling
    to adjust the number of running tasks based on the specified metric. Here is the
    code for the auto-scaling policy:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展策略部分概述了ECS服务将根据哪些规则和条件进行扩展。此策略利用AWS的应用自动扩展根据指定的指标调整运行任务的数量。以下是自动扩展策略的代码：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This section defines a scaling policy that adjusts the number of tasks based
    on CPU utilization. The policy does the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本节定义了一个根据CPU利用率调整任务数量的扩展策略。该策略执行以下操作：
- en: It tracks the ECS service’s average CPU utilization
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它跟踪ECS服务的平均CPU利用率
- en: It scales the number of tasks to maintain the target CPU utilization at 50%
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将任务数量扩展以保持目标CPU利用率在50%
- en: '**Step 3: Deploy** **the application**:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3步：部署** **应用程序**：'
- en: 'Build and push the Docker image to Amazon **Elastic Container** **Registry**
    (**ECR**):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并将Docker镜像推送到Amazon **弹性容器** **注册表** (**ECR**)：
- en: '**Install Docker**: Ensure Docker is installed on your local machine. You can
    download and install Docker from Docker’s official website.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装Docker**：确保您的本地机器上已安装Docker。您可以从Docker的官方网站下载并安装Docker。'
- en: '**Log in to AWS CLI**: Make sure you have the AWS CLI installed and configured
    with your AWS credentials:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**登录AWS CLI**：确保您已安装并配置了AWS CLI以及您的AWS凭证：'
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create an ECR repository to store your Docker image:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个ECR存储库以存储您的Docker镜像：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Navigate to the directory containing your Dockerfile and build the Docker image:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到包含您的Dockerfile的目录并构建Docker镜像：
- en: '[PRE24]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Tag the Docker image with the ECR repository URI:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ECR存储库URI标记Docker镜像：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <aws-account-id> with your actual AWS account ID.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`<aws-account-id>` 使用您的实际AWS账户ID。'
- en: 'Push the tagged Docker image to your ECR repository:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标记的Docker镜像推送到您的ECR存储库：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Step 4: Deploy the** **CloudFormation stack**:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第4步：部署** **CloudFormation堆栈**：'
- en: 'Once the Docker image is pushed to Amazon ECR, you can deploy the CloudFormation
    stack using the AWS CLI or AWS Management Console:'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦将Docker镜像推送到Amazon ECR，您可以使用AWS CLI或AWS管理控制台部署CloudFormation堆栈：
- en: '**Deploy using** **AWS CLI**:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **AWS CLI** **部署**：'
- en: '[PRE27]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Deploy using the AWS** **Management Console**:'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用AWS** **管理控制台** **部署**：'
- en: Open the AWS CloudFormation console ([https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)).
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开AWS CloudFormation控制台([https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation))。
- en: Click on **Create Stack**.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建堆栈**。
- en: Choose `cloudformation-template.yaml` file.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`cloudformation-template.yaml`文件。
- en: Follow the prompts to create the stack.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按提示创建堆栈。
- en: By following these steps, you will have your Dockerized Java application image
    stored in Amazon ECR and deployed using AWS CloudFormation, ECS, and Fargate,
    with auto-scaling capabilities configured.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，您将拥有存储在Amazon ECR中的Docker化Java应用程序镜像，并使用AWS CloudFormation、ECS和Fargate进行部署，同时配置了自动扩展功能。
- en: Monitoring tools and techniques for Java applications
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java应用程序的监控工具和技术
- en: Effective monitoring is crucial for managing and optimizing Java applications
    during auto-scaling events. Various cloud providers offer comprehensive monitoring
    tools and services. Here, we discuss AWS CloudWatch, Google Cloud Monitoring,
    and Azure Monitor.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有效的监控对于在自动扩展事件中管理和优化Java应用程序至关重要。各种云服务提供商提供全面的监控工具和服务。在此，我们讨论AWS CloudWatch、Google
    Cloud Monitoring和Azure Monitor。
- en: AWS CloudWatch
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: AWS CloudWatch
- en: '**AWS CloudWatch** is a monitoring and observability service that provides
    data and actionable insights to monitor applications, respond to system-wide performance
    changes, and optimize resource utilization. Key features include the following:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**AWS CloudWatch** 是一种监控和可观察性服务，它提供数据和可操作见解以监控应用程序、响应系统级性能变化以及优化资源利用率。主要功能包括以下内容：'
- en: '**Metrics collection**: It collects and tracks metrics such as CPU usage, memory
    usage, and request counts'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标收集**：它收集和跟踪指标，如CPU使用率、内存使用率和请求数量'
- en: '**Logs management**: It collects and stores log files from AWS resources'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志管理**：它收集并存储来自AWS资源的日志文件'
- en: '**Alarms**: It sets thresholds on metrics to automatically send notifications
    or trigger actions'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：它在指标上设置阈值，以自动发送通知或触发操作'
- en: '**Dashboards**: It creates custom dashboards to visualize and analyze metrics'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表板**：它创建自定义仪表板以可视化和分析指标'
- en: Google Cloud Monitoring
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Google Cloud Monitoring
- en: '**Google Cloud Monitoring** (formerly Stackdriver) provides visibility into
    the performance, uptime, and overall health of cloud-powered applications. Key
    features include the following:'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Google Cloud Monitoring**（以前称为Stackdriver）提供了对云应用程序性能、正常运行时间和整体健康状况的可见性。主要功能包括以下内容：'
- en: '**Metrics and dashboards**: It visualizes key metrics with custom dashboards
    and tracks metrics such as CPU utilization, memory usage, and latency'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标和仪表板**：它使用自定义仪表板可视化关键指标，并跟踪CPU利用率、内存使用情况和延迟等指标。'
- en: '**Logs and traces**: It collects logs and traces to diagnose issues and understand
    application behavior'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志和跟踪**：它收集日志和跟踪以诊断问题并了解应用程序行为'
- en: '**Alerting**: It configures alerts based on predefined or custom metrics to
    notify you of performance issues or anomalies'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：它根据预定义或自定义指标配置警报，以通知您性能问题或异常'
- en: '**Integration**: It integrates with other Google Cloud services for seamless
    monitoring and management'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：它与其他谷歌云服务无缝集成，以实现监控和管理'
- en: Azure Monitor
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Azure Monitor
- en: '**Azure Monitor** is a full-stack monitoring service that provides a comprehensive
    view of your application’s performance and health. Key features include the following:'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Azure Monitor**是一个全栈监控服务，提供了对应用程序性能和健康状况的全面视图。主要功能包括以下内容：'
- en: '**Metrics and logs**: It collects and analyzes performance metrics and logs
    from your applications and infrastructure.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标和日志**：它收集并分析来自您的应用程序和基础设施的性能指标和日志。'
- en: '**Application insights**: It monitors live applications and automatically detects
    performance anomalies. It also provides deep insights into application performance
    and user behavior.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序洞察**：它监控实时应用程序并自动检测性能异常。它还提供了对应用程序性能和用户行为的深入洞察。'
- en: '**Alerts**: It sets up alerts to notify you of critical issues based on various
    conditions and thresholds.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：它根据各种条件和阈值设置警报，以通知您关键问题。'
- en: '**Dashboards**: It has customizable dashboards to visualize and analyze application
    and infrastructure metrics.'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表板**：它具有可定制的仪表板，用于可视化和分析应用程序和基础设施指标。'
- en: By leveraging these tools, you can gain detailed insights into your Java application’s
    performance, quickly detect and resolve issues, and ensure optimal resource utilization
    during auto-scaling events.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过利用这些工具，您可以深入了解Java应用程序的性能，快速检测和解决问题，并在自动扩展事件期间确保最佳资源利用率。
- en: Code example – setting up monitoring and alerting for a Java-based cloud application
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码示例 - 为基于Java的云应用程序设置监控和警报
- en: 'The following example demonstrates how to set up monitoring and alerting for
    a Java-based application using AWS CloudWatch. *Figure 10**.2* illustrates the
    step-by-step process for configuring monitoring and alerting:'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用AWS CloudWatch设置基于Java的应用程序的监控和警报。*图10.2*展示了配置监控和警报的逐步过程：
- en: '![Figure 10.2: CloudWatch agent setup and alert notification workflow](img/B20937_10_02.jpg)'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.2：CloudWatch代理设置和警报通知工作流程](img/B20937_10_02.jpg)'
- en: 'Figure 10.2: CloudWatch agent setup and alert notification workflow'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.2：CloudWatch代理设置和警报通知工作流程
- en: '**Step 1: Configure CloudWatch agent on your** **java application**:'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第1步：在您的** **java应用程序**上配置CloudWatch代理：'
- en: 'Create a CloudWatch agent configuration file (`cloudwatch-config.json`) to
    collect metrics and logs:'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个CloudWatch代理配置文件（`cloudwatch-config.json`）以收集指标和日志：
- en: '[PRE28]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This CloudWatch agent configuration script collects metrics and logs from a
    Java application running on an EC2 instance and sends them to AWS CloudWatch.
    It specifies the metrics to collect (CPU and memory usage) at 60-second intervals,
    along with the log file path. The collected metrics include the EC2 instance ID
    as a dimension, and the logs are stored in a specified CloudWatch Logs group and
    stream. This configuration enables real-time monitoring and analysis of the Java
    application’s performance through CloudWatch.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此CloudWatch代理配置脚本从运行在EC2实例上的Java应用程序收集指标和日志，并将它们发送到AWS CloudWatch。它指定每60秒收集的指标（CPU和内存使用情况），以及日志文件路径。收集的指标包括EC2实例ID作为维度，日志存储在指定的CloudWatch日志组和流中。此配置通过CloudWatch实现Java应用程序性能的实时监控和分析。
- en: '**Step 2: Install and start the** **CloudWatch agent**:'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第2步：安装并启动** **CloudWatch代理**：'
- en: 'Install the CloudWatch agent:'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装CloudWatch代理：
- en: '[PRE29]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Configure the CloudWatch agent:'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置CloudWatch代理：
- en: '[PRE30]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Step 3: Create** **CloudWatch alarms**:'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第3步：创建** **CloudWatch警报**：'
- en: 'Create alarms to monitor CPU utilization and trigger alerts if it exceeds a
    certain threshold:'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建警报以监控CPU利用率，并在超过某个阈值时触发警报：
- en: '[PRE31]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Step 4: Set up SNS for** **alert notifications**:'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第4步：为** **警报通知** **设置SNS**:'
- en: 'Create an SNS topic:'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个SNS主题：
- en: '[PRE32]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Subscribe to the SNS topic:'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅SNS主题：
- en: '[PRE33]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: By following these steps, you can set up comprehensive monitoring and alerting
    for your Java-based cloud application, ensuring you are promptly notified of any
    scaling anomalies and can take immediate action to maintain stability and performance.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，您可以为您基于Java的云应用程序设置全面的监控和警报，确保您能够及时收到任何扩展异常的通知，并可以立即采取行动以保持稳定性和性能。
- en: Having explored the technical aspects of monitoring and alerting, let’s now
    turn our attention to real-world scenarios where companies such as Netflix and
    LinkedIn have successfully implemented Java-based auto-scaling solutions. These
    case studies will offer valuable insights into the practical application of the
    concepts we’ve discussed so far.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在探讨了监控和警报的技术方面之后，现在让我们将注意力转向Netflix和LinkedIn等公司成功实施基于Java的自动扩展解决方案的现实场景。这些案例研究将为我们提供关于我们迄今为止讨论的概念的实际应用的宝贵见解。
- en: Real-world case studies and examples
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现实案例研究和示例
- en: In this section, we will explore real-world examples that demonstrate how Java
    can be effectively utilized in auto-scaling environments. We will delve into case
    studies of industry leaders such as Netflix and LinkedIn, highlighting their implementation
    of auto-scaling solutions and the benefits they have derived from such implementations.
    Additionally, we’ll provide a few more practical examples from other companies
    to offer a broader perspective.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨现实世界的示例，展示Java如何在自动扩展环境中有效利用。我们将深入研究Netflix和LinkedIn等行业领导者的案例研究，突出他们自动扩展解决方案的实施以及从这些实施中获得的好处。此外，我们还将提供其他公司的几个更多实际示例，以提供更广泛的视角。
- en: 'The following example relates to Netflix:'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例与Netflix相关：
- en: '**Background**: It experiences significant demand fluctuations due to varying
    viewer activity, especially during new show releases and peak viewing hours.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**: 它因观众活动的变化而经历显著的需求波动，尤其是在新节目发布和高峰观看时段。'
- en: '**Solution**: It employs a Java-based microservices architecture using tools
    such as Eureka for service discovery, Ribbon for load balancing, and Hystrix for
    fault tolerance. This architecture allows Netflix to seamlessly scale services
    based on demand, ensuring high availability and cost efficiency.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**: 它采用基于Java的微服务架构，使用Eureka进行服务发现、Ribbon进行负载均衡和Hystrix进行容错。这种架构使Netflix能够根据需求无缝扩展服务，确保高可用性和成本效益。'
- en: '**Implementation**:'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施**:'
- en: '**Eureka**: This helps in service discovery, allowing services to find and
    communicate with each other dynamically'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eureka**: 这有助于服务发现，允许服务动态地找到并相互通信'
- en: '**Ribbon**: This provides client-side load balancing to distribute requests
    across multiple instances'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ribbon**: 这为客户端负载均衡提供支持，以在多个实例之间分配请求'
- en: '**Hystrix**: This implements circuit breakers to handle failures gracefully,
    ensuring system resilience'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hystrix**: 这实现断路器以优雅地处理故障，确保系统弹性'
- en: '**Benefits**: During peak times, such as new show releases, Netflix’s streaming
    services automatically scale up to handle increased traffic. This ensures a smooth
    and uninterrupted viewing experience for users while maintaining optimal resource
    utilization.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**好处**: 在高峰时段，如新节目发布时，Netflix的流媒体服务会自动扩展以处理增加的流量。这确保了用户获得平稳且不间断的观看体验，同时保持最佳资源利用。'
- en: 'The following example relates to LinkedIn:'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例与LinkedIn相关：
- en: '**Background**: It needs to handle varying levels of user activity, such as
    job searches, profile updates, and messaging.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**: 它需要处理不同级别的用户活动，例如职位搜索、个人资料更新和消息传递。'
- en: '**Solution**: It utilizes Java in its backend infrastructure for auto-scaling.
    They leverage Apache Samza for real-time data processing, Kafka for managing data
    pipelines, and Helix for cluster management.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**: 它在其后端基础设施中利用Java进行自动扩展。他们利用Apache Samza进行实时数据处理，Kafka管理数据管道，以及Helix进行集群管理。'
- en: '**Implementation**:'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施**：'
- en: '**Apache Samza**: This processes real-time data streams, enabling LinkedIn
    to provide timely insights and updates'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Samza**: 这处理实时数据流，使LinkedIn能够提供及时的信息和更新'
- en: '**Kafka**: This manages data streams, ensuring reliable and scalable message
    brokering'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kafka**: 这管理数据流，确保可靠和可扩展的消息代理'
- en: '**Helix**: This manages clusters, ensuring efficient resource utilization and
    failover mechanisms'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helix**: 这管理集群，确保高效资源利用和故障转移机制'
- en: '**Benefits**: LinkedIn can process and analyze data in real time, providing
    users with up-to-date information and insights. The scalable architecture ensures
    that their services can handle increased user activity without degradation in
    performance.'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**好处**：LinkedIn可以实时处理和分析数据，为用户提供最新信息和洞察。可扩展的架构确保他们的服务在用户活动增加时不会降低性能。'
- en: 'The following example relates to Airbnb:'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下例子与Airbnb相关：
- en: '**Background**: It faces varying traffic loads, especially during holiday seasons
    and special events'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**：它面临变化的流量负载，尤其是在假日季节和特殊活动期间'
- en: '**Solution**: Airbnb uses a combination of Java-based microservices and Kubernetes
    for container orchestration to manage auto-scaling'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：Airbnb使用基于Java的微服务和Kubernetes容器编排来管理自动扩展'
- en: '**Implementation**:'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施**:'
- en: '**Java microservices**: These decompose the application into smaller, manageable
    services that can be independently scaled'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java微服务**：这些将应用程序分解成更小、更易于管理的服务，可以独立扩展'
- en: '**Kubernetes**: It manages containerized applications, automatically scaling
    based on real-time demand'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：它管理容器化应用程序，根据实时需求自动扩展'
- en: '**Benefits**: During peak booking periods, Airbnb’s system can automatically
    scale up to handle the increased load, ensuring a seamless booking experience
    for users and optimal resource use'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**好处**：在预订高峰期，Airbnb的系统可以自动扩展以处理增加的负载，确保用户获得无缝的预订体验并优化资源使用'
- en: 'The following example relates to Spotify:'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下例子与Spotify相关：
- en: '**Background**: It needs to handle a large number of concurrent streams and
    user interactions'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**：它需要处理大量并发流和用户交互'
- en: '**Solution**: It employs a combination of Java-based services and AWS auto-scaling
    to manage its infrastructure'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：它采用基于Java的服务和AWS自动扩展来管理其基础设施'
- en: '**Implementation**:'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施**:'
- en: '**Java services**: They handle core functionalities such as music streaming,
    playlist management, and user recommendations'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java服务**：它们处理核心功能，如音乐流媒体、播放列表管理和用户推荐'
- en: '**AWS auto-scaling**: It adjusts the number of instances based on CPU and memory
    usage to handle varying workloads'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS自动扩展**：它根据CPU和内存使用情况调整实例数量以处理不同的工作负载'
- en: '**Benefits**: Spotify can ensure a high-quality streaming experience even during
    peak usage times, such as new album releases, by dynamically scaling its infrastructure
    to meet user demand'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**好处**：Spotify可以通过动态扩展其基础设施以满足用户需求，即使在高峰使用时间（如新专辑发布）也能确保高质量的流媒体体验'
- en: 'The following example relates to Pinterest:'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下例子与Pinterest相关：
- en: '**Background**: It needs to manage fluctuating traffic loads, especially when
    users upload and share new content'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**：它需要管理波动的流量负载，尤其是在用户上传和分享新内容时'
- en: '**Solution**: It uses Java-based backend services and integrates with KEDA
    for Kubernetes to manage auto-scaling based on event-driven metrics'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：它使用基于Java的后端服务，并与KEDA集成以管理基于事件驱动的指标的Kubernetes自动扩展'
- en: '**Implementation**:'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施**:'
- en: '**Java backend services**: These manage core functionalities such as image
    processing, feed generation, and user interactions'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java后端服务**：这些服务管理核心功能，如图像处理、内容生成和用户交互'
- en: '**KEDA**: It scales the services based on event-driven metrics such as the
    number of uploads and API requests'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KEDA**：它根据事件驱动的指标（如上传数量和API请求）来扩展服务'
- en: '**Benefits**: Pinterest can efficiently handle spikes in user activity by automatically
    scaling its backend services based on real-time events, ensuring a responsive
    and reliable user experience'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**好处**：Pinterest可以通过根据实时事件自动扩展其后端服务来高效地处理用户活动的峰值，确保响应和可靠的用户体验'
- en: These practical examples from Netflix, LinkedIn, Airbnb, Spotify, and Pinterest
    demonstrate the versatility and effectiveness of using Java for auto-scaling in
    diverse environments. By leveraging modern tools and techniques, these companies
    ensure their applications can handle varying workloads efficiently, providing
    optimal performance and resource utilization.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 来自Netflix、LinkedIn、Airbnb、Spotify和Pinterest的这些实际例子展示了使用Java在多种环境中进行自动扩展的灵活性和有效性。通过利用现代工具和技术，这些公司确保其应用程序能够高效地处理不同的工作负载，提供最佳性能和资源利用率。
- en: To solidify our understanding, we will embark on a hands-on journey by constructing
    a real-world simulation project that showcases how Java and cloud services can
    be harnessed to create an auto-scaling solution, with detailed steps and visual
    aids to guide us through the process.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了巩固我们的理解，我们将通过构建一个现实世界的模拟项目来亲身体验，展示如何利用Java和云服务创建自动扩展解决方案，并提供详细的步骤和视觉辅助来引导我们完成整个过程。
- en: Practical application – building scalable Java-based solutions for real-time
    analytics and event-driven auto-scaling
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际应用 – 构建可扩展的基于Java的解决方案，用于实时分析和事件驱动的自动扩展
- en: In this section, we will explore two practical examples that demonstrate how
    Java can be effectively leveraged in building scalable solutions for real-time
    analytics and event-driven auto-scaling. The first example will showcase how to
    implement a Kubernetes-based auto-scaling solution using Java, while the second
    application focuses on developing a Java-based real-time analytics platform using
    AWS services. These two applications highlight the versatility of Java in addressing
    the diverse challenges presented by modern cloud-native architectures, showcasing
    its ability to integrate seamlessly with a range of cloud-based tools and services.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两个实际示例，展示如何有效地利用Java构建可扩展的解决方案，用于实时分析和事件驱动的自动扩展。第一个示例将展示如何使用Java实现基于Kubernetes的自动扩展解决方案，而第二个应用则侧重于开发使用AWS服务的Java实时分析平台。这两个应用突出了Java在解决现代云原生架构带来的各种挑战方面的多功能性，展示了其与各种基于云的工具和服务无缝集成的能力。
- en: Auto-scaling a Java application with Kubernetes
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Kubernetes自动扩展Java应用
- en: 'In this example, we will create a realistic Spring Boot application that simulates
    a simple e-commerce order processing service. This service will have an endpoint
    to place an order, which will simulate some CPU-intensive processing to better
    demonstrate auto-scaling in a real-world scenario. We will use Kubernetes to manage
    the deployment and **Horizontal Pod Autoscaler** (**HPA**) to handle auto-scaling:'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本例中，我们将创建一个真实的Spring Boot应用，模拟简单的电子商务订单处理服务。此服务将有一个放置订单的端点，并模拟一些CPU密集型处理，以更好地展示现实场景中的自动扩展。我们将使用Kubernetes来管理部署，并使用**水平Pod自动缩放器（HPA**）来处理自动扩展：
- en: '**Step 1: Create the Spring** **Boot application**:'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步骤1：创建Spring Boot应用**：'
- en: '`pom.xml`: Enter the dependency:'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pom.xml`：输入依赖项：'
- en: '[PRE34]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Application.java`: This is the entry point of the Spring Boot application.
    It initializes and runs the Spring Boot application:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Application.java`：这是Spring Boot应用的入口点。它初始化并运行Spring Boot应用：'
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`OrderController.java`: This is a REST controller for handling order requests.
    It provides an endpoint to place orders and simulates CPU-intensive processing:'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OrderController.java`：这是一个用于处理订单请求的REST控制器。它提供了一个放置订单的端点并模拟CPU密集型处理：'
- en: '[PRE36]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Step 2: Dockerize** **the Application**:'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步骤2：将应用Docker化**：'
- en: '**Dockerfile**: This defines the Docker image for the application. Specifies
    the base image, sets the working directory, copies the application JAR, and defines
    the entry point to run the application:'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Dockerfile**：这定义了应用的Docker镜像。指定了基本镜像，设置了工作目录，复制了应用JAR文件并定义了运行应用的入口点：'
- en: '[PRE37]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Build and push the Docker image**: Run these Docker commands:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**构建并推送Docker镜像**：运行以下Docker命令：'
- en: '[PRE38]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Step 3: Deploy** **to Kubernetes**:'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步骤3：部署到Kubernetes**：'
- en: '`deployment.yaml`: This defines the deployment of the application in Kubernetes.
    It specifies the application image, the number of replicas, and resource requests
    and limits:'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`deployment.yaml`：这定义了在Kubernetes中的应用部署。它指定了应用镜像、副本数以及资源请求和限制：'
- en: '[PRE39]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`service.yaml`: This defines the service to expose the application. It creates
    a `LoadBalancer` service to expose the application on port `80`:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`service.yaml`：这定义了暴露应用的服务。它创建了一个`LoadBalancer`服务，在端口`80`上暴露应用：'
- en: '[PRE40]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Apply the deployment and service**: Run the following command:'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**应用部署和服务**：运行以下命令：'
- en: '[PRE41]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Step 4: Configure** **the HPA**:'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步骤4：配置HPA**：'
- en: '`hpa.yaml`: This defines the HPA configuration. It specifies the target deployment,
    minimum and maximum replicas, and CPU utilization threshold for scaling:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hpa.yaml`：这定义了HPA配置。它指定了目标部署、最小和最大副本数以及用于扩展的CPU利用率阈值：'
- en: '[PRE42]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Apply the HPA configuration and run the following command:'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用HPA配置并运行以下命令：
- en: '[PRE43]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Step 5:** **Testing auto-scaling**:'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步骤5：测试自动扩展**：'
- en: 'To test the auto-scaling, you can generate load on the application to increase
    CPU usage. Use a tool such as `hey` or `ab` (Apache Benchmark) to send a large
    number of requests to the application. Run these commands:'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要测试自动扩展，您可以在应用程序上生成负载以增加 CPU 使用率。使用 `hey` 或 `ab`（Apache Benchmark）等工具向应用程序发送大量请求。运行以下命令：
- en: '[PRE44]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Monitor the Kubernetes pods to see the auto-scaling in action:'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 监控 Kubernetes pods 以查看自动扩展的实际操作：
- en: '[PRE45]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You should see that the number of pods increases as the load increases and then
    decrease once the load is reduced.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到随着负载的增加，pods 的数量会增加，一旦负载减少，数量就会减少。
- en: In this example, we demonstrated how to containerize the application using Docker
    and deploy it to Kubernetes. Building upon this foundation, the next practical
    application we will explore is developing a serverless real-time analytics pipeline
    using Java and AWS.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例中，我们展示了如何使用 Docker 容器化应用程序并将其部署到 Kubernetes。在此基础上，我们将探索的下一个实际应用是使用 Java
    和 AWS 开发无服务器实时分析管道。
- en: Developing a serverless real-time analytics pipeline using Java and AWS
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Java 和 AWS 开发无服务器实时分析管道
- en: 'We will simulate a real-time analytics platform that processes streaming data
    to generate insights. This platform will use Java-based AWS Lambda functions to
    handle various tasks, including data ingestion, processing, storage, and notification.
    AWS Step Functions will orchestrate these tasks, DynamoDB will be used for data
    storage, AWS SNS for notifications, and API Gateway to expose endpoints:'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将模拟一个实时分析平台，该平台处理流数据以生成洞察。该平台将使用基于 Java 的 AWS Lambda 函数来处理各种任务，包括数据摄取、处理、存储和通知。AWS
    Step Functions 将编排这些任务，DynamoDB 将用于数据存储，AWS SNS 用于通知，API Gateway 用于暴露端点：
- en: '**Step 1: Set up** **the environment**:'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第 1 步：设置** **环境**：'
- en: '**Install Docker**: Ensure Docker is installed on your local machine.'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 Docker**：确保 Docker 已安装在本机。'
- en: '**Install AWS CLI**: Follow the instructions here: [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 AWS CLI**：请按照以下说明进行操作：[https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)。'
- en: '**Install AWS SAM CLI**: Follow the instructions here: [https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html).'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 AWS SAM CLI**：请按照以下说明进行操作：[https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html)。'
- en: '**Step 2: Create Java** **Lambda functions**:'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第 2 步：创建 Java** **Lambda 函数**：'
- en: 'We will need to create several Lambda functions to handle different tasks.
    Let’s use `DataIngestionFunction` as an example:'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要创建几个 Lambda 函数来处理不同的任务。以下以 `DataIngestionFunction` 为例：
- en: '[PRE46]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a Dockerfile:'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个 Dockerfile：
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This Dockerfile sets up a container based on the OpenJDK 11 JRE slim image,
    copies the `DataIngestionFunction-1.0.jar` file into the container, and sets the
    entry point to run the JAR file using `java` `-jar`.
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此 Dockerfile 设置了一个基于 OpenJDK 11 JRE 瘦身镜像的容器，将 `DataIngestionFunction-1.0.jar`
    文件复制到容器中，并设置入口点以使用 `java` `-jar` 运行 JAR 文件。
- en: '**Step 3: Create the** **CloudFormation template**:'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第 3 步：创建** **CloudFormation 模板**：'
- en: Create a `cloudformation-template.yaml` file to define the infrastructure. In
    this crucial step, we’ll define our real-time analytics infrastructure using AWS
    CloudFormation. CloudFormation allows us to describe and provision all the infrastructure
    resources in a declarative way, ensuring consistency and ease of deployment.
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个 `cloudformation-template.yaml` 文件来定义基础设施。在这个关键步骤中，我们将使用 AWS CloudFormation
    定义我们的实时分析基础设施。CloudFormation 允许我们以声明性方式描述和配置所有基础设施资源，确保一致性和部署的简便性。
- en: 'Our template will encompass various AWS services essential for our real-time
    analytics platform, including the following:'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的模板将包括我们实时分析平台所需的各种 AWS 服务，包括以下内容：
- en: DynamoDB for data storage
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB 用于数据存储
- en: '**Simple Storage Service** (**S3**) for processed data'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单存储服务**（**S3**）用于处理后的数据'
- en: SNS for notifications
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNS 用于通知
- en: Lambda functions for data processing
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于数据处理的功能 Lambda
- en: Step Functions for workflow orchestration
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于工作流程编排的 Step Functions
- en: API Gateway for exposing endpoints
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于暴露端点的 API 网关
- en: We’ll break down each resource in the template, explaining its purpose and configuration.
    This approach will give you a clear understanding of how each component fits into
    the overall architecture and how they interact with each other.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将分解模板中的每个资源，解释其目的和配置。这种方法将使您清楚地了解每个组件如何融入整体架构以及它们如何相互交互。
- en: By using CloudFormation, we ensure that our infrastructure is version-controlled,
    easily replicable, and can be updated or rolled back as needed. Let’s dive into
    the details of each resource in our CloudFormation template.
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用 CloudFormation，我们确保我们的基础设施是版本控制的、易于复制的，并且可以根据需要更新或回滚。让我们深入了解 CloudFormation
    模板中每个资源的细节。
- en: 'First, let’s look at the DynamoDB table:'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，让我们看看 DynamoDB 表：
- en: '[PRE48]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`DataIngestionTable` with a primary key of `DataId` to store ingested data.
    It includes provisions for read and write capacities.'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataIngestionTable`，具有 `DataId` 主键以存储摄取数据。它包括读取和写入容量的配置。'
- en: 'Let’s look at the S3 bucket:'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看 S3 存储桶：
- en: '[PRE49]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Explanation**: This resource creates an S3 bucket named processed-data-bucket
    to store processed data files.'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**说明**：此资源创建了一个名为 processed-data-bucket 的 S3 存储桶，用于存储处理后的数据文件。'
- en: 'Let’s look at an SNS topic:'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看一个 SNS 主题：
- en: '[PRE50]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`DataNotificationTopic` to send notifications related to data processing events.'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataNotificationTopic` 用于发送与数据处理事件相关的通知。'
- en: 'Let’s look at an IAM role for Lambda execution:'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看 Lambda 执行的 IAM 角色：
- en: '[PRE51]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Explanation**: This resource defines an IAM role that grants Lambda functions
    permissions to interact with DynamoDB, S3, and SNS.'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**说明**：此资源定义了一个 IAM 角色，授予 Lambda 函数与 DynamoDB、S3 和 SNS 交互的权限。'
- en: '[PRE52]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`DataIngestionFunction` to handle data ingestion tasks. The function is associated
    with the previously defined IAM role for necessary permissions.'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataIngestionFunction` 用于处理数据摄取任务。该函数与之前定义的 IAM 角色相关联，以获得必要的权限。'
- en: 'Let’s look at a Step Functions state machine:'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看一个 Step Functions 状态机：
- en: '[PRE53]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`RealTimeAnalyticsStateMachine` , which orchestrates the data ingestion process
    using `DataIngestionFunction`.'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RealTimeAnalyticsStateMachine`，它使用 `DataIngestionFunction` 协调数据摄取过程。'
- en: 'Let’s look at API Gateway:'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看 API Gateway：
- en: '[PRE54]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`RealTimeAnalyticsApi` to expose endpoints for the real-time analytics platform.'
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RealTimeAnalyticsApi` 用于公开实时分析平台的端点。'
- en: 'Let’s look at a real-time analytics resource:'
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看一个实时分析资源：
- en: '[PRE55]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`RealTimeAnalyticsApi`, creating a path segment/ingest for the data ingestion
    endpoint.'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RealTimeAnalyticsApi`，为数据摄取端点创建路径段/ingest。'
- en: 'Let’s look at an API Gateway method:'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看一个 API Gateway 方法：
- en: '[PRE56]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`POST` method for the `/ingest` endpoint, integrating it with the Step Functions
    state machine to start the data ingestion process.'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/ingest` 端点的 `POST` 方法，将其与 Step Functions 状态机集成以启动数据摄取过程。'
- en: '**Step 4:** **Deploy** **the application**:'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步骤 4：** **部署** **应用程序**：'
- en: 'Build and push the Docker image:'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建并推送 Docker 镜像：
- en: '[PRE57]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Deploy the CloudFormation stack:'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部署 CloudFormation 堆栈：
- en: '[PRE58]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Monitor the stack creation:'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 监控堆栈创建：
- en: '[PRE59]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Verify resources**: Ensure all resources (DynamoDB tables, API Gateway, Lambda
    functions, IAM roles, etc.) are created successfully.'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**验证资源**：确保所有资源（DynamoDB 表、API Gateway、Lambda 函数、IAM 角色、等）创建成功。'
- en: 'Test the API Gateway:'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试 API Gateway：
- en: '[PRE60]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Step** **5:** **Cleanup**:'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步骤 5：** **清理**：'
- en: 'To delete the resources created by the CloudFormation stack:'
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除由 CloudFormation 堆栈创建的资源：
- en: '[PRE61]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This practical project demonstrates how to use Java and cloud services to implement
    an auto-scaling solution for a real-time analytics platform. By following these
    steps, readers will gain hands-on experience in deploying and managing scalable
    Java applications in a cloud environment.
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个实际项目演示了如何使用 Java 和云服务来实现实时分析平台的自动扩展解决方案。通过遵循这些步骤，读者将获得在云环境中部署和管理可扩展 Java 应用程序的实际经验。
- en: Advanced topics
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高级主题
- en: This section will explore advanced techniques such as predictive auto-scaling
    using ML algorithms and integration with cloud-native tools and services, which
    provide more efficient and intelligent scaling solutions for optimal performance
    and cost efficiency.
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节将探讨使用机器学习算法进行预测性自动扩展以及与云原生工具和服务的集成等高级技术，这些技术为最佳性能和成本效率提供了更高效和智能的扩展解决方案。
- en: Predictive auto-scaling using ML algorithms
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用机器学习算法进行预测性自动扩展
- en: '**Predictive auto-scaling**, a more proactive approach than traditional reactive
    methods, harnesses ML algorithms to forecast future demand based on historical
    data and relevant metrics. This allows for optimized resource allocation and improved
    application performance.'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**预测性自动扩展**，比传统的反应性方法更主动的方法，利用机器学习算法根据历史数据和相关指标预测未来需求。这允许优化资源分配并提高应用程序性能。'
- en: 'To implement predictive auto-scaling, follow these steps:'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要实现预测性自动扩展，请按照以下步骤操作：
- en: '**Collect and preprocess data**: Gather historical metrics such as CPU usage,
    memory usage, network traffic, and request rates using monitoring tools (e.g.,
    AWS CloudWatch, Google Cloud Monitoring, or Azure Monitor). Cleanse and preprocess
    this data to handle any missing values, and outliers and ensure consistency.'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**收集和预处理数据**：使用监控工具（例如，AWS CloudWatch、Google Cloud Monitoring或Azure Monitor）收集历史指标，如CPU使用率、内存使用率、网络流量和请求速率。清理和预处理这些数据以处理任何缺失值、异常值并确保一致性。'
- en: '**Train ML models**: Utilize ML algorithms such as linear regression, **autoregressive
    integrated moving average** (**ARIMA**), or more sophisticated techniques such
    as **long short-term memory** (**LSTM**) networks to train models on historical
    data. Cloud-based platforms such as Amazon SageMaker, Google Cloud AI Platform,
    or Azure ML can facilitate this process.'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**训练机器学习模型**：利用机器学习算法，如线性回归、**自回归积分移动平均**（**ARIMA**）或更复杂的技巧，如**长短期记忆**（**LSTM**）网络，在历史数据上训练模型。Amazon
    SageMaker、Google Cloud AI Platform或Azure ML等基于云的平台可以简化此过程。'
- en: '**Deploy and integrate**: Deploy the trained models as services, using either
    serverless functions (e.g., AWS Lambda, Google Cloud Functions, Azure Functions)
    or containerized applications. Integrate these models with your auto-scaling policies,
    enabling them to dynamically adjust resource allocation based on the predictions.'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署和集成**：将训练好的模型作为服务部署，可以使用无服务器函数（例如，AWS Lambda、Google Cloud Functions或Azure
    Functions）或容器化应用程序。将这些模型与您的自动扩展策略集成，使它们能够根据预测动态调整资源分配。'
- en: To demonstrate how these steps can be implemented in practice, let’s take a
    look at a Spring Boot application that integrates with Amazon SageMaker for predictive
    scaling.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了展示这些步骤如何在实践中实现，让我们看看一个与Amazon SageMaker集成的Spring Boot应用程序，用于预测性扩展。
- en: This code snippet demonstrates a Spring Boot application that integrates with
    Amazon SageMaker to perform predictive scaling. It defines a bean that invokes
    a trained linear regression model endpoint in SageMaker and adjusts the auto-scaling
    policies based on the predictions.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个代码片段演示了一个与Amazon SageMaker集成的Spring Boot应用程序，用于执行预测性扩展。它定义了一个bean，该bean在SageMaker中调用一个训练好的线性回归模型端点，并根据预测调整自动扩展策略。
- en: 'The Spring Boot application is `PredictiveScalingApplication.java`. Train the
    model in SageMaker:'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Spring Boot应用程序是`PredictiveScalingApplication.java`。在SageMaker中训练模型：
- en: '[PRE62]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this Java-based Spring Boot application, we define a `predictiveScaling()`
    function that takes input data, sends it to a designated SageMaker endpoint for
    prediction, and then adjusts auto-scaling policies based on the returned prediction.
    Remember to replace the placeholder endpoint name (`"linear-endpoint"`) with your
    actual SageMaker endpoint. While this example focuses on the integration with
    an existing endpoint, typically, you would first train a model in SageMaker using
    appropriate algorithms such as linear regression or time series forecasting to
    generate these predictions. The choice of algorithm will depend on your specific
    use case. The `adjustAutoScalingBasedOnPrediction()` method is where you would
    implement the logic for adjusting auto-scaling policies using the AWS auto-scaling
    API or other relevant services.
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个基于Java的Spring Boot应用程序中，我们定义了一个`predictiveScaling()`函数，该函数接收输入数据，将其发送到指定的SageMaker端点进行预测，然后根据返回的预测调整自动扩展策略。请记住将占位符端点名称（`"linear-endpoint"`）替换为您的实际SageMaker端点。虽然这个例子侧重于与现有端点的集成，但通常，您首先需要在SageMaker中使用适当的算法（如线性回归或时间序列预测）来训练模型以生成这些预测。算法的选择将取决于您的特定用例。`adjustAutoScalingBasedOnPrediction()`方法是您实现使用AWS自动扩展API或其他相关服务调整自动扩展策略逻辑的地方。
- en: The `application.yaml` file is a crucial configuration component in Spring Boot
    applications, serving as a central place to define various application settings.
    In the context of our predictive scaling function for AWS Lambda, this file plays
    a particularly important role.
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`application.yaml`文件是Spring Boot应用程序中的一个关键配置组件，它作为一个中心位置来定义各种应用程序设置。在我们的AWS
    Lambda预测性扩展功能中，这个文件扮演着特别重要的角色。'
- en: 'Let’s examine the key configuration:'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们检查关键配置：
- en: '[PRE63]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This concise yet powerful configuration does several important things:'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此简洁而强大的配置做了几件重要的事情：
- en: It utilizes **Spring Cloud Function**, a project that simplifies the development
    of serverless applications.
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它利用了 **Spring Cloud Function**，这是一个简化无服务器应用程序开发的计划。
- en: The `predictiveScaling` definition line is especially significant. It tells
    Spring Cloud Function that our `predictiveScaling` function (which we’ll define
    in our `PredictiveScalingApplication` class) should be the primary entry point
    for our serverless application.
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predictiveScaling` 定义行尤其重要。它告诉 Spring Cloud Function，我们的 `predictiveScaling`
    函数（我们将在 `PredictiveScalingApplication` 类中定义）应该是我们无服务器应用程序的主要入口点。'
- en: This configuration ensures that when our Spring Boot application is built and
    packaged, the `predictiveScaling` function is properly included and set up as
    the main executable component.
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此配置确保当我们的 Spring Boot 应用程序构建和打包时，`predictiveScaling` 函数被正确包含并设置为主要的可执行组件。
- en: Understanding this configuration is crucial as it bridges the gap between our
    Spring Boot application and the serverless environment of AWS Lambda. It enables
    our Java code to seamlessly integrate with the cloud infrastructure, allowing
    us to focus on the business logic of predictive scaling rather than the intricacies
    of serverless deployment.
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理解此配置至关重要，因为它在我们 Spring Boot 应用程序和无服务器环境 AWS Lambda 之间架起了桥梁。它使我们的 Java 代码能够无缝集成到云基础设施中，使我们能够专注于预测扩展的业务逻辑，而不是无服务器部署的复杂性。
- en: 'Let’s take a look at the Dockerfile:'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看 Dockerfile：
- en: '[PRE64]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This Dockerfile sets up a container based on the OpenJDK 11 JRE slim image,
    copies the predictive scaling JAR file into the container, and sets the entry
    point to run the JAR file.
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此 Dockerfile 基于 OpenJDK 11 JRE 瘦身镜像设置容器，将预测扩展 JAR 文件复制到容器中，并将入口点设置为运行 JAR 文件。
- en: 'Build and push the Docker image:'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建并推送 Docker 镜像：
- en: '[PRE65]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Replace `<aws-account-id>` with your actual AWS account ID. Open your terminal
    and navigate to the project directory containing your Dockerfile. Run the preceding
    command.
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `<aws-account-id>` 替换为您的实际 AWS 账户 ID。打开您的终端，导航到包含您的 Dockerfile 的项目目录。运行前面的命令。
- en: This script builds a Docker image tagged `predictive-scaling-app`, then tags
    it for an Amazon ECR repository in the `us-east-1` region. It then logs into that
    ECR repository using AWS credentials, preparing the image for deployment to a
    cloud environment.
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此脚本构建了一个标记为 `predictive-scaling-app` 的 Docker 镜像，然后将其标记为位于 `us-east-1` 区域的 Amazon
    ECR 仓库。接着，它使用 AWS 凭据登录到该 ECR 仓库，为将镜像部署到云环境做准备。
- en: Integration with cloud-native tools and services
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与云原生工具和服务的集成
- en: To enhance the deployment and management of our predictive scaling application,
    we can integrate it with popular cloud-native tools and services. Let’s explore
    how we can leverage Kubernetes, Istio, and AWS SAM to improve our application’s
    scalability, observability, and infrastructure management.
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了增强我们的预测扩展应用程序的部署和管理，我们可以将其与流行的云原生工具和服务集成。让我们探讨如何利用 Kubernetes、Istio 和 AWS
    SAM 来提高我们应用程序的可扩展性、可观察性和基础设施管理。
- en: Kubernetes
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Kubernetes
- en: '**Kubernetes** is a powerful container orchestration platform that enables
    automated deployment, scaling, and management of containerized applications. One
    of the key features of Kubernetes is the HPA, which allows us to automatically
    scale the number of pods based on CPU utilization or other custom metrics.'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Kubernetes** 是一个强大的容器编排平台，它使容器化应用程序的自动化部署、扩展和管理成为可能。Kubernetes 的一个关键特性是 HPA（自动扩展），它允许我们根据
    CPU 利用率或其他自定义指标自动扩展 pod 的数量。'
- en: 'Here’s an example of an HPA configuration:'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个 HPA 配置的示例：
- en: '[PRE66]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This configuration defines an HPA that targets a deployment named `java-app`.
    It specifies the minimum and maximum number of replicas and sets the target CPU
    utilization to 50%. Kubernetes will automatically scale the number of pods based
    on the observed CPU utilization, ensuring that our application can handle varying
    levels of traffic.
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此配置定义了一个针对名为 `java-app` 的部署的 HPA。它指定了副本的最小和最大数量，并将目标 CPU 利用率设置为 50%。Kubernetes
    将根据观察到的 CPU 利用率自动扩展 pod 的数量，确保我们的应用程序能够处理不同级别的流量。
- en: 'To apply this HPA configuration to your Kubernetes cluster, save the configuration
    as a YAML file (e.g., `hpa.yaml`) and run the following command in your terminal:'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将此 HPA 配置应用到您的 Kubernetes 集群，将配置保存为 YAML 文件（例如，`hpa.yaml`），然后在您的终端中运行以下命令：
- en: '[PRE67]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Istio service mesh
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Istio 服务网格
- en: '**Istio** is a powerful service mesh that provides a wide range of features
    for managing microservices in a distributed environment. It enables fine-grained
    traffic control, observability, and security for our application.'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Istio**是一个强大的服务网格，它为分布式环境中管理微服务提供了一系列功能。它为我们应用程序提供了细粒度的流量控制、可观察性和安全性。'
- en: 'Here’s an example of an Istio `VirtualService` configuration:'
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个Istio `VirtualService`配置的示例：
- en: '[PRE68]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This `VirtualService` configuration defines routing rules for our Java application.
    It specifies that 50% of the traffic should be routed to subset `v1` and the other
    50% to subset `v2`. This allows us to implement advanced deployment strategies
    such as canary releases or A/B testing.
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`VirtualService`配置定义了我们的Java应用程序的路由规则。它指定50%的流量应该路由到子集`v1`，其余50%路由到子集`v2`。这使我们能够实现诸如金丝雀发布或A/B测试的高级部署策略。
- en: 'To apply this Istio `VirtualService` configuration in your Kubernetes cluster,
    follow these steps:'
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在您的Kubernetes集群中应用此Istio `VirtualService`配置，请按照以下步骤操作：
- en: '`VirtualService` configuration as a YAML file (e.g., `virtual-service.yaml`).'
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`VirtualService`配置作为一个YAML文件（例如，`virtual-service.yaml`）。
- en: '**Apply configuration**: Open your terminal and run the following command:'
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用配置**：打开您的终端并运行以下命令：'
- en: '[PRE69]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: AWS SAM
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: AWS SAM
- en: AWS SAM is a framework that extends AWS CloudFormation to define and manage
    serverless applications. It provides a simplified syntax for defining AWS Lambda
    functions, API Gateway endpoints, and other serverless resources.
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: AWS SAM是一个框架，它扩展了AWS CloudFormation以定义和管理无服务器应用程序。它提供了一种简化的语法来定义AWS Lambda函数、API网关端点和其他无服务器资源。
- en: 'Here’s an example of a SAM template defining a Lambda function:'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个定义Lambda函数的SAM模板的示例：
- en: '[PRE70]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This template defines a Lambda function resource named `PredictiveScalingFunction`
    with properties such as the function name, the fully qualified name of the Java
    method serving as the entry point, the IAM role granting permissions, the runtime
    environment (Java 11), the maximum allowed execution time (30 seconds), the allocated
    memory (1,024 MB), the location of the function code in an S3 bucket, and an environment
    variable indicating the name of the function to be invoked.
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模板定义了一个名为`PredictiveScalingFunction`的Lambda函数资源，具有诸如函数名称、作为入口点的Java方法的完全限定名称、授予权限的IAM角色、运行时环境（Java
    11）、最大允许执行时间（30秒）、分配的内存（1,024 MB）、函数代码在S3存储桶中的位置以及指示要调用的函数名称的环境变量等属性。
- en: 'To implement this, do the following:'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要实现这一点，请执行以下操作：
- en: '`template.yaml`).'
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: （`template.yaml`）。
- en: '**Install SAM CLI**: If you haven’t already, install the AWS SAM CLI ([https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html)).'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装SAM CLI**：如果您还没有安装，请安装AWS SAM CLI（[https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html)）。'
- en: '`template.yaml` and run `sam build`. This will build your function code and
    prepare it for deployment.'
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`sam build`。这将构建您的函数代码并准备部署。
- en: '`sam deploy –guided` and follow the prompts to deploy your function to AWS
    Lambda.'
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sam deploy –guided`并按照提示将您的函数部署到AWS Lambda。
- en: Now, your Java Lambda function is running in the cloud, ready to be triggered
    by events or invoked directly.
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您的Java Lambda函数已经在云中运行，准备好由事件触发或直接调用。
- en: By leveraging these cloud-native tools and services, we can enhance the scalability,
    observability, and management of our predictive scaling application. Kubernetes
    enables automated scaling based on resource utilization, Istio provides advanced
    traffic management and observability features, and AWS SAM simplifies the definition
    and deployment of serverless components.
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过利用这些云原生工具和服务，我们可以增强我们预测性扩展应用程序的可伸缩性、可观察性和管理能力。Kubernetes允许基于资源利用率进行自动化扩展，Istio提供了高级流量管理和可观察性功能，而AWS
    SAM简化了无服务器组件的定义和部署。
- en: Summary
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the synchronization of Java’s concurrency models
    with cloud auto-scaling dynamics. We delved into the fundamentals of cloud auto-scaling,
    examining how Java’s concurrency tools can be leveraged to optimize applications
    for scalability. Key discussions included best practices for enhancing Java application
    performance, monitoring and managing Java processes during auto-scaling events,
    and real-world case studies from industry leaders such as Netflix and LinkedIn.
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Java并发模型与云自动扩展动态的同步。我们深入研究了云自动扩展的基本原理，探讨了如何利用Java的并发工具来优化应用程序的可扩展性。关键讨论包括提高Java应用程序性能的最佳实践、在自动扩展事件期间监控和管理Java进程，以及来自Netflix和LinkedIn等行业领导者的实际案例研究。
- en: We also walked through a practical project that demonstrated the deployment
    and management of a scalable Java-based real-time analytics platform using AWS
    services and Docker. Advanced topics such as predictive auto-scaling using ML
    and the integration of Java applications with cloud-native tools such as Kubernetes,
    Istio, and AWS SAM were covered to provide a comprehensive understanding of modern
    scaling solutions.
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还介绍了一个实际项目，展示了使用AWS服务和Docker部署和管理可扩展的基于Java的实时分析平台。涵盖了预测性自动扩展使用机器学习以及Java应用程序与Kubernetes、Istio和AWS
    SAM等云原生工具的集成等高级主题，以提供对现代扩展解决方案的全面理解。
- en: The skills and knowledge gained from this chapter are essential for building
    robust, scalable, and cost-effective Java applications in cloud environments.
    By mastering these techniques, readers can ensure optimal performance, efficient
    resource utilization, and seamless adaptability to the demands of contemporary
    cloud-based systems.
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从本章中获得的知识和技能对于在云环境中构建健壮、可扩展和成本效益高的Java应用程序至关重要。通过掌握这些技术，读者可以确保最佳性能、高效资源利用，并能够无缝适应现代基于云的系统需求。
- en: In the next chapter, *Advanced Java Concurrency Practices in Cloud Computing*,
    we will delve deeper into the intricacies of concurrent Java applications optimized
    for cloud environments. We will explore powerful techniques such as leveraging
    GPU computing, utilizing **Compute Unified Device Architecture** (**CUDA**) and
    OpenCL libraries, and integrating Java with native libraries for unparalleled
    parallel execution. This chapter will equip readers with a robust toolkit to ensure
    their Java applications remain resilient and ultra-performant in any cloud setting,
    advancing their skills to the next level.
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章“云计算中的高级Java并发实践”中，我们将更深入地探讨针对云环境优化的并发Java应用程序的复杂性。我们将探讨利用GPU计算、利用**统一计算设备架构**（**CUDA**）和OpenCL库，以及将Java与本地库集成以实现无与伦比的并行执行等强大技术。本章将为读者提供一套强大的工具集，以确保他们的Java应用程序在任何云环境中都保持弹性并具有超高性能，将他们的技能提升到下一个水平。
- en: Questions
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题
- en: What is the primary advantage of cloud auto-scaling in Java applications?
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java应用程序中，云自动扩展的主要优势是什么？
- en: Manual monitoring and scaling
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动监控和扩展
- en: Fixed resource allocation
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固定资源分配
- en: Dynamic resource allocation based on demand
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需求动态资源分配
- en: Increased operational overhead
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加操作开销
- en: Which Java concurrency tool is essential for managing asynchronous tasks in
    cloud auto-scaling environments?
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在云自动扩展环境中，哪个Java并发工具对于管理异步任务是必不可少的？
- en: '`ThreadLocal`'
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ThreadLocal`'
- en: '`CompletableFuture`'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`'
- en: '`StringBuilder`'
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StringBuilder`'
- en: '`InputStream`'
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InputStream`'
- en: What is the role of `ExecutorService` in Java’s concurrency model for cloud
    auto-scaling?
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java的并发模型中，`ExecutorService`在云自动扩展中扮演什么角色？
- en: Managing a fixed number of threads
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理固定数量的线程
- en: Encrypting data
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密数据
- en: Handling single-threaded tasks only
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅处理单线程任务
- en: Directly handling HTTP requests
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接处理HTTP请求
- en: Which practice is recommended for optimizing Java applications for cloud scalability?
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种实践推荐用于优化Java应用程序的云可扩展性？
- en: Using synchronous processing
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用同步处理
- en: Avoiding the use of caching
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免使用缓存
- en: Implementing stateless services
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现无状态服务
- en: Designing monolithic applications
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计单体应用程序
- en: What benefit do parallel streams provide in Java applications with respect to
    cloud auto-scaling?
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java应用程序中，并行流相对于云自动扩展提供了什么好处？
- en: Simplifying error handling
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化错误处理
- en: Blocking the main thread
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阻塞主线程
- en: Improving performance through concurrent data processing
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过并发数据处理提高性能
- en: Reducing the need for load balancing
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少负载均衡的需求
- en: '[PRE71]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
