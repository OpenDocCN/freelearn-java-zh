- en: Chapter 3. Building a Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。构建 Web 应用程序
- en: Now that we have seen the ease of using Gradle for building a command-line Java
    application, we shouldn't be surprised to know that building web applications
    based on Java servlet specification is also equally easy with Gradle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了使用 Gradle 构建命令行 Java 应用程序的便捷性，我们不应该对基于 Java servlet 规范构建 web 应用程序也同样容易感到惊讶。
- en: In this chapter, we will build a simple web application first, which is distributed
    as a `WAR` file that can be deployed to any servlet container. Then, we will take
    a look at how dependencies and repositories are configured in a build file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先构建一个简单的 web 应用程序，它以 `WAR` 文件的形式分发，可以部署到任何 servlet 容器。然后，我们将看看如何在构建文件中配置依赖项和仓库。
- en: Building a simple Java web project
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建简单的 Java web 项目
- en: Again, we will keep our application as minimal as possible and create a web-enabled
    version of the application, which we developed in the last chapter. The application
    will provide the user a form to input their name and a **Submit** button. When
    the user clicks on the **Submit** button, the greeting will be displayed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将使我们的应用程序尽可能简单，并创建一个基于上一章开发的 web 版本的应用程序。该应用程序将提供一个用户输入姓名的表单和一个 **提交**
    按钮。当用户点击 **提交** 按钮时，将显示问候语。
- en: The application will be based on Servlet 3.1 specification. We will reuse the
    `GreetService` that we developed in the previous chapter. The form will be served
    by a static HTML file, which can post data to our servlet. The servlet will create
    a greeting message and forward it to a JSP for rendering.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将基于 Servlet 3.1 规范。我们将重用上一章中开发的 `GreetService`。表单将由静态 HTML 文件提供服务，该文件可以将数据发送到我们的
    servlet。servlet 将创建一个问候消息并将其转发到 JSP 进行渲染。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on Servlet specification 3.1, go to [https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Servlet 规范 3.1 的详细信息，请访问 [https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html)。
- en: Creating source files
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建源文件
- en: Let's create the root of the project as `hello-web`. The structure is similar
    to what we had seen for a simple Java application, with one addition, which is
    the web app root. The Web app root, by default, is located at `src/main/webapp`.
    Those who are familiar with Maven will immediately notice that it's the same path
    used by Maven as well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `hello-web` 作为项目的根目录。其结构类似于我们之前看到的简单 Java 应用程序的结构，增加了一个新的部分，即 web 应用程序根目录。默认情况下，web
    应用程序根目录位于 `src/main/webapp`。熟悉 Maven 的人会立刻注意到，这个路径与 Maven 使用的路径相同。
- en: The Web app root (`webapp`) contains all the public resources required to run
    a web application, which includes dynamic pages such as JSPs or the files required
    for other view template engines such as Thymeleaf, FreeMarker, Velocity, and so
    on; as well as static resources such as HTML, CSS, JavaScript, and image files;
    and other configuration files such as `web.xml` in the special directory called
    `WEB-INF`. The files stored in `WEB-INF` are not directly accessible to the client;
    hence, it is a perfect place to store protected files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序根目录（`webapp`）包含运行 web 应用程序所需的所有公共资源，包括动态页面，如 JSP 或其他视图模板引擎（如 Thymeleaf、FreeMarker、Velocity
    等）所需的文件；以及静态资源，如 HTML、CSS、JavaScript 和图像文件；以及特殊目录 `WEB-INF` 中的其他配置文件，如 `web.xml`。存储在
    `WEB-INF` 中的文件不能直接被客户端访问；因此，这是一个存储受保护文件的完美位置。
- en: 'We will begin with creating the directory structure for what the final application
    should look like:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始创建最终应用程序应具有的目录结构：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, perform the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行以下步骤：
- en: Let's first add the familiar `GreetingService` from the last chapter to our
    sources. We might notice that copying the Java source file is not a right way
    to reuse. There are much better ways to organize such dependencies. One such way
    is with multimodule projects. We will see this in [Chapter 5](part0035_split_000.html#11C3M1-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 5. Multiprojects Build"), *Multiprojects Build*.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先添加上一章中熟悉的 `GreetingService` 到我们的源代码中。我们可能会注意到，复制 Java 源文件并不是重用的正确方式。有更好的方法来组织这样的依赖。其中一种方法就是使用多模块项目。我们将在
    [第 5 章](part0035_split_000.html#11C3M1-e78ecbb3ac0544f19c59f96d594821c0 "第 5 章。多项目构建")
    中看到这一点，*多项目构建*。
- en: 'Now, add the following content to the `index.html` file:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下内容添加到 `index.html` 文件中：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file starts with an HTML 5 `doctype` declaration, which is the most simple
    `doctype` we can use. Then, we create a form that will post to `greet` endpoint
    (it is a relative path to the page).
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件以HTML 5的`doctype`声明开始，这是我们能够使用的最简单的`doctype`。然后，我们创建一个表单，它将向`greet`端点（它是页面的一个相对路径）发送POST请求。
- en: 'Now, at the heart of this application, there is the `GreetServlet` that responds
    to the post request:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这个应用程序的核心部分，有一个名为`GreetServlet`的servlet，它响应POST请求：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code , the `WebServlet` annotation's value maps this servlet
    to the `/greet` path relative to the context of the application. Then, an instance
    of `GreetService` is made available in this servlet. The overridden method `doPost`
    extracts the name from the `request` object, generates the greeting message, sets
    this message back in the `request` as an attribute so that it's accessible in
    the JSP, and then finally forwards the request to the `greet.jsp` file that is
    located at `/WEB-INF/greet.jsp`.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`WebServlet`注解的值将这个servlet映射到应用程序上下文中的`/greet`路径。然后，在这个servlet中创建了一个`GreetService`实例。重写的方法`doPost`从`request`对象中提取名称，生成问候信息，将此消息作为属性设置回`request`，以便在JSP中访问，然后最终将请求转发到位于`/WEB-INF/greet.jsp`的`greet.jsp`文件。
- en: 'This brings us to the `greet.jsp` file, which is kept in `WEB-INF` so that
    it''s not directly accessible and the request has to always come through the servlet
    that sets the right request attributes:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们到`greet.jsp`文件，它被保存在`WEB-INF`中，这样它就不能直接访问，并且请求必须始终通过设置正确请求属性的servlet来传递：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This JSP just prints the `message` that is available in the request attribute.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个JSP只是打印出在请求属性中可用的`message`。
- en: Creating a build file
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构建文件
- en: 'Finally, let''s create the file we''ve been waiting for—the `build.gradle`
    file —in the root of the project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在项目的根目录中创建我们一直在等待的文件——`build.gradle`文件：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s try to understand this file now:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试理解这个文件：
- en: The first line applies the `war` plugin to the project. This plugin adds a `war`
    task to the project. One might wonder why we don't need to apply the `java` plugin
    to compile the classes. This is because the `war` plugin extends the `java` plugin;
    so all the tasks that were available when we applied the `java` plugin are still
    available to us in addition to the `war` task.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将`war`插件应用于项目。此插件向项目添加一个`war`任务。有人可能会想知道为什么我们不需要应用`java`插件来编译类。这是因为`war`插件扩展了`java`插件；因此，当我们应用`java`插件时所有可用的任务仍然可用，除了`war`任务。
- en: Next, comes the `repositories` section that configures our build to look for
    all the dependencies in the Maven central repository.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`repositories`部分，它配置我们的构建过程以在Maven中央仓库中查找所有依赖项。
- en: 'Lastly, in the `dependencies` block, we add `servlet-api` to the `providedCompile`
    configuration (scope). This tells Gradle not to package the servlet API with the
    application, as it will already be available on the container where the application
    will be deployed. The `providedCompile` configuration is added by the `war` plugin
    (it also adds `providedRuntime`). If we had any other dependency that needs to
    be packaged with our application, it would have been declared using the compile
    configuration. For example, if our app depends on the Spring Framework, then the
    dependencies section might have looked as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`dependencies`块中，我们将`servlet-api`添加到`providedCompile`配置（范围）。这告诉Gradle不要将servlet
    API打包到应用程序中，因为它将在应用程序部署的容器中已经可用。`providedCompile`配置是由`war`插件添加的（它还添加了`providedRuntime`）。如果我们有任何其他需要与我们的应用程序一起打包的依赖项，它将使用编译配置声明。例如，如果我们的应用程序依赖于Spring框架，那么依赖项部分可能看起来如下：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Don't worry if it feels like the details on `repositories`, `configurations`
    and `dependencies` are a bit sketchy. We will soon see them again, in more detail,
    later in this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果觉得`repositories`、`configurations`和`dependencies`的细节有点模糊，请不要担心。我们很快将在本章的后面部分更详细地看到它们。
- en: Building the artifact
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建工件
- en: 'Now that our source files are ready with the build file, we must build the
    deployable WAR file. Let''s verify the tasks available for our build using the
    following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了构建文件，我们必须构建可部署的WAR文件。让我们使用以下命令来验证我们的构建任务：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will notice the `war` task there, which depends on `classes` (task). We
    don''t need to explicitly compile and build the Java sources, which is automatically
    taken care of by the `classes` task. So all that we need to do now is, use the
    following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到那里的`war`任务，它依赖于`classes`（任务）。我们不需要显式地编译和构建Java源代码，这由`classes`任务自动处理。所以我们现在需要做的就是，使用以下命令：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the build is complete, we will see the directory''s structure similar
    to following structure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，我们将看到目录结构类似于以下结构：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The war file is created at `/build/libs/hello-web.war`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WAR文件创建在`/build/libs/hello-web.war`。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `war` file is nothing but a ZIP file with a different file extension. The
    same holds true for an `.ear` or `.jar` file for that matter. We can use the standard
    zip/unzip tools too or use the JDK's `jar` utility to perform various operations
    on these files. To list the contents of WAR, use `jar -tf build/libs/hello-web.war`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`war`文件不过是一个具有不同文件扩展名的ZIP文件。对于`.ear`或`.jar`文件也是如此。我们可以使用标准的zip/unzip工具，或者使用JDK的`jar`实用程序对这些文件执行各种操作。要列出WAR的内容，使用`jar
    -tf build/libs/hello-web.war`。'
- en: 'Let''s check the content of this WAR file once:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个WAR文件的内容：
- en: …
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Perfect. The compiled classes landed into the `WEB-INF/classes` directory. The
    servlet API's JAR is not included as it was in the `providedCompile` scope.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。编译后的类已经落在`WEB-INF/classes`目录中。servlet API的JAR文件没有包含在内，因为它在`providedCompile`范围内。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Exercise**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: Add `compile 'org.springframework:spring-context:4.0.6.RELEASE'` in the `dependencies`
    section and then do a `gradle war` file and see the content of the created WAR.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dependencies`部分添加`compile 'org.springframework:spring-context:4.0.6.RELEASE'`，然后执行`gradle
    war`文件，查看创建的WAR文件的内容。
- en: Running the web application
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行web应用
- en: We have come a long way in creating the web-app. However, to use it, it must
    be deployed to a servlet container. It can be classically deployed to a servlet
    container by copying the `.war` file in the servlet container's designated directory
    (such as `webapps` in the case of Tomcat). Alternatively, a more recent technique
    can be used to embed a Servlet container into a Java app, which is packaged as
    a `.jar` and is run as any other `java –jar` command.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建web-app方面已经走了很长的路。然而，为了使用它，它必须部署到一个servlet容器中。可以通过复制servlet容器指定目录（例如Tomcat中的`webapps`）中的`.war`文件来经典地部署到servlet容器中。或者，可以使用一种更近期的技术将Servlet容器嵌入到Java应用中，该应用被打包为`.jar`文件，并以任何其他`java
    –jar`命令运行。
- en: 'Web apps are typically run in three modes, development, functional testing,
    and production. The key characteristics of all the three modes differ as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用通常以三种模式运行，开发、功能测试和生产。所有三种模式的关键特性如下有所不同：
- en: The key characteristics of running web in development mode is faster deployment
    (preferably hot reloads), quick server start and shutdown, very low server footprint,
    and so on.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发模式下运行web的关键特性包括更快的部署（最好是热重载）、快速的服务器启动和关闭、非常低的服务器占用空间等。
- en: While in functional testing, we typically deploy `web-app` once for the entire
    test suite's run. We need to mimic production-like behavior of an app as much
    as possible. We need to set up and destroy the web-app's state (such as databases),
    using lightweight databases (preferably in-memory) for all tests. We also need
    to mock external services.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在功能测试期间，我们通常在整个测试套件的运行中只部署一次`web-app`。我们需要尽可能地模拟应用的生产类似行为。我们需要设置和销毁web-app的状态（如数据库），对于所有测试使用轻量级数据库（最好是内存中的）。我们还需要模拟外部服务。
- en: Whereas, in production deployments, the app-servers' (whether standalone or
    embedded) configuration, security, optimization of app, caches, and so on, takes
    more precedence, features such as hot reloading deployments are rarely used; faster
    startup time takes lesser precedence.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比之下，在生产部署中，应用服务器（无论是独立还是嵌入）的配置、安全性、应用优化、缓存等，具有更高的优先级；像热部署这样的特性很少使用；更快的启动时间具有较低的优先级。
- en: We will only cover the development scenario in this chapter. We will start with
    the traditional way to highlight its problems and then move on to Gradle's way.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中仅涵盖开发场景。我们将从传统的做法开始，以突出其问题，然后转向Gradle的方式。
- en: 'Now, if we need to deploy the war in a manual way. We can choose any Java servlet
    container such as Jetty or Tomcat to run our web-app. In this example, let''s
    use Tomcat. Assuming Tomcat is installed at`~/tomcat` or `C:\tomcat` (based on
    the OS that we are using):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要手动部署 war 文件。我们可以选择任何 Java Servlet 容器，例如 Jetty 或 Tomcat 来运行我们的 Web 应用。在这个例子中，让我们使用
    Tomcat。假设 Tomcat 安装在 `~/tomcat` 或 `C:\tomcat`（根据我们使用的操作系统）：
- en: If the server is running, ideally we should stop it.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务器正在运行，理想情况下我们应该停止它。
- en: Copy the WAR file to the Tomcat's `webapp` (`~/tomcat/webapps`) directory.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 WAR 文件复制到 Tomcat 的 `webapp` (`~/tomcat/webapps`) 目录。
- en: Then, start the Tomcat server using `~/tomcat/bin/startup.sh` or `C:\tomcat\bin\startup.bat`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `~/tomcat/bin/startup.sh` 或 `C:\tomcat\bin\startup.bat` 启动 Tomcat 服务器。
- en: However, this kind of deployment feels outdated in Gradle's age. Especially,
    while developing the web-app, we have to constantly package the application as
    a `war`, copy the latest version to the container, and restart the container to
    get the latest code running. When we say build automation, it implicitly means
    that no manual intervention should be expected and things should work in one click
    (or one command in Gradle's case). Also, luckily, there are many options to achieve
    this level of automation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Gradle 的时代，这种部署方式感觉已经过时了。特别是，在开发 Web 应用时，我们必须不断将应用程序打包成 `war` 文件，将最新版本复制到容器中，并重新启动容器以运行最新代码。当我们说构建自动化时，这隐含着不需要手动干预，一切应该一键（或在
    Gradle 的情况下，一键命令）完成。幸运的是，有许多选项可以实现这种程度的自动化。
- en: Plugins to the rescue
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插件拯救
- en: Out of the box, Gradle has no support for modern servlet containers. However,
    this is the beauty of Gradle's architecture. Innovation and/or implementation
    does not have to come from a selected few who are creating Gradle. With the help
    of plugins API, anyone can create functionally rich plugins. We are going to use
    a plugin called Gretty for our web-app's development time deployment, but you
    should also check out others to see what works the best for you.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Gradle 不支持现代 Servlet 容器。然而，这正是 Gradle 架构的美丽之处。创新和/或实现不必来自少数几个创建 Gradle
    的人。借助插件 API，任何人都可以创建功能丰富的插件。我们将使用一个名为 Gretty 的插件来为我们的 Web 应用开发时间部署，但你也应该检查其他插件，看看哪个最适合你。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a `jetty` plugin available, which is shipped with Gradle. However,
    it has not been actively updated; hence, it officially supports only Jetty 6.x
    (as of this writing). So we can use it if our web application is based on Servlet
    2.5 specification or lower.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可用 `jetty` 插件，该插件随 Gradle 一起提供。然而，它并未得到积极更新；因此，它官方只支持 Jetty 6.x（截至本文撰写时）。所以，如果我们的
    Web 应用基于 Servlet 2.5 规范或更低版本，我们可以使用它。
- en: A Gretty plugin can be found at a Gradle plugin portal (look at the references
    below). This plugin adds numerous tasks to the build and supports various versions
    of Tomcat and Jetty. Installing it cannot be any easier. The code for this uses
    the same `hello-web` source from the last section, but updates the `build.gradle`
    file. An entire source code for this example can be found in the `chapter-03/hello-gretty`
    directory of the book's sample code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Gretty 插件可以在 Gradle 插件门户中找到（请参阅以下参考）。此插件为构建添加了众多任务，并支持 Tomcat 和 Jetty 的各种版本。安装它非常简单。此代码使用与上一节相同的
    `hello-web` 源代码，但更新了 `build.gradle` 文件。此示例的完整源代码可以在书籍示例代码的 `chapter-03/hello-gretty`
    目录中找到。
- en: 'Just include the following at the first line of `build.gradle`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 `build.gradle` 的第一行包含以下内容：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That''s it—we are done. This is relatively a new syntax for applying plugins
    to builds, which was added in Gradle 2.1\. This is especially useful for applying
    third-party plugins. Unlike calling the `apply` method to apply the plugin, we
    start with the plugin block on the first line. Then, we specify the plugin''s
    ID. For applying an external plugin, we must use the fully qualified plugin ID
    and version. We can include the `war` plugin''s application inside this block.
    For internal plugins, we don''t need to specify a version. It will look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们完成了。这是 Gradle 中应用插件的新语法，它是在 Gradle 2.1 中添加的。这对于应用第三方插件特别有用。与调用 `apply`
    方法应用插件不同，我们从第一行的插件块开始。然后，我们指定插件的 ID。对于应用外部插件，我们必须使用完全限定的插件 ID 和版本。我们可以在该块内包含 `war`
    插件的应用。对于内部插件，我们不需要指定版本。它看起来如下：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we run `gradle tasks` now, we must have an `appRun` task under the `Gretty`
    group. There are many more tasks in this group, which are added by the Gretty
    plugin. If we run the `appRun` task, without configuring the plugin explicitly,
    then by default a Jetty 9 will be run on `http://localhot:8080`. We can open the
    browser and verify.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行`gradle tasks`，必须在`Gretty`组下有一个`appRun`任务。这个组中还有许多由Gretty插件添加的任务。如果我们运行`appRun`任务，而没有明确配置插件，那么默认情况下将在`http://localhot:8080`上运行Jetty
    9。我们可以打开浏览器进行验证。
- en: There are many configurations exposed by the plugin, in order to control aspects
    such as server version, port number, and many more. Add a `gretty` block to the
    `build.gradle` files as follows`:`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件暴露了许多配置，以便控制服务器版本、端口号等各个方面。在`build.gradle`文件中添加一个`gretty`块，如下所示：`
- en: 'If we want to use Tomcat 8 on port 8080, we''ll add the following lines of
    code:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在8080端口上使用Tomcat 8，我们将添加以下代码行：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we want to use Jetty 9 on 9080, we''ll add the following lines of code:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在9080端口上使用Jetty 9，我们需要添加以下代码行：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are many more configuration options available in Gretty; we would recommend
    you to check Gretty's online documentation. See the link to Gretty in the references
    section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Gretty提供了许多更多的配置选项；我们建议您查看Gretty的在线文档。请参阅参考文献部分中Gretty的链接。
- en: 'Here is how the running application looks like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的应用程序看起来如下：
- en: '![Plugins to the rescue](img/00008.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![救命插件](img/00008.jpeg)'
- en: 'Once the **Submit** button is pressed, we''ll get the following result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦按下**提交**按钮，我们将得到以下结果：
- en: '![Plugins to the rescue](img/00009.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![救命插件](img/00009.jpeg)'
- en: References
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'For Gradle, refer to the following URL:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Gradle，请参考以下URL：
- en: 'Gradle plugin portal: [https://plugins.gradle.org/](https://plugins.gradle.org/)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle插件门户：[https://plugins.gradle.org/](https://plugins.gradle.org/)
- en: 'For Gretty, refer to the following URL:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Gretty，请参考以下URL：
- en: 'Gretty plugin: [https://plugins.gradle.org/plugin/org.akhikhl.gretty](https://plugins.gradle.org/plugin/org.akhikhl.gretty)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gretty插件：[https://plugins.gradle.org/plugin/org.akhikhl.gretty](https://plugins.gradle.org/plugin/org.akhikhl.gretty)
- en: 'Gretty documentation: [http://akhikhl.github.io/gretty-doc/](http://akhikhl.github.io/gretty-doc/)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gretty文档：[http://akhikhl.github.io/gretty-doc/](http://akhikhl.github.io/gretty-doc/)
- en: 'There are various plugins available to automate the deployment. Some of them
    are listed here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多插件可用于自动化部署。其中一些列在这里：
- en: 'Cargo plugin: [https://github.com/bmuschko/gradle-cargo-plugin](https://github.com/bmuschko/gradle-cargo-plugin)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货物插件：[https://github.com/bmuschko/gradle-cargo-plugin](https://github.com/bmuschko/gradle-cargo-plugin)
- en: 'Arquillian plugin: [https://github.com/arquillian/arquillian-gradle-plugin](https://github.com/arquillian/arquillian-gradle-plugin)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arquillian插件：[https://github.com/arquillian/arquillian-gradle-plugin](https://github.com/arquillian/arquillian-gradle-plugin)
- en: 'Tomcat plugin: [https://github.com/bmuschko/gradle-tomcat-plugin](https://github.com/bmuschko/gradle-tomcat-plugin)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat插件：[https://github.com/bmuschko/gradle-tomcat-plugin](https://github.com/bmuschko/gradle-tomcat-plugin)
- en: Project dependencies
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目依赖
- en: In real life, we work on a lot more complex applications than what we have just
    seen. Such applications rely on other specialized components to provide some functionality.
    For example, an Enterprise Java application's build may depend on various components
    such as open source libraries in Maven central, libraries developed and hosted
    in-house, and (maybe) even on another subprojects. Such dependencies are, themselves,
    located at various locations like, local intranet, local filesystem, and so on.
    They need to be resolved, downloaded, and brought into the appropriate configuration
    (such as `compile`, `testCompile`, and so on) of the build.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们处理的应用程序比我们刚才看到的要复杂得多。这些应用程序依赖于其他专门的组件来提供某些功能。例如，企业Java应用程序的构建可能依赖于各种组件，如Maven中央的开源库、内部开发和托管的库，以及（可能）其他子项目。这些依赖项本身位于各种位置，如本地内网、本地文件系统等。它们需要被解析、下载，并引入构建的适当配置（如`compile`、`testCompile`等）。
- en: Gradle does an excellent job in locating and making dependencies available in
    the appropriate `classpath` and packaging if required. Let's begin with the most
    common kind of dependencies—external libraries.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle在定位和使依赖项在适当的`classpath`和打包（如果需要）中可用方面做得非常出色。让我们从最常见的依赖类型——外部库——开始。
- en: External libraries
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部库
- en: Almost all real-world projects depend on external libraries for reusing the
    proven and tested components. Such dependencies include language utilities, database
    drivers, web frameworks, XML/JSON serialization libraries, ORMs, logging utilities,
    and many more.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现实世界的项目都依赖于外部库来重用经过验证和测试的组件。这些依赖包括语言工具、数据库驱动程序、Web框架、XML/JSON序列化库、ORM、日志工具等等。
- en: The dependencies of a project are declared in the `dependencies` section in
    the build file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的依赖关系在构建文件中的`dependencies`部分声明。
- en: Gradle provides an extremely succinct syntax for declaring the coordinates of
    an artifact. It usually takes a form of `group:name:version`. Note that each value
    is separated by a colon (`:`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle提供了声明工件坐标的极其简洁的语法。它通常采用`group:name:version`的形式。请注意，每个值都由冒号（`:`）分隔。
- en: 'For example, Spring Framework''s core library can be referenced using the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Spring框架的核心库可以使用以下代码引用：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those who don't enjoy terseness, dependencies can be referred in a more
    descriptive format (called map format).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不喜欢简洁性的人来说，依赖项可以用更描述性的格式（称为映射格式）引用。
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also specify multiple dependencies as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以如下指定多个依赖项：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Where `configurationName` represents the configuration such as `compile`, `testCompile`
    and so on, we are soon going to see what configuration is in this context.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`configurationName`代表配置，如`compile`、`testCompile`等，我们很快就会看到在这个上下文中配置是什么。
- en: The dynamic version
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态版本
- en: The version of our dependencies keep on updating every now and then. Also, when
    we are in the development phase, we don't want keep on checking manually whether
    a new version is available.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的依赖版本会时不时地更新。此外，当我们处于开发阶段时，我们不想手动检查是否有新版本可用。
- en: In such situations, we can add a `+` to denote the version mentioned above,
    given the number of artifacts. For example, `org.slf4j:slf4j-nop:1.7+` declares
    any version of SLF4J that is above 1.7\. Let's include this in a `build.gradle`
    file and check what Gradle brings in for us.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以添加一个`+`来表示上述版本，给定工件的数量。例如，`org.slf4j:slf4j-nop:1.7+`声明任何高于1.7的SLF4J版本。让我们将其包含在一个`build.gradle`文件中，并检查Gradle为我们带来了什么。
- en: 'We run the following code in our `build.gradle` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`build.gradle`文件中运行以下代码：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we run the `dependencies` task:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行`dependencies`任务：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We see that Gradle chose the 1.7.7 version, as it's the latest version available
    as of the writing of this book. If you observe the second line, it tells us that
    `slf4j-nop` depends on `slf4j-api`; hence, it's a transitive dependency for our
    project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Gradle选择了1.7.7版本，因为这是本书撰写时可用的新版版本。如果你观察第二行，它告诉我们`slf4j-nop`依赖于`slf4j-api`；因此，它是我们项目的传递依赖。
- en: A word of caution here is, always use `+` for only minor version upgrades (such
    as `1.7+` in the preceding example). Letting the major version automatically update
    (for example, just image is spring automatically updates from 3 to 4, `compile
    'org.springframework:spring-core:+'`) is nothing but a gamble. A dynamic dependency
    resolution is a nice feature, but it should be used with care. It should ideally
    only be used at the development stage of the project and not for releases candidates.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个警告，始终只使用`+`进行小版本升级（如前例中的`1.7+`）。让主版本自动更新（例如，想象Spring自动从3更新到4，`compile 'org.springframework:spring-core:+'`）不过是一场赌博。动态依赖解析是一个很好的功能，但应该谨慎使用。理想情况下，它应该只在项目的开发阶段使用，而不是用于发布候选版本。
- en: We get a flaky build whenever the dependency's version updates to some incompatible
    version with our app. We should target for reproducible builds, such a build should
    produce the exact same artifact, be it today or one year down the line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖项的版本更新到与我们的应用程序不兼容的版本时，我们会得到一个不稳定的构建。我们应该追求可重复的构建，这样的构建应该产生完全相同的工件，无论是今天还是一年后。
- en: Transitive dependencies
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递依赖
- en: 'By default, Gradle resolves transitive dependencies quite intelligently, giving
    preference to the latest conflicting versions, if any. However, for some reason,
    if we want to disable transitive dependencies, all we need to provide is an extra
    block to our dependency declaration:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Gradle非常智能地解析传递依赖，如果存在，优先选择最新的冲突版本。然而，由于某种原因，如果我们想禁用传递依赖，我们只需要在我们的依赖声明中提供一个额外的块：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, if we check the output of the `dependencies` task, we see that no other
    dependency is included anymore:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们检查`dependencies`任务的输出，我们会看到不再包含其他依赖项：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also force a given version of the library so that, even if the same
    artifacts, the later version comes through the transitive dependency; the version
    we forced will win:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以强制指定库的给定版本，即使有相同的工件，较新版本通过传递依赖项获取；我们强制指定的版本将获胜：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running dependencies task now will produce:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行依赖项任务将产生：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This shows the older version of `slf4j-api` won, even though a later version
    could have been fetched by the transitive dependency.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明较旧的`slf4j-api`版本获胜，即使可以通过传递依赖项获取较新版本。
- en: Dependency configurations
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项配置
- en: Gradle provides a very elegant way to declare dependencies that are required
    for building different groups of sources in various stages of a project build.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle提供了一种非常优雅的方式来声明在项目构建的不同阶段构建不同源代码组所需的依赖项。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: These groups of sources are known as **source sets**. The simplest and well-understood
    examples of source sets are `main` and `test`. The `main` source set contains
    files that will be compiled and built as a JAR file and will be deployed somewhere
    or published to some repository. The `test` source set, on the other hand, contains
    files that will be executed by a testing tool such as JUnit, but will not make
    it to production. Now, both the source sets have different requirements for the
    dependencies, building, packaging, and execution. We will see how to add new source
    sets in [Chapter 7](part0045_split_000.html#1AT9A1-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 7. Testing and Reporting with Gradle"), *Testing and Reporting with Gradle*,
    for integration testing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些源代码组被称为**源集**。源集最简单和最易于理解的例子是`main`和`test`。`main`源集包含将被编译和构建为JAR文件并部署到某处或发布到某个仓库的文件。另一方面，`test`源集包含将由JUnit等测试工具执行的文件，但不会进入生产环境。现在，这两个源集对依赖项、构建、打包和执行有不同的要求。我们将在[第7章](part0045_split_000.html#1AT9A1-e78ecbb3ac0544f19c59f96d594821c0
    "第7章。使用Gradle进行测试和报告")中看到如何添加新的源集，*使用Gradle进行测试和报告*，以进行集成测试。
- en: 'As we have defined the group of related sources in a source set, dependencies
    are also defined as a group called **configuration**. Each configuration has its
    name such as `compile`, `testCompile`, and so on. Dependencies included in various
    configurations also differ. Configurations are grouped by the characteristics
    of dependencies. For example, the following are configurations that are added
    by the `java` and `war` plugins:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在源集中定义了相关源代码的组，因此依赖项也被定义为名为**配置**的组。每个配置都有自己的名称，例如`编译`、`测试编译`等。包含在各种配置中的依赖项也有所不同。配置是根据依赖项的特性进行分组的。例如，以下是由`java`和`war`插件添加的配置：
- en: '`compile`: This is added by the `java` plugin. Adding a dependency to this
    configuration implies that the dependency is required to compile the source. In
    the case of `war`, these will also get copied in `WEB-INF/lib`. Examples of such
    dependencies are libraries such as Spring Framework, Hibernate, and so on.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`编译`：这是由`java`插件添加的。向此配置添加依赖意味着该依赖项是编译源代码所必需的。在`war`的情况下，这些依赖项也将被复制到`WEB-INF/lib`中。此类依赖项的例子包括Spring框架、Hibernate等库。'
- en: '`runtime`: This is added by the `java` plugin. This includes the `compile`
    dependencies by default. Dependencies in this group are required at runtime for
    the compiled source code, but they are not required to compile it. Dependencies
    such as JDBC drivers are runtime dependencies only. We do not need them on our
    classpath to compile the source code as we code against the standard JDBC API
    interfaces available in JDK. However, for our application to run properly, we
    need a specific driver implementation at run time. For example, `runtime ''mysql:mysql-connector-java:5.1.37''`
    includes the MySQL driver.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行时`：这是由`java`插件添加的。默认情况下，这包括`编译`依赖项。此组中的依赖项在运行时对于编译的源代码是必需的，但它们不是编译它的必需品。例如，JDBC驱动程序这样的依赖项仅是运行时依赖项。我们不需要它们在我们的类路径上编译源代码，因为我们针对的是JDK中可用的标准JDBC
    API接口进行编码。然而，为了我们的应用程序能够正常运行，我们需要在运行时特定的驱动程序实现。例如，`runtime ''mysql:mysql-connector-java:5.1.37''`包括MySQL驱动程序。'
- en: '`testCompile`: This is added by the `java` plugin. This includes the `compile`
    dependencies by default. Dependencies added to this configuration are only available
    to test sources. Examples are testing libraries such as JUnit, TestNG, and so
    on, or any libraries that are exclusively used by test source such as Mockito.
    They are neither required to compile, nor required at runtime for the main source
    set. They do not get included in `war` in the case of building a `web-app`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testCompile`：这是由 `java` 插件添加的。默认情况下，这包括 `compile` 依赖项。添加到该配置的依赖项仅对测试源可用。例如，JUnit、TestNG
    等测试库，或者仅由测试源使用的任何库，如 Mockito。它们既不需要编译，也不需要在主源集的运行时存在。在构建 `web-app` 的情况下，它们不会包含在
    `war` 中。'
- en: '`testRuntime`: This is added by the `java` plugin. This includes `testCompile`
    and `runtime` dependencies by default. Dependencies in this configuration are
    only required to test sources at the runtime (that is, while running tests). Hence,
    they are not included in the compilation classpath of tests. This is just like
    the runtime configuration, but only for test sources.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testRuntime`：这是由 `java` 插件添加的。默认情况下，这包括 `testCompile` 和 `runtime` 依赖项。此配置中的依赖项仅需要在运行时（即在运行测试时）测试源。因此，它们不包括在测试的编译类路径中。这就像运行时配置一样，但仅限于测试源。'
- en: '`providedCompile`: This is added by the `war` plugin. Dependencies such as
    servlet APIs are provided by application servers and hence need not be packaged
    in our `war`. Anything that we expect to be already included in the server runtime
    can be added to this configuration. However, it has to be present at the time
    of compilation of the source code. Hence, we can declare such dependencies as
    `providedCompile`. Examples are servlet API and any Java EE implementations that
    are available at server runtime. Such dependencies are not included in `war`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providedCompile`：这是由 `war` 插件添加的。例如，servlet API 这样的依赖项由应用程序服务器提供，因此不需要打包在我们的
    `war` 中。任何我们期望已经包含在服务器运行时中的内容都可以添加到这个配置中。然而，它必须在源代码编译时存在。因此，我们可以将这些依赖项声明为 `providedCompile`。例如，servlet
    API 和任何在服务器运行时提供的 Java EE 实现。此类依赖项不会包含在 `war` 中。'
- en: '`providedRuntime`: This is added by the `war` plugin. Dependencies that will
    be made available at application runtime by the server and application do not
    need to be included while compiling because there is no direct reference to the
    implementation. Such libraries can be added to this configuration. Such dependencies
    will not be included in `war`. Hence, we should make sure to have implementation
    available in the application runtime.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providedRuntime`：这是由 `war` 插件添加的。服务器和应用程序将在应用运行时提供的依赖项不需要在编译时包含，因为没有直接引用实现。此类库可以添加到该配置中。此类依赖项将不会包含在
    `war` 中。因此，我们应该确保在应用运行时有实现可用。'
- en: As we know, when we apply the `war` plugin, the `java` plugin also gets applied.
    That's why all six configurations are available when we are building a web application.
    More configurations can be added by plugins, or we can declare them ourselves
    in our build script.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，当我们应用 `war` 插件时，`java` 插件也会被应用。这就是为什么当我们构建 Web 应用程序时，所有六个配置都可用。可以通过插件添加更多配置，或者我们可以在构建脚本中自行声明它们。
- en: Interestingly, configuration does not just include dependencies, but also the
    artifacts produced by this configuration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，配置不仅包括依赖项，还包括由该配置生成的工件。
- en: Repositories
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库
- en: 'The repositories section configures the repositories where Gradle will look
    for dependencies. Gradle downloads the dependencies into its own cache so that
    the download doesn''t need to happen every time Gradle is run. We can configure
    multiple repositories as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库部分配置了 Gradle 将在其中查找依赖项的仓库。Gradle 将依赖项下载到其自己的缓存中，这样就不需要在每次运行 Gradle 时都进行下载。我们可以按以下方式配置多个仓库：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Repositories such as Maven, Ivy, and flat directory (filesystem) are supported
    for dependency resolution and uploading artifacts. There are some more specific
    convenience methods available for commonly used Maven repositories such as `mavenCentral()`,
    `jcenter()`, and `mavenLocal()`. However, more Maven repos can be easily configured
    using the following syntax:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 支持使用 Maven、Ivy 和平面目录（文件系统）等仓库进行依赖项解析和上传工件。对于常用的 Maven 仓库，如 `mavenCentral()`、`jcenter()`
    和 `mavenLocal()`，还有一些更具体的便捷方法可用。然而，可以使用以下语法轻松配置更多 Maven 仓库：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before the central repositories, projects used to manage the libraries on filesystem,
    which were mostly checked in along with the source code. Some projects still do
    it; although we discourage this, people have their reasons to do so and Gradle
    has no reason to not support that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在中央仓库之前，项目通常会在文件系统中管理库，这些库大多与源代码一起提交。有些项目仍然这样做；尽管我们不建议这样做，但人们有自己的理由这样做，而 Gradle
    没有不支持的理由。
- en: It is important to remember that Gradle does not automatically assume any repository
    to search and download dependencies from. We have to explicitly configure at least
    one repository in the `repositories` block where Gradle will search for artifacts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，Gradle 并不会自动假设任何仓库来搜索和下载依赖项。我们必须在 `repositories` 块中显式配置至少一个仓库，Gradle
    将在其中搜索工件。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**Exercise**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: 'Include Apache Commons Lang library to convert the message to title case using
    the following method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法将 Apache Commons Lang 库包含到消息中，以将其转换为标题大小写：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Capitalize all the whitespace-separated words in a string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串中所有空格分隔的单词转换为大写。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we first developed a web application using Gradle. We generated
    the WAR artifact by building the application and then deployed it to a local Tomcat.
    Then, we learned a few basics about dependency management, configurations, and
    supported repositories in Gradle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先使用 Gradle 开发了一个 Web 应用程序。我们通过构建应用程序生成了 WAR 工件，然后将其部署到本地 Tomcat。然后，我们学习了关于
    Gradle 中的依赖管理、配置和支持的仓库的一些基础知识。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The reader should spend some more time reading these concepts in detail at Gradle's
    official documentation at [https://docs.gradle.org/current/userguide/userguide](https://docs.gradle.org/current/userguide/userguide)
    .
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该在 Gradle 的官方文档中花更多时间详细阅读这些概念，官方文档地址为 [https://docs.gradle.org/current/userguide/userguide](https://docs.gradle.org/current/userguide/userguide)。
- en: For now, we should be good to build the most common type of Java applications
    with Gradle. In the next chapter, we will try to understand the Groovy DSL that
    Gradle provides and also understand the basic project model.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们应该能够使用 Gradle 构建最常见类型的 Java 应用程序。在下一章中，我们将尝试理解 Gradle 提供的 Groovy DSL 以及基本的项目模型。
