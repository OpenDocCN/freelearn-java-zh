- en: Integrating Legacy APIs with the Proxy Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理模式将遗留API集成
- en: Developing a new API is very often a pleasant experience for developers. Without
    any legacy code, we engineers can choose our tooling, think through the design
    process to ensure an enjoyable end user experience, build on top of a serverless
    platform, and all of the other best practices learned through the ages. However,
    companies and bosses task many engineers with taking a legacy API and supporting,
    maintaining, or porting it to a new architecture. Given an already deployed production
    API that sees constant usage, porting to a serverless system can be akin to changing
    the engine of a race car while in the middle of a race.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发新的API对于开发者来说通常是一种愉快的体验。在没有遗留代码的情况下，我们工程师可以选择我们的工具，思考设计过程以确保用户有愉快的体验，在无服务器平台上构建，以及所有通过岁月学到的最佳实践。然而，公司和老板经常要求许多工程师承担将遗留API支持、维护或将其移植到新架构的任务。给定一个已经部署并持续使用的生产API，将其移植到无服务器系统可能就像在比赛中更换赛车引擎一样。
- en: Fortunately, this complicated task can be made much simpler nowadays using the
    proxy pattern, the idea of which has been around for many years as a software
    pattern. If the name isn't clear enough, the main ideas are that a layer sits
    in between the client and backend system, which acts as a proxy, shuffling data
    to and from the backend service on behalf of the client. Inserting this proxy
    in between the two actors (client and server) makes it possible to transform request
    data from the client before it's sent to the server, as well as transform the
    payload from the server before it's delivered to the client. In this manner, one
    may mimic the exact behavior of a legacy API without any changes needed on the
    client side. This design allows for a graceful transition from a legacy API backend
    to a newer backend system without the fear of breaking existing clients or requiring
    them to update their application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现在可以使用代理模式，这个想法作为一个软件模式已经存在了多年，来简化这个复杂任务的执行。如果名字不够清楚，主要思想是在客户端和后端系统之间有一个层，它充当代理，代表客户端在前后端服务之间传递数据。在两个行为者（客户端和服务器）之间插入这个代理，使得在将请求数据发送到服务器之前对其进行转换成为可能，同样，在将有效负载发送到客户端之前对其进行转换也成为可能。以这种方式，可以在不修改客户端的情况下模拟遗留API的确切行为。这种设计允许从遗留API后端到较新后端系统的平稳过渡，无需担心破坏现有客户端或要求他们更新他们的应用程序。
- en: 'By the end of this chapter, you can expect to learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你可以期待学习以下内容：
- en: Introduction to the proxy pattern and how it works for migrating API backends
    or updating the request/response payloads for existing APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式的介绍以及它是如何用于迁移API后端或更新现有API的请求/响应负载
- en: Options for implementing the proxy pattern, including AWS API Gateway and custom
    serverless functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现代理模式的选项，包括AWS API网关和自定义无服务器函数
- en: Transforming requests/responses to an existing API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求/响应转换为现有API
- en: Migrating existing APIs to a serverless backend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有API迁移到无服务器后端
- en: AWS API Gateway introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS API网关介绍
- en: API Gateway from Amazon Web Services is a fantastic tool with a slew of features
    that significantly simplifies implementation of an API proxy pattern. Later on
    in the chapter, we'll discuss strategies when building on a different cloud provider;
    however, if you're like me and use AWS consistently, API Gateway can make your
    life much more comfortable. Personally, I feel that it's an underrated tool, which
    can do a lot more than HTTP requests to Lambda functions as we saw in [Chapter
    2](svrls-dsnptn-bstprac_ch02.html), *Three-Tier Web Application Using REST* and
    [Chapter 3](svrls-dsnptn-bstprac_ch03.html), *Three-Tier Web Application Pattern
    with GraphQL*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊网络服务（AWS）的API网关是一个功能丰富的工具，它显著简化了API代理模式的实现。在本章的后面部分，我们将讨论在构建不同云服务提供商时的策略；然而，如果你像我一样一直使用AWS，API网关可以使你的生活变得更加舒适。我个人认为，这是一个被低估的工具，它可以做比我们看到的[第2章](svrls-dsnptn-bstprac_ch02.html)，“使用REST的三层Web应用程序”和[第3章](svrls-dsnptn-bstprac_ch03.html)，“带有GraphQL的三层Web应用程序模式”中Lambda函数的HTTP请求更多的事情。
- en: 'The first question may be, *What is API Gateway and what does it do?* Rather
    than answer this myself, I''ll defer to the technical documentation at [http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html](http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html),
    which does a good job of describing Gateway at a high level:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题可能是，*什么是API网关，它有什么作用？* 我不会自己回答这个问题，而是会参考[http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html](http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html)上的技术文档，它很好地描述了在高级别上的网关：
- en: '"Amazon API Gateway is an AWS service that enables developers to create, publish,
    maintain, monitor, and secure APIs at any scale. You can create APIs that access
    AWS or other web services, as well as data stored in the AWS Cloud."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “Amazon API网关是一个AWS服务，它使开发者能够以任何规模创建、发布、维护、监控和安全地管理API。您可以创建访问AWS或其他Web服务以及存储在AWS云中的数据的API。”
- en: 'API Gateway provides you with a publicly accessible HTTPS URL. Requests that
    hit this endpoint may do a variety of things including, but not limited to, the
    following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: API网关为您提供了一个公开可访问的HTTPS URL。击中此端点的请求可能执行各种操作，包括但不限于以下操作：
- en: Call a Lambda function
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用Lambda函数
- en: Return a mock endpoint build with templates
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回由模板构建的模拟端点
- en: Proxy requests to a different HTTP endpoint
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代理请求发送到不同的HTTP端点
- en: In [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A* *Three-Tier Web Application
    Using REST* and [Chapter 3](svrls-dsnptn-bstprac_ch03.html), *A* *Three-Tier Web
    Application Pattern with GraphQL*, we used API Gateway to expose an HTTPS endpoint
    that would invoke our Lambda functions containing application logic. HTTP payload
    data, including headers and query parameters, would be pulled in from the HTTPS
    request and sent to Lambda. Our Lambda functions also control the response payload
    by returning a JSON-encodable data structure as well as appropriate HTTP status
    codes and headers. Managing the actual HTTP response from Lambda is known as a
    **proxy integration**, not to be confused with the proxy pattern we will work
    on in this chapter. I bring this up to add clarity to what we've done and what
    we'll be doing for this pattern with API Gateway.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](svrls-dsnptn-bstprac_ch02.html)《使用REST的*三层Web应用程序*》和[第3章](svrls-dsnptn-bstprac_ch03.html)《具有GraphQL的*三层Web应用程序模式*》中，我们使用了API网关来公开一个HTTPS端点，该端点将调用包含应用程序逻辑的Lambda函数。HTTP有效负载数据，包括头和查询参数，将从HTTPS请求中提取并发送到Lambda。我们的Lambda函数还通过返回可JSON编码的数据结构以及适当的HTTP状态码和头信息来控制响应有效负载。从Lambda管理实际的HTTP响应被称为**代理集成**，不要与本章节中我们将要工作的代理模式混淆。我提出这一点是为了澄清我们所做的工作以及我们将如何使用API网关来实现这种模式。
- en: In most of the subsequent examples, we will not be using the Lambda proxy integration.
    While this means more configuration will work on our behalf, it also means we
    will be able to control the request/response payloads to our liking. When building
    a brand new Serverless API with API Gateway and AWS Lambda, Lambda proxy integration
    should be precisely what you need since it's easy to control requests and responses
    from your API definition and application code, respectively. However, when setting
    up the proxy pattern for an existing HTTP backend, it's common to need more control
    over transforming response data before it's sent back to the client.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数后续的示例中，我们不会使用Lambda代理集成。虽然这意味着更多的配置将代表我们工作，但也意味着我们将能够控制请求/响应有效负载，以满足我们的需求。当使用API网关和AWS
    Lambda构建全新的无服务器API时，Lambda代理集成正是您所需要的，因为它很容易从API定义和应用程序代码中控制请求和响应。然而，当为现有的HTTP后端设置代理模式时，通常需要在将响应数据发送回客户端之前对其进行更多控制。
- en: 'In addition to being the ingestion point for web requests and sending those
    requests somewhere else, API Gateway provides quite a bit more functionality,
    including:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为网页请求的接收点和将请求发送到其他地方之外，API网关还提供了相当多的功能，包括：
- en: Authentication and authorization hooks
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权钩子
- en: Automatic API documentation generation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成API文档
- en: Rate limiting/throttling
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制/节流
- en: Logging
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录日志
- en: Defining multiple stages or environments with their variables that can be passed
    to downstream systems
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义多个阶段或环境及其变量，这些变量可以被传递到下游系统
- en: Personally speaking, the more I learn about the capabilities of API Gateway,
    the more ideas I come up with for possible applications and use cases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 说到个人观点，我对API网关的功能了解得越多，我就越能想出可能的应用和用例。
- en: There are other services that provide similar functionality. If you prefer to
    build on something other than AWS, have a look at **Apigee** ([https://apigee.com/api-management/](https://apigee.com/api-management/))
    or **Kong** ([https://getkong.org/](https://getkong.org/)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他提供类似功能的服务。如果您更喜欢在AWS之外构建，请查看**Apigee** ([https://apigee.com/api-management/](https://apigee.com/api-management/))或**Kong**
    ([https://getkong.org/](https://getkong.org/))。
- en: Simple proxy to a legacy API
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的旧版API代理
- en: In this first example, we'll go through the steps to set up a simple integration
    with an existing API. What is neat about API Gateway is that it's possible to
    go a very long way on the path to replacing current application code without writing
    any code ourselves.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，我们将通过设置与现有API的简单集成来展示步骤。API Gateway的 neat 之处在于，在替换当前应用程序代码的过程中，我们可能根本不需要编写任何代码。
- en: In these examples, we'll use a publicly available fake API called `JsonPlaceholder`,
    pretending for our purposes that it's a legacy API that we'd like to replace: [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们将使用一个公开可用的假API，称为`JsonPlaceholder`，为了我们的目的，我们假设它是一个我们想要替换的旧版API：[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)。
- en: Of course, this type of replacement warrants plenty of thought and careful planning.
    Authentication, rate limiting, DNS entries, and the like are all factors that
    much be thought through carefully before embarking on such a project. Still, with
    all of the issues that one should consider, there are many tools and options to
    make this pattern a real possibility for many applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种替换需要大量的思考和仔细的计划。认证、速率限制、DNS条目等因素在开始这样的项目之前都必须仔细考虑。尽管如此，考虑到所有应该考虑的问题，仍然有许多工具和选项使这种模式成为许多应用程序的可行选择。
- en: Setting up a pass-through proxy
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置透传代理
- en: Step one on our journey will be to work through the steps of setting up a new
    API in API Gateway that will pass requests and responses to and from `JsonPlaceholder`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旅程的第一步将是设置API Gateway中的新API，该API将传递请求和响应到`JsonPlaceholder`。
- en: 'First, in the AWS console, create a new API, shown as follows. I''ll call this
    one `JsonProxy`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在AWS控制台中创建一个新的API，如下所示。我将称这个为`JsonProxy`：
- en: '![](img/5040d3c5-6ded-4cc7-94d2-085f11ccfc3c.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5040d3c5-6ded-4cc7-94d2-085f11ccfc3c.png)'
- en: Once we have our API, we can start filling it in and adding endpoints and behavior.
    In my experience, most AWS services have essential concepts that one should understand
    well before building something of significance. API Gateway is no different in
    this regard. The good news is that it's not incredibly difficult to understand
    these concepts in API Gateway.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的API，我们就可以开始填充它并添加端点和行为。根据我的经验，大多数AWS服务都有一些基本概念，在构建有意义的结构之前，应该很好地理解这些概念。API
    Gateway在这方面也不例外。好消息是，在API Gateway中理解这些概念并不特别困难。
- en: 'The two concepts we''ll be working with when using API Gateway are resources
    and methods. The mental model is situation simple:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用API Gateway时，我们将使用两个概念：资源和方法。心理模型很简单：
- en: '**Resource**: API endpoint'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：API端点'
- en: '**Method**: HTTP method that lives under a resource'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：位于资源下的HTTP方法'
- en: '`JSONPlaceholder` provides API endpoints for a few different API resources,
    posts, comments, albums, and so on. To begin, we''ll create a new API Gateway
    resource for `/posts`. This endpoint, on our unique URL, will proxy to [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
    It should be noted that we could set up an endpoint on our API Gateway deployment
    named something other than `/posts`. That is, it''s possible to create a resource
    named `/all_posts`, which would then proxy to [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONPlaceholder`为几个不同的API资源提供API端点，包括帖子、评论、专辑等。首先，我们将为`/posts`创建一个新的API Gateway资源。这个端点在我们的唯一URL上会代理到[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)。需要注意的是，我们可以在我们的API
    Gateway部署中设置一个名为`/posts`之外端点的端点。也就是说，可以创建一个名为`/all_posts`的资源，然后它会代理到[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)。'
- en: 'In the console, we set this up in the following way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，我们以以下方式设置：
- en: 'Select the Actions button → Create Resource:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择操作按钮→创建资源：
- en: Set Resource Name to be posts
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资源名称设置为posts
- en: Ensure Configure as proxy resource is not checked
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保不要选中“配置为代理资源”
- en: Click the Create Resource button
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建资源按钮
- en: Ensure the newly created `/posts` resource is selected/highlighted in the list
    of resources
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保新创建的`/posts`资源在资源列表中被选中/突出显示
- en: 'Select the Actions button → Create Method:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择操作按钮→创建方法：
- en: Select GET and click the confirmation checkbox button
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择GET并点击确认复选框按钮
- en: On the next screen, set the options as shown in the following screenshot
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，设置如下截图所示选项
- en: Ensure the Endpoint URL is pointing to [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保端点URL指向[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
- en: 'Click the Save button; take a look at the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击保存按钮；请看以下截图：
- en: '![](img/d95aed31-20f8-4855-ba1b-71efb41ed4ef.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d95aed31-20f8-4855-ba1b-71efb41ed4ef.png)'
- en: 'The preceding screenshot may look quite confusing. I''ll admit, I didn''t understand
    many details of this part of API Gateway for quite a long time until I went through
    this exercise that we''re going through now. We''ll go through the details of
    the Method Execution screen in detail, but first, let''s deploy our new API and
    test it out:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图可能看起来相当混乱。我必须承认，我在相当长一段时间内都没有完全理解API网关的这一部分细节，直到我完成了我们现在正在进行的这个练习。我们将详细讨论方法执行屏幕的细节，但首先，让我们部署我们的新API并对其进行测试：
- en: '![](img/2136a688-883c-42d5-ab37-2b1bf7b52e89.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2136a688-883c-42d5-ab37-2b1bf7b52e89.png)'
- en: Deploying a pass-through proxy
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署透传代理
- en: 'At this point, we''ve merely defined our API''s skeleton and straightforward
    structure, with a single endpoint of `/posts`. There is no URL for us to query
    to test. For that, we''ll need to deploy our API:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅仅定义了API的骨架和简单的结构，只有一个`/posts`的端点。我们没有查询的URL来测试。为此，我们需要部署我们的API：
- en: Select the Actions button → Deploy API
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择操作按钮→部署API
- en: 'From the Deploy API screen:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从部署API屏幕：
- en: Select New stage
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新阶段
- en: Enter `dev` for the stage name
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`dev`作为舞台名称
- en: Click the Deploy button
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击部署按钮
- en: 'After deployment, the console will take you to the dev Stage Editor screen.
    Here, you''ll notice many other types of features that you can update. For example,
    it''s possible to turn on/off API throttling, set stage variables, and so on.
    For our purposes, we''re all done:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，控制台将带您进入dev舞台编辑器屏幕。在这里，您会注意到许多其他可以更新的功能类型。例如，可以开启/关闭API节流，设置阶段变量等。就我们的目的而言，我们已经完成了：
- en: '![](img/89145268-abb3-45e4-b1e6-72355575afef.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89145268-abb3-45e4-b1e6-72355575afef.png)'
- en: You'll notice a URL highlighted at the top of this screen. This custom URL is
    unique to this deployment and may be used to hit our API. Expanding the dev stage
    on the left-hand side will show you the single URL endpoint we defined in the
    prior Resources section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到屏幕顶部有一个高亮的URL。这个自定义URL对于这次部署是唯一的，可以用来调用我们的API。展开左侧的dev阶段将显示我们在先前的资源部分定义的单个URL端点。
- en: 'Now, if we load up our custom URL in the browser or hit that URL with cURL,
    we can see the data pulled from the `JSONPlaceholder` endpoint of `/posts`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用浏览器加载我们的自定义URL或使用cURL调用该URL，我们就可以看到从`JSONPlaceholder`的`/posts`端点获取的数据：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What we have now is our very own HTTPS URL, which doesn''t do much, but it''s
    still quite remarkable. We have not written a single line of application code
    in any sort of programming language, and have set up a proxy to return results
    from an existing legacy API. You may think this isn''t very useful right now.
    You wouldn''t be wrong, necessarily. However, even with a simple integration like
    this, we can already begin to take advantage of some API Gateway features such
    as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有自己的HTTPS URL，虽然它目前做不了太多，但仍然非常了不起。我们没有在任何编程语言中编写一行应用程序代码，而是设置了一个代理来从现有的遗留API返回结果。您可能会认为这目前并不太有用。您并不完全错误。然而，即使有这样一个简单的集成，我们也可以开始利用一些API网关功能，例如：
- en: Automated API documentation generation
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化API文档生成
- en: Throttling
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节流
- en: Automated SDK generation in multiple languages
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多种语言中自动生成SDK
- en: This is merely the first step. In the next section, we will dive into the details
    of starting to transform our API Gateway API to turn it into something completely
    different using the same data source.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是第一步。在下一节中，我们将深入了解如何开始转换我们的API网关API，使其使用相同的数据源变成完全不同的东西。
- en: Transforming responses from a modern API
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将现代API的响应进行转换
- en: Next, we'll walk through a scenario where we have an existing API interface
    that we need to support, but would like to change the backend implementation entirely.
    This scenario is common and one I've dealt with personally. Existing clients point
    to a particular set of API endpoints. Breaking a public API that many developers
    depend on isn't something anyone wants to do. But, when that API is built on top
    of hard-to-maintain or poorly performing code, how does one iterate without requiring
    hundreds or thousands of developers to update their mobile, web, or GUI applications?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个场景来演示，这个场景是我们需要支持现有的API接口，但希望完全改变后端实现。这种情况很常见，也是我个人处理过的情况。现有客户端指向特定的API端点。破坏许多开发者依赖的公共API不是任何人想要做的事情。但是，当这个API建立在难以维护或性能不佳的代码之上时，如何在不要求数百或数千名开发者更新他们的移动、Web或GUI应用程序的情况下进行迭代呢？
- en: In this example, I will walk through the steps necessary to take a pretend legacy
    API and reimplement it using our modern API. `JSONPlaceholder` will play the part
    of our new, modern, scalable, and performant RESTful API. The single URL we will
    reimplement with the proxy pattern is `https://$HOSTNAME/get_comments_by_post_id`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将演示必要的步骤，将一个假设的遗留API重新实现为我们的现代API。`JSONPlaceholder`将扮演我们新的、现代的、可扩展和性能良好的RESTful
    API的角色。我们将使用代理模式重新实现的单个URL是`https://$HOSTNAME/get_comments_by_post_id`。
- en: You can imagine the type of data this endpoint returns. Thinking back to our
    discussion on REST APIs, it's evident that this legacy pattern is not RESTful
    for a variety of reasons. With an API structure such as this, you can bet that
    the rest of the API design will need some work and may not be the easiest to work
    with as an end user. Our shiny new RESTful API (`JSONPlaceholder`) is much more
    to our liking and one that we'd like to advertise and have developers adopt rather
    than the previous old structure. How can we support existing clients with the
    same input and output payloads by using our new RESTful API?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象这个端点返回的数据类型。回顾我们关于REST API的讨论，很明显，这个遗留模式在许多原因上都不是RESTful的。具有这种API结构的，你可以确信，API设计的其余部分也需要一些工作，并且可能不是作为最终用户最容易与之工作的。我们闪亮的新RESTful
    API（`JSONPlaceholder`）更符合我们的口味，我们希望宣传并让开发者采用，而不是之前的旧结构。我们如何使用我们新的RESTful API通过相同的输入和输出有效载荷来支持现有客户端？
- en: API Gateway can help us out in this scenario.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: API网关可以帮助我们解决这个问题。
- en: Method execution flow
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法执行流程
- en: 'The Method Execution screenshot shown in the *Setting up a pass-through proxy* section
    will come into play now. You may refer back to that screenshot as we walk through
    the four different parts. It also may be easier to look at the following diagram,
    which represents the same request/response flow but is a bit simpler to digest:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在*设置透明代理*部分显示的方法执行截图现在将发挥作用。在我们通过四个不同的部分进行讲解时，你可以参考那个截图。查看以下图表可能也更容易，它表示相同的请求/响应流程，但更简单易懂：
- en: '![](img/b8c521b0-35db-4e38-a981-2ee660098568.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8c521b0-35db-4e38-a981-2ee660098568.png)'
- en: 'For every API Gateway resource/method combination, there are four steps that
    we may configure. It all starts with the client on the far left of this diagram.
    This **client** icon represents the user who is calling our API. After a series
    of steps, an HTTP response is created, and the client receives some payload. Working
    with API Gateway means configuring some or all of these stages to control the
    HTTP request and the HTTP response. Sitting right in the middle of this flow is
    the **Integration Type**, which, as mentioned earlier, may be a variety of things,
    including an AWS Lambda function or existing HTTP endpoint. The two steps that
    precede the execution of the integration (**Method Request** and **Integration
    Request**) are responsible for working with the HTTP request. The work that these
    two stages perform may include:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个API网关资源/方法组合，我们可能需要配置四个步骤。这一切都是从图的最左侧的客户端开始的。这个**客户端**图标代表调用我们API的用户。经过一系列步骤后，创建了一个HTTP响应，客户端接收了一些有效载荷。使用API网关意味着配置这些阶段中的某些或全部，以控制HTTP请求和HTTP响应。位于这个流程中间的是**集成类型**，如前所述，它可能包括各种东西，包括AWS
    Lambda函数或现有的HTTP端点。在执行集成之前的前两个步骤（**方法请求**和**集成请求**）负责处理HTTP请求。这两个阶段执行的工作可能包括：
- en: Transforming query parameters
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换查询参数
- en: Transforming input data (that is, POST payload)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换输入数据（即POST有效载荷）
- en: Extracting and transforming headers
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取和转换头部信息
- en: Performing authentication
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行身份验证
- en: 'Once this work is done, the Integration Request will pass data (which may or
    may not be transformed from the original input payload) to the Integration Type.
    The Integration Type returns some data, hands it off to the Integration Response,
    and finally Method Response. As the other two sections worked on the request payload,
    these two sections (Integration Response and Method Response) operate on the response
    payload. Actions we may perform here include:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这项工作后，集成请求将传递数据（可能已从原始输入有效载荷转换或未转换）到集成类型。集成类型返回一些数据，将其传递给集成响应，最后是方法响应。由于其他两个部分处理了请求有效载荷，这两个部分（集成响应和方法响应）操作的是响应有效载荷。我们可能在这里执行的操作包括：
- en: Transforming the HTTP body/payload
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换 HTTP 主体/有效载荷
- en: Transforming/adding HTTP headers
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换/添加 HTTP 标头
- en: Controlling HTTP status codes
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制HTTP状态码
- en: 'In the AWS console screenshot in the *Setting up a pass-through proxy* section,
    the client is represented on the far left as a vertically oriented rectangle. On
    the far right of the same screenshot is the endpoint that we configured this API
    to talk with, [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
    Again, in other cases, that integration endpoint may be a Lambda function, mock
    integration, or any of the other supported backend systems for API Gateway. In
    our example for this chapter, it will always be our existing `JSONPlaceholder`
    API. Following the arrows in the Method Execution screen on the AWS console you
    can see how a request from clients flows in the order described previously:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在“设置代理”部分的 AWS 控制台截图上，客户端以垂直方向的矩形形式位于最左侧。在同一截图的最右侧是配置此 API 通信的端点，[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)。同样，在其他情况下，该集成端点可能是一个
    Lambda 函数、模拟集成或 API Gateway 支持的任何其他后端系统。在本章的示例中，它始终是我们的现有 `JSONPlaceholder` API。按照
    AWS 控制台方法执行屏幕上的箭头，你可以看到客户端请求按照之前描述的顺序流动：
- en: Method Request
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法请求
- en: Integration Request
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成请求
- en: Our configured integration endpoint
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们配置的集成端点
- en: Integration Response
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成响应
- en: Method Response
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法响应
- en: 'There are many options and a huge number of permutations with this flow of
    data. We can''t go through every one obviously, but we''ll work primarily with
    Integration Request and Integration Response for this example. Our tasks will
    involve:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据处理流程中有很多选项和大量的排列组合。显然，我们无法逐一介绍，但我们将主要使用集成请求和集成响应进行本例。我们的任务将包括：
- en: Creating new resources for the three separate legacy API endpoints
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为三个单独的遗留 API 端点创建新资源
- en: Creating `GET` methods on those three resources
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这三个资源上创建 `GET` 方法
- en: For each resource/method combination, map query parameters from the request
    to our new API
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个资源/方法组合，将请求中的查询参数映射到我们新的 API
- en: For each resource/method combination, set up an Integration Response Body Mapping
    Template to transform the JSON payload from our new API to the structure expected
    of the legacy API
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个资源/方法组合，设置一个集成响应体映射模板，将我们新 API 的 JSON 有效载荷转换为遗留 API 预期的结构
- en: Setting up example
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置示例
- en: 'The API to integrate with has the URL structure of [https://jsonplaceholder.typicode.com/comments?postId=1](https://jsonplaceholder.typicode.com/comments?postId=1).
    As a reminder, this is the endpoint URL for our HTTP Integration Type. With a
    URL structure like that, it''s clear what is going on and what the return data
    should be. This request fetches comments for a given `postId`, which are passed
    along as a `GET` argument. Additionally, this modern API returns an array of comment
    resources with the following format:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成的 API 的 URL 结构为 [https://jsonplaceholder.typicode.com/comments?postId=1](https://jsonplaceholder.typicode.com/comments?postId=1)。提醒一下，这是我们的
    HTTP 集成类型的端点 URL。具有这种 URL 结构，可以清楚地了解正在发生什么以及返回数据应该是什么。此请求获取特定 `postId` 的评论，作为
    `GET` 参数传递。此外，这个现代 API 返回一个包含以下格式的评论资源数组：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Assume for the sake of this example that our legacy system has an analogous
    API but with a different URL structure, `GET` argument to filter the comments
    and representation of the comment resource:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在这个示例中，我们的遗留系统有一个类似的 API，但具有不同的 URL 结构，`GET` 参数用于过滤评论和评论资源的表示：
- en: '`https://$HOSTNAME/get_comments_by_post_id?post_id=1`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://$HOSTNAME/get_comments_by_post_id?post_id=1`'
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our job here is to support this legacy URL pattern and payload using the modern-day
    RESTful API (`JSONPlaceholder`) as the data source. Fortunately, all of the data
    we need to support we have in our new API, so our job will be to have API Gateway
    perform the translation of the payload before it's sent out to the client.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作是使用现代的RESTful API（`JSONPlaceholder`作为数据源）来支持这个遗留的URL模式和有效负载。幸运的是，我们需要支持的所有数据我们都在新的API中，所以我们的工作将是让API网关在将其发送给客户端之前对有效负载进行转换。
- en: Setting up a new resource and method
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的资源和方法
- en: 'First, we need to create a new API Gateway resource and method for the `get_comments_by_post_id`
    endpoint. The steps are the same as the prior section. The only differences will
    be:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为`get_comments_by_post_id`端点创建一个新的API网关资源和方法。步骤与上一节相同。唯一的不同之处在于：
- en: The endpoint we'll talk to will be [https://jsonplaceholder.typicode.com/comments](https://jsonplaceholder.typicode.com/comments)
    rather than the `/posts` endpoint
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要与之通信的端点将是[https://jsonplaceholder.typicode.com/comments](https://jsonplaceholder.typicode.com/comments)，而不是`/posts`端点
- en: We'll need to map query parameters from the initial client request to the desired
    query parameters to the backend API that provides the data
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将初始客户端请求的查询参数映射到后端API所需的查询参数
- en: 'After setting up this new resource and method, it should look like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置这个新资源和方法后，它应该看起来像以下这样：
- en: '![](img/f9b798d0-bedc-4c27-b3e4-c1587caef4ec.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9b798d0-bedc-4c27-b3e4-c1587caef4ec.png)'
- en: Setting up Integration Request
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置集成请求
- en: 'First, we need to set up API Gateway so that it passes the expected `GET` arguments
    from the request to our backend. API Gateway allows for controlling the query
    parameter mapping in the *Method Request* and *Integration Request* sections.
    In the Method Execution screen:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置API网关，使其将请求中期望的`GET`参数传递到我们的后端。API网关允许在*方法请求*和*集成请求*部分控制查询参数映射。在方法执行屏幕中：
- en: 'Click on Method Request:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击方法请求：
- en: Click on URL Query String Parameters
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击URL查询字符串参数
- en: Click Add query string parameter
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加查询字符串参数
- en: Put in `post_id`
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`post_id`
- en: Leave required and caching unchecked
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不选中必需的和缓存
- en: 'Back on the Method Execution screen, click on Integration Request:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到方法执行屏幕，点击集成请求：
- en: Expand URL Query String Parameters
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开URL查询字符串参数
- en: Click on Add query string
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加查询字符串
- en: Put in `postId` for Name and `method.request.querystring.post_id` for Mapped
    from
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于名称输入`postId`，对于映射来自输入`method.request.querystring.post_id`
- en: What we've done here is tell API Gateway to expect a `GET` argument named `post_id`,
    which is the old parameter we need to support. From there, Gateway will extract
    this `post_id` attribute and inject it into the Integration Request. The value
    for `post_id` is accessible in `method.request.querystring.post_id`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是告诉API网关期望一个名为`post_id`的`GET`参数，这是我们需要支持的旧参数。从那里，网关将提取这个`post_id`属性并将其注入到集成请求中。`post_id`的值在`method.request.querystring.post_id`中可访问。
- en: 'By adding a new query string named `postId` and with a value of `method.request.querystring.post_id`,
    we''re simply passing that value along to the new RESTful API, but using the new
    parameter name of `postId`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个名为`postId`的新查询字符串，其值为`method.request.querystring.post_id`，我们只是简单地将该值传递给新的RESTful
    API，但使用新的参数名`postId`：
- en: '![](img/d51b0241-b5e5-408a-86d4-56eafdfdf868.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d51b0241-b5e5-408a-86d4-56eafdfdf868.png)'
- en: 'To test these changes, we need to deploy the API. In the console, in the Resources
    section, select the Actions button and click Deploy API. Deploy this to our single
    `dev` stage:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些更改，我们需要部署API。在控制台中，在资源部分，选择操作按钮并点击部署API。将其部署到我们的单个`dev`阶段：
- en: '![](img/4543ff55-21af-4f56-ab43-71608b098ba9.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4543ff55-21af-4f56-ab43-71608b098ba9.png)'
- en: 'We can hit our new API and see the results using `curl`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`curl`来调用我们的新API并查看结果：
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Setting up Integration Response
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置集成响应
- en: 'Now that we have the URL and query parameter mapping working, it''s time to
    begin transforming the response generated from our new API. Since the old JSON
    structure is different, we''ll use Gateway''s Body Mapping Templates to take the
    output from the JSON response and rewrite it. API Gateway uses the Velocity Template
    language and system to perform this work. If you''ve ever done web programming
    with a modern-day web framework, you''ve undoubtedly worked with a templating
    library. There are many. Velocity isn''t magic; it serves the same purpose as
    any other templating system: taking some marked up template in a particular syntax
    along with some contextual data and rendering an output string.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设置了 URL 和查询参数映射，现在是时候开始转换我们新 API 生成的响应了。由于旧的 JSON 结构不同，我们将使用网关的主体映射模板从
    JSON 响应中提取输出并重写。API 网关使用 Velocity 模板语言和系统来完成这项工作。如果你曾经使用现代 Web 框架进行过 Web 编程，你无疑已经使用过模板库。有很多。Velocity
    并非魔法；它与其他任何模板系统一样，起到相同的作用：根据特定的语法标记模板以及一些上下文数据，渲染输出字符串。
- en: 'In the Method Execution screen, click on Integration Response. Where we are
    at this point in the request/response cycle is after the backend integration has
    generated a response, just before the system starts sending the data back to the
    client. At this stage, we''ll configure the Integration Response to rewrite the
    output to the client using two things:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法执行屏幕上，点击集成响应。在我们请求/响应周期中的这个阶段，是在后端集成生成响应之后，系统开始向客户端发送数据之前。在这个阶段，我们将配置集成响应，使用以下两点来重写输出给客户端：
- en: The JSON response from our backend (`JSONPlaceholder`)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自我们后端（`JSONPlaceholder`）的 JSON 响应
- en: A body mapping template, which is written using the Velocity Template language
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 Velocity 模板语言编写的主体映射模板
- en: In this section, it's possible to set up different body mapping templates based
    on HTTP response codes and content/type. For simplicity, we'll just be dealing
    with HTTP 200 and a single Integration Response, response code, and content/type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，可以根据 HTTP 响应代码和 content/type 设置不同的主体映射模板。为了简化，我们只需处理 HTTP 200 和单个集成响应、响应代码和
    content/type。
- en: 'In the Integration Response section:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成响应部分：
- en: Expand the single row in the table, which is the Default mapping
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开表格中的单行，即默认映射
- en: Expand the Body Mapping Templates section
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开主体映射模板部分
- en: Click on the application/json in the Content-Type table
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击内容类型表中的 application/json
- en: Add the following template code in the text area and click Save
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本区域中添加以下模板代码并点击保存
- en: Deploy the API to the `dev` stage
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 API 部署到 `dev` 阶段
- en: 'The code block as follows refers to step #4\. This is the Velocity Template
    language syntax:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '下面的代码块指的是步骤 #4。这是 Velocity 模板语言的语法：'
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The template code in the preceding code block should be placed in the template
    section for the application/json, Content-Type, as shown in the screenshot as
    follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码块中的模板代码应放置在 application/json、内容类型模板部分，如图所示：
- en: '![](img/1a1bf104-df97-4c44-8afa-cea7f0a2789f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a1bf104-df97-4c44-8afa-cea7f0a2789f.png)'
- en: 'With that out of the way, calling our API will result in a completely different
    structure of the return payload:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这些问题之后，调用我们的 API 将导致返回负载的结构完全不同：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Provided the backend system contains the necessary data, it's possible to implement
    a complete API with an entirely different structure, writing nothing more than
    some API Gateway configuration and Velocity Templates. As mentioned earlier, there
    are many other advantages to API Gateway that you can leverage, which may be extremely
    useful when replacing a legacy API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设后端系统包含必要的数据，可以实现一个完全不同的结构，只需编写一些 API 网关配置和 Velocity 模板。如前所述，API 网关还有许多其他可以利用的优点，这些优点在替换遗留
    API 时可能非常有用。
- en: Complex integration using a Lambda function
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lambda 函数进行复杂数值积分
- en: Our prior example is a best-case scenario. Because our new backend system included
    all of the data we needed to support our legacy API, our jobs were pretty easy.
    However, what happens in cases where the legacy API you need to support does not
    have a one-to-one mapping with a newer API? Of course, if you control the new
    API it's possible to implement any missing functionality. While that may be possible,
    it may not be a good idea since you may be reimplementing imperfect design in
    your new and clean RESTful API in order to support a legacy system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子是一个最佳情况。因为我们的新后端系统包含了支持遗留API所需的所有数据，我们的工作相当简单。然而，当需要支持的遗留API与较新的API没有一对一映射时会发生什么？当然，如果您控制新的API，则可以实施任何缺失的功能。虽然这可能可行，但这可能不是一个好主意，因为您可能需要在新的干净RESTful
    API中重新实现不完善的设计，以支持遗留系统。
- en: 'In this case, rather than dirtying the new API, it''s possible to use a Lambda
    function as the Integration Type, rather than an HTTP endpoint. With this pattern,
    the Lambda function may act with some intelligence and perform any type of task
    that is needed. For example, imagine another legacy endpoint of `https://$HOSTNAME/get_posts_with_users`
    that returns a list of `posts` with the `user` records embedded in each post record.
    The new API returns `posts` with a structure as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们与其污染新的API，不如使用Lambda函数作为集成类型，而不是HTTP端点。使用这种模式，Lambda函数可以具备一定的智能，并执行所需的任何类型任务。例如，想象一下另一个遗留端点`https://$HOSTNAME/get_posts_with_users`，它返回一个包含在每个帖子记录中嵌入的`user`记录的`posts`列表。新的API返回的`posts`结构如下：
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, our legacy API needs that payload to be returned in the form of the
    following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的遗留API需要以以下形式返回负载：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new API has the user data available at the `/users` endpoint. Using a Lambda
    function, we can make two separate API calls and mash up the results ourselves.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 新的API在`/users`端点提供了用户数据。使用Lambda函数，我们可以进行两个独立的API调用，并自行合并结果。
- en: Implementing the application code
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现应用程序代码
- en: 'First, we need to implement our application logic. The code will be very straightforward
    and I won''t cover the details. Everything can be implemented in a mere 42 lines
    of Python code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要实现我们的应用程序逻辑。代码将非常直接，我不会详细说明。所有内容都可以用仅仅42行Python代码实现：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that our application logic is making the two HTTP requests to our backend
    and mashing up the results, we finally have our desired output format, where `user`
    records are embedded in the `post` records.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用程序逻辑正在向我们的后端发送两个HTTP请求并合并结果，我们最终得到了期望的输出格式，其中`user`记录嵌入在`post`记录中。
- en: 'Deploying this consists of setting up a serverless *service* with a single
    endpoint. Interestingly, we''ll define our function in `serverless.yml` but will
    not use any event to trigger this function. The reason for this is that we will
    manually set up this function to be triggered by our existing API Gateway deployment:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 部署这一步骤包括设置一个具有单个端点的无服务器*服务*。有趣的是，我们将在`serverless.yml`中定义我们的函数，但不会使用任何事件来触发此函数。这样做的原因是我们将手动设置此函数，使其由我们现有的API
    Gateway部署触发：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setting up a new resource and method
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的资源和方法
- en: 'Now, it''s time to set up a new resource and `GET` method in API Gateway. This
    time, we''ll select Lambda Function as the Integration type. Also, we will want
    to check Use Lambda Proxy integration. The reason for choosing this now is that
    we can control details of the response from our application code run by Lambda.
    If there is a need to update headers or otherwise transform the response, we simply
    update our application code and redeploy the Lambda function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在API Gateway中设置一个新的资源和`GET`方法了。这次，我们将选择Lambda Function作为集成类型。此外，我们还将想要检查使用Lambda
    Proxy集成。选择这个的原因是我们可以控制由Lambda运行的应用程序代码的响应细节。如果需要更新头信息或以其他方式转换响应，我们只需更新我们的应用程序代码并重新部署Lambda函数：
- en: '![](img/81b312da-7b79-41bf-add0-46b1b8c346ea.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81b312da-7b79-41bf-add0-46b1b8c346ea.png)'
- en: Select the already deployed Lambda function, click Save, and we're all done.
    There is no need to update the Method Request or Integration since we may perform
    any transformations from the application code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 选择已经部署的Lambda函数，点击保存，我们就完成了。由于我们可能从应用程序代码中执行任何转换，因此无需更新方法请求或集成。
- en: 'Finally, deploy the API, hit the new API endpoint, and see the results:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，部署API，访问新的API端点，查看结果：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Migration techniques
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移技术
- en: In these examples, we've taken a look at a few strategies for implementing a
    new API using existing API backends. Another common scenario is migrating an *existing*
    API to a serverless architecture, *without* changing any of its functionality.
    In this scenario, we can still use the proxy pattern and API Gateway. With all
    of the work in place ready to go, how does one actually deploy a new proxy layer
    without affecting existing traffic or breaking these clients? The following are
    a few techniques and deployment strategies that you may consider when faced with
    this problem.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们查看了一些使用现有API后端实现新API的策略。另一个常见的场景是将现有的API迁移到无服务器架构，而不改变其任何功能。在这种情况下，我们仍然可以使用代理模式和API网关。所有准备工作就绪，那么如何实际部署新的代理层而不影响现有流量或破坏这些客户端呢？以下是一些在遇到这个问题时可以考虑的技术和部署策略。
- en: Staged migration
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分阶段迁移
- en: To replace an existing API with a serverless-based system, it makes sense to
    first implement the proxy pattern and define the complete API in API Gateway.
    Each endpoint would simply proxy requests and responses to and from their corresponding
    APIs on the system to be replaced.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要用基于无服务器的系统替换现有的API，首先实现代理模式并在API网关中定义完整的API是有意义的。每个端点只需简单地代理请求和响应到要替换的系统中的相应API。
- en: 'It''s even possible to start initial testing with what is called a **proxy
    resource**. With this model, one creates a resource in API Gateway named `{proxy+}`.
    This is a greedy resource and will match any URL path that doesn''t already exist,
    be it `/cats`, `/users/10/comments`, and so on. It will also match on any HTTP
    verb. In short, it''s a catch-all that will send any request that doesn''t match
    an existing resource on to the configure Integration backend:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以使用所谓的**代理资源**来开始初始测试。在这种模式下，用户在API网关中创建一个名为`{proxy+}`的资源。这是一个贪婪的资源，会匹配任何不存在的URL路径，无论是`/cats`、`/users/10/comments`等等。它也会匹配任何HTTP动词。简而言之，它是一个通配符，会将任何不匹配现有资源的请求发送到配置的集成后端：
- en: '![](img/34bf8d80-a3ee-4b06-b5eb-aa8ff4c583f2.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34bf8d80-a3ee-4b06-b5eb-aa8ff4c583f2.png)'
- en: Doing this first is a good way to start testing the interaction between Gateway
    and your backend system since you can build out a full test suite without the
    fear of misconfiguring anything. Slowly, you may begin implementing and replacing
    different APIs one by one. In this fashion, you can work at your own pace without
    the fear of flipping a switch to move *all* APIs to some new system at once. If
    a single deployment of a new serverless API doesn't go well, rolling back takes
    mere seconds by deleting the resource and redeploying the API. Since the proxy
    resource will catch any non-matching URL paths, deleting a problematic resource
    simply points that URL path back to the original HTTP integration endpoint. This
    is as simple of a rollback procedure as you'll find.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先这样做是开始测试网关与您的后端系统之间交互的好方法，因为您可以构建一个完整的测试套件，而不用担心配置任何东西出错。慢慢地，您可以一个接一个地实施和替换不同的API。这样，您可以按自己的节奏工作，而不必担心一次性将所有API切换到某个新系统。如果新无服务器API的单次部署不顺利，只需删除资源并重新部署API即可在几秒钟内回滚。由于代理资源会捕获任何不匹配的URL路径，删除有问题的资源只需将那个URL路径指向原始HTTP集成端点。这将是您能找到的最简单的回滚程序。
- en: Migrating URLs
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL迁移
- en: You may have noticed that the URLs provided by API Gateway are quite obscure
    and not easy to remember, for example, [https://eocmzivub6.execute-api.us-west-2.amazonaws.com](https://eocmzivub6.execute-api.us-west-2.amazonaws.com).
    In the example of replacing a legacy API from under existing users, the ideal
    scenario is to merely update DNS records.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到API网关提供的URL相当晦涩，不容易记住，例如，[https://eocmzivub6.execute-api.us-west-2.amazonaws.com](https://eocmzivub6.execute-api.us-west-2.amazonaws.com)。在用现有用户替换旧API的示例中，理想的情况是只需更新DNS记录。
- en: For example, presume the API you're migrating is located at ` https://api.mysite.io` and
    that this URL is embedded across thousands of devices in a mobile application.
    Forcing users to update their code isn't feasible with thousands of clients. You
    know that there will be traffic to that subdomain for a long time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在迁移的API位于`https://api.mysite.io`，并且这个URL嵌入在数千个移动设备的应用程序中。对于数千个客户端来说，强制用户更新代码是不可行的。您知道在很长时间内都会有流量到那个子域。
- en: 'API Gateway provides the ability to apply a custom domain to an API and provides
    free SSL/TLS certificates. With those two features, a migration would be fairly
    straightforward. Assuming you''ve implemented and thoroughly tested the new API
    Gateway version of your API, the migration would consist of:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关提供了将自定义域名应用于 API 的能力，并提供免费的 SSL/TLS 证书。有了这两个功能，迁移过程将相对简单。假设你已经实施并彻底测试了新的
    API 网关版本的 API，迁移将包括以下步骤：
- en: Setting up `api.mysite.io` as a custom domain in API Gateway
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 API 网关中将 `api.mysite.io` 设置为自定义域名
- en: Creating a TLS certificate for `api.mysite.io` from API Gateway (using Amazon
    Certificate Manager, ACM)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 API 网关（使用亚马逊证书管理器 ACM）为 `api.mysite.io` 创建 TLS 证书
- en: Updating DNS to point to the API Gateway URL
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 DNS 以指向 API 网关 URL
- en: 'In cases where the URL is not running on a subdomain, life becomes more complex.
    For example, if you have an existing web application running at `https://mysite.io`
    and the API is found at `https://mysite.io/api`, changing DNS would not work since
    it would break it for the users of your web application. In this case, there are
    two viable options:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 不运行在子域名上的情况下，事情变得更加复杂。例如，如果你有一个运行在 `https://mysite.io` 的现有 Web 应用程序，而
    API 位于 `https://mysite.io/api`，更改 DNS 将不会起作用，因为它会破坏你的 Web 应用程序用户。在这种情况下，有两种可行的选择：
- en: Use or set up some type of router or load balancer that supports path-based
    routing
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用或设置某种支持基于路径路由的路由器或负载均衡器
- en: Update application code to call the API Gateway endpoints for any request to
    `/api`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序代码更新为调用 `/api` 下的 API 网关端点
- en: A load balancer such as HAProxy would work out well here since it provides path-based
    routing and is extremely fast. If it's not feasible to set up a system such as
    that, a final solution would be to manually proxy requests from your own application
    code to the API Gateway endpoint. That method isn't elegant, but technically it
    would work provided headers and query parameters are forwarded along to API Gateway.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个负载均衡器，如 HAProxy，在这里会工作得很好，因为它提供基于路径的路由，并且速度非常快。如果无法设置这样的系统，最终的解决方案将是手动从你的应用程序代码代理请求到
    API 网关端点。这种方法并不优雅，但从技术上讲，如果将头信息和查询参数转发到 API 网关，这种方法是可行的。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the proxy pattern using API Gateway from AWS.
    We walked through multiple examples of mimicking a legacy API using an existing
    RESTful URL as an HTTP integration. You learned the four stages of API Gateway
    method execution and some of the details surrounding each of those integration
    points. We also discussed the proxy pattern when integrating with an AWS Lambda
    function, which provides a bit more control at the expense of more maintenance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 AWS API 网关的代理模式。我们通过多个示例展示了如何使用现有的 RESTful URL 作为 HTTP 集成来模拟遗留
    API。你学习了 API 网关方法执行的四个阶段以及围绕每个集成点的某些细节。我们还讨论了在集成 AWS Lambda 函数时使用的代理模式，这提供了一些控制，但需要更多的维护。
- en: Readers should understand the proxy pattern and have a rough idea of how to
    implement this themselves using API Gateway after this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该理解代理模式，并在本章之后对如何使用 API 网关自己实现这一模式有一个大致的了解。
- en: In the next chapter, we'll move our focus from web application patterns to those
    for data processing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注点从 Web 应用程序模式转移到数据处理模式。
