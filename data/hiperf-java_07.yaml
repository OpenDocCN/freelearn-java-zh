- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: String Objects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串对象
- en: In an effort to analyze every aspect of our Java applications to ensure that
    they perform at a highly efficient rate, we need to consider string objects. Strings
    are a big part of Java applications and are used for limitless purposes from a
    simple list of names to complex data storage needs, such as with a bank’s databases.
    The creation, manipulation, and management of these objects should be a primary
    concern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析我们Java应用程序的各个方面，确保它们以高度高效的速率运行，我们需要考虑字符串对象。字符串是Java应用程序的重要组成部分，用于从简单的名称列表到复杂的数据库存储需求等无限用途。这些对象的创建、操作和管理应该是首要关注的问题。
- en: This chapter focuses on the efficient use of string objects in our Java applications.
    The first concept is proper string pooling. We will examine this concept and explore
    best practices for using string pooling for high performance. The chapter also
    introduces the concept of lazy initialization, examines its benefits, and illustrates
    implementation with sample code. Lastly, we will look at additional string operation
    strategies, to include advanced string manipulation techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍在Java应用程序中高效使用字符串对象。第一个概念是合适的字符串池化。我们将探讨这个概念，并探讨使用字符串池化以实现高性能的最佳实践。本章还介绍了延迟初始化的概念，分析了其优势，并通过示例代码进行说明。最后，我们将探讨额外的字符串操作策略，包括高级字符串操作技术。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Proper string pooling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合适的字符串池化
- en: Lazy initialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟初始化
- en: Additional string operation strategies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的字符串操作策略
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    please refer back to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循本章中的示例和说明，你需要具备加载、编辑和运行Java代码的能力。如果你尚未设置你的开发环境，请参阅[*第1章*](B21942_01.xhtml#_idTextAnchor014)。
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter07](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter07).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下链接找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter07](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter07)。
- en: Proper string pooling
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合适的字符串池化
- en: Our overarching concern is to ensure that our Java applications perform at a
    high level. To that end, memory management is a critical concern. It is important
    that we design, test, and implement techniques for optimizing memory usage. **String
    pooling** is one such technique, whose focus is to enable the reuse of string
    objects for greater application efficiency. The efficiency gains stem from reducing
    memory overhead.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要关注点是确保我们的Java应用程序以高水平运行。为此，内存管理是一个关键问题。我们设计、测试和实施优化内存使用的技术至关重要。**字符串池化**就是这样一种技术，其重点是使字符串对象能够重用，从而提高应用程序的效率。效率的提高源于减少内存开销。
- en: String pooling is an important concept that is anchored to the sharing of string
    values as an alternative to creating new string instances. If your application
    uses string literals frequently, then you should find string pooling especially
    useful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串池化是一个重要的概念，它基于将字符串值共享作为创建新字符串实例的替代方案。如果你的应用程序频繁使用字符串字面量，那么你应该会发现字符串池化特别有用。
- en: String literal
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'A string literal is a fixed value bookended by double quotes. For example,
    the `"Read more books."` component of the following statement is a string literal:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量是一个由双引号包围的固定值。例如，以下语句中的`"Read more books."`部分是一个字符串字面量：
- en: '`System.out.println("Read` `more books.");`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println("Read more books.");`'
- en: To examine string pooling, we will start with the concept of **string interning**,
    then review best practices, and complete our discovery with code examples using
    Java. To take this concept one step further, we will look at string pooling for
    database queries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检验字符串池化，我们将从**字符串内部化**的概念开始，然后回顾最佳实践，并通过Java的代码示例完成我们的探索。为了进一步深入这一概念，我们将探讨数据库查询中的字符串池化。
- en: String interning
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串内部化
- en: String interning is an interesting concept. It is a memory reduction technique
    that allows more than one string to use the same memory location. As you might
    expect, the contents of those strings must be identical for this to work. Memory
    reduction is possible because we can eliminate duplicate objects. String interning
    relies on string pooling for this to work. As we covered in [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074),
    pooling uses a special heap area to store the string literals.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串池化是一个有趣的概念。它是一种内存减少技术，允许多个字符串使用相同的内存位置。正如你所期望的，这些字符串的内容必须相同才能工作。内存减少是可能的，因为我们能够消除重复的对象。字符串池化依赖于字符串池来实现这一点。正如我们在[*第4章*](B21942_04.xhtml#_idTextAnchor074)中提到的，池化使用一个特殊的堆区域来存储字符串字面量。
- en: Let’s try to think like the `intern()` method, part of the `String` class, to
    accomplish this. We will look at an example later in the *Code examples* section
    of this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试像`intern()`方法一样思考，这是`String`类的一部分，以实现这一点。我们将在本章的*代码示例*部分稍后查看一个示例。
- en: Best practices
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: In general, it is considered a good idea to employ string interning in our applications.
    When implementing string interning, there are two important considerations to
    be aware of. First, we should not overuse string interning. The performance and
    memory usage benefits are clear, but if our applications use interning on very
    large strings, then we might consume more memory than we want to.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，被认为在我们的应用程序中使用字符串池化是一个好主意。在实现字符串池化时，有两个重要的考虑因素需要注意。首先，我们不应该过度使用字符串池化。性能和内存使用的益处是明显的，但如果我们的应用程序在非常长的字符串上使用池化，那么我们可能会消耗比我们想要的更多的内存。
- en: Another best practice to consider is avoiding `intern()` method. This way, we
    can ensure consistent behavior in our application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得考虑的最佳实践是避免使用`intern()`方法。这样，我们可以确保我们的应用程序中行为的一致性。
- en: Code examples
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Let’s look at a simple example to demonstrate string interning. The following
    code starts by defining two string literals, `s1` and `s2`. Both strings have
    the same values. A third string, `s3`, is created using the `intern()` method.
    The final two statements are used to compare references:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的示例来演示字符串池化。以下代码首先定义了两个字符串字面量，`s1`和`s2`。这两个字符串具有相同的值。第三个字符串`s3`使用`intern()`方法创建。最后的两个语句用于比较引用：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see from our application’s output, both reference comparisons are
    evaluated as `true`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从我们应用程序的输出中可以看出，两个引用比较都被评估为`true`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: String pooling for database queries
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库查询的字符串池化
- en: SQL and other database queries are often created dynamically in our code and
    can become quite complex. As with other large strings, we can use string pooling
    to help ensure that our application does not unnecessarily create string objects.
    Our goal is to reuse any commonly used database queries instead of recreating
    them multiple times at runtime.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SQL和其他数据库查询通常在我们的代码中动态创建，可能会变得相当复杂。与其他大型字符串一样，我们可以使用字符串池来帮助确保我们的应用程序不会不必要地创建字符串对象。我们的目标是重用任何常用的数据库查询，而不是在运行时多次重新创建它们。
- en: Lazy initialization
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟初始化
- en: The decision to not instantiate an object until it is needed is called **lazy
    initialization**. The word *lazy* normally has a negative connotation; however,
    in the context of software development, lazy initialization is a performance optimization
    approach with the goal of managing an application’s overhead. This design pattern
    is especially useful when detailing very large objects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不在需要时实例化对象的决定被称为**延迟初始化**。通常，“懒惰”这个词带有负面含义；然而，在软件开发中，延迟初始化是一种性能优化方法，其目标是管理应用程序的开销。这种设计模式在详细处理非常大的对象时特别有用。
- en: Should I implement lazy initialization?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该实现延迟初始化吗？
- en: If you have string objects that are large or complex and require significant
    overhead at initialization time, then you should consider lazy initialization.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有大型或复杂的字符串对象，并且需要在初始化时消耗大量开销，那么你应该考虑延迟初始化。
- en: Lazy initialization does not reduce the number of string objects created; rather,
    it delays the initialization until it is required by your application for processing.
    This delaying technique can help you with memory optimization. Let us look at
    a narrative example before we examine the source code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟初始化不会减少创建的字符串对象数量；相反，它将初始化延迟到应用程序需要处理时。这种延迟技术可以帮助你进行内存优化。在我们检查源代码之前，让我们先看看一个叙述示例。
- en: Imagine you have a legacy application that uses very sophisticated string objects.
    When your application opens, a loading screen is displayed and, behind the scenes,
    the application creates several string objects to support the application’s normal
    operations. Users have complained that the application “takes forever to load”
    and that the computer often locks up when trying to launch the application. After
    reviewing the source code, you realize that many of the string objects created
    when the application is launched are only used by the application when the user
    selects certain functions. Your solution is to implement lazy initialization,
    so these string objects are only created when and if they are needed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个使用非常复杂的字符串对象的遗留应用程序。当你的应用程序打开时，会显示一个加载屏幕，并且在幕后，应用程序创建几个字符串对象以支持应用程序的正常操作。用户抱怨应用程序“加载时间过长”，并且当尝试启动应用程序时，计算机经常锁定。在审查源代码后，你意识到在应用程序启动时创建的许多字符串对象仅在用户选择某些功能时被应用程序使用。你的解决方案是实现懒加载，这样这些字符串对象仅在需要时创建。
- en: Code examples
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Now, let us look at how we can implement the lazy initialization design pattern
    in Java. We will start by importing `java.util.function.Supplier`. It is an interface
    that provides a single `get()` method, which we will use to retrieve a value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Java中实现懒加载初始化设计模式。我们首先导入`java.util.function.Supplier`。这是一个接口，它提供了一个单一的`get()`方法，我们将使用它来检索一个值：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we declare our class and use `StringBuilder` to generate a complex string
    using the `append()` method multiple times:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明我们的类，并使用`StringBuilder`通过多次调用`append()`方法生成一个复杂字符串：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Staying inside the `LazyInitializationExample` class, we make a call to the
    `getLazyString()` method. This method is used to create or retrieve the complex
    string only when it is needed – not before:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LazyInitializationExample`类内部，我们调用`getLazyString()`方法。此方法用于在需要时创建或检索复杂字符串，而不是在需要之前：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last part of our code is the `main()` method. When this method is run,
    we access the lazily initialized string:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的最后一部分是`main()`方法。当此方法运行时，我们访问懒加载的字符串：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the program is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Best practices
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: The concept of lazy initialization is straightforward and the decision to implement
    it is easy. If you have large string objects, then you should try this approach.
    There are two best practices to consider with lazy initialization. First, we should
    implement synchronization when we are working in a multiple-thread environment.
    This is to help promote thread safety. Another best practice is to avoid overuse.
    When we overuse lazy initialization, our code might become difficult to read and
    maintain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载的概念很简单，决定实现它也很容易。如果你有大型字符串对象，那么你应该尝试这种方法。在懒加载中有两个最佳实践需要考虑。首先，当我们在一个多线程环境中工作时，我们应该实现同步。这是为了帮助促进线程安全。另一个最佳实践是避免过度使用。当我们过度使用懒加载时，我们的代码可能变得难以阅读和维护。
- en: Additional string operation strategies
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的字符串操作策略
- en: String pooling and lazy initialization are excellent optimization strategies
    that can help improve the overall performance of our Java applications. In addition
    to these strategies, we can ensure that our string concatenation operations are
    efficient, that we properly leverage regular expressions, and that we efficiently
    handle large text files. This section reviews techniques in each of those areas.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串池和懒加载是优秀的优化策略，可以帮助提高我们Java应用程序的整体性能。除了这些策略之外，我们还可以确保我们的字符串连接操作是高效的，我们正确地利用正则表达式，并且我们有效地处理大文本文件。本节回顾了这些领域的各项技术。
- en: Concatenation
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接
- en: String concatenation – the joining of two or more strings into one – using the
    plus (`+`) operator often results in inefficient code. This concatenation creates
    a new string object, which we want to avoid. Let’s look at two alternatives that
    offer better performance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接——使用加号（`+`）操作符将两个或多个字符串连接成一个——通常会导致代码效率低下。这种连接会创建一个新的字符串对象，我们希望避免。让我们看看两种提供更好性能的替代方案。
- en: 'This first alternative uses `StringBuilder`. In the following example, we create
    a `StringBuilder` object, append five string literals to it, convert the `StringBuilder`
    object to `String`, and then output the results:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择使用了`StringBuilder`。在下面的示例中，我们创建了一个`StringBuilder`对象，向其中追加五个字符串字面量，将`StringBuilder`对象转换为`String`，然后输出结果：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another alternative is to use `StringBuffer`. The following program is similar
    to our `StringBuilder` example but uses `StringBuffer` instead. As you can see,
    both methods are implemented in the same manner:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种替代方案是使用`StringBuffer`。以下程序类似于我们的`StringBuilder`示例，但使用的是`StringBuffer`。如您所见，两种方法都是用相同的方式实现的：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference between the `StringBuilder` and `StringBuffer` alternatives to
    string concatenation is that `StringBuffer` offers us thread safety, so it should
    be used in multiple-thread environments; otherwise, `StringBuilder` is an alternative
    to using the plus (`+`) operator for string concatenation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`和`StringBuffer`在字符串连接上的区别在于`StringBuffer`提供了线程安全，因此应在多线程环境中使用；否则，`StringBuilder`是使用加号（`+`）运算符进行字符串连接的替代方案。'
- en: Regular expressions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: '**Regular expressions** provide us with an excellent method of pattern matching
    as well as string manipulation. Because these expressions can be processor- and
    memory-intensive, it is important to learn how to use them efficiently. We can
    optimize the use of regular expressions by compiling our patterns only once and
    reusing them as needed.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**为我们提供了优秀的模式匹配和字符串操作方法。因为这些表达式可能对处理器和内存资源要求较高，因此学习如何高效使用它们非常重要。我们可以通过仅编译一次模式并按需重用它们来优化正则表达式的使用。'
- en: 'Let’s look at an example. In the first part of our application, we import the
    `Matcher` and `Pattern` classes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。在我们应用程序的第一部分，我们导入了`Matcher`和`Pattern`类：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we establish our email pattern regex:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们建立我们的电子邮件模式正则表达式：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This next section of code creates a list of sample email addresses. We will
    later check these for validity:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段创建了一个示例电子邮件地址列表。我们稍后将检查这些地址的有效性：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next statement compiles the regex pattern:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句编译了正则表达式模式：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This last section of code iterates through each email address in our list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一部分遍历我们列表中的每个电子邮件地址：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This simple implementation of regular expression checks for email address formatting
    and demonstrates how to compile the regex pattern once and use it elsewhere in
    the application as an efficient alternative to compiling the pattern each time
    we need to perform the email address validation operation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的正则表达式实现检查电子邮件地址格式，并演示了如何一次性编译正则表达式模式，并在应用程序的其他地方作为每次执行电子邮件地址验证操作时的有效替代方案使用。
- en: Large text files
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大型文本文件
- en: Some Java applications can process very large text files, even book-length files.
    It is not advisable to load the file’s complete content at one time. Our applications
    can quickly run out of available memory and cause undesirable runtime results.
    An alternative is to use a buffered approach to read the text files in segments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Java应用程序可以处理非常大的文本文件，甚至长达书籍的文件。一次性加载文件的完整内容是不推荐的。我们的应用程序可能会迅速耗尽可用内存，导致不希望的运行时结果。一种替代方案是使用缓冲方法分段读取文本文件。
- en: 'The following example assumes that there is a text file in the local directory.
    We read each line using `BufferedReader`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例假设本地目录中有一个文本文件。我们使用`BufferedReader`逐行读取：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This approach can help us manage our memory and improve the overall performance
    of our applications.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以帮助我们管理内存，并提升我们应用程序的整体性能。
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on how to create, manipulate, and manage strings to contribute
    to the overall performance of your Java applications. You should now understand
    string pooling and have the confidence to use it effectively based on best practices.
    Lazy initialization should now be a strategy you consider implementing in your
    future applications when dealing with the extensive use of strings and you are
    concerned about thread safety. The chapter also introduced advanced string operation
    strategies to help give you choices when designing your Java applications for
    high performance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了如何创建、操作和管理字符串，以提升您Java应用程序的整体性能。您现在应该理解了字符串池，并基于最佳实践有信心有效地使用它。在处理大量字符串使用且关注线程安全时，延迟初始化现在应该是一个您在未来的应用程序中考虑实现的策略。本章还介绍了高级字符串操作策略，以帮助您在设计高性能Java应用程序时有所选择。
- en: In the next chapter, *Memory Leaks*, we will look at what memory leaks are,
    how they are created, and what effects they have on our applications. We will
    look at strategies for avoiding memory leaks to improve the performance of our
    Java applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章“内存泄漏”中，我们将探讨内存泄漏是什么，它们是如何产生的，以及它们对我们应用程序的影响。我们将探讨避免内存泄漏的策略，以提升我们Java应用程序的性能。
