- en: 7\. Databases and JDBC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 数据库和JDBC
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In the following chapter, you will learn how to use **Java Database Connectivity**
    (**JDBC**) to access relational databases from your Java applications. This begins
    with creating tables in relational databases to store and sort data. Only then
    can you manipulate these tables by writing basic SQL queries to retrieve and modify
    that data. Once this baseline is established, you'll be able to apply these skills
    to Java applications, specifically, in order to access databases and run queries
    from JDBC. You will further practice using the JDBC PreparedStatement interface
    to allow for parameterized SQL statements, boosting your speed by cutting out
    time-consuming and repetitive keystrokes. By the end of this chapter, you will
    know how to insert and update data from the JDBC, and handle any exceptions it
    throws with confidence and skill.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用**Java数据库连接**（**JDBC**）从Java应用程序中访问关系型数据库。这始于在关系型数据库中创建表以存储和排序数据。只有在此基础上，你才能通过编写基本的SQL查询来检索和修改这些数据。一旦这个基础建立起来，你将能够将这些技能应用到Java应用程序中，特别是为了通过JDBC访问数据库并运行查询。你还将进一步练习使用JDBC
    PreparedStatement接口，以允许使用参数化SQL语句，通过减少耗时和重复的按键操作来提高速度。到本章结束时，你将知道如何从JDBC中插入和更新数据，并自信地处理它抛出的任何异常。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Databases—especially relational databases—are used in thousands of applications,
    from small home-based applications to huge enterprise systems. To help us write
    applications that access databases, Java provides a few very handy tools, starting
    with **Java Database Connectivity** (**JDBC**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库——尤其是关系型数据库——被用于成千上万的应用程序中，从小型家庭应用到大型的企业系统。为了帮助我们编写访问数据库的应用程序，Java提供了一些非常实用的工具，从**Java数据库连接**（**JDBC**）开始。
- en: '**JDBC** allows Java applications to connect to a myriad of databases, provided
    you have the correct driver: a Java library designed to communicate with a given
    database. Once connected, JDBC provides an API for accessing databases in a manner
    that is mostly generic. You''ll only encounter a few areas where you need to know
    the specifics of the underlying database implementation.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**JDBC**允许Java应用程序连接到众多数据库，前提是你有正确的驱动程序：一个设计用来与特定数据库通信的Java库。一旦连接，JDBC提供了一种通用的方式来访问数据库。你只会遇到少数几个需要了解底层数据库实现具体细节的区域。'
- en: Relational Databases
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: 'Originally defined by E. F. Codd, relational databases store data in tables,
    made up of columns and rows. For example, the following table could be used to
    store customer information:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库最初由E. F. Codd定义，将数据存储在由列和行组成的表中。例如，以下表可以用来存储客户信息：
- en: '![Figure 7.1: A database table of customers'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：客户数据库表](img/C13927_07_01.jpg)'
- en: '](img/C13927_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_07_01.jpg)'
- en: 'Figure 7.1: A database table of customers'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：客户数据库表
- en: 'In this customer table example, each row has four columns: an ID, a username,
    a first name, and a last name.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个客户表示例中，每一行有四个列：一个ID、一个用户名、一个名和一个姓。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to celebrities such as Sting, Cher, and Bono, some ethnic groups
    use just one name. You will not always have first and last names.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像Sting、Cher和Bono这样的名人之外，一些民族群体只使用一个名字。你并不总是会有姓氏和名字。
- en: Each row needs a unique way to distinguish that row from all others, called
    a **unique primary key**. In this case, the ID column acts as a unique key. In
    this table, you could also use the username as a unique key.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都需要一种独特的方式来区分该行与其他所有行，这被称为**唯一主键**。在这种情况下，ID列充当唯一键。在这个表中，你也可以使用用户名作为唯一键。
- en: Some tables use a single column as a key, while others use the values in multiple
    columns to form the key, called a **composite key**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表使用单个列作为键，而其他表则使用多个列中的值来形成键，这被称为**组合键**。
- en: Most databases use more than one table. You can relate tables to other tables
    based on information within a row.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库使用多个表。你可以根据行中的信息将表与其他表关联起来。
- en: 'For example, in an online system, each customer might have multiple email addresses.
    You can model this relationship using a separate table for email addresses, as
    shown in Table 2:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个在线系统中，每个客户可能有多个电子邮件地址。你可以使用一个单独的表来模拟这种关系，如表2所示：
- en: '![Figure 7.2: A database table for email addresses'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2：电子邮件地址数据库表](img/C13927_07_02.jpg)'
- en: '](img/C13927_07_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_07_02.jpg)'
- en: 'Figure 7.2: A database table for email addresses'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：电子邮件地址数据库表
- en: In table 2, each row has its own unique ID, with the `EMAIL_ID` column. Each
    row also links back to the customer table by holding an ID for the user table
    in the `CUSTOMER_ID` column. This allows the `EMAIL` table to link to the `CUSTOMER`
    table. User `bobmarley`, for example, has two email addresses in the system, one
    for home and one for work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在表 2 中，每一行都有一个唯一的 ID，通过 `EMAIL_ID` 列。每一行也通过在 `CUSTOMER_ID` 列中持有用户表的 ID 来链接回客户表。这使得
    `EMAIL` 表能够链接到 `CUSTOMER` 表。例如，用户 `bobmarley` 在系统中有两个电子邮件地址，一个用于家庭，一个用于工作。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These email addresses are not real.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些电子邮件地址不是真实的。
- en: In this hypothetical example, there may also be tables for postal addresses,
    customer preferences, billing, and other things. Each table would likely relate
    back to the customer table.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个假设的例子中，也可能有用于邮政地址、客户偏好、账单和其他事物的表。每个表都可能关联回客户表。
- en: To use a relational database, you need a **Relational Database Management System**
    (**RDBMS**), the software that manages the tables.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用关系数据库，您需要一个 **关系数据库管理系统**（**RDBMS**），这是管理表的软件。
- en: Relational Database Management Systems
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系数据库管理系统
- en: Some of the most common RDBMSes include Oracle, MySQL, SQL Server, PostgreSQL,
    and DB2\. In each case, you have software that runs on a server (or servers) to
    manage the data, along with separate client software to query and manipulate the
    data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常用的关系数据库管理系统（RDBMS）包括 Oracle、MySQL、SQL Server、PostgreSQL 和 DB2。在每种情况下，您都有在服务器（或服务器）上运行的软件来管理数据，以及用于查询和操作数据的独立客户端软件。
- en: To use an RDMS, you first need to install the database software.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 RDMS，您首先需要安装数据库软件。
- en: Installing a Database
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装数据库
- en: In this chapter, we'll use an open-source database called H2\. H2 is written
    entirely in Java, so you can run it wherever you run a JVM, such as in Windows,
    Linux, or macOS systems. On account of its portability and simplicity, H2 works
    well for the database tables we'll create in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个名为 H2 的开源数据库。H2 完全用 Java 编写，因此您可以在任何运行 JVM 的地方运行它，例如在 Windows、Linux
    或 macOS 系统上。由于其可移植性和简单性，H2 适用于本章中我们将创建的数据库表。
- en: H2 has some nice features in that it comes with a browser-based database console
    that you can use to access the database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: H2 有一些不错的功能，它提供了一个基于浏览器的数据库控制台，您可以使用它来访问数据库。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: H2 can also be used inside your applications as an embedded in-memory database.
    In this case, the database server and client both exist within your Java application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: H2 也可以在您的应用程序中作为嵌入式的内存数据库使用。在这种情况下，数据库服务器和客户端都存在于您的 Java 应用程序中。
- en: To install H2, go to [https://packt.live/2MYw1XX](https://packt.live/2MYw1XX)
    and download the `h2`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 H2，请访问 [https://packt.live/2MYw1XX](https://packt.live/2MYw1XX) 并下载 `h2`。
- en: Inside the `h2` folder, you will see sub-folders named `bin`, `docs`, `service`,
    and `src`. The documentation in the `docs` folder is also available online.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `h2` 文件夹内，您将看到名为 `bin`、`docs`、`service` 和 `src` 的子文件夹。`docs` 文件夹中的文档也在线可用。
- en: The bin folder contains the H2 database software bundled into a JAR file. It
    also contains a Windows batch file and a Unix/Linux shell script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`bin` 文件夹包含打包成 JAR 文件的 H2 数据库软件。它还包含 Windows 批处理文件和 Unix/Linux 脚本。'
- en: 'Exercise 1: Running the H2 Database'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：运行 H2 数据库
- en: 'Now that you have installed the database, the next step is to get the database
    up and running. To do this, perform the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了数据库，下一步是让数据库运行起来。为此，请执行以下步骤：
- en: 'To run the H2 database, you can use one of the scripts in the `bin` folder,
    or simply run the `jar` file. For example:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 H2 数据库，您可以使用 `bin` 文件夹中的其中一个脚本，或者简单地运行 `jar` 文件。例如：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Regardless of how you launch the H2 database, you can access it from a browser.
    On some systems, such as macOS, H2 will open the database console in your default
    browser.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论您如何启动 H2 数据库，您都可以通过浏览器访问它。在某些系统上，例如 macOS，H2 将在您的默认浏览器中打开数据库控制台。
- en: If it does not open automatically, you can simply point your browser to `http://10.0.1.7:8082/`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它没有自动打开，您只需将浏览器指向 `http://10.0.1.7:8082/`。
- en: 'You will see the login pane with the information filled in, as shown in *Figure
    7.1*:![Figure 7.3: The login pane for the web database console'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到带有填写信息的登录面板，如图 *图 7.1* 所示：![图 7.3：Web 数据库控制台的登录面板
- en: '](img/C13927_07_03.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C13927_07_03.jpg)'
- en: 'Figure 7.3: The login pane for the web database console'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.3：Web 数据库控制台的登录面板
- en: All the information should be filled in correctly when you start. The database
    driver (discussed later in this chapter) is `org.h2.Driver`, the JDBC URL is `jdbc:h2:~/test`,
    the username is `sa` (for system administrator), and the password is empty.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在开始时，所有信息都应该填写正确。数据库驱动程序（本章后面将讨论）是 `org.h2.Driver`，JDBC URL 是 `jdbc:h2:~/test`，用户名是
    `sa`（系统管理员），密码为空。
- en: Obviously, on a real database, you'd use an actual password.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然，在实际数据库中，你会使用实际的密码。
- en: Click `Connect`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `连接`。
- en: In a few moments, you'll see the main console pane, and you're in.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几分钟后，你会看到主控制台面板，你已进入。
- en: Note
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: By default, H2 will store databases in your home directory. With this database
    named `test`, you should see two files in your home directory with names starting
    with `test` and ending with `db`.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，H2 将数据库存储在你的主目录中。使用名为 `test` 的数据库，你应该在你的主目录中看到两个以 `test` 开头并以 `db` 结尾的文件。
- en: Once you have the H2 database installed and running, the next step is to start
    creating tables. To do so, you need to write commands in a language called SQL.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装并运行了 H2 数据库，下一步就是开始创建表。为此，你需要用一种叫做 SQL 的语言编写命令。
- en: Introducing SQL
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 SQL
- en: '**Structured Query Language** (**SQL** and often pronounced "sequ-el") provides
    a common language for querying and manipulating data in relational databases.
    While there are a few differences, SQL mostly works the same in relational database
    systems such as Oracle, SQL Server, MySQL, and H2.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化查询语言**（**SQL**，通常发音为“sequ-el”）为查询和操作关系数据库中的数据提供了一种通用语言。虽然有一些差异，但 SQL 在
    Oracle、SQL Server、MySQL 和 H2 等关系数据库系统中大多以相同的方式工作。'
- en: The first thing you need to do is to create a table. To do so, use the `CREATE
    TABLE` SQL command. To create a table, you must provide the name of the table,
    the names and types of the columns, and any constraints.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是创建一个表。为此，使用 `CREATE TABLE` SQL 命令。要创建表，你必须提供表名、列名和类型以及任何约束。
- en: 'Exercise 2: Creating the customer Table'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2：创建客户表
- en: Use the SQL `CREATE TABLE` command to create a `customer` table. It should contain
    the customer ID and the users' first and last names.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQL `CREATE TABLE` 命令创建一个 `customer` 表。它应包含客户 ID 和用户的姓氏和名字。
- en: 'Enter the following SQL commands in the upper-right input pane:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角的输入面板中输入以下 SQL 命令：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After entering the SQL command, click on the `Run` button.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 SQL 命令后，点击 `运行` 按钮。
- en: '*Figure 7.2* shows the main database console window:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 7.2* 展示了主要数据库控制台窗口：'
- en: '![Figure 7.4: The H2 database console after creating a table'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4：创建表后的 H2 数据库控制台'
- en: '](img/C13927_07_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_07_04.jpg)'
- en: 'Figure 7.4: The H2 database console after creating a table'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：创建表后的 H2 数据库控制台
- en: Notice in *Figure 7.4* that once the table is created, you see the table name,
    `CUSTOMER`, in the left-hand pane. You can click on the `+` symbol to expand the
    table entry and see the columns, as shown in *Figure 7.4*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 *图 7.4* 中，一旦表创建完成，你会在左侧面板看到表名 `CUSTOMER`。你可以点击 `+` 符号展开表条目并查看列，如 *图 7.4*
    所示。
- en: 'The `CREATE TABLE` command can be broken down into its component parts. The
    command starts with `CREATE TABLE`. After that, `IF NOT EXISTS` means to not attempt
    to recreate the table if it already exists (the `ALTER TABLE` command is used
    to change the structure of an existing table):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE` 命令可以被分解为其组成部分。命令以 `CREATE TABLE` 开始。之后，`IF NOT EXISTS` 表示如果表已存在则不尝试重新创建表（使用
    `ALTER TABLE` 命令来更改现有表的结构）：'
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next comes the table name, `customer`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是表名，`customer`。
- en: 'After a parenthesis, you will see the definition of the columns and then the
    constraints:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号之后，你会看到列的定义然后是约束：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `CUSTOMER_ID` column is of the `long` type, like the Java `long` type. This
    column will be the unique primary key.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUSTOMER_ID` 列是 `long` 类型，类似于 Java 的 `long` 类型。这个列将是唯一的键。'
- en: The `USERNAME`, `FIRST_NAME`, and `LAST_NAME` columns are all of the `varchar`
    type. The `varchar` type holds variable-length character (text) data up to a maximum
    number of characters, specified here as `255` characters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`USERNAME`、`FIRST_NAME` 和 `LAST_NAME` 列都是 `varchar` 类型。`varchar` 类型可以存储最多指定为
    `255` 个字符的变长字符（文本）数据。'
- en: 'Next comes the constraints:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是约束：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `USERNAME` column must be unique, and the `CUSTOMER_ID` column is the primary
    key. (The primary key must also be unique.) The database will enforce these constraints
    when you insert data. Note that you can list multiple columns names, separated
    by commas, to create a composite primary key. This means that the combination
    of values in those columns must be unique.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`USERNAME`列必须是唯一的，而`CUSTOMER_ID`列是主键。（主键也必须是唯一的。）当您插入数据时，数据库将强制执行这些约束。请注意，您可以通过逗号分隔多个列名来创建一个复合主键。这意味着这些列中的值组合必须是唯一的。'
- en: The entire command ends with a closing parenthesis and a semicolon. SQL uses
    a semicolon in the same way as Java to indicate the end of a statement.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 整个命令以一个闭括号和一个分号结束。SQL使用分号与Java一样，表示语句的结束。
- en: Inserting Data into a Table
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向表中插入数据
- en: 'To insert data into a table, use the `INSERT INTO` command. The basic syntax
    is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要向表中插入数据，请使用`INSERT INTO`命令。基本语法如下：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You first list the columns and then provide values for those columns. You must
    provide a value for all columns that do not allow nulls. In this case, the `CUSTOMER_ID`
    and the `USERNAME` are required. Each must also be unique.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先列出列，然后为这些列提供值。对于不允许为空的列，您必须提供值。在这种情况下，`CUSTOMER_ID`和`USERNAME`是必需的。每个都必须是唯一的。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: SQL uses a single quote character to delimit strings. If you need to enter a
    quote character, use two together, such as `Java''s`. Don't try smart quotes,
    as are used in some word processors.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SQL使用单引号字符来界定字符串。如果您需要输入引号字符，请使用两个一起，例如`Java''s`。不要尝试使用一些文字处理软件中使用的智能引号。
- en: 'Exercise 3: Inserting Data'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3：插入数据
- en: This exercise again uses the H2 web console.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习再次使用H2网络控制台。
- en: 'Enter the following SQL in the upper-right input pane:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角的输入面板中输入以下SQL语句：
- en: '[PRE6]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After entering the SQL command, click on the `Run` button.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入SQL命令后，单击`运行`按钮。
- en: 'Repeat these two steps with the following two SQL statements:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下两个SQL语句重复这两个步骤：
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Most RDBMSs support types that will automatically manage ID numbers for a primary
    key. The syntax does differ in different database software, however. Refer to
    [https://packt.live/2J6z5Qt](https://packt.live/2J6z5Qt) for the `IDENTIIY` type
    for H2.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数关系型数据库管理系统（RDBMS）支持自动管理主键ID号的类型。然而，不同的数据库软件的语法可能会有所不同。有关H2数据库中`IDENTIIY`类型的详细信息，请参阅[https://packt.live/2J6z5Qt](https://packt.live/2J6z5Qt)。
- en: Retrieving Data
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索数据
- en: To retrieve data from a table (or tables), use the `SELECT` command. The SQL
    `SELECT` command lets you query for data. You must specify what you are looking
    for.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要从表（或多个表）中检索数据，请使用`SELECT`命令。SQL `SELECT`命令允许您查询数据。您必须指定您要查找的内容。
- en: 'The basic syntax is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基本语法如下：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can provide a comma-delimited list of columns to return, or use an asterisk,
    `*`, to indicate you want all the columns returned. The simplest query follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供以逗号分隔的列列表以返回，或者使用星号`*`来表示您希望返回所有列。最简单的查询如下：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should now see all the rows returned, as displayed in *Figure 7.3*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到所有返回的行，如*图7.3*所示：
- en: '![Figure 7.5: Querying all the rows from the customer table'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：查询客户表中的所有行'
- en: '](img/C13927_07_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_07_05.jpg)'
- en: 'Figure 7.5: Querying all the rows from the customer table'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：查询客户表中的所有行
- en: 'You can refine your query with a `WHERE` clause. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`WHERE`子句来细化您的查询。例如：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will return all rows that have a `first_name` column value equal to `Bob`,
    which, so far, would be just one row.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有`first_name`列值等于`Bob`的行，到目前为止，这将是仅有一行。
- en: 'You can use a wild card query with the `LIKE` modifier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用带有`LIKE`修饰符的通配符查询：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This query returns all rows where the username has an `e`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回所有用户名中包含`e`的行。
- en: 'In SQL, the percent sign acts as a wild card. This example has a wild card
    at the beginning of the value, and another at the end. You can use just one wild
    card, for example, to query for the end of a value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，百分号用作通配符。此示例在值的开头和结尾都有一个通配符。例如，您可以使用单个通配符来查询值的结尾：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example queries for all records that have a username value that ends in
    `ey`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例查询所有用户名值以`ey`结尾的记录。
- en: 'You can make a more detailed query using `OR` or `AND` in the `WHERE` clause.
    For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`OR`或`AND`在`WHERE`子句中进行更详细的查询。例如：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example returns all rows where the `first_name` is `Peter` or the `last_name`
    is `Cliff`, which is two rows in this example.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例返回所有`first_name`为`Peter`或`last_name`为`Cliff`的行，在这个例子中是两行。
- en: 'With an `OR` operator, the `SELECT` statement returns all rows that match either
    of the criteria. With an `AND` operator, both parts of the criteria must match:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `OR` 运算符，`SELECT` 语句返回所有符合任一条件的行。使用 `AND` 运算符，两个条件部分都必须匹配：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example will return zero rows since no row matches both criteria.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有行同时符合两个条件，此示例将返回零行。
- en: 'Thus far, we''ve used an asterisk to indicate that we want all columns returned.
    You can specify a comma-delimited list of column names instead. For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用星号来表示我们想要返回所有列。您可以使用逗号分隔的列名列表来指定。例如：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This example also uses the `ORDER BY` clause to tell the database to return
    the records in a certain order, in this case, sorted by `last_name` and then `first_name`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还使用了 `ORDER BY` 子句来告诉数据库按特定顺序返回记录，在这种情况下，按 `last_name` 排序，然后按 `first_name`
    排序。
- en: 'SQL uses two dashes, `--`, to indicate the start of a comment, as shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 使用两个短横线 `--` 来表示注释的开始，如下所示：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: SQL queries can get quite complex. These examples just provide a small taste.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 查询可以非常复杂。这些例子只是提供了一个小的示例。
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on SQL, you can refer to the following Packt video: [https://packt.live/33KIi8S](https://packt.live/33KIi8S).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 SQL 的更多信息，您可以参考以下 Packt 视频：[https://packt.live/33KIi8S](https://packt.live/33KIi8S)。
- en: Relating Tables
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联表
- en: Most databases include multiple tables, and many of these tables will be related.
    From the earlier example, we can relate the customer table to a separate table
    for email addresses. In the previous example, each row in the email table included
    the ID of the related row in the customer table.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据库都包含多个表，其中许多表将是相关的。从早期的例子中，我们可以将客户表与一个单独的电子邮件地址表相关联。在先前的例子中，电子邮件表中的每一行都包含了与客户表相关行的
    ID。
- en: 'Exercise 4: Creating the email Table'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4：创建电子邮件表
- en: This exercise uses the H2 web console. In this exercise, we will create an email
    table and insert some values into it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习使用的是 H2 网络控制台。在这个练习中，我们将创建一个电子邮件表并向其中插入一些值。
- en: 'Enter the following SQL in the upper-right input pane:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角的输入面板中输入以下 SQL：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After entering the SQL command, click the `Run` button.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 SQL 命令后，点击 `运行` 按钮。
- en: 'Include the following `INSERT` statement, and then click the `Run` button:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下 `INSERT` 语句，然后点击 `运行` 按钮：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Include the following `INSERT` statement, and then click on the `Run` button:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下 `INSERT` 语句，然后点击 `运行` 按钮：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Include the following `INSERT` statement, and then click on the `Run` button:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下 `INSERT` 语句，然后点击 `运行` 按钮：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how we must manage the IDs, both `EMAIL_ID` and the related `CUSTOMER_ID`.
    This can become tedious. Java libraries, such as Hibernate, that map Java objects
    to relational tables can help with this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何必须管理 ID，即 `EMAIL_ID` 和相关的 `CUSTOMER_ID`。这可能会变得繁琐。将 Java 对象映射到关系表的 Java
    库，如 Hibernate，可以帮助解决这个问题。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Hibernate is considered an ORM, or Object-Relational Mapper. For more information
    on Hibernate, refer to [https://packt.live/2Bs5z3k](https://packt.live/2Bs5z3k).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 被认为是 ORM，即对象关系映射器。有关 Hibernate 的更多信息，请参阅 [https://packt.live/2Bs5z3k](https://packt.live/2Bs5z3k)。
- en: Once you have data in multiple related tables, you can query from multiple tables
    at once, joining the results together.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在多个相关表中有了数据，您就可以一次性查询多个表，并将结果连接起来。
- en: Selecting Data from Multiple Tables
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个表中选择数据
- en: When you use the SQL select statement to query data from multiple tables, you
    need to list all the columns (from all the tables) that you wish to be returned,
    along with the criteria to search in the `WHERE` clause. In the `WHERE` clause,
    you will need to join the two tables on some common value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 SQL 选择语句从多个表中查询数据时，您需要在 `WHERE` 子句中列出您希望返回的所有列（来自所有表），以及搜索条件。在 `WHERE`
    子句中，您需要根据某些共同值将两个表连接起来。
- en: 'For example, the `email` table has a `customer_id` column to join back to the
    `customer` table. To join that, write a query along the lines of the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`email` 表有一个 `customer_id` 列，可以用来与 `customer` 表关联。为了关联它，编写如下查询：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this query, we ask for the `username` from the customer table, along with
    the `email_address` from the email table. The `FROM` section lists both the customer
    and email tables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询中，我们请求来自客户表的 `username` 以及来自电子邮件表的 `email_address`。`FROM` 部分列出了客户和电子邮件表。
- en: The `WHERE` clause gets more interesting. This query looks for all email addresses
    where the type is `HOME`. To join this back to the customer table, and to ensure
    you are getting the right customer, the query adds a join where the `customer_id`
    email table column corresponds to the `customer_id` customer table column. This
    ensures that you get the correct customers aligned.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句变得更加有趣。此查询查找所有类型为 `HOME` 的电子邮件地址。为了将其与客户表连接起来，并确保你得到正确的客户，查询添加了一个连接，其中电子邮件表的
    `customer_id` 列与客户表的 `customer_id` 列相对应。这确保了你得到正确的客户对齐。'
- en: Modifying Existing Rows
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改现有行
- en: 'The `UPDATE` command lets you modify existing rows. To update data, you need
    to specify which rows to change, along with the values to change. The basic syntax
    is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE` 命令让你修改现有行。要更新数据，你需要指定要更改的行以及要更改的值。基本语法如下：'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Exercise 5: Modifying email Data'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5：修改电子邮件数据
- en: 'If a user, such as `bobmarley`, switches to a different work email, you would
    need to update the email table. To do so, perform the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户，如 `bobmarley`，切换到不同的工作电子邮件，你需要更新电子邮件表。为此，执行以下步骤：
- en: Go to the H2 database console.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 H2 数据库控制台。
- en: 'Include the following SQL query, and then click `Run`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下 SQL 查询，然后点击“运行”：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command lets you see what values are in the table now before we change
    anything.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令让你在更改任何内容之前查看表中当前有哪些值。
- en: 'Next, enter the following `UPDATE` statement, and then click `Run`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入以下 `UPDATE` 语句，然后点击“运行”：
- en: '[PRE24]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This query changes the `email_address` entry for the customer, `bobmarley`,
    but just the `WORK` email.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此查询更改了客户 `bobmarley` 的 `email_address` 条目，但只是 `WORK` 电子邮件。
- en: 'Now, run the select query again (and click `Run`) to see how the table has
    changed:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行选择查询（并点击“运行”）以查看表如何更改：
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should now see the results as shown in the following table:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在应该看到以下表格中所示的结果：
- en: '![Figure 7.6: Output of the query'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6：查询输出'
- en: '](img/C13927_07_06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C13927_07_06.jpg](img/C13927_07_06.jpg)'
- en: 'Figure 7.6: Output of the query'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：查询输出
- en: Deleting Data
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'To remove data from a table, use the `DELETE` command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要从表中删除数据，请使用 `DELETE` 命令：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For example, to remove the work email for the customer, `bobmarley`, you would
    use a command such as the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要删除客户 `bobmarley` 的工作电子邮件，你会使用如下命令：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you have tables that are related, deleting data becomes trickier. If you
    delete a customer, for example, you need to delete all rows from the email table
    for this customer, too. In this example, the email table depends on the customer
    table, but the opposite is not true.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有相关的表时，删除数据变得更加复杂。例如，如果你删除一个客户，你还需要删除该客户的电子邮件表中的所有行。在这个例子中，电子邮件表依赖于客户表，但反之则不成立。
- en: In all the examples so far in this chapter, we've used SQL in the H2 console
    to work with the data in a test database. In your Java applications, you will
    use JDBC to accomplish much the same goals.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章迄今为止的所有示例中，我们都在 H2 控制台中使用了 SQL 来处理测试数据库中的数据。在你的 Java 应用程序中，你将使用 JDBC 来实现几乎相同的目标。
- en: JDBC—Accessing Databases from Java
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDBC——从 Java 访问数据库
- en: JDBC provides a common API to work with databases. Mostly, JDBC works with relational
    databases, but you can work with any data source for which you have a **JDBC driver**,
    the Java library that communicates with the data source and implements the JDBC
    API.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 提供了一个通用的 API 来处理数据库。大多数情况下，JDBC 与关系数据库一起工作，但你可以处理任何有 **JDBC 驱动程序** 的数据源，这是与数据源通信并实现
    JDBC API 的 Java 库。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: One of the best parts of JDBC is that most driver libraries are written in Java,
    so you can use these drivers from any platform that runs the JVM.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 最好的部分之一是大多数驱动程序库是用 Java 编写的，因此你可以在运行 JVM 的任何平台上使用这些驱动程序。
- en: The first thing you need to do with JDBC is connect to a data source, typically
    a database.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JDBC 的第一步是与数据源连接，通常是数据库。
- en: Connecting to Databases
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'The simplest way to connect to a database using JDBC is to use the `getConnection()`
    method on the `java.sql.DriverManager` class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JDBC 连接到数据库的最简单方法是使用 `java.sql.DriverManager` 类上的 `getConnection()` 方法：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method takes three parameters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法需要三个参数：
- en: The JDBC URL, which starts with `jdbc:h2` tells `DriverManager` to look for
    an H2 JDBC driver. `~/test` tells H2 to look for a database named `test` in the
    current user's home directory. (This is the user—you—running the Java program.)
    `test` is the default database name created by H2.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC URL 以 `jdbc:h2` 开头，告诉 `DriverManager` 查找 H2 JDBC 驱动程序。`~/test` 告诉 H2 在当前用户的家目录中查找名为
    `test` 的数据库。（这是运行 Java 程序的你。）`test` 是 H2 创建的默认数据库名。
- en: The username to connect under, in this case, `sa`, for the system administrator.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此情况下，连接的用户的用户名是 `sa`，代表系统管理员。
- en: The password, in this case, is empty.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，密码是空的。
- en: Note
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Other than H2, you will likely never have an empty password when connecting
    to a database. H2 sets up the `sa` account that you can use for testing by default.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了 H2，你连接数据库时很可能不会遇到空密码。H2 默认设置了 `sa` 账户，你可以用它进行测试。
- en: The `getConnection()` method returns a `java.sql.Connection` object, which you
    can use as a starting point for working with a database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`getConnection()` 方法返回一个 `java.sql.Connection` 对象，你可以将其用作与数据库交互的起点。'
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are other ways to connect to a database, especially when using connection
    pools, described later in this chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库的其他方法有很多，尤其是在使用连接池时，这些方法将在本章后面进行描述。
- en: Almost every JDBC operation can throw a `java.sql.SQLException`, so you will
    usually wrap JDBC calls in a try-catch block.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的 JDBC 操作都可能抛出 `java.sql.SQLException`，因此你通常会使用 try-catch 块来包装 JDBC 调用。
- en: 'When you are done with a JDBC connection, you should close the connection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成 JDBC 连接时，你应该关闭连接：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Querying Data with JDBC
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JDBC 查询数据
- en: 'To query from a database with JDBC, create `java.sql.Statement` and then execute
    a query:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 JDBC 从数据库中查询，创建 `java.sql.Statement` 并执行查询：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a statement using the `Connection` object. You can then execute a SQL
    query using the `executeQuery()` method, which returns a `java.sql.ResultSet`
    object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Connection` 对象创建一个语句。然后，你可以使用 `executeQuery()` 方法执行 SQL 查询，该方法返回一个 `java.sql.ResultSet`
    对象。
- en: The `ResultSet` API can be confusing at first. It is based on the idea of a
    cursor, a record of the program's position within the data. By calling `next()`
    on a `ResultSet`, you move the cursor to the next row.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` API 最初可能会让人困惑。它基于游标的概念，即程序在数据中的位置记录。通过在 `ResultSet` 上调用 `next()`，你可以将游标移动到下一行。'
- en: 'So, the normal flow for a query will look something like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，查询的正常流程将类似于以下内容：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`ResultSet` starts with a position—the cursor—prior to the first row, so you
    need to call `next()` to get the very first row of data. The `next()` method returns
    false when it has reached the end of the data.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` 从一个位置——游标——开始，在第一行之前，因此你需要调用 `next()` 来获取第一行数据。当 `next()` 方法返回
    false 时，表示已到达数据的末尾。'
- en: Part of the reason for iterating through a `ResultSet` like this is because
    some database tables hold so many records that you could not hold them all in
    memory at the same time. Hence, the general technique is to process one row at
    a time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这样迭代 `ResultSet` 的部分原因是因为某些数据库表包含如此多的记录，你无法同时将它们全部保存在内存中。因此，一般的技巧是逐行处理。
- en: 'With each row of data, call `get` methods on the `ResultSet`. For example,
    to get a string value, call `getString()`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行数据，调用 `ResultSet` 上的 `get` 方法。例如，要获取字符串值，调用 `getString()`：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we pass the name of the column to `getString()`. It returns
    the value of the `USERNAME` column for the current row.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将列名传递给 `getString()`。它返回当前行的 `USERNAME` 列的值。
- en: 'You can also pass the position of the column in the results. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以传递结果集中列的位置。例如：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The position number is the position of the column in the results, which is dependent
    on the query.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 位置号是结果集中列的位置，这取决于查询。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike almost everything else in Java, JDBC columns start counting at 1, not
    0.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 中的几乎所有其他内容不同，JDBC 列的计数从 1 开始，而不是 0。
- en: 'You have to know the type of data in the column to call the proper `get` method.
    For example, to get a `long` value, call `getLong()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须知道列中的数据类型，才能调用适当的 `get` 方法。例如，要获取 `long` 类型的值，调用 `getLong()`：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can call `getObject()` if you are unsure of the type of data in the column.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定列中的数据类型，可以调用 `getObject()`。
- en: When done with a `ResultSet`, call `close()`. Similarly, when you're done with
    a statement, call `close()`. Calling the `close()` method on these objects frees
    up resources.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成 `ResultSet` 的操作后，调用 `close()`。同样，当你完成语句的操作后，也调用 `close()`。在这些对象上调用 `close()`
    方法可以释放资源。
- en: 'Exercise 6: Querying Data with JDBC'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6：使用 JDBC 查询数据
- en: 'This exercise will create an IntelliJ project, bring in a dependency for the
    H2 database JDBC driver, and then query the database:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将创建一个 IntelliJ 项目，引入 H2 数据库 JDBC 驱动的依赖项，然后查询数据库：
- en: Select `New` and then `Project…` from the `File` menu in IntelliJ.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 的“文件”菜单中选择“新建”然后选择“项目...”。
- en: Select `Gradle` for the type of project. Click `Next`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“Gradle”作为项目类型。点击“下一步”。
- en: For the `Group Id`, enter `com.packtpub.db`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“组 ID”，输入 `com.packtpub.db`。
- en: For the `Artifact Id`, enter `customers`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“工件 ID”，输入 `customers`。
- en: For the `Version`, enter `1.0`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“版本”中输入 `1.0`。
- en: Accept the default on the next pane. Click `Next`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页接受默认设置。点击“下一步”。
- en: Leave the project name as `customers`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称保留为 `customers`。
- en: Click `Finish`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“完成”。
- en: Call up `build.gradle` in the IntelliJ text editor.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 文本编辑器中调用 `build.gradle`。
- en: 'Set `sourceCompatibility` to `12`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `sourceCompatibility` 设置为 `12`：
- en: '[PRE35]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace the plugins block with the following, just as we did in *Chapter 6*,
    *Libraries, Packages, and Modules*:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将插件块替换为以下内容，就像我们在 *第 6 章*，*库、包和模块* 中做的那样：
- en: '[PRE36]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following dependency to incorporate the H2 library in the project:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下依赖项以将 H2 库纳入项目：
- en: '[PRE37]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the same jar file that provides the JDBC driver also includes the
    entire database software.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，提供 JDBC 驱动的相同 jar 文件还包括整个数据库软件。
- en: 'Add the following to the end of the project''s `build.gradle` file to define
    the main class for the executable jar:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到项目的 `build.gradle` 文件末尾，以定义可执行 jar 的主类：
- en: '[PRE38]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the `src/main/java` folder, create a new Java package.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main/java` 文件夹中创建一个新的 Java 包。
- en: Enter `com.packtpub.db` as the package name.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包名输入为 `com.packtpub.db`。
- en: Right-click on this package in the `Project` pane and create a new Java class
    named `Query`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“项目”窗格中右键单击此包，创建一个名为 `Query` 的新 Java 类。
- en: 'Create a `main()` method for the `Query` class:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为“查询”类创建一个 `main()` 方法：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This program establishes a connection to an H2 database. Notice how all the
    JDBC calls are wrapped in a try-catch block.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序建立与 H2 数据库的连接。注意所有 JDBC 调用都被包装在 try-catch 块中。
- en: After establishing a `connection`, the program asks the `Connection` to create
    a `Statement`. Calling `executeQuery()` on the `Statement` runs the query, returning
    a `ResultSet`. With a `while` loop, the program iterates over each row in the
    `ResultSet`, extracting data, and printing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立 `connection` 之后，程序要求 `Connection` 创建一个 `Statement`。在 `Statement` 上调用 `executeQuery()`
    执行查询，返回一个 `ResultSet`。通过 `while` 循环，程序遍历 `ResultSet` 中的每一行，提取数据并打印。
- en: In the end, the program closes the resources used.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序关闭了使用的资源。
- en: This sets up an executable jar that will run the `Query` class. Remember to
    run the `shadowJar` Gradle task to build the executable jar with dependencies.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了一个可执行的 jar，它将运行 `Query` 类。请记住运行 `shadowJar` Gradle 任务来构建带有依赖项的可执行 jar。
- en: 'When you run this program, you should see output similar to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此程序时，你应该看到如下类似的输出：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that the query asked the database to order the results by username.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，查询要求数据库按用户名排序结果。
- en: 'If you are connected to the database from the H2 web console, you will see
    an error like the following when you run this program:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从 H2 网页控制台连接到数据库，当你运行此程序时，你会看到如下错误：
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You should also see the full stack trace for the error. This error indicates
    that you are already logged into the database as user `sa`. Click on the disconnect
    icon in the upper-left corner of the H2 web console to close the web console's
    connection to the database.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该看到完整的错误堆栈跟踪。这个错误表明你已经以用户 `sa` 登录到数据库。点击 H2 网页控制台左上角的断开连接图标来关闭网页控制台与数据库的连接。
- en: In the `Query` class in *Exercise 6*, *Querying Data with JDBC*, we used a string
    for the SQL query. That works fine when your program generates the entire SQL
    statement itself. However, if you accept user input and then build a string for
    the SQL, your program may be vulnerable to SQL injection attacks, where a malicious
    user inputs SQL syntax designed to cause havoc to your database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 6 章*，*使用 JDBC 查询数据* 的“查询”类中，我们使用字符串作为 SQL 查询。当你的程序生成整个 SQL 语句时，这没问题。然而，如果你接受用户输入然后构建一个字符串作为
    SQL，你的程序可能会受到 SQL 注入攻击的威胁，恶意用户输入的 SQL 语法旨在破坏你的数据库。
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a more detailed look at SQL injection vulnerabilities, refer to [https://packt.live/2OYGF3g](https://packt.live/2OYGF3g).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解 SQL 注入漏洞，请参阅 [https://packt.live/2OYGF3g](https://packt.live/2OYGF3g)。
- en: Because of this risk, you should sanitize any user input prior to placing it
    in a SQL statement.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个风险，你应该在将用户输入放入 SQL 语句之前对其进行清理。
- en: Sanitizing User Input
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理用户输入
- en: 'To sanitize user input:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要清理用户输入：
- en: You can properly sanitize the data yourself. You could disallow characters that
    could form SQL syntax, for example.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以自己正确地清理数据。例如，您可以禁止可能形成SQL语法的字符。
- en: You can use the `PreparedStatement` interface and set the values on the prepared
    statement. JDBC will then sanitize the input for you.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`PreparedStatement`接口并在预编译语句上设置值。JDBC将为您清理输入。
- en: Using Prepared Statements
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预编译语句
- en: A JDBC prepared statement takes in a SQL statement with placeholders for the
    data values. With most databases, JDBC sends the SQL to the database to be compiled.
    When you send a SQL statement to a database, the database needs to compile the
    SQL into an internal format that is native to the database, from which the database
    can execute the statement.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC预编译语句接受一个带有数据值占位符的SQL语句。在大多数数据库中，JDBC将SQL发送到数据库进行编译。当您向数据库发送SQL语句时，数据库需要将SQL编译成数据库本地的内部格式，然后数据库可以执行该语句。
- en: With a regular statement, you can provide a SQL statement to methods such as
    `executeQuery()` and `executeUpdate()`. You can reuse the `Statement` and provide
    a completely different SQL statement.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规语句时，您可以将SQL语句提供给`executeQuery()`和`executeUpdate()`等方法。您可以使用`Statement`重复使用并提供一个完全不同的SQL语句。
- en: With a `PreparedStatement`, on the other hand, you prepare the statement with
    a SQL string, and that is all you get. Luckily, though, you provide placeholders
    for the data values. This means that you can reuse a `PreparedStatement` to insert
    multiple records into a table, for example.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用`PreparedStatement`时，您使用SQL字符串准备语句，这就是您得到的所有内容。幸运的是，尽管如此，您提供了数据值的占位符。这意味着您可以使用`PreparedStatement`重复插入多个记录到表中，例如。
- en: 'From *Exercise 5*, *Modifying email Data*, we use an `UPDATE` statement:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从*练习5*，*修改电子邮件数据*，我们使用`UPDATE`语句：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With a `PreparedStatement`, you would use a question mark, `?` as a placeholder
    for the input values:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PreparedStatement`时，您会使用问号`?`作为输入值的占位符：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a prepared statement, you do not need to place single quotes around string
    placeholders. JDBC will take care of that for you.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在预编译语句中，您不需要在字符串占位符周围放置单引号。JDBC会为您处理这一点。
- en: 'These placeholders need to be filled in prior to using `PreparedStatement`.
    For example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`PreparedStatement`之前，需要填写这些占位符。例如：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Pass your SQL string, with placeholders, to the `prepareStatement()` method
    on a connection. Then, call `setString()`, `setLong()`, and so on, to fill in
    the placeholder values. With each set method call, you pass the index of the placeholder
    to fill, starting with `1` for the first placeholder. Then, pass the value to
    fill in. JDBC will handle the prevention of SQL injection attacks.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将带有占位符的SQL字符串传递给连接上的`prepareStatement()`方法。然后，调用`setString()`、`setLong()`等，以填写占位符值。在每个设置方法调用中，您传递要填充的占位符的索引，从第一个占位符的`1`开始。然后，传递要填充的值。JDBC将处理防止SQL注入攻击。
- en: As for a regular `Statement`, you can call `executeQuery()` to perform a SQL
    query, or `executeUpdate()` to modify the database. The `executeUpdate()` method
    handles `INSERT`, `UPDATE`, and `DELETE SQL` statements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规`Statement`，您可以通过调用`executeQuery()`执行SQL查询，或通过调用`executeUpdate()`修改数据库。`executeUpdate()`方法处理`INSERT`、`UPDATE`和`DELETE
    SQL`语句。
- en: In this example, `executeUpdate()` returns the number of rows in the table that
    was modified.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`executeUpdate()`返回被修改的表中的行数。
- en: One of the primary benefits of using prepared statements is that JDBC will sanitize
    the input values so that you don't have to. The other primary benefit is improved
    performance. If you execute the same SQL statement again and again, or a nearly
    similar statement with just different values, then using a prepared statement
    will speed things up, mostly due to pre-compiling the statement.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预编译语句的主要好处之一是JDBC将清理输入值，因此您不必这样做。另一个主要好处是性能提升。如果您反复执行相同的SQL语句，或者几乎相同的语句，只是值不同，那么使用预编译语句将加快速度，这主要是由于预编译语句。
- en: Transactions and Rollback
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务和回滚
- en: In relational databases, transaction groups a set of SQL statements together.
    Either all the statements succeed, or the transaction will get rolled back, undoing
    the statements. In addition, databases treat all the statements within a transaction
    as happening at the same time, which helps to ensure that the data has integrity.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，事务将一组SQL语句组合在一起。要么所有语句都成功，要么事务将回滚，撤销这些语句。此外，数据库将事务中的所有语句视为同时发生，这有助于确保数据的一致性。
- en: In JDBC, a transaction continues until you call `commit()` on the connection.
    If there is a failure, you should call `rollback()` on the connection to restore
    the data to the state it held prior to the transaction.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在JDBC中，事务会一直持续到你在连接上调用`commit()`。如果发生故障，你应该在连接上调用`rollback()`以将数据恢复到事务开始之前的状态。
- en: 'By default, a JDBC connection starts in auto-commit mode. This means that each
    JDBC connection gets committed one at a time. If you want to group a few statements
    together in a transaction, you first need to turn off auto-commit mode:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JDBC连接以自动提交模式开始。这意味着每个JDBC连接都会逐个提交。如果你想将几个语句组合在一个事务中，你首先需要关闭自动提交模式：
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After turning off auto-commit mode, you should turn it back on when done accessing
    the database.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对数据库的访问后，你应该将自动提交模式关闭后再打开。
- en: 'When you want to end a transaction and commit the results to the database,
    call `commit()`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想结束事务并将结果提交到数据库时，调用`commit()`：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If an `SQLException` gets thrown, you''ll want to roll back the transaction:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出`SQLException`，你将想要回滚事务：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code shows one of the most tedious parts of working with JDBC. In your
    exception handler for a `SQLException`, the calls made—`rollback()`, for instance—can
    also throw another `SQLException`, which you need to catch. You'll find that JDBC
    code is full of `try`-`catch`-`finally` blocks with nested `try`-`catch` blocks.
    *Exercise 7*, *Using Prepared Statements with Transactions* shows this technique
    in action.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了使用JDBC时最繁琐的部分之一。在你的`SQLException`异常处理程序中，所做的调用——例如`rollback()`——也可能抛出另一个`SQLException`，你需要捕获它。你会发现JDBC代码充满了嵌套的`try`-`catch`-`finally`块。*练习7*，*使用带有事务的预编译语句*展示了这一技术的实际应用。
- en: 'Exercise 7: Using Prepared Statements with Transactions'
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7：使用带有事务的预编译语句
- en: In this exercise, we'll create another Java class that uses a JDBC `PreparedStatement`
    to update data in the email table and wrap that update in a JDBC transaction.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建另一个Java类，该类使用JDBC `PreparedStatement`更新电子邮件表中的数据，并将该更新包装在JDBC事务中。
- en: In IntelliJ, create a new class named `Prepared` and create a `main()` method.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IntelliJ中创建一个名为`Prepared`的新类并创建一个`main()`方法。
- en: 'Import the required libraries:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE48]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Enter the following code in the `Prepared` class.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prepared`类中输入以下代码。
- en: '[PRE49]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Prepared` class starts by defining a `SQL UPDATE` statement using placeholders.
    This SQL statement will later get placed in a `PreparedStatement`.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Prepared`类首先定义一个使用占位符的`SQL UPDATE`语句。这个SQL语句稍后将放入`PreparedStatement`中。'
- en: In the first try-catch block, the program gets a `Connection` to the database
    and then calls `setAutoCommit()` with a parameter of `false` to turn off auto-commit
    mode. JDBC now expects the program to manage transactions.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个try-catch块中，程序获取数据库的`Connection`，然后使用参数`false`调用`setAutoCommit()`以关闭自动提交模式。JDBC现在期望程序管理事务。
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When you run the `main()` method, you should see output like the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`main()`方法时，你应该看到以下输出：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Just one row should be modified.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 只应修改一行。
- en: The program passes the SQL string to the connection's `prepareStatement()` method.
    This creates a `PreparedStatement` initialized with the given SQL. Next, the program
    fills in the placeholder values in the `PreparedStatement`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将SQL字符串传递给连接的`prepareStatement()`方法。这创建了一个初始化给定SQL的`PreparedStatement`。接下来，程序在`PreparedStatement`中填充占位符值。
- en: When it's done, the program calls `executeUpdate()` on the statement, commits
    the transaction and then tells us the number of rows that were changed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，程序在语句上调用`executeUpdate()`，提交事务，然后告诉我们更改了多少行。
- en: If any of the JDBC calls throws an `SQLException`, the catch block prints the
    stack trace and then calls `rollback()` on the connection. Calling `rollback()`
    can also throw `SQLException`, so the program catches that as well, printing the
    stack trace.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何JDBC调用抛出`SQLException`，catch块将打印堆栈跟踪，然后在连接上调用`rollback()`。调用`rollback()`也可能抛出`SQLException`，因此程序也会捕获它，打印堆栈跟踪。
- en: The `finally` block from the original try-catch-finally block restores auto-commit
    transaction mode, and then calls `close()` on the `PreparedStatement` and the
    connection, each of which might also result in an `SQLException`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的try-catch-finally块中的`finally`块将自动提交事务模式恢复，然后对`PreparedStatement`和连接调用`close()`，这可能会导致每个都抛出`SQLException`。
- en: Simplifying JDBC Programming
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化JDBC编程
- en: As you can see from the examples, programming with JDBC is tedious. Because
    of that, a lot of projects have developed wrappers over the JDBC API in order
    to simplify making JDBC calls.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 JDBC 编程是繁琐的。正因为如此，许多项目都在 JDBC API 上开发了包装器，以简化 JDBC 调用。
- en: Java itself contains a number of utility classes, such as `JdbcRowSet`, which
    wrap `ResultSet` objects and provide a somewhat simpler API.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Java 本身包含了许多实用类，例如 `JdbcRowSet`，它包装 `ResultSet` 对象并提供了一个相对简单的 API。
- en: Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Spring framework provides a number of utilities to simplify JDBC programming.
    Refer to [https://packt.live/35PalWP](https://packt.live/35PalWP) for more information.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架提供了一系列实用工具来简化 JDBC 编程。更多信息请参考 [https://packt.live/35PalWP](https://packt.live/35PalWP)。
- en: By far the most popular way to access databases without the inconvenience of
    the JDBC API is to use object-relational mapping software.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最受欢迎的无需 JDBC API 不便即可访问数据库的方法是使用对象关系映射软件。
- en: Using Object-Relational Mapping Software
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象关系映射软件
- en: As the name suggests, **object-relational mapping**, or **ORM**, software maps
    between the world of objects and the world of relational tables. With an ORM,
    you typically write a Java class that represents one row of a table.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**对象关系映射**（**ORM**）软件在对象世界和关系表世界之间进行映射。使用 ORM，你通常编写一个 Java 类来表示表中的一行。
- en: 'For example, the following class could represent a row in the customer table:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下类可以代表客户表中的一行：
- en: '[PRE52]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `Customer` class is what is often called a **Plain Old Java Object** (**POJO**).
    ORM software then allows you to use query tables and get back a list of POJOs,
    or fill in data in a POJO and then persist that object to the database. In the
    majority of cases, ORM software uses reflection to discover the fields in the
    class and map those to columns in the table.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer` 类通常被称为 **纯 Java 对象**（**POJO**）。ORM 软件允许你使用查询表并获取 POJO 列表，或者在一个 POJO
    中填写数据，然后将该对象持久化到数据库。在大多数情况下，ORM 软件使用反射来发现类中的字段并将它们映射到表中的列。'
- en: Note
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*Chapter 19* covers reflection.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 19 章* 讲解反射。'
- en: The **Java Persistence API**, or **JPA**, provides a standardized API to define
    the mapping between objects and database tables using annotations to describe
    the mapping. JPA also defines an API for persisting POJOs to database tables.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 持久化 API**（**JPA**）提供了一个标准化的 API，用于使用注解来描述映射，从而定义对象和数据库表之间的映射。JPA 还定义了一个
    API，用于将 POJO 持久化到数据库表。'
- en: Underneath the standard Java Persistence API, you need to use a JPA provider,
    a library that implements the JPA. The most commonly used JPA provider is called
    **Hibernate**.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的 Java 持久化 API 之下，你需要使用一个 JPA 提供者，这是一个实现 JPA 的库。最常用的 JPA 提供者是 **Hibernate**。
- en: Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on JPA, refer to [https://packt.live/2OZjHsP](https://packt.live/2OZjHsP).
    JPA is part of the **Java Enterprise Edition** (**JavaEE**).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JPA 的更多信息，请参考 [https://packt.live/2OZjHsP](https://packt.live/2OZjHsP)。JPA
    是 **Java 企业版**（**JavaEE**）的一部分。
- en: Database Connection Pooling
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库连接池
- en: The `DriverManager.getConnection()` method can take a good bit of time to establish
    a connection to a database. To help with this, you can use a database connection
    pool.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`DriverManager.getConnection()` 方法建立数据库连接可能需要相当长的时间。为了帮助解决这个问题，你可以使用数据库连接池。'
- en: Connection pools set up multiple and managed connections to a database. Your
    application can then request a free connection from the pool. Your code uses the
    connection and then returns it to the pool.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池会建立多个并管理到数据库的连接。然后你的应用程序可以从池中请求一个空闲连接。你的代码使用连接后，将其返回到池中。
- en: 'Some of the main connection pool software libraries are:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一些主要的连接池软件库包括：
- en: HikariCP, from [https://packt.live/2Bw7gg5](https://packt.live/2Bw7gg5)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HikariCP，来自 [https://packt.live/2Bw7gg5](https://packt.live/2Bw7gg5)
- en: Apache Commons DBCP, from [https://packt.live/31p4xQg](https://packt.live/31p4xQg)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Commons DBCP，来自 [https://packt.live/31p4xQg](https://packt.live/31p4xQg)
- en: C3p0, from [https://packt.live/2pw1vN0](https://packt.live/2pw1vN0)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C3p0，来自 [https://packt.live/2pw1vN0](https://packt.live/2pw1vN0)
- en: The Tomcat connection pool, from [https://packt.live/31pGgcJ](https://packt.live/31pGgcJ)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat 连接池，来自 [https://packt.live/31pGgcJ](https://packt.live/31pGgcJ)
- en: Non-Relational, or NoSQL, Databases
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系型，或 NoSQL 数据库
- en: Relational databases work well when you have data that works well with the columns
    and rows in SQL database tables. In the real world, not all data fits neatly into
    this model. This has led to the creation of NoSQL databases, database management
    software that does not support relational tables.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库在数据与SQL数据库表中的列和行很好地工作时表现良好。在现实世界中，并非所有数据都能整齐地适应这个模型。这导致了NoSQL数据库的创建，这是一种不支持关系表的数据库管理软件。
- en: Note
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Oddly enough, some NoSQL databases support a SQL-like language for accessing
    data.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，一些NoSQL数据库支持类似于SQL的语言来访问数据。
- en: NoSQL databases all differ, and some of the categories to describe these databases
    overlap. Terrastore, [https://packt.live/2P23i7e](https://packt.live/2P23i7e),
    and MongoDB, [https://packt.live/31qJVY0](https://packt.live/31qJVY0), are considered
    document storage databases. In these systems, you store a full document, typically
    a structured document.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库各不相同，描述这些数据库的一些类别有所重叠。Terrastore，[https://packt.live/2P23i7e](https://packt.live/2P23i7e)，和MongoDB，[https://packt.live/31qJVY0](https://packt.live/31qJVY0)，被认为是文档存储数据库。在这些系统中，你存储一个完整的文档，通常是结构化文档。
- en: Cassandra, [https://packt.live/2MtDtej](https://packt.live/2MtDtej), and HBase,
    [https://packt.live/2VWebsp](https://packt.live/2VWebsp), are sometimes referred
    to as column-store or column family databases, which store data in columns as
    opposed to storing data in rows, as is done with most SQL databases. If you organize
    the columns properly, these databases can very quickly retrieve data. You can
    also store a huge number of columns.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra，[https://packt.live/2MtDtej](https://packt.live/2MtDtej)，和HBase，[https://packt.live/2VWebsp](https://packt.live/2VWebsp)，有时被称为列存储或列族数据库，它们将数据存储在列中，而不是像大多数SQL数据库那样按行存储。如果你正确地组织了列，这些数据库可以非常快速地检索数据。你还可以存储大量的列。
- en: Neo4j, [https://packt.live/2o51EXm](https://packt.live/2o51EXm), is a graph
    database. In a graph database, you retrieve data by following relationships between
    elements. These relationships form a graph.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j，[https://packt.live/2o51EXm](https://packt.live/2o51EXm)，是一个图数据库。在图数据库中，你通过元素之间的关系来检索数据。这些关系形成了一个图。
- en: 'Activity 1: Track Your Progress'
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一：跟踪你的进度
- en: 'In this activity, we will set up database tables in the H2 database to track
    your progress through this course. These steps will help us complete this activity:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将设置H2数据库中的数据库表来跟踪你在本课程中的进度。以下步骤将帮助我们完成这个活动：
- en: Create a table called `student`, where each record holds information on a student,
    such as you. Define the ID, first name, and last name columns.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`student`的表，其中每条记录都包含有关学生（例如你）的信息。定义ID、姓名和姓氏列。
- en: Create a table called `chapter`, where each record holds information on a chapter.
    Define columns for an ID (use the chapter number) and chapter title. For simplicity,
    you can just enter the chapters up to and including this one.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`chapter`的表，其中每条记录都包含有关章节的信息。定义ID（使用章节编号）和章节标题列。为了简单起见，你可以只输入到包括这一章在内的所有章节。
- en: Create a table to relate students to chapters, called `student_progress`. This
    table should have columns for the ID of a student, the ID of a chapter, and a
    date for when the chapter was completed. Use the `SQL DATE` type and pass the
    data as `yyyy-MM-dd`. This table should have a composite primary key.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`student_progress`的表来关联学生和章节，这个表应该包含学生的ID、章节的ID以及完成章节的日期。使用`SQL DATE`类型，并将数据传递为`yyyy-MM-dd`。这个表应该有一个复合主键。
- en: You can use the H2 web console to create the tables and insert records.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用H2网络控制台创建表并插入记录。
- en: Create two Java programs that use JDBC.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个使用JDBC的Java程序。
- en: 'Create the first to query all the chapters a given student has completed, and
    when. Take as inputs the student''s first and last name. This should generate
    output like the following:'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建第一个程序来查询给定学生完成的所有章节及其完成时间。输入学生的姓名和姓氏。这将生成如下输出：
- en: '[PRE53]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Create the second program to insert chapter completion. Take as inputs the student's
    first and last name, along with a chapter number. The program should mark that
    chapter as having been completed today.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建第二个程序来插入章节完成情况。输入学生的姓名、姓氏以及章节编号。程序应标记该章节为今天已完成。
- en: Because both programs take in user input, be sure to use a `PreparedStatement`
    in each to handle potentially malicious input data. You can create these programs
    as part of the customer's project created previously in this chapter.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这两个程序都接受用户输入，请确保在每个程序中使用`PreparedStatement`来处理可能的有害输入数据。你可以将这些程序作为本章之前创建的客户项目的一部分来创建。
- en: Note
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for the activity can be found on page 548.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 活动的解决方案可以在第548页找到。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced relational database management systems (RDBMSs) and
    the SQL language, which is used for working with relational databases. We used
    an all-Java database called H2\. SQL is a language that's used to retrieve and
    modify data stored in a relational database. JDBC is a Java API that communicates
    with a relational database. You can use SQL commands to retrieve and modify data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了关系数据库管理系统（RDBMS）和SQL语言，这是用于处理关系数据库的语言。我们使用了一个全Java数据库，称为H2。SQL是一种用于检索和修改存储在关系数据库中的数据的语言。JDBC是一个与关系数据库通信的Java
    API。你可以使用SQL命令来检索和修改数据。
- en: There is a lot more to databases than can be presented in a single chapter,
    but after working through the exercises, you should be able to start working with
    databases using SQL and JDBC. A book or training course on SQL can help you delve
    into advanced database topics.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的内容远不止一个章节所能展示的，但在完成练习后，你应该能够开始使用SQL和JDBC与数据库进行工作。一本关于SQL的书或培训课程可以帮助你深入研究高级数据库主题。
- en: Note
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Packt video SQL Beginner to Guru: MySQL Edition - Master SQL with MySQL:
    [https://packt.live/33KIi8S](https://packt.live/33KIi8S) will help you advance
    your SQL skills.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Packt视频《SQL从入门到精通：MySQL版》- 使用MySQL掌握SQL：[https://packt.live/33KIi8S](https://packt.live/33KIi8S)
    将帮助你提升SQL技能。
- en: In the next chapter, you'll learn about networking and files using Java.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习使用Java进行网络和文件操作。
