- en: Chapter 8. Scaling with Spring Batch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Spring Batch进行扩展
- en: In the previous chapter, we learned about monitoring, accessing the execution
    information and administering the configurations, using listeners, reporting the
    batch job problems, and understanding the Spring Batch Administration features.
    The Spring Batch job execution deals with huge data that changes time-to-time.
    This detailed processing consumes huge infrastructure. It is obvious to expect
    these jobs to perform efficiently and meet the scaling needs with the growing
    size of the organization's data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用监听器、访问执行信息和管理配置来监控、获取执行信息和理解Spring Batch管理功能。Spring Batch作业执行处理的是随时间变化的大量数据。这种详细处理消耗了巨大的基础设施。显然，可以预期这些作业在组织数据规模增长时能够高效执行并满足扩展需求。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The batch scaling model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量扩展模型
- en: The thread model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程模型
- en: Parallel processing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理
- en: Remote chunking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程分块
- en: Partitioning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区
- en: The batch scaling model
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量扩展模型
- en: So far we have seen how to handle different types of batch jobs, configurations,
    and executions. As the organization size is growing day-by-day, the data to be
    processed per batch job also gets increased accordingly. It is important to design
    and configure our batch jobs to meet these performance and scaling expectations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何处理不同类型的批量作业、配置和执行。随着组织规模的日益增长，每个批量作业需要处理的数据量也相应增加。设计并配置我们的批量作业以满足这些性能和扩展预期是很重要的。
- en: The batch jobs we write with certain business logic, keeping different resources
    interacting in between, cannot be changed every time we see change in data load
    or performance issues. Spring Batch offers rich configuration infrastructure to
    be able to scale jobs without altering them, by just tuning the configuration
    information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的具有特定业务逻辑的批量作业，保持不同资源之间的交互，不能每次看到数据负载或性能问题时都进行更改。Spring Batch提供了丰富的配置基础设施，可以通过调整配置信息来扩展作业，而无需更改它们。
- en: 'Scaling the infrastructure can be done in either of the following two ways:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施的扩展可以通过以下两种方式之一进行：
- en: '**By increasing the capacity of the system hardware**: In this way of scaling,
    we can replace the existing slow infrastructure with more powerful infrastructure.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过增加系统硬件的容量**：在这种扩展方式中，我们可以用更强大的基础设施替换现有的缓慢基础设施。'
- en: '**Adding more servers**: In this way of scaling, we can add more processing
    systems of the same capacity in parallel to the existing infrastructure. These
    additional nodes share the work and increase the scaling of the total system.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加更多服务器**：在这种扩展方式中，我们可以在现有基础设施中并行添加更多相同容量的处理系统。这些额外的节点分担工作并增加了整个系统的扩展性。'
- en: 'Spring Batch offers the following ways to scale the batch applications:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch提供了以下方式来扩展批量应用程序：
- en: '**Thread model**: This is a multithreaded step with a single process'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程模型**：这是一个单进程的多线程步骤'
- en: '**Parallel processing**: This is a parallel step execution with a single process'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行处理**：这是一个单进程的并行步骤执行'
- en: '**Remote chunking**: This is the remote chunking of a step with multi process'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程分块**：这是多进程步骤的远程分块'
- en: '**Partitioning**: This is the partitioning of a step; it can be a single or
    multi process'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区**：这是步骤的分区；它可以是一个或多个进程'
- en: The thread model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程模型
- en: By default, step execution is a single-thread model. Spring Batch lets us configure
    the step to execute in multiple chunks to let the single step execute in a multithread
    model with the help of `org.springframework.core.task.TaskExecutor`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，步骤执行是单线程模型。Spring Batch允许我们配置步骤以多块执行，从而使单个步骤能够在`org.springframework.core.task.TaskExecutor`的帮助下以多线程模型执行。
- en: 'The following diagram depicts the multithread model of a step execution:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了步骤执行的线程模型：
- en: '![The thread model](img/3372OS_08_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![线程模型](img/3372OS_08_01.jpg)'
- en: 'The following is the sample configuration for the multithread step with `TaskExecutor`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例配置是带有`TaskExecutor`的多线程步骤：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the preceding configuration, the `employeePayProcessing` step considers
    the configured reader, processor, and writers for the tasklets and task execution,
    with the help of `org.springframework.core.task.SimpleAsyncTaskExecutor` having
    a thread pool of 20 threads, each executing in parallel with chunks of data being
    processed in each thread.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的配置，`employeePayProcessing` 步骤考虑了为任务和任务执行配置的读取器、处理器和写入器，通过 `org.springframework.core.task.SimpleAsyncTaskExecutor`
    拥有 20 个线程的线程池，每个线程并行处理每个线程中的数据块。
- en: Just like any other multithread model, the Spring Batch multithread models also
    take into account the resources used by the multiple threads, and whether they
    are thread safe. `ItemReader` is one such process that is not thread safe.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他多线程模型一样，Spring Batch 的多线程模型也考虑了多个线程使用的资源，以及它们是否是线程安全的。"ItemReader" 是这样一个过程，它不是线程安全的。
- en: To configure a thread-safe operation, the recommendation is to synchronize the
    `ItemReader` process by synchronizing the read method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置线程安全的操作，建议通过同步读取方法来同步 `ItemReader` 过程。
- en: Parallel processing
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行处理
- en: While multithreading allows a single step to be processed in multiple threads
    of chunks, Spring Batch allows us to process multiple steps and flows simultaneously
    with the help of parallel processing. This feature enables the independent steps
    to execute in parallel and ensures a faster processing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然多线程允许单个步骤在多个线程中处理数据块，但 Spring Batch 允许我们通过并行处理同时处理多个步骤和流程。这个特性使得独立的步骤可以并行执行，并确保更快的处理速度。
- en: 'The following figure shows the multiple steps under execution in parallel:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了正在并行执行的多个步骤：
- en: '![Parallel processing](img/3372OS_08_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![并行处理](img/3372OS_08_02.jpg)'
- en: With parallel processing, the independent steps need not wait for the other
    steps to complete before execution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并行处理，独立的步骤不需要等待其他步骤完成后再执行。
- en: 'The following is the sample configuration for the parallel steps in processing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例配置了处理中的并行步骤：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding configuration, the `readEmployeeData` and `processEmployeeData`
    steps get executed in parallel with `organizationDataSetup`. By default, the `taskExecutor`
    is `SyncTaskExecutor`; with the preceding configuration we changed it to `SimpleAsyncTaskExecutor`
    to support parallel step processing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，`readEmployeeData` 和 `processEmployeeData` 步骤与 `organizationDataSetup`
    并行执行。默认情况下，`taskExecutor` 是 `SyncTaskExecutor`；通过前面的配置，我们将其更改为 `SimpleAsyncTaskExecutor`
    以支持并行步骤处理。
- en: Remote chunking
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程分块
- en: Remote chunking is the process in which the original step reads the data calls
    from remote process to process and writes or receives the processed data back
    to write on to the system. As the remote chunking deals with the data transmission
    to another system that is remotely located, we should also consider the cost in
    building this infrastructure versus the advantage we are getting in remote processing.
    The actual step (master) executes the read process, and the remote slaves (listeners)
    could be the JMS listeners that execute the process and write steps, or return
    the processed information to the master.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 远程分块是原始步骤读取数据调用远程过程进行处理，并将处理后的数据写回或接收回系统上的过程。由于远程分块涉及将数据传输到远程系统，我们还应该考虑建立此基础设施的成本与我们在远程处理中获得的优势之间的成本。实际步骤（主步骤）执行读取过程，远程从属步骤（监听器）可以是执行处理和写入步骤的
    JMS 监听器，或者将处理后的信息返回给主步骤。
- en: 'The following figure depicts the steps in remote chunking:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了远程分块步骤：
- en: '![Remote chunking](img/3372OS_08_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![远程分块](img/3372OS_08_03.jpg)'
- en: 'The `ChunkProvider` interface returns chunks from `ItemReader`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChunkProvider` 接口从 `ItemReader` 返回数据块：'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ChunkProcessor` interface processes the chunks:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChunkProcessor` 接口处理数据块：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To be able to effectively perform the remote interactions, the remote chunking
    process can have the Spring Integration project included to deal with the integration
    of resources.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够有效地执行远程交互，远程分块过程可以包含 Spring Integration 项目以处理资源的集成。
- en: Partitioning
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区
- en: While the remote chunking reads the data at master node and handles the processing
    to another remote system (slave), partitioning executes the entire process (reading,
    processing, and writing) in parallel, by having the multiple systems having the
    entire processing ability. Here, the master step takes care of understanding the
    job and handing over the task to multiple slaves, and slaves have to take care
    of the rest of the tasks (reading, processing, and writing). Essentially, the
    slaves constitute the steps that take care of the read, process, and write in
    their own world.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然远程分块在主节点读取数据并处理到另一个远程系统（从属节点），但分区通过具有完整处理能力的多个系统并行执行整个流程（读取、处理和写入）。在此，主步骤负责理解作业并将任务交给多个从属节点，而从属节点必须负责剩余的任务（读取、处理和写入）。本质上，从属节点构成了在其自己的世界中负责读取、处理和写入的步骤。
- en: The advantages of partitioning over remote chunking include the data transmission
    not being there, as the slave system takes care of the read step as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与远程分块相比，分区的好处包括不需要数据传输，因为从属系统也负责读取步骤。
- en: '![Partitioning](img/3372OS_08_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![分区](img/3372OS_08_04.jpg)'
- en: Even though the communication sent by the master to the slaves in this pattern
    fails to deliver, batch metadata in the `JobRepository` ensures that each slave
    gets executed only once per job execution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在此模式中，主节点发送给从属节点的通信未能成功传递，但 `JobRepository` 中的批处理元数据确保每个从属节点在每个作业执行中只执行一次。
- en: 'The Spring Batch partitioning **Service** **Provider Interface** (**SPI**)
    has the following infrastructure for effective partitioning:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch 分区 **服务** **提供者接口**（**SPI**）具有以下基础设施以实现有效的分区：
- en: '`PartitionHandler`: This sends `StepExecution` a request to the remote steps.
    It doesn''t have to know how to split or integrate the data, and `TaskExecutorPartitionHandler`
    is the default implementation of `PartitionHandler`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PartitionHandler`: 这向远程步骤发送 `StepExecution` 请求。它不必知道如何拆分或整合数据，而 `TaskExecutorPartitionHandler`
    是 `PartitionHandler` 的默认实现。'
- en: '`Partitioner`: This generates the step executions for the partitioned steps
    (only for new step executions). `SimplePartitioner` is the default implementation
    of `Partitioner`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Partitioner`: 这为分区步骤生成步骤执行（仅适用于新的步骤执行）。`SimplePartitioner` 是 `Partitioner`
    的默认实现。'
- en: '`StepExecutionSplitter`: This generates the input execution contexts for the
    partitioned step execution, and `SimpleStepExecutionSplitter` is the default implementation.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StepExecutionSplitter`: 这为分区步骤执行生成输入执行上下文，而 `SimpleStepExecutionSplitter`
    是默认实现。'
- en: 'The following is the sample partitioned step execution configuration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例分区步骤执行配置：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding configuration starts its execution with `initialStep` and hands
    over the execution to the partitioned step. The grid size indicates the number
    of different steps to be created.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置以 `initialStep` 开始执行，并将执行权交给分区步骤。网格大小表示要创建的不同步骤的数量。
- en: While the multithread model fits for the basic tuning of chunk processing, parallel
    processing lets us configure independent steps to execute in parallel. Remote
    chunking needs comparatively larger infrastructure and configuration but fits
    for distributed nodes processing. Partitioning helps quickly replicate the batch
    infrastructure and configure the entire process to execute in parallel nodes,
    with a single point of the repository acting as master.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然多线程模型适合于块处理的基本调整，但并行处理使我们能够配置独立步骤以并行执行。远程分块需要相对较大的基础设施和配置，但适合于分布式节点处理。分区有助于快速复制批处理基础设施，并将整个流程配置为在并行节点上执行，其中存储库的单一点作为主节点。
- en: Based on the system requirement and feasibility of the available infrastructure,
    one can choose either of the earlier mentioned scaling strategies for batch job
    execution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据系统需求和现有基础设施的可行性，可以选择之前提到的任何一种扩展策略来执行批处理作业。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Through this chapter we learned the importance of performance and scaling of
    the batch. We also learned Spring Batch offerings to scale the batch applications.
    In addition, we learned about the details and configurations of a thread model,
    parallel processing, remote chunking, and partitioning techniques. We finished
    this chapter with an understanding of choosing the right strategy to scale the
    batch application with the available infrastructure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们学习了批处理性能和扩展的重要性。我们还了解了Spring Batch提供的扩展批处理应用的方法。此外，我们还学习了线程模型、并行处理、远程分块和分区技术的详细信息和配置。我们通过理解如何利用现有基础设施选择合适的策略来扩展批处理应用，结束了本章的学习。
- en: In the next chapter, we will learn in detail about performing different types
    of testing on Spring Batch applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细了解在Spring Batch应用上执行不同类型的测试。
