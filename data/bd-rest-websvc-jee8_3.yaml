- en: Content Marshalling with JSON-B and JSON-P
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON-B和JSON-P进行内容序列化
- en: In this chapter, we will focus on the data structures and payloads of web services.
    You will learn how to properly use content types and content negotiation for your
    web services, how to use the new JSON-B APIs for easy data binding, how JSON-P
    API can be used for very flexible JSON processing, and how it can be used to implement
    hypermedia-driven REST APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注Web服务的数据结构和有效载荷。您将学习如何正确使用内容类型和内容协商来为您的Web服务，如何使用新的JSON-B API进行简单的数据绑定，如何使用JSON-P
    API进行非常灵活的JSON处理，以及如何使用它来实现由超媒体驱动的REST API。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to content types and content negotiation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容类型和内容协商简介
- en: Easy data binding using JSON-B
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON-B进行简单数据绑定
- en: Flexible JSON processing with JSON-P
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON-P进行灵活的JSON处理
- en: Implementing hypermedia-driven REST APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现由超媒体驱动的REST API
- en: Introduction to content types and content negotiation
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容类型和内容协商简介
- en: In this section, we're going to take a look at using the `@Produces` and `@Consumes`
    annotations to specify the content types. We'll also learn about API versioning
    using custom content types, smart content negotiation using a quality from server
    factor, and how you can serve and upload binary content.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用`@Produces`和`@Consumes`注解来指定内容类型。我们还将了解使用自定义内容类型进行API版本控制，使用服务器质量因子进行智能内容协商，以及如何提供和上传二进制内容。
- en: 'Let''s switch to code and open our IDE. Let''s take a look at the small REST
    service that we have prepared. As you already know, you can specify the `@Produces`
    or `@Consumes` annotations to specify what your REST service will consume as a
    content type and what content type your REST service will produce. What we do
    here is we specify `application/json`. This is what we usually do. We implement
    this method and return a simple `Map` with the status code `ok`. Using JAX-RS,
    we''ll make sure that this `Map` is serialized to proper JSON:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到代码并打开我们的IDE。让我们看看我们准备的小型REST服务。如您所知，您可以使用`@Produces`或`@Consumes`注解来指定您的REST服务将作为内容类型消费什么，以及您的REST服务将产生什么内容类型。我们在这里做的是指定`application/json`。这是我们通常做的事情。我们实现这个方法并返回一个包含状态码`ok`的简单`Map`。使用JAX-RS，我们将确保这个`Map`被序列化为正确的JSON：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What if we want to implement a second version of this? We can do that by implementing
    the method called `v2` and returning something different:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想实现这个的第二版，我们可以通过实现名为`v2`的方法并返回不同的内容来实现：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, this here will not work correctly because we have two methods producing
    the same content type. What we can do is specify a custom `MediaType`. We will
    specify `MediaType v1` and `MediaType v2` of type `"application"`, and we will
    use the custom subtype. We have one subtype for version one and the JSON format
    (`"vnd.version.v1+json"`), and another one for version two and the JSON format
    (`"vnd.version.v2+json"`):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里将无法正确工作，因为我们有两种方法产生相同的内容类型。我们可以做的是指定一个自定义的`MediaType`。我们将指定`MediaType v1`和`MediaType
    v2`的类型为`"application"`，并且我们将使用自定义子类型。我们有一个子类型用于版本一和JSON格式（`"vnd.version.v1+json"`），另一个子类型用于版本二和JSON格式（`"vnd.version.v2+json"`）：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use those custom content types with `v1` and `v2`. Since this is done,
    we have an API version for `v1` and `v2` using content types. This is the way
    it should be if we use an API version. `v1` supports application JSON and also
    supports the content type `v1` in the JSON format:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些自定义内容类型`v1`和`v2`。既然这样，我们就有了使用内容类型的`v1`和`v2`的API版本。如果我们使用API版本，这就是它应该的样子。`v1`支持应用JSON，也支持JSON格式的`v1`内容类型：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'How does the client specify or know which content type it accepts? Well, basically,
    they can specify the accept header for this specific content type. If they don''t,
    we specify a factor which is called **quality from server**, that is, `qs`, `qs=0.75`,
    and `qs=1`. If the client does not specify the content type, `"application/vnd.version.v1+json"`will
    always win because it has the higher factor:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让客户端指定或知道它接受哪种内容类型？基本上，他们可以为此特定内容类型指定接受头。如果他们没有指定，我们指定一个称为**服务器质量**的因子，即`qs`，`qs=0.75`和`qs=1`。如果客户端没有指定内容类型，`"application/vnd.version.v1+json"`将始终获胜，因为它具有更高的因子：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s look at using binary content. We will prepare two methods: serving a
    JPEG image and a GIF image. All we have to do is just open a file and send the
    file back:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用二进制内容。我们将准备两种方法：提供JPEG图像和GIF图像。我们只需打开一个文件并将文件发送回去：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What we can also do is implement and upload a mechanism by using the HTTP `POST`
    method. We will consume `MULTIPART_FORM_DATA`. While you are referencing the form
    with a parameter called `"file"`, which is an input stream, to get the filename,
    you can also reference `@FormDataParam` and use `FormDataContentDisposition`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现并上传一个机制，使用HTTP `POST`方法。我们将消费`MULTIPART_FORM_DATA`。当你用一个名为`"file"`的参数引用表单，它是一个输入流以获取文件名时，你也可以引用`@FormDataParam`并使用`FormDataContentDisposition`：
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s open our REST API. We do not specify anything; we just send the
    version and receive `"v1"`, which is the default setting:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开我们的REST API。我们不指定任何内容；我们只发送版本号并接收`"v1"`，这是默认设置：
- en: '![](img/943b3a68-6d03-4209-9bc7-442939d63f38.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/943b3a68-6d03-4209-9bc7-442939d63f38.png)'
- en: 'We also get `"v1"` because I''ve explicitly set the Accept header here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到了`"v1"`，因为我在这里明确设置了Accept头：
- en: '![](img/43954a70-c83e-43a0-9acc-625bd44b994a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43954a70-c83e-43a0-9acc-625bd44b994a.png)'
- en: 'To obtain `"v2"`, we must specify the Accept header with the `application/vnd.version.v2+json`
    content type:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得`"v2"`，我们必须指定包含`application/vnd.version.v2+json`内容类型的Accept头：
- en: '![](img/7a81c7b2-780c-49b8-8238-a68de3bdc4bb.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a81c7b2-780c-49b8-8238-a68de3bdc4bb.png)'
- en: 'Finally, we can see that the serving of GIF images and JPEGs is also working.
    We can request a GIF image and, as you can see here, we have the magic of content
    types:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到GIF图像和JPEG的提供也是正常工作的。我们可以请求一个GIF图像，正如你所看到的，我们有内容类型的魔力：
- en: '![](img/a110088b-3ced-48aa-b651-0cf592b195d2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a110088b-3ced-48aa-b651-0cf592b195d2.png)'
- en: In the next section, we will talk about easy data binding using JSON-B.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论使用JSON-B的简单数据绑定。
- en: Easy data binding using JSON-B
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON-B的简单数据绑定
- en: In this section, we're going to take a look at using JSON-B for marshalling
    and unmarshalling of your JSON and POJO data structures, how you can use JSON-B
    annotations on POJOs such as `@JsonbProperty`, `@JsonbNumberFormat`, `@JsonbDateFormat`,
    `@JsonbTransient`, and `@JsonbPropertyOrder`, and finally how you can explicitly
    create `JsonbConfig` and `Jsonb` instances using `JsonbBuilder`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用JSON-B进行JSON和POJO数据结构的序列化和反序列化，如何在POJO上使用JSON-B注解，例如`@JsonbProperty`、`@JsonbNumberFormat`、`@JsonbDateFormat`、`@JsonbTransient`和`@JsonbPropertyOrder`，以及最后如何显式创建`JsonbConfig`和`Jsonb`实例使用`JsonbBuilder`。
- en: Let's get started and switch to code. We will create a `JsonResource` class.
    This is our basic REST resource and we want to implement our basic methods that
    return JSON structures from a POJO and that unmarshall our POJO from JSON structures.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始并切换到代码。我们将创建一个`JsonResource`类。这是我们基本的REST资源，我们想要实现我们的基本方法，从POJO返回JSON结构，以及从JSON结构反序列化我们的POJO。
- en: 'The first bit is easy; first up, we''re implementing a basic `@GET` method.
    We call it `marshall` and it returns a `JsonbPojo`. `JsonbPojo` is a plane POJO
    object: it''s a plane class. We''ll use the `@Produces` application for JSON and
    JAX-RS, and Java EE 8 will make sure that this POJO is marshalled properly to
    JSON using JSON-B:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分很简单；首先，我们实现一个基本的`@GET`方法。我们称之为`marshall`，它返回一个`JsonbPojo`。`JsonbPojo`是一个简单的POJO对象：它是一个简单的类。我们将使用`@Produces`应用JSON和JAX-RS，Java
    EE 8将确保这个POJO使用JSON-B正确地序列化为JSON：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same is true for unmarshalling. Let''s assume that we want to `POST` a
    `JsonbPojo` to this REST resource. At the class level, we make sure that we use
    the `@Consumes` application JSON. If you `POST` a proper JSON to this REST resource,
    JAX-RS and Java EE 8 will make sure that this JSON structure is then deserialized
    and unmarshalled into a `JsonbPojo`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化也是如此。假设我们想要将一个`JsonbPojo`通过这个REST资源`POST`。在类级别上，我们确保使用`@Consumes`应用JSON。如果你向这个REST资源`POST`一个合适的JSON，JAX-RS和Java
    EE 8将确保这个JSON结构被反序列化和反序列化为`JsonbPojo`：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you don''t like the default serialization, what you can always do is take
    care of the marshalling yourself using the `jsonb` instance. It offers a method
    called `toJson`, which you can pass to any object and it will return the string
    as an output, and vice versa. You can say that it expects the JSON string as the
    first parameter and the class of the final POJO as the second parameter. If everything
    goes the way you want it to, you''ll receive the unmarshalled object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢默认的序列化，你可以自己处理序列化，使用`jsonb`实例。它提供了一个名为`toJson`的方法，你可以传递给任何对象，它将返回一个字符串作为输出，反之亦然。你可以这样说，它期望JSON字符串作为第一个参数，最终POJO的类作为第二个参数。如果你一切顺利，你会收到反序列化的对象：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s have a closer look at using this `jsonb`. We will prepare simple unit
    tests here. What we can always do is create and use JSON-B standalone without
    any JAX-RS resources. The one thing you should do is use `JsonbConfig` and make
    sure that we import everything in there. We will create a new `JsonbConfig` and
    on this `JsonbConfig`, we can set several parameters. For example, you can specify
    a property ordering strategy where we use `LEXICOGRAPHICAL`. You can also specify
    `REVERSE` and `ANY` in any case as well. We can specify if we want to marshall
    null values, use a property naming strategy, in this case, `LOWERCASE_CASE_WITH_DASHES`,
    we can specify whether the produced JSON is formatted or not, you can specify
    a default date format, you can specify how to handle binary data, and you can
    specify the overall locale. Using `jsonbConfig` is pretty straightforward; we
    use the JSON-B builder (`JsonbBuilder`) and call the `create` method on it and
    pass `create` (`jsonbConfig`):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看如何使用这个`jsonb`。在这里，我们将准备简单的单元测试。我们总能做的是创建并使用JSON-B独立，而不需要任何JAX-RS资源。你应该做的一件事是使用`JsonbConfig`并确保我们导入那里的一切。我们将创建一个新的`JsonbConfig`，在这个`JsonbConfig`上，我们可以设置几个参数。例如，你可以指定一个属性排序策略，其中我们使用`LEXICOGRAPHICAL`。你也可以在任何情况下指定`REVERSE`和`ANY`。我们可以指定是否要序列化null值，使用属性命名策略，在这种情况下，`LOWERCASE_CASE_WITH_DASHES`，我们可以指定生成的JSON是否格式化，可以指定默认的日期格式，可以指定如何处理二进制数据，并且可以指定全局区域设置。使用`jsonbConfig`非常直接；我们使用JSON-B构建器（`JsonbBuilder`）并调用其上的`create`方法，并传递`create`（`jsonbConfig`）：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we obtain this JSON-B instance, in the test methods, we use `jsonb.toJson(pojo)`
    and we get the string JSON-B from JSON. Pass it the string data and a class you
    want and the `pojo` will be returned:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了这个JSON-B实例，在测试方法中，我们使用`jsonb.toJson(pojo)`并从JSON中获得字符串JSON-B。传递字符串数据和想要转换成的类，`pojo`将被返回：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This works for plain POJOs and POJOs that have not been specifically annotated.
    If we want to overwrite these default configurations, we can annotate our POJO
    like we did previously using `@JsonbPropertyOrder`. For example, to specify the
    very explicit property order, we can say `@JsonbProperty` to give it a different
    name, `@JNumberFormat` to specify the number format to use, `@JsonbDateFormat`
    to specify a different date, or `@JsonbTransient`, which tells JSON-B to ignore
    this property during marshalling and unmarshalling:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于普通的POJO以及未被特别注解的POJO。如果我们想覆盖这些默认配置，我们可以像之前一样使用`@JsonbPropertyOrder`注解我们的POJO。例如，为了指定非常明确的属性顺序，我们可以使用`@JsonbProperty`来给它一个不同的名称，使用`@JNumberFormat`来指定要使用的数字格式，使用`@JsonbDateFormat`来指定不同的日期，或者使用`@JsonbTransient`，这告诉JSON-B在序列化和反序列化过程中忽略这个属性：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s take this test and run our thing. Our test should hopefully be green,
    as shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个测试。我们的测试应该如以下截图所示，希望是绿色的：
- en: '![](img/b59eeaa3-b404-4bec-bc9d-ea1a35bc12d3.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b59eeaa3-b404-4bec-bc9d-ea1a35bc12d3.png)'
- en: In this section, we saw that using JSON-B is really simple and straightforward.
    In the next section, we'll talk about flexible JSON processing with JSON-P.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了使用JSON-B实际上非常简单直接。在下一节中，我们将讨论使用JSON-P的灵活JSON处理。
- en: Flexible JSON processing with JSON-P
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON-P进行灵活的JSON处理
- en: In this section, we're going to take a look at using JSON-P builders to construct
    JSON arrays and objects. We'll see how you can use JSON-P in REST resources for
    marshalling and unmarshalling data, how to use JSON Pointers to access JSON structures,
    and have a closer look at JSON Patch and JSON Diff to modify JSON structures.
    We will also be using the `@PATCH` annotation and the `application/json-patch+json`
    content type to apply patches in our REST resources, so there's lots of content
    ahead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用JSON-P构建器来构建JSON数组和对象。我们将看到如何在REST资源中使用JSON-P进行序列化和反序列化数据，如何使用JSON指针访问JSON结构，并更详细地看看JSON
    Patch和JSON Diff如何修改JSON结构。我们还将使用`@PATCH`注解和`application/json-patch+json`内容类型在我们的REST资源中应用补丁，所以接下来有很多内容。
- en: 'Let''s get started. As usual, we prepare a small REST resource as a template
    to start. The first thing we do is create arrays for JSON and JSON objects using
    the associated builders, so let''s do that:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。像往常一样，我们准备一个小型的REST资源作为模板来开始。我们首先做的事情是使用相关的构建器创建JSON和JSON对象的数组，所以让我们来做这件事：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we're using the `createArrayBuilder` to create an array builder, and we're
    using the `add` method to add JSON objects. Here, you can use `Json.createObjectBuilder`
    to obtain an object builder. On this object builder, we then call different `add`
    methods to add a string, an integer, a Boolean, or maybe a null value using the
    special `JsonValue`. That's all there is to it. Using these two builders, you
    can create complex JSON structures quite easily.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `createArrayBuilder` 创建一个数组构建器，并使用 `add` 方法添加 JSON 对象。在这里，你可以使用 `Json.createObjectBuilder`
    获取一个对象构建器。在这个对象构建器上，我们然后调用不同的 `add` 方法来添加一个字符串、一个整数、一个布尔值或者可能使用特殊的 `JsonValue`
    添加一个 null 值。就是这样。使用这两个构建器，你可以相当容易地创建复杂的 JSON 结构。
- en: 'What do we do with this? The first thing we do is we return `jsonArray`; this
    is really straightforward. You can explicitly and directly return this `jsonArray`
    for marshalling. To do this, we will produce an `APPLICATION_JSON` as our content
    type and JAX-RS will make sure that our `jsonArray` is serialized and marshalled
    to the corresponding JSON structure:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何处理这个呢？我们首先做的事情是返回 `jsonArray`；这实际上是非常直接的。你可以明确并直接返回这个 `jsonArray` 以进行序列化。为此，我们将生成一个
    `APPLICATION_JSON` 作为我们的内容类型，JAX-RS 将确保我们的 `jsonArray` 被序列化和打包到相应的 JSON 结构中：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same is true if we want to unmarshall the data using JSON-P. We will consume
    the `APPLICATION_JSON`, get the `InputStream` which is basically `jsonBody`, and
    we''re going to use `JsonReader` Here, we''re going to use `Json.CreateReader(jsonBody)`
    from the `InputStream`, obtain a `JsonReader`, and on the `reader`, we can read
    the array:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 JSON-P 反序列化数据，情况也是一样的。我们将消费 `APPLICATION_JSON`，获取基本为 `jsonBody` 的 `InputStream`，然后我们将使用
    `JsonReader`。在这里，我们将从 `InputStream` 使用 `Json.CreateReader(jsonBody)` 获取一个 `JsonReader`，并在
    `reader` 上读取数组：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s see what else there is in JSON-P. Well, first up there are JSON Pointers.
    Let''s look into JSON Pointers. Let''s assume we have a simple JSON structure.
    In this test, we''ll create a reader using a string, and we''ll obtain a `JsonObject`
    from the reader and a `JsonArray` from this object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 JSON-P 中还有什么。首先，有 JSON 指针。让我们来看看 JSON 指针。假设我们有一个简单的 JSON 结构。在这个测试中，我们将使用一个字符串创建一个读取器，并从读取器获取一个
    `JsonObject` 和一个 `JsonArray`：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What if we want to access an array value by index? For this, we use a JSON Pointer.
    We'll use `Json.createPointer`, and using this annotation here basically specifies
    the path and the index of the value we want to reference. We'll also create a
    `jsonPointer`, and on the `jsonPointer` we can then set `getValue` and pass it
    the `JsonObject`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过索引访问数组值怎么办？为此，我们使用 JSON 指针。我们将使用 `Json.createPointer`，并且使用这个注解基本上指定了我们想要引用的路径和值的索引。我们还将创建一个
    `jsonPointer`，并在 `jsonPointer` 上设置 `getValue` 并传递 `JsonObject`：
- en: 'Doing this, we''ll get back a `jsonValue` and what we can do is we can check
    that the values of the `JsonNumber` and `jsonArray` instances are correct as well:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们将得到一个 `jsonValue`，我们可以做的是检查 `JsonNumber` 和 `jsonArray` 实例的值是否正确：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also use the JSON Pointer to replace objects in the array, for example,
    or in the JSON structure. We use `jsonPointer.replace`, give it the original `jsonObject`,
    and we specify the new `createValue(42)` value we want to replace the pointer
    value with:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 JSON 指针替换数组中的对象，例如，或者在 JSON 结构中。我们使用 `jsonPointer.replace`，给它原始的 `jsonObject`，并指定我们想要用
    `createValue(42)` 替换指针值的新的 `createValue(42)` 值：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also use the JSON Pointer to remove things from the JSON''s structure.
    Here, we can use the JSON Pointer, say, on `remove(jsonObject)`, and a new JSON
    object will be returned. If we check the JSON array, the size is smaller than
    before:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 JSON 指针从 JSON 的结构中删除内容。在这里，我们可以在 `remove(jsonObject)` 上使用 JSON 指针，并返回一个新的
    JSON 对象。如果我们检查 JSON 数组，其大小将小于之前：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Something else regarding JSON-P is JSON Patch. We will create a JSON object
    first, a `jsonReader`, pass it a string, and read the object from the reader.
    We will create a `JsonPatch`. For this, we will use the `createPatchBuilder` and
    on the `patch` we want to say, please replace the element `"/aString"` with the
    `"Patched Json-P."` value and please remove this from `"/arrayOfInt/1"`. Therefore,
    you can use JSON Patch to specify modifying operations, such as replacing, removing,
    and adding values to JSON structures. On the `patch`, we call the `apply` method
    and we''ll pass it as a parameter to the JSON structure we want to apply the patch
    to. This will return a new and modified JSON object. Here, we can make sure that
    the modification is done properly:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JSON-P 的另一件事是 JSON Patch。我们首先创建一个 JSON 对象，一个 `jsonReader`，传递一个字符串，并从读取器中读取对象。我们将创建一个
    `JsonPatch`。为此，我们将使用 `createPatchBuilder`，在 `patch` 中我们想要说的是，请将元素 `"/aString"`
    替换为 `"Patched Json-P."` 值，并请从 `"/arrayOfInt/1"` 中删除它。因此，你可以使用 JSON Patch 来指定修改操作，例如替换、删除和向
    JSON 结构中添加值。在 `patch` 上，我们调用 `apply` 方法，并将其作为参数传递给我们要应用补丁的 JSON 结构。这将返回一个新的和修改后的
    JSON 对象。在这里，我们可以确保修改是正确完成的：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Something else that''s quite nice is the JSON Diff feature. Let''s assume that
    we have a `source` and a `target` object. As you can see, they''re both kind of
    the same—they have one element called `"aString"`, but the values differ. What
    we then do is create a `diff`, say, `Json.createDiff(source, target)`, and what
    we get back is a `JsonPatch` describing the necessary changes it needs to apply
    to `source` so that we can get the `target` object. If we have a look at our JSON
    Diff, we can see all that is required is a `replace` operation. For the following
    path, we do the same with `"/aString"`, and we need to replace the `"value"` with
    `"xyz"`. If we apply this patch to the `source` object, we get the `target` object,
    and we do that by taking the `diff` and applying it to the `source`. We get back
    a new object and we assert that the `source` is equal to the `target`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件相当不错的事情是 JSON Diff 功能。假设我们有一个 `source` 和一个 `target` 对象。如你所见，它们都有一种相似之处——都有一个名为
    `"aString"` 的元素，但值不同。我们接下来要做的是创建一个 `diff`，比如 `Json.createDiff(source, target)`，我们得到的是一个
    `JsonPatch`，它描述了需要应用到 `source` 上的必要更改，以便我们可以得到 `target` 对象。如果我们查看我们的 JSON Diff，我们可以看到所需的所有操作只是一个
    `replace` 操作。对于以下路径，我们对 `"/aString"` 做同样的操作，我们需要将 `"value"` 替换为 `"xyz"`。如果我们将这个补丁应用到
    `source` 对象上，我们得到 `target` 对象，我们通过将 `diff` 应用到 `source` 上来实现这一点。我们得到一个新的对象，并断言
    `source` 等于 `target`：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also use JSON Patch in your JAX-RS resources as well. For this, we
    have to use the following two annotations. First up, we use `@PATCH` and then
    specify `@Consumes` with a media type of `APPLICATION_JSON_PATCH_JSON`. The structure
    we send this in is a `JsonArray`, and from that `JsonArray`, we create a `jsonPatch`
    that we can use to apply it to our data structures:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在你的 JAX-RS 资源中使用 JSON Patch。为此，我们必须使用以下两个注解。首先，我们使用 `@PATCH` 并指定 `@Consumes`
    的媒体类型为 `APPLICATION_JSON_PATCH_JSON`。我们发送的结构是一个 `JsonArray`，然后从该 `JsonArray` 中创建一个
    `jsonPatch`，我们可以用它来应用到我们的数据结构中：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That was a lot of content for covering JSON-P. In the next section, we are going
    to implement a hypermedia-driven REST API using what we've learned so far.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分涵盖了 JSON-P 的内容很多。在下一节中，我们将使用我们迄今为止所学的内容来实现一个超媒体驱动的 REST API。
- en: Implementing hypermedia-driven REST APIs
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现超媒体驱动的 REST API
- en: In this section, we're going to take a look at how you can traverse REST resources
    using hypermedia (with links and URIs). We'll see how to use JSON-P to construct
    hypermedia enabled JSON structures. We'll use the `@Context` and `UriInfo` objects
    to construct resource URIs programmatically. We will also have a look at how to
    set link headers with URIs on the HTTP response.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用超媒体（带有链接和 URI）遍历 REST 资源。我们将看到如何使用 JSON-P 构建超媒体启用的 JSON 结构。我们将使用
    `@Context` 和 `UriInfo` 对象来程序化地构建资源 URI。我们还将查看如何在 HTTP 响应中设置带有 URI 的链接头。
- en: Let's get started and switch to our IDE. We will prepare a resource, and this
    resource will be serving books and authors; both are individual REST resources.
    Obviously, books are written by authors, so we should be able to navigate from
    books to the authors and vice versa. This is what we can use hypermedia for.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，切换到我们的 IDE。我们将准备一个资源，这个资源将提供书籍和作者；它们都是独立的 REST 资源。显然，书籍是由作者写的，所以我们应该能够从书籍导航到作者，反之亦然。这就是我们可以使用超媒体的地方。
- en: 'Navigate to our book resource. In here, we have the method to serve a specific
    book. First up, we''ll obtain the book and then we can construct the URI for this
    book. `createBookResourceUri` is the URI to use to reference this book:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到我们的书籍资源。在这里，我们有为特定书籍提供的方法。首先，我们将获取书籍，然后我们可以为这本书构造URI。`createBookResourceUri`
    是用于引用这本书的URI：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also want to construct the author URI for this book. If you look in here
    into one of those methods, you''ll see that we use the `uriInfo` object and that
    we obtain a base URI builder from it. We then use the `path` methods to actually
    build the final URI. Using these `path` methods, we can construct the path from
    the `@Path` annotations of our resources and resource methods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要为这本书构造作者URI。如果您查看这里的一个方法，您会看到我们使用`uriInfo`对象，并从中获取一个基本URI构建器。然后，我们使用`path`方法来实际构建最终的URI。使用这些`path`方法，我们可以从资源的`@Path`注解和资源方法中构建路径：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the final result, we have a URI that references the actual resource:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终结果中，我们有一个引用实际资源的URI：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next up, what we do is create a JSON object from `book` from our `bookUri`,
    and this is where hypermedia comes into play. Let''s have a look at them. We''ll
    use JSON-P to create an object builder and add `"isbn"` and `"title"` to it. However,
    there''s one bit missing and that bit makes the final hypermedia enabled JSON
    structure. We will add an additional object called `"_links"` which is a JSON
    object, and this JSON object contains two other JSON objects which are called `"self"`
    and `"author"`. `"self"` describes the URI of the REST resource itself, which
    in this case is the type of book. Then, we specify `"author"`, and we give it
    an `"href"` attribute which points to `authorUri`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是从`bookUri`创建一个JSON对象，这正是超媒体发挥作用的地方。让我们看看它们。我们将使用JSON-P创建一个对象构建器，并向其中添加`"isbn"`和`"title"`。然而，这里缺少一个部分，这个部分使得最终的超媒体启用JSON结构。我们将添加一个额外的对象，称为`"_links"`，这是一个JSON对象，它包含两个其他JSON对象，分别称为`"self"`和`"author"`。`"self"`描述了REST资源的URI本身，在这种情况下是书籍类型。然后，我们指定`"author"`，并给它一个指向`authorUri`的`"href"`属性：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we return the JSON object, and on the `response` object you can also
    set the link HTTP headers as well so that you have two options. You can either
    specify the link header on the HTTP `response` or embed the URIs, which adds a
    linked JSON structure here. We've completed the books.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回JSON对象，在`response`对象上，您也可以设置HTTP链接头，这样您就有两种选择。您可以在HTTP `response`中指定链接头，或者嵌入URI，这在这里添加了一个链接JSON结构。我们已经完成了书籍。
- en: 'We can pretty much do almost the same thing for authors; the code this is pretty
    much copy/paste. This kind of follows the same procedure: we get the authors and
    then construct the URI for the author and the books. We construct our JSON object
    where we''re going to embed the links to `"self"`, which is `"books"` itself,
    and do the same for the `booksUri`. Finally, you return the response of this JSON
    object and we can also embed the `link` HTTP headers.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以对作者做同样的事情；这段代码几乎是复制粘贴的。这遵循相同的程序：我们获取作者，然后为作者和书籍构造URI。我们在将要嵌入`"self"`链接的JSON对象中构建我们的JSON对象，`"self"`是`"books"`本身，并为`booksUri`做同样的事情。最后，您返回这个JSON对象的响应，我们还可以嵌入`link`
    HTTP头。
- en: 'Now, let''s put this API to the test. Open our Postman and issue a `GET` request
    for the list of books. In here, you will see that the book has a title and that
    it also contains a list of links. For `"self"`, this is the book itself and for
    `"author"`, we get the author of the book, as shown in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试这个API。打开我们的Postman，对书籍列表发出`GET`请求。在这里，您将看到书籍有一个标题，它还包含一个链接列表。对于`"self"`，这是书籍本身，对于`"author"`，我们得到书籍的作者，如下面的截图所示：
- en: '![](img/1aee538a-1f94-468c-98d8-4560e1bb6597.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1aee538a-1f94-468c-98d8-4560e1bb6597.png)'
- en: 'Let''s click on the book, that is, the URI present in `"self"`, to get information
    about this book in particular. As you can see, this returns a single book structure.
    If you want to navigate to the author, we can use the author link. Here, we have
    the author of this book, as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击书籍，即`"self"`中存在的URI，以获取这本书的特定信息。如您所见，这返回了一个单独的书籍结构。如果您想导航到作者，我们可以使用作者链接。在这里，我们有这本书的作者，如下面的截图所示：
- en: '![](img/b575a269-e5c8-4d97-ac28-539aa98574f3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b575a269-e5c8-4d97-ac28-539aa98574f3.png)'
- en: If we want to obtain the list of books that this author has written, we can
    use the `"books"` link, which gets all the books from this author's ID, as shown
    in the preceding screenshot.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取这位作者所写的书籍列表，我们可以使用`"books"`链接，该链接从这位作者的ID获取所有书籍，如前一张截图所示。
- en: 'If you want to have a look at this book again, you can navigate from those
    two books. What you can also see here in the headers is that we have the two links
    for the author and the book itself:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要再次查看这本书，你可以从这两本书中进行导航。你还可以在这里的头部看到，我们有两个链接，一个是作者的链接，另一个是书籍本身的链接：
- en: '![](img/7adbe647-433e-4c27-b0d4-798bb2ac86f5.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7adbe647-433e-4c27-b0d4-798bb2ac86f5.png)'
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's summarize what we have learned in this chapter. First up, we had a look
    at how we can use custom content types and content negotiation in our web services.
    Next up, we had a look at JSON-B and how we can use it for easy data binding of
    your POJOs to and from JSON. We also had a look at JSON-P for very flexible JSON
    processing, and how we can create JSON structures and retrace these structures
    using JSON-P. Then, we looked at how to use JSON Pointers, JSON Patch, and JSON
    Diff for more flexible JSON processing, and finally, we had a look at implementing
    hypermedia enabled REST APIs using JSON-P and `UriInfo`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容。首先，我们探讨了如何在我们的Web服务中使用自定义内容类型和内容协商。接下来，我们了解了JSON-B以及如何使用它来轻松地将你的POJOs与JSON进行数据绑定。我们还探讨了JSON-P，这是一种非常灵活的JSON处理方式，以及如何使用JSON-P创建JSON结构和回溯这些结构。然后，我们研究了如何使用JSON
    Pointers、JSON Patch和JSON Diff进行更灵活的JSON处理，最后，我们探讨了使用JSON-P和`UriInfo`实现具有超媒体功能的REST
    API。
- en: In the next chapter, we will talk about building asynchronous web services.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论构建异步Web服务。
