- en: Duplicate File Finder
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复文件查找器
- en: Any system that's been running for a while starts to suffer from hard drive
    clutter. This is especially true, for example, with large music and photo collections.
    Except for the most fastidious files getting copied and moved, we end up with
    a copy here and a copy there. The question is, though, which of these are duplicates
    and which are not? In this chapter, we'll build a file-walking utility that will
    scan a set of directories looking for duplicate files. We'll be able to specify
    whether the duplicates should be deleted, **quarantined**, or simply reported.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何运行了一段时间的系统都会开始受到硬盘杂乱的影响。例如，对于大型音乐和照片收藏来说，这一点尤其如此。除了最挑剔的文件被复制和移动之外，我们最终会在这里和那里都有副本。然而，问题是，这些副本中哪些是重复的，哪些不是？在本章中，我们将构建一个文件遍历实用程序，它将扫描一组目录以查找重复文件。我们将能够指定是否应该删除重复文件、**隔离**或只是报告。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Java Platform Module System
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台模块系统
- en: The Java NIO (New I/O) File APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java NIO（新I/O）文件API
- en: File hashing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件哈希
- en: '**Java Persistence API** (**JPA**)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java持久化API**（**JPA**）'
- en: The new Java Date/Time API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的Java日期/时间API
- en: Writing command-line utilities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写命令行实用程序
- en: More JavaFX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多JavaFX
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This application, while conceptually fairly simple, is a bit more complex than
    what we looked at in the last chapter, in that we will have both, a command line
    and a graphical interface. The experienced programmer is likely to immediately
    see the need to share the code between these two interfaces, as **DRY** (**Don''t
    Repeat Yourself**) is one of the many hallmarks of a well-designed system. To
    facilitate this sharing of code, then, we will want to introduce a third module,
    which provides a library that can be consumed by the other two projects. We will
    call these modules `lib`, `cli`, and `gui`. Our first step in setting up the project
    is to create the various Maven POM files to describe the project''s structure.
    The parent POM will look something like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序在概念上相当简单，但比上一章我们讨论的要复杂一些，因为我们会有命令行和图形界面两个界面。经验丰富的程序员可能会立即看到在两个界面之间共享代码的需要，因为**DRY**（不要重复自己）是良好设计系统的一个许多标志之一。因此，为了促进这种代码共享，我们将引入第三个模块，该模块提供了一个可以被其他两个项目使用的库。我们将把这些模块称为`lib`、`cli`和`gui`。设置项目的第一步是创建各种Maven
    POM文件来描述项目的结构。父POM看起来可能像这样：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a fairly typical POM file. We will start by identifying the project's
    parent that lets us inherit a number of settings, dependencies, and so on, and
    avoid having to repeat them in this project. Next, we will define the Maven coordinates
    for the project. Note that we don't define a version for this project, allowing
    the parent's version to cascade down. This will allow us to increase the version
    as needed in one place, and update all of the subprojects implicitly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当典型的POM文件。我们首先将确定项目的父项目，这样我们就可以继承许多设置、依赖项等，避免在这个项目中重复它们。接下来，我们将定义项目的Maven坐标。请注意，我们没有为这个项目定义版本，允许父项目的版本向下传递。这将允许我们在一个地方增加版本，并隐式更新所有子项目。
- en: The last interesting part of this POM, for those who haven't seen a multi-module
    project before, is the `modules` section. The only thing to note here, for those
    who are new to this, is that each `module` element refers to a directory name,
    which is a direct child of the current directory, and should be declared in the
    order in which they are needed. In our case, the CLI and GUI both depend on the
    library, so `lib` goes first. Next, we'll need to create the POM files for each
    module. Each of these are typical POMs of type jar, so there's no need to include
    them here. There will be varying dependencies in each, but we'll cover those as
    the need arises.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些以前没有见过多模块项目的读者来说，这个POM的最后一个有趣的部分是`modules`部分。对于那些新手来说，需要注意的是，每个`module`元素都指的是一个目录名，它是当前目录的直接子目录，并且应该按照它们所需的顺序声明。在我们的情况下，CLI和GUI都依赖于库，所以`lib`排在第一位。接下来，我们需要为每个模块创建POM文件。这些每个都是典型的jar类型POM，所以没有必要在这里包含它们。每个都会有不同的依赖项，但我们将根据需要来讨论这些依赖项。
- en: Building the library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建库
- en: The foundational piece of this project is the library which both the CLI and
    the GUI will consume, so it makes sense to start here. When designing the library--its
    inputs, outputs, and general behavior--it helps to understand what exactly do
    we want this system to do, so let's take some time to discuss the functional requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的基石是库，CLI和GUI都将使用这个库，所以从这里开始是有意义的。在设计库时——它的输入、输出和一般行为——了解我们到底想要这个系统做什么，这很有帮助，所以让我们花点时间来讨论功能需求。
- en: As stated in the introduction, we'd like to be able to search for duplicate
    files in an arbitrary number of directories. We'd also like to be able to restrict
    the search and comparison to only certain files. If we don't specify a pattern
    to match, then we want to check every file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，我们希望能够搜索任意数量的目录中的重复文件。我们还希望能够将搜索和比较限制在仅某些文件上。如果我们没有指定匹配模式，那么我们希望检查每个文件。
- en: 'The most important part is how to identify a match. There are, of course, a
    myriad of ways in which this can be done, but the approach we will use is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是如何识别匹配。当然，有无数种方法可以做到这一点，但我们将采用以下方法：
- en: Identify files that have the same filename. Think of those situations where
    you might have downloaded images from your camera to your computer for safekeeping,
    then, later, perhaps you forgot that you had already downloaded the images, so
    you copied them again somewhere else. Obviously, you only want one copy, but is
    the file, for example, `IMG_9615.JPG`, in the temp directory the same as the one
    in your picture backup directory? By identifying files with matching names, we
    can test them to be sure.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别具有相同文件名的文件。想想那些你可能已经从相机下载图片到电脑保存，然后后来可能忘记了你已经下载了这些图片，所以你又在其他地方复制了它们的情况。显然，你只需要一个副本，但是例如文件`IMG_9615.JPG`在临时目录中与你在图片备份目录中的文件是否相同？通过识别具有匹配名称的文件，我们可以测试它们以确保它们是相同的。
- en: Identify files that have the same size. The likelihood of a match here is smaller,
    but there is still a chance. For example, some photo management software, when
    importing images from a device, if it finds a file with the same name, will modify
    the filename of the second file and store both, rather than stopping the import
    and requiring immediate user intervention. This can result in a large number of
    files such as `IMG_9615.JPG` and `IMG_9615-1.JPG`. This check will help identify
    these situations.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别具有相同大小的文件。这里的匹配可能性较小，但仍然存在机会。例如，一些照片管理软件在从设备导入图片时，如果发现具有相同名称的文件，会修改第二个文件的文件名并将两个文件都存储起来，而不是停止导入并要求立即用户干预。这可能导致大量文件，如`IMG_9615.JPG`和`IMG_9615-1.JPG`。这个检查将有助于识别这些情况。
- en: For each match above, to determine whether the files are actually a match, we'll
    generate a hash based on the file contents. If more than one file generates the
    same hash, the likelihood of those files being identical is extremely high. These
    files we will flag as potential duplicates.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于上面的每个匹配项，为了确定文件是否实际上是匹配的，我们将根据文件内容生成一个哈希值。如果有多个文件生成了相同的哈希值，这些文件实际上是相同的可能性非常高。我们将这些文件标记为潜在的重复文件。
- en: 'It''s a pretty simple algorithm and should be pretty effective, but we do have
    a problem, albeit one that''s likely not immediately apparent. If you have a large
    number of files, especially a set with a large number of potential duplicates,
    processing all of these files could be a very lengthy process, which we would
    like to mitigate as much as possible, which leads us to some non-functional requirements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的算法，应该相当有效，但我们确实有一个问题，尽管这个问题可能不是立即显而易见的。如果你有大量的文件，特别是具有大量潜在重复文件的集合，处理所有这些文件可能是一个非常耗时的过程，我们希望尽可能减少这个过程，这导致我们有一些非功能性需求：
- en: The program should process files in a concurrent manner so as to minimize, as
    much as possible, the amount of time it takes to process a large file set
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序应该以并发方式处理文件，以尽可能减少处理大量文件集所需的时间。
- en: This concurrency should be bounded so that the system is not overwhelmed by
    processing the request
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种并发性应该是有界的，这样系统就不会因为处理请求而超负荷。
- en: Given the potential for a large amount of data, the system must be designed
    in such a way so as to avoid using up all available RAM and causing system instability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到可能存在大量数据，系统必须设计得避免耗尽所有可用的RAM并导致系统不稳定。
- en: 'With that fairly modest list of functional and non-functional requirements,
    we should be ready to begin. Like the last application, let''s start by defining
    our module. In `src/main/java`, we will create this `module-info.java`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当简短的函数性和非函数性需求列表中，我们应该准备好开始。就像上一个应用程序一样，让我们先定义我们的模块。在 `src/main/java` 中，我们将创建这个
    `module-info.java`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initially, the compiler--and the IDE--will complain that the `com.steeplesoft.dupefind.lib`
    package does not exist and won't compile the project. That's fine for now, as
    we'll be creating that package now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，编译器——以及IDE——会抱怨 `com.steeplesoft.dupefind.lib` 包不存在，并且不会编译项目。现在还不用担心这个问题，因为我们现在就会创建这个包。
- en: The use of the word **concurrency** in the functional requirements, most likely,
    immediately brings to mind the idea of threads. We introduced the idea of threads
    in [Chapter 18](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml), *Managing Java Processes*,
    so if you are not familiar with them, review that section in the previous chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能性需求中使用 **并发** 这个词，很可能会立刻让人联想到线程的概念。我们在第18章 [管理Java进程](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml)
    中介绍了线程的概念，所以如果你不熟悉它们，请回顾一下上一章的相关内容。
- en: Our use of threading in this project is different from that in the last, in
    that we will have a body of work that needs to be done, and, once it's finished,
    we want the threads to exit. We also need to wait for these threads to finish
    their work so that we can analyze it. In the `java.util.concurrent` package, the
    JDK provides several options to accomplish this.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们使用线程的方式与上一个项目不同，因为我们会有一些需要完成的工作，一旦完成，我们希望线程退出。我们还需要等待这些线程完成它们的工作，以便我们可以分析它们。在
    `java.util.concurrent` 包中，JDK提供了几个选项来完成这项任务。
- en: Concurrent Java with a Future interface
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有Future接口的并发Java
- en: One of the more common and popular APIs is the `Future<V>` interface. `Future`
    is a means to encapsulate an asynchronous calculation. Typically, the `Future`
    instance is returned by `ExecutorService`, which we'll discuss later. The calling
    code, once it has the reference to `Future`, can continue to work on other tasks
    while `Future` runs in the background in another thread. When the caller is ready
    for the results of `Future`, it calls `Future.get()`. If `Future` has finished
    its work, the call returns immediately with the results. If, however, `Future`
    is still working, calls to `get()` will block until `Future` completes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个更常见且受欢迎的API是 `Future<V>` 接口。`Future` 是封装异步计算的一种方式。通常，`Future` 实例由 `ExecutorService`
    返回，我们稍后会讨论它。一旦调用者获得 `Future` 的引用，它就可以继续在其他任务上工作，同时 `Future` 在另一个线程的背景中运行。当调用者准备好
    `Future` 的结果时，它调用 `Future.get()`。如果 `Future` 已经完成其工作，调用将立即返回结果。然而，如果 `Future`
    仍在工作，对 `get()` 的调用将阻塞，直到 `Future` 完成。
- en: For our uses, though, `Future` isn't the most appropriate choice. Looking over
    the non-functional requirements, we see the desire to avoid crashing the system
    by exhausting the available memory explicitly listed out. As we'll see later,
    the way this will be implemented is by storing the data in a lightweight on-disk
    database, and we will implement that--again, as we'll see later-by storing the
    file information as it is retrieved rather than by gathering the data, then saving
    it in a post-process method. Given that, our `Future` won't be returning anything.
    While there is a way to make that work (defining `Future` as `Future<?>` and returning
    `null`), it's not the most natural approach.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的用途来说，`Future` 并不是最合适的选择。查看非功能性需求，我们看到避免通过显式耗尽可用内存而导致系统崩溃的愿望被明确列出。正如我们稍后将会看到的，这将通过将数据存储在轻量级的磁盘数据库中来实现，我们将会实现这一点——同样，正如我们稍后将会看到的——通过在检索文件信息时将其存储，而不是通过收集数据然后在后处理方法中保存它。鉴于这一点，我们的
    `Future` 不会返回任何内容。虽然有一种方法可以使它工作（将 `Future` 定义为 `Future<?>` 并返回 `null`），但这并不是最自然的方法。
- en: Perhaps the most appropriate approach is `ExecutorService`, which is `Executor`
    that provides additional functionality, such as the ability to create a `Future`,
    as discussed earlier, and manage termination of the queue. What, then, is `Executor`?
    `Executor` is a mechanism to execute `Runnable` that is more robust than simply
    calling `new Thread(runnable).start()`. The interface itself is very basic, consisting
    only of the `execute(Runnable)` method, so its value is not immediately apparent
    just from looking at the Javadoc. If, however, you look at `ExecutorService`,
    which is the interface that all `Executor` provided by the JDK implement, as well
    as the various `Executor` implementations, their value easily becomes more apparent.
    Let's take a quick survey now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最合适的方案是`ExecutorService`，它是一个提供了额外功能（例如创建`Future`的能力，如前所述，以及管理队列的终止）的`Executor`。那么，`Executor`是什么呢？`Executor`是一个比简单地调用`new
    Thread(runnable).start()`更健壮的执行`Runnable`的机制。该接口本身非常基础，仅包含`execute(Runnable)`方法，因此仅从查看Javadoc中无法立即看出其价值。然而，如果你查看`ExecutorService`，这是所有由JDK提供的`Executor`实现以及各种`Executor`实现的接口，它们的价值就很容易显现出来。现在让我们快速浏览一下。
- en: 'Looking at the `Executors` class, we can see five different types of `Executor`
    implementations: a cached thread pool, a fixed-size thread pool, a scheduled thread
    pool, a single thread executor, and a work-stealing thread pool. With the single
    thread `Executor` being the only exception, each of these can be instantiated
    directly (`ThreadPoolExecutor`, `ScheduledThreadPoolExecutor`, and `ForkJoinPool`),
    but users are urged by the JDK authors to use the convenience methods on the `Executors`
    class. That said, what are each of these options and why might you choose one?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`Executors`类，我们可以看到五种不同类型的`Executor`实现：一个缓存线程池、一个固定大小的线程池、一个计划线程池、一个单线程执行器和一个工作窃取线程池。除了单线程`Executor`是唯一例外外，这些都可以直接实例化（`ThreadPoolExecutor`、`ScheduledThreadPoolExecutor`和`ForkJoinPool`），但JDK作者强烈建议用户使用`Executors`类上的便利方法。话虽如此，这些选项分别是什么，为什么你可能会选择其中一个？
- en: '`Executors.newCachedThreadPool()`: This returns `Executor` that provides a
    pool of cached threads. As tasks come in, `Executor` will attempt to find an unused
    thread to execute the task with. If one cannot be found, a new `Thread` is created
    and the work begins. When a task is complete, `Thread` is returned to the pool
    to await reuse. After approximately 60 seconds, unused threads are destroyed and
    removed from the pool, which prevents resources from being allocated and never
    released. Care must be taken with this `Executor`, though, as the thread pool
    is unbounded, which means that under heavy use, the system could be overwhelmed
    by active threads.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newCachedThreadPool()`: 此方法返回一个提供缓存线程池的`Executor`。随着任务的到来，`Executor`将尝试找到一个未使用的线程来执行任务。如果找不到，将创建一个新的`Thread`并开始工作。当任务完成时，`Thread`将返回到池中以等待重用。大约60秒后，未使用的线程将被销毁并从池中移除，这防止了资源被分配后从未释放。尽管如此，在使用此`Executor`时必须小心，因为线程池是无界的，这意味着在重负载下，系统可能会被活跃的线程压垮。'
- en: '`Executors.newFixedThreadPool(int nThreads)`: This method returns an `Executor`
    similar to the one previously mentioned, with the exception that the thread pool
    is bounded to at most `nThreads`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newFixedThreadPool(int nThreads)`: 此方法返回一个与之前提到的类似但有所不同的`Executor`，其区别在于线程池的大小被限制在最多`nThreads`。'
- en: '`Executors.newScheduledThreadPool(int corePoolSize)`: This `Executor` is able
    to schedule tasks to run after an optional initial delay and then periodically,
    based on the delay and `TimeUnit` value. See, for example, the `schedule(Runnable
    command, long delay, TimeUnit unit)` method.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newScheduledThreadPool(int corePoolSize)`: 此`Executor`能够根据可选的初始延迟和基于延迟和`TimeUnit`值的周期性来调度任务。例如，查看`schedule(Runnable
    command, long delay, TimeUnit unit)`方法。'
- en: '`Executors.newSingleThreadExecutor()`: This method will return an `Executor`
    that will use a single thread to execute the tasks submitted to it. Tasks are
    guaranteed to be executed in the order in which they were submitted.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newSingleThreadExecutor()`: 此方法将返回一个使用单个线程来执行提交给它的任务的`Executor`。任务将保证按照它们提交的顺序执行。'
- en: '`Executors.newWorkStealingExecutor()`: This method will return a so-called
    **work stealing** `Executor`, which is of type `ForkJoinPool`. The tasks submitted
    to this `Executor` are written in such a way as to be able to divide up the work
    to additional worker threads until the size of the work is under a user-defined
    threshold.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newWorkStealingExecutor()`: 此方法将返回一个所谓的**工作窃取**`Executor`，它属于`ForkJoinPool`类型。提交给此`Executor`的任务将以一种方式编写，以便能够将工作分配给额外的工作线程，直到工作的大小低于用户定义的阈值。'
- en: Given our non-functional requirements, the fixed-size `ThreadPoolExecutor` seems
    to be the most appropriate. One configuration option we'll need to support, though,
    is the option to force the generation of hashes for every file found. Based on
    the preceding algorithm, only files that have duplicate names or sizes will be
    hashed. However, users may want a more thorough analysis of their file specification
    and would like to force a hash on every file. We'll implement this using the work-stealing
    (or fork/join) pool.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的非功能性需求，固定大小的`ThreadPoolExecutor`似乎是最合适的选择。然而，我们需要支持的一个配置选项是强制为每个找到的文件生成哈希值。根据前面的算法，只有具有重复名称或大小的文件会被哈希化。但是，用户可能希望对他们的文件规范进行更彻底的分析，并希望对每个文件强制进行哈希处理。我们将使用工作窃取（或分叉/合并）池来实现这一点。
- en: 'With our threading approach selected, let''s take a look at the entry point
    for the library, a class we''ll call `FileFinder`. Since this is our entry point,
    it will need to know where we want to search and what we want to search for. That
    will give us the instance variables, `sourcePaths` and `patterns`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了我们的线程方法后，让我们看看库的入口点，我们将称之为`FileFinder`的类。由于这是我们的入口点，它需要知道我们想要搜索的位置以及我们想要搜索的内容。这将给我们实例变量`sourcePaths`和`patterns`：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We're declaring the variables as `private`, as that is a good object-oriented
    practice. We're also declaring them `final`, to help avoid subtle bugs where these
    variables are assigned new values, resulting in the unexpected loss of data. Generally
    speaking, I find it to be a good practice to mark variables as `final` by default
    to prevent such subtle bugs. In the case of instance variables in a class like
    this, a variable can only be declared `final` if it is either immediately assigned
    a value, as we are doing here, or if it is given a value in the class' constructors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量声明为`private`，因为这是一种良好的面向对象实践。我们还将它们声明为`final`，以帮助避免这些变量被分配新值导致的微妙错误。一般来说，我发现将变量默认标记为`final`是一种良好的实践，以防止此类微妙错误。在这种情况下，此类类的实例变量只能声明为`final`，如果它要么立即被赋予值，就像我们在这里所做的那样，要么在类的构造函数中赋予值。
- en: 'We also want to define our `ExecutorService` now:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望在现在定义我们的`ExecutorService`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have somewhat arbitrarily chosen to limit our thread pool to five threads,
    as it seems to be a fair balance between providing a sufficient number of worker
    threads for heavy requests, while not allocating a large number of threads that
    may not be used in most cases. In our case, it is probably a minor issue overblown,
    but it's certainly something to keep in mind.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有些任意地将线程池限制为五个线程，因为它似乎在为重请求提供足够的工作线程和分配大量线程之间提供了一个公平的平衡，而这些线程在大多数情况下可能不会被使用。在我们的情况下，这可能是被夸大了一点的小问题，但确实是一件需要记住的事情。
- en: 'Next, we need to provide a means to store any duplicates found. Consider the
    following lines of code as an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供一种存储任何找到的重复项的方法。以下代码行作为示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll see more details later, but, for now, all that we need to note is that
    this is a `Map` of `List<FileInfo>` objects, keyed by the file hash.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到更多细节，但，目前我们只需要注意的是，这是一个以文件哈希为键的`Map`，其中包含`List<FileInfo>`对象。
- en: The final variable to make note of is something that might be a bit unexpected--an
    `EntityManagerFactory`. You might be asking yourself, what is that? The `EntityManagerFactory`
    is an interface to interact with a persistence unit as defined by the **Java Persistence
    API** (**JPA**), which is part of the Java Enterprise Edition Specification. Fortunately,
    though, the specification was written in such a way to mandate that it be usable
    in a **Standard Edition** (**SE**) context like ours.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的最后一个变量可能有些出乎意料——一个`EntityManagerFactory`。你可能想知道那是什么？`EntityManagerFactory`是与由**Java持久化API**（**JPA**）定义的持久化单元交互的接口，它是Java企业版规范的一部分。幸运的是，该规范被编写得如此，以至于它可以在我们这样的**标准版**（**SE**）环境中使用。
- en: So, what are we doing with such an API? If you'll look back at the non-functional
    requirements, we've specified that we want to make sure that the search for duplicate
    files doesn't exhaust the available memory on the system. For very large searches,
    it is quite possible that the list of files and their hashes can grow to a problematic
    size. Couple that with the memory it will take to generate the hashes, which we'll
    discuss later, and we can very likely run into out-of-memory situations. We will,
    therefore, be using JPA to save our search information in a simple, light database
    (SQLite) that will allow us to save our data to the disk. It will also allow us
    to query and filter the results more efficiently than iterating over in-memory
    structures repeatedly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们用这样的API做什么呢？如果您回顾一下非功能性需求，我们指定了我们要确保搜索重复文件不会耗尽系统上的可用内存。对于非常大的搜索，文件及其哈希值的列表可能会增长到问题的大小。再加上生成哈希值所需的内存，我们稍后会讨论这一点，我们很可能遇到内存不足的情况。因此，我们将使用JPA将我们的搜索信息保存到一个简单、轻量级的数据库（SQLite）中，这将允许我们将数据保存到磁盘。它还将允许我们比反复迭代内存结构更有效地查询和过滤结果。
- en: 'Before we can make use of those APIs, we need to update our module descriptor
    to let the system know that we now require the persistence modules. Consider the
    following code snippet as an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用那些API之前，我们需要更新我们的模块描述符，让系统知道我们现在需要持久化模块。以下代码片段可以作为示例：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've declared to the system that we require both `javax.persistence` and `java.logging`,
    which we'll be using later. As we discussed in [Chapter 18](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml),
    *Managing Processes in Java*, if any of these modules are not present, the JVM
    instance will fail to start.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向系统声明我们需要`javax.persistence`和`java.logging`，我们稍后会使用。正如我们在第18章[管理Java中的进程](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml)中讨论的，如果这些模块中的任何一个不存在，JVM实例将无法启动。
- en: Perhaps the more important part of the module definition is the `exports` clause.
    With this line (there can be 0 or more of them), we're telling the system that
    we are exporting all of the types in the specified package. This line will allow
    our CLI module, which we'll get into later, to use the classes (as well as interfaces,
    enums, and so on, if we were to add any) in that module. If a type's package does
    not `export`, consuming modules will be unable to see the type, which we'll also
    demonstrate later.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 模块定义中可能更为重要的部分是`exports`子句。通过这一行（可能有一行或多行），我们告诉系统我们正在导出指定包中的所有类型。这一行将允许我们的CLI模块（我们稍后会讨论）使用该模块中的类（以及如果我们添加任何的话，还包括接口、枚举等）。如果一个类型的包没有`export`，那么消费模块将无法看到该类型，我们稍后也会演示这一点。
- en: 'With that understanding, let''s take a look at our constructor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点后，让我们看看我们的构造函数：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To configure the persistence unit, JPA typically uses a `persistence.xml` file.
    In our case, though, we'd like a bit more control over where the database file
    is stored. As you can see in the preceding code, we are constructing the JDBC
    URL using the `user.home` environment variable. We then store that in a `Map`
    using the JPA-defined key to specify the URL. This `Map` is then passed to the
    `createEntityManagerFactory` method, which overrides anything set in `persistence.xml`.
    This allows us to put the database in the home directory appropriate for the user's
    operating system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置持久化单元，JPA通常使用一个`persistence.xml`文件。然而，在我们的情况下，我们希望对数据库文件的存储位置有更多的控制。正如您在前面的代码中所看到的，我们正在使用`user.home`环境变量来构建JDBC
    URL。然后我们使用JPA定义的键将这个URL存储在一个`Map`中，以指定URL。这个`Map`随后被传递给`createEntityManagerFactory`方法，该方法覆盖了`persistence.xml`中设置的任何内容。这允许我们将数据库放在适合用户操作系统的家目录中。
- en: 'With our class constructed and configured, it''s time to take a look at how
    we''ll find duplicate files:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类构建和配置完成后，是时候看看我们如何找到重复的文件了：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our first step is to create a list of the `PathMatcher` instances based on the
    patterns specified by the user. A `PathMatcher` instance is a functional interface
    that is implemented by objects that attempt to match files and paths. Our instances
    are retrieved from the `FileSystems` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是根据用户指定的模式创建一个`PathMatcher`实例列表。`PathMatcher`实例是一个函数式接口，由尝试匹配文件和路径的对象实现。我们的实例是从`FileSystems`类中检索的。
- en: When requesting `PathMatcher`, we have to specify the globbing pattern. As can
    be seen in the first call to `map()`, we have to make an adjustment to what the
    user specified. Typically, a pattern mask is specified simply as something like
    `*.jpg`. However, a pattern mask like this won't work in a way that the user expects,
    in that it will only look in the current directory and not walk down into any
    subdirectories. To do that, the pattern must be prefixed with `**/`, which we
    do in the call to `map()`. With our adjusted pattern, we request the `PathMatcher`
    instance from the system's default `FileSystem`. Note that we specify the matcher
    pattern as `"glob:" + p` because we need to indicate that we are, indeed, specifying
    a `glob` file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求 `PathMatcher` 时，我们必须指定全局模式。正如在 `map()` 的第一次调用中可以看到的，我们必须调整用户指定的内容。通常，模式掩码简单地指定为类似
    `*.jpg` 的内容。然而，这样的模式掩码不会按用户期望的方式工作，它只会查看当前目录，而不会遍历任何子目录。为了做到这一点，模式必须以 `**/` 前缀开始，我们在
    `map()` 调用中这样做。使用调整后的模式，我们从系统的默认 `FileSystem` 请求 `PathMatcher` 实例。请注意，我们指定匹配器模式为
    `"glob:" + p`，因为我们确实需要表明我们正在指定一个 `glob` 文件。
- en: 'With our matchers prepared, we''re ready to start the search. We do that with
    this code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的匹配器准备就绪后，我们就可以开始搜索了。我们用以下代码来完成：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the `Stream` API, we map each source path to a lambda that creates an
    instance of `FindFileTask`, providing it the source path it will search. Each
    of these `FileFindTask` instances will then be passed to our `ExecutorService`
    via the `execute()` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Stream` API，我们将每个源路径映射到一个 lambda 表达式，该表达式创建一个 `FindFileTask` 实例，并提供它将搜索的源路径。这些
    `FileFindTask` 实例中的每一个都将通过 `execute()` 方法传递给我们的 `ExecutorService`。
- en: 'The `FileFindTask` method is the workhorse for this part of the process. It
    is a `Runnable` as we''ll be submitting this to the `ExecutorService`, but it
    is also a `FileVisitor<Path>` as it will be used in walking the file tree, which
    we do from the `run()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileFindTask` 方法是这个过程这一部分的工作马。它是一个 `Runnable`，因为我们将会将其提交给 `ExecutorService`，但它也是一个
    `FileVisitor<Path>`，因为它将会在遍历文件树时使用，我们从 `run()` 方法中执行这一操作：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we will be inserting data into the database via JPA, we'll need to start
    a transaction as our first step. Since this is an application-managed `EntityManager`,
    we have to manage the transaction manually. We acquire a reference to the `EntityTransaction`
    instance outside the `try/catch` block to simplify referencing it. Inside the
    `try` block, we start the transaction, start the file walking via `Files.walkFileTree()`,
    then commit the transaction if the process succeeds. If it fails--if an `Exception`
    was thrown--we roll back the transaction.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将会通过 JPA 将数据插入数据库，因此我们需要首先开始一个事务。由于这是一个应用程序管理的 `EntityManager`，我们必须手动管理事务。我们在
    `try/catch` 块之外获取 `EntityTransaction` 实例的引用，以简化对其的引用。在 `try` 块内部，我们开始事务，通过 `Files.walkFileTree()`
    开始文件遍历，如果过程成功，则提交事务。如果失败——如果抛出了 `Exception`——则回滚事务。
- en: 'The `FileVisitor` API requires a number of methods, most of which are not too
    terribly interesting, but we''ll show them for clarity''s sake:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileVisitor` API 需要实现许多方法，其中大多数并不特别有趣，但为了清晰起见，我们将展示它们：'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we tell the system that if the directory is readable, then we continue
    with walking down that directory. Otherwise, we skip it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉系统如果目录可读，则继续遍历该目录。否则，我们跳过它：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The API requires this method to be implemented, but we''re not very interested
    in file read failures, so we simply return a skip result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: API 要求实现这个方法，但我们并不非常关心文件读取失败，所以我们简单地返回一个跳过结果：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Much like the preceding method, this method is required, but we''re not interested
    in this particular event, so we signal the system to continue:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的方法类似，这个方法也是必需的，但我们对此特定事件不感兴趣，所以我们向系统发出继续的信号：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we''ve come to a method we''re interested in. We will check to make sure
    that the file is readable, then check to see if it''s a match. If it is, we add
    the file. Regardless, we continue walking the tree. How do we test if the file''s
    a match? Consider the following code snippet as an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了一个我们感兴趣的方法。我们将检查文件是否可读，然后检查它是否匹配。如果是，我们添加该文件。无论如何，我们继续遍历树。我们如何测试文件是否匹配？以下代码片段可以作为示例：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We iterate over the list of `PathMatcher` instances we passed in to the class
    earlier. If the `List` is empty, which means the user didn't specify any patterns,
    the method's result will always be `true`. However, if there are items in the
    `List`, we use the `anyMatch()` method on the `List`, passing a lambda that checks
    the `Path` against the `PathMatcher` instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历我们之前传递给类的`PathMatcher`实例列表。如果`List`为空，这意味着用户没有指定任何模式，那么该方法的结果始终是`true`。然而，如果有项目在`List`中，我们就在`List`上使用`anyMatch()`方法，传递一个检查`Path`是否与`PathMatcher`实例匹配的lambda表达式。
- en: 'Adding the file is very straightforward:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文件非常简单：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create a `FileInfo` instance, set the properties, then persist it to the
    database via `em.persist()`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`FileInfo`实例，设置属性，然后通过`em.persist()`将其持久化到数据库。
- en: 'With our tasks defined and submitted to `ExecutorService`, we need to sit back
    and wait. We do that with the following two method calls:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务定义并提交给`ExecutorService`后，我们需要坐下来等待。我们通过以下两个方法调用来实现这一点：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first step is to ask `ExecutorService` to shut down. The `shutdown()` method
    will return immediately, but it will instruct `ExecutorService` to refuse any
    new tasks, as well as shut down its threads as soon as they are idle. Without
    this step, the threads will continue to run indefinitely. Next, we will wait for
    the service to shut down. We specify the maximum wait time to make sure we give
    our tasks time to complete. Once this method returns, we''re ready to process
    the results, which is done in the following `postProcessFiles()` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是要求`ExecutorService`关闭。`shutdown()`方法将立即返回，但它将指示`ExecutorService`拒绝任何新任务，并在它们空闲时关闭其线程。如果没有这一步，线程将继续无限期地运行。接下来，我们将等待服务关闭。我们指定最大等待时间以确保我们给任务足够的时间完成。一旦这个方法返回，我们就准备好处理结果，这将在下面的`postProcessFiles()`方法中完成：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Modern database access with JPA
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPA的现代数据库访问
- en: Let's stop here for a moment. Remember our discussion of the **Java Persistence
    API** (**JPA**) and database? Here is where we see that coming in. With the JPA,
    interactions with the database are done via the `EntityManager` interface, which
    we retrieve from the cleverly named `EntityManagerFactory`. It is important to
    note that the `EntityManager` instances are not thread-safe, so they should not
    be shared between threads. That's why we didn't create one in the constructor
    and pass it around. This is, of course, a local variable, so we need not worry
    about that too much until, and if, we decide to pass it as a parameter to another
    method, which we are doing here. As we will see in a moment, everything happens
    in the same thread, so we will not have to worry about thread-safety issues as
    the code stands now.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里暂停一下。还记得我们关于**Java持久化API**（**JPA**）和数据库的讨论吗？这里就是我们看到它的地方。使用JPA，与数据库的交互是通过`EntityManager`接口完成的，我们从巧妙命名的`EntityManagerFactory`中检索它。需要注意的是，`EntityManager`实例不是线程安全的，因此它们不应该在线程之间共享。这就是为什么我们没有在构造函数中创建一个并传递它的原因。这当然是一个局部变量，所以我们不需要太担心，直到我们决定将其作为参数传递给另一个方法，这正是我们现在正在做的。正如我们一会儿将看到的，所有事情都在同一个线程中发生，所以我们现在不需要担心线程安全问题。
- en: 'With our `EntityManager`, we call the `getDuplicates()` method and pass the
    manager and field name, `fileName`. This is what that method looks like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`EntityManager`，我们调用`getDuplicates()`方法，并传递管理器和字段名，`fileName`。这个方法看起来是这样的：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a fairly straightforward use of the Java Persistence API--we're creating
    a query and telling it that we want, and getting a `List` of `FileInfo` references
    back. The `createQuery()` method creates a `TypedQuery` object, on which we will
    call `getResultList()` to retrieve the results, which gives us `List<FileInfo>`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Java持久化API的一个相当直接的使用——我们创建一个查询，并告诉它我们想要什么，然后返回一个`FileInfo`引用的`List`。`createQuery()`方法创建一个`TypedQuery`对象，我们将调用`getResultList()`来检索结果，这给我们`List<FileInfo>`。
- en: Before we go any further, we need to have a short primer on the Java Persistence
    API. JPA is what is known as an **object-relational mapping** (**ORM**) tool.
    It provides an object-oriented, type-safe, and database-independent way of storing
    data in, typically, a relational database. The specification/library allows application
    authors to define their data models using concrete Java classes, then persist
    and/or read them with little thought about the mechanics specific to the database
    currently being used. (The developer isn't completely shielded from database concerns--and
    it's arguable as to whether or not he or she should be--but those concerns are
    greatly lessened as they are abstracted away behind the JPA interfaces). The process
    of acquiring a connection, creating the SQL, issuing it to the server, processing
    results, and more are all handled by the library, allowing a greater focus on
    the business of the application rather than the plumbing. It also allows a high
    degree of portability between databases, so applications (or libraries) can be
    easily moved from one system to another with minimal change (usually restricted
    to configuration changes).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要对Java持久化API有一个简短的介绍。JPA被称为**对象关系映射**（**ORM**）工具。它提供了一种面向对象、类型安全和数据库无关的方式来存储数据，通常是在关系型数据库中。该规范/库允许应用程序作者使用具体的Java类来定义他们的数据模型，然后通过JPA接口持久化和/或读取它们，而无需过多考虑当前使用的数据库的具体机制。（开发者并不完全免于数据库的担忧——这一点是有争议的——但通过JPA接口抽象，这些担忧大大减少）。获取连接、创建SQL语句、将其发送到服务器、处理结果等过程都由库来处理，使得开发者可以更多地关注应用程序的业务，而不是底层架构。它还允许数据库之间有高度的便携性，因此应用程序（或库）可以轻松地从一种系统移动到另一种系统，只需进行最小更改（通常限于配置更改）。
- en: At the heart of JPA is `Entity`, the business object (or domain model, if you
    prefer) that models the data for the application. This is expressed in the Java
    code as a **plain old Java object** (**POJO**), which is marked up with a variety
    of annotations. A complete discussion of all of those annotations (or the API
    as a whole) is outside the scope of this book, but we'll use enough of them to
    get you started.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JPA的核心是`Entity`，它是业务对象（如果你更喜欢，可以称为领域模型）的数据模型。在Java代码中，这表现为一个**普通的Java对象**（**POJO**），并用各种注解进行标记。对所有这些注解（或整个API）的完整讨论超出了本书的范围，但我们将使用足够多的它们来帮助你入门。
- en: 'With that basic explanation given, let''s take a look at our one and only entity--the
    `FileInfo` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在给出这个基本解释之后，让我们来看看我们唯一的实体——`FileInfo`类：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This class has five properties. The only one that needs special attention is
    `id`. This property holds the primary key value for each row, so we annotate it
    with `@Id`. We also annotate this field with `@GeneratedValue` to indicate that
    we have a simple primary key for which we''d like the system to generate a value.
    This annotation has two properties: `strategy` and `generator`. The default value
    for strategy is `GenerationType.AUTO`, which we happily accept here. Other options
    include `IDENTITY`, `SEQUENCE`, and `TABLE`. In more complex uses, you may want
    to specify a strategy explicitly, which allows you to fine-tune how the key is
    generated (for example, the starting number, the allocation size, the name of
    the sequence or table, and so on). By choosing `AUTO`, we''re telling JPA to choose
    the appropriate generation strategy for our target database. If you specify a
    strategy other than `AUTO`, you will also need to specify the details for the
    generator, using `@SequenceGenerator` for `SEQUENCE` and `@TableGenerator` for
    `TABLE`. You will also need to give the ID of the generator to the `@GeneratedValue`
    annotation using the generator attribute. We''re using the default, so we need
    not specify a value for this attribute.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有五个属性。唯一需要特别注意的属性是`id`。这个属性包含每行的主键值，所以我们用`@Id`来标注它。我们还用`@GeneratedValue`来标注这个字段，表示我们有一个简单的主键，希望系统生成值。这个注解有两个属性：`strategy`和`generator`。策略的默认值是`GenerationType.AUTO`，我们在这里愉快地接受它。其他选项包括`IDENTITY`、`SEQUENCE`和`TABLE`。在更复杂的使用中，你可能需要明确指定一个策略，这允许你微调键的生成方式（例如，起始数字、分配大小、序列或表名等）。通过选择`AUTO`，我们告诉JPA为我们的目标数据库选择合适的生成策略。如果你指定了除`AUTO`之外的其他策略，你还需要使用`@SequenceGenerator`为`SEQUENCE`和`@TableGenerator`为`TABLE`指定生成器的详细信息。你还需要使用生成器属性将生成器的ID提供给`@GeneratedValue`注解。我们使用默认值，因此不需要指定此属性的值。
- en: The next four fields are the pieces of data we have identified that we need
    to capture. Note that if we do not need to specify anything special about the
    mapping of these fields to the database columns, no annotations are necessary.
    However, if we would like to change the defaults, we can apply the `@Column` annotation
    and set the appropriate attribute, which can be one or more of `columnDefinition`
    (used to help generate the DDL for the column), `insertable`, `length`, `name`,
    `nullable`, `precision`, `scale`, `table`, `unique`, and `updatable`. Again, we're
    happy with the defaults.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个字段是我们已经识别出需要捕获的数据项。请注意，如果我们不需要对这些字段映射到数据库列的任何特殊指定，则不需要进行注释。然而，如果我们想更改默认值，我们可以应用`@Column`注释并设置适当的属性，这些属性可以是`columnDefinition`（用于帮助生成列的DDL）、`insertable`、`length`、`name`、`nullable`、`precision`、`scale`、`table`、`unique`和`updatable`中的一个或多个。再次强调，我们对默认值感到满意。
- en: JPA also requires each property to have a getter and a setter; the specification
    seems to be worded oddly, which has led to some ambiguity as to whether or not
    this is a hard requirement, and different JPA implementations handle this differently,
    but it's certainly safer to provide both as a matter of practice. If you need
    a read-only property, you can experiment with either no setter, or simply a no-op
    method. We haven't shown the getters and setters here, as there is nothing interesting
    about them. We have also omitted the IDE-generated `equals()` and `hashCode()`
    methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JPA还要求每个属性都有一个getter和setter；规范似乎措辞有些奇怪，这导致了对是否这是一个硬性要求存在一些歧义，不同的JPA实现处理方式不同，但出于实践考虑，提供这两个确实是更安全的。如果你需要一个只读属性，你可以尝试不设置setter，或者简单地设置一个无操作方法。我们没有在这里展示getter和setter，因为它们没有什么有趣的地方。我们还省略了IDE生成的`equals()`和`hashCode()`方法。
- en: 'To help demonstrate the module system, we''ve put our entity in a `com.steeplesoft.dupefind.lib.model`
    subpackage. We''ll tip our hand a bit and go ahead and announce that this class
    will be used by both our CLI and GUI modules, so we''ll need to update our module
    definition as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助展示模块系统，我们将我们的实体放在了`com.steeplesoft.dupefind.lib.model`子包中。我们将提前透露一点，这个类将由我们的CLI和GUI模块共同使用，因此我们需要更新我们的模块定义如下：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That''s all there is to our entity, so let''s turn our attention back to our
    application logic. The `createQuery()` call deserves a bit of discussion. Typically,
    when using JPA, queries are written in what is called **JPAQL** (**Java Persistence
    API Query Language**). It looks very much like SQL, but has a more object-oriented
    feel to it. For example, if we wanted to query for every `FileInfo` record in
    the database, we would do so with this query:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的实体所需要的一切，所以让我们将注意力转回到我们的应用程序逻辑上。`createQuery()`调用值得讨论。通常，当使用JPA时，查询是用所谓的**JPAQL**（**Java
    Persistence API Query Language**）编写的。它看起来非常像SQL，但它有更多的面向对象的感觉。例如，如果我们想查询数据库中每个`FileInfo`记录，我们会用这个查询来做：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I have put the keywords in all caps, with variable names in lower and the entity
    name in camel case. This is mostly a matter of style, but while most identifiers
    are case-insensitive, JPA does require that the case on the entity name matches
    that of the Java class it represents. You must also specify an alias, or identification
    variable, for the entity, which we simply call `f`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我将关键字全部大写，变量名小写，实体名驼峰式。这主要是一个风格问题，但尽管大多数标识符不区分大小写，JPA确实要求实体名称的大小写与它所代表的Java类的大小写相匹配。你还必须指定一个别名，或识别变量，对于实体，我们简单地称之为`f`。
- en: 'To get a specific `FileInfo` record, you can specify a `WHERE` clause as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取特定的`FileInfo`记录，你可以指定一个如下所示的`WHERE`子句：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this query, we can filter the query just as SQL does, and, just like SQL,
    we specify a positional parameter. The parameter can either be a name, like we''ve
    done here, or simply a `?`. If you use a name, you set the parameter value on
    the query using that name. If you use the question mark, you must set the parameter
    using its index in the query. For small queries, this is usually fine, but for
    larger, more complex queries, I would suggest using names so that you don''t have
    to manage index values, as that''s almost guaranteed to cause a bug at some point.
    Setting the parameter can look something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个查询，我们可以像SQL一样过滤查询，并且，就像SQL一样，我们指定一个位置参数。参数可以是名称，就像我们在这里所做的那样，或者简单地是一个`?`。如果你使用名称，你将使用该名称在查询上设置参数值。如果你使用问号，你必须使用其在查询中的索引来设置参数。对于小型查询，这通常没问题，但对于更大、更复杂的查询，我建议使用名称，这样你就不必管理索引值，因为这几乎肯定会引起某个时刻的bug。设置参数可能看起来像这样：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With that said, let''s take a look at our query:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来看看我们的查询：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This query is moderately complicated, so let's break it down and see what's
    going on. First, in our `SELECT` query, we will specify only `f`, which is the
    identification variable of the entity for which we are querying. Next, we are
    selecting from a regular table and a temporary table, which is defined by the
    subselect in the `FROM` clause. Why are we doing it this way? We need to identify
    all of the rows that have a duplicate value (`fileName`, `size`, or `hash`). To
    do that, we use a `HAVING` clause with the `COUNT` aggregation function, `HAVING
    (COUNT(fieldName > 1))` which says, in effect, give me all of the rows where this
    field occurs more than one time. The `HAVING` clause requires a `GROUP BY` clause,
    and once that's done, all of the rows with duplicate values are aggregated down
    to a single row. Once we have that list of rows, we will then join the real (or
    physical) table to those results to filter our physical table. Finally, we filter
    out the null fields in the `WHERE` clause, then order by `fileName` and `path`
    so that we don't have to do that in our Java code, which is likely to be less
    efficient than it would be if done by the database--a system designed for such
    operations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询相当复杂，所以让我们分解一下，看看发生了什么。首先，在我们的`SELECT`查询中，我们将只指定`f`，这是我们正在查询的实体的标识变量。接下来，我们从常规表和临时表中选择，这是由`FROM`子句中的子查询定义的。我们为什么要这样做呢？我们需要识别所有具有重复值（`fileName`、`size`或`hash`）的行。为了做到这一点，我们使用了一个带有`COUNT`聚合函数的`HAVING`子句，`HAVING
    (COUNT(fieldName) > 1)`实际上意味着给我所有这个字段出现超过一次的行。`HAVING`子句需要一个`GROUP BY`子句，一旦完成，所有具有重复值的行都会聚合到一行。一旦我们有了这些行的列表，我们就会将真实（或物理）表与这些结果连接起来，以过滤我们的物理表。最后，我们在`WHERE`子句中过滤掉空字段，然后按`fileName`和`path`排序，这样我们就不需要在Java代码中这样做，这可能会比由数据库完成要低效——数据库是为这类操作设计的系统。
- en: You should also note the `%FIELD%` attribute in the SQL. We'll run the same
    query for multiple fields, so we've written the query once, and placed a marker
    in the text that we will replace with the desired field, which is sort of a *poor
    man's* template. There are, of course, a variety of ways to do this (and you may
    have one you find superior), but this is simple and easy to use, so it's perfectly
    acceptable in this environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意SQL中的`%FIELD%`属性。我们将为多个字段运行相同的查询，因此我们已经编写了一次查询，并在文本中放置了一个标记，我们将用所需的字段替换它，这有点像一种*穷人的*模板。当然，有各种各样的方法可以做到这一点（你可能有一个你认为更好的方法），但这种方法简单易用，所以在这个环境中完全可接受。
- en: We should also note that it is, generally speaking, a very bad idea to either
    concatenate SQL with values or do string replacements like we're doing, but our
    scenario is a bit different. If we were accepting user input and inserting that
    into the SQL this way, then we would certainly have a target for an SQL injection
    attack. In our use here, though, we aren't taking input from users, so this approach
    should be perfectly safe. In terms of database performance, this shouldn't have
    any adverse effects either. While we will require three different hard parses
    (one for each field by which we will filter), this is no different than if we
    were hardcoding the queries in our source file. Both of those issues, as well
    as many more, are always good to consider as you write your queries (and why I
    said the developer is mostly shielded from database concerns).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意的是，一般来说，将SQL与值连接或像我们这样做字符串替换是一个非常糟糕的想法，但我们的场景略有不同。如果我们接受用户输入并以这种方式将其插入SQL中，那么我们肯定会成为SQL注入攻击的目标。然而，在我们的使用中，我们并没有从用户那里获取输入，所以这种方法应该是完全安全的。在数据库性能方面，这也不应该有任何不利影响。虽然我们需要进行三次不同的硬解析（每个字段一次），但这与我们硬编码源文件中的查询没有区别。这两个问题以及许多其他问题，在你编写查询时总是值得考虑的（这就是为什么我说开发者主要被屏蔽在数据库问题之外）。
- en: 'All of that gets us through the first step, which is identifying all of the
    files that have the same name. We now need to identify the files that have the
    same size, which can be done using the following piece of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都帮助我们完成了第一步，即识别所有具有相同名称的文件。我们现在需要识别具有相同大小的文件，这可以通过以下代码片段来完成：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our call to find duplicate filenames, we declared a local variable, `files`,
    to store those results. In finding files with duplicate sizes, we call the same
    `getDuplicates()` method, but with the correct field name, and simply add that
    to `files` via the `List.addAll()` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用查找重复文件名时，我们声明了一个局部变量`files`来存储这些结果。在查找具有重复大小的文件时，我们调用相同的`getDuplicates()`方法，但使用正确的字段名，并通过`List.addAll()`方法将其添加到`files`中。
- en: 'We now have a complete list of all of the possible duplicates, so we need to
    generate the hashes for each of these to see if they are truly duplicates. We
    will do that with this loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个所有可能重复项的完整列表，因此我们需要为这些中的每一个生成哈希，以查看它们是否真的是重复的。我们将使用这个循环来完成：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a nutshell, we start a transaction (since we'll be inserting data into the
    database), then loop over each possible duplicate via `List.forEach()` and a lambda
    that calls `calculateHash(f)`, and then pass the `FileInfo` instance. Once the
    loop terminates, we commit the transaction to save our changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们开始一个事务（因为我们将在数据库中插入数据），然后通过`List.forEach()`和调用`calculateHash(f)`的lambda表达式遍历每个可能的重复项，并传递`FileInfo`实例。一旦循环结束，我们就提交事务以保存我们的更改。
- en: 'What does `calculateHash()` do? Let''s a take a look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateHash()`函数做什么？让我们看看：'
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This simple method encapsulates the work required to read the contents of a
    file and generate a hash. It requests an instance of `MessageDigest` using the
    `SHA3-256` hash, which is one of the four new hashes supported by Java 9 (the
    other three being `SHA3-224`, `SHA3-384`, and `SHA3-512`). Many developers' first
    thought is to reach for MD-5 or SHA-1, but those are no longer considered reliable.
    Using the new SHA-3 should guarantee we avoid any false positives.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法封装了读取文件内容并生成哈希所需的工作。它使用`SHA3-256`哈希请求`MessageDigest`实例，这是Java 9支持的四种新哈希之一（其他三种是`SHA3-224`、`SHA3-384`和`SHA3-512`）。许多开发者的第一反应是去抓取MD-5或SHA-1，但它们现在不再被认为是可靠的。使用新的SHA-3应该可以保证我们避免任何假阳性。
- en: The rest of the method is pretty interesting in terms of how it does its work.
    First, it reads all of the bytes of the specified file and passes them to `MessageDigest.update()`,
    which updates the internal state of the `MessageDigest` object to give us the
    hash we want. Next, we create a `ByteArrayInputStream` that wraps the results
    of `messageDigest.digest()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的其他部分在如何执行其工作方面非常有趣。首先，它读取指定文件的所有字节，并将它们传递给`MessageDigest.update()`，这将更新`MessageDigest`对象的内部状态，以给我们想要的哈希。接下来，我们创建一个`ByteArrayInputStream`，它包装了`messageDigest.digest()`的结果。
- en: With our hash ready, we generate a string based on those bytes. We will do that
    by generating a stream via the `IntStream.generate()` method using the `InputStream`
    we just created as a source. We will limit the stream generation to the bytes
    available in the `inputStream`. For each byte, we will convert it to a string
    via `Integer.toHexString()`; then pad it with zero to two spaces, which prevents,
    for example, the single-digit hex characters `E` and `F` from being interpreted
    as `EF`; then collect them all into a string using `Collections.joining()`. Finally,
    we take that string value and update the `FileInfo` object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的哈希准备好后，我们将基于这些字节生成一个字符串。我们将通过使用我们刚刚创建的`InputStream`作为源的`IntStream.generate()`方法来生成一个流。我们将流生成限制在`inputStream`中可用的字节。对于每个字节，我们将通过`Integer.toHexString()`将其转换为字符串；然后使用零到两个空格进行填充，这防止了例如单个十六进制字符`E`和`F`被解释为`EF`；然后使用`Collections.joining()`将它们全部收集到一个字符串中。最后，我们更新`FileInfo`对象。
- en: 'The eagle-eyed might notice something interesting: we call `FileInfo.setHash()`
    to change the value of the object, but we never tell the system to persist those
    changes. This is because our `FileInfo` instance is a managed instance, meaning
    that we got it from JPA, which is keeping an eye on it, so to speak. Since we
    retrieved it via JPA, when we make any changes to its state, JPA knows it needs
    to persist those changes. When we call `em.getTransaction().commit()` in the calling
    method, JPA automatically saves those changes to the database.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 灵敏的读者可能会注意到一些有趣的地方：我们调用`FileInfo.setHash()`来改变对象的价值，但我们从未告诉系统持久化这些更改。这是因为我们的`FileInfo`实例是一个受管理的实例，意味着我们是从JPA获取的，JPA在某种程度上正在关注它。由于我们是通过JPA检索的，当我们对其状态进行任何更改时，JPA知道它需要持久化这些更改。当我们调用调用方法中的`em.getTransaction().commit()`时，JPA会自动将这些更改保存到数据库中。
- en: 'There''s a catch to this automatic persistence: if you retrieve an object via
    JPA, then pass it across some sort of barrier that serializes the object, for
    example, across a remote EJB interface, then the JPA entity is said to be "detached".
    To reattach it to the persistence context, you will need to call `entityManager.
    merge()`, after which this behavior will resume. There is no need to call `entityManager.flush()`
    unless you have some need to synchronize the in-memory state of the persistence
    context with the underlying database.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动持久化的一个问题是：如果你通过 JPA 获取一个对象，然后通过某种序列化对象的方式（例如，通过远程 EJB 接口）传递它，那么 JPA 实体就被说成是“分离的”。为了将其重新附加到持久化上下文中，你需要调用
    `entityManager.merge()`，之后这种行为将恢复。除非你需要将持久化上下文的内存状态与底层数据库同步，否则不需要调用 `entityManager.flush()`。
- en: 'Once we''ve calculated the hashes for the potential duplicates (at this point,
    given that they have duplicate SHA-3 hashes, they are almost certainly actual
    duplicates), we''re ready to gather and report them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算了潜在重复项的哈希值（在这个阶段，鉴于它们有重复的 SHA-3 哈希，它们几乎肯定是实际重复项），我们就准备好收集和报告它们：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We call the same `getDuplicates()` method to find duplicate hashes, and pass
    each record to the `coalesceDuplicates()` method, which will group these in a
    manner appropriate to report upstream to our CLI or GUI layers, or, perhaps, to
    any other program consuming this functionality:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用相同的 `getDuplicates()` 方法来查找重复的哈希值，并将每个记录传递给 `coalesceDuplicates()` 方法，该方法将以适当的方式将这些分组，以便报告给我们的
    CLI 或 GUI 层，或者，也许，给任何其他消费此功能的程序：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This simple method follows what is likely a very familiar pattern:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法遵循了一个可能非常熟悉的模式：
- en: Get a `List` from a `Map` based on the key, the filename.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 key，即文件名，从 `Map` 中获取 `List`。
- en: If the map doesn't exist, create it and add it to the map.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果映射不存在，则创建它并将其添加到映射中。
- en: Add the `FileInfo` object to the list.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FileInfo` 对象添加到列表中。
- en: This completes the duplicate file detection. Back in `find()`, we will call
    `factory.close()` to be a good JPA citizen, then return to the calling code. With
    that, we're ready to build our CLI.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了重复文件检测。回到 `find()`，我们将调用 `factory.close()` 以成为一个好的 JPA 公民，然后返回到调用代码。有了这个，我们就准备好构建我们的
    CLI。
- en: Building the command-line interface
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建命令行界面
- en: 'The primary means to interact with our new library will be the command-line
    interface we will now develop. Unfortunately, the Java SDK has nothing built in
    to help make sophisticated command-line utilities. If you''ve been using Java
    for any time, you''ve seen the following method signature:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们新库交互的主要方式将是我们现在将要开发的命令行界面。不幸的是，Java SDK 内置的功能无法帮助我们创建复杂的命令行工具。如果你使用过 Java
    任何时间，你一定见过以下的方法签名：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Clearly, there is *a* mechanism to process command-line arguments. The `public
    static void main` method is passed string arrays that represent arguments provided
    by the user on the command line, but that''s about as far as it goes. To parse
    the options, the developer is required to iterate over the array, analyzing each
    entry. It might look something like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，存在一种处理命令行参数的机制。`public static void main` 方法接收代表用户在命令行提供的字符串数组的参数，但这只是开始。为了解析选项，开发者需要遍历数组，分析每个条目。它可能看起来像这样：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is an effective solution, if very naive and error-prone. It assumes that
    whatever follows `--source` and `--target` is that argument's value. If the user
    types `--source --target /foo`, then our processor breaks. Clearly, something
    better is needed. Fortunately, we have options.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的解决方案，尽管非常简单且容易出错。它假设跟随 `--source` 和 `--target` 的任何内容都是该参数的值。如果用户输入 `--source
    --target /foo`，那么我们的处理器就会崩溃。显然，我们需要更好的解决方案。幸运的是，我们有选择。
- en: 'If you were to search for Java command-line libraries, you''ll find an abundance
    of them (at least 10 at last count). Our space (and time) is limited here, so
    we obviously can''t discuss all of them, so I''ll mention the first three that
    I''m familiar with: Apache Commons CLI, Airline, and Crest. Each of these has
    some fairly significant differences from its competitors.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你搜索 Java 命令行库，你会找到很多（至少最后统计有 10 个）。我们的空间（和时间）是有限的，所以我们显然不能讨论所有这些库，所以我将提到我熟悉的第一个三个：Apache
    Commons CLI、Airline 和 Crest。它们中的每一个与竞争对手都有一些相当显著的不同。
- en: 'Commons CLI takes a more procedural approach; the list of available options,
    its name, description, whether or not it has arguments, and so forth, are all
    defined using Java method calls. Once the list of `Options` has been created,
    the command-line arguments are then manually parsed. The preceding example could
    be rewritten as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Commons CLI采用更程序化的方法；可用的选项列表、其名称、描述、是否有参数等等，都是通过Java方法调用来定义的。一旦创建了`Options`列表，然后手动解析命令行参数。前面的例子可以重写如下：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's certainly more verbose, but it's also clearly, I think, more robust. We
    can specify long and short names for the option (`--source` versus `-s`), we can
    give it a description, and, best of all, we get built-in validation that an option
    has its required value. As much of an improvement as this is, I've learned from
    experience that the procedural approach here gets tedious in practice. Let's take
    a look at our next candidate to see how it fares.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实更加冗长，但我认为它也更清晰，更健壮。我们可以指定选项的长名和短名（例如`--source`与`-s`），我们可以为其提供描述，而且最好的是，我们得到了内置的验证，确保选项有它所需的价值。尽管这是一个很大的改进，但根据经验，我了解到这里的程序方法在实践中会变得繁琐。让我们看看下一个候选人，看看它的表现如何。
- en: 'Airline is a command-line library originally written as part of the airlift
    organization on GitHub. After languishing for some time, it was forked by Rob
    Vesse and given a new life ([http://rvesse.github.io/airline](http://rvesse.github.io/airline)).
    Airline''s approach to command-line definition is more class-based--to define
    a command utility, you declare a new class, and mark it up appropriately with
    a number of annotations. Let''s implement our preceding simple command line with
    Airline:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Airline是一个命令行库，最初是GitHub上airlift组织的一部分。经过一段时间的不活跃后，它被Rob Vesse分叉并赋予了新的生命([http://rvesse.github.io/airline](http://rvesse.github.io/airline))。Airline对命令行定义的方法更基于类——要定义一个命令工具，你需要声明一个新的类，并使用多个注解来适当标记。让我们用Airline实现前面的简单命令行：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The options handling continues to grow in terms of code size, but we're also
    gaining more and more clarity as to what options are supported, and what they
    each mean. Our command is clearly defined via `@Command` on the class declaration.
    The possible options are delineated as `@Option`--annotated instance variables,
    and the business logic in `run()` is completely devoid of command-line parsing
    code. By the time this method is called, all the data has been extracted and we're
    ready to do our work. That looks very nice, but let's see what our last contender
    has to offer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 选项处理在代码量上持续增长，但我们也越来越清晰地了解到支持哪些选项，以及它们各自的意义。我们的命令通过类声明中的`@Command`明确定义。可能的选项以`@Option`注解的实例变量来界定，而`run()`方法中的业务逻辑完全不含命令行解析代码。当这个方法被调用时，所有数据已经被提取，我们准备开始工作。这看起来非常不错，但让我们看看最后一个竞争者能提供什么。
- en: 'Crest is a library from Tomitribe, the company behind TomEE, the "all-Apache
    Java EE Web Profile certified stack" based on the venerable Tomcat Servlet container.
    Crest''s approach to command definition is method based, where you define a method
    per command. It also uses annotations, and offers Bean Validation out of the box,
    as well as optional command discovery. Reimplementing our simple command, then,
    may look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Crest是Tomitribe公司的一个库，该公司是TomEE背后的公司，TomEE是基于备受尊敬的Tomcat Servlet容器的“所有Apache
    Java EE Web Profile认证堆栈”。Crest对命令定义的方法是基于方法的，其中每个命令定义一个方法。它也使用注解，并提供开箱即用的Bean
    Validation以及可选的命令发现。因此，重新实现我们的简单命令可能看起来像这样：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That seems to be the best of both worlds: it''s nice and concise, and will
    still keep the actual logic of the command free from any CLI-parsing concerns,
    unless you''re bothered by the annotations on the method. Although the actual
    logic-implementing code is free from such concerns. While Airline and Crest both
    offer things the other does not, Crest wins for me, so that''s what we''ll use
    to implement our command-line interface.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是两者的最佳结合：既简洁又清晰，并且仍然会保持命令的实际逻辑不受任何CLI解析问题的干扰，除非你介意方法上的注解。尽管实际实现逻辑的代码不受此类问题的干扰。虽然Airline和Crest都提供了对方没有的东西，但Crest对我来说是胜出的，所以我们将使用它来实现我们的命令行界面。
- en: With a library chosen, then, let's take a look at what our CLI might look like.
    Most importantly, we need to be able to specify the path (or paths) we want to
    search. Likely, most files in those paths will have the same extension, but that
    certainly won't always be the case, so we want to allow the user to specify only
    the file patterns to match (for example, `.jpg`). Some users might also be curious
    about how long it takes to run the scan, so let's throw in a switch to turn on
    that output. And finally, let's add a switch to make the process a bit more verbose.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 选择了一个库之后，让我们来看看我们的 CLI 可能的样子。最重要的是，我们需要能够指定我们想要搜索的路径（或路径）。很可能会发现这些路径中的大多数文件具有相同的扩展名，但这肯定不会总是如此，因此我们希望允许用户仅指定要匹配的文件模式（例如，`.jpg`）。一些用户可能也对运行扫描所需的时间感兴趣，所以让我们添加一个开关来开启该输出。最后，让我们添加一个开关来使过程更加详细。
- en: With our functional requirements set, let's start writing our command. Crest
    is method-based in its command declarations, but we'll still need a class to put
    our method in. If this CLI were more complicated (or, for example, if you were
    writing a CLI for an application server), you could easily put several CLI commands
    in the same class, or group similar commands in several different classes. How
    you structure them is completely your concern, as Crest is happy with whatever
    you choose.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好功能需求后，让我们开始编写我们的命令。Crest 在命令声明中是基于方法的，但我们需要一个类来放置我们的方法。如果这个 CLI 更复杂（或者，例如，如果你正在为应用程序服务器编写
    CLI），你可以很容易地将多个 CLI 命令放在同一个类中，或者将类似的命令分组在几个不同的类中。它们的结构完全取决于你，因为 Crest 对你的选择都很满意。
- en: 'We''ll start with our CLI interface declaration as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 CLI 接口声明开始，如下所示：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Before we can discuss the preceding code, we need to declare our Java module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论前面的代码之前，我们需要声明我们的 Java 模块：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've defined a new module, which is named similarly to our library's module
    name. We also declared that we `require` two Crest modules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个新的模块，其名称与我们的库模块名称相似。我们还声明了我们 `require` 两个 Crest 模块。
- en: Back to our source code, we have the four parameters that we discussed in our
    functional requirements. Note that `patterns` and `paths` are defined as `List<String>`.
    When Crest is parsing the command line, if it finds multiple instances of one
    of these (for example, `--path=/path/one--path=/path/two`), it will collect all
    of these values and store them as a `List` for you. Also, note that `verbose`
    and `showTimings` are defined as `boolean`, so we see a nice example of the type
    coercion that Crest will do on our behalf. We also have default values for both
    of these, so we're sure to have sane, predictable values when our method executes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的源代码，我们有我们在功能需求中讨论的四个参数。请注意，`patterns` 和 `paths` 被定义为 `List<String>`。当 Crest
    解析命令行时，如果它发现这些中的一个有多个实例（例如，`--path=/path/one--path=/path/two`），它将收集所有这些值并将它们存储为一个
    `List`。此外，请注意，`verbose` 和 `showTimings` 被定义为 `boolean`，因此我们看到了一个很好的例子，说明 Crest
    将代表我们执行类型强制转换。我们为这两个都设置了默认值，因此当我们的方法执行时，我们确保有合理、可预测的值。
- en: 'The business logic of the method is pretty straightforward. We will handle
    the verbose flag upfront, printing a summary of the operation requested as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的业务逻辑相当简单。我们将首先处理详细模式标志，按照以下方式打印出请求的操作摘要：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we will perform the actual work. Thanks to the work we did building the
    library, all of the logic for the duplicate search is hidden away behind our API:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将执行实际的工作。多亏了我们构建库的工作，所有重复搜索的逻辑都隐藏在我们的 API 后面：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code won''t compile at first, as we''ve not told the system we need it.
    We can do that now:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码最初无法编译，因为我们没有告诉系统我们需要它。我们现在可以这样做：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now import the `FileFinder` class. First, to demonstrate that the modules
    are, in fact, doing what they''re supposed to do, let''s try to import something
    that wasn''t exported: `FindFileTask`. Let''s create a simple class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以导入 `FileFinder` 类。首先，为了证明这些模块确实在执行它们应该做的事情，让我们尝试导入一些未导出的内容：`FindFileTask`。让我们创建一个简单的类：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we try to compile this, Maven/javac will complain loudly with an error message
    like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译这个，Maven/javac 将会大声抱怨，错误信息如下：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We have successfully hidden our utility classes while exposing our public API.
    It may take some time for this practice to become widespread, but it should work
    wonders in preventing the crystallization of private APIs as pseudo-public.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功隐藏了我们的实用工具类，同时公开了我们的公共 API。这种做法可能需要一段时间才能普及，但它应该能够神奇地防止私有 API 作为伪公共 API
    的结晶。
- en: Back on task, we create an instance of our `FileFinder` class, use `String.forEach`
    to pass our `paths` and `patterns` to the finder, then start the work with a call
    to `find()`. The work itself is threaded, but we've exposed a synchronous API,
    so our call here will block until the work has been completed. Once it returns,
    we start printing details to the screen. Since `FindFiles.getDuplicates()` returns
    `Map<String, List<FileInfo>>`, we call `forEach()` on the `Map` to iterate over
    each key, then we call `forEach()` on the `List` to print information about each
    file. We also use an `AtomicInteger` as the index, as the variable must be final
    or effectively final, so we just use a `final` instance of `AtomicInteger`. `BigInteger`
    may come to mind to more experienced developers, but it's immutable, so that makes
    it a poor choice for our use here.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回到任务，我们创建了一个`FileFinder`类的实例，使用`String.forEach`将我们的`paths`和`patterns`传递给查找器，然后通过调用`find()`开始工作。这项工作本身是线程化的，但我们提供了一个同步API，所以这里的调用将会阻塞，直到工作完成。一旦返回，我们就开始向屏幕打印详细信息。由于`FindFiles.getDuplicates()`返回`Map<String,
    List<FileInfo>>`，我们在`Map`上调用`forEach()`来遍历每个键，然后我们在`List`上调用`forEach()`来打印每个文件的信息。我们还使用了一个`AtomicInteger`作为索引，因为这个变量必须是final或实际上是final的，所以我们只使用一个`final`的`AtomicInteger`实例。对于更有经验的开发者来说，可能会想到`BigInteger`，但它是不变的，所以它在这里不是一个好的选择。
- en: 'The output of running the command will look something like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令的输出将类似于以下内容：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we handle `showTimings`. I didn''t call it out in the preceding code,
    though I will now, but we get an `Instant` instance (from the Java 8 date/time
    library in `java.time`) before and after processing. Only when `showTimings` is
    true do we actually do anything with them. The code that does that looks like
    this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理`showTimings`。虽然我在前面的代码中没有提到它，但现在我会提到，我们在处理前后获取一个`Instant`实例（来自`java.time`库的Java
    8日期/时间库）。只有当`showTimings`为true时，我们才会实际对它们进行处理。执行此操作的代码如下所示：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With our two `Instant`, we get a `Duration`, then start calculating hours, minutes,
    and seconds. Hopefully, this never runs more than an hour, but it can't hurt to
    be ready for it. And that's all there is to the CLI, in terms of code. Crest did
    the heavy lifting for our command-line parameter parsing, leaving us with a straightforward
    and clean implementation of our logic.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的两个`Instant`，我们得到一个`Duration`，然后开始计算小时、分钟和秒。希望这永远不会超过一个小时，但准备好总是好的。这就是CLI的所有代码了。Crest为我们处理了命令行参数解析的重活，让我们有一个简单且干净的逻辑实现。
- en: 'There''s one last thing we need to add, and that''s the CLI help. It would
    be very helpful for the end user to be able to find out how to use our command.
    Fortunately, Crest has support built in to provide that information. To add the
    help information, we need to create a file called `OptionDescriptions.properties`
    in the same package as our command class (remember that since we''re using Maven,
    this file should be under `src/main/resource`), as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加最后一件事，那就是CLI的帮助信息。对于最终用户来说，能够找到如何使用我们的命令是非常有帮助的。幸运的是，Crest内置了支持来提供这些信息。要添加帮助信息，我们需要在命令类相同的包中创建一个名为`OptionDescriptions.properties`的文件（记住，由于我们使用Maven，这个文件应该在`src/main/resource`下），如下所示：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Doing so will produce an output like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将会产生如下输出：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can be as verbose as you need to be without making your source code an unreadable
    mess.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尽可能详细，而不会让你的源代码变得难以阅读。
- en: 'With that, our CLI is feature-complete. Before we move on, we need to take
    a look at some build concerns for our CLI and see how Crest fits in. Obviously,
    we need to tell Maven where to find our Crest dependency, which is shown in the
    following piece of code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们的CLI功能已经完整。在我们继续之前，我们需要查看一些CLI的构建问题，并看看Crest如何适应。显然，我们需要告诉Maven在哪里可以找到我们的Crest依赖项，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also need to tell it where to find our duplicate finder library as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要告诉它在哪里可以找到我们的重复查找库，如下所示：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note `groupId` and `version`: since our CLI and library modules are part of
    the same parent multi-module build, we set `groupId` and `version` to that of
    the parent module, allowing us to manage that from a single location, which makes
    changing groups or bumping versions much simpler.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`groupId`和`version`：由于我们的CLI和库模块是同一个父多模块构建的一部分，我们将`groupId`和`version`设置为父模块的，这样我们就可以从单个位置管理它，这使得更改组或升级版本变得简单得多。
- en: 'The more interesting part is the `build` section of our POM. First, let''s
    start with `maven-compiler-plugin`. While we are targeting Java 9, `crest-maven-plugin`,
    which we''ll look at in a moment, does not currently seem to like the classes
    generated for Java 9, so we instruct the compiler plugin to emit Java 1.8 bytecode:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的部分是我们POM的`build`部分。首先，让我们从`maven-compiler-plugin`开始。虽然我们针对的是Java 9，但我们将要讨论的`crest-maven-plugin`似乎不喜欢为Java
    9生成的类，因此我们指示编译插件生成Java 1.8字节码：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we need to set up `crest-maven-plugin`. To expose our command classes
    to Crest, we have two options: we can use runtime scanning for the classes, or
    we can have Crest scan for commands at build time. In order to make this utility
    as small as possible, as well as reducing the startup time as much as possible,
    we will opt for the latter approach, so we will need to add another plugin to
    the build, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置`crest-maven-plugin`。为了将我们的命令类暴露给Crest，我们有两种选择：我们可以使用运行时扫描类，或者我们可以在构建时让Crest扫描命令。为了使这个实用程序尽可能小，以及尽可能减少启动时间，我们将选择后者，因此我们需要在构建中添加另一个插件，如下所示：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When this plugin runs, it will generate a file called `crest-commands.txt` that
    Crest will process to find classes when it starts. It may not save much time here,
    but it's definitely something to keep in mind for larger projects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个插件运行时，它将生成一个名为`crest-commands.txt`的文件，Crest将在启动时处理该文件以查找类。这在这里可能节省不了多少时间，但确实是一些值得记住的大项目。
- en: 'Finally, we don''t want the user to have to worry about setting up the classpath
    (or module path!) each time, so we''ll introduce the Maven Shade plugin, which
    will create a single, fat jar with all of our dependencies, transitive and otherwise:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不希望用户每次都要担心设置类路径（或模块路径！），因此我们将引入Maven Shade插件，该插件将创建一个包含所有依赖项的单个fat jar，包括传递依赖项：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After the build, we can then run a search with the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以使用以下命令运行搜索：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Clearly, it can still be improved, so we would want to ship that, say, with
    script wrappers (shell, batch, and so on), but the number of jars is cut down
    from 18 or so to 1, so that's a big improvement.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，它还可以进一步改进，因此我们可能希望将其与脚本包装器（shell、批处理等）一起分发，但jar的数量从大约18个减少到1个，这是一个很大的改进。
- en: With our CLI done, let's make a simple GUI that consumes our library as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CLI完成之后，让我们创建一个简单的GUI来消费我们的库。
- en: Building the graphical user interface
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建图形用户界面
- en: 'For our GUI, we''d like to expose the same type of functionality as the command
    line, but, obviously, with a nice graphical interface. For this, we''ll again
    reach for JavaFX. We''ll give the user a means to select, using a chooser dialog,
    the directories to be searched, and a field by which to add the search patterns.
    Once the duplicates have been identified, we will display them in a list for the
    user to peruse. All of the duplicate groups will be listed and, when clicked,
    the files in that group will be displayed in another list. The user can right-click
    on the list and choose to either view the file (or files) or delete it (or them).
    When we are finished, the application will look like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的GUI，我们希望暴露与命令行相同的功能类型，但显然，有一个漂亮的图形界面。为此，我们再次选择JavaFX。我们将为用户提供一种方式，通过选择对话框选择要搜索的目录，以及一个字段来添加搜索模式。一旦识别出重复项，我们将它们显示在列表中供用户浏览。所有重复组都将列出，并且当点击时，该组中的文件将在另一个列表中显示。用户可以在列表上右键单击并选择查看文件（或文件）或删除它（或它们）。当我们完成时，应用程序将看起来像这样：
- en: '![](img/22589176-b54f-485f-9c1e-0b21ce2a8896.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22589176-b54f-485f-9c1e-0b21ce2a8896.png)'
- en: Let's start by creating our project. In NetBeans, go to File | New Project and
    select Maven | JavaFX Application. You can name it whatever you'd like, but we've
    used the name `Duplicate Finder - GUI`, `groupId` as `com.steeplesoft.dupefind`,
    and `artifactId` as `gui`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的项目。在NetBeans中，转到文件 | 新项目，然后选择Maven | JavaFX应用程序。你可以取任何你喜欢的名字，但我们使用了`Duplicate
    Finder - GUI`这个名字，`groupId`为`com.steeplesoft.dupefind`，`artifactId`为`gui`。
- en: 'Once you have your project, you should have two classes, `Main` and `FXMLController`,
    as well as the `fxml/Scene.fxml` resource. This may sound repetitive, but before
    we go any further, we need to set up our Java module as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了你的项目，你应该有两个类，`Main`和`FXMLController`，以及`fxml/Scene.fxml`资源。这听起来可能有些重复，但在我们进一步之前，我们需要按照以下方式设置我们的Java模块：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, to create the interface we saw, we will use `BorderPane`, to which we''ll
    add `MenuBar` to the `top` section, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了创建我们看到的界面，我们将使用`BorderPane`，并在其`top`部分添加`MenuBar`，如下所示：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When you add `MenuBar` with Scene Builder, it automatically adds several sample
    `Menu` entries for you. We've removed the unwanted entries, and tied the remaining
    to Java methods in the controller class. Specifically, the `Close` menu will call
    `closeApplication()` and `About` will call `showAbout()`. This looks just like
    the menu markup seen previously in the book, so there's not much to talk about.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Scene Builder添加`MenuBar`时，它会自动为你添加几个示例`Menu`条目。我们已经删除了不需要的条目，并将剩余的与控制器类中的Java方法绑定。具体来说，`Close`菜单将调用`closeApplication()`，而`About`将调用`showAbout()`。这看起来就像书中之前看到的菜单标记，所以没有太多可说的。
- en: 'The rest of the layout is a bit more complex. In the `left` section, we have
    a number of controls stacked vertically. JavaFX has a built-in container that
    makes that easy to do: `VBox`. We''ll get to its contents in a moment, but its
    usage looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的布局稍微复杂一些。在`left`部分，我们有一些控件垂直堆叠。JavaFX有一个内置的容器，使得这样做变得容易：`VBox`。我们稍后会看到它的内容，但它的用法看起来像这样：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That's not valid FXML, so don't try to copy and paste that. I've omitted the
    details of the children for clarity. As you can see, `VBox` has a number of children,
    each of which will be stacked vertically, but, as we can see from the preceding
    screenshot, there are some we want to be lined up horizontally. To achieve that,
    we nest an `HBox` instance where needed. Its markup looks just like `VBox`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是有效的FXML，所以不要尝试复制和粘贴。为了清晰起见，我省略了子元素的细节。正如你所见，`VBox`有多个子元素，每个子元素都将垂直堆叠，但是，正如我们从前面的截图中所见，有一些我们希望水平对齐。为了实现这一点，我们在需要的地方嵌套了一个`HBox`实例。它的标记看起来就像`VBox`。
- en: 'There''s not much of interest in this part of the FXML, but there are a couple
    of things to note. We want certain parts of the user interface to shrink and grow
    as the window is resized, namely `ListView`. By default, each component''s various
    height and width properties--minimum, maximum, and preferred--will use the computed
    size, which means, roughly, that they''ll be as big as they need to be to render
    themselves, and, in most cases, that''s fine. In our situation, we want the two
    `ListView` instances to grow as much as possible inside their respective containers,
    which, in this case, is `VBox` we discussed earlier. To make that happen, we need
    to modify our two `ListView` instances like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个FXML的部分没有太多值得注意的内容，但有两点需要注意。我们希望用户界面的某些部分在窗口大小调整时能够收缩和扩展，即`ListView`。默认情况下，每个组件的各种高度和宽度属性（最小、最大和首选）将使用计算大小，这意味着，大致上，它们将变得足够大以渲染自身，在大多数情况下这是可以的。在我们的情况下，我们希望两个`ListView`实例尽可能在其各自的容器内扩展，在这种情况下，是之前讨论过的`VBox`。为了实现这一点，我们需要像这样修改我们的两个`ListView`实例：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: With both the `ListView` instances set to `ALWAYS` grow, they will compete with
    each other for the available space, and end up sharing it. The available space,
    of course, is dependent on the height of the `VBox` instance, as well as the computed
    height of the other components in the container. With that property set, we can
    increase or decrease the size of the window, and watch the two `ListView` instances
    grow and shrink, while everything else remains the same.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个`ListView`实例都设置为`ALWAYS`增长时，它们将相互竞争可用空间，并最终共享它。可用空间，当然，取决于`VBox`实例的高度以及其他容器中其他组件的计算高度。设置了该属性后，我们可以增加或减少窗口的大小，并观察两个`ListView`实例如何增长和收缩，而其他一切保持不变。
- en: 'For the rest of the user interface, we''ll apply the same tactic to arrange
    components, but, this time, we''ll start with an `HBox` instance, and divide that
    up as necessary. We have two `ListView` instances that we also want to fill all
    the available space with, so we mark those up in the same way we did the last
    two. Each `ListView` instance also has a `Label`, so we wrap each `Label`/`ListView`
    pair in a `VBox` instance to get our vertical distribution. In pseudo-FXML, this
    would look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户界面的其余部分，我们将应用相同的策略来排列组件，但这次，我们将从一个`HBox`实例开始，并根据需要将其分割。我们有两个`ListView`实例，我们希望它们也填充所有可用空间，所以我们以相同的方式标记这些实例。每个`ListView`实例还有一个`Label`，因此我们将每个`Label`/`ListView`对包裹在一个`VBox`实例中，以获得垂直分布。在伪FXML中，这看起来像这样：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There is one item of interest in this part of the user interface, and that
    is the context menu we discussed earlier. To add a context to a control, you nest
    a `contextMenu` element in the target control''s FXML like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面的这部分有一个值得注意的项目，那就是我们之前讨论过的上下文菜单。为了给一个控件添加上下文，你需要在目标控件的FXML中嵌套一个`contextMenu`元素，如下所示：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We''ve defined a content menu with two `MenuItem`: `"Open File(s)..."` and
    `"Deleted File(s)..."`. We''ve also specified the action for the two `MenuItem`
    using the `onAction` attribute. We''ll look at these following methods.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个包含两个`MenuItem`的内容菜单：`"Open File(s)..."`和`"Deleted File(s)..."`。我们还使用`onAction`属性指定了这两个`MenuItem`的动作。我们将在接下来的方法中查看这些。
- en: This marks the end of our user interface definition, so now we turn our attention
    to the Java code, in which we will finish preparing the user interface for use,
    as well as implement our application's logic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们用户界面定义的结束，因此现在我们将注意力转向Java代码，在那里我们将完成用户界面的准备工作，以及实现我们应用程序的逻辑。
- en: 'While we didn''t show the FXML that accomplishes this, our FXML file is tied
    to our controller class: `FXMLController`. This class can be called anything,
    of course, but we''ve opted to use the name generated by the IDE. In a larger
    application, more care will need to be given in the naming of this class. To allow
    the injection of our user interface components into our code, we need to declare
    instance variables on our class, and mark them up with the `@FXML` annotation.
    Some examples include the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有展示完成这个任务的FXML，但我们的FXML文件与我们的控制器类`FXMLController`相关联。当然，这个类可以命名为任何东西，但我们选择使用IDE生成的名称。在一个更大的应用程序中，需要对这个类的命名给予更多的关注。为了允许将我们的用户界面组件注入到我们的代码中，我们需要在我们的类中声明实例变量，并用`@FXML`注解标记它们。以下是一些示例：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are several others, but this should be sufficient to demonstrate the concept.
    Note that rather than declaring a plain `ListView`, we've parameterized our instances
    as `ListView<String>` and `ListView<FileInfo>`. We know this is what we're putting
    into the control, so specifying that the type parameter gets us a measure of type
    safety at compile time, but also allows us to avoid having to cast the contents
    every time we interact with them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个，但这应该足以展示这个概念。请注意，我们不是声明了一个普通的`ListView`，而是将我们的实例参数化为`ListView<String>`和`ListView<FileInfo>`。我们知道这是我们放入控制器的，所以指定类型参数在编译时提供了类型安全，同时也允许我们在与它们交互时避免每次都需要进行类型转换。
- en: 'Next, we need to set up the collections that will hold the search paths and
    patterns that the user will enter. We''ll use the `ObservableList` instances for
    that. Remember that with an `ObservableList` instance, the container can automatically
    rerender itself as needed when the `Observable` instance is updated:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置将包含用户输入的搜索路径和模式的集合。我们将使用`ObservableList`实例来完成这项工作。记住，在使用`ObservableList`实例时，容器可以自动根据需要重新渲染自身，当`Observable`实例被更新时：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `initialize()` method, we can start tying things together. Consider
    the following code snippet as an example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize()`方法中，我们可以开始将事物联系起来。以下代码片段可以作为示例：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we associate our `ListView` instances with our `ObservableList` instances.
    Now, at any point that these lists are updated, the user interface will immediately
    reflect the change.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`ListView`实例与我们的`ObservableList`实例关联起来。现在，在任何这些列表被更新的时候，用户界面将立即反映这一变化。
- en: 'Next, we need to configure the duplicate file group `ListView`. The data coming
    back from our library is a `Map` of a `List<FileInfo>` object, keyed by the duplicate
    hashes. Clearly, we don''t want to show the user a list of hashes, so, like the
    CLI, we want to denote each group of files with a more friendly label. To do that,
    we need to create a `CellFactory`, which will, in turn, create a `ListCell` that
    is responsible for rendering the cell. We will do that as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置重复文件组的`ListView`。从我们的图书馆返回的数据是一个`Map`，其键是一个`List<FileInfo>`对象，通过重复的哈希值进行索引。显然，我们不希望向用户展示哈希列表，所以，就像命令行界面（CLI）一样，我们希望用更友好的标签来表示每个文件组。为了做到这一点，我们需要创建一个`CellFactory`，它将创建一个负责渲染单元格的`ListCell`。我们将按照以下方式完成：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'While lambdas can be great, in that they tend to make code more concise, they
    can also obscure some details. In a non-lambda code, the lambda above might look
    like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然lambda表达式可以非常好，因为它们往往可以使代码更加简洁，但它们也可能隐藏一些细节。在非lambda代码中，上面的lambda表达式可能看起来像这样：
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You certainly get more detail, but it''s also much harder to read. The main
    point in including both here is twofold: to show why lambdas are often so much
    better, and to show the actual types involved, which helps the lambdas make sense.
    With that understanding of the lambdas under our belts, what is the method doing?'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然会得到更多的细节，但阅读起来也更困难。在这里包含两者的主要目的是双重的：一方面是为了展示为什么lambda表达式通常如此之好，另一方面是为了展示实际涉及到的类型，这有助于lambda表达式更有意义。有了对lambda表达式的这种理解，这个方法在做什么呢？
- en: 'First, we call `super.updateItem()`, as that''s simply good practice. Next,
    we find the index of the string being rendered. The API gives us the string (since
    it''s a `ListView<String>`), so we find its index in our `ObservableList<String>`.
    If it''s found, we set the text of the cell to `Group #` plus the index plus one
    (since indexes in Java are typically zero-based). If the string isn''t found (`ListView`
    is rendering an empty cell), we set the text to null to ensure that the field
    is blank.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们调用`super.updateItem()`，因为这仅仅是良好的实践。接下来，我们找到正在渲染的字符串的索引。API为我们提供了字符串（因为它是一个`ListView<String>`），所以我们找到它在我们的`ObservableList<String>`中的索引。如果找到了，我们将单元格的文本设置为`Group
    #`加上索引加一（因为Java中的索引通常是零基的）。如果字符串没有找到（`ListView`正在渲染一个空单元格），我们将文本设置为null以确保字段为空。'
- en: 'Next, we need to perform a similar procedure on `matchingFilesListView`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`matchingFilesListView`上执行类似的程序：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is almost identical, but with a couple of exceptions. First, we're setting
    the selection mode of `ListView` to `MULTIPLE`. This will allow the user to control-click
    on items of interest, or shift-click on a range of rows. Next, we set up `CellFactory`
    in an identical fashion. Note that since the `ListView` instance's parameterized
    type is `FileInfo`, the types in the method signature of `ListCell.updateItem()`
    are different.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎完全相同，但有一些例外。首先，我们将`ListView`的选择模式设置为`MULTIPLE`。这将允许用户控制点击感兴趣的项，或者按住shift键点击一系列行。接下来，我们以相同的方式设置`CellFactory`。请注意，由于`ListView`实例的参数化类型是`FileInfo`，因此`ListCell.updateItem()`方法签名中的类型不同。
- en: 'We have one last user interface setup step. If you look back at the screenshot,
    you will notice that the Find Duplicates button is the same width as `ListView`,
    unlike the other buttons, which are just wide enough to render their content.
    We do that by binding the width of the `Button` element to that of its container,
    which is an `HBox` instance:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个最后的用户界面设置步骤。如果你回顾一下截图，你会注意到查找重复项按钮的宽度与`ListView`相同，而其他按钮的宽度仅足够渲染其内容。我们通过将`Button`元素的宽度绑定到其容器的宽度来实现这一点，这是一个`HBox`实例：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We are getting the preferred width property, which is a `DoubleProperty`, and
    binding that to the width property (also a `DoubleProperty`) of `findBox`, the
    control's container. `DoubleProperty` is an `Observable` instance, just as `ObservableListView`
    is, so we're telling the `findFiles` control to observe its container's width
    property, and set its own value accordingly when the other changes. This lets
    us set the property, after a fashion, and then forget about it. Unless we want
    to break the binding between these two properties, we never again have to think
    about it, and we certainly don't need to manually watch one property to update
    the author. The framework does that for us.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在获取首选宽度属性，它是一个`DoubleProperty`，并将其绑定到`findBox`的宽度属性（也是一个`DoubleProperty`）上，这是控制器的容器。`DoubleProperty`是一个`Observable`实例，就像`ObservableListView`一样，所以我们告诉`findFiles`控制器观察其容器的宽度属性，并在其他属性变化时相应地设置自己的值。这让我们以一种方式设置属性，然后就可以忘记它了。除非我们想要打破这两个属性之间的绑定，否则我们再也不必考虑它了，我们当然不需要手动监视一个属性来更新作者。框架为我们做了这件事。
- en: 'Now, how about those buttons? How do we make them do something? We do that
    by setting the `onAction` property of the `Button` element to a method in our
    controller: `#someMethod` translates to `Controller.someMethod(ActionEvent event)`.
    We can handle this in one of at least two ways: we can create a separate handler
    method for each button, or, as we''ve done here, we can create one, then delegate
    to another method as appropriate; either is fine:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，那些按钮呢？我们如何让它们做些什么？我们通过将`Button`元素的`onAction`属性设置为控制器中的方法来实现：`#someMethod`转换为`Controller.someMethod(ActionEvent
    event)`。我们可以以至少两种方式处理这个问题：我们可以为每个按钮创建一个单独的处理程序方法，或者，就像我们在这里所做的那样，我们可以创建一个，然后根据需要委托给另一个方法；两种方式都可以：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We have to make sure we''re actually getting a `Button` element, then we cast
    it and compare it to the instances that were injected. The actual handlers for
    each button are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们实际上得到了一个`Button`元素，然后我们将其转换为实例并比较注入的实例。每个按钮的实际处理程序如下：
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: To add a pattern, we create a `TextInputDialog` instance with the appropriate
    text, then call `showAndWait()`. The beauty of this method in JavaFX 8 is that
    it returns `Optional<String>`. If the user enters text in the dialog, and if the
    user clicks on OK, the `Optional` will have content. We identify that with the
    call to `ifPresent()`, passing it a lambda that adds the new pattern to `ObservableList<String>`,
    which automatically updates the user interface. If the user doesn't click on OK,
    the `Optional` will be empty. If the user didn't enter any text (or entered a
    bunch of spaces), the call to `filter()` will prevent the lambda from ever running.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个模式，我们创建一个带有适当文本的`TextInputDialog`实例，然后调用`showAndWait()`。在JavaFX 8中，这个方法的优点是它返回`Optional<String>`。如果用户在对话框中输入文本，并且如果用户点击了OK，`Optional`将包含内容。我们通过调用`ifPresent()`来识别这一点，传递给它一个lambda，该lambda将新模式添加到`ObservableList<String>`中，这会自动更新用户界面。如果用户没有点击OK，`Optional`将是空的。如果用户没有输入任何文本（或者输入了一堆空格），`filter()`的调用将阻止lambda运行。
- en: 'Removing an item is similar, though we get to hide some of the details in a
    utility method, since we have two needs for the functionality. We make sure something
    is selected, then show a confirmation dialog, removing the pattern from the `ObservableList<String>`
    if the user clicks on OK:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 删除项与删除模式类似，尽管我们可以通过一个实用方法隐藏一些细节，因为我们有两个功能需求。我们确保有东西被选中，然后显示一个确认对话框，如果用户点击OK，则从`ObservableList<String>`中删除模式：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s take a look at the `showConfirmationDialog` method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`showConfirmationDialog`方法：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Again, this is much like the dialogs earlier, and should be self-explanatory.
    The interesting part here is the use of a lambda as a method parameter that makes
    this, by the way, a higher order function--meaning it takes in a function as a
    parameter, returns a function as its result, or both. We pass in `Runnable`, as
    we want a lambda that takes in nothing and returns nothing, and `Runnable` is
    a `FunctionalInterface` that matches that description. After we show the dialog
    and get the user's response, we will filter for only responses where the button
    clicked on was `OK`, and, if present, we execute `Runnable` via `action.run()`.
    We have to specify `b -> action.run()` as `ifPresent()` takes a `Consumer<? super
    ButtonType>`, so we create one and ignore the value passed in, allowing us to
    shield our calling code from that detail.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这与之前的对话框非常相似，应该很容易理解。这里有趣的部分是使用lambda作为方法参数，这使得它成为一个高阶函数——意味着它接受一个函数作为参数，返回一个函数作为其结果，或者两者都是。我们传递`Runnable`，因为我们想要一个不接受任何内容并返回任何内容的lambda，而`Runnable`是一个`FunctionalInterface`，符合这个描述。在我们显示对话框并获取用户响应后，我们将只过滤出点击了按钮OK的响应，并且如果存在，我们将通过`action.run()`执行`Runnable`。我们必须指定`b
    -> action.run()`，因为`ifPresent()`接受一个`Consumer<? super ButtonType>`，所以我们创建一个并忽略传入的值，这样我们就可以保护我们的调用代码不受该细节的影响。
- en: 'Adding a path requires a `DirectoryChooser` instance:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 添加路径需要一个`DirectoryChooser`实例：
- en: '[PRE69]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When creating the `DirectoryChooser` instance, we set the initial directory
    to the last directory used as a convenience for the user. When the application
    starts, this defaults to the user's home directory, but once a directory is successfully
    chosen, we set `lastDir` to the added directory's parent, allowing the user to
    start where he or she left off should there be a need to enter multiple paths.
    `DirectoryChooser.showDialog()` returns a file, so we get its canonical path and
    store that in paths, which, again, causes our user interface to be updated automatically.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`DirectoryChooser`实例时，我们将初始目录设置为用户上次使用的目录，以便为用户提供便利。当应用程序启动时，这默认为用户的主目录，但一旦成功选择了一个目录，我们将`lastDir`设置为添加的目录的父目录，这样如果需要输入多个路径，用户就可以从上次停止的地方开始。`DirectoryChooser.showDialog()`返回一个文件，所以我们获取其规范路径并将其存储在paths中，这再次导致我们的用户界面自动更新。
- en: 'Removing a path looks very similar to removing a pattern, as you can see in
    the following code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 删除路径看起来与删除模式非常相似，如以下代码片段所示：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Same basic code, just a different lambda. Aren't lambdas just the coolest?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基本相同，只是lambda不同。难道lambda不是最酷的吗？
- en: 'The handler for the `findFiles()` button is a bit different, but looks a lot
    like our CLI code, as you can see here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`findFiles()`按钮的处理程序与我们的CLI代码有点不同，但看起来很相似，如下所示：'
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We create our `FileFinder` instance, set the paths and patterns using streams
    and lambdas, then start the search process. When it completes, we get the list
    duplicate file information via `getDuplicates()`, then create a new `ObservableList<String>`
    instance using the keys of the map, which we then set on `dupeFileGroupListView`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`FileFinder`实例，使用流和lambda表达式设置路径和模式，然后启动搜索过程。当它完成后，我们通过`getDuplicates()`获取重复文件信息列表，然后使用映射的键创建一个新的`ObservableList<String>`实例，并将其设置在`dupeFileGroupListView`上。
- en: 'Now we need to add the logic to handle mouse clicks on the group list, so we
    will set the `onMouseClicked` property on `ListView` in the FXML file to `#dupeGroupClicked`,
    as you can see in the following code block:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加处理组列表鼠标点击的逻辑，因此我们将FXML文件中`ListView`的`onMouseClicked`属性设置为`#dupeGroupClicked`，如下面的代码块所示：
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When the control is clicked on, we get the index and make sure it is non-negative,
    so as to ensure that the user actually clicked on something. We then get the hash
    of the group by getting the selected item from `ListView`. Remember that while
    `ListView` may show something like `Group #2`, the actual content of that row
    is the hash. We just used a custom `CellFactory` to give it a prettier label.
    With the hash, we clear the list of items in `matchingFilesListView`, then get
    the control''s `ObservableList` and add all of the `FileInfo` objects in the `List`
    keyed by the hash. And, again, we get an automatic user interface update, thanks
    to the power of `Observable`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '当控件被点击时，我们获取索引并确保它是非负的，以确保用户确实点击了某个东西。然后我们从`ListView`获取所选项目的哈希值。记住，虽然`ListView`可能显示类似`Group
    #2`的内容，但该行的实际内容是哈希值。我们只是使用自定义的`CellFactory`给它一个更漂亮的标签。有了哈希值，我们清除`matchingFilesListView`中的项目列表，然后获取控件的`ObservableList`并添加所有通过哈希值键入的`FileInfo`对象。再次，我们通过`Observable`的力量获得自动的用户界面更新。'
- en: 'We also want the user to be able to navigate the list of duplicate groups using
    the keyboard to update the matching file list. We do that by setting the `onKeyPressed`
    attribute on our `ListView` to point to this rather simple method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望用户能够使用键盘导航重复组列表，以更新匹配文件列表。我们通过将我们的`ListView`上的`onKeyPressed`属性设置为指向这个相当简单的方法来实现：
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It just so happens that we're not too terribly interested in the actual `Event`
    in either of these methods (they're never actually used), so we can naively delegate
    to the mouse-click method discussed earlier.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好我们对这两个方法中的实际`Event`（它们实际上从未被使用）不太感兴趣，因此我们可以天真地委托给之前讨论的鼠标点击方法。
- en: 'There are two more minor pieces of functionality we need to implement: viewing
    the matching files and deleting matching files.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现两个更小的功能：查看匹配文件和删除匹配文件。
- en: 'We''ve already created the context menu and menu entries, so all we need to
    do is implement the handler methods as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了上下文菜单和菜单项，所以我们只需要实现如下所示的处理方法：
- en: '[PRE74]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The matching file list allows multiple selections, so we need to get `List<FileInfo>`
    from the selection model instead of the single object we''ve already seen. We
    then call `forEach()` to process the entry. We want to open the file in whatever
    application the user has configured in the operating system to handle that file
    type. To do this, we use an AWT class introduced in Java 6: `Desktop`. We get
    the instance via `getDesktop()`, then call `open()`, passing it `File` that points
    to our `FileInfo` target.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配文件列表允许多选，因此我们需要从选择模型获取`List<FileInfo>`而不是我们之前看到的单个对象。然后我们调用`forEach()`来处理条目。我们希望以用户在操作系统中配置的任何应用程序打开文件。为此，我们使用Java
    6中引入的AWT类：`Desktop`。我们通过`getDesktop()`获取实例，然后调用`open()`，传递指向我们的`FileInfo`目标的`File`。
- en: 'Deleting a file is similar:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件的过程类似：
- en: '[PRE75]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Similarly to open files, we get all of the selected files. If there's at least
    one, we confirm the user's intent via `showConfirmationDialog()`, and pass in
    a lambda that handles the deleting. We do the actual file deletion using the `Desktop`
    class again to move the file to the trash can provided by the filesystem to provide
    the user with a safe delete option. If the file is successfully deleted, we remove
    its entry from `ObservableList`, as well as our cache duplicate file `Map`, so
    that it isn't shown should the user click on this file group again.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与打开文件类似，我们获取所有选定的文件。如果至少有一个文件，我们通过`showConfirmationDialog()`确认用户的意图，并传递一个处理删除的lambda表达式。我们再次使用`Desktop`类执行实际的文件删除操作，将文件移动到文件系统提供的垃圾桶中，为用户提供一个安全的删除选项。如果文件成功删除，我们从`ObservableList`中移除其条目，以及我们的缓存重复文件`Map`，这样在用户再次点击此文件组时就不会显示。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, our application is done. So, what have we covered? From the project
    description, this seemed like a pretty simple application, but as we started breaking
    down the requirements and delving into the implementation, we ended up covering
    a lot of territory--a scenario that is not at all uncommon. We built another multi-module
    Maven project. We introduced Java concurrency, including basic `Thread` management
    and `ExecutorService` usage, as well as the Java Persistence API, showing basic
    `@Entity` definition, `EntityManagerFactory/EntityManager` usage, and JPAQL query
    authoring. We discussed creating file hashes using the `MessageDigest` classes,
    and demonstrated the new file I/O APIs, including the directory tree walking APIs.
    We also built a more complex user interface in JavaFX using nested containers,
    "linked" `ListView` instances, and bound properties.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，我们的应用程序就完成了。那么，我们涵盖了哪些内容呢？从项目描述来看，这似乎是一个相当简单的应用程序，但随着我们开始分解需求并深入到实现中，我们最终覆盖了大量的领域——这种情况并不罕见。我们构建了一个多模块的Maven项目。我们介绍了Java并发，包括基本的`Thread`管理和`ExecutorService`的使用，以及Java持久化API，展示了基本的`@Entity`定义、`EntityManagerFactory/EntityManager`的使用和JPAQL查询编写。我们还讨论了使用`MessageDigest`类创建文件哈希，并演示了新的文件I/O
    API，包括目录树遍历API。我们还使用嵌套容器、"链接"的`ListView`实例和绑定属性在JavaFX中构建了一个更复杂的用户界面。
- en: That's quite a bit for such a "simple" project. Our next project will also be
    relatively simple, as we build a command-line date calculator that will allow
    us to explore the `java.time` package and see some of what this new date/time
    API offers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个“简单”的项目来说，内容已经相当丰富了。我们的下一个项目也将相对简单，因为我们将构建一个命令行日期计算器，这将使我们能够探索`java.time`包，并了解这个新的日期/时间API提供了哪些功能。
