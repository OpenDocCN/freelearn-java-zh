- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Documenting Your API Effectively
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效地记录您的 API
- en: Comprehensive **documentation** is essential for ensuring clients understand
    how to use your API effectively. In this chapter, we will explore the process
    of documenting a REST API using **Swagger** annotations and best practices. We’ll
    delve into several key topics to provide you with a comprehensive understanding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 **文档** 对于确保客户能够有效使用您的 API 至关重要。在本章中，我们将探讨使用 **Swagger** 注解和最佳实践来记录 REST
    API 的过程。我们将深入研究几个关键主题，以提供全面的理解。
- en: Firstly, we’ll discuss the importance of API specifications by examining the
    **OpenAPI Specification** and **JSON Schema** , essential standards that define
    the structure and format of API documentation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过检查 **OpenAPI 规范** 和 **JSON Schema** 来讨论 API 规范的重要性，这些是定义 API 文档结构和格式的关键标准。
- en: We’ll also explore the debate between **code-first** and **specification-first**
    approaches in API development, discussing their respective advantages and considerations.
    Following this, we’ll document the Product API, illustrating how to use Swagger
    annotations effectively to describe endpoints, parameters, responses, and other
    critical details.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨 API 开发中 **先编码** 和 **先规范** 方法之间的辩论，讨论它们各自的优缺点和考虑因素。在此之后，我们将记录产品 API，展示如何有效地使用
    Swagger 注解来描述端点、参数、响应和其他关键细节。
- en: Finally, we’ll demonstrate the practical utility of the Swagger **user interface**
    ( **UI)** , a powerful tool for visualizing and interacting with API documentation,
    enhancing developer experience and facilitating seamless API consumption. Through
    these discussions and examples, you will gain insights into creating well-documented,
    standardized REST APIs that promote interoperability and ease of use.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示 Swagger **用户界面**（**UI**）的实用价值，这是一个用于可视化并交互 API 文档的强大工具，它能够提升开发者的体验并促进
    API 的无缝使用。通过这些讨论和示例，您将深入了解创建良好文档、标准化的 REST API，这些 API 能够促进互操作性和易用性。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Importance of API specifications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 规范的重要性
- en: Introducing OpenAPI and JSON Schema
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 OpenAPI 和 JSON Schema
- en: Choosing between specification-first and code-first
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在规范优先和编码优先之间进行选择
- en: Documenting the Product API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录产品 API
- en: Using the Swagger UI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Swagger UI
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will implement the documentation for our Product API. To
    be able to follow along and use the code examples as they are printed in this
    book, you should have the Product API code that was created in the previous chapter.
    You can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter3](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter3)
    . The code added in this chapter will not change the actual functionality of the
    API; it will only provide metadata to generate the documentation for the API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现产品 API 的文档。为了能够跟随并使用本书中打印的代码示例，您应该拥有上一章中创建的产品 API 代码。您可以在 GitHub 上访问本章的代码：[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter3](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter3)。本章添加的代码不会改变
    API 的实际功能；它只会提供元数据以生成 API 的文档。
- en: Importance of API specifications
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 规范的重要性
- en: Let us begin by discussing what API specifications are and why they are important.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论 API 规范是什么以及为什么它们很重要。
- en: From Java, we know the principles of object-oriented programming. One of those
    principles is **encapsulation** , which involves making as many members of a class
    private as possible. Only those members (typically methods) that are explicitly
    intended for external access should be made public. The collection of these public
    members forms the class’s API. It is good practice to accompany the public members
    by Javadoc so that their usage is clear without seeing the code implementing the
    class. By limiting the size of the public API, we retain the liberty to change
    or remove the internal (private) members without breaking code outside the class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 我们了解到面向对象编程的原则。其中之一是 **封装**，它涉及尽可能多地使类的成员私有。只有那些明确打算对外部访问的成员（通常是方法）应该被公开。这些公共成员的集合构成了类的
    API。与公共成员伴随的 Javadoc 可以确保其使用清晰，无需查看实现类的代码。通过限制公共 API 的大小，我们保留了对更改或删除类外部的（私有）成员的自由，而不会破坏类外部的代码。
- en: We should also be cautious when defining the signatures of public methods. Passing
    unnecessary data via arguments or return values can cause unnecessary coupling,
    increase the complexity of the code processing the data (e.g., validations or
    ensuring immutability), and limit the possibilities of performance optimization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义公共方法的签名时，我们也应该谨慎。通过参数或返回值传递不必要的数据可能导致不必要的耦合，增加处理数据的代码（例如，验证或确保不可变性）的复杂性，并限制性能优化的可能性。
- en: A poorly designed API, whose structure is driven more by the ease of technical
    implementation rather than business requirements, can expose elements that should
    be hidden. Once such an API is in use, it becomes difficult to change because
    there may be clients outside our control who depend on it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计不良的API，其结构更多地由技术实现的便利性驱动，而不是业务需求，可能会暴露应该隐藏的元素。一旦这样的API开始使用，就很难更改，因为可能存在我们无法控制的客户端依赖于它。
- en: If this is true for APIs within a single Java program, it is even more crucial
    for REST APIs that cross the boundaries of individual programs to have clearly
    separated interfaces and thorough documentation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对于单个Java程序中的API是正确的，那么对于跨越单个程序边界的REST API来说，具有清晰分离的接口和详尽的文档就更加关键。
- en: Although it may be necessary to provide API users with some additional information
    using prose, we can greatly benefit from describing as much as possible of our
    API using a formal and machine-readable specification language. For REST APIs,
    the most widely used and advanced standard is **OpenAPI** .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能需要使用散文提供一些额外的信息给API用户，但我们可以通过尽可能多地使用正式和机器可读的规范语言来描述我们的API来大大受益。对于REST API，最广泛使用和最先进的标准是
    **OpenAPI** 。
- en: Introducing OpenAPI and JSON Schema
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OpenAPI和JSON Schema
- en: 'The **OpenAPI Specification** , backed by the OpenAPI Initiative ( [https://www.openapis.org/](https://www.openapis.org/)
    ), defines a formal language that both humans and computers can read to learn
    about the capabilities of a service without the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由OpenAPI倡议（[https://www.openapis.org/](https://www.openapis.org/)）支持的 **OpenAPI规范**
    定义了一种人类和计算机都能阅读的正式语言，以了解服务的功能，而无需以下：
- en: Access to the service implementation code
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问服务实现代码
- en: Separate documentation in another format (language)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用另一种格式（语言）的单独文档
- en: Analyzing the network traffic
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析网络流量
- en: The OpenAPI Specification was originally based on the Swagger Specification.
    OpenAPI can describe any API using the HTTP protocol, including RESTful APIs at
    any maturity level.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范最初基于Swagger规范。OpenAPI可以使用HTTP协议描述任何API，包括任何成熟度的RESTful API。
- en: OpenAPI Specification documents can be written in JSON and YAML formats. The
    YAML syntax ( [https://yaml.org/](https://yaml.org/) ) replaces a lot of the JSON
    punctuation with indentation; therefore, YAML tends to be more concise and easier
    to read for many humans. In this book, we will use the YAML format for all OpenAPI
    Specifications written manually (not generated by tools).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范文档可以用JSON和YAML格式编写。YAML语法（[https://yaml.org/](https://yaml.org/)）用缩进来代替了大量的JSON标点符号；因此，YAML对于许多人来说更简洁，更容易阅读。在这本书中，我们将使用YAML格式来编写所有手动编写的OpenAPI规范（不是由工具生成的）。
- en: 'The two most important (and usually longest) parts of a typical OpenAPI Specification
    are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 典型OpenAPI规范的两个最重要的（通常也是最长的）部分如下：
- en: '**Paths** : These describe the actions that the API supports, specified by
    resources, HTTP methods, URI parameters, etc.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Paths** : 这些描述了API支持的操作，由资源、HTTP方法、URI参数等指定。'
- en: '**Schemas** : These describe the complex data structures of the request and
    response bodies (payloads)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Schemas** : 这些描述了请求和响应体（有效载荷）的复杂数据结构'
- en: 'Our Product API uses two paths:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的产品API使用两条路径：
- en: '`/api/products/{productId}` : This supports the `GET` , `PUT` , `DELETE` ,
    and `PATCH` methods'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/products/{productId}` : 这支持 `GET`、`PUT`、`DELETE` 和 `PATCH` 方法'
- en: '`/api/products` : This supports the `GET` method only'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/products` : 这只支持 `GET` 方法'
- en: 'The following schemas are used:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用到的模式：
- en: '`ProductInput` : This is used for full product data in requests'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductInput` : 这用于请求中的完整产品数据'
- en: '`ProductDescriptionInput` : This is used to update the product description
    only'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductDescriptionInput` : 这用于仅更新产品描述'
- en: '`ProductOutput` : This is used for product data in responses'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductOutput` : 这用于响应中的产品数据'
- en: '`ProblemDetail` : This is used for error responses'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProblemDetail` : 这用于错误响应'
- en: The format we use to transfer complex data through our API is JSON, which is
    why the schemas part of the OpenAPI Specification uses a dialect of a specification
    language called JSON Schema.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 API 传输复杂数据使用的格式是 JSON，这就是为什么 OpenAPI 规范的架构部分使用 JSON Schema 语言的方言。
- en: '**JSON Schema** is a separate standard that can be used to validate JSON documents
    outside the scope of OpenAPI Specifications. The schema part of every version
    of the OpenAPI Specification is based on a version of the JSON Schema standard,
    plus some OpenAPI-specific modifications. This is why it is called a **dialect**
    of the JSON Schema. It is important to use the features of the schemas section
    supported by the version of the OpenAPI Specification that we want to use.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Schema** 是一个独立的标准，可以用于在 OpenAPI 规范范围之外验证 JSON 文档。OpenAPI 规范每个版本的架构部分都是基于
    JSON Schema 标准的一个版本，并添加了一些 OpenAPI 特定的修改。这就是为什么它被称为 JSON Schema 的 **方言**。使用我们想要使用的
    OpenAPI 规范版本的架构部分支持的功能是很重要的。'
- en: Let’s see what the OpenAPI Specification of our Product API would look like.
    We will use YAML syntax. In the following subsections, some attributes of the
    API specification are omitted for brevity. You can see the full specification
    in the accompanying GitHub repository at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter3/product-api/src/main/resources/Product_Catalogue_API.yml](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter3/product-api/src/main/resources/Product_Catalogue_API.yml)
    .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的产品 API 的 OpenAPI 规范会是什么样子。我们将使用 YAML 语法。在以下子节中，为了简洁起见，省略了一些 API 规范的属性。您可以在附带的
    GitHub 仓库中看到完整的规范：[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter3/product-api/src/main/resources/Product_Catalogue_API.yml](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter3/product-api/src/main/resources/Product_Catalogue_API.yml)
    。
- en: Common API metadata
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见 API 元数据
- en: 'Besides the two main parts of the specification mentioned earlier, there are
    header sections providing metadata about the API and its specification. They define
    the version of the OpenAPI standard, the version of our API, the base URL for
    the API, and some human-readable names and descriptions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的规范的两个主要部分之外，还有提供有关 API 和其规范的元数据的头部部分。它们定义了 OpenAPI 标准的版本、我们 API 的版本、API
    的基本 URL 以及一些可读性强的名称和描述：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Product API paths
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品 API 路径
- en: 'The following parts of the Product API specification are the paths, starting
    with the `GET` method for `/api/products/{productId}` . The `$ref` notation is
    used to refer to the schemas. There are separate response specifications for the
    `200` , `400` , and `404` HTTP response codes. We can also see the specification
    of the required `productId` URI parameter:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 产品 API 规范的以下部分是路径，从 `/api/products/{productId}` 的 `GET` 方法开始。使用 `$ref` 符号来引用架构。对于
    `200`、`400` 和 `404` HTTP 响应码有单独的响应规范。我们还可以看到必需的 `productId` URI 参数的规范：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The same path continues with the specification of the `PUT` method that needs
    a request body:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的路径继续使用需要请求体的 `PUT` 方法的规范：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (The response bodies for the other status codes are omitted.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: （省略了其他状态码的响应体。）
- en: 'Let’s look at one more operation: the one returning the list of products (represented
    by a JSON array):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看一个操作：返回产品列表（由 JSON 数组表示）的操作：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Product API schemas
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品 API 架构
- en: Putting the named schemas in a separate part of the specification lets us reuse
    them for multiple operations, for example, the `ProductOutput` schema.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将命名架构放在规范的一个独立部分，让我们可以在多个操作中重用它们，例如，`ProductOutput` 架构。
- en: 'Using the `example` attribute, we can provide additional information about
    the data elements that can be used by both humans and automated tools (test client
    or mock server generators). Without the `example` attribute, anyone who wants
    to test our API would have to guess meaningful values solely based on their types.
    Generating random strings would lead to unrealistic examples:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `example` 属性，我们可以提供有关数据元素的信息，这些信息既可以由人类使用，也可以由自动化工具（测试客户端或模拟服务器生成器）使用。如果没有
    `example` 属性，任何想要测试我们 API 的人将不得不仅根据它们的类型猜测有意义的值。生成随机字符串会导致不切实际的示例：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ProblemDetail` schema used for error responses is so generic that it is
    likely that we will want to reuse it across multiple APIs (microservices). OpenAPI
    Specifications can be divided into multiple files. We can also host the reusable
    schemas on a web server and refer to them using HTTP URLs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用于错误响应的`ProblemDetail`架构非常通用，我们可能会希望在不同API（微服务）之间重用它。OpenAPI规范可以分成多个文件。我们还可以在Web服务器上托管可重用的架构，并使用HTTP
    URL引用它们。
- en: However, we should bear in mind that it brings coupling among the different
    APIs, so this kind of reuse should only be used with schemas that rarely change
    (the `ProblemDetail` schema fulfills this criterion).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该记住，它会在不同的API之间引入耦合，因此这种重用应该仅用于很少改变的架构（`ProblemDetail`架构满足这一标准）。
- en: We have introduced the basic structure and the most important attributes of
    OpenAPI Specifications. We will get to more advanced OpenAPI features in the following
    chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了OpenAPI规范的基本结构和最重要的属性。我们将在下一章中介绍更高级的OpenAPI功能。
- en: 'In the following section, you will learn about an important decision you have
    to make: This is whether you want to start with an explicit abstract specification
    document, such as the one shown earlier, or derive it from Java code.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解你必须做出的一个重要决定：这是否想要从一个明确的抽象规范文档开始，例如前面展示的，或者从Java代码中推导出来。
- en: Choosing between specification-first and code-first
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在规范优先和代码优先之间进行选择
- en: 'We made it clear that for the success of our API, we need both a concrete implementation
    and an abstract specification of the interface it implements. There are two basic
    approaches when creating APIs: **specification-first** (also known as *design-first*
    or *API-first* ) and **code-first** .'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确指出，为了我们API的成功，我们需要一个具体的实现和一个接口的抽象规范。在创建API时，有两种基本方法：**规范优先**（也称为*设计优先*或*API优先*）和**代码优先**。
- en: Specification-first
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范优先
- en: Starting with the specification forces the API developers to decide upfront
    what needs to be in the public part of the API. Intentional hiding of the details
    the consumers do not need to know makes the API as small as possible and hence
    easier to maintain and evolve.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从规范开始迫使API开发者提前决定API公共部分需要包含什么。有意隐藏消费者不需要知道的具体细节使API尽可能小，因此更容易维护和演进。
- en: 'Here are the pros of specification-first:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是规范优先的优点：
- en: Standalone specifications tend to be smaller as they only define the elements
    of the API needed to satisfy the business requirements; the APIs defined by separate
    specification documents are easier to maintain, and the specification changes
    are more controllable.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的规范通常较小，因为它们只定义了满足业务需求的API元素；由单独的规范文档定义的API更容易维护，规范变更也更可控。
- en: Specification-first ensures the API specification is not biased to any implementation
    language, supporting API providers and consumers written in multiple languages.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范优先确保API规范不对任何实现语言有偏见，支持用多种语言编写的API提供者和消费者。
- en: You get the ability to develop the API provider and consumers in parallel. The
    interface between the connected parties can be negotiated without going into the
    details of the implementation.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以并行开发API提供者和消费者。连接各方之间的接口可以在不深入了解实现细节的情况下协商。
- en: Tests can be created before the API is implemented.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API实现之前可以创建测试。
- en: Specifications written manually (not generated) are easier for humans to read.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手写（非生成）的规范更容易被人阅读。
- en: 'Here are the cons of specification-first:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是采用规范优先的缺点：
- en: The development team needs to master the API specification language in addition
    to the implementation programming language.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队需要掌握API规范语言，除了实现编程语言。
- en: To maintain consistency between the specification and the code, we need tools
    to generate code stubs from the specification. The code generators available may
    not support all the features of both the specification and the implementation
    language.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持规范和代码之间的一致性，我们需要工具从规范中生成代码占位符。可用的代码生成器可能不支持规范和实现语言的所有功能。
- en: Code-first
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码优先
- en: '**Code-first** prioritizes the short-term speed of implementation over clean
    interface design. The API specification is actually reverse-engineered from the
    implementation code. Annotations on code elements and additional metadata are
    added manually to aid the tool used to generate the specification.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码优先** 优先考虑实现的速度，而不是干净的接口设计。API 规范实际上是反向工程自实现代码的。代码元素的注释和额外的元数据被手动添加，以帮助生成规范的工具。'
- en: 'Here are the pros of code-first:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码优先的优点：
- en: Skipping the specification step leads to a working API faster; this makes sense
    for rapid prototyping or low-impact APIs whose clients are under our control
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过规范步骤可以更快地得到一个可工作的 API；这对于快速原型设计或影响较小的 API（其客户端受我们控制）是有意义的。
- en: Both the implementation and the interface are written in one language (usually
    with the help of some annotations or metadata)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和接口都使用一种语言编写（通常需要一些注释或元数据的帮助）
- en: Having the implementation code available may help to include performance or
    other non-functional considerations in the API specification
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用实现代码可能有助于在 API 规范中包含性能或其他非功能性考虑因素。
- en: 'Here are the cons of code-first:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码优先的缺点：
- en: Need to explicitly prevent unwanted implementation details from leaking in the
    generated specification.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要明确防止不希望的实施细节泄漏到生成的规范中。
- en: Need to master the specification generation tools with their annotations specific
    to each implementation language instead of using a standard implementation-agnostic
    specification language.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要掌握针对每种实现语言具有特定注释的规范生成工具，而不是使用标准的实现无关规范语言。
- en: Hard to generate polished and nice-to-read specifications, especially for more
    complex APIs.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成精致且易于阅读的规范很困难，尤其是对于更复杂的 API。
- en: The structure of the APIs developed without the conscious API design step is
    likely to reflect the (first) technical implementation rather than the business
    domain. This is why they tend to be hard to maintain and evolve.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有经过有意识的 API 设计步骤开发的 API 结构可能更多地反映了（首次）技术实现，而不是业务领域。这就是为什么它们往往难以维护和演进。
- en: In this chapter, we will demonstrate the code-first approach for the Product
    API because we already have its implementation code from the previous chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示 Product API 的代码优先方法，因为我们已经从前一章获得了其实现代码。
- en: The specification-first approach will be shown in the following chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将展示规范优先的方法。
- en: Documenting the Product API
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录 Product API
- en: 'To document our API, we will need to add some dependencies from Swagger. In
    the case of the Spring framework, we have the `springdoc-openapi-starter-webmvc-ui`
    dependency, which covers all we need to document the API of the Spring application:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录我们的 API，我们需要添加一些来自 Swagger 的依赖项。在 Spring 框架的情况下，我们有 `springdoc-openapi-starter-webmvc-ui`
    依赖项，它涵盖了记录 Spring 应用程序 API 所需的一切：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Adding this dependency in `pom.xml` allows us to use the Swagger annotations
    and the Swagger UI. After accessing `http://localhost:8080/swagger-ui/index.html`
    , we can see the Swagger UI, represented in *Figure 3.1* .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pom.xml` 中添加此依赖项允许我们使用 Swagger 注释和 Swagger UI。在访问 `http://localhost:8080/swagger-ui/index.html`
    后，我们可以看到在 *图 3.1* 中表示的 Swagger UI。
- en: '![Figure 3.1 – Swagger UI](img/B21843_03_1.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Swagger UI](img/B21843_03_1.png)'
- en: Figure 3.1 – Swagger UI
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Swagger UI
- en: The Swagger UI is generated based on `RestController` and our endpoints. To
    make our API more user-friendly and comprehensible for clients, we should enhance
    it using Swagger annotations. These annotations are available in the `io.swagger.v3.oas.annotations`
    package. Let us explore some of them and see how they can be applied to improve
    our API documentation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 是基于 `RestController` 和我们的端点生成的。为了使我们的 API 对客户端更加友好和易于理解，我们应该使用 Swagger
    注释来增强它。这些注释位于 `io.swagger.v3.oas.annotations` 包中。让我们探索一些它们，并看看它们如何应用于改进我们的 API
    文档。
- en: Swagger annotations
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swagger 注释
- en: '**Swagger annotations** are a set of annotations provided by the Swagger library
    used to generate interactive API documentation for RESTful web services. These
    annotations, when added to your code, help define and describe the structure and
    behavior of your API endpoints, request and response models, and overall API metadata.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swagger 注释** 是由用于生成交互式 API 文档的 Swagger 库提供的一组注释。当这些注释添加到您的代码中时，有助于定义和描述您的
    API 端点、请求和响应模型以及整体 API 元数据的结构和行为。'
- en: '@Tag'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Tag'
- en: 'The `@Tag` annotation is used to group a set of operations; we can use it in
    our API class to inform that every method in this class should belong to this
    tag:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Tag`注解用于将一组操作分组；我们可以在我们的API类中使用它来告知每个方法都应该属于这个标签：'
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '@Operation'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Operation'
- en: 'The `@Operation` annotation is used in method declarations to name API endpoints.
    This annotation can be combined with other annotations to provide a comprehensive
    description of the endpoint, including possible outputs and HTTP status codes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Operation`注解用于方法声明中命名API端点。这个注解可以与其他注解结合使用，以提供端点的全面描述，包括可能的输出和HTTP状态码：'
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are using the `@Operation` annotation to define the
    description for our `delete` endpoint. The `@ApiResponse` annotation is used to
    add the possible response status, in this case, `204` , which represents that
    the product was removed successfully.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`@Operation`注解来定义`delete`端点的描述。`@ApiResponse`注解用于添加可能的响应状态，在这种情况下，`204`表示产品已成功删除。
- en: '@Parameter'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Parameter'
- en: In our previous example, we used the `@Parameter` annotation. This annotation
    is specifically designed to be applied to method parameters, allowing for the
    definition of clear descriptions, examples, and additional information about each
    parameter. Such details are very useful for API consumers, as they provide clear
    examples and essential information, enhancing the usability of the API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们使用了`@Parameter`注解。这个注解专门设计用于应用于方法参数，允许定义清晰的描述、示例和有关每个参数的附加信息。这些细节对于API消费者非常有用，因为它们提供了清晰的示例和必要的信息，增强了API的可用性。
- en: '@ApiResponse'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@ApiResponse'
- en: 'In our previous example, we applied the `@ApiResponse` annotation. This annotation
    serves to specify the potential responses from our API endpoint, detailing the
    HTTP status and response type, and providing examples where applicable. In our
    previous case, there was no return body, as it is `204` ; let’s see an example
    for a `GET` operation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们应用了`@ApiResponse`注解。这个注解用于指定API端点的潜在响应，详细说明HTTP状态和响应类型，并在适用的情况下提供示例。在我们之前的案例中，没有返回体，因为它是`204`；让我们看看`GET`操作的示例：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our example, we have two instances of `@ApiResponse` , the first for successful
    responses with a status code of `200` . In this scenario, we use the `@Schema`
    annotation to reference the implementation class, specifically `ProductOutput.class`
    .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有两个`@ApiResponse`实例，第一个是成功响应，状态码为`200`。在这种情况下，我们使用`@Schema`注解来引用实现类，特别是`ProductOutput.class`。
- en: The second instance pertains to a `404` error, utilizing a schema outside our
    domain, namely `ProblemDetail.class` from Spring. In this case, we use another
    annotation from Swagger, the `@ExampleObject` annotation, to create a structured
    JSON representation of the expected error response, using Java’s text block feature
    to enhance readability.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个实例涉及一个`404`错误，使用的是我们领域之外的架构，即Spring中的`ProblemDetail.class`。在这种情况下，我们使用Swagger的另一个注解`@ExampleObject`注解，通过Java的文本块功能来增强可读性，创建预期的错误响应的结构化JSON表示。
- en: '@Schema'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Schema'
- en: 'In our previous example, we used the `@Schema` annotation to identify the content
    for the API response. This annotation is also used to describe the fields of the
    request and response models. Let’s look at an example using `ProductInput` :'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们使用了`@Schema`注解来标识API响应的内容。这个注解也用于描述请求和响应模型的字段。让我们通过使用`ProductInput`来查看一个例子：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we are using `@Schema` to define the name of each field, indicate
    whether the field is required, and provide an example value. The example value
    is especially useful for new API users, as it offers clear information about the
    expected input and output.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`@Schema`来定义每个字段的名称，指示字段是否必需，并提供示例值。示例值对于新API用户特别有用，因为它提供了关于预期输入和输出的清晰信息。
- en: 'By incorporating bean validation, we enhance our API with additional information
    about the fields. The generated code for `ProductInput` will look something like
    this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合bean验证，我们增强了我们的API，提供了有关字段的其他信息。`ProductInput`生成的代码将类似于以下内容：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By applying these annotations throughout our entire API, we achieve clear and
    well-defined documentation. Now, we can revisit the Swagger UI to review and explore
    the updated documentation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在整个API中应用这些注解，我们实现了清晰且定义良好的文档。现在，我们可以重新访问Swagger UI来审查和探索更新的文档。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Many mock servers use the Swagger implementation to generate mocks; having a
    clear definition and examples for the input and output is essential to generate
    better mocks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模拟服务器使用Swagger实现来生成模拟；对于输入和输出的清晰定义和示例对于生成更好的模拟至关重要。
- en: Using the Swagger UI
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swagger UI
- en: The **Swagger UI** is a web-based interface that provides interactive documentation
    for APIs. It allows developers to visualize and execute API endpoints, making
    it easier to understand and experiment with the API.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swagger UI**是一个基于Web的界面，它为API提供交互式文档。它允许开发者可视化并执行API端点，使其更容易理解和实验API。'
- en: 'Before accessing the Swagger UI, let’s add one more annotation from Swagger:
    the `OpenAPI` annotation. This contains some metadata from our API. We can do
    that in Spring by defining the `OpenAPI` bean:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问Swagger UI之前，让我们添加一个来自Swagger的额外注解：`OpenAPI`注解。这个注解包含了我们API的一些元数据。我们可以在Spring中通过定义`OpenAPI`
    bean来实现这一点：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code, we use the `OpenAPI` bean from Swagger to define metadata information.
    Specifically, we set the title, description, and version of the API. The version
    information is retrieved from the application properties, allowing us to synchronize
    it with the version specified in `pom.xml` .
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用Swagger的`OpenAPI` bean来定义元数据信息。具体来说，我们设置了API的标题、描述和版本。版本信息是从应用程序属性中检索的，这使得我们可以将其与`pom.xml`中指定的版本同步。
- en: 'This annotation supports the following metadata items:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解支持以下元数据项：
- en: '`openapi` : The version of the OpenAPI specification.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openapi`：OpenAPI规范的版本。'
- en: '`info` : This provides metadata about the API:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`：这提供了关于API的元数据：'
- en: '`title` : The title of the API'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：API的标题'
- en: '`version` : The version of the API'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：API的版本'
- en: '`description` : A brief description of the API'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：API的简要描述'
- en: '`termsOfService` : A URL to the terms of service for the API'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`termsOfService`：API服务条款的URL'
- en: '`contact` : Contact information for the API'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact`：API的联系方式'
- en: '`license` : License information for the API'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license`：API的许可信息'
- en: '`servers` : This specifies the servers where the API can be accessed:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servers`：这指定了API可以访问的服务器：'
- en: '`url` : The URL of the server'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：服务器的URL'
- en: '`description` : A description of the server'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：服务器的描述'
- en: '`paths` : The available endpoints for the API; this is usually generated from
    the annotations shown previously.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths`：API的可用端点；这通常是从之前显示的注解生成的。'
- en: '`components` : Components are reusable schemas or other objects that can be
    referenced from multiple places in the API specification. This is also generated
    based on the annotations shown previously.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`：组件是可以重复使用的模式或其他对象，可以在API规范中的多个地方引用。这也是基于之前显示的注解生成的。'
- en: '`security` : This defines the security mechanisms for the API. It is also generated
    from the `@SecurityRequirement` annotations.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security`：这定义了API的安全机制。它也是从`@SecurityRequirement`注解生成的。'
- en: '`tags` : This provides a list of tags used by the specification with additional
    metadata. It is also generated from the `@Tag` annotation.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`：这提供了由规范使用的标签列表以及附加的元数据。它也是从`@Tag`注解生成的。'
- en: '`externalDocs` : This provides external documentation about the API:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`externalDocs`：这提供了关于API的外部文档：'
- en: '`description` : A short description of the external documentation'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：外部文档的简短描述'
- en: '`url` : The URL for the external documentation'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：外部文档的URL'
- en: 'All the preceding annotations and configuration parameters can be used to enrich
    the API documentation. Now that our API is documented in the Java code, we can
    view the results by accessing the Swagger UI at `http://localhost:8080/swagger-ui/index.html`
    , as shown in *Figure 3.2* :'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述注解和配置参数都可以用来丰富API文档。现在我们的API已经在Java代码中进行了文档化，我们可以通过访问`http://localhost:8080/swagger-ui/index.html`的Swagger
    UI来查看结果，如图3.2所示：
- en: '![Figure 3.2 – Swagger UI](img/B21843_03_2.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Swagger UI](img/B21843_03_2.png)'
- en: Figure 3.2 – Swagger UI
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Swagger UI
- en: As we can see in the preceding figure, our API has more detail. It has the description
    of each endpoint and all the metadata provided in the `OpenAPI` bean.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们的API具有更多细节。它包含了每个端点的描述以及`OpenAPI` bean中提供的所有元数据。
- en: In addition, we have schemas that provide detailed information about our data
    models. These schemas include details about each field, indicating whether the
    field is required, along with example values, as we can see in *Figure 3.3* .
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有提供关于我们的数据模型详细信息的模式。这些模式包括每个字段的详细信息，指示字段是否必需，以及示例值，如图3.3所示。
- en: '![Figure 3.3 – Swagger schemas](img/B21843_03_3.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – Swagger 架构](img/B21843_03_3.png)'
- en: Figure 3.3 – Swagger schemas
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Swagger 架构
- en: With this information, API consumers can gain a good understanding of the API,
    simplifying the process of creating a client. In [*Chapter 4*](B21843_04.xhtml#_idTextAnchor096)
    , we will explore how to use the generated documentation to help in generating
    the HTTP client.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些信息，API 用户可以更好地理解 API，简化创建客户端的过程。在[第 4 章](B21843_04.xhtml#_idTextAnchor096)中，我们将探讨如何使用生成的文档来帮助生成
    HTTP 客户端。
- en: 'Generating the documentation file is straightforward. In Swagger UI, there
    is a link that opens the OpenAPI Specification in JSON format, as shown in *Figure
    3.4* :'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 生成文档文件很简单。在 Swagger UI 中，有一个链接可以打开 JSON 格式的 OpenAPI 规范，如图 3.4 所示：
- en: '![Figure 3.4 – Link to the documentation file](img/B21843_03_4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 文档文件链接](img/B21843_03_4.png)'
- en: Figure 3.4 – Link to the documentation file
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 文档文件链接
- en: This specification file can be used by anyone who wants to integrate with our
    API. Many tools, such as Postman, IntelliJ IDEA, and others, seamlessly integrate
    with the OpenAPI standard, offering numerous benefits.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此规范文件可供任何希望集成我们 API 的人使用。许多工具，如 Postman、IntelliJ IDEA 等，与 OpenAPI 标准无缝集成，提供了众多好处。
- en: 'The wide range of uses of the OpenAPI Specification is the reason why we should
    prefer to share a good OpenAPI Specification rather than ready-made Java clients
    in the form of libraries (JAR files). Even if we would like to limit ourselves
    to only Java-implemented clients, ready-made libraries can cause problems:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范的广泛用途是我们应该优先分享良好的 OpenAPI 规范而不是以库（JAR 文件）形式提供的现成 Java 客户端的原因。即使我们希望仅限于
    Java 实现的客户端，现成的库也可能引起问题：
- en: Incompatibility of used third-party libraries or their versions
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库或其版本的不兼容性
- en: Code style not fitting with the rest of the client application (e.g., reactive
    versus imperative programming)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码风格与客户端应用程序的其他部分不匹配（例如，响应式编程与命令式编程）
- en: Missing or incompatible annotations
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少或不兼容的注释
- en: The Swagger UI also offers a convenient way to interact with the API and view
    the results. This feature proves especially useful, as demonstrated in *Figure
    3.5* , by allowing developers to easily test endpoints and observe responses directly
    within the interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 还提供了一种方便的方式与 API 进行交互并查看结果。如图 3.5 所示，这一功能特别有用，因为它允许开发者轻松测试端点并直接在界面中观察响应。
- en: '![Figure 3.5 – Try it out – Swagger UI](img/B21843_03_5.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 尝试使用 – Swagger UI](img/B21843_03_5.png)'
- en: Figure 3.5 – Try it out – Swagger UI
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 尝试使用 – Swagger UI
- en: In the preceding figure, we can see a **Try it out** button, which allows users
    to interact with the API directly from the documentation. This feature enables
    developers to send real requests and view the responses in real time, as illustrated
    in *Figure 3.6* . It’s a straightforward way to validate API behavior without
    needing to write external scripts or tools.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个“尝试使用”按钮，它允许用户直接从文档中与 API 进行交互。这一功能使得开发者能够发送真实请求并在实时查看响应，如图 3.6
    所示。这是一种无需编写外部脚本或工具即可验证 API 行为的简单方法。
- en: '![Figure 3.6 – Execute the Swagger UI](img/B21843_03_6.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 执行 Swagger UI](img/B21843_03_6.png)'
- en: Figure 3.6 – Execute the Swagger UI
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 执行 Swagger UI
- en: These features offered by the Swagger UI greatly enhance the developer experience
    by making it easier to test, understand, and integrate with the API. The interactive
    documentation allows developers to explore the API’s functionality, ensuring they
    can quickly grasp how it works and incorporate it effectively into their own applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 提供的这些功能通过简化测试、理解和集成 API 的过程，大大提升了开发者的体验。交互式文档允许开发者探索 API 的功能，确保他们可以快速掌握其工作原理，并有效地将其集成到自己的应用程序中。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the OpenAPI Specification and how to utilize
    Swagger annotations to generate documentation. In the upcoming chapter, we will
    explore using this documentation to develop a client for it and delve deeper into
    the specification-first approach.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 OpenAPI 规范以及如何利用 Swagger 注释生成文档。在下一章中，我们将探讨如何使用此文档来开发客户端，并深入探讨规范优先的方法。
