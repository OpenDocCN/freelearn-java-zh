- en: Algorithms and Complexities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法和复杂度
- en: An algorithm is a set of logical instructions to perform a particular task.
    Algorithms are everywhere nowadays. As a software developer, understanding the
    core principles of algorithms and data structures will enable you to make informed
    decisions on how to approach a particular problem. This is valid whether you're
    working in a bank writing accounting software or doing medical research data,
    mining genetic code. How do we determine which is the right algorithm to use when
    more than one solution to a problem exists? In this chapter, we will examine different
    types of algorithms and discuss how the performance varies in each. We will discuss
    what makes an algorithm more efficient than another and how to express the complexity
    of each.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是一组执行特定任务的逻辑指令。如今，算法无处不在。作为一名软件开发者，理解算法和数据结构的核心原则将使你能够在如何解决特定问题方面做出明智的决定。这无论你是在银行编写会计软件还是在进行医学研究数据挖掘、遗传编码都是适用的。当存在多个问题的解决方案时，我们如何确定使用哪种算法？在本章中，我们将探讨不同类型的算法，并讨论每种算法的性能差异。我们将讨论什么使一个算法比另一个更高效，以及如何表达每个算法的复杂性。
- en: The common examples of algorithms include traffic lights regulating congestion
    on the streets, face recognition software on smartphones, recommendation technologies,
    and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的常见例子包括调节街道拥堵的交通信号灯、智能手机上的面部识别软件、推荐技术等等。
- en: It's important for you to understand that an algorithm is just a small part
    of an application used to solve a well-defined problem. Examples such as sorting
    a list of numbers, finding the shortest route, or word prediction are all correct.
    Big software applications, such as email clients or an operating system are improper
    examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解的是，算法只是用于解决定义良好问题的应用程序的一个小部分。例如，对数字列表进行排序、找到最短路径或单词预测都是正确的。大型软件应用程序，如电子邮件客户端或操作系统，是不恰当的例子。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Define an algorithm with an example
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用示例定义一个算法
- en: Measure algorithmic complexity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量算法复杂度
- en: Identify algorithms with different complexities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别具有不同复杂度的算法
- en: Assess various examples with different runtime complexities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估具有不同运行时复杂度的各种示例
- en: Developing Our First Algorithm
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的第一个算法
- en: An algorithm can be seen as a roadmap or a set of instructions to accomplish
    a well-defined task. In this section, we will build a simple example of one such
    algorithm to help us get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 算法可以被视为一个路线图或一组完成定义良好任务的指令。在本节中，我们将构建一个这样的算法的简单示例，以帮助我们开始。
- en: Algorithm for Converting Binary Numbers to Decimal
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将二进制数转换为十进制的算法
- en: Number systems have different bases. Decimals numbers with a base of ten are what
    most of us are familiar with. Computers, on the other hand, use only ones and zeros
    (binary). Let's try to write some code that converts binary numbers to decimals.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数制有不同的基数。十进制数是我们大多数人熟悉的。然而，计算机只使用一和零（二进制）。让我们尝试编写一些将二进制数转换为十进制的代码。
- en: Specifically, we want to develop an algorithm that accepts a string containing
    ones and zeros and returns an integer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们想要开发一个算法，该算法接受包含一和零的字符串，并返回一个整数。
- en: 'We can convert the binary string by following these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤转换二进制字符串：
- en: Start from the end of the string and process each character at a time. The position
    of each digit in the binary string corresponds to a decimal number in a sequence.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串的末尾开始，一次处理一个字符。二进制字符串中每个数字的位置对应于序列中的一个十进制数。
- en: To generate this sequence, you start from one and multiply by two every time,
    so one, two, four, eight, and so on (see *Conversion Sequence* row of *Table 1.1*).
    More formally, the sequence is a geometric progression that starts at one and
    progresses in a common ratio of two.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成这个序列，你从一开始，每次乘以二，所以一、二、四、八，以此类推（参见*表1.1*的*转换序列*行）。更正式地说，这个序列是一个以一为起点，以二为公比的几何级数。
- en: We then apply the binary string as a mask on this sequence (see the *Binary String
    (Mask)* row of *Table 1.1*).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将二进制字符串作为掩码应用于这个序列（参见*表1.1*的*二进制字符串（掩码）*行）。
- en: The result is a new sequence where the values are only kept if the corresponding
    position in the binary string has a value of one (see the *Result* row of *Table
    1.1*).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果是一个新序列，其中只保留二进制字符串中相应位置值为一的值（参见*表1.1*的*结果*行）。
- en: After applying the mask, we just need to sum up the resulting numbers together.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用掩码后，我们只需将得到的数字相加。
- en: '| **Conversion Sequence** | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **转换序列** | 16 | 8 | 4 | 2 | 1 |'
- en: '| **Binary String (Mask)** | 1 | 0 | 1 | 1 | 0 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **二进制字符串（掩码）** | 1 | 0 | 1 | 1 | 0 |'
- en: '| **Result** | 16 | 0 | 4 | 2 | 0 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **结果** | 16 | 0 | 4 | 2 | 0 |'
- en: 'Table 1.1: Binary to decimal masking'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1：二进制到十进制的掩码
- en: In the preceding example (*Table 1.1*), resulting total is **22**. This is our
    decimal number corresponding to the binary number 10110.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子（*表1.1*）中，得到的总数是**22**。这是我们对应于二进制数10110的十进制数。
- en: To design our algorithm, it's important to realize that we don't need to store
    the entire conversion sequence. Since we are processing one binary digit at a
    time (starting from the back), we only need to use the conversion number corresponding
    to the binary position we are processing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计我们的算法，重要的是要意识到我们不需要存储整个转换序列。由于我们一次处理一个二进制位（从后向前），我们只需要使用我们正在处理的二进制位置的转换数字。
- en: '*Snippet 1.1* shows us how we can do this. We use a single conversion variable
    instead of a sequence and initialize this variable to the value of one. We then
    use a loop to iterate over the length of the binary string starting from the end.
    While iterating, if the digit at our current position is one, we add the current
    conversion variable to the final result. We then simply double the current conversion
    variable and repeat. The code snippet is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*片段1.1* 展示了我们可以如何做到这一点。我们使用一个单一的转换变量而不是一个序列，并将此变量初始化为1。然后我们使用一个循环从二进制字符串的末尾开始迭代其长度。在迭代过程中，如果当前位置的数字是1，我们将当前的转换变量添加到最终结果中。然后我们简单地双倍当前的转换变量并重复。代码片段如下：'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Snippet 1.1: Binary to decimal. Source class name: BinaryToDecimal.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 片段1.1：二进制到十进制。源类名：BinaryToDecimal。
- en: Go to [https://goo.gl/rETLfq](https://goo.gl/rETLfq) to access the code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/rETLfq](https://goo.gl/rETLfq) 访问代码。
- en: 'Activity: Writing an Algorithm to Convert Numbers from Octal To Decimal'
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：编写将八进制数转换为十进制数的算法
- en: '**Scenario**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: In aviation, the aircraft's transponders transmit a code so that they can identify
    one another. This code uses the octal system, a number system which has a base
    of 8\. We have been asked to write a method to convert octal numbers into decimals.
    For example, the octal number 17 is represented as 15 in the decimal system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在航空领域，飞机的应答器会发送一个代码，以便它们可以相互识别。这个代码使用八进制系统，这是一种基数为8的数制。我们被要求编写一个将八进制数字转换为十进制的方法。例如，八进制数字17在十进制系统中表示为15。
- en: '**Aim**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To be able to adapt the algorithm shown in the previous section to be used in
    a different scenario.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将上一节中显示的算法修改为用于不同的场景。
- en: '**Prerequisites**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'Ensure that you have a class available on the following path:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您在以下路径上有可用的类：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/octaltodecimal/OctalToDecimal.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/octaltodecimal/OctalToDecimal.java)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/octaltodecimal/OctalToDecimal.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/octaltodecimal/OctalToDecimal.java)'
- en: 'You will find the following method that needs implementing:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将找到以下需要实现的方法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have your project set up, you can run the unit test for this activity
    by running the following command:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您已经设置了项目，您可以通过运行以下命令来运行此活动的单元测试：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Steps for Completion**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: The algorithms shown in *Snippet 1.1* the preceding snippets of code can be
    adapted to work with octal numbers instead of binary.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的片段1.1中显示的算法可以修改为与八进制数而不是二进制数一起工作。
- en: Change the base from two to eight. This can be done by changing the conversion
    multiplier variable in *Snippet 1.1*.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基数从二改为八。这可以通过更改片段1.1中的转换乘数变量来实现。
- en: Parse the digit being processed to convert it into an integer. This integer
    can then be multiplied by the conversion variable or result of the power function.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正在处理的数字解析为整数。然后，这个整数可以乘以转换变量或幂函数的结果。
- en: In this first section, we introduced the idea of algorithms by working on a
    simple example. It's important to note that for every problem multiple solutions
    exist. Choosing the right algorithm to solve your problem will depend on several
    metrics, such as performance and memory requirements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过一个简单的示例介绍了算法的概念。需要注意的是，对于每个问题，都存在多种解决方案。选择正确的算法来解决你的问题将取决于几个指标，例如性能和内存需求。
- en: Measuring Algorithmic Complexity with Big O Notation
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用大O符号衡量算法复杂度
- en: Algorithmic complexity is a way to describe the efficiency of an algorithm as
    a relation of its input. It can be used to describe various properties of our
    code, such as runtime speed or memory requirements. It's also a very important
    tool programmers should understand to write efficient software. In this section,
    we will start by describing a scenario, introducing the section, and then dive
    into the details of the various types of complexities and the different techniques
    to measure them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 算法复杂度是一种描述算法效率的方式，它是其输入的关系。它可以用来描述我们代码的各种属性，如运行速度或内存需求。它也是程序员应该理解以编写高效软件的重要工具。在本节中，我们将首先描述一个场景，介绍本节，然后深入探讨各种复杂类型及其不同测量技术的细节。
- en: Complexity Example
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂度示例
- en: Imagine we were given the task of writing a piece of software for air traffic
    control. Specifically, we were asked to write an algorithm that, in a pre-defined
    space and altitude, will ring out an alarm if any two aircraft get too close to
    each other.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被分配了一个编写用于空中交通控制的软件的任务。具体来说，我们被要求编写一个算法，在预定义的空间和高度内，如果任何两架飞机彼此过于接近，则发出警报。
- en: 'In our implementation, we solved the problem by computing all possible distances
    between every pair in our airspace and keeping only the minimum distance. If this
    minimum distance is less than a certain threshold, our software will ring out
    an alarm. The following snippet of code shows this solution:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们通过计算我们空域中每一对之间的所有可能距离，并仅保留最小距离来解决该问题。如果这个最小距离小于某个特定阈值，我们的软件将发出警报。以下代码片段展示了这个解决方案：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 1.2: Minimum distance. Source class name: ClosestPlane and Point.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段1.2：最小距离。源类名：ClosestPlane和Point。
- en: Note that the `Point` class in the preceding piece of code is not shown. Go
    to [https://goo.gl/iDHD5J](https://goo.gl/iDHD5J) to access the code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前一段代码中的`Point`类没有显示。请访问[https://goo.gl/iDHD5J](https://goo.gl/iDHD5J)以获取代码。
- en: Our little algorithm works fine for a couple of years and the controllers are
    happy to have this useful alerting. However, over the years, air traffic increases
    at a fast rate, and instead of having to monitor a few hundred aircraft at any
    given time, our algorithm has to handle tens of thousands of points. At busy times,
    the software is having trouble keeping up with the increased load.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小算法在几年内运行良好，控制器们对这种有用的警报功能感到满意。然而，随着时间的推移，空中交通量以很快的速度增长，我们不再需要监控几百架飞机，我们的算法必须处理成千上万的点。在繁忙时段，软件难以跟上增加的负载。
- en: We are called in to investigate and we start to write some benchmarks to test
    how fast the algorithm performs. We obtain the timings shown in *Table 1.2*. As
    you can see, we are doubling the load on every run; however, our algorithm is
    not scaling up in the same manner. Our algorithm is not slowing down at the same
    rate as our input.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被召集来调查，并开始编写一些基准测试来测试算法的性能。我们获得了*表1.2*中所示的计时结果。正如你所见，我们在每次运行中都加倍了负载；然而，我们的算法并没有以同样的方式扩展。我们的算法没有以与输入相同的速率减慢。
- en: Intuitively, you may expect that if you double the number of planes, the algorithm
    has, then you have twice the amount of work to do, and as a result, it should
    take twice as long. However, this is not what is happening.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地讲，你可能期望如果你加倍飞机的数量，算法的工作量也将加倍，因此它应该需要两倍的时间。然而，情况并非如此。
- en: When we double the number of planes, the time taken doesn't just double but
    skyrockets.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将飞机数量加倍时，所需的时间不仅仅是加倍，而是急剧上升。
- en: For example, our algorithm takes 2.6 seconds (2,647 ms) to finish when it's
    dealing with 16,000 planes. However, if we double the amount of planes to 32,000,
    the time it takes increases to 10.4 seconds (10,488 ms), a four-fold increase!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们的算法处理16,000架飞机时，它需要2.6秒（2,647毫秒）来完成。然而，如果我们把飞机的数量加倍到32,000，所需的时间增加到10.4秒（10,488毫秒），增加了四倍！
- en: '| **Number of planes** | **Time taken (ms)** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **飞机数量** | **耗时（毫秒）** |'
- en: '| 1000 | 27 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 27 |'
- en: '| 2000 | 48 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 2000 | 48 |'
- en: '| 4000 | 190 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 4000 | 190 |'
- en: '| 8000 | 664 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 8000 | 664 |'
- en: '| 16000 | 2647 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 16000 | 2647 |'
- en: '| 32000 | 10488 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 32000 | 10488 |'
- en: 'In the following graph, we plot the benchmark results in a chart. What is going
    on here? Our algorithm is doing a lot of work due to the nested loop. For every
    plane point in its input, it''s calculating the distance to every other plane.
    This results in *n²* calculations, where *n* is the number of planes we are monitoring.
    We can say that our algorithm has a runtime performance of *O(n²)*, read as <q
    class="pcalibre5 pcalibre4 calibre33">big O of n squared</q>. Alternatively, we
    can also call it the quadratic runtime performance. Take a look at this graph:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图表中，我们以图表的形式展示了基准测试结果。这里发生了什么？由于嵌套循环，我们的算法做了大量工作。对于输入中的每一个平面点，它都会计算到其他每个平面的距离。这导致了
    *n²* 次计算，其中 *n* 是我们监控的平面数量。我们可以说，我们的算法具有 *O(n²)* 的运行性能，读作 <q class="pcalibre5
    pcalibre4 calibre33">大O的平方</q>。或者，我们也可以称之为二次运行性能。看看这个图表：
- en: '![](img/46610d5d-85aa-46c3-ac1a-e268073faec6.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46610d5d-85aa-46c3-ac1a-e268073faec6.png)'
- en: 'Figure 1.1: Algorithm benchmark result plot'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：算法基准测试结果图
- en: The algorithm listed in *Snippet 1.2* is a slow solution for the closest pair
    problem. There exists a much more efficient solution that involves a divide and
    conquer technique.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列在 *片段1.2* 中的算法是解决最近对问题的一个慢速解决方案。存在一个更高效的解决方案，它涉及分而治之的技术。
- en: This class of algorithms is explored in detail in the second part of this book
    in [Chapter 4](da07fa18-a8ce-4d4c-91eb-9dc893de7273.xhtml), *Algorithm Design
    Paradigms*, where we present a faster solution to the closest pair problem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第二部分详细探讨了这类算法，在 [第4章](da07fa18-a8ce-4d4c-91eb-9dc893de7273.xhtml)，*算法设计范式*
    中，我们提出了一个解决最近对问题的更快解决方案。
- en: Increasing the input load on your code does not always mean that the resource
    consumption will also increase in a directly proportional manner. The relation
    between the input size of your problem and resource usage (CPU time, memory, and
    so on) is what this section is all about.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 增加代码的输入负载并不总是意味着资源消耗会以直接成比例的方式增加。本节讨论的是问题的输入大小与资源使用（CPU时间、内存等）之间的关系。
- en: In the next section, we will see different types of these relations between
    the problem, input size, and resource usage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到不同类型的问题、输入大小和资源使用之间的关系。
- en: Understanding Complexity
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解复杂性
- en: 'To better understand algorithmic complexity, we can make use of an analogy.
    Imagine that we were to set different types of algorithms so that they compete
    against one another on a race track. However, there is a slight twist: The race
    course has no finish line.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解算法复杂度，我们可以使用一个类比。想象一下，我们将不同类型的算法设置在赛道上相互竞争，但是有一个小小的转折：赛道上没有终点线。
- en: Since the race is infinite, the aim of the race is to surpass the other, slower
    opponents over time and not to finish first. In this analogy, the race track distance
    is our algorithm input. How far from the start we get, after a certain amount
    of time, represents the amount of work done by our code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于比赛是无限的，比赛的目标是在一段时间内超越其他较慢的对手，而不是首先完成。在这个类比中，赛道距离是我们的算法输入。经过一段时间后，我们从起点出发的距离代表了我们的代码完成的工作量。
- en: Recall the quadratic method for measuring the closest pair of planes in the
    preceding section. In our fictitious race, the quadratic algorithm starts quite
    fast and is able to move quite a distance before it starts slowing down, similar
    to a runner that is getting tired and slowing down. The further it gets away from
    the start line, the slower it gets, although it never stops moving.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一节中测量最近一对平面的二次方法。在我们的虚构比赛中，二次算法开始时相当快，能够在开始减速之前移动相当的距离，类似于一个开始感到疲劳并减速的跑步者。它离起跑线越远，速度越慢，尽管它从未停止移动。
- en: Not only do the algorithms progress through the race at different speeds, but
    their way of moving varies from one type to another. We already mentioned that
    *O(n²)* solutions slow down as they progress along the race. How does this compare
    to the others?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅算法在比赛中以不同的速度前进，它们的移动方式也各不相同。我们已经提到，*O(n²)* 解决方案在比赛中会减速。这与其他算法相比如何？
- en: Another type of runner taking part in our imaginary race is the linear algorithm.
    Linear algorithms are described with the notation of *O(n)*. Their speed on our
    race track is constant. Think of them as an old, reliable car moving at the same
    fixed speed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想象的比赛中，还有另一种类型的参赛者，那就是线性算法。线性算法用 *O(n)* 的符号来描述。它们在赛道上的速度是恒定的。把它们想象成一辆老而可靠的汽车，以固定的速度行驶。
- en: In real life, solutions that have an *O(n)* runtime complexity have a running
    performance that is directly proportional to the size of their input.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，具有 *O(n)* 运行时间复杂度的解决方案，其运行性能与输入大小成正比。
- en: This means, for example, that if you double the input size of a linear algorithm,
    the algorithm would also take about twice as long to finish.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，如果你将线性算法的输入规模加倍，该算法完成所需的时间也会大约加倍。
- en: The efficiency of each algorithm is always evaluated in the long run. Given
    a big enough input, a linear algorithm will always perform better than a quadratic
    one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个算法的效率总是从长远来看进行评估的。给定足够大的输入，线性算法总是会比二次算法表现得更好。
- en: We can go much quicker than *O(n)*. Imagine that our algorithm is continually
    accelerating along the track instead of moving constantly. This is the opposite
    of quadratic runtime. Given enough distance, these solutions can get really fast.
    We say that these type of algorithms have a logarithmic complexity written as
    *O(log n)*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以比 *O(n)* 快得多。想象一下，我们的算法在轨道上不断加速，而不是持续移动。这与二次运行时间相反。给定足够的距离，这些解决方案可以变得非常快。我们说这类算法具有对数复杂度，表示为
    *O(log n)*。
- en: In real life, this means that the algorithm doesn't slow much as the size of
    the input increases. Again, it doesn't matter if at the start, the algorithm performs
    slower than a linear one for a small input, as for a big enough input, a logarithmic
    solution will always outperform the linear one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，这意味着算法在输入规模增加时不会慢很多。同样，如果算法在开始时对于小输入比线性算法慢，那也没有关系，因为对于足够大的输入，对数解决方案总是会优于线性解决方案。
- en: Can we go even faster? It turns out that there is another complexity class of
    algorithms that performs even better.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能更快吗？结果证明，还有一种算法的复杂度类别表现得更好。
- en: Picture a runner in our race who has the ability to teleport in constant time
    to any location along our infinite track. Even if the teleportation takes a long
    time, as long as it's constant and doesn't depend on the distance traveled, this
    type of runner will always beat any other. No matter how long the teleportation
    takes, given enough distance, the algorithm will always arrive there first. This
    is what is known as a constant runtime complexity, written as *O(1)*. Solutions
    that belong to this complexity class will have a runtime independent of the input
    size given.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在我们的比赛中有一个跑者，他有能力在恒定的时间内将任何位置传送到我们无限长的轨道上。即使传感能够花费很长时间，只要它是恒定的，并且不依赖于行进距离，这种类型的跑者总是会击败其他任何跑者。无论传感能够花费多长时间，只要给定足够的距离，算法总是会第一个到达那里。这就是所谓的常数运行时间复杂度，表示为
    *O(1)*。属于这个复杂度类别的解决方案将具有与输入大小无关的运行时间。
- en: On the other side of the spectrum, we can find algorithms that are much slower
    than quadratic ones. Complexities such as cubic with *O(n³)* or quartic with *O(n⁴)*
    are examples. All of the mentioned complexities up to this point are said to be
    polynomial complexities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，我们可以找到比二次算法慢得多的算法。例如，立方复杂度 *O(n³)* 或四次复杂度 *O(n⁴)*。到目前为止提到的所有这些复杂度都被认为是多项式复杂度。
- en: A polynomial is simply a mathematical term used for expressions. Expressions
    such as *3x⁵ + 2x³ + 6*, *2x – 3*, or even just 5 are all good examples. The key
    here is that polynomial complexities are of the form *O(n^k)*, where *k* is a
    positive, non-fractional constant.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式是一个用于表达式的数学术语。例如，*3x⁵ + 2x³ + 6*、*2x – 3*，甚至仅仅是5，都是很好的例子。关键在于多项式的复杂度形式为 *O(n^k)*，其中
    *k* 是一个正的、非分数的常数。
- en: Not all solutions have a polynomial time behavior. A particular class of algorithms
    scale really badly in proportion to their input with a runtime performance of
    *O(k^n)*. In this class, the efficiency degrades exponentially with the input
    size. All the other types of polynomial algorithms will outperform any exponential
    one pretty fast. *Figure 1.2* shows how this type of behavior compares with the
    previously mentioned polynomial algorithms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有解决方案都具有多项式时间行为。一类特定的算法在输入规模与运行时间性能成比例增长时表现非常糟糕，其运行时间为 *O(k^n)*。在这个类别中，效率随着输入规模的增加呈指数级下降。所有其他类型的多项式算法将很快超越任何指数算法。*图1.2*
    展示了这种类型的行为与之前提到的多项式算法的比较。
- en: 'The following graph also shows how fast an exponential algorithm degrades with
    input size:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表也显示了指数算法随着输入规模的增加而退化的速度：
- en: '![](img/2ad23cb2-ff94-449b-bc0c-a80344f0c926.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ad23cb2-ff94-449b-bc0c-a80344f0c926.png)'
- en: 'Figure 1.2: Operations performed versus input size for different algorithms'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：不同算法的运算次数与输入大小的关系
- en: How much faster does a logarithmic algorithm perform versus a quadratic one?
    Let's try to pick a particular example. A specific algorithm performs about two
    operations to solve a problem; however, the relation to its input is *O(n²)*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对数算法相对于二次算法快多少？让我们尝试选择一个特定的例子。一个特定的算法大约执行两次操作来解决一个问题；然而，它与输入的关系是 *O(n²)*。
- en: 'Assuming each operation is a slow one (such as file access) and has a constant
    time of about 0.25 milliseconds, the time required to perform those operations
    will be as shown in *Table 1.3*. We work out the timings by *Time = 0.25 * operations
    * n²*, where operations is the number of operations performed (in this example
    it''s equal to 2), *n* is the input size, and *0.25* is the time taken per operation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个操作都是一个慢操作（例如文件访问），并且具有大约0.25毫秒的恒定时间，执行这些操作所需的时间将如 *表1.3* 所示。我们通过 *时间 = 0.25
    * 操作数 * n²* 来计算时间，其中操作数是执行的操作次数（在这个例子中等于2），*n* 是输入大小，*0.25* 是每次操作的时间：
- en: '| **Input Size (n)** | **Time: 2 operations O(n²)** | **Time: 400 operations
    O(log n)** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **输入大小 (n)** | **时间：2次操作 O(n²)** | **时间：400次操作 O(log n)** |'
- en: '| 10 | 50 milliseconds | 100 milliseconds |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 50毫秒 | 100毫秒 |'
- en: '| 100 | 5 seconds | 200 milliseconds |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 5秒 | 200毫秒 |'
- en: '| 1000 | 8.3 minutes | 300 milliseconds |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 8.3分钟 | 300毫秒 |'
- en: '| 10000 | 13.8 hours | 400 milliseconds |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 10000 | 13.8小时 | 400毫秒 |'
- en: 'Table 1.3: How fast does it run?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.3：运行速度有多快？
- en: Our logarithmic algorithm performs around 400 operations; however, its relation
    to the input size is logarithmic. Although this algorithm is slower for a smaller
    input, it quickly overtakes the quadratic algorithm. You can notice that, with
    a large enough input, the difference in performance is huge. In this case, we
    work out the timing using *Time = 0.25 * operations * log n*, with *operations
    = 400*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的对数算法大约执行400次操作；然而，它与输入大小的关系是对数级的。尽管这个算法在较小的输入上较慢，但它很快就会超过二次算法。你可以注意到，对于足够大的输入，性能差异是巨大的。在这种情况下，我们使用
    *时间 = 0.25 * 操作数 * log n* 来计算时间，其中 *操作数 = 400*。
- en: 'Activity: Developing a Timing Table Using the Exponential Algorithm'
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动内容：使用指数算法开发时间表
- en: '**Scenario**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We have been asked to develop a timing table using an input size of 2, 10, 30,
    and 50 for an exponential algorithm of *O(2^n)*. Assume an operation time of 0.5
    ms and that the algorithm only performs one operation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求使用输入大小为2、10、30和50的指数算法开发一个时间表。假设操作时间为0.5毫秒，并且算法只执行一个操作。
- en: '**Aim**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To discover how badly exponential algorithms scale.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现指数算法的规模如何变得糟糕。
- en: '**Steps for Completion**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 0.5 x 2² = 2 ms
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0.5 x 2² = 2毫秒
- en: 0.5 x 2^(10) = 512 ms
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0.5 x 2^(10) = 512毫秒
- en: 0.5 x 2^(30) = 0.536 billion ms = 6.2 days
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0.5 x 2^(30) = 0.536亿毫秒 = 6.2天
- en: 0.5 x 2^(50) = 5.629 and 10^(14) ms = 17838 years
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0.5 x 2^(50) = 5.629 和 10^(14)毫秒 = 17838年
- en: '**Output**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: 'The results may be as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能如下：
- en: '| **Input Size (n)** | **Time : 1 Operations O(2^n)** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **输入大小 (n)** | **时间：1次操作 O(2^n)** |'
- en: '| 2 | 2 milliseconds |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2毫秒 |'
- en: '| 10 | 512 milliseconds |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 512毫秒 |'
- en: '| 30 | 6.2 days |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 6.2天 |'
- en: '| 50 | 17838 years |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 17838年 |'
- en: 'Table 1.4: Timings for the O(2^n) algorithm'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.4：O(2^n)算法的时间表
- en: In this section, we have compared different types of algorithmic runtime complexities.
    We have seen how each compares against the others, starting from the theory's
    fastest of *O(1)* to some of the slowest with *O(k^n)*. It's also important to
    understand that there is a difference between theory and practice. For example,
    in real life, a quadratic algorithm may outperform a linear one if the operations
    performed are less, the input is a fixed size, and is small.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们比较了不同类型的算法运行时间复杂度。我们看到了每种算法是如何与其他算法相比的，从理论上的最快*O(1)*到一些最慢的*O(k^n)*。理解理论与实践之间的差异也很重要。例如，在现实生活中，如果执行的操作较少，输入是固定大小且较小，二次算法可能比线性算法表现更好。
- en: Complexity Notation
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂度符号
- en: In the previous section, we have seen how we can use the big O notation to measure
    the runtime performance to our algorithms in proportion to the input size. We
    have neither examined in detail what *O(n)* really means nor have we considered
    the performance of our algorithm in relation to the type of input it's given.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用大O符号来衡量算法的运行性能，与输入大小的比例。我们既没有详细检查*O(n)*究竟意味着什么，也没有考虑算法相对于给定输入类型的性能。
- en: 'Consider the following code snippet. The method accepts an array containing
    a string and searches for a match. If one is found, the index of the array is
    returned. We will use this example and try to measure the runtime complexity.
    The code is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段。该方法接受一个包含字符串的数组并搜索匹配项。如果找到匹配项，则返回数组的索引。我们将使用这个例子来尝试测量运行时间复杂度。代码如下：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snippet 1.3: Array search. Source class name: ArraySearch.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Snippet 1.3：数组搜索。源类名：ArraySearch。
- en: Go to [https://goo.gl/egw1Sn](https://goo.gl/egw1Sn) to access the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/egw1Sn](https://goo.gl/egw1Sn)访问代码。
- en: There are a number of operations happening inside the loop. The obvious ones are
    the arrays accessing at `i` and the string `equals`. However, we also have the
    increment of `i`, the assignment of the new incremented value to `i` and the comparison
    of `i` being less than the length of the array. However, this is not the end of
    the story. The `equals()` method is also matching each character of the string
    to an element at `i` in the array.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部发生了很多操作。最明显的操作是在`i`位置访问数组和字符串`equals`。然而，我们还有`i`的递增、将新的递增值赋给`i`以及比较`i`是否小于数组长度的操作。但是，这并不是故事的结束。`equals()`方法还在将字符串的每个字符与数组中`i`位置的元素进行匹配。
- en: 'The following table lists all these operations:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了所有这些操作：
- en: '| **Operation name** | **Code** | **Count** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **操作名称** | **代码** | **计数** |'
- en: '| Array access | `strArray[i]` | 1 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 数组访问 | `strArray[i]` | 1 |'
- en: '| String equality | `.equals(strToMatch)` | String length |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 字符串相等 | `.equals(strToMatch)` | 字符串长度 |'
- en: '| Array pointer increment and assignment | `i = i + 1` | 2 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 数组指针递增和赋值 | `i = i + 1` | 2 |'
- en: '| Reading array length and comparing to pointer | `i < strArray.length` | 2
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 读取数组长度并与指针比较 | `i < strArray.length` | 2 |'
- en: 'Table 1.5: Operations performed in the ArraySearch method for every item'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.5：ArraySearch方法对每个项执行的操作
- en: We have seen that for each processed item in the search array, we perform *5
    + m* operations, where *m* is the length of the search string. The next aspect
    to look at is to work out how often we perform this. The number of times we perform
    the operations mentioned in *Table 1.5* doesn't just rely on the length of our
    input; it also depends on how quick we are in finding our match in the input array,
    that is, it depends on the actual array's contents.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，对于搜索数组中每个处理的项，我们执行*5 + m*次操作，其中*m*是搜索字符串的长度。接下来要考虑的方面是如何确定我们执行这些操作的频率。执行*表1.5*中提到的操作次数不仅依赖于输入的长度，还取决于我们在输入数组中找到匹配项的速度，也就是说，它取决于实际数组的实际内容。
- en: The best case of an algorithm is when the input causes the algorithm to perform
    in the most efficient manner possible. The worst case is the opposite, which is
    when a particular input makes it behave in the least efficient manner possible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 算法最好的情况是输入导致算法以尽可能高效的方式进行操作。最坏的情况则相反，即特定输入使它以尽可能低效的方式进行操作。
- en: If we are lucky and the item we are searching for is located in the first element
    of the search array, we perform only *5 + m* operations. This is the best case
    and is the fastest manner our search can compute.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们很幸运，要搜索的项位于搜索数组的第一个元素，我们只需执行*5 + m*次操作。这是最佳情况，也是搜索可以计算的最快方式。
- en: The worst case of this algorithm is either when our item is at the end of the
    array or when the item is not found at all. Both of these scenarios will have
    us then check the entire contents of the array. In the worst case, we end up performing
    *n(5 + m)* operations, where *n* is the array size.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的最坏情况是当我们的项目在数组的末尾，或者当项目根本找不到。这两种情况都会让我们检查数组的全部内容。在最坏的情况下，我们最终执行 *n(5 +
    m)* 次操作，其中 *n* 是数组大小。
- en: In this example, we can say that the worst-case runtime complexity for our algorithm
    is *O(mn)* and our best case, when our algorithm finds a match immediately, is
    *O(m)*. We will see in the following sub-section how we arrive at this result
    from *5 + m* and *n(5 + m)*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以说，我们算法的最坏情况运行时间复杂度是 *O(mn)*，而我们的最佳情况，当我们的算法立即找到匹配项时，是 *O(m)*。我们将在以下子节中看到，我们是如何从
    *5 + m* 和 *n(5 + m)* 得到这个结果的。
- en: Another algorithmic analysis that is commonly used is the average case performance.
    The average case complexity can be found by averaging the performance over all
    possible inputs. This is useful, as in certain scenarios, the worst case has a
    low chance of occurring.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常用的算法分析是平均情况性能。平均情况复杂度可以通过对所有可能的输入的平均性能来找到。这在某些情况下是有用的，因为最坏情况发生的可能性很低。
- en: Although we have the best, average, and worst-case complexities, the worst case
    is usually the most used when measuring and comparing different algorithms to
    one another. Apart from runtime performance, the other most common use of big
    O notation is to measure memory requirements. However, it can be used for any resource,
    such as disk space or network usage.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有最佳、平均和最坏情况复杂度，但在测量和比较不同算法时，通常最常用的是最坏情况。除了运行时性能外，大 O 符号的最常见用途是测量内存需求。然而，它可以用于任何资源，例如磁盘空间或网络使用。
- en: Identifying the Best and Worst Performance of an Algorithm While Checking for
    Duplicates in an Array
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在检查数组中的重复项时，识别算法的最佳和最坏性能
- en: We want to determine the complexity of an algorithm checking for duplicates
    in an array by considering the best and worst case performance. Find the number
    of operations performed in the *Snippet 1.4* for both the worst and best case.
    There is no need to work out the algorithmic complexity in big O notation. Assume
    that the inner loop results in eight operations every time it executes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过考虑最佳和最坏情况性能来确定检查数组中重复项的算法的复杂度。找出 *Snippet 1.4* 中最坏和最佳情况下的操作次数。不需要计算出大
    O 符号中的算法复杂度。假设内部循环每次执行都会产生八次操作。
- en: 'For the outer loop, assume four operations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外部循环，假设四个操作：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 1.4: Checking for duplicates. Source class name: Duplicates.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Snippet 1.4：检查重复项。源类名：Duplicates。
- en: Go to [https://goo.gl/wEUqYk](https://goo.gl/wEUqYk) to access the code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/wEUqYk](https://goo.gl/wEUqYk) 访问代码。
- en: 'To do this, we should perform the following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们应该执行以下步骤：
- en: In the worst- case, we execute the inner loop *n* times (array length).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最坏的情况下，我们执行内部循环 *n* 次（数组长度）。
- en: In the best case, we only execute the inner loop only twice.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最佳情况下，我们只执行内部循环两次。
- en: The best case is when the duplicate numbers are in the front of the input array.
    The worst is when the array doesn't contain any duplicates.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳情况是重复数字在输入数组的开头。最坏的情况是数组不包含任何重复项。
- en: 'The worst case is when the array doesn''t contain duplicates and is of size
    *n*:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最坏的情况是数组不包含重复项且大小为 *n*：
- en: For the outer loop, we have *4*n* operations
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于外部循环，我们有 *4*n* 次操作
- en: For the inner loop, we have *n*(n*8)* operations
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内部循环，我们有 *n*(n*8)* 次操作
- en: In total, we have *4n + 8n²* operations
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总共，我们有 *4n + 8n²* 次操作
- en: 'In the best case, the duplicates are the first two items in the array:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最佳情况下，重复项是数组的头两个项目：
- en: For the outer loop, we have *4* operations
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于外部循环，我们有 *4* 次操作
- en: For the inner loop, we have *2*8* operations as the inner loop executes twice
    to get to the second item in the array where the duplicate is located
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内部循环，我们有 *2*8* 次操作，因为内部循环执行两次才能到达数组中的第二个项目，即重复项所在的位置
- en: In total, we have 20 operations
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总共，我们有 20 次操作
- en: We have seen how we can analyze the number of operations performed in an algorithm
    and how we can use big O notation to describe the best and worst case. We also
    discussed how the notation can be used to describe any resource usage. In the
    next section, we'll describe some basic rules that are used when using the notation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何分析算法中执行的操作的数量，以及如何使用大O符号来描述最佳和最坏情况。我们还讨论了如何使用该符号来描述任何资源的使用。在下一节中，我们将描述在使用符号时使用的一些基本规则。
- en: '**Notation Rules**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号规则**'
- en: There are two simple rules to follow when we want to express an algorithm using
    the big O notation. In this section, we will understand how to convert the expression
    from *4n + 8n²* to the big O notation equivalent.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要用大O符号表示一个算法时，有两个简单的规则需要遵循。在本节中，我们将了解如何将表达式从 *4n + 8n²* 转换为大O符号的等价形式。
- en: The first rule to follow is to drop any constants.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循的第一个规则是丢弃任何常数。
- en: For example, *3n + 4* becomes *n* and, a single constant such as *5* becomes
    *1*. If an algorithm simply has *4* constant instructions that don't depend on
    the input, we say the algorithm is *O(1)*, also known as **constant time complexity**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*3n + 4* 变为 *n*，单个常数如 *5* 变为 *1*。如果一个算法只有 *4* 个不依赖于输入的常数指令，我们说该算法是 *O(1)*，也称为**常数时间复杂度**。
- en: The second rule is to drop everything except the highest order.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个规则是丢弃除了最高阶之外的所有内容。
- en: To understand why we adopt the second rule, it's important to realize that for
    a large value of *n*, anything but the highest order becomes irrelevant. When
    we have a large enough input, the performance difference is negligible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们为什么采用第二个规则，重要的是要意识到对于足够大的 *n*，除了最高阶之外的所有内容都变得无关紧要。当我们有足够大的输入时，性能差异是可以忽略不计的。
- en: Consider an algorithm that performs *n + n² + n³*. The highest order variable
    of this is the *n³* part. If we keep the highest order, we end up with a big O
    runtime complexity of *O(n³)*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个执行 *n + n² + n³* 的算法。这个算法的最高阶变量是 *n³* 部分。如果我们保留最高阶，我们最终得到的大O运行时复杂度为 *O(n³)*。
- en: 'Activity: Converting Expressions to Big O Notations'
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：将表达式转换为大O符号
- en: '**Scenario**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: To convert the expression *3mn + 5mn^(4 )+2n^(2 )+ 6* to a big O notation, firstly
    we drop any constants from the expression, leaving us with *mn+mn⁴+n²*. Next,
    we simply keep the highest order part, which results in *O(mn⁴)*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将表达式 *3mn + 5mn^(4) + 2n^(2) + 6* 转换为大O符号，首先我们从表达式中删除任何常数，留下 *mn + mn⁴ + n²*。然后，我们只需保留最高阶部分，这导致结果为
    *O(mn⁴)*。
- en: 'For each of the expressions found in *Table 1.6*, find the equivalent in big
    O notation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 *表1.6* 中找到的每个表达式，找到其大O符号的等价形式：
- en: '| **Expression** | *3mn* | *5n + 44n² + 4* | *4 + 5 log n* | *3^n + 5n² + 8*
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | *3mn* | *5n + 44n² + 4* | *4 + 5 log n* | *3^n + 5n² + 8* |'
- en: 'Table 1.6: Find big O equivalent'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.6：找到大O等价
- en: '**Aim**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To apply notation rules to convert expressions into big O notations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 应用符号规则将表达式转换为大O符号。
- en: '**Steps for completion**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'Identify and drop the constants in the expression:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别并删除表达式中的常数：
- en: '*3mn → No constants → 3mn*'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3mn → 无常数 → 3mn*'
- en: '*5n + 44n² + 4 → 4 → 5n + 44n²*'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*5n + 44n² + 4 → 4 → 5n + 44n²*'
- en: '*4 + 5 log n → 4 → 5 log n*'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*4 + 5 log n → 4 → 5 log n*'
- en: '*3^n + 5n² + 8 → 8 → 3^n + 5n²*'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3^n + 5n² + 8 → 8 → 3^n + 5n²*'
- en: 'Drop everything except the highest-order part:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 丢弃除了最高阶部分之外的所有内容：
- en: '*3mn → O(mn)*'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3mn → O(mn)*'
- en: '*5n + 44n^(2 )→ O(n²)*'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*5n + 44n² → O(n²)*'
- en: '*5 log n → O(log n)*'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*5 log n → O(log n)*'
- en: '*3^n + 5n^(2 )→ O(3^n)*'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3^n + 5n^(2) → O(3^n)*'
- en: '**Output**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: 'The outcome may be as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能如下：
- en: '| **Expression** | *3mn* | *5n + 44n² + 4* | *4 + 5 log n* | *3^n + 5n² + 8*
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | *3mn* | *5n + 44n² + 4* | *4 + 5 log n* | *3^n + 5n² + 8* |'
- en: '| **Solution** | *O(mn)* | *O(n²)* | *O(log n)* | *O(3^n)* |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **解决方案** | *O(mn)* | *O(n²)* | *O(log n)* | *O(3^n)* |'
- en: 'Table 1.7: Solution to find big O equivalent activity'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.7：找到大O等价活动的解决方案
- en: In this section, we have explored two simple rules used for converting expressions
    to big O notations. We have also learned why we keep only the highest-order from
    the expression. In the next section, we shall see some examples of algorithms
    with different complexities.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了用于将表达式转换为大O符号的两个简单规则。我们还学习了为什么我们只保留表达式的最高阶。在下一节中，我们将看到一些具有不同复杂度的算法的示例。
- en: Identifying Algorithms with Different Complexities
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别具有不同复杂度的算法
- en: In this section, we shall look into examples of different complexities. This
    is important so that we can learn to recognize algorithms that belong to different
    complexity classes and possibly attempt improving the performance of each.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不同复杂度的示例。这很重要，这样我们就可以学会识别属于不同复杂度类的算法，并可能尝试提高每个算法的性能。
- en: Figuring out the worst case complexity can be quite difficult for some algorithms.
    Sometimes, this requires some experience and is best learned by looking at many
    examples and getting familiar with different types of algorithms.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 确定某些算法的最坏情况复杂度可能相当困难。有时，这需要一些经验，并且最好是通过查看许多示例并熟悉不同类型的算法来学习。
- en: Linear Complexity
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性复杂度
- en: Linear algorithms are the ones where the work done varies in direct proportion
    with the input size, that is, if you double the input size, you double the work
    done. These typically involve a single pass through the input.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 线性算法是那些工作量与输入大小成正比的算法，也就是说，如果你加倍输入大小，你也会加倍工作量。这些通常涉及对输入的单次遍历。
- en: The problem presented in this example is that of counting the number of occurrences
    of a particular character in a string. Imagine we are given the string <q class="pcalibre5
    pcalibre4 calibre33">Sally sells sea shells on the seashore</q>, and we want to
    find out the number of occurrences of the letter *a*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中提出的问题是计算字符串中特定字符的出现次数。想象一下，我们被给出了字符串“Sally sells sea shells on the seashore”，我们想找出字母*a*出现的次数。
- en: 'The following code in *Snippet 1.5* goes through each character in the input
    string and if the character at the current position matches the search letter,
    a counter is increased. At the end of the loop, the final count is returned. The
    code is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*片段1.5*中的以下代码遍历输入字符串中的每个字符，如果当前位置的字符与搜索字母匹配，则计数器增加。循环结束时，返回最终计数。代码如下：'
- en: '[PRE6]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 1.5: Count the number of characters in a string. Source class name:
    CountChars.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 片段1.5：计算字符串中的字符数。源类名：CountChars。
- en: Go to [https://goo.gl/M4Vy7Y](https://goo.gl/M4Vy7Y) to access the code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/M4Vy7Y](https://goo.gl/M4Vy7Y)以获取代码。
- en: Linear complexity algorithms are the most common types of algorithms. These
    usually make a single pass on the input and thus scale proportionally with the
    input size. In this section, we have seen one such example.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 线性复杂度算法是最常见的算法类型。这些通常对输入进行单次遍历，因此与输入大小成比例。在本节中，我们已经看到了这样一个例子。
- en: The algorithm is linear because its runtime is directly proportional to the
    string length. If we take the string length to be *n*, the runtime complexity
    of this Java method is *O(n)*. Notice the single loop varying according to the
    input size. This is very typical of linear runtime complexity algorithms, where
    a constant number of operations are performed for each input unit. The input unit
    in this example is each character in the string.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法是线性的，因为其运行时间与字符串长度成正比。如果我们取字符串长度为*n*，则此Java方法的运行时间复杂度为*O(n)*。注意，根据输入大小变化的单个循环。这非常典型于线性运行时间复杂度算法，其中对每个输入单元执行固定数量的操作。在这个例子中，输入单元是字符串中的每个字符。
- en: Quadratic Complexity
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二次复杂度
- en: 'Quadratic complexity algorithms are not very performant for large input sizes.
    The work done increases following a quadratic proportion as we increase our input
    size. We already saw an example of a *O(n²)* in our minimum distance solution
    in *Snippet 1.2*. There are many other examples, such as bubble and selection
    sorting. The problem presented in this example is about finding the common elements
    contained in two arrays (assuming no duplicate values exist in each array), producing
    the intersection of the two inputs. This results in a runtime complexity of *O(mn)*,
    where *m* and *n* are the sizes of the first and second input arrays. If the input
    arrays are the same size as *n* elements, this results in a runtime of *O(n²)*.
    This can be demonstrated with the help of the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 二次复杂度算法对于大输入大小来说性能不佳。随着我们增加输入大小，工作量按照二次比例增加。我们在*片段1.2*中的最小距离解决方案中已经看到了一个*O(n²)*的例子。还有很多其他例子，比如冒泡排序和选择排序。本例中提出的问题是找出包含在两个数组中的公共元素（假设每个数组中都不存在重复值），产生两个输入的交集。这导致运行时间复杂度为*O(mn)*，其中*m*和*n*是第一个和第二个输入数组的大小。如果输入数组的大小与*n*个元素相同，这将导致运行时间为*O(n²)*。这可以通过以下代码来证明：
- en: '[PRE7]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 1.6: Intersection between two arrays. Source class name: SimpleIntersection.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 片段1.6：两个数组之间的交集。源类名：SimpleIntersection。
- en: Go to [https://goo.gl/uHuP5B](https://goo.gl/uHuP5B) to access the code. There
    is a more efficient implementation of the intersection problem. This involves
    sorting the array first, resulting in an overall runtime of *O(n log n)*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/uHuP5B](https://goo.gl/uHuP5B) 访问代码。存在一个更有效的交集问题实现。这涉及到首先对数组进行排序，从而实现总体运行时间为
    *O(n log n)*。
- en: When calculating the space complexity, the memory consumed for the input arguments
    should be ignored. Only memory allocated inside the algorithms should be considered.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算空间复杂度时，应该忽略输入参数所占用的内存。只有算法内部分配的内存才需要考虑。
- en: The amount of memory we use is dictated by the size of our result listed in
    our method. The bigger this list, the more memory we're using.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的内存量由我们方法中列出的结果大小决定。这个列表越大，我们使用的内存就越多。
- en: The best case is when we use the least amount of memory. This is when the list
    is empty, that is, when we have no common elements between the two arrays. Thus,
    this method has a best case space complexity of *O(1)*, when there is no intersection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳情况是我们使用最少的内存。这是当列表为空时，即当我们两个数组之间没有共同元素时。因此，当没有交集时，这种方法的空间复杂度最佳情况为 *O(1)*。
- en: The worst case is just the opposite, when we have all the elements in both arrays.
    This can happen when the arrays are equal to each other, although the numbers
    may be in a different order. The memory in this case is equal to the size of one
    of our input arrays. In short, the worst space complexity of the method is *O(n)*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏情况正好相反，当我们两个数组中都有所有元素时。当数组相等时，这种情况可能发生，尽管数字可能顺序不同。在这种情况下，内存大小等于我们输入数组的大小。简而言之，该方法的最坏空间复杂度为
    *O(n)*。
- en: In this section, we have shown examples of quadratic algorithms. Many other
    examples exist. In the next chapter, we will also describe a poorly-performing
    sorting algorithm, which is *O(n²)*, called **bubble sort**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了二次算法的示例。还有许多其他示例。在下一章中，我们还将描述一个性能较差的排序算法，其复杂度为 *O(n²)*，称为 **冒泡排序**。
- en: Logarithmic Complexity
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数复杂度
- en: Logarithmic complexity algorithms are very fast, and their performance hardly
    degrades as you increase the problem size. These types of algorithm scale really
    well. Code that has a runtime complexity of *O(log n)* is usually recognizable
    since it systematically divides the input in several steps. Common examples that
    operate in logarithmic times are database indexes and binary trees. If we want
    to find an item in a list, we can do it much more efficiently if the input list
    is sorted in some specific order. We can then use this ordering by jumping to
    specific positions of our list and skipping over a number of elements.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对数复杂度算法非常快，并且随着问题规模的增加，它们的性能几乎不会下降。这些类型的算法扩展性非常好。具有 *O(log n)* 时间复杂度的代码通常很容易识别，因为它会系统地分几个步骤来划分输入。在对数时间内运行的常见示例包括数据库索引和二叉树。如果我们想在列表中查找一个项目，如果输入列表按某种特定顺序排序，我们可以更有效地完成这项任务。然后我们可以通过跳到列表的特定位置并跳过一定数量的元素来使用这种排序。
- en: '*Snippet 1.7* shows an implementation of the binary search in Java. The method
    uses three array pointers—a start, an end, and a midpoint. The algorithm starts
    by checking the middle element in the array. If the element is not found and is
    less than the value at the middle, we choose to search in the lower half; otherwise,
    we choose the upper half. *Figure 1.3* shows the steps involved when doing a binary
    search. The code snippet is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*片段1.7* 展示了Java中二分搜索的实现。该方法使用三个数组指针——开始、结束和中点。算法首先检查数组中的中间元素。如果元素未找到且小于中间的值，我们选择在下半部分进行搜索；否则，我们选择上半部分。*图1.3*
    展示了进行二分搜索时涉及的步骤。代码片段如下：'
- en: '[PRE8]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Snippet 1.7: Binary search. Source class name: BinarySearch.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 片段1.7：二分搜索。源类名：BinarySearch。
- en: Go to [https://goo.gl/R9e31d](https://goo.gl/R9e31d) to access the code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/R9e31d](https://goo.gl/R9e31d) 访问代码。
- en: 'Take a look at the following diagram:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表：
- en: '![](img/7fb57d9b-4d48-4059-8add-761694e069f1.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fb57d9b-4d48-4059-8add-761694e069f1.png)'
- en: 'Figure 1.3: Binary search steps'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：二分搜索步骤
- en: Assuming the worst case scenario, how big would the input size have to be if
    our binary search algorithm is 95 array jumps (such as the one shown in *Figure
    1.3*)? Since this is a binary search, where we're splitting the search space in
    two, we should use a logarithm of base 2.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设最坏情况，如果我们的二分搜索算法需要95次数组跳跃（如 *图1.3* 所示），输入大小需要有多大？由于这是一个二分搜索，我们正在将搜索空间分成两半，因此我们应该使用以2为底的对数。
- en: 'Also, the inverse of a logarithm is the exponential. Thus, we can say the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对数的倒数是指数。因此，我们可以得出以下结论：
- en: '*log[2] n = 95*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*log[2] n = 95*'
- en: '*2^(95) = n*'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2^(95) = n*'
- en: '*39614081257132168796771975168 = n*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*39614081257132168796771975168 = n*'
- en: For the record, *2^(95)* is larger than the number of seconds in the universe
    by far. This example demonstrates how well these types of algorithm scale. Even
    for huge inputs, the number of steps performed stays very small.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 记录在案，*2^(95)*远远大于宇宙中的秒数。这个例子展示了这类算法的扩展性有多好。即使对于巨大的输入，执行步骤的数量仍然非常小。
- en: Logarithmic algorithms are the opposite of exponential ones. As the input gets
    bigger, the rate of performance degradation gets smaller. This is a very desirable
    property as it means that our problem can scale to a huge size and would hardly
    affect our performance. In this section, we gave one such example of this class
    of complexity.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对数算法与指数算法相反。随着输入值的增大，性能退化的速率会减小。这是一个非常理想化的特性，因为它意味着我们的问题可以扩展到非常大的规模，而几乎不会影响我们的性能。在本节中，我们给出了这类复杂度的一个例子。
- en: Exponential Complexity
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指数复杂度
- en: As we have seen previously, algorithms that have an exponential runtime complexity
    scale really poorly. There are many examples of problems for which only an *O(k^n)*
    solution is known. Improving these algorithms is a very dynamic area of study
    in computer science. Examples of these include the traveling salesman problem
    and cracking a password using a brute force approach. Now, let's see an example
    of such problem.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，具有指数运行时间复杂度的算法扩展性非常差。对于许多问题，只知道*O(k^n)*的解决方案。在计算机科学中，改进这些算法是一个非常活跃的研究领域。这些例子包括旅行商问题和使用暴力破解方法破解密码。现在，让我们来看一个这样的问题示例。
- en: A prime number is only divisible by itself and one. The example problem we present
    here is called the **prime factorization problem**. It turns out that if you have
    the right set of prime numbers, you can create any other possible number by multiplying
    them all together. The problem is to find out these prime numbers. More specifically,
    given an integer input, find all the prime numbers that are factors of the input
    (primes that when multiplied together give us the input).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一个质数只能被自身和1整除。我们在这里提出的例子问题被称为**质因数分解问题**。结果是，如果你有一组正确的质数，你可以通过将它们全部相乘来创建任何其他可能的数字。问题是要找出这些质数。更具体地说，给定一个整数输入，找出所有是输入的因数的质数（这些质数相乘给出输入）。
- en: A lot of the current cryptographic techniques rely on the fact that no known polynomial
    time algorithm is known for prime factorization. However, nobody has yet proved
    that one doesn't exist. Hence, if a fast technique to find prime factors is ever
    discovered, many of the current encryption strategies will need to be reworked.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 许多当前的加密技术依赖于这样一个事实：对于质因数分解，没有已知的多项式时间算法。然而，没有人证明过不存在这样的算法。因此，如果发现一种快速找到质因数的方法，许多当前的加密策略将需要重新设计。
- en: '*Snippet 1.8* shows one implementation for this problem, called **trail division**.
    If we take an input decimal number of *n* digits, this algorithm would perform
    in *O(10^n)* in the worst case. The algorithm works by using a counter (called
    **factor** in *Snippet 1.8*) starting at two and checks whether if it''s a factor
    of the input. This check is done by using the modulus operator. If the modulus
    operation leaves no remainder, then the value of the counter is a factor and is
    added to the factor list. The input is then divided by this factor. If the counter
    is not a factor (the mod operation leaves a remainder), then the counter is incremented
    by one. This continues until `x` is reduced to one. This is demonstrated by the
    following code snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*Snippet 1.8*展示了该问题的一个实现，称为**试除法**。如果我们取一个有*n*位数字的输入十进制数，这个算法在最坏情况下会以*O(10^n)*的复杂度运行。该算法通过使用一个计数器（在*Snippet
    1.8*中称为**factor**）从2开始，检查它是否是输入的因数。这个检查是通过使用取模运算符来完成的。如果取模运算没有余数，则计数器的值是一个因数，并将其添加到因数列表中。然后，输入被除以这个因数。如果计数器不是因数（取模运算留下余数），则计数器增加1。这个过程一直持续到`x`减少到1。这可以通过以下代码片段来演示：'
- en: '[PRE9]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Snippet 1.8: Prime factors. Source class name: FindPrimeFactors.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Snippet 1.8：质因数。源类名：FindPrimeFactors。
- en: Go to [https://goo.gl/xU4HBV](https://goo.gl/xU4HBV) to access the code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/xU4HBV](https://goo.gl/xU4HBV)以获取代码。
- en: 'Try executing the preceding code for the following two numbers:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试执行以下两个数字的先前代码：
- en: '*2100078578*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2100078578*'
- en: '*2100078577*'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2100078577*'
- en: Why does it take so long when you try the second number? What type of input
    triggers the worst-case runtime of this code?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么当你尝试第二个数字时花费这么长时间？什么类型的输入会触发此代码的最坏情况运行时间？
- en: The worst case of the algorithm is when the input is a prime number, wherein
    it needs to sequentially count all the way up to the prime number. This is what
    happens in the second input.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的最坏情况发生在输入是质数时，此时它需要依次计数直到质数。这就是第二个输入发生的情况。
- en: On the other hand, the largest prime factor for the first input is only 10,973,
    so the algorithm only needs to count up to this, which it can do quickly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第一个输入的最大质数因子仅为10,973，因此算法只需要计数到这个数，它可以快速完成。
- en: Exponential complexity algorithms are usually best avoided, and an alternate
    solution should be investigated. This is due to its really bad scaling with the
    input size. This is not to say that these types of algorithms are useless. They
    may be suitable if the input size is small enough or if it's guaranteed not to
    hit the worst case.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 指数复杂度算法通常最好避免，应该调查其他解决方案。这是由于其与输入大小的糟糕扩展性。这并不是说这些类型的算法没有用。如果输入大小足够小或者保证不会触发最坏情况，它们可能是合适的。
- en: Constant Complexity
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常数复杂度
- en: The efficiency of constant runtime algorithms remains fixed as we increase the
    input size. Many examples of these exist. Consider, for example, accessing an
    element in an array. Access performance doesn't depend on the size of the array,
    so as we increase the size of the array, the access speed stays constant.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 随着输入大小的增加，常数运行时间算法的效率保持不变。这些例子有很多。例如，考虑访问数组中的一个元素。访问性能不依赖于数组的大小，因此当我们增加数组大小时，访问速度保持不变。
- en: 'Consider the code in *Snippet 1.9*. The number of operations performed remains
    constant, irrespective of the size of the input radius. Such an algorithm is said
    to have a runtime complexity of *O(1)*. The code snippet is as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑*片段1.9*中的代码。执行的操作数量保持不变，无论输入半径的大小如何。这样的算法被称为具有*O(1)*的运行时间复杂度。代码片段如下：
- en: '[PRE10]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Snippet 1.9: Circle circumference. Source class name: CircleOperations.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 片段1.9：圆周长。源类名：CircleOperations。
- en: Go to [https://goo.gl/Rp57PB](https://goo.gl/Rp57PB) to access the code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/Rp57PB](https://goo.gl/Rp57PB)访问代码。
- en: Constant complexity algorithms are the most desirable out of all the complexity
    classes for the best scaling. Many of the simple mathematical functions, such
    as finding the distance between two points and mapping a three-dimensional coordinate
    to a two-dimensional one, all fall under this class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 常数复杂度算法是所有复杂度类别中最理想的，因为它们具有最佳的扩展性。许多简单的数学函数，例如找到两点之间的距离和将三维坐标映射到二维坐标，都属于这一类别。
- en: 'Activity: Developing a Faster Intersection Algorithm'
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：开发更快的交集算法
- en: '**Scenario**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We have already seen an algorithm that produces an intersection between two
    input arrays in *Snippet 1.6*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*片段1.6*中看到了一个产生两个输入数组交集的算法。
- en: We have already shown how the runtime complexity of this algorithm is *O(n²)*.
    Can we write an algorithm with a faster runtime complexity?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了这个算法的运行时间复杂度是*O(n²)*。我们能写一个具有更快运行时间复杂度的算法吗？
- en: To find a solution for this problem, think about how you would you go about
    finding the intersection by hand between two decks of playing cards. Imagine you
    take a subset from each shuffled deck; which technique would you use to find the
    common cards between the first and second deck?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到这个问题的解决方案，考虑你如何手动在两副扑克牌中找到交集。想象你从每副洗好的牌中取一个子集；你会使用什么技术来找到第一副和第二副牌中的共同牌？
- en: '**Aim**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To improve the performance of the array intersection algorithm and reduce its runtime
    complexity.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高数组交集算法的性能并降低其运行时间复杂度。
- en: '**Prerequisites**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'Ensure that you have a class available at:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你有一个类可用：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/improveintersection/Intersection.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/improveintersection/Intersection.java)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/improveintersection/Intersection.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/improveintersection/Intersection.java)'
- en: 'You will find two methods for improving the intersection:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将找到两种改进交集的方法：
- en: 'The slow intersection:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 慢速交集：
- en: '[PRE11]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The empty stub, returning null:'
  id: totrans-266
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空存根，返回 null：
- en: '[PRE12]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use the second, empty stub method, to implement a faster alternative for the intersection
    algorithm.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第二个、空的存根方法，为交集算法实现一个更快的替代方案。
- en: 'Assume that each array has no duplicate values. If you have your project set
    up, you can run the unit test for this activity by running the following command:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设每个数组都没有重复值。如果你已经设置了项目，可以通过运行以下命令来运行此活动的单元测试：
- en: '[PRE13]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Steps for Completion**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'Assume that we have a way to sort the inputs in *O(n log n)*. This is provided
    in the following method:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一种在 *O(n log n)* 时间内对输入进行排序的方法。以下方法提供了这种排序：
- en: '[PRE14]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can use this method to sort one input array, or both, and make the intersection easier.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种方法对一个或两个输入数组进行排序，使交集更容易。
- en: To sort one input array, we can use a binary search on it. The runtime complexity
    is *O(n log n)* for the merge sort plus *O(n log n)* for the binary search
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要对一个输入数组进行排序，我们可以使用二分搜索。运行时间复杂度是归并排序的 *O(n log n)* 加上二分搜索的 *O(n log n)*。
- en: per item in the first list. This is *nlog+ nlog n* which results in a final
    *O(n log n)*.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每一项都在第一个列表中。这是 *nlog+ nlog n*，最终结果是 *O(n log n)*。
- en: Sort both arrays, and have two pointers, one for each array.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对两个数组进行排序，并有两个指针，每个数组一个。
- en: Go through the input arrays in a linear fashion.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以线性方式遍历输入数组。
- en: Advance a pointer if the other pointer is pointing to a larger value.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果另一个指针指向的值更大，则递增一个指针。
- en: If the values at both pointers are equal, both pointers are incremented. The
    runtime complexity for this algorithm is *2 * (n log n)* for the two merge sorts
    plus the *n* for the linear pass after the sorting. This results in *2 * (n log
    n) + n* with a final *O(n log n)*.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个指针指向的值相等，则两个指针都递增。此算法的运行时间复杂度是 *2 * (n log n)*，包括两个归并排序以及排序后的线性遍历的 *n*。这导致
    *2 * (n log n) + n*，最终结果是 *O(n log n)*。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gave an introduction to algorithmic complexity and the notation
    to describe it. We have shown you how big O notation can be used to describe how
    well an algorithm scales as the input gets bigger. We have also seen various examples
    of complexities and shown you how you can intuitively differentiate between them.
    Understanding big O notations comes in handy when you need to design and implement
    new solutions or when you are diagnosing performance issues.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了算法复杂性和描述它的符号。我们向您展示了如何使用大 O 符号来描述算法在输入变大时的扩展情况。我们还看到了各种复杂性的例子，并向您展示了如何直观地区分它们。理解大
    O 符号在您需要设计和实现新解决方案或诊断性能问题时非常有用。
