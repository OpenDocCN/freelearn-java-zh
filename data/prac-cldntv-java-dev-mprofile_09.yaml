- en: '*Chapter 7*: MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：使用Open Liberty、Docker和Kubernetes的MicroProfile生态系统'
- en: 'So far, in the previous chapters of this book, we focused on using the MicroProfile
    APIs to write a cloud-native application. In this chapter, we will look at how
    to run a cloud-native application. One of the features of MicroProfile that sets
    it apart from some other cloud-native application frameworks is that MicroProfile
    offers multiple implementations of the APIs. This reduces the chance of ending
    up locked into a particular implementation or finding that the open source community
    behind the APIs you were utilizing wasn''t as vibrant as you thought and the maintainers
    disappear. In addition, different implementations tend to take different design
    decisions, which may better suit your needs. At the time of writing, there were
    four implementations of the most recent release of the MicroProfile APIs: **Open
    Liberty**, **Payara**, **WebSphere Liberty**, and **WildFly**. In addition, **Helidon**,
    **JBoss EAP**, **KumuluzEE**, and **Quarkus** implement previous versions.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书的前几章中，我们专注于使用MicroProfile API编写云原生应用程序。在本章中，我们将探讨如何运行云原生应用程序。MicroProfile与其他一些云原生应用程序框架的不同之处在于，MicroProfile提供了API的多个实现。这减少了最终陷入特定实现或发现您所利用的API背后的开源社区不如您想象的那么活跃，维护者消失的可能性。此外，不同的实现往往采取不同的设计决策，这可能更适合您的需求。在撰写本文时，MicroProfile
    API的最新版本有四个实现：**Open Liberty**、**Payara**、**WebSphere Liberty**和**WildFly**。此外，**Helidon**、**JBoss
    EAP**、**KumuluzEE**和**Quarkus**实现了之前的版本。
- en: Once you have chosen an implementation, you need to deploy the application into
    production. Increasingly, this is achieved using technologies such as **Docker**,
    **Kubernetes**, and a **Service Mesh**. This will be the focus of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了实现方式，您需要将应用程序部署到生产环境中。越来越普遍的做法是使用**Docker**、**Kubernetes**和**服务网格**等技术。这将是本章的重点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Deploying cloud-native applications to Open Liberty
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将云原生应用程序部署到Open Liberty
- en: Containerizing cloud-native applications using Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器化云原生应用程序
- en: Deploying cloud-native applications to Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将云原生应用程序部署到Kubernetes
- en: MicroProfile and Service Mesh
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile和Service Mesh
- en: In this chapter, you will learn how to configure a MicroProfile application
    to run on Open Liberty, packaging it as a container and deploying it into a Kubernetes
    runtime like Red Hat OpenShift.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何配置MicroProfile应用程序以在Open Liberty上运行，将其打包为容器，并部署到像Red Hat OpenShift这样的Kubernetes运行时中。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To build and run the samples mentioned in this chapter, you will need a Mac
    or PC (Windows or Linux) with the following software:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行本章中提到的示例，您需要一个装有以下软件的Mac或PC（Windows或Linux）：
- en: '**Java Development Kit** (**JDK**) – Java 8 or later: [http://ibm.biz/GetSemerut](http://ibm.biz/GetSemerut)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java开发工具包**（**JDK**）- Java 8或更高版本：[http://ibm.biz/GetSemerut](http://ibm.biz/GetSemerut)'
- en: 'Apache Maven: [https://maven.apache.org](https://maven.apache.org)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Maven：[https://maven.apache.org](https://maven.apache.org)
- en: 'A Git client: [https://git-scm.com](https://git-scm.com)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git客户端：[https://git-scm.com](https://git-scm.com)
- en: 'A Docker client: [https://www.docker.com/products](https://www.docker.com/products
    )'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker客户端：[https://www.docker.com/products](https://www.docker.com/products)
- en: 'The OpenShift client: [https://docs.openshift.com/container-platform/4.6/cli_reference/openshift_cli/getting-started-cli.html](https://docs.openshift.com/container-platform/4.6/cli_reference/openshift_cli/getting-started-cli.html
    )'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift客户端：[https://docs.openshift.com/container-platform/4.6/cli_reference/openshift_cli/getting-started-cli.html](https://docs.openshift.com/container-platform/4.6/cli_reference/openshift_cli/getting-started-cli.html)
- en: All of the source code used in this chapter is available on GitHub at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter07](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter07).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中使用的所有源代码均可在GitHub上找到，地址为[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter07](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter07)。
- en: Deploying cloud-native applications to Open Liberty
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将云原生应用程序部署到Open Liberty
- en: In this section, we will look at how to deploy a MicroProfile application using
    **Open Liberty**. We have chosen Open Liberty because we are committers on Open
    Liberty, but its focus on being current with the latest releases of MicroProfile,
    performance, and ease of use make it a good option for anyone.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用 **Open Liberty** 部署 MicroProfile 应用程序。我们选择 Open Liberty 是因为我们是在
    Open Liberty 的提交者，但它的关注点是保持与最新 MicroProfile 版本的同步、性能和易用性，这使得它成为任何人的好选择。
- en: As you might expect from the name, Open Liberty is an open source Java runtime
    for building and deploying cloud-native applications. It is designed around the
    idea of components called **features** that can be configured to provide just
    enough runtime for your application needs. This means if your application doesn't
    use or need MicroProfile OpenTracing, then you don't need to configure the MicroProfile
    OpenTracing feature and the runtime will be smaller, faster, and leaner – it'll
    be better sized for what your application needs. Open Liberty has a feature for
    programming APIs such as MicroProfile APIs, Java EE, Jakarta EE, and gRPC. It
    also has features for runtime capabilities such as a feature for integrating with
    OpenID Connect for authentication.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从其名称中预期的那样，Open Liberty 是一个开源的 Java 运行时，用于构建和部署云原生应用程序。它围绕称为 **功能** 的组件设计，这些组件可以配置以提供满足您的应用程序需求的最小运行时。这意味着如果您的应用程序不使用或不需要
    MicroProfile OpenTracing，那么您不需要配置 MicroProfile OpenTracing 功能，并且运行时将更小、更快、更精简——它将更适合您的应用程序需求。Open
    Liberty 具有编程 API 的功能，例如 MicroProfile API、Java EE、Jakarta EE 和 gRPC。它还具有运行时功能，例如用于与
    OpenID Connect 集成进行身份验证的功能。
- en: 'Open Liberty is configured primarily using a simple XML file format referred
    to as a `server.xml` file. XML is used for a few reasons:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Open Liberty 主要使用一个简单的 XML 文件格式进行配置，称为 `server.xml` 文件。使用 XML 的原因有几个：
- en: The fact that Java has baked-in support for parsing XML is one of the primary
    reasons.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 内置了对 XML 解析的支持，这是其主要原因之一。
- en: XML models hierarchical configuration very well (unlike a properties format)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 模型非常适合分层配置（与属性格式不同）。
- en: Space characters do not affect the semantic interpretation of the file format
    (unlike YAML).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格字符不影响文件格式的语义解释（与 YAML 不同）。
- en: When parsing the configuration file, Open Liberty takes the approach of ignoring
    any configuration it doesn't understand. This has several advantages. It means
    that a `server.xml` file can contain a configuration that isn't valid for the
    release of Open Liberty being used without causing a startup failure. It also
    means a simple typo in the configuration won't prevent the server from starting
    the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析配置文件时，Open Liberty 采取忽略任何它不理解配置的方法。这有几个优点。这意味着一个 `server.xml` 文件可以包含对正在使用的
    Open Liberty 版本无效的配置，而不会导致启动失败。这也意味着配置中的简单错误不会阻止服务器启动应用程序。
- en: 'One of the core responsibilities of the `server.xml` file is to configure which
    features to load. By using the `server.xml` file to configure which features are
    to be used and by ensuring behavior changes are only introduced via new features,
    Open Liberty guarantees that the behavior of the configuration remains unchanged
    from one release to the next. A simple server configuration that enables all the
    MicroProfile APIs is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.xml` 文件的核心职责之一是配置要加载的功能。通过使用 `server.xml` 文件来配置要使用哪些功能，并通过确保行为更改仅通过新功能引入，Open
    Liberty 保证配置的行为在各个版本之间保持不变。以下是一个简单的服务器配置示例，它启用了所有 MicroProfile API：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open Liberty configuration can be centralized in a single `server.xml` file,
    or it can be split up among many configuration files. This both facilitates both
    sharing of configuration and also separates configuration based on the environment
    the server configuration is deployed to. An example of this might be the use of
    an in-memory database in a development environment, but in production, a database
    such as DB2, Oracle, or MariaDB might be used instead. This is facilitated by
    two mechanisms. The first is a `server.xml` file that can explicitly include another
    `server.xml` file. The second is the use of something referred to as `defaults`
    and `overrides`, that are read before and after the main server configuration
    file. The files in these directories are read in alphabetical order, providing
    predictability in how configuration is read. Configuration files can also be parameterized
    using variable replacement syntax. Variables can be defined in the `server.xml`
    file, as Java system properties, or using environment variables. Variables in
    `server.xml` can be defined multiple times and the last definition of the variable
    will be used for variable resolution. A variable might be defined as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Open Liberty 的配置可以集中在一个单独的 `server.xml` 文件中，也可以分散到多个配置文件中。这既促进了配置的共享，也根据服务器配置部署到的环境分离了配置。一个例子可能是开发环境中使用内存数据库，但在生产中可能使用数据库，如
    DB2、Oracle 或 MariaDB。这通过两种机制实现。第一种是一个可以显式包含另一个 `server.xml` 文件的 `server.xml` 文件。第二种是使用所谓的
    `defaults` 和 `overrides`，这些在主服务器配置文件之前和之后读取。这些目录中的文件按字母顺序读取，提供了配置读取的可预测性。配置文件还可以使用变量替换语法进行参数化。变量可以在
    `server.xml` 文件中定义，作为 Java 系统属性，或使用环境变量。`server.xml` 中的变量可以定义多次，变量的最后定义将用于变量解析。变量的定义可能如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It can then be referenced elsewhere like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它可以在其他地方这样引用：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Variables can also have a default value, which allows configuration to be written
    that will always work while allowing it to be overridden in production:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以有一个默认值，这允许编写始终有效的配置，同时在生产中允许覆盖：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Variables have different precedents based on where they are defined from, allowing
    them to be easily overridden. The precedence order (later precedence overrides
    previous precedence) is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的优先级根据其定义的位置而不同，这使得它们可以轻松覆盖。优先级顺序（后定义的优先级覆盖先定义的优先级）如下：
- en: '`server.xml` default values'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`server.xml`的默认值'
- en: Environment variables
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境变量
- en: The `bootstrap.properties` file
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bootstrap.properties` 文件'
- en: Java system properties
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 系统属性
- en: Variables defined in s`erver.xml`
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`s`erver.xml`中定义的变量
- en: Variables defined on server startup
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器启动时定义的变量
- en: This provides multiple simple ways to change the behavior of Open Liberty based
    on the environment Open Liberty is deployed into.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了多种简单的方法来根据Open Liberty部署到的环境更改其行为。
- en: Open Liberty allows you to package your MicroProfile application as a `WAR`
    file for deployment into the server. The MicroProfile specifications do not have
    an opinion on how an application is packaged and deployed, so Open Liberty reuses
    the `WAR` packaging model from Jakarta EE as the way to package the application.
    This makes a lot of sense because MicroProfile makes use of several Jakarta EE
    programming models, and it makes it easier for a MicroProfile application to make
    use of parts of Jakarta EE that are not in MicroProfile, such as concurrency utilities
    for Jakarta EE. It also allows you to reuse the existing Maven and Gradle build
    tools for packaging a MicroProfile application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Open Liberty 允许您将 MicroProfile 应用程序打包为 `WAR` 文件以部署到服务器。MicroProfile 规范对应用程序的打包和部署方式没有意见，因此
    Open Liberty 重新使用 Jakarta EE 的 `WAR` 打包模型作为打包应用程序的方式。这很有意义，因为 MicroProfile 利用了几种
    Jakarta EE 编程模型，并且使 MicroProfile 应用程序更容易利用 Jakarta EE 中不在 MicroProfile 中的部分，例如
    Jakarta EE 的并发工具。它还允许您重用现有的 Maven 和 Gradle 构建工具来打包 MicroProfile 应用程序。
- en: 'There are two ways to deploy a `WAR` file into Open Liberty. The first is by
    dropping the WAR file into the `dropins` folder, and the second is through the
    `server.xml` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `WAR` 文件部署到 Open Liberty 有两种方式。第一种是将 WAR 文件放入 `dropins` 文件夹，第二种是通过 `server.xml`
    文件：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The primary reason for using the server configuration approach over the `dropins`
    folder is that it allows you to customize how the application is run, for example,
    setting the application's `contextRoot`, configuring classloading, or configuring
    security role bindings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器配置方法而不是`dropins`文件夹的主要原因是可以自定义应用程序的运行方式，例如，设置应用程序的`contextRoot`，配置类加载，或配置安全角色绑定。
- en: 'Open Liberty supports several mechanisms for packaging applications for deployment.
    The simplest is to package the application as a `WAR` file. This is the least
    likely in a cloud-native environment though. Open Liberty also supports packaging
    a server as a `zip` file, an executable `JAR` file, and a Docker container (described
    in the next section). Open Liberty provides plugins for Maven and Gradle that
    make it simple to build applications that will run on Open Liberty. One of the
    features of these plugins is the Open Liberty `dev` mode in Maven, simply add
    the Open Liberty Maven plugin to the `plugin` section of your `pom.xml` as shown
    here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Open Liberty支持多种机制来打包应用程序以进行部署。最简单的方法是将应用程序打包为`WAR`文件。但在云原生环境中，这不太可能。Open Liberty还支持将服务器打包为`zip`文件、可执行的`JAR`文件和Docker容器（下一节将描述）。Open
    Liberty为Maven和Gradle提供了插件，使得构建将在Open Liberty上运行的应用程序变得简单。这些插件的一个特性是在Maven中提供Open
    Liberty的`dev`模式，只需将Open Liberty Maven插件添加到`pom.xml`文件中的`plugin`部分，如下所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This configures the plugin to use the 3.3.4 version of the plugin or a more
    recent release if one exists.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置使插件使用3.3.4版本的插件或如果存在的话，使用更近期的版本。
- en: When you run the `liberty:dev` Maven goal, the plugin will compile the application,
    downloading any dependencies required to run the application, deploy it into Liberty,
    and run the server with Java debugger support. This allows you to make changes
    to the application in any code editor, whether it is a simple editor such as **vi**
    or a full-fledged IDE such as **IntelliJ IDEA** or **Eclipse IDE**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`liberty:dev` Maven目标时，插件将编译应用程序，下载运行应用程序所需的任何依赖项，将其部署到Liberty中，并使用Java调试器支持运行服务器。这允许你在任何代码编辑器中对应用程序进行更改，无论是简单的**vi**编辑器还是功能齐全的IDE，如**IntelliJ
    IDEA**或**Eclipse IDE**。
- en: Liberty's design makes it very simple to build applications that will run in
    a container environment such as Docker. There is even a `dev` mode for containers
    that can be run using `liberty:devc` for this. The next section will discuss how
    to create a container as the deployment artifact.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Liberty的设计使得构建将在容器环境（如Docker）中运行的应用程序变得非常简单。甚至还有一个用于容器的`dev`模式，可以使用`liberty:devc`来运行。下一节将讨论如何创建容器作为部署工件。
- en: Containerizing cloud-native applications using Docker
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker容器化云原生应用程序
- en: 'In this section, we will look at how to containerize a MicroProfile application.
    There are two key parts to containerizing anything: the first is the creation
    of an image, and the second is running that image. While Docker was not the first
    product to do containerization, it did popularize it in a way that developers
    and operators could understand. Cloud Foundry was a common early alternative that
    had similar concepts but hid them as internal implementation details rather than
    making them first-class concepts. With Docker, these two concepts were broken
    into two parts, exposed by the `docker build` command used to create the image,
    and the `docker run` command used to run the image. These concepts were further
    expanded to become standardized, meaning there are now multiple alternatives to
    `docker build` and `docker run`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何容器化MicroProfile应用程序。容器化的关键有两部分：第一是创建镜像，第二是运行该镜像。虽然Docker不是第一个进行容器化的产品，但它以开发者和管理员能够理解的方式普及了这一概念。Cloud
    Foundry是一个常见的早期替代品，它有类似的概念，但将它们隐藏为内部实现细节，而不是作为一级概念。使用Docker，这两个概念被分为两部分，通过创建镜像时使用的`docker
    build`命令和运行镜像时使用的`docker run`命令暴露出来。这些概念进一步扩展，成为标准化，这意味着现在有多个替代方案用于`docker build`和`docker
    run`。
- en: The container image
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器镜像
- en: A **container image** is the container deployment artifact. A container image
    contains everything required to run the application. This means that a container
    image can be moved from one environment to another with confidence that it will
    run in the same way. The motto is to think, create once, run everywhere; however,
    there are some limitations to this. A container is tied to a CPU architecture,
    so a container designed for x86 CPUs wouldn't run on ARM or Power ones without
    a translation layer for the CPU instructions (such as Rosetta 2, which translates
    Mac x86 instructions to Mac ARM ones to support x86 Mac applications on Macs with
    an M series ARM processor).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器镜像** 是容器部署的工件。容器镜像包含运行应用程序所需的一切。这意味着容器镜像可以从一个环境移动到另一个环境，有信心它在同一方式下运行。座右铭是“一次思考，一次创建，到处运行”；然而，这也有一些限制。容器与
    CPU 架构相关联，因此为 x86 CPU 设计的容器在没有 CPU 指令转换层（如 Rosetta 2，将 Mac x86 指令转换为 Mac ARM 指令以支持在具有
    M 系列ARM处理器的 Mac 上运行的 x86 Mac 应用程序）的情况下，无法在 ARM 或 Power CPU 上运行。'
- en: A **Dockerfile** is a set of instructions for how to create a container image.
    A Dockerfile starts by declaring a named image that it is based on and then identifies
    a series of steps to add additional content into the container image. A common
    practice might be for it to be based on an image containing an **Operating System**
    (**OS**), a Java image, or an image that pre-packages the application runtime
    such as Open Liberty.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile** 是创建容器镜像的一系列指令。一个 Dockerfile 首先声明一个基于的命名镜像，然后确定一系列步骤以将额外的内容添加到容器镜像中。常见的做法可能是基于包含
    **操作系统**（**OS**）、Java 镜像或预包装应用程序运行时（如 Open Liberty）的镜像。'
- en: 'While it is convenient to think of a container image as a single large file
    containing everything in the image, this is not how a container image works. A
    container image is made up of a series of layers that are identified by an SHA
    hash. This provides three key advantages:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将容器镜像想象成一个包含镜像中所有内容的单个大文件很方便，但这并不是容器镜像的工作方式。容器镜像由一系列通过 SHA 哈希标识的层组成。这提供了三个关键优势：
- en: It reduces the storage space required to store images. If you have 30 images
    based on a common base image, you only store that common base image once, not
    30 times. While storage space is relatively cheap, if you have a large number
    of applications, file duplication between the containers would soon add up to
    large numbers.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了存储图像所需的存储空间。如果你有 30 个基于公共基础镜像的图像，你只需存储一次那个公共基础镜像，而不是 30 次。虽然存储空间相对便宜，但如果你有大量应用程序，容器之间的文件重复很快就会累积成大量。
- en: It reduces bandwidth requirements. When you transfer container images to and
    from a **container registry**, you do not need to upload or download the layers
    you already have. It is likely you will have many container images, but one common
    OS image, and a common JVM image.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了带宽需求。当你将容器镜像传输到和从 **容器注册库** 时，你不需要上传或下载你已经拥有的层。很可能你会有很多容器镜像，但一个常见的操作系统镜像和一个常见的
    JVM 镜像。
- en: It reduces build time. If the input to a layer hasn't changed, there is no need
    to rebuild it. The input to a layer is any change you made in that line, plus
    the output of the prior line.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了构建时间。如果层的输入没有变化，就没有必要重新构建它。层的输入是你在该行所做的任何更改，加上上一行的输出。
- en: 'Each layer has a pointer to the layer it was built on top of. When you create
    a container image, it consists of all the layers from the base image and one new
    layer for every single line in the Dockerfile. A simple Dockerfile for packaging
    a simple MicroProfile application might look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层都有一个指向其构建在其上的层的指针。当你创建一个容器镜像时，它由基础镜像的所有层和一个 Dockerfile 中每行的单个新层组成。一个用于打包简单
    MicroProfile 应用程序的简单 Dockerfile 可能看起来像这样：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This creates a container image based on Ubuntu 20.04 with Java SE 11 using the
    OpenJ9 JRE implementation with all Open Liberty features available to it. It then
    copies `server.xml` from the default location in a Maven project and the application
    to the `dropins` folder. This will create an image with all the layers associated
    with the `open-liberty:full-java11-openj9` image, and two layers associated with
    this image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个基于 Ubuntu 20.04 和 Java SE 11 的容器镜像，使用 OpenJ9 JRE 实现并包含所有可用的 Open Liberty
    功能。然后，它将从 Maven 项目的默认位置复制 `server.xml` 和应用程序到 `dropins` 文件夹。这将创建一个包含与 `open-liberty:full-java11-openj9`
    镜像相关联的所有层的镜像，以及与该镜像相关联的两个层。
- en: 'Best practice: using multiple layers'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践：使用多个层
- en: 'The advantage of this approach is when you push or pull an image, only layers
    that are not already present are transferred. In the simple MicroProfile example
    stated previously, when you build and push the image, only the layers associated
    with the application and server configuration will be transferred. Think of it
    this way: if you have a base image that is 500 MB in size, and the layers of your
    image are a total of 5 MB, your image would be a total of 505 MB, but when you
    push that back to the container registry, only 5 MB would need to be sent since
    the base image is already there.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是当你推送或拉取镜像时，只有尚未存在的层才会被传输。在之前提到的简单MicroProfile示例中，当你构建和推送镜像时，只有与应用程序和服务器配置相关的层会被传输。可以这样想：如果你有一个500MB大小的基础镜像，而你镜像的层总共是5MB，那么你的镜像总共将是505MB，但当你将其推送到容器注册库时，只需要发送5MB，因为基础镜像已经存在了。
- en: 'This leads to some interesting design questions when designing Docker images.
    The purpose of a Docker image is clearly to get it running somewhere, and preferably
    to get that to happen as quickly as possible. This makes it faster to deploy a
    new image production, to scale it up, or in the event of a problem, to replace
    the container with a new one. A simple way to build Docker images is to package
    your application in a single JAR file, add it to the Dockerfile, and then run
    it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这在设计Docker镜像时引发了一些有趣的设计问题。Docker镜像的目的是显然的，即让它运行起来，并且最好是尽可能快地运行起来。这使得部署新的镜像、扩展它或发生问题时用新的容器替换容器变得更快。构建Docker镜像的一个简单方法是将你的应用程序打包在一个单一的JAR文件中，将其添加到Dockerfile中，然后运行它：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a popular way to create Docker images and works well if the application
    is small, but many applications built this way are not small. Consider the case
    where that `jar` contains Open Liberty, the application code, and some open source
    dependencies. That means that every time the application is modified, a new layer
    containing all that code has to be re-created and deployed. If, on the other hand,
    the application was split up, then a change to the application would require a
    much smaller upload:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种创建Docker镜像的流行方式，如果应用程序很小，效果很好，但以这种方式构建的许多应用程序并不小。考虑这种情况，如果那个`jar`文件包含Open
    Liberty、应用程序代码和一些开源依赖项。这意味着每次修改应用程序时，都必须重新创建和部署包含所有这些代码的新层。另一方面，如果应用程序被拆分，那么对应用程序的更改将需要更小的上传：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, a change to the application code would only rebuild the last
    layer, meaning the upload will be smaller and distributed faster. A change to
    the open source dependencies would of course result in that layer being rebuilt,
    but those tend to change less frequently than the application. If there are many
    applications that share a common set of libraries (whether open source or not),
    it might make sense to create a named base image that all applications can use.
    This would be especially useful if the container images are commonly run on the
    same host.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对应用程序代码的更改只会重建最后一层，这意味着上传的文件会更小，分发速度更快。当然，对开源依赖项的更改会导致该层被重新构建，但这些更改的频率通常低于应用程序。如果有许多应用程序共享一组公共库（无论是否为开源），那么创建一个所有应用程序都可以使用的命名基础镜像可能是有意义的。如果容器镜像通常在同一个主机上运行，这将特别有用。
- en: A significant thing to understand about the layers is once created, they are
    immutable. That means if you delete a file created in an earlier layer, it doesn't
    remove the files from the image; it just marks them as deleted so they cannot
    be accessed. This means that when transferring the container image around, you
    will copy the bytes for the file, but it won't ever be accessible. If the file
    is contributed to by a base image, this will be unavoidable, but if you control
    the image, then it is something to avoid.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于层的一个重要理解是，一旦创建，它们就是不可变的。这意味着如果你删除了早期层中创建的文件，它不会从镜像中删除文件；它只是将它们标记为已删除，因此无法访问。这意味着在传输容器镜像时，你会复制文件的字节，但文件永远不会可访问。如果文件是由基础镜像贡献的，这是不可避免的，但如果你控制镜像，那么这是需要避免的。
- en: Dockerfile instructions
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dockerfile指令
- en: As previously stated, a Dockerfile is a series of instructions detailing how
    to create a Docker image. There are several instructions for creating an image.
    The first instruction in all the examples so far is the `FROM` instruction.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Dockerfile是一系列指令，详细说明了如何创建Docker镜像。有几种创建镜像的指令。到目前为止所有示例中的第一个指令是`FROM`指令。
- en: FROM
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FROM
- en: 'The `FROM` instruction defines the container image that is the base of the
    image you are creating. All Dockerfiles are required to start with `FROM`. A Dockerfile
    can have multiple `FROM` lines: these are commonly used to create a multi-stage
    build. An example of this might be if you need some kind of extra tools to build
    your image that you don''t want to be present when you run it. An example of this
    might be `wget` or `curl` for downloading files and `unzip` for expanding a zip
    file. A simple multi-stage build might look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 指令定义了您正在创建的镜像的基础容器镜像。所有 Dockerfile 都必须以 `FROM` 开头。Dockerfile 可以有多个 `FROM`
    行：这些通常用于创建多阶段构建。一个例子可能是，如果您需要一些额外的工具来构建您的镜像，而这些工具在运行时不需要存在。一个例子可能是 `wget` 或 `curl`
    用于下载文件，以及 `unzip` 用于解压缩 zip 文件。一个简单的多阶段构建可能看起来像这样：'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, the first stage installs `wget` and `unzip`, downloads a file,
    and unzips it. The second stage starts from the base image and then copies the
    extracted files into the new image layer. If a single-stage Dockerfile were created,
    this would have resulted in an image with three additional layers containing the
    binaries for `unzip` and `get`, the `zip` file, and `extract`. The multi-stage
    build only contains `extract`. To do this with a single-stage Docker build is
    less readable and would look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一阶段安装了 `wget` 和 `unzip`，下载了一个文件，并将其解压缩。第二阶段从基础镜像开始，然后将提取的文件复制到新的镜像层。如果创建了一个单阶段
    Dockerfile，这将导致包含 `unzip` 和 `get` 的二进制文件、zip 文件和 `extract` 的三个额外层的镜像。多阶段构建只包含
    `extract`。要使用单阶段 Docker 构建实现这一点，可读性较差，看起来可能像这样：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This Dockerfile uses a single `RUN` command to run multiple commands to create
    only a single layer and it has to undo each step before the end. The last line
    is required to tidy up files created by `apt`. The multi-stage Dockerfile is much
    simpler. Another common use for multi-stage builds is to use the first stage to
    build the application, and then the second stage for running:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 使用单个 `RUN` 命令来运行多个命令，以创建单个层，并且必须在结束时撤销每个步骤。最后一行是必需的，用于清理 `apt`
    创建的文件。多阶段 Dockerfile 要简单得多。多阶段构建的另一个常见用途是使用第一阶段构建应用程序，然后使用第二阶段运行：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: COPY and ADD
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: COPY 和 ADD
- en: The `COPY` and `ADD` instructions perform a similar function. `ADD` has a superset
    of the function of `COPY` so it is generally advised to only use `ADD` if you
    need the extended function. The first argument for both instructions specifies
    the source file (or directory) and by default is interpreted to be copying from
    the machine running the build. The command is always relative to the directory
    the build is run from and you cannot use `..` to navigate to the parent directory.
    The use of the `from` argument, as shown in the previous section, redirects the
    copy to be from another container image. The second argument is the location in
    the container the file should be copied to.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 和 `ADD` 指令执行类似的功能。`ADD` 指令的功能集合包含了 `COPY` 的功能，因此通常建议只有在需要扩展功能时才使用 `ADD`。这两个指令的第一个参数指定了源文件（或目录），默认情况下解释为从运行构建的机器复制。命令始终相对于运行构建的目录，并且不能使用
    `..` 来导航到父目录。正如前一个部分所示，使用 `from` 参数可以将复制重定向到另一个容器镜像。第二个参数是容器中文件应该被复制到的位置。'
- en: 'The `ADD` command provides some additional features over and above the `COPY`
    command. The first is it allows you to specify a `URL` to download the file from
    as the first argument. The second feature is it will unzip a `tar.gz` file into
    a directory. To go back to the first multi-stage build example, if the output
    was a `tar.gz` file, it would mean it could be simplified to just be the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` 命令在 `COPY` 命令的基础上提供了一些额外的功能。第一个功能是它允许您将 `URL` 作为第一个参数指定，以从该 URL 下载文件。第二个功能是它可以将
    `tar.gz` 文件解压缩到目录中。回到第一个多阶段构建示例，如果输出是一个 `tar.gz` 文件，这意味着它可以简化为以下内容：'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: RUN
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RUN
- en: 'The `RUN` instruction simply executes one or more commands using the shell
    from the OS layer. This allows you to do pretty much anything you want or need
    to provide the command available in the base OS image. For example, it is uncommon
    for `unzip` or `wget` to be in the base Linux OS images, so those commands will
    fail unless action is taken to install them. Each `RUN` instruction creates a
    new layer, so if you create a file in one `RUN` command and delete it in another,
    due to the immutability of the layers, the file will exist but not be visible
    anymore. For this reason, it is often important to use the `&&` operator to string
    multiple commands together in a single layer. An example of this was shown previously,
    but is repeated here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN` 指令简单地使用操作系统层的 shell 执行一个或多个命令。这允许你做几乎你想做或需要做的任何事情，或者提供在基础操作系统镜像中可用的命令。例如，在基础
    Linux 操作系统镜像中通常不包含 `unzip` 或 `wget`，因此除非采取行动安装它们，否则这些命令将失败。每个 `RUN` 指令创建一个新的层，所以如果你在一个
    `RUN` 命令中创建一个文件，然后在另一个 `RUN` 命令中删除它，由于层的不可变性，文件将存在但不再可见。因此，通常很重要使用 `&&` 操作符将多个命令连接到单个层中。这个例子之前已经展示过，但在此处重复：'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ARG and ENV
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ARG 和 ENV
- en: '`ARG` defines a build argument that can be specified at build time. The `ARG`
    values are set when running `docker build` using the `build-arg` argument. `ARG`
    can have a default value, in case it isn''t provided at build time. These build
    arguments are not persisted after the build finishes, so they are not available
    at runtime and are not persisted in the image.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG` 定义了一个在构建时可以指定的构建参数。`ARG` 的值在运行 `docker build` 时通过 `build-arg` 参数设置。如果构建时没有提供，`ARG`
    可以有一个默认值。这些构建参数在构建完成后不会持久化，因此它们在运行时不可用，也不会在镜像中持久化。'
- en: '`ENV` defines an environment variable that is available both at build and runtime.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV` 定义了一个在构建和运行时都可用的环境变量。'
- en: Both of these are referenced in the same way, so the key difference is the visibility
    of the value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是用相同的方式引用的，所以关键的区别是值的可见性。
- en: ENTRYPOINT and CMD
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ENTRIES 和 CMD
- en: When running a container, you need something to happen, such as starting the
    Open Liberty server. What happens can be defined by the Dockerfile using the instructions
    `ENTRYPOINT` and `CMD`. The difference between the two instructions is how they
    interact with the `docker run` command. When running a Docker container, any arguments
    after the Docker image name are passed into the container. `CMD` provides a default
    value in case no command-line arguments are provided. `ENTRYPOINT` defines a command
    that will be run and any command-line arguments provided to `docker run` are passed
    in after `ENTRYPOINT`. Both `CMD` and `ENTRYPOINT` have the same syntax. The Open
    Liberty container specifies both of these, so images based on them do not tend
    to specify them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行一个容器时，你需要发生一些事情，比如启动 Open Liberty 服务器。发生的事情可以通过 Dockerfile 使用 `ENTRYPOINT`
    和 `CMD` 指令来定义。这两个指令之间的区别在于它们如何与 `docker run` 命令交互。当运行 Docker 容器时，任何在 Docker 镜像名称之后的参数都会传递到容器中。`CMD`
    在没有提供命令行参数的情况下提供了一个默认值。`ENTRYPOINT` 定义了一个将被运行的命令，并且提供给 `docker run` 的任何命令行参数都会在
    `ENTRYPOINT` 之后传递。`CMD` 和 `ENTRYPOINT` 有相同的语法。Open Liberty 容器指定了这两个指令，因此基于它们的镜像通常不会指定它们。
- en: WORKDIR
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WORKDIR
- en: The `WORKDIR` instruction is used to change the current directory for future
    `RUN`, `CMD`, `COPY`, and `ENTRYPOINT` instructions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR` 指令用于更改未来 `RUN`、`CMD`、`COPY` 和 `ENTRYPOINT` 指令的当前目录。'
- en: USER
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: USER
- en: 'When building an image, the default user account used for executing commands
    is the `root` one. For some operations, this is reasonable and fair. If doing
    an OS update, you typically need to execute as `root`. However, when running the
    containers using, the `root` account is a clear security issue. The Dockerfile
    has a `USER` instruction that sets the user account used for `RUN` instructions
    as well as the process that executes in the container when it is run. This makes
    it simple to set the account to a non-root account. The Open Liberty images in
    previous examples set `USER` to `1001`, which means that any of the previous examples
    based on it will not run using the `root` account, but the one based on the Java
    image would. One problem with the previous Dockerfile examples is that the `ADD`
    and `COPY` instructions write to the files so they are owned by the `root` user,
    which can cause issues at runtime. This can be resolved by updating the `ADD`
    or `COPY` instructions to change the ownership as they are written:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建镜像时，用于执行命令的默认用户账户是 `root`。对于某些操作，这是合理且公平的。如果你正在执行操作系统更新，通常需要以 `root` 身份执行。然而，当使用
    `root` 账户运行容器时，这是一个明显的安全问题。Dockerfile 有一个 `USER` 指令，它设置了用于 `RUN` 指令以及容器运行时执行的进程的用户账户。这使得将账户设置为非
    root 账户变得简单。前面示例中的 Open Liberty 镜像将 `USER` 设置为 `1001`，这意味着基于它的任何先前示例都不会使用 `root`
    账户运行，但基于 Java 镜像的示例会。先前 Dockerfile 示例的一个问题是 `ADD` 和 `COPY` 指令将写入文件，因此它们属于 `root`
    用户，这可能在运行时引起问题。这可以通过更新 `ADD` 或 `COPY` 指令来更改所有权来解决，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Alternatively, the `RUN` instruction can be used to execute the `chown` command-line
    tool. This will create a new layer but might be required if the `ADD` or `COPY`
    instruction moves multiple files and only some should have their ownership changed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用 `RUN` 指令来执行 `chown` 命令行工具。这将创建一个新的层，但如果 `ADD` 或 `COPY` 指令移动多个文件，而只有一些文件需要更改所有权，则可能需要这样做。
- en: Although Dockerfiles are the most used way to create a container image, there
    are alternative ways to build container images. A few examples follow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Dockerfile是创建容器镜像最常用的方式，但还有其他构建容器镜像的方法。以下是一些示例。
- en: Source-to-Image
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源到镜像
- en: '**Source-to-Image** (**S2I**) is a technology that converts an application
    source into a container image. Instead of creating a **Dockerfile**, an **S2I**
    builder ingests the source code, runs the build, and encodes it in a container
    image. This allows the developer to focus on the application code and not the
    creation of the container. By encoding the best practices for building a container
    in an **S2I** builder, it can be reused across applications, making it more likely
    that a set of applications all have well-designed container images. There are
    **S2I** builders for many languages and frameworks, including Open Liberty. **S2I**
    is an open source technology created by Red Hat to help developers adopt OpenShift,
    although it can be, and is, used to create containers that can run anywhere.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**源到镜像**（**S2I**）是一种技术，它将应用程序源代码转换为容器镜像。与创建 **Dockerfile** 不同，**S2I** 构建器会摄取源代码，运行构建，并将其编码到容器镜像中。这使得开发人员可以专注于应用程序代码，而不是容器创建。通过在
    **S2I** 构建器中编码构建容器的最佳实践，它可以在应用程序之间重用，使得一组应用程序都拥有精心设计的容器镜像的可能性更大。有适用于许多语言和框架的 **S2I**
    构建器，包括 Open Liberty。**S2I** 是 Red Hat 创建的开源技术，旨在帮助开发人员采用 OpenShift，尽管它可以，并且确实被用来创建可以在任何地方运行的容器。'
- en: Cloud Native Buildpacks
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云原生构建包
- en: '`WAR` file.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`WAR` 文件。'
- en: Having created a container image, the next step is to run it. While a developer
    might use Docker to run the image on their desktop when running in production,
    the most common way to run container images is with Kubernetes, which we will
    discuss in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建容器镜像后，下一步是运行它。虽然开发人员可能会在桌面运行时使用 Docker 来运行镜像，但在生产中运行容器镜像最常见的方式是使用 Kubernetes，我们将在下一节中讨论。
- en: Deploying cloud-native applications to Kubernetes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将云原生应用程序部署到 Kubernetes
- en: '**Kubernetes** started as a project in Google to allow them to manage software
    at scale. It has since moved to become an open source project managed by the **Cloud
    Native Computing Foundation** (**CNCF**) and has contributors from all over the
    industry. Every major (and most minor) public cloud provider uses Kubernetes to
    manage the deployment of containers. There are also private cloud products such
    as Red Hat OpenShift that provide a distribution of Kubernetes for deployment
    either on-premises or on a public cloud but dedicated to a single company.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes** 最初是谷歌的一个项目，旨在让他们能够大规模管理软件。随后，它转变为一个由 **云原生计算基金会**（**CNCF**）管理的开源项目，并得到了整个行业的贡献者。每个主要（以及大多数次要）的公共云提供商都使用
    Kubernetes 来管理容器的部署。还有一些私有云产品，如 Red Hat OpenShift，提供 Kubernetes 的发行版，用于在本地或公共云上部署，但仅限于单一公司。'
- en: A Kubernetes deployment is known as a **cluster**. To run containers and provide
    a highly available, scalable environment a cluster consists of a control plane
    and a set of key resources that provide it with the ability to run or manage containers,
    scale them, and keep the containers running in the event of any failures. When
    running a container in Kubernetes, the container is placed in a Pod, which is
    then run on a node based on decisions made by the control plane.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 部署被称为 **集群**。为了运行容器并提供高度可用、可扩展的环境，集群由控制平面和一组关键资源组成，这些资源使它能够运行或管理容器、扩展它们，并在发生任何故障时保持容器的运行。在
    Kubernetes 中运行容器时，容器被放置在 Pod 中，然后根据控制平面的决策在节点上运行。
- en: A **Pod** provides a shared context for running a set of containers. All the
    containers in a Pod run on the same node. Although you can run multiple containers
    in a Pod, normally a Pod will contain a single application container, and any
    other containers running in the Pod will be sidecars providing some administrative
    or support function to the application container.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pod** 为运行一组容器提供了一个共享的上下文。Pod 中的所有容器都在同一个节点上运行。虽然你可以在 Pod 中运行多个容器，但通常一个 Pod
    将包含一个单一的应用容器，而 Pod 中运行的任何其他容器都将作为辅助容器，为应用容器提供一些管理或支持功能。'
- en: 'In a traditional automated operation environment, the automation will describe
    how to set the environment up. When using Kubernetes instead of describing how
    to set up the environment, the description describes the desired end state, and
    it is up to the control plane to decide how to make this happen. The configuration
    for this is provided as one (or, more often, a set of) YAML document(s). The net
    effect of this is when deploying to Kubernetes, you do not describe the deployment
    by defining pods on a node and putting a container into it. Instead, you define
    a **Deployment** that will express the container you want to deploy and how many
    replicas of the container should be created. A simple deployment of a single instance
    of Open Liberty can be done with this YAML:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的自动化操作环境中，自动化将描述如何设置环境。当使用 Kubernetes 时，不是描述如何设置环境，而是描述期望的最终状态，而控制平面将决定如何实现这一点。此配置以一个（或更常见的是一组）YAML
    文档的形式提供。这种效果是，在部署到 Kubernetes 时，你不是通过在节点上定义 Pod 并将容器放入其中来描述部署。相反，你定义一个 **Deployment**，它将表达你想要部署的容器以及应该创建多少个容器副本。可以使用以下
    YAML 部署 Open Liberty 的单个实例：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This YAML can then be deployed using the `kubectl apply` command. This results
    in a single Pod running Open Liberty being deployed. While the container is running
    and could respond to HTTP requests, there is no route for network traffic to get
    to the container. The key to enabling network traffic to reach a deployment is
    the Kubernetes **Service**. The Service defines the port the process in the container
    is listening on and the port it should be accessed via the Kubernetes networking
    stack. A Service for this can be defined using this YAML:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用 `kubectl apply` 命令部署此 YAML。这会导致部署一个运行 Open Liberty 的单一 Pod。当容器运行并能够响应
    HTTP 请求时，没有路由让网络流量到达容器。使网络流量能够到达部署的关键是 Kubernetes **服务**。服务定义了容器中进程监听的端口以及通过 Kubernetes
    网络堆栈访问的端口。可以使用以下 YAML 定义此类服务：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A Service allows other containers running Kubernetes to access it, but it doesn''t
    allow services outside the cluster to access it. There are several options for
    how to expose the container externally, for example, port forwarding, an ingress
    controller, or OpenShift has the concept of **routes**. A route essentially just
    exposes a service externally to the cluster. You can specify the host and path,
    or you can let Kubernetes default it. To expose this Open Liberty server externally,
    you can define a route using this YAML:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务允许运行 Kubernetes 的其他容器访问它，但不允许集群外的服务访问它。有几种方法可以将容器外部暴露，例如端口转发、入口控制器，或者 OpenShift
    有 **路由** 的概念。路由本质上只是将服务外部暴露给集群。您可以指定主机和路径，或者您可以允许 Kubernetes 默认设置。为了将此 Open Liberty
    服务器外部暴露，您可以使用以下 YAML 定义一个路由：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These three YAML files have deployed a container and exposed it externally so
    it can be accessed and used. The three YAML files can be placed in a single file
    using `---` as a separator, but there is an alternative option for managing deployment
    than using YAML to configure everything, and that option is to use an Operator.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个 YAML 文件已部署了一个容器并将其外部暴露，以便可以访问和使用。这三个 YAML 文件可以使用 `---` 作为分隔符放置在单个文件中，但除了使用
    YAML 配置一切之外，还有另一种管理部署的选项，那就是使用 Operator。
- en: 'An **Operator** is a way of packaging, deploying, and managing a set of resources
    related to an application. They were originally intended to help manage stateful
    applications where just throwing away and starting a new Pod might result in data
    loss; however, they can also be used to simplify the deployment of applications.
    Operators watch for the definition of a **Custom Resource** that it understands
    and configures the relevant Kubernetes resources to run that application. An Operator
    can do things such as managing the deployment and updating of an application when
    new images become available. Open Liberty provides an Operator that can manage
    the deployment of applications built on Open Liberty. As an example, all the previous
    YAML files can be simply replaced with this YAML:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Operator** 是一种打包、部署和管理与应用程序相关的一组资源的方式。它们最初旨在帮助管理有状态的应用程序，如果只是丢弃并启动一个新的 Pod，可能会导致数据丢失；然而，它们也可以用来简化应用程序的部署。Operator
    监视它理解的 **自定义资源** 的定义，并配置相关的 Kubernetes 资源来运行该应用程序。Operator 可以执行诸如管理应用程序的部署和更新，当有新镜像可用时。Open
    Liberty 提供了一个 Operator，可以管理基于 Open Liberty 的应用程序的部署。例如，所有之前的 YAML 文件都可以简单地替换为以下
    YAML：'
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: MicroProfile Health in Kubernetes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 中的 MicroProfile Health
- en: 'The MicroProfile Health specification allows you to configure support for liveness
    and readiness checks. These probes allow the Kubernetes control plane to understand
    the health of the container and what action to take. An unsuccessful liveness
    probe will trigger the Pod to be recycled as it indicates that a problem has occurred
    that cannot be resolved. A readiness probe, on the other hand, will simply cause
    Kubernetes to stop routing traffic to the Pod. In both cases, you need to have
    multiple instances to ensure that during any outage of one container, the clients
    will remain unaware. To configure these liveness and readiness probes, you ensure
    that the Open Liberty server is configured to run MicroProfile Health:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Health 规范允许您配置对存活性和就绪性检查的支持。这些探针允许 Kubernetes 控制平面了解容器的健康状况以及应采取什么行动。一个失败的存活性探针将触发
    Pod 被回收，因为它表明发生了无法解决的问题。另一方面，就绪性探针将简单地导致 Kubernetes 停止将流量路由到 Pod。在这两种情况下，您需要多个实例以确保在任何容器故障期间，客户端仍然不会察觉。要配置这些存活性和就绪性探针，您需要确保
    Open Liberty 服务器配置为运行 MicroProfile Health：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, when defining the application, configure the liveness and readiness probes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在定义应用程序时，配置存活性和就绪性探针：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This configures the liveness and readiness probes to make an HTTP `get` request
    to the MicroProfile health endpoints for liveness and readiness. It also configures
    a wait period after the container starts before making the first check. This gives
    the container a chance to run any startup routines before it starts polling to
    determine the status.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将存活性和就绪性探针配置为向 MicroProfile 健康端点发送 HTTP `get` 请求以检查存活性和就绪性。它还在容器启动后配置了一个等待期，在执行第一次检查之前。这给了容器一个机会在开始轮询以确定状态之前运行任何启动程序。
- en: MicroProfile Config in Kubernetes
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 中的 MicroProfile Config
- en: '**MicroProfile Config** provides a way to receive configuration in your application
    that can be provided in the environment. In Kubernetes, this kind of configuration
    is typically stored in a **ConfigMap** or a **Secret**. As discussed previously,
    in [*Chapter 5*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091), *Enhancing Cloud-Native
    Applications*, a ConfigMap is essentially a set of key/value pairs stored in Kubernetes
    that can be bound into a Pod so it is available to the container. To receive configuration
    in your application from Kubernetes, ensure that the Open Liberty server is configured
    to run MicroProfile Config:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile Config** 提供了一种在您的应用程序中接收配置的方法，该配置可以在环境中提供。在 Kubernetes 中，此类配置通常存储在
    **ConfigMap** 或 **Secret** 中。如前所述，在 [*第 5 章*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091)，“增强云原生应用程序”中，ConfigMap
    实质上是存储在 Kubernetes 中的键/值对集合，可以绑定到 Pod 中，使其对容器可用。要从 Kubernetes 接收应用程序的配置，请确保 Open
    Liberty 服务器已配置为运行 MicroProfile Config：'
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are many ways to create a ConfigMap, and [*Chapter 5*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091),
    *Enhancing Cloud-Native Applications*, demonstrated one mechanism. Another way
    to define a ConfigMap is to apply a ConfigMap with the following YAML:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ConfigMap 有许多方法，[*第 5 章*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091)，“增强云原生应用程序”演示了一种机制。定义
    ConfigMap 的另一种方法是应用以下 YAML 的 ConfigMap：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when deploying your application, you can either bind a single environment
    variable from this ConfigMap, or all of them. To bind the value of `example.property.1`
    from the ConfigMap as a variable called `PROP_ONE` to an Open Liberty application,
    you would use the following YAML:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当部署您的应用程序时，您可以选择绑定此 ConfigMap 中的一个单个环境变量，或者全部绑定。要将 ConfigMap 中的 `example.property.1`
    的值绑定到名为 `PROP_ONE` 的变量，并将其绑定到 Open Liberty 应用程序，您将使用以下 YAML：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A ConfigMap could (as in the aforementioned example) contain a lot of properties
    that the container may need to access, instead of binding a single entry, or entries
    one by one, you can bind all the entries. The following YAML would define an application
    with all the values of the ConfigMap bound:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 可以（如上述示例所示）包含许多容器可能需要访问的属性，而不是绑定单个条目或逐个绑定条目，您可以绑定所有条目。以下 YAML 将定义一个将
    ConfigMap 的所有值绑定的应用程序：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One of the more recent features of MicroProfile Config is the concept of configuration
    profiles. The idea is that you can provide the configuration for running the application
    in development, test, and production environments and have MicroProfile Config
    only load the configuration for the desired profile. To configure this, you also
    need to define the config profile. The MicroProfile Config specification says
    that a property in a profile name starts with `%<profile name>`; however, `%`
    isn''t valid in an environment variable name so it is replaced with `_`. Example
    YAML for this is the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Config 的最新功能之一是配置配置文件的概念。想法是您可以为开发、测试和生产环境中的应用程序提供配置，并且 MicroProfile
    Config 只加载所需配置文件的配置。为此，您还需要定义配置配置文件。MicroProfile Config 规范说明配置文件名称中的属性以 `%<profile
    name>` 开头；然而，`%` 在环境变量名称中无效，因此它被替换为 `_`。以下 YAML 是此示例的示例：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ConfigMaps in Kubernetes are good for storing data that isn't sensitive, but
    when it comes to storing API keys, credentials, and so on, Kubernetes has an alternative
    concept known as Secrets. Secrets can represent multiple different kinds of Secrets,
    but here we are just going to consider simple key/value pairs. The Kubernetes
    platform provides better protection for Secrets than ConfigMaps, although many
    people prefer to use third-party products for Secret management. It is still good
    to understand how Secrets work because third-party products tend to follow the
    same conventions to access sensitive data from within the container.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 ConfigMaps 适用于存储非敏感数据，但当涉及到存储 API 密钥、凭证等内容时，Kubernetes 提供了一种称为
    Secrets 的替代概念。Secrets 可以代表多种不同类型的 Secrets，但在这里我们只考虑简单的键/值对。Kubernetes 平台为 Secrets
    提供了比 ConfigMaps 更好的保护，尽管许多人更喜欢使用第三方产品进行 Secret 管理。了解 Secrets 的工作原理仍然很有用，因为第三方产品通常遵循相同的约定来从容器内部访问敏感数据。
- en: 'Secrets are encoded using base64 encoding, which isn''t fantastic protection.
    Open Liberty allows passwords it loads to be AES encrypted, and provides an API
    for decrypting protected strings, so your base64-encoded secret could be a base64-encoded
    AES encrypted string. However, since you would still need to provide the decryption
    key to Open Liberty and this is not a security hardening book, we will not go
    into further details here. Referencing a single key pair from a secret from deployment
    is done almost identically to referencing from a ConfigMap, but using `secretKeyRef`
    rather than `configMapKeyRef`; for example, with this YAML:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密使用 base64 编码，这并不是非常好的保护。Open Liberty 允许加载的密码使用 AES 加密，并提供了解密受保护字符串的 API，因此你的
    base64 编码的秘密可能是一个 base64 编码的 AES 加密字符串。然而，由于你仍然需要向 Open Liberty 提供解密密钥，而这不是一本关于安全加固的书，所以我们不会在这里进一步详细介绍。从部署中引用秘密中的单个密钥对几乎与从
    ConfigMap 中引用相同，但使用 `secretKeyRef` 而不是 `configMapKeyRef`；例如，以下 YAML：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you deploy the secret YAML and bind to it as in the aforementioned example,
    your container will have an environment variable called `PROP_ONE` whose value
    is `super secret`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你部署了秘密 YAML 并按照前面提到的示例进行绑定，你的容器将有一个名为 `PROP_ONE` 的环境变量，其值为 `super secret`。
- en: 'Just like with a ConfigMap, you can bind all the key/value pairs in a secret
    to the container, and just like with the prior example, it is done in a very similar
    way to ConfigMaps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 ConfigMap 一样，你可以将秘密中的所有键/值对绑定到容器中，并且就像前面的例子一样，它是以与 ConfigMaps 非常相似的方式进行操作的：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Secrets can also be bound as files in the container file system and this can
    be preferable for security-sensitive data. When you do this, the secret will be
    defined in the file system and the value of the secret will be the content of
    the file. MicroProfile Config cannot consume secrets bound this way, but it provides
    a way to add additional ConfigSources, allowing you to easily load the configuration.
    The YAML for binding a secret to the file system is to essentially mount it as
    a volume. The following example YAML will result in every key/value in the secret
    `secret.config` being mounted as a file in the file system of the container under
    the directory `/my/secret`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密也可以绑定到容器文件系统中的文件，这对于需要高度安全的数据来说可能更可取。当你这样做时，秘密将在文件系统中定义，秘密的值将是文件的内容。MicroProfile
    Config 不能消费以这种方式绑定的秘密，但它提供了一种添加额外 ConfigSources 的方法，让你可以轻松地加载配置。将秘密绑定到文件系统的 YAML
    实际上就是将其挂载为一个卷。以下示例 YAML 将导致秘密 `secret.config` 中的每个键/值在容器的 `/my/secret` 目录下作为文件挂载：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To enable the injection of the bound Secrets, you need a `META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource`
    on the application classpath will automatically cause it to be loaded. A short
    example ConfigSource that will do this is the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用注入绑定的秘密，你需要在应用程序类路径上有一个 `META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource`，这将自动导致它被加载。以下是一个简短的示例
    ConfigSource，它将执行此操作：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This config source will load the content of a file with the property name read
    from a well-defined directory. If the file cannot be read, it will act as if the
    property is not defined. Kubernetes will update the file content when the secret
    is updated, which means that updates can be visible to the application automatically
    since this code will reread the file each time the property is read.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置源将加载具有属性名称的文件内容，该属性名称是从一个定义良好的目录中读取的。如果文件无法读取，它将表现得好像该属性未定义。当秘密更新时，Kubernetes
    将更新文件内容，这意味着更新可以自动对应用程序可见，因为每次读取属性时，此代码都会重新读取文件。
- en: In the next section, we will discuss some considerations when using a Service
    Mesh with MicroProfile.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论在使用 MicroProfile 与服务网格时的一些考虑因素。
- en: MicroProfile and Service Mesh
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile 和服务网格
- en: When deploying into a Kubernetes cluster, some people choose to make use of
    a Service Mesh. The goal of a Service Mesh is to move certain considerations of
    microservices out of the application code and to place it around the application.
    A Service Mesh can remove some application concerns such as service selection,
    observability, fault tolerance, and, to a certain degree, security. One common
    Service Mesh technology is **Istio**. The way Istio works is by inserting a sidecar
    into the Pod for the containers and all inbound and network traffic is routed
    via that sidecar. This allows the sidecar to perform activities applying access
    control policies, routing requests to downstream services, and applying fault
    tolerance policies such as retrying requests or timing them out. Some of these
    capabilities overlap with some of the MicroProfile capabilities, for example,
    Istio can handle attaching and propagating OpenTracing data with requests. If
    you use **Istio**, you clearly do not need to make use of MicroProfile OpenTracing,
    although using both would complement each other rather than cause conflict.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署到 Kubernetes 集群时，有些人选择使用服务网格。服务网格的目标是将微服务的某些考虑因素从应用程序代码中移出，并将其放置在应用程序周围。服务网格可以消除一些应用程序关注点，例如服务选择、可观察性、故障容忍，以及在某种程度上，安全性。一种常见的服务网格技术是
    **Istio**。Istio 的工作方式是在容器的 Pod 中插入一个边车，所有传入和网络流量都通过该边车路由。这允许边车执行应用访问控制策略、将请求路由到下游服务以及应用故障容忍策略，例如重试请求或超时。其中一些功能与
    MicroProfile 的一些功能重叠，例如，Istio 可以处理将 OpenTracing 数据附加到请求并传播。如果你使用 **Istio**，显然不需要使用
    MicroProfile OpenTracing，尽管同时使用两者会相辅相成而不是产生冲突。
- en: 'One area where the use of a Service Mesh and MicroProfile can conflict in negative
    ways is fault tolerance. For example, if you configure 5 retries in MicroProfile
    and 5 retries in Istio and they all fail, you will end up with a total of 25 retries.
    As a result, it is common when using a Service Mesh to disable the MicroProfile
    fault tolerance capabilities. This can be done with the environment variable of
    `MP_Fault_Tolerance_NonFallback_Enabled` set to `false`. This will disable all
    the MicroProfile fault tolerance support except for the fallback capability. This
    is because the logic to perform on a failure is intrinsically an application consideration
    and not something that can be extracted into the Service Mesh. This can simply
    be disabled using the following YAML:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用服务网格和 MicroProfile 可能产生负面冲突的一个领域是故障容忍。例如，如果你在 MicroProfile 中配置了 5 次重试，在 Istio
    中也配置了 5 次重试，并且它们都失败了，你最终会有 25 次重试。因此，当使用服务网格时，通常禁用 MicroProfile 的故障容忍功能。这可以通过将环境变量
    `MP_Fault_Tolerance_NonFallback_Enabled` 设置为 `false` 来完成。这将禁用所有 MicroProfile 故障容忍支持，除了回退功能。这是因为执行失败时的逻辑本质上是一个应用程序考虑因素，而不是可以提取到服务网格中的东西。这可以通过以下
    YAML 简单禁用：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This configures the application to have a hardcoded environment variable that
    disables the non-fallback MicroProfile Fault Tolerance behaviors. This could also
    be done with a ConfigMap.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置应用程序具有一个硬编码的环境变量，该变量禁用了非回退的 MicroProfile 故障容忍行为。这也可以通过 ConfigMap 来完成。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have reviewed the MicroProfile implementation that is used
    in the rest of the book, some best practices for building a container for a MicroProfile
    application, and how to deploy that application into Kubernetes. While the chapter
    isn't an exhaustive review of the capabilities available in Kubernetes, it does
    focus on the particular considerations for deploying MicroProfile applications
    to Kubernetes, and why they interact with Kubernetes services. This chapter should
    have provided you with a good starting point for creating and deploying MicroProfile
    applications using Open Liberty, containers, and Kubernetes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了本书其余部分使用的 MicroProfile 实现，构建 MicroProfile 应用程序容器的最佳实践，以及如何将应用程序部署到
    Kubernetes。虽然本章并不是对 Kubernetes 中可用功能的详尽审查，但它确实关注了将 MicroProfile 应用程序部署到 Kubernetes
    的特定考虑因素以及它们如何与 Kubernetes 服务交互。本章应该为您提供了创建和部署使用 Open Liberty、容器和 Kubernetes 的
    MicroProfile 应用程序的良好起点。
- en: The next chapter will describe an example application that makes use of MicroProfile
    for a set of microservices deployed in a container to a Kubernetes cluster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将描述一个示例应用程序，该应用程序利用 MicroProfile 在一个容器中部署到 Kubernetes 集群中的一组微服务。
