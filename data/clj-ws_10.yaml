- en: 10\. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 测试
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we look at testing in Clojure. We start by learning about different
    types of tests. We then explore the most common unit testing libraries in order
    to test our Clojure functions. We see how to do test-driven development. We dive
    into property-based testing that helps us to generate a vast amount of testing
    data. We then learn how to integrate testing with Clojure and ClojureScript projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Clojure 中的测试。我们首先了解不同类型的测试。然后，我们探索最常用的单元测试库，以便测试我们的 Clojure 函数。我们学习如何进行测试驱动开发。我们深入研究基于属性的测试，这有助于我们生成大量的测试数据。然后，我们学习如何将测试集成到
    Clojure 和 ClojureScript 项目中。
- en: By the end of this chapter, you will be able to test programs in Clojure and
    ClojureScript using their respective standard test libraries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用各自的标准化测试库在 Clojure 和 ClojureScript 中测试程序。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned about host platform interoperability (inter-op)
    in Clojure. We explored how to use Java code in Clojure and JavaScript in ClojureScript.
    During our inter-op adventure, we created a coffee-ordering application. The application
    has various features, such as displaying a menu with coffee choices and ordering
    a coffee. We ran the code and we saw the application working. It is now time to
    learn about testing in Clojure.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 Clojure 中的宿主平台互操作性（inter-op）。我们探讨了如何在 Clojure 中使用 Java 代码和在 ClojureScript
    中使用 JavaScript。在我们的互操作性冒险中，我们创建了一个咖啡订购应用程序。该应用程序具有各种功能，例如显示带有咖啡选择的菜单和订购咖啡。我们运行了代码，并看到了应用程序正在运行。现在是学习
    Clojure 中测试的时候了。
- en: Clojure was designed from the beginning to be a very practical language. Getting
    things done means interacting with the outside world, building projects, using
    libraries, and deploying your work. We need to be confident that the code that
    we write does what it is supposed to do. As a developer, you will need to test
    your applications. In this chapter, we will see what types of tests can be used.
    We will look at unit tests as they are the most common type of test written by
    developers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 从一开始就被设计成一个非常实用的语言。完成任务意味着与外部世界互动，构建项目，使用库，并部署你的工作。我们需要确信我们编写的代码确实做了它应该做的事情。作为一名开发者，你需要测试你的应用程序。在本章中，我们将了解可以使用哪些类型的测试。我们将查看单元测试，因为它们是开发者编写的最常见类型的测试。
- en: Consider a situation where we have an air-ticket ordering application. This
    application allows users to search for flights and book flights. One of its features
    is searching for flights. A user should be able to enter search dates. The end
    date should be after the start date – it does not make much sense to fly back
    before we have even flown out. Testing allows us to ensure that the code handling
    start and end dates are in order.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情况，我们有一个机票订购应用程序。这个应用程序允许用户搜索航班并预订航班。其一个功能是搜索航班。用户应该能够输入搜索日期。结束日期应该在开始日期之后——在我们飞出之前就返回是没有太多意义的。测试使我们能够确保处理开始和结束日期的代码是有序的。
- en: Similarly, we would want to make sure that when many customers enter our site,
    it does not slow down. User experience elements such as website speed are also
    tested in software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们希望确保当许多客户进入我们的网站时，它不会变慢。用户体验元素，如网站速度，在软件中也会进行测试。
- en: The first step is to understand why testing is important and what types of tests
    can be done in Clojure and ClojureScript. Then, we will look at testing libraries
    in Clojure and ClojureScript. Finally, we will look at a special type of testing
    called **generative testing** and how it helps developers to write tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是了解为什么测试很重要，以及 Clojure 和 ClojureScript 中可以执行哪些类型的测试。然后，我们将探讨 Clojure 和 ClojureScript
    中的测试库。最后，我们将探讨一种特殊的测试类型，称为**生成测试**，以及它是如何帮助开发者编写测试的。
- en: Why Testing Is Important
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么测试很重要
- en: At the beginning of this chapter, we saw that software testing is important.
    Why? In order to answer that, we will need to understand what software testing
    is. It can be defined as a process that ensures that a particular piece of software
    is bug-free. A software bug is a problem that causes a program to crash or produce
    invalid output. In *Chapter 9*, *Host Platform Interoperability with Java and
    JavaScript*, we learned about errors in Clojure and ClojureScript. Testing is
    a step-by-step process that ensures that software passes expected standards of
    performance, set by customers or the industry. These steps can also help to identify
    errors, gaps, or missing requirements. Bugs, errors, and defects are synonyms.
    They all mean problems with our software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了软件测试的重要性。为什么？为了回答这个问题，我们需要了解什么是软件测试。它可以定义为确保特定软件无错误的过程。软件错误是导致程序崩溃或产生无效输出的问题。在*第9章*，*Java和JavaScript与宿主平台互操作性*中，我们学习了Clojure和ClojureScript中的错误。测试是一个逐步的过程，确保软件通过客户或行业设定的预期性能标准。这些步骤还可以帮助识别错误、差距或缺失的需求。错误、错误和缺陷是同义词。它们都意味着我们的软件存在问题。
- en: 'The benefits of software testing are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的好处如下：
- en: Providing a high-quality product with low maintenance costs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供具有低维护成本的高质量产品
- en: Assuring the accuracy and consistency of the product
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保产品的准确性和一致性
- en: Discovering errors that are not recognized during the developmental phase
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现开发阶段未被识别的错误
- en: Checking whether the application produces the expected output
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序是否产生预期的输出
- en: Providing us with knowledge of customers' satisfaction with the product
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助我们了解客户对产品的满意度
- en: There are a number of software testing methodologies, depending on the angle
    from which we look at the software. The most common distinction is between functional
    testing and non-functional testing. We will now discuss what makes tests functional
    or non-functional, and when it is appropriate to use one type or the other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们观察软件的角度，存在许多软件测试方法。最常见的区别是功能测试和非功能性测试。现在我们将讨论什么使测试成为功能性的或非功能性的，以及何时使用一种类型或另一种类型是合适的。
- en: Functional Testing
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性测试
- en: '**Functional tests** try to capture the functional requirements of the software
    being tested. The requirements are taken from the specifications of the software.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能性测试**试图捕捉正在测试的软件的功能性需求。需求来自软件的规范。'
- en: Consider the air-ticket ordering application, which allows users to buy airline
    tickets. As mentioned, one of its features is searching for flights. Users would
    want to search using different criteria. One criterion could be searching for
    direct flights. Functional tests would ensure that when a user searches for a
    direct flight, they do not see connecting flights.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以机票订购应用程序为例，它允许用户购买航班。如前所述，其功能之一是搜索航班。用户可能会使用不同的标准进行搜索。一个标准可能是搜索直飞航班。功能性测试将确保当用户搜索直飞航班时，他们不会看到转机航班。
- en: 'Typically, functional testing involves the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，功能性测试包括以下步骤：
- en: Identifying what functions and features a software component has, based on the
    requirements specification document
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需求规范文档确定软件组件具有哪些功能和特性
- en: Creating input data based on the requirements
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需求创建输入数据
- en: Determining the expected output
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定预期的输出
- en: Executing the tests
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试
- en: Comparing the expected results with the actual output
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预期结果与实际输出进行比较
- en: While functional testing has advantages, there are some testing areas that are
    not covered by functional tests. In such cases, so-called non-functional tests
    are performed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然功能性测试有优势，但有些测试领域并未被功能性测试覆盖。在这种情况下，将执行所谓的非功能性测试。
- en: Non-Functional Testing
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能性测试
- en: '**Non-functional tests** check things that are not directly related to the
    functional requirements. To put it another way, non-functional tests are concerned
    with the way that software operates as a whole, rather than with the specific
    behaviors of the software or its components.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**非功能性测试**检查与功能性需求不直接相关的事项。换句话说，非功能性测试关注的是软件作为一个整体的操作方式，而不是软件或其组件的具体行为。'
- en: With non-functional tests, we are concerned with areas such as security, how
    a system behaves under various load conditions, whether it is user-friendly, and
    whether it provides localization to run in different countries.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在非功能性测试中，我们关注的是诸如安全性、系统在各种负载条件下的行为、是否用户友好以及是否提供本地化以在不同国家运行等问题。
- en: Consider the air-ticket ordering application again. This application allows
    users to buy airline tickets. Users should be able to pay with their credit cards.
    The application should handle payments securely. This means that transactions
    should be encrypted. Encryption is the process of encoding a message or information
    in such a way that only authorized parties can access it and those who are not
    authorized cannot. Someone who is not authorized should not be able to see transaction
    details.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑机票订购应用程序。此应用程序允许用户购买机票。用户应该能够使用信用卡支付。应用程序应该安全地处理支付。这意味着交易应该被加密。加密是将消息或信息编码成只有授权方才能访问，而未授权方无法访问的过程。未授权的人不应该能够看到交易详情。
- en: Another non-functional test for the air-ticket ordering application would be
    load testing. With load testing, we would test that our application can handle
    a very high page load. During the festive period, many customers will enter our
    website. We need to make sure that thousands of users can use the application
    at the same time. The application should be responsive and not slow down when
    many customers use it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于机票订购应用程序的另一个非功能性测试将是负载测试。通过负载测试，我们将测试我们的应用程序能否处理非常高的页面负载。在节日期间，许多客户将访问我们的网站。我们需要确保数千名用户可以同时使用该应用程序。应用程序应该响应迅速，当许多客户使用时不会变慢。
- en: Functional tests ensure that our applications are secure. While we have discussed
    functional and non-functional testing separately, they should not be seen as opposing
    testing methodologies, but rather, complementary approaches. They are often performed
    together to provide assurance that software has a high standard of quality and
    can operate under various conditions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性测试确保我们的应用程序是安全的。虽然我们已经分别讨论了功能性和非功能性测试，但它们不应被视为对立的测试方法，而应被视为互补的方法。它们通常一起执行，以确保软件具有高标准的质量并能在各种条件下运行。
- en: Testing and catching bugs in software are not free. It requires time and resources
    from developers and testers. Having said that, fixing bugs late in development
    is more expensive than catching them early in the development phase. Unit testing
    allows us to catch many bugs early on, while not requiring too many resources
    from developers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中进行测试和捕捉错误并非免费。这需要开发人员和测试人员的时间和资源。话虽如此，在开发后期修复错误比在开发早期捕捉它们要昂贵得多。单元测试使我们能够早期捕捉许多错误，同时不会从开发人员那里消耗太多资源。
- en: In the next topic, we will examine what unit testing is, and the most popular
    unit testing frameworks in Clojure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将探讨单元测试是什么，以及 Clojure 中最受欢迎的单元测试框架。
- en: Clojure Unit Testing
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure 单元测试
- en: '**Unit testing** is the testing of an individual software component or module.
    In Clojure, a function is a good candidate for unit testing. A function is intended
    to perform one task at a time. Otherwise, a change in logic in one job would influence
    a second job. When a function has one responsibility, we can reason about the
    function much more easily than if it performed more than one thing. Clojure provides
    a number of testing frameworks for unit testing. When we use testing libraries,
    we often call them frameworks. A framework is a structure that supports and encloses
    testing. With testing frameworks, we support testing our code. Our code is enclosed
    in a number of tests written for our code.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是对单个软件组件或模块的测试。在 Clojure 中，一个函数是单元测试的良好候选者。函数旨在一次执行一个任务。否则，一个任务中的逻辑变化会影响第二个任务。当一个函数只有一个责任时，我们比它执行多个任务时更容易对函数进行推理。Clojure
    为单元测试提供了一系列测试框架。当我们使用测试库时，我们通常称它们为框架。框架是一个支持和包围测试的结构。使用测试框架，我们支持对代码进行测试。我们的代码被为我们的代码编写的多个测试所包围。'
- en: 'There are a number of concepts in testing, two of which are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中有许多概念，以下是其中两个：
- en: '**Assertion**: A Boolean (true or false) expression. An assertion is a statement
    about a specific part of our program, which will be true or false. For example,
    we can state that a function in our program will throw an error when we pass a
    string instead of a number as a parameter. The assertion will be: Does this function
    throw an error? The answer is either yes (true) or no (false).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：一个布尔（true或false）表达式。断言是对我们程序特定部分的一个声明，它将是true或false。例如，我们可以声明，当我们用一个字符串而不是一个数字作为参数传递给函数时，我们的程序中的函数将抛出一个错误。断言将是：这个函数会抛出错误吗？答案是是（true）或否（false）。'
- en: '**Stub**: A temporary replacement for a part of a code or a concept. A stub
    simulates the behavior of the replaced software component. In the flight-ticket
    ordering application, we could have a payment component that takes card details
    and contacts the bank to withdraw money for the plane ticket. After taking payment
    through the bank, we would display ticket details. A stub would simulate contacting
    the bank without actually contacting the bank. When we use a stub, we can focus
    on testing displaying ticket details without handling contacting the bank and
    all card transactions. This keeps the test focused on a single task, in this case,
    displaying a ticket after taking payment via a bank.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**：代码或概念的一部分的临时替换。存根模拟被替换的软件组件的行为。在航班票订购应用程序中，我们可能有一个支付组件，它接受卡详情并与银行联系以提取机票费用。在通过银行完成支付后，我们会显示票务详情。存根将模拟与银行联系，但实际上并不与银行联系。当我们使用存根时，我们可以专注于测试显示票务详情，而不需要处理与银行联系和所有卡交易。这使测试专注于单一任务，在本例中，是通过银行支付后显示票务。'
- en: The `clojure.test` framework is the default Clojure unit testing framework that
    comes with the Clojure standard library. The purpose of `clojure.test` is to provide
    developers with a number of testing functions. In our first exercise, we will
    write unit tests for the coffee app from the previous chapter using the clojure.test
    library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.test`框架是Clojure标准库中提供的默认Clojure单元测试框架。`clojure.test`的目的是为开发者提供一系列测试函数。在我们的第一个练习中，我们将使用clojure.test库为前一章中的咖啡应用程序编写单元测试。'
- en: 'Exercise 10.01: Unit Testing with the clojure.test Library'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.01：使用clojure.test库进行单元测试
- en: The aim of this exercise is to learn how to perform unit testing with the `clojure.test`
    library. This is the default testing library in Clojure. It is included in Clojure
    so we do not need to import this library as an external dependency. In the previous
    chapter, we created a coffee-ordering application that allowed us to display a
    coffee menu and order coffees. In this exercise, we will write unit tests for
    the functions created in the coffee-ordering application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是学习如何使用`clojure.test`库进行单元测试。这是Clojure的默认测试库。由于Clojure已经包含了这个库，因此我们不需要将其作为外部依赖项导入。在前一章中，我们创建了一个允许我们显示咖啡菜单和订购咖啡的咖啡订购应用程序。在本练习中，我们将为咖啡订购应用程序中创建的函数编写单元测试。
- en: 'First, we will create the application, then we will write tests:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建应用程序，然后我们将编写测试：
- en: 'Create the coffee-ordering application:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建咖啡订购应用程序：
- en: '[PRE0]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Leiningen created the project for us. By default, we have one source file called
    `core.clj`. Inside this file, we will add the code responsible for displaying
    the menu options and processing them.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Leiningen为我们创建了项目。默认情况下，我们有一个名为`core.clj`的源文件。在这个文件中，我们将添加负责显示菜单选项和处理它们的代码。
- en: 'Import the `java.util.Scanner` class in the `core` namespace:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`core`命名空间中导入`java.util.Scanner`类：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have imported the `Scanner` class. This class allows us to get input from
    a keyboard. In order to use methods from Scanner, we need to create an instance
    of this class.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经导入了`Scanner`类。这个类允许我们从键盘获取输入。为了使用`Scanner`类的方法，我们需要创建这个类的一个实例。
- en: Create an instance of the `Scanner` class.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Scanner`类的一个实例。
- en: We will call methods on this class instance when we want to get input from a
    user. The `Scanner` class needs to know what the source of the input is. In our
    case, we use the default `in` source of the `System` class – the keyboard.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们想要从用户那里获取输入时，我们将在这个类实例上调用方法。`Scanner`类需要知道输入的来源。在我们的情况下，我们使用`System`类的默认`in`源——键盘。
- en: '[PRE2]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When a user runs the application, they should see a menu with options. The options
    are displaying and ordering coffees, listing orders, and exiting the application.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户运行应用程序时，他们应该看到一个带有选项的菜单。这些选项包括显示和订购咖啡、列出订单以及退出应用程序。
- en: '![Figure 10.1: Menu of the application showing all the options'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.1：显示所有选项的应用程序菜单'
- en: '](img/B14502_10_01.jpg)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_10_01.jpg)'
- en: 'Figure 10.1: Menu of the application showing all the options'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.1：显示所有选项的应用菜单
- en: 'Add the code for displaying the menu and handling user choices:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加显示菜单和处理用户选择的代码：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `start-app` function, we set the application to running by default:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`start-app`函数中，我们将应用设置为默认运行状态：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to get the values stored in `run-application`, we use the `deref` function.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了获取`run-application`中存储的值，我们使用`deref`函数。
- en: 'Inside the `while` block, the application runs until the user chooses the exit
    option. In such cases, we will update the value of `ref`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`块内部，应用将一直运行，直到用户选择退出选项。在这种情况下，我们将更新`ref`的值：
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After updating, `ref` is no longer true but false. The `while` block will stop
    when the value of `ref` is false and our application will exit. When our application
    runs, the user can choose options from the menu:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后，`ref`不再为真，而是为假。当`ref`的值为假时，`while`块将停止，我们的应用将退出。当我们的应用运行时，用户可以从菜单中选择选项：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will display the following menu:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示以下菜单：
- en: '![Figure 10.2: Menu of the coffee ordering application'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.2：咖啡订购应用的菜单'
- en: '](img/B14502_10_02.jpg)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_10_02.jpg)'
- en: 'Figure 10.2: Menu of the coffee ordering application'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.2：咖啡订购应用的菜单
- en: We are able to display the initial menu. We can work on handling user choices
    from the menu.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们能够显示初始菜单。我们可以着手处理用户从菜单中的选择。
- en: 'In order to get the user response, we call the `nextInt` method from the `Scanner`
    instance:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取用户响应，我们调用`Scanner`实例的`nextInt`方法：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, once we get the user input, we check which option from the menu should
    be executed:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，一旦我们获取了用户输入，我们就检查菜单中的哪个选项应该被执行：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We now know about the logic in the main application menu when we start the app.
    It is time to dig deeper and look at the code for the `show-menu` function.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们启动应用时，我们就知道了主应用菜单中的逻辑。现在是时候深入挖掘并查看`show-menu`函数的代码了。
- en: 'Display the menu for the available coffees:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示可用的咖啡菜单：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `show-menu` function, we let the user know about two available coffees
    – `Latte` and `Mocha`:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`show-menu`函数中，我们让用户了解两种可用的咖啡——`Latte`和`Mocha`：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will display the coffee menu:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示咖啡菜单：
- en: '![Figure 10.3: Coffee menu display'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.3：咖啡菜单显示'
- en: '](img/B14502_10_03.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_10_03.jpg)'
- en: 'Figure 10.3: Coffee menu display'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.3：咖啡菜单显示
- en: The user can choose numbers `1` or `2`. We need to respond to the user's coffee
    choice now.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户可以选择数字`1`或`2`。我们现在需要响应用户的咖啡选择。
- en: 'We use the `Scanner` instance to get the user input:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Scanner`实例来获取用户输入：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we proceed to buy the coffee that the user chose:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们继续购买用户选择的咖啡：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `show-menu` function is not long. Its purpose is to display the available
    coffees and get the user input. Once the user has chosen their coffee, we call
    the `buy-coffee` function to handle buying the selected coffee.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`show-menu`函数并不长。它的目的是显示可用的咖啡并获取用户输入。一旦用户选择了他们的咖啡，我们就调用`buy-coffee`函数来处理所选咖啡的购买。'
- en: 'Ask the user how many coffees they''d like to buy:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户他们想要购买多少杯咖啡：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `buy-coffee` function asks how many coffees the user wants to buy. Again,
    we use an instance of the `Scanner` class – `input` – to get the user's choice.
    Next, the function calls two utility functions to process the purchase. The functions
    are responsible for calculating the coffee price and displaying the feedback message
    to the user.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`buy-coffee`函数询问用户想要购买多少杯咖啡。同样，我们使用`Scanner`类的实例`input`来获取用户的选择。接下来，函数调用两个实用函数来处理购买。这些函数负责计算咖啡价格并向用户显示反馈信息。'
- en: All the functions will be placed in the `utils.clj` file. Instead of having
    all functions in one big file, it is good practice to split functions into various
    namespaces. A common namespace name is `utils`. We can keep any useful functions
    that operate on data there.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有函数都将放置在`utils.clj`文件中。将所有函数放在一个大的文件中不是好习惯，将函数拆分到各种命名空间中是更好的做法。一个常见的命名空间名称是`utils`。我们可以将任何有用的操作数据的函数保存在那里。
- en: 'Create a `utils` namespace:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`utils`命名空间：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Calculate the coffee price:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算咖啡价格：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our first utility function calculates the coffee price. It uses the `get` function
    to check the `coffees` hash for the passed-in coffee type. The hash is defined
    in the core namespace:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的第一个实用函数计算咖啡价格。它使用`get`函数来检查传入的咖啡类型在`coffees`哈希中。该哈希定义在核心命名空间中：
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The value obtained from the hash is then multiplied by the number of coffee
    cups that the user ordered. Finally, we coerce the number to float. This allows
    us to convert a number such as 1.2000000000000002 to 1.2.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从哈希中获得的值然后乘以用户订购的咖啡杯数。最后，我们将数字强制转换为浮点数。这允许我们将1.2000000000000002这样的数字转换为1.2。
- en: The last utility function used when we handle buying coffee is the `display-bought-coffee-message`
    function.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们处理购买咖啡时使用的最后一个实用函数是`display-bought-coffee-message`函数。
- en: 'Display the message to the user after buying the coffee:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在购买咖啡后向用户显示消息：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `display-bought-coffee-message` function takes the order map and constructs
    a string message for the user based on the data from the map. The user is informed
    that they bought a certain amount of cups of coffee for the specified price.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`display-bought-coffee-message`函数接收订单映射并基于映射中的数据为用户构建一个字符串消息。用户被告知他们以指定价格购买了特定数量的咖啡杯。'
- en: 'With this function, we can control the information passed back to the user
    after completing their order:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此函数，我们可以在用户完成订单后控制传递给用户的信息：
- en: '![Figure 10.4: Displaying the message for the coffee bought'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.4：显示购买咖啡的消息'
- en: '](img/B14502_10_04.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_04.jpg)'
- en: 'Figure 10.4: Displaying the message for the coffee bought'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.4：显示购买咖啡的消息
- en: 'The second option from the main menu allows us to see the placed orders:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主菜单中的第二个选项允许我们查看已放置的订单：
- en: '![Figure 10.5: Orders allows the user to see their orders'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.5：订单允许用户查看他们的订单'
- en: '](img/B14502_10_05.jpg)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_05.jpg)'
- en: 'Figure 10.5: Orders allows the user to see their orders'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.5：订单允许用户查看他们的订单
- en: The function responsible for displaying orders is `show-orders` from the `coffee-app.core`
    namespace.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 负责显示订单的函数是来自`coffee-app.core`命名空间的`show-orders`函数。
- en: 'Display the placed orders:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示已放置的订单：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function will display the coffee orders made. In this exercise, we informed
    the user that orders will be displayed here. In the following exercise, we will
    implement saving and displaying orders:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数将显示所下的咖啡订单。在这个练习中，我们通知用户订单将在这里显示。在接下来的练习中，我们将实现保存和显示订单：
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we run the application and buy two cups of latte, we will see the following output:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行应用程序并购买两杯拿铁时，我们将看到以下输出：
- en: '![Figure 10.6: Output when the user buys two cups of coffee'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.6：用户购买两杯咖啡时的输出'
- en: '](img/B14502_10_06.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_06.jpg)'
- en: 'Figure 10.6: Output when the user buys two cups of coffee'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.6：用户购买两杯咖啡时的输出
- en: 'Add the main function as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加主函数如下：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to run the application, we will use the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行应用程序，我们将使用以下命令：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once we run the application, we can see the available coffees and order them,
    similar to what we saw in *Figure 10.6*.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行应用程序，我们就可以看到可用的咖啡并下订单，就像我们在*图10.6*中看到的那样。
- en: We have our application running successfully. We will create tests for our application
    now.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的应用程序已成功运行。我们现在将为我们的应用程序创建测试。
- en: 'Check the testing directory. We use the `tree` command to display a list of
    folders and files within the test directory:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查测试目录。我们使用`tree`命令显示测试目录中的文件夹和文件列表：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we created the application, Leiningen created the `test` directory for
    us. There are a number of ways to check the project's structure. We check the
    project structure using the preceding `tree` command.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们创建应用程序时，Leiningen为我们创建了`test`目录。有几种方法可以检查项目结构。我们使用前面的`tree`命令来检查项目结构。
- en: '![Figure 10.7: Project structure'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.7：项目结构'
- en: '](img/B14502_10_07.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_07.jpg)'
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This file imports the Clojure testing namespace, as well as the core file from
    the source directory. The file contains one test method. This method is called
    `a-test`. Because we have autogenerated the `a-test` test function, we can run
    tests after creating a Leiningen project:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件导入了Clojure测试命名空间，以及源目录中的核心文件。该文件包含一个测试方法。此方法称为`a-test`。因为我们已自动生成了`a-test`测试函数，所以我们可以在创建Leiningen项目后运行测试：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we create a new project with Leiningen, it will create one test function.
    This function is called `a-test` and is inside the `core_test.clj` file.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们使用Leiningen创建新项目时，它将创建一个测试函数。此函数称为`a-test`，位于`core_test.clj`文件中。
- en: 'In order to run tests, we need to call Leiningen''s `test` task. The `test`
    task is a task that will run the tests within the test directory:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行测试，我们需要调用Leiningen的`test`任务。`test`任务是一个将在测试目录中运行测试的任务：
- en: '[PRE25]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.8: Running the test task'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.8：运行测试任务'
- en: '](img/B14502_10_08.jpg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_08.jpg)'
- en: 'Figure 10.8: Running the test task'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.8：运行测试任务
- en: The `a-test` test fails, as we have not yet implemented the `a-test` test from
    the `core_test.clj` file. Leiningen informed us that it tested the `coffee-app.core-test`
    namespace. We have information that the test failed, including which line in the
    test file (line 7) caused the test to fail.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`a-test`测试失败，因为我们还没有在`core_test.clj`文件中实现`a-test`测试。Leiningen通知我们它测试了`coffee-app.core-test`命名空间。我们有信息表明测试失败，包括测试文件中的哪一行（第7行）导致了测试失败。'
- en: Leiningen even provided us with information about what the test expected and
    what the actual result was. In this case, the default test tried to compare the
    numbers one and zero. In order to make the test pass, let's change the `a-test` function.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Leiningen甚至提供了关于测试期望的结果和实际结果的信息。在这种情况下，默认测试尝试比较数字一和零。为了使测试通过，让我们更改`a-test`函数。
- en: 'To fix the default `test` function from the Leiningen project, we will change
    the implementation of the default `a-test` function that we have just seen:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复Leiningen项目的默认`test`函数，我们将更改我们刚刚看到的默认`a-test`函数的实现：
- en: '[PRE26]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We changed the test to state that 1 is equal to 1\. This will make our `a-test`
    pass.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们更改了测试，使其表明1等于1。这将使我们的`a-test`通过。
- en: 'We run the test using the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下方式运行测试：
- en: '[PRE27]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can run the tests again:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以再次运行测试：
- en: '![Figure 10.9: Running the test after fixing the default a-test function'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.9：修复默认的a-test函数后的测试运行'
- en: '](img/B14502_10_09.jpg)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_10_09.jpg)'
- en: 'Figure 10.9: Running the test after fixing the default a-test function'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.9：修复默认的a-test函数后的测试运行
- en: This time, Leiningen informs us that it ran one test with one assertion (test
    condition). There were zero failures and zero errors. We now know how to run tests.
    It is time to write tests for the `utils` namespace. We will create a testing
    file for the `utils` namespace.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，Leiningen通知我们它运行了一个测试，包含一个断言（测试条件）。没有失败和错误。我们现在知道如何运行测试。是时候为`utils`命名空间编写测试了。我们将为`utils`命名空间创建一个测试文件。
- en: 'Create a test file for the `utils` namespace. Inside the file, we will write
    code to test functions in the `utils` namespace:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`utils`命名空间创建一个测试文件。在文件中，我们将编写代码来测试`utils`命名空间中的函数：
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After creating `utils_test.clj`, we will have two test files:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建`utils_test.clj`之后，我们将有两个测试文件：
- en: '![Figure 10.10: We now have two test files after creating utils_test.clj'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.10：创建utils_test.clj后，我们现在有两个测试文件'
- en: '](img/B14502_10_10.jpg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_10_10.jpg)'
- en: 'Figure 10.10: We now have two test files after creating utils_test.clj'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.10：创建utils_test.clj后，我们现在有两个测试文件
- en: In `utils_test.clj`, we want to test functions from the `utils` namespace. We
    will add the necessary dependencies to the testing namespace. Inside `core_test.clj`,
    we will keep tests for functions that are defined in the `core.clj` file. The
    `utils_test.clj` file will contain tests for functions defined in the `utils.clj`
    file.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`utils_test.clj`中，我们想要测试`utils`命名空间中的函数。我们将向测试命名空间添加必要的依赖。在`core_test.clj`中，我们将保留在`core.clj`文件中定义的函数的测试。`utils_test.clj`文件将包含在`utils.clj`文件中定义的函数的测试。
- en: 'We will import the `clojure.test` library and namespaces from the source directory
    that we will test:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从源目录中导入我们将要测试的`clojure.test`库和命名空间：
- en: '[PRE29]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `clojure.test` namespace has a number of testing functions. We import them
    using the `:refer` keyword, which we learned about in *Chapter 8*, *Namespaces,
    Libraries, and Leiningen*. We import four functions:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clojure.test`命名空间有几个测试函数。我们使用`:refer`关键字导入它们，我们在第8章“命名空间、库和Leiningen”中学习了它。我们导入了四个函数：'
- en: '`are`: Allows you to test multiple testing scenarios'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`are`: 允许您测试多个测试场景'
- en: '`is`: Allows you to test a single testing scenario'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`is`: 允许您测试单个测试场景'
- en: '`deftest`: Defines a Clojure test'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`deftest`: 定义Clojure测试'
- en: '`testing`: Defines an expression that will be tested'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`testing`: 定义一个将被测试的表达式'
- en: We import the `coffee-app.core` and `coffee-app.utils` namespaces from the source
    directory. From the `core` namespace, we import `price-menu`, which contains a
    list of available coffees and the price for each coffee. Finally, we import the
    `utils` namespace, which contains the functions that we want to test.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从源目录中导入`coffee-app.core`和`coffee-app.utils`命名空间。从`core`命名空间中，我们导入`price-menu`，其中包含可用的咖啡列表以及每款咖啡的价格。最后，我们导入`utils`命名空间，其中包含我们想要测试的函数。
- en: The `clojure.test` object provides the `is` macro for testing. We will learn
    about macros in *Chapter 11*, *Macros*. For the purpose of this exercise, you
    can think of macros as special functions. Macros are used in the same way as we
    have used functions.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clojure.test` 对象提供了用于测试的 `is` 宏。我们将在第 11 章 *宏* 中学习关于宏的内容。为了这个练习，你可以将宏视为特殊函数。宏的使用方式与函数相同。'
- en: 'The `is` macro takes a test and an optional assertion message. Add the following
    code to `utils_test.clj`:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`is` 宏接受一个测试和一个可选的断言消息。将以下代码添加到 `utils_test.clj`：'
- en: '[PRE30]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `deftest` macro allows us to define tests. Each test is defined using the
    `testing` macro. The `testing` macro can be supplied with a string to provide
    a testing context. Here, we inform you that this is a single test using the `is`
    macro. In this test, we call the `calculate-coffee-price` function, passing `price-menu`,
    which contains information about the available coffees.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`deftest` 宏允许我们定义测试。每个测试都是使用 `testing` 宏定义的。`testing` 宏可以提供一个字符串来提供测试上下文。在这里，我们通知你这是一个使用
    `is` 宏的单个测试。在这个测试中，我们调用 `calculate-coffee-price` 函数，传递 `price-menu`，它包含有关可用咖啡的信息。'
- en: The second argument that we pass is the number of cups of coffee that we want
    to buy. In our case, we want to buy one cup. For the test, the result of calling
    the `calculate-coffee-price` function for one latte should be 0.5\.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们传递的第二个参数是我们想要购买咖啡杯数。在我们的例子中，我们想要购买一杯。对于测试，调用 `calculate-coffee-price` 函数得到一杯拿铁的结果应该是
    0.5。
- en: 'We will run the test now:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将运行测试：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.11: Running the test after using the is macro'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.11：使用 is 宏运行测试后的结果'
- en: '](img/B14502_10_11.jpg)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_11.jpg](img/B14502_10_11.jpg)'
- en: 'Figure 10.11: Running the test after using the is macro'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.11：使用 is 宏运行测试后的结果
- en: We can see that the newly added test passes.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到新添加的测试通过了。
- en: 'While we can write tests with the `is` macro, testing multiple times with the
    `is` macro results in the unnecessary duplication of code. Consider the next test,
    where we run through three scenarios:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们可以使用 `is` 宏编写测试，但使用 `is` 宏多次测试会导致代码的不必要重复。考虑下一个测试，其中我们运行了三个场景：
- en: Buying one coffee – a user decides to buy one cup of coffee
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 购买一杯咖啡——用户决定购买一杯咖啡
- en: Buying two coffees – a user decides to buy two cups of coffee
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 购买两杯咖啡——用户决定购买两杯咖啡
- en: Buying three coffees – a user decides to buy three cups of coffee
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 购买三杯咖啡——用户决定购买三杯咖啡
- en: '[PRE32]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the `calculate-coffee-price-test-with-multiple-is` test, we have three
    single tests using the `is` macro. We test three different scenarios: buying one
    coffee, buying two coffees, and buying three coffees.'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `calculate-coffee-price-test-with-multiple-is` 测试内部，我们使用了三个使用 `is` 宏的单个测试。我们测试了三种不同的场景：购买一杯咖啡、购买两杯咖啡和购买三杯咖啡。
- en: 'Run multiple `is` tests. We run the tests for the `calculate-coffee-price-test-with-multiple-is`
    test:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行多个 `is` 测试。我们运行 `calculate-coffee-price-test-with-multiple-is` 测试：
- en: '[PRE33]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.12: Running multiple is tests'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.12：运行多个 is 测试'
- en: '](img/B14502_10_12.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_12.jpg](img/B14502_10_12.jpg)'
- en: 'Figure 10.12: Running multiple is tests'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.12：运行多个 is 测试
- en: The new test has been run and passes. In the preceding code, we see that we
    duplicate a lot of calls to the `calculate-coffee-price` function. There should
    be a more efficient way to write tests for multiple scenarios.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新测试已运行并通过。在先前的代码中，我们可以看到我们重复调用了多次 `calculate-coffee-price` 函数。应该有更高效的方式来编写针对多个场景的测试。
- en: The `are` macro is a convenience macro when we plan to write multiple tests
    using the `is` macro. The `are` macro is a test macro used for testing multiple
    testing scenarios. It differs from the `is` macro in a number of scenarios that
    we can test.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们计划使用 `is` 宏编写多个测试时，`are` 宏是一个便利的宏。`are` 宏是一个用于测试多个测试场景的测试宏。它在许多测试场景中与 `is`
    宏不同。
- en: 'The `is` macro allows us to test one scenario. It is singular. The `are` macro
    allows us to test more than one scenario. It is plural. We use the `is` macro
    when we want to test a single scenario and the `are` macro when we want to test
    more than one scenario. The previous test with multiple `is` macro calls can be
    rewritten as:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`is` 宏允许我们测试一个场景。它是单数的。`are` 宏允许我们测试多个场景。它是复数的。当我们想要测试单个场景时，我们使用 `is` 宏；当我们想要测试多个场景时，我们使用
    `are` 宏。之前的多个 `is` 宏调用测试可以重写为：'
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `are` macro checks multiple tests against the assertion written by us.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`are` 宏会对我们编写的断言进行多个测试。'
- en: 'In the preceding test, we wrote an assertion:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在先前的测试中，我们编写了一个断言：
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The result of calling `calculate-coffee-price` with `coffees-hash coffee-type
    number-of-cups` should be equal to the result.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`coffees-hash coffee-type number-of-cups`调用`calculate-coffee-price`的结果应该等于预期结果。
- en: 'Inside the vector, we specify four arguments that we need to run our test:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在向量中，我们指定了四个我们需要运行测试的参数：
- en: '[PRE36]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The arguments include coffee-hash with information about coffees, coffee-type,
    number-of-cups, and result – the result of calculating the coffee price.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数包括关于咖啡的信息、咖啡类型、杯数和结果——计算咖啡价格的结果。
- en: Again, we use the `equals` (`=`) function to check the result of calling the
    `calculate-coffee-price` function against the result that we expect.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，我们使用`equals`（`=`）函数来检查调用`calculate-coffee-price`函数的结果与预期结果是否一致。
- en: 'When we run the tests again, we get the following:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们再次运行测试时，我们得到以下结果：
- en: '[PRE37]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.13: Output for tests run after using the are macro'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.13：使用are宏后的测试输出'
- en: '](img/B14502_10_13.jpg)'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_13.jpg)'
- en: 'Figure 10.13: Output for tests run after using the are macro'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：使用are宏后的测试输出
- en: Our new test passes. We used the `are` macro to simplify writing multiple test
    assertions. Whenever we need to write multiple tests with the `is` macro, using
    the `are` macro will make our code shorter and more readable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新测试通过了。我们使用了`are`宏来简化多个测试断言的编写。每次我们需要使用`is`宏编写多个测试时，使用`are`宏将使我们的代码更短、更易读。
- en: In this exercise, we have seen how to write tests using the `clojure.test` library.
    In the next exercise, we will look at another Clojure library for testing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用`clojure.test`库编写测试。在下一个练习中，我们将查看另一个用于测试的Clojure库。
- en: Using the Expectations Testing Library
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Expectations测试库
- en: The main philosophy in the `Expectations` library revolves around an expectation.
    The `expectation` object is built with the idea that unit tests should contain
    one assertion per test. A result of this design choice is that expectations have
    very minimal syntax, and reduce the amount of code needed to perform tests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expectations`库中的主要哲学是围绕一个预期。`expectation`对象是基于单元测试应该包含一个断言每个测试的想法构建的。这种设计选择的结果是，预期具有非常简洁的语法，并减少了执行测试所需的代码量。'
- en: Minimal syntax helps to maintain the code as it is easier to read and reason
    about code that is short and focused on testing one feature. Another benefit relates
    to testing failing code. When a test fails, it is easy to check which test failed
    and why because the test is focused on one feature and not multiple features.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最简语法有助于保持代码，因为它更容易阅读和推理简短且专注于测试一个功能的代码。另一个好处与测试失败的代码相关。当测试失败时，很容易检查哪个测试失败了以及为什么，因为测试专注于一个功能而不是多个功能。
- en: 'The `Expectations` library allows us to test things like the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expectations`库允许我们测试以下内容：'
- en: 'Errors thrown by the code: We can test whether a part of our code throws an
    error. Imagine a function that calculates a discount. This function takes numbers
    as input and multiplies them. If we pass a string such as "`text`" and a number
    `5`, we will get an error because Clojure cannot multiply a number and a string.
    We can write tests to check whether an error is thrown in this scenario.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码抛出的错误：我们可以测试我们的代码的一部分是否抛出错误。想象一个计算折扣的函数。这个函数接受数字作为输入并相乘。如果我们传递一个如"`text`"的字符串和一个数字`5`，我们将得到一个错误，因为Clojure不能将数字和字符串相乘。我们可以编写测试来检查在这种情况下是否抛出错误。
- en: 'The function''s return value: We can test whether a function returns the expected
    value. Imagine a function that calculates a discount. This function takes numbers
    as input and multiplies them. After the multiplication, it should return a number.
    We can write tests to check that our function returns a number instead of a collection
    or a string.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回值：我们可以测试函数是否返回预期的值。想象一个计算折扣的函数。这个函数接受数字作为输入并相乘。在乘法之后，它应该返回一个数字。我们可以编写测试来检查我们的函数是否返回一个数字而不是集合或字符串。
- en: 'Elements in a collection: We can write tests to check whether a collection
    contains expected elements. Imagine a function checking a list of users for children.
    This function takes a list of users as input. We can write tests checking the
    age of users.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合中的元素：我们可以编写测试来检查集合是否包含预期的元素。想象一个检查用户列表中是否有儿童的函数。这个函数接受用户列表作为输入。我们可以编写测试来检查用户的年龄。
- en: 'In order to use `Expectations`, we need to import it into a Leiningen project:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`Expectations`，我们需要将其导入Leiningen项目：
- en: We add a dependency for the `expectations` library [`expectations "2.1.10"`].
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了对`expectations`库的依赖项`[`expectations "2.1.10"`]。
- en: '`lein-expectations` is a Leiningen plugin that runs expectations tests from
    the command line `[lein-expectations "0.0.8"]`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lein-expectations`是一个Leiningen插件，它从命令行运行expectations测试`[lein-expectations
    "0.0.8"]`。'
- en: We will write tests for the `calculate-coffee-price` function. This will allow
    us to compare how we compose tests in the `Expectations` library against tests
    written using the `clojure.test` library.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`calculate-coffee-price`函数编写测试。这将使我们能够比较在`Expectations`库中编写的测试与使用`clojure.test`库编写的测试。
- en: 'Exercise 10.02: Testing the Coffee Application with Expectations'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.02：使用Expectations测试咖啡应用程序
- en: 'The aim of this exercise is to learn how to write unit testing in Clojure using
    the `Expectations` library. We will write tests for the `calculate-coffee-price`
    function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是学习如何使用`Expectations`库在Clojure中编写单元测试。我们将为`calculate-coffee-price`函数编写测试：
- en: 'Add `expectations` to the `project.clj` file. After adding the `Expectations`
    library to `project.clj`, the file should look as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`expectations`添加到`project.clj`文件中。在将`Expectations`库添加到`project.clj`后，文件应如下所示：
- en: '[PRE38]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Create a file for the `utils` tests.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`utils`测试创建一个文件。
- en: 'In order to use the Expectations library, we need to import functions first.
    The `utils` namespace should look like the following:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使用Expectations库，我们首先需要导入函数。`utils`命名空间应如下所示：
- en: '[PRE39]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Test the `calculate-coffee-price` function. Buying three cups of latte should
    cost us 1.5\. The following test will check this condition:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`calculate-coffee-price`函数。购买三杯拿铁应该花费我们1.5元。以下测试将检查这个条件：
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We are ready to run the test.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经准备好运行测试。
- en: 'Run the `expectations` test with the Leiningen task. In order to run tests
    on the command line, we need to use the Leiningen task from the `lein-expectations`
    plugin:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Leiningen任务运行`expectations`测试。为了在命令行上运行测试，我们需要使用来自`lein-expectations`插件的Leiningen任务：
- en: '[PRE41]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This task will execute the `expectations` tests.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此任务将执行`expectations`测试。
- en: '![Figure 10.14: Output after running the expectations test'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.14：运行expectations测试后的输出'
- en: '](img/B14502_10_14.jpg)'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_14.jpg)'
- en: 'Figure 10.14: Output after running the expectations test'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.14：运行expectations测试后的输出
- en: As we expected, for three lattes, we need to pay 1.5\. What will happen if we
    pass a string instead of a number for a number of cups? We would expect an error.
    With `expectations`, we can test for errors.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所料，对于三杯拿铁，我们需要支付1.5元。如果我们传递一个字符串而不是数字作为杯数会发生什么？我们预计会出错。使用`expectations`，我们可以测试错误。
- en: 'The `expectations` library allows us to test whether a function throws an error.
    The `calculate-coffee-price` function requires a number. Passing a string should
    result in an error:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`expectations`库允许我们测试函数是否抛出错误。`calculate-coffee-price`函数需要一个数字。传递一个字符串应该导致错误：'
- en: '[PRE42]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.15: Testing the calculate-coffee-price function using the Expectations
    library'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.15：使用Expectations库测试calculate-coffee-price函数'
- en: '](img/B14502_10_15.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_15.jpg)'
- en: 'Figure 10.15: Testing the calculate-coffee-price function using the Expectations
    library'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.15：使用Expectations库测试calculate-coffee-price函数
- en: After running the test, we see that all tests pass. Tests do not always pass.
    With `expectations`, we are informed when tests fail.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行测试后，我们看到所有测试都通过了。测试并不总是通过。使用`expectations`，当测试失败时，我们会得到通知。
- en: 'When we run a test that fails, `Expectations` will let us know. Testing for
    an error when the error is not thrown will fail the test:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行一个失败的测试时，`Expectations`会通知我们。当错误未抛出时测试错误将失败：
- en: '[PRE43]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.16: Running a test that fails using the Expectations library'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.16：使用Expectations库运行失败的测试'
- en: '](img/B14502_10_16.jpg)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_16.jpg)'
- en: 'Figure 10.16: Running a test that fails using the Expectations library'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.16：使用Expectations库运行失败的测试
- en: The Expectations library informed us that one test failed. We also know in which
    namespace we have a failing test and which line of code caused the test to fail.
    This allows us to quickly find the failing test.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Expectations`库通知我们有一个测试失败了。我们还知道在哪个命名空间有一个失败的测试以及哪一行代码导致了测试失败。这使我们能够快速找到失败的测试。'
- en: We know that passing a string to `calculate-coffee-price` will result in an
    error. With Expectations, we can also check what the return type from the function
    is.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们知道将字符串传递给`calculate-coffee-price`将导致错误。使用Expectations，我们还可以检查函数的返回类型。
- en: 'In Clojure code, we often compose functions. One function operates on the result
    of running other functions. It is common to check that functions that we call
    return the types of values that we expect. With `Expectations`, we can check the
    return type from a function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Clojure代码中，我们经常组合函数。一个函数作用于其他函数运行的结果。检查我们调用的函数返回我们期望的类型值是很常见的。使用`Expectations`，我们可以检查函数的返回类型：
- en: '[PRE44]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We expect that `calculate-coffee-price` will return a number:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们期望`calculate-coffee-price`将返回一个数字：
- en: '![Figure 10.17: Using Expectations'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.17：使用Expectations]'
- en: '](img/B14502_10_17.jpg)'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_17.jpg)'
- en: 'Figure 10.17: Using Expectations'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.17：使用Expectations
- en: Running the tests confirms that the number is the correct return type of the
    `calculate-coffee-price` function. With `Expectations`, we also can test whether
    a collection contains requested elements.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行测试确认，该数字是`calculate-coffee-price`函数正确的返回类型。使用`Expectations`，我们还可以测试一个集合是否包含请求的元素。
- en: 'The `price-menu` hash contains information about the available coffees, such
    as type and price. With `Expectations`, we can test whether elements belong to
    a collection:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`price-menu`哈希表包含有关可用咖啡的信息，例如类型和价格。使用`Expectations`，我们可以测试元素是否属于一个集合：'
- en: '[PRE45]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We expect that, on the menu, we have latte and that its price is `0.5`.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们期望在菜单上我们有拿铁，并且它的价格是`0.5`。
- en: '![Figure 10.18: Testing whether latte belongs to the menu'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.18：测试拿铁是否属于菜单]'
- en: '](img/B14502_10_18.jpg)'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_18.jpg)'
- en: 'Figure 10.18: Testing whether latte belongs to the menu'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18：测试拿铁是否属于菜单
- en: 'As expected, on our menu, we have a latte. We now know two testing libraries
    in Clojure: `clojure.test` and Expectations. The third testing library that we
    will learn about is `Midje`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在我们的菜单上，我们有拿铁。我们现在知道了Clojure中的两个测试库：`clojure.test`和Expectations。我们将要学习的第三个测试库是`Midje`。
- en: Unit Testing with the Midje Library
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Midje库进行单元测试
- en: '`Midje` is a testing library in Clojure that encourages writing readable tests.
    `Midje` builds on top of the bottom-up testing provided by `clojure.test` and
    adds support for top-down testing. Bottom-up testing means that we write tests
    for a single function first. If this function is used by some other function,
    we write tests after finishing the implementation for the other function.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Midje`是Clojure中的一个测试库，它鼓励编写可读的测试。`Midje`建立在`clojure.test`提供的自底向上测试之上，并增加了对自顶向下测试的支持。自底向上测试意味着我们首先为单个函数编写测试。如果这个函数被其他函数使用，我们将在完成其他函数的实现后编写测试。'
- en: 'In the coffee-ordering application, we have the `load-orders` function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在咖啡订购应用程序中，我们有`load-orders`函数：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `load-orders` function uses the `file-exists?` function. Functions in Clojure
    should not perform many things. It is good practice to have small functions focusing
    on single tasks. The `file-exist` function checks a file. The `load-orders` function
    loads orders. Because we cannot load orders from a file that does not exist, we
    need to use the `file-exist` function to check for a file with saved orders:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`load-orders`函数使用了`file-exists?`函数。Clojure中的函数不应执行许多操作。良好的实践是编写专注于单个任务的短小函数。`file-exist`函数检查文件。`load-orders`函数加载订单。因为我们不能从不存在的文件中加载订单，所以我们需要使用`file-exist`函数来检查保存订单的文件：'
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With bottom-up testing, we have to write the implementation for `file-exists`
    first. After we have a working implementation of `file-exist`, then we can write
    the implementation for `load-orders`. This way of writing tests forces us to think
    about implementation details for all functions instead of focusing on a feature
    that we want to implement. Our original goal was to load data from a file but
    we are focusing now on checking whether a file exists.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在自底向上的测试中，我们首先需要编写`file-exists`的实现。在我们有了`file-exist`的工作实现之后，然后我们可以编写`load-orders`的实现。这种编写测试的方式迫使我们思考所有函数的实现细节，而不是专注于我们想要实现的功能。我们的原始目标是加载文件中的数据，但现在我们专注于检查文件是否存在。
- en: With a top-down approach, we can write working tests for the main tested function
    without implementing functions that are used by the tested function. We state
    that we want to test the `load-orders` function and that it uses the file-exist
    function but we do not need to have a full implement of file-exist. We merely
    need to say that we will use this function. This allows us to focus on a feature
    that we want to test without worrying about implementing all sub-steps.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自上而下的方法，我们可以在不实现被测试函数使用的函数的情况下编写针对主测试函数的工作测试。我们声明我们想要测试`load-orders`函数，并且它使用`file-exist`函数，但我们不需要有一个完整的`file-exist`实现。我们只需要声明我们将使用此函数。这允许我们专注于我们想要测试的功能，而不用担心实现所有子步骤。
- en: In order to use `Midje`, add it as a dependency (`[midje "1.9.4"] to project.clj`)
    to the `project.clj` file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`Midje`，将其作为依赖项（`[midje "1.9.4"]`）添加到`project.clj`文件中。
- en: 'Exercise 10.03: Testing the Coffee Application with Midje'
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.03：使用Midje测试咖啡应用
- en: 'The aim of this exercise is to learn how to use the `Midje` library and write
    top-down tests. We will write tests for `calculate-coffee-price`. We will use
    a top-down approach to write tests for the load-orders function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是学习如何使用`Midje`库并编写自上而下的测试。我们将为`calculate-coffee-price`编写测试。我们将使用自上而下的方法为`load-orders`函数编写测试：
- en: 'We will import the `Midje` namespace to the `utils` namespace:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导入`Midje`命名空间到`utils`命名空间：
- en: '[PRE48]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After importing the `Midje` namespace, we are ready to use the `fact` macro
    from the `Midje` namespace.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入`Midje`命名空间后，我们就可以使用`Midje`命名空间中的`fact`宏了。
- en: '`Midje` uses the `fact` macro, which states certain facts about a future version
    of our test. The macro takes a single argument on both sides of the `=>` symbol.
    The `fact` macro states that the result from the left-hand side is to be expected
    on the right-hand side of the symbol:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Midje`使用`fact`宏，该宏声明了关于我们测试未来版本的某些事实。宏在`=>`符号的两侧都接受一个参数。`fact`宏声明左侧的结果应该在符号的右侧预期：'
- en: '[PRE49]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We wrote a test where we expect that the price for three cups of latte is `3`.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们编写了一个测试，预期三杯拿铁的价格是`3`。
- en: '`Midje` supports autotesting in the REPL.'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Midje`支持在REPL中进行自动测试。'
- en: 'With autotesting, we do not need to run tests every time we make changes. The
    autotester will run the tests anytime it detects changes. In order to use autotesting
    in `Midje`, we enable autotesting in the REPL:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自动测试，我们不需要每次更改时都运行测试。当自动测试器检测到更改时，它会自动运行测试。为了在`Midje`中使用自动测试，我们在REPL中启用自动测试：
- en: '[PRE50]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After starting the REPL, we import the `Midje` namespace and enable the autotester:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动REPL后，我们导入`Midje`命名空间并启用自动测试器：
- en: '[PRE51]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After starting the REPL, we imported the `Midje` namespace.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在启动REPL后，我们导入了`Midje`命名空间。
- en: The second step was calling the `autotest` function. This function will run
    the tests automatically when our code changes.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二步是调用`autotest`函数。当我们的代码发生变化时，此函数将自动运行测试。
- en: 'After enabling autotesting, our tests are run thanks to the `autotest` function
    that we used in the REPL:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启用自动测试后，我们的测试是通过我们在REPL中使用的`autotest`函数运行的：
- en: '![Figure 10.19: Executing the tests'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.19：执行测试'
- en: '](img/B14502_10_19.jpg)'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_19.jpg)'
- en: 'Figure 10.19: Executing the tests'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.19：执行测试
- en: '`Midje` informs us that our tests failed. The price for three cups of latte
    is not `3` but `1.5`. When we change the implementation of the test, the autotest
    runs again:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Midje`告诉我们测试失败了。三杯拿铁的价格不是`3`，而是`1.5`。当我们更改测试的实现时，自动测试再次运行：'
- en: '[PRE52]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The autotest runs as follows:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动测试的运行方式如下：
- en: '![Figure 10.20: Running autotest after changing the implementation'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.20：更改实现后运行自动测试'
- en: '](img/B14502_10_20.jpg)'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_20.jpg)'
- en: 'Figure 10.20: Running autotest after changing the implementation'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.20：更改实现后运行自动测试
- en: This time, we are informed that our tests pass. We know now how to run autotests
    and how to write tests using `Midje`. It is time now to explore top-down testing
    in `Midje`.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们被告知测试通过。现在我们知道了如何运行自动测试以及如何使用`Midje`编写测试。现在是时候探索`Midje`中的自上而下测试了。
- en: 'In the `utils` namespace, we have the `display-bought-coffee-message` function,
    which displays a message about the number of coffee types bought. This function
    has a hardcoded currency symbol:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`utils`命名空间中，我们有一个`display-bought-coffee-message`函数，该函数显示购买咖啡类型的数量信息。此函数有一个硬编码的货币符号：
- en: '[PRE53]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It would be nice to obtain the currency code from a utility function and not
    hardcode it. As some countries use the same currency, just as the euro is used
    in many European countries, it is a good idea to encapsulate the logic of getting
    the currency into a function.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从实用函数中获取货币代码而不是硬编码它将是一个不错的选择。正如欧元在许多欧洲国家使用一样，一些国家使用相同的货币，将获取货币的逻辑封装到函数中是一个好主意。
- en: 'We will keep the information about the currencies in a hash. Remember from
    *Chapter 1*, *Hello REPL!*, that a hash is a Clojure collection where we store
    data using keys and values:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把有关货币的信息保存在一个哈希表中。记得从 *第一章*，*Hello REPL!*，哈希是一个 Clojure 集合，我们使用键和值来存储数据：
- en: '[PRE54]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This allows us to check the currencies that different countries use and currency
    symbols.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许我们检查不同国家使用的货币和货币符号。
- en: As we do not plan to write the implementation for the functions of currencies,
    we will provide a stub (substitution) for it.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不打算编写货币函数的实现，我们将为此提供一个存根（替代）。
- en: 'We saw an explanation of a stub at the beginning of this chapter:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在本章开头看到了存根的解释：
- en: '[PRE55]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This tells `Midje` that we plan to use the `get-currency` function but we have
    not implemented it yet. We will test against the euro, so we will add the `helper`
    var:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉 `Midje` 我们计划使用 `get-currency` 函数，但我们还没有实现它。我们将针对欧元进行测试，因此我们将添加 `helper`
    变量：
- en: '[PRE56]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The function for displaying information about bought coffees will initially
    look like this:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示购买咖啡信息的函数最初看起来像这样：
- en: '[PRE57]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The test for the `get-bought-coffee-message-with-currency` function looks as
    follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get-bought-coffee-message-with-currency` 函数的测试如下所示：'
- en: '[PRE58]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the test, we use the `Midje =>` symbol. We expect the result of calling `get-bought-coffee-message-with-currency`
    to equal the string message.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试中，我们使用 `Midje =>` 符号。我们期望调用 `get-bought-coffee-message-with-currency` 的结果等于字符串消息。
- en: We use the provided function from `Midje` to stub call to the `get-currency`
    function. When the `Midje` test calls this function, it should return the euro
    symbol, €.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `Midje` 提供的函数来存根对 `get-currency` 函数的调用。当 `Midje` 测试调用此函数时，它应该返回欧元符号，€。
- en: 'If we check autorun in the REPL, we will see the following:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们在 REPL 中检查自动运行，我们将看到以下内容：
- en: '![Figure 10.21: Testing the get-bought-coffee-message-with-currency function
    using Midje'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.21：使用 Midje 测试 get-bought-coffee-message-with-currency 函数]'
- en: '](img/B14502_10_21.jpg)'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_21.jpg](img/B14502_10_21.jpg)'
- en: 'Figure 10.21: Testing the get-bought-coffee-message-with-currency function
    using Midje'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.21：使用 Midje 测试 get-bought-coffee-message-with-currency 函数]'
- en: '`Midje` informs us that one test failed. The `get-currency` function should
    have been called but was not called at all. We just wrote a test that compiled
    and ran. We did not get a compilation error. We focused on the logic for displaying
    a message and this part was a success. Once we have a test for `get-bought-coffee-message-with-currency`,
    it is time now to think about using `get-currency` to display messages:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Midje` 通知我们有一个测试失败了。`get-currency` 函数应该被调用，但实际上并没有被调用。我们只是编写了一个编译并运行的测试。我们没有得到编译错误。我们专注于显示消息的逻辑，这部分是成功的。一旦我们有
    `get-bought-coffee-message-with-currency` 的测试，现在就是考虑使用 `get-currency` 来显示消息的时候了：'
- en: '[PRE59]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This implementation of the `get-bought-coffee-message-with-currency` function
    uses the `get-currency` function:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `get-bought-coffee-message-with-currency` 函数的实现使用了 `get-currency` 函数：
- en: '![Figure 10.22: Testing again after using the get-currency function'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.22：使用 get-currency 函数后的再次测试]'
- en: '](img/B14502_10_22.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_22.jpg](img/B14502_10_22.jpg)'
- en: 'Figure 10.22: Testing again after using the get-currency function'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.22：使用 get-currency 函数后的再次测试]'
- en: When we check the autotest in the REPL, we see that all tests pass now.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 REPL 中检查自动测试时，我们看到现在所有测试都通过了。
- en: In this exercise, we were able to write tests using the `Midje` library. This
    library allows us to write tests using a top-down approach where we think about
    testing the main function and any other functions called by it are stubbed first.
    This helps us to focus on the behavior of the main function under test without
    worrying about implementing all of the used functions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够使用 `Midje` 库编写测试。这个库允许我们使用自顶向下的方法编写测试，我们首先考虑测试主函数，然后是它调用的任何其他函数都是存根。这有助于我们专注于测试的主函数的行为，而不必担心实现所有使用的函数。
- en: While we wrote tests using various libraries, all tests are limited. When we
    tested `calculate-coffee-price`, we tested it a few times. If we could test it
    more times, we could be more confident that the `calculate-coffee-price` function
    is performing as expected. Writing a few tests can be quick but writing 100 or
    200 tests takes time. Luckily, with property-based testing, we can generate lots
    of test scenarios very quickly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们使用了各种库来编写测试，但所有测试都是有限的。当我们测试 `calculate-coffee-price` 时，我们只测试了几次。如果我们能测试更多次，我们就可以更有信心地认为
    `calculate-coffee-price` 函数按预期执行。编写几个测试可能很快，但编写 100 或 200 个测试则需要时间。幸运的是，使用属性测试，我们可以非常快速地生成大量的测试场景。
- en: Property-Based Testing
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性测试
- en: '**Property-based testing**, also known as generative testing, describes properties
    that should be true for all valid test scenarios. A property-based test consists
    of a method for generating valid inputs (also known as a generator), and a function
    that takes a generated input. This function combines a generator with the function
    under test to decide whether the property holds for that particular input. With
    property-based testing, we automatically generate data across a wide search space
    to find unexpected problems.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性测试**，也称为生成式测试，描述了对于所有有效测试场景都应成立的属性。属性测试由一个生成有效输入的方法（也称为生成器）和一个接收生成输入的函数组成。此函数将生成器与被测试的函数结合起来，以决定该特定输入的属性是否成立。使用属性测试，我们可以在广泛的搜索空间内自动生成数据以查找意外问题。'
- en: 'Imagine a room-booking application. We should allow users to search for rooms
    suitable for families. Such rooms should have at least two beds. We could have
    a function that returns only those rooms that have at least two beds. With unit
    testing, we would need to write scenarios for the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个房间预订应用程序。我们应该允许用户搜索适合家庭的房间。这样的房间至少应该有两张床。我们可以有一个函数，它只返回至少有两张床的房间。使用单元测试，我们需要编写以下场景：
- en: Zero beds
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零张床
- en: One bed
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张床
- en: Two beds
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两张床
- en: Three beds
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三张床
- en: Four beds
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四张床
- en: Five beds
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五张床
- en: And other scenarios
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及其他场景
- en: If we wanted to test rooms with 20 beds, it would mean creating over 20 tests
    that are very similar. We would only change the number of beds. We can generalize
    such tests by describing what a family room is in general terms. As we said, a
    family room would have at least two beds. Property-based testing allows us to
    generalize inputs and generate them for us. Because inputs are generated automatically,
    we are not limited to manually typing tests and we could create 1,000 test scenarios
    easily. For our family room example, the input is a number of rooms. Testing would
    involve specifying that a room number is a number. With property-based tests,
    integer inputs would be automatically generated for us.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要测试有 20 张床的房间，那就意味着要创建超过 20 个非常相似的测试。我们只需更改床的数量。我们可以通过一般性地描述家庭房间的特性来概括此类测试。正如我们所说，家庭房间至少有两张床。属性测试允许我们概括输入并为我们生成它们。因为输入是自动生成的，所以我们不受手动输入测试的限制，可以轻松地创建
    1,000 个测试场景。在我们的家庭房间示例中，输入是房间数量。测试将涉及指定房间号是一个数字。使用属性测试，整数输入将自动为我们生成。
- en: 'Clojure provides the `test.check` library for property-based testing. Property-based
    testing has two key concepts:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 提供了 `test.check` 库用于属性测试。属性测试有两个关键概念：
- en: '`test.check.generators` namespace has many built-in generators, as well as
    combinator functions for creating your own new generators from the built-in generators.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test.check.generators` 命名空间包含许多内置生成器，以及组合函数，用于从内置生成器创建您自己的新生成器。'
- en: '**Properties**: Properties are characteristics of inputs. An input to any function
    can be described in general terms. In our family room example, the input is a
    number of rooms. So, the property is a number.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：属性是输入的特性。任何函数的输入都可以用一般术语来描述。在我们的家庭房间示例中，输入是房间数量。因此，属性是一个数字。'
- en: In the next exercise, we will write property-based tests for the coffee-ordering
    application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将为咖啡订购应用程序编写属性测试。
- en: 'Exercise 10.04: Using Property-Based Testing in the Coffee-Ordering Application'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.04：在咖啡订购应用程序中使用属性测试
- en: The aim of this exercise is to learn how to create tests using property-based
    testing. We will describe inputs for the `calculate-coffee-price` function and
    this will allow us to generate tests automatically.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是学习如何使用属性测试创建测试。我们将描述 `calculate-coffee-price` 函数的输入，这将允许我们自动生成测试。
- en: 'In order to use the `test.check` library, we need to add `[org.clojure/test.check
    "0.10.0"]` as a dependency in the `project.clj` file:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`test.check`库，我们需要在`project.clj`文件中将`[org.clojure/test.check "0.10.0"]`添加为依赖项：
- en: 'Before we can use `test.check` in the utils namespace, we need to import the
    necessary namespaces:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以在utils命名空间中使用`test.check`之前，我们需要导入必要的命名空间：
- en: '[PRE60]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We import three `test.check` namespaces:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们导入三个`test.check`命名空间：
- en: '`clojure.test.check.generators`: Will generate inputs'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clojure.test.check.generators`：将生成输入'
- en: '`clojure.test.check.properties`: Will allow us to describe inputs in a general
    form'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clojure.test.check.properties`：将允许我们以通用形式描述输入'
- en: '`clojure.test.check.clojure-test`: Will allow us to integrate with clojure.test'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clojure.test.check.clojure-test`：将允许我们与clojure.test集成'
- en: 'If we wanted to import these namespaces in the REPL, we would do the following:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想在REPL中导入这些命名空间，我们会这样做：
- en: '[PRE61]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Once we have the necessary namespaces imported, we can look at how to generate
    inputs.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们导入了必要的命名空间，我们就可以看看如何生成输入。
- en: 'In order to generate inputs for tests, we will use generators. The `calculate-coffee-price`
    function takes a number of cups as an argument. A generator creating numbers such
    as `small-integer` is what we need:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成测试输入，我们将使用生成器。`calculate-coffee-price`函数接受一个杯数作为参数。我们需要一个创建类似`small-integer`这样的数字的生成器：
- en: '[PRE62]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `small-integer` function from the generators'' namespace returns an integer
    between `-32768` and `32767`. The `sample` function returns a sample collection
    of the specified type. In the preceding example, we have a sample collection of
    small integers:'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成器命名空间中的`small-integer`函数返回介于`-32768`和`32767`之间的整数。`sample`函数返回指定类型的样本集合。在上面的例子中，我们有一个小整数的样本集合：
- en: '![Figure 10.23: Creating a sample of small integers'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.23：创建小整数的样本'
- en: '](img/B14502_10_23.jpg)'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_23.jpg)'
- en: 'Figure 10.23: Creating a sample of small integers'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.23：创建小整数的样本
- en: 'With generator combinators, we can obtain new generators. The `fmap` generator
    allows us to create a new generator by applying a function to the values created
    by another generator. The `fmap` generator works like the `map` function, which
    we know about from the first chapter. It allows us to map a function to a value
    created by the following generator. In this example, each integer created by the
    `small-integer` generator is incremented using the `inc` function:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成器组合子，我们可以获得新的生成器。`fmap`生成器允许我们通过将函数应用于另一个生成器创建的值来创建一个新的生成器。`fmap`生成器的工作方式类似于我们第一章节中了解到的`map`函数。它允许我们将函数映射到由以下生成器创建的值。在这个例子中，`small-integer`生成器创建的每个整数都通过`inc`函数进行增加：
- en: '[PRE63]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will return the following:'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE64]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We were able to increase the numbers generated by the `small-integer` generator
    by applying the `inc` function using the `fmap` combinator.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们能够通过使用`fmap`组合子应用`inc`函数来增加`small-integer`生成器生成的数字数量。
- en: We now know how to create inputs using generators. It is time to learn how to
    describe the properties of inputs.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在知道了如何使用生成器创建输入。现在是学习如何描述输入属性的时候了。
- en: A property is an actual test — it combines a generator with a function you want
    to test, and checks that the function behaves as expected given the generated
    values.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性是一个实际的测试——它结合了一个生成器和你想要测试的函数，并检查在给定的生成值下函数是否按预期行为。
- en: 'Properties are created using the `for-all` macro from the `clojure.test.check.properties`
    namespace:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性是通过`clojure.test.check.properties`命名空间中的`for-all`宏创建的：
- en: '[PRE65]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `defspec` macro allows you to run `test.check` tests like standard `clojure.test`
    tests. This allows us to extend test suits to include property-based testing together
    with standard unit tests. In the `for-all` macro, we use a small-integer generator
    to create a number of small integers. Our test passes when the number of coffee
    cups value created by the generator is multiplied by the price of the coffee.
    The result of this calculation should equal the result of running the `calculate-coffee-price`
    function. We intend to run the test 1,000 times. This is amazing that with three
    lines of code we were able to create 1,000 tests.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`defspec`宏允许你像标准`clojure.test`测试一样运行`test.check`测试。这允许我们将基于属性的测试与标准单元测试一起扩展到测试套件中。在`for-all`宏中，我们使用小整数生成器创建一系列小整数。当生成器创建的咖啡杯数乘以咖啡的价格时，我们的测试通过。这个计算的结果应该等于运行`calculate-coffee-price`函数的结果。我们打算运行这个测试1,000次。这真是太神奇了，我们只用了三行代码就能创建1,000个测试。'
- en: 'We can run `test.check` tests using Leiningen:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用Leiningen运行`test.check`测试：
- en: '[PRE66]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.24:Testing test.check using Leiningen'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.24：使用Leiningen测试test.check'
- en: '](img/B14502_10_24.jpg)'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_24.jpg)'
- en: '[PRE67]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our test failed. The original failing example `[-2]` (given at the `:fail`
    key) has been shrunk to `[-1]` (under `[:shrunk :smallest]`). The test failed
    because in the implementation of `calculate-coffee-price`, we return only absolute,
    non-negative values. The current implementation of `calculate-coffee-price` is
    as follows:'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的测试失败了。原始失败的例子`[-2]`（在`:fail`键中给出）已经被缩减到`[-1]`（在`[:shrunk :smallest]`下）。测试失败是因为在`calculate-coffee-price`的实现中，我们只返回绝对的非负值。当前`calculate-coffee-price`的实现如下：
- en: '[PRE68]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the last line, we have the `Math/abs` function call. `calculate-coffee-price`
    should return only absolute numbers. Yet in our tests we allowed negative numbers
    to be generated. We need to use a different generator to match the expected result
    from the `calculate-coffee-price` function.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后一行，我们有`Math/abs`函数调用。`calculate-coffee-price`应该只返回绝对数值。然而，在我们的测试中，我们允许生成负数。我们需要使用不同的生成器来匹配`calculate-coffee-price`函数的预期结果。
- en: '`test.check` provides a `nat` generator that can create natural numbers (non-negative
    integers).'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test.check`提供了一个`nat`生成器，可以创建自然数（非负整数）。'
- en: 'The test for `calculate-coffee-price` should be updated to the following:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`calculate-coffee-price`的测试应该更新为以下内容：'
- en: '[PRE69]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When we run tests with this generator, the tests pass:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们使用这个生成器运行测试时，测试通过了：
- en: '[PRE70]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output is as follows:'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.25: Using nat to create non-negative integers and running tests'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.25：使用nat创建非负整数并运行测试'
- en: '](img/B14502_10_25.jpg)'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_25.jpg)'
- en: 'Figure 10.25: Using nat to create non-negative integers and running tests'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.25：使用nat创建非负整数并运行测试
- en: We were able to test the `calculate-coffee-price` function 1,000 times. We generated
    an integer each time and used the integer as a number of cups. With `test.check`,
    we can truly check parameters against generated inputs. We have tested only the
    number of cups parameter. It is time to write generators and test all of the parameters.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们能够测试`calculate-coffee-price`函数1,000次。每次我们生成一个整数，并将其作为杯数。使用`test.check`，我们可以真正地检查参数与生成的输入是否匹配。我们只测试了杯数参数。现在是时候编写生成器并测试所有参数了。
- en: 'In order to generate all of the remaining parameters for the `calculate-coffee-price`
    function, we will use some new generators. The code for creating all parameters
    is as follows:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成`calculate-coffee-price`函数的所有剩余参数，我们将使用一些新的生成器。创建所有参数的代码如下：
- en: '[PRE71]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The coffee hash that stores the coffee menu contains information about the
    coffee type as a key and its value as a double:'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储咖啡菜单信息的咖啡哈希表包含有关咖啡类型的键和其值的双精度数：
- en: '[PRE72]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `gen/map` generator allows us to create a hash. In the hash, we want to
    generate a keyword as a key and a double for a value. We limit the value to be
    between 0.1 and 999\. We are only interested in numbers. We do not want to get
    an infinite value. With generators, we could create an infinite value if we wanted.
    We also do not want a NaN (not a number) to be generated. Lastly, our hash should
    have at least two elements – two tuples to be precise. Each tuple is a pair of
    a key and a value.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gen/map`生成器允许我们创建一个哈希表。在哈希表中，我们想要生成一个关键字作为键和一个双精度数作为值。我们将值限制在0.1到999之间。我们只对数字感兴趣。我们不想得到无限值。使用生成器，如果我们想的话，可以创建一个无限值。我们也不想生成NaN（不是一个数字）。最后，我们的哈希表应该至少有两个元素——确切地说，是两个元组。每个元组是一对键和值。'
- en: In the `let` block, we take the first tuple and assign it to `coffee-tuple`.
    This will help us to test and pass appropriate arguments to the `calculate-coffee-price`
    function.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`let`块中，我们取第一个元组并将其分配给`coffee-tuple`。这将帮助我们测试并传递适当的参数给`calculate-coffee-price`函数。
- en: 'We will run the tests again:'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将再次运行测试：
- en: '[PRE73]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.26: Running the tests after generating all parameters for the calculate-coffee-price
    function'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.26：生成`calculate-coffee-price`函数的所有参数后运行测试'
- en: '](img/B14502_10_26.jpg)'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_26.jpg)'
- en: 'Figure 10.26: Running the tests after generating all parameters for the calculate-coffee-price
    function'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26：生成`calculate-coffee-price`函数的所有参数后运行测试
- en: We see that both `test.check` tests pass. With a few lines of code, we were
    able to test 2,000 scenarios. This is amazing.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`test.check`测试都通过了。用几行代码，我们就能够测试2,000种场景。这真是太神奇了。
- en: So far, we have tested the `calculate-coffee-price` function. In the following
    activity, you will write tests for other functions from the coffee-ordering application.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经测试了 `calculate-coffee-price` 函数。在接下来的活动中，你将编写来自咖啡订购应用程序的其他函数的测试。
- en: 'Activity 10.01: Writing Tests for the Coffee-Ordering Application'
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.01：为咖啡订购应用程序编写测试
- en: In this activity, we will apply knowledge about unit testing to write a test
    suite. Many applications running in production are very complex. They have lots
    of features. Developers write unit tests in order to increase their trust in the
    application. The features coded should fulfill business needs. A well written
    and maintained test suite gives confidence to developers and people using such
    applications that the applications' features perform as expected.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将应用关于单元测试的知识来编写测试套件。许多在生产中运行的应用程序非常复杂。它们有很多功能。开发者编写单元测试是为了增加他们对应用程序的信任。编写的代码应该满足业务需求。一个编写良好且维护良好的测试套件会给开发者和使用此类应用程序的人带来信心，即应用程序的功能按预期执行。
- en: The coffee-ordering application that we wrote in the previous chapter allowed
    us to display the coffee menu and order some coffees. In this chapter, we have
    learned about unit testing libraries in Clojure by testing the `calculate-coffee-price`
    function. In the coffee-ordering application, there are still functions that have
    not been tested.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写的咖啡订购应用程序使我们能够显示咖啡菜单并订购一些咖啡。在本章中，我们通过测试 `calculate-coffee-price` 函数学习了Clojure中的单元测试库。在咖啡订购应用程序中，还有一些尚未测试的函数。
- en: 'In this activity, we will write unit tests for the following functions:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将为以下函数编写单元测试：
- en: '`display-order`: Displays information about the order'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display-order`: 显示关于顺序的信息'
- en: '`file-exist`: Checks whether a given file exists'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file-exist`: 检查指定的文件是否存在'
- en: '`save-coffee-order`: Saves the coffee order to a file'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save-coffee-order`: 将咖啡订单保存到文件'
- en: '`load-orders`: Loads coffee orders from a file'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load-orders`: 从文件中加载咖啡订单'
- en: 'These steps will help you complete the activity:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成活动：
- en: Import the testing namespace.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入测试命名空间。
- en: 'Create tests using the `clojure.test` library to display orders messages:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `clojure.test` 库创建测试以显示订单消息：
- en: Tests using `is` macro
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `is` 宏的测试
- en: Tests using `are` macro
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `are` 宏的测试
- en: Create tests using the `clojure.test` library to test if the file exists or
    if the file does not exist
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `clojure.test` 库创建测试以检查文件是否存在或文件不存在
- en: Create tests using the `clojure.test` library to save orders, load empty orders,
    load coffee orders.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `clojure.test` 库创建测试以保存订单、加载空订单、加载咖啡订单。
- en: Create tests using the `expectations` library to save data to file, save coffee
    orders, save coffee data, and load orders
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `expectations` 库创建测试以将数据保存到文件、保存咖啡订单、保存咖啡数据以及加载订单
- en: Create tests using the `expectations` library to check whether the file exists.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `expectations` 库创建测试以检查文件是否存在。
- en: Create tests using the `expectations` library to save and load orders.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `expectations` 库创建测试以保存和加载订单。
- en: Create tests using the `Midje` library to display the orders messages.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Midje` 库创建测试以显示订单消息。
- en: Create tests using the `Midje` library to check whether the file exists.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Midje` 库创建测试以检查文件是否存在。
- en: Create tests using the `Midje` library to load orders.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Midje` 库创建测试以加载订单。
- en: 'Create tests using `test.check` to display the orders messages:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `test.check` 创建测试以显示订单消息：
- en: Import the `test.check` namespace
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 `test.check` 命名空间
- en: Test the displayed orders
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试显示的订单
- en: Create tests using `test.check` to check whether the file exists.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `test.check` 创建测试来检查文件是否存在。
- en: Create tests using `test.check` to load orders.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `test.check` 创建测试以加载订单。
- en: 'The output of the `clojure.test` and `test.check` tests will look as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.test` 和 `test.check` 测试的输出将如下所示：'
- en: '![Figure 10.27: Expected output for the clojure.test and test.check tests'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.27：clojure.test和test.check测试的预期输出'
- en: '](img/B14502_10_27.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_10_27.jpg)'
- en: 'Figure 10.27: Expected output for the clojure.test and test.check tests'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27：clojure.test和test.check测试的预期输出
- en: 'The output of the `expectations` tests will look as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`expectations` 测试的输出将如下所示：'
- en: '![Figure 10.28: Expected output for the expectations test'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.28：expectations测试的预期输出'
- en: '](img/B14502_10_28.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_10_28.jpg)'
- en: 'Figure 10.28: Expected output for the expectations test'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28：expectations测试的预期输出
- en: 'The output of the `Midje` tests will look as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`Midje` 测试的输出将如下所示：'
- en: '![Figure 10.29: Output for the Midje tests'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.29：Midje测试的输出'
- en: '](img/B14502_10_29.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_10_29.jpg)'
- en: 'Figure 10.29: Output for the Midje tests'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29：Midje 测试的输出
- en: 'The output of the `test.check` tests will look as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.check` 测试的输出将如下所示：'
- en: '![Figure 10.30: Output for the test.check tests'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.30：`test.check` 测试的输出'
- en: '](img/B14502_10_30.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_10_30.jpg)'
- en: 'Figure 10.30: Output for the test.check tests'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30：`test.check` 测试的输出
- en: Note
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 723.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第723页找到。
- en: We now know how to write unit tests in Clojure using four libraries. In the
    next section, we will look at testing in ClojureScript.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何使用四个库在Clojure中编写单元测试。在下一节中，我们将探讨ClojureScript中的测试。
- en: Testing in ClojureScript
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClojureScript中的测试
- en: In Clojure, we used the `clojure.test` library for testing. In ClojureScript,
    we have a port of `clojure.test` in the form of `cljs.test`. In `cljs.test`, we
    have functionality that we used when we wrote tests using the `clojure.test` library.
    We can use the `is` and `are` macros to write our tests. `cljs.test` provides
    facilities for asynchronous testing. Asynchronous testing is a type of testing
    that tests asynchronous code. We will see shortly why it is important that `cljs.test`
    allows us to test asynchronous code.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，我们使用`clojure.test`库进行测试。在ClojureScript中，我们有`clojure.test`的端口，形式为`cljs.test`。在`cljs.test`中，我们具有使用`clojure.test`库编写测试时使用的功能。我们可以使用`is`和`are`宏来编写我们的测试。`cljs.test`提供了异步测试的设施。异步测试是一种测试异步代码的类型。我们将很快看到为什么`cljs.test`允许我们测试异步代码是如此重要。
- en: Synchronous code is what developers write most of the time, even without realizing
    this. In synchronous code, code is executed line by line. For example, the code
    defined in line 10 needs to finish executing before the code on line 11 can start
    executing. This is step-by-step execution. Asynchronous coding is a more advanced
    concept.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 同步代码是开发者大多数时候编写的内容，即使没有意识到这一点。在同步代码中，代码是逐行执行的。例如，第10行定义的代码需要完成执行，第11行的代码才能开始执行。这是逐步执行。异步编程是一个更高级的概念。
- en: In asynchronous programming, executing code and completing the execution of
    code cannot happen in a line-by-line fashion. For example, we could schedule downloading
    a song on line 10 and then on line 11 we could have code to let the user know
    that downloading has finished. In synchronous code, we would have to wait for
    the download to finish before we can show information to the user or perform some
    other actions. This is not what we would really want. We would like to inform
    the user about the progress as we download the song. In asynchronous code, we
    would schedule downloading a song and start showing the progress bar before the
    song is downloaded.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程中，执行代码和完成代码的执行不能按行进行。例如，我们可以在第10行安排下载一首歌曲，然后在第11行我们可以有代码让用户知道下载已完成。在同步代码中，我们必须等待下载完成，然后才能向用户显示信息或执行其他操作。这并不是我们真正想要的。我们希望在下载歌曲时通知用户进度。在异步代码中，我们会在歌曲下载之前安排下载歌曲并开始显示进度条。
- en: In Java and Clojure, we would use threads to write asynchronous code. A thread
    is a process on a JVM that consumes little computer resources. One thread would
    handle downloading a song and the other would display the progress bar.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和Clojure中，我们会使用线程来编写异步代码。线程是在JVM上消耗少量计算机资源的进程。一个线程会处理下载歌曲，另一个线程会显示进度条。
- en: As we learned in *Chapter 1*, *Hello REPL*, ClojureScript runs on top of JavaScript.
    JavaScript provides a single-thread environment. This is in contrast to Java,
    which allows creating many threads. Writing code for one thread is simpler as
    we do not need to coordinate resource-sharing between many threads. ClojureScript
    applications requiring asynchronous code need to use some other facilities than
    threads.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*第1章*，*Hello REPL*中学到的，ClojureScript在JavaScript之上运行。JavaScript提供了一个单线程环境。这与允许创建许多线程的Java形成对比。为单个线程编写代码更简单，因为我们不需要在许多线程之间协调资源共享。需要异步代码的ClojureScript应用程序需要使用一些其他设施而不是线程。
- en: JavaScript provides callbacks to manage writing asynchronous code. Callbacks
    are functions that we define to be run once certain conditions are met. In our
    downloading example, a callback would let us know when downloading is finished
    so we can inform the user.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了回调来管理异步代码的编写。回调是我们定义的，在满足某些条件时运行的函数。在我们的下载示例中，回调会让我们知道下载何时完成，这样我们就可以通知用户。
- en: 'ClojureScript provides the `core.async` library for working with asynchronous
    code. The `core.async` library has a number of functions and macros:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ClojureScript 提供了 `core.async` 库来处理异步代码。`core.async` 库有许多函数和宏：
- en: '`go`: Creates a block that marks the code as asynchronous. The result from
    the block is put on a channel.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go`：创建一个标记代码为异步的块。块的结果被放置在通道上。'
- en: '`<!`: Takes a value from a channel.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<!`：从一个通道中获取一个值。'
- en: Why do we need a go block and channels?
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要一个 go 块和通道？
- en: Asynchronous code is by definition asynchronous. We do not know when we will
    get a return value from an asynchronous call. When we use channels for asynchronous
    calls, our code becomes simpler. This happens because return values are put on
    a channel. We do not need to manage this channel. `core.async` does this management
    for us. When we are ready, we just take value from this channel. Without explicit
    channel management, our code is shorter as the code can focus on simpler tasks
    that we program.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码按定义是异步的。我们不知道何时会从异步调用中获得返回值。当我们使用通道进行异步调用时，我们的代码变得更简单。这是因为返回值被放置在通道上。我们不需要管理这个通道。`core.async`
    为我们管理这个通道。当我们准备好时，我们只需从这个通道中获取值。没有显式的通道管理，我们的代码更短，因为代码可以专注于更简单的任务，这些任务是我们编写的。
- en: In the following exercise, we will see how to set up and use testing libraries
    in ClojureScript.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将看到如何在 ClojureScript 中设置和使用测试库。
- en: 'Exercise 10.05: Setting Up Testing in ClojureScript'
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.05：在 ClojureScript 中设置测试
- en: The aim of this exercise is to learn how to set up testing libraries in ClojureScript
    and how to use those libraries. We will use `cljs.test` for testing.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目的是学习如何在 ClojureScript 中设置测试库以及如何使用这些库。我们将使用 `cljs.test` 进行测试。
- en: In this exercise, we will create a number of folders and files. There are many
    ways to create folders and files. Readers are welcome to use any methods they
    are most comfortable with. The following steps will use the command line.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建多个文件夹和文件。有许多创建文件夹和文件的方法。读者可以自由选择他们最舒适的方法。以下步骤将使用命令行。
- en: '![Figure 10.31: Command and it''s description'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.31：命令及其描述](img/B14502_10_31.jpg)'
- en: '](img/B14502_10_31.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B14502_10_31](img/B14502_10_31.jpg)'
- en: 'Figure 10.31: Command and it''s description'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.31：命令及其描述
- en: 'Create a project named `hello-test`, as follows:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `hello-test` 的项目，如下所示：
- en: '[PRE74]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This will create a project where we will keep our code. Once we finish setting
    up, the project structure should look like the following screenshot. We can see
    the project structure using the `tree` command or your preferred way to check
    directories:'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个项目，我们将在此项目中保存我们的代码。一旦我们完成设置，项目结构应如下所示。我们可以使用 `tree` 命令或您喜欢的任何方式来检查目录：
- en: '[PRE75]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output is as follows:'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.32: Project structure'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.32：项目结构](img/B14502_10_32.jpg)'
- en: '](img/B14502_10_32.jpg)'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 B14502_10_32](img/B14502_10_32.jpg)'
- en: 'Figure 10.32: Project structure'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.32：项目结构
- en: 'Inside the source folder, we will keep our code:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件夹中，我们将保存我们的代码：
- en: '[PRE76]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Executing this command will create the `src` and `hello_test` folders.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此命令将创建 `src` 和 `hello_test` 文件夹。
- en: 'Create a source file. In the source file, we will keep our code:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个源文件。在源文件中，我们将保存我们的代码：
- en: '[PRE77]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This command creates an empty core file.
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令创建一个空的核心文件。
- en: 'Create a core namespace. Inside the `core.cljs` file, add a namespace:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个核心命名空间。在 `core.cljs` 文件中，添加一个命名空间：
- en: '[PRE78]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Inside the `core.cljs` file, put a function for adding numbers:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `core.cljs` 文件中，放置一个用于加法运算的函数：
- en: '[PRE79]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Create a testing folder.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试文件夹。
- en: 'We will create a folder for our testing files:'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将为我们的测试文件创建一个文件夹：
- en: '[PRE80]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This command will create the `test` and `hello_test` folders.
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将创建 `test` 和 `hello_test` 文件夹。
- en: Create the configuration.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建配置。
- en: 'We will keep the project configuration in the `project.clj` file. The file
    should look like the following:'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在 `project.clj` 文件中保存项目配置。该文件应如下所示：
- en: '[PRE81]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This is a standard `project.clj` file like we created in *Chapter 8*, *Namespaces,
    Libraries and Leiningen*. Inside the project.clj file, we have the `:dependencies`
    key where we put the libraries that we need for testing.
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个标准的 `project.clj` 文件，就像我们在 *第 8 章*，*命名空间、库和 Leiningen* 中创建的那样。在 `project.clj`
    文件中，我们有 `:dependencies` 键，我们将在此键中放置我们需要的用于测试的库。
- en: The `cljs-http` library will allow us to make HTTP calls. We will use `GET`
    requests to make asynchronous calls that will be tested.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cljs-http` 库将允许我们进行 HTTP 调用。我们将使用 `GET` 请求来执行将被测试的异步调用。'
- en: 'The `cuerdas` library has many string utility functions. Some of the functions
    are as follows:'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cuerdas` 库有许多字符串实用函数。以下是一些函数：'
- en: '`capital`: Uppercases the first character of a string. The string "john" becomes
    "John".'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`capital`：将字符串的第一个字符转换为大写。字符串"john"变为"John"。'
- en: '`Clean`: Trims and replaces multiple spaces with a single space. The string
    " a b " becomes "a b."'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Clean`：删除并替换多个空格为单个空格。字符串" a b "变为"a b"。'
- en: '`Human`: Converts a string or keyword into a human-friendly string (lowercase
    and spaces). The string "DifficultToRead" becomes "difficult to read."'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Human`：将字符串或关键字转换为人类友好的字符串（小写和空格）。字符串"DifficultToRead"变为"difficult to read"。'
- en: '`Reverse`: Returns a reverted string. The string "`john`" becomes "`nhoj`."'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Reverse`：返回一个反转的字符串。字符串"`john`"变为"`nhoj`"。'
- en: We will write unit tests manipulating strings.
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将编写操作字符串的单元测试。
- en: 'Add a test plugin dependency. We will use the `lein-doo` plugin to run ClojureScript
    tests. Add the following line in `project.clj`:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加测试插件依赖。我们将使用`lein-doo`插件来运行ClojureScript测试。在`project.clj`文件中添加以下行：
- en: '[PRE82]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `lein-doo` plugin will be used to run ClojureScript tests. This plugin will
    autorun tests and display test results. We will run `lein-doo` against a web browser
    environment. `lein-doo` relies on the JavaScript `Karma` library to run tests
    in a JavaScript environment. Karma is a JavaScript tool that helps to run JavaScript
    tests. We need to install the necessary dependencies for `Karma`.
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`lein-doo`插件将被用来运行ClojureScript测试。这个插件将自动运行测试并显示测试结果。我们将对Web浏览器环境运行`lein-doo`。`lein-doo`依赖于JavaScript的`Karma`库在JavaScript环境中运行测试。Karma是一个帮助运行JavaScript测试的JavaScript工具。我们需要安装`Karma`的必要依赖。'
- en: Install Karma. Karma is distributed using `npm` is an equivalent of Maven that
    we learned about in *Chapter 8*, *Namespaces, Libraries, and Leiningen*. Basically,
    it is a repository of projects. While Maven hosts Java projects, npm hosts JavaScript
    projects.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Karma。Karma使用`npm`相当于我们在第8章中学习的Maven。基本上，它是一个项目仓库。虽然Maven托管Java项目，但npm托管JavaScript项目。
- en: 'We will use npm to install Karma:'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用npm来安装Karma：
- en: '[PRE83]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: With the `-save-dev` flag, we install the `karma` packages in the current directory.
    The purpose of using the `-save-dev` flag is to allow us to separate different
    test configurations between projects. One legacy project could still rely on an
    old version of Karma while a new project could use a newer version of Karma.
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`-save-dev`标志，我们在当前目录中安装`karma`包。使用`-save-dev`标志的目的是允许我们在项目之间分离不同的测试配置。一个遗留项目可能仍然依赖于Karma的旧版本，而新项目可以使用Karma的新版本。
- en: 'We will install the Chrome Karama launcher. Our tests will be run (launched)
    in the Chrome browser:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将安装Chrome Karama启动器。我们的测试将在Chrome浏览器中运行（启动）：
- en: '[PRE84]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding command searches `npm` for `karma-chrome-launcher` projects. When
    `npm` finds this project, it will download the Chrome launcher and install it.
    With the -`save-dev` flag, we install the karma-chrome-launcher in the current
    directory.
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的命令在`npm`中搜索`karma-chrome-launcher`项目。当`npm`找到这个项目时，它将下载Chrome启动器并安装它。使用`-save-dev`标志，我们在当前目录中安装`karma-chrome-launcher`。
- en: Install the Karma command-line tool.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Karma命令行工具。
- en: 'The final step to install the Karma libraries is to install command-line tools
    that allow executing Karma commands:'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装Karma库的最终步骤是安装允许执行Karma命令的命令行工具：
- en: '[PRE85]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We install Karma command-line tools globally as the ClojureScript plugin running
    the tests needs to access Karma commands.
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将全局安装Karma命令行工具，因为运行测试的ClojureScript插件需要访问Karma命令。
- en: 'We need to set the build configuration for the test task in the `project.clj`
    file:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`project.clj`文件中设置测试任务的构建配置：
- en: '[PRE86]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ClojureScript build configurations are set under the `:cljsbuild` key in the
    project.clj file. We specify one `:browser-test` build. This build will access
    files from the `src` and `test` directories. The code will be compiled to the
    `out` directory to the `tests.js` file. The `:main` entry point for tests is the
    `hello-test.runner` namespace. For testing, we do not need any optimizations for
    compilation so we set the optimizations parameter to `:none`.
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ClojureScript构建配置在`project.clj`文件中的`:cljsbuild`键下设置。我们指定一个`:browser-test`构建。此构建将访问`src`和`test`目录中的文件。代码将被编译到`out`目录下的`tests.js`文件。测试的`:main`入口点是`hello-test.runner`命名空间。对于测试，我们不需要任何编译优化，因此我们将优化参数设置为`:none`。
- en: 'Create a core test file:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建核心测试文件：
- en: '[PRE87]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This command creates the `core_test.cljs` file.
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令创建`core_test.cljs`文件。
- en: Import the testing namespaces.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入测试命名空间。
- en: 'The `core_test.cljs` file will contain the tests. We need to import the necessary
    namespaces:'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`core_test.cljs`文件将包含测试。我们需要导入必要的命名空间：'
- en: '[PRE88]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We import the testing macros from the `cljs.test` namespace. We will use them
    for testing our code. We also import the namespace from the `test.check` namespace.
    We will write property-based tests for our functions. The `cuerdas` namespace
    will be used to manipulate strings. Finally, we import test functions from the
    `hello-test.core` namespace.
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从 `cljs.test` 命名空间导入测试宏。我们将使用它们来测试我们的代码。我们还从 `test.check` 命名空间导入命名空间。我们将为我们的函数编写基于属性的测试。`cuerdas`
    命名空间将用于操作字符串。最后，我们从 `hello-test.core` 命名空间导入测试函数。
- en: Create a test runner.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试运行器。
- en: 'A test runner is a file that runs all the tests. We will test our code using
    the browser engine from Karma:'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试运行器是一个运行所有测试的文件。我们将使用 Karma 的浏览器引擎来测试我们的代码：
- en: '[PRE89]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Import the namespaces for the test runner.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入测试运行器的命名空间。
- en: 'Inside `hello_test.runnerfile`, we import the core testing namespace and the
    `lein-doo` namespace:'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `hello_test.runnerfile` 中，我们导入核心测试命名空间和 `lein-doo` 命名空间：
- en: '[PRE90]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We let `lein-doo` know that it needs to run tests from the `hello-test.core-test`
    namespace.
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们让 `lein-doo` 知道它需要从 `hello-test.core-test` 命名空间运行测试。
- en: 'Once we install Karma and create all the files, the project structure should
    look like this:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装 Karma 并创建所有文件，项目结构应该如下所示：
- en: '[PRE91]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output is as follows:'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.33: Project structure after installing Karma and creating all the
    files'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.33：安装 Karma 并创建所有文件后的项目结构]'
- en: '](img/B14502_10_33.jpg)'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_33.jpg]'
- en: 'Figure 10.33: Project structure after installing Karma and creating all the
    files'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.33：安装 Karma 并创建所有文件后的项目结构
- en: We are ready to launch the test runner.
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们准备好启动测试运行器。
- en: 'Launch the test runner:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动测试运行器：
- en: '[PRE92]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We call the `lein doo` plugin to run tests using the Chrome browser. Remember
    that JavaScript is a language that runs in browsers.
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们调用 `lein doo` 插件，使用 Chrome 浏览器运行测试。请记住，JavaScript 是一种在浏览器中运行的编程语言。
- en: '![Figure 10.34: Launching the test runners'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.34：启动测试运行器]'
- en: '](img/B14502_10_34.jpg)'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_34.jpg]'
- en: 'Figure 10.34: Launching the test runners'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.34：启动测试运行器
- en: The `lein doo` plugin launched a Karma server for us. The server is watching
    the source and test directories for us. When we make changes in our ClojureScript
    files, the tests will run against our code.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`lein doo` 插件为我们启动了一个 Karma 服务器。服务器正在监视源代码和测试目录。当我们对 ClojureScript 文件进行更改时，测试将针对我们的代码运行。'
- en: In this exercise, we learned how to set up testing in ClojureScript. In the
    next exercise, we will learn how to write ClojureScript tests.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何在 ClojureScript 中设置测试。在下一个练习中，我们将学习如何编写 ClojureScript 测试。
- en: 'Exercise 10.06: Testing ClojureScript Code'
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.06：测试 ClojureScript 代码
- en: In the previous exercise, we configured a project for ClojureScript testing.
    In this exercise, we will write ClojureScript tests. We will use functions from
    the `cuerdas` library that allow us to manipulate strings. We will also test the
    asynchronous ClojureScript code.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们为 ClojureScript 测试配置了一个项目。在这个练习中，我们将编写 ClojureScript 测试。我们将使用来自 `cuerdas`
    库的函数来操作字符串。我们还将测试异步的 ClojureScript 代码。
- en: 'We will implement and test three functions:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现并测试三个函数：
- en: '`profanity-filter`: It is common to filter certain words in chat applications
    or web forums. A profanity filter will remove words that we consider inappropriate.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`profanity-filter`：在聊天应用或网络论坛中过滤某些单词是很常见的。粗口过滤器将移除我们认为不恰当的单词。'
- en: '`prefix-remover`: This function will use string functions and will remove prefixes
    from words.'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefix-remover`：这个函数将使用字符串函数并从单词中移除前缀。'
- en: '`http-caller`: This function will make a HTTP call to a web address. This will
    help us test asynchronous code.'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http-caller`：这个函数将对一个网址进行 HTTP 调用。这将帮助我们测试异步代码。'
- en: Import namespaces for the core file.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入核心文件的命名空间。
- en: 'Inside the `core.cljs` file, add the necessary namespaces:'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `core.cljs` 文件中，添加必要的命名空间：
- en: '[PRE93]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We import the `cuerdas` namespace for string manipulation.
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们导入用于字符串操作的 `cuerdas` 命名空间。
- en: 'Create a profanity filter. The first function that we will write in the `hello_test.core.cljs`
    file is a profanity filter:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个粗口过滤器。在 `hello_test.core.cljs` 文件中，我们将编写的第一个函数是一个粗口过滤器：
- en: '[PRE94]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this function, we test whether a passed string contains the word `bad`. If
    it does, we replace it with the word `great`.
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，我们测试传入的字符串是否包含单词 `bad`。如果包含，我们将它替换为单词 `great`。
- en: Import the test namespaces.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入测试命名空间。
- en: 'Inside the `hello_test.core_test.cljs` file, import the necessary test namespaces:'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `hello_test.core_test.cljs` 文件中，导入必要的测试命名空间：
- en: '[PRE95]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Write a test for the `profanity-filter` functions.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `profanity-filter` 函数的测试。
- en: 'Inside the `hello_test.core_test.cljs` file, add a test for the profanity filter
    function:'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`hello_test.core_test.cljs`文件中，为粗口过滤器函数添加一个测试：
- en: '[PRE96]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The tests look similar to the ones we wrote using the `clojure.test` library.
    We use `is` and `are` macros to set testing scenarios. We are ready to run the
    tests.
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试看起来与我们使用`clojure.test`库编写的测试类似。我们使用`is`和`are`宏来设置测试场景。我们已经准备好运行测试。
- en: 'In order to run the tests, we call the `lein doo` task from the command line.
    If you have a `lein doo` running from the previous exercise, it will watch file
    changes and run the tests for us:![Figure 10.35: Calling the lein doo task from
    the command line'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行测试，我们从命令行调用`lein doo`任务。如果你在之前的练习中有一个正在运行的`lein doo`，它将监视文件变化并为我们运行测试：![图10.35：从命令行调用lein
    doo任务
- en: '](img/B14502_10_35.jpg)'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_35.jpg)'
- en: 'Figure 10.35: Calling the lein doo task from the command line'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.35：从命令行调用lein doo任务
- en: The profanity filter test was run. The output informs us that one test was successful.
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 粗口过滤器测试已运行。输出告诉我们有一个测试成功执行。
- en: 'If you do not have `lein doo` running, you need to start `lein doo`:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有运行`lein doo`，你需要启动`lein doo`：
- en: '[PRE97]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Starting the `lein doo` task will start watching our ClojureScript files for
    changes:'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动`lein doo`任务将开始监视我们的ClojureScript文件变化：
- en: '![Figure 10.36: Starting the lein doo task'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.36：启动lein doo任务'
- en: '](img/B14502_10_36.jpg)'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_36.jpg)'
- en: 'Figure 10.36: Starting the lein doo task'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.36：启动lein doo任务
- en: Once the `lein doo` is watching the changes in our file, we are ready. We are
    informed that the `karma` server has been started. The autorunner is watching
    for changes in the `src` and `test` directories. Any changes in these directories
    will result in `lein doo` running the tests again.
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦`lein doo`开始监视我们的文件变化，我们就可以开始了。我们被告知`karma`服务器已经启动。自动运行器正在监视`src`和`test`目录中的变化。这些目录中的任何变化都将导致`lein
    doo`再次运行测试。
- en: 'Go to `hello_test.core_test.cljs`, save the file, and watch the tests being
    executed:'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往`hello_test.core_test.cljs`文件，保存文件，并观察测试的执行过程：
- en: '![Figure 10.37: Executing the tests'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.37：执行测试'
- en: '](img/B14502_10_37.jpg)'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_37.jpg)'
- en: 'Figure 10.37: Executing the tests'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.37：执行测试
- en: We are informed that one test has been successfully executed.
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们被告知有一个测试已成功执行。
- en: 'The autorunner will let us know if our tests fail. If we add the following
    test, the autorunner informs us that one test failed:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动运行器会告诉我们测试是否失败。如果我们添加以下测试，自动运行器会告诉我们有一个测试失败了：
- en: '[PRE98]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The test fails as follows:'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试失败如下：
- en: '![Figure 10.38: The autorunner informs us when a test fails'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.38：自动运行器在测试失败时通知我们'
- en: '](img/B14502_10_38.jpg)'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_38.jpg)'
- en: '[PRE99]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In the test, we pass the lowercase string "`katy`" to the capitalize function
    from the `cuerdas` library. The `capitalize` function will uppercase the first
    letter, "k," and return a new string, "`Katy`". This new string is compared to
    the string `Katy` in a test.
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试中，我们将小写字符串"`katy`"传递给`cuerdas`库中的`capitalize`函数。`capitalize`函数将首字母大写，"k"，并返回一个新的字符串，"`Katy`"。这个新字符串与测试中的字符串`Katy`进行比较。
- en: As both strings, `Katy` and `Katy`, are equal, the tests will pass.
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于两个字符串`Katy`和`Katy`相等，测试将通过。
- en: 'The autorunner tells us that all of the tests passed now:'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动运行器告诉我们现在所有的测试都通过了：
- en: '![Figure 10.39: All of the tests passed after we fixed the string case'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.39：修复字符串大小写后所有测试通过'
- en: '](img/B14502_10_39.jpg)'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_39.jpg)'
- en: 'Figure 10.39: All of the tests passed after we fixed the string case'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.39：修复字符串大小写后所有测试通过
- en: 'We can check for errors being thrown by our code:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查我们的代码抛出的错误：
- en: '[PRE100]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In the preceding code, we wanted to insert an apple in the fourth index, which
    does not exist as we have only three elements. Remember that, in Clojure, the
    first index is zero so the third element in a list has an index of two. Trying
    to add an element at index 4 generates an error in ClojureScript. In our test,
    we caught this error:'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们想要在第四个索引处插入一个苹果，但因为我们只有三个元素，所以这个索引不存在。记住，在Clojure中，第一个索引是0，所以列表中的第三个元素的索引是2。尝试在索引4处添加一个元素会在ClojureScript中生成一个错误。在我们的测试中，我们捕获了这个错误：
- en: '![Figure 10.40: The third test passes because we caught the error in our code'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.40：第三次测试通过，因为我们捕获了代码中的错误'
- en: '](img/B14502_10_40.jpg)'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_40.jpg)'
- en: 'Figure 10.40: The third test passes because we caught the error in our code'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.40：第三次测试通过，因为我们捕获了代码中的错误
- en: The autorunner tests our code and the third test passed.
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动运行测试测试我们的代码，第三次测试通过。
- en: 'In ClojureScript, we can make requests to websites. These requests are asynchronous.
    We will import ClojureScript namespaces that help us to make asynchronous calls:'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ClojureScript中，我们可以向网站发起请求。这些请求是异步的。我们将导入帮助我们进行异步调用的ClojureScript命名空间：
- en: '[PRE101]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `cljs-http.client` namespace will allow us to make HTTP calls. Functions
    from the `core.async` namespace will manage asynchronous calls for us.
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cljs-http.client`命名空间将允许我们进行HTTP调用。来自`core.async`命名空间的函数将为我们管理异步调用。'
- en: 'Our HTTP function will take three arguments, a website address, HTTP parameters,
    and a callback function to call after we finish sending the request to the website
    address:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的HTTP函数将接受三个参数，一个网站地址、HTTP参数以及一个在向网站地址发送请求后调用的回调函数：
- en: '[PRE102]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We have our function making asynchronous calls. We need to import this function:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有进行异步调用的函数。我们需要导入这个函数：
- en: '[PRE103]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'HTTP calls happen asynchronously in ClojureScript. A `GET` request will run
    a callback function when the request finishes. This is ideal for testing asynchronous
    code:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ClojureScript中，HTTP调用是异步发生的。一个`GET`请求会在请求完成后运行回调函数。这对于测试异步代码来说是非常理想的：
- en: '[PRE104]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `async` macro allows us to write an asynchronous block of code for testing.
    In our block, we make a GET request to GitHub API to access the list of current
    public users. The `http-get` function takes a callback function as the last parameter.
    In the callback, we check the response. A successful response will have the status
    `200`.
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`async`宏允许我们为测试编写异步代码块。在我们的代码块中，我们向GitHub API发起GET请求以访问当前公开用户列表。`http-get`函数将回调函数作为最后一个参数。在回调中，我们检查响应。成功的响应将具有状态`200`。'
- en: 'The final function call in the callback is `done`. `done` is a function that
    is invoked when we are ready to relinquish control and allow the next test to
    run:'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回调中的最后一个函数调用是`done`。`done`是一个在我们准备好放弃控制并允许下一个测试运行时被调用的函数：
- en: '![Figure 10.41: The fourth test is passed'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.41：第四次测试通过]'
- en: '](img/B14502_10_41.jpg)'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_41.jpg]'
- en: 'Figure 10.41: The fourth test is passed'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.41：第四次测试通过
- en: Our request was successful and the fourth test passed.
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的请求成功了，第四次测试通过了。
- en: 'Import the namespaces for property-based testing. ClojureScript allows us to
    use property-based testing to check our functions:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入用于基于属性的测试的命名空间。ClojureScript允许我们使用基于属性的测试来检查我们的函数：
- en: '[PRE105]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We already know about generators and the properties used for property-based
    testing. With generators, we can create various types of function inputs such
    as numbers or strings. Properties allow us to describe the characteristics of
    the inputs.
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经了解了生成器和用于基于属性的测试的属性。使用生成器，我们可以创建各种类型的函数输入，如数字或字符串。属性允许我们描述输入的特性。
- en: The `defspec` macro allows us to write tests that can be run with the `clsj.test`
    library.
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`defspec`宏允许我们编写可以用`clsj.test`库运行的测试。'
- en: 'With property-based tests, we can check 1,000 scenarios against our profanity
    filter. The structure of property-based tests in ClojureScript is the same as
    in Clojure:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于属性的测试，我们可以检查1,000种场景与我们的粗话过滤器。在ClojureScript中，基于属性的测试结构与Clojure中的结构相同：
- en: '[PRE106]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'With the `for-all` macro, we specify what properties our function parameters
    should have. For the profanity filter, we generate ASCII strings. ASCII, abbreviated
    from American Standard Code for Information Interchange, is a character encoding
    standard for electronic communication:'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`for-all`宏，我们指定函数参数应该具有哪些属性。对于粗话过滤器，我们生成ASCII字符串。ASCII是从美国信息交换标准代码（American
    Standard Code for Information Interchange）缩写而来，是一种电子通信的字符编码标准：
- en: '![Figure 10.42: The fifth test is passed'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.42：第五次测试通过]'
- en: '](img/B14502_10_42.jpg)'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_42.jpg]'
- en: 'Figure 10.42: The fifth test is passed'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.42：第五次测试通过
- en: Our fifth test passed. Furthermore, the `test.check` informed us that 1,000
    test scenarios were executed.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第五次测试通过了。此外，`test.check`告诉我们执行了1,000个测试场景。
- en: In this exercise, we have seen how to set up testing in ClojureScript. We wrote
    functions and tested them using the `cljs.test` and `test.check` libraries. In
    the next section, we will see how to integrate tests with existing projects.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何在ClojureScript中设置测试。我们编写了函数，并使用`cljs.test`和`test.check`库来测试它们。在下一节中，我们将看到如何将测试集成到现有项目中。
- en: Testing ClojureScript Applications with Figwheel
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Figwheel测试ClojureScript应用程序
- en: In *Chapter 9*, *Host Platform Interoperability with Java and JavaScript*, we
    learned about Figwheel. Figwheel allows us to create ClojureScript applications.
    Most developers use Figwheel because it provides hot-code reloading. It means
    that any changes in our code are recompiled and the application running in the
    web browser is updated.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 9 章*，*Java 和 JavaScript 与宿主平台互操作性* 中，我们学习了 Figwheel。Figwheel 允许我们创建 ClojureScript
    应用程序。大多数开发者使用 Figwheel，因为它提供了热代码重新加载功能。这意味着我们代码中的任何更改都会被重新编译，并且运行在网页浏览器中的应用程序会得到更新。
- en: In the previous exercise, we learned how to add testing to a ClojureScript project.
    Figwheel comes with a testing configuration. Any Figwheel application is ready
    to add tests to after creating the application. Because the testing configuration
    is included in each project, developers save time. Developers do not need to install
    external tools or create the configuration; they can start writing tests straight
    away.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们学习了如何向 ClojureScript 项目添加测试。Figwheel 内置了测试配置。创建应用程序后，任何 Figwheel 应用程序都可以添加测试。因为测试配置包含在每个项目中，开发者可以节省时间。开发者不需要安装外部工具或创建配置；他们可以直接开始编写测试。
- en: 'In *Chapter 9*, *Host Platform Interoperability with Java and JavaScript*,
    we talked about Figwheel projects in detail. As a reminder, in Figwheel, we use
    two concepts:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 9 章*，*Java 和 JavaScript 与宿主平台互操作性* 中，我们详细讨论了 Figwheel 项目。作为提醒，在 Figwheel
    中，我们使用两个概念：
- en: Reactive components
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式组件
- en: Application state management
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用状态管理
- en: For reactive components – HTML elements that react to user actions – we will
    use the Rum library. The state of the application will be kept inside an atom.
    Concurrency is a topic covered in *Chapter 12*, *Concurrency*. For our purposes,
    an atom is a data structure like a collection. We learned about collections in
    *Chapter 1*, *Hello REPL!*. The main difference between collections and atoms
    is that we can alter the value of an atom, while collections are immutable.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应式组件——对用户操作做出反应的 HTML 元素——我们将使用 Rum 库。应用程序的状态将保存在一个原子中。并发是 *第 12 章*，*并发*
    中讨论的主题。就我们的目的而言，原子是一种类似于集合的数据结构。我们在 *第 1 章*，*Hello REPL!* 中学习了集合。集合和原子之间的主要区别是我们可以更改原子的值，而集合是不可变的。
- en: 'Exercise 10.07: Tests in Figwheel Applications'
  id: totrans-646
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.07：Figwheel 应用程序中的测试
- en: In the previous section, we learned that Figwheel supports testing ClojureScript
    applications. We revised the benefits of using Figwheel to create ClojureScript
    applications. We also reminded ourselves about important concepts in Figwheel
    applications, such as reactive components and application state management.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个部分，我们学习了 Figwheel 支持测试 ClojureScript 应用程序。我们回顾了使用 Figwheel 创建 ClojureScript
    应用程序的好处。我们还提醒了自己在 Figwheel 应用程序中的重要概念，例如响应式组件和应用状态管理。
- en: In this exercise, we will investigate how Figwheel configures projects to support
    testing in ClojureScript. Figwheel aims to support developers creating applications.
    Figwheel sets up default testing configuration for us. In *Exercise 10.5*, *Setting
    Up Testing in ClojureScript*, we saw how much setup is needed to configure testing
    in ClojureScript. With Figwheel, we do not need to write this configuration; we
    can focus on writing our code.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将调查 Figwheel 如何配置项目以支持 ClojureScript 中的测试。Figwheel 旨在支持开发者创建应用程序。Figwheel
    为我们设置了默认的测试配置。在 *练习 10.5*，*在 ClojureScript 中设置测试* 中，我们看到了配置 ClojureScript 中的测试需要多少设置。使用
    Figwheel，我们不需要编写此配置；我们可以专注于编写我们的代码。
- en: 'In order to write tests in Figwheel, we need to understand how Figwheel sets
    up the default testing configuration:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Figwheel 中编写测试，我们需要了解 Figwheel 如何设置默认的测试配置：
- en: 'Create a Figwheel application:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Figwheel 应用程序：
- en: '[PRE107]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We created a new Figwheel project using Rum.
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 Rum 创建了一个新的 Figwheel 项目。
- en: Test the configuration in the project.clj file.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 `project.clj` 文件中的配置。
- en: 'Figwheel puts some testing configuration in the `project.clj` file:'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figwheel 在 `project.clj` 文件中放置了一些测试配置：
- en: '[PRE108]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Inside the `project.clj` file, Figwheel defines aliases to help run tasks on
    the command line. An alias is a shortcut for commands that we use often. Using
    aliases saves developers typing. Figwheel defines the `fig:test` task.
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `project.clj` 文件中，Figwheel 定义了别名以帮助在命令行上运行任务。别名是我们经常使用的命令的快捷方式。使用别名可以节省开发者输入。Figwheel
    定义了 `fig:test` 任务。
- en: 'This task runs on a command line with a number of parameters:'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此任务在命令行上运行，并带有多个参数：
- en: '`-m`: Search a file for the main function. Remember from *Chapter 8*, *Namespaces,
    Libraries, and Leiningen*, that the main function in Leiningen projects is an
    entry point in an application. We start applications in main functions.'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-m`：在文件中搜索主函数。记得在 *第 8 章*，*命名空间、库和 Leiningen* 中，Leiningen 项目的 `main` 函数是应用程序的入口点。我们在
    `main` 函数中启动应用程序。'
- en: '`-co`: Load options from a given file.'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-co`：从给定的文件中加载选项。'
- en: 'Test the configuration in the `test.cljs.edn` file. Inside the `test.cljs.edn`
    file, we have the testing configuration:'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 `test.cljs.edn` 文件中的配置。在 `test.cljs.edn` 文件中，我们有测试配置：
- en: '[PRE109]'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: When the Figwheel application is run, it launches a web page. Figwheel provides
    two web pages. There is one web page for the actual application that we are developing.
    Also, there is a different web page for testing.
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 Figwheel 应用程序运行时，它会启动一个网页。Figwheel 提供了两个网页。有一个网页用于我们正在开发的实际应用程序。还有一个不同的网页用于测试。
- en: Figwheel also provides a main method inside the `test-app.test-runner` namespace.
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figwheel 还在 `test-app.test-runner` 命名空间中提供了一个主方法。
- en: 'Test the runner namespace. Inside the `test/test_app/test_runner.cljs` file,
    we have code for running ClojureScript tests:'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试运行器命名空间。在 `test/test_app/test_runner.cljs` 文件中，我们有运行 ClojureScript 测试的代码：
- en: '[PRE110]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: First, in the file, we require the namespaces that we want to test. Initially,
    the only namespace to test is a `test-app.core-test` namespace created by default
    by Leiningen. If we add more files for testing, we need to import namespaces in
    those files. The second namespace that is required is a Figwheel namespace with
    a utility function.
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，在文件中，我们引入了我们想要测试的命名空间。最初，要测试的唯一命名空间是由 Leiningen 默认创建的 `test-app.core-test`
    命名空间。如果我们为测试添加更多文件，我们需要在这些文件中导入命名空间。第二个需要的命名空间是一个包含实用函数的 Figwheel 命名空间。
- en: Second, we have the `-main` function. This function is called by Leiningen to
    run tests. Figwheel provides a `run-tests-async` function. This means that tests
    are run in an asynchronous manner. This allows the tests to run faster than if
    run in a synchronous manner. They run faster because the tests do not need to
    wait for other tests to finish before they can be started.
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二，我们有 `-main` 函数。这个函数由 Leiningen 调用来运行测试。Figwheel 提供了一个 `run-tests-async` 函数。这意味着测试以异步方式运行。这意味着测试可以比同步方式运行得更快。它们运行得更快，因为测试不需要等待其他测试完成才能开始。
- en: 'Inside the `test/test_app/core_test.cljs` file, we have autogenerated tests
    by Figwheel:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test/test_app/core_test.cljs` 文件中，我们有 Figwheel 自动生成的测试：
- en: '[PRE111]'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Figwheel first requires the `cljs.test` namespace with macros that we are familiar
    with. The tests will use macros such as `deftest`, `is`, and `testing`.
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figwheel 首先需要我们熟悉的 `cljs.test` 命名空间及其宏。测试将使用 `deftest`、`is` 和 `testing` 等宏。
- en: The second namespace required is the `test-app.core` namespace. This namespace,
    from the source directory, contains the implementation for a `multiply` function.
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要的第二个命名空间是 `test-app.core` 命名空间。这个命名空间，从源目录开始，包含了 `multiply` 函数的实现。
- en: 'Inside the `core_test.cljs` file, we have two autogenerated tests:'
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `core_test.cljs` 文件中，我们有两组自动生成的测试：
- en: '[PRE112]'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Both tests use the familiar `is` macro. With the `is` macro, we test whether
    calling the `multiply` function is equal to the expected output. Multiplying 1
    by 2 should equal calling the `multiply` function with two arguments: 1 and 2.'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个测试都使用了熟悉的 `is` 宏。使用 `is` 宏，我们测试调用 `multiply` 函数是否等于预期的输出。将 1 乘以 2 应该等于调用带有两个参数的
    `multiply` 函数：1 和 2。
- en: 'Run the default tests. When we create a new application based on Figwheel,
    the application has some default tests. Straight after creating the application,
    we can run the default tests:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行默认测试。当我们基于 Figwheel 创建一个新应用程序时，该应用程序有一些默认测试。在创建应用程序后，我们可以立即运行默认测试：
- en: '[PRE113]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.43 Using the fig:test command to run tests'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.43 使用 fig:test 命令运行测试'
- en: '](img/B14502_10_43.jpg)'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_10_43.jpg]'
- en: Figure 10.43 Using the fig:test command to run tests
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.43 使用 fig:test 命令运行测试
- en: We use Leiningen to launch Figwheel. In order to run tests, we use the `fig:test`
    command-line task. This task will read the Figwheel configuration from the `project.clj`
    file and run tests according to the configuration.
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 Leiningen 来启动 Figwheel。为了运行测试，我们使用 `fig:test` 命令行任务。这个任务将从 `project.clj`
    文件中读取 Figwheel 配置并按照配置运行测试。
- en: We saw two default tests in the previous steps. Both tests pass and we are informed
    about the tests passing.
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们看到了两个默认测试。两个测试都通过了，并且我们被告知测试通过了。
- en: 'The selling point of Figwheel is hot-code reloading. In order to get an interactive
    development environment, run the following:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Figwheel的卖点在于热代码重载。为了获得一个交互式开发环境，请运行以下命令：
- en: '[PRE114]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This will launch Figwheel, which autocompiles code for us:'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将启动Figwheel，它会自动编译我们的代码：
- en: '![Figure 10.44: Figwheel validates the configuration on the figwheel-main.edn
    file'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.44：Figwheel验证figwheel-main.edn文件上的配置'
- en: '](img/B14502_10_44.jpg)'
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_44.jpg)'
- en: 'Figure 10.44: Figwheel validates the configuration on the figwheel-main.edn
    file'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.44：Figwheel验证figwheel-main.edn文件上的配置
- en: Figwheel reads and validates the configuration on the `figwheel-main.edn` file.
    Then, `if` compiles our source code to the `dev-main.js` file. The test code is
    compiled to the `dev-auto-testing.js` file.
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figwheel读取并验证`figwheel-main.edn`文件上的配置。然后，`if`编译我们的源代码到`dev-main.js`文件。测试代码编译到`dev-auto-testing.js`文件。
- en: 'With Figwheel, we can see a summary of our tests in a browser. Go to `http://localhost:9500/figwheel-extra-main/auto-testing`:![Figure
    10.45: All tests passed'
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Figwheel，我们可以在浏览器中看到测试的摘要。访问`http://localhost:9500/figwheel-extra-main/auto-testing`：![图10.45：所有测试通过
- en: '](img/B14502_10_45.jpg)'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_45.jpg)'
- en: 'Figure 10.45: All tests passed'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.45：所有测试通过
- en: Figwheel informs us that all tests have passed. We have a summary displaying
    which tests were run.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: Figwheel通知我们所有测试都已通过。显示了一个摘要，说明了哪些测试被执行。
- en: In this exercise, we learned how Figwheel supports testing in ClojureScript.
    We saw the default testing configuration provided by Figwheel. In the next exercise,
    we will see how to add tests to a Figwheel application.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了Figwheel如何在ClojureScript中支持测试。我们看到了Figwheel提供的默认测试配置。在下一个练习中，我们将看到如何向Figwheel应用添加测试。
- en: 'Exercise 10.08: Testing a ClojureScript Application'
  id: totrans-695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.08：测试ClojureScript应用
- en: The aim of this exercise is to learn how to test ClojureScript applications.
    Often, front-end code is complex. The state of an application in the browser changes.
    User interactions result in many unpredictable scenarios. Having ClojureScript
    tests for frontend applications helps us to catch bugs early.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目的是学习如何测试ClojureScript应用。通常，前端代码很复杂。浏览器中应用的状态会改变。用户交互会导致许多不可预测的场景。为前端应用编写ClojureScript测试可以帮助我们及早捕捉到错误。
- en: In the previous chapter, we learned about the Figwheel application template.
    It is a very common template for writing frontend applications in ClojureScript.
    We will create an application that will react to user actions. When a user clicks
    on the action button, we will increment a counter.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了关于Figwheel应用模板的内容。它是用ClojureScript编写前端应用的非常常见的模板。我们将创建一个能够响应用户操作的应用。当用户点击操作按钮时，我们将增加计数器。
- en: 'Initially, the count will be zero:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，计数将为零：
- en: '![Figure 10.46: The initial number of clicks is zero'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.46：初始点击次数为零
- en: '](img/B14502_10_46.jpg)'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_10_46.jpg)'
- en: 'Figure 10.46: The initial number of clicks is zero'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.46：初始点击次数为零
- en: 'After six clicks the count will change:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在六次点击后，计数将改变：
- en: '![Figure 10.47: The count changes to six'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.47：计数变为六'
- en: '](img/B14502_10_47.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_10_47.jpg)'
- en: 'Figure 10.47: The count changes to six'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.47：计数变为六
- en: We know what our application will do. We are ready to implement the functionality
    now.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的应用将做什么。我们现在可以实施这个功能了。
- en: 'Create a Figwheel application:'
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Figwheel应用：
- en: '[PRE115]'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We created a new Figwheel project using Rum.
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用Rum创建了一个新的Figwheel项目。
- en: 'In the previous section, we learned that Figwheel supports testing. After creating
    a project, we are already set to run tests:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到Figwheel支持测试。在创建项目后，我们已经准备好运行测试：
- en: '[PRE116]'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.48: Two tests containing two assertions are passed'
  id: totrans-713
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.48：包含两个断言的两个测试通过
- en: '](img/B14502_10_48.jpg)'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_48.jpg)'
- en: 'Figure 10.48: Two tests containing two assertions are passed'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.48：包含两个断言的两个测试通过
- en: Figwheel compiles our code and runs the tests. We test the tet-app.core-test
    namespace. The two tests pass.
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figwheel编译我们的代码并运行测试。我们测试了tet-app.core-test命名空间。两个测试都通过了。
- en: 'We will implement a function to handle user clicks inside the `src/test_app/core.cljs`
    file:'
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`src/test_app/core.cljs`文件中实现一个处理用户点击的函数：
- en: '[PRE117]'
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `handle-click` function has one parameter. The parameter is the current
    application state. We increment the value stored in the atom under the `:counter`
    key.
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`handle-click`函数有一个参数。该参数是当前应用状态。我们在`:counter`键下增加atom中存储的值。'
- en: 'We will store the state application in an atom in the `core.cljs` file:'
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`core.cljs`文件中的atom中存储状态应用：
- en: '[PRE118]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The atom is a hash with the `:counter` key. The initial value of the key is
    zero.
  id: totrans-722
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原子是一个带有`:counter`键的哈希表。键的初始值是零。
- en: Create the counter component.
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建计数器组件。
- en: 'We create a Rum component that will display the number of mouse clicks:'
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建一个Rum组件，该组件将显示鼠标点击次数：
- en: '[PRE119]'
  id: totrans-725
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The component displays the number of clicks, which is passed as an argument.
    Inside the component, we use the `handle-click` function to respond to `:on-click`
    actions. Whenever a user clicks on the component, the `handle-click` function
    is called.
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件显示点击次数，该次数作为参数传递。在组件内部，我们使用`handle-click`函数来响应`:on-click`动作。每当用户点击组件时，`handle-click`函数就会被调用。
- en: 'Create a page component. We will put the `counter` component inside the `page-content`
    component. It is good practice to have a main component on the page where we will
    put all our components. In our example, we have one component:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建页面组件。我们将把`counter`组件放在`page-content`组件内部。在页面上有一个主要组件，我们将把所有组件放在那里是一个好的做法。在我们的例子中，我们有一个组件：
- en: '[PRE120]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The container uses Rum's `reactive` directive. This directive instructs Rum
    to handle the component in a special manner. Reactive components will `react`
    to changes to the application state. Whenever there is a change to the application
    state, the component will be updated and redisplayed in the browser using the
    new application state. We learned about reactive components in *Chapter 9*, *Host
    Platform Interoperability with Java and JavaScript*, and refreshed our memory
    in the section preceding this exercise.
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 容器使用Rum的`reactive`指令。此指令指示Rum以特殊方式处理组件。响应式组件将对应用程序状态的变化做出响应。每当应用程序状态发生变化时，组件将更新，并使用新的应用程序状态在浏览器中重新显示。我们在*第9章*，*Java和JavaScript与宿主平台互操作性*中学习了响应式组件，并在本练习之前的章节中复习了相关知识。
- en: 'Finally, we need to attach our `page-component` to a web page. As we did in
    *Chapter 9*, *Host Platform Interoperability with Java and JavaScript*, we use
    the `mount` method from Rum:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的`page-component`附加到网页上。正如我们在*第9章*，*Java和JavaScript与宿主平台互操作性*中所做的那样，我们使用Rum的`mount`方法：
- en: '[PRE121]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `page-content` component is mounted to the web page.
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`page-content`组件被挂载到网页上。'
- en: Run the application.
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。
- en: 'We will run our Figwheel application:'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将运行我们的Figwheel应用程序：
- en: '[PRE122]'
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This command will launch Figwheel for us:'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将为我们启动Figwheel：
- en: '![Figure 10.49: Launching the Figwheel'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.49：启动Figwheel](img/B14502_10_49.jpg)'
- en: '](img/B14502_10_49.jpg)'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_50.jpg)'
- en: 'Figure 10.49: Launching the Figwheel'
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.49：启动Figwheel
- en: 'Figwheel successfully launches our application. We can see the page in the
    browser. It will look as follows:'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figwheel成功启动了我们的应用程序。我们可以在浏览器中看到页面。它将如下所示：
- en: '![Figure 10.50: The number of clicks at the start of the application'
  id: totrans-741
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.50：应用程序开始时的点击次数](img/B14502_10_50.jpg)'
- en: '](img/B14502_10_50.jpg)'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_51.jpg)'
- en: 'Figure 10.50: The number of clicks at the start of the application'
  id: totrans-743
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.50：应用程序开始时的点击次数
- en: 'When the application starts, the number of clicks is zero. After six clicks,
    the state is updated and a new value is displayed on the page:'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序启动时，点击次数为零。经过六次点击后，状态更新，并在页面上显示新的值：
- en: '![Figure 10.51: The updated number of clicks'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.51：更新后的点击次数](img/B14502_10_51.jpg)'
- en: '](img/B14502_10_51.jpg)'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_51.jpg)'
- en: 'Figure 10.51: The updated number of clicks'
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.51：更新后的点击次数
- en: We see that the component on the page reacts to our actions. It is time to write
    tests for the `handle-click` function.
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到页面上的组件对我们的操作做出反应。现在是时候为`handle-click`函数编写测试了。
- en: We will create fixtures for our tests. A test fixture is a fixed state of a
    set of objects used as a baseline for running tests. The purpose of a test fixture
    is to ensure that there is a well-known and fixed environment in which tests are
    run so that results are repeatable.
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为我们的测试创建固定数据。测试固定数据是一组对象的固定状态，用作运行测试的基线。测试固定数据的目的确保测试在一个已知且固定的环境中运行，以便结果可重复。
- en: Because we will manipulate the state of an application, we want the state to
    be the same every time we run our tests. We do not want previous tests to influence
    subsequent tests.
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们将操作应用程序的状态，我们希望每次运行测试时状态都相同。我们不希望之前的测试影响后续的测试。
- en: The `handle-click` function takes a state atom as an argument. In order to test
    the handle-click function, we need a state atom. `cljs.test` provides the `use-fixtures`
    macro, which allows us to preset tests to the required state before tests are
    run. This is a good place to create a state atom for further manipulation.
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`handle-click` 函数接受一个状态原子作为参数。为了测试 `handle-click` 函数，我们需要一个状态原子。`cljs.test`
    提供了 `use-fixtures` 宏，它允许我们在测试运行之前预设测试到所需的状态。这是一个创建状态原子以进行进一步操作的好地方。'
- en: 'We will put our tests inside the `core_test.cljs` file:'
  id: totrans-752
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将把我们的测试放在 `core_test.cljs` 文件中：
- en: '[PRE123]'
  id: totrans-753
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: With the `:each` keyword, we specify that we want the fixtures to be run for
    each test. This way, we can set the state for each test. An alternative would
    be to use the `:only` keyword, which would set up fixtures only once per test.
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `:each` 关键字，我们指定我们想要为每个测试运行设置。这样，我们可以为每个测试设置状态。另一种选择是使用 `:only` 关键字，它将只在每个测试中设置一次设置。
- en: 'In the fixtures, we have two keys:'
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设置中，我们有两个键：
- en: '`:before`: Runs a function before the test is executed'
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`:before`：在测试执行之前运行一个函数'
- en: '`:after`: Runs a function after the test is executed'
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`:after`：在测试执行之后运行一个函数'
- en: In `:before` and `:after`, we set the state of the application's atom. Before
    each test, we set `:counter` to zero. After each test, we reset the application
    state to `nil`. Setting the counter to zero resets it. This way, every time we
    run a new test, the counter is started from zero. Previous tests will not influence
    subsequent tests.
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `:before` 和 `:after` 中，我们设置应用程序原子的状态。在每个测试之前，我们将 `:counter` 设置为零。在每个测试之后，我们将应用程序状态重置为
    `nil`。将计数器设置为零将其重置。这样，每次我们运行新的测试时，计数器都是从零开始的。之前的测试不会影响后续的测试。
- en: After setting up fixtures, we are ready to launch the test runner.
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设置好设置之后，我们准备启动测试运行器。
- en: Test the `handle-click` function.
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 `handle-click` 函数。
- en: 'We will test handling multiple clicks:'
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将测试处理多个点击：
- en: '[PRE124]'
  id: totrans-762
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We use the `are` macro to simplify testing. We compare the expected result to
    the return value of calling the `handle-click` function. Calling `handle-click`
    three times should increase the counter to three.
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `are` 宏来简化测试。我们比较预期结果与调用 `handle-click` 函数的返回值。调用 `handle-click` 三次应该将计数器增加到三。
- en: 'We will run the tests now:'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将运行测试：
- en: '[PRE125]'
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The output is as follows:'
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.52: Running the tests'
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.52：运行测试'
- en: '](img/B14502_10_52.jpg)'
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_52.jpg)'
- en: 'Figure 10.52: Running the tests'
  id: totrans-769
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.52：运行测试
- en: As we see in the summary, the tests pass. The `handle-click` test used `app-state`,
    which we set up using the `use-fixtures` macro. Before each test, the fixtures
    created an application state. After each test, the fixtures should reset the state
    to zero. We will write a new test to check whether the application state is reset.
  id: totrans-770
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们在摘要中看到的，测试通过了。`handle-click` 测试使用了 `app-state`，这是我们使用 `use-fixtures` 宏设置的。在每个测试之前，设置创建了一个应用程序状态。在每个测试之后，设置应该将状态重置为零。我们将编写一个新的测试来检查应用程序状态是否已重置。
- en: 'In the following test, we will test a single click:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下测试中，我们将测试单个点击：
- en: '[PRE126]'
  id: totrans-772
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In this test, we use the `is` macro to test a single click.
  id: totrans-773
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用 `is` 宏来测试单个点击。
- en: 'We will run the tests again:'
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次运行测试：
- en: '[PRE127]'
  id: totrans-775
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The output is as follows:'
  id: totrans-776
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 10.53: Running the tests again'
  id: totrans-777
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.53：再次运行测试'
- en: '](img/B14502_10_53.jpg)'
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_10_53.jpg)'
- en: 'Figure 10.53: Running the tests again'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.53：再次运行测试
- en: Running the new test tells us that the state has been reset. We see that our
    test passed as the application state has been reset successfully.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新的测试告诉我们状态已经被重置。我们看到我们的测试通过了，因为应用程序状态已经成功重置。
- en: In this exercise, we learned how to integrate testing into ClojureScript applications.
    We created a project using the Figwheel template. This template allowed us to
    create a web application. In the application, we added user interaction. The application
    counted the number of clicks. We wrote tests to make sure that our functions perform
    as expected.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何将测试集成到 ClojureScript 应用程序中。我们使用 Figwheel 模板创建了一个项目。这个模板允许我们创建一个网络应用程序。在应用程序中，我们添加了用户交互。应用程序计算点击次数。我们编写了测试来确保我们的函数按预期执行。
- en: You are ready to start writing web applications and adding tests to them. In
    the following activity, you will put your new knowledge to use.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以开始编写网络应用程序并将测试添加到其中。在接下来的活动中，你将应用你的新知识。
- en: 'Activity 10.02: Support Desk Application with Tests'
  id: totrans-783
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 10.02：带有测试的支持台应用程序
- en: The aim of this activity is to add a testing suite to a web application. Many
    applications require complex functionality and many features. While manual testing
    can catch many bugs, it is time-consuming and requires many testers. With automated
    testing, checking applications are faster and more features can be tested. ClojureScript
    provides tools to help with unit testing.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是向网络应用程序添加测试套件。许多应用程序需要复杂的功能和许多特性。虽然手动测试可以捕捉到许多错误，但它耗时且需要许多测试人员。使用自动化测试，检查应用程序更快，并且可以测试更多功能。ClojureScript
    提供了帮助进行单元测试的工具。
- en: In the previous chapter, we wrote a support desk application that allowed us
    to manage issues raised with the help desk ([https://packt.live/2NTTJpn](https://packt.live/2NTTJpn)).
    The application allows you to sort issues and resolve them when they are done.
    By sorting the issues, we can raise the priority of the issue. In this activity,
    we will add unit tests using `clsj.test` and `test.check` for property-based testing.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了一个支持台应用程序，该应用程序允许我们通过帮助台管理提出的问题（[https://packt.live/2NTTJpn](https://packt.live/2NTTJpn)）。该应用程序允许您对问题进行排序并在完成后解决它们。通过排序问题，我们可以提高问题的优先级。在这个活动中，我们将使用
    `clsj.test` 和 `test.check` 为属性测试添加单元测试。
- en: 'You will write tests for the following:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 您将编写以下测试：
- en: A function displaying the sort message status
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示排序消息状态的函数
- en: A function filtering the list of issues by priority
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按优先级过滤问题列表的函数
- en: A function sorting the list of issues
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对问题列表进行排序的函数
- en: A function deleting an item from the issues list
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从问题列表中删除项的函数
- en: 'These steps will help you complete the activity:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成活动：
- en: Add the testing dependencies to the `project.clj` file.
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试依赖项添加到 `project.clj` 文件中。
- en: Import the namespaces to the `core_test.cljs` file.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命名空间导入到 `core_test.cljs` 文件中。
- en: Create fixtures with issues in the application state.
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序状态中创建带有问题的固定装置。
- en: Write tests for the sort message function, `cljs.test`.
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为排序消息函数编写 `cljs.test` 测试。
- en: Write tests for the sort message function using `test.check`.
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `test.check` 为排序消息函数编写测试。
- en: Write tests to filter issues by priority function using `cljs.test`.
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写按优先级过滤问题的测试。
- en: Write tests to sort the issues list using `cljs.test`.
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写排序问题列表的测试。
- en: Write tests to delete issues from the list using `cljs.test`.
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写从列表中删除问题的测试。
- en: Write tests to handle the sort function using `cljs.test`.
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cljs.test` 编写测试来处理排序函数。
- en: 'The initial issues list will look as follows:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 初始问题列表将如下所示：
- en: '![Figure 10.54: List of initial issues'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.54：初始问题列表]'
- en: '](img/B14502_10_54.jpg)'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_10_54.jpg]'
- en: 'Figure 10.54: List of initial issues'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.54：初始问题列表
- en: 'The issues list after sorting will look as follows:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后的问题列表将如下所示：
- en: '![Figure 10.55: List after sorting'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.55：排序后的列表]'
- en: '](img/B14502_10_55.jpg)'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_10_55.jpg]'
- en: 'Figure 10.55: List after sorting'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.55：排序后的列表
- en: 'When the tests are run, the output should look like the following:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，输出应如下所示：
- en: '![Figure 10.56: Output after running the tests'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.56：运行测试后的输出]'
- en: '](img/B14502_10_56.jpg)'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_10_56.jpg]'
- en: 'Figure 10.56: Output after running the tests'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.56：运行测试后的输出
- en: Note
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 730
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第730页找到
- en: Summary
  id: totrans-815
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about testing in Clojure. First, we explored why
    testing is important. We looked at some of the benefits, such as reduced maintenance
    costs and bug fixing. We also learned what testing methodologies are available.
    We focused on unit testing as this is the most common type of test written by
    developers.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Clojure 中的测试。首先，我们探讨了为什么测试很重要。我们查看了一些好处，例如降低维护成本和错误修复。我们还学习了可用的测试方法。我们专注于单元测试，因为这是开发者编写的最常见类型的测试。
- en: Next, we explored four testing libraries available in Clojure. We started with
    the standard clojure.test library, which provides a rich set of testing features.
    The second library we learned about was Expectations. It allows us to write concise
    tests as it focuses on readability.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了 Clojure 中可用的四个测试库。我们首先了解了标准的 clojure.test 库，它提供了一套丰富的测试功能。我们学习的第二个库是
    Expectations。它允许我们编写简洁的测试，因为它侧重于可读性。
- en: The `Midje` library allowed us to explore top-down test-driven development (TDD).
    We created a test for the main function and stubs for functions that would be
    implemented in the future. TDD allows us to focus on testing functions' features
    without worrying about implementing all of the subfunctions used.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '`Midje`库使我们能够探索自顶向下的测试驱动开发（TDD）。我们为主要的函数创建了一个测试，并为将来要实现的函数创建了存根。TDD允许我们专注于测试函数的特性，而不必担心实现所有使用的子函数。'
- en: The last library used was `test.check`, which introduced us to property-based
    testing. With property-based tests, we describe the properties of function arguments
    in a general form. This allows tests to generate input based on such properties.
    With this type of test, we can run thousands of test scenarios with a few lines
    of code. There's no need to enumerate every single test case.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 最后使用的库是`test.check`，它向我们介绍了基于属性的测试。使用基于属性的测试，我们以一般形式描述函数参数的性质。这使得测试可以根据这些属性生成输入。使用这种类型的测试，我们可以用几行代码运行成千上万的测试场景。无需枚举每一个单独的测试用例。
- en: In the second part of this chapter, we learned about testing in ClojureScript.
    We saw that the cljs.test library provides us with features comparable to the
    `clojure.test` library. With `clsj.test`, we were able to test ClojureScript code.
    We also looked at macros, allowing us to test asynchronous ClojureScript code.
    We also set up an autorunner to run ClojureScript tests automatically when our
    code changes.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们学习了ClojureScript中的测试。我们了解到`cljs.test`库为我们提供了与`clojure.test`库相当的功能。使用`clsj.test`，我们能够测试ClojureScript代码。我们还研究了宏，使我们能够测试异步的ClojureScript代码。我们还设置了一个自动运行器，当我们的代码发生变化时，它会自动运行ClojureScript测试。
- en: Finally, we worked through two activities that allowed us to use our testing
    knowledge in projects. We wrote tests using libraries we learned about for applications
    developed in previous chapters.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了两个活动，这些活动使我们能够在项目中应用我们的测试知识。我们使用了在前几章中学习到的库来编写测试，用于开发前几章中的应用程序。
- en: In the next chapter, we will learn about macros. Macros are a powerful feature
    that allows us to influence the Clojure language.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习宏的概念。宏是一种强大的功能，它允许我们影响Clojure语言。
