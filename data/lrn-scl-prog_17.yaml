- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: '**Describe two ways to make it possible for some resource, `R`**, **to be used
    together with the `scala.util.Using` resource management utility.**'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述两种使某些资源`R`能够与`scala.util.Using`资源管理实用程序一起使用的方法。**'
- en: Let `R` extend `java.lang.AutoCloseable`. This will allow existing implicit
    conversion from `AutoCloseable` into `Resource` to be applied to `R`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让`R`扩展`java.lang.AutoCloseable`。这将允许将现有的从`AutoCloseable`到`Resource`的隐式转换应用于`R`。
- en: Provide an implicit implementation of `Resource[R]`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对`Resource[R]`的隐式实现。
- en: '**How can** `Set` **and** `List` **be compared?**'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何比较`Set`和`List`？**'
- en: 'Equality is not defined between `Set` and `List`, hence we have to use the `sameElements`
    method in one of two ways, directly on `List` or on the iterator of `Set`, as
    shown in the following snippet:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`和`List`之间没有定义等性，因此我们必须以以下两种方式之一使用`sameElements`方法，直接在`List`上或在`Set`的迭代器上，如下面的代码片段所示：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another possibility is to utilize the `corresponds` operation in combination
    with the equality checking function. This works similar in either direction:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是利用`corresponds`操作与等性检查函数的组合。这在两个方向上工作方式相似：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Name the default concrete implementation for an immutable** `Seq`**.**'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为不可变的`Seq`命名默认的具体实现。**'
- en: '`scala.collection.immutable.List`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala.collection.immutable.List`'
- en: '**Name the default concrete implementation for an immutable indexed** `Seq`**.**'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为不可变的索引`Seq`命名默认的具体实现。**'
- en: '`scala.collection.immutable.Vector`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala.collection.immutable.Vector`'
- en: '**Name the default concrete implementation for a mutable** `Seq`**.**'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为可变的`Seq`命名默认的具体实现。**'
- en: '`scala.collection.mutable.ArrayBuffer`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala.collection.mutable.ArrayBuffer`'
- en: '**Name the default concrete implementation for a mutable** `IndexedSeq`**.**'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为可变的`IndexedSeq`命名默认的具体实现。**'
- en: '`scala.collection.mutable.ArrayBuffer`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala.collection.mutable.ArrayBuffer`'
- en: '**It is sometimes said that** `List.flatMap` **is more powerful than it is
    expected to be. Can you try to explain why? **'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有时人们会说** `List.flatMap` **比预期的更强大。你能尝试解释一下为什么吗？**'
- en: '`flatMap` is defined on `IterableOnce` and hence takes a function returning
    `IterableOnce` as its argument. Because of this, it is possible to mix different
    types while `flatMap` pings. Consider the following example where `List` is able
    to `flatMap` the collection with `Set[Int]` and  as its elements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`是在`IterableOnce`上定义的，因此它的参数是一个返回`IterableOnce`的函数。正因为如此，在`flatMap`操作时可以混合不同的类型。考虑以下示例，其中`List`能够将`Set[Int]`和其元素进行`flatMap`操作：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Describe a way to map over a collection multiple times using different functions
    but without producing intermediate collections.**'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述一种使用不同函数多次映射集合的方法，但又不产生中间集合。**'
- en: 'Create a view, map over the view as required, and force conversion back to
    the original representation type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个视图，按需映射视图，并强制将其转换回原始表示类型：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Chapter 2
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: '**Which type constraints can you name?**'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能命名哪些类型约束？**'
- en: 'There are two constraints: the lower bound or subtype relation and the upper
    bound or supertype relation.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个约束：下界或子类型关系和上界或超类型关系。
- en: '**What implicit type constraints are added to a type if there are no type constraints
    defined on it by the developer?**'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果没有开发者为类型定义类型约束，那么会添加哪些隐式类型约束到该类型中？**'
- en: For missing upper bound, the compiler adds `Any` as a constraint, and, for missing
    lower bound–`Nothing`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于缺少上界，编译器添加`Any`作为约束，对于缺少下界则添加`Nothing`。
- en: '**Which operators can be used to refer to the nested type of some type?**'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些运算符可以用来引用某些类型的嵌套类型？**'
- en: There are two operators. The notion `A#B` refers to the nested type of the `A` type.
    The notion of `a.B` refers to the `B` subtype of the instance `a`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个运算符。`A#B`的概念指的是`A`类型的嵌套类型。`a.B`的概念指的是实例`a`的`B`子类型。
- en: '**Which type can be used as an infix type?**'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪种类型可以用作中缀类型？**'
- en: Any type which is parameterized by exactly two type parameters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 任何恰好由两个类型参数参数化的类型。
- en: '**Why is the use of structural types discouraged in Scala?**'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么在Scala中不建议使用结构化类型？**'
- en: Use of structural types often leads to generated byte code, which accesses methods
    via reflection, which is slower than normal method calls.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型的用法通常会导致生成的字节码，它通过反射访问方法，这比正常方法调用要慢。
- en: '**What is expressed via variance?**'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过变异性表达了什么？**'
- en: The correlation between subtyping relations of parameterized and parameterizing types.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化类型和参数化类型之间的子类型关系的相关性。
- en: Chapter 3
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: '**What will be a type of the following function in curried form: `(Int, String)
    => (Long, Boolean, Int) => String`?**'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以下函数在柯里化形式中的类型将是什么：`(Int, String) => (Long, Boolean, Int) => String`？**'
- en: '`Int => (String => ((Long, Boolean, Int) => String))` or simplified `Int =>
    String => (Long, Boolean, Int) => String`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int => (String => ((Long, Boolean, Int) => String)))` 或简化为 `Int => String
    => (Long, Boolean, Int) => String`'
- en: '**Describe the difference between a partially applied function and a partial
    function.**'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述部分应用函数和部分函数之间的区别**。'
- en: A partial function is not defined for some of the possible input values. A partially
    applied function has some of its parameters fixed to specific values.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数未定义在某些可能的输入值上。部分应用函数将其一些参数固定为特定值。
- en: '**Define a signature and implement a function, `uncurry`**, **for a curried
    function of three arguments, `A => B => C => R`**.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义一个签名并实现一个函数，`uncurry`，用于三个参数的柯里化函数，`A => B => C => R`**。'
- en: '`def uncurry[A,B,C,R](in: A => B => C => R): (A,B,C) => R = (a,b,c) => in(a)(b)(c)`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`def uncurry[A,B,C,R](in: A => B => C => R): (A,B,C) => R = (a,b,c) => in(a)(b)(c)`'
- en: '**Implement a head-recursive function for the factorial calculation (n! = n
    * (n-1) * (n-2) * ... * 1.**'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现一个用于阶乘计算的头部递归函数（n! = n * (n-1) * (n-2) * ... * 1**）。'
- en: '`def factorial(n: Long): Long = if (n < 2) n else n * factorial(n-1)`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`def factorial(n: Long): Long = if (n < 2) n else n * factorial(n-1)`'
- en: '**Implement a tail-recursive function for a factorial calculation.**'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现一个用于阶乘计算的尾递归函数**。'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Implement a recursive function for a factorial calculation using trampolining.**'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现一个使用跳跃递归的阶乘计算的递归函数**。'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Chapter 4
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: '**Describe a case where an implicit parameter is also an implicit conversion.**'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述一个隐式参数也是隐式转换的情况**。'
- en: 'This is the case if an implicit parameter is a function: `def func[A, T](a:
    A)(implicit adapter: A => T): T  = adapter(a)`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '如果隐式参数是一个函数，则这是这种情况：`def func[A, T](a: A)(implicit adapter: A => T): T = adapter(a)`。'
- en: '**Replace the following definition that uses view bounds with one using context
    bounds: `def compare[T <% Comparable[T]](x: T, y: T) = x < y`**.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将以下使用视图边界的定义替换为使用上下文边界的定义：`def compare[T <% Comparable[T]](x: T, y: T) =
    x < y`**。'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Why are type classes sometimes said to separate behavior and data?**'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么有时说类型类将行为和数据分开？**'
- en: Because type class instances define logic to work and the data comes from the
    values the type class is applied to.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类型类实例定义了逻辑以工作，并且数据来自类型类应用到的值。
- en: 'It is easy to change the example of possible conflicts in lexical scope so
    that one of the implicits wins over others and all others can be uncommented without
    having conflicts anymore. Make this change. For example, it can be done by changing
    one of the definitions of `val`s to the definition of an `object`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易改变可能的冲突的示例，以便其中一个隐式参数胜过其他隐式参数，并且所有其他隐式参数都可以取消注释而不再有冲突。进行此更改。例如，可以通过将`val`的定义之一更改为`object`的定义来完成：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, the TSO will be more specific than the rest of the values because of static
    resolution rules and will be selected by the compiler for the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于静态解析规则，TSO将比其他值更具体，并且将由编译器为应用程序选择。
- en: Chapter 5
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: '**Define an invariant property for sorting a list.**'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义一个用于排序列表的不变性质**。'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Define an idempotent property for sorting a list.**'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义一个用于排序列表的幂等性质**。'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Define an inductive property for sorting a list.**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义一个用于排序列表的归纳性质**。'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Define a generator for `List[Lists[Int]]` so that elements of the nested
    list are positive.**'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义一个用于`List[List[Int]]`的生成器，使得嵌套列表的元素都是正数**。'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Define a generator for `Map[UUID, () => String].`**'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义一个用于`Map[UUID, () => String]`的生成器**。'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that `Gen.function0` generates a function of zero arguments that
    just return random values generated by the provided generator.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Gen.function0`生成一个零参数的函数，该函数仅返回由提供的生成器生成的随机值。
- en: Chapter 6
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: '**What would be the proper effect to represent getting each of the following:**'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表示获取以下每个元素的适当效果是什么：**'
- en: '**The first element of some** `List`: `Option[?]` with `None` representing
    an empty list does not have a head element'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**某些列表的第一个元素**：`Option[?]`，其中`None`表示空列表没有头元素'
- en: '**A list of tweets**: `Future[List[Tweet]]` as the operation will probably
    take some time as it goes over the network'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推文列表**：`Future[List[Tweet]]`，因为操作可能需要一些时间，因为它通过网络进行'
- en: '**User information from the database for a given** `userId`: `Future[Option[?]]`
    with `Future` denoting the network call and `Option` denoting no user account
    for a given `userId`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用数据库中的用户信息** `userId`：`Future[Option[?]]`，其中`Future`表示网络调用，`Option`表示对于给定的`userId`没有用户账户'
- en: '**What is a range of possible values of the following expression:** `Option(scala.util.Random.nextInt(10)).fold(9)(_-1) `'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以下表达式的可能值范围是什么：** `Option(scala.util.Random.nextInt(10)).fold(9)(_-1)`'
- en: An inclusive [-1;9]
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含 [-1;9] 的区间
- en: '**What will be the result of the following expression: **'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以下表达式的结果会是什么：**'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Try` constructor will not catch an `OutOfMemoryError`, hence the given
    expression will throw the `OutOfMemoryError`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try` 构造函数不会捕获 `OutOfMemoryError`，因此给定的表达式将抛出 `OutOfMemoryError`。'
- en: '**Describe the result of the following expression:**'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述以下表达式的结果：**'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result of the expression will be `Future(<not completed>)` which will eventually
    throw an `OutOfMemoryError`, as in the previous case.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的结果将是 `Future(<未完成>)`，最终会抛出 `OutOfMemoryError`，就像上一个案例一样。
- en: '**Given the following function:**'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**给定以下函数：**'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**What would be the result of the following call:** `either(1)` ?'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以下调用会有什么结果：** `either(1)`？'
- en: The result will be `true` because `Either.cond` evaluates to `Left` for `i ==
    2` and `Left.forall` evaluates to `true` for any `Left`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是 `true`，因为 `Either.cond` 在 `i == 2` 时评估为 `Left`，而 `Left.forall` 对任何 `Left`
    评估为 `true`。
- en: Chapter 7
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: '**Why is the property of associativity essential for the monoid to be useful
    in a distributed setup?**'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么结合律对于幺半群在分布式设置中有用是本质的？**'
- en: In a distributed setup, we're usually talking about folding and reusing datasets
    with parts of the data being processed by different computers. Monoidal operations
    are applied on remote machines. Regardless of the order in which they were sent
    from the master machine, network delays, different load patterns, and hardware
    settings will influence the order in which they will be returned. It is important
    to be able to apply an operation on the intermediate results already at hand without
    waiting for the first operations to complete.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式设置中，我们通常讨论的是折叠和重用数据集，其中部分数据由不同的计算机处理。幺半群操作应用于远程机器。无论它们是从主机器发送的顺序如何，网络延迟、不同的负载模式和硬件设置都将影响它们返回的顺序。能够在不等待第一次操作完成的情况下，对已经掌握的中间结果应用操作是很重要的。
- en: '**Implement a monoid for `Boolean` under `OR`**.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 `OR` 下实现 `Boolean` 的幺半群。**'
- en: 'The implementation is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The property is as follows::'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '属性如下::'
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Implement a monoid for `Boolean` under `AND.`**'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 `AND` 下实现 `Boolean` 的幺半群。**'
- en: 'The implementation is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The property is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 属性如下：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Given `Monoid[A]`, implement `Monoid[Option[A]].`**'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**给定 `Monoid[A]`，实现 `Monoid[Option[A]].`**'
- en: 'The implementation is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The property is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 属性如下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Given `Monoid[R]`, implement `Monoid[Either[L, R]].`**'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**给定 `Monoid[R]`，实现 `Monoid[Either[L, R]].`**'
- en: 'The implementation is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The property is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 属性如下：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Generalize two previous implementations for any effect parameterized by `A` or
    describe why it is not possible.**'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**泛化前两个实现以适用于任何由 `A` 参数化的效果，或描述为什么不可能。**'
- en: 'Unfortunately, it is not possible to implement such a monoid in general because
    the implementation would require two aspects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在一般情况下无法实现这样的幺半群，因为实现将需要两个方面：
- en: An identity element for the new monoid
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新幺半群的单位元素
- en: A possibility to check whether an effect is empty and retrieve an element if
    it is not
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查一个效果是否为空，并在它不为空时检索一个元素的可能性
- en: It is possible to pass an identity element as an argument to the constructor,
    but then there is no way to work with existing effects as required by the second
    point.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将单位元素作为参数传递给构造函数，但这样就没有办法按照第二点的要求与现有的效果一起工作。
- en: Chapter 8
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: '**Implement** `Functor[Try]`.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现** `Functor[Try]`。'
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Implement** `Applicative[Try]`.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现** `Applicative[Try]`。'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Implement ** `Applicative[Either]`.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现** `Applicative[Either]`。'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Implement** `Traversable[Try]`.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现** `Traversable[Try]`。'
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Implement** `Traversable[Either]`.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现** `Traversable[Either]`。'
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Implement **`Traversable.compose`.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现** `Traversable.compose`。'
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Chapter 9
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: '**Implement `Monad[Try]`**.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现** `Monad[Try]`。'
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Prove the right identity law for the `State` monad.**'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**证明 `State` 幺半群的右单位律。**'
- en: 'Let''s start with the property definition we had in this chapter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本章中已有的属性定义开始：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let `f(a) = a => State(s => (b, s2))`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 设 `f(a) = a => State(s => (b, s2))`
- en: First, we substitute the definition of unit with the result of the call. Hence, `M.flatMap(M.unit(a))(f)`
    becomes `M.flatMap(State(s => (a, s)))(f)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将单位定义的值替换为调用结果。因此，`M.flatMap(M.unit(a))(f)` 变为 `M.flatMap(State(s => (a,
    s)))(f)`。
- en: Next, we substitute `M.flatMap` with `compose`, which gives us `State(s => (a,
    s)).compose(f).`
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`M.flatMap`替换为`compose`，这给我们`State(s => (a, s)).compose(f).`
- en: 'Next, we''ll use the lemma proved in this chapter to substitute the `compose`
    call with the definition of it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用本章中证明的引理，用其定义替换`compose`调用：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By application of `f`, the previous code can be simplified to `State(s => State(s
    => (b, s2)).run(s)` and further to `State(s => (b, s2)`. **(1)**
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用`f`，之前的代码可以简化为`State(s => State(s => (b, s2)).run(s)`，进一步简化为`State(s =>
    (b, s2))`。**(1)**
- en: The right side of the equation, `f(a)`, is by definition equal to `State(s =>
    (b, s2))`. **(2)**
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式的右侧，`f(a)`，根据定义等于`State(s => (b, s2))`。**(2)**
- en: We have (1) == (2) and hence proved the right identity law for the state monad.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有(1) == (2)，因此证明了状态单子的右单位律。
- en: '**Pick one of the monads we defined in this chapter and implement the `go` function
    that will encode the notion of sinking the boat with a 1% probability.**'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在本章定义的单子中选择一个，并实现一个`go`函数，该函数将以1%的概率编码船沉没的概念。**'
- en: '`Option` will represent the notion of the sunk boat:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`将代表船沉没的概念：'
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Please do the same but encode the notion of a motor breaking in 1% of the
    moves, leaving the boat immobilized.**'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请同样操作，但以1%的概率编码电机在移动中损坏的概念，使船无法移动。**'
- en: Both `Try` and right-biased `Either` can be used to encode the case of the broken
    motor.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try`和右偏`Either`都可以用来编码电机损坏的情况。'
- en: 'Following is the implementation with `Try`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`Try`的实现：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Following is the implementation with `Either`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`Either`的实现：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Describe the essence of monads we defined in this chapter using (loosely) the following
    template: The state monad passes state between chained computation. The computation
    itself accepts the outcome of the previous calculation and returns the result
    along with the new state.**'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用以下模板（松散地）描述本章中定义的单子的本质：状态单子传递链式计算之间的状态。计算本身接受前一次计算的结果，并返回结果以及新的状态。**'
- en: The option monad allows the chaining of computations which might return no result.
    The computations are carried over until the last one or until the first one returns
    no result.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 选项单子允许链式计算，这些计算可能不会返回结果。计算会一直进行，直到最后一个或直到第一个返回无结果。
- en: The try monad does the same as the option monad but instead of having a special
    *no result* value, which aborts the whole computation chain, it has a notion of
    *failure* represented by a `Failure` case class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试单子与选项单子做同样的事情，但不是通过一个特殊的*无结果*值来中断整个计算链，而是有一个由`Failure`案例类表示的*失败*概念。
- en: Either monad has similar semantics to the option and try monads but, in this
    case, the notion of aborting the sequence of steps is carried on by the Left type
    and the notion of continuing the sequence, by the `Right` type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单子都有类似于选项和尝试单子的语义，但在这个情况下，中断步骤序列的概念由`Left`类型承担，而继续序列的概念由`Right`类型承担。
- en: '**Define a `go` method that both tracks the boat''s position and takes the
    possibility of sinking the boat using the structure with the following type: `type
    WriterOption[B] = Writer[Vector[(Double, Double)], Option[Boat]]`**.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义一个`go`方法，该方法既跟踪船的位置，又使用以下类型的结构来考虑船沉没的可能性：`type WriterOption[B] = Writer[Vector[(Double,
    Double)], Option[Boat]]`**。'
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Compare the answer to Question 6 and the way we combined applications in
    the previous chapter.**'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**比较第6题的答案和我们在上一章中组合应用的方式。**'
- en: In [Chapter 8](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml), *Dealing with Effects*,
    we implemented a generic combinator for applications. In this implementation involving
    monads, we needed to know how to dissect the options effect in order to be able
    to implement the combination logic. Please read [Chapter 10](5503a5a0-2aaa-44f2-be25-64e34977f6ff.xhtml), 
    *A Look at Monad Transformers and Free Monad*, for more details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml)，*处理效果*中，我们实现了一个通用的组合子用于应用。在这个涉及单子的实现中，我们需要了解如何剖析选项的效果，以便能够实现组合逻辑。请阅读[第10章](5503a5a0-2aaa-44f2-be25-64e34977f6ff.xhtml)，*单子变换器和自由单子的观察*，以获取更多详细信息。
- en: Chapter 10
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: '**Why does the type of monad transformer reflect the type of the stack "upside-down"?**'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么单子变换器的类型反映了栈类型的“颠倒”？**'
- en: It is impossible to define a monad composition in general, only in a way specific
    to the internal effect of the stack. Because of this, the name of the effect is
    fixed in the name of the transformer and the outer effect becomes a type parameter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，无法定义单子组合，只有在其堆栈内部效果特定的情况下才能定义。因此，效果的名字被固定在转换器的名字中，外部效果成为类型参数。
- en: '**Why is it possible to reuse existing monads for the top layer of the stack?**'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么可以在堆栈顶层重用现有的单子？**'
- en: The return type of the Kleisli arrow fits well with the type of the stack. For
    this reason, it is possible to produce the result of the proper type by utilizing
    the `flatMap` method of the outer monad.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Kleisli 箭的返回类型与堆栈的类型很好地匹配。因此，可以通过利用外部单子的 `flatMap` 方法来产生正确类型的正确结果。
- en: '**Why is it impossible to reuse existing monads for the bottom layer of the
    stack?**'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么不能在堆栈底层重用现有的单子？**'
- en: The argument type of the arrow expects a plain argument. Consequently, we need
    to extract the effect-free value from the context of internal effect. This is
    only possible in a specific way but not in general.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 箭的参数类型期望一个普通参数。因此，我们需要从内部效果上下文中提取无效果的价值。这只能在特定方式下实现，而不能在一般方式下实现。
- en: '**Implement the `TryT` monad transformer.**'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现 `TryT` 单子转换器。**'
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Use the `TryT` monad transformer instead of `EitherT` with the example functions
    from this chapter.**'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请使用 `TryT` 单子转换器代替本章中的示例函数中的 `EitherT`。**'
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Implement another take on the monad transformer stack, this time with this
    layers placed upside-down: **`EitherT[OptionT[Future, A], String, A]`.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现另一种单子转换器堆栈，这次将层放置颠倒： **`EitherT[OptionT[Future, A], String, A]`。'
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Add an action to release the caught fish to the free monad example we developed
    in the chapter.**'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将释放捕获的鱼的动作添加到我们在本章中开发的自由单子示例中。**'
- en: 'Only the changed parts of the example are shown here. Please see the accompanying
    code to see the example with incorporated changes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只显示了示例的更改部分。请参阅附带的代码，以查看包含更改的示例：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We need to extend the action model and a function, add a helper lifting method,
    add the additional step to the definition of the process, and augment both interpreters
    to support the new action.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要扩展动作模型和函数，添加一个辅助提升方法，将额外的步骤添加到进程的定义中，并增强两个解释器以支持新的动作。
- en: Chapter 11
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: '**Name two ways in which an actor can change itself in response to the received
    message.**'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请列举两种演员可以对其接收到的消息做出反应并改变自己的方式。**'
- en: An actor can mutate its internal state using a var field. This is a classical
    object-oriented approach.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以使用 var 字段来改变其内部状态。这是一种经典的对象导向方法。
- en: Another way is to use context and become close over some value which will become
    part of the new state. The context.become can also be used to change the behavior
    of the actor completely. This is a more functional approach because both state
    and behavior are in fact immutable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用上下文并围绕某个将成为新状态一部分的值进行成为操作。context.become 也可以用来完全改变演员的行为。这更是一种函数式方法，因为状态和行为实际上都是不可变的。
- en: '**What is the purpose of `ActorRef`?**'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ActorRef` 的目的是什么？**'
- en: The ActorRef provides a means to address an actor via the actor path. It also
    encapsulates an actor's mailbox and a dispatcher. Actors in Akka communicate via
    ActorReference.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ActorRef 提供了一种通过演员路径来寻址演员的方法。它还封装了一个演员的邮箱和调度器。Akka 中的演员通过 ActorReference 进行通信。
- en: '**Look up in the official documentation the description of the system guardian.
    What is the main purpose of it?**'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在官方文档中查找系统守护者的描述。它的主要目的是什么？**'
- en: The main purpose of the system guardian is to supervise system level actors.
    It is also used to ensure a proper shutdown order so that system level actors
    are available for user-defined actors until the user guardian is terminated.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 系统守护者的主要目的是监督系统级演员。它还用于确保适当的关闭顺序，以便在用户守护者终止之前，系统级演员对用户定义的演员可用。
- en: '**Describe the advantages and disadvantages of using Akka FSM.**'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述使用 Akka FSM 的优缺点。**'
- en: Akka FSM allows for the modeling of actor behavior as a state machine defining
    separate state transitions and data for these states.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Akka FSM 允许将演员行为建模为状态机，定义这些状态之间的单独状态转换和数据。
- en: Akka FSM couples business logic to the particular implementation and makes it
    hard to test and debug.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Akka FSM 将业务逻辑与特定实现耦合，使得测试和调试变得困难。
- en: '**In how many ways can an actor in another actor system be accessed? Describe
    them.**'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以多少种方式可以访问另一个演员系统中的演员？描述它们。**'
- en: There are two ways to access an actor in a remote system – remote deployment
    and remote lookup. With remote deployment, a new actor is created in the remote
    system. The remote deployment can be done explicitly in the code or by providing
    a deployment configuration. Remote lookup allows for the selection of an existing
    actor in a remote system using the same approach as used for the lookup locally.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程系统中访问actor有两种方式——远程部署和远程查找。通过远程部署，在远程系统中创建一个新的actor。远程部署可以在代码中显式执行，或者通过提供部署配置来完成。远程查找允许使用与本地查找相同的方法来选择远程系统中的现有actor。
- en: '**Why does testing actors require a special toolkit?**'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么测试actor需要特殊的工具集？**'
- en: Actors are highly non-deterministic. The state of the actor is inaccessible.
    The only way to properly test an actor is by sending messages to it and waiting
    for its responses. Sometimes a whole actor hierarchy needs to be created for this
    purpose.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Actors具有高度的非确定性。actor的状态是不可访问的。正确测试actor的唯一方法是通过向其发送消息并等待其响应。有时需要创建整个actor层次结构来完成此目的。
- en: Chapter 12
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: '**What is the meaning of the `Behavior[Tpe]` definition?**'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`Behavior[Tpe]`定义的意义是什么？**'
- en: '`Behavior[Tpe]` explicitly specifies that this actor is capable of handling
    messages that are subtypes of `Tpe`. By recursion, we can conclude that the returned
    behavior also will be `Behavior[Tpe].`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Behavior[Tpe]`明确指定了这个actor能够处理`Tpe`的子类型消息。通过递归，我们可以得出结论，返回的行为也将是`Behavior[Tpe]`。'
- en: '**How do you get access to the scheduler in the actor''s behavior?**'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何在actor的行为中获取对调度器的访问？**'
- en: The schedule is accessible via the behavior constructor, `Behaviors.withTimers.`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序可以通过行为构造函数`Behaviors.withTimers`访问。
- en: '**Describe possible ways an actor can be stopped.**'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述actor可能被停止的可能方式。**'
- en: 'An actor can be stopped by the parent using the parent''s actor context: `context.stop(child)`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 父actor可以使用父actor的actor上下文来停止actor：`context.stop(child)`。
- en: 'An actor can also stop itself by returning respective behavior: `Behaviors.stopped`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: actor也可以通过返回相应的行为来停止自己：`Behaviors.stopped`。
- en: An actor can also be stopped if an exception was thrown by the actor's logic
    and the `SupervisorStrategy` defined for this actor is `stop`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果actor的逻辑抛出了异常，并且为该actor定义的`SupervisorStrategy`是`stop`，actor也可以被停止。
- en: '**What is the difference between a local and a cluster receptionist?**'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**本地和集群接待员之间的区别是什么？**'
- en: There are different implementations but there is no noticeable difference for
    the developer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有不同的实现方式，但对开发者来说没有明显的区别。
- en: '**What supervision possibilities exist and how are they defined?**'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存在哪些监督可能性，以及它们是如何定义的？**'
- en: 'There are three supervision strategies: stop, restart, and resume. They are
    defined by wrapping an actor in supervising behavior using `Behaviors.supervise`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种监督策略：停止、重启和恢复。它们通过使用`Behaviors.supervise`将监督行为包装在actor上来定义。
- en: '**Why should stashing be used judiciously?**'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么应该谨慎使用stashing？**'
- en: Current stashing implementation buffers messages in memory and can lead to `OutOfMemory`
    or `StashOverflowException`, depending on the stash size. If messages are unstashed,
    the actor will not produce other incoming messages until all stashed bits are
    processed, which might make it unresponsive.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的stashing实现将消息缓冲在内存中，可能导致`OutOfMemory`或`StashOverflowException`，具体取决于stash的大小。如果消息被移除，actor将不会产生其他传入的消息，直到所有缓存的位都处理完毕，这可能会使其无响应。
- en: '**What is a preferred way to test actor logic in isolation?**'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在独立测试actor逻辑方面，有什么推荐的方法？**'
- en: Synchronous testing using BehaviorTestKit provides better possibilities to test
    actor logic in isolation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BehaviorTestKit提供的同步测试可以更好地测试actor逻辑的独立性。
- en: Chapter 13
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: '**Name two different modes associated with "classic" streams. Why are they
    problematic?**'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与“经典”流相关联的两个不同模式是什么？为什么它们有问题？**'
- en: The two modes are push and pull. Push is problematic in the case of a slow consumer
    because it can lead to dropped stream elements or memory overflow. Pull is suboptimal
    in the case of a slow producer because it can lead to blocking or extensive resource
    consumption.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式是推送和拉取。在消费者速度较慢的情况下，推送可能会导致流元素丢失或内存溢出。在生产者速度较慢的情况下，拉取可能不理想，因为它可能导致阻塞或大量资源消耗。
- en: '**Why are Reactive Streams considered to work in dynamic pull-push mode?**'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么Reactive Streams被认为是在动态拉-推模式下工作？**'
- en: Reactive Streams introduce the notion of non-blocking back pressure. The consumer
    reports the demand it has and the producer pushes data in batches according to
    this demand. When the consumer is faster, the demand is always there so the producer
    is always pushing data as soon as it is available. If there is a producer which
    is faster, there is always data available and the consumer just pulls it as soon
    as it has some demand. The flow automatically switches between these modes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams 引入了非阻塞背压的概念。消费者报告其需求，生产者根据这个需求批量推送数据。当消费者更快时，需求总是存在，因此生产者总是尽快推送数据。如果有一个比消费者更快的生产者，总是有数据可用，消费者一旦有需求就会立即拉取。流会自动在这些模式之间切换。
- en: '**What are the typical building blocks of Akka Stream''s graph?**'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Akka Stream 图的典型构建块是什么？**'
- en: A flow is a stage with exactly one input and one output. Fan-In has multiple
    inputs and one output. Fan-Out is the opposite with multiple outputs and one input.
    BidiFlow represents bi-directional flow with two inputs and two outputs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 流是一个具有一个输入和一个输出的阶段。Fan-In 有多个输入和一个输出。Fan-Out 是相反的，有多个输出和一个输入。BidiFlow 代表双向流，有两个输入和两个输出。
- en: '**How do you convert a graph into a runnable graph?**'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何将图转换为可运行的图？**'
- en: A graph can be connected into a runnable graph by connecting a source and a
    sink to it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将源和汇连接到图中，可以将一个图连接成一个可运行的图。
- en: '**What is the main goal of having materialization as a separate explicit step?**'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么将材料化作为一个独立的显式步骤的主要目标？**'
- en: Before the materialization step, any graph can be considered to be just a blueprint
    of the stream and hence can be freely shared and reused.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在材料化步骤之前，任何图都可以被视为流的蓝图，因此可以自由共享和重用。
- en: '**Describe the effects of applying different supervision strategies.**'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述应用不同监督策略的效果。**'
- en: There are three different supervision strategies.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的监督策略。
- en: Stop interrupts the stream in the failed processing stage. The failure propagates
    downstream and cancellation propagates upstream.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 停止中断失败的处理阶段的流。失败会向下传播，取消会向上传播。
- en: Resume drops the current element and continues streaming.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复丢弃当前元素并继续流处理。
- en: Restart drops the current element, cleans the internal state of the processing
    stage (usually by re-creating it), and continues steaming.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重启丢弃当前元素，清理处理阶段的内部状态（通常是通过重新创建它），并继续流处理。
- en: '**Which main abstractions provide Akka Streams TestKit? Why are they useful?**'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些主要抽象提供了 Akka Streams TestKit？为什么它们是有用的？**'
- en: Two main abstractions provided by Akka Streams TestKit are TestSink and TestSource.
    They allow the control and verification of assumptions about stream flow on different
    levels, for example, a high messaging level or low reactive-streams level. They
    also make it possible to use a nice DSL to drive the test and to formulate expectations
    about the outcomes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams TestKit 提供的两个主要抽象是 TestSink 和 TestSource。它们允许在不同级别上控制和验证关于流流的假设，例如，在高消息级别或低
    reactive-streams 级别。它们还使得可以使用一个漂亮的 DSL 来驱动测试，并形成关于结果期望。
- en: Chapter 14
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章
- en: '**What is a database migration?**'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是数据库迁移？**'
- en: The database migration  (or schema migration) is the automatic management of
    updates to the database schema. The changes to the schema are incremental, usually
    reversible, and applied in the moment the database schema needs to be changed
    in order to reflect changes in the application code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移（或模式迁移）是数据库模式更新的自动管理。模式更改是增量性的，通常是可逆的，并在数据库模式需要更改以反映应用程序代码更改的时刻应用。
- en: '**Describe what could be an alternative approach to discarding an order completely,
    in the case of insufficient stock for some articles? **'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述在库存不足的情况下，完全丢弃订单的替代方法可能是什么？**'
- en: One of the alternatives could be to satisfy orders for all articles for which
    there are sufficient stock. This could be implemented by running each inventory
    update in a separate transaction and combining the results of all of them that
    succeeded.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的替代方案是满足所有有足够库存的文章的订单。这可以通过在每个库存更新中运行单独的事务并组合所有成功的事务的结果来实现。
- en: Yet another alternative would be to satisfy orders as fully as possible. This
    approach would require selecting rows for update, calculating new possible states,
    and applying them in the same transaction.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的替代方案是尽可能满足订单。这种方法需要选择更新行，计算新的可能状态，并在同一事务中应用它们。
- en: '**Describe the conceptual difference between http4s and Akka HTTP in regard
    to defining routes.**'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述http4s和Akka HTTP在定义路由方面的概念差异。**'
- en: http4s defines routes as a partial function that pattern matches over the request.
    Akka HTTP route definition is constructed from nested directives. The requests
    follow the path through matching directives top-down.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: http4s将路由定义为部分函数，该函数通过请求进行模式匹配。Akka HTTP路由定义是由嵌套指令构建的。请求通过匹配指令自顶向下遍历路径。
- en: '**Can you name a reason why event-sourced data storage can scale better than
    a traditional relational database?**'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能说出为什么事件源数据存储可以比传统的关系型数据库扩展得更好吗？**'
- en: Concurrent updates require much more locking and synchronization than append-only
    operations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 并发更新比追加操作需要更多的锁定和同步。
- en: '**Implement a `GET /articles/:name` call with http4s and doobie.**'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用http4s和doobie实现`GET /articles/:name`调用。**'
- en: '1\. Add new route definition:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 添加新的路由定义：
- en: '`case GET -> Root / "articles" / name => renderInventory(repo.getArticle(name))`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`case GET -> Root / "articles" / name => renderInventory(repo.getArticle(name))`'
- en: '2\. Extend the repository `getArticle` method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 扩展`getArticle`方法：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See the source code in GitHub for the refactored version, which reuses the parameterless
    definition of `getInventory.`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上查看重构版本的源代码，该版本重用了`getInventory`的无参数定义。
- en: '**Implement the `GET /articles/:name` call with Akka HTTP and Akka Persistence.**'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Akka HTTP和Akka Persistence实现`GET /articles/:name`调用。**'
- en: '1\. Add a new query definition:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 添加新的查询定义：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '2\. Add a query handler in `InventoryActor`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在`InventoryActor`中添加查询处理器：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '3\. Add the route definition:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 添加路由定义：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The GitHub repository contains this route definition embedded in the previously
    defined `lazy val articlesRoutes: Route`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub仓库包含此路由定义，它嵌入在先前定义的`lazy val articlesRoutes: Route`中。'
- en: Chapter 15
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: '**How do you map the endpoint with the query parameter to a REST call?**'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何将带有查询参数的端点映射到REST调用？**'
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**What is the recommended serialization format for persistent entities?**'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**推荐用于持久化实体的序列化格式是什么？**'
- en: Lagom's recommended serialization format is JSON.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Lagom推荐使用JSON作为序列化格式。
- en: '**Can you explain why clustering is required in order to use persistence in
    Lagom?**'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能解释为什么在Lagom中使用持久化需要集群吗？**'
- en: Lagom's persistence is implemented on top of Akka persistence. Akka requires
    each persistent actor to have a unique persistence ID. In a microservice landscape,
    each service is supposed to have multiple instances at the same time. Without
    clustering, there will be multiple persistent actors with the same ID storing
    events into the same database, which will corrupt data. By utilizing clustering
    and cluster sharding, Akka makes sure there is only one persistent actor in the
    cluster across all instances of the service.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Lagom的持久化是在Akka持久化之上实现的。Akka要求每个持久化actor都有一个唯一的持久化ID。在微服务领域中，每个服务应该同时拥有多个实例。如果没有集群，将会有多个具有相同ID的持久化actor将事件存储到同一个数据库中，这将损坏数据。通过利用集群和集群分片，Akka确保在服务的所有实例中集群中只有一个持久化actor。
- en: '**Describe one possible data model that could be used to make the `Manager`
    to the persistent entity.**'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述一个可能的数据模型，该模型可用于将`Manager`转换为持久化实体。**'
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Outline an alternative way to implement the Baker service.**'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**概述实现Baker服务的另一种方法。**'
- en: The `Baker` service could also be implemented message passing style similar
    to the `Chef` service.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Baker`服务也可以实现类似于`Chef`服务的信息传递风格。'
- en: '**Can you identify a design bug in the current implementation of the Chef?**'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能识别出Chef当前实现中的设计缺陷吗？**'
- en: The `Chef` does not trigger mixing for unbalanced mixing events after recovery.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chef`在恢复后不会触发不平衡混合事件的混合。'
- en: '**The `Manager` implementation stores a number of cookies in memory and this
    number will be lost at the moment the service restarts. Can you name another reason
    why it is a bad idea to hold the number of cookies in a local variable?**'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`Manager`实现将多个cookie存储在内存中，而这个数字在服务重启的瞬间将会丢失。你能说出另一个为什么将cookie的数量保存在局部变量中不是一个好主意的原因吗？**'
- en: In a production environment, there will be multiple instances of the service
    running. Each of them will have its own internal state.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，将有多个服务实例运行。每个实例都将有自己的内部状态。
