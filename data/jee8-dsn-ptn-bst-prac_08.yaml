- en: Cloud-Native Application Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生应用程序模式
- en: In this chapter, we will explain cloud-native application patterns, looking
    at what a cloud-native application is and what its goals are. We will also show
    the patterns already described in previous chapters and new patterns that have
    emerged to address cloud-based applications. After reading this chapter, the reader
    will be able to understand the concepts and patterns that characterize a cloud
    architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释云原生应用程序模式，探讨云原生应用程序是什么以及其目标是什么。我们还将展示之前章节中描述的图案以及针对基于云的应用程序出现的新图案。阅读本章后，读者将能够理解表征云架构的概念和模式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Explaining the concept of cloud-native applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释云原生应用程序的概念
- en: Explaining the goals of a cloud application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释云应用程序的目标
- en: Explaining the cloud design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释云设计模式
- en: Explaining the concept of cloud-native applications
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释云原生应用程序的概念
- en: The cloud and its resources are increasingly becoming a part of life for businesses.
    In the past, cloud resources were used for solutions such as storage management,
    emails, documents, and photos. Nowadays, the deployment of enterprise applications
    in the cloud structure certainly points the way to be followed by companies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 云及其资源正越来越多地成为企业生活的一部分。在过去，云资源被用于存储管理、电子邮件、文档和照片等解决方案。如今，在云结构中部署企业应用程序无疑指明了公司应遵循的道路。
- en: The cloud has become one of the first strategies to consider when developing
    a business application. The big challenge here is to make this application use
    the features offered by the cloud, such as elasticity, scalability, and availability,
    for the benefit of the business.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 云已成为开发业务应用程序时首先考虑的策略之一。这里的重大挑战是使此应用程序使用云提供的功能，如弹性、可扩展性和可用性，以利于业务。
- en: To start off with, monolithic applications were migrated and deployed in the
    cloud. Some gains were achieved such as greater management and control, as well
    as availability. But what we really want is an application integrated with the
    capabilities offered by the cloud, that is, to leverage the cloud computing resources
    to better solve the business.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，单体应用程序被迁移并部署到云中。我们取得了一些成果，如更好的管理和控制，以及可用性。但我们真正想要的是与云提供的功能集成的应用程序，即利用云计算资源更好地解决业务问题。
- en: Then comes the cloud-native application, which is an application that uses the
    benefits and capabilities provided by the cloud. A set of design patterns is used
    for the development of this application. We'll look at some of the main design
    patterns used in cloud architecture in more detail later in the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是云原生应用程序，这是一种利用云提供的优势和能力的应用程序。该应用程序的开发使用了一套设计模式。我们将在本章后面更详细地探讨云架构中使用的某些主要设计模式。
- en: The cloud computing environment is basically elastic in the sense that computing
    resources are used and released according to demand. Consequently, scalability
    and availability are achieved with less complexity than they would be if the application
    were still under datacenter control.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算环境在基本意义上是弹性的，即计算资源根据需求使用和释放。因此，与数据中心控制下的应用程序相比，可扩展性和可用性以更少的复杂性实现。
- en: 'Based on the cloud-native computing foundation, the properties that guide a
    cloud-native application are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基于云原生计算基础，指导云原生应用程序的特性如下：
- en: '**Container-packaged**: The applications are executed in isolated units'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器封装**：应用程序在隔离单元中执行'
- en: '**Dynamically-managed**: There is a central orchestration that manages the
    applications, improving the use of the resources, and reducing operational costs'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态管理**：有一个中央编排来管理应用程序，提高资源利用率，并降低运营成本'
- en: '**Microservices-oriented**: Applications in the cloud are loosely-coupled'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向微服务**：云中的应用程序是松散耦合的'
- en: Hence, a cloud-native application has a strongly-distributed nature. This is
    because this application is deployed in the cloud, and these properties are satisfied.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，云原生应用程序具有高度分布的特性。这是因为该应用程序部署在云中，并且这些特性得到了满足。
- en: Explaining the goals of the cloud-native application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释云原生应用程序的目标
- en: 'Cloud design patterns aim to build secure, reliable applications available
    in the cloud. The following list will show these and other characteristics to
    be achieved by a cloud-native application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 云设计模式旨在构建安全、可靠的云应用程序。以下列表将展示云原生应用程序要实现的其他特征：
- en: '**Availability**: The time the application is up and running. What is desired
    is a non-stop operation of all the system''s functionalities.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：应用程序运行和运行的时间。所期望的是所有系统功能的持续运行。'
- en: '**Data management**: Data handled by an application is the building block of
    a cloud application. Data can be distributed or replicated across many servers
    (or clusters) to achieve scalability, availability, or even performance.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据管理**：应用程序处理的数据是云应用程序的基石。数据可以在多个服务器（或集群）之间分布或复制，以实现可伸缩性、可用性，甚至性能。'
- en: '**Messaging**: To increase scalability, services or applications in the cloud
    have low coupling and often communicate using asynchronous messaging.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递**：为了提高可伸缩性，云中的服务或应用程序具有低耦合性，并且通常使用异步消息进行通信。'
- en: '**Management and monitoring**: Because cloud applications run in remote environments,
    there must be a way to monitor non-functional property states—such as the use
    of computing resources—through logs and reports. Also, we must be able to deploy
    new implementations without having to stop the application (maintaining the availability
    characteristic).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理和监控**：由于云应用程序在远程环境中运行，必须有一种方法可以通过日志和报告来监控非功能性属性状态——例如计算资源的使用情况。此外，我们必须能够部署新的实现，而无需停止应用程序（保持可用性特性）。'
- en: '**Performance and scalability**: Maintains performance despite an increase
    in the use of computing resources and scaling of the application.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和可伸缩性**：即使在计算资源的使用和应用程序扩展增加的情况下，也能保持性能。'
- en: '**Resiliency**: A cloud application should be able to overcome a failure quickly.
    This issue is important for maintaining availability.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：云应用程序应该能够快速克服故障。这个问题对于保持可用性非常重要。'
- en: '**Security**: A cloud application exposes several of its elements to users
    and should be able to prevent attacks by malicious users or malicious programs.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：云应用程序向用户公开了其多个元素，应该能够防止恶意用户或恶意程序发起的攻击。'
- en: 'It is important here to note that there are some issues that should be taken
    into account when implementing a distributed application, and specifically a cloud-native
    application. These *fallacies of distributed computing* were made by L. Peter
    Deutsch and others at Sun Microsystems, describing false assumptions about distributed
    programming:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，在实现分布式应用程序，尤其是云原生应用程序时，有一些问题应该予以考虑。这些由L. Peter Deutsch和Sun Microsystems的其他人提出的“分布式计算谬误”描述了关于分布式编程的错误假设：
- en: The network is reliable
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络可靠
- en: Latency is zero
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟为零
- en: Bandwidth is infinite
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽无限
- en: The network is secure
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全
- en: Topology doesn't change
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑结构不改变
- en: There is one administrator
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一位管理员
- en: The transport cost is zero
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输成本为零
- en: The network is homogeneous
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络同质
- en: With the goals and challenges to be achieved by a cloud-native application on
    the one hand, and the difficulties that have always existed for the implementation
    of a distributed application on the other, we have launched the design pattern
    to solve the problems faced by a cloud-native application. As we progress, we
    will show the main design patterns used in the cloud architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，云原生应用程序要实现的目标和挑战，另一方面，分布式应用程序实现中一直存在的困难，我们推出了设计模式来解决云原生应用程序面临的问题。随着我们的进展，我们将展示在云架构中使用的的主要设计模式。
- en: Explaining the cloud design patterns
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释云设计模式
- en: 'Now that the cloud application concepts and its challenges are defined, let''s
    get straight to the point and talk about the design patterns used for the implementation
    of a cloud architecture:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然云应用程序的概念及其挑战已经定义，让我们直接进入正题，讨论用于实现云架构的设计模式：
- en: Composite application (microservices)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合应用程序（微服务）
- en: Abstraction
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Twelve-factor
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十二要素
- en: API Gateway
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关
- en: Service registry
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册表
- en: Config server
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器
- en: Circuit breaker
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路器
- en: Composite application (microservices)
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合应用程序（微服务）
- en: In [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml), *Microservice Patterns, *we
    demonstrated the advantages (and disadvantages) of decomposing an application
    into functions and taking several benefits from this pattern, always aiming at
    the application business. In that chapter, it was established that a microservice-based
    architecture is characterized by decomposing the application into small, functional,
    independent components with a well-defined communication interface that is loosely-coupled.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml)，《微服务模式》中，我们展示了将应用程序分解为函数的优势（以及劣势），并从中获得多方面的好处，始终以应用业务为目标。在该章中，确立了基于微服务的架构的特点，即通过将应用程序分解为小型、功能独立且具有良好定义的松散耦合通信接口的组件。
- en: Abstraction
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: This pattern states that the focus must be on what the client needs and not
    on the existing hardware structure. In this sense, the computational resources
    of the cloud are used on demand, which characterizes the elastic scalability.
    In this way, resources are seen in an abstract way and are changed according to
    the needs of the clients.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式指出，重点必须放在客户端的需求上，而不是现有的硬件结构上。从这个意义上说，云计算的计算资源是按需使用的，这体现了弹性可伸缩性。这样，资源以抽象的方式看待，并根据客户的需求进行改变。
- en: Twelve-factor
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十二要素
- en: The twelve-factor methodology is based on the twelve factors that guide the
    creation of a successful SaaS project. This technology was created during the
    development of Heroku, a cloud service platform (PaaS) that supports several programming
    languages, including Ruby, Java, Node.js, Scala, Clojure, Python, and PHP.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素方法基于指导创建成功SaaS项目的十二要素。这项技术是在Heroku的开发过程中创建的，Heroku是一个支持多种编程语言的云服务平台（PaaS），包括Ruby、Java、Node.js、Scala、Clojure、Python和PHP。
- en: 'The experience acquired during the development and support of SaaS applications
    was cataloged, that is, observations of the errors encountered, and solutions
    drawn up for the problems that occurred. As a consequence, the twelve-factor methodology
    was created, which is a set of guidelines that make it easier to develop cloud-based
    applications. For teaching purposes, here are some definitions—SaaS stands for
    *Software as a Service*, and PaaS stands for *Platform as a Service*. SaaS is
    best known to the end user as it has the highest growth rate in the market. The
    twelve factors are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和支持SaaS应用程序期间获得的经验被编目，即记录遇到的错误，并为出现的问题制定解决方案。因此，创建了十二要素方法，这是一套使开发基于云的应用程序更加容易的指南。为了教学目的，这里有一些定义——SaaS代表*软件即服务*，PaaS代表*平台即服务*。SaaS最广为人知，因为它在市场上的增长率最高。以下为十二要素：
- en: '**Code base**: One codebase is tracked in revision control, while many deploys'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码库**: 在版本控制中跟踪一个代码库，同时进行多次部署'
- en: '**Dependencies**: Explicitly declare and isolate dependencies'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**: 明确声明并隔离依赖项'
- en: '**Config**: Store config in the environment'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**: 在环境中存储配置'
- en: '**Backing services**: Treat backing services as attached resources'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份服务**: 将备份服务视为附加资源'
- en: '**Build, release, run**: Strictly separate the build and run stages'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建、发布、运行**: 严格分离构建和运行阶段'
- en: '**Processes**: Execute the app as one or more stateless processes'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**: 以一个或多个无状态进程执行应用程序'
- en: '**Port-binding**: Export services via port-binding'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口绑定**: 通过端口绑定导出服务'
- en: '**Concurrency**: Scale-out via the process model'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**: 通过进程模型进行扩展'
- en: '**Disposability**: Maximize robustness with a fast startup and graceful shutdown'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可丢弃性**: 通过快速启动和优雅关闭最大化鲁棒性'
- en: '**Dev/prod parity**: Keep development, staging, and production as similar as
    possible'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/生产一致性**: 尽可能保持开发、预发布和生产环境的相似性'
- en: '**Logs**: Treat logs as event streams'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**: 将日志视为事件流'
- en: '**Admin processes**: Run admin/management tasks as one-off processes'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理进程**: 将管理/管理任务作为一次性进程运行'
- en: Codebase
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码库
- en: A codebase is any single repository where the codes reside. There can only be
    one codebase per application. Several applications cannot share a same codebase
    in the twelve-factor methodology. In this case, a solution would be to refactor
    the shared code by generating libraries that would go into the project as dependencies.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库是指任何单一存储代码的仓库。每个应用程序只能有一个代码库。在十二要素方法中，多个应用程序不能共享相同的代码库。在这种情况下，一种解决方案是通过生成作为依赖项进入项目的库来重构共享代码。
- en: A codebase must be managed by a version control system (such as subversion or
    Git). Various deploys are generated from this codebase, each one for a different
    environment—development, staging, and production.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库必须由版本控制系统（如subversion或Git）进行管理。从这个代码库中生成各种部署，每个部署针对不同的环境——开发、预发布和生产。
- en: 'The developer has a version of the application (that is, a deploy) running
    in their local development environment:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在本地开发环境中运行应用程序的一个版本（即部署）：
- en: '![](img/752384bc-0ac1-4f32-8d70-8fd1591df823.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/752384bc-0ac1-4f32-8d70-8fd1591df823.png)'
- en: Dependencies
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'Every dependency that is used by the project must be declared and isolated
    from the code. In this case, we can use some package-management tools (such as
    Maven, grundle, and npm). As an example, the Maven tool is used for building and
    documenting projects. The dependencies are declared in the `pom.xml` file, where
    we can declare the project dependencies:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 项目使用的每个依赖项都必须声明，并且与代码隔离。在这种情况下，我们可以使用一些包管理工具（如Maven、grundle和npm）。例如，Maven工具用于构建和记录项目。依赖项在`pom.xml`文件中声明，我们可以声明项目依赖项：
- en: '![](img/86b2425c-a240-4065-8691-a1feca460ab0.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86b2425c-a240-4065-8691-a1feca460ab0.png)'
- en: Config
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'An application''s config is everything that varies between different deploys.
    It can be:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的配置是不同部署之间所有变化的配置。它可以包括：
- en: Hosts, ports, and credentials for database access
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库访问的主机、端口和凭证
- en: Database schema
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模式
- en: Cache settings
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存设置
- en: Hosts, ports, and credentials for accessing message queues
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问消息队列的主机、端口和凭证
- en: 'The twelve-factor method requires the separation of config from code. So, the
    config should never be in the code, because the configs may vary between deploys
    but the code does not. The practice of placing the config in files, such as Java
    properties, is not recommended by twelve-factor, as there is always the possibility
    of placing the same configuration data in different environments (an example is
    when a developer commits to the version-control repository with its own local
    configs). Another weakness is the security issue of these configuration files.
    The twelve-factor method recommends the use of environment variables that can
    be injected when deploying an application in a specific environment:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素方法要求将配置与代码分离。因此，配置永远不应该在代码中，因为配置可能在不同部署之间有所不同，但代码不会。十二要素方法不推荐将配置放在文件中，如Java属性文件，因为总有可能在不同环境中放置相同的配置数据（例如，当开发者在版本控制存储库中提交其本地配置时）。另一个弱点是这些配置文件的安全问题。十二要素方法建议使用环境变量，这些变量可以在部署应用程序到特定环境时注入：
- en: '![](img/2bb4c0a2-d2e6-478f-a67a-9b0009db5148.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2bb4c0a2-d2e6-478f-a67a-9b0009db5148.png)'
- en: Backing services
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后备服务
- en: Backing services are external services used by the application, such as a database,
    message service, file repository, or email service. The twelve-factor method considers
    each service that is external to the application as a resource. Each of these
    resources must be accessed via a URL or location and credentials attributes that
    are in the app's config. In this way, any changes to a service location—such as
    the database or file repository—does not impact the application code. The change
    becomes imperceptible to the code, resulting in a low desired coupling. We can
    also use abstractions or interfaces to access these services in addition to the
    app's config.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 后备服务是应用程序使用的外部服务，例如数据库、消息服务、文件存储库或电子邮件服务。十二要素方法将应用程序外部每个服务视为一种资源。这些资源必须通过URL或位置以及应用配置中的凭证属性来访问。这样，对服务位置（如数据库或文件存储库）的任何更改都不会影响应用程序代码。这种变化对代码来说是不可察觉的，从而实现了低耦合。我们还可以使用抽象或接口来访问这些服务，除了应用配置之外。
- en: As a first example, we have the file stored in a repository. Access to the repository
    can be executed via a URL, regardless of local or remote access (such as Amazon
    S3). For this, we use the app's config. Of course, the way to store files locally
    or remotely, in the last instance, may be different, but the use of an interface
    greatly improves this issue.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们有一个存储在存储库中的文件。无论本地还是远程访问（如Amazon S3），都可以通过URL访问存储库。为此，我们使用应用配置。当然，在最后实例中，存储文件本地或远程的方式可能不同，但使用接口可以极大地改善这个问题。
- en: 'As a second example, we have the use of a SQL database in different environments
    (production, staging, and development). We should only change the URL of the connection
    to the database using what is in the application''s config. This strategy should
    be extended to a possible change of database management systems, such as from
    MySQL to DB2\. Of course, we know that in practice, the use of specific mechanisms
    for a database can improve performance. However, the changes, if they happened,
    would be minimal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，我们有在不同环境中使用 SQL 数据库的情况（生产、预发布和开发）。我们应该只通过应用程序的配置来更改连接到数据库的 URL。这种策略应该扩展到数据库管理系统可能的变化，例如从
    MySQL 到 DB2。当然，我们知道在实践中，使用特定数据库的机制可以提高性能。然而，如果发生变化，这些变化将是微小的：
- en: '![](img/abe84a15-b5a3-40db-9c60-3bfbe15b2d55.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abe84a15-b5a3-40db-9c60-3bfbe15b2d55.png)'
- en: Build, release, run
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建、发布、运行
- en: 'The process of transforming a codebase into a given environment must be divided
    into three strictly separate stages:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码库转换为特定环境的过程必须分为三个严格独立的阶段：
- en: '**Build**: Compiles and generates an executable package; for example, generating
    an EAR or WAR archive.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：编译并生成可执行包；例如，生成 EAR 或 WAR 存档。'
- en: '**Release**: Applies the app''s config in the executable package. The resulting
    release, which is the combination of the package generated in the build with the
    app''s config, is ready to be scanned in the environment that contains the config.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：将应用程序的配置应用于可执行包。生成的发布，即构建过程中生成的包与应用程序配置的组合，已准备好在包含配置的环境中扫描。'
- en: '**Run** (or runtime): Initializes the application in the specific environment.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**（或运行时）：在特定环境中初始化应用程序。'
- en: 'The separation of these steps, that is, the definition of their responsibilities
    is important for improving system maintenance and automation. Continuous integration
    tools are used in these steps (Maven and Jenkins are examples of these tools):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤的分离，即定义它们的职责，对于提高系统维护和自动化非常重要。在这些步骤中使用了持续集成工具（Maven 和 Jenkins 是这些工具的例子）：
- en: '![](img/8adcda1d-cb5f-40af-88ba-2709a0b2c489.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8adcda1d-cb5f-40af-88ba-2709a0b2c489.png)'
- en: Processes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程
- en: The twelve-factor methodology emphasizes that all processes or components of
    the application must be stateless and share-nothing, that is, they should not
    store information. Therefore, in an application decomposed into microservices,
    each microservice must not store information in memory or use the server cache.
    This is an important factor for escalating an application. If there is a need
    to store some states between the requests, or some data to be used later, we can
    use a database.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 十二因素方法论强调，所有应用程序的过程或组件都必须是无状态的和无共享的，也就是说，它们不应该存储信息。因此，在分解为微服务应用程序中，每个微服务都不应该在内存中存储信息或使用服务器缓存。这是提升应用程序的一个重要因素。如果有在请求之间存储某些状态或稍后要使用的一些数据的需求，我们可以使用数据库。
- en: 'When we use memory to store information for later use in another request, we
    run a risk because the next request may be in a different process (or the request
    can even be processed by another server):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用内存来存储信息以供后续请求使用时，我们面临风险，因为下一个请求可能位于不同的进程（或者请求甚至可以由另一个服务器处理）：
- en: '![](img/fba60933-50a6-44b0-b6fc-c7be96679f0a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fba60933-50a6-44b0-b6fc-c7be96679f0a.png)'
- en: Port-binding
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口绑定
- en: A twelve-factor app is fully self-contained and does not depend on the use of
    an external server, such as Tomcat or Apache, to be exported as a service. A twelve-factor app
    must export the HTTP service by port-binding, meaning that the application also
    interfaces with the world via a URL. In this way, one application can be the backing
    service or external resource of another app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 十二因素应用程序是完全自包含的，不依赖于使用外部服务器（如 Tomcat 或 Apache）作为服务导出。十二因素应用程序必须通过端口绑定导出 HTTP
    服务，这意味着应用程序也通过 URL 与世界交互。这样，一个应用程序可以成为另一个应用程序的后端服务或外部资源。
- en: Concurrency
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: A twelve-factor app must be designed to scale using a process model that allows
    execution of the processes in parallel mode. This is much like the UNIX process
    model used when executing daemons. Consequently, we can design processes that
    only deal with HTTP requests while we can also have processes that deal with tasks
    that are very long and executed in the background. The process model shows its
    importance when the application needs to scale, because, at that moment, the application
    is replicated, making copies of the processes instead of executing a new instance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用必须设计成使用允许并行执行进程的进程模型来扩展。这就像在执行守护进程时使用的UNIX进程模型。因此，我们可以设计只处理HTTP请求的进程，同时也可以有处理非常长且在后台执行的任务的进程。当应用需要扩展时，进程模型显示出其重要性，因为此时应用被复制，而不是执行一个新实例。
- en: Disposability
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可丢弃性
- en: In the world of cloud computing, processes are constantly emerging and dying;
    this is exactly what causes escalation on-demand. In these conditions, the birth
    or origination of a process must be as fast as possible, and your interruption
    should be as fast, and have an as little impact, as possible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算的世界里，进程不断涌现和消亡；这正是导致按需扩展加剧的原因。在这些条件下，进程的诞生或起源必须尽可能快，你的中断应该尽可能快，并且影响尽可能小。
- en: The processes of a twelve-factor application are disposable, meaning that they
    can be initialized and stopped at any time. A process that ends without impact
    means that it should end gracefully, saving the state if necessary, and releasing
    the allocated computing resources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用的进程是可丢弃的，这意味着它们可以随时初始化和停止。一个没有造成影响的进程意味着它应该优雅地结束，如果需要的话保存状态，并释放分配的计算资源。
- en: Dev/prod parity
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发/生产一致性
- en: A twelve-factor app should keep the production, testing, and development environments
    in as similar a state as possible. This facilitates the process of continuous
    deployment, while avoiding possible errors generated when the builds are sent
    from the development environment to the production environment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用应尽可能保持生产、测试和开发环境的状态相似。这有助于持续部署的过程，同时避免在构建从开发环境发送到生产环境时可能产生的错误。
- en: Logs
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: The log of a twelve-factor app should be treated as an event stream. In a traditional
    environment, the log can be generated for a file. However, problems can arise,
    such as a lack of disk space. We know that in a cloud computing environment, where
    there is elastic scalability depending on demand, processes are born and die all
    the time. Likewise, machines and containers may no longer be used. Log files could
    get lost in this resizing in the cloud. Treating a log as an event stream is critical
    on a platform such as a cloud. In this way, logs can be directed anywhere. For
    example, they could be directed to a database in NoSQL, to another service, to
    a file in a repository, to a log-indexing-and-analysis system, or to a data-warehousing
    system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用的日志应被视为事件流。在传统环境中，日志可以生成一个文件。然而，可能会出现问题，例如磁盘空间不足。我们知道在云计算环境中，根据需求具有弹性可伸缩性，进程不断诞生和消亡。同样，机器和容器可能不再被使用。在云中的这种调整过程中，日志文件可能会丢失。在云平台上将日志视为事件流是至关重要的。这样，日志可以被导向任何地方。例如，它们可以被导向NoSQL数据库、另一个服务、存储库中的文件、日志索引和分析系统，或者数据仓库系统。
- en: Admin processes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理进程
- en: The twelve-factor method indicates that maintenance tasks, such as script execution
    for data migration, initial data loading, and cache cleaning, should be automated
    and performed on time. Because our application will run in multiple environments,
    and across multiple servers, it is necessary to use the same set of tools, software,
    and configuration files to perform these tasks. Consequently, parity problems
    between the different environments are reduced.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素方法指出，维护任务，如数据迁移的脚本执行、初始数据加载和缓存清理，应该自动化并在规定时间内执行。因为我们的应用将在多个环境中运行，并且跨越多个服务器，因此有必要使用相同的一套工具、软件和配置文件来执行这些任务。因此，不同环境之间的并行问题减少。
- en: The API Gateway
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关
- en: The decomposition of an application into small, intelligent, and well-defined
    components is an important design pattern in the world of cloud computing. These
    components are the microservices that bind the application business together.
    However, the control of these microservices, as seen in [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml),
    *Microservice Patterns*, is a complex task as the functionalities grow in the
    application history. One solution to this problem is called the **API ****Gateway**.
    As the API Gateway has already been explored in detail, in [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml), *Microservice
    Patterns,* we will only cover it briefly now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解成小型、智能且定义良好的组件是云计算领域中的一个重要设计模式。这些组件是绑定应用程序业务的微服务。然而，正如[第7章](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml)《微服务模式》中所述，随着应用程序历史中功能的增长，对这些微服务的控制变得复杂。解决这个问题的方法之一被称为**API网关**。由于API网关已经在[第7章](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml)《微服务模式》中进行了详细探讨，我们现在将只简要介绍它。
- en: 'The API Gateway serves as a frontend for cloud-application clients. Sometimes,
    the request is a simple call to a specific microservice, but often the API Gateway
    functions as a coarse-granulation layer that receives a request and performs several
    calls to microservices that are related to the required functionality. This issue
    is also related to the microservice aggregator pattern and the microservice proxy
    pattern. The API name comes exactly from the way that clients access the microservices,
    which is similar to the use of an API, as demonstrated in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: API网关作为云应用程序客户端的前端。有时，请求是对特定微服务的简单调用，但通常API网关作为一个粗粒度层接收请求并对与所需功能相关的微服务执行多个调用。这个问题也与微服务聚合器模式和微服务代理模式有关。API名称正好来自客户端访问微服务的方式，这与API的使用方式类似，如下面的图表所示：
- en: '![](img/18217b3a-9faf-41e3-ab00-5830c95e3ce8.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18217b3a-9faf-41e3-ab00-5830c95e3ce8.png)'
- en: 'Depending on the type of client in question, a given system''s functionality
    may sometimes work differently and the application may respond with different
    information. When calling a system service, a mobile client receives a smaller
    set of information than a web client (who uses a desktop computer). Taking this
    into account, there is an extension to the API Gateway. The extended API Gateway
    can provide a specific API for each type of client. In this way, a mobile client
    would access a mobile API, while a web client or a browser would access the web
    API:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所讨论的客户端类型，给定系统的功能有时可能有所不同，应用程序可能会以不同的信息响应。当调用系统服务时，移动客户端接收的信息集合比桌面计算机使用的Web客户端（浏览器）要小。考虑到这一点，API网关有一个扩展。扩展的API网关可以为每种类型的客户端提供特定的API。这样，移动客户端将访问移动API，而Web客户端或浏览器将访问Web
    API：
- en: '![](img/4a4ab591-6680-439f-a8e0-5618d8a7f32e.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a4ab591-6680-439f-a8e0-5618d8a7f32e.png)'
- en: The service-registry pattern
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册模式
- en: We know that microservices are exposed via access protocols such as HTTP/REST.
    This means that the services are accessed via a URL. However, we are in the cloud
    world, which has elastic scalability. The IPs of containers and virtual machines
    are dynamic and can change frequently. Consequently, the locations of services
    residing in these containers are also subject to change. As we have already said,
    instances of microservices are created and terminated constantly. Therefore, the
    following question arises—how can a client of a microservice handle this problem?
    The solution is to implement the service registry pattern. A service registry
    is a database of registered services. When a microservice is born, it is recorded
    on this database, and when it dies, it is unregistered from the database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道微服务通过HTTP/REST等访问协议暴露。这意味着服务通过URL访问。然而，我们处于具有弹性可伸缩性的云世界中。容器和虚拟机的IP地址是动态的，并且可以频繁更改。因此，驻留在这些容器中的服务的位置也可能会发生变化。正如我们之前所说，微服务的实例不断被创建和终止。因此，以下问题产生了——微服务的客户端如何处理这个问题？解决方案是实现服务注册模式。服务注册表是已注册服务的数据库。当微服务诞生时，它被记录在这个数据库上，当它死亡时，它从数据库中注销。
- en: 'A microservice client accesses the service registry that is responsible for
    knowing whether the microservice is available, as well as providing its location
    to the client. Let''s look at the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务客户端访问负责了解微服务是否可用的服务注册表，并为客户端提供其位置。让我们看一下以下图表：
- en: '![](img/e2e428b6-1304-40af-a0bb-db777f7e8721.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2e428b6-1304-40af-a0bb-db777f7e8721.png)'
- en: Config server
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器
- en: An application, whether in the cloud or not, has properties such as credentials
    and database location, application-specific information, and URLs for accessing
    external resources. For a traditional application, these properties are usually
    in a properties file. If we change a value of one of these properties, we must
    stop the application and restart the application container. This question becomes
    more critical when there are different environments, such as production, staging,
    and development. Each of these environments has their own configurations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序，无论是否在云中，都有诸如凭证和数据库位置、应用程序特定信息和访问外部资源的URL等属性。对于传统应用程序，这些属性通常位于属性文件中。如果我们更改这些属性中的一个的值，我们必须停止应用程序并重新启动应用程序容器。当存在不同的环境，如生产、预发布和开发时，这个问题变得更加关键。每个环境都有自己的配置。
- en: In the context of the cloud, microservices may be in different locations or
    servers. Let's assume that these properties are in the same microservice location.
    To change a property, we must locate the microservice, change the property, and
    restart the container. With a large number of microservices, this would be quite
    critical.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在云的背景下，微服务可能位于不同的位置或服务器上。让我们假设这些属性位于同一个微服务位置。要更改一个属性，我们必须定位微服务，更改属性，并重新启动容器。在大量微服务的情况下，这将会变得非常关键。
- en: To solve this problem, a layer called **cloud config server** has been introduced
    and its role is to manage the properties of the application based on microservices.
    This layer is responsible for maintaining these properties, and whenever any of
    these properties are changed, this change is reflected in the microservice (or
    application) without the need to rebuild or restart the service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，引入了一层名为**云配置服务器**的层，其作用是基于微服务管理应用程序的属性。这一层负责维护这些属性，并且每当这些属性中的任何一个发生变化时，这种变化都会在无需重建或重启服务的情况下反映到微服务（或应用程序）中。
- en: 'The config server is responsible for providing the properties for each registered
    microservice (service registry). When the config server initializes, the microservice
    properties are obtained from a path that was specified when the microservice was
    registered. The properties obtained are then stored in memory. This path is controlled
    by a version server (such as git or subversion). When a registered microservice
    is initialized, it goes to the config server and obtains the related properties.
    When there is a need to change a property of a microservice, we must go to the
    path in the config server, change the properties, and restart the config server,
    as can be seen in the following diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器负责为每个已注册的微服务（服务注册）提供属性。当配置服务器初始化时，微服务属性是从在微服务注册时指定的路径中获取的。获取到的属性随后存储在内存中。这个路径由版本服务器（如git或subversion）控制。当已注册的微服务初始化时，它会前往配置服务器并获取相关的属性。当需要更改微服务的属性时，我们必须前往配置服务器中的路径，更改属性，并重新启动配置服务器，如下面的图示所示：
- en: '![](img/939622c6-b678-4ed3-ad4d-4caa32f9083b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/939622c6-b678-4ed3-ad4d-4caa32f9083b.png)'
- en: The circuit-breaker pattern
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: In the cloud scenario with distributed systems, the probability of service failure
    exists for several reasons, such as a lack of connection or an unavailable service.
    The services created in the cloud must rely on this scenario and be prepared for
    fault-tolerance. This way, when a fault occurs, the reason for the fault will
    probably be fixed and the service will work again. However, there are situations
    where failures are caused by totally unexpected events and, even though the service
    tries to work again, it cannot. The situation is even more critical when there
    is timeout management.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有分布式系统的云场景中，由于连接不足或服务不可用等原因，存在服务失败的概率。在云中创建的服务必须依赖于这种场景，并准备好容错。这样，当出现故障时，故障的原因可能会得到修复，服务将再次工作。然而，也存在由于完全意想不到的事件导致的故障，尽管服务试图再次工作，但它无法做到。当存在超时管理时，这种情况变得更加关键。
- en: With very long waiting periods for situations in which the failure does not
    disappear within a reasonable period of time, computational resources remain blocked
    by the timeout time. Furthermore, as other requirements for the same service arrive,
    things get worse. Services that depend on this service (that is, waiting for the
    fault to end) are also inoperative, causing the problem to cascade. The solution
    to this problem is the implementation of the circuit-breaker pattern. A circuit-breaker
    pattern handles faults that take a long time to recover.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于失败在合理时间内未消失的情况，非常长的等待期会导致计算资源因超时时间而被阻塞。此外，当相同服务的其他要求到达时，情况变得更糟。依赖于该服务（即等待故障结束）的服务也处于不可操作状态，导致问题级联。解决这个问题的方法是实现断路器模式。断路器模式处理需要很长时间才能恢复的故障。
- en: The circuit-breaker pattern prevents an operation from repeatedly attempting
    to run in situations where it will likely fail during execution. In addition,
    this pattern checks to see whether the failure has been resolved. If it has been
    resolved, the proxy sends the request to the operation. If the operation fails,
    the failure counter is immediately incremented.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式防止操作在执行过程中可能失败的情况下反复尝试运行。此外，此模式检查失败是否已解决。如果已解决，代理将请求发送到操作。如果操作失败，失败计数器立即增加。
- en: The circuit-breaker mechanism
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器机制
- en: 'The circuit breaker functions as a proxy by routing the request to the operation
    or returning an exception immediately. The pattern has this name because its operation
    is similar to an electric circuit. This proxy has three distinct states, as demonstrated
    in the following diagram:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器通过将请求路由到操作或立即返回异常来充当代理。这个模式之所以叫这个名字，是因为它的操作类似于电路。这个代理有三个不同的状态，如下面的图所示：
- en: '**Closed**: The proxy sends the request to the operation. The proxy maintains
    a sequential counter of previous failures. If the execution of the operation fails,
    this counter is incremented. If the failure counter exceeds an established threshold,
    the proxy switches to an open state. However, at this point, a timer is started
    with a specified timeout time. The purpose of this is to cause the failure to
    be corrected during the timeout. When the timer expires, the proxy becomes half-open.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭状态**：代理将请求发送到操作。代理维护一个之前失败的顺序计数器。如果操作的执行失败，则该计数器增加。如果失败计数器超过设定的阈值，代理将切换到开启状态。然而，此时，启动一个具有指定超时时间的计时器。这样做的目的是在超时期间纠正失败。当计时器到期时，代理变为半开启状态。'
- en: '**Open**: When a request arrives, an exception is returned immediately.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开启状态**：当请求到达时，立即返回异常。'
- en: '**Half-open**: A limited number of requests are passed to the operation. If
    these requests succeed, the state changes to closed, and the failure counter is
    reset. If any request fails, the state changes to open and the timeout timer is
    restarted. The half-open state is important for avoiding a flood of requests to
    the operation in a short time.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开启状态**：将有限数量的请求传递到操作。如果这些请求成功，状态变为关闭，并且失败计数器重置。如果有任何请求失败，状态变为开启，并且重新启动超时计时器。半开启状态对于避免在短时间内向操作发送大量请求非常重要。'
- en: '![](img/35c7e123-1ede-47e3-b74b-edc98eb47401.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35c7e123-1ede-47e3-b74b-edc98eb47401.png)'
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explained the concept of cloud-native applications as well
    as the objectives and characteristics of a cloud application. We saw the main
    design patterns that aid in the construction of a cloud application. Among the
    main patterns, we reviewed the architecture of microservices and API Gateways.
    We also learned about the twelve-factor methodology, which helps in the implementation
    of a cloud application. Finally, we explored the service-registry patterns, which
    return the service location, the config server, which provides the necessary configurations
    to the microservices without the need to restart any containers, and the circuit
    breaker, a pattern that handles long-term failures.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了云原生应用程序的概念，以及云应用程序的目标和特性。我们看到了有助于构建云应用程序的主要设计模式。在主要模式中，我们回顾了微服务架构和API网关。我们还了解了十二要素方法，它有助于云应用程序的实施。最后，我们探讨了服务注册模式，它返回服务位置，配置服务器，为微服务提供必要的配置，而无需重新启动任何容器，以及断路器，这是一种处理长期故障的模式。
