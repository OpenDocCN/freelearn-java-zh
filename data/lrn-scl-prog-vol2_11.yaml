- en: Introduction to Akka
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka简介
- en: '"Technology is nothing. What''s important is that you have faith in people,
    that they''re good and smart, and if you give them tools, they''ll do wonderful
    things with them."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “技术什么都不是。重要的是你相信人们，相信他们是好的和聪明的，如果你给他们工具，他们会用它们做出奇妙的事情。”
- en: '- Steve Jobs'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 史蒂夫·乔布斯'
- en: As developers, we are used to facing programming problems and solving them using
    abstractions, programming models, or some design patterns. These programming models
    tend to make ours and consumer's lives easier. This chapter is about learning
    one such programming model that solves more than one problem. We'll understand
    and work with Akka, which is based on *Actor models*. We can think of Akka libraries
    (well mostly) as an open source set of libraries that help you write concurrent,
    fault tolerant, and distributed applications. We'll talk about what you might
    expect from this toolkit. As we go through the chapter, we'll try understanding
    the actor model and how these actors work together, as well as how the actor mechanism
    is different from any other concurrency mechanism.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们习惯于面对编程问题，并使用抽象、编程模型或某些设计模式来解决问题。这些编程模型往往使我们的生活和消费者的生活变得更轻松。本章将介绍一种解决多个问题的编程模型。我们将了解并使用基于*Actor模型*的Akka。我们可以将Akka库（好吧，大部分）视为一套开源库，帮助你编写并发、容错和分布式应用程序。我们将讨论从这个工具包中你可以期待什么。随着我们进入本章，我们将尝试理解actor模型以及这些actor如何协同工作，以及actor机制与其他任何并发机制的不同之处。
- en: 'Going through all the Akka libraries is outside of the scope of this chapter
    as well as the book, hence we''ll focus on understanding the actor system, which
    is the basis for any other library available within the Akka toolkit. This will
    enable us to use them when needed. In this chapter, we''ll be going through the
    following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章以及本书的范围不包括遍历所有Akka库，因此我们将专注于理解actor系统，这是Akka工具包中任何其他库的基础。这将使我们能够在需要时使用它们。在本章中，我们将讨论以下内容：
- en: Why do we care about Akka*?*
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么关心Akka*？
- en: What's up with the Actor model?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor模型有什么问题？
- en: Actors in practice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践中的Actor
- en: Supervising fault in our Actor*s*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督Actor*的故障
- en: Testing Actors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Actor
- en: So why do we care about another programming model? Let's find out.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们为什么还要关心另一种编程模型呢？让我们来探究一下。
- en: Why do we care about Akka?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么关心Akka？
- en: With a large amount of data all around us, our computer/processing systems are
    striving for performance. With multicore architecture and distributed computing,
    we are achieving high performance with acceptable availability of services. But
    this cannot be taken for granted; we have come to a point where we already have
    mechanisms to deal with problems that arise due to either incapability of systems
    or the programming models we are using.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们周围充斥着大量数据的情况下，我们的计算机/处理系统正在努力追求性能。通过多核架构和分布式计算，我们实现了可接受的服务可用性下的高性能。但这一点不能视为理所当然；我们已经到了一个已经拥有机制来处理由于系统或我们使用的编程模型的不完善而出现的问题的地步。
- en: Due to the advent of multicore architecture, our systems are capable of processing
    a large amount of data with high performance. But there is a fault in our programming
    models, which we use to mutate states, and at the same time use several threads
    to vary the states present in our programs. This has given us a reason to think.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多核架构的出现，我们的系统能够以高性能处理大量数据。但我们的编程模型中存在一个故障，我们使用它来改变状态，同时使用多个线程来改变程序中存在的状态。这给了我们思考的理由。
- en: Two or more threads trying to process a particular shared state might cause
    a *deadlock* (more on this in [Chapter 13](part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84),
    *Concurrent Programming in Scala*, where we discuss concurrency and threads in
    more detail) and your program may not even complete. But still, we are discussing
    the problem; nowhere do we see the solution. One way in which we can think of
    dealing with threads and problems is using some sort of locking mechanism so that
    two separate threads cannot access the same instance/state at the same time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或多个线程试图处理特定的共享状态可能会导致*死锁*（更多内容请参阅[第13章](part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84)，*Scala中的并发编程*，我们将更详细地讨论并发和线程），而且你的程序可能甚至无法完成。但尽管如此，我们仍在讨论这个问题；我们无处看到解决方案。我们可以考虑的一种处理线程和问题的方法是通过某种锁定机制，这样两个独立的线程就不能同时访问相同的实例/状态。
- en: But think of it this way, by introducing locks, we are making our operating
    systems interrupt/suspend the thread and restore it later to perform the same
    task. It's expecting more from your computer's CPU.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样想，通过引入锁，我们使操作系统中断/挂起线程，稍后恢复以执行相同任务。这要求你的计算机CPU承担更多。
- en: It means that without locks we are facing problems with states of our instances,
    and now with locks in place, the program's performance takes a hit. Now picture
    a multithreaded distributed environment; life's worse there.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在没有锁的情况下，我们面临着实例状态的难题，而现在有了锁，程序的性能受到了影响。现在想象一个多线程的分布式环境；那里的生活更糟糕。
- en: Also, the way we handle failures in multithreaded environments is not pleasing.
    Hence, what we need for handling these is a different mechanism altogether. In
    the case of Akka*,* we let entities interact via messages. We create entities
    in terms of Actors that communicate by passing messages to each other. You may
    compare this kind of communication to network communication where we depend on
    HTTP request-responses to perform the intended operation. Similarly, by encapsulating
    the state within Actor instances, we tend to pass immutable instances to another
    actor to perform some logic. That receiving actor, after applying/performing some
    logic, returns back a response. That's how we can build our systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在多线程环境中处理失败的方式并不令人满意。因此，我们需要一个不同的机制来处理这些问题。在Akka*的情况下，我们让实体通过消息进行交互。我们通过创建actors来创建实体，这些actors通过相互传递消息进行通信。你可以将这种通信方式与网络通信进行比较，在那里我们依赖于HTTP请求-响应来执行预期的操作。同样，通过在Actor实例中封装状态，我们倾向于将不可变实例传递给另一个actor以执行某些逻辑。接收消息的actor在应用/执行一些逻辑后返回响应。这就是我们构建系统的方式。
- en: 'Actor models have proven to be a highly effective solution. Akka provides this
    actor model and enforces a tree-like structure for actors. Some points to note
    down about actors:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Actor模型已被证明是一种非常有效的解决方案。Akka提供了这种actor模型，并为actors强制执行树状结构。关于actors的一些需要注意的点：
- en: By communicating via messages, we omit the possibility of corrupting the state
    for a particular instance
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过通过消息进行通信，我们排除了对特定实例状态进行破坏的可能性
- en: Because one actor can process one message at a time, we avoid the deadlock situation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于一个actor一次只能处理一条消息，我们避免了死锁的情况
- en: With a hierarchy in place, it's easier to form a domain logic
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在建立层次结构后，形成领域逻辑更容易
- en: The parent-child relationship between two actors makes it possible for us to
    handle faulty behavior; in Akka terminology, we call it a *supervision strategy*
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个actors之间的父子关系使我们能够处理错误行为；在Akka术语中，我们称之为*监督策略*
- en: We'll go through the way *actors* communicate and how messages are ordered/stored
    and executed. First, let's try to understand the *Actor Model*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨actors如何通信以及消息是如何排序/存储和执行的。首先，让我们尝试理解*Actor模型*。
- en: What's up with the Actor Model?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有关Actor模型的问题是什么？
- en: 'From our discussion, it''s clear that we have some entities that act on receipt
    of some messages, or let''s say requests. We call them Actors*.* To solve some
    domain-specific problems, we might want to have more than one Actor*.* Think of
    a basic scenario of e-commerce checkout flow. There''s more than one area of concern.
    The following diagram represents the basic intended flow:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的讨论中可以看出，我们有一些实体在接收到某些消息或请求时采取行动。我们称它们为Actors*。为了解决某些特定领域的问题，我们可能需要多个Actors*。考虑一个基本的电子商务结账流程场景。有多个关注点。以下图表表示了基本预期的流程：
- en: '![](img/00040.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.jpeg)'
- en: 'By taking a look at the diagram, it''s clear that we have few entities, and
    these entities are going to take care of specific concerns. We have named these
    entities based on their area of concern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看图表，很明显我们有一些实体，这些实体将负责特定的关注点。我们根据它们的关注点命名这些实体：
- en: '**CheckoutActor** might have the responsibility to fetch details from the cart
    and show the respective information.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CheckoutActor**可能负责从购物车中获取详细信息并显示相应的信息。'
- en: Additionally, you might want to apply some coupon code or offer. Our system
    has to validate that coupon or offer code and based on that we might want to modify
    order details. For this particular process, we have **HandleOffersActor***.*
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你可能想要应用一些优惠券代码或优惠。我们的系统必须验证该优惠券或优惠代码，并根据此可能修改订单详情。对于这个特定的过程，我们使用**HandleOffersActor***.*
- en: '**ShippingActor** has the responsibility of fetching user-specific information
    such as address, and based on that we can calculate the estimated time for shipping.
    It''s important to note that **ShippingActor** is not restricted to process the
    whole logic within, and can call another child actor named **UserInfoActor***,*
    which does nothing but to fetch a user''s information. Another point to note is
    that the operation of fetching user information is so general that this Actor might
    be useful outside this particular hierarchy.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ShippingActor**负责获取用户特定的信息，例如地址，根据这些信息我们可以计算出预计的运输时间。需要注意的是，**ShippingActor**不仅限于在内部处理整个逻辑，还可以调用另一个名为**UserInfoActor**的子演员，该演员除了获取用户信息外不做任何事情。另一个需要注意的点是，获取用户信息的操作非常通用，这个演员可能在这个特定的层次结构之外也很有用。'
- en: After shipping details are in place, we might want to redirect a user to a payment
    page, where we can perform payment-specific logic. For that, we have **PaymentsActor***.*
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发货详情就绪后，我们可能希望将用户重定向到支付页面，在那里我们可以执行支付特定的逻辑。为此，我们有一个**PaymentsActor**。
- en: Finally, based on the payment's success or failure, we might want to handle
    orders. For example, upon successful payment, we want to proceed to ordering,
    and in case of failure we might want to send an email to the user stating that
    they process payment again! For this purpose, we have **HandleNewOrdersActor***.*
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，根据支付的成功或失败，我们可能想要处理订单。例如，在支付成功的情况下，我们想要进行订购，而在失败的情况下，我们可能想要发送一封电子邮件给用户，说明他们需要再次处理支付！为此，我们有一个**HandleNewOrdersActor**。
- en: In the whole scenario, we can see that the whole flow makes a hierarchy of actors.
    Let's say **ShippingActor** fails to provide user information from the database,
    due to network/connection issues. Now it's up to us as to how we want to deal
    with that. Similarly, upon **PaymentsActor** failure, it's up to the business
    to make a decision about what to do next. It could be to proceed and take orders
    with payment status pending and payment method on delivery or to ask the user
    to retry. So, handling such scenarios is easier when you have your entities in
    a hierarchical manner, performing logic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个场景中，我们可以看到整个流程形成了一个演员的层次结构。假设**ShippingActor**由于网络/连接问题无法从数据库中提供用户信息，现在取决于我们如何处理这种情况。同样，在**PaymentsActor**失败的情况下，业务将决定下一步做什么。这可能是在支付状态挂起和支付方式为货到付款的情况下继续处理订单，或者要求用户重试。因此，当你的实体以层次结构的方式执行逻辑时，处理此类场景会更容易。
- en: In this simple scenario, we understood that these actors form a hierarchy, or
    let's call it a group, and live within a system; in Akka terminology, we call
    it an **ActorSystem**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的场景中，我们了解到这些演员形成了一个层次结构，或者让我们称之为一个组，并生活在系统中；在 Akka 术语中，我们称之为**ActorSystem**。
- en: Understanding the Actor system
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解演员系统
- en: Akka documentation simply explains an **ActorSystem** as a heavyweight structure
    that will allocate 1 to N threads, and we should create one per *logical* application.
    Once we create an actor system, we get the license to create actors under that
    system. We'll take a look at how we can create Actors in the next sections*.*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 文档简单地解释**ActorSystem**为一个重量级结构，它将分配 1 到 N 个线程，我们应该为每个**逻辑**应用程序创建一个。一旦我们创建了一个演员系统，我们就获得了在该系统下创建演员的许可。我们将在下一节中看看我们如何创建演员。
- en: When we create actors as part of a system, these actors share the same configuration
    (such as *dispatchers, paths,* and *addresses)* as the Actor system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将演员作为系统的一部分创建时，这些演员与演员系统共享相同的配置（例如**调度器、路径**和**地址**）。
- en: Within an Actor system, there's a **root guardian** Actor; this serves as a
    parent actor to all actors residing within an actor system, internal actors, as
    well actors that we create. So, as expected, this is the last actor to be stopped
    when the system terminates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个演员系统中，有一个**根守护者**演员；这个演员作为所有居住在演员系统中的演员的父演员，包括内部演员以及我们创建的演员。因此，正如预期的那样，这是系统终止时最后停止的演员。
- en: The reason why Akka provides these guardian actors is to supervise the first-level
    actors we create, so for user created actors too, we have a specific **user guardian**.
    Similarly, for system provided actors, Akka has system guardian.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 提供这些守护者演员的原因是为了监督我们创建的一级演员，因此对于用户创建的演员来说，我们也有一个特定的**用户守护者**。同样，对于系统提供的演员，Akka
    有系统守护者。
- en: 'Take a look at the following diagram to understand the hierarchy of guardian
    actors in the Akka system:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表以了解 Akka 系统中守护者演员的层次结构：
- en: '![](img/00041.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: 'In the previous diagram, we can see there''s a path representation of each
    actor specified:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到每个指定的actor的路径表示：
- en: '**root guardian**: `/`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根守护者**: `/`'
- en: '**user guardian**: `/user`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户守护者**: `/user`'
- en: '**system guardian**: `/system`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统守护者**: `/system`'
- en: 'So, whenever we create an actor within an Actor system, we tend to create a
    first-level. Hence, in the example shown in the diagram, we can see that the actor''s
    path is appended to `/user`*,* in our case it is the `SimpleActor`*,* hence the
    path formed is `/user/simpleActor`*.* With an Actor system defined as `system`*,*
    for creating these *first-level* (more on this in the next few sections) actors,
    we use:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们在Actor系统中创建Actor时，我们倾向于创建一个第一级。因此，在图中显示的示例中，我们可以看到Actor的路径附加到`/user`*，在我们的例子中是`SimpleActor`*，因此形成的路径是`/user/simpleActor`*.*
    对于定义了为`system`*的Actor系统，为了创建这些*第一级*（更多内容将在下一节中介绍）Actor，我们使用：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll try out creating an actor ourselves in subsequent sections, but for
    now it''s worth nothing the way we called an `actorOf` method on `system` to create
    a *first-level* Actor. From here, we can create child Actors for our first-level
    Actor. And for that purpose, we use `context` instead of a `system` instance.
    It''ll look as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中尝试自己创建Actor，但就目前而言，值得注意的是我们如何调用`system`上的`actorOf`方法来创建一个*第一级*Actor。从这里，我们可以为我们的第一级Actor创建子Actor。为此，我们使用`context`而不是`system`实例。它看起来如下：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, by using `context` instead of `system`*,* we are specifying that the
    actor that we want to create is going to be in the context of the current Actor,
    making it a child actor. It''s important to notice that this call to the following
    definition can only be made from within an Actor. So, with this method call, we
    get a child Actor for our `simpleActor`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过使用`context`而不是`system`*，我们指定我们想要创建的Actor将处于当前Actor的上下文中，使其成为一个子Actor。重要的是要注意，这个调用只能从Actor内部进行。因此，通过这个方法调用，我们为`simpleActor`获得一个子Actor：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Assuming that the call was made from `SimpleActor` and `SimpleActor` is the
    first-level actor, our `anotherSimpleActor` path may look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设调用是从`SimpleActor`发出的，并且`SimpleActor`是第一级Actor，我们的`anotherSimpleActor`路径可能看起来像这样：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have seen the child actor path, it''s obvious that path for our
    `simple-actor` will be:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了子Actor的路径，很明显，我们的`simple-actor`的路径将是：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Also, a few points worth noting are the usage of `Props` and the return type
    of the `actorOf` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些值得注意的点，包括`Props`的使用以及`actorOf`方法的返回类型。
- en: Props
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Props
- en: '`Props` can be seen as a configuration object for `ActorRef`*.* We can create
    instances of the props configuration with some configuration. The following is
    an example of that:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Props`可以看作是`ActorRef`*的配置对象。我们可以使用一些配置来创建props配置的实例。以下是一个例子：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One important thing to know about the `Props` object is that it is immutable
    and hence thread-safe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Props`对象的一个重要事实是它是不可变的，因此是线程安全的。
- en: Actor references and paths
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor引用和路径
- en: When we create an Actor*,* what we get in response is an `ActorRef`*.* This
    is a reference to our created Actor*.* Why we might need an `ActorRef` is to pass
    throughout the system to other actors as a reference. These references are used
    for message passing. Every actor that we create has a reference to itself through
    self.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个Actor*时，我们得到的响应是一个`ActorRef`*.* 这是对我们创建的Actor*的引用。我们可能需要`ActorRef`的原因是将其作为引用在整个系统中传递给其他Actor。这些引用用于消息传递。我们创建的每个Actor都通过`self`拥有对自己引用。
- en: From within an actor, it's possible to obtain an *actor reference* of the calling
    Actor via a method named `sender()`*.*
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Actor内部，可以通过名为`sender()`*的方法获取调用Actor的*actor引用*。
- en: We can also give names to actor references. In our case, we named our `SimpleActor`
    reference `simple-actor:`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以给actor引用命名。在我们的例子中，我们给我们的`SimpleActor`引用命名为`simple-actor:`
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also know that these Actors are created in a hierarchical fashion and we
    can give unique names to *actor instances.* Hence, these names together make a
    path for each Actor. The path is unique for each Actor. Our `SimpleActor` path
    might look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道这些Actor是以分层的方式创建的，我们可以为*actor实例*赋予唯一的名称。因此，这些名称共同为每个Actor形成一个路径。路径对每个Actor是唯一的。我们的`SimpleActor`路径可能看起来像这样：
- en: '![](img/00042.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00042.jpeg)'
- en: We can see that due to the hierarchy, we have paths for different actors, because
    actors must have unique names. We can also see that regardless of your actor being
    created on a remote network, its path is going to have the same structure along
    with host and port.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由于层次结构，我们有不同actor的路径，因为actor必须具有唯一的名称。我们还可以看到，无论你的actor是在远程网络上创建的，其路径都将具有相同的结构，包括主机和端口。
- en: Selecting existing actorRefs via actorSelection
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过actorSelection选择现有的actorRefs
- en: Due to every actor having its own unique ID, we can refer to a particular actor
    via its path using the `actorSelection` method. We can call the `actorSelection` method
    on `system` or `context` and get the `ActorRef`*.*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个actor都有一个唯一的ID，我们可以通过`actorSelection`方法通过其路径引用特定的actor。我们可以在`system`或`context`上调用`actorSelection`方法并获取`ActorRef`*.*
- en: When we call `actorSelection` on `system`*,* we need to pass the absolute Actor
    path starting from root, whereas while calling the same on `context`*,* we can
    pass the path relative to the current Actor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`system`*上调用`actorSelection`时，我们需要传递从根开始的绝对Actor路径，而当我们对`context`*调用相同的操作时，我们可以传递相对于当前Actor的路径。
- en: 'Assuming the current Actor (first-level Actor) has a `SiblingActor`*,* at the
    same level, we may refer to the sibling Actor''s actor reference as:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当前Actor（第一级Actor）在同一级别有一个`SiblingActor`*，*，我们可以将兄弟Actor的actor引用称为：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In these two approaches, the first one used to represent the parent Actor*.*
    The other approach directly referred to the Actor''s path. With this, we were
    able to get the actor references, but it''s discouraged because we might not want
    to write actor paths explicitly. We can leverage use of `actorSelection`*, *when
    suppose we want to make use of a wildcard (*), that is, to send messages to all
    the actors below a certain (*) level in hierarchy. The following diagram will
    clear what we mean by that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种方法中，第一种用于表示父Actor*.*另一种方法直接引用Actor的路径。通过这种方式，我们能够获取actor引用，但这种方法是不推荐的，因为我们可能不想明确地编写actor路径。当我们假设想要使用通配符(*)时，我们可以利用`actorSelection`*，*，即向层次结构中某个(*)级别以下的所有actor发送消息。以下图表将清楚地说明我们的意思：
- en: '![](img/00043.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: 'Here, in previous diagram, by providing the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在之前的图表中，通过提供以下代码：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can obtain the reference, that point to all the `LogicAActor` parameters
    in previously mentioned hierarchy. Also it's worth knowing that a call to the
    `actorOf` method creates an actor on the context or system, depending upon which
    it's invoked. Whereas a call to `actorSelection` does not create any new actors,
    it points to `actorpath` which we pass, and doesn't ensure actor's existence there.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取引用，这些引用指向之前提到的层次结构中所有`LogicAActor`参数。还值得注意的是，对`actorOf`方法的调用根据其被调用的上下文在上下文或系统中创建actor。而`actorSelection`的调用不会创建任何新的actor，它指向我们传递的`actorpath`，并不确保actor在那里存在。
- en: Now that we have gone through simple entities in an Actor system, let's try
    and understand how the Actor life cycle works and what approaches we might want
    to choose to kill an actor instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Actor系统中的简单实体，让我们尝试理解Actor的生命周期是如何工作的，以及我们可能想要选择哪些方法来终止actor实例。
- en: How the Actor life cycle works
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor生命周期是如何工作的
- en: When we make a call to method `actorOf`*,* what we get in return is an `ActorRef`that
    in turn also possesses a particular path where we've created the Actor*.* With
    this call, we know exactly there's an Actor instance created, been assigned a
    unique ID, and hook methods are called. There's this method named `preStart()` that
    gets called as the very first action, after a new Actor is created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用方法`actorOf`*时，我们得到的返回值是一个`ActorRef`，它反过来也拥有我们创建Actor的特定路径。通过这个调用，我们知道确实创建了一个Actor实例，分配了唯一的ID，并调用了钩子方法。有一个名为`preStart()`的方法，它在创建新的Actor后作为第一个动作被调用。
- en: 'A few points to note when a new Actor is created:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的Actor时需要注意以下几点：
- en: A new Actor path is reserved for the Actor
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Actor预留一个新的Actor路径
- en: A unique ID is assigned to the Actor
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor会被分配一个唯一的ID
- en: 'After the instance is created, the `preStart()` method is called:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例创建后，会调用`preStart()`方法：
- en: '![](img/00044.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: 'When an Actor is restarted:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当Actor重启时：
- en: The `preRestart()` is called on the instance.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例上调用`preRestart()`。
- en: New instance is created, replaces the old instance.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新实例，替换旧实例。
- en: The `postRestart()` method is called.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`postRestart()`方法。
- en: 'When an Actor is stopped:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当Actor停止时：
- en: The `postStop()` method is called on the instance.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例上调用`postStop()`方法。
- en: Terminated message is sent to watchers.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向观察者发送终止消息。
- en: Actor path is allowed to be used again.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Actor路径允许再次使用。
- en: The previous diagram illustrates this whole cycle. An important point to note
    is that we get these hook methods in the form of `preStart`, `preRestart`, `postStop`, and `postRestart`.
    Using these methods, we can define some logic as required.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示说明了整个周期。一个需要注意的重要点是，我们以`preStart`、`preRestart`、`postStop`和`postRestart`的形式获得这些钩子方法。使用这些方法，我们可以根据需要定义一些逻辑。
- en: So, now that we're aware of the actor model and have also discussed that Actors
    communicate via messages, let's practice them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经了解了actor模型，并且也讨论了actor通过消息进行通信，让我们来实践一下。
- en: Hello world in Akka
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka中的Hello world
- en: For writing our first Akka actor, we need to add the `akka-actor` library dependency.
    For dependency management we'll be using SBT and, as we know, we'll be defining
    these library dependencies in our `build.sbt` file. To do this, we need to have
    SBT installed on our system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的第一个Akka actor，我们需要添加`akka-actor`库依赖。对于依赖管理，我们将使用SBT，并且正如我们所知，我们将在`build.sbt`文件中定义这些库依赖。为此，我们需要在我们的系统上安装SBT。
- en: Setting up the environment
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'To get started with a simple Akka project, we can simply follow these steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始一个简单的Akka项目，我们可以简单地遵循以下步骤：
- en: 'Go to Lightbend''s **TECH HUB** ([https://developer.lightbend.com](https://developer.lightbend.com))
    and click on START A PROJECT:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Lightbend的**TECH HUB**（[https://developer.lightbend.com](https://developer.lightbend.com)）并点击START
    A PROJECT：
- en: '![](img/00045.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00045.jpeg)'
- en: 'Search for **Akka Quickstart** Scala under Akka projects:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Akka项目下搜索**Akka Quickstart** Scala。
- en: '![](img/00046.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00046.jpeg)'
- en: 'Click on CREATE A PROJECT FOR ME!:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '点击 CREATE A PROJECT FOR ME!:'
- en: '![](img/00047.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00047.jpeg)'
- en: Extract the downloaded ZIP (compressed) file.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取下载的ZIP（压缩）文件。
- en: 'We can open the extracted folder in **IntelliJ IDEA** IDE:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**IntelliJ IDEA** IDE中打开提取的文件夹：
- en: Open IntelliJ IDE.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IntelliJ IDE。
- en: 'Click on File | New | Project from Existing Sources...:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '点击 File | New | Project from Existing Sources...:'
- en: '![](img/00048.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00048.jpeg)'
- en: 'Choose the `build.sbt` from the project (`akka-quickstart-scala`) we''ve just
    extracted:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们刚刚提取的项目（`akka-quickstart-scala`）中选择`build.sbt`：
- en: '![](img/00049.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00049.jpeg)'
- en: 'And you get the project open in the IntelliJ window:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后您可以在IntelliJ窗口中打开项目：
- en: '![](img/00050.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00050.jpeg)'
- en: This is one way of starting with an Akka project. This project has already defined
    all the `akka-actors` specific dependencies. We don't have to define them on their
    own. But we would like to start by taking the first step ourselves hence let's
    start with a bootstrapped `sbt-scala` project and define library dependencies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种开始Akka项目的方法。该项目已经定义了所有`akka-actors`特定的依赖项。我们不必单独定义它们。但我们都想从自己迈出的第一步开始，因此让我们从一个自引导的`sbt-scala`项目开始并定义库依赖项。
- en: 'We can take some steps to do that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取一些步骤来实现这一点：
- en: Open your favorite command line (Command prompt in Windows/Terminal in Linux
    and macOS), and go to the desired directory where you want to locate the project.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的命令行（Windows中的命令提示符/Linux和macOS中的终端），并进入您想要定位项目的目标目录。
- en: 'Give the command `sbt new sbt/scala-seed.g8`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入命令`sbt new sbt/scala-seed.g8`：
- en: '![](img/00051.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00051.jpeg)'
- en: 'Command prompt will ask for the name of the project. Give a name to it:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令提示符将询问项目的名称。给它起一个名字：
- en: '![](img/00052.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00052.jpeg)'
- en: The command will generate the Scala seed project for us. We can follow *Steps
    1* to *3* to open the **Acala** seed project in IntelliJ IDE.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令将为我们生成Scala种子项目。我们可以按照*步骤1*到*3*在IntelliJ IDE中打开**Acala**种子项目。
- en: 'Open the `build.sbt` file. The file might look like this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`build.sbt`文件。文件可能看起来像这样：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This file specifies that we have a root project in the current directory named
    `Hello`*.* Along with that, we have given some version-specific information, and
    the final line specifies that we currently have one `libraryDependency`*,* that
    is, `scala-test`*.* This value comes from the `Dependencies.scala` file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件指定我们在当前目录中有一个名为`Hello`的根项目。除此之外，我们还提供了一些特定版本的详细信息，最后一行指定我们目前有一个`libraryDependency`，即`scala-test`。此值来自`Dependencies.scala`文件。
- en: 'We''ll define `akka-actors` specific dependencies in this `build.sbt` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本`build.sbt`文件中定义`akka-actors`特定的依赖项：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this, we would use the `sbt update` command for updating libraries, and
    give a command in the current project directory using `cmd/terminal`*.*
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用`sbt update`命令来更新库，并在当前项目目录中使用`cmd/terminal`输入命令。
- en: With these steps, we're ready to write our first Akka actor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们就可以编写我们的第一个Akka actor了。
- en: Writing our first Actor
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个Actor
- en: 'Writing an Actor is as simple as writing a class that extends the `akka.actor.Actor`
    class. And we know that Actors respond to messages, so to identify messages, we
    have a method named `receive` that we have to define for each Actor we write.
    Let''s write our `SimpleActor`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Actor就像编写一个扩展了`akka.actor.Actor`类的类一样简单。我们知道Actor会响应消息，因此为了识别消息，我们有一个名为`receive`的方法，我们必须为每个我们编写的Actor定义它。让我们编写我们的`SimpleActor`：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, we wrote the `SimpleActor` with some empty behavior defined in the `receive`
    method. But here we''ve just wrote our Actor; we have to instantiate the Actor
    as part of an Actor system*.* After instantiating, we might also want to run our
    application to see the behavior, hence, let''s write the entry point to our application
    and instantiate an Actor system:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们编写了`SimpleActor`，在`receive`方法中定义了一些空的行为。但在这里，我们只是编写了我们的Actor；我们必须将Actor实例化作为Actor系统的一部分。实例化后，我们可能还想运行我们的应用程序来查看行为，因此，让我们编写应用程序的入口点并实例化一个Actor系统：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This statement gives us an instance for an Actor system with the name `SimpleActorSystem`.
    Now, we want to create an instance of our `SimpleActor` as a top (first) level
    actor, hence we''ll use the `simpleActorSystem.actorOf` method available:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句为我们提供了一个名为`SimpleActorSystem`的Actor系统的实例。现在，我们想要创建一个我们的`SimpleActor`实例作为顶级（第一级）actor，因此我们将使用可用的`simpleActorSystem.actorOf`方法：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Right now we have an Actor system available, and we have created an Actor instance.
    It is to be noted that by convention, we''ve created a companion object for our
    Actor class and defined its `props` value in it. We can also name our actor by
    giving an extra argument as a string:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们有一个可用的Actor系统，并且我们已经创建了一个Actor实例。需要注意的是，按照惯例，我们为我们的Actor类创建了一个伴生对象，并在其中定义了它的`props`值。我们也可以通过提供一个额外的字符串参数来命名我们的actor：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This line gives our actor a `namesimple-actor`*.* For now, the behavior defined
    for our Actor is empty*.* We would like to define a `receive` method for our actor.
    Let's think, what's the simplest thing our actor can do? It may be to call any
    public finance API to give us stock information or to call any API to perform
    currency conversion; that's up to us. For this example scenario, we'll call our
    `football.csv` file to fetch and show information to the user. Lets see how this
    can work using actors.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码给我们的actor分配了一个`namesimple-actor`标识符。现在，我们为我们的Actor定义的行为是空的。我们希望为我们的actor定义一个`receive`方法。让我们思考，我们的actor能做的最简单的事情是什么？可能是调用任何公共金融API来提供股票信息，或者调用任何API来执行货币转换；这取决于我们。在这个示例场景中，我们将调用我们的`football.csv`文件来获取并展示给用户信息。让我们看看如何使用actors来实现这一点。
- en: 'First, let''s define some utility methods we might need to perform, parsing
    from string response to `Players` data. We have this case class for `Players`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一些我们可能需要的实用方法，用于将字符串响应解析为`Players`数据。我们有这个`Players`的case类：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We defined two utility methods named `bufferedSourceToList` and `asPlayers`*;* these
    methods do what they say. So, let''s now define our `SimpleActor` receive method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个名为`bufferedSourceToList`和`asPlayers`的实用方法；这些方法做了它们所说的。因此，现在让我们定义我们的`SimpleActor`的`receive`方法：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have defined the receive methods, or let's say `SimpleActor` method's behavior,
    for a particular request such as `ShowFootballPlayersRequest`*.* The request itself
    contains the required information to fetch the information from the URI for the
    file. We defined this request as a final case class in the companion object of
    `SimpleActor`*.* This conventional approach specifies the requests our actor supports.
    On receipt of such a request for players information, our actor fetches information
    from the file at the location specified, and then it prints the player's information.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为特定的请求，如`ShowFootballPlayersRequest`，定义了接收方法，或者说`SimpleActor`方法的特定行为。请求本身包含了从URI获取信息的所需信息。我们在`SimpleActor`的伴生对象中定义了这个请求，并将其定义为最终的case类。这种传统方法指定了我们的actor支持的请求。在收到这样的球员信息请求后，我们的actor从指定的位置获取信息，然后打印球员信息。
- en: 'Let''s use it. We''re going to send a request of `ShowFootballPlayersRequest` type
    using our actor reference:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用它。我们将使用我们的actor引用发送一个`ShowFootballPlayersRequest`类型的请求：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll consider a request containing a player's name and the source for a list
    of players. For example, the source can be any public API to get the player's
    information; in our case, it's a simple `List[Player]` with all the player's data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一个包含球员名字和球员列表来源的请求。例如，来源可以是任何公共API来获取球员信息；在我们的例子中，它是一个包含所有球员数据的简单`List[Player]`。
- en: 'The first thing we would like to do is create a simple request and response.
    For this, we can define these in our `SimpleActor` companion object. First is
    a simple request with the player''s name and a list of players we''ll pass along.
    The second one is a response container which has nothing but an option player:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是创建一个简单的请求和响应。为此，我们可以在我们的`SimpleActor`伴生对象中定义这些。第一个是一个简单的请求，包含玩家的名字和我们将传递的玩家列表。第二个是一个响应容器，它只包含一个可选的玩家：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's define a receive method for such a request, of type `GetPlayerInformationRequest`*:*
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这种请求定义一个接收方法，类型为`GetPlayerInformationRequest`：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A few points to note about this behavior:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种行为的一些要点：
- en: 'We have used a logger implementation to log information specific to this Actor.
    For this, we have used the `ActorLogging` trait. Simply mix in this trait by using:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了一个日志实现来记录与该Actor相关的特定信息。为此，我们使用了`ActorLogging`特质。只需通过以下方式混合这个特质：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we receive a message to perform some expensive operation, we perform that
    operation and wrap that in future*,* and want to return back future''s reference
    to the calling Actor. For this purpose, we''ve used a method named `pipe` from
    the `akka.pattern` package. This method expects an execution context. The way
    we use pipe or the similar syntax method `pipeTo` is as follows:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们收到一个执行某些昂贵操作的消息时，我们执行该操作并将其封装在future中，并希望返回future的引用给调用Actor。为此，我们使用了`akka.pattern`包中的`pipe`方法。此方法期望一个执行上下文。我们使用pipe或类似的语法方法`pipeTo`的方式如下：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively we can use:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This `pipe` or `pipeTo` method sends back the response to the calling site.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pipe`或`pipeTo`方法将响应发送回调用方。
- en: 'After defining the behavior of our Actor for messages of type `GetPlayerInformationRequest`*,*
    let''s call the Actor with this message. First, we''ll create the source, `List[Player]`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的Actor对类型为`GetPlayerInformationRequest`的消息的行为后，让我们用这个消息调用Actor。首先，我们将创建源，`List[Player]`：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Performing an ask call to the simple Actor is as simple as questioning the
    Actor:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 向简单的Actor发起ask调用就像询问Actor一样简单：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now this `?` is called *ask method*; we use this method when we expect a response
    from the called Actor. We need to give an `import` statement to import this method
    in scope:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个`?`被称为*ask方法*；我们使用这个方法当我们期望被调用Actor返回响应时。我们需要给出一个`import`语句来在作用域中导入这个方法：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, we might want to make sure this request gets completed in a given time
    duration. We''ll ensure that particular timeout duration by bringing an implicit
    timeout value in scope:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能还想确保这个请求在给定的时间范围内完成。我们将通过引入一个隐式超时值来确保特定的超时持续时间：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, on successful completion of our request we can obtain the values from
    the response. So, let''s do that and print the player''s information:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在请求成功完成后，我们可以从响应中获取值。所以，让我们这样做并打印玩家的信息：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, we mapped the response to the desired type by providing a `mapTo` method,
    and then we mapped values from the future and printed. We've used the *fire-and-forget*
    way of sending a message to one actor and we've waited for some response using
    the *ask* method. There's another way we can communicate messages and that's using
    the `forward` method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过提供一个`mapTo`方法将响应映射到所需类型，然后从未来映射值并打印。我们使用了发送消息到单个Actor的*fire-and-forget*方式，并且使用*ask*方法等待了一些响应。我们还有另一种通信消息的方式，那就是使用`forward`方法。
- en: The tell versus ask versus forward method
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉与询问与转发方法
- en: 'We use one of these three approaches to transmit messages from one actor to
    another. As we''ve already established, `tell` transmits messages and does not
    wait for the response; this way, we ensure *at most once* delivery. We can also
    use the `ask` method in cases where we expect our called *actors* to respond back
    with some messages of the response type. There might be scenarios where you want
    to forward a message of a particular type with the same actor reference (`ActorRef`)
    to another Actor*.* For this purpose, we can use the `forward` method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这三种方法之一来从一个Actor传输消息到另一个Actor。正如我们已经建立的，`tell`传输消息且不等待响应；这种方式确保了*最多一次*的交付。我们还可以在期望我们的调用*actors*以响应类型的一些消息响应的情况下使用`ask`方法。可能存在你想要将特定类型的消息与相同的actor引用（`ActorRef`）转发给另一个Actor的场景。为此，我们可以使用`forward`方法：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have defined `AnotherActor`*,* and we can make this a child actor of our
    `SimpleActor`*.* To do that, let''s instantiate this actor by giving a `context.actorOf`
    call from `SimpleActor`*.* Then, on receipt of a message of type `ShowFootballPlayersRequest`,
    we''ll forward the message to `anotherActor`, as shown in the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了 `AnotherActor`*，并且我们可以将其作为我们的 `SimpleActor`* 的子actor。为此，让我们通过从 `SimpleActor`*
    调用 `context.actorOf` 来实例化这个actor。然后，在接收到类型为 `ShowFootballPlayersRequest` 的消息时，我们将消息转发给
    `anotherActor`，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `SimpleActor` class simply forwards the message to another actor; now,
    we can have a look at the whole code we have written and try to run it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleActor` 类简单地转发消息给另一个actor；现在，我们可以查看我们编写的整个代码并尝试运行它：'
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous code is our main *SimpleActor* and its companion object. Let''s
    take a look at *AnotherActor*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是我们的主 *SimpleActor* 及其伴随对象。让我们看看 *AnotherActor*：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, the entry point to our application where we boot the Actor system:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应用程序的入口点，在这里我们启动Actor系统：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We also have this `Util` object which consists of utility methods. With this,
    we have defined the `Player` case class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个包含实用方法的 `Util` 对象。有了这个，我们定义了 `Player` 案例类：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After using our Actor, we should terminate its instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的Actor之后，我们应该终止其实例。
- en: Stopping Actors
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止actor
- en: 'One way of stopping actors is by calling the `stop` method from the `system`
    or `context` for a particular actor. To do this, we can define a particular message
    that can be passed to the actor, telling it to stop. For example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 停止actor的一种方式是通过从 `system` 或 `context` 对特定actor调用 `stop` 方法。为此，我们可以定义一个特定的消息，可以传递给actor，告诉它停止。例如：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Most of the times the preferred way of terminating an actor is by sending a
    `PoisonPill` message to it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，终止actor的首选方式是通过向其发送 `PoisonPill` 消息：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This simple message passing can terminate the actor gracefully. The termination
    takes place after all the messages in the Actor's queue are processed before the
    poison pill is processed. Stopping an *actor* stops all of its child actors. Remember,
    we talked about those hook methods that can be called if we want to perform some
    logic when the actor is starting up or at termination. Let's take a look at those.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的消息传递可以优雅地终止actor。终止发生在处理完actor队列中的所有消息之后，再处理毒药丸之前。停止一个 *actor* 会停止其所有子actor。记住，我们讨论了那些在actor启动或终止时可以调用的钩子方法。让我们看看那些方法。
- en: The preStart and postStop hooks
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: preStart 和 postStop 钩子
- en: 'Let''s define these methods in the `SimpleActor` class to log the starting
    and stopping of our `SimpleActor`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `SimpleActor` 类中定义这些方法来记录我们的 `SimpleActor` 的启动和停止：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运行：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Similar methods are also available for restart operations in the form of `preRestart`
    and `postRestart`*.*
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的重启操作方法也以 `preRestart` 和 `postRestart`*.* 的形式提供。
- en: When we discuss communicating via messages, the question of in which order the
    messages get delivered to other actors arises, and also at what guarantee of message
    delivery.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论通过消息进行通信时，消息被投递给其他actor的顺序以及消息传递的保证问题就出现了。
- en: Actor communication via messages and its semantics
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过消息传递的actor通信及其语义
- en: We talked about the fashion of *fire-and-forget* regarding message passing;
    to understand this a bit more, let's take a look at a diagram explaining message
    delivery semantics.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了关于消息传递的 *fire-and-forget* 风格；为了更好地理解这一点，让我们看看一个解释消息传递语义的图表。
- en: The following diagram explains the semantics of message delivery; when we send
    messages over a network, there are chances of it getting delivered and also chances
    of it being lost. Also, in the case of an unsuccessful or successful attempt to
    deliver a message, we might try to send a message or we might not. It depends
    on us if want to try sending a message exactly once and then not the second time
    or so on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了消息传递的语义；当我们通过网络发送消息时，存在消息被成功投递和丢失的可能性。此外，在尝试成功或失败地投递消息的情况下，我们可能会尝试发送消息，也可能不会。这取决于我们是否想要尝试一次投递消息而不进行第二次或更多次。
- en: 'Based on these assumptions, we can make some formal terminologies specifying
    what we discussed, and we call them:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些假设，我们可以制定一些正式的术语来具体说明我们所讨论的内容，我们称它们为：
- en: At most once
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最多一次
- en: At least once
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少一次
- en: Exactly once
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确一次
- en: '![](img/00053.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: The diagram explains each of the three approaches in simple terms. It's important
    to know that in case of the Actor's communication, we have at most once delivery;
    in other terms, it means no guaranteed delivery. When actors communicate, a message
    might or might not be delivered to the called Actor.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图表以简单的方式解释了三种方法。重要的是要知道，在演员通信的情况下，我们最多只能有一次投递；换句话说，这意味着没有保证的投递。当演员通信时，消息可能被投递给被调用的演员，也可能不会。
- en: Actors are pretty lightweight and can accommodate a large number of messages
    fired to them; when we send a message to an actor, the messages get delivered
    to the actor's mailbox. An actor's mailbox is a queue that gets instantiated when
    we create an actor's instance. We know the way queue works is FIFO, *first in
    first out.* The ordering of the execution of the messages depends on the order
    in which they arrive to the mailbox.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 演员相当轻量级，可以容纳大量发送给他们的消息；当我们向演员发送消息时，消息会被投递到演员的邮箱。演员的邮箱是一个队列，在我们创建演员实例时被实例化。我们知道队列的工作方式是FIFO，即*先进先出*。消息执行的顺序取决于它们到达邮箱的顺序。
- en: Until now, our discussions were based on the possibilities of successful execution
    of the logic implemented via Actors. But we know that Akka provides a very nice
    fault handling mechanism in the *form* of a *supervision strategy.* Let's discuss
    it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的讨论都是基于通过演员实现的逻辑成功执行的可能性。但我们知道，Akka提供了一个非常好的错误处理机制，即*监督策略*的形式。让我们来讨论一下。
- en: Supervising fault in our actors
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监督我们的演员中的故障
- en: There is a possibility that our logic ends up in a network error or some unexpected
    exception. Imagine a scenario where our service needs to call a particular database
    instance to fetch some data. We might face *connection timed out* or some other
    similar errors. In that case, what should be our behavior? Maybe trying to establish
    the connection a couple of times will help, this can be achieved if our tasks
    are performed in such a hierarchical manner. We can achieve this task by performing
    hierarchy via the *actors* in place. And if some actor from down in the hierarchy
    fails and can communicate the failure to parent actor, the parent actor, based
    on the type of failure, can restart/kill the actor or perform some other operation
    as required. This is in a sense supervising the actors below in the hierarchy;
    let's say parent actors can supervise child actors. The way we define this strategy
    comes under the Akka defined supervision strategy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能我们的逻辑最终会导致网络错误或某些意外的异常。想象一下，我们的服务需要调用特定的数据库实例来获取一些数据。我们可能会遇到*连接超时*或其他类似的错误。在这种情况下，我们应该怎么做？也许尝试建立连接几次会有所帮助，这可以通过以这种层次结构的方式执行任务来实现。我们可以通过在现有的*演员*中执行层次结构来完成任务。如果层次结构下方的某个演员失败并能够将故障通知父演员，那么基于故障的类型，父演员可以重启/杀死演员或执行所需的某些其他操作。这在某种意义上是对层次结构下方的演员进行监督；比如说，父演员可以监督子演员。我们定义这种策略的方式属于Akka定义的监督策略。
- en: Supervision in a sense is about reacting to *failures* within an actor's hierarchy.
    Apart from the *root guardian,* every *actor* has a parent/supervisor to supervise.
    Every actor when instantiated becomes a part of a *default supervision strategy*.
    It's also important to observe that *failures* need a separate channel to be communicated
    to supervisors. So, Akka has a separate group of *system level actors,* which
    deal with the communication of such messages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，监督是关于对演员层次结构内的*故障*做出反应。除了*根监护人*之外，每个*演员*都有一个父/监督者来监督。每个演员在实例化时都成为*默认监督策略*的一部分。观察到一个重要的现象是，*故障*需要单独的通道来与监督者通信。因此，Akka有一个专门的*系统级演员*组，负责处理此类消息的通信。
- en: Since we deal with actors in case of failures also, our reactions should be
    in terms of actor-specific actions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在出现故障的情况下也会处理演员，我们的反应应该以演员特定的动作来衡量。
- en: 'Hence, think about the actions a supervisor can perform:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑监督者可以执行的动作：
- en: Resume child actors
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复子演员
- en: Restart child actors
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重启子演员
- en: Stop child actors
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止子演员
- en: Escalate the failure
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级故障
- en: When a supervisor actor encounters a *failed child actor,* it can perform one
    of the actions described above. Depending on our preference, we might want to
    apply the strategy to all the children actors, regardless of if all of them failed
    or not. It's also possible to only *resume/restart/stop* the failing child actor.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个监督演员遇到一个*失败的子演员*时，它可以执行上述描述的其中一个动作。根据我们的偏好，我们可能希望将策略应用于所有子演员，无论他们是否都失败了。也有可能只*恢复/重启/停止*失败的子演员。
- en: Based on the children on which the *supervision strategy* should be applied,
    we have two strategies, namely *OneForOneStrategy* and *AllForOneStrategy.* Let's
    take a look at them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应该应用监督策略的子Actor，我们有两种策略，即*OneForOneStrategy*和*AllForOneStrategy*。让我们来看看它们。
- en: OneForOne versus AllForOne strategy
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OneForOne与AllForOne策略
- en: Take the scenario where we have `SimpleActor` and `AnotherSimpleActor` actors.
    There's one child actor for `SimpleActor` named `SimplerrrActor`*:*
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们有`SimpleActor`和`AnotherSimpleActor`actors的场景。`SimpleActor`有一个名为`SimplerrrActor`的子actor：*
- en: '**SimpleActor**: `/user/topLevelActor/simpleActor`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimpleActor**: `/user/topLevelActor/simpleActor`'
- en: '**AnotherSimpleActor**:` /user/topLevelActor/anotherSimpleActor`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AnotherSimpleActor**:` /user/topLevelActor/anotherSimpleActor`'
- en: '**SimplerrrActor**:` /user/topLevelActor/simpleActor/simplerrrActor`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimplerrrActor**:` /user/topLevelActor/simpleActor/simplerrrActor`'
- en: In such cases, the user guardian is going to take care of `topLevelActor` and
    `topLevelActor` is going to supervise `SimpleActor` and `AnotherSimpleActor`*.*
    If something goes wrong in `SimpleActor` and we want all the actors to resume/restart/stop,
    we can define an `AllForOneStrategy`*.* If we want to perform such actions only
    on the failed `SimpleActor` and its subsequent children, we can opt for `OneForOneStrategy`*.*
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户守护者将负责`topLevelActor`，而`topLevelActor`将监督`SimpleActor`和`AnotherSimpleActor`*.*
    如果`SimpleActor`出现问题，我们想要所有actors恢复/重启/停止，我们可以定义一个`AllForOneStrategy`*.* 如果我们只想对失败的`SimpleActor`及其后续子actors执行此类操作，我们可以选择`OneForOneStrategy`*.*
- en: 'These two are defined as case classes in Scala, which takes a few parameters
    in the form of `maxNrOfRetries`, `withinTimeRange`, and `loggingEnabled`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个在Scala中定义为案例类，它们以`maxNrOfRetries`、`withinTimeRange`和`loggingEnabled`的形式接受一些参数：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first parameter is to specify the number of times we might want to retry
    the strategy on the child actor; we can make it an infinite number of times by
    specifying -1 as the number. After the specified number of times, the child actor
    will stop. A second parameter specifies the duration after which the next retry
    should happen. As shown, the value `Duration.Inf` specifies no time window at
    all. Finally, we have to specify the logging behavior; it expects a Boolean value,
    and by default, it's true and means enabled.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是用来指定我们可能想要在子actor上重试策略的次数；我们可以通过指定-1作为数字来使其无限次数。在指定次数之后，子actor将停止。第二个参数指定了下一次重试应该发生的持续时间。如图所示，值`Duration.Inf`指定了没有任何时间窗口。最后，我们必须指定日志行为；它期望一个布尔值，默认情况下为true，表示启用。
- en: 'These two strategy classes extend the parent abstract class `SupervisorStrategy`.
    The way these two strategies work can be understood via the diagram here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个策略类扩展了父抽象类`SupervisorStrategy`。这些策略如何工作可以通过下面的图解来理解：
- en: '![](img/00054.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: Now, the choice is ours to apply whichever strategy that suits our needs/situation.
    We define these strategies based on the type of failures; in the case that we've
    not covered a particular failure occurs, the failure gets escalated to the parent
    supervisor Actor. There's a defined set of actions performed by supervisors.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择权在我们手中，我们可以应用任何适合我们需求/情况的策略。我们根据失败类型定义这些策略；如果我们没有覆盖到特定的失败情况，则该失败将升级到父监督Actor。监督者执行一系列定义好的动作。
- en: Default supervision strategy
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认监督策略
- en: By default, the Akka system looks for a few exception types from failure messages
    received from child Actors. Let's take a look at those scenarios.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Akka系统会从从子actors接收到的失败消息中查找一些异常类型。让我们看看那些场景。
- en: 'The default supervision strategy will stop the failing child Actor in case
    of:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的监督策略将在以下情况下停止失败的子Actor：
- en: '`ActorInitializationException`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActorInitializationException`'
- en: '`ActorKilledException`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActorKilledException`'
- en: '`DeathPactException`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeathPactException`'
- en: Note that in case of exception, it'll restart the failing Actor.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在发生异常的情况下，它将重新启动失败的Actor。
- en: With this information, let's try implementing one strategy on our own.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些信息，让我们尝试自己实现一个策略。
- en: Applying the supervision strategy
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用监督策略
- en: 'While overriding the default `supervisorStrategy`*,* all we do is define the
    value with arguments and provide a `Decider`; this decider contains the logic
    to be implemented in case of exceptions. It looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当覆盖默认的`supervisorStrategy`*时，我们只需定义带有参数的值并提供一个`Decider`；这个decider包含在发生异常时需要实现的逻辑。它看起来像这样：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we have defined a `OneForOneStrategy`, and on a case by case basis, the
    action to be performed in regards to the failing actor. A full example with this
    strategy in place can look like the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`OneForOneStrategy`，并且根据每个案例，对失败演员采取的操作。使用此策略的完整示例可能如下所示：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As shown in the code, we have a `TopLevelActor`*,* which sends messages to its
    child Actor `SuperSimpleActor`*,* hence, `TopLevelActor` becomes a supervisor
    for its child actor. We have overridden the `supervisorStrategy`. According to
    the new Strategy, we can resume/restart based on the types of exceptions. The
    rest of the example is self-explanatory. We've logged the start and restart steps
    of our actors by overriding `preStart` *and* `preRestart` methods. Upon running
    the example, we'll get the logged output.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我们有一个`TopLevelActor`，它向其子演员`SuperSimpleActor`发送消息，因此`TopLevelActor`成为其子演员的监督者。我们已经覆盖了`supervisorStrategy`。根据新的策略，我们可以根据异常类型恢复/重启。其余的示例是自我解释的。我们通过覆盖`preStart`和`preRestart`方法记录了我们的演员的启动和重启步骤。运行示例后，我们将得到记录的输出。
- en: 'Run:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since these failures are communicated via system level actors, the order of
    messages logged does not matter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些失败是通过系统级演员传达的，因此记录的消息顺序并不重要。
- en: With this example, we've pretty much covered how we can implement a supervisor
    strategy for our Actor.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们几乎涵盖了如何为我们演员实现监督策略。
- en: Akka library also provides `akka-testkit` for the testing of actors. It comes
    with a construct which make it easier to test actors. Let's go through the library
    and write unit test cases for our actor implementation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Akka库还提供了`akka-testkit`用于演员的测试。它包含一个构造，使得测试演员变得更加容易。让我们浏览这个库并为我们演员的实现编写单元测试用例。
- en: Testing actors
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试演员
- en: 'For the testing of Actors that we create, we might consider few entities that
    are needed to be present. These entities might be:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们创建的演员的测试，我们可能需要考虑一些必须存在的实体。这些实体可能包括：
- en: A test actor-system
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试演员系统
- en: A `testActor` (the message sender)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`testActor`（消息发送者）
- en: The actor under testing (whose behavior we want to test)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在测试的演员（我们想要测试其行为）
- en: Assertions to be made in case of an actors expected message
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在演员预期消息的情况下需要提出的断言
- en: Akka's `test-kit` library provides us with all of these needed entities ready-made.
    We can use these to test our actors. Let's write a simple actor test case.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Akka的`test-kit`库为我们提供了所有这些现成的所需实体。我们可以使用这些来测试我们的演员。让我们编写一个简单的演员测试用例。
- en: 'The expect case is to check if our `GetPlayerInformationRequest` works fine:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 预期情况是检查我们的`GetPlayerInformationRequest`是否工作正常：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The previous code is a very simple example of how we can write an Actor test
    case. We should make sure that the test case we write is in the test directory:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是我们如何编写演员测试用例的一个非常简单的示例。我们应该确保我们编写的测试用例位于测试目录中：
- en: '![](img/00055.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: Before we discuss our *test case,* let's run it. To run it, we can simply right-click
    using mouse and choose the Run option*.* In our case, the test case should pass.
    Now, let's take a look at the case we wrote.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论*测试用例*之前，让我们先运行它。要运行它，我们可以简单地使用鼠标右键点击并选择运行选项*.*在我们的情况下，测试用例应该通过。现在，让我们看看我们编写的案例。
- en: 'The first thing to observe is the declaration we wrote:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是我们编写的声明：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We named our actor test case `SimpleActorSpec`, and extended `Testkit` by passing
    an `ActorSystem` for testing purposes. We've also mixed in `ImplicitSender`, which
    in turn returns the response from our actor under test, `SimpleActor`. Finally,
    `WordSpecLike` and the other `BeforeAndAfterAll` are just to provide DSL-like
    syntax methods for writing test cases. We can see these syntax methods in the
    form of must and in.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的演员测试用例命名为`SimpleActorSpec`，并通过传递一个`ActorSystem`来扩展`Testkit`以进行测试目的。我们还混合了`ImplicitSender`，它反过来返回我们正在测试的演员`SimpleActor`的响应。最后，`WordSpecLike`和其他`BeforeAndAfterAll`只是为了提供类似于DSL的语法方法来编写测试用例。我们可以以must和in的形式看到这些语法方法。
- en: 'In the implementation, we''ve done what''s expected, created the actor under
    the test''s reference, and provided dummy data as in the players list. We also
    created a dummy response that''s expected from our `SimpleActor`. The following
    line sends the message to `SimpleActor`, which in turn responds back:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，我们做了预期的事情，创建了测试演员的引用，并提供了玩家列表中的模拟数据。我们还创建了一个预期的`SimpleActor`的模拟响应。以下行将消息发送到`SimpleActor`，它反过来响应：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The assertion part is handled using the `expectMsg` method. Here, we compared
    the dummy response to the expected response. For assertion purposes, `scala-test`
    library provides many alternatives.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 断言部分是通过`expectMsg`方法处理的。在这里，我们比较了模拟响应和预期响应。为了断言目的，`scala-test`库提供了许多替代方案。
- en: With this, we wrote a simple test case for our `SimpleActor`*.* We've covered
    all the basics we need to understand and write actors in Akka*.* There are a few
    advanced configuration-related topics such as *dispatchers, mailbox implementations*,
    and *routing* you might want to have a look at. For those, we can first thank
    the beautifully covered standard *documentation* of Akka available at: [https://doc.akka.io/docs/akka/2.5.8/index-actors.html](https://doc.akka.io/docs/akka/2.5.8/index-actors.html)*.*
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们为我们的`SimpleActor`*.*编写了一个简单的测试用例。我们已经涵盖了理解和编写Akka*.*中演员所需的所有基础知识。还有一些高级配置相关主题，例如*调度器、邮箱实现*和*路由*，你可能想看看。对于这些，我们首先感谢Akka提供的精美标准*文档*，可在以下网址找到：[https://doc.akka.io/docs/akka/2.5.8/index-actors.html](https://doc.akka.io/docs/akka/2.5.8/index-actors.html)*.*
- en: And if you still have a question in mind about what's next or where to go from
    here, let me tell you there's way more that Akka provides. We've already talked
    about Akka as a set of open source libraries. These libraries are available for
    different problems. Libraries such as `akka-http`, streams, and clustering provide
    you with respective solutions. The good part is all these libraries are based
    on the abstraction of actor-model. And we have covered that in our chapter, so
    let's summarize what we've learnt in this chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对接下来要做什么或者从这里开始往哪里走有疑问，让我告诉你，Akka提供了更多。我们已经讨论了Akka作为一个开源库集合。这些库针对不同的问题可用。例如`akka-http`、流和集群等库提供了相应的解决方案。好的部分是所有这些库都是基于actor模型抽象的。我们已经在我们的章节中涵盖了这一点，所以让我们总结一下我们在本章中学到了什么。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was an introduction to Akka for us. We tried to understand the
    basic underlying principle of actors. We've covered one of the most important
    libraries Akka provides, `akka-actors`. Starting from why we need a library of
    this sort, to understanding the way we implement Actors in Akka, we covered it
    all. Then from there, we covered the important supervision strategy in Akka. We
    talked about and practiced our own custom supervisor strategy. Finally, we had
    a look at `akka-testkit`, a testkit provided by Akka. With this, we covered what
    was needed to understand Akka actors and the basics of it. In the next chapter,
    we'll focus on how we can handle concurrency in Scala. We know it's importance
    in modern architecture, so the next chapter will be an exciting one.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这章对我们来说是Akka的入门。我们试图理解演员的基本底层原理。我们已经涵盖了Akka提供的重要库之一，`akka-actors`。从为什么我们需要这样的库，到理解我们在Akka中实现演员的方式，我们涵盖了所有内容。然后从那里，我们涵盖了Akka中的重要监督策略。我们讨论并实践了我们自己的自定义监督策略。最后，我们查看了一下Akka提供的`akka-testkit`测试套件。通过这个，我们涵盖了理解Akka演员及其基础所需的所有内容。在下一章中，我们将关注如何在Scala中处理并发。我们知道它在现代架构中的重要性，所以下一章将会非常精彩。
