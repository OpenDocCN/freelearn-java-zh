- en: Unifying Imperative and Reactive with Vert.x
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vert.x统一命令式和反应式
- en: One of the greatest challenges for enterprise applications has traditionally
    been combining business operations, which are inherently synchronous, with dispatching
    the results of these operations, which can be also asynchronous and event-driven.
    In this chapter, we will learn how the Vert.x toolkit can address this challenge
    in Quarkus applications by combining standard imperative programming with asynchronous
    data streams that can be created, changed, or combined at runtime. By the end
    of this chapter, you should be proficient in writing reactive applications on
    the JVM using Vert.x.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业应用来说，最大的挑战之一传统上一直是将本质上是同步的业务操作与异步和事件驱动的操作结果调度相结合。在本章中，我们将学习Vert.x工具包如何通过结合标准命令式编程和可以在运行时创建、更改或组合的异步数据流来应对Quarkus应用中的这一挑战。到本章结束时，你应该能够熟练地在JVM上使用Vert.x编写反应式应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to Reactive Programming and the Vert.x toolkit
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程和Vert.x工具包的简介
- en: Vert.x API models available in Quarkus
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Quarkus中可用的Vert.x API模型
- en: Managing the Reactive SQL Client with Vert.x
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vert.x管理反应式SQL客户端
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter09).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上本章中找到项目的源代码：[https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter09)。
- en: Demystifying Reactive Programming and Vert.x
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘反应式编程和Vert.x
- en: 'Imperative programming is the way most programmers write their code every day.
    Wait a minute – what does imperative programming mean? In a concise statement,
    we can say that imperative programming means that lines of code get executed in
    a sequence, statement by statement, as shown in the following example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程是大多数程序员每天编写代码的方式。等等——命令式编程是什么意思？用一个简洁的声明来说，我们可以这样说，命令式编程意味着代码行按顺序、逐条执行，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, imperative programming can use loops or conditional statements
    to jump to different parts of code. Don't be fooled by this, though. As long as
    your debugger clearly points to a statement in your code (and thus it's obvious
    what line will be executed next), you are definitely using imperative programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命令式编程可以使用循环或条件语句跳转到代码的不同部分。不过，不要被这个迷惑。只要你的调试器清楚地指向你的代码中的某个语句（因此很明显下一个将执行哪一行），你就肯定是在使用命令式编程。
- en: While the imperative programming model is clearly simpler to understand, it
    can badly impact scalability as the number of connections tends to grow. As a
    matter of fact, the number of system threads will have to be increased accordingly,
    causing your OS to spend significant CPU cycles just for thread scheduling management.
    That's where Vert.x comes into play.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命令式编程模型显然更容易理解，但随着连接数量的增加，它可能会严重影响到可伸缩性。事实上，系统线程的数量将相应增加，这将导致你的操作系统花费大量的CPU周期仅仅是为了线程调度管理。这就是Vert.x发挥作用的地方。
- en: 'Let''s start with a definition: what exactly is Vert.x? Vert.x is not an application
    server or a framework but merely a toolkit or, if you prefer, a set of plain JAR
    files that can be added as a dependency to your projects. Easy-peasy. You don''t
    need a specific development environment or plugin to develop applications with
    Vert.x either.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义开始：Vert.x究竟是什么？Vert.x不是一个应用服务器或框架，而仅仅是一个工具包，或者如果你愿意，是一组可以添加到你的项目中的普通JAR文件。简单易懂。你也不需要特定的开发环境或插件来使用Vert.x开发应用程序。
- en: 'At its core, Vert.x is a reactive toolkit that fulfills the requirements dictated
    by the **Reactive Manifesto** ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)).
    These requirements can be summarized in the following points:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Vert.x是一个满足**反应式宣言**（[https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)）要求的反应式工具包。这些要求可以总结为以下几点：
- en: '**Responsive**: A reactive system needs to be capable of handling requests
    in a reasonable time.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**: 一个反应式系统需要能够以合理的时间处理请求。'
- en: '**Resilient**: A reactive system must be designed to handle failures and deal
    with them appropriately.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**: 一个反应式系统必须被设计成能够处理故障，并且适当地处理它们。'
- en: '**Elastic**: A reactive system must be able to scale up and down according
    to loads without compromising the responsiveness of the system.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：反应式系统必须能够根据负载进行扩展和缩减，而不会影响系统的响应性。'
- en: '**Message-driven**: The reactive system''s components interact with each other
    by exchanging asynchronous messages.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：反应式系统的组件通过交换异步消息相互交互。'
- en: 'Based on the preceding points, it''s clear that Vert.x promotes a new way of
    designing and building distributed systems while infusing asynchrony, scalability,
    and reactiveness into the core of your applications. Therefore, with regard to
    our former example, it can be rewritten in a reactive way, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的观点，很明显，Vert.x推动了一种新的设计和构建分布式系统的方法，同时将异步性、可扩展性和反应性注入到应用程序的核心。因此，关于我们之前的示例，它可以以反应式的方式重写，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unlike the former example, by using Vert.x, the running thread is released while
    the connection with the HTTP server is being established. Then, when the response
    has been received, a handler coded as a Lambda expression ([https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html))
    is called back to deal with the response.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例不同，使用Vert.x时，在建立与HTTP服务器的连接期间，运行线程被释放。然后，当收到响应时，一个作为Lambda表达式编写的处理器（[https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)）被调用来处理响应。
- en: In the preceding example, the `vertx` field can be used in your code each time
    you extend the Vert.x basic unit of deployment, which is called a **Verticle**.
    In essence, a Verticle processes incoming events over an event loop, creating
    the foundation for an asynchronous programming model. Verticles can be written
    in various languages, not only Java, so you can mix different environments as
    part of a larger reactive system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，每次你扩展Vert.x的基本部署单元，即所谓的**Verticle**时，都可以在你的代码中使用`vertx`字段。本质上，Verticle通过事件循环处理传入的事件，为异步编程模型奠定基础。Verticle可以用各种语言编写，而不仅仅是Java，因此你可以将不同的环境作为更大反应式系统的一部分进行混合。
- en: 'The main tool for allowing different Verticles to communicate with each other
    is called the **Event Bus**, and communication happens through asynchronous message
    passing. The following diagram shows how the **Event Bus** fits into this schema:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 允许不同的Verticle之间相互通信的主要工具被称为**事件总线**，通信通过异步消息传递进行。以下图表显示了**事件总线**如何融入此架构：
- en: '![](img/453ec3ac-428a-4835-9e16-02e973e72744.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/453ec3ac-428a-4835-9e16-02e973e72744.png)'
- en: 'The Event Bus doesn''t pose any restrictions on the kind of data format you
    use, although JSON is the preferred exchange format since it is a popular option
    for structuring data, allowing Verticles written in different languages to communicate.
    The Event Bus supports the following communication patterns:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线不对你使用的数据格式有任何限制，尽管JSON是首选的交换格式，因为它是一种流行的数据结构化选项，允许用不同语言编写的Verticle进行通信。事件总线支持以下通信模式：
- en: '**Point-to-point** messaging, which means that messages are routed to just
    one of the handlers registered at that address.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点对点**消息传递，意味着消息被路由到在该地址注册的处理器之一。'
- en: '**Request-respon****se** messaging, which is similar to point-to-point messaging,
    except that it includes an optional reply handler that can be specified while
    sending the message so that the recipient can decide whether to reply to the message.
    If they do so, the reply handler will be called.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求-响应**消息传递，与点对点消息传递类似，但它在发送消息时可以指定一个可选的回复处理器，以便接收者可以决定是否回复消息。如果他们这样做，回复处理器将被调用。'
- en: '**Publish-subscribe**, which allows you to broadcast messages using a publish
    function. In this case, the event bus will route messages to all the handlers
    that are registered against that address.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布-订阅**，允许你使用发布函数广播消息。在这种情况下，事件总线将消息路由到所有在该地址注册的处理器。'
- en: Since there are multiple communication patterns, several API models have been
    designed for Vert.x and are all based around the concept of executing the flow
    in an asynchronous way via callbacks. The next section discusses a variety of
    Vert.x API models that are available in Quarkus.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多种通信模式，已经为Vert.x设计了多个API模型，并且所有这些模型都围绕通过回调以异步方式执行流程的概念。下一节将讨论Quarkus中可用的各种Vert.x
    API模型。
- en: Vert.x API models in Quarkus
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quarkus中的Vert.x API模型
- en: 'Vert.x provides a large ecosystem of reactive APIs that are integrated into
    Quarkus. More specifically, Quarkus uses Vert.x as the reactive engine by providing
    a single dependency to your applications:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x提供了一整套集成到Quarkus中的反应式API。更具体地说，Quarkus通过提供一个单一依赖项到你的应用程序来使用Vert.x作为反应式引擎：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This allows you to access a managed Vert.x instance with simple code injection:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你通过简单的代码注入访问一个管理的Vert.x实例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Vertx` object is the control center of a Vert.x application. It's your
    pass to Vert.x land and allows you to create an asynchronous and non-blocking
    client and servers, get a reference to the Event Bus, and many other things.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vertx`对象是Vert.x应用程序的控制中心。它是你通往Vert.x世界的通行证，允许你创建异步和非阻塞的客户端和服务器，获取Event Bus的引用，以及许多其他功能。'
- en: 'When using Vert.x API in Quarkus, however, there''s no `Vertx` object for you
    to access. As a matter of fact, Quarkus provides three different Vert.x APIs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当在Quarkus中使用Vert.x API时，没有`Vertx`对象供你访问。事实上，Quarkus提供了三个不同的Vert.x API：
- en: '`io.vertx.core.Vertx`: This is the entry point into the Vert.x core API and
    allows you to achieve asynchronous and non-blocking clients and servers using
    callbacks.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.vertx.core.Vertx`：这是Vert.x核心API的入口点，允许你使用回调实现异步和非阻塞的客户端和服务器。'
- en: '`io.vertx.reactivex.core.Vertx`: This API allows us to use observable patterns
    in our Vert.x applications wherever we can use streams or asynchronous results.
    Additionally, it allows us to use a large set of data transformation operators
    on our streams.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.vertx.reactivex.core.Vertx`：这个API允许我们在Vert.x应用程序中可以使用流或异步结果的地方使用可观察模式。此外，它还允许我们在流上使用大量数据转换操作符。'
- en: '`io.vertx.axle.core.Vertx`: This API has been specifically designed to integrate
    with Quarkus'' MicroProfile patterns, proving a solid foundation for sending and
    receiving asynchronous messages, thus enforcing loose coupling between services.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.vertx.axle.core.Vertx`：这个API专门设计用于与Quarkus的MicroProfile模式集成，为发送和接收异步消息提供了一个坚实的基础，从而在服务之间强制松耦合。'
- en: In order to learn about all three different variations of Vert.x, we have provided
    an equal number of examples in the `Chapter09` folder in this book's GitHub repository.
    Let's take a look at them in detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解Vert.x的三个不同变体，我们在本书GitHub仓库的`Chapter09`文件夹中提供了相同数量的示例。让我们详细看看它们。
- en: Managing the Vert.x core API
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Vert.x核心API
- en: For the purpose of learning about the Vert.x core API, we will be using a modified
    version of our basic customer service application, which we discussed in [Chapter
    4](1eb0a987-ab8b-40a1-ab16-6562b8a45344.xhtml), *Adding Web Interfaces to Quarkus
    Services*. You can find the source code for this example of the `Chapter09/core/customer-service`
    folder in this book's GitHub repository. We recommend that you import the project
    into your IDE.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习Vert.x核心API，我们将使用我们之前讨论的基本客户服务应用程序的修改版，该应用程序在[第4章](1eb0a987-ab8b-40a1-ab16-6562b8a45344.xhtml)中介绍，*将Web接口添加到Quarkus服务中*。你可以在本书GitHub仓库的`Chapter09/core/customer-service`文件夹中找到这个示例的源代码。我们建议你将项目导入到你的IDE中。
- en: 'Now, let''s dive straight into the code. Since the Vert.x core API is based
    around the callback mechanism, in order to leverage asynchronous and non-blocking
    APIs, for our customer service example we have added two functions that will read
    and write a list of customers from the filesystem in JSON format. Where shall
    we write our customer list? The answer is into the `application.properties` file,
    which defines a property named `file.path`, which is where the customer list will
    be written:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们直接进入代码。由于Vert.x核心API基于回调机制，为了利用异步和非阻塞API，在我们的客户服务示例中，我们添加了两个函数，用于从文件系统中以JSON格式读取和写入客户列表。我们的客户列表应该写在哪里？答案是写入`application.properties`文件，它定义了一个名为`file.path`的属性，客户列表将写入该位置：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s look at the code. The core class that''s responsible for providing
    customer data is `CustomerRepository`. There we''ll inject an instance of `io.vertx.core.Vertx`
    at this point. We will also inject the path where the data will be stored:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码。负责提供客户数据的核心类是`CustomerRepository`。在这里，我们将注入一个`io.vertx.core.Vertx`实例。我们还将注入数据存储的路径：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now comes the interesting bit, that is, writing a method that uses the `vertx`
    instance to flatten our list of customers on the filesystem:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来到了有趣的部分，那就是编写一个使用`vertx`实例在文件系统中展平我们的客户列表的方法：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first thing you may have noticed is the `CompletionStage` method''s signature.
    If you have been programming async Java code, you may be familiar with the `java.util.concurrent.Future`
    API. It''s used to do the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是 `CompletionStage` 方法的签名。如果你已经编写过异步 Java 代码，你可能对 `java.util.concurrent.Future`
    API 很熟悉。它用于以下操作：
- en: Check whether the execution has completed via the `isDone()` method
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `isDone()` 方法检查执行是否已完成
- en: Cancel the execution using the `cancel()` method
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cancel()` 方法取消执行
- en: Fetch the result of the execution using the blocking `get()` method
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阻塞的 `get()` 方法获取执行结果
- en: The major limitation of this approach is that the caller cannot manually complete
    the task, nor can it chain multiple `Future` executions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的重大局限性是调用者无法手动完成任务，也不能链式调用多个 `Future` 执行。
- en: On the other hand, `CompletionStage` is based on the concept of stages, which
    are thought of as multiple intermediate computations and may or may not be asynchronous.
    In any case, we have to complete them before we reach the final result. These
    intermediate computations are known as **completion stages**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`CompletionStage` 基于阶段的概念，这些阶段被视为多个中间计算，可能是异步的，也可能不是。无论如何，我们必须在达到最终结果之前完成它们。这些中间计算被称为
    **完成阶段**。
- en: 'By using the `CompletionStage` stage, you can easily address the `java.util.concurrent.Future`
    API''s limitations by doing the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `CompletionStage` 阶段，你可以通过以下方式轻松解决 `java.util.concurrent.Future` API 的局限性：
- en: Manually completing `CompletableStage` using `complete(T value)`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `complete(T value)` 手动完成 `CompletableStage`
- en: Chaining multiple `CompletableStage` in a block
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个块中链式调用多个 `CompletableStage`
- en: Let's get back to our example. Once we have created `JsonArray` out of our customer
    list, we can access our `FileSystem` using the Vert.x core API. We can also register
    a handler that is in charge of completing our `CompletionStage` as soon as the
    file has been successfully written.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。一旦我们从客户列表中创建出 `JsonArray`，我们就可以使用 Vert.x 核心API访问我们的 `FileSystem`。我们还可以注册一个处理程序，负责在文件成功写入后立即完成我们的
    `CompletionStage`。
- en: 'Let''s take a look at the `readFile` method, which is in charge of reading
    the file that contains the customer list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看负责读取包含客户列表的文件的 `readFile` 方法：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `readFile` method is intentionally a bit more complex. As a matter of fact,
    we have chained two different stages into it. The first one executes a one-time
    timer that will fire the next execution in 100 ms. Timers are a core construct
    of Vert.x and should be used wherever you want to delay the execution of some
    code or execute it repeatedly:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile` 方法故意设计得稍微复杂一些。事实上，我们已经将两个不同的阶段链入其中。第一个阶段执行一个一次性定时器，将在 100 毫秒后触发下一次执行。定时器是
    Vert.x 的核心结构，应该在任何需要延迟某些代码执行或重复执行代码的地方使用：'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In any case, timers are how you can delay the execution in Vert.x terms in place
    of other mechanisms, such as `Thread.sleep`, which would block the event loop
    and therefore should **never**, ever be used in the Vert.x context.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vert.x 术语中，无论在何种情况下，定时器都是你可以用来延迟执行而不是其他机制（如 `Thread.sleep`），后者会阻塞事件循环，因此 **绝对**
    不应该在 Vert.x 上下文中使用。
- en: If you forget our gentle warning, Vert.x will remind you each time you attempt
    to use a blocking code in the Vert.x context with a log message similar to *Thread
    vertx-eventloop-thread-1 has been blocked for 22258 ms.*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了我们的温和警告，Vert.x 将会在你每次尝试在 Vert.x 上下文中使用阻塞代码时提醒你，日志消息类似于 *Thread vertx-eventloop-thread-1
    has been blocked for 22258 ms*。
- en: The remaining part of the `readFile` method does exactly the opposite of the
    `writeFile` method; that is, it reads the JSON file and completes the stage as
    soon as the file has been read.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile` 方法的剩余部分与 `writeFile` 方法的操作正好相反；也就是说，它读取 JSON 文件并在文件读取完成后立即完成阶段。'
- en: 'In order to expose this feature to the client application, we have added two
    wrapper methods to our `CustomerEndpoint` class in order to expose the functions
    via the REST API:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此功能暴露给客户端应用程序，我们在 `CustomerEndpoint` 类中添加了两个包装方法，以便通过 REST API 暴露函数：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's worth noting that the `writeFile` method produces text information since
    it's supposed to return a simple text message to the caller. On the other hand,
    the `readFile` method relies on the class' default `application/json` format to
    display the JSON text file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`writeFile` 方法产生文本信息，因为它应该返回一个简单的文本消息给调用者。另一方面，`readFile` 方法依赖于类的默认 `application/json`
    格式来显示 JSON 文本文件。
- en: 'Now, let''s move on to the client-side. We can easily capture the `CompletionStage`
    event using two more AngularJS handlers, which will capture the result as soon
    as it''s available:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向客户端。我们可以使用两个额外的AngularJS处理程序轻松捕获`CompletionStage`事件，这些处理程序将立即捕获结果：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Both functions will be triggered with the addition of two simple buttons to
    our home page:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在主页上添加两个简单的按钮，这两个函数将被触发：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Besides doing this, we have also added a `div` section to our HTML schema,
    which is where information will be displayed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了做这件事，我们还向我们的HTML架构中添加了一个`div`部分，信息将在这里显示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Without further ado, let''s build and run the application with the following
    command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们使用以下命令构建和运行应用程序：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is our new UI, which includes the Read File and Write File buttons.
    We have just saved a set of `Customer` objects, as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们新的UI，包括读取文件和写入文件的按钮。我们已经保存了一组`Customer`对象，如下面的截图所示：
- en: '![](img/59ac264c-73dd-44c5-a54a-7bcaa4ff5403.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59ac264c-73dd-44c5-a54a-7bcaa4ff5403.png)'
- en: 'Conversely, if we hit the Read File button, its content will be displayed in
    the lower `div` of the page in JSON format:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们点击“读取文件”按钮，其内容将以JSON格式显示在页面下方的`div`中：
- en: '![](img/1f5fce28-facd-48b1-85f0-da83b7380be5.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f5fce28-facd-48b1-85f0-da83b7380be5.png)'
- en: We have completed the first round with Vert.x core. Now, let's move on and look
    at using Vert.x with **ReactiveX** (**RxJava**).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了第一轮的Vert.x核心。现在，让我们继续前进，看看如何使用**ReactiveX**（**RxJava**）与Vert.x结合使用。
- en: Managing Vert.x API for RxJava
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Vert.x API for RxJava
- en: 'RxJava ([https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava))
    is a Java library that lets you create asynchronous and event-based applications
    using `Observable` sequences for the Java VM. In order to understand the core
    features of this framework, we need to define the core actors of ReactiveX, which
    are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava ([https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava))
    是一个Java库，它允许你使用Java VM的`Observable`序列创建异步和基于事件的程序。为了理解这个框架的核心特性，我们需要定义ReactiveX的核心角色，如下所示：
- en: '**Observables**: These represent the source of data to be emitted. An observable
    starts providing data once a subscriber starts to listen. An observable may emit
    a variable number of items and will eventually terminate with success or with
    an error.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Observables**：这些代表要发出数据的数据源。一旦订阅者开始监听，Observable就开始提供数据。Observable可以发出可变数量的项目，并最终以成功或错误结束。'
- en: '**Subscribers:** These listen to events that are emitted by observables. There
    can be one or more subscribers for one observable.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：这些监听由Observable发出的事件。一个Observable可以有零个或多个订阅者。'
- en: 'The following diagram shows the relationship between these two components:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这两个组件之间的关系：
- en: '![](img/ae69de57-5da3-409c-a331-3cb57443f8f4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae69de57-5da3-409c-a331-3cb57443f8f4.png)'
- en: 'Based on the number of items emitted and the control of the flow of items,
    we can distinguish between different types of observables:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 根据发出的项目数量和对项目流的控制，我们可以区分不同类型的Observables：
- en: '| **Observable type** | **Description** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **Observable类型** | **描述** |'
- en: '| `Flowable<T>` | Emits *0* or *n* items and terminates with a success or an
    error event. Supports backpressure, which allows us to control the rate of source
    emission. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Flowable<T>` | 发出*0*或*n*个项目，并以成功或错误事件结束。支持背压，这允许我们控制源发射的速率。 |'
- en: '| `Observable<T>` | Emits *0* or *n* items and terminates with a success or
    an error event. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Observable<T>` | 发出*0*或*n*个项目，并以成功或错误事件结束。 |'
- en: '| `Single<T>` | Emits either one value or an error notification. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `Single<T>` | 发出单个值或错误通知。 |'
- en: '| `Maybe<T>` | Emits a single item, no items, or an error event. The reactive
    version of an optional call. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `Maybe<T>` | 发出一个项目、没有项目或错误事件。可选调用的响应式版本。 |'
- en: '| `Completable` | Wraps the deferred computation without any value but only
    as an indication of completion or an exception. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `Completable` | 包裹延迟计算，没有值，但仅作为完成或异常的指示。 |'
- en: 'Let''s provide a minimalist example of this. The following is a `Hello world`
    example of an `Observable` that emits a single item:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提供一个简约的例子。以下是一个`Observable`发出单个项目的`Hello world`示例：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the subscriber receives the item, it simply prints it on the out stream.
    The following code is slightly different as it uses a `Flowable` observable to
    control the flow of items in the event you are pushing out data at a high rate,
    which could overflood your subscribers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当订阅者收到项目时，它只是简单地将其打印到输出流中。下面的代码略有不同，因为它使用了一个 `Flowable` 可观察对象来控制在高速率推送数据时项目的流动，这可能会使你的订阅者过载：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One important concept of RxJava programming is **operators**; an operator is
    a function that defines an `Observable` and how and when it should emit the data
    stream. We have already met one, that is, the `just` operator, which allows you
    to convert an object or a set of objects into an `Observable`. In our first example,
    the object was the `Hello world` string.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 编程的一个重要概念是**操作符**；操作符是一个函数，它定义了 `Observable` 以及它如何以及何时应该发射数据流。我们已经遇到过一个，那就是
    `just` 操作符，它允许你将一个对象或一组对象转换为 `Observable`。在我们的第一个例子中，对象是 `Hello world` 字符串。
- en: 'There are many more operators, all of which can be found in RxJava''s documentation
    ([http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)).
    For example, you can suppress duplicates in a stream of data using the `distinct`
    operator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他的操作符，所有这些都可以在 RxJava 的文档中找到（[http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)）。例如，你可以使用
    `distinct` 操作符在数据流中抑制重复项：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, the expected output from the subscriber will be as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，订阅者预期的输出如下：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also chain another operator to filter out items that don''t meet a
    pattern, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以链式添加另一个操作符来过滤掉不符合模式的项，如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you may have guessed, the output will be further restricted to the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，输出将进一步限制如下：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although we have barely scratched the surface of RxJava's power, we have a minimal
    background to how we plug these concepts into our example application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们对 RxJava 的强大功能只是浅尝辄止，但我们已经具备了将这些概念应用到我们的示例应用程序中的基本背景。
- en: Using RxJava with Quarkus
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Quarkus 与 RxJava
- en: In order to learn about RxJava, we will go through the example contained in
    the `Chapter09/rx2java/customer-service` folder in this book's GitHub repository.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 RxJava，我们将通过本书 GitHub 仓库中 `Chapter09/rx2java/customer-service` 文件夹中的示例进行学习。
- en: 'The first thing you should be aware of is that, in order to use RxJava with
    Quarkus, you have to add an instance of `Vertx`, which can be found under the
    `io.vertx.reativex.core` namespace:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该意识到的是，为了使用 RxJava 与 Quarkus，你必须添加一个 `Vertx` 实例，该实例位于 `io.vertx.reativex.core`
    命名空间下：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That being said, one of the main advantages of including ReactiveX in our project
    is that it will greatly enhance the capability of **transforming** data that flows
    between the observable and the subscriber.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，将 ReactiveX 包含到我们的项目中的一大主要优势是它将极大地增强在可观察对象和订阅者之间流动的数据的**转换**能力。
- en: 'For example, let''s take a look at the following use case:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看以下用例：
- en: We want to produce a file with a list of customers to be imported in a spreadsheet.
    Therefore, we will create a plain CSV file out of our customer list.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要生成一个包含要导入电子表格的客户列表的文件。因此，我们将从我们的客户列表中创建一个普通的 CSV 文件。
- en: Then, we want to convert the CSV file into any other format is coded in the
    customer's `toString` method.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们希望将 CSV 文件转换为客户的 `toString` 方法中编码的任何其他格式。
- en: 'Let''s learn how to operate the right changes on the `CustomerRepository` class.
    As we mentioned previously, the first change is to replace the `io.vertx.core.Vertx`
    instance with the corresponding `io.vertx.reativex.core.Vertx`. Then, we will
    apply some changes to the `writeFile` and `readFile` methods. Let''s begin with
    the `writeFile` method first:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何对 `CustomerRepository` 类进行适当的修改。正如我们之前提到的，第一个修改是将 `io.vertx.core.Vertx`
    实例替换为相应的 `io.vertx.reativex.core.Vertx`。然后，我们将对 `writeFile` 和 `readFile` 方法进行一些修改。让我们首先从
    `writeFile` 方法开始：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you have found our introduction to observables intuitive, the preceding code
    won't look overly complex, in spite of the proliferation of Lambda expressions.
    Here, we have added a long list of operators to produce the desired result.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得我们对可观察对象的介绍直观易懂，那么前面的代码尽管使用了大量的 Lambda 表达式，看起来也不会过于复杂。在这里，我们添加了一系列操作符以产生所需的结果。
- en: First of all, we have produced a set of observables by iterating over the customer
    list using the `Observable.fromIterable` operator. Since we need to produce a
    CSV file, we need to map single customer fields with the CSV format, which uses
    a comma (`,`) to separate the values. We have used the `map` operator for this
    purpose. Then, we are done with transformation and the result will be a list of
    observables that are in the format we have chosen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过使用`Observable.fromIterable`运算符遍历客户列表产生了一组可观察对象。由于我们需要生成一个CSV文件，我们需要将单个客户字段映射到CSV格式，该格式使用逗号（`,`）来分隔值。我们为此使用了`map`运算符。然后，我们完成了转换，结果将是一个列表，其中包含我们选择格式的可观察对象。
- en: For an observer (or subscriber) to see items that are being emitted by `Observable`,
    along with errors or completed notifications from `Observable`, it must subscribe
    to that `Observable` using the `subscribe` operator. In a nutshell, the `subscribe`
    operator is the glue that connects a subscriber to an `Observable`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个观察者（或订阅者）要看到由`Observable`发出的项目，以及来自`Observable`的错误或完成通知，它必须使用`subscribe`运算符订阅该`Observable`。简而言之，`subscribe`运算符是连接订阅者与`Observable`的粘合剂。
- en: Our subscriber will receive notifications when new items are added so that they
    can be appended to `StringBuffer`, which has already been initialized with the
    CSV header. The subscriber will also receive notifications in case of errors and
    eventually, when the stream of items gets completed, via the `()` handler. In
    this case, the CSV file will be written to the filesystem using the `writeFile`
    function, which is also available in the `io.vertx.reativex.core.Vertx` filesystem
    context.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当有新项目添加时，我们的订阅者将收到通知，以便它们可以被追加到已经初始化了CSV标题的`StringBuffer`中。在出现错误的情况下，订阅者也会收到通知，最终，当项目流完成时，通过`()`处理程序。在这种情况下，CSV文件将使用`writeFile`函数写入文件系统，该函数也存在于`io.vertx.reativex.core.Vertx`文件系统上下文中。
- en: 'Then, the `readFile` method will need to reverse the CSV file we have already
    written into the representation of the `Customer` object, as provided by its `toString`
    method. The code is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`readFile`方法需要将我们已写入的CSV文件反转成`Customer`对象表示的形式，如它的`toString`方法所提供的。代码如下：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have to familiarize ourselves with some more operators. Since we want
    to read and process the file line by line, we are using the `flatMapObservable`
    operator to produce our array of multiple `Observable` instances. In practice,
    this operator allows us to produce a set of `Observable` instances that are the
    result of a function being emitted by a single item the line in our CSV file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要熟悉一些更多的运算符。由于我们想要逐行读取和处理文件，我们使用`flatMapObservable`运算符来产生我们的多个`Observable`实例数组。在实践中，这个运算符允许我们产生一组`Observable`实例，这是由我们CSV文件中的单行发出的函数产生的结果。
- en: 'We have conveniently split the file into an array using the `split` method
    of the string''s class. Then, we used the `skip` operator to skip the first item,
    which is the CSV header. After, we applied two `map` transformations to the data:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方便地使用字符串类的`split`方法将文件分割成一个数组。然后，我们使用`skip`运算符跳过了第一个项目，即CSV标题。之后，我们对数据应用了两个`map`转换：
- en: The first one creates an array of string objects, out of the CSV line, using
    the comma (`,`) as a separator
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个操作符创建了一个字符串对象数组，从CSV行中出来，使用逗号（`,`）作为分隔符
- en: Next, we created an instance of the `Customer` object using the data arriving
    from the string array
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用从字符串数组中到达的数据创建了一个`Customer`对象的实例
- en: 'Now that we have collected our target data, which is a `Customer` object, we
    are ready to stream this data, which will eventually be collected by the subscriber.
    The subscriber, in turn, receives each item and adds the `toString()` output from
    it to the `StringBuffer`. You can include any format in your `toString()` method,
    but to keep it simple, we have let our IDE (IntelliJ IDEA) self-generate it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了我们的目标数据，即一个`Customer`对象，我们准备流式传输这些数据，这些数据最终将被订阅者收集。订阅者反过来接收每个项目，并将从它那里得到的`toString()`输出添加到`StringBuffer`中。你可以在你的`toString()`方法中包含任何格式，但为了简单起见，我们已经让我们的IDE（IntelliJ
    IDEA）自动生成它：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last thing we''ll do is set the media type of `readFile` so that it''s
    consistent with the format of our `toString` data. Since we are producing simple
    text, it will look as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的最后一件事是设置`readFile`的媒体类型，使其与我们的`toString`数据格式保持一致。由于我们正在生成简单的文本，它将如下所示：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, you can just run the application and check the new outcome. The following
    is what your UI should look like once you''ve added some customers and clicked
    on the Write File button:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需运行应用程序并检查新的结果。以下是在添加了一些客户并点击了“写入文件”按钮后，您的 UI 应该看起来像什么：
- en: '![](img/579d5247-c8fd-4625-adfe-e1db4b6f2a5d.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/579d5247-c8fd-4625-adfe-e1db4b6f2a5d.png)'
- en: 'Then, by hitting the Read File button, the lower HTML `div` will contain the
    `toString` data for each customer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过点击“读取文件”按钮，下方的 HTML `div` 将包含每个客户的 `toString` 数据：
- en: '![](img/173ae975-e619-49b2-8c73-92b4d6fbc23d.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/173ae975-e619-49b2-8c73-92b4d6fbc23d.png)'
- en: As you can see, in spite of the minimalist UI log, there is plenty of work being
    done under the hood to manage the transformation of data in different kinds of
    format.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管 UI 日志保持了极简风格，但在底层仍有大量工作在进行，以管理不同格式数据之间的转换。
- en: That was our second implementation of Vert.x and Quarkus. We still have to deal
    with the third beast, which is `io.vertx.axle.core.Vertx`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们对 Vert.x 和 Quarkus 的第二次实现。我们仍然需要处理第三个“野兽”，即 `io.vertx.axle.core.Vertx`。
- en: Decoupling events with Vert.x axle libraries
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vert.x 轴承库解耦事件
- en: Typically, we want to separate our service entry points (adapters) from the
    business logic, which is part of the application. A common pattern is to keep
    the service in a distinct bean, which is injected into our service REST entry
    point. When approaching Reactive Programming, however, we can decouple even more
    of our components by bringing the Vert.x Event Bus into the picture.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望将我们的服务入口点（适配器）与业务逻辑分开，后者是应用程序的一部分。一种常见的模式是将服务保存在一个独立的容器中，该容器被注入到我们的服务
    REST 入口点。然而，当我们接近响应式编程时，我们可以通过引入 Vert.x Event Bus 来进一步解耦我们的组件。
- en: 'In this kind of architecture, components communicate with each other by sending
    messages to virtual addresses. To manage the distribution of messages, the following
    components are available:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种架构中，组件通过向虚拟地址发送消息来相互通信。为了管理消息的分配，以下组件可用：
- en: '**EventBus**: This is a lightweight distributed messaging system that allows
    communication between the different parts of your application in a loosely coupled
    way.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EventBus**：这是一个轻量级的分布式消息系统，允许以松耦合的方式在应用程序的不同部分之间进行通信。'
- en: '**Message**: This contains data that is received from the Event Bus in a handler.
    Messages have a body and a header, both of which can be null. By adding a reply
    handler in the message, it is possible to apply a request-response pattern to
    the communication.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：这包含从 Event Bus 在处理程序中接收到的数据。消息有一个体和一个头，两者都可以为 null。通过在消息中添加回复处理程序，可以将请求-响应模式应用于通信。'
- en: Let's learn how we can instrument a simple messaging pattern by using the example
    application that's available in the `Chapter09/axle/customer-service` folder.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 `Chapter09/axle/customer-service` 文件夹中可用的示例应用程序来学习如何通过使用简单的消息模式进行仪表化。
- en: Adding an EventBus layer to Quarkus applications
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 EventBus 层添加到 Quarkus 应用程序中
- en: 'To include a distributed peer-to-peer messaging pattern in our application,
    we will need to inject the `EventBus` instance into a CDI bean, which will act
    as a receiver:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中包含分布式对等消息模式，我们需要将 `EventBus` 实例注入到一个 CDI 容器中，该容器将充当接收者：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our case, we will add the `EventBus` to the `CustomerEndpoint` class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将 `EventBus` 添加到 `CustomerEndpoint` 类中。
- en: Please note that there is only one single instance of the Event Bus per Vert.x
    instance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个 Vert.x 实例只有一个 Event Bus 实例。
- en: 'Now, in the same class, let''s create a new endpoint method, which will be
    in charge of dispatching messages:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个类中，让我们创建一个新的端点方法，它将负责分发消息：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are conveying messages on the bus through the `"callcustomer"` address. The
    body of the message contains the `Customer` object, which is retrieved by the
    `findCustomerById` method. In the event of an error, a throwable with the error's
    `getMessage` content will be thrown.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `"callcustomer"` 地址在总线上传递消息。消息体包含 `Customer` 对象，该对象通过 `findCustomerById`
    方法检索。在发生错误的情况下，将抛出一个包含错误 `getMessage` 内容的可抛出对象。
- en: 'Now, we need a consumer for messages, so we will add another class named `CustomerService`,
    which contains a method annotated as `@ConsumeEvent`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个消息消费者，因此我们将添加另一个名为 `CustomerService` 的类，其中包含一个被 `@ConsumeEvent` 注解的方法：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Within the `@ConsumeEvent` annotation, we are specifying the address where messages
    are consumed. At the end of the day, we are merely returning a response containing
    a message from the customer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@ConsumeEvent`注解中，我们指定了消息被消费的地址。最终，我们只是返回一个包含客户消息的响应。
- en: 'To complete the loop, we need to make the following changes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成循环，我们需要进行以下更改：
- en: 'We need to add one more button to the `index.html` page:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将一个按钮添加到`index.html`页面：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We need to add one more AngularJS controller to handle the response, which
    will display (in an alert window) the message:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要添加一个额外的AngularJS控制器来处理响应，该控制器将在（一个弹窗中）显示以下消息：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we have added everything, let's run our application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一切，让我们运行我们的应用程序。
- en: Rolling up the application
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收敛应用程序
- en: 'When all the changes are in place, you should be able to see that the Call
    button has been added to each customer''s row, as shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有更改都到位后，你应该能够看到呼叫按钮已经添加到每个客户的行中，如下面的截图所示：
- en: '![](img/65752cf0-e3d0-4b77-b5b4-9e388c6ea837.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/65752cf0-e3d0-4b77-b5b4-9e388c6ea837.png)'
- en: 'When you click on the Call button, a message will be sent through the Event
    Bus. As soon as it''s consumed, you should see the following response:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击呼叫按钮时，将通过事件总线发送一条消息。一旦被消费，你应该看到以下响应：
- en: '![](img/505134b9-4543-446a-be13-13b64b9f08be.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/505134b9-4543-446a-be13-13b64b9f08be.png)'
- en: Besides peer-to-peer messaging, you can also use the Vert.x axle API to stream
    **Server-Side Events** (**SSEs**).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了点对点消息之外，你还可以使用Vert.x轴API来流式传输**服务器端事件**（**SSEs**）。
- en: Streaming SSE with Vert.x
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vert.x流式传输SSE
- en: Traditionally, web applications are capable of sending a request to servers
    to receive a response; that is the standard paradigm. With server-send events,
    however, it's possible for the server application to send new data to a web page
    at any time by pushing events (messages) to the web page. These incoming messages
    are treated as events combined with data inside the web page.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Web应用程序能够向服务器发送请求以接收响应；这就是标准范式。然而，通过服务器发送事件，服务器应用程序可以在任何时候通过向网页推送事件（消息）来向网页发送新数据。这些传入的消息被作为网页内部的事件与数据结合处理。
- en: 'Now, let''s demonstrate how to use the Vert.x axle API to stream SSEs in Quarkus.
    The following class, which has been included in our project, is in charge of sending
    an SSE to the home page every two seconds:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示如何使用Vert.x轴API在Quarkus中流式传输SSE。以下被包含在我们项目中的类，负责每两秒向主页发送一个SSE：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First off, notice that we are using an instance of `io.vertx.axle.core.Vertx`
    to handle the streaming of events. Then, our REST method, which is bound to the
    `"/streaming"` URI, is annotated with a different media type, that is, `SERVER_SENT_EVENTS`.
    The method returns a publisher type, which is required in order to publish Reactive
    Streams.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意我们正在使用`io.vertx.axle.core.Vertx`的一个实例来处理事件的流式传输。然后，我们的REST方法，绑定到`"/streaming"`URI，被注解为不同的媒体类型，即`SERVER_SENT_EVENTS`。该方法返回一个发布者类型，这是发布Reactive
    Streams所必需的。
- en: By using the `ReactiveStreams.fromPublisher` method, we push stream events based
    on the frequency specified by `vert.xperiodicStream`. In our case, messages will
    be dispatched every two seconds. Before sending the actual event, the content
    will be transformed by the `map` operator, which will create a message with some
    `Customer` statistics, such as the number of customers and the last one added.
    By using the ternary operator, we managed to compress this login into just one
    statement, at the expense of slightly more complex readability.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ReactiveStreams.fromPublisher`方法，我们根据`vert.xperiodicStream`指定的频率推送流事件。在我们的例子中，消息将每两秒分发一次。在发送实际事件之前，内容将通过`map`操作符进行转换，这将创建一个包含一些`Customer`统计信息（如客户数量和最后添加的客户）的消息。通过使用三元操作符，我们成功地将这个逻辑压缩成只有一句话，但牺牲了稍微复杂一点的可读性。
- en: 'That''s all you need on the server-side. On the client-side, we made some other
    adaptations:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端你需要的就是这些。在客户端，我们做了一些其他的适配：
- en: 'We added one more button to trigger the SSE:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个额外的按钮来触发SSE：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We added a callback method, in JavaScript, to handle the event that was received:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在JavaScript中添加了一个回调方法来处理接收的事件：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We added a `div` where messages will be displayed:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个`div`，消息将在其中显示：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we run the updated application, the expected outcome is a UI that includes
    the Stats button at the bottom of it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行更新后的应用程序时，预期的结果是包含底部Stats按钮的UI：
- en: '![](img/b2901875-bcc9-49ee-a8ba-810a390dbf2b.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/b2901875-bcc9-49ee-a8ba-810a390dbf2b.png)'
- en: The lower `div` will be updated every two seconds, based on the data contained
    in the customer list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 较低级别的 `div` 将每两秒更新一次，基于客户列表中的数据。
- en: Canceling events
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消事件
- en: 'It''s worth mentioning that SSE subscriptions can be canceled by keeping a
    reference to the `Subscription` object so that you can cancel your subscription
    at any time:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，可以通过保持对 `Subscription` 对象的引用来取消 SSE 订阅，这样你就可以在任何时候取消你的订阅：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, when the event is emitted, the observer's `onNext`
    method is called with the item and the `onComplete` method is invoked immediately
    after. On the other hand, when the callback is a failure, the observer's `onError`
    method is called. Within any callback method, we can cancel the subscription using
    the `cancel` method on the subscription object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，当事件发出时，观察者的 `onNext` 方法会使用项目被调用，紧接着调用 `onComplete` 方法。另一方面，当回调是失败时，观察者的
    `onError` 方法会被调用。在任何回调方法中，我们都可以使用订阅对象的 `cancel` 方法来取消订阅。
- en: 'This was our last piece of work with Reactive Events, but not the last with
    Vert.x. We still have one more thing to cover: Quarkus'' Reactive SQL Clients.
    This is an API that focuses on scalable JDBC connections with minimal overhead.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们与 Reactive Events 的最后一次合作，但不是与 Vert.x 的最后一次。我们还有一件事要讲：Quarkus 的 Reactive
    SQL 客户端。这是一个专注于具有最小开销的可扩展 JDBC 连接的 API。
- en: Managing the Reactive SQL Client
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理反应式 SQL 客户端
- en: 'The Reactive SQL Client is an API that allows you to use reactive and non-blocking
    features of Vert.x to access a relational database. This brings some changes in
    terms of how you access your data. Let''s put the costs and benefits on the table:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式 SQL 客户端是一个 API，允许你使用 Vert.x 的反应式和非阻塞特性来访问关系数据库。这在访问数据的方式上带来了一些变化。让我们把成本和收益列出来：
- en: On one side, you will need to use SQL statements to enable your RDBMS to access
    data, instead of the abstract HQL. Also, automatic mapping between Java classes
    and DB is not available anymore since Hibernate is out of the game here.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一方面，你需要使用 SQL 语句来启用你的 RDBMS 访问数据，而不是抽象的 HQL。由于 Hibernate 不再适用，Java 类和数据库之间的自动映射也不再可用。
- en: On the other hand, you will be able to use a fully event-driven, non-blocking,
    lightweight alternative to stream the result of your SQL statements.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，你将能够使用完全事件驱动、非阻塞、轻量级的替代方案来流式传输 SQL 语句的结果。
- en: Based on your requirements, you may stick with Hibernate's API or switch to
    Reactive's SQL Client. Let's say you're brave and want to switch to Reactive SQL.
    To do that, you will need to configure your application so that it can use the
    PostgreSQL Reactive Client API.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需求，你可以继续使用 Hibernate 的 API 或切换到反应式 SQL 客户端。假设你很勇敢，想要切换到反应式 SQL。为此，你需要配置你的应用程序，使其能够使用
    PostgreSQL 反应式客户端 API。
- en: Configuring your application to use the PostgreSQL reactive client
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序以使用 PostgreSQL 反应式客户端
- en: 'In order to delve into the reactive Client API, please refer to the example
    contained in the `Chapter09/pgpool` folder in this book''s GitHub repository.
    Since this example won''t use the PostgreSQL JDBC driver, the following dependency
    has been added as a replacement:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入了解反应式客户端 API，请参阅本书 GitHub 仓库中 `Chapter09/pgpool` 文件夹中的示例。由于此示例不会使用 PostgreSQL
    JDBC 驱动程序，以下依赖项已被添加为替代品：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The other configuration we added was the JDBC URL, which needs to be in the
    following format:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的另一个配置是 JDBC URL，它需要以下格式：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Therefore, in our example, we will add this setting in `application.properties`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例中，我们将在 `application.properties` 中添加此设置：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, let's look at the changes in our application. To keep things as simple
    as possible, we have broken down our example so that it just uses the `CustomerEndpoint`
    and the `Customer` POJO class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们应用程序中的变化。为了尽可能保持简单，我们将示例分解，使其仅使用 `CustomerEndpoint` 和 `Customer` POJO
    类。
- en: 'Let''s begin with the `CustomerEndpoint`, which requires access to `io.vertx.axle.pgclient.PgPool`
    and `io.vertx.core.Vertx`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `CustomerEndpoint` 开始，它需要访问 `io.vertx.axle.pgclient.PgPool` 和 `io.vertx.core.Vertx`：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Within the same class, we have added an `init` method to create some data at
    startup:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个类中，我们添加了一个 `init` 方法，在启动时创建一些数据：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Pgpool's `query` method returns a `CompletionStage` object with a `RowSet` of
    data, as a result of the query. Please note how we can chain multiple statements
    to produce a `CompletableFuture`, which spins off the execution in another thread.
    Within this simple method, you can experience how powerful reactive SQL clients
    can be when it comes to creating event-driven, non-blocking SQL executions. You
    will eventually get the combined result of all the statements by executing the
    `join` method of `CompletableFuture` at the end.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Pgpool的`query`方法返回一个包含数据`RowSet`的`CompletionStage`对象，这是查询的结果。请注意我们如何将多个语句链接起来以生成一个`CompletableFuture`，它将在另一个线程中启动执行。在这个简单的方法中，你可以体验一下当涉及到创建事件驱动的、非阻塞的SQL执行时，反应式SQL客户端有多么强大。你最终将通过在`CompletableFuture`的末尾执行`join`方法来获得所有语句的合并结果。
- en: 'The other methods of `CustomerEndpoint` delegate the execution of CRUD statements
    to the `Customer` class using the same composition pattern:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerEndpoint`的其他方法使用相同的组合模式将CRUD语句的执行委托给`Customer`类：'
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Within the `Customer` class, we have coded all the methods that are required
    to perform CRUD operations. The first one, `create`, performs an `INSERT` in the
    `CUSTOMER` table by using `PreparedStatement`, which applies a tuple containing
    the name and surname as an argument:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Customer`类中，我们编写了所有执行CRUD操作所需的方法。第一个方法`create`通过使用`PreparedStatement`在`CUSTOMER`表中执行一个`INSERT`操作，将包含姓名和姓氏的元组作为参数：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In much the same way, the `update` method executes an `UPDATE` through a `PreparedStatement`,
    and applies the customer''s tuple of data as a parameter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`update`方法通过`PreparedStatement`执行`UPDATE`操作，并将客户的元组数据作为参数应用：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To remove a customer, the `delete` method executes `PreparedStatement`, which
    uses the customer `id` as a parameter:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除客户，`delete`方法执行`PreparedStatement`，它使用客户`id`作为参数：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, the `findAll` method is used to query a list of customers from the
    database and returns them as a Java list:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`findAll`方法从数据库查询客户列表，并将它们作为Java列表返回：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have finished coding our application. Let's get it running!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了应用程序的编码。让我们让它运行起来！
- en: Running the example
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'Before running the example, make sure you have bootstrapped the PostgreSQL
    database; otherwise, the initial statements will fail when the application is
    deployed:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例之前，请确保你已经初始化了PostgreSQL数据库；否则，当应用程序部署时，初始语句将失败：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, run the application as usual with the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令按常规运行应用程序：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The UI hides the fact that we have switched from plain objects to a real database,
    though you can work out that this has happened from the page title, which is now
    Quarkus Vert.X PgPool Example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: UI隐藏了我们从普通对象切换到真实数据库的事实，尽管你可以从页面标题中推断出这一点，现在标题是Quarkus Vert.X PgPool Example：
- en: '![](img/cd40a029-5c1c-4dcf-ba2b-0e2af385763d.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd40a029-5c1c-4dcf-ba2b-0e2af385763d.png)'
- en: 'However, if you log in to the database container, you verify sure that the
    `Customer` table has been created with its items. Let''s find the container ID
    for this purpose:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你登录到数据库容器，你可以确认`Customer`表已经创建并包含其项。让我们找到用于此目的的容器ID：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s go into the bash shell of the PostgreSQL container by using the
    `docker exec` command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`docker exec`命令进入PostgreSQL容器的bash shell：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can check the list of relationships using the `\dt` shortcut:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`\dt`快捷键检查关系列表：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can also query the `Customer` table''s rows, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以按照以下方式查询`Customer`表的行：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Great! We have completed our first reactive SQL application with Quarkus. This
    also marks the end of our journey into the land of Vert.x.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经完成了我们的第一个使用Quarkus的反应式SQL应用程序。这也标志着我们进入Vert.x世界的旅程的结束。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: From this whirlwind tour of Reactive Programming, you should be proficient in
    writing reactive applications on the JVM. Your programming skills now include
    how to use the Vert.x core API to write asynchronous and non-blocking services.
    You have also learned how to combine the `Observable` pattern with streams or
    asynchronous results using the Vert.x Reactive API. Then, we quickly explored
    the last Vert.x paradigm, Vert.x Axle, which allows different beans to interact
    using asynchronous messages and enforces loose coupling. Finally, we applied a
    reactive API to access a relational database using the PostgreSQL client extension
    for Vert.x.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对响应式编程的快速浏览，你应该已经熟练掌握了在JVM上编写响应式应用程序。你的编程技能现在包括如何使用Vert.x核心API编写异步和非阻塞服务。你还学习了如何使用Vert.x响应式API将`Observable`模式与流或异步结果相结合。然后，我们迅速探索了最后一个Vert.x范式，Vert.x
    Axle，它允许不同的bean通过异步消息进行交互并强制松耦合。最后，我们应用了响应式API，通过Vert.x的PostgreSQL客户端扩展来访问关系数据库。
- en: Although you've gotten to grips with the Reactive Programming API, note that
    much of its power can only be unleashed when building real-time data pipelines
    and streaming data. We will cover these in the next chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已经掌握了响应式编程API，请注意，其大部分功能只有在构建实时数据管道和流式数据时才能充分发挥。我们将在下一章中介绍这些内容。
