- en: Introduction to Quarkus Core Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quarkus核心概念简介
- en: 'Java was introduced to the open source community over 20 years ago. Since then,
    we cannot think of a single large IT company or organization that doesn''t use
    Java. For this reason, Java is often regarded as a **corporate** language, which
    is not a bad thing *per se*: Java is the enterprise standard, and it''s an extremely
    mature language with a huge ecosystem of tools and libraries around it and still
    the most used language by developers in the world.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 早在20多年前就被引入开源社区。从那时起，我们无法想到有任何一家大型IT公司或组织不使用Java。因此，Java常常被视为一种**企业级**语言，这本身并不是坏事：Java是企业标准，它是一个极其成熟的语言，周围有一个庞大的工具和库生态系统，并且仍然是全球开发者使用最多的语言。
- en: 20 years in the IT industry is, however, a considerable amount of time. Since
    the beginning, Java has gone through a long list of optimizations with the burden
    of keeping backward compatibility with earlier releases. Today, however, the IT
    landscape has significantly changed with the rise of new standards such as the
    cloud, containers, microservices, and Reactive Programming. Do we still need to
    use Java to address the latest application architectures and reach a higher level
    of productivity and efficiency? Yes! This book promises to do this while teaching
    you about **Quarkus**, a Kubernetes-native framework that will take supersonic,
    subatomic Java to new heights!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在IT行业20年是一个相当长的时间。从开始，Java就经历了一系列优化，同时承担着与早期版本保持向后兼容性的负担。然而，如今，随着云、容器、微服务和响应式编程等新标准的兴起，IT格局已经发生了显著变化。我们是否还需要使用Java来应对最新的应用程序架构，并达到更高的生产力和效率水平？是的！本书承诺在向您介绍**Quarkus**的同时做到这一点，Quarkus是一个Kubernetes原生框架，它将把超音速、亚原子级的Java提升到新的高度！
- en: In the first part of this book, we will learn how to create Quarkus applications
    with simple tools while using a development environment to code, execute, and
    debug them. After completing all the green bars, we will concentrate on advanced
    topics to show you how to combine multiple Quarkus extensions to produce a serverless
    infrastructure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，我们将学习如何使用简单的工具创建Quarkus应用程序，同时使用开发环境进行编码、执行和调试。完成所有绿色条目后，我们将专注于高级主题，向您展示如何结合多个Quarkus扩展来构建无服务器基础设施。
- en: 'As far as this chapter is concerned, we will have a quick tour of the Quarkus
    technology by covering these topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 就本章而言，我们将通过涵盖以下主题来快速浏览Quarkus技术：
- en: An overview of the IT landscape, showing the benefits of cloud-native applications
    and microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IT格局概述，展示云原生应用程序和微服务的优势
- en: The basics of the Quarkus architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus架构的基本原理
- en: Installing the required software (GraalVM to compile code natively and a development
    environment)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装所需的软件（GraalVM用于本地编译代码和开发环境）
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到该项目的源代码，请参阅本章中的[https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter01)。
- en: From the big data hype to Kubernetes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从大数据炒作到Kubernetes
- en: About 10 years ago, the biggest buzz in the IT industry was the term *big data*.
    Every major enterprise was racing to harness the mystical powers of massive, yet
    supposedly manageable, silos of data. Equipped with big data, no problem would
    prove insurmountable, and all forecasts would be met.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大约10年前，IT行业最大的炒作是“大数据”这个术语。每个主要企业都在竞相利用庞大的、但据说可管理的、神秘的数据孤岛的力量。有了大数据，没有任何问题是不可以克服的，所有的预测都会实现。
- en: But lately, these forecasts appear to have faded, and the worst-kept secret
    in the IT industry is that big data is dead – at least as we knew it. This doesn't
    mean that the volume or growth of data has broken down – or the opposite. It's
    just the underlying technology that has changed, which means that the architectures
    of applications that use big data have too.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但最近，这些预测似乎已经消退，IT行业最不为人知的秘密是大数据已经死亡——至少是我们所知道的大数据。这并不意味着数据的量或增长已经崩溃——或者相反。这只是底层技术发生了变化，这意味着使用大数据的应用程序架构也发生了变化。
- en: Take Hadoop as an example, which has been the icon of the big data hype. It
    was designed based on a set of assumptions that dramatically changed in a short
    time. One of these assumptions was that, in order to process a large batch of
    data, network latency was the evil and cloud-native storage simply wasn't an option.
    At that time, most of the IT industry data was on-premise, so the focus was on
    avoiding moving around big sets of information. This meant that data was to be
    co-located in order to compute it efficiently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以Hadoop为例，它一直是大数据炒作的标志。它基于一系列假设设计，这些假设在短时间内发生了巨大变化。其中之一是，为了处理大量数据，网络延迟是邪恶的，云原生存储根本不是一种选择。当时，大多数IT行业数据都在本地，因此重点是避免移动大量信息。这意味着数据需要集中存储以便高效计算。
- en: 'Today, this scenario has changed quite a bit: most applications still use large
    amounts of data, but data is now processed on the fly. That is to say, we now
    stream data instead of processing the whole dataset multiple times.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，这种场景已经发生了很大变化：大多数应用程序仍然使用大量数据，但现在数据是实时处理的。也就是说，我们现在流式传输数据而不是多次处理整个数据集。
- en: Besides this, the network latency barrier has become less of an issue for cloud
    providers and there are even multiple cloud sources to choose from. Also, companies
    now have the option to deploy their own private cloud on-premise, leading to new
    scenarios such as **hybrid clouds**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，网络延迟障碍对云服务提供商来说已经不再是问题，甚至有多个云源可供选择。此外，公司现在可以选择在自己的本地部署自己的私有云，从而产生新的场景，如**混合云**。
- en: 'Therefore, the focus is what really changed: today, big data does not merely
    mean a **big** quantity of datasets but flexible storage options for a big quantity
    of data.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，重点是真正发生了什么变化：今天，大数据不仅仅意味着大量数据集的**大**量，而是大量数据的灵活存储选项。
- en: This is where containers and, specifically, Kubernetes fits in. In a nutshell,
    you can think of a container as a packaged application that contains just the
    libraries that are needed to run it, and Kubernetes is like an orchestrating system
    that makes sure all the containers have the appropriate resources while managing
    their life cycle.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是容器和，特别是Kubernetes的适用之处。简而言之，你可以把容器想象成一个打包的应用程序，它只包含运行它所需的库，而Kubernetes就像是一个编排系统，确保所有容器都有适当的资源，同时管理它们的生命周期。
- en: Kubernetes runs images and manages containers using **Docker**. However, Kubernetes
    can use other engines too (for example, `rkt`). Since we will be building our
    applications on top of Kubernetes, we will provide a short overview of its architecture
    in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用**Docker**运行镜像并管理容器。然而，Kubernetes也可以使用其他引擎（例如，`rkt`）。由于我们将在Kubernetes之上构建我们的应用程序，因此我们将在下一节中简要概述其架构。
- en: The Kubernetes architecture in a nutshell
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes架构概述
- en: 'The architecture of Kubernetes is focused around the concept of a loosely coupled,
    flexible mechanism for service discovery. Like most other distributed middleware
    platforms, a Kubernetes cluster is composed of one or more master nodes and multiple
    compute nodes. The following diagram depicts a high-level view of a Kubernetes
    cluster:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的架构侧重于服务发现的概念，这是一种松散耦合且灵活的机制。像大多数其他分布式中间件平台一样，一个Kubernetes集群由一个或多个主节点和多个计算节点组成。以下图表展示了Kubernetes集群的高级视图：
- en: '![](img/5c429d97-786f-47cd-b488-d902f5897574.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c429d97-786f-47cd-b488-d902f5897574.png)'
- en: '**Kubernetes Master nodes** essentially make up the brain of the cluster. They
    are responsible for managing the overall cluster, exposing APIs, and scheduling
    deployments. **Kubernetes nodes** (right-hand side of the preceding diagram) contain
    the services that are needed to run applications in components called Pods.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes主节点**本质上构成了集群的大脑。它们负责管理整个集群，暴露API，以及调度部署。**Kubernetes节点**（前一张图的右侧）包含运行在Pod组件中的应用所需的服务。'
- en: 'Each **master node** contains the following components:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主节点包含以下组件：
- en: '**API Server**: This synchronizes and validates the information running in
    Pods and services.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API服务器**：此服务器同步并验证Pod和服务的运行信息。'
- en: '**etcd**: This provides consistent and highly available storage for the cluster
    data. You can think of `etcd` as the brain''s shared memory.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**：这为集群数据提供一致且高度可用的存储。你可以把`etcd`看作是大脑的共享内存。'
- en: '**Controller Manager server**: This checks for changes in the `etcd` service
    and uses its API to enforce the desired state.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器管理器服务器**：此服务器检查`etcd`服务的更改，并使用其API强制执行所需状态。'
- en: '**HAProxy**: This can be added when we''re configuring HA masters to balance
    loads between several master endpoints.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HAProxy**：在配置HA主节点以在多个主端点之间平衡负载时可以添加此组件。'
- en: '**Kubernetes nodes** (simply called **nodes**) can be considered workhorses
    of a Kubernetes cluster. Each node exposes a set of resources (such as computing,
    networking, and storage) to your applications. The node also ships with additional
    components for service discovery, monitoring, logging, and optional add-ons. In
    terms of infrastructure, you can run a node as a **virtual machine** (**VM**)
    in your cloud environment or on top of bare-metal servers running in the data
    center.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes节点**（简称**节点**）可以被视为Kubernetes集群的驮马。每个节点向您的应用程序提供一组资源（例如计算、网络和存储）。节点还包含用于服务发现、监控、日志记录和可选附加组件的附加组件。在基础设施方面，您可以在云环境中或数据中心运行的裸机服务器上以**虚拟机**（**VM**）的形式运行节点。'
- en: 'Each node contains the following components:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点包含以下组件：
- en: '**Pod**: This allows us to logically group containers and pieces of our application
    stacks together. A Pod acts as the logical boundary for such containers with shared
    resources and contexts. Pods can be scaled at runtime by creating Replica sets.
    This, in turn, ensures that the required number of Pods is always run by the deployment.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**: 这使我们能够逻辑地将容器和我们的应用程序堆栈的各个部分组合在一起。Pod充当具有共享资源和上下文的此类容器的逻辑边界。Pod可以通过创建副本集在运行时进行扩展。这反过来又确保了部署始终运行所需数量的Pod。'
- en: '**Kubelet**: This is an agent that runs on each node in the Kubernetes cluster.
    It makes sure that the containers are running in a Pod.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubelet**：这是一个在Kubernetes集群中的每个节点上运行的代理。它确保容器在Pod中运行。'
- en: '**Kube-Proxy**: This maintains network rules on nodes to allow network communication
    between Pods.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kube-Proxy**：这维护节点上的网络规则，以允许Pod之间的网络通信。'
- en: '**Container Runtime**: This is the software that is responsible for running
    containers. Kubernetes supports multiple container runtimes (such as Docker, `containerd`,
    `cri-o`, and `rktlet`).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器运行时**：这是负责运行容器的软件。Kubernetes支持多种容器运行时（如Docker、`containerd`、`cri-o`和`rktlet`）。'
- en: Now that we've covered the basics of the Kubernetes architecture, let's look
    at the top advantages that it can bring to your organization.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Kubernetes架构的基本知识，让我们来看看它可以为您的组织带来的主要优势。
- en: Benefits of using Kubernetes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes的好处
- en: 'The advantages that Kubernetes can bring to your organization are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以为您的组织带来的优势如下：
- en: Kubernetes greatly simplifies container management. As you have learned, when
    using Kubernetes, there's no need to manage containers directly. Instead, you
    just to have manage Pods. In order to have your applications available in your
    Pods, Kubernetes introduced an abstraction called a **service**. It defines a
    logical set of Pods with their IP address. This level of abstraction enhances
    fault tolerance and reduces downtime by launching containers on different machines.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes极大地简化了容器管理。如您所知，在使用Kubernetes时，无需直接管理容器。相反，您只需管理Pod。为了使您的应用程序在Pod中可用，Kubernetes引入了一个称为**服务**的抽象。它定义了一个具有其IP地址的逻辑Pod集合。这种抽象级别提高了容错性并减少了停机时间，通过在多台机器上启动容器来实现。
- en: Kubernetes speeds up the process of building, testing, and releasing software
    by supporting a wide range of programming languages (Java, Go, Python, and so
    on) and offering advanced deployment features (automated rollouts and rollbacks,
    canary deployments, and more). This makes it a lot easier to configure effective
    **Continuous Integration/Continuous Delivery** (**CI/CD**) pipelines for your
    software.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes通过支持广泛的编程语言（如Java、Go、Python等）和提供高级部署功能（如自动化部署和回滚、金丝雀部署等）来加速构建、测试和发布软件的过程。这使得为您的软件配置有效的**持续集成/持续交付**（**CI/CD**）管道变得容易得多。
- en: Kubernetes provides the fastest and least costly horizontal scalability for
    your pods, so when the number of users for your application increases, you can
    configure the replication service to fire new Pods and balance the load across
    them to avoid downtime.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes为您的Pod提供最快且成本最低的水平扩展，因此当您的应用程序的用户数量增加时，您可以配置复制服务以触发新的Pod，并在它们之间平衡负载以避免停机。
- en: It's worth mentioning that Kubernetes is able to manage both stateless and stateful
    applications, because it allows ephemeral storage and persistent volumes. It also
    supports a number of storage types, such as NFS, GlusterFS, and cloud storage
    systems. Furthermore, a **persistent volume** (**PV**) life cycle doesn't depend
    on any pod using it, so you can keep the data as long as you need it.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，Kubernetes能够管理无状态和有状态的应用程序，因为它允许临时存储和持久卷。它还支持多种存储类型，如NFS、GlusterFS和云存储系统。此外，**持久卷**（**PV**）的生命周期不依赖于任何使用它的Pod，因此您可以保留数据直到您需要它。
- en: The benefits of using Kubernetes as a service orchestrator in your industry
    are clearly evident, but the next question is, how do we write our services to
    get the most out of this architecture? Can we still write our applications using
    the same standards we have learned about in the last few years? The next section
    will address this dilemma.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的行业中使用Kubernetes作为服务编排器的优势显而易见，但下一个问题是，我们如何编写我们的服务以充分利用这种架构？我们是否还可以使用我们在过去几年中学到的相同标准来编写我们的应用程序？下一节将解决这个困境。
- en: From Java EE to MicroProfile
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Java EE到MicroProfile
- en: '**Java Enterprise Edition** (**EE**) has reached an outstanding level of maturity
    and has a huge adoption in the IT Enterprise. A Java EE application is typically
    packaged as a monolithic application and deployed in an application server, which
    can host multiples of them.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java企业版**（**EE**）已经达到了一个卓越的成熟度，并在IT企业中有巨大的采用率。一个Java EE应用程序通常被打包成一个单体应用程序，并在应用程序服务器中部署，它可以托管多个这样的应用程序。'
- en: A monolithic application can be thought of as a self-contained application that
    includes both the user interface and the business components that are required
    to run the applications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将单体应用程序视为一个自包含的应用程序，它包括运行应用程序所需的用户界面和业务组件。
- en: 'This approach has been widely used for years. The reason is simple: monolithic
    applications are conceptually simple to develop and package because everything
    is contained in a bundle and can be edited with a single IDE. Also, scaling monolithic
    applications is simple: all you need to do is scale a single component.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法已经广泛使用了多年。原因是简单的：单体应用程序在概念上简单易开发打包，因为所有内容都包含在一个包中，并且可以使用单个IDE进行编辑。此外，扩展单体应用程序很简单：您只需要扩展单个组件。
- en: As a result, the traditional way of coding enterprise applications produced
    an extremely large set of applications that were supposed to be available as long-running
    processes and needed an application server to manage their **High Availability**
    (**HA**). In turn, some other tooling was needed to manage server restarts in
    the case of failures and to check the overall health of the system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，传统的企业应用程序编码方式产生了一大批应用程序，这些应用程序应该作为长时间运行的过程提供，并需要一个应用程序服务器来管理它们的**高可用性**（**HA**）。反过来，在出现故障的情况下，需要一些其他工具来管理服务器重启并检查系统的整体健康状况。
- en: 'As server-based monolithic applications continued growing, several disadvantages
    became evident, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着基于服务器的单体应用程序的持续增长，几个缺点变得明显，如下所述：
- en: '**Difficult to maintain**: This is due to the size of the applications, which
    makes it complex to create a patch for them.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以维护**：这是由于应用程序的大小，这使得为它们创建补丁变得复杂。'
- en: '**Limited scalability**: You can scale the whole application, not the single
    services.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的扩展性**：您可以扩展整个应用程序，而不是单个服务。'
- en: '**Longer release cycles**: Any changes that are made to the code require that
    we deploy the whole application, which complicates things when multiple teams
    are working on the same application.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**较长的发布周期**：对代码所做的任何更改都需要我们部署整个应用程序，这在多个团队在同一应用程序上工作时会使得事情变得复杂。'
- en: '**Less isolation**: Deploying multiple applications in an application server
    can potentially lead to a whole system failure from a single application misbehaving.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性较差**：在应用程序服务器中部署多个应用程序可能导致整个系统因单个应用程序的异常行为而失败。'
- en: '**Slower startup**: The startup time of a full monolithic stack is ill-famed
    to be slow, especially if multiple applications are deployed at the same time
    and potentially competing for the same resources.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动速度较慢**：完整的单体堆栈的启动时间以慢而闻名，尤其是在多个应用程序同时部署并可能竞争相同资源的情况下。'
- en: '**Complex monitoring**: It is harder to monitor and tune the activity of a
    single monolithic application which delivers a myriad of metrics.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的监控**：监控和调整单个单体应用程序的活动更加困难，因为它提供了大量的指标。'
- en: '**More complex CI/CD**: Configuring a CI/CD pipeline for multiple monolithic
    applications is equally as hard.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更复杂的CI/CD**：为多个单体应用配置CI/CD管道同样困难。'
- en: In this scenario, a new paradigm called **microservices** emerged around a simple
    yet not new idea. The main theme behind microservices is that, for certain types
    of applications, once they are split into smaller and composable pieces, it's
    easier to build and maintain them. In a service-based architecture, we don't need
    to measure the uptime of our applications in weeks or months anymore since we
    can activate our services when they are needed. Therefore, the timing factor can
    be as little as minutes or seconds.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个名为**微服务**的新范式围绕着简单但并非全新的想法出现。微服务背后的主要主题是，对于某些类型的应用，一旦它们被分割成更小且可组合的部分，它们就更容易构建和维护。在基于服务的架构中，我们不再需要用周或月来衡量我们应用的正常运行时间，因为我们可以在需要时激活我们的服务。因此，时间因素可以少到分钟或秒。
- en: In such an architecture, each component has its own life cycle spanning from
    development to testing, and the resulting application is simply the combination
    of all these single components. This approach marks a sensible departure from
    **monolithic** applications, where everything is built and tested as a single
    unit.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种架构中，每个组件都有自己的生命周期，从开发到测试，而最终的应用只是所有这些单个组件的组合。这种方法与将所有内容作为一个单一单元构建和测试的**单体**应用相比，是一个合理的转变。
- en: 'Applications that are built as a set of smaller modular components are simpler
    to understand, easier to test/debug, and easier to maintain over the application
    life cycle. A microservice architecture leverages the agility of your company
    by reducing the time it takes to deploy improvements to production. This approach
    has been tried and tested and is superior for the following reasons:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用构建为一系列较小的模块化组件，这些组件更容易理解，更容易测试/调试，并且在应用生命周期中更容易维护。微服务架构通过减少将改进部署到生产所需的时间，利用了公司的敏捷性。这种方法经过尝试和测试，并且以下原因使其优于其他方法：
- en: '**Increased resilience**: The microservice architecture increases the system''s
    overall capability to withstand any kind of unexpected failures or faults of components
    or networks by spinning up another component, even as the remaining application
    continues to function.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的弹性**：微服务架构通过启动另一个组件来提高系统的整体能力，以承受任何类型的意外故障或组件或网络的故障，即使剩余的应用继续运行。'
- en: '**Developer independence**: By working in smaller teams in parallel, you can
    speed up the work that''s being done, especially for large enterprise applications
    that are composed of teams that are geographically and culturally diverse.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者独立性**：通过并行工作在较小的团队中，你可以加快正在进行的工作，特别是对于由地理和文化上多元化的团队组成的大型企业应用来说。'
- en: '**Scalability**: Fewer resources are demanded by smaller components. This means
    we can easily scale them to meet the increasing demand of only that specific component.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：较小的组件需要的资源更少。这意味着我们可以轻松地将它们扩展以满足特定组件不断增加的需求。'
- en: '**CI/CD life cycle automation**: Single components fit smoothly into CD pipelines
    and scenarios that have complex deployment.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD生命周期自动化**：单个组件可以无缝地融入CD管道和具有复杂部署的场景。'
- en: '**Simpler mapping with the business**: Microservice architectures are easier
    to map with the business domain logic since they have increasing independence
    and transparency across the organization.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与业务更简单的映射**：由于微服务架构在组织内具有不断增加的独立性和透明度，因此它们更容易与业务领域逻辑进行映射。'
- en: To obtain the best results from our **Software as a Service** (**SaaS**), a
    methodology is required. In the next section, we will discuss the Twelve-Factor
    App methodology, which is recommended by developers for smoothly working and delivering
    applications with a focus on microservices.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的**软件即服务**（**SaaS**）中获得最佳结果，需要一种方法论。在下一节中，我们将讨论由开发者推荐的十二要素应用方法论，该方法论旨在通过关注微服务，实现应用的平稳运行和交付。
- en: The Twelve-Factor App methodology
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十二要素应用方法论
- en: 'In 2011, the Heroku founder Adam Wiggins published **the Twelve-Factor App**
    methodology, which soon became a key reference for building **Software as a Service**
    (**SaaS**) based on their own experiences. This methodology is not exclusive to
    any programming language but is compatible with a microservices architecture and
    is based on containers and CI/CD pipelines. Let''s take a look at the 12 factors:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在2011年，Heroku的创始人Adam Wiggins发布了**十二要素应用**方法论，这个方法论很快成为了基于他们自身经验的构建**软件即服务**（**SaaS**）的关键参考。这个方法论不局限于任何编程语言，与微服务架构兼容，并基于容器和CI/CD管道。让我们来看看这12个因素：
- en: '**Code base**: You should build your application on top of one code base, tracked
    by a **Version Control System** (**VCS**). You should rely on a base repository
    for an individual application to ease CI/CD pipelines. It follows that deployments
    should be automatic so that everything can run in different environments without
    anything needing to be done.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码库**: 你应该在单个代码库的基础上构建你的应用程序，该代码库由**版本控制系统**（**VCS**）跟踪。你应该依赖一个基础仓库来简化单个应用程序的持续集成/持续部署（CI/CD）流程。因此，部署应该是自动的，这样一切都可以在不同的环境中运行，而不需要做任何事情。'
- en: '**Dependencies**: Don''t push any dependencies to your project code base. Instead,
    use a package manager so that you will have all the dependencies synced across
    your environments to make sure you reproduce the same behavior.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**: 不要将任何依赖项推送到你的项目代码库。相反，使用包管理器，这样你将能够在你的环境中同步所有依赖项，以确保你可以重现相同的行为。'
- en: '**Config**: Store your configuration in environment variables. The configuration
    should be well parted from the code so that the configuration varies in terms
    of where the application has been deployed.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**: 将你的配置存储在环境变量中。配置应该与代码分离，以便配置根据应用程序部署的位置而变化。'
- en: '**Backing services**: Services should be easily interchangeable so that you
    can manage your backing services as attached resources. You must be able to easily
    exchange the backing services from one provider to another without changing your
    code. This maximizes portability and helps maintain your system.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持服务**: 服务应该易于互换，这样你就可以将支持服务作为附加资源来管理。你必须能够轻松地从一家提供商交换到另一家提供商的支持服务，而无需更改你的代码。这最大化了可移植性，并有助于维护你的系统。'
- en: '**Build, run, release**: There should be a clear and strict separation between
    the build, release, and run stages. You can achieve this by assigning a unique
    release ID and allowing releases to roll back. The automation between these stages
    should be as easy as possible.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建、运行、发布**: 构建、发布和运行阶段之间应该有明确和严格的分离。你可以通过分配唯一的发布ID并允许发布回滚来实现这一点。这些阶段之间的自动化应该尽可能简单。'
- en: '**Stateless processes**: This factor lies at the core of the microservices
    architecture. You should not be introducing state into your services. Any data
    that needs to be persisted must be stored in a backing service, typically a database
    or another storage.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态进程**: 这个因素是微服务架构的核心。你不应该在你的服务中引入状态。任何需要持久化的数据都必须存储在支持服务中，通常是数据库或其他存储。'
- en: '**Port binding**: By this factor, your application should be completely self-contained.
    It should not depend on the runtime startup of a web server into the execution
    environment to create a frontend service. The web app should make HTTP applications
    as a service available by binding the service to a port.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口绑定**: 通过这个因素，你的应用程序应该是完全自包含的。它不应该依赖于执行环境中的网络服务器的启动来创建前端服务。Web 应用应该通过将服务绑定到端口，将HTTP应用作为服务提供。'
- en: '**Concurrency**: You should break down your application into much smaller pieces.
    Smaller, well-defined apps allow you to scale out as needed to handle varying
    loads. You should be able to individually scale the single component.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性**: 你应该将你的应用程序分解成更小的部分。更小、定义良好的应用程序允许你根据需要扩展以处理不同的负载。你应该能够单独扩展单个组件。'
- en: '**Disposability**: You should aim to maximize the robustness of your systems
    by coding applications with a fast startup and graceful shutdown. This means you
    should be able to handle unexpected failures. A recommended approach consists
    of using a robust async backend that returns notifications when failures occur.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可丢弃性**: 你应该通过编写快速启动和优雅关闭的应用程序来最大化你系统的鲁棒性。这意味着你应该能够处理意外的故障。一个推荐的方法是使用健壮的异步后端，当发生故障时返回通知。'
- en: '**Dev/prod Parity**: You should aim to keep the development, staging, and production
    phases similar and homogeneous to limit deviation and errors. This also implicitly
    encourages a DevOps culture where software development and operations are unified.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/生产一致性**：你应该努力保持开发、测试和生产阶段相似和一致，以限制偏差和错误。这也隐含地鼓励了一种DevOps文化，其中软件开发和运维是统一的。'
- en: '**Logs**: Logging is a key factor for debugging and monitoring your application''s
    general health. The place where logs are stored shouldn''t be a concern for developers.
    Instead, these logs should be treated as a continuous stream that''s being separately
    captured and stored by a service.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**：日志记录是调试和监控应用程序整体健康状况的关键因素。日志存储的位置不应成为开发者的担忧。相反，这些日志应被视为一个连续的流，由一个服务分别捕获和存储。'
- en: '**Admin Processes**: In many cases, developers perform one-off administrative
    or maintenance tasks, such as database migrations, application patching, or one-time
    script execution for the app. It is essential to run one-off admin processes in
    an environment that is similar to the regular long-running processes of the app.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理流程**：在许多情况下，开发者执行一次性管理或维护任务，例如数据库迁移、应用程序修补或为应用程序执行一次性的脚本。在类似于应用程序常规长期运行环境的环境中运行一次性管理流程是至关重要的。'
- en: Although some of the preceding patterns may seem trivial at first glance, they
    become essential building blocks as your services start to grow. Therefore, when
    designing your microservices applications, keep in mind that most challenges are
    not related just to coding, but rather to getting the basics wrong. As a matter
    of fact, even good teams fail at microservices when they don't have a culture
    that embraces DevOps and key building blocks such as the Twelve-Factor App methodology.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些先前的模式一开始看起来可能微不足道，但随着服务开始增长，它们成为基本构建块变得至关重要。因此，在设计微服务应用程序时，请记住，大多数挑战不仅与编码相关，而且与基本错误有关。事实上，即使优秀的团队在没有拥抱DevOps文化和关键构建块（如Twelve-Factor
    App方法）的情况下，也会在微服务方面失败。
- en: The MicroProfile initiative
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile倡议
- en: Having discussed the methodology of microservices, we will now cover some aspects
    related to the specific API that can be used to develop microservices.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了微服务的方法论之后，我们现在将涵盖一些与特定API相关的方面，这些API可以用来开发微服务。
- en: While, at first glance, it appears that Java and microservices don't really
    match, it would be a bad idea to discard the entire Java EE ecosystem (rebranded
    as **Jakarta EE** and transferred to the Eclipse Foundation) that has been created.
    A lot of effort has already gone into reusing Java EE for coding microservices.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看，Java和微服务似乎并不真正匹配，但放弃整个Java EE生态系统（更名为**Jakarta EE**并转移到Eclipse基金会）的想法是错误的。已经投入了大量努力来重用Java
    EE进行微服务编码。
- en: As a matter of fact, many major vendors, including IBM, Red Hat, and Payara,
    have already provided a lightweight and extensible runtime to power microservices
    and cloud deployments. Their individual efforts were naturally followed by an
    open collaboration within the **MicroProfile.io** initiative.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，包括IBM、Red Hat和Payara在内的许多主要厂商已经提供了一种轻量级且可扩展的运行时环境来支持微服务和云部署。他们的个人努力自然地被**MicroProfile.io**倡议下的开放协作所跟随。
- en: MicroProfile components are built upon the model of Java EE, thereby making
    the transition to microservices development natural. This means you will be able
    to reuse the valuable knowledge of Java EE you have accumulated over the years
    to flexibly use multiple vendor specs to define application requirements.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile组件建立在Java EE模型之上，因此使过渡到微服务开发变得自然。这意味着你将能够重用多年来积累的Java EE宝贵知识，灵活地使用多个供应商规范来定义应用程序需求。
- en: In its initial release, the MicroProfile initiative included just a small cutdown
    of the Java EE API (JAX-RS 2.0, CDI 1.2, and JSON-P 1.0).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在其初始版本中，MicroProfile倡议仅包含Java EE API的小部分裁剪（JAX-RS 2.0、CDI 1.2和JSON-P 1.0）。
- en: In a short time, however, new MicroProfile projects have been added. In 2018
    alone, we saw the advent of MicroProfile 1.3, 1.4, 2.0, and 2.1, and the projects
    contained in them. The current release of the MicroProfile initiative extends
    the standards with functionality that isn't part of Java EE, such as configuration,
    resiliency, monitoring, health checking, and distributed tracing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在很短的时间内，新的MicroProfile项目已经被添加。仅2018年，我们就看到了MicroProfile 1.3、1.4、2.0和2.1的问世，以及它们包含的项目。MicroProfile倡议的当前版本通过添加不属于Java
    EE的功能（如配置、弹性、监控、健康检查和分布式跟踪）来扩展标准。
- en: 'The following diagram depicts the building blocks of MicroProfile projects
    according to the latest specification (at the time of writing this book):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了根据最新规范（本书编写时）的MicroProfile项目的构建块：
- en: '![](img/66256e0f-6b46-4b99-8103-988b1f0ce0cf.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66256e0f-6b46-4b99-8103-988b1f0ce0cf.png)'
- en: MicroProfile alone, however, is mostly insufficient when it comes to developing
    a complex enterprise application. For example, it does not include an API for
    persistence, transaction, or **Security Socket Layer** (**SSL**) management out
    of the box. For this reason, we need a framework that leverages the MicroProfile
    API with extensible functionalities and can be orchestrated by Kubernetes, which
    is going to be the new application server, from the management point of view.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅凭MicroProfile本身在开发复杂的企业应用时通常是不够的。例如，它不包括持久化、事务或**安全套接字层**（**SSL**）管理的API。因此，我们需要一个框架，它利用MicroProfile
    API的可扩展功能，并且可以被Kubernetes编排，从管理角度来看，Kubernetes将成为新的应用服务器。
- en: Quarkus – a Kubernetes-native Java framework
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quarkus – 一个Kubernetes原生Java框架
- en: One of the main challenges of a microservices architecture is that the proliferation
    of services can increase the complexity of your systems unless you have a valid
    framework to orchestrate them from. Also, without a centralized function for authentication,
    data management, and an API gateway, the advantages of a microservices architecture
    are invalidated by these challenges.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的主要挑战之一是，除非你有有效的框架来编排它们，否则服务的激增可能会增加你系统的复杂性。此外，如果没有集中的认证、数据管理和API网关功能，微服务架构的优势就会被这些挑战所抵消。
- en: In this sense, the arrival of Kubernetes is a real revolution in IT patterns.
    With the help of Kubernetes-based orchestration, you can enhance efficiency and
    resource utilization by managing and scheduling your microservices in a dynamic
    manner. This also adds an advanced resiliency level. You can continue to operate
    as demand varies, without worrying about container failure. To close the circle
    and unify all the components, we need a framework that has been specifically thought
    of to work in this kind of architecture. Let's meet **Quarkus**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种意义上，Kubernetes的到来是IT模式的一次真正革命。借助基于Kubernetes的编排，你可以通过以动态方式管理和调度你的微服务来提高效率和资源利用率。这也增加了高级的弹性级别。你可以继续在需求变化时运行，而不用担心容器故障。为了闭合这个循环并统一所有组件，我们需要一个专门为这种架构设计的框架。让我们来认识一下**Quarkus**。
- en: Quarkus emerges as a first-class citizen when it comes to managing cloud-native
    enterprise applications and has lots of amazing features that can enable scenarios
    that haven't been possible before. As you will see in the upcoming sections, Quarkus
    is able to build thin native code from Java classes and create container images
    out of it that you can run on top of Kubernetes or OpenShift. Quarkus also leverages
    the best of the breed of Java libraries you have been working with for years,
    such as RESTEasy, Hibernate, Apache Kafka, Vert.x, and much more. Let's look at
    the highlights of this framework in more detail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到管理云原生企业应用时，Quarkus作为一个一等公民出现，并且拥有许多令人惊叹的功能，这些功能可以实现之前不可能的场景。正如你将在接下来的章节中看到的那样，Quarkus能够从Java类构建轻量级的原生代码，并从中创建容器镜像，你可以在Kubernetes或OpenShift上运行这些镜像。Quarkus还利用了你多年来一直在使用的Java库中的最佳库，如RESTEasy、Hibernate、Apache
    Kafka、Vert.x等等。让我们更详细地看看这个框架的亮点。
- en: Native code execution
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生代码执行
- en: Native code execution has been attempted several times during the long history
    of Java, but it never got much adoption by developers. First of all, it required
    some external tooling as this isn't provided out of the box by the platform's
    vendor. For monolithic applications, the advantage of native execution is minor
    because, in the long run, due to the advancement in the Hot Spot technology, the
    speed of Java can become closer to native execution (provided that you are willing
    to pay for a slower application bootstrap).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java漫长的历史中，原生代码执行尝试过多次，但开发者对其的采用率始终不高。首先，它需要一些外部工具，因为这些工具并不是平台供应商提供的。对于单体应用来说，原生执行的优势微乎其微，因为从长远来看，由于Hot
    Spot技术的进步，Java的速度可以接近原生执行（前提是你愿意为更慢的应用启动付费）。
- en: Nevertheless, in a microservice scenario, spinning up a bunch of native services
    plays a crucial role, and even optimizing seconds or a fraction of a second can
    play a huge difference. In much the same way, if you aim to reach the highest
    memory density requirements, the maximum requests' throughput, along with a consistent
    CPU performance, Quarkus' native execution fits neatly in the picture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在微服务场景中，启动大量原生服务起着至关重要的作用，甚至优化几秒或一秒钟的时间也能产生巨大的差异。同样，如果你旨在达到最高的内存密度要求，最大请求吞吐量以及一致的CPU性能，Quarkus的原生执行方式完美地融入了这一场景。
- en: On the other hand, you can smoothly transition to Quarkus using plain Java bytecode,
    still delivering applications with high memory density requirements, excellent
    CPU raw performance, advanced garbage collections tactics, a large set of libraries
    or monitoring tools that require the standard JDK, and the ubiquitous *compile
    once and run everywhere*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您可以使用纯Java字节码平稳地过渡到Quarkus，仍然可以交付具有高内存密度要求、卓越的CPU原生性能、先进的垃圾收集策略、大量需要标准JDK的库或监控工具，以及无处不在的*编译一次，运行在任何地方*。
- en: 'The following table summarizes some typical use cases for choosing between
    native applications and Java applications when developing with Quarkus:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了在开发Quarkus时选择原生应用程序和Java应用程序的一些典型用例：
- en: '| **Quarkus Native applications** | **Quarkus Java** **applications** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **Quarkus原生应用程序** | **Quarkus Java应用程序** |'
- en: '| Highest memory density requirements | High memory density requirements |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 最高内存密度要求 | 高内存密度要求 |'
- en: '| More consistent CPU performance | Best raw performance (CPU) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 更一致的CPU性能 | 最佳原生性能（CPU） |'
- en: '| Fastest startup time | Fast startup time |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 最快的启动时间 | 快速启动时间 |'
- en: '| Simpler garbage collection | Advanced garbage collection |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 简单的垃圾收集 | 高级垃圾收集 |'
- en: '| Highest throughput | A large set of libraries and tools that only work with
    JDK |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 最高吞吐量 | 仅与JDK兼容的大量库和工具 |'
- en: '| No JIT spikes | Compile once, run anywhere |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 无JIT峰值 | 编译一次，运行在任何地方 |'
- en: As resulting from this picture, Quarkus is a breakthrough as it leverages native
    code execution while preserving the capability for you to run your services with
    OpenJDK and use Hot Spot's rich dynamic code execution capabilities when required.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这一图景所示，Quarkus是一个突破性的技术，因为它利用了原生代码执行，同时保留了您使用OpenJDK运行服务的能力，并在需要时使用Hot Spot丰富的动态代码执行能力。
- en: Container first
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器优先
- en: As anticipated, one of the most promising features of Quarkus is the capability
    to automatically generate container images out of your applications. The minimal
    footprint of native applications is optimized to be run inside a container.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，Quarkus最有希望的功能之一是能够自动从您的应用程序中生成容器镜像。原生应用程序的最小占用空间已优化，以便在容器内运行。
- en: Generating container images of your native applications also defeats one common
    pitfall related to native execution, which is potential conflicts or errors when
    the build was done with a different OS. Since the container wraps the OS of your
    choice, you can provide container-safe native builds of your applications without
    hitting the risk of crash dumps or the infamous blue screen scenario.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 生成您原生应用程序的容器镜像也解决了与原生执行相关的一个常见陷阱，即当使用不同的操作系统构建时可能出现的潜在冲突或错误。由于容器封装了您选择的操作系统，您可以在不遇到崩溃转储或臭名昭著的蓝屏场景的风险下，提供容器安全的原生应用程序构建。
- en: Unifying the imperative and Reactive Programming models
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一命令式和响应式编程模型
- en: Most Java developers are familiar with the imperative programming model, which
    translates into a sequence of instructions that are used to modify an object's
    state. On the other hand, asynchronous programming has always been a challenge
    for Java developers due to its inherent complexity and the lack of a solid pattern
    for propagating asynchronous changes. In this context, a paradigm called **Reactive
    Programming** has gained popularity due to its ability to conjugate the asynchronous
    programming pattern with data streams and the propagation of change.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Java开发者都熟悉命令式编程模型，它转化为一系列用于修改对象状态的指令。另一方面，由于固有的复杂性和缺乏传播异步更改的可靠模式，异步编程一直是Java开发者的挑战。在这种情况下，一种称为**响应式编程**的范式因其能够将异步编程模式与数据流和变化的传播相结合而受到欢迎。
- en: Quarkus has been designed from the ground up to unify the two models in the
    same platform so that you can take the benefits of both programming models and
    use them in your IT organization.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus从头开始设计，旨在统一同一平台上的两种模型，以便你可以利用两种编程模型的好处，并在你的IT组织中使用它们。
- en: Coding that sparks joy
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令人愉悦的编码
- en: Even the most powerful framework available wouldn't gain widespread adoption
    if it were overly complex to use and required lots of coding and configuration
    to accomplish even minor functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最强大的框架，如果使用过于复杂，需要大量编码和配置才能完成即使是微小的功能，也不会得到广泛的应用。
- en: 'As we have learned from Spring Boot''s success, developers are more productive
    with a framework that doesn''t require you to spend lots of time on its setup
    or configuration. Out of the box, Quarkus provides the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从Spring Boot的成功中学到的那样，开发者在使用框架时不需要花费大量时间在其设置或配置上，会更加高效。开箱即用，Quarkus提供了以下功能：
- en: A unified configuration that can be easily maintained in a single property file
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个统一的配置，可以轻松地在一个属性文件中维护
- en: A large set of defaults so that you can actually write applications, even with
    no configuration at all
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列默认设置，这样你实际上可以编写应用程序，甚至无需任何配置
- en: 'Besides this, you can have extraordinary features, such as the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以拥有以下非凡的功能：
- en: Live reload of applications, without any third-party plugins
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需任何第三方插件即可进行应用程序的实时重新加载
- en: Straight to container generation with native executables
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地可执行文件直接生成容器
- en: Simplified testing by adding testing extensions built specifically for Quarkus
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加专门为Quarkus构建的测试扩展来简化测试
- en: Best-of-breed Java libraries and standards
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳Java库和标准
- en: The criterion that makes a development stack a successful one is a combination
    of various things, such as an active number of contributors, a high degree of
    recognition and use by top industrial actors, compliance to well-known standards,
    and strong and active criteria validators.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使开发堆栈成功的标准是各种事物的组合，例如活跃的贡献者数量、顶级工业参与者的高度认可和使用、遵守知名标准以及强大和活跃的标准验证者。
- en: On this matter, Quarkus brings a cohesive, full-stack framework by leveraging
    the best-of-breed libraries you are already familiar with, which are automatically
    wired together to produce the final artifact. Quarkus extensions include the full
    Eclipse MicroProfile Stack, a persistence API (JPA), a transaction manager (Narayana),
    a reactive framework (Vert.x), an asynchronous event-driven network application
    framework (Netty), and much more.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题上，Quarkus通过利用你已熟悉的最佳库，将它们自动连接起来以生成最终工件，提供了一个统一的、全栈的框架。Quarkus扩展包括完整的Eclipse
    MicroProfile Stack、持久化API（JPA）、事务管理器（Narayana）、响应式框架（Vert.x）、异步事件驱动网络应用程序框架（Netty）等等。
- en: Quarkus also includes an extension framework that third-party component authors
    can leverage to extend the framework. The Quarkus extension framework greatly
    reduces the complexity of making third-party frameworks run on Quarkus and compile
    to a native binary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus还包括一个扩展框架，第三方组件作者可以利用它来扩展框架。Quarkus扩展框架大大降低了第三方框架在Quarkus上运行和编译为本地二进制的复杂性。
- en: Quarkus architecture
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quarkus架构
- en: Now that we know about some of the highlights of Quarkus, let's have a more
    in-depth look at the architecture of this framework.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了Quarkus的一些亮点，让我们更深入地看看这个框架的架构。
- en: 'At the heart of Quarkus, there is the **core** component that does the hard
    work of rewriting our application in the build phase so that super-optimized native
    executable and Java-runnable applications can be generated. To do that, Quarkus
    **core** requires the cooperation of a set of tools:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Quarkus的核心，有一个**核心**组件在构建阶段完成重写我们的应用程序的繁重工作，以便生成超级优化的本地可执行文件和Java可运行的应用程序。为此，Quarkus
    **核心**需要一组工具的合作：
- en: '**Jandex**: This is a space-efficient Java annotation indexer and offline reflection
    library that''s able to index all runtime visible Java annotations and class hierarchies
    for a set of classes into a memory-efficient representation.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jandex**: 这是一个空间高效的Java注解索引器和离线反射库，能够将一组类的所有运行时可见Java注解和类层次结构索引到一个内存高效的表示中。'
- en: '**Gizmo**: This is a bytecode generation library used by Quarkus to produce
    Java bytecode.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gizmo**: 这是一个字节码生成库，Quarkus用它来生成Java字节码。'
- en: '**GraalVM**: This is a set of components. Every component has a specific function,
    such as a compiler, an SDK API for the integration of Graal languages and the
    configuration of native images, and a runtime environment for JVM-based languages.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraalVM**：这是一个组件集合。每个组件都有特定的功能，例如编译器、用于集成 Graal 语言和配置原生图像的 SDK API，以及基于 JVM
    的语言的运行环境。'
- en: '**SubstrateVM**: This is a subcomponent of GraalVM that allows for the **ahead-of-time**
    (**AOT**) compilation of Java applications of Java programs into self-contained
    executables.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SubstrateVM**：这是 GraalVM 的一个子组件，允许对 Java 应用程序进行 **提前编译**（**AOT**）。'
- en: Moving on to the list of available Quarkus extensions, first and foremost, Quarkus
    fully implements the MicroProfile specifications. Quarkus also includes a set
    of extensions for Hibernate ORM for handling persistence, a transaction manager
    (Narayana), a connection pool manager (Agroal), plus several more, such as an
    API for Apache Kafka, Camel Routes, and the ability to run reactive applications
    (Vert.X).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向可用的 Quarkus 扩展列表。首先，Quarkus 完全实现了 MicroProfile 规范。Quarkus 还包括一套用于处理持久化的
    Hibernate ORM 扩展，一个事务管理器（Narayana），一个连接池管理器（Agroal），以及更多其他扩展，例如 Apache Kafka API、Camel
    路由以及运行反应式应用程序的能力（Vert.X）。
- en: 'The following diagram summarizes the core components of the Quarkus architecture,
    although the list of available extensions cannot be exhaustive for the sake of
    brevity:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图总结了 Quarkus 架构的核心组件，尽管由于篇幅限制，可用的扩展列表可能无法详尽无遗：
- en: '![](img/4a630408-ce48-4a88-b1a5-108025088b33.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a630408-ce48-4a88-b1a5-108025088b33.png)'
- en: Having covered the basics of the Quarkus architecture, without further ado,
    we will now shift our attention to the installation of the tools that we'll need
    in order to build and run Quarkus applications. Our to-do list isn't that long
    and will be addressed shortly. In the next section, we will be installing GraalVM
    and a development environment for our applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了 Quarkus 架构的基础之后，我们不再拖延，现在将转向安装我们构建和运行 Quarkus 应用程序所需的工具。我们的待办事项列表并不长，并将很快解决。在下一节中，我们将安装
    GraalVM 和我们的应用程序的开发环境。
- en: Getting started with GraalVM
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 GraalVM
- en: To compile Java code into native executables, you will need an extension of
    the virtual machine called **GraalVM**. To be precise, GraalVM is a universal
    virtual machine that facilitates the compilation of the bytecode of various languages
    (such as Python, JavaScript, Ruby, and so on). In addition to this, it allows
    for the integration of those languages in the same project. It has a few other
    features as well, among which is one that offers **Substrate VM**, a framework
    that allows AOT compilation for applications written in various languages. It
    also allows us to compile JVM bytecode into a native executable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Java 代码编译成原生可执行文件，你需要一个虚拟机的扩展，称为 **GraalVM**。更准确地说，GraalVM 是一个通用虚拟机，它简化了各种语言（如
    Python、JavaScript、Ruby 等）的字节码编译。除此之外，它还允许在同一个项目中集成这些语言。它还有一些其他特性，其中之一是提供 **Substrate
    VM**，这是一个允许对用各种语言编写的应用程序进行 AOT 编译的框架。它还允许我们将 JVM 字节码编译成原生可执行文件。
- en: GraalVM is similar to any other JDK available from other vendors, except that
    it has **Java-based JVM Compiler Interface** (**JVMCI**) support, and it uses
    Graal as its default JIT compiler. Therefore, it can't *just* execute Java code
    but also languages such as JS, Python, and Ruby. This can be done through a language
    abstract syntax tree interpreter called **Truffle**, which was developed by Oracle
    in association with GraalVM.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 与其他供应商提供的任何其他 JDK 类似，除了它支持基于 Java 的 JVM 编译器接口（**JVMCI**），并且它使用 Graal
    作为其默认 JIT 编译器。因此，它不仅能执行 Java 代码，还能执行 JS、Python 和 Ruby 等语言。这可以通过一个名为 **Truffle**
    的语言抽象语法树解释器来完成，它是 Oracle 与 GraalVM 协作开发的。
- en: 'The following diagram depicts a high-level view of the GraalVM stack:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了 GraalVM 栈的高级视图：
- en: '![](img/9293c0d5-0ca0-4101-8f3d-1579a89bc838.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9293c0d5-0ca0-4101-8f3d-1579a89bc838.png)'
- en: All of this sounds great, but GraalVM comes with a price as well. The dynamic
    nature of Java is severely constrained; for example, there's the default reflection
    mechanism, which will not work unless a class/member has been explicitly registered
    for reflection. Also, class loading at runtime, dynamic proxies, and static initializers
    require, at best, some changes/workarounds in order to work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来都很棒，但GraalVM也有其代价。Java的动态性质受到严重限制；例如，默认的反射机制将不会工作，除非类/成员已被显式注册为反射。此外，运行时类加载、动态代理和静态初始化器至少需要一些更改/解决方案才能工作。
- en: How does Quarkus overcome these limitations? The trick is to move as much framework
    initialization at build time. During this phase, Quarkus is able to discover which
    classes need reflection at runtime through metadata discovery (such as annotations).
    Quarkus uses a set of tools such as Jandex to optimize annotation processing and
    bytecode generation. Also, to overcome other limitations of GraalVM, Quarkus uses
    a single-pass, single class loader and programmatically provides compiler hints
    to enable extensive dead code elimination, thereby substantially cutting down
    the size of the executable file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus是如何克服这些限制的呢？秘诀在于尽可能地在构建时移动框架初始化。在这个阶段，Quarkus能够通过元数据发现（如注解）来发现哪些类需要在运行时进行反射。Quarkus使用一系列工具，如Jandex来优化注解处理和字节码生成。此外，为了克服GraalVM的其他限制，Quarkus使用单遍、单类加载器，并通过编程方式提供编译提示，以实现广泛的死代码消除，从而大大减小可执行文件的大小。
- en: To get started, we will install GraalVM from [https://www.graalvm.org/](https://www.graalvm.org/).
    As you will see from the Downloads page, the Community and Enterprise GraalVM
    editions are available. In this book, we will be using the Community Edition,
    so proceed by downloading the community version that fits with your OS.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将从[https://www.graalvm.org/](https://www.graalvm.org/)安装GraalVM。正如您可以从下载页面看到的那样，社区版和企业版GraalVM都可用。在这本书中，我们将使用社区版，因此请下载适合您操作系统的社区版本。
- en: Installing GraalVM
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装GraalVM
- en: 'There are several ways to get started with GraalVM. You can either download
    the zipped binary for your operating system or build it from the source. For the
    purpose of this book, we will choose the former option. The installation steps
    are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以开始使用GraalVM。您可以选择下载适合您操作系统的zip包二进制文件，或者从源代码构建它。为了本书的目的，我们将选择前者。安装步骤如下：
- en: Navigate to the Downloads page and choose **Community Edition**. You will be
    redirected to the GitHub project where the project is hosted. Download the archive
    that matches with operating system. **Please note that the recommended version
    of GraalVM to use with Quarkus 1.0.0.final is the version 19.2.1**. As a matter
    of fact, the newer 19.3.0 version does not meet the requirements of Quarkus 1.0.0.final.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到下载页面，选择**社区版**。您将被重定向到GitHub项目，该项目在那里托管。下载与操作系统匹配的存档。**请注意，与Quarkus 1.0.0.final一起推荐的GraalVM版本是19.2.1版本**。实际上，较新的19.3.0版本不符合Quarkus
    1.0.0.final的要求。
- en: Extract the archive to your filesystem.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存档提取到您的文件系统中。
- en: 'You should have the following top-level structure in the folder where GraalVM
    has been extracted:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在提取GraalVM的文件夹中拥有以下顶级结构：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the top-level structure of GraalVM is quite similar to the
    JDK. In the `bin` folder, you will find many utilities and replacements for JDK
    tools. Notably, when you use the `java` command in GraalVM, it runs the JVM and
    the default compiler, which is Graal. `javac` can be used to compile your code.
    Apart from this, the following commands are essentials when it comes to leveraging
    the native and polyglot functionalities of GraalVM:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，GraalVM的顶级结构相当类似于JDK。在`bin`文件夹中，您将找到许多JDK工具的实用程序和替代品。值得注意的是，当您在GraalVM中使用`java`命令时，它会运行JVM和默认编译器，即Graal。`javac`可用于编译您的代码。除此之外，以下命令在利用GraalVM的本地和多语言功能时是必不可少的：
- en: '`js`: This command can be executed to run plain JavaScript code if we pass
    a set of options and the JavaScript filename as an argument.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js`：如果我们传递一组选项和JavaScript文件名作为参数，则可以使用此命令执行纯JavaScript代码。'
- en: '`node`: This command can be used to run Node.js-based applications. It relies
    on the `npm` command to install Node.js modules.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`：此命令可用于运行基于Node.js的应用程序。它依赖于`npm`命令来安装Node.js模块。'
- en: '`native-image`**:** This command takes your Java class(es) and builds an AOT
    compiled executable or a shared library. It is not included by default in most
    recent GraalVM installations and you need the `gu` tools to install it.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native-image`**:** 此命令将您的Java类（们）构建为AOT编译的可执行文件或共享库。它默认不包括在大多数最新的GraalVM安装中，您需要`gu`工具来安装它。'
- en: '`npm`: This is the package manager for Node.js. It puts modules in place so
    that `node` can find them and manages dependency conflicts intelligently.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm`：这是Node.js的包管理器。它将模块放置在适当的位置，以便`node`可以找到它们，并智能地管理依赖冲突。'
- en: '`lli`**:** This is an LLVM bitcode interpreter that can execute LLVM bitcode
    in a managed environment.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lli`**:** 这是一个可以执行在托管环境中LLVM位码的LLVM位码解释器。'
- en: '`gu`**:** This tool can be used to install language packs for Python, R, and
    Ruby, as well as the native-image tool.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gu`**:** 此工具可用于安装Python、R和Ruby的语言包，以及`native-image`工具。'
- en: 'The first thing we are going to do is export the path where GraalVM has been
    installed into our environment:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是将GraalVM已安装的路径导出到我们的环境中：
- en: '[PRE1]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In addition, it is recommended to complete the installation adding the `bin`
    folder of GraalVM to your OS''s `PATH`. For example, on Linux, we would do the
    following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，建议在安装过程中将GraalVM的`bin`文件夹添加到您的操作系统`PATH`中。例如，在Linux上，我们会这样做：
- en: '[PRE2]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Optionally, you can resolve to the GraalVM installation directory by setting
    the `JAVA_HOME` environment variable like so:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以通过设置`JAVA_HOME`环境变量来解析到GraalVM安装目录，如下所示：
- en: '[PRE3]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the preceding environment settings should be added to the script that initializes
    your shell. For most Linux distributions, this means putting them in the `.bashrc`
    file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的环境设置都应该添加到初始化您的shell的脚本中。对于大多数Linux发行版，这意味着将它们放入`.bashrc`文件中。
- en: 'After you have set the `PATH` environment variable, it''s pretty simple to
    check language versions with GraalVM''s launchers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在您设置了`PATH`环境变量之后，使用GraalVM的启动器检查语言版本就非常简单了：
- en: '[PRE4]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The executables belonging to all the language runtimes in GraalVM emulate the
    behavior of the languages' default runtimes. It should be enough to include GraalVM
    at the beginning of your `PATH` environment variable in order to run your applications
    with GraalVM.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM中所有语言运行时所属的可执行文件都模拟了语言默认运行时的行为。为了运行您的应用程序，您只需在`PATH`环境变量的开头包含GraalVM即可。
- en: Running a Java application with GraalVM
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GraalVM运行Java应用程序
- en: 'To test whether your GraalVM environment works correctly, we will be adding
    a minimal Java class and running it. Open an editor and create the following `Main`
    class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试您的GraalVM环境是否正确工作，我们将添加一个最小的Java类并运行它。打开一个编辑器并创建以下`Main`类：
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compile this class into bytecode and then run it on GraalVM using the following
    commands:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将此类编译成字节码，然后在GraalVM上使用以下命令运行：
- en: '[PRE6]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will give us the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Building native images
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建原生图像
- en: 'Now that we have tested the compilation and execution of Java bytecode, we
    will convert the bytecode into native executables to achieve faster startup and
    a smaller footprint for our applications. In order to do that, we need the `native-image`
    tool, which allows us to AOT compile Java code into a standalone executable. We
    can install the `native-image` tool as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了Java字节码的编译和执行，我们将把字节码转换为原生可执行文件，以实现应用程序更快地启动和更小的占用空间。为了做到这一点，我们需要`native-image`工具，它允许我们将Java代码AOT编译成独立的可执行文件。我们可以按照以下方式安装`native-image`工具：
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon successful installation, we can use the `native-image` tool against the
    same `HelloWorld` Java class we have created. Run the following command to build
    a native image:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装后，我们可以使用`native-image`工具针对我们创建的相同的`HelloWorld` Java类进行操作。运行以下命令来构建原生图像：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will see the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This builds an executable file, just 2 MB in size, named `main` in the current
    working directory:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个可执行文件，大小仅为2 MB，命名为`main`，位于当前工作目录中：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Invoking it executes the natively compiled code of the `Main` class, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它将执行`Main`类的本地编译代码，如下所示：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once that we have verified that our installation of GraalVM works, we can install
    a development environment, which will be needed to run the examples contained
    in this book.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证了我们的GraalVM安装正常工作，我们就可以安装一个开发环境，这将需要运行本书中包含的示例。
- en: Installing a development environment
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装开发环境
- en: Choosing a development environment becomes less significant as we move away
    from monolithic development, where a large set of plugins is often required to
    build the complex interaction between the application layers. Therefore, we can
    choose any IDE that is capable of importing/exporting Maven or Gradle projects
    natively, as well as a decent set of features for speeding up our code or refactoring
    it. We will be using **IntelliJ IDEA**, which we can download from [https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们远离单体开发，不再需要大量插件来构建应用层之间的复杂交互，选择开发环境的重要性就降低了。因此，我们可以选择任何能够原生导入/导出 Maven 或
    Gradle 项目的 IDE，以及一套不错的功能来加速我们的代码或重构它。我们将使用 **IntelliJ IDEA**，我们可以从 [https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)
    下载它。
- en: 'As you will see from the download page ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)),
    both the Ultimate and Community versions are available. We will be using the latter,
    which can be freely downloaded. Choose to download the latest binary for your
    operating system. Then, unzip it into a folder of your preference (for example,
    in your `Home` folder):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从下载页面 ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
    可以看到， Ultimate 和 Community 版本都可用。我们将使用后者，它可以免费下载。选择下载适用于您操作系统的最新二进制文件。然后，将其解压缩到您偏好的文件夹中（例如，在您的
    `Home` 文件夹中）：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, move into the `bin` folder of the installation and execute it with the
    following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入安装目录下的 `bin` 文件夹，并使用以下命令执行：
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's have a minimal overview of the development environment's visual elements.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对开发环境的视觉元素进行简要概述。
- en: A brief overview of IntelliJ IDEA
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IntelliJ IDEA 的简要概述
- en: 'Although we won''t be focusing on a specific development environment to learn
    about Quarkus, we will provide a short overview of the visual elements that comprise
    IntelliJ IDEA to understand what actions you can do in a quicker and easier manner.
    As shown in the following screenshot, these are the main elements of the IntelliJ
    IDEA interface:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会专注于特定的开发环境来学习 Quarkus，但我们将提供 IntelliJ IDEA 组成元素的简要概述，以便您能够更快、更轻松地了解可以执行的操作。如图所示，这些是
    IntelliJ IDEA 界面的主要元素：
- en: '![](img/1f35f8a8-6947-42f4-a30f-0e5c7f406e9b.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f35f8a8-6947-42f4-a30f-0e5c7f406e9b.png)'
- en: 'Let''s have a look at the various highlighted sections:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看各种高亮部分：
- en: '**Menu bar**: The menu bar includes options we can use to create or import
    projects and other key actions related to projects, such as code refactoring,
    builds, run, debug, version-control options, and so on.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**菜单栏**：菜单栏包括我们可以使用的选项，用于创建或导入项目，以及其他与项目相关的关键操作，如代码重构、构建、运行、调试、版本控制选项等。'
- en: '**Toolbar**: The toolbar contains some shortcuts for common execution actions,
    such as compile, debug, and run. You can also customize it according to your requirements.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工具栏**：工具栏包含一些常见执行操作的快捷键，如编译、调试和运行。您也可以根据需求自定义它。'
- en: '**Navigation bar**: The navigation bar enables navigation between sources within
    a project. This feature will come in handy as your code base grows.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导航栏**：导航栏允许在项目内部进行源之间的导航。随着代码库的增长，这个功能将非常有用。'
- en: '**Tools tab**: The tools tab, which can show up on either side of the main
    window, lets you access key tools such as Maven/Ant builds, databases, and so
    on.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工具栏**：工具栏包含一些常见执行操作的快捷键，如编译、调试和运行。您也可以根据需求自定义它。'
- en: '**Project perspective**: The project perspective window contains all the elements
    of your project, such as packages, modules, classes, external libraries, and so
    on.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**项目视角**：项目视角窗口包含您项目的所有元素，如包、模块、类、外部库等。'
- en: '**Editor window**: This is where you edit your code in IntelliJ IDEA using
    advanced features such as syntax highlighting, smart completion, quick-fix suggestions,
    and other useful features.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑窗口**：这是您在 IntelliJ IDEA 中使用高级功能（如语法高亮、智能完成、快速修复建议等）编辑代码的地方。'
- en: Great! In the next chapter, we will be creating a simple application with Quarkus
    that we will import into IntelliJ IDEA.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在下一章中，我们将创建一个简单的 Quarkus 应用程序，并将其导入 IntelliJ IDEA。
- en: Installing IntelliJ Plugin for Quarkus
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 IntelliJ IDEA 的 Quarkus 插件
- en: Before closing this chapter, it is worth mentioning that IntelliJ IDEA includes
    in its plugin marketplace a plugin to bootstrap Quarkus applications. You can
    install it through the **File | Settings | Plugin** top menu option. Once you
    have selected the Plugin option, search for "quarkus" in the marketplace text
    field.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，值得一提的是，IntelliJ IDEA 在其插件市场中包含了一个用于引导 Quarkus 应用程序的插件。您可以通过**文件 | 设置
    | 插件**顶菜单选项安装它。一旦您选择了插件选项，在市场文本字段中搜索“quarkus”。
- en: 'Once found it, click on the Install button as depicted by the following picture:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到它，点击以下图片所示的安装按钮：
- en: '![](img/2eb04dfe-e1be-4074-9dd3-5d0863477320.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2eb04dfe-e1be-4074-9dd3-5d0863477320.png)'
- en: 'Restart the IDE for the changes to take effect. Once that the Plugin has been
    installed, you can add new Quarkus projects directly from the IDE. Here is a snapshot
    of the updated list of Projects:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动 IDE 以使更改生效。一旦插件安装完成，您可以直接从 IDE 中添加新的 Quarkus 项目。以下是更新后的项目列表快照：
- en: '![](img/355a7971-dccb-441e-95d1-300b7edde452.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/355a7971-dccb-441e-95d1-300b7edde452.png)'
- en: 'The project wizard will guide you through the selection of the Maven coordinates
    of your project and the extensions you want to have included in it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 项目向导将引导您选择您项目的 Maven 坐标以及您想要包含在内的扩展：
- en: '![](img/d8c10044-3faa-40a5-b4d7-eddc0fe65a33.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8c10044-3faa-40a5-b4d7-eddc0fe65a33.png)'
- en: Before sailing into unknown waters, we will pause for a while to briefly recap
    what we have learned in this chapter. Then, grab a cup of tea and get ready for
    departure!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在驶向未知水域之前，我们将稍作停留，简要回顾本章所学内容。然后，泡上一杯茶，准备出发吧！
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got an overview of the current landscape of the IT industry.
    As we have learned, Kubernetes adds a completely new dimension to traditional
    language-based building blocks by offering a new set of distributed services and
    a runtime environment for creating distributed systems that spread across multiple
    nodes. Although the core principles of creating containerized applications don't
    strictly require that you decompose your monolithic applications in single services,
    there are evident advantages in doing so in terms of isolation, scalability, team
    independence, monitoring, resilience, and life cycle automation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了当前 IT 行业的格局。正如我们所学的，Kubernetes 通过提供一套新的分布式服务和创建跨多个节点分布式的系统运行环境，为传统的基于语言的构建块添加了一个全新的维度。尽管创建容器化应用程序的核心原则并不严格要求您将单体应用程序分解为单个服务，但在隔离、可扩展性、团队独立性、监控、弹性和生命周期自动化方面，这样做显然具有优势。
- en: Later, we discussed the actual applications that can run natively by introducing
    Quarkus, an amazing framework where we can create serverless, native applications
    without losing the skills we learned as Java developers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过介绍 Quarkus，一个令人惊叹的框架，其中我们可以创建无服务器、原生应用程序，而不会失去作为 Java 开发者所学的技能，讨论了可以原生运行的实际应用。
- en: Now that we've installed the required tools to get started with Quarkus, in
    the next chapter, we will code our first example application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了开始使用 Quarkus 所需的工具，在下一章中，我们将编写我们的第一个示例应用程序。
