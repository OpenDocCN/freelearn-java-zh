- en: Structural Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构型设计模式
- en: 'The next stop of our journey through design patterns will focus on the family
    of **structural design patterns**. We will be doing a Scala point of view exploration
    of the following structural design patterns:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计模式之旅的下一站将聚焦于结构型设计模式系列。我们将从Scala的角度探索以下结构型设计模式：
- en: Adapter
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Decorator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: Bridge
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Composite
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Facade
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面模式
- en: Flyweight
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元模式
- en: Proxy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: This chapter will give a better understanding of what structural design patterns
    are and why they are useful. After familiarizing ourselves with what they are,
    we will be looking into each of them separately and in detail, including code
    examples and hints about when to use each of them and when to avoid them, as well
    as what to be careful with when using them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将更好地理解结构型设计模式是什么以及为什么它们是有用的。在熟悉了它们之后，我们将分别详细研究每一个，包括代码示例以及何时使用它们、何时避免它们以及使用它们时需要注意的事项。
- en: Defining structural design patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义结构型设计模式
- en: 'Structural design patterns are concerned with composing objects and classes
    in our software. They use different approaches in order to obtain new functionality
    and larger and potentially more complex structures. These approaches include the
    following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型设计模式关注于在我们的软件中组合对象和类。它们使用不同的方法来获得新的功能以及更大和可能更复杂的结构。这些方法包括以下内容：
- en: Inheritance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Composition
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Properly identifying the relationships between objects in an application is
    key to simplifying the application's structure. In the following sections, we
    will be looking at different design patterns and provide examples, which will
    give us a better feel of how to use the various structural design patterns.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正确识别应用程序中对象之间的关系对于简化应用程序的结构至关重要。在接下来的章节中，我们将探讨不同的设计模式并提供示例，这将帮助我们更好地了解如何使用各种结构型设计模式。
- en: The adapter design pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: In many cases, we have to make applications work by combining different components
    together. However, quite often, we have a problem where the component interfaces
    are incompatible with each other. Similarly with using public or any libraries,
    which we cannot modify ourselves, it is quite rare that someone else's views will
    be exactly the same as ours in our current settings. This is where adapters help.
    Their purpose is to help incompatible interfaces work together without modifying
    their source code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们必须通过组合不同的组件来使应用程序工作。然而，相当常见的问题是组件接口之间不兼容。同样，在使用公共或任何库时，我们无法修改，其他人当前的设置中，他们的观点通常与我们的大相径庭。这就是适配器发挥作用的地方。它们的目的在于帮助不兼容的接口协同工作，而不需要修改它们的源代码。
- en: We will be showing how adapters work using a class diagram and an example in
    the next few subsections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将通过类图和示例展示适配器是如何工作的。
- en: Example class diagram
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: 'For the adapter class diagram, let''s imagine that we want to switch to using
    a new logging library in our application. The library we are trying to use has
    a log method that takes the message and the severity of the log. However, throughout
    our whole application, we expect to have the `info`, `debug`, `warning`, and `error`
    methods that only take the message and automatically set the right severity. Of
    course, we cannot edit the original library code, so we have to use the adapter
    pattern. The following figure shows the class diagram that represents the adapter
    design pattern:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于适配器类图，让我们假设我们想在应用程序中切换到使用一个新的日志库。我们试图使用的库有一个接受消息和日志严重性的日志方法。然而，在我们的整个应用程序中，我们期望有`info`、`debug`、`warning`和`error`方法，这些方法只接受消息并自动设置正确的严重性。当然，我们无法编辑原始库代码，因此我们必须使用适配器模式。以下图显示了代表适配器设计模式的类图：
- en: '![](img/2c53c864-1ecb-4912-b6da-524f164b035d.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c53c864-1ecb-4912-b6da-524f164b035d.png)'
- en: In the preceding diagram, we can see our adapter (**AppLogger**) extend and
    also use an instance of **Logger** as a field. While implementing the methods,
    we then simply call the log method with different parameters. This is the general
    adapter implementation and we will see the code for it in the next subsection.
    There are some cases where extending might not be possible and we will show how
    Scala can deal with this. Also, we will show some advanced usage of the language
    features to achieve the adapter pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到我们的适配器（**AppLogger**）扩展了，并且也使用了一个**Logger**实例作为字段。在实现方法时，我们只需简单地调用带有不同参数的日志方法。这是通用的适配器实现，我们将在下一小节中看到它的代码。有些情况下，扩展可能不可行，我们将展示Scala如何处理这种情况。此外，我们还将展示一些高级语言特性的用法，以实现适配器模式。
- en: Code example
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'First of all, let''s see the code for our `Logger` that we assume that we cannot
    change:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的`Logger`代码，我们假设我们无法更改它：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve tried to keep it as simple as possible in order to not distract the
    reader from the main purpose of this book. Next, we could either just write a
    class that extends `Logger` or we could provide an interface for abstraction.
    Let''s take the second approach:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽量让它尽可能简单，以免分散读者的注意力，从而影响本书的主要目的。接下来，我们既可以写一个扩展`Logger`的类，也可以提供一个接口进行抽象。让我们采取第二种方法：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we can create our `AppLogger`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建我们的`AppLogger`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can then use it in the following program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在以下程序中使用它：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As expected, our output will look as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们的输出将如下所示：
- en: '![](img/d24f61fd-75e9-4fdc-b394-ee70ee9630c6.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d24f61fd-75e9-4fdc-b394-ee70ee9630c6.png)'
- en: You can see that we haven't implemented the class diagram exactly as shown.
    We don't need the `Logger` instance as a field of our class, because our class
    is an instance of `Logger` already and we have access to its methods anyway. If
    we were to expand the behavior of the original `log` method, then we would need
    an instance of `Logger` as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们没有按照显示的完全实现类图。我们不需要将`Logger`实例作为我们类的字段，因为我们的类已经是`Logger`的一个实例，并且我们无论如何都可以访问其方法。如果我们想要扩展原始的`log`方法的行为，那么我们还需要一个`Logger`实例。
- en: This is how we implement and use the basic adapter design pattern. However,
    there are cases where the class we want to adapt is declared as `final` and we
    are unable to extend it. We will show how to handle this in the next subsection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们实现和使用基本适配器设计模式的方法。然而，有些情况下，我们想要适配的类被声明为`final`，我们无法扩展它。我们将在下一小节中展示如何处理这种情况。
- en: The adapter design pattern with final classes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终类适配器设计模式
- en: 'If we declare our original logger as final, we will see that our code will
    not compile. There is a different way to use the adapter pattern in this case.
    Here is the code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将原始的日志器声明为`final`，我们将看到我们的代码将无法编译。在这种情况下，我们可以使用不同的方式来使用适配器模式。以下是代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we simply wrap the final logger inside a class and then use it
    to call the `log` method with different parameters. The usage is absolutely the
    same as before. This could have a variation where the logger is passed as a constructor
    parameter as well. This is useful in cases where creating the logger requires
    some extra parameterization during creation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需将最终的日志器封装在一个类中，然后使用它以不同的参数调用`log`方法。使用方法与之前完全相同。这可以有一个变化，即日志器作为构造函数参数传递。这在创建日志器需要一些额外的参数化时很有用。
- en: The adapter design pattern the Scala way
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala风格的适配器设计模式
- en: As we have already mentioned multiple times, Scala is a rich programming language.
    Because of this fact, we can use implicit classes to achieve what the adapter
    pattern does. We will be using the same `FinalLogger` that we had in the previous
    example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次提到的，Scala是一种丰富的编程语言。正因为如此，我们可以使用隐式类来实现适配器模式的功能。我们将使用与上一个示例中相同的`FinalLogger`。
- en: 'Implicit classes provide implicit conversions in places where possible. In
    order for the implicit conversions to work, we need to have the implicits imported
    and that''s why they are often defined in objects or package objects. For this
    example, we will use a package object. Here is the code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类在可能的地方提供隐式转换。为了使隐式转换生效，我们需要导入隐式定义，这就是为什么它们通常定义在对象或包对象中。对于这个例子，我们将使用一个包对象。以下是代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is a `package object` for the package where our logger examples are defined.
    It will automatically convert a `FinalLogger` instance to our implicit class.
    The following code snippet shows an example usage of our logger:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为定义我们的记录器示例的包定义的`package object`。它将自动将`FinalLogger`实例转换为我们的隐式类。以下代码片段展示了我们记录器的示例用法：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The final output will be exactly the same as our first example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出将与我们的第一个例子完全相同。
- en: What it is good for
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么好处
- en: The adapter design pattern is useful in cases *after* the code is designed and
    written. It allows us to make, otherwise incompatible, interfaces work together.
    It is also pretty straightforward to implement and use.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式在代码设计和编写之后的情况中很有用。它允许我们使本应不兼容的接口一起工作。它实现和使用也非常简单直接。
- en: What it is not so good for
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么不好
- en: There is a problem with the last implementation mentioned in the preceding section.
    It is the fact that we will have to always import our package or normal object
    when using the logger. Also, implicit classes and conversions sometimes make the
    code much harder to read and understand. Implicit classes have some limitations,
    as described here: [http://docs.scala-lang.org/overviews/core/implicitclasses.html.](https://docs.scala-lang.org/overviews/core/implicit-classes.html)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面部分提到的最后一种实现中存在一个问题。那就是我们将在使用记录器时始终需要导入我们的包或普通对象。此外，隐式类和转换有时会使代码难以阅读和理解。隐式类有一些限制，如以下链接所述：[http://docs.scala-lang.org/overviews/core/implicitclasses.html](https://docs.scala-lang.org/overviews/core/implicit-classes.html)
- en: As we already mentioned, the adapter design pattern is useful when we have code
    that we cannot change. If we are able to fix our source code, then this might
    be a better decision because using adapters throughout our program will make it
    difficult to maintain and hard to understand.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，适配器设计模式在我们无法更改代码时很有用。如果我们能够修复我们的源代码，那么这可能会是一个更好的决定，因为在我们整个程序中使用适配器将使维护变得困难，并且难以理解。
- en: The decorator design pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: There are cases where we might want to add some extra functionality to a class
    in an application. This could be done via inheritance; however, we might not want
    to do this or it may affect all the other classes in our application. This is
    where the decorator design pattern is useful.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能想在应用程序中的类上添加一些额外的功能。这可以通过继承来完成；然而，我们可能不想这样做，或者它可能会影响我们应用程序中的其他所有类。这就是装饰器设计模式有用的地方。
- en: The purpose of the decorator design pattern is to add functionality to objects
    without extending them and without affecting the behavior of other objects from
    the same class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式的目的是在不影响同一类其他对象行为的情况下，向对象添加功能而不扩展它们。
- en: The decorator design pattern works by wrapping the decorated object, and it
    can be applied during runtime. Decorators are extremely useful in the cases where
    there could be multiple extensions of a class and they could be combined in various
    ways. Instead of writing all the possible combinations, decorators can be created
    and they can stack the modifications on top of each other. The next few subsections
    will show how and when to use decorators in real-world situations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式通过包装被装饰的对象来工作，并且可以在运行时应用。在可能需要多个类扩展并且可以以各种方式组合的情况下，装饰器非常有用。我们不需要编写所有可能的组合，可以创建装饰器并将修改堆叠在一起。接下来的几个小节将展示如何在现实世界场景中使用装饰器。
- en: Example class diagram
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: 'As we saw previously with the adapter design pattern, its aim is to change
    an interface to a different one. The decorator, on the other hand, helps us to
    enhance an interface by adding extra functionality to methods. For the class diagram,
    we will use an example with data streams. Imagine that we have a basic stream.
    We might want to be able to encrypt it, compress it, replace its characters, and
    so on. Here is the class diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在适配器设计模式中看到的，它的目的是将一个接口转换为另一个接口。另一方面，装饰器通过向方法添加额外功能来帮助我们增强接口。对于类图，我们将使用数据流的例子。想象一下，我们有一个基本的流。我们可能希望能够加密它、压缩它、替换其字符等等。以下是类图：
- en: '![](img/2d9bc629-779f-4eae-bf5b-a574a4fd21e5.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d9bc629-779f-4eae-bf5b-a574a4fd21e5.png)'
- en: In the preceding diagram, the `AdvancedInputReader` provides a basic implementation
    of the `InputReader`. It wraps a standard `BufferedReader`. Then, we have an abstract
    `InputReaderDecorator` class that extends the `InputReader` and contains an instance
    of it. By extending the base decorator, we provide the possibility to have streams
    that capitalize, compress, or `Base64` encode the input they get. We might want
    to have different streams in our application and they could be able to do one
    or more of the preceding operations in different orders. Our code will quickly
    become difficult to maintain and messy if we try and provide all possibilities,
    especially when the number of possible operations is even more. With decorators,
    it is nice and clean, as we will see in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`AdvancedInputReader`提供了一个`InputReader`的基本实现。它包装了一个标准的`BufferedReader`。然后，我们有一个扩展了`InputReader`的抽象`InputReaderDecorator`类，并包含了一个其实例。通过扩展基础装饰器，我们提供了有流可以大写、压缩或`Base64`编码输入的可能性。在我们的应用程序中，我们可能想要有不同的流，并且它们能够以不同的顺序执行前面提到的操作之一或多个。如果我们尝试提供所有可能性，尤其是当可能的操作数量更多时，我们的代码将很快变得难以维护和混乱。使用装饰器，它既简洁又清晰，正如我们将在下一节中看到的那样。
- en: Code example
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Now, let''s have a look at the actual code that describes the decorator design
    pattern shown in the previous diagram. First of all, we define our `InputReader`
    interface using a trait:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看描述前面图中装饰器设计模式的实际代码。首先，我们使用特质定义我们的`InputReader`接口：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we provide the basic implementation of the interface in the `AdvancedInputReader`
    class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`AdvancedInputReader`类中提供接口的基本实现：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to apply the decorator design pattern, we have to create different
    decorators. We have a base decorator that looks as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用装饰器设计模式，我们必须创建不同的装饰器。我们有一个如下所示的基础装饰器：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we have different implementations of our decorator. First, we implement
    a decorator that turns all text into upper case:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有我们装饰器的不同实现。首先，我们实现了一个将所有文本转换为大写的装饰器：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we implement a decorator that uses `gzip` to compress each line of our
    input separately:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现了一个使用`gzip`压缩输入每一行的装饰器：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, a decorator that encodes each line to `Base64`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个将每一行编码为`Base64`的装饰器：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have demonstrated the decorator design pattern using an intermediate abstract
    class that all decorators extend. We could have achieved this design pattern without
    the intermediate class and by just directly extending and wrapping `InputReader`.
    This implementation, however, adds a bit more structure to our code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个中间的抽象类来演示装饰器设计模式，这个抽象类被所有装饰器扩展。我们本可以直接扩展并包装`InputReader`来实现这个设计模式。然而，这种实现给我们的代码增加了一些结构。
- en: 'Now, we can use these decorators in our application to add extra functionality
    to our input stream as needed. The usage is straightforward. Here is an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的应用程序中使用这些装饰器，根据需要为我们的输入流添加额外的功能。使用方法很简单。以下是一个示例：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, we used the text file part of our classpath with
    the following contents:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了类路径中的文本文件部分，其内容如下：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As expected, the order in which we apply decorators will define the order in
    which their enhancements will be applied. The output of the preceding example
    will be the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们应用装饰器的顺序将定义它们增强的顺序。前面示例的输出将是以下内容：
- en: '![](img/e5385309-e4b2-4a19-b217-d37d2fe3ee06.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5385309-e4b2-4a19-b217-d37d2fe3ee06.png)'
- en: 'Let''s see another example, but this time we will apply all the decorators
    we have:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个示例，但这次我们将应用我们所有的装饰器：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This example will read the text, capitalize it, `Base64` encode it, and finally
    compress it with `gzip`. The following screenshot shows the output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将读取文本，将其转换为大写，`Base64`编码，并最终使用`gzip`压缩。以下截图显示了输出：
- en: '![](img/deaa0b3e-110f-42d7-90cc-1ce7f0d09fa6.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deaa0b3e-110f-42d7-90cc-1ce7f0d09fa6.png)'
- en: As you can see from the preceding screenshot, in the compressing decorator code,
    we are logging the size of the lines in bytes. The output is gzipped and this
    is the reason for the text showing up as unreadable characters. You can experiment
    and change the order of the application of the decorators or add new ones in order
    to see how things can differ.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的截图中所见，在压缩装饰器代码中，我们正在记录行的字节数。输出被gzip压缩，这也是文本显示为不可读字符的原因。您可以尝试更改装饰器应用的顺序或添加新的装饰器，以查看事物如何不同。
- en: The decorator design pattern the Scala way
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala风格的装饰器设计模式
- en: As with the other design patterns, this one has an implementation that takes
    advantage of the richness of Scala and uses some of the concepts we looked at
    throughout the initial chapters of this book. The decorator design pattern in
    Scala is also called **stackable traits**. Let's see what it looks like and how
    to use it. The `InputReader` and `AdvancedInputReader` code will remain exactly
    as shown in the previous section. We are actually reusing it in both examples.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他设计模式一样，这个实现利用了 Scala 的丰富性，并使用了一些我们在本书初始章节中探讨的概念。Scala 中的装饰器设计模式也称为**可堆叠特性**。让我们看看它的样子以及如何使用它。`InputReader`
    和 `AdvancedInputReader` 代码将与上一节中展示的完全相同。我们实际上在两个示例中都重用了它。
- en: 'Next, instead of defining an `abstract` decorator class, we will just define
    the different reader modifications in new traits as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们不再定义一个 `abstract` 装饰器类，而是将不同的读取修改定义在新特性中，如下所示：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we define the compressing input reader:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义压缩输入读取器：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the `Base64` encoder reader is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Base64` 编码读取器如下所示：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the implementation here is not much different. Here, we used
    traits instead of classes, extended the base `InputReader` trait, and used `abstract
    override`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里的实现并没有太大的不同。在这里，我们使用了特性（traits）而不是类，扩展了基类 `InputReader` 特性，并使用了 `abstract
    override`。
- en: Abstract override allows us to call `super` for a method in a trait that is
    declared abstract. This is permissible for traits as long as the trait is mixed
    in after another trait or a class that implements the preceding method. The abstract
    override tells the compiler that we are doing this on purpose and it will not
    fail our compilation—it will check later, when we use the trait, whether the requirements
    for using it are satisfied.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象覆盖（abstract override）允许我们在声明为抽象的特性中调用 `super` 方法。只要特性在另一个特性或实现先前方法的类之后混合，特性就是允许的。抽象覆盖告诉编译器我们故意这样做，它不会使我们的编译失败——它将在我们使用特性时检查是否满足使用它的要求。
- en: 'Previously, we presented two examples. We will now show you what they look
    like with stackable traits. The first one that only capitalizes will look as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们展示了两个示例。现在，我们将向您展示它们使用可堆叠特性（stackable traits）时的样子。第一个仅将字母大写的示例如下：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second example that capitalizes, `Base64` encodes, and compresses the stream
    will look as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例，将文本大写、`Base64` 编码和压缩流，如下所示：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output of both the examples will be exactly the same as in the original
    examples. Here, however, we are using mixin composition and things look somewhat
    cleaner. We also have one class less, as we don't need the abstract decorator
    class. Understanding how modifications are applied is also easy—we just follow
    the order in which the stackable traits are mixed in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例的输出将与原始示例完全相同。然而，在这里，我们使用了混合组合（mixin composition），看起来要干净一些。我们还有一个类更少，因为我们不需要抽象装饰器类。理解修改是如何应用的是很容易的——我们只需遵循可堆叠特性混合的顺序即可。
- en: Stackable traits follow the rules of linearizationThe fact that in our current
    example the modifications are applied from left to right is deceiving. The reason
    this happens is because we push calls on the stack until we reach the basic implementation
    of `readLines` and then apply modifications in a reverse order. We will see more
    in-depth examples of stackable traits that will showcase all of their specifics
    in the coming chapters of this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可堆叠特性遵循线性化规则。在我们当前的示例中，修改从左到右应用的事实是具有欺骗性的。这种情况发生的原因是因为我们在堆栈上推送调用，直到我们达到 `readLines`
    的基本实现，然后以相反的顺序应用修改。我们将在本书接下来的章节中看到更深入的可堆叠特性示例，这些示例将展示它们的所有具体细节。
- en: What it is good for
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的优点是什么
- en: Decorators add a lot of flexibility to our applications. They don't change the
    original classes, hence they don't introduce errors in the older code and can
    save on a lot of code writing and maintenance. Also, they could prevent us from
    forgetting or not foreseeing some use cases with the classes we create.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器（decorators）为我们的应用程序增加了许多灵活性。它们不会改变原始类，因此不会在旧代码中引入错误，并且可以节省大量的代码编写和维护工作。此外，它们还可以防止我们忘记或未能预见我们创建的类的一些用例。
- en: In the previous examples, we showed some static behavior modifications. However,
    it is also possible to dynamically decorate instances at runtime.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们展示了某些静态行为修改。然而，也有可能在运行时动态地装饰实例。
- en: What it is not so good for
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的缺点是什么
- en: We have covered the positive aspects of using decorators; however, we should
    point out that overusing decorators could cause issues as well. We might end up
    with a high number of small classes and they could make our libraries much harder
    to use and more demanding in terms of requiring more domain knowledge. They also
    complicate the instantiation process, which would require other (creational) design
    patterns, for example, factories or builders.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了使用装饰器的积极方面；然而，我们应该指出，过度使用装饰器也可能导致问题。我们可能会拥有大量的小类，这可能会使我们的库更难以使用，并且需要更多的领域知识。它们还使实例化过程复杂化，这需要其他（创建型）设计模式，例如工厂或构建者。
- en: The bridge design pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接设计模式
- en: Some applications can have multiple different implementations of a specific
    functionality. The implementations could be in the form of different algorithms
    or something to do with multiple platforms. The implementations tend to vary often
    and they could also have new implementations throughout the life cycle of a program.
    Moreover, the implementations could be used in different ways for different abstractions.
    In cases like these, it is good to decouple things in our code, or else we are
    in danger of a class explosion.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序可以具有特定功能的不同实现。这些实现可能是不同的算法或与多个平台有关的东西。实现往往经常变化，它们也可能在整个程序的生命周期中具有新的实现。此外，实现可能以不同的方式用于不同的抽象。在这些情况下，在我们的代码中解耦事物是很好的，否则我们面临类爆炸的风险。
- en: The purpose of the bridge design pattern is to decouple an abstraction from
    its implementation so that the two can vary independently.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式的目的在于将抽象与其实现解耦，以便它们可以独立变化。
- en: The bridge design pattern is quite useful in the cases where the abstractions
    or the implementations could vary often and independently. If we directly implement
    an abstraction, variations to the abstraction or the implementations would always
    affect all other classes in the hierarchy. This makes it hard to extend, modify,
    and reuse classes independently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式在抽象或实现可能经常且独立变化的情况下非常有用。如果我们直接实现抽象，对抽象或实现的任何变化都会影响层次结构中的所有其他类。这使得扩展、修改和独立重用类变得困难。
- en: The bridge design pattern eliminates a problem by directly implementing an abstraction,
    thus making the abstractions and implementations reusable and easier to change.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式通过直接实现抽象来消除问题，从而使得抽象和实现可重用且更容易更改。
- en: The bridge design pattern is very similar to the adapter design pattern. The
    difference between them is that in the former, we apply it when we design our
    application, and the latter is used for legacy or third-party code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式与适配器设计模式非常相似。它们之间的区别在于，前者在我们设计应用程序时应用，而后者用于遗留或第三方代码。
- en: Example class diagram
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: For the class diagram and the code example, let's imagine that we are writing
    a library that hashes passwords. In practice, storing passwords in plain text
    is something that should be avoided. This is what our library will help our users
    to do. There are many different hashing algorithms that can be used. Some are
    **SHA-1**, **MD5**, and **SHA-256**. We want to be able to support at least these
    and have the possibility to add new ones easily. There are different hashing strategies—you
    can hash multiple times, combine different hashes, add salt to the passwords,
    and so on. These strategies make our passwords harder to guess using rainbow tables,
    for example. For this example, we will show hashing with salt and simple hashing
    with any of the algorithms we have.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类图和代码示例，让我们假设我们正在编写一个哈希密码的库。在实践中，以纯文本形式存储密码是应该避免的。这正是我们的库将帮助用户做到的。有许多不同的哈希算法可以使用。一些是**SHA-1**、**MD5**和**SHA-256**。我们希望能够支持至少这些，并且能够轻松地添加新的算法。存在不同的哈希策略——你可以多次哈希，组合不同的哈希，向密码中添加盐，等等。这些策略使得我们的密码更难以使用彩虹表猜测。对于这个例子，我们将展示使用盐的哈希和简单使用我们拥有的任何算法的哈希。
- en: 'Here is our class diagram:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的类图：
- en: '![](img/9f53c6b0-bebc-4b1a-995a-5aab1e36e9be.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f53c6b0-bebc-4b1a-995a-5aab1e36e9be.png)'
- en: As you can see from the preceding diagram, we separated the implementation (**Hasher**
    and its implementations) from the abstraction (**PasswordConverter**). This allows
    us to easily add a new hashing implementation and then instantly use it by just
    providing an instance of it when creating a **PasswordConverter**. If we hadn't
    used the preceding builder pattern, we would probably have to create a password
    converter for each hashing algorithm separately—something that would make our
    code explode in size or become tedious to use.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的图中可以看到，我们将实现（**Hasher** 及其实现）与抽象（**PasswordConverter**）分离开来。这允许我们轻松地添加一个新的哈希实现，然后在创建
    **PasswordConverter** 时只需提供一个实例即可立即使用它。如果我们没有使用前面的构建器模式，我们可能需要为每个哈希算法分别创建一个密码转换器——这可能会使我们的代码规模爆炸或变得难以使用。
- en: Code example
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Now, let''s have a look at the previous class diagram from the point of view
    of Scala code. First, we will focus on the implementation side with the `Hasher`
    trait:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从 Scala 代码的角度来看一下之前的类图。首先，我们将关注 `Hasher` 特质的实现方面：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we have three classes that implement it—`Md5Hasher`, `Sha1Hasher`, and
    `Sha256Hasher`. Their code is pretty simple and similar, but yields different
    results:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有三个类实现了它——`Md5Hasher`、`Sha1Hasher` 和 `Sha256Hasher`。它们的代码相当简单且相似，但会产生不同的结果：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s take a look at the abstraction side of things. This is what our
    clients will use. The following listing shows the `PasswordConverter`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看抽象方面的事情。这是我们客户将要使用的内容。以下列表显示了 `PasswordConverter`：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have chosen to provide two different implementations here—`SimplePasswordConverter`
    and `SaltedPasswordConverter`. The code for them is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里选择了提供两种不同的实现方式——`SimplePasswordConverter` 和 `SaltedPasswordConverter`。它们的代码如下：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if a client wanted to use our library, they could write a program similar
    to the following one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果客户想要使用我们的库，他们可以编写一个类似于以下程序：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of this example application will look like the one in the following
    screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应用程序的输出将类似于以下截图：
- en: '![](img/1cb79fc0-190c-4630-8fae-63445a675fde.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cb79fc0-190c-4630-8fae-63445a675fde.png)'
- en: Our library now allows us to easily add new strategies or new hashing algorithms
    and use them instantly. We don't have to change any of the existing classes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的库允许我们轻松地添加新的策略或新的哈希算法，并立即使用它们。我们不需要更改任何现有的类。
- en: The bridge design pattern the Scala way
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 方式的桥梁设计模式
- en: 'The bridge design pattern is another example of those that can be achieved
    with the powerful features of the Scala programming language. Here, we will be
    using self types. The initial `Hasher` trait remains unchanged. Then, the actual
    implementations become traits instead of classes as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式是 Scala 强大功能实现的另一个例子。在这里，我们将使用自类型。初始的 `Hasher` 特质保持不变。然后，实际的实现变成了特质而不是类，如下所示：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Having traits would allow us to mix them in when needed later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有特质将允许我们在需要时将它们混合使用。
- en: 'We''ve changed some names for this version of our example just to avoid confusion.
    The `PasswordConverter` (`PasswordConverterBase` in this case) abstraction now
    looks as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是更改了示例版本中的一些名称，以避免混淆。`PasswordConverter`（在这种情况下为 `PasswordConverterBase`）抽象现在看起来如下：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This tells the compiler that when we use `PasswordConverterBase`, we also need
    to have a `Hasher` mixed in. Then, we change the converter implementation to the
    following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器，当我们使用 `PasswordConverterBase` 时，我们还需要混合使用一个 `Hasher`。然后，我们将转换器实现更改为以下内容：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we can use our new implementations, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用我们的新实现，如下所示：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The output of this program will be identical to the original one. However, when
    we use our abstractions, we can mix in the hash algorithms we want to use. The
    benefits will become more obvious in the cases where we might have more implementations
    that we might want to combine together with hashing. Using mixins also looks more
    natural and is easier to understand.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出将与原始程序相同。然而，当我们使用我们的抽象时，我们可以混合使用我们想要的哈希算法。在可能需要将更多实现组合在一起进行哈希的情况下，这种好处将变得更加明显。使用混入（mixins）看起来也更自然，更容易理解。
- en: What it is good for
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么好处
- en: As we already said, the bridge design pattern is similar to the adapter. Here,
    however, we apply it when we design our applications. One obvious benefit of using
    it is that we don't end up with an exponential number of classes in our application,
    which could make the use and maintenance of the pattern pretty complicated. The
    separation of hierarchies allows us to independently extend them without affecting
    the other one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，桥接设计模式类似于适配器。然而，在这里，我们是在设计应用程序时应用它。使用它的一个明显好处是，我们不会在我们的应用程序中结束于指数级数量的类，这可能会使模式的使用和维护变得相当复杂。层次结构的分离使我们能够独立扩展它们，而不会影响另一个。
- en: What it is not so good for
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么
- en: The bridge design pattern requires us to write some boilerplate. It could complicate
    the use of the library in terms of which implementation is exactly picked, and
    it might be a good idea to use the bridge design pattern together with some creational
    design patterns. All in all, it doesn't have any major drawbacks, but the developer
    should be wise whether to use it or not depending on the current circumstances.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式要求我们编写一些样板代码。它可能会在库的使用方面使选择确切实现变得复杂，因此可能是一个好主意将桥接设计模式与一些创建型设计模式一起使用。总的来说，它没有任何重大缺点，但开发者应该根据当前情况明智地决定是否使用它。
- en: The composite design pattern
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合设计模式
- en: The composite design pattern is used to describe groups of objects that should
    be treated the same way as a single one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式用于描述应该像单个对象一样对待的一组对象。
- en: The purpose of the composite design pattern is to compose objects into tree
    structures to represent whole-part hierarchies.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式的目的在于将对象组合成树结构以表示整体-部分层次结构。
- en: The composite design pattern is useful for removing code duplication and avoiding
    errors in cases where groups of objects are generally treated the same way. A
    popular example could be a filesystem in which we have directories, which can
    have other directories or files. Generally, the interface to interact with directories
    and files is the same, so they are good candidates for a composite design pattern.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式对于移除代码重复和在通常以相同方式对待对象组的情况下避免错误是有用的。一个流行的例子可能是在文件系统中，我们有目录，这些目录可以有其他目录或文件。通常，与目录和文件交互的接口是相同的，因此它们是组合设计模式的好候选者。
- en: Example class diagram
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: As we mentioned previously, filesystems are a good candidate for the composite
    design pattern. Essentially, they are just tree structures, so for our example,
    we will show you how to build a tree using the composite design pattern.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，文件系统是组合设计模式的良好候选者。本质上，它们只是树结构，因此在我们的例子中，我们将向您展示如何使用组合设计模式构建树。
- en: 'Consider the following class diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类图：
- en: '![](img/81048397-08ee-4e1c-a5cc-abb7b7b4f0dd.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![示例图片](img/81048397-08ee-4e1c-a5cc-abb7b7b4f0dd.png)'
- en: As you can see from the preceding diagram, **Tree** is our composite object.
    It contains children, which could be either other **Tree** objects with more children
    nested recursively or just **Leaf** nodes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的图中可以看到，**Tree** 是我们的组合对象。它包含子节点，这些子节点可以是具有更多嵌套子节点的其他 **Tree** 对象，或者只是
    **Leaf** 节点。
- en: Code example
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Let''s take a look at the code representation for the previous diagram. First
    of all, we have to define the `Node` interface through a trait:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前图中代码的表示。首先，我们必须通过特质定义 `Node` 接口：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `prefix` parameter in the `print` method is used to aid visualization when
    printing the tree to a console.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 方法中的 `prefix` 参数用于在控制台打印树时辅助可视化。'
- en: 'After we have the interface, we can now define the implementation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了接口之后，我们现在可以定义实现：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After this, using our code becomes pretty straightforward. While printing,
    we don''t need to care whether we do it on a leaf or a tree. Our code will automatically
    take care of this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，使用我们的代码变得相当简单。在打印时，我们不需要关心是在叶节点还是树上进行操作。我们的代码将自动处理这一点：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What this code actually does is depth-first traversal of our data structure.
    The actual example data structure that we have looks as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上执行的是我们数据结构的深度优先遍历。我们实际拥有的示例数据结构如下所示：
- en: '![](img/2afbd256-5117-4f2e-a920-adc3218c5639.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![示例图片](img/2afbd256-5117-4f2e-a920-adc3218c5639.png)'
- en: 'The following screenshot shows the output of our program:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了我们的程序输出：
- en: '![](img/6171338c-ad8d-4fec-b25d-442f4f1cddd4.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![示例图片](img/6171338c-ad8d-4fec-b25d-442f4f1cddd4.png)'
- en: As you can see, using composite, we can compose hierarchies of objects that
    have similar uses.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用组合，我们可以组合具有相似用途的对象层次结构。
- en: What it is good for
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用的场合
- en: The composite design pattern is useful for reducing code duplication and simplification
    when we create hierarchies. The simplification part comes from the fact that clients
    do not need to know which type of objects they are dealing with. Adding new types
    of nodes is also easy and won't make us change anything else.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式在创建层次结构时有助于减少代码重复和简化。简化部分来自于客户端不需要知道他们正在处理哪种类型的对象。添加新的节点类型也很容易，而且不会让我们改变其他任何东西。
- en: What it is not so good for
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用的情况
- en: The composite design pattern pattern does not have any major drawbacks. It really
    is applicable in specific cases. One thing developers should be careful about
    is when they deal with massive hierarchies. The reason is that in such cases,
    we could have really deeply recursive nested items and this could cause stack
    overflow issues.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式没有明显的缺点。它确实适用于特定情况。开发者应该注意的一点是，当处理大量层次结构时。原因是，在这种情况下，我们可能会有非常深层次的嵌套项，这可能会导致栈溢出问题。
- en: The facade design pattern
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观设计模式
- en: Whenever we are building libraries or big systems, we quite often depend on
    other libraries and functionality. Implementing methods sometimes requires the
    use of multiple classes at the same time. This requires knowledge. Whenever we
    build a library for someone, we usually try and make it simpler for the users
    by assuming they do not have (and do not need) as extensive knowledge as we do.
    Additionally, developers make sure that components are easy to use throughout
    their application. This is where the facade design pattern can become useful.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在构建库或大型系统时，我们常常依赖于其他库和功能。实现方法有时需要同时使用多个类。这需要知识。当我们为某人构建库时，我们通常会尝试通过假设他们没有（也不需要）像我们这样广泛的知识来简化用户的使用。此外，开发者确保组件在其应用程序中易于使用。这就是外观设计模式可以变得有用的地方。
- en: The purpose of the facade design pattern is to wrap a complex system with a
    simpler interface in order to hide the usage complexities and ease the client
    interaction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 外观设计模式的目的在于用更简单的接口封装复杂的系统，以隐藏使用复杂性并简化客户端交互。
- en: We already looked at other design patterns based on wrapping. While the adapter
    design pattern transforms one interface to another and the decorator adds extra
    functionality, the facade makes things simpler.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了基于封装的其他设计模式。虽然适配器设计模式将一个接口转换为另一个接口，装饰者添加额外的功能，但外观使事情变得更简单。
- en: Example class diagram
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: 'For the class diagram, let''s imagine the following setting—we want our users
    to be able to download some data from a server and get it de-serialized in the
    form of objects. The server returns our data in encoded form, so we should decode
    it first, then parse it, and finally return the right objects. This involves many
    operations and makes things complicated. That''s why we use a facade design pattern:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类图，让我们设想以下场景——我们希望我们的用户能够从服务器下载一些数据，并以对象的形式对其进行反序列化。服务器以编码形式返回我们的数据，因此我们应该首先对其进行解码，然后解析它，最后返回正确的对象。这涉及到许多操作，使事情变得复杂。这就是为什么我们使用外观设计模式：
- en: '![](img/d7608af3-84fd-4db5-ad28-4e9644fa97c5.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7608af3-84fd-4db5-ad28-4e9644fa97c5.png)'
- en: When clients use the preceding application, they will just have to interact
    with the **DataReader**. Internally, it will take care of downloading, decoding,
    and deserializing the data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端使用前面的应用程序时，他们只需与**DataReader**交互。内部，它将负责下载、解码和反序列化数据。
- en: Code example
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: The preceding diagram shows the `DataDownloader`, `DataDecoder`, and `DataDeserializer`
    as composed objects inside `DataReader`. This is straightforward and clear to
    achieve—they can be either created with their default constructors, or they can
    be passed as parameters. For the code representation of our example, however,
    we have chosen to use traits instead of classes and mix them in with the `DataReader`
    class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了`DataDownloader`、`DataDecoder`和`DataDeserializer`作为`DataReader`内部的组成对象。这是直接且清晰的——它们可以通过默认构造函数创建，或者作为参数传递。然而，对于我们的示例代码表示，我们选择使用特性（traits）而不是类，并将它们与`DataReader`类混合使用。
- en: 'Let''s first take a look at the `DataDownloader`, `DataDecoder`, and `DataDeserializer`
    traits:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`DataDownloader`、`DataDecoder`和`DataDeserializer`特性：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `DataDecoder` trait is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataDecoder`特性如下：'
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code snippet is of the `DataDeserializer` trait:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是`DataDeserializer`特质的示例：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding implementations are pretty straightforward and they are separated
    from each other, since they deal with different tasks. Anyone can use them; however,
    it requires some knowledge and makes things more complicated. That''s why we have
    a facade class called `DataReader`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的实现相当直接，并且它们是分开的，因为它们处理不同的任务。任何人都可以使用它们；然而，这需要一些知识，使事情更加复杂。这就是为什么我们有一个名为`DataReader`的外观类：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This example clearly shows that instead of using three different interfaces,
    we now have a simple method to call. All complexity is hidden inside this method.
    The following listing shows a sample usage of our class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子清楚地表明，我们不再需要使用三个不同的接口，现在有一个简单的方法可以调用。所有复杂性都隐藏在这个方法中。以下列表显示了我们的类的一个示例用法：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding code makes use of our libraries, which are hidden from the client,
    really easy. Here is a sample output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码利用了我们的库，这些库对客户端来说是隐藏的，使用起来非常简单。以下是一个示例输出：
- en: '![](img/bfd4cb1d-9cf4-4428-9444-28bef266e265.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfd4cb1d-9cf4-4428-9444-28bef266e265.png)'
- en: Of course, in the preceding example, we could have used classes inside `DataReader`
    instead of mixing traits in. This really depends on the requirements and should
    yield the same results anyway.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在先前的例子中，我们可以在`DataReader`内部使用类，而不是混合特质。这完全取决于需求，无论如何都应该产生相同的结果。
- en: What it is good for
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的优点是什么
- en: The facade design pattern is useful when we want to hide the implementation
    details of many libraries, make an interface much easier to use, and interact
    with complex systems.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 外观设计模式在需要隐藏许多库的实现细节、使接口更容易使用以及与复杂系统交互时非常有用。
- en: What it is not so good for
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的缺点是什么
- en: A common mistake some people could make is try and put everything into a facade.
    This is something that usually doesn't help and the developers remain with a complex
    system, if not more, as before. Moreover, facade could prove to be restrictive
    for those users who have enough domain knowledge to use the original functionality.
    This is especially true if facade is the only way to interact with the underlying
    system.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人们可能会犯的一个常见错误是试图将一切放入外观中。这通常不会有所帮助，开发者仍然会保留一个复杂系统，甚至可能比之前更复杂。此外，外观可能会对那些有足够领域知识来使用原始功能的人来说具有约束性。这尤其适用于外观是唯一与底层系统交互的方式时。
- en: The flyweight design pattern
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元设计模式
- en: Usually when software is written, developers try to make it fast and efficient.
    Normally, this means less processing cycles and a smaller memory footprint. There
    are different ways to achieve these two aspects. Most of the time, a good algorithm
    will take care of the first one. The amount of used memory can have many causes
    and solutions, and the flyweight design pattern is there to help and reduce the
    memory used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当编写软件时，开发者会尝试使其快速高效。通常这意味着更少的处理周期和更小的内存占用。实现这两个方面有不同的方法。大多数时候，一个好的算法会处理第一个方面。使用的内存量可能有多种原因和解决方案，而享元设计模式就是为了帮助并减少内存使用。
- en: The purpose of the flyweight design pattern is to minimize the memory usage
    with the help of an object that shares as much data as possible with other similar
    objects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 享元设计模式的目的是通过尽可能多地与其他相似对象共享数据来最小化内存使用。
- en: There are many cases where many objects share the same information. A common
    example when talking about flyweight is word processing. Instead of representing
    each character with all the information about font, size, color, image, and so
    on, we could just store the positions for similar characters and have a reference
    to one object that contains the common information. This makes the usage of memory
    significantly smaller. Otherwise, such applications would become unusable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况是许多对象共享相同的信息。当谈到享元时，一个常见的例子是文字处理。我们不需要用所有关于字体、大小、颜色、图像等信息来表示每个字符，我们只需存储相似字符的位置，并有一个指向包含公共信息的对象的引用。这使得内存使用显著减少。否则，这样的应用程序将变得无法使用。
- en: Example class diagram
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: 'For the class diagram, first let''s imagine that we are trying to represent
    a drawing for a color blindness test similar to the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类图，首先让我们想象我们正在尝试表示一个类似以下颜色盲测试的绘图：
- en: '![](img/ade3b12d-4f5e-4f46-9bcb-d1e166734227.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ade3b12d-4f5e-4f46-9bcb-d1e166734227.png)'
- en: 'As we can see, it is composed of circles of different sizes and colors. Potentially,
    this can be an infinitely big picture and it can have any number of circles. To
    make things simple, let''s just set a limitation where we can only have five different
    circle colors—red, green, blue, yellow, and magenta. Here is what our class diagram
    will look like in order to represent an image like the preceding one using the
    flyweight design pattern:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它由不同大小和颜色的圆组成。理论上，这可以是一个无限大的图片，并且可以有任意数量的圆。为了简化问题，让我们只设定一个限制，即我们只能有五种不同的圆颜色——红色、绿色、蓝色、黄色和洋红色。以下是我们类图的样子，以便使用享元设计模式来表示前面提到的图像：
- en: '![](img/b92d4fb5-f5d3-4ed4-b06e-cd9b52ef4481.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b92d4fb5-f5d3-4ed4-b06e-cd9b52ef4481.png)'
- en: The actual flyweight design pattern is implemented through the **CircleFactory**,
    **Circle**, and **Client** classes. The client requests the factory and it returns
    either a new instance of **Circle** or if one with the required parameters exists,
    it returns it from the cache. For this example, the shared data will be the **Circle**
    objects with their colors, and then each specific circle will have its own position
    and a radius. The **Graphic** will contain the actual circles with all of their
    information. Things will get much clearer with our code example, which the preceding
    diagram is based on.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的享元设计模式是通过**CircleFactory**、**Circle**和**Client**类实现的。客户端请求工厂，它返回**Circle**的新实例，或者如果存在具有所需参数的实例，则从缓存中返回它。对于这个例子，共享数据将是具有其颜色的**Circle**对象，然后每个特定的圆将有自己的位置和半径。**Graphic**将包含所有这些信息的实际圆。通过我们的代码示例，事情将会变得更加清晰，前一个图就是基于这个示例的。
- en: Code example
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: It is time to see how the flyweight design pattern looks like when expressed
    in Scala code. We will be using the same example as shown previously. It is worth
    noting that in the code version, some classes have different names than in the
    diagram. The reasons for this are Scala naming conventions. We will explicitly
    point out where this happens while going through the code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看享元设计模式在Scala代码中的样子了。我们将使用之前显示的相同示例。值得注意的是，在代码版本中，一些类的名称与图中的不同。这样做的原因是Scala的命名约定。我们将在查看代码时明确指出这些情况。
- en: An interesting thing about the flyweight design pattern and our example is that
    it actually uses other design patterns and techniques that we already went through
    before. We will also point them out while looking at the code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 关于享元设计模式和我们的例子，一个有趣的事情是它实际上使用了我们之前已经讨论过的其他设计模式和技巧。我们也会在查看代码时指出它们。
- en: 'The first thing we''ve done is represent the colors. This has nothing to do
    with the actual flyweight design pattern, but we''ve decided to use ADTs:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是表示颜色。这与实际的享元设计模式无关，但我们决定使用ADTs：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After we have the colors defined, we can implement our `Circle` class:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了颜色之后，我们可以实现我们的`Circle`类：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The circles will be flyweight objects, so the model only has the data that
    will be shared with the other circle instances. Now that we have the model for
    the circles, we can create our `CircleFactory`. As the name suggests, it uses
    the factory design pattern. Here is the code for it:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 圆将是享元对象，因此模型只包含将与其他圆实例共享的数据。现在我们有了圆的模型，我们可以创建我们的`CircleFactory`。正如其名所示，它使用工厂设计模式。以下是它的代码：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have a companion object that is used to implement the factory design pattern
    in Scala. This is why the name here is different than in the diagram shown previously.
    This representation allows us to either get an old instance of a circle or create
    a new one using the following syntax:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个伴随对象，用于在Scala中实现工厂设计模式。这就是为什么这里的名字与之前显示的图中的名字不同的原因。这种表示方式允许我们使用以下语法获取一个旧的圆实例或创建一个新的实例：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we have our circle and factory, we can implement the `Graphic` class:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的圆和工厂，我们可以实现`Graphic`类：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Graphic` class will actually hold our circles with all other data related
    to them. The `Client` in the previous diagram does not have a specific representation
    in our code—it will just be the code that uses the factory to obtain circles.
    Similarly, the `Graphic` object will retrieve the circle objects by the program
    and not through explicit access to a client. Here is how all this is implemented
    in our example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graphic`类实际上将持有我们的圆以及与它们相关的所有其他数据。前一个图中的`Client`在我们的代码中没有特定的表示——它将只是使用工厂获取圆的代码。同样，`Graphic`对象将通过程序检索圆对象，而不是通过客户端的显式访问。以下是我们如何在我们的例子中实现所有这些：'
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we run this code, we will get the following output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们将得到以下输出：
- en: '![](img/912b9415-dcae-4af1-a9f5-34abfbb765a4.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/912b9415-dcae-4af1-a9f5-34abfbb765a4.png)'
- en: While defining the `Circle` class earlier, we added a print message to the construction.
    From the preceding figure, we can see that each circle was created with a specific
    color only once, even though we requested it more times to build our graphic.
    The last line shows that we have exactly five distinct circle objects, even though
    our graphic contains 10 different circles.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前定义`Circle`类时，我们在构造函数中添加了一条打印消息。从前面的图中，我们可以看到每个圆只使用特定的颜色创建了一次，即使我们多次请求它来构建我们的图形。最后一行显示，我们恰好有五个不同的圆对象，尽管我们的图形包含10个不同的圆。
- en: This is just an example to illustrate how flyweight works. In real life, the
    flyweight objects will share many more attributes, thus lowering the overall memory
    footprint of the entire application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例，用来说明飞weight是如何工作的。在现实生活中，飞weight对象将共享更多属性，从而降低整个应用程序的整体内存占用。
- en: What it is good for
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么
- en: As we already mentioned before, the flyweight design pattern is useful when
    we are trying to lower the memory used by an application. Using shared objects,
    our application will require less constructions and destructions of objects, which
    could further improve performance.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当试图降低应用程序使用的内存时，飞weight设计模式非常有用。使用共享对象，我们的应用程序将需要更少的对象构建和销毁，这可能会进一步提高性能。
- en: What it is not so good for
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么
- en: Depending on the amount of shared data, sometimes the number of distinct shared
    objects could dramatically grow and not bring too much benefit. Moreover, it can
    complicate the factory and its usage. Multithreaded applications need extra care
    while working with factories. Last but not least, the developers need to be really
    careful while using shared objects, as any change in them could affect the entire
    application. Luckily, in Scala, this is less of a concern due to immutability.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据共享数据量的大小，有时不同共享对象的数量可能会大幅增加，但这并不会带来太多好处。此外，它可能会使工厂及其使用变得更加复杂。在处理工厂时，多线程应用程序需要格外小心。最后但同样重要的是，开发者在使用共享对象时需要格外小心，因为它们中的任何变化都可能影响整个应用程序。幸运的是，在Scala中，由于不可变性，这并不是一个很大的问题。
- en: The proxy design pattern
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理设计模式
- en: In some applications, developers could face the need to provide access control
    to objects. This could be due to many reasons. Some of them include hiding implementation
    details, improving interaction with expensive resources, interfacing with remote
    resources, caching, providing lazy or eager initialization, and so on. The proxy
    design pattern helps to achieve these.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中，开发者可能需要提供对对象的访问控制。这可能由许多原因引起。其中一些包括隐藏实现细节、提高与昂贵资源的交互、与远程资源接口、缓存、提供懒加载或预加载初始化等。代理设计模式有助于实现这些。
- en: The purpose of the proxy design pattern is to provide an interface to something
    else that then gets served behind the scenes to the user.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式的目的在于提供一个接口，然后在该接口背后为用户提供服务。
- en: The proxy design pattern is another example of a wrapper. It is pretty similar
    to the decorator design pattern, but feels more basic and limited. The reason
    for this is that the relationship between the proxy and the wrapped object is
    established during compile time and decorators could be applied at runtime. In
    the end, its purpose is different.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式是包装器的一个例子。它与装饰器设计模式非常相似，但感觉更基础和有限。这是因为代理与包装对象之间的关系是在编译时建立的，而装饰器可以在运行时应用。最终，它的目的也不同。
- en: Example class diagram
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例类图
- en: 'For the class diagram, let''s imagine that we have an application that visualizes
    text from files. It might need to visualize the text, or might not depending on
    user actions. These files could be enormous or could be somewhere in a remote
    location. Here is how the proxy design pattern could help us achieve this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类图，让我们假设我们有一个将文件中的文本可视化的应用程序。它可能需要根据用户操作来可视化文本，或者可能不需要。这些文件可能非常大，或者可能位于远程位置。以下是代理设计模式如何帮助我们实现这一目标的示例：
- en: '![](img/7e670c45-10ea-4aab-959a-9996977aa397.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e670c45-10ea-4aab-959a-9996977aa397.png)'
- en: According to the preceding diagram, we could use the **FileReaderProxy** objects
    and only when someone needs to access the file contents, we will delegate the
    functionality to the **FileReaderReal**. This design is nice and convenient because
    we can actually use the **FileReader** object; however, we can keep our application
    efficient by not needing to load everything at the same time, but just once when
    needed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图示，我们可以使用**FileReaderProxy**对象，并且只有在有人需要访问文件内容时，我们才会将功能委托给**FileReaderReal**。这种设计既好又方便，因为我们实际上可以使用**FileReader**对象；然而，我们可以通过不需要一次性加载所有内容，而只是在需要时加载一次来保持应用程序的效率。
- en: Code example
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Now, let''s have a closer look at the code that implements the preceding class
    diagram. The first thing we need to define is the interface (using a Scala trait):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看实现前面类图所需的代码。首先，我们需要定义一个接口（使用Scala特质）：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We then create two classes that implement it—`FileReaderReal` and `FileReaderProxy`.
    First, let''s see how the former implements the file read as it has nothing of
    real significance:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了两个实现它的类——`FileReaderReal`和`FileReaderProxy`。首先，让我们看看前者是如何实现文件读取的，因为它并没有什么真正的意义：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'During the construction of the object, it will get the file, read it, and store
    it in the contents variable. Then, whenever `readFileContents` is called, the
    class will return whatever it has buffered. Now, let''s take a look at the `FileReaderProxy`
    implementation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象的构建过程中，它将获取文件，读取它，并将其存储在`contents`变量中。然后，每次调用`readFileContents`时，该类将返回它已缓冲的内容。现在，让我们看看`FileReaderProxy`的实现：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The implementation contains an instance of `FileReaderReal`, which is created
    the first time `readFileContents` is called. The actual file read is then delegated
    to the `FileReaderReal` class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中包含一个`FileReaderReal`的实例，它在第一次调用`readFileContents`时创建。实际的文件读取操作随后委托给`FileReaderReal`类。
- en: A more elegant implementation of the `FileReaderProxy` would use a `lazy val`
    instead of a mutable variable. In such a case, the `if` statement won't be needed
    anymore.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReaderProxy`的一个更优雅的实现将使用`lazy val`而不是可变变量。在这种情况下，`if`语句将不再需要。'
- en: 'Now, let''s see how our proxy can be used in an application:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的代理如何在应用程序中使用：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It''s worth noting that each file is actually a resource in the application
    and contains a line of text in the form of `I am file x`. After running the preceding
    example, we will get the following output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，每个文件实际上都是应用程序中的一个资源，并包含一行文本，形式为`I am file x`。在运行前面的示例之后，我们将得到以下输出：
- en: '![](img/13ba72fe-f774-47b8-9f45-725ad691d1a2.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13ba72fe-f774-47b8-9f45-725ad691d1a2.png)'
- en: As you can see from the preceding screenshot , the real object is lazily created
    and so the actual file read is done on demand. This causes our application to
    skip reading `file2.txt` because we don't even request for it. Someone might come
    up with a different solution that serves the same purpose, but it will probably
    be a different design pattern or something similar to proxy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的屏幕截图中所见，实际对象是延迟创建的，因此实际的文件读取是在需要时进行的。这导致我们的应用程序跳过了`file2.txt`的读取，因为我们甚至没有请求它。有人可能会提出不同的解决方案来达到相同的目的，但它可能是一个不同的设计模式或类似代理的东西。
- en: What it is good for
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的优点是什么
- en: The proxy design pattern is good when we want to delegate some expensive operations
    to other classes, do operations lazily, and thus make our applications more efficient.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将一些昂贵的操作委托给其他类，进行延迟操作，从而使我们的应用程序更高效时，代理设计模式是好的。
- en: What it is not so good for
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的不足之处是什么
- en: The proxy design pattern is pretty simple and really, there are no drawbacks
    that could be mentioned. As with every other design pattern, they should be used
    carefully and only when actually needed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式相当简单，实际上，没有可以提到的缺点。与其他任何设计模式一样，它们应该谨慎使用，并且只有在实际需要时才使用。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about structural design patterns and specifically
    about the following—adapter, decorator, bridge, composite, facade, flyweight,
    and proxy. We went through the details of each of them and showed a class diagram
    as well as a code example for each. Because of the richness of Scala, sometimes
    there can be a better implementation using some of the nice features of Scala,
    but sometimes the design pattern just looks the same as it would in a language
    such as Java.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了结构设计模式，特别是以下内容——适配器、装饰器、桥接、组合、外观、享元和代理。我们详细介绍了每一个，并为每一个展示了类图以及代码示例。由于Scala的丰富性，有时可以使用Scala的一些优秀特性来实现更好的实现，但有时设计模式在Java等语言中看起来可能是一样的。
- en: 'In many cases, the structural design patterns seem quite similar. This, however,
    shouldn''t confuse you as they still have different purposes. Some examples include:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，结构设计模式看起来相当相似。然而，这不应该让你感到困惑，因为它们仍然有不同的目的。一些例子包括：
- en: '**Adapter versus Bridge**: Adapter is used to convert one interface to another
    when we do not have access to the code. Bridge is used while designing software
    and it decouples abstraction from implementation for easier extensions in the
    future.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器与桥接的比较**：适配器用于在没有访问代码的情况下将一个接口转换为另一个接口。桥接用于软件设计时，它将抽象与实现解耦，以便于未来的扩展。'
- en: '**Proxy versus Decorator**: Decorators usually enhance an interface. Proxies
    provide the same interface, but help with application efficiency.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理与装饰器的比较**：装饰器通常增强一个接口。代理提供相同的接口，但有助于提高应用程序的效率。'
- en: Now, you should have a good understanding of the structural design patterns
    and will have enough knowledge to apply them in real-world projects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对结构设计模式有了很好的理解，并且拥有足够的知识来在实际项目中应用它们。
- en: In the next chapter, you will learn about *behavioral design patterns*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于*行为设计模式*的内容。
