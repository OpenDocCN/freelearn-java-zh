- en: Adding Web Interfaces to Quarkus Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将网络界面添加到 Quarkus 服务中
- en: So far, we have learned how to build a simple REST application with Quarkus
    and covered the actions that should be put in place to build, test, and deploy
    our application on a Kubernetes environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 Quarkus 构建一个简单的 REST 应用程序，并介绍了构建、测试和部署我们的应用程序到 Kubernetes
    环境中所需采取的操作。
- en: We could stop at this point and be happy with what we have achieved; however,
    there are still lots of milestones to reach. For example, we haven't used any
    web interfaces to access Quarkus services. As you will see in this chapter, Quarkus
    features some extensions that allow us to reuse standard enterprise APIs such
    as Servlets and web sockets. At the same time, you can use lighter JavaScript/HTML
    5 frameworks as user interfaces for your services. We will explore both approaches
    in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里停下来，对我们所取得的成就感到满意；然而，还有许多里程碑需要达到。例如，我们还没有使用任何网络界面来访问 Quarkus 服务。正如您在本章中将要看到的，Quarkus
    具有一些扩展，允许我们重用标准的企业级 API，如 Servlet 和 WebSocket。同时，您可以使用更轻量级的 JavaScript/HTML 5
    框架作为服务的用户界面。我们将在本章中探讨这两种方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding web content to Quarkus applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将网页内容添加到 Quarkus 应用程序中
- en: Running our application on Minishift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Minishift 上运行我们的应用程序
- en: Adding enterprise web components to our application such as Servlet and WebSockets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将企业级网络组件（如 Servlet 和 WebSocket）添加到我们的应用程序中
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter04).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章项目的源代码，链接为 [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter04)。
- en: Adding web content to Quarkus applications
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将网页内容添加到 Quarkus 应用程序中
- en: 'In the examples we''ve discussed so far, we''ve tested the web server capabilities
    of Quarkus by adding RESTful services. Under the hood, Quarkus uses the following
    core components to handle web requests:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的示例中，我们通过添加 RESTful 服务来测试了 Quarkus 的网络服务器功能。在底层，Quarkus 使用以下核心组件来处理网络请求：
- en: '**Vert.x Web server**: It is the core web component in Quarkus delivering RESTful
    services as long as **real-time** (server push) web applications. We will discuss
    more in detail about Vert.x in [Chapter 9](3ca131cb-e293-4c25-a7c8-29d05a409ccd.xhtml),
    *Unifying Imperative and Reactive with Vert.x* of this book.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vert.x 网络服务器**：它是 Quarkus 中提供 RESTful 服务以及实时（服务器推送）网络应用的核心网络组件。我们将在本书的第九章
    [统一命令式和响应式编程的 Vert.x](3ca131cb-e293-4c25-a7c8-29d05a409ccd.xhtml) 中更详细地讨论 Vert.x。'
- en: '**Undertow Web server**: It is a flexible product, built by combining different
    small single-purpose handlers, that comes into play in Quarkus when delivering
    `WebSocket` applications.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Undertow 网络服务器**：它是一个灵活的产品，通过组合不同的小型单一用途处理器构建而成，在 Quarkus 中用于交付 `WebSocket`
    应用程序时发挥作用。'
- en: As already discussed, we can add static web content (HTML, JavaScript, images)
    to our applications by including them under the `resources/META-INF/resources`
    folder of your project. What is the purpose of having static web content in a
    microservice-styled application? As a matter of fact, static content can be used
    in several contexts, including microservices. For example, we could provide helper
    pages for the service itself. We could also mix and match Quarkus with existing
    frameworks such as Swagger UI to test our REST endpoints without even writing
    complex user interfaces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以通过将静态网页内容（HTML、JavaScript、图像）包含在项目的 `resources/META-INF/resources`
    文件夹下，将静态网页内容添加到我们的应用程序中。在微服务风格的程序中拥有静态网页内容的目的是什么？实际上，静态内容可以在多个上下文中使用，包括微服务。例如，我们可以为服务本身提供辅助页面。我们还可以将
    Quarkus 与现有的框架（如 Swagger UI）混合使用，以测试我们的 REST 端点，而无需编写复杂用户界面。
- en: With this premise, we are going to demonstrate how to build a **Create, Read,
    Update, Delete** (**CRUD**) application that uses JSON to consume and produce
    data. Then, we will enrich our application with a thin web interface made from
    a JavaScript-based web framework.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，我们将演示如何构建一个使用 JSON 消费和生成数据的 **创建、读取、更新、删除**（**CRUD**）应用程序。然后，我们将通过一个基于
    JavaScript 的网络框架构建的轻量级网络界面来丰富我们的应用程序。
- en: Building a CRUD application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 CRUD 应用程序
- en: Within the GitHub source folder for this chapter, you will find two examples.
    The first one is located in the `Chapter04/customer-service/basic` folder and
    will be discussed in this section. We recommend importing the project into your
    IDE before you move on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 GitHub 源文件夹中，您将找到两个示例。第一个位于 `Chapter04/customer-service/basic` 文件夹中，将在本节中讨论。我们建议在继续之前将项目导入到您的
    IDE 中。
- en: 'If you take a look at the project''s structure, you will see that it is made
    up of three main components:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看项目结构，您将看到它由三个主要组件组成：
- en: 'First of all, there is a model class that records customer entries:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，有一个模型类用于记录客户条目：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Customer` class is the minimal definition of a `Customer` record. It is
    defined as a Plain Old Java Object that should be stored in memory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer` 类是 `Customer` 记录的最小定义。它被定义为应该存储在内存中的普通旧 Java 对象。'
- en: 'Next, take a look at the `CustomerRepository` class, which contains the core
    functionalities that we''ll use to manage our model:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，看一下 `CustomerRepository` 类，它包含我们将用于管理我们的模型的核心功能：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, it's just a vanilla implementation of a repository that serves
    as a pattern that stores and retrieves our data. In upcoming chapters, we will
    be adding other features, such as persistent storage and asynchronous behavior.
    Due to this, it's good to start with a service-agnostic example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只是一个简单的存储和检索我们数据的模式，作为存储和检索数据的模板。在接下来的章节中，我们将添加其他功能，如持久存储和异步行为。因此，从无服务器的示例开始是很好的。
- en: 'The customer service is completed by the `CustomerEndpoint` class, which has
    the following implementation:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `CustomerEndpoint` 类完成客户服务的实现，其实现如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, `CustomerEndpoint` is a thin REST layer over the `CustomerRepository`
    class and contains a method for each CRUD action, where it maps each one to the
    appropriate HTTP method. When using this approach, it would suffice to have a
    single REST path for the whole application (`/customers`) since the REST engine
    will call the appropriate method based on the HTTP request method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`CustomerEndpoint` 是在 `CustomerRepository` 类之上的一个薄薄的 REST 层，并为每个 CRUD 操作包含一个方法，其中它将每个操作映射到适当的
    HTTP 方法。当使用这种方法时，对于整个应用程序来说，只需要一个 REST 路径（`/customers`）就足够了，因为 REST 引擎将根据 HTTP
    请求方法调用适当的方法。
- en: Adding a UI to our customer service
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的客户服务添加用户界面
- en: 'As we mentioned in [Chapter 1](0e04a6a1-5a50-4557-be00-f4a3406fa1dd.xhtml),
    *Introduction to Quarkus Core Concepts*, you can include static resources such
    as HTML pages, JavaScript, CSS, or images in the `src/main/resources/META-INF/resources`
    folder. An `index.html` page is provided as a marker in our project, as shown
    in the project''s hierarchy:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 1 章](0e04a6a1-5a50-4557-be00-f4a3406fa1dd.xhtml) 中提到的，*Quarkus 核心概念简介*，您可以在
    `src/main/resources/META-INF/resources` 文件夹中包含静态资源，如 HTML 页面、JavaScript、CSS 或图像。`index.html`
    页面作为我们的项目中的一个标记提供，如图所示的项目层次结构：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to connect to our REST endpoint, we will include a JavaScript framework
    called AngularJS and some CSS styling in the head section of our `index.html`
    page:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到我们的 REST 端点，我们将在 `index.html` 页面的头部部分包含一个名为 AngularJS 的 JavaScript 框架和一些
    CSS 样式：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, within the head section of the `index.html` page, we will include the
    **AngularJS Controller**, which contains a function that we can use to access
    REST endpoint methods. We will pass the HTML form data as an argument, which we
    will discuss next:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `index.html` 页面的头部部分，我们将包含 **AngularJS 控制器**，其中包含一个我们可以用来访问 REST 端点方法的函数。我们将传递
    HTML 表单数据作为参数，我们将在下一节中讨论：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An in-depth discussion of AngularJS is beyond the scope of this book; however,
    in a nutshell, Angular applications rely on controllers to manage their flow of
    data. Each controller accepts `$scope` as a parameter. This parameter refers to
    the module or application that the controller needs to handle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 的深入讨论超出了本书的范围；然而，简而言之，Angular 应用程序依赖于控制器来管理它们的数据流。每个控制器都接受 `$scope`
    作为参数。该参数指的是控制器需要处理的模块或应用程序。
- en: The purpose of our controller will be to reach out to our REST application using
    different HTTP methods (`GET`, `POST`, `PUT`, and `DELETE`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制器的目的是使用不同的 HTTP 方法（`GET`、`POST`、`PUT` 和 `DELETE`）来访问我们的 REST 应用程序。
- en: 'The final part of the `index.html` page contains the form data, which can be
    used to insert new customers and edit existing ones:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 页面的最后一部分包含表单数据，可用于插入新客户和编辑现有客户：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we're done with the `index.html` page, we can write a test class for
    our application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了 `index.html` 页面，我们可以为我们的应用程序编写一个测试类。
- en: Testing our application
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的应用程序
- en: 'Before testing our application, it is worth mentioning that the `quarkus-jsonb`
    dependency has been included in this project in order to produce JSON content
    through the REST endpoint and to create JSON objects programmatically in the test
    class. The following is the dependency we have included in the `pom.xml` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的应用程序之前，值得一提的是，为了通过REST端点生成JSON内容以及在实际测试类中程序化创建JSON对象，我们已经在这个项目中包含了`quarkus-jsonb`依赖项。以下是我们已在`pom.xml`文件中包含的依赖项：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is our `CustomerEndpointTest` class, which can be used to validate
    the `Customer` application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`CustomerEndpointTest`类，它可以用来验证`Customer`应用程序：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's switch gears and look a little more closely at the test class. Most of
    the content here should look familiar to you, except for the `Json.createObjectBuilder`
    API, which is a convenient factory method that we can use to fluently create JSON
    objects. In our code, we have used it to produce two instances of `javax.json.JsonObject`.
    The first one has been serialized as a string and sent to our `CustomerEndpoint`
    via an HTTP `POST` call. The second one has been adopted to update the customer
    via the HTTP `PUT` call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换一下思路，更仔细地看看测试类。这里的大部分内容你应该都很熟悉，除了`Json.createObjectBuilder` API，这是一个方便的工厂方法，我们可以用它流畅地创建JSON对象。在我们的代码中，我们用它来生成两个`javax.json.JsonObject`实例。第一个已经被序列化为字符串并通过HTTP
    `POST`调用发送到我们的`CustomerEndpoint`。第二个被用来通过HTTP `PUT`调用更新客户。
- en: 'You can package and test the application with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令打包和测试应用程序：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will show the test result, which should be successful:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示测试结果，应该成功：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `testCustomerService` method completed successfully. Now that we have a
    tested REST application, we'll learn how to get our application running in a browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`testCustomerService` 方法成功完成。现在我们有一个经过测试的REST应用程序，我们将学习如何让我们的应用程序在浏览器中运行。'
- en: Running the example
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'Now that the full project is at our fingertips, let''s see it in action! You
    can start the application with the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经完全在我们手中，让我们看看它的实际效果！你可以使用以下命令启动应用程序：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, go to the home page at `http://localhost:8080`. You should be able to
    see the following UI, where you can add new customers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到主页`http://localhost:8080`。你应该能够看到以下UI，其中你可以添加新的客户：
- en: '![](img/2063641a-ff2f-462e-9c0d-b51c8dae5814.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2063641a-ff2f-462e-9c0d-b51c8dae5814.png)'
- en: As you already know, the embedded Vert.x server will serve content from under
    the root context. If you want to vary this, you can configure the `quarkus.http.root-path`
    key in `application.properties` to set the context path.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，嵌入的Vert.x服务器将在根上下文中提供服务。如果你想改变这一点，你可以在`application.properties`中配置`quarkus.http.root-path`键来设置上下文路径。
- en: 'Once you have some data, other actions (such as Edit and Delete) will be available:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一些数据，其他操作（如编辑和删除）将可用：
- en: '![](img/3cd1c02c-5776-4c27-a149-b851814d1b73.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3cd1c02c-5776-4c27-a149-b851814d1b73.png)'
- en: Cool! You can try editing and deleting data to verify that all the REST methods
    work properly. Now, we will learn how to deploy our application on Minishift.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你可以尝试编辑和删除数据来验证所有REST方法是否正常工作。现在，我们将学习如何在Minishift上部署我们的应用程序。
- en: Running our application on Minishift
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Minishift上运行我们的应用程序
- en: 'Start your Minishift environment as usual and execute the following command
    to build the native executable Docker image of your application and deploy it
    in a Pod:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规启动你的Minishift环境，并执行以下命令来构建应用程序的本地可执行Docker镜像，并将其部署到一个Pod中：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Building the native image of your application will take a minute or so. Next,
    we will upload the application as a binary build into a Minishift namespace. You
    should already be familiar with these steps, so we will just include the script
    to be executed, along with some inline comments. Execute each line and verify
    that the output is successful for all the commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序的本地镜像需要大约一分钟的时间。接下来，我们将作为二进制构建将应用程序上传到Minishift命名空间。你应该已经熟悉这些步骤，所以我们只包括要执行的脚本，以及一些内联注释。执行每一行，并验证所有命令的输出是否成功：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you should be able to see the Pod where your application is running in
    the Overview panel, which can be reached through the Route - External Traffic
    link: http://quarkus-customer-service-quarkus-customer-service.192.168.42.53.nip.io
    (the actual route address depends on the IP address that''s been assigned to your
    environment):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够在概述面板中看到您的应用程序正在运行的 Pod，该面板可以通过“路由 - 外部流量”链接访问：http://quarkus-customer-service-quarkus-customer-service.192.168.42.53.nip.io（实际的路由地址取决于分配给您环境的
    IP 地址）：
- en: '![](img/78836d82-1c4b-45ef-bb7c-d06ea32f4ddb.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78836d82-1c4b-45ef-bb7c-d06ea32f4ddb.png)'
- en: By clicking on the Route - External Traffic link, you will be able to verify
    that your application works in a Kubernetes environment, just like your local
    copy does.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“路由 - 外部流量”链接后，您将能够验证您的应用程序是否在 Kubernetes 环境中正常工作，就像您的本地副本一样。
- en: Configuring Cross-Origin Resource Sharing in Quarkus
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Quarkus 中配置跨源资源共享
- en: In this chapter, we have used JavaScript to drive a request into Quarkus' service.
    In a more complex scenario where your JavaScript code is deployed in its own service
    on a distinct host or context, you will have to implement **Cross-Origin Resource
    Sharing** (**CORS**) to make it work. In a nutshell, CORS allows web clients to
    make HTTP requests to servers hosted on different origins. By **origin**, we mean
    a combination of the URI scheme, hostname, and port number.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们使用 JavaScript 将请求驱动到 Quarkus 的服务中。在更复杂的场景中，您的 JavaScript 代码部署在其自己的服务上，位于不同的主机或上下文中，您将需要实现
    **跨源资源共享**（**CORS**）以使其工作。简而言之，CORS 允许 Web 客户端向托管在不同源上的服务器发送 HTTP 请求。通过 **源**，我们指的是
    URI 方案、主机名和端口号的组合。
- en: This is especially challenging for client-side languages such as JavaScript
    because all modern browsers require a same-origin policy for scripting languages.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于客户端语言，如 JavaScript，尤其具有挑战性，因为所有现代浏览器都要求脚本语言遵循同源策略。
- en: To make this work, we need to put our server applications in charge of deciding
    who can make requests and what type of requests are allowed in using HTTP headers.
    In practice, when the server receives a request from a different origin, it can
    reply and state which clients are allowed to access the API, which HTTP methods
    or headers are allowed, and finally whether cookies are allowed in the request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，我们需要让我们的服务器应用程序负责决定谁可以发起请求以及允许哪些类型的请求，这通过使用 HTTP 头部来实现。在实践中，当服务器从不同的源接收到请求时，它可以回复并声明哪些客户端被允许访问
    API，哪些 HTTP 方法或头部被允许，以及最后是否允许在请求中包含 cookies。
- en: 'How does that translate into Quarkus configurations? As you may have guessed,
    the configuration has to be applied to the `application.properties` file, under
    the `quarkus.http.cors` namespace. The following is a sample configuration that
    allows CORS for all domains, all HTTP methods, and all common headers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何转化为 Quarkus 配置？正如您可能猜到的，配置必须应用于 `application.properties` 文件中的 `quarkus.http.cors`
    命名空间下。以下是一个允许所有域名、所有 HTTP 方法以及所有常见头部的示例配置：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In real-world scenarios, you would probably set the list of allowed origins
    to the domain asking to connect remotely, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，您可能会将允许的源列表设置为请求远程连接的域名，如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we've clarified this, we can look at another example where we'll use
    a Java Enterprise component, such as `WebSocket`, to reach our Quarkus service.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经澄清了这一点，我们可以看看另一个示例，我们将使用 Java 企业组件，如 `WebSocket`，来访问我们的 Quarkus 服务。
- en: Adding Enterprise web components
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加企业级 Web 组件
- en: 'In our customer service example, the frontend application used a JavaScript
    structural framework (AngularJS) to test our application. Now, we will consider
    a different use case: a new external service is going to connect to our application
    using a different protocol stack. Besides JAX-RS endpoints, Quarkus has native
    support for the `WebSocket` technology that runs in the embedded Undertow web
    server. Therefore, in this example, we will add a `WebSocket` endpoint to our
    existing application. This will be paired with another `WebSocket` running in
    a different application.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的客户服务示例中，前端应用程序使用 JavaScript 结构化框架（AngularJS）来测试我们的应用程序。现在，我们将考虑一个不同的用例：一个新的外部服务将使用不同的协议栈连接到我们的应用程序。除了
    JAX-RS 端点外，Quarkus 还原生支持在嵌入式 Undertow Web 服务器上运行的 `WebSocket` 技术。因此，在这个示例中，我们将向现有的应用程序添加一个
    `WebSocket` 端点。这将与另一个在不同应用程序中运行的 `WebSocket` 配对。
- en: Introducing WebSockets
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 WebSockets
- en: First off, let's briefly introduce new components for our application. `WebSocket`,
    as defined by its enterprise specification, is an API that establishes **socket**
    connections between a browser and a server endpoint. This is pretty much similar
    to standard TCP sockets due to its persistent connection between the client and
    the server, where both parties can start sending data at any time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们简要介绍我们应用程序的新组件。根据其企业规范，`WebSocket`是一个API，它在一个浏览器和服务器端点之间建立**套接字**连接。由于客户端和服务器之间有持久的连接，双方可以随时开始发送数据，所以它与标准TCP套接字非常相似。
- en: 'Typically, you would open a `WebSocket` connection simply by calling the `WebSocket`
    constructor in your JavaScript code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你只需在JavaScript代码中调用`WebSocket`构造函数来打开一个`WebSocket`连接：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the URL schema for `WebSocket` connections (`ws:`). We also have `wss:`
    for secure `WebSocket` connections, which is used in the same way as `https:`
    is for secure HTTP connections.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`WebSocket`连接的URL模式（`ws:`）。我们还有`wss:`用于安全的`WebSocket`连接，它以与`https:`相同的方式用于安全的HTTP连接。
- en: We can attach some event handlers to the connection to help us determine when
    the connection status is open, receiving messages, or when errors occur.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一些事件处理器附加到连接上，以帮助我们确定连接状态是打开的、正在接收消息，还是发生错误。
- en: 'We can declare a Java class `WebSocket` server endpoint on the server-side
    by annotating it with `@ServerEndpoint`. The URI where the endpoint is deployed
    needs to be specified as well, as shown in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在服务器端使用`@ServerEndpoint`注解来声明一个Java类`WebSocket`服务器端点。端点部署的URI也需要指定，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the next section, we will be adding a `WebSocket` layer to our existing project
    and then creating another thin project to remotely access `WebSocket` and add
    new customers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向我们的现有项目添加一个`WebSocket`层，然后创建另一个轻量级项目以远程访问`WebSocket`并添加新客户。
- en: Building a project that uses Websockets
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建使用Websockets的项目
- en: 'You will find two distinct projects within the `Chapter04/customer-service/websockets`
    folder in this book''s GitHub repository:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书GitHub仓库的`Chapter04/customer-service/websockets`文件夹中找到两个不同的项目：
- en: An updated `customer-service` project that ships with a `WebSocket` endpoint
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随附`WebSocket`端点的更新版`customer-service`项目
- en: A project called `customer-service-fe` that features a minimal JavaScript frontend
    for our `WebSocket` application
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`customer-service-fe`的项目，它为我们的`WebSocket`应用程序提供了一个最小化的JavaScript前端
- en: You should import both projects into your IDE before moving on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你应该将这两个项目导入到你的集成开发环境（IDE）中。
- en: 'First, let''s discuss the `customer-service` project. The main enhancement
    we have added is a `WebSocket` endpoint, which is in charge of inserting a new
    customer (using the `CustomerRepository` bean) and returning a tabular view of
    our customers. The following is the content of the `WebsocketEndpoint` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下`customer-service`项目。我们添加的主要增强功能是一个`WebSocket`端点，该端点负责插入新的客户（使用`CustomerRepository`组件）并返回我们客户的表格视图。以下是`WebsocketEndpoint`类的代码内容：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are two things to notice here, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的地方，如下所示：
- en: The method tagged with `@OnMessage` receives the customer to be added in JSON
    format as input and returns an updated list of customers.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`@OnMessage`注解的方法接收以JSON格式输入要添加的客户，并返回更新后的客户列表。
- en: This class uses an **encoder** in order to customize the message that's returned
    to the client. An encoder takes a Java object and produces its serialized representation,
    which can then be transmitted to the client. For example, an encoder is typically
    in charge of producing JSON, XML, and binary representations. In our case, it
    encodes the customer list in JSON format.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类使用一个**编码器**来定制返回给客户端的消息。编码器接收一个Java对象并产生其序列化表示，然后可以将其传输到客户端。例如，编码器通常负责生成JSON、XML和二进制表示。在我们的例子中，它以JSON格式编码客户列表。
- en: 'Now, let''s take a look at the `MessageEncoder` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`MessageEncoder`类：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, an `Encoder` must implement either of the following interfaces:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个`Encoder`必须实现以下接口之一：
- en: '`Encoder.Text<T>` for text messages'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Encoder.Text<T>`用于文本消息'
- en: '`Encoder.Binary<T>` for binary messages'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Encoder.Binary<T>`用于二进制消息'
- en: In our case, `List<Customer>` is received as a generic type in the `encode`
    method and transformed into a JSON string array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`List<Customer>`作为泛型类型在`encode`方法中接收，并转换为JSON字符串数组。
- en: 'To be compiled, our project needs the `quarkus-undertow-websockets` extension,
    which can be added manually into the `pom.xml` file. Alternatively, you can let
    the Maven plugin do it for you with the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行编译，我们的项目需要`quarkus-undertow-websockets`扩展，这可以通过手动将其添加到`pom.xml`文件中来实现。或者，您可以使用以下命令让Maven插件为您完成：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will see the following output on your console, which confirms that the
    extension has been added to our configuration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在控制台看到以下输出，这确认了扩展已被添加到我们的配置中：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The server project is now complete. You can compile it and run it with the
    following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器项目现在已完成。您可以使用以下命令编译和运行它：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's create a new frontend project with a thin `WebSocket` JavaScript
    client.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的前端项目，它包含一个瘦的`WebSocket`JavaScript客户端。
- en: Creating a WebSocket client project
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建WebSocket客户端项目
- en: '`WebSocket` clients, just like their server counterparts, can be written in
    many different languages. Since modern browsers have native support for `WebSocket`,
    we will write a simple JavaScript client so that we don''t have to install any
    additional tools or SDKs to run our example.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket`客户端，就像它们的服务器对应物一样，可以用许多不同的语言编写。由于现代浏览器对`WebSocket`有原生支持，我们将编写一个简单的JavaScript客户端，这样我们就不需要安装任何额外的工具或SDK来运行我们的示例。'
- en: Within the `customer-service-fe` folder, you will find the frontend project
    that can be used to reach our `WebSocket` example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`customer-service-fe`文件夹中，您将找到可以用来访问我们的`WebSocket`示例的前端项目。
- en: 'Our project contains a landing page named `index.html`, which is served when
    we request the root web context of our application. Within this page, we have
    included an HTML form and a table to display a list of customers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目包含一个名为`index.html`的着陆页，当请求我们应用程序的根Web上下文时，将提供此页面。在这个页面中，我们包含了一个HTML表单和一个表格来显示客户列表：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The connection to the `WebSocket` endpoint takes place in an external JavaScript
    file named `function.js` (you can find this in the `customer-service-fe/src/main/resources/META-INF/resources`
    folder in this book''s GitHub repository). Then following is the content of this
    file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket`端点的连接发生在名为`function.js`的外部JavaScript文件中（您可以在本书GitHub仓库的`customer-service-fe/src/main/resources/META-INF/resources`文件夹中找到此文件）。以下是该文件的内容：'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, there are several callback methods (`onOpen`, `onMessage`, `onError`)
    that are coupled with server events once the connection is established. Here,
    we will be adding a new customer, serialized as a JSON string, in the `doSend`
    method, while the `onMessage` callback method will receive the list of customers
    that was produced by our `WebSocket` encoder. This data will eventually be included
    in an HTML table.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一旦建立连接，就有几个回调方法（`onOpen`、`onMessage`、`onError`）与服务器事件相关联。在这里，我们将通过`doSend`方法添加一个新的客户，该客户以JSON字符串序列化，而`onMessage`回调方法将接收由我们的`WebSocket`编码器生成的客户列表。这些数据最终将包含在一个HTML表格中。
- en: 'You can run the project with the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行项目：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we have shifted the HTTP and debug port with an offset of `1000`
    so that it doesn't conflict with the `customer-service` project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将HTTP和调试端口移动了`1000`个偏移量，以避免与`customer-service`项目冲突。
- en: 'Browsing to `http://localhost:9080` will let you into the `WebSocket` client
    application. Add some sample data to verify that customers can be included in
    the table:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:9080`将带您进入`WebSocket`客户端应用程序。添加一些示例数据以验证客户是否可以包含在表格中：
- en: '![](img/27c0ff2a-9cbd-476c-8657-ef9151bfed99.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27c0ff2a-9cbd-476c-8657-ef9151bfed99.png)'
- en: Verify that the same data is also displayed in the AngularJS frontend, which
    is available at `http://localhost:8080`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 验证相同的数据是否也显示在可用的AngularJS前端中，该前端位于`http://localhost:8080`。
- en: Adding an AJAX handler
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加AJAX处理程序
- en: Our JavaScript client is primarily required when it comes to testing our `WebSocket`
    example. However, one more enhancement you will find in this project is a Java
    Servlet that will let you remove any hardcoded links to your backend so that both
    services can still communicate as we move our example to a different machine or
    port.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试我们的`WebSocket`示例时，我们的JavaScript客户端是必需的。然而，您在这个项目中还会发现一个增强功能，那就是一个Java
    Servlet，它将允许您删除任何硬编码的后端链接，这样在将示例移动到不同的机器或端口时，两个服务仍然可以通信。
- en: 'The following Servlet determines server endpoint information from an environment
    variable named `CUSTOMER_SERVICE` by using the `ws://localhost:8080/customers`
    string:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Servlet通过使用名为`CUSTOMER_SERVICE`的环境变量和字符串`ws://localhost:8080/customers`来确定服务器端点信息：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This change needs to be reflected in our JavaScript client so that it doesn''t
    use a hardcoded endpoint for our web socket. In the final version of the `function.js`
    file, you will find the following JavaScript function, which queries our Servlet
    via AJAX:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改需要在我们的 JavaScript 客户端中反映出来，以便它不使用硬编码的端点来访问我们的 WebSocket。在 `function.js` 文件的最终版本中，你会找到一个以下
    JavaScript 函数，该函数通过 AJAX 查询我们的 Servlet：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function is called when the HTML page is loaded:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTML 页面加载时，此函数会被调用：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, start the server from the same shell so that it reads the environment
    variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从相同的 shell 启动服务器，以便它读取环境变量：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, go to `http://localhost:9080` and verify that the output produced by the
    `WebSocket` request is the same as when the server endpoint address was statically
    defined.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `http://localhost:9080` 并验证由 `WebSocket` 请求产生的输出是否与服务器端点地址静态定义时相同。
- en: 'You can take this example one step further by varying `quarkus.http.port` in
    your `customer-service` application. For example, you could set it to `8888`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `customer-service` 应用程序中更改 `quarkus.http.port` 来将此示例进一步扩展。例如，你可以将其设置为
    `8888`：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`customer-service-fe` will be able to connect to the `WebSocket` endpoint once
    you have set the `CUSTOMER_SERVICE` environment variable accordingly:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer-service-fe` 将能够连接到 `WebSocket` 端点，一旦你相应地设置了 `CUSTOMER_SERVICE` 环境变量：'
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Great! In this section, we removed any static hardcoded information from our
    client application, which now uses an environment variable to reach out to the
    customer service.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在本节中，我们从客户端应用程序中移除了任何静态硬编码的信息，现在它使用环境变量来联系客户服务。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the different paths we can take to add web content
    to our Quarkus applications. First, we learned how to create a CRUD in-memory
    application to manage a set of Java objects. The example application was then
    accessed by a JavaScript layer (AngularJS) with some peculiar APIs to handle REST
    calls. We also looked at some configuration parameters that are needed when we
    want to enable CORS in Quarkus projects. Next, we added a `WebSocket` layer to
    introduce full-duplex communication between the initial project and the client
    frontend.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了我们可以采取的不同路径来将网络内容添加到我们的 Quarkus 应用程序中。首先，我们学习了如何创建一个 CRUD 内存应用程序来管理一组
    Java 对象。然后，该示例应用程序通过一个 JavaScript 层（AngularJS）和一些特殊的 API 来访问，这些 API 用于处理 REST
    调用。我们还探讨了在 Quarkus 项目中启用 CORS 时所需的某些配置参数。接下来，我们添加了一个 `WebSocket` 层，以在初始项目和客户端前端之间引入全双工通信。
- en: By completing this chapter, you now know how to use the embedded Vert.x and
    Undertow server to leverage REST APIs (`quarkus-resteasy`) and `WebSocket`/Servlet
    APIs (`quarkus-undertow-websockets`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，你现在知道如何使用嵌入式 Vert.x 和 Undertow 服务器来利用 REST API (`quarkus-resteasy`) 和
    `WebSocket`/Servlet API (`quarkus-undertow-websockets`)。
- en: In the next chapter, we will add database storage for our application using
    the Hibernate ORM and Hibernate Panache extensions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Hibernate ORM 和 Hibernate Panache 扩展为我们的应用程序添加数据库存储。
