- en: Chapter 9. Taking Our Game to the Next Level
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 将我们的游戏提升到下一个层次
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a muzzle flash using ParticleEmitter
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ParticleEmitter创建枪口闪光
- en: Creating a trigger system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建触发器系统
- en: Creating a timer trigger
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计时器触发器
- en: Adding an interaction trigger
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加交互触发器
- en: Controlling AI with triggers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触发器控制AI
- en: Creating a dynamic skybox with a moving sun
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有移动太阳的动态天空盒
- en: Improving a scene with postprocessing filters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用后处理过滤器改善场景
- en: Performing complex movements with MotionPaths
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MotionPaths执行复杂动作
- en: Cutscenes using cinematics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电影制作镜头
- en: Using a positional audio and environmental effects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位置音频和环境效果
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So the core mechanics are in and the game is playable, yet it still feels like
    the game lacks something. In this chapter, we will explore different methods to
    enhance games and fuse together some of the recipes from other chapters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，核心机制已经到位，游戏可玩，但仍然感觉游戏缺少一些东西。在本章中，我们将探讨不同的方法来增强游戏，并将一些其他章节中的食谱融合在一起。
- en: Creating a muzzle flash using ParticleEmitter
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ParticleEmitter创建枪口闪光
- en: 'Weapons of some sort are a common feature of many games and muzzle flashes
    greatly enhance the appearance and feeling when you fire. This recipe will show
    a way to create good-looking muzzle flashes by tweaking a ParticleEmitter''s properties.
    The following screenshot shows a texture with four muzzle flashes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 某种类型的武器是许多游戏中的常见特性，枪口闪光在开火时极大地增强了外观和感觉。这个食谱将展示如何通过调整ParticleEmitter的属性来创建看起来不错的枪口闪光。以下截图显示了一个包含四个枪口闪光的纹理：
- en: '![Creating a muzzle flash using ParticleEmitter](img/6478OS_09_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用ParticleEmitter创建枪口闪光](img/6478OS_09_01.jpg)'
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are two things needed before we can begin work on the ParticleEmitter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始对ParticleEmitter进行工作之前，需要准备两件事：
- en: First of all we need a texture for the muzzle flash. This can have anything
    from one to several images of muzzle flashes. The texture should be gray scaled.
    We'll add color using `ParticleEmitter`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个枪口闪光的纹理。这可以是从一个到几个枪口闪光图像。纹理应该是灰度图。我们将使用`ParticleEmitter`添加颜色。
- en: 'Secondly, we need to create a `Material` using the texture by performing the
    following steps:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们需要通过以下步骤创建一个`Material`，使用纹理：
- en: Right-click on your project's material folder and select **New.../Empty Material
    file**.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目材质文件夹上右键单击并选择**新建.../Empty Material file**。
- en: Select **Particle.j3md** as **Material Definition**.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Particle.j3md**作为**材质定义**。
- en: Then select the muzzle flash texture as **Texture**.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择枪口闪光纹理作为**纹理**。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now, we can begin creating the muzzle flash emitter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建枪口闪光发射器：
- en: Navigate to the **Emitters** folder in the project and select **New.../Empty
    jme3 Scene**. We should now have a fresh scene.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目中的**发射器**文件夹并选择**新建.../Empty jme3 Scene**。我们现在应该有一个新的场景。
- en: Right-click on the main node in the **SceneExplorer** window and select **Add
    Spatial/Particle Emitter**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景浏览器**窗口中的主节点上右键单击并选择**添加空间/粒子发射器**。
- en: Select the emitter instance and open the **Properties** window.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择发射器实例并打开**属性**窗口。
- en: Make sure the **Shadow Mode** option is **Off** and **Queue Bucket** is **Transparent**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将**阴影模式**选项设置为**关闭**，并将**队列桶**设置为**透明**。
- en: Then, select the muzzle flash material we created in the **Geometry/Material**
    section.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**几何/材质**部分选择我们创建的枪口闪光材质。
- en: Make the **Emitter** shape really small, for example, something like `[Sphere,
    0.0, 0.0, 0.0, 0.05]`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使**发射器**形状非常小，例如，例如`[Sphere, 0.0, 0.0, 0.0, 0.05]`。
- en: '**Num Particles** should be `1`, and **Particles Per Sec** should be `0.0`.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**粒子数**应该是`1`，而**每秒粒子数**应该是`0.0`。'
- en: Set **Start Color** to something like `[1.0, 1.0, 0.4, 1.0]` and **End Color**
    to `[1.0, 0.6, 0.2, 0.7]`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**起始颜色**设置为类似`[1.0, 1.0, 0.4, 1.0]`的东西，并将**结束颜色**设置为`[1.0, 0.6, 0.2, 0.7]`。
- en: Both **Start Size** and **End Size** should be `1.0`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**起始大小**和**结束大小**都应该设置为`1.0`。'
- en: '**High Life** and **Low Life** should be `0.15`.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高生命值**和**低生命值**应该是`0.15`。'
- en: '**Gravity** and **Face Normal** should be `[0.0, 0.0, 0.0]`.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重力**和**面向法线**应该是`[0.0, 0.0, 0.0]`。'
- en: Check the **Facing Velocity** box and set the **Initial Velocity** to`[0.0,
    0.0, 1.0]`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**面向速度**复选框并将**初始速度**设置为`[0.0, 0.0, 1.0]`。
- en: '**Images X** and **Images Y** should reflect the number of frames in the texture
    we created.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图像X**和**图像Y**应该反映我们创建的纹理中的帧数。'
- en: We can now test the emitter by clicking on the **Emit!** button.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过点击**Emit!**按钮来测试发射器。
- en: 'All these values can be seen in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些值都可以在以下屏幕截图中看到：
- en: '![How to do it...](img/6478OS_09_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/6478OS_09_02.jpg)'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The muzzle flash works pretty much like a normal ParticleEmitter with a couple
    of exceptions. Instead of outputting a constant stream of particles, it will only
    emit one. This is because **Num Particles** is set to `1`, meaning only one particle
    can be alive at any given time. **Particles Per Sec** is `0.0` so it won't continuously
    emit anything.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 闪光灯基本上就像一个普通的`ParticleEmitter`，但有几个例外。它不会输出恒定的粒子流，而只会发射一个。这是因为**粒子数量**设置为`1`，这意味着在任何给定时间只能有一个粒子是活跃的。**每秒粒子数**为`0.0`，所以它不会连续发射任何东西。
- en: The colors are set to be yellowish, turning a bit orange and fading slightly
    at the end of the lifetime; the lifetime being very short in this case, only 0.15
    seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色设置为黄色调，在寿命结束时略微变橙并逐渐变淡；在这种情况下，寿命非常短，只有0.15秒。
- en: A muzzle flash is emitted in one direction only. This is why we set **Facing
    Velocity** to `true` so that the particle will point in the direction of the velocity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 闪光灯只向一个方向发射。这就是为什么我们将**面向速度**设置为`true`，这样粒子就会指向速度的方向。
- en: Getting it to appear in the correct position in relation to the weapon can require
    a bit of tweaking. Using **Local Translation** can help us in this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使其在与武器的正确位置出现可能需要一些调整。使用**局部平移**可以帮助我们做到这一点。
- en: To use the muzzle flash on a weapon, open the target in **Scene Composer** and
    then choose **Link in Scene** on the muzzle flash. This way the original file
    can be modified and the changes will automatically appear in the places its being
    used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在武器上使用闪光灯，请打开**场景编辑器**中的目标，然后在闪光灯上选择**场景链接**。这样就可以修改原始文件，并且更改将自动出现在使用它的地方。
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Now that we have the muzzle flash and added it to a weapon, we can create a
    control in order to use it within the game by performing the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了闪光灯并将其添加到武器中，我们可以通过以下步骤创建一个控制，以便在游戏中使用它：
- en: Create a new class called `WeaponControl` extending `AbstractControl`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`WeaponControl`的新类，它扩展了`AbstractControl`。
- en: Add a `ParticleEmitter` field called `muzzleFlash`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`muzzleFlash`的`ParticleEmitter`字段。
- en: 'In the `setSpatial` method, check whether the supplied spatial has a suitable
    child, either by type or name (requires that the muzzle flash has a fixed name),
    and set the `muzzleFlash` field:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setSpatial`方法中，检查提供的空间是否具有合适的子空间，无论是通过类型还是名称（需要闪光灯有一个固定的名称），并设置`muzzleFlash`字段：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we create a publicly available `onFire` method and add the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个公开的`onFire`方法并添加以下内容：
- en: '[PRE1]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This control should then be added to the weapon spatial inside the game and
    `onFire` should be called whenever the weapon fires. The class is suitable to
    play sounds and keeps track of ammunition as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个控制应该添加到游戏中的武器空间内，并且每当武器开火时都应该调用`onFire`。这个类适合播放声音，并跟踪弹药。
- en: Creating a trigger system
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个触发系统
- en: Almost all story-driven games require some kind of system to trigger some sort
    of event for example, dialogs, enemies, or doors opening. Unless the game is very
    small, you generally don't want to hardcode these. The following recipe will describe
    a trigger system, which can be used for almost any type of game from FPSs to RTSs
    and RPGs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有以故事驱动的游戏都需要某种系统来触发某种事件，例如对话、敌人或门打开。除非游戏非常小，否则通常不希望硬编码这些。以下配方将描述一个触发系统，它可以用于几乎任何类型的游戏，从FPS到RTS和RPG。
- en: We'll start out by laying the ground work with an AppState controlling all the
    script objects and the basic functionality of a `Trigger` class. Then, we'll look
    into how to actually activate the trigger and use it for something.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过一个控制所有脚本对象和`Trigger`类基本功能的`AppState`来打下基础。然后，我们将探讨如何实际激活触发器并使用它。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start with the actual implementation, we create a small interface
    that we will use for various scripting scenarios. We call it `ScriptObject` and
    it should have the following three methods:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实际实现之前，我们创建了一个小接口，我们将用它来处理各种脚本场景。我们称之为`ScriptObject`，它应该有以下三个方法：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now, we can implement the `ScriptObject` in a class called `Trigger`. This
    will have six steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在一个名为`Trigger`的类中实现`ScriptObject`。这将包括六个步骤：
- en: 'Add the following fields to the `Trigger` class:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字段添加到`Trigger`类中：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `enabled` and `delay` fields should have getters and setters and `targets`
    should have a `addTarget` and `removeTarget` method publically available.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`enabled`和`delay`字段应该有getter和setter，`targets`应该有一个公开可用的`addTarget`和`removeTarget`方法。'
- en: 'In the `trigger` method, we add the following functionality:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`trigger`方法中，我们添加以下功能：
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the script is enabled in the `update` method, we should perform the following
    steps:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在`update`方法中启用了脚本，我们应该执行以下步骤：
- en: If `triggered` is `true` and delay is more than 0, the timer should be increased
    by tpf.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`triggered`为`true`且延迟大于0，计时器应该通过tpf增加。
- en: Then if the timer is more than or equal to delay, it should call `onTrigger()`.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果计时器超过或等于延迟，它应该调用`onTrigger()`。
- en: If delay is 0 and `triggered` is `true`, the timer should also call `onTrigger()`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果延迟为0且`triggered`为`true`，计时器也应该调用`onTrigger()`。
- en: In the `onTrigger` method, we should parse through all the values of `targetsMap`
    and call the trigger on them. Then `triggered` should be set to `false`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onTrigger`方法中，我们应该遍历`targetsMap`的所有值并调用它们上的触发器。然后`triggered`应该设置为`false`。
- en: Now, perform the following set of steps to control the `Trigger` class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下步骤来控制`Trigger`类。
- en: We define a new class called `ScriptAppState`, which extends `AbstractAppState`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`ScriptAppState`的新类，该类继承自`AbstractAppState`。
- en: It should have a `List<ScriptObject>` called `scriptObjects`, together with
    methods to add and remove ScriptObjects from `List`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该有一个名为`scriptObjects`的`List<ScriptObject>`，以及添加和从`List`中删除ScriptObjects的方法。
- en: In the `update` method, if `isEnabled()` is `true`, it should parse `scriptObjects`
    and call an update on all of the ScriptObjects.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，如果`isEnabled()`为`true`，它应该解析`scriptObjects`并对所有ScriptObjects调用更新。
- en: 'Now, we have a flexible system where one `ScriptObject` can trigger another.
    We''re still lacking input and output effects though. One common way to trigger
    events is when a player enters an area. So let''s go ahead and add that functionality
    by performing the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个灵活的系统，其中一个`ScriptObject`可以触发另一个。尽管如此，我们仍然缺少输入和输出效果。触发事件的一种常见方式是当玩家进入一个区域时。所以，让我们继续添加这个功能，通过执行以下步骤：
- en: Create a new class called `EnterableTrigger`, which extends `Trigger`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EnterableTrigger`的新类，该类继承自`Trigger`。
- en: This trigger needs a `Vector3f` field called `position` to define its place
    in the physical world along with a getter and setter.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个触发器需要一个名为`position`的`Vector3f`字段来定义它在物理世界中的位置，以及一个getter和setter。
- en: Add a `BoundingVolume` field called `volume`. In the `setter` method for this,
    we should call `volume.setCenter(position)`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`volume`的`BoundingVolume`字段。在这个字段的`setter`方法中，我们应该调用`volume.setCenter(position)`。
- en: Also, it needs a `List<Spatial>` called `actors` along with `add` and `remove`
    methods.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，它需要一个名为`actors`的`List<Spatial>`以及`add`和`remove`方法。
- en: 'Now, we should override the `update` method and then call the trigger if any
    item in the `actors` list is inside `volume`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该重写`update`方法，然后如果`actors`列表中的任何项目在`volume`内部，就调用触发器。
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've taken care of the triggering now. Let's actually do something with that
    trigger by creating a new class called `SpawnTarget`, implementing `ScriptObject`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经处理了触发。现在，让我们通过创建一个名为`SpawnTarget`的新类并实现`ScriptObject`来实际使用这个触发器。
- en: Like the `EnterableTrigger` class, the `SpawnTarget` class needs a `position`
    field and also a `Quaternion` field called `rotation`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`EnterableTrigger`类类似，`SpawnTarget`类需要一个`position`字段，还有一个名为`rotation`的`Quaternion`字段。
- en: The `SpawnTarget` class also requires a `Spatial` field called `target` and
    a Boolean field called `triggered` to know whether it's been triggered yet or
    not.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpawnTarget`类还需要一个名为`target`的`Spatial`字段和一个名为`triggered`的布尔字段，以知道它是否已经被触发过。'
- en: We should also add a `Node` field called `sceneNode` to attach the target to.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该添加一个名为`sceneNode`的`Node`字段，以便将目标附加到它。
- en: In the `trigger` method, we should check whether it has been triggered already.
    If not, we should set `triggered` to `true` and call `onTrigger`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`trigger`方法中，我们应该检查它是否已经被触发。如果没有，我们应该将`triggered`设置为`true`并调用`onTrigger`。
- en: 'The `onTrigger` method should apply the position and rotation to the target
    and attach it to the `sceneNode`. Depending on the implementation, we might want
    to subtract the `worldTranslation` and `worldRotation` values from the values
    we apply:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTrigger`方法应该将位置和旋转应用到目标并将其附加到`sceneNode`。根据实现方式，我们可能想要从我们应用的价值中减去`worldTranslation`和`worldRotation`值。'
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s have a look at another common game object that can be picked up. In
    many games, characters can pick up various power-up weapons or other items simply
    by walking over them. This section will have the following eight steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个常见的可捡起游戏对象。在许多游戏中，角色可以通过走过它们简单地捡起各种增强武器或其他物品。本节将包含以下八个步骤：
- en: We create a new class called `Pickup` extending `Trigger`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Pickup`的新类，它扩展了`Trigger`类。
- en: Like `EnterableTrigger`, the `Pickup` class needs a position and a `List<Spatial>`
    called `actors`. We also need to add a `Spatial` field called `triggeringActor`
    and a float called `triggeringDistance`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`EnterableTrigger`类似，`Pickup`类需要一个位置和一个名为`actors`的`List<Spatial>`。我们还需要添加一个名为`triggeringActor`的`Spatial`字段和一个名为`triggeringDistance`的浮点数。
- en: For this class, we also need something to pick up, represented here by an interface
    called `Pickupable`. In addition, we need to keep track of whether it's been picked
    up by a Boolean called `pickedUp`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个类，我们还需要一些可以捡起的东西，这里通过一个名为`Pickupable`的接口来表示。此外，我们需要通过一个名为`pickedUp`的布尔值来跟踪它是否已经被捡起。
- en: The difference between the previous ScriptObjects we've worked with and the
    current ScriptObjects is that the one in this recipe should be visible in the
    world, represented by a `Spatial` called `model`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前使用的ScriptObjects与当前的ScriptObjects之间的区别在于，本食谱中的ScriptObjects应该在世界中可见，由一个名为`model`的`Spatial`表示。
- en: In the `update` method, we should check whether the `Pickup` object is enabled
    and not `pickedUp`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们应该检查`Pickup`对象是否启用并且没有被`pickedUp`。
- en: To make it stand out a bit in the game world, we rotate the model a little bit
    by applying the `model.rotate(0, 0.05f, 0)` value.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在游戏世界中让它稍微突出一点，我们通过应用`model.rotate(0, 0.05f, 0)`值稍微旋转一下模型。
- en: 'Still inside the `if` clause, we check that `actors` is not null and parse
    through the list. If any of the actors is inside the radius of the `triggerDistance`,
    we set it to be `triggeringActor` and call the `trigger` method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`if`子句中，我们检查`actors`是否不为null，并遍历列表。如果任何actor位于`triggerDistance`半径内，我们将它设置为`triggeringActor`并调用`trigger`方法：
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, in the `onTrigger` method, we should set `pickedUp` to `true`, detach
    `model` from scene graph and call `pickupObject.apply(triggeringActor)` to have
    it apply whatever the `Pickupable` object is supposed to do.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`onTrigger`方法中，我们应该将`pickedUp`设置为`true`，将`model`从场景图中分离，并调用`pickupObject.apply(triggeringActor)`以执行`Pickupable`对象应该执行的操作。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Trigger` class has a fairly simple functionality. It will wait for something
    to call its `trigger` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trigger`类具有相当简单的功能。它将等待某个东西调用它的`trigger`方法。'
- en: When this happens, it will either trigger all the connected ScriptObjects immediately
    or if a delay is set, it will start counting until the time has passed and then
    execute the trigger. Once this is done, it will be set up so it can be triggered
    again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，它将立即触发所有连接的ScriptObjects，或者如果设置了延迟，它将开始计时，直到时间过去然后执行触发。一旦完成，它将被设置为可以再次触发。
- en: The `ScriptAppState` state is a convenient way to control the scripts. Since
    the `AppState` is either disabled or not attached to the `stateManager`, no call
    to `update` in `ScripObjects` is made. This way, we can easily disable all the
    scripting if we want to.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptAppState`状态是控制脚本的一种方便方式。由于`AppState`要么是禁用的，要么没有附加到`stateManager`，因此在`ScriptObjects`中没有调用`update`。这样，我们可以轻松地禁用所有脚本。'
- en: To create a working example with `Trigger`, we extended it into a class called
    `EnterableTrigger`. The idea with the `EnterableTrigger` class was that if any
    of the supplied actor spatials enter its `BoundingVolume` instance, then it should
    trigger whatever is connected to it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个带有`Trigger`的工作示例，我们将其扩展为一个名为`EnterableTrigger`的类。`EnterableTrigger`类的想法是，如果任何提供的actor
    spatial进入其`BoundingVolume`实例，那么它应该触发与之连接的任何内容。
- en: The basic `Trigger` method doesn't have the need for a position as it is a purely
    logical object. The `EnterableTrigger` object, however, has to have a relation
    to the physical space as it needs to know when one of the actors has entered its
    `BoundingVolume` instance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`Trigger`方法不需要位置，因为它是一个纯粹逻辑的对象。然而，`EnterableTrigger`对象必须与物理空间有关，因为它需要知道何时有actor进入其`BoundingVolume`实例。
- en: This is true for `SpawnTarget` as well, which in addition to a location should
    have a rotation, to rotate a potential enemy in a certain direction. Spawning
    characters or items in games is commonly used to control the gameplay flow and
    save some performance. The `SpawnTarget` option allows this kind of control by
    adding new spatials only when triggered.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于`SpawnTarget`，除了位置外，它还应有一个旋转，以将潜在的敌人旋转到特定方向。在游戏中生成角色或物品通常用于控制游戏流程并节省性能。`SpawnTarget`选项通过仅在触发时添加新的`spatial`来实现这种控制。
- en: The strategy for how to perform spawning might differ depending on the implementation
    but the way described here assumes it involves attaching the target `Spatial`
    to the main node tree, which would generally activate its update method and controls.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如何执行生成可能因实现而异，但这里描述的方法假设它涉及将目标`Spatial`附加到主节点树中，这通常会激活其更新方法和控制。
- en: Likewise, the `rootNode` of the scene graph is not necessarily the best choice
    to attach the target to and depends a lot on the game architecture. It could be
    any `Spatial`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，场景图的`rootNode`不一定是最合适的选择来附加目标，这很大程度上取决于游戏架构。它可以是一个任意的`Spatial`。
- en: Lastly, in this recipe, we created a `Pickup` object, which is very common in
    many games. These can be anything from items that increase health instantly or
    weapons or other equipment that are added to an inventory. In many cases, it's
    similar to the `EnterableTrigger` except it only requires a radius to see whether
    someone is within the pickup range or not. We keep track of the actor that enters
    it so that we know who to apply the pickup to. In this recipe, the pickup is represented
    by an object called `Pickupable`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个配方中，我们创建了一个`Pickup`对象，这在许多游戏中非常常见。这些可以是任何增加生命值、武器或其他装备，这些装备被添加到库存中。在许多情况下，它与`EnterableTrigger`类似，但它只需要一个半径来判断某人是否在拾取范围内。我们跟踪进入它的演员，以便我们知道将拾取应用于谁。在这个配方中，拾取由一个称为`Pickupable`的对象表示。
- en: Once it's picked up, we set `pickedUp` to `true` so that it can't be picked
    up again and detach the model from the node tree to make it disappear. If it is
    a recurring power up, a delay can be used here to make it available again after
    some time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦拾取，我们将`pickedUp`设置为`true`，这样它就不能再次被拾取，并从节点树中分离模型以使其消失。如果它是一个重复的增强，可以使用延迟在一段时间后再次使其可用。
- en: Pickups in games usually stand out from other objects in the game world to draw
    attention to them. How this is done depends on the game style, but here we apply
    a small rotation to it in each call to the `update` method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的拾取物品通常在游戏世界中突出显示，以吸引玩家的注意。这种做法取决于游戏风格，但在这里，我们在每次调用`update`方法时对其应用一个小旋转。
- en: Since `Pickup` also extends `Trigger`, it's possible to use it to trigger other
    things as well!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Pickup`也扩展了`Trigger`，因此可以使用它来触发其他事物！
- en: Creating a timer trigger
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建计时器触发器
- en: In the *Creating a trigger system* recipe, we laid the foundation for a `Trigger`
    system as well as created some basic implementations. A timer can be very useful
    when creating complex scripts that rely on timing or sequenced events. Not only
    does it do the obvious (trigger the blast of the door and then the soldiers running
    through) but it can also work as a relay trigger in case many things should be
    triggered at the same time. In this recipe, we'll create this `Timer` object as
    well as an actual implementation of it where it triggers an explosion with several
    components. To save some time, we'll use the `TestExplosion` test from jMonkeyEngine
    to get `ParticleEmitters` set up and the timing for free. We'll also create a
    new `ScriptObject` called `PlayEffect`, which controls the particle emitters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建触发系统*的配方中，我们为`Trigger`系统奠定了基础，并创建了一些基本实现。在创建依赖于时间或顺序事件的复杂脚本时，计时器非常有用。它不仅执行明显的操作（触发门的爆炸然后士兵通过），还可以作为多个同时触发事件的接力触发器。在这个配方中，我们将创建这个`Timer`对象以及其实际实现，其中它通过几个组件触发爆炸。为了节省时间，我们将使用jMonkeyEngine的`TestExplosion`测试来免费设置`ParticleEmitters`和计时。我们还将创建一个新的`ScriptObject`，称为`PlayEffect`，它控制粒子发射器。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To be able to control a `ParticleEmitter` object from our script system, we
    need a new class to handle the `ParticleEmitter` object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从我们的脚本系统中控制`ParticleEmitter`对象，我们需要一个新的类来处理`ParticleEmitter`对象：
- en: Start by creating a new class called `PlayEffect`, which implements `ScriptObject`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`PlayEffect`的新类，该类实现了`ScriptObject`。
- en: The `PlayEffect` class needs a Boolean called `emitAllParticles`, a `ParticleEmitter`
    field called `effect`, and a Boolean to control whether it's enabled or not (default
    it to `true`).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PlayEffect` 类需要一个名为 `emitAllParticles` 的布尔值，一个名为 `effect` 的 `ParticleEmitter`
    字段，以及一个布尔值来控制是否启用（默认设置为 `true`）。'
- en: The `trigger` method should call `onTrigger` if the object is enabled.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`trigger` 方法应该在对象启用时调用 `onTrigger`。'
- en: The `onTrigger` method should enable `effect` and if `emitAllParticles` is `true`,
    it should call `emitter.emitAllParticles()`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTrigger` 方法应该启用 `effect`，如果 `emitAllParticles` 是 `true`，则应该调用 `emitter.emitAllParticles()`。'
- en: 'Apart from the setter methods, this is all that''s needed for the `PlayEffect`
    class. Now, we can look at the `Timer` class by performing the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置器方法之外，这就是 `PlayEffect` 类所需的所有内容。现在，我们可以通过以下步骤查看 `Timer` 类：
- en: We create a new class called `Timer`, which implements `ScriptObject`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的类 `Timer`，该类实现了 `ScriptObject`。
- en: 'It will use a simple callback interface to keep track of events:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将使用简单的回调接口来跟踪事件：
- en: '[PRE8]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It needs two Boolean fields. One called `enabled` and another called `running`.
    It also needs to keep track of time with three floats called `time`, `lastTime`,
    and `maxTime`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要两个布尔字段。一个名为 `enabled`，另一个名为 `running`。它还需要使用三个浮点数 `time`、`lastTime` 和 `maxTime`
    来跟踪时间。
- en: Finally, we will store the events in `HashMap<Float, TimerEvent>`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将事件存储在 `HashMap<Float, TimerEvent>` 中。
- en: 'We need a method to add events to the timer. Call it `addTimerEvent` and add
    inputs for `time` in seconds to execute the event, as well as a `TimerEvent` object
    with the code to execute it. After `TimerEvent` is placed in the `timerEvents`
    map, we check whether the supplied `time` value is higher than the current `maxTime`
    and set `maxTime` to `time` if true, as shown in the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个方法来向计时器添加事件。命名为 `addTimerEvent`，并添加 `time` 秒的输入来执行事件，以及一个包含执行代码的 `TimerEvent`
    对象。在将 `TimerEvent` 放入 `timerEvents` 映射后，我们检查提供的 `time` 值是否高于当前的 `maxTime`，如果是，则将
    `maxTime` 设置为 `time`，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `trigger` method should call `onTrigger`, if it is enabled.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`trigger` 方法应该在启用时调用 `onTrigger`。'
- en: The `onTrigger` method should set time to `0` and set `running` to `true`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTrigger` 方法应将时间设置为 `0` 并将 `running` 设置为 `true`。'
- en: The `update` method should first check whether the `Timer` is `enabled` and
    `running`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update` 方法应该首先检查 `Timer` 是否 `enabled` 和 `running`。'
- en: If it is, tpf should be added to the time.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，则将 tpf 添加到时间中。
- en: 'Inside the `same` statement, we then create an iterator based on `keySet` of
    `timerEvents` and parse through it. If the key (a float) is more than `lastTime`
    and less or equal to the current time, we should get the corresponding value from
    the `timerEvents` map and execute it. Otherwise, if the key is less than `lastTime`,
    we should just continue using the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `same` 语句内部，我们根据 `timerEvents` 的 `keySet` 创建一个迭代器，并遍历它。如果键（一个浮点数）大于 `lastTime`
    并且小于或等于当前时间，我们应该从 `timerEvents` 映射中获取相应的值并执行它。否则，如果键小于 `lastTime`，我们应该继续使用以下代码：
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Outside of the previous loop, we check if `time` is more than `maxTime`, in
    which case, we should set `running` to `false`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的循环之外，我们检查 `time` 是否大于 `maxTime`，如果是，则将 `running` 设置为 `false`。
- en: Finally in the `update` method, we set `lastTime` to be equal to `time`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后在 `update` 方法中，我们将 `lastTime` 设置为等于 `time`。
- en: 'With the basic logic done, let''s take a look at how we can use the timer for
    something real and use it to trigger an explosion by performing the following
    steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 基本逻辑完成后，让我们看看如何使用计时器进行实际操作，并按照以下步骤通过触发爆炸来实现：
- en: Copy the `TestExplosion` class from jMonkeyEngine's test package and strip it
    from everything except the methods that create `ParticleEmitters` and the lines
    in `simpleInitApp`, which uses them and sets up the camera.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 jMonkeyEngine 的测试包中复制 `TestExplosion` 类，并从中移除除了创建 `ParticleEmitters` 的方法和在
    `simpleInitApp` 中使用它们的行之外的所有内容，该行设置了相机。
- en: Then, create a `PlayEffect` instance for each of `ParticleEmitters` and set
    the effect accordingly with `emitAllParticles` set to `true`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为每个 `ParticleEmitters` 创建一个 `PlayEffect` 实例，并相应地设置效果，将 `emitAllParticles`
    设置为 `true`。
- en: Create a new `Timer` instance called `explosionTimer`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `explosionTimer` 的新 `Timer` 实例。
- en: 'Add a new `TimerEvent` at time 0 where it triggers the `flash`, `spark`, `smoke`,
    `debris`, and `shockwave` effects, by calling `trigger()` on each of the `PlayEffects`,
    as shown in the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间 0 添加一个新的 `TimerEvent`，触发 `flash`、`spark`、`smoke`、`debris` 和 `shockwave`
    效果，通过在 `PlayEffects` 的每个实例上调用 `trigger()`，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, add another `TimerEvent` at time `0.05f`, which triggers the `flame` and
    `roundSpark` effects.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在时间 `0.05f` 处添加另一个 `TimerEvent`，触发 `flame` 和 `roundSpark` 效果。
- en: The last `TimerEvent` should happen at time `5f` and should call `stop()` on
    all of the effects.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个 `TimerEvent` 应该在时间 `5f` 时发生，并且应该在所有效果上调用 `stop()`。
- en: 'Finally, we create a `ScriptAppState` instance to which we add `explosionTimer`
    and then add it to `stateManager` using the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 `ScriptAppState` 实例，向其中添加 `explosionTimer`，然后使用以下代码将其添加到 `stateManager`：
- en: '[PRE12]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we can trigger `explosionTimer`. It should perform the explosion in the
    same way as `TestExplosion` does.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以触发 `explosionTimer`。它应该以与 `TestExplosion` 相同的方式执行爆炸。
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once triggered, `Timer` works by checking the time that has passed since it
    was started (`time`). It then checks each of the events in the `timerEvents` map
    to see whether their execution time is anywhere between the current time and the
    last time (`lastTime`). The `maxTime` option is used by the `Timer` to know when
    it has executed the last of its events and can switch itself off. If the `Timer`
    was only meant to be used once, the events can simply be removed from the `timerEvent`
    map. This way it can be reused.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发，`Timer` 通过检查自启动以来经过的时间（`time`）来工作。然后，它检查 `timerEvents` 映射中的每个事件，以查看它们的执行时间是否在当前时间和最后时间（`lastTime`）之间。`maxTime`
    选项被 `Timer` 用于知道何时已执行其最后的事件，并可以关闭自己。如果 `Timer` 只打算使用一次，则可以简单地从 `timerEvent` 映射中删除事件。这样就可以重复使用。
- en: The `PlayEffect` instance has a fairly simple functionality to turn it on and
    off. Since `ParticleEmitters` can be used in two ways, fire all their particles
    at once, or emit a continuous stream of particles, it needs to know which way
    to fire it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayEffect` 实例具有相当简单的功能来打开和关闭它。由于 `ParticleEmitters` 可以有两种使用方式，一次发射所有粒子，或发射粒子的连续流，因此它需要知道如何发射。'
- en: In the example application, we create `ScriptAppState` since it's needed to
    update the `Timer` with the passed time. We don't need to add the `PlayEffect`
    instances since they don't use the `update` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序中，我们创建 `ScriptAppState`，因为它需要用经过的时间更新 `Timer`。我们不需要添加 `PlayEffect` 实例，因为它们不使用
    `update` 方法。
- en: Adding an interaction trigger
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加交互触发器
- en: Another common trigger is the one where an action from the player is required.
    For example, you can use it to open a door, or access an in-game store system
    or dialog.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的触发器是要求玩家执行动作的情况。例如，你可以用它来打开门，或访问游戏内的商店系统或对话框。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We begin by creating a new class called `InteractionTrigger`, which extends
    `Trigger` and also implements `ActionListener`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `InteractionTrigger` 的新类，它扩展了 `Trigger` 并实现了 `ActionListener`。
- en: The `InteractionTrigger` class needs a `Vector3f` field called position, a `BoundingVolume`
    field called `volume`, a `Spatial` field called `player`, and a `boolean` field
    called `inside`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InteractionTrigger` 类需要一个名为 `position` 的 `Vector3f` 字段，一个名为 `volume` 的 `BoundingVolume`
    字段，一个名为 `player` 的 `Spatial` 字段，以及一个名为 `inside` 的 `boolean` 字段。'
- en: Furthermore, the `InteractionTrigger` class needs access to the application's
    `guiNode`, which we store in a `Node` field with the same name and a `BitmapText`
    field called `interactionPrompt`. The text will be displayed when interaction
    is possible.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`InteractionTrigger` 类需要访问应用程序的 `guiNode`，我们将其存储在具有相同名称的 `Node` 字段和一个名为 `interactionPrompt`
    的 `BitmapText` 字段中。当可以进行交互时，将显示文本。
- en: We also have to define a static string called `INTERACTION_KEY = "Interact"`
    either in this class or the `input manager` class
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须在类中或 `input manager` 类中定义一个静态字符串 `INTERACTION_KEY = "Interact"`。
- en: 'The `update` method will check whether the player is inside `BoundingVolume`.
    If it is and `inside` is `false`, it will show `interactionPrompt`. On the other
    hand, if `inside` is `true` and the player is not inside `BoundingVolume`, it
    will remove it, as shown in the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update` 方法将检查玩家是否在 `BoundingVolume` 内。如果是，并且 `inside` 为 `false`，则显示 `interactionPrompt`。另一方面，如果
    `inside` 为 `true` 且玩家不在 `BoundingVolume` 内，则将其移除，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the implemented `onAction` method, we check for when the key corresponding
    to `INTERACTION_KEY` is released. Then, we see whether the trigger is enabled
    and whether `inside` is `true` or not. If both are `true`, we call `trigger()`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现的 `onAction` 方法中，我们检查与 `INTERACTION_KEY` 对应的键何时被释放。然后，我们查看触发器是否启用以及 `inside`
    是否为 `true`。如果两者都为 `true`，则调用 `trigger()`。
- en: 'Some logic outside the class is required to get the trigger to work. Apart
    from supplying `guiNode` and `BitmapText` to the trigger, the `INTERACTION_KEY`
    needs to be bound to `inputManager`. This can be done with the following line:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要在类外实现一些逻辑才能使触发器工作。除了向触发器提供`guiNode`和`BitmapText`之外，还需要将`INTERACTION_KEY`绑定到`inputManager`。这可以通过以下行完成：
- en: '[PRE14]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `InteractionTrigger` instance also needs to be added as a listener to `inputManager`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InteractionTrigger`实例还需要被添加为`inputManager`的监听器：'
- en: '[PRE15]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `InteractionTrigger` instance has several things in common with `EnterableTrigger`,
    which we created in the *Creating a trigger system* recipe, and it also has a
    new functionality. Rather than firing the trigger as soon as the player enters
    it, it sets the `inside` flag, which defines whether it's possible to interact
    with it or not. It also displays a text on the GUI for the player.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`InteractionTrigger`实例与我们在*创建触发器系统*配方中创建的`EnterableTrigger`有几个共同点，它还具有新的功能。它不是在玩家进入时立即触发触发器，而是设置`inside`标志，该标志定义了是否可以与之交互。它还在玩家的GUI上显示文本。'
- en: Once the `InteractionTrigger` receives a call to its `onAction` method from
    `InputManager`, it checks whether `inside` is `true` and calls `trigger`. To brush
    up your knowledge on how input is handled, check out [Chapter 2](ch02.html "Chapter 2. Cameras
    and Game Controls"), *Cameras and Game Control*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`InteractionTrigger`从`InputManager`收到对其`onAction`方法的调用，它会检查`inside`是否为`true`并调用`trigger`。为了提高你对如何处理输入的知识，请查看[第2章](ch02.html
    "第2章。相机和游戏控制")，*相机和游戏控制*。
- en: Controlling AI with triggers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触发器控制AI
- en: '[Chapter 5](ch05.html "Chapter 5. Artificial Intelligence"), *Artificial Intelligence*,
    deals with several methods to control AI in games. As we learned in that chapter,
    control and predictability are very important. Even if we have the smartest AI
    in the world, as programmers, we want to be able to know that the AI will perform
    a certain action at a certain time. This is where triggers can be extremely useful.
    In fact, with a good trigger system there might not be need for much AI at all.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。人工智能")，*人工智能*，讨论了在游戏中控制AI的几种方法。正如我们在那一章中学到的，控制和可预测性非常重要。即使我们拥有世界上最聪明的AI，作为程序员，我们仍然希望能够知道AI将在某个时间执行某个动作。这就是触发器可以极其有用的地方。事实上，有了好的触发系统，可能根本不需要太多的AI。'
- en: One example of trigger usage might be a warehouse where guards are in a patrolling
    state. Once the player reaches a certain area (maybe where they should not go),
    an alarm is triggered. At this point, we also want the guards to switch to a more
    aggressive state.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器使用的一个例子可能是一个仓库，守卫处于巡逻状态。一旦玩家到达某个区域（可能是不应该去的地方），就会触发警报。此时，我们还想让守卫切换到更具有侵略性的状态。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will link the trigger system we created previously in the chapter
    with the StateMachine-based `AIControl` class from the *Decision making – Finite
    State Machine* recipe in [Chapter 5](ch05.html "Chapter 5. Artificial Intelligence"),
    *Artificial Intelligence*. Even if you haven't followed the recipes in [Chapter
    5](ch05.html "Chapter 5. Artificial Intelligence"), *Artificial Intelligence*,
    but have a different class controlling AI, it should be quite easy to adapt this
    recipe to accommodate that class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将把我们在本章中之前创建的触发器系统与基于状态机的`AIControl`类链接起来，该类来自[第5章](ch05.html "第5章。人工智能")，*人工智能*中的*决策制定
    – 有限状态机*配方。即使你没有遵循[第5章](ch05.html "第5章。人工智能")，*人工智能*中的配方，但有一个不同的类控制AI，也应该很容易将此配方适应以适应该类。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: As with the previous examples, we begin by creating a new class that extends
    the `ScriptObject` interface. We can call it `AIScriptControl`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们首先创建一个新的类，该类扩展了`ScriptObject`接口。我们可以将其命名为`AIScriptControl`。
- en: It needs to have an `AIControl` field called `aiControl` and a `Class<AIState>`
    field called `targetState`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要有一个名为`aiControl`的`AIControl`字段和一个名为`targetState`的`Class<AIState>`字段。
- en: It might also have a `Spatial` called `target`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可能还有一个名为`target`的`Spatial`。
- en: Finally, we add a Boolean called `enabled`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个名为`enabled`的布尔值。
- en: In its `trigger` method, we should call `onTrigger` if `enabled` is `true`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`trigger`方法中，如果`enabled`为`true`，我们应该调用`onTrigger`。
- en: 'In the `onTrigger` method, we apply `targetState` to `aiControl`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onTrigger`方法中，我们将`targetState`应用于`aiControl`：
- en: '[PRE16]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If `target` is not null, we call `aiControl.setTarget(target)`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`target`不为空，我们调用`aiControl.setTarget(target)`。
- en: The `StateMachine` for the `AIControl` we created was a closed system and it
    didn't need any external input to change the states. Now, we need to be able to
    trigger it externally so let's add a setter method in the `AIControl`. Create
    a new method called `setState`, which takes a `Class<AIState>` called `state`
    as an input parameter.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的`AIControl`的`StateMachine`是一个封闭系统，它不需要任何外部输入来改变状态。现在，我们需要能够从外部触发它，所以让我们在`AIControl`中添加一个setter方法。创建一个名为`setState`的新方法，它接受一个名为`state`的`Class<AIState>`作为输入参数。
- en: 'Inside, we check whether `spatial` has the supplied state, and enable it if
    possible:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部，我们检查`spatial`是否具有提供的状态，并在可能的情况下启用它：
- en: '[PRE17]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe follows the pattern we established in the *Creating a trigger system*
    recipe. In the `onTrigger` method, we apply `targetState`, which will change the
    behavior and actions of the AI. For example, it can change from `PatrolState`
    to `AttackState`. We only supply the class type and not a whole instance of the
    class since the AI should already have the state and it might be configured already.
    In this way, we tell the AI to simply change the state if it is available. We
    also have a `target` field, in case the new state requires that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱遵循我们在*创建触发系统*菜谱中建立的模式。在`onTrigger`方法中，我们应用`targetState`，这将改变AI的行为和动作。例如，它可以从`PatrolState`变为`AttackState`。我们只提供类类型，而不是整个类的实例，因为AI应该已经有了状态，并且可能已经配置好了。这样，我们告诉AI如果可用，就简单地改变状态。我们还有一个`target`字段，以防新状态需要它。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It doesn't have to end with that. We can, for example, with some modification
    trigger the AI to start walking a path, turn in a certain direction, or take cover
    and other things. This functionality can either be built into this class or be
    made as separate classes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它不必以这种方式结束。例如，我们可以通过一些修改触发AI开始行走路径、转向特定方向或掩护等。这种功能可以集成到这个类中，或者作为独立的类来实现。
- en: To explore an example in detail, let's have a look at what will be needed to
    have the AI move to a specific location once `AIScriptControl` is triggered.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细探索一个示例，让我们看看在`AIScriptControl`被触发后，AI移动到特定位置需要什么。
- en: We will need an `AIState`, which handles moving to a set location. [Chapter
    5](ch05.html "Chapter 5. Artificial Intelligence"), *Artificial Intellegence*,
    explains this. The `SeekCoverState` can easily be modified to only have a `target`
    field rather than a list to choose from.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个`AIState`，用于处理移动到指定位置。[第5章](ch05.html "第5章。人工智能")*人工智能*解释了这一点。`SeekCoverState`可以轻松修改，使其只包含一个`target`字段，而不是一个可供选择的列表。
- en: We will need something to function as a waypoint or target. Again, the `CoverPoint`
    control from the same recipe can function as a waypoint too. It can also be extended
    so that using cover at `WayPoint` is an option within the class.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个作为航标或目标的东西。同样，来自同一菜谱的`CoverPoint`控件也可以作为航标使用。它还可以扩展，以便在`WayPoint`中使用掩护成为类中的一个选项。
- en: Finally, we will need to pass `WayPoint` to the state. Since we're not supplying
    a whole class, we can't set it in `AIState` itself. One way would be to pass it
    through the `setTarget` method of `AIControl`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将`WayPoint`传递给状态。由于我们没有提供整个类，我们无法在`AIState`本身中设置它。一种方法是通过`AIControl`的`setTarget`方法传递它。
- en: Creating a dynamic skybox with a moving sun
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有移动太阳的动态天空盒
- en: We covered how to create static skyboxes in [Chapter 1](ch01.html "Chapter 1. SDK
    Game Development Hub"), *SDK Game Development Hub*. While they are fine for many
    implementations, some games require day and night cycles.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。SDK游戏开发中心")*SDK游戏开发中心*中介绍了如何创建静态天空盒。虽然它们适用于许多实现，但有些游戏需要昼夜循环。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe will show us how to create a moving sun, which can be superimposed
    on a regular skybox. In this case, a neutral skybox without any protruding features
    such as mountains will work best. We'll also learn how to make a sky that changes
    color during the day. In this case, no skybox is required.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向我们展示如何创建一个移动的太阳，它可以叠加在常规天空盒上。在这种情况下，一个没有突出特征（如山脉）的中性天空盒将工作得最好。我们还将学习如何制作一天中改变颜色的天空。在这种情况下，不需要天空盒。
- en: 'We will also need a texture that should have a transparent background with
    a filled, white circle in it, as shown in the following figure:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个纹理，它应该有一个透明的背景，其中包含一个填充的白色圆圈，如图所示：
- en: '![Getting ready](img/6478OS_09_03.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6478OS_09_03.jpg)'
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We begin by creating a new application class extending `SimpleApplication`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的应用程序类，它扩展了`SimpleApplication`。
- en: 'In the `simpleInitApp` method, we first need to create `Geometry` for the sun:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`simpleInitApp`方法中，我们首先需要为太阳创建`Geometry`：
- en: '[PRE18]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to set some rendering hints on it, as shown in the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在其上设置一些渲染提示，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we can load a `Material` instance based on the unshaded material definition.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以根据无阴影材质定义加载一个`Material`实例。
- en: 'For `ColorMap`, we load the texture with the white circle in it and apply the
    texture. Then, for `Color` we can set an almost white color with a tint of yellow
    in it. We also have to enable alpha in the material:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`ColorMap`，我们加载包含白色圆圈的纹理并应用该纹理。然后，对于`Color`，我们可以设置一个几乎为白色但带有黄色色调的颜色。我们还需要在材质中启用alpha：
- en: '[PRE20]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, the basic `Geometry` is set up and we can create a `Control` class to move
    the sun across the sky by performing the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本的`Geometry`已经设置好，我们可以创建一个`Control`类，通过以下步骤在天空移动太阳：
- en: Create a class called `SunControl`, which extends `AbstractControl`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SunControl`的类，它扩展了`AbstractControl`。
- en: It should have a `float` field called `time`, a reference to the application
    camera called `cam`, a `Vector3f` field called `position`, and a `DirectionalLight`
    field called `directionalLight`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该有一个名为`time`的`float`字段，一个指向应用程序摄像机的引用`cam`，一个名为`position`的`Vector3f`字段，以及一个名为`directionalLight`的`DirectionalLight`字段。
- en: 'In the `controlUpdate` method, we start by finding the `x` and `z` positions
    based on the time and multiply the result to move it some distance away. We can
    also make the sun move up and down by doing the same for the `y` value:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，我们首先根据时间找到`x`和`z`位置，并将结果乘以一定的距离来移动太阳。我们也可以通过同样的方式对`y`值进行操作，使太阳上下移动：
- en: '[PRE21]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we should set `localTranslation` of the sun. Since we want it to appear
    to be very far away, we add the camera''s location. This way it will always appear
    to be the same distance from the camera:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们应该设置太阳的`localTranslation`。由于我们希望它看起来非常远，我们添加了摄像机的位置。这样，它将始终看起来与摄像机保持相同的距离：
- en: '[PRE22]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also want the sun to always face the camera. This is easily done by calling
    the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望太阳始终面向摄像机。这可以通过调用以下代码轻松实现：
- en: '[PRE23]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the `directionalLight` field is set, we should also set its direction. We
    get the direction by inverting `position`, as shown in the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了`directionalLight`字段，我们还应该设置其方向。我们通过反转`position`来获取方向，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we increase the `time` value by a factor of `tpf` (depending on how
    fast we want the sun to move). Since two PI in radians make up a circle, we start
    over once `time` exceeds that value, using the following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`time`值增加一个因子`tpf`（取决于我们希望太阳移动得多快）。由于两个PI弧度组成一个圆，因此当`time`超过该值时，我们使用以下代码重新开始：
- en: '[PRE25]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Going back to the `application` class, we add the control to the `Geometry`
    sun and `Geometry` to the scene graph:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`application`类，我们将控制添加到太阳的`Geometry`和场景图中：
- en: '[PRE26]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The previous implementation can be enough for many games but it can be taken
    much further. Let''s explore how to make the sun color dynamic based on its height
    above the horizon and how to also have a dynamic sky color by performing the following
    steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的实现对于许多游戏来说可能已经足够，但它可以做得更多。让我们探索如何根据太阳在水平线以上的高度动态调整太阳颜色，以及如何通过以下步骤动态调整天空颜色：
- en: First of all, let's introduce two static `ColorRGBA` fields in the `SunControl`
    class called `dayColor` and `eveningColor`. We also add another `ColorRGBA` field
    called `sunColor`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在`SunControl`类中引入两个静态`ColorRGBA`字段，分别称为`dayColor`和`eveningColor`。我们还添加另一个名为`sunColor`的`ColorRGBA`字段。
- en: In the `controlUpdate` method, we take the `y` value of the sun and divide it
    so that we get a value between `-1` and `1`, and store this as the height.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，我们取太阳的`y`值并对其进行除法处理，使其得到一个介于`-1`和`1`之间的值，并将其存储为高度。
- en: '`ColorRGBA` has a method to interpolate two colors that we can use to get a
    smooth transition during the day:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ColorRGBA`有一个方法可以插值两种颜色，我们可以使用它来在白天得到平滑的过渡：'
- en: '[PRE27]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After this, we set the color of `directionalLight` to the same as `sunColor`
    and also set the material''s `Color` parameter to the same:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将`directionalLight`的颜色设置为与`sunColor`相同，并将材质的`Color`参数也设置为相同：
- en: '[PRE28]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Handling the sky color will take a bit more work. To do this, perform the following
    steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 处理天空颜色需要更多的工作。为此，请执行以下步骤：
- en: We begin by creating a new class called `SkyControl` extending `AbstractControl`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`SkyControl`的新类，它扩展了`AbstractControl`。
- en: 'Like `SunControl`, the `SkyControl` class needs a `Camera` field called `cam`.
    It also needs a `ColorRGBA` field called `color` and three static `ColorRGBA`
    fields for different times in the day:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`SunControl`类似，`SkyControl`类需要一个名为`cam`的`Camera`字段。它还需要一个名为`color`的`ColorRGBA`字段以及三个用于一天中不同时间的静态`ColorRGBA`字段：
- en: '[PRE29]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `SkyControl` class needs to know about the sun's location so we add a `SunControl`
    field called `sun`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SkyControl`类需要了解太阳的位置，因此我们添加了一个名为`sun`的`SunControl`字段。'
- en: In the `controlUpdate` method, we set the `localTranslation` of the spatial
    to the location of the `cam`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，我们将空间体的`localTranslation`设置为`cam`的位置。
- en: 'Next, we get the sun''s height and if it is higher than 0, we interpolate the
    color between `eveningColor` and `dayColor`. Otherwise, we interpolate between
    the `eveningColor` and `nightColor` instead. Then, we set the resulting color
    in the sky''s material''s `Color` parameter, as shown in the following code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们获取太阳的高度，如果它高于0，我们在`eveningColor`和`dayColor`之间插值颜色。否则，我们将在`eveningColor`和`nightColor`之间插值。然后，我们将结果颜色设置在天空材料的`Color`参数中，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Going back to the `application` class, we create a box shaped `Geometry` called
    `sky`
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`application`类，我们创建了一个名为`sky`的盒子形状的`Geometry`。
- en: for the control with `10f` sides.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于控制具有`10f`边的形状。
- en: Like the sun geometry, sky should have the Sky `QueueBucket`, `ShadowMode.Offand
    CullHint.Never` settings applied to it.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与太阳几何形状类似，天空应该应用Sky `QueueBucket`、`ShadowMode.Off`和`CullHint.Never`设置。
- en: In addition, we should call `getAdditionalRenderState` and set `FaceCullMode`
    to `FaceCullMode.Off`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还应该调用`getAdditionalRenderState`并将`FaceCullMode`设置为`FaceCullMode.Off`。
- en: How it works...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Always causing the geometries of this recipe follow the camera around is one
    of the parts that make this recipe work. The other trick is using the Sky `QueueBucket`.
    The Sky `QueueBucket` can be thought of as lists of items to be rendered. Everything
    in the Sky bucket is rendered first. Because it's rendered first, other things
    will be rendered on top of it. This is why it appears to be far away even though
    it's really close to the camera.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使这个食谱中的几何形状跟随相机移动是使这个食谱工作的一部分原因。另一个技巧是使用Sky `QueueBucket`。Sky `QueueBucket`可以被视为要渲染的项目列表。Sky桶中的所有内容都会首先渲染。因为它首先渲染，所以其他东西将渲染在其上方。这就是为什么它看起来很遥远，尽管它实际上非常接近相机。
- en: We also use the direction of the sun from the camera for `DirectionalLight`
    in the scene, making it follow the sun as it moves across the sky.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用从相机到太阳的方向为场景中的`DirectionalLight`设置，使其随着太阳在天空中的移动而移动。
- en: When updating the control, we handle the movement of the sun using the `time`
    value, which increases with each update. Using `FastMath.sin` and `FastMath.cos`
    for the `x` and `z` values, we get it to move in a circle around the camera. Using
    `FastMath.sin` again for the `y` value will move it in an arc above (and below)
    the horizon. By multiplying the `y` value, we can get it to rise higher in the
    sky.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新控制时，我们使用`time`值处理太阳的运动，该值在每次更新时增加。使用`FastMath.sin`和`FastMath.cos`为`x`和`z`值，使其在相机周围移动圆形。再次使用`FastMath.sin`为`y`值将使其在地平线以上（和以下）的弧线上移动。通过乘以`y`值，我们可以使其在天空中的高度更高。
- en: The resulting position was added to the camera's location to always make the
    sun centered around the camera. Since the sun is a simple quad, we also had to
    rotate it to face the camera with every update.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 结果位置被添加到相机的位置，以确保太阳始终位于相机中心。由于太阳是一个简单的四边形，我们还需要在每次更新时将其旋转以面向相机。
- en: We went on to change the color of the sun based on the height above the horizon.
    We used the interpolate method of `ColorRGBA` to do this. Interpolation requires
    a value between `0.0` and `1.0`. That's why we needed to divide the `y` value
    by the max `y` value (or amplitude) in the case where we've multiplied it earlier
    to get a higher arc in the sky.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续根据地平线以上的高度更改太阳的颜色。我们使用`ColorRGBA`的插值方法来完成此操作。插值需要一个介于`0.0`和`1.0`之间的值。这就是为什么我们需要将`y`值除以最大`y`值（或振幅），在之前将其乘以以获得更高天空弧度的情况下。
- en: The movement of the box simulating the sky is similar. We just keep it centered
    around the camera so that even if it's a small box, it appears to cover the whole
    sky. Normally, we wouldn't see the sides of the box when we're inside it so we
    set `FaceCullMode` to `Off` to always make it render the sides.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟天空的盒子运动类似。我们只需将其保持在相机中心，即使它是一个小盒子，它看起来也覆盖了整个天空。通常，当我们身处其中时，我们不会看到盒子的侧面，所以我们设置`FaceCullMode`为`Off`以始终渲染侧面。
- en: '`SkyControl` was fitted with three instances of `ColorRGBA: dayColor` with
    a bluish tint, `eveningColor` with orange, and `nightColor` almost black. The
    `SunControl` was supplied to the control and used to interpolate between the colors
    based on the height of the sun. Anything above `0.0f` is considered day.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`SkyControl`被配置了三个`ColorRGBA`实例，分别是带有蓝色调的`dayColor`，橙色调的`eveningColor`，以及几乎全黑的`nightColor`。`SunControl`被提供给控制器，并用于根据太阳的高度在颜色之间进行插值。任何大于`0.0f`的值都被认为是白天。'
- en: In this implementation, the whole sky changes color with the sun. Any further
    development of `SkyControl` could include a more complex shape, such as a cylinder
    or sphere where only the vertices on the same side as the sun change color. Clouds
    can be implemented and they also use a quad that moves in the xz-plane.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，整个天空随着太阳的颜色变化。`SkyControl`的任何进一步开发都可能包括一个更复杂的形状，例如圆柱体或球体，其中只有与太阳同侧的顶点颜色会改变。云可以实施，并且它们也使用一个在xz平面移动的四边形。
- en: Another improvement would be to have a night-time, star-filled skybox outside
    of the box we made and fade the alpha value of `nightColor` to let it gradually
    shine through the night time.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个改进是，在盒子外面有一个充满星星的夜晚天空盒，并逐渐降低`nightColor`的alpha值，让它逐渐在夜晚发光。
- en: There's more...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we try the recipe with the unshaded material definition for the sky, it will
    work well in most cases. However, when it comes to the postprocessor water filter,
    it will not pick up the sky color properly. To achieve this, we will have to make
    some modifications to its material. We don't need to actually change any of the
    `.vert` or `.frag` files, but can create a new `Material Definition (.j3md)` file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用天空的无阴影材质定义这个配方，在大多数情况下它都会工作得很好。然而，当涉及到后处理器水过滤器时，它将无法正确拾取天空颜色。为了实现这一点，我们可能需要对其材质进行一些修改。我们实际上不需要更改任何`.vert`或`.frag`文件，但可以创建一个新的`Material
    Definition (.j3md)`文件。
- en: 'To make things as easy as possible, we can copy the `Unshaded.j3md` file. Refer
    to the following code within the `Unshaded.j3md` file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能简化操作，我们可以复制`Unshaded.j3md`文件。请参考`Unshaded.j3md`文件内的以下代码：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replace the previous line with the following line:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一行替换为以下行：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means we'll be using the vertex shader normally used by the Sky material
    to handle the positions of the vertices for the renderer.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将使用通常由天空材质使用的顶点着色器来处理渲染器的顶点位置。
- en: 'We also need to change the `WorldParameters` segment to contain the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改`WorldParameters`部分，使其包含以下内容：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Improving a scene with postprocessing filters
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后处理过滤器改善场景
- en: In the *Creating dynamic skybox with moving sun* recipe, we created a dynamic
    skybox that has many applications. It's possible to improve the appearance of
    this (and any other) scene significantly with postprocessing filters. They are
    called postprocessing filters because they are applied after the scene has already
    been rendered. This also makes them affect everything in the scene.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建带有移动太阳的动态天空盒*配方中，我们创建了一个具有许多应用的动态天空盒。通过后处理过滤器，我们可以显著改善这个（以及任何其他）场景的外观。它们被称为后处理过滤器，因为它们是在场景渲染之后应用的。这也使得它们影响场景中的所有内容。
- en: We also covered how to create an advanced postfilter in [Chapter 1](ch01.html
    "Chapter 1. SDK Game Development Hub"), *SDK Game Development Hub*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何在[第1章](ch01.html "第1章。SDK游戏开发中心") *SDK游戏开发中心* 中创建高级后过滤器。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The sun we have is now moving across the sky. It has very sharp edges and we
    can use a bloom filter to smooth it out a bit. Perform the following steps to
    improve a scene with the help of postprocessing filters:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的太阳正在天空中移动。它有非常锐利的边缘，我们可以使用布隆过滤器稍微平滑一下。执行以下步骤，通过后处理过滤器改善场景：
- en: First of all, we need to create a new `FilterPostProcessor` instance called
    `processor`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的`FilterPostProcessor`实例，命名为`processor`。
- en: Add this to the main view port, by calling `viewPort.addProcessor(processor)`
    from within the application.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在应用程序中调用`viewPort.addProcessor(processor)`，将此添加到主视口中。
- en: Then, we create a new bloom filter called `bloomFilter`. The default settings
    will produce a decent result, but it might be worth playing around a bit with
    the settings.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的名为`bloomFilter`的布隆过滤器。默认设置会产生一个相当不错的成果，但可能值得稍微调整一下设置。
- en: Add the `bloomFilter` to `processor.addFilter(bloomFilter)` and try it again.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bloomFilter`添加到`processor.addFilter(bloomFilter)`中，并再次尝试。
- en: Then, we create a new `LightScatteringFilter` instance called `lightScatteringFilter`
    and add it again to `processor.addFilter(lightScatteringFilter)`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的 `LightScatteringFilter` 实例，命名为 `lightScatteringFilter`，并将其再次添加到
    `processor.addFilter(lightScatteringFilter)`。
- en: This is dependent on a position for the light to scatter, so we need to make
    it aware of the sun's location. We can achieve this by adding a new field for
    the filter in the `SunControl` class from the last recipe along with a setter.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这取决于光散射的位置，因此我们需要让它知道太阳的位置。我们可以通过在 `SunControl` 类中添加一个新的字段以及一个设置器来实现这一点，该类来自上一个食谱。
- en: 'Then in the `controlUpdate` method, once we have updated `position`, we add
    the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在 `controlUpdate` 方法中，一旦我们更新了 `position`，我们添加以下代码：
- en: '[PRE34]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We still have some tweaking to do as it will now also apply the effect when
    the sun is below the ground. To mitigate this, we can disable the filter during
    nighttime:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要进行一些调整，因为现在当太阳在地面以下时，它也会应用这个效果。为了减轻这种情况，我们可以在夜间禁用过滤器：
- en: '[PRE35]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `FilterPostProcessor` acts as a container for the filters and applies them
    to the rendered result. Several filters can be added to the same processor and
    the order matters. If we add `LightScatteringFilter` before `bloomFilter`, we
    will get bloom applied to the light scattering and vice versa.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterPostProcessor` 作为一个容器，用于存放过滤器并将它们应用于渲染结果。可以将多个过滤器添加到同一个处理器中，并且顺序很重要。如果我们先添加
    `LightScatteringFilter`，然后再添加 `bloomFilter`，那么我们将得到应用于光散射的模糊效果，反之亦然。'
- en: The `bloomFilter` works by blurring the image slightly and intensifying colors,
    making the result appear a bit softer. Bloom filters work best with tweaking and
    shouldn't just be slapped on to the scene. It's easy to be impressed by the initial
    effect and leave it at that but it should always be adapted to the art style of
    the game. A fantasy game in an enchanted forest might get away with more bloom
    than a hard-boiled cyberpunk shooter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`bloomFilter` 通过轻微模糊图像并增强颜色来实现效果，使得结果看起来更加柔和。Bloom 过滤器在调整后效果最佳，不应直接应用于场景。人们很容易被最初的效果所吸引，并就此停止，但应该始终适应游戏的美术风格。在一个魔法森林中的幻想游戏可能比一个冷酷的赛博朋克射击游戏更能容忍更多的模糊效果。'
- en: The `LightScatteringFilter` instance does two things. Firstly, it creates a
    halo of rays emanating from the direction of the light source. Secondly, if the
    camera is pointing towards the light source, it will whiteout the image increasingly,
    simulating glare.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`LightScatteringFilter` 实例做两件事。首先，它从光源方向创建一束光晕。其次，如果相机指向光源，它将使图像逐渐变白，模拟眩光。'
- en: In a normal skybox, the sun would be static but in this example the sun keeps
    moving. By supplying the filter to `SunControl`, we could keep the logic to update
    the position within that class. We will also get some weird effects as the glare
    will still show. The easy way out is to simply turn off the effect as the sun
    gets below the horizon.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个正常的盒子中，太阳是静态的，但在这个例子中，太阳是移动的。通过将过滤器提供给 `SunControl`，我们可以在该类中保持更新位置的逻辑。我们还将得到一些奇怪的效果，因为眩光仍然会显示。一个简单的解决方案是在太阳低于地平线时简单地关闭效果。
- en: Performing complex movements with MotionPaths
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MotionPaths 进行复杂移动
- en: Players in games have been obliged to jump on moving platforms since the dawn
    of gaming. Even with the incredibly advanced games of today, it's not uncommon
    to encounter this most primitive game mechanic albeit with better graphics. There's
    also a popular retro genre that calls for the same, not the least for mobile games.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 自从游戏诞生以来，玩家就必须在移动平台上跳跃。即使在今天这些极其先进的游戏中，遇到这种最原始的游戏机制也并不罕见，尽管图形有所改进。还有一个流行的复古游戏类型，也要求这样做，至少对于移动游戏来说是这样。
- en: How do we do that in jMonkeyEngine? One way is, of course, to simply use move
    or `setLocalTranslation` on geometries. This can quickly get complex if we want
    to make sequenced paths. A better option is to use MotionPaths and MotionEvents.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jMonkeyEngine 中我们该如何实现？一种方法当然是简单地使用移动或 `setLocalTranslation` 对几何体进行操作。如果我们想要制作序列路径，这可能会很快变得复杂。一个更好的选择是使用
    MotionPaths 和 MotionEvents。
- en: A `MotionPath` object is basically a set of waypoints through which an object
    will move in an interpolated way meaning the movement will be smooth. The `MotionEvent`
    is the control class defining when and how the object should move along the `MotionPath`
    object. It can define how an object should be rotated along the path and if and
    how the path should be cycled through.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`MotionPath` 对象基本上是一系列航点，通过这些航点，对象将以插值的方式移动，这意味着移动将是平滑的。`MotionEvent` 是一个控制类，它定义了对象何时以及如何沿着
    `MotionPath` 对象移动。它可以定义对象在路径上如何旋转，以及路径是否以及如何循环。'
- en: In this recipe, we'll check out how to use them for a game, which could be a
    side-scrolling 2D game, but the same principles can be used to create advanced
    cinematic cutscenes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何将它们用于游戏，这可能是一个横向卷轴2D游戏，但相同的原理也可以用来创建高级电影场景。
- en: How to do it...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s begin by creating a platform object to move, by performing the following
    steps:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过以下步骤创建一个可移动的平台对象：
- en: 'We define a new `Geometry` called `platform` and apply the `Unshaded` material
    to it, as shown in the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个新的`Geometry`名为`platform`，并应用`Unshaded`材质，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then, we attach the `platform` object to `rootNode`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`platform`对象附加到`rootNode`上。
- en: Next, we define a new `MotionPath` object called `path`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个新的名为`path`的`MotionPath`对象。
- en: 'We add 8 waypoints in a circular pattern, using the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下代码以圆形模式添加8个航点：
- en: '[PRE37]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then, we call `path.setCycle(true)` to make it connect the first and last waypoints.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用`path.setCycle(true)`来使其连接第一个和最后一个航点。
- en: Now, we can define a new `MotionEvent` called `event` and supply `platform`
    and `path` in the constructor.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个新的名为`event`的`MotionEvent`，并在构造函数中提供`platform`和`path`。
- en: We call `event.setInitialDuration(10f)` and `setSpeed(1f)`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`event.setInitialDuration(10f)`和`setSpeed(1f)`。
- en: Finally, we call `event.setLoopMode(LoopMode.Loop)`.![How to do it...](img/6478OS_09_04.jpg)
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`event.setLoopMode(LoopMode.Loop)`。
- en: Debug MotionPath with red waypoints
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用红色航点调试MotionPath
- en: 'Optionally, we can visualize the path by calling the following method:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们可以通过调用以下方法来可视化路径：
- en: '[PRE38]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, all we need to do is call `event.play()` to start the event!
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要调用`event.play()`来开始事件！
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `for` loop creates eight waypoints along a circle at 45 degrees distance
    from each other. However, to make a complete circle the first and last waypoints
    need to be connected or the path will stop at the final one. This is why `setCycle(true)`
    must be set. This is treated as the ninth waypoint at the same position as the
    first.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在彼此之间相隔45度的圆周上创建了八个航点。然而，为了形成一个完整的圆，第一个和最后一个航点需要连接，否则路径将在最后一个航点上停止。这就是为什么必须设置`setCycle(true)`。这被视为与第一个航点相同位置的第九个航点。'
- en: MotionEvent's `initialDuration` is the time it should take to complete the path.
    The speed defines the factor at which the `initialDuration` should be completed.
    So, setting the speed to 2f will halve the actual time it takes for the object
    to complete its movement. The `loopMode`, not surprisingly, defines whether the
    object should stop once it has completed the path, or continue. There's also an
    option to make it go back the same path again with `LoopMode.Cycle`. This is not
    related to MotionPath's `setCycle` method.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: MotionEvent的`initialDuration`是完成路径所需的时间。速度定义了`initialDuration`应该完成的因子。因此，将速度设置为2f将减半对象完成移动的实际时间。不出所料，`loopMode`定义了对象在完成路径后是否应该停止，或者继续。还有一个选项使用`LoopMode.Cycle`让它再次沿着相同的路径移动。这与MotionPath的`setCycle`方法无关。
- en: While this recipe doesn't explore the option, it's possible to have the spatial
    in `MotionPath` perform various types of rotation. By default, no rotation will
    be applied. By calling `setDirectionType` it is possible to, for example, let
    the object follow the path's rotation (face the direction of the path) or rotate
    by a fixed amount or always face a certain point. Some of the direction types
    require a rotation to be supplied with the `setRotation` method.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个菜谱没有探索这个选项，但`MotionPath`中的空间可以执行各种类型的旋转。默认情况下，不会应用任何旋转。通过调用`setDirectionType`，例如，可以让对象跟随路径的旋转（面向路径的方向）或以固定量旋转或始终面向某个点。某些方向类型需要通过`setRotation`方法提供旋转。
- en: There's more...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now, the object is moving along its given path and we can add several platforms
    moving in different patterns. Let's say we want something to happen once a platform
    reaches the end of its path. Maybe it should start the next one or trigger one
    of our ScriptObjects from the previous recipes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对象正沿着其给定的路径移动，我们可以添加几个以不同模式移动的平台。假设我们想在平台到达其路径的末端时发生某些事情。也许它应该启动下一个，或者从之前的菜谱中触发我们的ScriptObjects。
- en: 'In that case, we can use `MotionPathListener`. This is an interface with a
    callback method called `onWayPointReached`, which will be called every time the
    path passes a waypoint. It will supply both the `MotionEvent` and the `index`
    of the waypoint. If we want to trigger something at the end of the path, it might
    look like the following code snippet:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们可以使用`MotionPathListener`。这是一个具有名为`onWayPointReached`的回调方法的接口，每次路径经过航点时都会被调用。它将提供`MotionEvent`和航点的`index`。如果我们想在路径的末端触发某些操作，代码片段可能如下所示：
- en: '[PRE39]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Cutscenes using cinematics
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用电影制作镜头场景
- en: The previous recipe explored the possibilities of using `MotionPaths` to move
    objects around. One step up from that and a way to organize many events in a sequence
    is cinematics. It can be used both to create in-game scripted events and advanced
    cutscenes. The power of a well-scripted in-game event should not be underestimated
    but neither should the time it takes to get one right.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的菜谱探讨了使用`MotionPaths`移动对象的可能性。比那更进一步，以及组织一系列事件的方法是电影。它可以用来创建游戏中的脚本事件和高级镜头。一个精心编写的游戏事件的力量不应被低估，但也不应低估正确实现它所需的时间。
- en: In this recipe, we'll explore the possibilities of the `Cinematics` system by
    creating a cutscene using content that we have created before.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过创建一个使用之前创建的内容的镜头场景来探索`Cinematics`系统的可能性。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some basic knowledge of `MotionPaths` and `MotionEvents` is required. Checking
    out the *Performing complex movements with MotionPath* recipe should provide enough
    information to get started. A new class that is introduced is the `Cinematic`
    class. This works as a sequencer or manager of many events firing them at set
    times. The events don't just have to be `MotionEvents` but could be `AnimationEvents`
    dealing with skeleton-based animations, `SoundEvents`, and even `GuiEvents`. It
    can also manage several cameras and switch between them.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些关于`MotionPaths`和`MotionEvents`的基本知识。查看*使用MotionPath执行复杂动作*菜谱应该提供足够的信息来开始。新引入的一个类是`Cinematic`类。这个类作为一个事件序列器或管理者，在设定的时间触发事件。事件不一定是`MotionEvents`，也可以是处理基于骨骼的动画的`AnimationEvents`、`SoundEvents`，甚至是`GuiEvents`。它还可以管理多个相机并在它们之间切换。
- en: Before starting the actual implementation of a cinematic scene, it's good to
    have some kind of script describing what is going to happen. This will help organize
    the cinematic event and will save time in the end.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实际实现电影场景之前，有一个描述将要发生什么的脚本是个好主意。这将有助于组织电影事件，并在最后节省时间。
- en: This recipe will use the `TestScene` from [Chapter 1](ch01.html "Chapter 1. SDK
    Game Development Hub"), *SDK Game Development Hub*. We can also use the animated
    sky box from earlier in this chapter. It will display Jaime walking from his initial
    position to stand by the edge of the water looking into the horizon. While he's
    walking, several switches between panning cameras will occur.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将使用来自[第1章](ch01.html "第1章。SDK游戏开发中心")的`TestScene`，*SDK游戏开发中心*。我们也可以使用本章早些时候的动画天空盒。它将显示杰伊迈从他的初始位置走到水边，眺望远方。在他行走的过程中，将发生几个切换到全景相机的动作。
- en: '![Getting ready](img/6478OS_09_05.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6478OS_09_05.jpg)'
- en: Using an empty node as a waypoint
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空节点作为航点
- en: Finding out good waypoints for characters and cameras can be difficult enough
    and it's not any easier if you have to do it all in code. A trick is to use the
    SceneComposer to create markers much like real movie makers use tape to designate
    where actors should move. Right-clicking on the scene node and selecting **Add
    Spatial.../New Node** will give us an invisible marker. Give this a recognizable
    name and drag it into place by using the `Move` function.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为角色和相机找到好的航点可能已经足够困难，如果你必须全部用代码来完成，那就更不容易了。一个技巧是使用SceneComposer创建标记，就像真正的电影制作人使用胶带标记演员应该移动的位置一样。在场景节点上右键单击并选择**添加空间.../新建节点**将给我们一个不可见的标记。给它一个可识别的名称，并使用`移动`功能将其拖放到合适的位置。
- en: How to do it...
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'So now that we have a scene prepared with some waypoints we can get to work
    with implementing the cutscene itself by performing the following steps:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经准备了一个带有一些航点的场景，我们可以通过执行以下步骤来实现镜头场景本身：
- en: We start by loading a scene where the `Cinematic` will be played out. The scene
    reference will be used in several places, so it is a good idea to store it in
    a field.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先加载一个场景，其中将播放`Cinematic`。场景引用将在几个地方使用，所以将其存储在一个字段中是个好主意。
- en: We'll also create a `Spatial` field called Jaime, the main actor and either
    load or extract him from the scene (depending on the setup).
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个名为贾迈的 `Spatial` 字段，作为主要演员，要么从场景中加载他，要么提取他（取决于设置）。
- en: 'Now, we can create a `MotionPath` instance called `jaimePath` for Jaime. Since
    we created `Nodes` for each waypoint in `SceneComposer`, we can get their location
    from the scene by using:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为贾迈创建一个名为 `jaimePath` 的 `MotionPath` 实例。由于我们在 `SceneComposer` 中为每个航点创建了
    `Nodes`，我们可以通过以下方式从场景中获取它们的位置：
- en: '[PRE40]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We go on and create a `MotionEvent` called `jaimeMotionEvent` using `jaimePath`
    and `initialDuration` of 25 seconds:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续创建一个名为 `jaimeMotionEvent` 的 `MotionEvent`，使用 `jaimePath` 和 25 秒的 `initialDuration`：
- en: '[PRE41]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It's also preferable if Jaime faces in the direction of the path he travels
    along, so we also set `directionType` to `MotionEvent.Direction.Path`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果贾迈面向他行进路径的方向，那就更好了，因此我们也设置 `directionType` 为 `MotionEvent.Direction.Path`。
- en: 'Before we get too far, we want to check out that the path Jaime follows is
    alright. Therefore, we should go ahead and create a `Cinematic` instance at this
    point. To do this, perform the following steps:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们走得太远之前，我们想检查一下贾迈遵循的路径是否正确。因此，我们应该在这个时候创建一个 `Cinematic` 实例。为此，执行以下步骤：
- en: 'Doing this is as simple as supplying it with a scene, which will affect `rootNode`
    together with the total duration of the cinematic:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这件事很简单，只需提供一个场景，这将影响 `rootNode` 以及整个电影的总时长：
- en: '[PRE42]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After that, we add `MotionEvent` with the following line; 0 being the time
    it should start at:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们添加以下 `MotionEvent`；0 是它应该开始的时间：
- en: '[PRE43]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We also need to add cinematic to the `stateManager` of the application with
    `stateManager.attach(cinematic)`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要使用 `stateManager.attach(cinematic)` 将电影添加到应用程序的 `stateManager` 中。
- en: Calling `cinematic.play()` at this point should display Jaime sliding along
    the path.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个时刻调用 `cinematic.play()` 应该会显示贾迈沿着路径滑动。
- en: 'Once we''re happy with it, we can go on and do the camera work as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对此满意，我们就可以继续进行以下相机工作：
- en: The `Cinematic` instance will create a `CameraNode` for us if we call `cinematic.bindCamera("cam1",
    cam)`, so let's do that for our first camera. The string is the reference that
    `Cinematic` will know the camera by.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们调用 `cinematic.bindCamera("cam1", cam)` 时，`Cinematic` 实例会为我们创建一个 `CameraNode`，所以让我们为我们的第一个相机做这件事。这个字符串是
    `Cinematic` 通过它来识别相机的引用。
- en: It will be a camera that pans so we create a `MotionPath` instance and a `MotionEvent`
    instance for it. Again, we can get the waypoints of the camera path from the scene.
    Since the `Node` we added in `SceneComposer` by default snaps to the ground, we
    need to add between 1.5f and 2.0f to the y axis to get it to a suitable height.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将是一个平移的相机，因此我们为它创建一个 `MotionPath` 实例和一个 `MotionEvent` 实例。同样，我们可以从场景中获取相机路径的航点。由于我们在
    `SceneComposer` 中添加的 `Node` 默认情况下会吸附到地面上，我们需要在 y 轴上添加 1.5f 到 2.0f 以达到合适的高度。
- en: 'The camera should look at a fixed point as it pans, so we set `directionType`
    of camera''s `MotionEvent` to `LookAt` and then also set the direction it should
    look at with `cam1Event.setLookAt` where the first `Vector3f` is the location
    to look at and the second is `Vector3f`, which is up in the world:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当相机平移时，它应该看向一个固定点，因此我们将相机 `MotionEvent` 的 `directionType` 设置为 `LookAt`，然后通过
    `cam1Event.setLookAt` 设置它应该看向的方向，其中第一个 `Vector3f` 是要查看的位置，第二个是 `Vector3f`，它在世界中是向上的：
- en: '[PRE44]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With that done, we can test the first camera pan. We do that by calling the
    following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以测试第一个相机的平移。我们通过调用以下代码来完成：
- en: '[PRE45]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The next camera will get its own `MotionPath` and `MotionEvent` instances and
    can similarly get its own `CameraNode`. It's perfectly fine to use the same physical
    camera for both of the CameraNodes.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个相机将获得自己的 `MotionPath` 和 `MotionEvent` 实例，并且可以像第一个相机一样获得自己的 `CameraNode`。使用相同的物理相机为两个
    `CameraNode` 是完全可以接受的。
- en: Now, we can start doing something about the lack of animation in the scene.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始处理场景中缺少动画的问题。
- en: 'The first thing Jaime does in the scene is walk towards the beach. We can create
    a new `AnimationEvent` instance that uses the `Walk` animation:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贾迈在场景中的第一件事是走向海滩。我们可以创建一个新的 `AnimationEvent` 实例，它使用 `Walk` 动画：
- en: '[PRE46]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We then add it to `cinematic` at 0 seconds:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 0 秒时将其添加到 `cinematic` 中：
- en: '[PRE47]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Jaime should stop when he reaches the last waypoint, which is also when the
    `jaimeMotionEvent` ends. So we create another `AnimationEvent` with the idle animation
    and add it at the end of the duration of the `jaimeMotionEvent`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当贾迈到达最后一个航点时，他应该停止，这也是 `jaimeMotionEvent` 结束的时候。因此，我们创建另一个带有空闲动画的 `AnimationEvent`
    并将其添加到 `jaimeMotionEvent` 的持续时间末尾。
- en: Tip
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'At the time of writing this, it seems the cinematic doesn''t end the animation
    when it starts a new one, so we have to do something to stop it ourselves. Using
    a MotionPathListener, we can check when the final waypoint is reached and manually
    stop the walking animation:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，似乎当它开始新的动画时，电影不会结束动画，因此我们必须自己做一些事情来停止它。使用MotionPathListener，我们可以检查何时达到最后一个航点，并手动停止行走动画：
- en: '[PRE48]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Cinematic` acts as a sequencer for all the different events and apart from
    firing events at the defined intervals, we can instead use `cinematic.enqueueCinematicEvent`.
    Doing so will start the supplied event just after the previous one is done. This
    can be useful if we want to trigger a series of animations right after each other.
    Cinematics can also be set to loop or cycle just like `MotionEvents` and you don't
    need to start them at time 0.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cinematic`充当所有不同事件的序列器，除了在定义的间隔处触发事件外，我们还可以使用`cinematic.enqueueCinematicEvent`。这样做将在上一个事件完成后立即启动提供的事件。如果我们想在一系列动画之后立即触发一系列动画，这很有用。Cinematics也可以设置为循环或循环，就像`MotionEvents`一样，你不需要从时间0开始。'
- en: In conclusion, using cinematics is not particularly technical. It's just difficult
    to get all the positions, angles, and timings right, especially since there's
    no intelligence or collision involved in the script. Once you get it right, however,
    the result will be extremely rewarding.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，使用电影并不是特别技术性。只是很难正确地获取所有位置、角度和时间，尤其是在脚本中不涉及智能或碰撞的情况下。然而，一旦你做到了，结果将会非常令人满意。
- en: Using a positional audio and environmental effects
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位置音频和环境效果
- en: Audio is an incredibly powerful mood setter and should not be overlooked in
    a game. In this recipe, we'll go through how to make the most of your sound assets
    using runtime effects and settings. If you're simply looking for omnipresent sounds
    or the basics on how to play them, check out [Chapter 1](ch01.html "Chapter 1. SDK
    Game Development Hub"), *SDK Game Development Hub*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 音频是一个极其强大的情绪营造者，在游戏中不应被忽视。在这个菜谱中，我们将介绍如何利用运行时效果和设置充分利用你的声音资产。如果你只是想寻找无处不在的声音或如何播放它们的基础知识，请查看[第1章](ch01.html
    "第1章。SDK游戏开发中心")，*SDK游戏开发中心*。
- en: This recipe will do well in an FPS, where you have a number of footstep sounds
    that are played when the player moves around. However, the principle is true for
    any short sound that is played often enough to sound repetitive.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱在FPS游戏中效果很好，其中当玩家移动时会有许多脚步声播放。然而，这个原理适用于任何经常播放以至于听起来重复的短声音。
- en: 'We''ll approach this recipe in two steps:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步来处理这个菜谱：
- en: First, we will learn how to vary a basic, repetitive sound. We can achieve this
    by varying the sound's pitch and using `LowPassFilter`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何改变一个基本且重复的声音。我们可以通过改变声音的音调和使用`LowPassFilter`来实现这一点。
- en: In the second step, we'll use reverb to vary it further, depending on the scene.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，我们将使用混响进一步改变声音，这取决于场景。
- en: How to do it...
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First of all, we need some basics set up.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置一些基础知识。
- en: We create a new application extending `SimpleApplication`, and add an `AudioNode`
    field called `audioNode`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的扩展`SimpleApplication`的应用程序，并添加一个名为`audioNode`的`AudioNode`字段。
- en: In addition to this, we need to keep track of passed time with a `float` field
    called `time` and another `float` field called `pauseTime`, which we set to `0.7f`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要使用名为`time`的`float`字段和另一个名为`pauseTime`的`float`字段来跟踪经过的时间，我们将`pauseTime`设置为`0.7f`。
- en: 'In the `simpleInitApp` method, we create a new `audioNode` instance:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`simpleInitApp`方法中，我们创建一个新的`audioNode`实例：
- en: '[PRE49]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We override the `simpleUpdate` method and begin by checking whether `time` is
    more than `pauseTime`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写`simpleUpdate`方法，首先检查`time`是否大于`pauseTime`。
- en: 'If it is, we should set a new float called `pitch`. This should have a value
    of `1f +- 10%`, which can be achieved with the following code:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，我们应该设置一个新的名为`pitch`的`float`。这个值应该是`1f +- 10%`，以下代码可以实现：
- en: '[PRE50]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, we call `audioNode.setPitch(pitch)` to set it.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用`audioNode.setPitch(pitch)`来设置它。
- en: 'Since this particular sound file plays four footsteps in sequence, we tell
    the node to not start from the beginning and only play the last of the footsteps
    by skipping forward in time, using the following code:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个特定的声音文件按顺序播放四个脚步声，我们告诉节点不要从开头开始，而是通过在时间上跳过来只播放最后一个脚步声，以下代码如下：
- en: '[PRE51]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Before exiting the `if` statement, we set `time` to `0`.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出`if`语句之前，我们将`time`设置为`0`。
- en: Finally, we shouldn't forget to increase `time` by tpf.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们不应该忘记通过tpf增加`time`。
- en: Try running the application now. We should hear the same sound over and over
    again but with a slight variation.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试运行应用程序。我们应该会一遍又一遍地听到相同的声音，但略有变化。
- en: 'We can use `LowPassFilter` to further vary the sound. We instantiate it by
    supplying a float for the general volume, and another for the high frequency volume.
    To get the most variation, we can supply two random values between 0f and 1f:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`LowPassFilter`进一步改变声音。我们通过提供一个浮点数作为一般音量和另一个作为高频音量来实例化它。为了获得最大的变化，我们可以提供介于0f和1f之间的两个随机值：
- en: '[PRE52]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, we call `audioNode.setDryFilter(filter)` before `audioNode.playInstance()`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`audioNode.playInstance()`之前调用`audioNode.setDryFilter(filter)`。
- en: When we play it again, we should hear a slightly more varied sound that from
    time to time gets more muffled.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次播放时，我们应该听到一个稍微变化的声音，偶尔会变得更闷。
- en: 'Reverb is another parameter we can use for our sounds. But unlike the previous
    examples, this should not be randomized each time we play it (or randomized at
    all!). We can add reverb using the following steps:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是我们可以用于声音的另一个参数。但与前面的例子不同，每次播放时不应随机化（或者根本不随机化！）！我们可以通过以下步骤添加反射：
- en: 'Create a new instance of `Environment` in the `simpleInitApp` method using
    one of the premade static ones in the `Environment` class and telling the application''s
    `audioRenderer` to use it:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`simpleInitApp`方法中创建`Environment`的新实例，使用`Environment`类中预制的静态之一，并告诉应用程序的`audioRenderer`使用它：
- en: '[PRE53]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Running the application again with this environment should give each footstep
    a huge echo.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行此环境下的应用程序应该会给每个脚步声带来巨大的回声。
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first part of the recipe, we varied a single sound by changing its pitch
    slightly every time it was played. This will still sound repetitive and it is
    recommended to have several premade variants of a sound and use it in combination
    with this technique to get more out of them.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱的第一部分，我们通过每次播放时略微改变音高来改变单个声音。这听起来仍然会重复，建议有几种预制的声音变体，并使用这种技术与它们结合使用，以获得更多效果。
- en: At the time of writing this, filters are not developed past `LowPassFilter`
    and have a limited use. It can still be used to cut the dryness of the sound and
    make it more muffled, as if heard through a wall, for example.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，过滤器尚未开发到`LowPassFilter`以上，并且用途有限。它仍然可以用来减少声音的干燥感，使其听起来更闷，例如，就像是通过墙壁听到的声音。
- en: Having a sound file with a sequence of footsteps, like the one in the test-data
    library is fine for some types of games. They work best when you know how far
    a character will move each time, such as in an RTS or turn-based game. In an FPS,
    however, where we don't know how fast or far a player decides to move, it's better
    to have footstep sounds split up and played individually based on movement speed.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个包含脚步声序列的声音文件，就像测试数据库中的那样，对于某些类型的游戏来说是可以的。当你知道每次角色会移动多远时，它们效果最好，例如在实时战略游戏或回合制游戏中。然而，在第一人称射击游戏中，由于我们不知道玩家决定移动多快或多远，最好将脚步声分开并基于移动速度单独播放。
- en: Using an `Environment` class is a great way to add immersion to sounds without
    having to bake the effect into the sound file. Controlling the effect unless it's
    level-wide can be a bit trickier. For example, you may want more reverb outside
    than in a furnished room. One way could be to use the trigger system from earlier
    in the chapter and big bounding volumes triggering a change in environment as
    the player enters their area.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Environment`类是一种在不将效果烘焙到声音文件中的情况下为声音添加沉浸感的好方法。除非是全局级别的效果，否则控制效果可能会有些棘手。例如，你可能希望在室外比在装饰过的房间里有更多的反射。一种方法可能是使用本章早些时候提到的触发系统，以及大边界体积触发玩家进入其区域时的环境变化。
- en: In this example, we used the `setDryFilter` method of the `audioNode`. This
    will not modify any reverb coming from the environment. To do that, we have to
    use `setReverbFilter`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`audioNode`的`setDryFilter`方法。这不会修改来自环境的任何反射。为了做到这一点，我们必须使用`setReverbFilter`。
- en: There's more
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: The recipe has covered playing audio originating from the player. It is almost
    as easy doing this for other entities in the scene. Since `AudioNode` extends
    `Node`, it has a position in the scene graph. Attaching an `AudioNode` instance
    to the scene graph will play the sound using its `worldTranslation` field, just
    like how a model will be shown at that location.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱已经涵盖了播放来自玩家的音频。为场景中的其他实体做这件事几乎一样简单。由于`AudioNode`扩展了`Node`，它在场景图中有一个位置。将`AudioNode`实例附加到场景图中将使用其`worldTranslation`字段播放声音，就像模型将在该位置显示一样。
- en: Apart from setting `localTranslation`, we also need to make sure that the positional
    Boolean in `AudioNode` is `true` (which it is by default). We're also only allowed
    to use mono channel sounds when using positional audio.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置`localTranslation`之外，我们还需要确保`AudioNode`中的位置布尔值是`true`（默认情况下就是如此）。在使用位置音频时，我们只能使用单声道声音。
