- en: Chapter 3. Reverse Engineering the Domain Layer with JPA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用JPA进行领域层的逆向工程
- en: The domain layer represents the real-world entities that model the heart of
    your application. At the highest level, the domain layer represents the application's
    business domain and fully describes the entities, their attributes, and their
    relationships with one another. At its most basic level, the domain layer is a
    set of **Plain Old Java Objects** (**POJOs**) that define the Java representation
    of the database tables being mapped onto your application. This mapping is achieved
    through JPA.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层代表了模拟应用程序核心的真实世界实体。在最高层次上，领域层代表了应用程序的业务领域，并完全描述了实体、它们的属性以及它们之间的关系。在最基本的层次上，领域层是一组**普通的旧Java对象**（**POJOs**），它们定义了数据库表的Java表示，这些表被映射到应用程序上。这种映射是通过JPA实现的。
- en: The **Java Persistence API** (**JPA**) is one of the most significant advances
    in the Java EE 5 platform, replacing the complex and cumbersome entity beans with
    the far simpler POJO-based programming model. JPA provides a standard set of rules
    for **Object Relational Mapping** (**ORM**), which are simple, intuitive, and
    easy to learn. Database relationships, attributes, and constraints are mapped
    onto POJOs using JPA annotations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java持久化API**（**JPA**）是Java EE 5平台中最重要的进步之一，它用更简单的基于POJO的编程模型取代了复杂和繁琐的实体bean。JPA提供了一套标准的**对象关系映射**（**ORM**）规则，这些规则简单直观，易于学习。数据库关系、属性和约束通过JPA注解映射到POJOs上。'
- en: 'In this chapter we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将执行以下操作：
- en: Reverse engineer the 3T database using the NetBeans IDE
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans IDE对3T数据库进行逆向工程
- en: Explore and define JPA annotations for our domain layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索并定义我们领域层的JPA注解
- en: Introduce the **Java Persistence Query Language** (**JPQL**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍**Java持久化查询语言**（**JPQL**）
- en: Understanding the reasons for using JPA
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用JPA的原因
- en: JPA is a productivity tool that allows developers to focus on business rather
    than write low-level SQL and JDBC codes. It completely eliminates the need to
    map a Java `ResultSet` to Java domain objects and greatly reduces the amount of
    effort required to produce a usable and functional application. A JPA-based application
    will be easier to maintain, test, and enhance. More importantly, the quality of
    your application code will significantly increase and the domain entities will
    become self-documenting.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JPA是一种提高开发人员专注于业务而不是编写低级SQL和JDBC代码的生产力工具。它完全消除了将Java的`ResultSet`映射到Java领域对象的需要，并大大减少了产生可用和功能性应用程序所需的工作量。基于JPA的应用程序将更容易维护、测试和增强。更重要的是，您的应用程序代码质量将显著提高，领域实体将变得自我描述。
- en: From personal experience, I estimate the time taken to write a traditional SQL
    application (without JPA, coding the CRUD SQL statements directly) to be in the
    order of 10-15 times longer than with the JPA approach. This translates into an
    enormous saving of time and effort for enterprise applications where cost saving
    can amount to many man-months of work. During the lifecycle of an application,
    when maintenance, bug fixes, and enhancements are taken into account, cost savings
    alone may be the difference between success and failure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据个人经验，我估计编写传统的SQL应用程序（不使用JPA，直接编写CRUD SQL语句）所需的时间大约是使用JPA方法的10-15倍。这意味着在企业应用程序中节省了大量的时间和精力。在应用程序的生命周期中，考虑到维护、错误修复和增强，仅仅通过节约成本就可能是成功与失败之间的差异。
- en: Understanding JPA implementations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JPA实现
- en: The JPA specification initially evolved from the combined experiences of key
    ORM implementations including TopLink (from Oracle), Hibernate, and Kodo to name
    a few. These products revolutionized Java database interactions by abstracting
    the underlying SQL from the domain layer and simplifying the development effort
    required to implement the core CRUD operations (Create, Read, Update, and Delete).
    Each implementation supports the JPA standards in addition to their own proprietary
    APIs. TopLink, for example, provides caching enhancements that are outside of
    the JPA specification as well as sophisticated query optimizations for Oracle
    databases. The implementation that you select may depend on the requirements of
    your application (for example, distributed caching) and also on the underlying
    database itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JPA规范最初是从包括TopLink（来自Oracle）、Hibernate和Kodo在内的关键ORM实现的经验中演变而来。这些产品通过将领域层中的底层SQL抽象出来，并简化实现核心CRUD操作（创建、读取、更新和删除）所需的开发工作，从而彻底改变了Java数据库交互。每个实现都支持JPA标准以及它们自己的专有API。例如，TopLink提供了超出JPA规范的缓存增强功能，以及针对Oracle数据库的复杂查询优化。您选择的实现可能取决于应用程序的要求（例如，分布式缓存）以及底层数据库本身。
- en: The GlassFish 4 server comes bundled with the open source **EclipseLink** JPA
    implementation, and this is what we will be using in our book. More information
    about the EclipseLink project can be found at [http://www.eclipse.org/eclipselink/](http://www.eclipse.org/eclipselink/).
    You don't need to download any files as the EclipseLink dependencies will be automatically
    added to your `pom.xml` file during the reverse engineering process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish 4服务器捆绑了开源的**EclipseLink** JPA实现，这是我们将在本书中使用的。有关EclipseLink项目的更多信息，请访问[http://www.eclipse.org/eclipselink/](http://www.eclipse.org/eclipselink/)。您无需下载任何文件，因为在逆向工程过程中，EclipseLink依赖项将自动添加到您的`pom.xml`文件中。
- en: Reverse engineering with NetBeans
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NetBeans进行逆向工程
- en: 'The **New Entity Classes from Database** wizard is one of the most helpful
    and time-saving wizards in NetBeans. It generates a set of entity classes from
    an existing database connection, extracting and annotating all the fields and
    defining relationships between the classes. To access the wizard, navigate to
    **File** | **New File**. This will open the **New File** window, where you can
    then select the **Persistence** category followed by the **Entity Classes From
    Database** file type:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “从数据库创建新实体类”向导是NetBeans中最有帮助和节省时间的向导之一。它从现有的数据库连接生成一组实体类，提取和注释所有字段，并定义类之间的关系。要访问该向导，请导航到“文件”|“新建文件”。这将打开“新建文件”窗口，然后您可以选择“持久性”类别，然后选择“来自数据库的实体类”文件类型：
- en: '![Reverse engineering with NetBeans](img/5457OS_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![使用NetBeans进行反向工程](img/5457OS_03_01.jpg)'
- en: 'Click on **Next** to display the **Database Tables** screen where you can create
    a **New Data Source**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“下一步”以显示“数据库表”屏幕，您可以在其中创建“新数据源”：
- en: '![Reverse engineering with NetBeans](img/5457OS_03_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![使用NetBeans进行反向工程](img/5457OS_03_02.jpg)'
- en: 'This will allow you to enter the **JNDI Name** and to select the **Database
    Connection** that was created in the previous chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您输入“JNDI名称”并选择在上一章中创建的“数据库连接”：
- en: '![Reverse engineering with NetBeans](img/5457OS_03_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![使用NetBeans进行反向工程](img/5457OS_03_03.jpg)'
- en: 'The wizard will now read all the tables and display them in the **Available
    Tables** list. Select all the tables and add them to the **Selected Tables** list
    as shown:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 向导现在将读取所有表并将它们显示在“可用表”列表中。选择所有表并将它们添加到“已选表”列表中，如图所示：
- en: '![Reverse engineering with NetBeans](img/5457OS_03_04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![使用NetBeans进行反向工程](img/5457OS_03_04.jpg)'
- en: Click on the **Next** button. This will display the following screen with entity
    class generation properties. Change the **Class Name** for each entity to remove
    the **Ttt** prefix by double-clicking on each **Class Name** row to edit this
    property as shown (the screenshot shows the `User` entity prior to editing). Why
    do we remove this **Ttt**? Simply because the reverse engineering process automatically
    creates a class name based on the table name and the **Ttt** prefix does not add
    anything to our design. The next change has to be done in the package name. Add
    **domain** to the package name as shown. This will generate new entity classes
    in the **com.gieman.tttracker.domain** package that will represent our business
    domain objects and the associated helper classes. Keeping our classes in well-defined,
    separate packages according to usage or purpose enhances our ability to maintain
    the application easily. For large enterprise applications, a well-defined Java
    package structure is crucial.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“下一步”按钮。这将显示以下屏幕，显示实体类生成属性。通过双击每个“类名”行来更改每个实体的“类名”，以删除“Ttt”前缀来编辑此属性（屏幕截图显示了编辑前的“User”实体）。为什么要删除这个“Ttt”？简单地因为反向工程过程会自动创建基于表名的类名，而“Ttt”前缀对我们的设计没有任何帮助。下一个更改必须在包名中完成。如图所示，在包名中添加“domain”。这将在“com.gieman.tttracker.domain”包中生成新的实体类，代表我们的业务领域对象和相关的辅助类。根据用途或目的将我们的类放在定义明确的独立包中，增强了我们轻松维护应用程序的能力。对于大型企业应用程序，定义良好的Java包结构至关重要。
- en: The final step is to uncheck the **Generate JAXB Annotations** checkbox. We
    don't need to generate XML via JAXB, so we will not need the additional annotations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是取消选中“生成JAXB注释”复选框。我们不需要通过JAXB生成XML，因此我们不需要额外的注释。
- en: '![Reverse engineering with NetBeans](img/5457OS_03_05.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![使用NetBeans进行反向工程](img/5457OS_03_05.jpg)'
- en: Now click on the **Next** button, which will show the following screen. The
    final step involves selecting the appropriate **Collection** **Type**. There are
    three different types of collections that can be used and all can be used with
    equal success. We will change the default **Collection Type** to **java.util.List**
    as the sort order is often important in an application's business logic and the
    other types do not allow sorting. On a more personal level, we prefer using the
    `java.util.List` API over the `java.util.Set` and `java.util.Collection` APIs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在单击“下一步”按钮，将显示以下屏幕。最后一步涉及选择适当的“集合类型”。有三种不同类型的集合可以使用，并且都可以同样成功地使用。我们将默认的“集合类型”更改为`java.util.List`，因为在应用程序的业务逻辑中，排序顺序通常很重要，而其他类型不允许排序。在更个人的层面上，我们更喜欢使用`java.util.List`
    API而不是`java.util.Set`和`java.util.Collection` API。
- en: '![Reverse engineering with NetBeans](img/5457OS_03_06.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用NetBeans进行反向工程](img/5457OS_03_06.jpg)'
- en: 'Click on the **Finish** button to start the reverse engineering process. When
    the process is complete, you can open the `src/java` nodes to view the generated
    files, as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“完成”按钮开始反向工程过程。过程完成后，您可以打开`src/java`节点查看生成的文件，如下图所示：
- en: '![Reverse engineering with NetBeans](img/5457OS_03_07.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![使用NetBeans进行反向工程](img/5457OS_03_07.jpg)'
- en: Introducing the persistence.xml file
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍persistence.xml文件
- en: 'The `persistence.xml` file is generated during the reverse engineering process
    and defines the JPA configuration for a set of entity classes. This file is always
    located in the `META-INF` directory at the root of the classpath. Maven projects
    have a special directory named `resources` located in the `src/main` directory,
    which contains additional resources applicable for building the Java project.
    The `resources` directory is automatically copied by Maven to the root of the
    classpath when building the project. Open the file by double-clicking on it to
    display the **Design** view of the file in the editor:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`persistence.xml`文件是在反向工程过程中生成的，为一组实体类定义了JPA配置。该文件始终位于类路径根目录下的`META-INF`目录中。Maven项目有一个名为`resources`的特殊目录，位于`src/main`目录中，其中包含适用于构建Java项目的其他资源。构建项目时，Maven会自动将`resources`目录复制到类路径的根目录。双击打开文件以在编辑器中显示文件的“设计”视图：'
- en: '![Introducing the persistence.xml file](img/5457OS_03_08.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![介绍persistence.xml文件](img/5457OS_03_08.jpg)'
- en: The **Design** view contains several properties that are used to configure the
    persistence unit behavior. We will stick to the simplest settings, but we encourage
    you to explore the different strategies that may be useful for your own application's
    needs. For example, projects that require tables to be automatically created will
    appreciate the **Table Generation Strategy** of **Create** or **Drop and Create**.
    Selecting the different options and switching to the **Source** view will help
    us to quickly identify the appropriate properties in the `persistence.xml` file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计**视图包含用于配置持久性单元行为的几个属性。我们将坚持使用最简单的设置，但我们鼓励您探索可能对您自己应用程序需求有用的不同策略。例如，需要自动创建表的项目将欣赏**表生成策略**的**创建**或**删除和创建**。选择不同的选项并切换到**源**视图将帮助我们快速识别`persistence.xml`文件中的适当属性。'
- en: 'Click on the **Source** button at the top to view the default file contents
    in the text format:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 点击顶部的**源**按钮以以文本格式查看默认文件内容：
- en: '![Introducing the persistence.xml file](img/5457OS_03_09.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![介绍persistence.xml文件](img/5457OS_03_09.jpg)'
- en: 'Change the default `persistence-unit` node `name` attribute value to `tttPU`
    instead of the long autogenerated name. This value will be used in your Java code
    to refer to this persistence unit and is easy to remember. The `provider` node
    value is automatically set to the appropriate EclipseLink class, and the `jta-data-source`
    node value is automatically set to the data source used during the reverse engineering
    wizard. The `exclude-unlisted-classes` setting will define whether the classpath
    is scanned for annotated entity classes. Change this to `false`. For large projects,
    this is the safest way of ensuring that classes are not omitted accidentally.
    It is also possible to specify each class explicitly in the following way:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将默认的`persistence-unit`节点`name`属性值更改为`tttPU`，而不是长自动生成的名称。此值将用于您的Java代码来引用此持久性单元，并且易于记忆。`provider`节点值会自动设置为适当的EclipseLink类，`jta-data-source`节点值会自动设置为在反向工程向导期间使用的数据源。`exclude-unlisted-classes`设置将定义是否对注释的实体类进行类路径扫描。将其更改为`false`。对于大型项目，这是确保类不会被意外省略的最安全方法。还可以以以下方式明确指定每个类：
- en: '![Introducing the persistence.xml file](img/5457OS_03_10.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![介绍persistence.xml文件](img/5457OS_03_10.jpg)'
- en: This is fine for small projects but not very practical if you have hundreds
    of entity classes. In the previous example, the `exclude-unlisted-classes` property
    is set to `true`, meaning that only the specified classes will be loaded without
    the need for classpath scanning. We prefer the first method for defining our JPA
    classes, where the classpath is scanned for all the annotated entity classes by
    setting `exclude-unlisted-classes` to `false`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于小型项目来说很好，但如果您有数百个实体类，这就不太实际了。在前面的示例中，`exclude-unlisted-classes`属性设置为`true`，这意味着只有指定的类将被加载，无需进行类路径扫描。我们更喜欢通过将`exclude-unlisted-classes`设置为`false`来定义我们的JPA类的第一种方法，从而通过类路径扫描加载所有注释的实体类。
- en: The final configuration item of interest is the `transaction-type` attribute.
    There are two different types of transactions supported by this item, of which
    we have `JTA` set by default. **JTA** (**Java Transaction API**) denotes that
    transactions will be managed by a Java EE transaction manager provided by the
    GlassFish server in our application. We will explore the `RESOURCE_LOCAL` alternative
    to JTA when we build our test cases in [Chapter 5](ch05.html "Chapter 5. Testing
    the DAO Layer with Spring and JUnit"), *Testing the DAO Layer with Spring and
    JUnit*. In this situation, the transactions will be managed locally without a
    Java EE container.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的最终配置项是`transaction-type`属性。此项支持两种不同类型的事务，我们默认设置为`JTA`。**JTA**（**Java事务API**）表示事务将由GlassFish服务器提供的Java
    EE事务管理器管理。我们将在[第5章](ch05.html "第5章。使用Spring和JUnit测试DAO层")中构建测试用例时探索`RESOURCE_LOCAL`替代JTA。在这种情况下，事务将在没有Java
    EE容器的情况下在本地管理。
- en: Refactoring the Java classes
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构Java类
- en: The classes generated by the reverse engineering process can be improved upon
    with a little refactoring to make the code more readable and easier to understand.
    Some of the autogenerated properties and fields have `id` in their name when we
    are actually referring to classes, while the collection of `java.util.List` objects
    have `list` in their name. Let's start with the `Company.java` file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些重构，可以改进反向工程过程生成的类，使代码更易读和理解。当我们实际上是在引用类时，一些自动生成的属性和字段的名称中都有`id`，而`java.util.List`对象的集合中都有`list`。让我们从`Company.java`文件开始。
- en: The Company.java file
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Company.java文件
- en: This file represents the `Company` entity. Double-click on the file to open
    it in the editor and browse through the contents. This class is a simple POJO
    with set and get methods for each property in addition to the standard `hashCode`,
    `equals`, and `toString` methods. The class has a no-arg constructor (required
    by the JPA specification as domain objects must be created dynamically without
    any properties), a second constructor that takes only the primary key, and a full
    (all arguments) constructor. We will make the code more readable by making a few
    minor changes to the `Company.java` file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件代表`Company`实体。双击文件以在编辑器中打开并浏览内容。这个类是一个简单的POJO，除了标准的`hashCode`，`equals`和`toString`方法外，还有每个属性的set和get方法。该类有一个无参构造函数（JPA规范要求域对象必须动态创建，没有任何属性），一个仅接受主键的第二个构造函数和一个完整（所有参数）的构造函数。我们将通过对`Company.java`文件进行一些小的更改来使代码更易读。
- en: 'The first change is to rename the field `projectList` to `projects` everywhere
    in the file. This can be easily achieved by selecting the `projectList` field,
    and then selecting **Refactor** | **Rename** from the menu:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改是将文件中的`projectList`字段到处重命名为`projects`。这可以通过选择`projectList`字段，然后从菜单中选择**重构**
    | **重命名**来轻松实现：
- en: '![The Company.java file](img/5457OS_03_11.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Company.java文件](img/5457OS_03_11.jpg)'
- en: You can now change the field name to **projects**. Make sure that you also select
    the **Rename Getters and Setters** option before clicking on the **Refactor**
    button.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将字段名称更改为**projects**。在单击**Refactor**按钮之前，确保还选择**Rename Getters and Setters**选项。
- en: '![The Company.java file](img/5457OS_03_12.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Company.java文件](img/5457OS_03_12.jpg)'
- en: Making these changes will change the field name and generate new get and set
    methods for the `projects` field.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些更改将更改字段名称并为`projects`字段生成新的获取和设置方法。
- en: 'The final change for the `Company.java` file is renaming the `mappedBy` property
    from `idCompany` to `company`. The appropriate lines should now look like the
    following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Company.java`文件的最终更改是将`mappedBy`属性从`idCompany`重命名为`company`。适当的行现在应该如下所示的代码：'
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The final refactored `Company.java` file should now look like the following
    code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最终重构的`Company.java`文件现在应该如下所示的代码片段：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: JPA uses the convention-over-configuration concept to simplify the configuration
    of entities. This is achieved by using annotations with sensible defaults to keep
    the entity definitions lean. Now, let's look at the key JPA annotations in this
    file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JPA使用约定优于配置的概念来简化实体的配置。这是通过使用具有合理默认值的注释来实现的，以保持实体定义的简洁。现在，让我们看看此文件中的关键JPA注释。
- en: The @Entity annotation
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Entity注释'
- en: This is a marker annotation that indicates to the JPA persistence provider that
    the `Company` class is an entity. JPA scans for the `@Entity` annotations when
    `exclude-unlisted-classes` is set to `false` in the `persistence.xml` file. Without
    the `@Entity` annotation, the persistence engine will ignore the class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标记注释，指示JPA持久性提供者`Company`类是一个实体。当`persistence.xml`文件中的`exclude-unlisted-classes`设置为`false`时，JPA会扫描`@Entity`注释。没有`@Entity`注释，持久性引擎将忽略该类。
- en: The @Table annotation
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Table注释'
- en: The `@Table` annotation defines the underlying database table that is represented
    by this entity class. The `@Table(name = "ttt_company")` line tells the persistence
    provider that the `Company` class represents the `ttt_company` table. Only one
    table annotation can be defined in any entity class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '@Table注释定义了由此实体类表示的底层数据库表。`@Table(name = "ttt_company")`行告诉持久性提供者`Company`类表示`ttt_company`表。任何实体类中只能定义一个表注释。'
- en: The @Id annotation
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Id注释'
- en: The `@Id` annotation defines the primary key field in the class and is required
    for each entity. The persistence provider will throw an exception if the `@Id`
    annotation is not present. The `Company` class property representing the primary
    key in the `ttt_company` table is the `Integer idCompany` field. There are three
    additional annotations attached to this field, of which the following annotation
    is specific to primary keys.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '@Id注释定义了类中的主键字段，并且对于每个实体都是必需的。如果不存在@Id注释，持久性提供者将抛出异常。表示`ttt_company`表中主键的`Company`类属性是`Integer
    idCompany`字段。此字段附加了三个附加注释，其中以下注释特定于主键。'
- en: The @GeneratedValue annotation
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@GeneratedValue注释'
- en: 'This annotation identifies how the persistence engine should generate new primary
    key values for the insertion of records into the table. The `strategy=GenerationType.IDENTITY`
    line will use the MySQL autoincrement strategy in the background to insert records
    into the `ttt_company` table. Different databases may require different strategies.
    For example, an Oracle database table could use a sequence as the basis for primary
    key generation by defining the following generator annotations:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释标识持久性引擎应如何为将记录插入表中生成新的主键值。`strategy=GenerationType.IDENTITY`行将在后台使用MySQL自动增量策略将记录插入`ttt_company`表。不同的数据库可能需要不同的策略。例如，Oracle数据库表可以通过定义以下生成器注释以使用序列作为主键生成的基础：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The primary key generation is independent of the class itself. The persistence
    engine will handle the generation of the primary key for you as defined by the
    generation strategy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 主键生成与类本身无关。持久性引擎将根据生成策略处理主键的生成。
- en: The @Basic annotation
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Basic注释'
- en: This is an optional annotation that is used to identify the nullability of the
    field. The `@Basic(optional = false)` line is used to specify that the field is
    not optional (may not be null). Likewise, the `@Basic(optional = true)` line could
    be used for other fields that may be nullable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可选的注释，用于标识字段的可空性。`@Basic(optional = false)`行用于指定字段不是可选的（不可为null）。同样，`@Basic(optional
    = true)`行可用于其他可能可为空的字段。
- en: The @Column annotation
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Column注释'
- en: This annotation specifies the column to which the field is mapped. The `@Column(name
    = "id_company")` line will, hence, map the `id_company` column in the `ttt_company`
    table to the `idCompany` field in the class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释指定字段映射到的列。因此，`@Column(name = "id_company")`行将`ttt_company`表中的`id_company`列映射到类中的`idCompany`字段。
- en: The @NotNull and @Size annotations
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@NotNull和@Size注释'
- en: These annotations are part of the `javax.validation.constraints` package (the
    Bean Validation package was introduced in Java EE 6) and define that the field
    cannot be null as well as the minimum and maximum sizes for the field. The `company_name`
    column in the `ttt_company` table was defined as `varchar(200) not null`, which
    is the reason why these annotations were created during the reverse engineering
    process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注释是`javax.validation.constraints`包的一部分（Bean Validation包是在Java EE 6中引入的），定义了字段不能为空以及字段的最小和最大大小。`ttt_company`表中的`company_name`列被定义为`varchar(200)
    not null`，这就是在反向工程过程中创建这些注释的原因。
- en: The @OneToMany annotation
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@OneToMany注释'
- en: A `Company` class may have zero or more `Projects` entities. This relationship
    is defined by the `@OneToMany` annotation. In words, we can describe this relationship
    as *One Company can have Many Projects*. In JPA, an entity is associated with
    a collection of other entities by defining this annotation with a `mappedBy` property.
    We have refactored the original `mappedBy` value to `company`. This will be the
    name of the field in the `Project.java` file after we have refactored the `Project`
    file in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Company`类可能有零个或多个`Projects`实体。这种关系由`@OneToMany`注解定义。简而言之，我们可以描述这种关系为*一个公司可以有多个项目*。在JPA中，通过在此注解中定义`mappedBy`属性，实体与其他实体的集合相关联。我们已经将原始的`mappedBy`值重构为`company`。这将是在我们在下一节中重构`Project`文件后，在`Project.java`文件中的字段的名称。'
- en: The @NamedQueries annotation
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@NamedQueries注解'
- en: The `@NamedQueries` annotations deserve an explanation in their own right. We
    will look at these in detail later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NamedQueries`注解值得单独解释。我们稍后会详细讨论这些。'
- en: The Projects.java file
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Projects.java文件
- en: 'As you may have guessed by now, this file represents the `Project` entity and
    maps to the `ttt_project` table. Double-click on the file to open it in the editor
    and browse the contents. We will once again do a bit of refactoring to clarify
    the autogenerated fields:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经猜到，这个文件代表`Project`实体，并映射到`ttt_project`表。双击文件以在编辑器中打开并浏览内容。我们将再次进行一些重构，以澄清自动生成的字段：
- en: Rename the autogenerated `idCompany` field to `company` using the refactoring
    process. Don't forget to rename the get and set methods.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重构过程将自动生成的`idCompany`字段重命名为`company`。不要忘记重命名get和set方法。
- en: Rename the autogenerated `taskList` field to `tasks`. Don't forget the get and
    set methods again!
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自动生成的`taskList`字段重命名为`tasks`。不要忘记再次编写get和set方法！
- en: Rename the `mappedBy` value from `idProject` to `project`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`mappedBy`值从`idProject`重命名为`project`。
- en: 'The final refactored file should now look like the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最终重构后的文件现在应该如下代码所示：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The @ManyToOne annotation
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@ManyToOne注解'
- en: 'This annotation represents a relationship between entities; it is the reverse
    of the `@OneToMany` annotation. For the `Project` entity, we can say that *Many
    Projects have One Company*. In other words, a `Project` entity belongs to a single
    `Company` class, and (inversely) a `Company` class can have any number of `Projects`
    entities. This relationship is defined at the database level (that is, the foreign
    key relationship in the underlying tables) and is achieved in the `@JoinColumn`
    annotation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解表示实体之间的关系；它是`@OneToMany`注解的反向。对于`Project`实体，我们可以说*多个项目对应一个公司*。换句话说，一个`Project`实体属于一个单一的`Company`类，而（反过来）一个`Company`类可以有任意数量的`Projects`实体。这种关系在数据库级别（即底层表中的外键关系）中定义，并在`@JoinColumn`注解中实现：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `name` property defines the name of the column in the `ttt_project` table
    that is the foreign key to the `referencedColumnName` column in the `ttt_company`
    table.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性定义了`ttt_project`表中的列名，该列是指向`ttt_company`表中的`referencedColumnName`列的外键。'
- en: Bidirectional mapping and owning entities
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向映射和拥有实体
- en: 'It is essential to grasp the very important concept of how one entity is related
    to another through the `@ManyToOne` and `@OneToMany` annotations. The `Company`
    class has a list of mapped `Projects` entities defined as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@ManyToOne`和`@OneToMany`注解，理解一个实体如何通过这两个注解与另一个实体相关联是非常重要的。`Company`类有一个映射的`Projects`实体列表，定义如下：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Whereas, the `Project` class has exactly one mapped `Company` entity:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 而`Project`类恰好有一个映射的`Company`实体：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is known as bidirectional mapping, one mapping on each class for each
    direction. A many-to-one mapping back to the source, as in the `Project` entity
    back to the `Company` entity, implies a corresponding one-to-many mapping on the
    source (`Company`) back to the target (`Project`). The terms **source** and **target**
    can be defined as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为双向映射，每个方向上每个类都有一个映射。一个多对一的映射回到源，就像`Project`实体回到`Company`实体一样，意味着源（`Company`）到目标（`Project`）有一个对应的一对多映射。术语**源**和**目标**可以定义如下：
- en: '**Source**: This is an entity that can exist in a relationship in its own right.
    The source entity does not require the target entity to exist and the `@OneToMany`
    collection can be empty. In our example, a `Company` entity can exist without
    a `Project` entity.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**：这是一个可以独立存在于关系中的实体。源实体不需要目标实体存在，`@OneToMany`集合可以为空。在我们的例子中，`Company`实体可以存在而不需要`Project`实体。'
- en: '**Target**: This is an entity that cannot exist on its own without a reference
    to a valid source. The `@ManyToOne` entity defined on the target cannot be null.
    A `Project` entity cannot exist in our design without a valid `Company` entity.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：这是一个没有参考有效源就无法独立存在的实体。目标上定义的`@ManyToOne`实体不能为空。在我们的设计中，`Project`实体不能存在而没有有效的`Company`实体。'
- en: 'The **owning entity** is an entity that understands the other entity from a
    database perspective. In simple terms, the owning entity has the `@JoinColumn`
    definition describing the underlying columns that form the relationship. In the
    `Company`-`Project` relationship, `Project` is the owning entity. Note that an
    entity can be both a target as well as a source as shown in the following `Project.java`
    file snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**拥有实体**是一个从数据库角度理解另一个实体的实体。简单来说，拥有实体具有`@JoinColumn`定义，描述形成关系的基础列。在`Company`-`Project`关系中，`Project`是拥有实体。请注意，一个实体可以同时是目标和源，如下面的`Project.java`文件片段所示：'
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `Project` is the source for the `Task` entity relationship and we would
    expect a reverse `@ManyToOne` annotation on the `Task` class. This is exactly
    what we will find.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Project`是`Task`实体关系的源，我们期望在`Task`类上找到一个反向的`@ManyToOne`注解。这正是我们将找到的。
- en: The Task.java file
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Task.java文件
- en: 'This file defines the `Task` entity that represents the `ttt_task` table. Open
    the file and perform the following refactoring:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件定义了代表`ttt_task`表的`Task`实体。打开文件并执行以下重构：
- en: Delete the autogenerated `taskLogList` field and also delete the associated
    get and set methods. Why do we do this? There may be many millions of task logs
    in the system for each `Task` instance and it is not advisable to hold a reference
    to such a large set of `TaskLog` instances within the `Task` object.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除自动生成的`taskLogList`字段，同时也删除相关的get和set方法。为什么要这样做？系统中可能有数百万条任务日志与每个`Task`实例相关联，不建议在`Task`对象内保存对这么大一组`TaskLog`实例的引用。
- en: Rename the autogenerated `idProject` field to `project`. Don't forget to delete
    the get and set methods again.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自动生成的`idProject`字段重命名为`project`。不要忘记再次删除get和set方法。
- en: 'After making the preceding changes, you will see that some of the imports are
    no longer required and are highlighted by the NetBeans IDE:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了上述更改之后，您会发现一些导入不再需要，并且在NetBeans IDE中被标记出来：
- en: '![The Task.java file](img/5457OS_03_13.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Task.java文件](img/5457OS_03_13.jpg)'
- en: 'The keyboard combination of *Ctrl* + *Shift* + *I* will remove all the unused
    imports. Another alternative is to click on the icon, shown in the following screenshot,
    to open the menu and select a **Remove** option:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *Shift* + *I*的组合键将删除所有未使用的导入。另一种选择是单击下图中显示的图标，打开菜单并选择**删除**选项：'
- en: '![The Task.java file](img/5457OS_03_14.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Task.java文件](img/5457OS_03_14.jpg)'
- en: It is good practice to have clean code and removing the unused imports is a
    simple process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 清理代码并删除未使用的导入是一个简单的过程，这是一个良好的实践。
- en: 'The final refactored file should now look like the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最终重构后的文件现在应该看起来像以下代码片段：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the `@ManyToOne` annotation referencing the `Project` class using the `@JoinColumn`
    definition. The `Task` object owns this relationship.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`@ManyToOne`注释引用`Project`类，使用`@JoinColumn`定义。`Task`对象拥有这个关系。
- en: The User.java file
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: User.java文件
- en: 'The `User` entity represents the underlying `ttt_user` table. The generated
    class has a `@OneToMany` definition for the relationship to the `TaskLog` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`实体代表了底层的`ttt_user`表。生成的类对与`TaskLog`类的关系有一个`@OneToMany`定义：'
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Refactoring in this file will once again **delete** this relationship completely.
    As noted in the `Tasks.java` section, a `User` entity may also have many thousands
    of task logs. By understanding the application's requirements and data structure,
    it is often far cleaner to remove unnecessary relationships completely.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中进行重构将再次**完全删除**这个关系。如`Tasks.java`部分所述，一个`User`实体也可能有成千上万的任务日志。通过了解应用程序的要求和数据结构，完全删除不必要的关系通常更加清晰。
- en: 'You will also note that the `@Pattern` annotation is commented out by default
    during the reverse engineering process. The `email` field name indicated to NetBeans
    that this might be an e-mail field and NetBeans added the annotation for use if
    required. We will uncomment this annotation to enable e-mail pattern checking
    for the field and add the required import:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到在反向工程过程中，默认情况下`@Pattern`注释被注释掉了。`email`字段名称告诉NetBeans这可能是一个电子邮件字段，如果需要，NetBeans会添加注释以供使用。我们将取消注释此注释以启用对该字段的电子邮件模式检查，并添加所需的导入：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The refactored `User.java` file will now look like the following code snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的`User.java`文件现在应该看起来像以下代码片段：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The TaskLog.java file
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TaskLog.java文件
- en: 'The final entity in our application represents the `ttt_task_log` table. The
    refactoring required here is to rename the `idTask` field to `task` (remember
    to also rename the get and set methods) and then rename the `username` field to
    `user`. The file should now look like the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的最终实体代表了`ttt_task_log`表。这里需要进行的重构是将`idTask`字段重命名为`task`（记得同时重命名get和set方法），然后将`username`字段重命名为`user`。文件现在应该看起来像以下代码片段：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Introducing the Java Persistence Query Language
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Java持久性查询语言
- en: 'Everyone reading this book should be familiar with SQL queries and how they
    work. Constructing a simple query against the `ttt_company` table to retrieve
    all records would look something like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本书的每个人都应该熟悉SQL查询及其工作原理。针对`ttt_company`表构建一个简单的查询以检索所有记录将如下所示：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Restricting the result set to companies starting with `G` would look like the
    following code line:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果集限制为以`G`开头的公司将如下代码行所示：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In JPA, we are dealing with entities and relationships between entities. The
    **Java Persistence Query Language** (**JPQL**) is used to formulate queries in
    a similar way to SQL. The previously mentioned statement will be written in JPQL
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在JPA中，我们处理实体和实体之间的关系。**Java持久性查询语言**（**JPQL**）用于以类似于SQL的方式制定查询。前面提到的语句将以JPQL形式写成如下：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And the statement that follows is written as such:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的语句将被写成如下形式：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the major differences between SQL and JPQL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SQL和JPQL之间的主要区别：
- en: 'JPQL class and field names are case sensitive. When we are dealing with classes,
    the class name must start with an uppercase letter. All the fields must have the
    exact case as defined in the class. The following statement will not compile as
    the company entity starts with a lowercase `c`:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPQL类和字段名称区分大小写。当我们处理类时，类名必须以大写字母开头。所有字段必须与类中定义的大小写完全一致。以下语句将无法编译，因为公司实体以小写`c`开头：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'JPQL keywords are case insensitive. The preceding statement could just as well
    have been written as follows:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPQL关键字不区分大小写。上述语句也可以写成如下形式：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: JPQL uses aliases to define instances and relationships between the instances.
    In the previous examples, the lowercase `c` is used as the alias in the `SELECT`
    and `WHERE` clauses.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPQL使用别名来定义实例和实例之间的关系。在前面的例子中，小写的`c`被用作`SELECT`和`WHERE`子句中的别名。
- en: JPQL queries may be static (defined in an annotation) or dynamic (built and
    executed at runtime). Static queries are compiled once and looked up whenever
    required. This makes static queries faster to use and more performant.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPQL查询可以是静态的（在注释中定义）或动态的（在运行时构建和执行）。静态查询只编译一次，并在需要时查找。这使得静态查询更快速和更高效。
- en: JPQL queries are translated into SQL; they are then executed against the underlying
    database. This translation allows for database-specific query optimization in
    the persistence engine.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPQL查询被翻译成SQL；然后针对底层数据库执行。这种翻译允许在持久性引擎中进行特定于数据库的查询优化。
- en: JPQL has a rich set of functions to define conditional expressions. These expressions
    are translated into the correct SQL for the underlying database. This means that
    developers no longer need to write database-specific SQL statements. Switching
    between databases will not require any coding as the JPQL statements abstract
    the underlying SQL required to execute the statement.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPQL有一套丰富的函数来定义条件表达式。这些表达式被翻译成底层数据库的正确SQL。这意味着开发人员不再需要编写特定于数据库的SQL语句。在不同数据库之间切换不需要任何编码，因为JPQL语句抽象了执行语句所需的底层SQL。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We strongly recommend you spend time learning about JPQL. There are many excellent
    books available that are dedicated to JPA and JPQL; they explain advanced usage.
    There are also many online tutorials and JPQL examples on the Internet. It is
    beyond the scope of this book to go beyond the basics, and we leave it to you
    to delve into this rich language further.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您花时间学习JPQL。有许多专门介绍JPA和JPQL的优秀书籍可供阅读，它们解释了高级用法。互联网上也有许多在线教程和JPQL示例。本书的范围超出了基础知识，我们将其留给您进一步深入学习这种丰富语言。
- en: Defining named queries
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义命名查询
- en: 'The reverse engineering process generated a set of `@NamedQuery` annotations
    in each class, one for each persistent field. The `Company` class, for example,
    had the following named queries defined:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 反向工程过程在每个类中生成了一组`@NamedQuery`注解，每个持久字段都有一个。例如，`Company`类定义了以下命名查询：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each `@NamedQuery` name must be unique within the persistence engine; hence,
    it is prefixed with the name of the class. The first query name, `Company.findAll`,
    represents the full list of the `Company` objects. The second query uses a named
    parameter, `idCompany`, as a placeholder for a value provided at runtime. Named
    parameters are always prefixed with the colon symbol. You should spend some time
    browsing the queries generated in the Java classes to become familiar with the
    basic JPQL syntax. We will learn more about named queries and how they are used
    in the following chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`@NamedQuery`名称在持久性引擎内必须是唯一的；因此，它以类的名称为前缀。第一个查询名称`Company.findAll`表示`Company`对象的完整列表。第二个查询使用命名参数`idCompany`作为运行时提供的值的占位符。命名参数总是以冒号符号为前缀。您应该花一些时间浏览Java类中生成的查询，以熟悉基本的JPQL语法。我们将在接下来的章节中学习更多关于命名查询以及它们的用法。
- en: Refactoring Java equals() and hashCode()
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构Java equals()和hashCode()
- en: 'Our domain layer entity classes have autogenerated `equals` and `hashCode`
    methods defined. The `Company` class, for example, defines these methods as shown:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域层实体类已定义了自动生成的`equals`和`hashCode`方法。例如，`Company`类定义了如下方法：
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_15.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![重构Java equals()和hashCode()](img/5457OS_03_15.jpg)'
- en: 'It is best practice to always provide correctly implemented `equals` and `hashCode`
    methods that use the entity ID to calculate the value that is returned. These
    methods are used by JPA to determine the equality between entities. Our autogenerated
    `equals` method will work correctly with JPA as the ID entity is used in the comparison
    for each method. However, the `//TODO: Warning` message on line 83 (see the previous
    screenshot) indicates an issue that can be avoided if we regenerate the `equals`
    method with the NetBeans IDE.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '最佳实践是始终提供正确实现的`equals`和`hashCode`方法，这些方法使用实体ID来计算返回的值。这些方法由JPA用于确定实体之间的相等性。我们的自动生成的`equals`方法将与JPA一起正常工作，因为ID实体在每个方法的比较中都被使用。然而，83行上的`//TODO:
    Warning`消息（参见上一个屏幕截图）指示了一个问题，如果我们使用NetBeans IDE重新生成`equals`方法，就可以避免这个问题。'
- en: 'Delete the `equals` method and right-click on the `Company.java` file in the
    editor using the mouse to display the context menu. Select the **Insert Code…**
    option:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`equals`方法，并使用鼠标右键单击编辑器中的`Company.java`文件，显示上下文菜单。选择**Insert Code…**选项：
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_16.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![重构Java equals()和hashCode()](img/5457OS_03_16.jpg)'
- en: 'From the pop-up menu, select the **equals()…** option and ensure that the **idCompany
    : Integer** field is selected in the **Generate equals()** pop up:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '从弹出菜单中，选择**equals()…**选项，并确保在**Generate equals()**弹出窗口中选择了**idCompany : Integer**字段：'
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_17.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![重构Java equals()和hashCode()](img/5457OS_03_17.jpg)'
- en: 'Click on **Generate** to create the new `equals` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**Generate**以创建新的`equals`方法：
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_19.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![重构Java equals()和hashCode()](img/5457OS_03_19.jpg)'
- en: 'Click on the information icon (circled) over line 92 to display the context
    information:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 单击信息图标（圈出的）在第92行上显示上下文信息：
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_20.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![重构Java equals()和hashCode()](img/5457OS_03_20.jpg)'
- en: 'Click on **The if statement is redundant** to clean your code further and replace
    the `if` statement with the following line:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**if语句是多余的**以进一步清理您的代码，并用以下行替换`if`语句：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Objects` class was introduced in Java 1.7 and consists of static utility
    methods for operating on objects. The `Objects.equals` method takes into account
    `null` values and solves the potential `//TODO: Warning` issue with the autogenerated
    `equals` method. From the Java 1.7 JavaDoc for the `Objects.equals` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Objects`类是在Java 1.7中引入的，它包含用于操作对象的静态实用方法。`Objects.equals`方法考虑了`null`值，并解决了自动生成的`equals`方法可能出现的`//TODO:
    Warning`问题。来自Java 1.7 JavaDoc的`Objects.equals`方法：'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns `true` if the arguments are equal to each other and `false` otherwise.
    Consequently, if both the arguments are null, `true` is returned, and if exactly
    one argument is null, `false` is returned. Otherwise, the equality is determined
    using the `equals` method of the first argument.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数彼此相等，则返回`true`，否则返回`false`。因此，如果两个参数都为null，则返回`true`，如果恰好一个参数为null，则返回`false`。否则，使用第一个参数的`equals`方法来确定相等性。
- en: You can now replace the autogenerated `equals` method of the `Project`, `Task`,
    `User`, and `TaskLog` entity classes in a similar way.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以以类似的方式替换`Project`，`Task`，`User`和`TaskLog`实体类的自动生成的`equals`方法。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we have reverse engineered the 3T database into a set of Java
    classes. Each Java class represents a JPA entity with annotations defining the
    relationship between entities as well as the mapping of database columns to Java
    fields. We have had a brief introduction to JPQL through named query definitions
    and introduced key JPA annotations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将3T数据库反向工程为一组Java类。每个Java类代表一个带有注释的JPA实体，定义了实体之间的关系以及数据库列与Java字段的映射。我们通过命名查询定义简要介绍了JPQL，并介绍了关键的JPA注释。
- en: Although this chapter has introduced many key concepts, the scope of JPA and
    JPQL leaves much for you to learn. JPA is a key tool in enterprise application
    development, allowing for easy enhancements and database-agnostic programming.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章介绍了许多关键概念，但JPA和JPQL的范围还有很多需要学习的地方。JPA是企业应用程序开发中的关键工具，可以轻松进行增强和与数据库无关的编程。
- en: The next chapter will introduce the **Data Access Object** (**DAO**) design
    pattern and implement a robust data access layer using the domain classes we have
    just defined. Our JPA journey has just started!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍**数据访问对象**（**DAO**）设计模式，并使用我们刚刚定义的领域类实现一个强大的数据访问层。我们的JPA之旅刚刚开始！
