- en: Creating JEE Applications with EJB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EJB 创建 JEE 应用程序
- en: In the last chapter, we learned some techniques to debug JEE applications from
    Eclipse. In this chapter, we will shift our focus back to JEE application development
    and learn how to create and use **Enterprise JavaBeans** (**EJB**). If you recall
    the architecture of database applications in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications,* we had JSP or a JSF page calling a JSP bean
    or a managed bean. The beans then called DAOs to execute the data access code.
    This separated code for the user interface, the business logic, and the database
    nicely. This would work for small or medium applications, but may prove to be
    a bottleneck in large enterprise applications; the application may not scale very
    well. If processing of the business logic is time consuming then it would make
    more sense to distribute it on different servers for better scalability and resilience.
    If code for the user interface, the business logic, and the data access is all
    on the same machine, then it may affect scalability of the application; that is,
    it may not perform well under the load.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了从 Eclipse 调试 JEE 应用程序的一些技术。在本章中，我们将将我们的重点重新转向 JEE 应用程序开发，并学习如何创建和使用
    **企业 JavaBeans**（**EJB**）。如果你还记得 [第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“创建
    JEE 数据库应用程序”中的数据库应用程序架构，我们使用了 JSP 或 JSF 页面调用 JSP Bean 或托管 Bean。然后，Bean 调用 DAO
    执行数据访问代码。这样，用户界面、业务逻辑和数据库的代码就很好地分离了。这对于小型或中型应用程序来说可能适用，但在大型企业应用程序中可能会成为瓶颈；应用程序可能扩展性不好。如果业务逻辑的处理耗时较长，那么将其分布在不同服务器上以获得更好的可扩展性和弹性会更有意义。如果用户界面、业务逻辑和数据访问的代码都在同一台机器上，那么它可能会影响应用程序的可扩展性；也就是说，在负载下可能表现不佳。
- en: Using EJB for implementing the business logic is ideal in scenarios where you
    want components processing the business logic to be distributed across different
    servers. However, this is just one of the advantages of EJB. Even if you use EJBs
    on the same server as the web application, you may gain from a number of services
    that the EJB container provides; you can specify the security constraints for
    calling EJB methods declaratively (using annotations) and can easily specify transaction
    boundaries (specify a set of method calls from a part of one transaction) using
    annotations. Furthermore, the container handles the life cycle of EJBs, including
    pooling of certain types of EJB objects so that more objects can be created when
    load on the application increases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要将处理业务逻辑的组件分布在不同服务器上的场景中，使用 EJB 实现业务逻辑是理想的。然而，这只是 EJB 的优势之一。即使你在与 Web 应用程序相同的服务器上使用
    EJB，你也可以从 EJB 容器提供的众多服务中获益；你可以声明性地（使用注解）指定调用 EJB 方法的安全约束，并可以使用注解轻松指定事务边界（指定一个事务的一部分的方法调用集合）。此外，容器处理
    EJB 的生命周期，包括某些类型 EJB 对象的池化，以便在应用程序负载增加时可以创建更多对象。
- en: In [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, we created a *Course Management* web application using
    simple JavaBeans. In this chapter, we will create the same application using EJBs
    and deploy it on the GlassFish Server. However, before that we need to understand
    some basic concepts of EJBs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“创建 JEE 数据库应用程序”，我们使用简单的
    JavaBeans 创建了一个 *课程管理* 网络应用程序。在本章中，我们将使用 EJB 创建相同的应用程序并将其部署到 GlassFish 服务器上。然而，在此之前，我们需要了解一些
    EJB 的基本概念。
- en: 'We will cover the following broad topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下广泛的主题：
- en: Understanding different types of EJBs and how they can be accessed from different
    client deployment scenarios
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同类型的 EJB 以及它们如何从不同的客户端部署场景中访问
- en: Configuring GlassFish Server for testing EJB applications in Eclipse
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Eclipse 中配置 GlassFish 服务器以测试 EJB 应用程序
- en: Creating and testing EJB projects from Eclipse with and without Maven
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和未使用 Maven 从 Eclipse 创建和测试 EJB 项目
- en: Types of EJB
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB 类型
- en: 'EJB can be of the following types according to the EJB3 specification:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 EJB3 规范，EJB 可以有以下类型：
- en: 'Session bean:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话 Bean：
- en: Stateful session bean
  id: totrans-11
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态会话 Bean
- en: Stateless session bean
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态会话 Bean
- en: Singleton session bean
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例会话 Bean
- en: Message-driven bean
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息驱动 Bean
- en: We will discuss **message-driven bean** (**MDB**) in detail in a [Chapter 10](part0208.html#66BL00-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Asynchronous Programming with JMS*, when we learn about asynchronous processing
    of requests in the JEE application. In this chapter, we will focus on session
    beans.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习到JEE应用程序中的异步请求处理时，我们将在第10章[Chapter 10](part0208.html#66BL00-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“使用JMS的异步编程”，将详细讨论**消息驱动Bean**（**MDB**）。在这一章中，我们将专注于会话Bean。
- en: Session beans
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话Bean
- en: In general, session beans are meant to contain methods to execute the main business
    logic of the enterprise application. Any **Plain Old Java Object** (**POJO**) can
    be annotated with the appropriate EJB3-specific annotations to make it a session
    bean. Session beans come in three types.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，会话Bean旨在包含执行企业应用程序主要业务逻辑的方法。任何**普通Java对象**（**POJO**）都可以通过适当的EJB3特定注解来注解，使其成为一个会话Bean。会话Bean有三种类型。
- en: Stateful session beans
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态会话Bean
- en: One stateful session bean serves requests for one client only. There is one-to-one
    mapping between the stateful session bean and the client. Therefore, stateful
    beans can hold the state data for the client between multiple method calls. In
    our *Course Management* application, we could use a stateful bean for holding
    student data (student profile and courses taken by her/him) after a student logs
    in. The state maintained by the stateful bean is lost when the server restarts
    or when the session times out. Since there is one stateful bean per client, using
    a stateful bean might impact scalability of the application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有状态会话Bean只为一个客户端提供服务。有状态会话Bean与客户端之间存在一对一的映射。因此，有状态Bean可以在多个方法调用之间保留客户端的状态数据。在我们的*课程管理*应用程序中，我们可以在学生登录后使用一个有状态Bean来保存学生数据（学生资料和她/他选择的课程）。当服务器重启或会话超时时，由有状态Bean维护的状态将丢失。由于每个客户端都有一个有状态Bean，使用有状态Bean可能会影响应用程序的可伸缩性。
- en: We use the `@Stateful` annotation on the class to mark it as a stateful session
    bean.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类上使用`@Stateful`注解来标记它为一个有状态会话Bean。
- en: Stateless session beans
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态会话Bean
- en: A stateless session bean does not hold any state information for the client.
    Therefore, one session bean can be shared across multiple clients. The EJB container
    maintains pools of stateless beans, and when a client request comes, it takes
    a bean out of the pool, executes methods, and returns the bean to the pool again.
    Stateless session beans provide excellent scalability because they can be shared
    and they need not be created for each client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态会话Bean不保留任何客户端的状态信息。因此，一个会话Bean可以被多个客户端共享。EJB容器维护着一组无状态Bean的池，当客户端请求到来时，它会从池中取出一个Bean，执行方法，然后将Bean返回池中。无状态会话Bean提供了卓越的可伸缩性，因为它们可以被共享，并且不需要为每个客户端创建。
- en: We use the `@Stateless` annotation on the class to mark it as a stateless session
    bean.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类上使用`@Stateless`注解来标记它为一个无状态会话Bean。
- en: Singleton session beans
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例会话Bean
- en: As the name suggests, there is only one instance of a singleton bean class in
    the EJB container (this is true in the clustered environment too; each EJB container
    will have one instance of a singleton bean). This means that they are shared by
    multiple clients, and they are not pooled by EJB containers (because there can
    be only one instance). Since a singleton session bean is a shared resource, we
    need to manage concurrency in it. Java EE provides two concurrency management
    options for singleton session beans, namely container-managed concurrency and
    bean-managed concurrency. Container-managed concurrency can be easily specified
    by annotations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，在EJB容器中只有一个单例Bean类的实例（这在集群环境中也是正确的；每个EJB容器将有一个单例Bean的实例）。这意味着它们被多个客户端共享，并且不会被EJB容器池化（因为只能有一个实例）。由于单例会话Bean是一个共享资源，我们需要在其中管理并发。Java
    EE为单例会话Bean提供了两种并发管理选项，即容器管理并发和Bean管理并发。容器管理并发可以通过注解轻松指定。
- en: See [https://javaee.github.io/tutorial/ejb-basicexamples003.html#GIPSZ](https://javaee.github.io/tutorial/ejb-basicexamples003.html#GIPSZ) for
    more information on managing concurrency in singleton session beans.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在单例会话Bean中管理并发的更多信息，请参阅[https://javaee.github.io/tutorial/ejb-basicexamples003.html#GIPSZ](https://javaee.github.io/tutorial/ejb-basicexamples003.html#GIPSZ)。
- en: The use of a singleton bean could have an impact on the scalability of the application
    if there are resource contentions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在资源竞争，单例Bean的使用可能会影响应用程序的可伸缩性。
- en: We use the `@Singleton` annotation on the class to mark it as a singleton session
    bean.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类上使用`@Singleton`注解来标记它为一个单例会话Bean。
- en: Accessing session beans from a client
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从客户端访问会话Bean
- en: Session beans can be designed to be accessed locally (client and bean in the
    same application), remotely (from a client running in a different application
    or JVM), or both. In the case of remote access, session beans are required to
    implement a remote interface. For local access, session beans can implement a
    local interface or implement no interface (no-interface view of a session bean).
    The remote and local interfaces that the session bean implements are sometimes
    also called **business interfaces** because they typically expose the primary
    business functionality.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 会话Bean可以被设计为本地访问（客户端和Bean在同一个应用程序中），远程访问（从运行在不同应用程序或JVM中的客户端），或两者兼而有之。在远程访问的情况下，会话Bean必须实现一个远程接口。对于本地访问，会话Bean可以实现一个本地接口或实现无接口（会话Bean的无接口视图）。会话Bean实现的远程和本地接口有时也被称为**业务接口**，因为它们通常暴露主要业务功能。
- en: Creating a no-interface session bean
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建无接口会话Bean
- en: 'To create a session bean with the no-interface view, create a POJO and annotate
    it with the appropriate EJB annotation type and `@LocalBean`. For example, we
    can create a local stateful `Student` bean as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建具有无接口视图的会话Bean，创建一个POJO，并使用适当的EJB注解类型和`@LocalBean`对其进行注解。例如，我们可以创建一个本地状态ful的`Student`
    Bean如下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Accessing session beans using dependency injection
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入访问会话Bean
- en: You can access session beans either using the `@EJB` annotation (which injects
    the bean in the client class) or by performing the **Java Naming and Directory
    Interface** (**JNDI**) lookup. EJB containers are required to make JNDI URLs of
    the EJBs available to clients.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`@EJB`注解（该注解将Bean注入客户端类）或通过执行**Java命名和目录接口**（**JNDI**）查找来访问会话Bean。EJB容器必须使EJB的JNDI
    URL对客户端可用。
- en: Injecting session beans using `@EJB` works only for managed components, that
    is, components of the application whose life cycle is managed by the EJB container.
    When a component is managed by the container, it is created (instantiated) and
    destroyed by the container. You do not create managed components using the `new`
    operator. JEE-managed components that support direct injection of EJBs are servlets,
    managed beans of JSF pages, and EJBs themselves (one EJB can have another EJB
    injected into it). Unfortunately, you cannot have a web container inject EJBs
    in JSPs or JSP beans. Furthermore, you cannot have EJBs injected into any custom
    classes that you create and that are instantiated using the `new` operator. Later
    in the chapter, we will see how to use JNDI to access EJBs from objects that are
    not managed by the container.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@EJB`注入仅适用于受管理组件，即由EJB容器管理生命周期的应用程序组件。当组件由容器管理时，它由容器创建（实例化）和销毁。您不使用`new`运算符创建受管理组件。支持直接注入EJB的JEE受管理组件包括servlet、JSF页面的受管理Bean以及EJB本身（一个EJB可以注入另一个EJB）。不幸的是，您不能让Web容器在JSP或JSP
    Bean中注入EJB。此外，您不能将EJB注入您创建并使用`new`运算符实例化的任何自定义类。在本章的后面部分，我们将看到如何使用JNDI从不受容器管理的对象访问EJB。
- en: 'We could use a student bean (created previously) from a managed bean of a JSF
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从JSF的受管理Bean中使用之前创建的学生Bean如下：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that if you create an EJB with no-interface view, then all `public` methods
    in that EJB will be exposed to the client. If you want to control the methods
    that could be called by the client, then you should implement a business interface.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您创建了一个无接口视图的EJB，那么该EJB中的所有`public`方法都将暴露给客户端。如果您想控制客户端可以调用的方法，那么您应该实现一个业务接口。
- en: Creating session beans using local business interface
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地业务接口创建会话Bean
- en: 'Business interface for the EJB is a simple Java interface annotated either
    with `@Remote` or `@Local`. Therefore, we can create a local interface for a student
    bean as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: EJB的业务接口是一个简单的Java接口，用`@Remote`或`@Local`进行注解。因此，我们可以创建一个学生Bean的本地接口如下：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Furthermore, we can implement a session bean as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以如下实现会话Bean：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The client can access the `Student` EJB only through the local interface:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端只能通过本地接口访问`Student` EJB：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A session bean can implement multiple business interfaces.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 会话Bean可以实现多个业务接口。
- en: Accessing session beans using JNDI lookup
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JNDI查找访问会话Bean
- en: Although accessing EJB using dependency injection is the easiest way, it works
    only if the container manages the class that accesses the EJB. If you want to
    access EJB from a POJO that is not a managed bean, then dependency injection will
    not work. Another scenario where dependency injection does not work is when EJB
    is deployed in a separate JVM (could be on a remote server). In such cases, you
    will have to access the EJB using JNDI lookup (visit [https://docs.oracle.com/javase/tutorial/jndi/](https://docs.oracle.com/javase/tutorial/jndi/)
    for more information on JNDI).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用依赖注入访问EJB是最简单的方法，但它仅当容器管理访问EJB的类时才有效。如果你想从一个不是管理bean的POJO中访问EJB，则依赖注入将不起作用。依赖注入不起作用的另一个场景是当EJB部署在单独的JVM（可能是在远程服务器上）时。在这种情况下，你必须使用JNDI查找来访问EJB（有关JNDI的更多信息，请访问[https://docs.oracle.com/javase/tutorial/jndi/](https://docs.oracle.com/javase/tutorial/jndi/)）。
- en: 'JEE applications could be packaged in **Enterprise Application aRchive** (**EAR**),
    which contains a `.jar` file for EJBs and a `.war` file for web applications (and
    a `lib` folder containing libraries required for both). If, for example, the name
    of the EAR file is `CourseManagement.ear` and the name of the EJB JAR in it is
    `CourseManagementEJBs.jar`, then the name of the application is `CourseManagement`
    (name of the EAR file) and the module name is `CourseManagementEJBs`. The EJB
    container uses these names to create JNDI URL for looking up EJBs. A global JNDI
    URL for EJB is created as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JEE应用程序可以打包成**企业应用程序存档**（**EAR**），其中包含EJB的`.jar`文件和Web应用程序的`.war`文件（以及包含两个都需要的库的`lib`文件夹）。例如，如果EAR文件的名称是`CourseManagement.ear`，其中EJB的`.jar`文件名称是`CourseManagementEJBs.jar`，则应用程序的名称是`CourseManagement`（EAR文件的名称），模块名称是`CourseManagementEJBs`。EJB容器使用这些名称来创建查找EJB的JNDI
    URL。EJB的全局JNDI URL创建如下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s have a look at the different parameters used in the preceding code snippets:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面代码片段中使用的不同参数：
- en: '`java:global`: This indicates that it is a global JNDI URL.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java:global`: 这表示它是一个全局JNDI URL。'
- en: '`<application_name>`: This is typically the name of the EAR file.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<application_name>`: 这通常是EAR文件的名称。'
- en: '`<module_name>`: This is the name of the EJB JAR.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<module_name>`: 这是EJB JAR的名称。'
- en: '`<bean_name>`: This is the name of the EJB bean class.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<bean_name>`: 这是EJB bean类的名称。'
- en: '`<bean_interface>`: This is optional if EJB has a no-interface view, or if
    EJB implements only one business interface. Otherwise it is a fully qualified
    name of the business interface.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<bean_interface>`: 如果EJB有一个无接口视图，或者如果EJB只实现了一个业务接口，则此属性是可选的。否则，它是业务接口的完全限定名称。'
- en: 'EJB containers are required to publish two more variations of JNDI URLs for
    each EJB. These are not global URLs, which means that they can''t be used to access
    EJBs from clients that are not in the same JEE application (in the same EAR):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: EJB容器必须为每个EJB发布两个JNDI URL的变体。这些不是全局URL，这意味着它们不能用于从不在同一JEE应用程序（同一EAR）中的客户端访问EJB：
- en: '`java:app/[<module_name>]/<bean_name>![<bean_interface>]`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java:app/[<module_name>]/<bean_name>![<bean_interface>]`'
- en: '`java:module/<bean_name>![<bean_interface>]`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java:module/<bean_name>![<bean_interface>]`'
- en: The first URL can be used if the EJB client is in the same application, and
    the second URL can be used if the client is in the same module (the same `.jar`
    file as the EJB).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果EJB客户端在同一应用程序中，则可以使用第一个URL；如果客户端在同一模块中（与EJB相同的`.jar`文件），则可以使用第二个URL。
- en: 'Before you look up any URL in a JNDI server, you need to create `InitialContext`,
    which includes, among other things, information such as the hostname of the JNDI
    server and the port on which it is running. If you create `InitialContext` in
    the same server, then there is no need to specify these attributes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在你查找JNDI服务器中的任何URL之前，你需要创建`InitialContext`，这包括其他信息，例如JNDI服务器的主机名和它运行的端口。如果你在同一服务器中创建`InitialContext`，那么不需要指定这些属性：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can use the following JNDI URLs to access a no-interface (`LocalBean`) `Student`
    EJB (assuming that the name of the EAR file is `CourseManagement` and the name
    of the `.jar` file for EJBs is `CourseManagementEJBs`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下JNDI URL来访问无接口（`LocalBean`）的`Student` EJB（假设EAR文件的名称是`CourseManagement`，EJB的`.jar`文件名称是`CourseManagementEJBs`）：
- en: '| **URL** | **When to use** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **何时使用** |'
- en: '| `java:global/CourseManagement/ CourseManagementEJBs/Student` | The client
    can be anywhere in the EAR file, because we use the global URL. Note that we haven''t
    specified the interface name because we are assuming that the student bean provides
    a no-interface view in this example. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `java:global/CourseManagement/ CourseManagementEJBs/Student` | 客户端可以位于 EAR
    文件中的任何位置，因为我们使用了全局 URL。请注意，我们没有指定接口名称，因为我们假设在这个示例中学生 Bean 提供了一个无接口视图。|'
- en: '| `java:app/CourseManagementEJBs/Student` | The client can be anywhere in the
    EAR. We skipped application name because the client is expected to be in the same
    application, because the namespace of the URL is `java:app`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `java:app/CourseManagementEJBs/Student` | 客户端可以位于 EAR 中的任何位置。我们跳过了应用程序名称，因为客户端预期位于同一应用程序中，因为
    URL 的命名空间是 `java:app`。|'
- en: '| `java:module/Student` | The client must be in the same `.jar` file as EJB.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `java:module/Student` | 客户端必须在与 EJB 相同的 `.jar` 文件中。|'
- en: 'We can use the following JNDI URLs for accessing `Student` EJB that implemented
    a local interface called `StudentLocal`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 JNDI URL 来访问实现了名为 `StudentLocal` 的本地接口的 `Student` EJB：
- en: '| **URL** | **When to use** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **何时使用** |'
- en: '| --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `java:global/CourseManagement/ CourseManagementEJBs/Student!packt.jee.book.ch6.StudentLocal`
    | The client can be anywhere in the EAR file, because we use a global URL. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `java:global/CourseManagement/ CourseManagementEJBs/Student!packt.jee.book.ch6.StudentLocal`
    | 客户端可以位于 EAR 文件中的任何位置，因为我们使用了全局 URL。|'
- en: '| `java:global/CourseManagement/ CourseManagementEJBs/Student` | The client
    can be anywhere in the EAR. We skipped the interface name because the bean implements
    only one business interface. Note that the object returned from this call will
    be of `StudentLocal` type, and not `Student` type. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `java:global/CourseManagement/ CourseManagementEJBs/Student` | 客户端可以位于 EAR
    中的任何位置。我们跳过了接口名称，因为 Bean 只实现了单个业务接口。请注意，从这个调用返回的对象将是 `StudentLocal` 类型，而不是 `Student`
    类型。|'
- en: '| `java:app/CourseManagementEJBs/Student`Or`java:app/CourseManagementEJBs/Student!packt.jee.book.ch6.StudentLocal`
    | The client can be anywhere in the EAR. We skipped the application name because
    the JNDI namespace is `java:app`. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `java:app/CourseManagementEJBs/Student` 或 `java:app/CourseManagementEJBs/Student!packt.jee.book.ch6.StudentLocal`
    | 客户端可以位于 EAR 中的任何位置。我们跳过了应用程序名称，因为 JNDI 命名空间是 `java:app`。|'
- en: '| `java:module/Student`Or`java:module/Student!packt.jee.book.ch6.StudentLocal`
    | The client must be in the same EAR as the EJB. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `java:module/Student` 或 `java:module/Student!packt.jee.book.ch6.StudentLocal`
    | 客户端必须在与 EJB 相同的 EAR 中。|'
- en: 'Here is an example of how we can call the student bean with a local business
    interface from one of the objects (that is not managed by the web container) in
    our web application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从我们的 Web 应用程序中的非 Web 容器管理的对象（之一）调用具有本地业务接口的学生 Bean 的示例：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating session beans using remote business interface
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程业务接口创建会话 Bean
- en: 'If the session bean that you create is going to be accessed by a client object
    that is not in the same JVM as the bean, then the bean needs to implement a remote
    business interface. You create a remote business interface by annotating the class
    with `@Remote`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建的会话 Bean 将由不在 Bean 所在 JVM 中的客户端对象访问，则该 Bean 需要实现远程业务接口。您可以通过在类上使用 `@Remote`
    注解来创建远程业务接口：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The EJB implementing the remote interface is also annotated with `@Remote`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实现远程接口的 EJB 也用 `@Remote` 注解：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Remote EJBs can be injected into managed objects in the same application using
    the `@EJB` annotation. For example, a JSF bean can access the previously mentioned
    student bean (in the same application) as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 远程 EJB 可以使用 `@EJB` 注解注入到同一应用程序中的管理对象中。例如，一个 JSF Bean 可以如下访问之前提到的学生 Bean（位于同一应用程序中）：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Accessing remote session beans
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问远程会话 Bean
- en: 'For accessing a remote `Student` EJB, we can use the following JNDI URLs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问远程 `Student` EJB，我们可以使用以下 JNDI URL：
- en: '| **URL** | **When to use** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **何时使用** |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `java:global/CourseManagement/ CourseManagementEJBs/Student!packt.jee.book.ch6.StudentRemote`
    | The client can be in the same application or remote. In the case of a remote
    client, we need to set up proper `InitialContext` parameters. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `java:global/CourseManagement/ CourseManagementEJBs/Student!packt.jee.book.ch6.StudentRemote`
    | 客户端可以在同一应用程序或远程位置。对于远程客户端，我们需要设置适当的 `InitialContext` 参数。|'
- en: '| `java:global/CourseManagement/CourseManagementEJBs/Student` | The client
    can be in the same application or remote. We skipped the interface name because
    the bean implements only one business interface. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `java:global/CourseManagement/CourseManagementEJBs/Student` | 客户端可以在同一应用程序或远程位置。我们跳过了接口名称，因为
    Bean 只实现了单个业务接口。|'
- en: '| `java:app/CourseManagementEJBs/Student`Or`java:app/CourseManagementEJBs/Student!packt.jee.book.ch6.StudentRemote`
    | The client can be anywhere in the EAR. We skipped the application name because
    the JNDI namespace is `java:app`. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `java:app/CourseManagementEJBs/Student`或`java:app/CourseManagementEJBs/Student!packt.jee.book.ch6.StudentRemote`
    | 客户端可以在EAR的任何位置。我们跳过了应用程序名称，因为JNDI命名空间是`java:app`。|'
- en: '| `java:module/Student`Or`java:module/Student!packt.jee.book.ch6.StudentRemote`
    | The client must be in the same EAR as the EJB. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `java:module/Student`或`java:module/Student!packt.jee.book.ch6.StudentRemote`
    | 客户端必须在与EJB相同的EAR中。|'
- en: 'To access EJBs from a remote client, you need to use the JNDI lookup method.
    Furthermore, you need to set up `InitialContext` with certain properties; some
    of them are JEE application server specific. If the remote EJB and the client
    are both deployed in GlassFish (different instances of GlassFish), then you can
    look up the remote EJB as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要从远程客户端访问EJB，您需要使用JNDI查找方法。此外，您需要设置具有某些属性的`InitialContext`；其中一些属性是JEE应用服务器特定的。如果远程EJB和客户端都部署在GlassFish中（不同的GlassFish实例），那么您可以按以下方式查找远程EJB：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Configuring the GlassFish Server in Eclipse
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Eclipse中配置GlassFish服务器
- en: We are going to use the GlassFish application server in this chapter. We have
    already seen how to install GlassFish in the *Installing GlassFish Server* section
    of [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用GlassFish应用服务器。我们已经在[第1章](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)的“安装GlassFish服务器”部分中看到了如何安装GlassFish。
- en: 'We will first configure the GlassFish Server in Eclipse JEE:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在Eclipse JEE中配置GlassFish服务器：
- en: 'To configure the GlassFish Server in Eclipse EE, make sure that you are in
    the Java EE perspective in Eclipse. Right-click on the Servers view and select
    New | Server. It you do not see the GlassFish Server group in the list of server
    types, then expand Oracle node and select and install GlassFish Tools:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Eclipse EE中配置GlassFish服务器，请确保您处于Eclipse的Java EE视图中。右键单击服务器视图并选择新建 | 服务器。如果您在服务器类型列表中看不到GlassFish服务器组，请展开Oracle节点并选择和安装GlassFish工具：
- en: '![](img/00153.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00153.jpeg)'
- en: 'Figure 7.1: Installing GlassFish Tools'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：安装GlassFish工具
- en: 'If you have already installed GlassFish Tools, or if GlassFish Server type
    is available in the list, then expand that and select the GlassFish option:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经安装了GlassFish工具，或者GlassFish服务器类型在列表中可用，那么展开它并选择GlassFish选项：
- en: '![](img/00154.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00154.jpeg)'
- en: 'Figure 7.2: Creating GlassFish Server instance in Eclipse'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：在Eclipse中创建GlassFish服务器实例
- en: 'Click Next. Enter the path of the GlassFish Server on your local machine in
    the Domain path field. Enter admin name and password, if applicable, and click Next:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步。在“域路径”字段中输入您本地机器上的GlassFish服务器路径。如果适用，输入管理员名称和密码，然后点击下一步：
- en: '![](img/00155.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00155.jpeg)'
- en: 'Figure 7.3: Defining GlassFish Server properties'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：定义GlassFish服务器属性
- en: The next page allows you to deploy the existing Java EE projects in GlassFish.
    We don't have any projects to add at this point, so just click Finish.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一页允许您在GlassFish中部署现有的Java EE项目。目前我们没有要添加的项目，所以只需点击完成。
- en: The server is added to the Servers view. Right-click on the server and select
    Start. If the server is installed and configured properly, then the server status
    should change to Started.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器已添加到服务器视图。右键单击服务器并选择启动。如果服务器已正确安装和配置，则服务器状态应更改为已启动。
- en: To open the admin page of the server, right-click on the server and select GlassFish
    | View Admin Console. The admin page is opened in the built-in Eclipse browser.
    You can browse to the server home page by opening the `http://localhost:8080 URL`.
    `8080` is the default GlassFish port.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开服务器的管理页面，右键单击服务器并选择GlassFish | 查看管理控制台。管理页面在内置的Eclipse浏览器中打开。您可以通过打开`http://localhost:8080`
    URL来浏览服务器主页。`8080`是GlassFish的默认端口。
- en: Creating a Course Management application using EJB
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EJB创建课程管理应用程序
- en: Let's now create the *Course Management* application that we created in [Chapter
    4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating JEE Database
    Applications,* this time using EJBs. In [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, we created service classes (which were POJOs)
    for writing the business logic. We will replace them with EJBs. We will start
    by creating Eclipse projects for EJBs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建我们在[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中创建的*课程管理*应用程序，这次使用EJB。在第4章中，我们创建了用于编写业务逻辑的服务类（它们是POJO）。我们将用EJB来替换它们。我们将首先创建EJB的Eclipse项目。
- en: Creating EJB projects in Eclipse
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Eclipse中创建EJB项目
- en: EJBs are packaged in a JAR file. Web applications are packaged in a **Web Application
    aRchive** (**WAR**). If EJBs are to be accessed remotely, then the client needs
    to have access to business interfaces. Therefore, EJB business interfaces and
    shared objects are packaged in a separate JAR, called EJB client JAR. Furthermore,
    if EJBs and web applications are to be deployed as one single application, then
    they need to be packaged in an EAR.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: EJB打包在一个JAR文件中。Web应用程序打包在一个**Web应用程序存档**（**WAR**）中。如果EJB需要远程访问，则客户端需要访问业务接口。因此，EJB业务接口和共享对象（在EJB和客户端之间共享）打包在一个单独的JAR中，称为EJB客户端JAR。此外，如果EJB和Web应用程序要作为一个单一应用程序部署，那么它们需要打包在一个EAR中。
- en: 'So, in most cases the application with EJBs is not a single project, but four
    different projects:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在大多数情况下，带有EJB的应用程序不是一个单一的项目，而是四个不同的项目：
- en: EJB project that creates EJB JAR
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建EJB JAR的EJB项目
- en: EJB client project that contains business classes and shared (between EJB and
    client) classes
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含业务类和共享（在EJB和客户端之间）类的EJB客户端项目
- en: Web project that generates WAR
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成WAR的Web项目
- en: EAR project that generates EAR containing EBJ JAR, EJB client JAR, and WAR
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成包含EJB JAR、EJB客户端JAR和WAR的EAR项目
- en: 'You can create each of these projects independently and integrate them. However,
    Eclipse gives you the option to create EJB projects, EJB client projects, and
    EAR projects with one wizard:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以独立创建这些项目并将它们集成。然而，Eclipse提供了使用一个向导创建EJB项目、EJB客户端项目和EAR项目的选项：
- en: 'Select File | New | EJB Project. Type `CourseManagementEJBs` in the Project
    name textbox:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件 | 新建 | EJB项目。在项目名称文本框中输入`CourseManagementEJBs`：
- en: '![](img/00156.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/00156.jpeg)'
- en: 'Figure 7.4: New EJB Project wizard'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：新建EJB项目向导
- en: Make sure Target runtime is GlassFish 5 and EJB module version is 3.2 or later.
    From the Configuration drop-down list, select Default Configuration for GlassFish
    5\. In the EAR membership group, check the Add project to an EAR box.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保目标运行时为GlassFish 5，EJB模块版本为3.2或更高。从配置下拉列表中选择GlassFish 5的默认配置。在EAR成员组中，勾选将项目添加到EAR的框。
- en: 'Select Next. On the next page, specify source and output folders for the classes.
    Leave the defaults unchanged on this page:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择下一步。在下一页上，指定类的源文件夹和输出文件夹。在此页上保持默认设置不变：
- en: '![](img/00157.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00157.jpeg)'
- en: 'Figure 7.5: Select source and output folders'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：选择源文件夹和输出文件夹
- en: 'The source Java files in this project would be created in the `ejbModule` folder.
    Click Next:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此项目的源Java文件将创建在`ejbModule`文件夹中。点击下一步：
- en: '![](img/00158.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00158.jpeg)'
- en: 'Figure 7.6: Creating an EJB client project'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：创建EJB客户端项目
- en: Eclipse gives you the option to create an EJB client project. Select the option
    and click Finish.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eclipse提供了创建EJB客户端项目的选项。选择该选项并点击完成。
- en: 'Since we are building a web application, we will create a web project. Select
    File | Dynamic Web Project. Set the project name as `CourseManagementWeb`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在构建一个Web应用程序，我们将创建一个Web项目。选择文件 | 动态Web项目。将项目名称设置为`CourseManagementWeb`：
- en: '![](img/00159.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/00159.jpeg)'
- en: 'Figure 7.7: New Dynamic Web Project'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：新建动态Web项目
- en: Select the Add Project to an EAR checkbox. Since we have only one EAR project
    in the workspace, Eclipse selects this project from the drop-down list. Click
    Finish.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择将项目添加到EAR的复选框。由于我们在工作空间中只有一个EAR项目，Eclipse会从下拉列表中选择此项目。点击完成。
- en: 'We now have the following four projects in the workspace:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们工作空间中有以下四个项目：
- en: '![](img/00160.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/00160.jpeg)'
- en: 'Figure 7.8: Course Management projects'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：课程管理项目
- en: In the course management application, we will create a stateless EJB called
    `CourseBean`. We will use **Java Persistence API**s (JPA) for data access and
    create a `Course` entity. See [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, for details on using JPAs. The `CourseManagementEJBClient`
    project will contain the EJB business interface and shared classes. In `CourseManagementWeb`,
    we will create a JSF page and a managed bean that will access the `Course` EJB
    in the `CourseManagementEJBs` project to get a list of courses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在课程管理应用程序中，我们将创建一个无状态的 EJB，称为 `CourseBean`。我们将使用 **Java 持久性 API**（JPA）进行数据访问并创建一个
    `Course` 实体。有关使用 JPAs 的详细信息，请参阅[第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建
    JEE 数据库应用程序*。`CourseManagementEJBClient` 项目将包含 EJB 业务接口和共享类。在 `CourseManagementWeb`
    中，我们将创建一个 JSF 页面和一个管理 Bean，该 Bean 将访问 `CourseManagementEJBs` 项目中的 `Course` EJB
    以获取课程列表。
- en: Configuring datasources in GlassFish
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 GlassFish 中的数据源
- en: In [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications,* we created the JDBC datasource locally in the application.
    In this chapter, we will create a JDBC datasource in GlassFish. GlassFish Server
    is not packaged with the JDBC driver for MySQL. So, we need to place the `.jar`
    file for `MySQLDriver` in the path where GlassFish can find it. You can place
    such external libraries in the `lib`/`ext` folder of the GlassFish domain in which
    you want to deploy your application. For this example, we will copy the JAR in
    `<glassfish_home>/glassfish/domains/domain1/lib/ext`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建 JEE 数据库应用程序*中，我们在应用程序本地创建了
    JDBC 数据源。在本章中，我们将在 GlassFish 中创建 JDBC 数据源。GlassFish 服务器没有打包 MySQL 的 JDBC 驱动程序。因此，我们需要将
    `MySQLDriver` 的 `.jar` 文件放置在 GlassFish 可以找到它的路径中。您可以将此类外部库放置在您想要部署应用程序的 GlassFish
    域的 `lib`/`ext` 文件夹中。对于本例，我们将复制 JAR 文件到 `<glassfish_home>/glassfish/domains/domain1/lib/ext`。
- en: 'If you do not have the MySQL JDBC driver, you can download it from `http://dev.mysql.com/downloads/connector/j/`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有 MySQL JDBC 驱动程序，您可以从以下网址下载它：`http://dev.mysql.com/downloads/connector/j/`：
- en: 'Open the GlassFish admin console, either by right-clicking on the server in
    the Servers view and selecting GlassFish | View Admin Console (this opens the
    admin console inside Eclipse) or browsing to `http://localhost:4848` (`4848` is
    the default port to which the GlassFish admin console application listens). In
    the admin console, select Resources | JDBC | JDBC Connection Pools. Click the New
    button on the JDBC Connection Pool page:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 GlassFish 管理控制台，可以通过在“服务器视图”中右键单击服务器并选择 GlassFish | 查看管理控制台（这将在 Eclipse 内打开管理控制台）或浏览到
    `http://localhost:4848`（`4848` 是 GlassFish 管理控制台应用程序默认监听的端口号）。在管理控制台中，选择资源 | JDBC
    | JDBC 连接池。在 JDBC 连接池页面上单击“新建”按钮：
- en: '![](img/00161.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00161.jpeg)'
- en: 'Figure 7.9: Create JDBC Connection Pool in GlassFish'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：在 GlassFish 中创建 JDBC 连接池
- en: 'Set Pool Name as `MySQLconnectionPool` and select javax.sql.DataSource as Resource
    Type. Select MySql from the Database Driver Vendor list and click Next. In the
    next page, select the correct Datasource Classname (com.mysql.jdbc.jdbc2.optional.MysqlDatasource):'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将池名称设置为 `MySQLconnectionPool` 并选择 javax.sql.DataSource 作为资源类型。从数据库驱动程序供应商列表中选择
    MySql 并单击下一步。在下一页上，选择正确的数据源类名（com.mysql.jdbc.jdbc2.optional.MysqlDatasource）：
- en: '![](img/00162.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00162.jpeg)'
- en: 'Figure 7.10: JDBC Connection Pool settings in GlassFish'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：GlassFish 中的 JDBC 连接池设置
- en: 'We need to set the hostname, port, username, and password of MySQL. In the
    admin page, scroll down to the Additional Properties section and set the following
    properties:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置 MySQL 的主机名、端口号、用户名和密码。在管理页面上，向下滚动到“附加属性”部分，并设置以下属性：
- en: '| **Properties** | **Values** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **值** |'
- en: '| Port/PortNumber | `3306` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 端口/端口号 | `3306` |'
- en: '| DatabaseName | `<schemaname_of_coursemanagement>`, for example,`course_management`.
    See [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, for details on creating the MySQL schema for the *Course
    Management* database. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 数据库名称 | `<schemaname_of_coursemanagement>`, 例如，`course_management`。有关创建 *Course
    Management* 数据库的 MySQL 模式的详细信息，请参阅[第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建
    JEE 数据库应用程序*。 |'
- en: '| Password | MySQL database password. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 密码 | MySQL 数据库密码。 |'
- en: '| URL/Url | `jdbc:mysql://:3306/<database_name>` , for example,`jdbc:mysql://:3306/course_management`
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| URL/URL | `jdbc:mysql://:3306/<database_name>`，例如，`jdbc:mysql://:3306/course_management`
    |'
- en: '| ServerName | `localhost` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 服务器名称 | `localhost` |'
- en: '| User | MySQL username |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | MySQL 用户名 |'
- en: 'Click Finish. The new connection pool is added to the list in the left pane.
    Click on the newly added connection pool. In the General tab, click on the Ping
    button and make sure that the ping is successful:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。新的连接池已添加到左侧窗格中的列表中。点击新添加的连接池。在“常规”选项卡中，点击“Ping”按钮并确保ping操作成功：
- en: '![](img/00163.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00163.jpeg)'
- en: 'Figure 7.11: Test JDBC Connection Pool in GlassFish'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：在GlassFish中测试JDBC连接池
- en: 'Next, we need to create a JNDI resource for this connection pool so that it
    can be accessed from the client application. Select the Resources | JDBC | JDBC Resources
    node in the left pane. Click the New button to create a new JDBC resource:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为这个连接池创建一个JNDI资源，以便它可以从客户端应用程序访问。在左侧窗格中选择“资源”|“JDBC”|“JDBC资源”节点。点击“新建”按钮创建一个新的JDBC资源：
- en: '![](img/00164.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00164.jpeg)'
- en: 'Figure 7.12: Test JDBC Connection Pool in GlassFish'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：在GlassFish中测试JDBC连接池
- en: Set JNDI Name as `jdbc/CourseManagement`. From the Pool Name drop-down list,
    select the connection pool that we created for MySQL, `MySQLconnectionPool`. Click
    Save.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JNDI名称设置为`jdbc/CourseManagement`。从“池名称”下拉列表中选择我们为MySQL创建的连接池，即`MySQLconnectionPool`。点击保存。
- en: Configuring JPA in an Eclipse project
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Eclipse项目中配置JPA
- en: 'We will now configure our EJB project to use JPA to access the MySQL database.
    We have already learned how to enable JPA for an Eclipse project in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. However, we will briefly cover the steps
    again here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将配置我们的EJB项目以使用JPA来访问MySQL数据库。我们已经在[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)的*创建JEE数据库应用程序*部分中学习了如何为Eclipse项目启用JPA。然而，我们将在下面再次简要介绍这些步骤：
- en: 'Right-click on the `CourseManagementEJBs` project in Project Explorer and select
    Configure | Convert to JPA Project. Eclipse opens the Project Facets window:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目探索器中右键单击`CourseManagementEJBs`项目，选择“配置”|“转换为JPA项目”。Eclipse打开“项目特性”窗口：
- en: '![](img/00165.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00165.jpeg)'
- en: 'Figure 7.13: Eclipse Project Facets'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：Eclipse项目特性
- en: 'Click Next to go to the JPA Facet page:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步进入“JPA特性”页面：
- en: '![](img/00166.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00166.jpeg)'
- en: 'Figure 7.14: JPA Facet'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：JPA特性
- en: Keep the default values unchanged, and click Finish. Eclipse adds `persistence.xml`,
    required by JPA, to the project under the JPA Content group in Project Explorer.
    We need to configure the JPA datasource in `persistence.xml`. Open `persistence.xml`
    and click on the Connection tab. Set Transaction Type to `JTA`. In the JTA datasource
    textbox, type the JNDI name that we set up for our MySQL database in the previous
    section, which was `jdbc/CourseManagement`. Save the file. Note that the actual
    location of `persistence.xml` is `ejbModule`/`META-INF`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 保持默认值不变，然后点击完成。Eclipse会将JPA所需的`persistence.xml`文件添加到项目探索器中的“JPA内容”组下的项目中。我们需要在`persistence.xml`中配置JPA数据源。打开`persistence.xml`并点击“连接”选项卡。将事务类型设置为`JTA`。在JTA数据源文本框中，输入我们在上一节中为MySQL数据库设置的JNDI名称，即`jdbc/CourseManagement`。保存文件。请注意，`persistence.xml`的实际位置是`ejbModule`/`META-INF`。
- en: 'Let''s now create a database connection in Eclipse and link it with JPA properties
    of the project so that we can create JPA entities from the database tables. Right-click
    on the `CourseManagementEJBs` project and select Properties. This opens the Project
    Properties window. Click on the JPA node to see the details page. Click on the Add
    connection link just below the Connection drop-down box. We have already seen
    how to set up a database connection in the *Using Eclipse Data Source Explorer*
    section of [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. However, we will quickly recap the steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在Eclipse中创建一个数据库连接，并将其与项目的JPA属性链接起来，以便我们可以从数据库表中创建JPA实体。在`CourseManagementEJBs`项目上右键单击并选择“属性”。这会打开“项目属性”窗口。点击“JPA”节点以查看详细信息页面。在连接下拉框下方点击“添加连接”链接。我们已经在[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)的“使用Eclipse数据源探索器”部分中看到了如何设置数据库连接，*创建JEE数据库应用程序*。然而，我们将在下面简要回顾这些步骤：
- en: 'In the Connection Profile window, select MySQL:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“连接配置”窗口中，选择MySQL：
- en: '![](img/00167.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00167.jpeg)'
- en: 'Figure 7.15: New DB Connection Profile'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：新的数据库连接配置文件
- en: 'Type `CourseManagementDBConnection` in the name textbox and click Next. In
    the New Connection Profile window, click on the new connection profile button
    (the circle next to the Drivers drop-down box) to open the New Driver Definition
    window. Select the appropriate MySQL JDBC Driver version and click on the JAR
    List tab. In the case of any error, remove any existing `.jar` and click on the
    Add JAR/Zip button. Browse to the MySQL JDBC driver JAR that we saved in the `<glassfish_home>/glassfish/domains/domain1/lib/ext`
    folder. Click OK. Back in the New Connection Profile window, enter the database
    name, modify the connection URL, and enter User name and Password:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名称文本框中输入`CourseManagementDBConnection`并点击下一步。在“新连接配置”窗口中，点击新连接配置按钮（位于“驱动程序”下拉框旁边的圆圈）以打开“新驱动程序定义”窗口。选择适当的MySQL
    JDBC驱动程序版本，并点击“JAR列表”标签。如果出现任何错误，删除任何现有的`.jar`文件，并点击“添加JAR/ZIP”按钮。浏览到我们在`<glassfish_home>/glassfish/domains/domain1/lib/ext`文件夹中保存的MySQL
    JDBC驱动程序JAR文件。点击确定。回到“新连接配置”窗口，输入数据库名称，修改连接URL，并输入用户名和密码：
- en: '![](img/00168.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00168.jpeg)'
- en: 'Figure 7.16: Configuring MySQL database connection'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：配置MySQL数据库连接
- en: 'Select the Save password checkbox. Click the Test Connection button and make
    sure that the test is successful. Click the Finish button. Back in the JPA properties
    page, the new connection is added and appropriate schema is selected:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“保存密码”复选框。点击“测试连接”按钮并确保测试成功。点击完成按钮。回到JPA属性页面，新的连接被添加，并选择了适当的模式：
- en: '![](img/00169.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00169.jpeg)'
- en: 'Figure 7.17: Connection added to JPA project properties'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17：添加到JPA项目属性的连接
- en: Click OK to save the changes.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定以保存更改。
- en: Creating a JPA entity
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建JPA实体
- en: 'We will now create the entity class for `Course`, using Eclipse JPA tools:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用Eclipse JPA工具为`Course`创建实体类：
- en: 'Right-click on the `CourseManagementEJBs` project and select JPA Tool | Generate
    Entities from Tables:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`CourseManagementEJBs`项目，并选择JPA工具 | 从表生成实体：
- en: '![](img/00170.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: 'Figure 7.18: Creating entity from tables'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：从表创建实体
- en: 'Select the Course table and click Next. Click Next in the Table Associations
    window. On the next page, select `identity` as Key generator:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择课程表并点击下一步。在“表关联”窗口中点击下一步。在下一页上，选择`identity`作为键生成器：
- en: '![](img/00171.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00171.jpeg)'
- en: 'Figure 7.19: Customizing JPA entity details'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：自定义JPA实体细节
- en: 'Enter the package name. We do not want to change anything on the next page,
    so click Finish. Notice that the wizard creates a `findAll` query for the class
    that we can use to get all courses:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入包名。我们不想在下一页上更改任何内容，因此点击完成。注意，向导为我们的类创建了一个`findAll`查询，我们可以使用它来获取所有课程：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating stateless EJB
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建无状态EJB
- en: 'We will now create the stateless EJB for our application:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为我们的应用程序创建无状态EJB：
- en: 'Right-click on the `ejbModule` folder in the `CourseManagementEJBs` project
    in Project Explorer and select New | Session Bean (3.x). Type `packt.book.jee.eclipse.ch7.ejb`
    in the Java package textbox and `CourseBean` in Class name. Select the Remote
    checkbox:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中右键单击`CourseManagementEJBs`项目的`ejbModule`文件夹，并选择新建 | 会话Bean（3.x）。在Java包文本框中输入`packt.book.jee.eclipse.ch7.ejb`，在类名中输入`CourseBean`。选择远程复选框：
- en: '![](img/00172.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00172.jpeg)'
- en: 'Figure 7.20: Creating a stateless session bean'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：创建无状态会话Bean
- en: 'Click Next. No change is required on the next page:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步。在下一页上不需要进行任何更改：
- en: '![](img/00173.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00173.jpeg)'
- en: 'Figure 7.21: Stateless session bean information'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：无状态会话Bean信息
- en: 'Click Finish. A `CourseBean` class is created with `@Stateless` and `@Localbean`
    annotations. The class also implements the `CourseBeanRemote` interface, which
    is defined in the `CourseManagementEJBClient` project. This interface is a shared
    interface (a client calling EJB needs to access this interface):'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。一个带有`@Stateless`和`@Localbean`注解的`CourseBean`类被创建。该类还实现了在`CourseManagementEJBClient`项目中定义的`CourseBeanRemote`接口，这是一个共享接口（调用EJB的客户需要访问此接口）：
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The interface is annotated with `@Remote`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接口被注解为`@Remote`：
- en: '[PRE14]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, the question is how do we return `Course` information from our EJB? The
    EJB will call JPA APIs to get instances of the `Course` entity, but do we want
    EJB to return instances of the `Course` entity or should it return instances of
    lightweight **data transfer object** (**DTO**)? Each has its own advantages. If
    we return a `Course` entity, then we do not need to transfer data between objects;
    which we will have to do in the case of DTO (transfer data from the entity to
    the corresponding DTO). However, passing entities between layers may not be a
    good idea if the EJB client is not in the same application, and you may not want
    to expose your data model to external applications. Furthermore, by passing back
    JPA entities you are forcing the client application to depend on JPA libraries
    in its implementation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是我们是怎样从我们的 EJB 返回 `Course` 信息的？EJB 将调用 JPA API 来获取 `Course` 实体的实例，但我们希望
    EJB 返回 `Course` 实体的实例，还是应该返回轻量级的数据传输对象（**DTO**）的实例？每种方法都有其自身的优点。如果我们返回一个 `Course`
    实体，那么我们就不需要在不同对象之间传输数据；这在 DTO 的情况下是必须做的（从实体传输数据到相应的 DTO）。然而，如果 EJB 客户端不在同一应用程序中，那么在层之间传递实体可能不是一个好主意，你可能不希望将你的数据模型暴露给外部应用程序。此外，通过返回
    JPA 实体，你正在迫使客户端应用程序在其实现中依赖 JPA 库。
- en: DTOs are lightweight, and you can expose only those fields that you want your
    clients to use. However, you will have to transfer data between entities and DTOs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs 轻量级，并且你可以仅暴露那些你希望客户端使用的字段。然而，你将不得不在实体和 DTO 之间传输数据。
- en: If your EJBs are going to be used by the client in the same application, then
    it could be easier to transfer entities to the client from the EJBs. However,
    if your client is not part of the same EJB application, or when you want to expose
    the EJB as a web service (we will learn how to create web services in [Chapter
    9](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating Web Services*),
    then you may need to use DTOs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 EJB 将被同一应用程序中的客户端使用，那么从 EJB 传输实体到客户端可能更容易。然而，如果你的客户端不是同一 EJB 应用程序的一部分，或者当你想将
    EJB 作为 Web 服务（我们将在 [第 9 章](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建
    Web 服务*）暴露时，你可能需要使用 DTO。
- en: In our application, we will see examples of both the approaches, that is, an
    EJB method returning JPA entities as well as DTOs. Remember that we have created
    `CourseBean` as a remote as well as a local bean (no-interface view). Implementation
    of the remote interface method will return DTOs and that of the local method will
    return JPA entities.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将看到两种方法的示例，即 EJB 方法返回 JPA 实体以及 DTO。记住，我们已经创建了 `CourseBean` 作为远程以及本地
    Bean（无接口视图）。远程接口方法的实现将返回 DTO，而本地方法的实现将返回 JPA 实体。
- en: Let's now add the `getCourses` method to the EJB. We will create `CourseDTO`,
    a data transfer object, which is a POJO, and returns instances of the DTO from
    the `getCourses` method. This DTO needs to be in the `CourseManagementEJBsClient`
    project because it will be shared between the EJB and its client.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `getCourses` 方法添加到 EJB 中。我们将创建 `CourseDTO`，一个数据传输对象，它是一个 POJO，并且从 `getCourses`
    方法返回 DTO 的实例。此 DTO 需要位于 `CourseManagementEJBsClient` 项目中，因为它将在 EJB 和其客户端之间共享。
- en: 'Create the following class in the `packt.book.jee.eclipse.ch7.dto` package
    in the `CourseManagementEJBsClient` project:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CourseManagementEJBsClient` 项目的 `packt.book.jee.eclipse.ch7.dto` 包中创建以下类：
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following method to `CourseBeanRemote`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `CourseBeanRemote`：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to implement this method in `CourseBean` EJB. To get the courses from
    the database, the EJB needs to first get an instance of `EntityManager`. Recall
    that in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications,* we created `EntityManagerFactory` and got an instance
    of `EntityManager` from it. Then, we passed that instance to the service class,
    which actually got the data from the database using JPA APIs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `CourseBean` EJB 中实现此方法。要从数据库获取课程，EJB 需要先获取一个 `EntityManager` 实例。回想一下，在
    [第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建 JEE 数据库应用程序*，我们创建了
    `EntityManagerFactory` 并从其中获取了一个 `EntityManager` 实例。然后，我们将该实例传递给服务类，该类实际上使用 JPA
    API 从数据库中获取数据。
- en: 'JEE application servers make injecting `EntityManager` very easy. You just
    need to create the `EntityManager` field in the EJB class and annotate it with
    `@PersistenceContext(unitName="<name_as_specified_in_persistence.xml>")`. The
    `unitName` attribute is optional if there is only one persistence unit defined
    in `persistence.xml`. Open the `CourseBean` class and add the following declaration:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: JEE应用服务器使注入`EntityManager`变得非常简单。你只需在EJB类中创建`EntityManager`字段，并用`@PersistenceContext(unitName="<name_as_specified_in_persistence.xml>")`注解它。如果`persistence.xml`中只定义了一个持久化单元，则`unitName`属性是可选的。打开`CourseBean`类，并添加以下声明：
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: EJBs are managed objects, and the EJB container injects `EntityManager` after
    EJBs are created.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: EJB是受管理的对象，EJB创建后，EJB容器会注入`EntityManager`。
- en: Auto injection of objects is a part of JEE features called **Context and Dependency
    Injection** (**CDI**). See [https://javaee.github.io/tutorial/cdi-basic.html#GIWHB](https://javaee.github.io/tutorial/cdi-basic.html#GIWHB) for
    information on CDI.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的自动注入是JEE特性的一部分，称为**上下文和依赖注入**（**CDI**）。有关CDI的信息，请参阅[https://javaee.github.io/tutorial/cdi-basic.html#GIWHB](https://javaee.github.io/tutorial/cdi-basic.html#GIWHB)。
- en: 'Let''s now add a method to `CourseBean` EJB that will return a list of `Course`
    entities. We will name this method `getCourseEntities`. This method will be called
    by the `getCourses` method in the same EJB, which will then convert the list of
    entities to DTOs. The method `getCourseEntities` can also be called by any web
    application, because the EJB exposes no-interface view (using the `@LocalBean`
    annotation):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们给`CourseBean` EJB添加一个方法，该方法将返回一个`Course`实体的列表。我们将把这个方法命名为`getCourseEntities`。这个方法将由同一EJB中的`getCourses`方法调用，然后将其转换成DTO列表。`getCourseEntities`方法也可以由任何Web应用程序调用，因为EJB公开了无接口视图（使用`@LocalBean`注解）：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After implementing the `getCourses` method (defined in our remote business
    interface called `CourseBeanRemote`), we have `CourseBean`, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`getCourses`方法（定义在我们的远程业务接口`CourseBeanRemote`中）之后，我们得到`CourseBean`，如下所示：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating JSF and managed beans
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建JSF和管理Bean
- en: We will now create a JSF page to display courses in the `CourseManagementWeb`
    project. We will also create a managed bean that will call the `getCourses` method
    of `CourseEJB`. See the *Java Server Faces* section in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, for details about JSF.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在`CourseManagementWeb`项目中创建一个JSF页面来显示课程。我们还将创建一个管理Bean来调用`CourseEJB`的`getCourses`方法。有关JSF的详细信息，请参阅[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)的*Java服务器页面*部分，*创建一个简单的JEE
    Web应用程序*。
- en: 'As explained in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, we need to add JSF Servlet and mapping
    to `web.xml`. Open `web.xml` from the `CourseManagementWeb` project. You can open
    this file either by double-clicking the Deployment Descriptor: CourseManagementWeb
    node (under the project in Project Explorer) or from the `WebContent/Web-INF`
    folder (again, under the project in Project Explorer). Add the following servlet
    declaration and mapping (within the `web-app` node):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中所述，*创建一个简单的JEE
    Web应用程序*，我们需要在`web.xml`中添加JSF Servlet和映射。从`CourseManagementWeb`项目打开`web.xml`。你可以通过双击项目资源管理器中的“部署描述符：CourseManagementWeb”节点（在项目下）或从“WebContent/Web-INF”文件夹（再次在项目下）打开此文件。在`web-app`节点内添加以下Servlet声明和映射：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `CourseManagementWeb` project needs to access the business interface of
    EJB, which is in `CourseManagementEJBsClient`. So, we need to add the reference
    of `CourseManagementEJBsClient` to `CourseManagementWeb`. Open the project properties
    of `CourseManagementWeb` (right-click on the `CourseManagementWeb` project and
    select Properties) and select Java Build Path. Click on the Projects tab, and
    then click the Add... button. Select `CourseManagementEJBsClient` from the list
    and click OK:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseManagementWeb`项目需要访问EJB的业务接口，该接口位于`CourseManagementEJBsClient`中。因此，我们需要将`CourseManagementEJBsClient`的引用添加到`CourseManagementWeb`中。打开`CourseManagementWeb`项目的项目属性（在`CourseManagementWeb`项目上右键单击并选择属性），然后选择Java构建路径。单击“项目”选项卡，然后单击“添加...”按钮。从列表中选择`CourseManagementEJBsClient`并单击确定：'
- en: '![](img/00174.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00174.jpeg)'
- en: 'Figure 7.22: Adding project reference'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22：添加项目引用
- en: 'Now, let''s create a managed bean for the JSF that we are going to create later.
    Create a `CourseJSFBean` class in the `packt.book.jee.eclipse.ch7.web.bean` package
    in the `CourseManagementWeb` project (Java source files go in the `src` folder
    under the Java Resources group):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为稍后要创建的 JSF 创建一个托管豆。在 `CourseManagementWeb` 项目的 `packt.book.jee.eclipse.ch7.web.bean`
    包中创建一个 `CourseJSFBean` 类（Java 源文件位于 Java 资源组下的 `src` 文件夹中）：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: JSF beans are managed beans, so we can have the container inject EJBs using
    the `@EJB` annotation. In the preceding code we have referenced `CourseBean` with
    its remote interface, `CourseBeanRemote`. We then created a method called `getCourses`,
    which calls the method with the same name on `Course` EJB and returns the list
    of `CourseDTO` objects.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 豆是托管豆，因此我们可以使用 `@EJB` 注解让容器注入 EJB。在前面的代码中，我们使用其远程接口 `CourseBeanRemote` 引用了
    `CourseBean`。然后我们创建了一个名为 `getCourses` 的方法，该方法调用 `Course` EJB 上相同名称的方法，并返回 `CourseDTO`
    对象的列表。
- en: Note that we have set the `name` attribute in the `@ManagedBean` annotation.
    This managed bean would be accessed from JSF as variable `Course`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `@ManagedBean` 注解中设置了 `name` 属性。这个托管豆将通过 JSF 作为变量 `Course` 访问。
- en: 'We will now create the JSF page, `course.xhtml`. Right-click on WebContent
    group in the `CourseManagementWeb` project, and select New | File. Create `courses.xhtml` with
    the following content:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建 JSF 页面 `course.xhtml`。在 `CourseManagementWeb` 项目的 `WebContent` 组中右键单击，选择新建
    | 文件。创建 `courses.xhtml` 并包含以下内容：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The page uses the `dataTable` tag ([https://docs.oracle.com/javaee/7/javaserver-faces-2-2/vdldocs-jsp/h/dataTable.html](https://docs.oracle.com/javaee/7/javaserver-faces-2-2/vdldocs-jsp/h/dataTable.html)),
    which receives the data to populate from the `Course` managed bean (which is actually
    the `CourseJSFBean` class). `Course.courses` in the expression language syntax
    is a short-form for `Course.getCourses()`. This results in a call to the `getCourses`
    method of the `CourseJSFBean` class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面使用 `dataTable` 标签 ([https://docs.oracle.com/javaee/7/javaserver-faces-2-2/vdldocs-jsp/h/dataTable.html](https://docs.oracle.com/javaee/7/javaserver-faces-2-2/vdldocs-jsp/h/dataTable.html))，它从
    `Course` 托管豆（实际上是 `CourseJSFBean` 类）接收数据以填充。表达式语言语法中的 `Course.courses` 是 `Course.getCourses()`
    的简写形式。这导致调用 `CourseJSFBean` 类的 `getCourses` 方法。
- en: Each element of the list returned by `Course.courses`, which is `List` of `CourseDTO`,
    is represented by the `course` variable (in the `var` attribute value). We then
    display the name and credits of each course in the table using the `column` child
    tag.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Course.courses` 返回的列表的每个元素，即 `CourseDTO` 的 `List`，都由 `course` 变量（在 `var` 属性值中）表示。然后我们使用
    `column` 子标签在表中显示每门课程的名字和学分。'
- en: Running the example
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'Before we can run the example, we need to start the GlassFish Server and deploy
    our JEE application in it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行示例之前，我们需要启动 GlassFish 服务器并将我们的 JEE 应用程序部署到其中：
- en: Start the GlassFish Server.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 GlassFish 服务器。
- en: 'Once it is started, right-click on the GlassFish Server in the Servers view
    and select the Add and Remove... menu option:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动，在服务器视图中右键单击 GlassFish 服务器，并选择添加和移除...菜单选项：
- en: '![](img/00175.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.75](img/00175.jpeg)'
- en: 'Figure 7.23: Adding a project to GlassFish for deployment'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23：将项目添加到 GlassFish 以进行部署
- en: Select the EAR project and click on the Add button. Then, click Finish.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 EAR 项目并点击添加按钮。然后，点击完成。
- en: 'The selected EAR application will be deployed in the server:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选定的 EAR 应用程序将在服务器中部署：
- en: '![](img/00176.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.76](img/00176.jpeg)'
- en: 'Figure 7.24: Application deployed in GlassFish'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24：在 GlassFish 中部署的应用程序
- en: To run the JSF page, `course.xhtml`, right-click on it in Project Explorer
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 JSF 页面 `course.xhtml`，在项目资源管理器中右键单击它。
- en: and select Run As | Run on Server. The page will be opened in the internal Eclipse
    browser and courses in the MySQL database will be displayed on the page.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后选择运行方式 | 在服务器上运行。页面将在内部 Eclipse 浏览器中打开，MySQL 数据库中的课程将显示在页面上。
- en: Note that we can use `CourseBean` (EJB) as a local bean in `CourseJSFBean`,
    because they are in the same application deployed on the same server. To do this,
    add a reference of the `CourseManagementEJBs` project in the build path of `CourseManagementWeb`
    (open the project properties of `CourseManagementWeb`, select Java Build Path,
    select the Projects tab, and click the Add... button. Select the `CourseManagementEJBs`
    project and add its reference).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以在 `CourseJSFBean` 中使用 `CourseBean`（EJB）作为本地豆，因为它们位于同一应用程序中，在相同的服务器上部署。为此，在
    `CourseManagementWeb` 的构建路径中添加 `CourseManagementEJBs` 项目的引用（打开 `CourseManagementWeb`
    的项目属性，选择 Java 构建路径，选择项目标签，然后点击添加...按钮。选择 `CourseManagementEJBs` 项目并添加其引用）。
- en: 'Then, in the `CourseJSFBean` class, remove the declaration of `CourseBeanRemote`
    and add one for `CourseBean`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `CourseJSFBean` 类中，删除 `CourseBeanRemote` 的声明并添加一个 `CourseBean`：
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When you make any changes in the code, the EAR project needs to be redeployed
    in the GlassFish Server. In Servers view, you can see whether redeployment is
    needed by checking the status of the server. If it is [Started, Synchronized],
    then no redeployment is needed. However, if it is [Started, Republish], then redeployment
    is required. Just click on the server node and select the Publish menu option.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对代码进行任何更改时，需要重新部署 EAR 项目到 GlassFish 服务器。在服务器视图中，您可以通过检查服务器状态来查看是否需要重新部署。如果状态是[已启动，同步]，则不需要重新部署。然而，如果状态是[已启动，重新发布]，则需要重新部署。只需单击服务器节点并选择发布菜单选项。
- en: Creating EAR for deployment outside Eclipse
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Eclipse 外部创建 EAR 文件进行部署
- en: 'In the last section, we learned how to deploy an application to GlassFish from
    Eclipse. This works fine during development, but finally you will need to create
    the EAR file for deployment to an external server. To create the EAR file from
    the project, right-click on the EAR project (in our example, it is `CourseManagementEJBsEAR`)
    and select Export | EAR file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何从 Eclipse 部署应用程序到 GlassFish。这在开发过程中运行良好，但最终您需要创建 EAR 文件以部署到外部服务器。要从项目创建
    EAR 文件，请右键单击 EAR 项目（在我们的示例中，它是 `CourseManagementEJBsEAR`），然后选择导出 | EAR 文件：
- en: '![](img/00177.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00177.jpeg)'
- en: 'Figure 7.25: Exporting to EAR file'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25：导出到 EAR 文件
- en: Select the destination folder and click Finish. This file can then be deployed
    in GlassFish using the management console or by copying it to the `autodeploy`
    folder in GlassFish.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 选择目标文件夹并单击完成。然后，可以使用管理控制台或将其复制到 GlassFish 的 `autodeploy` 文件夹来部署此文件。
- en: Creating a JEE project using Maven
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven 创建 JEE 项目
- en: 'In this section, we will learn how to create JEE projects with EJBs using Maven.
    Creating Maven projects may be preferable to Eclipse JEE projects because builds
    can be automated. We have seen many details of creating EJBs, JPA entities, and
    other classes in the previous section, so we won''t repeat all that information
    here. We have also learned how to create Maven projects in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application,* and [Chapter 3](part0057.html#1MBG20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Source Control Management in Eclipse,* so the basic details of creating a Maven
    project will not be repeated either. We will focus mainly on how to create EJB
    projects using Maven. We will create the following projects:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Maven 创建带有 EJB 的 JEE 项目。创建 Maven 项目可能比 Eclipse JEE 项目更可取，因为构建可以自动化。我们在上一节中看到了创建
    EJB、JPA 实体和其他类的许多细节，所以这里不会重复所有这些信息。我们还学习了如何在[第 2 章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“创建简单的
    JEE Web 应用程序”和[第 3 章](part0057.html#1MBG20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“Eclipse
    中的源代码管理”中创建 Maven 项目，所以创建 Maven 项目的详细信息也不会重复。我们将主要关注如何使用 Maven 创建 EJB 项目。我们将创建以下项目：
- en: '`CourseManagementMavenEJBs`: This project contains EJBs'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CourseManagementMavenEJBs`：该项目包含 EJB'
- en: '`CourseManagementMavenEJBClient`: This project contains shared interfaces and
    objects between an EJB project and the client projects'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CourseManagementMavenEJBClient`：该项目包含 EJB 项目和客户端项目之间的共享接口和对象'
- en: '`CourseManagementMavenWAR`: This is a web project containing a JSF page and
    a managed bean'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CourseManagementMavenWAR`：这是一个包含 JSF 页面和管理 Bean 的 Web 项目'
- en: '`CourseManagementMavenEAR`: This project creates the EAR file that can be deployed
    in GlassFish'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CourseManagementMavenEAR`：该项目创建可以部署到 GlassFish 的 EAR 文件'
- en: '`CourseManagement`: This project is the overall parent project that builds
    all the previously mentioned projects'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CourseManagement`：该项目是所有之前提到的项目的整体父项目，构建所有这些项目'
- en: 'We still start with `CourseManagementMavenEJBs`. This project should generate
    the EJB JAR file. Let''s create a Maven project with the following details:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然从 `CourseManagementMavenEJBs` 开始。该项目应生成 EJB JAR 文件。让我们创建一个具有以下详细信息的 Maven
    项目：
- en: '| ** Field** | **Value** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 组 ID | packt.book.jee.eclipse.ch7.maven |'
- en: '| Artifact ID | CourseManagementMavenEJBClient |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 艺术品 ID | CourseManagementMavenEJBClient |'
- en: '| Version | 1 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1 |'
- en: '| Packaging | jar |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 打包 | jar |'
- en: 'We need to add the dependency of JEE APIs to our EJB project. Let''s add the
    dependency of `javax.javaee-api`. Since we are going to deploy this project in
    GlassFish, which comes with its own JEE implementation and libraries, we will
    scope this dependency as provided. Add the following in `pom.xml`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将JEE API的依赖项添加到我们的EJB项目中。让我们将`javax.javaee-api`的依赖项添加到`pom.xml`中。由于我们打算在带有自己的JEE实现和库的GlassFish中部署此项目，我们将此依赖项的范围设置为提供。在`pom.xml`中添加以下内容：
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we create the EJBs in this project, we need to create local or remote
    business interfaces in a shared project (client project). Therefore, we will create
    `CourseManagementMavenEJBClient` with the following details:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本项目中创建EJB时，需要在共享项目（客户端项目）中创建本地或远程业务接口。因此，我们将创建`CourseManagementMavenEJBClient`，以下为详细信息：
- en: '| **Field** | **Values** |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 组ID | packt.book.jee.eclipse.ch7.maven |'
- en: '| Artifact ID | CourseManagementMavenEJBs |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 艺术品ID | CourseManagementMavenEJBs |'
- en: '| Version | 1 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1 |'
- en: '| Packaging | jar |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 打包 | jar |'
- en: This shared project also needs to access EJB annotations. So, add the same dependency
    for `javax.javaee-api` that we added previously to the `pom.xml` file of the `CourseManagementMavenEJBClient`
    project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此共享项目还需要访问EJB注解。因此，将之前添加到`pom.xml`文件的`javax.javaee-api`依赖项添加到`CourseManagementMavenEJBClient`项目的`pom.xml`文件中。
- en: We will create a `packt.book.jee.eclipse.ch7.ejb` package in this project and
    create a remote interface. Create a `CourseBeanRemote` interface (just as we created
    in the *Creating stateless EJB* section of this chapter). Furthermore, create
    a `CourseDTO` class in the `packt.book.jee.eclipse.ch7.dto` package. This class
    is the same as the one that we created in the *Creating stateless EJB* section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本项目中创建一个`packt.book.jee.eclipse.ch7.ejb`包，并创建一个远程接口。创建一个`CourseBeanRemote`接口（就像我们在本章*创建无状态EJB*部分的创建无状态EJB中创建的那样）。此外，在`packt.book.jee.eclipse.ch7.dto`包中创建一个`CourseDTO`类。此类与我们创建的*创建无状态EJB*部分中的类相同。
- en: 'We are going to create a `Course` JPA entity in the `CourseManagementMavenEJBs` project.
    Before we do that, let''s convert this project to a JPA project. Right-click on
    the project in Package Explorer and select Configure | Convert to JPA Project.
    In the JPA configuration wizard, select the following JPA facet details:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`CourseManagementMavenEJBs`项目中创建一个`Course` JPA实体。在我们这样做之前，让我们将此项目转换为JPA项目。在包资源管理器中右键单击项目，选择配置
    | 转换为JPA项目。在JPA配置向导中，选择以下JPA特性详细信息：
- en: '| **Fields** | **Values** |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| Platform | Generic 2.1 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | Generic 2.1 |'
- en: '| JPA Implementation | Disable Library Configuration |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| JPA实现 | 禁用库配置 |'
- en: JPA wizard creates a `META-INF` folder in the `src` folder of the project and
    creates `persistence.xml`. Open `persistence.xml` and click on the Connection
    tab. We have already created the MySQL datasource in GlassFish (see the *Configuring
    datasource in GlassFish* section). Enter the JNDI name of the datasource, `jdbc/CourseManagement`,
    in the JTA data source field.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: JPA向导在项目的`src`文件夹中创建一个`META-INF`文件夹，并创建`persistence.xml`文件。打开`persistence.xml`文件，点击连接选项卡。我们已经在GlassFish中创建了MySQL数据源（参见*配置GlassFish中的数据源*部分）。在JTA数据源字段中输入数据源的JNDI名称，`jdbc/CourseManagement`。
- en: 'Create a `Course` entity in `packt.book.jee.eclipse.ch7.jpa`, as described
    in the *Creating JPA entity* section. Before we create the EJB in this project,
    let''s add an EJB facet to this project. Right-click on the project and select
    Properties. Click on the Project Facets group and select the EJB Module checkbox.
    Set version to the latest one (at the time of writing, the latest version was
    3.2). We will now create the implementation class of the remote session bean interface
    that we created previously. Right-click on the `CourseManagementMavenEJBs` project
    and select the New | Session Bean menu. Create the EJB class with the following
    details:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`packt.book.jee.eclipse.ch7.jpa`中创建一个`Course`实体，如*创建JPA实体*部分所述。在我们创建本项目的EJB之前，让我们给本项目添加一个EJB特性。在项目上右键单击，选择属性。点击项目特性组，并选择EJB模块复选框。将版本设置为最新版本（撰写本文时，最新版本为3.2）。我们现在将创建之前创建的远程会话bean接口的实现类。在`CourseManagementMavenEJBs`项目上右键单击，并选择新建
    | 会话bean菜单。创建EJB类，以下为详细信息：
- en: '| **Fields** | **Values** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| Java package | packt.book.jee.eclipse.ch7.ejb |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| Java包 | packt.book.jee.eclipse.ch7.ejb |'
- en: '| Class name | CourseBean |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | CourseBean |'
- en: '| State type | Stateless |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 状态类型 | 无状态 |'
- en: 'Do not select any business interface, because we have already created the business
    interface in the `CourseManagementMavenEJBClient` project. Click Next. On the
    next page, select `CourseBeanRemote`. Eclipse will show errors at this point because
    `CourseManagementMavenEJBs` does not know about `CourseManagementMavenEJBClient`,
    which contains the `CourseBeanRemote` interface, used by `CourseBean` in the EJB
    project. Adding the Maven dependency (in `pom.xml`) for `CourseManagementMavenEJBClient`
    in `CourseManagementMavenEJBs` and implementing the `getCourses` method in the
    EJB class should fix the compilation errors. Now complete the implementation of
    the `CourseBean` class as described in the *Creating stateless EJB* section of
    this chapter. Make sure that EJB is marked as `Remote`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 不要选择任何业务接口，因为我们已经在 `CourseManagementMavenEJBClient` 项目中创建了业务接口。点击“下一步”。在下一页，选择
    `CourseBeanRemote`。此时 Eclipse 将显示错误，因为 `CourseManagementMavenEJBs` 不了解 `CourseManagementMavenEJBClient`，它包含
    `CourseBeanRemote` 接口，该接口在 EJB 项目中的 `CourseBean` 中使用。在 `CourseManagementMavenEJBs`
    中添加 `CourseManagementMavenEJBClient` 的 Maven 依赖项（在 `pom.xml` 中）并在 EJB 类中实现 `getCourses`
    方法应该可以修复编译错误。现在按照本章 *创建无状态 EJB* 部分的描述完成 `CourseBean` 类的实现。确保将 EJB 标记为 `Remote`：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s create a web application project for course management using Maven.
    Create a Maven project with the following details:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Maven 创建一个用于课程管理的 Web 应用程序项目。创建一个具有以下详细信息的 Maven 项目：
- en: '| **Fields** | **Values** |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 组 ID | packt.book.jee.eclipse.ch7.maven |'
- en: '| Artifact ID | CourseManagementMavenWebApp |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 艺术品 ID | CourseManagementMavenWebApp |'
- en: '| Version | 1 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1 |'
- en: '| Packaging | war |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 打包 | war |'
- en: To create `web.xml` in this project, right-click on the project and select Java
    EE
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此项目中创建 `web.xml`，请右键单击项目并选择 Java EE
- en: Tools | Generate Deployment Descriptor Stub. The `web.xml` file is created in
    the `src/main/webapp/WEB-INF` folder. Open `web.xml` and add the servlet definition
    and mapping for JSF (see the *Creating JSF and managed bean* section of this chapter).
    Add the dependency of the `CourseManagementMavenEJBClient` project and `javax`.
    `javaee-api` in `pom.xml` of the `CourseManagementMavenWebApp` project so that
    the web project has access to the EJB business interface declared in the shared
    project and also to EJB annotations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 工具 | 生成部署描述符占位符。`web.xml` 文件将在 `src/main/webapp/WEB-INF` 文件夹中创建。打开 `web.xml`
    并添加 JSF 的 servlet 定义和映射（参见本章的 *创建 JSF 和托管 Bean* 部分）。在 `CourseManagementMavenWebApp`
    项目的 `pom.xml` 中添加 `CourseManagementMavenEJBClient` 项目和 `javax.javaee-api` 的依赖项，以便
    Web 项目能够访问共享项目中声明的 EJB 业务接口以及 EJB 注解。
- en: 'Let''s now create a `CourseJSFBean` class in the web project as described in
    the *Creating JSF and managed bean* section. Note that this will reference the
    remote interface of the EJB in the managed bean, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 Web 项目中创建一个 `CourseJSFBean` 类，如本章 *创建 JSF 和托管 Bean* 部分所述。请注意，这将引用 EJB
    的远程接口，如下所示：
- en: '[PRE26]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create `course.xhtml` in the `webapp` folder as described in the *Creating JSF
    and managed bean* section.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章 *创建 JSF 和托管 Bean* 部分的描述，在 `webapp` 文件夹中创建 `course.xhtml`。
- en: 'Let''s now create a `CourseManagementMavenEAR` project with the following details:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个具有以下详细信息的 `CourseManagementMavenEAR` 项目：
- en: '| **Fields** | **Values** |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 组 ID | packt.book.jee.eclipse.ch7.maven |'
- en: '| Artifact ID | CourseManagementMavenEAR |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 艺术品 ID | CourseManagementMavenEAR |'
- en: '| Version | 1 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1 |'
- en: '| Packaging | ear |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 打包 | ear |'
- en: 'You will have to type `ear` in the Packaging file; there is no `ear` option
    in the drop-down list. Add dependencies of `web`, `ejb`, and client projects to `pom.xml`,
    as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在打包文件中键入 `ear`；下拉列表中没有 `ear` 选项。将 `web`、`ejb` 和客户端项目的依赖项添加到 `pom.xml` 中，如下所示：
- en: '[PRE27]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Make sure to set `<type>` of each dependency properly. You also need to update
    JNDI URLs for any name changes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 确保正确设置每个依赖项的 `<type>`。您还需要更新任何名称更改的 JNDI URL。
- en: 'Maven does not have built-in support to package EAR. However, there is a Maven
    plugin for EAR. You can find details of this plugin at [https://maven.apache.org/plugins/maven-ear-plugin/](https://maven.apache.org/plugins/maven-ear-plugin/)
    and [https://maven.apache.org/plugins/maven-ear-plugin/modules.html](https://maven.apache.org/plugins/maven-ear-plugin/modules.html).
    We need to add this plugin to our `pom.xml` and configure its parameters. Our
    EAR file will contain the JAR for the EJB project, the client project, and the
    WAR for the web project. Right-click on `pom.xml` of the EAR project, and select
    Maven | Add Plugin. Type `ear` in the Filter box, and select the latest plugin
    version under maven-ear-plugin. Make sure that you also install the maven-acr-plugin
    plugin. Configure the EAR plugin in the `pom.xml` details, as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Maven没有内置支持来打包EAR。然而，有一个针对EAR的Maven插件。您可以在[https://maven.apache.org/plugins/maven-ear-plugin/](https://maven.apache.org/plugins/maven-ear-plugin/)和[https://maven.apache.org/plugins/maven-ear-plugin/modules.html](https://maven.apache.org/plugins/maven-ear-plugin/modules.html)找到此插件的详细信息。我们需要将其添加到我们的`pom.xml`中并配置其参数。我们的EAR文件将包含EJB项目的JAR文件、客户端项目以及Web项目的WAR文件。右键点击EAR项目的`pom.xml`，选择Maven
    | 添加插件。在过滤器框中输入`ear`，并在maven-ear-plugin下选择最新插件版本。确保您还安装了maven-acr-plugin插件。在`pom.xml`的详细信息中配置EAR插件，如下所示：
- en: '[PRE28]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After modifying `pom.xml`, sometimes Eclipse may display the following error:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`pom.xml`后，有时Eclipse可能会显示以下错误：
- en: '[PRE29]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In such cases, right-click on the project and select Maven | Update Project.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，右键点击项目并选择Maven | 更新项目。
- en: 'The last project that we create in this section is `CourseManagement`, which
    will be the container project for all other EJB projects. When this project is
    installed, it should build and install all the contained projects. Create a Maven
    project with the following details:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们创建的最后一个项目是`CourseManagement`，它将成为所有其他EJB项目的容器项目。当此项目安装时，它应该构建并安装所有包含的项目。创建一个具有以下详细信息的Maven项目：
- en: '| **Fields** | **Values** |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 组ID | packt.book.jee.eclipse.ch7.maven |'
- en: '| Artifact ID | CourseManagement |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 艺术品ID | CourseManagement |'
- en: '| Version | 1 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1 |'
- en: '| Packaging | Pom |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 打包 | Pom |'
- en: 'Open `pom.xml` and click on the Overview tab. Expand the Modules group, and
    add all the other projects as modules. The following modules should be listed
    in `pom.xml`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`pom.xml`并点击“概览”选项卡。展开“模块”组，并将所有其他项目作为模块添加。以下模块应列在`pom.xml`中：
- en: '[PRE30]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Right-click on the `CourseManagement` project and select Run As | Maven Install.
    This builds all EJB projects, and an EAR file is created in the target folder
    of the `CourseManagementMavenEAR` project. You can deploy this EAR in GlassFish
    from its management console, or you can right-click on the configured GlassFish
    Server in the Servers view of Eclipse, select the Add and Remove... option, and
    deploy the EAR project from within Eclipse. Browse to `http://localhost:8080/CourseManagementMavenWebApp/course.xhtml`
    to see the list of courses displayed by the `course.xhtml` JSF page.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`CourseManagement`项目，选择运行方式 | Maven安装。这将构建所有EJB项目，并在`CourseManagementMavenEAR`项目的目标文件夹中创建一个EAR文件。您可以从GlassFish的管理控制台部署此EAR文件，或者您可以在Eclipse的“服务器视图”中右键点击配置的GlassFish服务器，选择“添加和移除...”选项，并在Eclipse内部部署EAR项目。浏览到`http://localhost:8080/CourseManagementMavenWebApp/course.xhtml`以查看由`course.xhtml`
    JSF页面显示的课程列表。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: EJBs are ideal for writing business logic in web applications. They can act
    as the perfect bridge between web interface components such as JSF, servlet, or
    JSP and data access objects such as JDO. EJBs can be distributed across multiple
    JEE application servers (this could improve application scalability), and their
    life cycle is managed by the container. EJBs can be easily injected into managed
    objects or can be looked up using JNDI.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: EJB非常适合在Web应用程序中编写业务逻辑。它们可以作为JSF、servlet或JSP等Web界面组件与JDO等数据访问对象之间的完美桥梁。EJB可以跨多个JEE应用程序服务器分布（这可以提高应用程序的可伸缩性），并且其生命周期由容器管理。EJB可以轻松注入到管理对象中，或者可以使用JNDI查找。
- en: Eclipse JEE makes creating and consuming EJBs very easy. Just like we saw how
    Tomcat can be configured and managed within Eclipse, JEE application servers,
    such as GlassFish, can also be managed from within Eclipse.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse JEE使得创建和消费EJB非常容易。就像我们看到的如何在Eclipse中配置和管理Tomcat一样，JEE应用程序服务器，如GlassFish，也可以在Eclipse中管理。
- en: In the next chapter, we will learn how to create web applications using Spring
    MVC. Although Spring is not part of JEE, it is a popular framework to implement
    the MVC pattern in JEE web applications. Spring can also work with many of the
    JEE specifications.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Spring MVC创建Web应用程序。尽管Spring不是JEE的一部分，但它是一个流行的框架，用于在JEE Web应用程序中实现MVC模式。Spring还可以与许多JEE规范协同工作。
