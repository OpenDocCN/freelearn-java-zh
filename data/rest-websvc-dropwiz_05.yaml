- en: Chapter 5. Representations – RESTful Entities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。表示 – RESTful实体
- en: Our web service is now responding to requests that produce output by utilizing
    the `Response` class. We saw that there are methods of this class that take an
    object as a parameter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web服务现在通过利用`Response`类来响应产生输出的请求。我们注意到这个类有一些方法接受一个对象作为参数。
- en: Creating a representation class
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表示类
- en: We are going to create the representations that will be produced by the REST
    resources of our application. A simple Java class is everything needed by Jersey,
    so it will consider the class as a RESTful representation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建由我们的应用程序的REST资源产生的表示。一个简单的Java类就是Jersey所需的一切，因此它将把该类视为RESTful表示。
- en: 'Given that our web service needs to produce contact-related information in
    the JSON format, a sample response would look something like the following code:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的Web服务需要以JSON格式生成与联系人相关的信息，一个示例响应将类似于以下代码：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will build our representation class around this JSON string. The class will
    have the necessary properties (`id`, `firstName`, `lastName`, and `phone`) along
    with their getter methods.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将围绕这个JSON字符串构建我们的表示类。该类将具有必要的属性（`id`、`firstName`、`lastName`和`phone`）以及它们的getter方法。
- en: How to do it…
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Perform the following steps for creating a representation class:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建表示类：
- en: Create a new package called `com.dwbook.phonebook.representations` and create
    a `Contact` class in it.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`com.dwbook.phonebook.representations`的新包，并在其中创建一个`Contact`类。
- en: 'Add the aforementioned contact properties as final members, also implementing
    their getters and a constructor:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上述联系人属性作为final成员添加，并实现它们的getter和构造函数：
- en: '[PRE1]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The representation class for contacts is now ready. All that was required was
    just a plain Java class with the same properties as the JSON object that we wish
    our application to generate. In order for this to work though, the appropriate
    public getter methods are needed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人的表示类现在已准备就绪。所需的一切只是一个具有与我们要生成应用程序的JSON对象相同属性的普通Java类。然而，为了使其工作，需要适当的公共getter方法。
- en: Our properties were declared final in order to be immutable, and for this reason,
    we also created a constructor that initializes the properties accordingly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的属性被声明为final，以便是不可变的，因此我们也创建了一个相应初始化属性的构造函数。
- en: Instances of this class may now be used in our Jersey-based REST resources as
    the output. Jackson will handle the transformation from POJO to JSON transparently.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实例现在可以用作我们基于Jersey的REST资源的输出。Jackson将透明地处理从POJO到JSON的转换。
- en: There's more…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Any POJO can be used as a representation. Jackson constructs the JSON string
    recursively according to the getter methods of each class and their return type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何POJO都可以用作表示。Jackson根据每个类的getter方法和它们的返回类型递归地构建JSON字符串。
- en: The Jackson Java JSON processor
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jackson Java JSON处理器
- en: Jackson is a powerful open source JSON data binder/parser and processor that
    facilitates the transformation of plain old Java objects to the JSON format and
    vice versa. Jersey uses Jackson for its transformation needs and is part of the
    `dropwizard-core` module; so, it is already included in our project setup.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Jackson是一个强大的开源JSON数据绑定/解析器/处理器，它简化了将普通Java对象转换为JSON格式以及相反的过程。Jersey使用Jackson来满足其转换需求，并且是`dropwizard-core`模块的一部分；因此，它已经包含在我们的项目设置中。
- en: JSON arrays
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON数组
- en: Any instance of the `java.util.List` type will be converted to a JSON array.
    For example, if we wanted to store multiple phone numbers for a contact, we would
    have declared `private final List<String> phoneNumbers` in the representation
    class (with the appropriate modifications to the class constructor and the getter).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`java.util.List`类型的实例都将被转换为JSON数组。例如，如果我们想为联系人存储多个电话号码，我们将在表示类中声明`private
    final List<String> phoneNumbers`（对类构造函数和getter的适当修改）。
- en: 'This would lead to JSON representations of the following format:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下格式的JSON表示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ignoring properties
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略属性
- en: You can prevent a property from being a part of the JSON representation by adding
    the `@JsonIgnore` annotation to its getter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其getter上添加`@JsonIgnore`注解来防止一个属性成为JSON表示的一部分。
- en: This will cause Jackson to ignore a getter method that otherwise would be treated
    as a JSON property.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致Jackson忽略一个否则会被视为JSON属性的getter方法。
- en: Serving representations through the Resource class
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Resource类提供表示
- en: 'Consider the `ContactResource#getContact()` method we previously implemented.
    We use the `Response#ok(Object entity)` method in order to build the response
    to be sent to the client, passing it to `String` as a parameter, as shown in the
    following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前实现的`ContactResource#getContact()`方法。我们使用`Response#ok(Object entity)`方法来构建要发送给客户端的响应，并将其作为参数传递给`String`，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we have our `Representation` class ready, and we are going to utilize it
    and pass instances of it to the `#ok()` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了`Representation`类，我们将利用它并将其实例传递给`#ok()`方法。
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to learn the serving of representation through
    the resource class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以通过资源类学习表示的提供：
- en: 'Update the `ContactResource#getContact()` method accordingly in order to pass
    a `Contact` object in the `#ok()` method instead of `String`, as shown in the
    following code. You will need to import the `Contact` class first (`import com.dwbook.phonebook.representations.Contact`):'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下代码相应地更新`ContactResource#getContact()`方法，以便在`#ok()`方法中传递`Contact`对象而不是`String`，您需要首先导入`Contact`类（`import
    com.dwbook.phonebook.representations.Contact`）：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, modify the method''s signature, splitting the `name` variable to `firstName`
    and `lastName` in order to be consistent with the `Contact` class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改方法的签名，将`name`变量拆分为`firstName`和`lastName`，以便与`Contact`类保持一致：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Rebuild (`mvn package`) and run the application again:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建（`mvn package`）并再次运行应用程序：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Navigate to `http://localhost:8080/contact/123` or perform a PUT request to
    the same URL. You will see that the response that the server is sending to our
    request is a JSON representation of the object we are passing to the `Response#ok()`
    method.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:8080/contact/123`或向同一URL执行PUT请求。您将看到服务器发送给我们的请求的响应是我们传递给`Response#ok()`方法的对象的JSON表示。
- en: How it works…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define the response sent to the client by using the `Response#ok()` method,
    which accepts an object as a parameter. Until now, we have been passing JSON strings
    directly. This is not an efficient way, as our application will be handling actual
    objects (the `Contact` instances), and there is no reason for manually creating
    JSON representations of them when this can be done automatically by Jackson.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`Response#ok()`方法定义发送给客户端的响应，该方法接受一个对象作为参数。到目前为止，我们一直直接传递JSON字符串。这不是一种高效的方式，因为我们的应用程序将处理实际的对象（`Contact`实例），而且没有理由手动创建它们的JSON表示，当Jackson可以自动完成时。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We are now using our `representation` class in order to map its properties to
    the response we are producing. We can also use the same class to map our input
    parameters. For instance, we could modify the `ContactResource#updateContact()`
    and `ContactResource#createContact()`methods to expect a `Contact` object as a
    parameter instead of using each of its properties explicitly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在使用我们的`representation`类来将其属性映射到我们正在生成的响应。我们还可以使用相同的类来映射我们的输入参数。例如，我们可以修改`ContactResource#updateContact()`和`ContactResource#createContact()`方法，使其期望一个`Contact`对象作为参数，而不是显式使用其每个属性。
- en: Using cURL to perform HTTP requests
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用cURL执行HTTP请求
- en: Using your browser, you can only perform GET requests. In order to effectively
    test our application though, we will need a tool capable of performing HTTP requests
    with the POST, PUT, and DELETE methods. cURL ([http://curl.haxx.se/](http://curl.haxx.se/))
    is a command-line tool that we can use to better comprehend the examples. You
    can download it from [http://curl.haxx.se/download.html](http://curl.haxx.se/download.html)
    by choosing the package that is compatible with your platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的浏览器，您只能执行GET请求。为了有效地测试我们的应用程序，我们需要一个能够使用POST、PUT和DELETE方法执行HTTP请求的工具。cURL
    ([http://curl.haxx.se/](http://curl.haxx.se/))是一个命令行工具，我们可以用它更好地理解示例。您可以从[http://curl.haxx.se/download.html](http://curl.haxx.se/download.html)下载它，选择与您的平台兼容的包。
- en: 'Performing a GET request is as simple as the cURL. The following example will
    call the `#getContact()` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 执行GET请求与cURL一样简单。以下示例将调用`#getContact()`方法：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Using cURL to perform HTTP requests](img/9530OS_05_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![使用cURL执行HTTP请求](img/9530OS_05_01.jpg)'
- en: The JSON string you are seeing in the second line is the server's response.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您在第二行看到的JSON字符串是服务器的响应。
- en: 'In order to perform a PUT request to update a contact, we will need to use
    the `-X` flag followed by the method name (that is `curl -X PUT` …). To send data
    to the server along with our request, a contact''s information in this case, use
    the `-d` flag as well along with the data. Note that since the `#updateContact()`
    method''s parameters are mapped to request parameters (with `@FormParam`), we
    need to send the data URL encoded. Take a look at the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行一个用于更新联系人的 PUT 请求，我们需要使用 `-X` 标志后跟方法名称（即 `curl -X PUT` …）。为了在请求中向服务器发送数据，在这种情况下是联系人的信息，同时使用
    `-d` 标志以及数据。请注意，由于 `#updateContact()` 方法的参数映射到请求参数（使用 `@FormParam`），我们需要以 URL
    编码的形式发送数据。请看下面的截图：
- en: '![Using cURL to perform HTTP requests](img/9530OS_05_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![使用 cURL 执行 HTTP 请求](img/9530OS_05_02.jpg)'
- en: 'If we want to see a verbose output that includes the request''s and response''s
    headers, we can use the `-v` (long name --verbose) flag. Also, in case we need
    to set the value of a request header, we can use the `-H` (long name --header)
    flag followed by the header information:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想看到包含请求和响应头部的详细输出，可以使用 `-v`（长名称 --verbose）标志。此外，如果我们需要设置请求头部的值，可以使用 `-H`（长名称
    --header）标志，后跟头部信息：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Mapping the request data to representations
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求数据映射到表示形式
- en: The current way of reading the web service properties by mentioning each one
    of them (annotated) in the signatures of the `#createContact()` and `#updateContact()`
    methods is fine; however, it is not efficient in case of significant amount of
    input data. Imagine a case where we would need to add several additional properties
    in the `Contact` class. We would have to also update the method signatures as
    well, making them less readable and finally unmanageable. Generally, it is preferred
    to map the request data to the representation directly. To achieve this, we will
    update the relevant methods accordingly, removing the properties and adding a
    `contact` instance instead. Jackson will take care of the rest.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当前通过在 `#createContact()` 和 `#updateContact()` 方法的签名中提及每个属性（注解）来读取 Web 服务属性的方式是可以的；然而，在大量输入数据的情况下，它并不高效。想象一下，如果我们需要在
    `Contact` 类中添加几个额外的属性。我们还需要更新方法签名，使它们变得不那么易读，最终难以管理。通常，我们更喜欢直接将请求数据映射到表示形式。为了实现这一点，我们将相应地更新相关方法，删除属性并添加一个
    `contact` 实例。Jackson 将处理其余部分。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to map the request data:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以映射请求数据：
- en: 'Update the `ContactResource#createContact()` method, replacing its parameters
    with a single `contact` object:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `ContactResource#createContact()` 方法，用单个 `contact` 对象替换其参数：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Update the `ContactResource#updateContact()` method, replacing its parameters
    with a single `contact` object:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `ContactResource#updateContact()` 方法，用单个 `contact` 对象替换其参数：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Rebuild and run the application again. The application is now able to handle
    HTTP POST and PUT requests to the `/contact` and `/contact/{id}` endpoints respectively,
    having JSON strings on the request body instead of the named parameters. Note
    that the `Content-Type` header of the request will be set to `application/json`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建并再次运行应用程序。现在，应用程序能够处理 `/contact` 和 `/contact/{id}` 端点的 HTTP POST 和 PUT 请求，请求体中包含
    JSON 字符串而不是命名参数。请注意，请求的 `Content-Type` 头部将被设置为 `application/json`。
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By declaring a `Contact` instance as the parameter on a method that handles
    requests (that is, a method with Jersey annotations bound to URI), we force Jersey
    to parse the request body and deserialize (using Jackson) it to a `Contact` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在处理请求的方法（即带有 Jersey 注解绑定到 URI 的方法）上声明 `Contact` 实例作为参数，我们强制 Jersey 解析请求体并将其反序列化（使用
    Jackson）为 `Contact` 对象。
- en: 'The PUT request we performed in the previous example can now be performed by
    sending the JSON data to the server and setting the appropriate header, as shown
    in the following line of code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中执行的 PUT 请求现在可以通过向服务器发送 JSON 数据并设置适当的头部来执行，如下面的代码行所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How it works…](img/9530OS_05_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/9530OS_05_03.jpg)'
- en: 'In case a POST request is performed on `http://localhost:8080/contact` with
    the `{"firstName": "Alexandros", "lastName": "Dallas", "phone": "+3012345678"}`
    JSON data as the request''s body and the `Content-Type` header: `application/json`,
    the `contact` object within the `#createContact()` method will have its properties
    initialized accordingly, thanks to Jackson and its appropriate JAX-RS entity providers.
    Entity providers are components that process the payload that is included in an
    HTTP request and transform it to an object. This is similar to the transformation
    that happens when a `resource` method is returning an object and is transformed
    to a JSON object.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '如果在 `http://localhost:8080/contact` 上执行 POST 请求，请求体包含 JSON 数据 `{"firstName":
    "Alexandros", "lastName": "Dallas", "phone": "+3012345678"}`，并且 `Content-Type`
    报头为 `application/json`，那么在 `#createContact()` 方法中的 `contact` 对象将根据这些属性进行初始化，这得益于
    Jackson 以及其适当的 JAX-RS 实体提供者。实体提供者是处理包含在 HTTP 请求中的有效负载并将其转换为对象的组件。这与当 `resource`
    方法返回一个对象并将其转换为 JSON 对象时发生的转换类似。'
