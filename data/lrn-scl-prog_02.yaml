- en: Understanding Types in Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Scala 中的类型
- en: The strong type system is one of the most important parts of the Scala language.
    Like a double-edged sword, it helps the compiler to verify and optimize the code
    on one side, while at the same time guiding developers toward possible correct
    implementations and preventing them from making programming mistakes on another
    side. As with any sharp tool, it requires some skill so that it can be used for
    carving beautiful source code without cutting the user in the process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型系统是 Scala 语言最重要的部分之一。就像一把双刃剑，它帮助编译器在一侧验证和优化代码，同时也在另一侧引导开发者向可能的正确实现方向前进，并防止他们在编程过程中犯错误。就像任何锋利的工具一样，它需要一些技巧，这样它才能在雕刻美丽源代码的同时，不会伤害用户。
- en: In this chapter, we will improve this skill by recapping and summarizing basic
    type-related knowledge, taking a look at a new type that was introduced in Scala
    2.13, and finally looking at some advanced usages of types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过回顾和总结基本类型相关知识，查看 Scala 2.13 中引入的新类型，并最终查看一些类型的先进用法来提高这项技能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Different ways to create a type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类型的不同方式
- en: Different ways to parameterize a type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化类型的不同方式
- en: Kinds of types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型种类
- en: Using types to express domain constraints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型来表示领域约束
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你已经安装了以下内容：
- en: JDK 1.8+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+
- en: SBT 1.2+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The source code for this chapter is available under our GitHub repository at: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02)[.](https://github.com/PacktPublishing/Learn-Scala---Fundamentals-of-Scala-2.13/ch02)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在我们的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02)[.](https://github.com/PacktPublishing/Learn-Scala---Fundamentals-of-Scala-2.13/ch02)
- en: Understanding types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型
- en: The type of something is a summation of the information the compiler owns about
    this *something*. In the most general case, we're talking about the type of a
    variable; the knowledge of the compiler includes the methods that are available
    on this variable and the classes that the variable extends. A very convenient
    feature of Scala is that it tries to use type inference where possible, freeing
    the developer from the need to define types explicitly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 事物的类型是编译器拥有的关于这个“事物”的信息的总和。在最一般的情况下，我们谈论的是变量的类型；编译器的知识包括这个变量上可用的方法和这个变量扩展的类。Scala
    的一个非常方便的特性是它尽可能地使用类型推断，从而让开发者从需要显式定义类型的需要中解放出来。
- en: Let's take a structured look at Scala's type system, starting with a short recap
    of its basics.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以结构化的方式审视 Scala 的类型系统，从对其基本知识的简要回顾开始。
- en: Ways to create a type
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类型的途径
- en: 'There are four ways to define a type in Scala:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中定义类型有四种方式：
- en: By using a literal to define a singleton type
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用字面量来定义单例类型
- en: By using the type keyword to define an alias for an abstract or concrete type
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用类型关键字为抽象或具体类型定义别名
- en: By defining a class, object, or trait to create a concrete type
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义一个类、对象或特质来创建一个具体类型
- en: By defining a method that creates a method type
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义一个创建方法类型的函数
- en: 'Singleton types were introduced in Scala 2.13, and we''ll look at them in detail
    later in this chapter. For now, let''s try to define and refer to some concrete
    types in Scala REPL:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类型是在 Scala 2.13 中引入的，我们将在本章后面详细探讨它们。现在，让我们尝试在 Scala REPL 中定义和引用一些具体的类型：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The type can be referred before it is fully defined, as shown by the example
    of `SomeTrait`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以在完全定义之前被引用，正如`SomeTrait`的例子所示。
- en: When annotating types, traits and classes can be used directly, but the type
    of an object needs to be referenced by using its `type` operator. The `a.type` form
    in Scala describes a *singleton type*. Depending upon whether `p` conforms to `scala.AnyRef`,
    it denotes either a set of values, `[a, null]`, or just an `a`. As we usually
    don't use `null` in Scala programs, we can say that `a.type `denotes a type containing
    a single element, `a`. Normally, it is not used in *regular *code because it is
    easier to reference an object directly than to pass it as a parameter, but this
    style has found its use in some advanced libraries to implement parts of the internal
    DSL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当注解类型、特性和类时，可以直接使用它们，但对象的类型需要通过使用其`type`运算符来引用。在Scala中，`a.type`形式描述了一个*单例类型*。根据`p`是否符合`scala.AnyRef`，它表示一组值`[a,
    null]`或仅仅是`a`。由于我们通常不在Scala程序中使用`null`，我们可以说`a.type`表示一个包含单个元素`a`的类型。通常，它不用于*常规*代码，因为它直接引用对象比将其作为参数传递更简单，但这种风格在一些高级库中用于实现内部DSL的部分。
- en: 'In Scala 2.13, there is a new marker trait `Singleton` that can be applied
    as an upper bound on a type parameter, which indicates that the singleton type
    should be inferred for this parameter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala 2.13中，有一个新的标记特质`Singleton`，可以作为类型参数的上界应用，这表示应该为此参数推断单例类型：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A *method type* does not denote a value, nor does it appear directly in the
    program. It is an internal representation of a method definition. It is represented
    as a sequence of parameter names with respective types and a return type of the
    method. The method type is important into know about because, if a method name
    is used as a value, its type is implicitly converted to the corresponding function
    type. As we defined in the `usage` method, the compiler internally created a method
    type called `(a: SomeClass, b: SomeObject.type)SomeTrait`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法类型*不表示一个值，也不直接出现在程序中。它是方法定义的内部表示。它表示为参数名称的序列，每个参数都有相应的类型，以及方法的返回类型。了解方法类型很重要，因为如果方法名称用作值，其类型会隐式转换为相应的函数类型。正如我们在`usage`方法中定义的，编译器内部创建了一个名为`(a:
    SomeClass, b: SomeObject.type)SomeTrait`的方法类型。'
- en: Literal types
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量类型
- en: 'Scala 2.13 introduced a special kind of singleton type—the *literal type*.
    It denotes a single value of some literal and represents the most precise type
    of this literal. It is available for all types for which literal syntax is available
    (for example, `Boolean`, `Char`, `String`, and `Symbol`). It is impossible to
    define a literal type for `Unit` (by specification) and for `Byte` and `Short`
    (because there is no syntax to define literals of such types). This is how it
    works in practice:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 2.13引入了一种特殊类型的单例类型——*字面量类型*。它表示某个字面量的单个值，并代表这个字面量最精确的类型。它对所有可以提供字面量语法的类型都可用（例如，`Boolean`、`Char`、`String`和`Symbol`）。根据规范，无法为`Unit`定义字面量类型，也无法为`Byte`和`Short`定义（因为没有语法来定义此类类型的字面量）。以下是实际的工作方式：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two ways to define a variable of a literal type. The first way is
    by using an explicit type ascription, and the second way is by making it a non-lazy
    `final`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 定义字面量类型的变量有两种方式。第一种方式是使用显式的类型注解，第二种方式是将其声明为非懒加载的`final`：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A literal type is erased to the normal type during compilation, and so it is
    not possible to override methods using literal types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量类型在编译期间被擦除为普通类型，因此无法使用字面量类型覆盖方法：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous snippet, the compiler prevented us from declaring two methods
    with the same name, and so took a parameter with a different literal type because
    of the erasure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，编译器阻止了我们声明两个具有相同名称的方法，因此由于擦除，它采用了具有不同字面量类型的参数。
- en: 'The singleton type forming the `.type` operator can be used to specify that
    a function should return a literal type and not a normal type, as demonstrated
    by the type of `t` inferred by the compiler—`42`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由`.type`运算符形成的单例类型可以用来说明一个函数应该返回一个字面量类型而不是一个普通类型，正如编译器推断出的`t`的类型所展示的——`42`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since Scala 2.13, there is a type class called `scala.ValueOf[T]` and an operator
    called `scala.Predef.valueOf[T]` that can be used to yield values for singleton types.
    This is how `valueOf[T]` is defined:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Scala 2.13以来，有一个名为`scala.ValueOf[T]`的类型类和一个名为`scala.Predef.valueOf[T]`的运算符，可以用来为单例类型提供值。这是`valueOf[T]`的定义方式：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And this is how it can be used:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的用法：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The pattern matching against literal types also works as expected, though the
    syntax is unusual and probably not very useful, as demonstrated by this first
    case:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对字面量类型的模式匹配也按预期工作，尽管语法不寻常且可能不太有用，如下面的第一个案例所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These literal types are probably not very interesting for day-to-day programming,
    but are very useful for type-level library development.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字面类型在日常编程中可能不太有趣，但对于类型级别库的开发来说非常有用。
- en: Compound (intersection) types
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合（交集）类型
- en: 'A compound type is defined as a combination of zero or more component types
    with a refinement. If no refinement is provided, an implicit empty one (`{}`)
    is added by the compiler. Depending on the number of components, we can have the
    following cases:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型被定义为零个或多个组件类型与细化的组合。如果没有提供细化，编译器会添加一个隐式的空细化（`{}`）。根据组件的数量，我们可以有以下几种情况：
- en: If just a refinement is given, the compound type is equivalent to extending `AnyRef`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只给出细化，复合类型等价于扩展`AnyRef`
- en: A single type is extended by using the corresponding `extends` keyword
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相应的`extends`关键字扩展单个类型
- en: Two or more types are combined by interleaving them with the `with` keyword
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个或多个类型通过使用`with`关键字交错组合
- en: In the case of a name clash in combined types and/or refinement, the usual override
    rules apply. This means that the rightmost type or refinement has the highest
    priority. This combination also represents an inheritance relation, and it is
    possible to access members of extended types with the use of the `super` keyword.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合类型和/或细化中发生名称冲突的情况下，适用通常的重写规则。这意味着最右侧的类型或细化具有最高优先级。这种组合还代表了一个继承关系，并且可以使用`super`关键字访问扩展类型的成员。
- en: 'The compound type is easy to imagine as a layer of wrappers. Because of this,
    the process of resolving conflicting members in traits is called **trait linearisation**,
    while the decorator design pattern is called **stackable traits**. The following
    example demonstrates how layers of traits can access methods defined on subtypes
    of the compound type to implement a decorated `toString` representation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型可以很容易地想象成一层层的包装器。正因为如此，解决特质中冲突成员的过程被称为**特质线性化**，而装饰者设计模式被称为**可堆叠特质**。以下示例演示了特质层如何访问复合类型子类型上定义的方法，以实现装饰的`toString`表示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The definition of type contains just a refinement in the case of zero components
    being extended. This way of defining a type is known as a **structural type**.
    The use of structural types is generally discouraged in Scala because it can lead
    to a generation of bytecode that will access structurally defined members using
    reflection, which is significantly slower. Nevertheless, it is useful to define
    type lambdas, which we will take a look at near the end of this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在零个组件被扩展的情况下，类型的定义只包含一个细化。这种方式定义的类型被称为**结构化类型**。在Scala中，通常不建议使用结构化类型，因为它可能导致生成使用反射访问结构定义成员的字节码，这会显著减慢速度。尽管如此，定义类型lambda是有用的，我们将在本章末尾探讨这一点。
- en: Type constraints
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型约束
- en: 'Type constraints are rules associated with a type. They define a subset of
    all types that, for example, a variable can have. A type constraint takes the
    form of lower bound (subtype relation) or upper bound (supertype relation). It
    is possible to define multiple constraints for a single type. In this case, a
    type must satisfy both of them. Constraints are defined using the symbols `>:`
    (lower, unhappy bound) and  `<:` (upper, happy bound), and the direction of the
    sign corresponds to the reversed direction of the arrow on the UML diagram, as
    shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束是与类型相关联的规则。它们定义了所有类型的一个子集，例如，一个变量可以具有的类型。类型约束的形式是下界（子类型关系）或上界（超类型关系）。可以为单个类型定义多个约束。在这种情况下，类型必须满足这两个约束。约束使用符号
    `>:`（下界，不高兴的界限）和 `<:`（上界，高兴的界限）来定义，符号的方向对应于UML图上箭头的反向方向，如下面的截图所示：
- en: '![](img/6a801360-cd32-48dc-a797-40bf79b3e084.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a801360-cd32-48dc-a797-40bf79b3e084.png)'
- en: The type constraints are inclusive, which is why type `B` represents both the
    upper and lower bounds. Besides `B` in our type hierarchy, only `A` obeys the
    `LOWER` type constraint and only `C ` obeys the `UPPER` constraint.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束是包含性的，这就是为什么类型`B`既代表上界也代表下界。在我们的类型层次结构中，除了`B`之外，只有`A`遵守`LOWER`类型约束，只有`C`遵守`UPPER`约束。
- en: Scala's types hierarchy and special types
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala的类型层次结构和特殊类型
- en: 'Type constraints in combination with Scala''s type hierarchy give us a few
    interesting classes that are important to know about. To recap, the type hierarchy
    is represented in the following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束与Scala的类型层次结构结合，给我们带来了一些有趣且重要的类。为了回顾，类型层次结构在以下图中表示：
- en: '![](img/7f06375d-67c7-4713-af6c-7e00f662fb2b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f06375d-67c7-4713-af6c-7e00f662fb2b.png)'
- en: In Scala, all types have a maximum upper bound of **Any** and a lower bound
    of **Nothing**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，所有类型都有一个最大上界 **Any** 和一个下界 **Nothing**。
- en: '**Value Classes** is a Scala way to avoid allocating runtime objects. This
    works by wrapping JVM''s primitive types. Scala already represents numeric types
    and `Boolean` and `Char` as **AnyVal**, and it is possible to implement custom
    value classes by extending **AnyVal** and obeying a few restrictions. An interesting
    subtype of **AnyVal** is a **Unit** type, which represents a case where something
    unimportant needs to be returned from a function or a method. It roughly corresponds
    to the void return type and has a single member, `()`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**值类**是 Scala 避免分配运行时对象的一种方式。这是通过包装 JVM 的原始类型来实现的。Scala 已经将数值类型和 `Boolean`
    以及 `Char` 表示为 **AnyVal**，并且可以通过扩展 **AnyVal** 并遵守一些限制来实现自定义值类。**AnyVal** 的一个有趣的子类型是
    **Unit** 类型，它表示在函数或方法中需要返回不重要的东西的情况。它大致对应于空返回类型，并且有一个成员，`()`。'
- en: '**AnyRef** is a representation of any type that is allocated at runtime. In
    JVM, it is possible to have `null` in a place where an object reference is expected;
    the type of `null` is `Null`. The `Null` type has a single inhabitant, `null`,
    the same way `Unit` has a single value of `()`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**AnyRef** 是任何在运行时分配的类型的表现。在 JVM 中，在期望对象引用的地方可以有 `null`；`null` 的类型是 `Null`。`Null`
    类型有一个成员，`null`，就像 `Unit` 有一个值 `()` 一样。'
- en: '`Nothing` is a special subtype of every other type and has no members. Because
    of this, it is not possible to instantiate members of that type. As a result,
    it is useful to indicate that the only possibility for a method or function to
    terminate is to do this abnormally, usually by throwing an exception.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing` 是其他每个类型的特殊子类型，并且没有成员。正因为如此，无法实例化该类型的成员。因此，在表示一个方法或函数终止的唯一可能性是异常终止时，这非常有用，通常是通过抛出异常来实现。'
- en: There are two traits that are not represented in the preceding diagram, `Serializable`
    and `Product`. The former marker trait is used to tell the JVM that some class
    should be serializable across platforms, and it just delegates to Java's interface, `java.io.Serializable`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特质在先前的图中没有表示，`Serializable` 和 `Product`。前者标记特质用于告诉 JVM 某个类应该在跨平台上可序列化，并且它只是委托给
    Java 的接口，`java.io.Serializable`。
- en: The `Product` stays for the Cartesian product, which is basically just an ordered
    set of pairs of named types. In Scala, `Product` is extended by tuples and case
    classes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 保持为笛卡尔积，这基本上只是一个有序的命名类型对的集合。在 Scala 中，`Product` 通过元组和案例类扩展。'
- en: 'The `Self` type is another special notion in Scala that''s used to define dependencies
    between traits without declaring an extension relation. This syntax allows you
    to bring in the scope of the trait members from other traits, as shown in the
    following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Self` 类型是 Scala 中的另一个特殊概念，用于在不需要声明扩展关系的情况下定义特质之间的依赖关系。此语法允许你引入来自其他特质的特质成员的作用域，如下面的代码所示：'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last member in our zoo of special types is `Dynamic`. This is a marker trait
    that allows you to use the dynamic invocation of methods (also known as **duck
    typing**).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特殊类型动物园中的最后一个成员是 `Dynamic`。这是一个标记特质，允许你使用方法的动态调用（也称为 **鸭子类型**）。
- en: It feels a bit inappropriate to go into the details of `Dynamic` here because
    Scala's strength is exactly the opposite—to express knowledge about the system
    statically using proper types. For curious readers, official documentation on
    this is available here: [https://www.scala-lang.org/api/current/scala/Dynamic.html](https://www.scala-lang.org/api/current/scala/Dynamic.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里详细讨论 `Dynamic` 可能有点不合适，因为 Scala 的优势正好相反——使用适当的类型静态地表达对系统的了解。对于好奇的读者，官方文档在此处提供：[https://www.scala-lang.org/api/current/scala/Dynamic.html](https://www.scala-lang.org/api/current/scala/Dynamic.html)。
- en: Type inference
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'The preceding type hierarchy is quite important for understanding how type
    inference works. Type inference is a mechanism that the compiler uses to guess
    the type of an expression or a method if the definition of its type is omitted.
    The same also applies to the type parameters of polymorphic methods or generic
    classes and sometimes to anonymous function parameter types as well. This inference
    aims to provide the most specific type possible while obeying all of the existing
    constraints. The compiler does this by walking the hierarchy tree and finding
    the *least upper bound*. Let''s look at an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类型层次结构对于理解类型推断的工作方式非常重要。类型推断是编译器用来猜测表达式或方法的类型的一种机制，如果省略了其类型的定义。这同样适用于多态方法的类型参数或泛型类的泛型参数，有时也适用于匿名函数的参数类型。这种推断旨在提供最具体的类型，同时遵守所有现有的约束。编译器通过遍历层次树并找到*最小上界*来实现这一点。让我们看一个例子：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we specified the return types as the compiler infers them. For the first
    two cases, you can easily follow the hierarchy of Scala types to understand how
    the compiler did the inference. The last three are a bit more complicated:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了返回类型，编译器会推断它们。对于前两种情况，你可以很容易地遵循Scala类型的层次结构来理解编译器是如何进行推断的。最后三种情况稍微复杂一些：
- en: In `sOrC`, the inferred type is `java.io.Serializable`. The reason for this
    is that Scala's `String` is just an alias for `java.lang.String`, which extends `java.io.Serializable`.
    All case classes in Scala extend `Product with Serializable` by default and `Serializable`
    extends `java.io.Serializable`. Therefore, `java.io.Serializable` is the least
    upper bound in this case.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`sOrC`中，推断出的类型是`java.io.Serializable`。这是因为Scala的`String`只是`java.lang.String`的一个别名，它扩展了`java.io.Serializable`。Scala中的所有案例类默认都扩展了`Product
    with Serializable`，而`Serializable`扩展了`java.io.Serializable`。因此，在这种情况下，`java.io.Serializable`是最小上界。
- en: In `cOrD`, `D` is not a case class, and therefore it does not extend anything
    but the `AnyRef`, which becomes an inferred type.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`cOrD`中，`D`不是一个案例类，因此它不扩展任何东西，只是扩展了`AnyRef`，这成为了一个推断出的类型。
- en: In `cOrE`, both `C` and `E` are case classes, and so the compiler can infer
    the most specific type, that is, `Product with Serializable`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`cOrE`中，`C`和`E`都是案例类，因此编译器可以推断出最具体的类型，即`Product with Serializable`。
- en: 'In fact, the preciseness of the compiler can go quite far, as the following
    example demonstrates:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，编译器的精确度可以相当高，以下示例可以证明：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can see that the inferred type of `fOrG` is a compound type with three
    members.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`fOrG`推断出的类型是一个包含三个成员的复合类型。
- en: Path-dependent types
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖路径的类型
- en: Until now, we have avoided talking about paths, mostly because they are not
    types themselves. However, they can be a part of named types, and thus have an
    important role in Scala's type system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们避免谈论路径，主要是因为它们本身不是类型。然而，它们可以是命名类型的一部分，因此在Scala的类型系统中扮演着重要的角色。
- en: 'A path can have one of the following forms:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可以有以下几种形式：
- en: An empty path, denoted with `ε`. It cannot be written directly, but implicitly
    precedes any other path.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空路径，用`ε`表示。它不能直接书写，但隐式地位于任何其他路径之前。
- en: '`C.this`, where `C` is a reference class. This is the path that is constructed
    if `this` is used inside of a class.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C.this`，其中`C`是一个引用类。这是在类内部使用`this`时构建的路径。'
- en: '`C.super.x.` or `C.super[P].` refers to the member `x` of the superclass or
    designated parent class, `P` of `C`. It plays the same role as `this` for the
    class, but refers to the classes that are upper in the hierarchy.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C.super.x.`或`C.super[P].`指的是`C`的超类或指定的父类`P`的成员`x`。它在类中的作用与`this`相同，但指向的是层次结构中更上层的类。'
- en: '`p.x`, where `p` is a path and `x` is a stable member of `p`. The stable member
    is an object definition or a value definition for which it is possible for the
    compiler to tell that it will always be accessible (as opposed to the volatile
    type where it is not possible, for example, there is an abstract type definition
    that can be overridden by a subclass).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p.x`，其中`p`是一个路径，`x`是`p`的一个稳定成员。稳定成员是一个对象定义或值定义，编译器可以确定它始终是可访问的（与不可访问的类型相对，例如，有一个可以被子类覆盖的抽象类型定义）。'
- en: 'Types within the path can be referred to by two operators, `#` (hash) and `.`
    (dot). The former is known as **type projection**, and `T#m` refers to the type
    member `m` of the type `T`. We can demonstrate the difference between these operators
    by building a type-safe lock:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 路径内的类型可以通过两个运算符进行引用，`#`（哈希）和`.`（点）。前者被称为**类型投影**，`T#m`指的是类型`T`的成员`m`。我们可以通过构建一个类型安全的锁来展示这两个运算符之间的区别：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we defined a type, `Lock`, with a nested type, `Key`. The key can be
    referenced using its path, `Lock.Key`, or by using a projection, `Lock#Key`. The
    former denotes a type tied to a specific instance, and the latter denotes a type
    that is not. The specific types of key are returned by two different constructor
    methods. The `makeKey` return type is a `Key` that is a shortcut for `this.Key`,
    which in turn is an alias for `Lock.this.type#Key` and represents a *path-dependent
    type*. The latter is just a type projection, `Lock#Key`. Because the path-dependent
    type refers to the concrete instance, the compiler will only allow the use of
    the appropriate type to call the `open` and `close` methods:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个类型，`Lock`，它包含一个嵌套类型，`Key`。键可以通过其路径`Lock.Key`或通过投影`Lock#Key`来引用。前者表示与特定实例相关的类型，后者表示不是。键的具体类型由两个不同的构造方法返回。`makeKey`的返回类型是一个`Key`，它是`this.Key`的快捷方式，而`this.Key`又是一个别名，代表`Lock.this.type#Key`，它表示一个*路径相关类型*。后者只是一个类型投影，`Lock#Key`。因为路径相关类型引用了具体的实例，编译器将只允许使用适当类型来调用`open`和`close`方法：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `masterKey` is not path-dependent, and so can be used to call methods on
    any instance in a typical way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`masterKey` 不是路径相关的，因此可以以通常的方式在任意实例上调用方法：'
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These path-dependent types conclude our journey regarding concrete types and
    can be used to describe values. All of the types we've seen so far (except method
    types) are named *value types* to reflect this fact. A named value type is called
    a **type designator**. All type designators are shorthand for type projections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径相关的类型结束了我们对具体类型的探索，并且可以用来描述值。我们迄今为止所看到的所有类型（除了方法类型）都被命名为*值类型*，以反映这一事实。一个命名的值类型被称为**类型设计器**。所有类型设计器都是类型投影的缩写。
- en: We will now switch gears and inspect how types can be used to narrate definitions
    of other types.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转换方向，检查如何使用类型来叙述其他类型的定义。
- en: Types – all the way down
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型 – 贯穿始终
- en: Up until now, we have only talked about concrete types. Despite being quite
    simple, they already allow for the expression of a lot of properties of a program
    on the type level and they have these properties verified at compile time. Scala
    gives the developer even more freedom by allowing them to use types as parameters
    while defining methods, classes, or other types. In the next section, we will
    look at different ways to do this, starting with basic type parameters and type
    member definition, and continuing with type constraints and variance topics. We'll
    conclude our discussion with higher kinded types and type lambdas.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了具体类型。尽管它们相当简单，但它们已经在类型级别上允许表达程序的大量属性，并且这些属性在编译时得到验证。Scala 通过允许开发者在定义方法、类或其他类型时使用类型作为参数，为开发者提供了更多的自由。在下一节中，我们将探讨不同的实现方式，从基本类型参数和类型成员定义开始，继续到类型约束和变异性话题。我们将以高阶类型和类型lambda作为讨论的结论。
- en: Type parameters
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数
- en: 'Type parameters are defined using square brackets `[]`. If applied to classes
    and methods, they must be declared before normal parameters, and the result is
    known as a **parameterized type**:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数使用方括号 `[]` 定义。如果应用于类和方法，它们必须在正常参数之前声明，其结果称为**参数化类型**：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Wrapper` class is parameterized by the `A` type. This type parameter is
    used to refer to the type of content in the `unwrap` method. The scope resolution
    rules apply to the type parameters the same way as they do to the normal parameters,
    as shown by the `unwrap` method definition.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wrapper`类通过`A`类型进行参数化。这个类型参数用于在`unwrap`方法中引用内容类型。作用域解析规则以与正常参数相同的方式应用于类型参数，如`unwrap`方法定义所示。'
- en: The `createWrapper` method definition shows how the type parameter propagates
    to the implementation side—`Wrapper(a)` is parameterized with the `A` type by
    the compiler.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`createWrapper`方法定义展示了类型参数如何传播到实现端——编译器通过`Wrapper(a)`将`A`类型参数化。'
- en: The `ConcreteWrapper` type definition shows that type aliases are parameterized
    in the same way that types are.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteWrapper`类型定义展示了类型别名以与类型相同的方式进行参数化。'
- en: We then use our parameterized type to demonstrate that it is possible to provide
    explicit type parameters on the call side, as well as rely on type inference.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用我们的参数化类型来展示，在调用端提供显式的类型参数，以及依赖类型推断是可能的。
- en: 'This type inference is in fact quite powerful. The compiler always tries to
    find the most specific type, as the following example reveals (I''ve provided
    the explicit type ascriptions, which reflect the types inferred by the compiler):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型推断实际上非常强大。编译器总是试图找到最具体的类型，以下示例揭示了这一点（我提供了显式的类型注解，它们反映了编译器推断的类型）：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We discussed Scala's type hierarchy earlier, so it should be obvious how the
    compiler came up with the types shown in the preceding code snippet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了 Scala 的类型层次结构，所以应该很明显编译器是如何在前面的代码片段中得出这些类型的。
- en: 'It is possible to restrict possible definitions of the type parameter by using
    type constraints, as shown in the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用类型约束来限制类型参数的可能定义，以下示例展示了这一点：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The compiler will check that the concrete definition conforms to the type parameter
    bounds.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将检查具体定义是否符合类型参数的限制。
- en: Type members
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型成员
- en: 'A *type member* is similar to the type parameter, but it is defined as a type
    alias that''s a member of an abstract class or trait. It can then be made concrete
    at the moment the abstract definition itself is made concrete. Let''s look at
    the following few lines of code, which will show you how this works:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *类型成员* 类似于类型参数，但它被定义为抽象类或特质的一个类型别名。然后可以在抽象定义本身被具体化的时刻将其具体化。让我们看看以下几行代码，它将展示这是如何工作的：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we defined an abstract type member, `A`, and overrode it in the concrete
    implementation by binding it to the `Int`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个抽象类型成员 `A`，并在具体实现中通过将其绑定到 `Int` 来覆盖它。
- en: 'It is possible to define multiple type members, of course, and define constraints
    on them, including type members themselves as part of the constraint:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以定义多个类型成员，并对它们进行约束，包括将类型成员本身作为约束的一部分：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Type inference is not applied in this case, so the following code will not
    compile because the type definition is missing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下不应用类型推断，因此以下代码将无法编译，因为缺少类型定义：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These type members can be defined using all language features that can be applied
    to other type definitions, including multiple type constraints and path-dependent
    types. In the following example, we demonstrate this by declaring type members
    in the `HolderDEF` and providing the concrete definition in the class `DEF`. Incompatible
    type definitions are noted as such and commented out:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型成员可以使用适用于其他类型定义的所有语言特性来定义，包括多个类型约束和路径相关类型。在以下示例中，我们通过在 `HolderDEF` 中声明类型成员并在类
    `DEF` 中提供具体定义来展示这一点。不兼容的类型定义被标记为不兼容，并已注释掉：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is also possible to combine type members and type parameters and use them
    later to further constrain possible definitions of the former:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将类型成员和类型参数结合起来，并在以后进一步约束前者的可能定义：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Type members and type parameters look very similar in their function—this is
    done to define abstract type definitions that can be refined later. Given this
    similarity, a developer can use one or another most of the time. Still, there
    are a couple of nuances regarding the situations in which you should prefer to
    use them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类型成员和类型参数在功能上非常相似——这是为了定义可以稍后细化的抽象类型定义。鉴于这种相似性，开发者大多数时候可以使用其中一个。然而，还有一些细微差别，关于在哪些情况下你应该更倾向于使用它们。
- en: 'These type parameters are usually more straightforward and easier to get right,
    so generally, they should be preferred. Type members are the way to go if you
    run into one of the following cases:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型参数通常更直接且更容易正确使用，因此通常应该优先选择。如果你遇到以下情况之一，类型成员是最佳选择：
- en: If the concrete type definition should remain hidden
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果具体的类型定义应该保持隐藏
- en: If the intended way to provide the concrete definition of the type is via inheritance
    (overridden in subclasses or mixed-in via traits)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供类型具体定义的方式是通过继承（在子类中覆盖或在特质中混合）
- en: 'There is another simple rule that''s easy to memorize—type parameters are used
    to define the types of parameters of the method and type members to define the
    result type of this method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一条简单易记的规则——类型参数用于定义方法的参数类型和类型成员用于定义此方法的结果类型：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is also another way to specify boundaries for type parameters and type
    members in Scala.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，还有另一种指定类型参数和类型成员边界的途径。
- en: Generalized type constraints
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛化类型约束
- en: In the previous two sections, we used type constraints provided by the language
    to precisely define type members and type parameters. There are also supplementary
    *generalized type constraints* defined in the standard library that allow you
    to define relations between types using type classes. We will look at type classes
    and implicits in detail in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml),
    *Getting* *to Know Implicits and Type Classes*, but we will give a brief introduction
    to generalized type constraints here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两节中，我们使用了语言提供的类型约束来精确地定义类型成员和类型参数。标准库中还定义了一些补充的*泛化类型约束*，允许你使用类型类来定义类型之间的关系。我们将在[第4章](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml)，*了解隐式和类型类*中详细探讨类型类和隐式，但在这里我们将简要介绍泛化类型约束。
- en: 'The `<:<` constraint expresses the requirement that the left-side type is a
    subtype of the right-side type. Basically, having an instance of  `A <:< B` is
    the same as having a definition of `A <: B`. But why is it needed, then? Because
    sometimes the language is not expressive enough. Let''s look at an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`<:<`约束表达了左侧类型是右侧类型的子类型的要求。基本上，拥有`A <:< B`的实例与拥有`A <: B`的定义相同。但为什么需要它呢？因为有时语言的表达能力不足。让我们通过一个例子来看看：'
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is not possible to express the `A <: Wrapper[B]` type constraint because
    the `A` in this definition will shadow the `A` type constraint in the definition
    of `Wrapper[A]`. The implicit, `ev`, solves this problem easily. `ev` will be
    available in scope if the compiler can prove that the subtype relation holds.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '无法表达`A <: Wrapper[B]`类型约束，因为在这个定义中的`A`将覆盖`Wrapper[A]`定义中的`A`类型约束。隐式类型`ev`可以轻松解决这个问题。如果编译器可以证明子类型关系成立，`ev`将在作用域内可用。'
- en: Another generalized type constraint available in the Scala standard library
    is `=:=`. So, `A =:= B` allows you to require that `A` and `B` are equal, the
    same way that `A <:< B` allows you to express subtyping relation. Due to restrictions
    on subclassing, it also witnesses that `A <:< B`, but not that `B <:< A`. We will
    take a look in detail how this equality relation can be used to express domain
    constraints at the end of this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Scala标准库中可用的另一个泛化类型约束是`=:=`。因此，`A =:= B`允许你要求`A`和`B`相等，就像`A <:< B`允许你表达子类型关系一样。由于子类化的限制，它也证明了`A
    <:< B`，但不证明`B <:< A`。我们将在本章末尾详细探讨这种等价关系如何用来表达域约束。
- en: The strange syntax of `A <:< B` and `A =:= B` brings us to the next section, *Infix
    types*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`A <:< B` 和 `A =:= B` 的奇怪语法带我们进入下一节，*中缀类型*。'
- en: Infix types
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中缀类型
- en: In the same way that Scala has infix operators, it has infix types. An infix
    type, such as `A Op B`, is just any type that has exactly two type operands. It
    is equivalent to the type defined as `Op[A, B]`. `Op` may be any valid identifier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与Scala有中缀运算符一样，它也有中缀类型。中缀类型，如`A Op B`，只是恰好有两个类型操作数的任何类型。它等价于定义为`Op[A, B]`的类型。`Op`可以是任何有效的标识符。
- en: 'The type operators have the same associativity as term operators—they are left
    associative unless an operator ends in `:` (colon), in which case it is right
    associative. Consecutive infix operators must have the same associativity. Let''s
    look at an example to understand what this means:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类型运算符具有与项运算符相同的结合性——它们是左结合的，除非运算符以`:`（冒号）结尾，在这种情况下它是右结合的。连续的中缀运算符必须具有相同的结合性。让我们通过一个例子来理解这意味着什么：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we defined four types, all of which have two type parameters and so can
    be used as infix types. Then, we define a type called `CC`, which expresses some
    relation between the `A`, `B`, and `C` types. The `DA` and `DB` type definitions
    show what the type definition looks like in infix notation. The first attempt
    to define some type, `E`, to be the same as the `C` type fails because of the
    different associativity of the types, `=+` and `=:`, and we have demonstrated
    how parentheses can be used to work around this rule.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了四种类型，它们都具有两个类型参数，因此可以用作中缀类型。然后，我们定义了一个名为`CC`的类型，它表达了`A`、`B`和`C`类型之间的一些关系。`DA`和`DB`类型定义显示了中缀表示法中的类型定义看起来是什么样子。尝试定义与`C`类型相同的某些类型`E`的第一种方法失败了，因为类型的结合性不同，`=+`和`=:`，并且我们已经展示了如何使用括号来绕过这个规则。
- en: 'If used properly, infix types can greatly improve the readability of the code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用得当，中缀类型可以极大地提高代码的可读性：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we can see how infix types allow you to define type relation in a way
    that looks similar to Boolean operations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到中缀类型如何允许你以类似于布尔操作的方式定义类型关系。
- en: Variance
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性
- en: '*Variance* is another aspect related to parameterized types. To understand
    why it is needed and how it works, let''s have a drink. First, we will define
    a glass that can be (half) full or empty:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*协变性*是与参数化类型相关的另一个方面。为了理解为什么需要它以及它是如何工作的，让我们喝一杯。首先，我们将定义一个可以（半）满或空的玻璃杯：'
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There can only be one empty glass filled with `Nothing`, and we model this
    case with a case object. A full glass can be filled with different contents. `Nothing`
    is a subclass of any class in Scala, so in our case it should be able to substitute
    any contents. We will now create the contents and we would like to be able to
    drink it. The implementation is not important in this case:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 只能有一个空玻璃杯装满`Nothing`，我们用案例对象来模拟这种情况。一个满的玻璃杯可以装不同的内容。`Nothing`是Scala中任何类的子类，所以在这种情况下，它应该能够替代任何内容。我们现在将创建内容，并且希望能够喝掉它。在这个情况下，实现并不重要：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We now are able to drink from the full glass and are unable to do so from an
    empty one:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够从满的玻璃杯中喝，但不能从空的玻璃杯中喝：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But what if instead of drinking, we'd like to define `drinkAndRefill`, which
    should refill an empty glass?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们不想喝，而是想定义`drinkAndRefill`，这个方法应该能够给一个空玻璃杯重新装满？
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We would like our implementation to accept not only `Glass[Water]`, but also `Glass[Nothing]`,
    or more generally any `Glass[B]` if `B <: Water`. We can change our implementation
    accordingly:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '我们希望我们的实现不仅接受`Glass[Water]`，还接受`Glass[Nothing]`，或者更一般地，任何`Glass[B]`，如果`B <:
    Water`。我们可以相应地更改我们的实现：'
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But what if we would like our `Glass` to work like this with any method, not
    only `drinkAndRefill`? Then we need to define how the relation between parameterizing
    types should affect the way the parameterized type works. This is done with variance.
    Our definition, `sealed trait Glass[Contents]`, is called **invariant**, and it
    means that the relation in the type that parameterizes `Glass` does not affect
    how glasses with different contents are related—they are not related at all. The
    *covariance* means that, in regards to the compiler, if type parameters are in
    a subclass relation, then the main types should be too. It is expressed with a
    `+` (plus) before the type constraint. Therefore, our definition of the glass
    becomes the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想让我们的`Glass`与任何方法都这样工作，而不仅仅是`drinkAndRefill`？那么我们需要定义参数化类型之间的关系应该如何影响参数化类型的工作方式。这是通过协变来完成的。我们的定义，`sealed
    trait Glass[Contents]`，被称为**不变**，这意味着参数化`Glass`的类型之间的关系不会影响不同内容玻璃杯之间的关系——它们之间根本没有任何关系。*协变性*意味着，对于编译器来说，如果类型参数处于子类关系，那么主要类型也应该如此。它通过在类型约束之前使用一个`+`（加号）来表示。因此，我们的玻璃定义变成了以下这样：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And the rest of the code remains unchanged. Now, if we have contents that are
    related, we can drink them without facing the same problems we had before:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码保持不变。现在，如果我们有相关的内容，我们可以喝掉它们，而不会遇到之前遇到的问题：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A typical use of covariance is with different kinds of immutable containers,
    where it is safe to have a more specific element in the container, like the one
    that is declared by the type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 协变性的典型用法是与不同种类的不可变容器一起，其中在容器中拥有一个更具体的元素是安全的，就像由类型声明的那个元素。
- en: It is not safe to do so with mutable containers, though. The compiler will not
    allow us to do this, but if it would, we might end up passing a container, `C`,
    with some subclass, `B`, to the method, expecting a container with superclass
    `A`. This method would then be able to replace the contents of `C` with `A` (as
    it is not even supposed to know about the existence of `B`), hence making future
    uses of `C[B]` impossible.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但与可变容器一起这样做是不安全的。编译器不会允许我们这样做，但如果它允许，我们可能会传递一个包含某些子类`B`的容器`C`到方法中，期望得到一个包含超类`A`的容器。这个方法然后将能够用`A`（它甚至不应该知道`B`的存在）替换`C`的内容，从而使得未来对`C[B]`的使用变得不可能。
- en: 'Now, let''s imagine that our glass is supposed to interact with a drinker.
    We''ll create a `Drinker` class for this, and the drinker is supposed to be able
    to drink the contents of `Glass`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下，我们的玻璃应该与一个饮酒者互动。我们将为这个目的创建一个`Drinker`类，并且饮酒者应该能够喝掉`Glass`中的内容：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s inspect what happens if we have two different kinds of `Water`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下，如果我们有两种不同的`Water`会发生什么：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`PureWater` is `Water` with some additional properties. We can create a glass
    full of it and let it fill a drinker. Obviously, if somebody can drink just water,
    they should be able to drink pure water as well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`PureWater`是带有一些额外属性的`Water`，我们可以创建一个装满它的玻璃杯，并让它填满一个饮酒者。显然，如果有人可以喝普通的水，他们也应该能够喝纯水：'
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To fix this, we need to use *contravariance*, which is denoted by the `-` (minus
    sign) before the type parameter. We fix our `Drinker` like so, and our example
    starts to compile:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要使用*逆变*，这由类型参数前的`-`（减号）表示。我们这样修复我们的`Drinker`，我们的示例开始编译：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is important to notice that co- and contravariance do not define the type
    itself, but only the type parameters. This is very important for functional programming
    in Scala because it allows defining functions as first-class citizens. We will
    look at function definition in more detail in the next chapter, but to give you
    some indication, here is what it is about.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，协变和逆变并不定义类型本身，而只是类型参数。这对于Scala中的函数式编程非常重要，因为它允许将函数定义为第一类公民。我们将在下一章更详细地探讨函数定义，但为了给你一些提示，这里是什么意思。
- en: 'If we want to pass over to the caller a function, that is, `f(water: Water):
    Water`, what kind of substitute would be safe to pass instead? It would not be
    safe to pass a function that accepts `PureWater` because the caller won''t be
    able to call it with such an argument. But it will be safe for the function to
    accept `Water` and any superclass of it that describes contravariance. For the
    result, it would be unacceptable for our replacement function to return anything
    higher in the hierarchy than `f` because the caller expects the result to be at
    least as specific as `f`. It would be no problem if our substitute was more specific,
    though. Therefore, we end up with covariance. Hence, we can define `f` as `f[-Parameter,+Result]`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们要传递一个函数给调用者，即`f(water: Water): Water`，那么传递哪种替代函数是安全的呢？传递一个接受`PureWater`的函数是不安全的，因为调用者无法用这样的参数调用它。但是，如果函数接受`Water`及其任何描述逆变性的超类，那么这是安全的。对于结果，如果我们的替代函数返回比`f`更高的层次结构中的任何内容，那么这是不可接受的，因为调用者期望结果至少与`f`一样具体。如果替代函数更具体，那就没问题了。因此，我们最终得到的是协变。因此，我们可以将`f`定义为`f[-Parameter,+Result]`。'
- en: Existential types
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存在类型
- en: 'Existential types come into play if we stop caring about the specifics of type
    parameters. Taking our previous example, if we have a method that expects a glass
    of something, but inside the method, we do not actually care what this something
    is, then we get the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不再关心类型参数的具体细节，存在类型就会发挥作用。以我们的前一个例子为例，如果我们有一个期望某种东西的玻璃的方法，但在方法内部，我们实际上并不关心这个“某种东西”是什么，那么我们得到以下结果：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this definition, we actually don''t need to know what `T` is, we just want
    to make sure that it is some kind of `Water`. Scala allows you to have an underscore
    as a placeholder, in the same way it can be utilized to denote unused variables:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中，我们实际上不需要知道`T`是什么，我们只是想确保它是某种`Water`。Scala允许你使用下划线作为占位符，就像它可以用来表示未使用的变量一样：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a placeholder syntax for *existential type*s. As we saw previously,
    if the upper bound is omitted, `scala.Any` is assumed. In the case that the lower
    bound hasn't been defined, the compiler will implicitly add `scala.Nothing`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*存在类型*的占位符语法。正如我们之前看到的，如果省略了上界，则假定`scala.Any`。在未定义下界的情况下，编译器将隐式添加`scala.Nothing`。
- en: 'This syntax is just a shorter version of the more powerful syntax `T forSome
    { Q }`, where `Q` is a sequence of type declarations, for example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法只是更强大的语法`T forSome { Q }`的简短版本，其中`Q`是一系列类型声明，例如：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Existential types are considered to be an advanced language feature and so need
    a respective import to be in scope or to be enabled as a compiler option.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 存在类型被认为是高级语言特性，因此需要相应的导入使其在作用域内或作为编译器选项启用。
- en: Higher kinded types
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶类型
- en: 'Our example of the glass has become a bit boring. To make it fascinating again,
    we''ll add another abstraction, a jar. This is how our model will look after that:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的玻璃示例已经变得有点无聊了。为了再次让它变得有趣，我们将添加另一个抽象概念，一个罐子。这样我们的模型将看起来是这样的：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The glass and the jar can both be filled with any contents. For instance, this
    is how it can be done:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 玻璃和罐子都可以装满任何内容。例如，可以这样操作：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As we can see, both methods look identical with respect to the type used to
    construct the result. The parameterized type that is used to construct types is
    called a **type constructor**. As a consistent language, Scala allows you to abstract
    over type constructors in the same way it allows you to abstract over functions
    via higher order functions (more about this in the next chapter). This abstraction
    over type constructors is called **higher kinded types**. The syntax requires
    us to use an underscore to denote the expected type parameter on the definition
    side. The implementation should then use the type constructor without type constraints.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这两种方法在用于构造结果的类型方面看起来是相同的。用于构造类型的参数化类型被称为**类型构造器**。作为一个一致的语言，Scala允许你以与通过高阶函数抽象函数相同的方式抽象类型构造器（更多关于这一点将在下一章中讨论）。这种对类型构造器的抽象被称为**高阶类型**。语法要求我们在定义侧使用下划线来表示预期的类型参数。然后实现应该使用没有类型约束的类型构造器。
- en: 'We can use a type constructor to provide a generic filling functionality. Of
    course, we can''t get rid of the specific knowledge about how to fill our containers,
    but we can move it to the type level:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类型构造器来提供通用的填充功能。当然，我们无法摆脱关于如何填充我们容器的具体知识，但我们可以将其移动到类型级别：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding code, we''re using the type constructor `CC[_]` to denote
    both `Glass` and `Jar` in the `Filler` trait. We can now use created abstractions
    to define a generic filling functionality:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用类型构造器`CC[_]`在`Filler`特质中表示`Glass`和`Jar`。现在我们可以使用创建的抽象来定义通用的填充功能：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `G[_]` type is a type constructor for glass and jar, and `Filler[G]` is
    a higher order type that uses this type constructor to build a full `G[C]` for
    any content, `C`. This is how the generic fill method can be used in practice:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`G[_]`类型是玻璃和罐子的类型构造器，`Filler[G]`是一个高阶类型，它使用这个类型构造器为任何内容`C`构建完整的`G[C]`。这就是通用填充方法在实际中是如何使用的：'
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This might not look like a huge win over the specific methods for now because
    we've provided our type constructors explicitly. The real advantage will become
    obvious the moment we start talking about implicits in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml),
    *Getting to know Implicits and Type Classes*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这可能看起来并没有在特定方法上取得巨大的胜利，因为我们已经明确地提供了我们的类型构造器。真正的优势将在我们开始讨论[第4章](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml)中的隐式内容时变得明显，即*了解隐式和类型类*。
- en: Type lambdas
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型lambda
- en: 'As a next step, let''s imagine that we have a generic `Filler` that is capable
    of filling different containers with different kinds of contents, as shown in
    the following code snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们想象一下，我们有一个通用的`Filler`，它能够用不同种类的填充物填充不同的容器，如下面的代码片段所示：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What could we do if we had a requirement to provide a method that should only
    accept one type of container or content? We would need to fix the second type
    parameter in a similar fashion to how we would partially apply a function if given
    one of the arguments. A type alias can be used to do this on the type level:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个需求，需要提供一个只能接受一种容器或内容的方法，我们该如何做？我们需要以类似部分应用函数的方式固定第二个类型参数。类型别名可以在类型级别上用来完成这个操作：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'But it feels a bit verbose to define a type alias just to be used once in the
    definition of the function parameter. **Type lambda** is a syntax that allows
    us to do such partial type application in-place:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅仅为了在函数参数的定义中用一次，就定义一个类型别名，感觉有点冗长。**类型lambda**是一种语法，允许我们在原地执行这种部分类型应用：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The type lambda can also be used to define a parameter type directly:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 类型lambda也可以用来直接定义参数类型：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The internal definition of `T[C]` is analogous to the type alias we defined
    previously. The added part is the type projection, `()#T[C]`, that allows us to
    reference the type we've just defined.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`T[C]`的内部定义与我们之前定义的类型别名类似。增加的部分是类型投影`()`#T[C]`，它允许我们引用刚刚定义的类型。'
- en: Using types to define domain constraints
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型定义域约束
- en: We've already seen how simple types can be used to express domain constraints,
    as discussed in the *Path-dependent types* section. We implemented a lock that
    guaranteed at compile time that it is only possible to open and close it with
    the key created for this specific lock. We will conclude our study of type parameters
    and higher kinded types with two examples.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用简单类型来表示域约束，正如在*路径依赖类型*部分所讨论的。我们实现了一个锁，它在编译时保证了只能使用为这个特定锁创建的钥匙来打开和关闭它。我们将通过两个示例来结束对类型参数和高阶类型的探讨。
- en: The first example will demonstrate an application of phantom types to create
    another version of the lock, which can guarantee the safety of state transitions
    at compile time without the use of inheritance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例将演示如何使用幻影类型创建锁的另一个版本，该版本可以在不使用继承的情况下在编译时保证状态转换的安全性。
- en: The second example will show how self-recursive types can help to constrain
    possible subtyping.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例将展示自递归类型如何帮助约束可能的子类型。
- en: Phantom types
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幻影类型
- en: 'The *phantom type* in Scala is a type that is never instantiated at runtime.
    Because of this, it is only useful at compile time to express domain constraints
    similar to (generalized) type constraints. To get a feeling for how this works,
    let''s imagine the following situation—we have an abstraction of `Lock`, that
    has already been implemented in different ways via the use of inheritance:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的*幻影类型*是一种在运行时永远不会实例化的类型。正因为如此，它仅在编译时有用，用于表达类似于（泛化）类型约束的领域约束。为了了解它是如何工作的，让我们想象以下情况——我们有一个`Lock`的抽象，它已经通过继承的不同方式实现了：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We would like to encode in the type system that only the following state transitions
    are allowed for any locks:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在类型系统中编码，只有以下状态转换对于任何锁是允许的：
- en: open -> closed
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: open -> closed
- en: closed -> open
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: closed -> open
- en: closed -> broken
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: closed -> broken
- en: open -> broken
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: open -> broken
- en: 'As we already have an existing hierarchy, we cannot easily model these state
    transitions with inheritance by extending `Lock` with `ClosedLock`, `OpenLock`,
    and `BrokenLock`. Instead, we will use the phantom types `Open`, `Closed`, and
    `Broken` to model the states (we will define `Lock` from scratch later, just to
    avoid cluttering the example with unnecessary details):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个现有的层次结构，我们无法通过将`ClosedLock`、`OpenLock`和`BrokenLock`扩展到`Lock`上来轻松地用继承来模拟这些状态转换。相反，我们将使用幻影类型`Open`、`Closed`和`Broken`来模拟状态（我们稍后将从零开始定义`Lock`，以避免在示例中添加不必要的细节）：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can assign this `State` to a `Lock`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个`State`赋值给`Lock`：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And define our state transitioning methods using type constraints:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用类型约束定义我们的状态转换方法：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can bring any lock to the broken state so that the `break` method does not
    have any constraints defined on it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何锁带到broken状态，这样`break`方法就不会有任何约束定义。
- en: 'The transition to the `Open` state is only available from the `Closed` state,
    and we encode this fact with the existential type (that, nevertheless, should
    be available for successful compilation), which is a subclass of the current `State`
    of the lock and a superclass of `Closed`. The only possibility to satisfy type
    constraint is for `State` to be equal to `Closed`. This is done in the same way
    that it is only possible way to call the `close` method and satisfy type constraints
    by having `Lock` in the `Open` state. Let''s see how the compiler reacts in different
    cases:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Closed`状态转换到`Open`状态仅从`Closed`状态可用，我们通过存在类型（尽管如此，它应该可用于成功编译）来编码这一事实，它是锁当前`State`的子类，也是`Closed`的超类。满足类型约束的唯一可能性是`State`等于`Closed`。这是通过只有一种可能的方式来调用`close`方法并满足类型约束，即让`Lock`处于`Open`状态来完成的。让我们看看编译器在不同情况下的反应：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The compiler refuses to accept calls that would lead to inappropriate state
    transitions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器拒绝接受会导致不适当状态转换的调用。
- en: 'We can also provide an alternative implementation by using generalized type
    constraints:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用泛化类型约束来提供一个替代实现：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It is arguable that the generalized syntax conveys the intention much better
    as it almost reads as `State should be equal to Closed` in the first case or `State
    should be equal to Open` in the second case.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有争议的是，泛化语法更好地传达了意图，因为它在第一种情况下几乎可以读作“状态应等于Closed”，在第二种情况下则读作“状态应等于Open”。
- en: 'Let''s see how the compiler reacts to our new implementation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编译器对我们新实现有何反应：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Obviously, the error messages are also better for the implementation with generalized
    type constraints.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对于具有泛化类型约束的实现，错误信息也更好。
- en: Self-recursive types
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自递归类型
- en: 'Let''s recall different implementations inheriting from a single trait from
    the previous example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前示例中从单个特质继承的不同实现：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We will now extend `Lock` with an `open` method, which should return the same
    type of `Lock` and let our implementations serve as type parameters:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将扩展`Lock`以包含一个`open`方法，该方法应返回与`Lock`相同的类型，并让我们的实现作为类型参数：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The realization is not very interesting for now—the important part is that it
    returns the same type as the instance it was called on.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个实现并不很有趣——重要的是它返回了与调用实例相同的类型。
- en: 'Now, with this implementation, there is an issue that we can use it with something
    that is not a `Lock` at all:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个实现，有一个问题是我们可以用它来与根本不是`Lock`的东西一起使用：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Naturally, we don''t want to allow this! We want to constrain our type parameter
    so that it is a subtype of `Lock`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想允许这样做！我们希望约束我们的类型参数，使其成为`Lock`的子类型：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'But unfortunately, this won''t compile because the `Lock` takes a type parameter
    that is absent in the preceding definition. We need to provide that type parameter.
    What should it be? Logically, the same type as we used to parameterize the `Lock`—`E`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，这无法编译，因为`Lock`接受了一个在先前定义中不存在的类型参数。我们需要提供那个类型参数。它应该是什么？逻辑上，与用来参数化`Lock`的相同类型——`E`：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The type parameter looks a bit weird because it refers to itself recursively.
    This way of defining a type is called a **self-recursive type parameter** (or
    sometimes an F-bounded type polymorphism).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数看起来有点奇怪，因为它以递归的方式引用自身。这种定义类型的方式被称为**自递归类型参数**（有时也称为F界限类型多态）。
- en: 'Now, we can only parameterize `Lock` by the type, which is itself a `Lock`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只能通过类型来参数化`Lock`，而这个类型本身也是一个`Lock`：
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'But unfortunately, we can still mess things up by defining the wrong subtype
    as a type parameter:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，我们仍然可以通过定义错误的子类型作为类型参数来搞砸事情：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Therefore, we need to define another constraint that will say that the type
    parameter should refer to the type itself, not just any `Lock`. We already know
    that there is a self-type that can be used for that:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要定义另一个约束，表明类型参数应该引用类型本身，而不仅仅是任何`Lock`。我们已经知道有一个自类型可以用于此：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Nice! We've just defined a `Lock` trait that can only be parameterized with
    classes that extend this trait and only by the class itself. We've done this by
    using a combination of the self-recursive type parameter and the self-type.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们刚刚定义了一个只能用扩展此特质的类以及自身来参数化的`Lock`特质。我们通过使用自递归类型参数和自类型组合实现了这一点。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The type system is one of the key components of the Scala language. It allows
    the developer to express expectations about the behavior of the program, which
    can then be checked at compile time. This reduces the number of tests needed to
    verify the correctness of the solution and the possibility of runtime errors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统是Scala语言的关键组件之一。它允许开发者表达对程序行为的期望，这些期望可以在编译时进行检查。这减少了验证解决方案正确性所需的测试数量，以及运行时错误的可能性。
- en: Usually, strictly typed languages are associated with verbose code. Normally,
    this is not the case with Scala because of its powerful type inference mechanism.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，严格类型化的语言与冗长的代码相关联。通常，Scala并不是这样，因为它拥有强大的类型推断机制。
- en: Scala allows you to define very narrow types containing a single value as well
    as much wider types, even those represented as a combination of other types.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Scala允许你定义非常窄的类型，只包含单个值，以及更宽的类型，甚至那些表示为其他类型组合的类型。
- en: The type definition can be made more precise by using type constraints, type
    parameters, and variance.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类型约束、类型参数和变异性，可以使类型定义更加精确。
- en: We also looked at some examples of how the type system can be used to express
    domain constraints.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了一些如何使用类型系统来表示领域约束的示例。
- en: Needless to say, Scala's ecosystem is much richer than what we have covered
    here. Some open source libraries offer advanced type constraints that are expressed
    as refined types, fixpoint types, or tagged types. Other libraries, such as shapeless,
    provide the possibility for type-level programming, which allows you to express
    and verify quite complex program logic at compile time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，Scala的生态系统比我们这里所涵盖的丰富得多。一些开源库提供了以精炼类型、定点类型或标记类型表达的高级类型约束。其他库，如shapeless，提供了类型级别编程的可能性，这允许你在编译时表达和验证相当复杂的程序逻辑。
- en: Questions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which type constraints can you name?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能说出哪些类型约束？
- en: What implicit type constraints are added to a type if there are no type constraints
    defined on it by the developer?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果开发者在类型上没有定义任何类型约束，那么会添加哪些隐式类型约束？
- en: Which operators can be used to refer to the nested type of some type?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些运算符可以用来引用某些类型的嵌套类型？
- en: Which type can be used as an infix type?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型可以用作中缀类型？
- en: Why is the use of structural types discouraged in Scala?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在Scala中不建议使用结构化类型？
- en: What is expressed via variance?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过变异性表达了什么？
- en: Further reading
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Mads Hartmann, and Ruslan Shevchenko, *Professional Scala*: You will learn how
    to write type-safe code concisely and expressively in an environment that lets
    you build for the JVM, browser, and more.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mads Hartmann 和 Ruslan Shevchenko 著，《Professional Scala》：你将学习如何在允许你为 JVM、浏览器等构建的环境下，简洁且富有表现力地编写类型安全的代码。
- en: Vikash Sharma, *Learning Scala Programming: **Learn how to write scalable and
    concurrent programs in Scala*, a language that grows with you.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vikash Sharma 著，《Learning Scala Programming》：**学习如何在 Scala 中编写可扩展和并发程序**，这是一种与你一同成长的编程语言。
