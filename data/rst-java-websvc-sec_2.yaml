- en: Chapter 2. The Importance of Securing Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。保护Web服务的重要性
- en: Look at you; you have made it to Chapter 2; congratulations! This chapter is
    quite important because it is related to a concept that is implicit in software,
    which is **security**. This is very important because software is used by companies
    and people like us. Sometimes, we share very important and confidential information
    through software, and that is why this topic becomes so important for everybody.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你，你已经到了第2章；恭喜！这一章非常重要，因为它与软件中隐含的概念相关，即**安全性**。这非常重要，因为软件被公司和像我们这样的人使用。有时，我们通过软件共享非常重要和机密的信息，这就是为什么这个主题对每个人都如此重要。
- en: In this chapter, we will take you through the basic aspects related to the management
    of security in computer systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带您了解与计算机系统安全管理相关的基本方面。
- en: We will explore and implement each of the different security mechanisms and
    scenarios in which they can be used.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索和实施不同的安全机制以及可以使用它们的场景。
- en: Also, you'll learn how to use a protocol analyzer. This will allow us to demonstrate
    how an attack can be performed and determine the impact of this attack when it
    achieves its target, in this case, our information. Also, you will be able to
    imagine more options to implement security in web services.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将学习如何使用协议分析器。这将使我们能够演示攻击如何执行以及攻击达到目标时的影响，本例中是我们的信息。此外，您将能够想象更多的选项来在Web服务中实施安全性。
- en: As everything needs practice, you will go through a simple example of code to
    learn the differences between authentication and authorization. Get ready for
    an interesting and useful topic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切都需要实践，您将通过一个简单的代码示例了解认证和授权之间的区别。准备好迎接一个有趣且有用的主题。
- en: 'In this chapter, we will cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Understanding the importance of security management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解安全管理的重要性
- en: Exploring and implementing the different available mechanisms of security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和实施不同的安全机制
- en: Using a protocol analyzer to intercept requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协议分析器拦截请求
- en: Understanding the difference between authentication and authorization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解认证和授权之间的区别
- en: The importance of security
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性的重要性
- en: The management of security is one of the main aspects to consider when designing
    applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，安全管理是需要考虑的主要方面之一。
- en: 'No matter what, neither the functionality nor the information of organizations
    can be exposed to all users without any kind of restriction. Consider the case
    of a human resource management application that allows you to consult the wages
    of employees, for example: if the company manager needs to know the salary of
    one of their employees, it is not something of great importance. However, in the
    same context, imagine that one of the employees wants to know the salary of their
    colleagues; if access to this information is completely open, it can generate
    problems among employees with varied salaries.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，组织的功能或信息都不能对所有用户完全开放而没有任何限制。考虑一个人力资源管理应用程序的情况，它允许您查询员工的工资，例如：如果公司经理需要了解其员工的工资，这并不是什么重要的事情。然而，在同样的情境中，想象一下其中一名员工想要了解其同事的工资；如果对这些信息的访问完全开放，可能会在工资不同的员工之间产生问题。
- en: An even more critical example can be the case where the bank XYZ increases a
    bank balance every time a customer or a third party makes a deposit into one of
    their accounts using an ATM. The IT manager envisions that this functionality
    could be common, and decides to implement it as a web service. Right now, this
    functionality is limited to bank users logged in to the application that uses
    this web service. Suppose that the visions of the future of the IT manager come
    true, and this functionality is now required from an ATM; raising this requirement
    quickly indicates that such functionality is implemented and can be used by invoking
    the web service. So far, there may be no security loopholes since ATMs are likely
    to have a security system that controls access, and thus operating system access
    to the functionality of the web service is also indirectly controlled.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更为关键的例子可能是银行XYZ每当客户或第三方使用ATM向其账户之一存款时都会增加银行余额。IT经理设想这种功能可能会很普遍，并决定将其实施为Web服务。目前，此功能仅限于登录到使用此Web服务的应用程序的银行用户。假设IT经理对未来的设想成真，并且现在需要从ATM进行此功能；提出这一要求迅速表明此功能已实施，并且可以通过调用Web服务来使用。到目前为止，可能没有安全漏洞，因为ATM可能具有控制访问的安全系统，因此操作系统对Web服务功能的访问也间接受到控制。
- en: Now, imagine that the company ABC wants a similar functionality to increase
    the balance in one of its employee's bank account by an *x* amount in recognition
    of some kind of contribution to the company. What happens to the functionality
    of the web service? Do you think you can again trust the application that handles
    its own security scheme to control access to its functionality? Even if we do
    trust this mechanism, what if the request is intercepted by a sniffer? Then, anyone
    who knows how to perform the request may increase the balance. These questions,
    when answered, throw in the response in quite a logical way. Exposed, these scenarios
    now sound quite logical so that whoever authenticates the user to have access
    to this functionality is the web service, and as such, should be entrusted with
    the management scheme security systems under all circumstances. It doesn't matter
    if invocations are from the organization itself or from an external institution;
    security control must be present in order to expose a sensitive functionality
    such as the one we just outlined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，公司ABC想要一个类似的功能，以增加其员工银行账户中的余额，以表彰其对公司的某种贡献。Web服务的功能会发生什么变化？您认为您可以再次信任处理自己安全方案的应用程序来控制对其功能的访问吗？即使我们信任这种机制，如果请求被嗅探器拦截会怎么样？那么，任何知道如何执行请求的人都可以增加余额。这些问题在回答时以相当合乎逻辑的方式得到了解答。因此，这些场景现在听起来相当合乎逻辑，因此，认证用户以访问此功能的是Web服务，并且应该在任何情况下都信任其管理方案安全系统。无论调用是来自组织本身还是来自外部机构，都必须存在安全控制，以暴露像我们刚刚概述的这样的敏感功能。
- en: When sharing existing information or functionality through web services, it
    is well known that we don't depend on programming languages, architectures, or
    system platforms to interact with. This gives us flexibility and saves us from
    having to rewrite the existing functionality. Going further, we should understand
    that these features have an impact on data confidentiality, as we are going to
    share information and/or functionality with entities or systems. This way, we
    can accomplish the business objectives and definitely prevent intruders from reading
    our information; or even worse, a third party not authorized has access to functionalities
    exposed by our services. Hence, access to them must be rigorously analyzed and
    our exposed services must be correctly ensured.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过Web服务共享现有信息或功能时，众所周知，我们不依赖于编程语言、架构或系统平台进行交互。这使我们具有灵活性，并使我们免于重写现有功能。此外，我们应该了解这些功能对数据机密性的影响，因为我们将与实体或系统共享信息和/或功能。这样，我们可以实现业务目标，并确保入侵者无法阅读我们的信息；甚至更糟的是，未经授权的第三方可以访问我们的服务所暴露的功能。因此，对它们的访问必须进行严格分析，并且我们暴露的服务必须得到正确的保障。
- en: Security management options
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全管理选项
- en: 'Java provides some options for security management. Right now, we will explain
    some of them and demonstrate how to implement them. All authentication methods
    are practically based on credential delivery from the client to the server. There
    are several methods to perform this, which are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一些安全管理选项。现在，我们将解释其中一些，并演示如何实现它们。所有认证方法实际上都基于客户端向服务器传递凭据。有几种方法可以执行这一点，包括：
- en: BASIC authentication
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证
- en: DIGEST authentication
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要认证
- en: CLIENT CERT authentication
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端证书认证
- en: Using API keys
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API密钥
- en: Security management in applications built with Java, including the ones with
    RESTful web services, always rely on JAAS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java构建的应用程序的安全管理，包括具有RESTful Web服务的应用程序，始终依赖于JAAS。
- en: '**Java Authentication and Authorization Service** (**JAAS**) is a framework
    that is part of Java Platform Enterprise Edition. Hence, it is the default standard
    to handle an application''s security in Java; it allows you to implement authorization,
    and it allows authentication controls over applications with the purpose of protecting
    resources that belong to the application. If you want to know more about JAAS,
    you can check out the following link:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java身份验证和授权服务（JAAS）是Java平台企业版的一部分。因此，它是处理Java应用程序安全性的默认标准；它允许您实现授权，并允许对应用程序进行身份验证控制，以保护属于应用程序的资源。如果您想了解更多关于JAAS的信息，可以查看以下链接：
- en: '[http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html)'
- en: If you don't want to use JAAS, of course it is always possible to create our
    own implementation to handle securities, but it would be hard. So, why don't we
    save ourselves some time, effort, and peace by implementing this useful technology?
    It is recommended to use standard implementations whenever possible. In our development
    exercise, we will use JAAS for the first three methods of authentication.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用JAAS，当然可以创建我们自己的实现来处理安全性，但这将很困难。那么，为什么不通过实现这项有用的技术来节省时间、精力和平静呢？建议尽可能使用标准实现。在我们的开发练习中，我们将使用JAAS来进行前三种认证方法。
- en: Authorization and authentication
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权和认证
- en: When you these terms, it is very easy to get confused, but they have different
    meanings when you have a security system approach. In order to clarify these terms,
    we will explain them in this section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用这些术语时，很容易感到困惑，但在安全系统方法中，它们具有不同的含义。为了澄清这些术语，我们将在本节中对它们进行解释。
- en: Authentication
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证
- en: In a nutshell, this term refers to *who you are*. It is the process to identify
    a user, usually through their *username* and *password*. When we use this concept,
    we are trying to ensure the identity of the user and we verify the identity the
    user claims to be. Also, it doesn't have anything to do with the access rights
    the user has.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个术语指的是*您是谁*。这是识别用户的过程，通常通过他们的*用户名*和*密码*。当我们使用这个概念时，我们试图确保用户的身份，并验证用户声称的身份。此外，这与用户的访问权限无关。
- en: 'Security research has specified a list of factors that should be verified in
    order to achieve positive authentication. This list contains three elements, where
    it is very common to use two of them, but preferably we should use all of them.
    These elements are the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安全研究已经指定了一系列应该验证的因素，以实现积极的身份验证。这个清单包含三个元素，通常使用其中两个是很常见的，但最好使用全部。这些元素包括：
- en: '**Knowledge factors**: This element implies something the user **knows**, for
    example, a password, pass phrase, or personal identification number (PIN). Another
    example is challenge response, where the user must answer a question, software
    token, or phone serving as a software token.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识因素**：这个元素意味着用户**知道**的东西，例如密码、口令或个人识别号码（PIN）。另一个例子是挑战响应，用户必须回答问题，软件令牌或作为软件令牌的电话。'
- en: '**Ownership factors**: This is something the user *has*, for example, a wrist
    band (in case of physical authentication), ID card, security token, or cell phone
    with a built-in hardware token.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有权因素**：这是用户*拥有*的东西，例如手环（在物理身份验证的情况下）、身份证、安全令牌或带有内置硬件令牌的手机。'
- en: '**Inherence factors**: This is something the user *is* or *does*, for example,
    fingerprint or retinal pattern, DNA sequence, signature, face, voice, unique bio-electric
    signals, or other biometric identifiers.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固有因素**：这是用户*是*或*做*的东西，例如指纹或视网膜图案、DNA序列、签名、面部、声音、独特的生物电信号或其他生物识别标识符。'
- en: Authorization
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权
- en: In a few words, this term refers to *what you can do*. It is the process of
    giving a user permission to do or have something. When we talk about software,
    we have a system administrator that is in charge of defining the system which
    users are allowed to access and what the privileges of use are (such as access
    to which file directories, access period, amount of allocated storage space, and
    so forth).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个术语指的是*您可以做什么*。这是给用户权限做或拥有某些东西的过程。当我们谈论软件时，我们有一个系统管理员负责定义用户被允许访问的系统以及使用权限（例如访问哪些文件目录，访问期限，分配的存储空间等）。
- en: Authorization is often seen as both the introductory setting up of permissions
    by a system administrator and the checking of the permission values that have
    already been set up when a user is getting access.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 授权通常被视为系统管理员设置权限的初始设置，以及在用户获取访问权限时检查已经设置的权限值。
- en: Access control
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制
- en: 'A very common use of authentication and authorization is access control. A
    computer system that is supposed to be used only by authorized users must attempt
    to detect and reject unauthorized users. Access is controlled by persisting on
    an authentication process to establish the user''s identity with a certain level
    of confidence, also conferring privileges specified for that identity. Let''s
    name some examples of access control involving authentication in different scenarios,
    such as the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权的一个非常常见的用途是访问控制。一个计算机系统只能被授权用户使用，必须试图检测和拒绝未经授权的用户。访问由坚持身份验证过程来控制，以建立用户的身份并赋予特定身份的特权。让我们举一些涉及不同场景中身份验证的访问控制的例子，例如：
- en: Calling for photo ID when a contractor first arrives at a house to do some work
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当承包商第一次到达房屋进行工作时要求身份证照片
- en: Implementing captcha as a way of verification that a user is a human being and
    not a computer program
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施验证码作为验证用户是人类而不是计算机程序的一种方式
- en: When using a **One Time Password** (**OTP**) obtained on telenetwork-enabled
    devices such as mobile phones as an authentication password/PIN
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用像手机这样的电信网络设备获得的**一次性密码**（**OTP**）作为身份验证密码/PIN时
- en: A computer program that uses a blind credential in order to authenticate to
    another program
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个计算机程序使用盲凭证来验证另一个程序
- en: When you enter a country with a passport
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您用护照进入一个国家时
- en: When you log in to a computer
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您登录计算机时
- en: When a service uses a confirmation e-mail to verify ownership of an e-mail address
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个服务使用确认电子邮件来验证电子邮件地址的所有权
- en: Using an Internet banking system
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互联网银行系统
- en: When you withdraw cash from an ATM
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您从ATM取款时
- en: Sometimes, the ease of access is adjusted against the strictness of access checks.
    For example, a small transaction usually doesn't require a signature of the authenticated
    person as proof of the transaction's authorization.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，便利性会与访问检查的严格性相抵触。例如，一个小额交易通常不需要经过认证人的签名作为交易授权的证明。
- en: However, security experts argue that it is impossible to prove the user's identity
    with absolute certainty. It is only possible to apply a set of tests which, if
    passed, have been previously declared as a minimum to confirm the identity. The
    problem lies in how to determine which tests are enough; it depends on the company
    to determine this set.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，安全专家认为不可能绝对确定用户的身份。只能应用一系列测试，如果通过，就被先前声明为确认身份的最低要求。问题在于如何确定哪些测试足够；这取决于公司来确定这个集合。
- en: Transport layer security
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层安全
- en: 'In this section, we highlight some of the main features of TLS:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们强调了TLS的一些主要特点：
- en: Its predecessor is **Secure Sockets Layer** (**SSL**)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的前身是**安全套接字层**（**SSL**）
- en: It is a cryptographic protocol
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个加密协议
- en: It provides security communication over the Internet
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了互联网上的安全通信
- en: It authenticates the counterpart through X.509 certificates (asymmetric cryptography)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过X.509证书（非对称加密）对对方进行身份验证
- en: It allows client-server applications to communicate over the network and prevents
    eavesdropping and tampering
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许客户端-服务器应用程序在网络上进行通信，并防止窃听和篡改
- en: TLS is often implemented on top of the Transport layer protocols
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS通常实现在传输层协议之上
- en: It encapsulates application-specific protocols such as HTTP, FTP, SMTP, NNTP,
    and XMPP
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它封装了特定于应用程序的协议，如HTTP、FTP、SMTP、NNTP和XMPP
- en: The use of TLS should be delegated, especially when credentials, updates, deletions,
    and any kind of value transactions are performed
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该委托使用TLS，特别是在执行凭据、更新、删除和任何类型的价值交易时
- en: The overhead of TLS is very low on modern hardware, with a little increase of
    latency, but this represents more safety for the end user
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS在现代硬件上的开销非常低，延迟略有增加，但这为最终用户提供了更多的安全性
- en: Basic authentication by providing user credentials
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过提供用户凭据进行基本身份验证
- en: Possibly, basic authentication is one of the most used techniques in all types
    of applications. The user, before gaining functionality over the application,
    is requested to enter a username and password. Both are validated in order to
    verify whether the credentials are correct (they belong to an application user).
    We are 99 percent sure you have performed this technique at least once, maybe
    through a customized mechanism, or if you have used the JEE platform, probably
    through JAAS. This kind of control is known as **basic authentication**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，基本身份验证是所有类型应用程序中最常用的技术之一。在用户获得应用程序功能之前，会要求用户输入用户名和密码。两者都经过验证，以验证凭据是否正确（它们属于应用用户）。我们99%确定您至少曾经执行过这种技术，也许是通过自定义机制，或者如果您使用了JEE平台，可能是通过JAAS。这种控制被称为**基本身份验证**。
- en: The main problem with this security implementation is that credentials are propagated
    in a plain way from the client to the server. This way, any sniffer could read
    the sent packages over the network. We will consider an example using a tool named
    Wireshark; it is a protocol analyzer that will show this problem. For installation,
    we can go to the link [http://www.wireshark.org/download.html](http://www.wireshark.org/download.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安全实现的主要问题是凭据以明文方式从客户端传播到服务器。这样，任何嗅探器都可以读取网络上传送的数据包。我们将考虑一个使用名为Wireshark的工具的示例；它是一个协议分析器，将显示这个问题。有关安装，我们可以转到链接[http://www.wireshark.org/download.html](http://www.wireshark.org/download.html)。
- en: The installation is pretty basic (click on **Next** all the way). For this reason,
    we will not show screenshots of these steps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装非常基本（一路点击“下一步”）。因此，我们不会展示这些步骤的截图。
- en: Now, we are going to modify the project from [Chapter 1](ch01.html "Chapter 1. Setting
    Up the Environment"), *Setting Up the Environment*, where the user tries to invoke
    any of the functions of the web service. The user will be requested to enter a
    username and password; once these are verified, the user will have access to the
    web service functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改[第1章](ch01.html "第1章。设置环境")中的项目，*设置环境*，在该项目中，用户尝试调用Web服务的任何功能。用户将被要求输入用户名和密码；一旦这些验证通过，用户将可以访问Web服务功能。
- en: 'In order to have a working example, let''s start our application server JBoss
    AS 7; then, go to the `bin` directory and execute the file `add-user.bat` (the
    `.sh` file for UNIX users). Finally, we will create a new user as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个可工作的示例，让我们启动我们的应用服务器JBoss AS 7；然后，转到“bin”目录并执行文件“add-user.bat”（对于UNIX用户是“.sh”文件）。最后，我们将创建一个新用户，如下所示：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭据进行基本身份验证](img/0109OS_02_01.jpg)'
- en: The most important thing here is that you should select `Application User` in
    the first question and assign it an `admin` role. This will match with the information
    defined in the `web.xml` file, which will be explained later when we implement
    securities inside our application. As a result, we will have a new user in the
    `JBOSS_HOME/standalone/configuration/application - users.properties` file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的是，您应该在第一个问题中选择“应用用户”并为其分配“管理员”角色。这将与“web.xml”文件中定义的信息相匹配，稍后在我们应用程序内实现安全性时将进行解释。结果，我们将在“JBOSS_HOME/standalone/configuration/application
    - users.properties”文件中拥有一个新用户。
- en: 'JBoss is already set with a default security domain called `other`; this domain
    uses the information stored in the file we mentioned earlier in order to authenticate.
    Right now, we will configure the application to use this security domain inside
    the folder `WEB-INF` from the `resteasy-examples` project. Let''s create a file
    named `jboss-web.xml` with the following content:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss已经设置了一个名为“other”的默认安全域；此域使用我们前面提到的文件中存储的信息进行身份验证。现在，我们将配置应用程序以在“resteasy-examples”项目的“WEB-INF”文件夹中使用此安全域。让我们创建一个名为“jboss-web.xml”的文件，其中包含以下内容：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alright, let''s configure the file `web.xml` in order to aggregate the security
    constraints. In the following block of code, you will see in bold what you should
    add:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们配置文件“web.xml”以聚合安全约束。在下面的代码块中，您将看到应添加的内容。
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From a terminal, let''s go to the home folder of the `resteasy-examples` project
    and execute `mvn jboss-as:redeploy`. Now, we will test our web service as we did
    in [Chapter 1](ch01.html "Chapter 1. Setting Up the Environment"), *Setting Up
    the Environment*, using SOAP UI. We will perform a request using the `POST` method
    to the URL `http://localhost:8080/resteasy-examples/services/person/` with the
    following XML:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端，让我们转到“resteasy-examples”项目的主文件夹，并执行“mvn jboss-as:redeploy”。现在，我们将测试我们的Web服务，就像我们在[第1章](ch01.html
    "第1章。设置环境")中所做的那样，*设置环境*，使用SOAP UI。我们将使用“POST”方法向URL“http://localhost:8080/resteasy-examples/services/person/”发出请求，并使用以下XML：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We obtain the following response:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下响应：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭据进行基本身份验证](img/0109OS_02_02.jpg)'
- en: 'SOAP UI shows us the HTTP 401 error, which means that the request wasn''t authorized.
    This is because we performed the request without delivering the credentials to
    the server. In order to do this, we have to click on the (**…**) button that is
    located in the left-bottom spot of SOAP UI and enter the user''s credentials we
    just created, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP UI向我们显示了HTTP 401错误，这意味着请求未经授权。这是因为我们在没有向服务器提供凭据的情况下执行了请求。为了做到这一点，我们必须点击SOAP
    UI左下角的(**…**)按钮，并输入我们刚刚创建的用户凭据，如下截图所示：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭据进行基本认证](img/0109OS_02_03.jpg)'
- en: Now is the time to enable our traffic analyzer. Let's start Wireshark and set
    it to analyze the traffic inside the loopback address. From the **Main** menu,
    navigate to **Capture** | **Interfaces**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是启用我们的流量分析器的时候了。让我们启动Wireshark，并设置它来分析环回地址内的流量。从**主**菜单，导航到**捕获** | **接口**。
- en: Check the option **lo0**, as shown in the following screenshot, and then click
    on the **Start** button. This way, all traffic that goes through the address 127.0.0.1
    or its equivalent localhost will be intercepted for our analysis.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选**lo0**选项，如下截图所示，然后点击**开始**按钮。这样，所有通过地址127.0.0.1或其等效的本地主机的流量都将被拦截进行分析。
- en: 'Also, in the field `Filter`, we will type `http` just to intercept the HTTP
    request and response, as shown in the screenshot that follows later:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在“过滤器”字段中，我们将输入“http”，以拦截HTTP请求和响应，如后面的截图所示：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_04.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭据进行基本认证](img/0109OS_02_04.jpg)'
- en: 'Have a look at the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下截图：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭据进行基本认证](img/0109OS_02_05.jpg)'
- en: 'Once we have done this, we will perform the request operation from SOAP UI.
    Once again, SOAP UI shows us a HTTP 201 message; this time, the request is successfully
    processed. You can see the following columns of information in Wireshark:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，我们将从SOAP UI执行请求操作。再次，SOAP UI向我们显示了一个HTTP 201消息；这次，请求成功处理。您可以在Wireshark中看到以下信息列：
- en: '**No**: This column identifies the request or response in a unique way'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编号**：这一栏以唯一方式标识了请求或响应'
- en: '**Time**: This column identifies the time to execute the operation'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：这一栏标识了执行操作所需的时间'
- en: '**Source**: This column identifies the address where requests/responses are
    originated'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**：这一栏标识了请求/响应的发起地址'
- en: '**Destination**: This column identifies the target IP address to perform a
    HTTP request/response'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地**：这一栏标识了执行HTTP请求/响应的目标IP地址'
- en: '**Protocol**: This column identifies the protocol where requests/responses
    are performed'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议**：这一栏标识了请求/响应所执行的协议'
- en: '**Length**: This column identifies the request/response length'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度**：这一栏标识了请求/响应的长度'
- en: '**Info**: This column identifies information related to the request/response'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：这一栏标识了与请求/响应相关的信息'
- en: 'Now, it is time to watch the information traffic on Wireshark, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在Wireshark上观察信息流量了，如下所示：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭据进行基本认证](img/0109OS_02_06.jpg)'
- en: Notice how Wireshark shows us we are performing a POST (info) operation using
    the protocol HTTP with an XML string (protocol) to the target address `127.0.0.1`
    (destination). Also, you can read the username and password. Hence, this method
    is not very safe for security implementation because anyone can access this information
    and perform a phishing attack.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Wireshark如何显示我们正在使用HTTP协议执行POST（信息）操作，使用XML字符串（协议）发送到目标地址`127.0.0.1`（目的地）。此外，您可以读取用户名和密码。因此，这种方法对安全实施来说并不是很安全，因为任何人都可以访问这些信息并进行网络钓鱼攻击。
- en: 'You can find the source code for this chapter at the following URL:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下URL找到本章的源代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication)'
- en: Digest access authentication
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要访问认证
- en: This authentication method makes use of a hash function to encrypt the password
    entered by the user before sending it to the server. This, obviously, makes it
    much safer than the basic authentication method, in which the user's password
    travels in plain text that can be easily read by whoever intercepts it. To overcome
    such drawbacks, digest md5 authentication applies a function on the combination
    of the values of the username, realm of application security, and password. As
    a result, we obtain an encrypted string that can hardly be interpreted by an intruder.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种认证方法利用哈希函数对用户输入的密码进行加密，然后再发送到服务器。显然，这比基本认证方法要安全得多，基本认证方法中，用户的密码以明文形式传输，任何拦截它的人都可以轻易读取。为了克服这些缺点，摘要md5认证对用户名、应用安全领域和密码的值进行组合，并应用一个函数。结果，我们得到一个加密字符串，几乎无法被入侵者解释。
- en: To better understand this process, we will show you a simple explanation extracted
    from Wikipedia.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个过程，我们将向您展示一个简单的解释，摘自维基百科。
- en: An example with explanation
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个带解释的例子
- en: '*The following example was originally given in RFC 2617 and is expanded here
    to show the full text expected for each request and response. Note that only the
    `auth` (authentication) quality of protection code is covered—at the time of writing,
    only the Opera and Konqueror web browsers are known to support `auth-int` (authentication
    with integrity protection). Although the specification mentions HTTP Version 1.1,
    the scheme can be successfully added to the Version 1.0 server, as shown here.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下示例最初在RFC 2617中给出，这里扩展显示了每个请求和响应所期望的完整文本。请注意，此处仅涵盖了`auth`（身份验证）保护代码——在撰写本文时，已知只有Opera和Konqueror网络浏览器支持`auth-int`（带完整性保护的身份验证）。尽管规范提到了HTTP版本1.1，但该方案可以成功地添加到版本1.0服务器，如下所示。*'
- en: '*This typical transaction consists of the following steps:*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*此典型交易包括以下步骤：*'
- en: '*The client asks for a page that requires authentication but does not provide
    a username and password. Typically, this is because the user simply entered the
    address or followed a link to the page.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户端请求需要身份验证的页面，但未提供用户名和密码。通常，这是因为用户只是输入了地址或者点击了页面链接。*'
- en: '*The server responds with the 401 "Unauthorized" response code, providing the
    authentication realm and a randomly generated, single-use value called `nonce`.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务器以401“未经授权”的响应代码做出响应，提供身份验证领域和一个名为`nonce`的随机生成的一次性值。*'
- en: '*At this point, the browser will present the authentication realm (typically,
    a description of the computer or system being accessed) to the user and prompt
    for a username and password. The user may decide to cancel at this point.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*此时，浏览器将向用户呈现身份验证领域（通常是正在访问的计算机或系统的描述）并提示输入用户名和密码。用户可以决定在这一点上取消。*'
- en: '*Once a username and password have been supplied, the client resends the same
    request but adds an authentication header that includes the response code.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦提供了用户名和密码，客户端会重新发送相同的请求，但会添加一个包含响应代码的身份验证标头。*'
- en: '*In this example, the server accepts the authentication and the page is returned.
    If the username is invalid and/or the password is incorrect, the server might
    return the *401* response code and the client will prompt the user again.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，服务器接受了身份验证并返回了页面。如果用户名无效和/或密码不正确，服务器可能会返回*401*响应代码，客户端将再次提示用户。*'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A client may already have the required username and password without needing
    to prompt the user, for example, if they have previously been stored by a web
    browser.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可能已经具有所需的用户名和密码，而无需提示用户，例如，如果它们以前已被Web浏览器存储。
- en: If you want to know more about this mechanism, you can visit Wikipedia for the
    complete article following the link [http://en.wikipedia.org/wiki/Digest_access_authentication](http://en.wikipedia.org/wiki/Digest_access_authentication).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于这种机制的信息，可以访问维基百科，查看完整文章，链接如下[http://en.wikipedia.org/wiki/Digest_access_authentication](http://en.wikipedia.org/wiki/Digest_access_authentication)。
- en: You can also read the specification RFC 2617, which is available at [https://www.ietf.org/rfc/rfc2617.txt](https://www.ietf.org/rfc/rfc2617.txt).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以阅读规范RFC 2617，该规范可在[https://www.ietf.org/rfc/rfc2617.txt](https://www.ietf.org/rfc/rfc2617.txt)上找到。
- en: Now, let's test this mechanism in our example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的示例中测试这种机制。
- en: 'In order to start, we must ensure that the environment variable `JAVA_HOME`
    is already set and added to the `PATH` variable. So, you can ascertain this by
    typing the following command in a terminal:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们必须确保环境变量`JAVA_HOME`已经设置并添加到`PATH`变量中。因此，您可以通过在终端中输入以下命令来确定：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will display the information shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下截图中显示的信息：
- en: '![An example with explanation](img/0109OS_02_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![带解释的示例](img/0109OS_02_07.jpg)'
- en: This command shows us the Java version installed on our PC. In case you obtain
    an error instead of the previous output, you should create the environment variable
    `JAVA_HOME`, add it to the `PATH` variable, and repeat the verification.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令显示了我们PC上安装的Java版本。如果您获得的是错误而不是之前的输出，您应该创建环境变量`JAVA_HOME`，将其添加到`PATH`变量中，并重复验证。
- en: 'Now, in order to perform what we explained before, we need to generate a password
    for our example user. We have to generate the password using the parameters we
    talked about earlier—username, realm, and password. Let''s go to the directory
    of `JBOSS_HOME/modules/org/picketbox/main/` from a terminal and type the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了执行我们之前解释的内容，我们需要为我们的示例用户生成一个密码。我们必须使用我们之前讨论的参数——用户名、领域和密码来生成密码。让我们从终端进入`JBOSS_HOME/modules/org/picketbox/main/`目录，并输入以下内容：
- en: '`java -cp picketbox-4.0.7.Final.jar org.jboss.security.auth.callback.RFC2617Digest
    username MyRealmName password`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`java -cp picketbox-4.0.7.Final.jar org.jboss.security.auth.callback.RFC2617Digest
    username MyRealmName password`'
- en: 'We will obtain the following result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下结果：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Through this process, we obtain the encrypted password and use it in our password
    storage file (the `JBOSS_HOME/standalone/configuration/application-users.properties`
    file). We must replace the password in the file, and it will be used for the user
    `username`. We have to replace it because the old password doesn't contain the
    realm name information of the application. As an alternative, you can create a
    new user using the file `add-user.sh`; you just have to deliver the realm information
    when you are requested.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个过程，我们获得了加密密码，并在我们的密码存储文件（`JBOSS_HOME/standalone/configuration/application-users.properties`文件）中使用它。我们必须替换文件中的密码，并且它将用于用户`username`。我们必须替换它，因为旧密码不包含应用程序的领域名称信息。作为替代方案，您可以使用文件`add-user.sh`创建一个新用户；您只需在被请求时提供领域信息。
- en: 'In order to make our application work, we just need to make a little change
    in the `web.xml` file. We have to modify the `auth-method` tag, change the value
    `FORM` to `DIGEST`, and set the application realm name in the following way:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序工作，我们只需要在`web.xml`文件中进行一点修改。我们必须修改`auth-method`标签，将值`FORM`更改为`DIGEST`，并以以下方式设置应用程序领域名称：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s create a new security domain in JBoss so that we can manage the
    authentication mechanism `DIGEST`. On the `<security-domains>` section of the
    `JBOSS_HOME/standalone/configuration/standalone.xml` file, let''s add the following
    entry:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在JBoss中创建一个新的安全域，以便我们可以管理`DIGEST`身份验证机制。在`JBOSS_HOME/standalone/configuration/standalone.xml`文件的`<security-domains>`部分中，让我们添加以下条目：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, in the application, change the security domain name in the file `jboss-web.xml`,
    as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在应用程序中，更改文件`jboss-web.xml`中的安全域名称，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will change the authentication method from `BASIC` to `DIGEST` in the `web.xml`
    file. Also, we will enter the name of the security realm. All these changes must
    be applied in the tag `login-config` in the following way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`web.xml`文件中将身份验证方法从`BASIC`更改为`DIGEST`。此外，我们将输入安全域的名称。所有这些更改必须以以下方式应用于`login-config`标签：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, restart the application server and redeploy the application on JBoss.
    For this, execute the following command in the terminal command line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动应用服务器并在JBoss上重新部署应用程序。为此，在终端命令行中执行以下命令：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s enable the catching of traffic through Wireshark and test the web service
    again using SOAP UI. First, we should change the field `Authentication Type` from
    Global HTTP Settings to **SPNEGO/Kerberos**. A very useful trick is to tell SOAP
    UI not to use the basic authentication method. Once we execute the request, Wireshark
    will tell us the message shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过Wireshark启用流量捕获，并使用SOAP UI再次测试Web服务。首先，我们应该将`Authentication Type`字段从全局HTTP设置更改为**SPNEGO/Kerberos**。一个非常有用的技巧是告诉SOAP
    UI不要使用基本身份验证方法。一旦我们执行请求，Wireshark将告诉我们以下截图中显示的消息：
- en: '![An example with explanation](img/0109OS_02_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![带解释的示例](img/0109OS_02_08.jpg)'
- en: 'As shown in the screenshot, let''s first confirm that all the steps described
    earlier are performed in this authentication method. Let''s keep track using the
    **No** field in Wireshark:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如屏幕截图所示，让我们首先确认在此身份验证方法中执行了前面描述的所有步骤。让我们使用Wireshark中的**No**字段进行跟踪：
- en: In step 5, the request is performed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，执行请求。
- en: In step 7, the server returns an error message code HTTP 401 with the generated
    `nonce` value. The `nonce` value helps to avoid replay attacks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，服务器返回带有生成的`nonce`值的错误消息代码HTTP 401。`nonce`值有助于避免重放攻击。
- en: In step 9, the request is performed again. This time, the information required
    for authentication is included and all this information is encrypted in the same
    way we described earlier.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，再次执行请求。这次，所需的身份验证信息包括，并且所有这些信息都以与我们之前描述的相同的方式进行加密。
- en: Finally, in step 11, we obtain the response that tells us the request has been
    successfully executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第11步中，我们获得了响应，告诉我们请求已成功执行。
- en: As you will notice, this is a more secure authentication method, mainly used
    if you don't want the overhead of full transport security through TLS/SSL encryption.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，这是一种更安全的身份验证方法，主要用于如果您不想通过TLS/SSL加密进行完整传输安全的开销。
- en: 'You can find the source code for this chapter at the following URL:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下URL找到本章的源代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication)'
- en: Authentication through certificates
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过证书进行身份验证
- en: This is a mechanism in which a trust agreement is established between the server
    and the client through certificates. They must be signed by an agency established
    to ensure that the certificate presented for authentication is legitimate, which
    is known as CA.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种机制，通过该机制，在服务器和客户端之间建立了信任协议，通过证书进行。它们必须由一个旨在确保用于身份验证的证书是合法的机构签署，这就是所谓的CA。
- en: Let's imagine an application that uses this mechanism of security. When the
    client attempts to access a protected resource, instead of providing a username
    or password, it presents the certificate to the server. This is the certificate
    that contains the user information for authentication; in other words, the credentials,
    besides a unique private-public key pair. The server determines if the user is
    legitimate through the CA. Then, it verifies whether the user has access to the
    resource. Also, you should know that this authentication mechanism must use HTTPS
    as the communication protocol as we don't have a secure channel and anyone could
    steal the client's identity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个使用这种安全机制的应用程序。当客户端尝试访问受保护的资源时，它不是提供用户名或密码，而是向服务器呈现证书。这是包含用户信息用于身份验证的证书；换句话说，除了唯一的私钥-公钥对之外，还包括凭据。服务器通过CA确定用户是否合法。然后，它验证用户是否有权访问资源。此外，您应该知道，此身份验证机制必须使用HTTPS作为通信协议，因为我们没有安全通道，任何人都可以窃取客户端的身份。
- en: Now, we will show how to do this in our example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示如何在我们的例子中执行此操作。
- en: 'In our example, we turn ourselves into the CA; they are usually companies such
    as VERISIGN or others. However, as we want to save you money, we will do it this
    way. The first thing we need is a key for the CA (which is ourselves), and we
    will sign the certificates for the application server and users. As the purpose
    of this book is to explain how this method works and not how to generate certificates,
    we will not include all steps required to generate them, but we include them on
    GitHub at the following link:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们把自己变成了CA；它们通常是VERISIGN或其他公司。然而，由于我们想要为您节省金钱，我们将以这种方式进行。我们需要的第一件事是CA的密钥（也就是我们自己），我们将为应用服务器和用户签署证书。由于本书的目的是解释这种方法的工作原理，而不是如何生成证书，我们不会包括生成证书所需的所有步骤，但我们会在GitHub上的以下链接中包含它们：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication)'
- en: 'Alright, let''s start. First, copy the `server.keystore` and `server.trutstore`
    files to the folder directory `JBOSS_HOME/standalone/configuration/`. You can
    download these files from GitHub using the following link:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始。首先，将`server.keystore`和`server.trutstore`文件复制到文件夹目录`JBOSS_HOME/standalone/configuration/`中。您可以使用以下链接从GitHub下载这些文件：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates)'
- en: 'Now, as we mentioned before, this security mechanism requires our application
    server to use HTTPS as the communication protocol. So, we must enable HTTPS. Let''s
    add a connector in the `standalone.xml` file; look for the following line:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们之前提到的，此安全机制要求我们的应用程序服务器使用HTTPS作为通信协议。因此，我们必须启用HTTPS。让我们在`standalone.xml`文件中添加一个连接器；查找以下行：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following block of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码块：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we add the security domain, as shown:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加安全域，如下所示：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we need two files: `my-users.properties` and `my-roles.properties`;
    both are empty and located in the `JBOSS_HOME/standalone/configuration` path.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们需要两个文件：`my-users.properties`和`my-roles.properties`；两者都为空，并位于`JBOSS_HOME/standalone/configuration`路径中。
- en: 'We will add the `<user-data-constraint>` tag in the `web.xml` file in the following
    way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以以下方式在`web.xml`文件中添加`<user-data-constraint>`标签：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, change the authentication method to `CLIENT-CERT`, as shown:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更改身份验证方法为`CLIENT-CERT`，如下所示：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, change the security domain in the `jboss-web.xml` file in the following
    way:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`jboss-web.xml`文件中以以下方式更改安全域：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, restart the application server and redeploy the application with Maven
    using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动应用程序服务器，并使用以下命令使用Maven重新部署应用程序：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to test this authentication method, we will have to first perform
    some configurations in SOAP UI. First, let''s go to the installation directory,
    find the file `vmoptions.txt`, and add the following line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这种身份验证方法，我们首先必须在SOAP UI中执行一些配置。首先，让我们转到安装目录，找到文件`vmoptions.txt`，并添加以下行：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we will change the SSL settings of SOAP UI. For this, you have to navigate
    to **File** | **Preferences** from the principal menu.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更改SOAP UI的SSL设置。为此，您必须从主菜单中导航到**文件** | **首选项**。
- en: 'From the pop-up window, select the **SSL Settings** tab and enter the values
    shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从弹出窗口中，选择**SSL设置**选项卡，并输入以下截图中显示的值：
- en: '![Authentication through certificates](img/0109OS_02_09.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![通过证书进行身份验证](img/0109OS_02_09.jpg)'
- en: '**KeyStore** is the place where you should have copied the `.pfx` file. Note
    that **KeyStore Password** is `changeit` and check the option **requires client
    authentication**.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**KeyStore**是您应该复制`.pfx`文件的位置。请注意**KeyStore密码**为`changeit`，并选中**需要客户端身份验证**选项。'
- en: 'Now, we will test the modifications we just did; so, let''s enable the traffic
    analyzer and execute the request using SOAP UI again. Wireshark will show the
    information shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测试刚刚进行的修改；因此，让我们启用流量分析器，并再次使用SOAP UI执行请求。Wireshark将显示以下截图中显示的信息：
- en: '![Authentication through certificates](img/0109OS_02_10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![通过证书进行身份验证](img/0109OS_02_10.jpg)'
- en: As you can see, all information is encrypted and it can't be interpreted. So,
    if the packages are transmitted and they are intercepted in the network, the information
    is not vulnerable to attacks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，所有信息都是加密的，无法解释。因此，如果数据包被传输并在网络中被拦截，信息不会容易受到攻击。
- en: 'You can find the source code of this section on GitHub at the following URL:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下URL的GitHub上找到此部分的源代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples)'
- en: API keys
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API密钥
- en: With the advent of cloud computing, it is not difficult to think of applications
    that integrate with many others available in the cloud. Right now, it's easy to
    see how applications interact with Flickr, Facebook, Twitter, Tumblr, and so on.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算的出现，很容易想到与云中许多其他应用程序集成的应用程序。现在，很容易看到应用程序如何与Flickr、Facebook、Twitter、Tumblr等进行交互。
- en: To enable these integrations, a new authentication mechanism has been developed
    using API keys. This authentication method is used primarily when we need to authenticate
    from another application but we do not want to access the private user data hosted
    in another application. On the contrary, if you want to access this information,
    you must use OAuth. If you are interested in this, don't worry, we will study
    this wonderful technology later in this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用这些集成，已开发了一种使用API密钥的新身份验证机制。当我们需要从另一个应用程序进行身份验证但不想访问另一个应用程序中托管的私人用户数据时，主要使用此身份验证方法。相反，如果您想访问此信息，必须使用OAuth。如果您对此感兴趣，不用担心，我们将在本书的后面学习这项奇妙的技术。
- en: We want to understand how the API keys work, so let's take the case of Flickr.
    The important thing here is to understand how the API keys work because the same
    concept can be applied to companies like Google, Facebook, and so on. For those
    unfamiliar with Flickr, it is an application in the cloud in which we can store
    our photos, images, screenshots, or similar files.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要了解API密钥的工作原理，所以让我们以Flickr为例。这里重要的是要理解API密钥的工作原理，因为相同的概念可以应用于谷歌、Facebook等公司。对于不熟悉Flickr的人来说，它是一个云端应用，我们可以在其中存储照片、图像、截图或类似文件。
- en: 'To start working with this authentication model, we first obtain an API key;
    in our example with Flickr, you can do this using the following link:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用这种身份验证模型，我们首先获得一个API密钥；在我们的Flickr示例中，您可以使用以下链接来做到这一点：
- en: '[https://www.flickr.com/services/developer/api/](https://www.flickr.com/services/developer/api/)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.flickr.com/services/developer/api/](https://www.flickr.com/services/developer/api/)'
- en: 'When we ask for our API key, we are asked to enter the name of the application
    that we will create and with which we use the API key. Once we enter the information
    requested and submit it, Flickr will deliver us a couple of values; they are a
    secret and a key. Both are displayed in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求我们的API密钥时，我们被要求输入我们将创建的应用程序的名称，并使用API密钥。一旦我们输入所请求的信息并提交，Flickr将向我们提供一对值；它们是一个秘钥和一个密钥。两者都显示在以下截图中：
- en: '![API keys](img/0109OS_02_11.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![API keys](img/0109OS_02_11.jpg)'
- en: Each application we create is part of Flickr App Garden. App Garden is nothing
    but the set of all applications created by all Flickr members.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的每个应用程序都是Flickr App Garden的一部分。App Garden只是由所有Flickr成员创建的所有应用程序的集合。
- en: 'Keep in mind that when creating an API key, we consciously accept certain terms
    of use of the provider. These terms clearly detail what we can and can''t do;
    for example, Flickr says:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当创建API密钥时，我们有意接受提供者的某些使用条款。这些条款清楚地详细说明了我们可以做什么和不能做什么；例如，Flickr说：
- en: '*a. You shall:*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*a. 你应该：*'
- en: '*Comply with the Flickr Community Guidelines at [www.flickr.com/guidelines.gne](http://www.flickr.com/guidelines.gne),
    the Flickr Terms of Use at [http://www.flickr.com/terms.gne](http://www.flickr.com/terms.gne),
    and the Yahoo! Terms of Service at [http://docs.yahoo.com/info/terms/](http://docs.yahoo.com/info/terms/).*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*遵守Flickr社区准则[www.flickr.com/guidelines.gne](http://www.flickr.com/guidelines.gne)，Flickr使用条款[http://www.flickr.com/terms.gne](http://www.flickr.com/terms.gne)，以及Yahoo!服务条款[http://docs.yahoo.com/info/terms/](http://docs.yahoo.com/info/terms/)。*'
- en: '*…*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*…*'
- en: '*b. You shall not:*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*b. 你不应该：*'
- en: '*Use Flickr APIs for any application that replicates or attempts to replace
    the essential user experience of Flickr.com*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用Flickr API来为任何试图复制或替代Flickr.com基本用户体验的应用程序*'
- en: '*…*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*…*'
- en: 'Thus, by requiring that users accept the terms of use, API key providers prevent
    the abusive use of its APIs. So, if someone starts disrespecting agreements, the
    provider withdraws the API key. Flickr has a large set of methods that we can
    use in our applications; we will try one of them to show how they work:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过要求用户接受使用条款，API密钥提供者防止了对其API的滥用使用。因此，如果有人开始不尊重协议，提供者将撤回API密钥。Flickr有一系列我们可以在应用程序中使用的方法；我们将尝试其中一个来展示它们是如何工作的：
- en: 'The `flickr.photos.getRecent` method lists all recent photos that have been
    posted in Flickr, and we can invoke it as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`flickr.photos.getRecent`方法列出了在Flickr中发布的所有最新照片，我们可以按照以下方式调用它：'
- en: '`https://www.flickr.com/services/rest?method=flickr.photos.getRecent&;&api+key=[your_api_key_from_flicker]`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://www.flickr.com/services/rest?method=flickr.photos.getRecent&;&api+key=[your_api_key_from_flicker]`'
- en: 'Let''s use the key we just generated earlier, and let''s perform the request
    using the browser as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前生成的密钥，并让我们使用浏览器执行请求如下：
- en: '![API keys](img/0109OS_02_12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![API keys](img/0109OS_02_12.jpg)'
- en: First notice how information travels through a secure channel (HTTPS). Then,
    when receiving the request, Flickr authenticates the user by reading the information
    from the API key with the secret key that belongs to the user. Once these validations
    are successful, the server delivers the response to the client. Thus, we obtain
    a response with all the photos that have been recently posted within Flickr. As
    you'll notice, this way, you can easily create applications using the provider's
    API. Also, the provider will allow you to authenticate, access public information,
    and be responsible to keep track of volume or the number of API calls you've made
    using the API key, in order to validate that the use complies with the agreements.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意信息是如何通过安全通道（HTTPS）传输的。然后，在接收请求时，Flickr通过读取属于用户的API密钥的秘钥来对用户进行身份验证。一旦这些验证成功，服务器将响应传递给客户端。因此，我们获得了最近在Flickr中发布的所有照片的响应。正如您将注意到的那样，通过这种方式，您可以轻松地使用提供者的API创建应用程序。此外，提供者将允许您进行身份验证，访问公共信息，并负责跟踪您使用API密钥进行的调用量或API调用次数，以验证使用是否符合协议。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through all possible models of authentication. We will
    use all of them in the next chapter, and we will apply them to the web service
    functionality we just created.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了所有可能的身份验证模型。我们将在下一章中使用它们，并将它们应用到我们刚刚创建的Web服务功能中。
- en: Even if you had trouble with any of the examples, you can continue to the next
    chapter. As for your better understanding, we will go step-by-step and more in-depth
    into how we can leverage each available authentication model.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您在任何示例中遇到问题，您也可以继续下一章。为了让您更好地理解，我们将逐步深入地介绍如何利用每个可用的身份验证模型。
- en: As you realize, it is important to choose the correct security management, otherwise
    information is exposed and can easily be intercepted and used by third parties.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您意识到的那样，选择正确的安全管理非常重要，否则信息将被暴露并且很容易被第三方拦截和使用。
- en: Finally, in this chapter, we reviewed the differences between authentication
    and authorization. Both concepts are very important and definitely impossible
    to put aside in the context of security terms.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章中，我们回顾了身份验证和授权之间的区别。这两个概念都非常重要，在安全术语的背景下绝对不可忽视。
- en: Now, we will ask you to join us to go ahead and secure our web service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们会请你加入我们，继续前进并保护我们的网络服务。
