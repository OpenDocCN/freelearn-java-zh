- en: 11\. Processes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 进程
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will quickly look at how Java handles processes. You will
    start by exploring the Runtime and `ProcessBuilder` classes, their functions,
    and how to launch them, in order to then create a process from either class. You'll
    then learn to send and receive data between parent and child, and how to store
    the outcomes of a process in a file. In this chapter's final activity, you will
    use these skills to create a parent process which will launch a child that will
    print an outcome (then captured by the parent) to the terminal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速了解Java如何处理进程。你将从探索`Runtime`和`ProcessBuilder`类开始，了解它们的功能以及如何启动它们，然后从任一类创建一个进程。你将学习在父进程和子进程之间发送和接收数据，以及如何将进程的结果存储在文件中。在本章的最终活动中，你将使用这些技能创建一个父进程，该进程将启动一个子进程，该子进程将打印一个结果（然后由父进程捕获）到终端。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'The `java.lang.Process` class is used to look for information about, and launch,
    runtime processes. If you want to understand how the `Process` class works, you
    can start by looking at the `Runtime` class. All Java programs include an instance
    of the `Runtime` class. It is possible to get information about the `Runtime`
    class by calling the `getRuntime()` method and assigning its outcome to a variable
    of the `Runtime` class. With that, it is possible to obtain information about
    the **JVM** environment that commands your program:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Process`类用于查找有关运行时进程的信息并启动它们。如果你想了解`Process`类是如何工作的，你可以从查看`Runtime`类开始。所有Java程序都包含一个`Runtime`类的实例。可以通过调用`getRuntime()`方法并将结果分配给`Runtime`类的变量来获取有关`Runtime`类的信息。有了这个，就可以获取有关控制你程序的**JVM**环境的信息：'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Processes carry the information relating to a program being launched on a computer.
    Each operating system handles processes differently. What the `Process` class
    is an opportunity to control them in the same way. This is done through a single
    method of the `Runtime` class, called `exec()`, which returns an object of the
    `Process` class. `Exec` has different implementations that allow you to simply
    issue a command, or to do so by modifying the environmental variable and even
    the directory the program will run from.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 进程携带有关在计算机上启动的程序的信息。每个操作系统处理进程的方式都不同。`Process`类提供了一个机会，以相同的方式控制它们。这是通过`Runtime`类的一个单独的方法实现的，称为`exec()`，它返回一个`Process`类的对象。`Exec`有不同的实现，允许你简单地发出一个命令，或者通过修改环境变量甚至程序运行的目录来实现。
- en: Launching a Process
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动进程
- en: 'As mentioned earlier, a process is launched with `exec()`. Let''s look at a
    simple example where we will call the Java compiler, something that is done the
    same way from the terminal on any operating system:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，进程是通过`exec()`启动的。让我们看看一个简单的例子，我们将调用Java编译器，这在任何操作系统的终端上都是用相同的方式完成的：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When running this example, if you happen to have Firefox installed, it will
    launch automatically. You could change that to be any other application on your
    computer. The program will exit with no error, but it will not do anything besides
    that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此示例时，如果你恰好安装了Firefox，它将自动启动。你可以将其更改为计算机上的任何其他应用程序。程序将无错误退出，但除了这一点之外，它不会做任何事情。
- en: 'Now, let''s add a couple of lines to the previous example so that the program
    you just opened will be closed after 5 seconds:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在先前的例子中添加几行，以便你刚刚打开的程序将在5秒后关闭：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `waitFor(timeOut, timeUnit)` method will wait for the process to end for
    5 seconds. If it was `waitFor()` without parameters, it would wait for the program
    to end by itself. Following the 5-second timeout, the process variable will call
    the `destroy()` method, which will stop the process immediately. For this reason,
    opening and closing an application over a short period of time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitFor(timeOut, timeUnit)`方法将等待进程结束5秒钟。如果它是没有参数的`waitFor()`，它将等待程序自行结束。在5秒超时之后，进程变量将调用`destroy()`方法，这将立即停止进程。因此，在短时间内打开和关闭应用程序。'
- en: 'There is an alternative way of launching a process that doesn''t require the
    creation of a `Runtime` object. This other method makes use of the `ProcessBuilder`
    class. The construction of a `ProcessBuilder` object will require the actual command
    to be executed as a parameter. The following example is a revision of the previous
    one, with the addition of this new constructor:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种启动进程的方法，不需要创建`Runtime`对象。这种方法使用`ProcessBuilder`类。构建`ProcessBuilder`对象将需要实际要执行的命令作为参数。以下是对先前示例的修订，增加了这个新构造函数：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are a couple of things you should be aware of. First, the process includes
    the call to the command as an argument in the constructor. However, that does
    not launch the process until you call `processBuilder.start()`. The only issue
    is that the object resulting from `ProcessBuilder` does not include the same method
    as the one coming from the `Process` API. For example, methods such as `waitFor()`
    and `destroy()` are not available, therefore, if those were needed, you would
    have to instantiate an object of `Process` before you could call it in your program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情你应该注意。首先，该过程包括在构造函数中将命令作为参数调用。然而，直到你调用 `processBuilder.start()`，这个过程才启动。唯一的问题是，`ProcessBuilder`
    对象不包含与 `Process` API 相同的方法。例如，`waitFor()` 和 `destroy()` 等方法不可用，因此，如果需要这些方法，你必须在程序中调用它之前实例化一个
    `Process` 对象。
- en: Sending Input to a Child Process
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向子进程发送输入
- en: 'Once the process is running, it would be interesting to pass over some data
    to it. Let''s make a small program that will `echo` whatever you type on the CLI
    back to it. Later, we will write a program that will launch the first application
    and that will send text for it to print. This simple `echo` program could be like
    the one in the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进程开始运行，向其中传递一些数据将很有趣。让我们创建一个小程序，它会将你在 CLI 上输入的任何内容 `echo` 回来。稍后，我们将编写一个程序来启动第一个应用程序并向它发送文本。这个简单的
    `echo` 程序可能如下所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, this simple program will be reading from the `System.in` stream
    until you press *Enter*. Once that happens, it will exit gracefully:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个简单的程序将读取 `System.in` 流，直到你按下 *Enter*。一旦发生这种情况，它将优雅地退出：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the first line of the preceding output, we enter the string ''`Hello World`''
    for this example, which is echoed on the next line. Next, you can make another
    program that will launch this example and send some text to it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出第一行中，我们输入字符串 '`Hello World`' 作为此示例，它在下一行被 echo。接下来，你可以创建另一个程序来启动此示例并向它发送一些文本：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example has two interesting tricks that you need to look into. The first
    is the call to the previous example. Since we have to launch a Java application,
    we need to call the `java` executable with the `cp` parameter, which will indicate
    the directory in which **JVM** should be looking for the example compiled. You
    just compiled and tried out *Example05*, which means that there is already a compiled
    class in your computer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例有两个有趣的技巧，你需要注意。第一个是调用前一个示例。由于我们必须启动一个 Java 应用程序，我们需要使用 `cp` 参数调用 `java` 可执行文件，这将指示
    JVM 应在哪个目录中查找编译的示例。你刚刚编译并尝试了 *Example05*，这意味着你的计算机中已经有一个编译好的类。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After the call to the `cp` parameter, in Linux/macOS, you need to add a colon
    (`:`) before the name of the class, whereas in the case of Windows, you should
    use a semicolon (`;`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `cp` 参数之后，在 Linux/macOS 中，你需要在类名之前添加一个冒号 (`:`)，而在 Windows 的情况下，你应该使用分号 (`;`)。
- en: Once you compile this example, its relative path to the previous example is
    `../../../../Example05/out/production/Example05`. This might be completely different
    in your case, depending on how you named your project folders.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译此示例，其相对于前一个示例的相对路径是 `../../../../Example05/out/production/Example05`。这可能会因你如何命名项目文件夹而完全不同。
- en: The second thing to note is also highlighted in the code listing. There, you
    can see the declaration of the `OutStream` that is linked to the one coming from
    the process. In other words, we are linking an outgoing stream from *Example06*
    to the `System.in` in the *Example05* application. In order to be able to write
    strings to it, we construct a `Writer` object that exposes a `write` method with
    the ability to send strings to the stream.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件需要注意的事情也在代码列表中突出显示。在那里，你可以看到与来自进程的 `OutStream` 链接的 `OutStream` 的声明。换句话说，我们正在将
    *Example06* 的输出流链接到 *Example05* 应用程序的 `System.in`。为了能够向它写入字符串，我们构建了一个 `Writer`
    对象，该对象公开了一个具有向流发送字符串能力的 `write` 方法。
- en: 'We can call this example from the CLI using:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从 CLI 调用此示例：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result is nothing. The reason for this is that `System.out` on the echo
    example (*Example05*) is not made available to the application that initiated
    the process. If we want to use it, we need to capture it inside *Example06*. We
    will see how to do that in the following section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 结果什么也没有。原因是 echo 示例 (*Example05*) 中的 `System.out` 没有对启动进程的应用程序开放。如果我们想使用它，我们需要在
    *Example06* 中捕获它。我们将在下一节中看到如何做到这一点。
- en: Capturing the Output of a Child Process
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获子进程的输出
- en: We now have two different programs; one that can run by itself (*Example05*),
    and one that is executed from another one, which will also try to send information
    to it and capture its output. The purpose of this section is to capture the output
    from *Example05* and print it out to a terminal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个不同的程序；一个可以独立运行（*Example05*），另一个是从另一个程序中执行的，它也会尝试向它发送信息并捕获其输出。本节的目的就是捕获*Example05*的输出并将其打印到终端。
- en: 'To capture whatever is being sent by the child process to `System.out`, we
    need to create a `BufferedReader` in the parent class that will be fed from the
    `InputStream` that can be instantiated from the process. In other words, we need
    to enhance *Example06* with the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获子进程发送到`System.out`的内容，我们需要在父类中创建一个`BufferedReader`，它将从可以由进程实例化的`InputStream`中获取数据。换句话说，我们需要增强*Example06*，如下所示：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The reason for needing a `BufferedReader` is that we are using the end of the
    line (`EOL` or "`\n`") as a marker for a message between processes. That allows
    the utilization of methods such as `readLine()`, which will block the program
    until it captures an EOL; otherwise, we could stick to the `Reader` object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用`BufferedReader`的原因是我们使用行尾（`EOL`或"`\n`"）作为进程间消息的标记。这允许使用`readLine()`等方法，这些方法将阻塞程序直到捕获到EOL；否则，我们可以坚持使用`Reader`对象。
- en: 'Once you have added that to the example, calling the previous program from
    the terminal will result in the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将此内容添加到示例中，从终端调用之前的程序将产生以下输出：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After this output, the program will end.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出之后，程序将结束。
- en: An important aspect to consider is that since `BufferedReader` is of a buffered
    nature, it requires the use of `flush()` as a way to force the data we sent to
    the buffer to be sent out to the child process. Otherwise, it will be waiting
    forever when **JVM** gives it a priority, which eventually could bring the program
    to a stall.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个重要方面是，由于`BufferedReader`具有缓冲性质，它需要使用`flush()`方法来强制将我们发送到缓冲区的数据发送到子进程。否则，当**JVM**给它优先级时，它将永远等待，这最终可能导致程序停滞。
- en: Storing the Output of a Child Process in a File
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将子进程的输出存储到文件中
- en: 'Wouldn''t it be useful to store the data in a file? This is one of the reasons
    why you may be interested in having a process to run a program (or a series of
    programs) – capturing their output in a log file to study them. By adding a small
    modification to the process launcher, you could capture whatever it is that is
    sent to `System.out` by the other program. This is really powerful as you could
    make a program that could be used to launch any existing command in your operating
    system and capture all of its output, which could be used later to conduct some
    sort of forensic analysis of the outcomes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据存储在文件中不是很有用吗？这可能是你可能会对有一个进程来运行程序（或一系列程序）感兴趣的原因之一——将它们的输出捕获到日志文件中以供研究。通过向进程启动器添加一个小修改，你可以捕获其他程序发送到`System.out`的任何内容。这真的很有用，因为你可以创建一个程序，它可以用来启动操作系统中任何现有的命令并捕获所有输出，这些输出可以用于稍后进行某种类型的成果分析：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The outcome will be not just writing the result to the terminal, but also creating
    a `data.log` file that will contain the exact same sentence.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不仅会将结果写入终端，还会创建一个`data.log`文件，其中包含完全相同的句子。
- en: 'Activity 1: Making a Parent Process to Launch a Child Process'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一：创建一个父进程以启动子进程
- en: In this activity, we will create a parent process that will launch a child process
    that will print out an increasing series of numbers. The outcomes of the child
    process will be captured by the parent, which will print them to the terminal.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个父进程，该进程将启动一个子进程，该子进程将打印出一系列递增的数字。子进程的结果将被父进程捕获，然后将其打印到终端。
- en: To stop the program from running forever to reach infinity, the child process
    should stop when a certain number is reached. Let's take `50` as a limit for this
    activity, at which point the counter will exit.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止程序无限运行达到无穷大，子进程应在达到某个数字时停止。让我们以`50`作为这个活动的限制，此时计数器将退出。
- en: At the same time, the parent process will read the inputs and compare them with
    a certain number, for example, 37, after which the counter should restart. To
    ask the child process to restart, the parent should send a single-byte command
    to the child. Let's use an asterisk (`*`) for this activity. You should use the
    `sleep()` command so that printing on the terminal doesn't happen too quickly.
    A good configuration would be `sleep(200)`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，父进程将读取输入并将其与某个数字进行比较，例如37，之后计数器应重新启动。为了请求子进程重新启动，父进程应向子进程发送一个单字节命令。让我们用星号（`*`）来完成这项活动。你应该使用`sleep()`命令，以便终端上的打印不会太快。一个好的配置是`sleep(200)`。
- en: 'Given the abovementioned brief, the expected output from running the child
    program on its own is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述简要说明，单独运行子程序预期的输出如下：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But, when called from the parent program, the outcome should be:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当从父程序调用时，结果应该是：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The child should have an algorithm that looks like the following:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子程序应该有一个类似于以下算法：
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, there is a call to `System.in.available()` to check whether there is any
    data in the output buffer from the child program.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一个调用`System.in.available()`来检查子程序输出缓冲区中是否有数据。
- en: 'On the other hand, the parent program should consider including something along
    the lines of:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，父程序应考虑包含类似以下内容：
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This would detect whether the number that just arrived as a `String` will be
    converted to an `Integer`, and from there it would be compared to the limit we
    suggested for the counting to reset.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检测刚刚到达的作为`String`的数字是否将被转换为`Integer`，然后它将与我们为计数重置所建议的限制进行比较。
- en: We didn't go in-depth in terms of all of the methods offered by the `Process`
    class. It is therefore recommended to wrap the work in this chapter in good old-school
    reference documentation and visit JavaDoc to see what else this class has to offer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有深入探讨`Process`类提供的所有方法。因此，建议将本章的工作包裹在传统的参考文档中，并访问JavaDoc以了解该类还能提供什么。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found at page 559\. You can read more
    about the `Process` class on Oracle''s official documentation: [https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html](https://www.packtpub.com/application-development/mastering-java-9).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第559页找到。你可以在Oracle的官方文档中了解更多关于`Process`类的信息：[https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html](https://www.packtpub.com/application-development/mastering-java-9)。
- en: Summary
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this short chapter, you were introduced to the `Process` class in Java. You
    got to see how a process that outputs to `System.out` can be captured in the parent
    program. At the same time, you also saw how the parent can easily send data to
    the child. The examples showed that it is possible to launch not just your own
    programs, but also any other program, such as a web browser. The possibilities
    for building software automation with programs that include the `Process` API
    are endless.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章简短的介绍中，你了解了Java中的`Process`类。你看到了一个输出到`System.out`的过程如何在父程序中被捕获。同时，你也看到了父程序如何轻松地向子程序发送数据。示例表明，不仅可以启动自己的程序，还可以启动任何其他程序，例如网页浏览器。使用包含`Process`
    API的程序构建软件自动化的可能性是无限的。
- en: We also saw the importance of streams in terms of intra-process communication.
    Basically, you have to create streams on top of streams to develop more complex
    data structures, which will allow the code to run a lot faster. The next chapter
    will cover regular expressions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了在进程间通信方面流的重要性。基本上，你必须在上层流的基础上创建流来开发更复杂的数据结构，这将使代码运行得更快。下一章将介绍正则表达式。
