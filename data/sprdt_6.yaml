- en: Chapter 6. Building Applications with Spring Data Redis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。使用Spring Data Redis构建应用程序
- en: We have learned how we can set up our project and configure the used Redis connection.
    Now it is time to expand our knowledge and learn how we can use Spring Data Redis
    in our applications. We will also prove that it is possible to use Redis as data
    storage of a web application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何设置我们的项目并配置所使用的Redis连接。现在是扩展我们的知识并学习如何在应用程序中使用Spring Data Redis的时候了。我们还将证明可以将Redis用作Web应用程序的数据存储。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Salvatore Sanfilippo* is a contributor of the Redis project and he has written
    a wonderful blog entry that describes how we can use Redis in our applications.
    This blog entry is available at [http://antirez.com/post/take-advantage-of-redis-adding-it-to-your-stack.html](http://antirez.com/post/take-advantage-of-redis-adding-it-to-your-stack.html).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*Salvatore Sanfilippo*是Redis项目的贡献者，他写了一篇精彩的博客文章，描述了我们如何在应用程序中使用Redis。这篇博客文章可以在[http://antirez.com/post/take-advantage-of-redis-adding-it-to-your-stack.html](http://antirez.com/post/take-advantage-of-redis-adding-it-to-your-stack.html)找到。'
- en: 'In this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The basic design principles of a Redis data model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis数据模型的基本设计原则
- en: The key components of Spring Data Redis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data Redis的关键组件
- en: How we can implement a CRUD application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何可以实现CRUD应用程序
- en: How we can use the publish/subscribe messaging pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何可以使用发布/订阅消息模式
- en: How we can use Spring Data Redis as an implementation of the cache abstraction
    provided by Spring Framework 3.1
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何可以使用Spring Data Redis作为Spring Framework 3.1提供的缓存抽象的实现
- en: Designing a Redis data model
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计Redis数据模型
- en: 'The most important rules of designing a Redis data model are: Redis does not
    support ad hoc queries and it does not support relations in the same way than
    relational databases. Thus, designing a Redis data model is a total different
    ballgame than designing the data model of a relational database. The basic guidelines
    of a Redis data model design are given as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 设计Redis数据模型的最重要规则是：Redis不支持特设查询，也不支持关系数据库中的关系。因此，设计Redis数据模型与设计关系数据库的数据模型完全不同。Redis数据模型设计的基本指导原则如下：
- en: Instead of simply modeling the information stored in our data model, we have
    to also think how we want to search information from it. This often leads to a
    situation where we have to duplicate data in order to fulfill the requirements
    given to us. Don't be afraid to do this.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不仅要对存储在数据模型中的信息进行建模，还要考虑如何从中搜索信息。这经常导致我们不得不复制数据以满足给定的要求。不要害怕这样做。
- en: We should not concentrate on normalizing our data model. Instead, we should
    combine the data that we need to handle as an unit into an aggregate.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该专注于规范化我们的数据模型。相反，我们应该将需要处理的数据作为一个单元合并成一个聚合。
- en: Since Redis does not support relations, we have to design and implement these
    relations by using the supported data structures. This means that we have to maintain
    these relations manually when they are changed. Because this might require a lot
    of effort and code, it could be wise to simply duplicate the information instead
    of using relations.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Redis不支持关系，我们必须使用支持的数据结构来设计和实现这些关系。这意味着当这些关系发生变化时，我们必须手动维护这些关系。因为这可能需要大量的工作和代码，所以简单地复制信息而不使用关系可能是明智的。
- en: It is always wise to spend a moment to verify that we are using the correct
    tool for the job.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花一点时间验证我们是否使用了正确的工具总是明智的。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '*NoSQL Distilled*, by *Martin Fowler* contains explanations of different NoSQL
    databases and their use cases, and can be found at [http://martinfowler.com/books/nosql.html](http://martinfowler.com/books/nosql.html).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*NoSQL Distilled*，由*Martin Fowler*编写，解释了不同的NoSQL数据库及其用例，可以在[http://martinfowler.com/books/nosql.html](http://martinfowler.com/books/nosql.html)找到。'
- en: 'As we learned in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting
    Started*, Redis supports multiple data structures. However, one question remained
    unanswered: which data structure should we use for our data? This question is
    addressed in the following table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html "第1章。入门")中学到的，*入门*，Redis支持多种数据结构。然而，一个问题仍然没有得到解答：我们应该使用哪种数据结构来存储我们的数据？这个问题在下表中得到了解答：
- en: '| Data type | Description |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| String | A string is good choice for storing information that is already
    converted to a textual form. For instance, if we want to store HTML, JSON, or
    XML, a string should be our weapon of choice. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 字符串是存储已转换为文本形式的信息的好选择。例如，如果我们想存储HTML、JSON或XML，字符串应该是我们的选择。'
- en: '| List | A list is a good choice if we will access it only near the start or
    end. This means that we should use it for representing queues or stacks. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 如果我们只会在开始或结束附近访问它，列表是一个不错的选择。这意味着我们应该用它来表示队列或堆栈。'
- en: '| Set | We should use a set if we need to get the size of a collection or check
    if a certain item belongs to it. Also, if we want to represent relations, a set
    is a good choice (for example, "who are John''s friends?"). |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 如果我们需要获取集合的大小或检查某个项目是否属于它，我们应该使用集合。此外，如果我们想表示关系，集合是一个很好的选择（例如，“约翰的朋友是谁？”）。'
- en: '| Sorted set | Sorted sets should be used in the same situations as sets when
    the ordering of items is important to us. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 有序集合 | 当项目的排序对我们很重要时，应该在与集合相同的情况下使用有序集合。'
- en: '| Hash | A hash is a perfect data structure for representing complex objects.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 哈希 | 哈希是表示复杂对象的完美数据结构。'
- en: Key components
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键组件
- en: Spring Data Redis provides certain components that are the cornerstones of each
    application that uses it. This section provides a brief introduction to the components
    that we will later use to implement our example applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data Redis提供了一些组件，它们是使用它的每个应用程序的基石。本节简要介绍了我们稍后将用来实现示例应用程序的组件。
- en: Atomic counters
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子计数器
- en: 'Atomic counters are for Redis what sequences are for relational databases.
    Atomic counters guarantee that the value received by a client is unique. This
    makes these counters a perfect tool for creating unique IDs to our data that is
    stored in Redis. At the moment, Spring Data Redis offers two atomic counters:
    `RedisAtomicInteger` and `RedisAtomicLong` . These classes provide atomic counter
    operations for integers and longs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 原子计数器对于Redis来说就像序列对于关系数据库一样。原子计数器保证客户端接收的值是唯一的。这使得这些计数器成为在Redis中创建唯一ID的完美工具。目前，Spring
    Data Redis提供了两种原子计数器：`RedisAtomicInteger`和`RedisAtomicLong`。这些类为整数和长整数提供了原子计数器操作。
- en: RedisTemplate
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RedisTemplate
- en: 'The `RedisTemplate<K,V>` class is the central component of Spring Data Redis.
    It provides methods that we can use to communicate with a Redis instance. This
    class requires that two type parameters are given during its instantiation: the
    type of used Redis key and the type of the Redis value.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedisTemplate<K,V>`类是Spring Data Redis的核心组件。它提供了我们可以用来与Redis实例通信的方法。在实例化时，这个类要求给定两个类型参数：用于Redis键的类型和Redis值的类型。'
- en: Operations
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作
- en: 'The `RedisTemplate` class provides two kinds of operations that we can use
    to store, fetch, and remove data from our Redis instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedisTemplate`类提供了两种我们可以用来存储、获取和删除Redis实例中的数据的操作：'
- en: Operations that require that the key and the value are given every time an operation
    is performed. These operations are handy when we have to execute a single operation
    by using a key and a value.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要每次操作都提供键和值的操作。当我们必须使用键和值执行单个操作时，这些操作非常方便。
- en: Operations that are bound to a specific key that is given only once. We should
    use this approach when we have to perform multiple operations by using the same
    key.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定到只给定一次的特定键的操作。当我们必须使用相同的键执行多个操作时，应该使用这种方法。
- en: 'The methods that require that a key and value is given every time an operation
    is performed are described in following list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要每次操作都提供键和值的方法在以下列表中描述：
- en: '`HashOperations<K,HK,HV> opsForHash()`: This method returns the operations
    that are performed on hashes'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashOperations<K,HK,HV> opsForHash()`: 此方法返回对哈希执行的操作'
- en: '`ListOperations<K,V> opsForList()`: This method returns the operations performed
    on lists'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListOperations<K,V> opsForList()`: 此方法返回对列表执行的操作'
- en: '`SetOperations<K,V> opsForSet()`: This method returns the operations performed
    on sets'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetOperations<K,V> opsForSet()`: 此方法返回对集合执行的操作'
- en: '`ValueOperations<K,V> opsForValue()`: This method returns the operations performed
    on simple values'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueOperations<K,V> opsForValue()`: 此方法返回对简单值执行的操作'
- en: '`ZSetOperations<K,HK,HV> opsForZSet()`: This method returns the operations
    performed on sorted sets'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZSetOperations<K,HK,HV> opsForZSet()`: 此方法返回对有序集合执行的操作'
- en: 'The methods of the `RedisTemplate` class that allow us to execute multiple
    operations by using the same key are described in following list:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedisTemplate`类的方法允许我们使用相同的键执行多个操作，在以下列表中描述：'
- en: '`BoundHashOperarations<K,HK,HV> boundHashOps(K key)`: This method returns hash
    operations that are bound to the key given as a parameter'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoundHashOperarations<K,HK,HV> boundHashOps(K key)`: 此方法返回绑定到给定键的哈希操作'
- en: '`BoundListOperations<K,V> boundListOps(K key)`: This method returns list operations
    bound to the key given as a parameter'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoundListOperations<K,V> boundListOps(K key)`: 此方法返回绑定到给定键的列表操作'
- en: '`BoundSetOperations<K,V> boundSetOps(K key)`: This method returns set operations,
    which are bound to the given key'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoundSetOperations<K,V> boundSetOps(K key)`: 此方法返回绑定到给定键的集合操作'
- en: '`BoundValueOperations<K,V> boundValueOps(K key)`: This method returns operations
    performed to simple values that are bound to the given key'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoundValueOperations<K,V> boundValueOps(K key)`: 此方法返回绑定到给定键的简单值的操作'
- en: '`BoundZSetOperations<K,V> boundZSetOps(K key)`: This method returns operations
    performed on sorted sets that are bound to the key that is given as a parameter'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoundZSetOperations<K,V> boundZSetOps(K key)`: 此方法返回绑定到给定键的有序集合的操作'
- en: The differences between these operations become clear to us when we start building
    our example applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建示例应用程序时，这些操作之间的差异就变得清晰起来了。
- en: Serializers
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化器
- en: 'Because the data is stored in Redis as bytes, we need a method for converting
    our data to bytes and vice versa. Spring Data Redis provides an interface called
    `RedisSerializer<T>`, which is used in the serialization process. This interface
    has one type parameter that describes the type of the serialized object. Spring
    Data Redis provides several implementations of this interface. These implementations
    are described in the following table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据以字节形式存储在Redis中，我们需要一种方法将数据转换为字节，反之亦然。Spring Data Redis提供了一个名为`RedisSerializer<T>`的接口，用于序列化过程。这个接口有一个类型参数，描述了序列化对象的类型。Spring
    Data Redis提供了这个接口的几种实现。这些实现在下表中描述：
- en: '| Serializer | Description |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 序列化器 | 描述 |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GenericToStringSerializer<T>` | Serializes strings to bytes and vice versa.
    Uses the Spring `ConversionService` to transform objects to strings and vice versa.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `GenericToStringSerializer<T>` | 将字符串序列化为字节，反之亦然。使用Spring的`ConversionService`将对象转换为字符串，反之亦然。
    |'
- en: '| `JacksonJsonRedisSerializer<T>` | Converts objects to JSON and vice versa.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `JacksonJsonRedisSerializer<T>` | 将对象转换为JSON，反之亦然。 |'
- en: '| `JdkSerializationRedisSerializer` | Provides Java based serialization to
    objects. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `JdkSerializationRedisSerializer` | 为对象提供基于Java的序列化。 |'
- en: '| `OxmSerializer` | Uses the Object/XML mapping support of Spring Framework
    3. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `OxmSerializer` | 使用Spring Framework 3的对象/XML映射支持。 |'
- en: '| `StringRedisSerializer` | Converts strings to bytes and vice versa. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `StringRedisSerializer` | 将字符串转换为字节，反之亦然。 |'
- en: We can customize the serialization process of the `RedisTemplate` class by using
    the described serializers. The `RedisTemplate` class provides flexible configuration
    options that can be used to set the serializers that are used to serialize value
    keys, values, hash keys, hash values, and string values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用描述的序列化器来自定义`RedisTemplate`类的序列化过程。`RedisTemplate`类提供了灵活的配置选项，可用于设置用于序列化值键、值、哈希键、哈希值和字符串值的序列化器。
- en: The default serializer of the `RedisTemplate` class is `JdkSerializationRedisSerializer`.
    However, the string serializer is an exception to this rule. `StringRedisSerializer`
    is the serializer that is by default used to serialize string values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedisTemplate`类的默认序列化器是`JdkSerializationRedisSerializer`。但是，字符串序列化器是一个例外。`StringRedisSerializer`是默认用于序列化字符串值的序列化器。'
- en: Implementing a CRUD application
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CRUD应用程序
- en: This section describes two different ways for implementing a CRUD application
    that is used to manage contact information. First, we will learn how we can implement
    a CRUD application by using the default serializer of the `RedisTemplate` class.
    Second, we will learn how we can use value serializers and implement a CRUD application
    that stores our data in JSON format.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了实现用于管理联系信息的CRUD应用程序的两种不同方式。首先，我们将学习如何使用`RedisTemplate`类的默认序列化器来实现CRUD应用程序。其次，我们将学习如何使用值序列化器并实现以JSON格式存储数据的CRUD应用程序。
- en: 'Both of these applications will also share the same domain model. This domain
    model consists of two classes: `Contact` and `Address`. The information content
    of these classes has already been described in [Chapter 2](ch02.html "Chapter 2. Getting
    Started with Spring Data JPA"), *Getting Started with Spring Data JPA*. However,
    we have made the following changes to these classes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个应用程序还将共享相同的领域模型。这个领域模型包括两个类：`Contact`和`Address`。这些类的信息内容已经在[第2章](ch02.html
    "第2章。使用Spring Data JPA入门")中描述，*使用Spring Data JPA入门*。但是，我们对这些类进行了以下更改：
- en: We removed the JPA specific annotations from them
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从中删除了JPA特定的注解
- en: We use these classes in our web layer as form objects and they no longer have
    any other methods than getters and setters
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在我们的Web层中使用这些类作为表单对象，它们不再具有除了getter和setter之外的任何其他方法
- en: 'The domain model is not the only thing that is shared by these examples. They
    also share the interface that declares the service methods for the `Contact` class.
    The source code of the `ContactService` interface is given as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型不是这些示例共享的唯一内容。它们还共享了声明`Contact`类的服务方法的接口。`ContactService`接口的源代码如下：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both of these applications will communicate with the used Redis instance by
    using the Jedis connector that was described in [Chapter 5](ch05.html "Chapter 5. Getting
    Started with Spring Data Redis"), *Getting Started with Spring Data Redis*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个应用程序将使用在[第5章](ch05.html "第5章。使用Spring Data Redis入门")中描述的Jedis连接器与所使用的Redis实例进行通信，*使用Spring
    Data Redis入门*。
- en: 'Regardless of the user''s approach, we can implement a CRUD application with
    Spring Data Redis by following these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论用户的方法如何，我们都可以通过以下步骤实现使用Spring Data Redis的CRUD应用程序：
- en: Configure the application context.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置应用程序上下文。
- en: Implement the CRUD functions.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现CRUD功能。
- en: Let's get started and find out how we can implement the CRUD functions for contact
    information.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始并找出如何实现联系信息的CRUD功能。
- en: Using default serializers
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用默认序列化器
- en: This subsection describes how we can implement a CRUD application by using the
    default serializers of the `RedisTemplate` class. This means that `StringRedisSerializer`
    is used to serialize string values, and `JdkSerializationRedisSerializer` serializes
    other objects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节描述了如何使用`RedisTemplate`类的默认序列化器来实现CRUD应用程序。这意味着`StringRedisSerializer`用于序列化字符串值，而`JdkSerializationRedisSerializer`用于序列化其他对象。
- en: Configuring the application context
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置应用程序上下文
- en: 'We can configure the application context of our application by making the following
    changes to the `ApplicationContext` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对`ApplicationContext`类进行以下更改来配置我们应用程序的应用程序上下文：
- en: Configuring the Redis template bean.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Redis模板bean。
- en: Configuring the Redis atomic long bean.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Redis原子长整型bean。
- en: Configuring the Redis template bean
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置Redis模板bean
- en: 'We can configure the Redis template bean by adding a `redisTemplate()` method
    to the `ApplicationContext` class and annotating this method with the `@Bean`
    annotation. We can implement this method by following these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`ApplicationContext`类添加一个`redisTemplate()`方法并使用`@Bean`注解对该方法进行注解来配置Redis模板bean。我们可以通过以下步骤实现此方法：
- en: Create a new `RedisTemplate` object.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`RedisTemplate`对象。
- en: Set the used connection factory to the created `RedisTemplate` object.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用的连接工厂设置为创建的`RedisTemplate`对象。
- en: Return the created object.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `redisTemplate()` method is given as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`redisTemplate()`方法的源代码如下：'
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Configuring the Redis atomic long bean
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置Redis原子长整型bean
- en: 'We start the configuration of the Redis atomic long bean by adding a method
    called `redisAtomicLong()` to the `ApplicationContext` class and annotating the
    method with the `@Bean` annotation. Our next task is to implement this method
    by following these steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向`ApplicationContext`类添加一个名为`redisAtomicLong()`的方法，并使用`@Bean`注解对该方法进行注解来开始配置Redis原子长整型bean。我们的下一个任务是通过以下步骤实现此方法：
- en: Create a new `RedisAtomicLong` object. Pass the name of the used Redis counter
    and the Redis connection factory as constructor parameters.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`RedisAtomicLong`对象。将所使用的Redis计数器的名称和Redis连接工厂作为构造函数参数传递。
- en: Return the created object.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `redisAtomicLong()` method is given as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`redisAtomicLong()`方法的源代码如下：'
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we need to create IDs for instances of different classes, we can use the
    same Redis counter. Thus, we have to configure only one Redis atomic long bean.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为不同类的实例创建ID，我们可以使用相同的Redis计数器。因此，我们只需配置一个Redis原子长整型bean。
- en: CRUD
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CRUD
- en: Before we can start implementing the CRUD functions for the `Contact` class,
    we have to discuss a bit about the Redis data model of our application. We use
    two different data types for storing contact information to Redis. The information
    of a single contact is stored in a hash because as we know, a hash is a great
    structure for storing the information of complex objects. Also, we store the key
    of each contact in a set because a set provides us a fast capability to check
    if a contact exists. We also use this set when we are fetching a list of all contacts
    from Redis.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始为`Contact`类实现CRUD函数之前，我们必须先讨论一下我们应用程序的Redis数据模型。我们使用两种不同的数据类型来将联系人信息存储到Redis中。单个联系人的信息存储在哈希中，因为我们知道，哈希是存储复杂对象信息的很好的结构。此外，我们将每个联系人的密钥存储在一个集合中，因为集合在检查联系人是否存在时为我们提供了快速的能力。当我们从Redis中获取所有联系人的列表时，我们也使用这个集合。
- en: 'Our next step is to implement the `ContactService` interface that declares
    CRUD operations for contacts. Let''s start by creating a dummy service implementation
    and add the actual CRUD methods later. The implementation of this class includes
    the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是实现`ContactService`接口，该接口声明了联系人的CRUD操作。让我们首先创建一个虚拟服务实现，然后稍后添加实际的CRUD方法。该类的实现包括以下步骤：
- en: Implementing the `ContactService` interface.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ContactService`接口。
- en: Annotating the created class with the `@Service` annotation.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`@Service`注解创建的类。
- en: Adding the required dependencies as private members of the created class and
    annotating these members with the `@Resource` annotation. We need to have a reference
    to both the `RedisTemplate` and `RedisAtomicLong` objects.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的依赖项添加为创建的类的私有成员，并使用`@Resource`注解对这些成员进行注解。我们需要引用`RedisTemplate`和`RedisAtomicLong`对象。
- en: 'The source code of our dummy implementation is given as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们虚拟实现的源代码如下：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next step is to implement common methods that are used by the methods declared
    by the `ContactService` interface. These private methods are described in the
    following table:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现`ContactService`接口声明的方法所使用的通用方法。这些私有方法在下表中描述：
- en: '| Method | Description |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `String buildKey(Long contactId)` | Returns a key for a contact. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `String buildKey(Long contactId)` | 返回联系人的密钥。|'
- en: '| `Contact buildContact(String key)` | Fetches the information of a contact
    and returns the found contact. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Contact buildContact(String key)` | 获取联系人的信息并返回找到的联系人。|'
- en: '| `Contact buildContact(Long id)` | Fetches the information of a contact and
    returns the found contact. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Contact buildContact(Long id)` | 获取联系人的信息并返回找到的联系人。|'
- en: '| `boolean contactDoesNotExist(Long id)` | Returns false if a contact is found
    with the given ID and true otherwise. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `boolean contactDoesNotExist(Long id)` | 如果找到具有给定ID的联系人，则返回false，否则返回true。|'
- en: '| `String persist(Contact persisted)` | Saves the contact information and returns
    the key of the contact. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `String persist(Contact persisted)` | 保存联系人信息并返回联系人的密钥。|'
- en: 'First, we have to implement the method that is used to build keys for our contacts.
    Our implementation of the `buildKey()` method is quite simple. We build the key
    by appending the contact ID given as a parameter to a string `contact` and returning
    the resulting string. The source code of the `buildKey()` method is given as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须实现用于构建联系人密钥的方法。我们的`buildKey()`方法的实现非常简单。我们通过将作为参数给定的联系人ID附加到字符串`contact`并返回结果字符串来构建密钥。`buildKey()`方法的源代码如下：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Second, we have to implement the method that is used to fetch contact information
    by using the key of the contact. We can implement the `buildContact(String key)`
    method by following these steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们必须实现使用联系人密钥获取联系人信息的方法。我们可以通过以下步骤实现`buildContact(String key)`方法：
- en: Create a new `Contact` object.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Contact`对象。
- en: Fetch the information of the contact from the hash.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从哈希中获取联系人的信息。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use bound hash operations because this way we have to provide the key only
    once.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用绑定的哈希操作，因为这样我们只需要提供一次密钥。
- en: Return the created object.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the implemented method is given as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法的源代码如下：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Third, we have to implement the method that fetches contact information by
    using the ID of the contact. Our implementation of the `buildContact(Long id)`
    method is rather simple, and it includes the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们必须实现使用联系人ID获取联系人信息的方法。我们的`buildContact(Long id)`方法相当简单，包括以下步骤：
- en: Build the key of the contact.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建联系人的密钥。
- en: Get the contact by using the created key.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的密钥获取联系人。
- en: Return the found contact.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回找到的联系人。
- en: 'The source code of this method is given as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的源代码如下：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Fourth, we have to implement the method used to verify whether a contact in
    question exists or not. Our implementation of the `contactDoesNotExist()` method
    consists of the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，我们必须实现用于验证所讨论的联系人是否存在的方法。我们的`contactDoesNotExist()`方法的实现包括以下步骤：
- en: Create the key of the contact.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建联系人的密钥。
- en: Check if the key is found from the contacts set by calling the `isMember()`
    method of the `SetOperations` class, and passing the name of the set and the key
    as parameters.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`SetOperations`类的`isMember()`方法，并传递集合的名称和密钥作为参数，检查密钥是否在联系人集合中找到。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use `setOperations` because we execute only one command.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`setOperations`因为我们只执行一个命令。
- en: Inverse the return value of the `isMember()` method and return the inverted
    value.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转`isMember()`方法的返回值并返回反转后的值。
- en: 'The source code of this method is given as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的源代码如下：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Fifth, we have to implement the method that saves the information of a single
    contact. Our implementation of the `persist()` method includes the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第五，我们必须实现保存单个联系人信息的方法。我们的`persist()`方法的实现包括以下步骤：
- en: If the persisted `Contact` object does not have an ID, create one calling the
    `incrementAndGet()` method of the `RedisAtomicLong` class and set the received
    `Long` object as the contact ID.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果持久化的`Contact`对象没有ID，则调用`RedisAtomicLong`类的`incrementAndGet()`方法创建一个ID，并将接收到的`Long`对象设置为联系人ID。
- en: Build a key for the persisted contact.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为持久化的联系人构建一个键。
- en: Save the contact in the hash.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将联系人保存在哈希中。
- en: Return the persisted contact.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回持久化的联系人。
- en: 'The source code of the `persist()` method is given as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`persist()`方法的源代码如下：'
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have now implemented the common methods of the `RedisContactService` class.
    Let's move on and find out how we can provide the CRUD operations for the contact
    information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了`RedisContactService`类的常用方法。让我们继续找出如何为联系信息提供CRUD操作。
- en: Create
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建
- en: 'We can create a new contact by following these steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤创建一个新的联系人：
- en: Save the added contact to the hash.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将添加的联系人保存到哈希中。
- en: Add the key of the contact to our contact set.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将联系人的键添加到我们的联系人集合中。
- en: Return the added contact.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回添加的联系人。
- en: 'The source code of the `add()` method is given as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`方法的源代码如下：'
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Read
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取
- en: We have to provide two methods that are used to fetch contact information from
    Redis. The first method is used to return a list of existing contacts and the
    second one is used to find the information of a single contact.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提供两种方法，用于从Redis中获取联系人信息。第一种方法用于返回现有联系人的列表，第二种方法用于查找单个联系人的信息。
- en: 'First, we have to implement a method that is used to return a list of existing
    contacts. We can implement the `findAll()` method by following these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须实现一个方法，用于返回现有联系人的列表。我们可以通过以下步骤实现`findAll()`方法：
- en: Create a new `ArrayList` object that is used to store the found `Contact` objects.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ArrayList`对象，用于存储找到的`Contact`对象。
- en: Get the keys of existing contacts from the contact set.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从联系人集合中获取现有联系人的键。
- en: Get the information of each existing contact from the hash and add them to the
    created `ArrayList` object.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从哈希中获取每个现有联系人的信息，并将它们添加到创建的`ArrayList`对象中。
- en: Return the list of contacts.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回联系人列表。
- en: 'The source code of the implemented method is given as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法的源代码如下：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Second, we have to implement a method that is used to return the information
    of a single contact. We can implement the `findById()` method by following these
    steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们必须实现一个方法，用于返回单个联系人的信息。我们可以通过以下步骤实现`findById()`方法：
- en: Check that the contact exists. If contact does not exist, throw `NotFoundException`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查联系人是否存在。如果联系人不存在，则抛出`NotFoundException`。
- en: Get the contact from the hash.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从哈希中获取联系人。
- en: Return the found contact.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回找到的联系人。
- en: 'The source code of our method is given as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方法的源代码如下：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Update
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新
- en: 'We can update the information of an existing contact by following these steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤更新现有联系人的信息：
- en: Check if that contact exists. If no contact is found, throw a `NotFoundException`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查该联系人是否存在。如果找不到联系人，则抛出`NotFoundException`。
- en: Save the updated contact information in the hash.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更新后的联系信息保存在哈希中。
- en: Return the updated contact.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回更新后的联系人。
- en: 'The source code of the `update()` method is given as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法的源代码如下：'
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Delete
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除
- en: 'We can delete the information of a contact by following these steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤删除联系人的信息：
- en: Get a reference of the deleted contact.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取已删除联系人的引用。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use the `findById()` method because it throws `NotFoundException` if the
    contact is not found.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`findById()`方法，因为如果找不到联系人，它会抛出`NotFoundException`。
- en: Build a key of the deleted contact.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建已删除联系人的键。
- en: Remove the contact from our contact set.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的联系人集合中删除联系人。
- en: Remove the information of a contact from the hash.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从哈希中删除联系人的信息。
- en: Return the deleted contact.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回已删除的联系人。
- en: 'The source code of the `deleteById()` method is given as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteById()`方法的源代码如下：'
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Storing data in JSON
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据存储为JSON
- en: If we store object information in a hash, we have to write a lot of boilerplate
    code that is used to save, read, and delete contact information. This subsection
    describes how we reduce the amount of required code and implement a CRUD application
    that stores the contact information in JSON format. This means that `StringRedisSerializer`
    is used to serialize string values and that `JacksonJsonRedisSerializer` transforms
    our `Contact` objects into JSON.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将对象信息存储在哈希中，我们必须编写大量样板代码，用于保存、读取和删除联系人信息。本小节描述了我们如何减少所需代码量并实现一个以JSON格式存储联系人信息的CRUD应用程序。这意味着`StringRedisSerializer`用于序列化字符串值，而`JacksonJsonRedisSerializer`将我们的`Contact`对象转换为JSON。
- en: Configuring the application context
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置应用程序上下文
- en: 'We can configure the application context of our application by following these
    steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤配置应用程序的应用程序上下文：
- en: Configure the value serializer bean.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置值序列化器bean。
- en: Configure the Redis template.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Redis模板。
- en: Configure the Redis atomic long bean.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Redis原子长整型bean。
- en: Configuring the value serializer bean
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置值序列化器bean
- en: 'We can configure the value serializer bean by adding a `contactSerializer()`
    method to the `ApplicationContext` class and annotating it with the `@Bean` annotation.
    We can implement this method by following these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`ApplicationContext`类添加`contactSerializer()`方法并用`@Bean`注解对其进行注释来配置值序列化器bean。我们可以通过以下步骤实现此方法：
- en: Create a new `JacksonJsonRedisSerializer` object and pass the type of the `Contact`
    class as a constructor parameter.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`JacksonJsonRedisSerializer`对象，并将`Contact`类的类型作为构造函数参数传递。
- en: Return the created object.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `contactSerializer()` method is given as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`contactSerializer()`方法的源代码如下：'
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Configuring the Redis template bean
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置Redis模板bean
- en: 'We can configure the Redis template by adding a `redisTemplate()` method to
    the `ApplicationContex`t class, annotating it with the `@Bean` annotation and
    configuring the Redis template in its implementation. We can implement this method
    by following these steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`ApplicationContext`类添加`redisTemplate()`方法，对其进行`@Bean`注解，并在其实现中配置Redis模板来配置Redis模板。我们可以按照以下步骤实现此方法：
- en: Create a new `RedisTemplate` object and give the type of our key and value as
    type parameters.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`RedisTemplate`对象，并将我们的键和值的类型作为类型参数。
- en: Set the used connection factory.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置使用的连接工厂。
- en: Set the used value serializer.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置使用的值序列化程序。
- en: Return the created object.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `redisTemplate()` method is given as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`redisTemplate()`方法的源代码如下所示：'
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Configuring the Redis atomic long bean
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置Redis原子长整型bean
- en: 'We will start the configuration of the Redis atomic long bean by adding a `redisAtomicLong()`
    method to the `ApplicationContext` class and annotating it with the `@Bean` annotation.
    Our next step is to implement this method by following these steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向`ApplicationContext`类添加`redisAtomicLong()`方法并使用`@Bean`注解对其进行注解来开始配置Redis原子长整型bean。我们的下一步是按照以下步骤实现此方法：
- en: Create a new `RedisAtomicLong` object. Pass the name of the used Redis counter
    and the Redis connection factory as constructor parameters.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`RedisAtomicLong`对象。将使用的Redis计数器的名称和Redis连接工厂作为构造函数参数传递。
- en: Return the created object.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `redisAtomicLong()` method is given as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`redisAtomicLong()`方法的源代码如下所示：'
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: CRUD
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CRUD
- en: First we have to talk about our Redis data model. We store the contact information
    to Redis, using two different data types. We store the information of a single
    contact to Redis as a string value. This makes sense since the contact information
    is transformed to the JSON format before it is saved. We will also use a set that
    contains the JSON representations of the `Contact` objects. We have to duplicate
    the information because otherwise we would not be able to show a list of contacts.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须谈论一下我们的Redis数据模型。我们使用两种不同的数据类型将联系人信息存储到Redis中。我们将单个联系人的信息存储到Redis中作为字符串值。这是有道理的，因为在保存之前，联系人信息会被转换为JSON格式。我们还将使用一个包含`Contact`对象的JSON表示的集合。我们必须复制信息，否则我们将无法显示联系人列表。
- en: 'We can provide the CRUD operations for the `Contact` objects by implementing
    the `ContactService` interface. Let''s start by creating a dummy service implementation
    and adding or implementing the actual CRUD operations later. The steps needed
    to create a dummy service implementation are described as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现`ContactService`接口为`Contact`对象提供CRUD操作。让我们开始创建一个虚拟服务实现，并稍后添加或实现实际的CRUD操作。创建虚拟服务实现所需的步骤如下所述：
- en: Implement the `ContactService` interface.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ContactService`接口。
- en: Annotate the created class with the `@Service` annotation.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`@Service`注解注释创建的类。
- en: Add the required dependencies as private members of the created class and annotate
    these members with the `@Resource` annotation. We need to have a reference to
    both the `RedisTemplate` and `RedisAtomicLong` objects.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的依赖项作为创建的类的私有成员添加，并使用`@Resource`注解对这些成员进行注解。我们需要引用`RedisTemplate`和`RedisAtomicLong`对象。
- en: 'The source code of our dummy service implementation is given as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的虚拟服务实现的源代码如下所示：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also have to implement some utility methods that are used by the methods
    declared by the `ContactService` interface. These private methods are described
    in the following table:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须实现一些实用方法，这些方法由`ContactService`接口声明的方法使用。这些私有方法在以下表中描述：
- en: '| Method | Description |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `String buildKey(Long contactId)` | Returns a key for a contact. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `String buildKey(Long contactId)` | 返回联系人的键。 |'
- en: '| `void persist(Contact persisted)` | Saves the contact information to a string
    value. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `void persist(Contact persisted)` | 将联系人信息保存为字符串值。 |'
- en: 'First, we have to implement a method that is used to build keys for the persisted
    `Contact` objects. The implementation of the `buildKey()` method is simple. We
    build the key by appending the contact ID given as a parameter to a string `contact`
    and return the resulting string. The source code of the `buildKey()` method is
    given as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须实现一个用于构建持久化`Contact`对象键的方法。`buildKey()`方法的实现很简单。我们通过将作为参数给定的联系人ID附加到字符串`contact`并返回结果字符串来构建键。`buildKey()`方法的源代码如下所示：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Second, we have to implement a `persist()` method that saves the contact information.
    We can do this by performing the following steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们必须实现一个`persist()`方法来保存联系人信息。我们可以通过执行以下步骤来实现这一点：
- en: If the contact ID is null, get a new ID and set the received `Long` object as
    an ID of the `Contact` object.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果联系人ID为空，则获取新ID并将接收到的`Long`对象设置为`Contact`对象的ID。
- en: Create a key for the contact.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为联系人创建一个键。
- en: Save the contact information as a string value.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将联系人信息保存为字符串值。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use value operations because we need to execute only one operation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用值操作，因为我们只需要执行一个操作。
- en: 'The source code of the `persist()` method is given as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`persist()`方法的源代码如下所示：'
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are now ready to start implementing the CRUD operations for contacts. Let's
    move on and find out how it is done.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始为联系人实现CRUD操作。让我们继续并找出如何完成。
- en: Create
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建
- en: 'We can implement a method that adds new contacts by following these steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤实现一个添加新联系人的方法：
- en: Save the added contact.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存添加的联系人。
- en: Add the contact information into the contact set.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将联系人信息添加到联系人集合中。
- en: Return the added contact.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回添加的联系人。
- en: 'The source code of the `add()` method is given as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`方法的源代码如下所示：'
- en: '[PRE20]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Read
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取
- en: 'Our application has two views that present contact information: the first one
    shows a list of contacts and the second one shows the information of a single
    contact.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有两个视图，显示联系人信息：第一个显示联系人列表，第二个显示单个联系人的信息。
- en: 'First, we have to implement a method that fetches all the contacts from Redis.
    We can implement the `findAll()` method by following these steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须实现一个从Redis获取所有联系人的方法。我们可以按照以下步骤实现`findAll()`方法：
- en: Fetch all the contacts from the contact set.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从联系人集合中获取所有联系人。
- en: Create a new `ArrayList` object and return the created object.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ArrayList`对象并返回该对象。
- en: 'The source code of the `findAll()` method is given as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`findAll()`方法的源代码如下：'
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Second, we have to implement a method that returns the information of a single
    contact. Our implementation of the `findById()` method includes the following
    steps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们必须实现一个返回单个联系人信息的方法。我们的`findById()`方法的实现包括以下步骤：
- en: Create the key of the contact.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建联系人的键。
- en: Get the `Contact` object from Redis.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Redis获取`Contact`对象。
- en: If no contact is found, throw `NotFoundException`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未找到联系人，则抛出`NotFoundException`。
- en: Return the found object.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回找到的对象。
- en: 'The source code of the `findById()` method is given as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`findById()`方法的源代码如下：'
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Update
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新
- en: 'We can update the information of an existing contact by following these steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下步骤更新现有联系人的信息：
- en: Get the old contact information from Redis.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Redis获取旧的联系人信息。
- en: Save the updated contact information.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更新后的联系人信息。
- en: Remove the old contact information from the contact set. This ensures that our
    set does not contain duplicate entries for the same contact.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从联系人集合中删除旧的联系人信息。这样可以确保我们的集合不包含相同联系人的重复条目。
- en: Add the updated contact information to the contact set.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更新后的联系人信息添加到联系人集合中。
- en: Return the updated contact.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回更新后的联系人。
- en: 'The source code of the `update()` method is given as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法的源代码如下：'
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Delete
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除
- en: 'We can delete contact information by following these steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下步骤删除联系人信息：
- en: Find the deleted contact by calling the `findById()` method. This ensures that
    `NotFoundException` is thrown if the contact is not found.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`findById()`方法找到已删除的联系人。这样可以确保如果联系人未找到，则会抛出`NotFoundException`。
- en: Build a key used to get the contact information.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建用于获取联系人信息的键。
- en: Remove the deleted contact from the contact set.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从联系人集合中删除已删除的联系人。
- en: Remove the JSON representation of the deleted contact.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除已删除联系人的JSON表示。
- en: Return the deleted contact.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回已删除的联系人。
- en: 'The source code of the `delete()` method is given as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()`方法的源代码如下：'
- en: '[PRE24]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The publish/subscribe messaging pattern
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布/订阅消息模式
- en: Redis also includes an implementation of the publish/subscribe messaging pattern.
    This section demonstrates how we can use Spring Data Redis for the purpose of
    sending and receiving messages. As an example, we will modify the CRUD application
    that stores the contact information as JSON to send notifications when a new contact
    is added, contact information is updated, and a contact is deleted.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Redis还包括发布/订阅消息模式的实现。本节演示了我们如何使用Spring Data Redis来发送和接收消息。例如，我们将修改将联系人信息存储为JSON的CRUD应用程序，以便在添加新联系人时发送通知，更新联系人信息以及删除联系人时发送通知。
- en: 'We can implement this requirement by performing the following steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下步骤来实现此要求：
- en: Create message listeners that process the received messages.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建处理接收到的消息的消息监听器。
- en: Configure the application context of our application.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置我们应用程序的应用程序上下文。
- en: Send messages by using the `RedisTemplate` class.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RedisTemplate`类发送消息。
- en: This section also describes how we can ensure that our implementation is working
    correctly.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还描述了我们如何确保我们的实现工作正常。
- en: Creating message listeners
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建消息监听器
- en: 'There are two ways to create message listeners by using Spring Data Redis:
    we can implement the `MessageListener` interface or we can create a POJO message
    listener and use the `MessageListenerAdapter` class to delegate messages to it.
    Both of these approaches are discussed in this subsection.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Data Redis创建消息监听器有两种方法：我们可以实现`MessageListener`接口，或者我们可以创建一个POJO消息监听器并使用`MessageListenerAdapter`类将消息委派给它。这两种方法都在本小节中讨论。
- en: Implementing the MessageListener interface
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现MessageListener接口
- en: 'The first way to create a message listener is to implement the `MessageListener`
    interface. Our implementation includes the following steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 创建消息监听器的第一种方法是实现`MessageListener`接口。我们的实现包括以下步骤：
- en: Create a new `Logger` object that is used to log the received messages.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于记录接收到的消息的新`Logger`对象。
- en: Create a new `StringRedisSerializer` object that is used to transform byte arrays
    to `String` objects.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于将字节数组转换为`String`对象的新`StringRedisSerializer`对象。
- en: Implement the `onMessage()` method declared by the `MessageListener` interface.
    This method simply logs the received message.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`MessageListener`接口声明的`onMessage()`方法。此方法简单地记录接收到的消息。
- en: 'The source code of the `ContactListener` class is given as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactListener`类的源代码如下：'
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a POJO message listener
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个POJO消息监听器
- en: 'The second way to create message listeners is to create a normal Java class.
    We can do this by following these steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 创建消息监听器的第二种方法是创建一个普通的Java类。我们可以按照以下步骤来做到这一点：
- en: Create a new `Logger` object that is used to log the received messages.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于记录接收到的消息的新`Logger`对象。
- en: Create a message handler method called `handleMessage()` that takes the `Contact`
    object and a `String` object as parameters.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`handleMessage()`的消息处理方法，该方法接受`Contact`对象和`String`对象作为参数。
- en: Implement the `handleMessage()` method. This method logs the received message.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`handleMessage()`方法。此方法记录接收到的消息。
- en: 'The source code of the `ContactPOJOMessageListener` class is given as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactPOJOMessageListener`类的源代码如下：'
- en: '[PRE26]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Configuring the application context
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置应用程序上下文
- en: 'We have to make the following changes to the application context configuration:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对应用程序上下文配置进行以下更改：
- en: Configure the message listener beans.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置消息监听器bean。
- en: Configure a message listener adapter bean.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置消息监听适配器bean。
- en: Configure a message listener container bean.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置消息监听器容器bean。
- en: Configuring the message listener beans
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置消息监听器bean
- en: 'First, we have to configure our message listener beans. The configuration is
    rather simple. We just create new message listener objects and return the created
    objects. The source code of the message listener bean configuration is given as
    follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须配置我们的消息监听器bean。配置相当简单。我们只需创建新的消息监听器对象并返回创建的对象。消息监听器bean配置的源代码如下：
- en: '[PRE27]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Configuring the message listener adapter bean
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置消息监听器适配器bean
- en: 'Next we have to configure the message listener adapter bean that is used to
    delegate the messages forward to our POJO message listener. We can configure this
    bean by following these steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须配置消息监听器适配器bean，该bean用于将消息转发给我们的POJO消息监听器。我们可以通过以下步骤配置此bean：
- en: Create a new `MessageListenerAdapter` object and pass the `ContactPOJOMessageListener`
    object as a constructor parameter.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`MessageListenerAdapter`对象，并将`ContactPOJOMessageListener`对象作为构造函数参数传递。
- en: Set the serializer that is used to transform the received message to a `Contact`
    object.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置用于将接收到的消息转换为`Contact`对象的序列化器。
- en: Return the created object.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `messageListenerAdapter()` method is given as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`messageListenerAdapter()`方法的源代码如下：'
- en: '[PRE28]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `defaultListenerMethod` property of the `MessageListenerAdapter` class is
    used to configure the name of the message handler method. The default value of
    this property is `handleMessage`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageListenerAdapter`类的`defaultListenerMethod`属性用于配置消息处理程序方法的名称。此属性的默认值为`handleMessage`。'
- en: Configuring the message listener container bean
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置消息监听器容器bean
- en: 'The **message listener container** is a component that listens to the messages
    that are sent through the different channels and forwards these messages to the
    registered message listeners. We can configure this component by following these
    steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息监听器容器**是一个组件，它监听通过不同通道发送的消息，并将这些消息转发给注册的消息监听器。我们可以通过以下步骤配置此组件：'
- en: Create a new `RedisMessageListenerContainer` object.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`RedisMessageListenerContainer`对象。
- en: Set the used Redis connection factory.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置已使用的Redis连接工厂。
- en: Register the message listeners and specify the subscribed channels.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册消息监听器并指定订阅的通道。
- en: Return the created object.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of our configuration is given as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置源代码如下：
- en: '[PRE29]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sending messages with RedisTemplate
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RedisTemplate发送消息
- en: We can send publish messages to different channels by using the `convertAndSend(String
    channel, Object message)` method of the `RedisTemplate` class. This subsection
    describes how we can send notifications about new contacts, updated contacts,
    and removed contacts by using this method.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`RedisTemplate`类的`convertAndSend(String channel, Object message)`方法向不同的通道发送发布消息。本小节描述了如何使用此方法发送有关新联系人、更新联系人和删除联系人的通知。
- en: Create
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建
- en: 'In order to send change notifications about new contacts, we have to modify
    the `add()` method of the `RedisContactService` class to call the `convertAndSend()`
    method of the `RedisTemplate` class after the information of a new contact is
    saved successfully. The source code of our new `add()` method is given as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送有关新联系人的更改通知，我们必须修改`RedisContactService`类的`add()`方法，在成功保存新联系人信息后调用`RedisTemplate`类的`convertAndSend()`方法。我们的新`add()`方法的源代码如下：
- en: '[PRE30]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Update
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: 'We can send notifications about updated contacts by modifying the `update()`
    method of the `RedisContactService` class. We simply call the `convertAndSend()`
    method of the `RedisTemplate` class after the contact information is updated.
    The source code of the new `update()` method is given as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改`RedisContactService`类的`update()`方法，我们可以发送关于更新联系人的通知。在联系信息更新后，我们只需调用`RedisTemplate`类的`convertAndSend()`方法。新`update()`方法的源代码如下：
- en: '[PRE31]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Delete
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除
- en: 'We can send a notification about the deleted contacts by making a small change
    in the `deleteById()` method of the `RedisContactService` class. After the contact
    information is deleted, we will call the `convertAndSend()` method of the `RedisTemplate`
    class, which sends the notification message. The source code of the modified `deleteById()`
    method is given as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`RedisContactService`类的`deleteById()`方法进行小修改，我们可以发送有关已删除联系人的通知。在联系信息被删除后，我们将调用`RedisTemplate`类的`convertAndSend()`方法，该方法发送通知消息。修改后的`deleteById()`方法的源代码如下：
- en: '[PRE32]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Verifying the wanted behaviour
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证所需的行为
- en: We have now implemented our message listeners and modified our application to
    send a notification message every time the contact information is changed. Our
    next step is to verify that our implementation is working as expected.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了我们的消息监听器，并修改了我们的应用程序，以便在联系信息更改时每次发送通知消息。我们的下一步是验证我们的实现是否按预期工作。
- en: 'We can confirm this by making changes to the contact information and making
    sure that log lines written by our message listeners appear in the application''s
    log. The loglines that are written when a new contact is added are given as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改联系信息并确保我们的消息监听器写入应用程序日志中的日志行来确认这一点。当添加新联系人时写入的日志行如下：
- en: '[PRE33]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the channel information passed to a POJO message handler is always
    `null`. This is a known bug of Spring Data Redis. More information about this
    is available at [https://jira.springsource.org/browse/DATAREDIS-98](https://jira.springsource.org/browse/DATAREDIS-98).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给POJO消息处理程序的通道信息始终为`null`。这是Spring Data Redis的已知错误。有关更多信息，请访问[https://jira.springsource.org/browse/DATAREDIS-98](https://jira.springsource.org/browse/DATAREDIS-98)。
- en: Using Spring cache abstraction with Spring Data Redis
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Data Redis的Spring缓存抽象
- en: The cache abstraction of Spring Framework 3.1 applies caching to Java methods.
    When a cached method is called, the cache abstraction will check from the cache
    if the method has been called earlier by using the same parameters. If this is
    the case, then the return value is fetched from the cache and the method is not
    executed. Otherwise, the method is executed and its return value is stored in
    the cache.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 3.1的缓存抽象将缓存应用于Java方法。当调用缓存的方法时，缓存抽象将从缓存中检查该方法是否早期使用相同的参数调用过。如果是这种情况，则从缓存中获取返回值，并且不执行该方法。否则，执行该方法并将其返回值存储在缓存中。
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The cache abstraction of Spring Framework 3.1 is explained in more detail at
    [http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html](http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 3.1的缓存抽象在[http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html](http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html)中有更详细的解释。
- en: 'Spring Data Redis provides an implementation of the Spring cache abstraction.
    Using Redis as a cache has two benefits over using local caching implementations
    such as Ehcache:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data Redis提供了Spring缓存抽象的实现。使用Redis作为缓存比使用Ehcache等本地缓存实现有两个好处：
- en: It can be used as a centralized cache that is shared by each servlet container
    or application server that runs our application. This reduces the overall number
    of database queries, which reduces the load of our database server and increases
    the performance of all the servers.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以作为一个集中的缓存，被运行我们的应用程序的每个servlet容器或应用程序服务器共享。这减少了数据库查询的总体数量，减少了数据库服务器的负载，并提高了所有服务器的性能。
- en: The cache will not be emptied until we empty it. This means that we can restart
    our servlet container or application server without losing the information stored
    in the cache. After our server is restarted, it can take full advantage of the
    cached information right away. There is no need to warm up the cache.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存不会被清空，直到我们清空它。这意味着我们可以重新启动我们的servlet容器或应用程序服务器，而不会丢失缓存中存储的信息。在服务器重新启动后，它可以立即充分利用缓存的信息。无需预热缓存。
- en: 'This section describes how we can use Spring Data Redis for the purpose of
    adding a caching support to an application that uses the JPA Criteria API. This
    application has been originally introduced in [Chapter 3](ch03.html "Chapter 3. Building
    Queries with Spring Data JPA"), *Building Queries with Spring Data JPA*. The requirements
    of our caching example are as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了我们如何使用Spring Data Redis来为使用JPA Criteria API的应用程序添加缓存支持。该应用程序最初是在[第3章](ch03.html
    "第3章。使用Spring Data JPA构建查询")中介绍的，*使用Spring Data JPA构建查询*。我们缓存示例的要求如下：
- en: The method calls to the method that finds the information of a single contact
    from the database must be cached
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中查找单个联系人信息的方法调用必须被缓存
- en: When the information of a contact is updated, the information stored in the
    cache must be updated as well
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当联系人的信息被更新时，缓存中存储的信息也必须更新
- en: When a contact is deleted, the deleted contact must be removed from the cache
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当联系人被删除时，必须从缓存中删除已删除的联系人
- en: 'We can add caching support to our example application by following these steps:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤为我们的示例应用程序添加缓存支持：
- en: Configure the Spring cache abstraction.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Spring缓存抽象。
- en: Identify the cached methods.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别缓存的方法。
- en: We will also learn how we can verify that the Spring cache abstraction is working
    correctly.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何验证Spring缓存抽象是否正常工作。
- en: Configuring the Spring cache abstraction
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Spring缓存抽象
- en: 'We can configure the Spring cache abstraction by making the following changes
    to the application context configuration of our application:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对应用程序的应用程序上下文配置进行以下更改来配置Spring缓存抽象：
- en: Enable the caching annotations.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用缓存注解。
- en: Configure the host and port of the used Redis instance in the used properties
    file.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所使用的属性文件中配置所使用的Redis实例的主机和端口。
- en: Configure the Redis connection factory bean.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Redis连接工厂bean。
- en: Configure the Redis template bean.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Redis模板bean。
- en: Configure the cache manager bean.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置缓存管理器bean。
- en: Enabling caching annotations
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用缓存注解
- en: 'We can enable the caching annotations by annotating our application context
    configuration class with the `@EnableCaching` annotation. The relevant part of
    the `ApplicationContext` class is given as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`@EnableCaching`注解来注解我们的应用程序上下文配置类来启用缓存注解。`ApplicationContext`类的相关部分如下所示：
- en: '[PRE34]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Configuring the host and port of the used Redis instance
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置所使用的Redis实例的主机和端口
- en: 'In order to configure the host and port of the used Redis instance, we have
    to add the following lines to the `application.properties` file:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置所使用的Redis实例的主机和端口，我们必须在`application.properties`文件中添加以下行：
- en: '[PRE35]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Configuring the Redis connection factory bean
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Redis连接工厂bean
- en: 'We can configure the Redis connection factory bean by adding a `redisConnectionFactory()`
    method to the `ApplicationContext` class and annotating this method with the `@Bean`
    annotation. We can implement this method by following these steps:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`ApplicationContext`类中添加一个`redisConnectionFactory()`方法，并用`@Bean`注解对该方法进行注解来配置Redis连接工厂bean。我们可以通过以下步骤实现这个方法：
- en: Create a new `JedisConnectionFactory` object.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`JedisConnectionFactory`对象。
- en: Configure the host and port of the used Redis instance.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置所使用的Redis实例的主机和端口。
- en: Return the created object.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `redisConnectionFactory()` method is given as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 给出`redisConnectionFactory()`方法的源代码如下：
- en: '[PRE36]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Configuring the Redis template bean
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Redis模板bean
- en: 'In order to configure the Redis template bean, we have to add a `redisTemplate()`
    method to the `ApplicationContext` class and annotate this method with the `@Bean`
    annotation. Our implementation of this method includes the following steps:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置Redis模板bean，我们必须在`ApplicationContext`类中添加一个`redisTemplate()`方法，并用`@Bean`注解对该方法进行注解。我们对这个方法的实现包括以下步骤：
- en: Create a new `RedisTemplate` object.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`RedisTemplate`对象。
- en: Set the used Redis connection factory.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置使用的Redis连接工厂。
- en: Return the created object.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `redisTemplate()` method is given as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`redisTemplate()`方法的源代码如下：'
- en: '[PRE37]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Configuring the cache manager bean
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置缓存管理器bean
- en: 'Our last step is to configure the cache manager bean. We can do this by adding
    the `cacheManager()` method to the `ApplicationContext` class and annotating this
    method with the `@Bean` annotation. We can implement this method by following
    these steps:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是配置缓存管理器bean。我们可以通过在`ApplicationContext`类中添加`cacheManager()`方法，并用`@Bean`注解对此方法进行注释来实现这一点。我们可以通过以下步骤实现这个方法：
- en: Create a new `RedisCacheManager` object and provide the used Redis template
    as a constructor parameter.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`RedisCacheManager`对象，并将使用的Redis模板作为构造函数参数。
- en: Return the created object.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的对象。
- en: 'The source code of the `cacheManager()` method is given as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheManager()`方法的源代码如下：'
- en: '[PRE38]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Identifying the cached methods
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别缓存方法
- en: We have now configured the Spring cache abstraction and we are ready to identify
    the cached methods. This subsection describes how we can add contact information
    in the cache, update contact information that is already stored in the cache,
    and delete the contact information from the cache.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经配置了Spring缓存抽象，并且准备好识别缓存方法。本小节描述了我们如何在缓存中添加联系信息，更新已经存储在缓存中的联系信息，并从缓存中删除联系信息。
- en: Adding contact information to the cache
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将联系信息添加到缓存
- en: 'In order to add contact information to the cache, we must cache the method
    calls to the `findById()` method of the `RepositoryContactService` class. We can
    do this by annotating the method with the `@Cacheable` annotation and providing
    the name of the cache. This tells the cache abstraction that the returned contact
    should be added to the `contacts` cache by using the provided ID as a key. The
    source code of the `findById()` method is given as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将联系信息添加到缓存中，我们必须缓存`RepositoryContactService`类的`findById()`方法的方法调用。我们可以通过使用`@Cacheable`注解对方法进行注释并提供缓存的名称来实现这一点。这告诉缓存抽象应该使用提供的ID作为键，将返回的联系人添加到`contacts`缓存中。`findById()`方法的源代码如下：
- en: '[PRE39]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Updating the contact information to the cache
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将联系信息更新到缓存
- en: 'We can update the contact information that is stored in the cache by annotating
    the `update()` method of the `RepositoryContactService` class with the `@CachePut`
    annotation. We will also have to provide the name of the cache and specify that
    the `id` property of the `ContactDTO` object is used as a key when the return
    value of this method is updated to the cache. The source code of the `update()`
    method is given as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`RepositoryContactService`类的`update()`方法上注释`@CachePut`注解来更新存储在缓存中的联系信息。我们还必须提供缓存的名称，并指定当此方法的返回值更新到缓存时，`ContactDTO`对象的`id`属性将被用作键。`update()`方法的源代码如下：
- en: '[PRE40]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Deleting contact information from the cache
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从缓存中删除联系信息
- en: 'We can delete contact information from the cache by annotating the `deleteById()`
    method with the `@CacheEvict` annotation and providing the name of the cache as
    its value. This means that the cache abstraction removes the deleted contact from
    the cache after the method has been executed. The removed contact is identified
    by the ID given as a method parameter. The source code of the `deleteById()` method
    is given as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`deleteById()`方法上注释`@CacheEvict`注解并提供缓存的名称作为其值来从缓存中删除联系信息。这意味着在方法执行后，缓存抽象会从缓存中删除已删除的联系人。被删除的联系人由作为方法参数给定的ID标识。`deleteById()`方法的源代码如下：
- en: '[PRE41]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Verifying that the Spring cache abstraction is working
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证Spring缓存抽象是否正常工作
- en: 'We have now successfully added caching to our example application. We can verify
    that the Spring cache abstraction is working properly by using the cached methods
    and looking for the following lines from the log file of our application:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功地将缓存添加到我们的示例应用程序中。我们可以通过使用缓存方法并查找我们应用程序的日志文件中的以下行来验证Spring缓存抽象是否正常工作：
- en: '[PRE42]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If these lines are found from the log file it can mean that:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在日志文件中找到这些行，可能意味着：
- en: The contact information is fetched from the cache instead of the used database
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓存中获取联系信息而不是使用的数据库
- en: The contact information is updated to the cache
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系信息已更新到缓存
- en: The contact information is removed from the cache
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系信息已从缓存中删除
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have learned that:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学到：
- en: Designing a Redis data model is totally different from designing a data model
    of a relational database
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计Redis数据模型与设计关系数据库的数据模型完全不同
- en: We can use Redis as data storage of a web application
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将Redis用作Web应用程序的数据存储
- en: Spring Data Redis provides a clean integration with the Redis publish/subscribe
    implementation
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data Redis与Redis发布/订阅实现提供了清晰的集成
- en: We can use Redis as a centralized cache of our application by using the Spring
    cache abstraction
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用Spring缓存抽象将Redis作为我们应用程序的集中式缓存来使用
