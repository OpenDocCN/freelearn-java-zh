- en: Chapter 1. Spring at Glance
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章。Spring概览
- en: '*Spring the fresh new start after the winter of traditional J2EE*, is what
    Spring framework is in actual. A complete solution to the most of the problems
    occurred in handling the development of numerous complex modules collaborating
    with each other in a Java enterprise application. Spring is not a replacement
    to the traditional Java Development but it is a reliable solution to the companies
    to withstand in today''s competitive and faster growing market without forcing
    the developers to be tightly coupled on Spring APIs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*Spring，传统J2EE的冬天之后的新起点*，这就是Spring框架的真正含义。是处理Java企业应用程序中众多复杂模块相互协作开发的最问题解决方案。Spring不是传统Java开发的替代品，而是公司应对当今竞争激烈、快速发展的市场的可靠解决方案，同时不让开发者紧密依赖于Spring
    API。'
- en: 'In this topic, we will be going through the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们将涉及以下几点：
- en: Introduction to Spring framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架简介
- en: Problems address by Spring in enterprise application development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring在企业应用程序开发中解决的问题
- en: Spring road map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring路线图
- en: What's new in Spring 5.0
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 5.0的新特性
- en: Introduction to Spring framework
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: spring框架简介
- en: '* * *'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 引言
- en: Rod Johnson is an Australian computer specialist and co-founder of SpringSource.
    "Expert One on One J2EE Design and Development" was published in November 2002
    by him. This book contains about 30000 lines of code, which contains the fundamental
    concepts like **Inversion of Control** (**IoC**), **Dependency Injection** (**DI**)
    of the framework. This code is referred as interface21\. He wrote this code with
    just an intension to be used by developers to simplify their work, or they can
    use this as basis of their own development. He never thought of any framework
    development or anything like that. There happened to be a long discussion at Wrox
    Forum about the code, its improvement and lot many things. Juregen Holler and
    Yann Caroffa,were the two readers of the forum who proposed the thought of making
    the code a base of a new framework. This is the reasoning of Yann, *Spring the
    fresh new start after Winter of traditional J2EE* who names the framework as The
    Spring framework. The project went in public in June 2003 and powered towards
    1.0\. Then onwards lots of changes and up gradations took place to withstand and
    support the technologies in market. We aim in this book about the latest version
    5.0\. In couple of pages we will cover what are the new features added in this
    version. In subsequent pages we will cover how to use the latest features in your
    application and how as a developer you can take advantages of.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 罗德·约翰逊是澳大利亚计算机专家，也是SpringSource的联合创始人。《J2EE设计和发展一对一专家》于2002年11月由他出版。这本书包含大约30000行代码，其中包括框架的基本概念，如**控制反转**（**IoC**）和**依赖注入**（**DI**）。这部分代码被称为interface21。他写这部分代码的初衷只是为了方便开发者工作，或者作为他们自己开发的基石。他从未想过开发任何框架或类似的东西。在Wrox论坛上，关于代码、其改进和其他许多事情进行了长时间的讨论。论坛上的两位读者尤尔根·霍勒和扬·卡罗夫提出了将代码作为新框架基础的想法。这是扬的理由，*Spring，传统J2EE的冬天之后的新起点*，他将框架命名为Spring框架。该项目于2003年6月公开，并朝着1.0版本迈进。此后，为了支持市场上的技术，发生了许多变化和升级。本书关注的是最新版本5.0。在接下来的几页中，我们将介绍这个版本中添加的新特性。在随后的页面中，我们将介绍如何将最新特性应用于您的应用程序，以及作为开发人员如何充分利用这些特性。
- en: Problems addressed by Spring
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring解决的问题
- en: '* * *'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 引言
- en: Java Platform is long term, complex, scalable, aggressive, and rapidly developing
    platform. The application development takes place on a particular version. The
    applications need to keep on upgrading to the latest version in order to maintain
    recent standards and cope up with them. These applications have numerous classes
    which interact with each other, reuse the APIs to take their fullest advantage
    so as to make the application is running smoothly. But this leads to some very
    common problems of as.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台是一个长期、复杂、可扩展、积极进取并快速发展的平台。应用程序开发在特定的版本上进行。为了保持最新的标准和与之相适应，这些应用程序需要不断升级到最新版本。这些应用程序有大量的类相互交互，复用API以充分发挥其优势，使应用程序运行顺畅。但这导致了AS的许多常见问题。
- en: Scalability
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性
- en: The growth and development of each of the technologies in market is pretty fast
    both in hardware as well as software. The application developed, couple of years
    back may get outdated because of this growth in these areas. The market is so
    demanding that the developers need to keep on changing the application on frequent
    basis. That means whatever application we develop today should be capable of handling
    the upcoming demands and growth without affecting the working application. The
    scalability of an application is handling or supporting the handling of the increased
    load of the work to adapt to the growing environment instead of replacing them.
    The application when supports handling of increased traffic of website due to
    increase in numbers of users is a very simple example to call the application
    is scalable. As the code is tightly coupled, making it scalable becomes a problem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上的每项技术，无论是硬件还是软件，其增长和发展的速度都非常快。几年前开发的应用程序可能会因为这些领域的增长而变得过时。市场的要求如此之高，以至于开发者需要不断更新应用程序。这意味着我们今天开发的任何应用程序都应能在不影响现有运行的情况下，处理未来的需求和增长。应用程序的可扩展性是处理或支持工作负载的增加，以适应不断增长的环境，而不是替换它们。应用程序能够支持因用户数量增加而增加的网站流量，这是一个非常简单的例子，说明应用程序是可扩展的。由于代码紧密耦合，使其可扩展成为一个问题。
- en: Plumbing code
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道代码
- en: Let's take an example of configuring the DataSource in the Tomcat environment.
    Now the developers want to use this configured DataSource in the application.
    What will we do? Yes, we will do the JNDI lookup to get the DataSource. In order
    to handle JDBC we will acquire and then release the resources in `try catch`.
    The code like `try catch` as we discuss here, inter computer communication, collections
    too necessary but are not application specific are the plumbing codes. The plumbing
    code increases the length of the code and makes debugging complex.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以在Tomcat环境中配置DataSource为例。现在开发者想要在应用程序中使用这个配置的DataSource。我们会做什么？是的，我们会进行JNDI查找以获取DataSource。为了处理JDBC，我们将获取资源并在`try
    catch`中释放。像我们在这里讨论的`try catch`，计算机间的通信，集合等都是必要的，但不是特定于应用程序的，这些是管道代码。管道代码增加了代码的长度，并使调试变得复杂。
- en: Boiler plate code
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样板代码
- en: How do we get the Connection while doing JDBC? We need to register Driver class
    and invoke the `getConnection()` method on DriverManager to obtain the connection
    object. Is there any alternative to these steps? Actually NO! Whenever, wherever
    we have to do JDBC these same steps have to repeat every time. This kind of repetitive
    code, block of code which developer write at many places with little or no modification
    to achieve some task is called as Boilerplate code. The boiler plate code makes
    the Java development unnecessarily lengthier and complex.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进行JDBC时如何获取连接？我们需要注册Driver类，并在DriverManager上调用`getConnection()`方法以获取连接对象。这些步骤有其他替代方案吗？实际上没有！无论何时，无论在哪里进行JDBC，这些相同的步骤每次都必须重复。这种重复的代码，开发者在不同地方编写的代码块，少量或没有修改以实现某些任务，称为样板代码。样板代码使Java开发变得不必要地更长和更复杂。
- en: Unavoidable non-functional code
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无法避免的非功能性代码
- en: Whenever application development happens, the developer concentrate on the business
    logic, look and feel and persistency to be achieved. But along with these things
    the developers also give a rigorous thought on how to manage the transactions,
    how to handle increasing load on site, how to make the application secure and
    many more. If we give a close look, these things are not core concerns of the
    application but still these are unavoidable. Such kind of code which is not handling
    the business logic (functional) requirement but important for maintenance, trouble
    shooting, managing security of an application is called as non-functional code.
    In most of the Java application along with core concerns the developers have to
    write down non-functional code quite frequently. This leads to provide biased
    concentration on business logic development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时进行应用程序开发，开发者都会专注于业务逻辑、外观和要实现的数据持久性。但除了这些事情，开发者还会深入思考如何管理事务，如何处理网站上的增加负载，如何使应用程序安全等问题。如果我们仔细观察，这些事情并不是应用程序的核心关注点，但它们却是无法避免的。这种不处理业务逻辑（功能性）需求，但对维护、故障排除、应用程序安全等重要的代码称为非功能性代码。在大多数Java应用程序中，开发者经常不得不编写非功能性代码。这导致对业务逻辑开发产生了偏见。
- en: Unit testing of the application
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试应用程序
- en: Let's take an example. We want to test a code which is saving the data to the
    table in database. Here testing the database is not our motive, we just want to
    be sure whether the code which we have written is working fine or not. Enterprise
    Java application consists of many classes, which are interdependent. As there
    is dependency exists in the objects it becomes difficult to carry out the testing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们希望测试一段将数据保存到数据库中的代码。这里测试数据库不是我们的目的，我们只是想确定我们编写的代码是否正常工作。企业级Java应用程序由许多相互依赖的类组成。由于对象之间存在依赖，因此进行测试变得困难。
- en: Spring, mainly addresses these problematic areas and provide a very powerful
    yet easy solution with,
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Spring主要解决了这些问题，并提供了一个非常强大而又简单的解决方案，
- en: POJO based development
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于POJO的开发
- en: The class is a very basic structure of application development. If the class
    is getting extended or implementing an interface of the framework, reusing it
    becomes difficult as they are tightly coupled with API. The **Plain Old Java Object**
    (**POJO**) is very famous and regularly used terminology in Java application development.
    Unlike Struts and EJB Spring doesn't force developers to write the code which
    is importing or extending Spring APIs. The best thing about Spring is that developers
    can write the code which generally doesn't has any dependencies on framework and
    for this, POJOs are the favorite choice. POJOs support loosely coupled modules
    which are reusable and easy to test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类是应用程序开发的基本结构。如果类被扩展或实现了框架的接口，由于它们与API紧密耦合，因此复用变得困难。**普通老式Java对象**（**POJO**）在Java应用程序开发中非常著名且经常使用。与Struts和EJB不同，Spring不会强制开发者编写导入或扩展Spring
    API的代码。Spring最好的地方在于，开发者可以编写通常不依赖于框架的代码，为此，POJO是首选。POJO支持松耦合的模块，这些模块可复用且易于测试。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Spring framework is called to be non-invasive as it doesn't force the developer
    to use API classes or interfaces and allows to develop loosely coupled application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架之所以被称为非侵入性，是因为它不会强制开发者使用API类或接口，并允许开发松耦合的应用程序。
- en: Loose coupling through DI
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过依赖注入实现松耦合
- en: Coupling, is the degree of knowledge in class has about the other. When a class
    is less dependent on the design of any other class, the class will be called as
    loosely coupled. Loose coupling can be best achieved by **interface programming**.
    In the Spring framework, we can keep the dependencies of the class separated from
    the code in a separate configuration file. Using interfaces and dependency injection
    techniques provided by Spring, developers can write loosely coupled code (Don't
    worry, very soon we will discuss about Dependency Injection and how to achieve
    it). With the help of loose coupling one can write a code which needs a frequent
    change, due to the change in the dependency it has. It makes the application more
    flexible and maintainable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合度是类与类之间知识的关联程度。当一个类对其他类的设计依赖性较低时，这个类就可以被称为松耦合。松耦合最好通过**接口编程**来实现。在Spring框架中，我们可以将类的依赖关系在与代码分离的配置文件中维护。利用Spring提供的接口和依赖注入技术，开发者可以编写松耦合的代码（别担心，我们很快就会讨论依赖注入以及如何实现它）。借助松耦合，开发者可以编写出因依赖变化而需要频繁变动的代码。这使得应用程序更加灵活和易于维护。
- en: Declarative programming
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明式编程
- en: In declarative programming, the code states what is it going to perform but
    not how it will be performed. This is totally opposite of imperative programming
    where we need to state stepwise what we will execute. The declarative programming
    can be achieved using XML and annotations. Spring framework keeps all configurations
    in XML from where it can be used by the framework to maintain the lifecycle of
    a bean. As the development happened in Spring framework, the 2.0 onward version
    gave an alternative to XML configuration with a wide range of annotations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式编程中，代码声明了将要执行什么，而不是如何执行。这与命令式编程完全相反，在命令式编程中，我们需要逐步说明我们将执行什么。声明式编程可以通过XML和注解来实现。Spring框架将所有配置保存在XML中，框架可以从中维护bean的生命周期。由于Spring框架中的开发，从2.0版本开始提供了XML配置的替代方案，即使用广泛的注解。
- en: Boilerplate code reduction using aspects and templates
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用方面和模板减少样板代码
- en: We just have discussed couple of pages back that repetitive code is boilerplate
    code. The boiler plate code is essential and without which providing transactions,
    security, logging etc will become difficult. The framework gives solution of writing
    Aspect which will deal with such cross cutting concerns and no need to write them
    along with business logic code. The use of Aspect helps in reduction of boilerplate
    code but the developers still can achieve the same end effect. One more thing
    the framework provides, is the templates for different requirements. The JDBCTemplate,
    HibernateTemplate are one more useful concept given by Spring which does reduction
    of boilerplate code. But as a matter of fact, you need to wait to understand and
    discover the actual potential.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在前几页讨论过，重复的代码是样板代码。样板代码是必要的，如果没有它，提供事务、安全、日志等功能将变得困难。框架提供了解决编写处理此类交叉关注点的Aspect的方案，无需将其与业务逻辑代码一起编写。使用Aspect有助于减少样板代码，但开发者仍然可以实现相同的效果。框架提供的另一个功能是不同需求的模板。JDBCTemplate、HibernateTemplate是Spring提供的另一个有用的概念，它减少了样板代码。但事实上，你需要等待理解并发现其真正的潜力。
- en: Layered architecture
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分层架构**'
- en: Unlike Struts and Hibernate which provides web persistency solutions respectively,
    Spring has a wide range of modules for numerous enterprise development problems.
    This layered architecture helps the developer to choose any one or more of the
    modules to write solution for his application in a coherent way. E.g. one can
    choose Web MVC module to handle web request efficiently without even knowing that
    there are many other modules available in the framework.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与分别提供Web持久性解决方案的Struts和Hibernate不同，Spring有一系列广泛的模块解决多种企业开发问题。这种分层架构帮助开发者选择一个或多个模块，以一种连贯的方式为他的应用程序编写解决方案。例如，即使不知道框架中有许多其他模块，开发者也可以选择Web
    MVC模块高效处理Web请求。
- en: Spring Architecture
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Spring 架构**'
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: 'Spring provides more than 20 different modules which can be broadly summaries
    under 7 main modules which are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了超过20个不同的模块，可以大致归纳为7个主要模块，如下所示：
- en: '![](img/image_01_001.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_001.png)'
- en: Spring modules
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring模块**'
- en: Core modules
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**核心模块**'
- en: Core
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**核心**'
- en: Spring Core module supports ways of creating Spring beans and injecting the
    dependencies in beans. It provide means to configure the beans and how to obtain
    the configured beans from the Spring container using `BeanFactory` and `ApplicationCotext`
    for developing standalone application
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring核心模块**支持创建Spring bean的方法以及向bean中注入依赖。它提供了配置bean以及如何使用BeanFactory和ApplicationContext从Spring容器获取配置bean的方法，用于开发独立应用程序。'
- en: Beans
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**Beans**'
- en: The Beans module provides `BeanFactory` which provides alternative for programmatic
    singletons. The `BeanFactory` is an implementation of factory design pattern.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Beans模块**提供了**BeanFactory**，为编程单例提供了替代方案。BeanFactory是工厂设计模式的实现。'
- en: Context
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**上下文**'
- en: This module supports Java enterprise features such as EJB, JMX and basic remoting.
    It supports for integration of third party libraries for caching, Java Mailing
    and templating engines like Velocity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块支持诸如EJB、JMX和基本远程调用的Java企业特性。它支持缓存、Java邮件和模板引擎（如Velocity）的第三方库集成。
- en: SpEL
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SpEL**'
- en: Spring Expression Language (SpEL) is an extension of unified Expression Language
    which has be specified in JSP 2.1 specifications. SpEL module supports setting
    and getting of property values, configuring collections using logical as well
    as arithmetic operators, named variables from Spring IoC.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring表达式语言（SpEL）**是**统一表达式语言**的扩展，该语言已在JSP 2.1规范中指定。SpEL模块支持设置和获取属性值，使用逻辑和算术运算符配置集合，以及从Spring
    IoC中获取命名变量。'
- en: Data access and integration modules
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据访问与集成模块**'
- en: JDBC(DAO)
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**JDBC（DAO）**'
- en: This module provides abstraction layer on JDBC. It supports reduction of boiler
    plate code which occurs in getting connection object via loading of driver, getting
    statement object and many more. It also supports templates as JdbcTemplate, HibernateTemplate
    to simplify the development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块在JDBC之上提供了抽象层。它支持减少通过加载驱动器获取连接对象、获取语句对象等产生的样板代码。它还支持模板，如JdbcTemplate、HibernateTemplate，以简化开发。
- en: ORM
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**ORM**'
- en: The Object Relational Mapping (ORM) module supports integration of very popular
    frameworks like Hibernate, iBATIS, Java Persistence API(JPA), Java Data Object(JDO).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对象关系映射（ORM）模块支持与非常流行的框架（如Hibernate、iBATIS、Java持久性API（JPA）、Java数据对象（JDO））的集成。
- en: OXM
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**OXM**'
- en: The Object XML Mapper (OXM) module supports object to XML mapping and integration
    for JAXB, castor, XStream etc.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对象XML映射器（OXM）模块支持对象到XML的映射和集成，适用于JAXB、Castor、XStream等。
- en: JMS
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JMS
- en: This module provides support and provides Spring abstract layer over Java Message
    Service(JMS)for asynchronous integration with other applications via messaging.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块提供支持，并为通过消息进行异步集成的Java消息服务（JMS）提供Spring抽象层。
- en: Transaction
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事务
- en: JDBC and ORM modules handle exchange of data to-and-fro between Java application
    and database. This module supports transaction management support while working
    with ORM and JDBC modules.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC和ORM模块处理Java应用程序与数据库之间的数据交换。此模块在处理ORM和JDBC模块时支持事务管理。
- en: Web MVC and remoting modules
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web MVC和远程模块
- en: Web
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Web
- en: This module supports integration of web application created in other frameworks.
    Using this module the developers can also develop web application using Servlet
    listener. It supports multipart file uploading and handling of request and response.
    It also provides web related remoting support.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块支持与其他框架创建的web应用程序的集成。使用此模块，开发人员还可以通过Servlet监听器开发web应用程序。它支持多部分文件上传和请求与响应的处理。它还提供了与web相关的远程支持。
- en: Servlet
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Servlet
- en: This module contains Spring Model View Controller(MVC) implementation for web
    applications. Using Spring MVC developers can write handling of request and response
    to develop full-fledged web application. It helps in getting rid from the boiler
    plate code while handling request and response by supporting handling form submission.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块包含Spring模型视图控制器（MVC）实现，用于web应用程序。使用Spring MVC，开发人员可以编写处理请求和响应的代码，以开发功能齐全的web应用程序。它通过支持处理表单提交来摆脱处理请求和响应的样板代码。
- en: Portlet
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 门户
- en: The Portlet module provides MVC implementation to be used in Portlet environment
    which support Java's portlet API.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 门户模块提供了MVC实现，用于支持Java门户API的门户环境。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Portlet has been removed in Spring 5.0M1\. If you want to use Portlet you
    need to use with 4.3 module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 门户在Spring 5.0M1中被移除。如果您想使用门户，则需要使用4.3模块。
- en: WebSocket
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WebSocket
- en: WebSocket is a protocol which provides two way communications between client
    and server which has been included in Spring 4\. This module provides support
    for integration of Java WebSocket API in the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是一种协议，提供客户端与服务器之间的双向通信，已在Spring 4中包含。此模块为应用程序提供对Java WebSocket API的集成支持。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**`Struts module`** This module contains supports for integrating Struts framework
    within Spring application. But this has been deprecated in Spring 3.0'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Struts模块`** 此模块包含支持将Struts框架集成到Spring应用程序中的内容。但在Spring 3.0中已弃用。'
- en: AOP modules
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AOP模块
- en: AOP
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AOP
- en: The Aspect Oriented Programming module helps in handling and managing the cross
    cutting concern services in the application and helps in keeping the code cleaner.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 面向方面编程（AOP）模块有助于处理和管理应用程序中的交叉关注点服务，有助于保持代码的清洁。
- en: Aspects
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方面
- en: This module provides integration support with AspectJ.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块为AspectJ提供了集成支持。
- en: Instrumentation modules
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪器模块
- en: Instrumentation
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仪器
- en: Java Instrumentation gives an innovative way to access a class from JVM with
    the help of class loader and modify its byte code by inserting the custom code.
    This module supports instrumentation and class loader implementations for some
    application servers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Java仪器提供了一种创新的方法，通过类加载器帮助从JVM访问类并修改其字节码，通过插入自定义代码。此模块支持某些应用服务器的仪器和类加载器实现。
- en: Instrument Tomcat
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仪器Tomcat
- en: Instrument Tomcat module contains Spring instrumentation support for Tomcat.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器Tomcat模块包含对Tomcat的Spring仪器支持。
- en: Messaging
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息传递
- en: The messaging module provides support for STOMP as websocket protocol. It also
    has annotations for routing and processing STOMP messages received from the clients.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递模块提供了对STOMP作为WebSocket协议的支持。它还有用于路由和处理从客户端接收的STOMP消息的注解。
- en: Spring messaging module has been included in Spring 4.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 4中包含了消息传递模块。
- en: Test module
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试模块
- en: The Test module support unit as well as integration testing with JUnit and TestNG.
    It also provides support for creating mock objects to simplify testing in isolated
    environment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块支持单元以及集成测试，适用于JUnit和TestNG。它还提供创建模拟对象的支持，以简化在隔离环境中进行的测试。
- en: What more Spring supports underneath?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring还支持哪些底层技术？
- en: '* * *'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: Security module
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全模块
- en: Now a days the applications alone with basic functionalities also need to provide
    sound ways to handle security at different levels. Spring5 support declarative
    security mechanism using Spring AOP.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，仅具有基本功能的应用程序也需要提供良好的多层次安全处理方式。Spring5支持使用Spring AOP的声明式安全机制。
- en: Batch module
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量处理模块
- en: The Java Enterprise Applications needs to perform bulk processing, handling
    of large amount of data in many business solutions without user interactions.
    To handle such things in batches is the best solution available. Spring provides
    integration of batch processing to develop robust application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Java企业应用需要执行批量处理，在没有用户交互的情况下处理大量数据，这在许多商业解决方案中是必需的。以批处理方式处理这些问题是可用的最佳解决方案。Spring提供了批量处理集成，以开发健壮的应用程序。
- en: Spring integration
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Integration
- en: In the development of enterprise application, the application may need interaction
    with them. Spring integration is extension of the core spring framework to provide
    integration of other enterprise applications with the help of declarative adapters.
    The messaging is one of such integration which is extensively supported by Spring.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用的开发中，应用可能需要与它们进行交互。Spring Integration是Spring核心框架的扩展，通过声明式适配器提供与其他企业应用的集成。消息传递是此类集成中广泛支持的一项。
- en: Mobile module
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动模块
- en: The extensive use of mobiles opens the new doors in development. This module
    is an extension of Spring MVC which helps in developing mobile web applications
    known as Spring Android Project. It also provide detection of the type of device
    which is making the request and accordingly renders the views.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛使用移动设备为开发打开了新的大门。这个模块是Spring MVC的扩展，有助于开发称为Spring Android Project的手机网络应用。它还提供检测发起请求的设备类型，并相应地呈现视图。
- en: LDAP module
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LDAP模块
- en: The basic aim of Spring was to simplify the development and to reduce the boilerplate
    code. The Spring LDAP module supports easy LDAP integration using template based
    development.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的初衷是简化开发并减少 boilerplate 代码。Spring LDAP模块支持使用模板开发进行简单的LDAP集成。
- en: .NEW module
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NEW模块
- en: The new module has been introduced to support .NET platform. The modules like
    ADO.NET, NHibernate, ASP.NET has been in the .NET module includes to simplify
    the .NET development taking the advantages of features as DI, AOP, loose coupling.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了新的模块来支持.NET平台。ADO.NET、NHibernate、ASP.NET等模块包含在.NET模块中，以简化.NET开发，利用DI、AOP、松耦合等特性。
- en: Spring road map
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring 路线图
- en: '* * *'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.0 March2004
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.0 2004年3月
- en: It supports for JDO1.0 and iBATIS 1.3 with integrated with Spring transaction
    management. This version was supporting the functionalities as, Spring Core, Spring
    Context, Spring AOP, Spring DAO, Spring ORM and Spring web.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持JDO1.0和iBATIS 1.3，并与Spring事务管理集成。这个版本支持的功能有，Spring Core、Spring Context、Spring
    AOP、Spring DAO、Spring ORM和Spring web。
- en: 2.0 October 2006
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.0 2006年10月
- en: Spring framework enhanced support for Java5\. It added out of box namespaces
    like jee, tx, aop, lang, util to simplify the configuration. The IoC was supporting
    scopes as singleton and prototype. In addition to these scopes, scopes for HttpSession,
    Cluster cache and request has been also introduced. The annotation bases configuration
    as @Transactional, @Required, @PersistenceContext introduced.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架增强了Java5的支持。它添加了开箱即用的命名空间，如jee、tx、aop、lang、util，以简化配置。IoC支持单例和原型等作用域。除了这些作用域，还引入了HttpSession、集群缓存和请求的作用域。引入了基于注解的配置，如@Transactional、@Required、@PersistenceContext。
- en: 2.5 November 2007
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5 2007年11月
- en: In this version Spring supports full Java6 and JavaEE5 features as JDBC4, JavMail1.4,
    JTA1.1, JAX WS 2.0\. It also extends the support for annotation based DI including
    support for qualifier as well. A new bean named pointcut element in AspectJ pointcut
    expressions has been introduced. The build in support for AspectJ for load time
    weaving which is based on LoadTimeWeaver abstraction has been provided. For the
    convenience an introduction of custom namespaces like context, jms has been included.
    The testing support extended for Junit4 and TestNG. The annotation based SpringMVC
    controllers has been added. It also supports for auto detection of components
    on the classpath such as @Repository,@Service, @Controller and @Conponent. Now
    SimpleJdbcTemplate supports named SQL parameters. The certified WebSphere support
    has been included. It also include support for JSR-250 annotations like @Resource,PostConstruct,
    @PreDestroy
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，Spring支持完整的Java 6和Java EE 5特性，包括JDBC 4、JavMail 1.4、JTA 1.1、JAX WS 2.0。它还扩展了对基于注解的依赖注入的支持，包括对限定符的支持。引入了一个名为AspectJ切点表达式中的pointcut元素的新bean。提供了基于LoadTimeWeaver抽象的AspectJ加载时间编织的内置支持。为了方便，包含了像context、jms这样的自定义命名空间的介绍。测试支持扩展到了Junit4和TestNG。添加了基于注解的Spring
    MVC控制器。它还支持在类路径上自动检测组件，如@Repository、@Service、@Controller和@Conponent。现在SimpleJdbcTemplate支持命名SQL参数。包含了认证的WebSphere支持。还包括了对JSR-250注解的支持，如@Resource、PostConstruct、@PreDestroy。
- en: 3.0 GA December 2009
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.0 GA 2009年12月
- en: The entire code has been revised to support Java5 feature like generics, varargs.
    The Spring Expression Language(SpEL) has been introduced. It also supports for
    annotation for REST web application. It extends support for many Java EE6 features
    like JPA 2.0, JSF 2.0\. The version 3.0.5 support hibernate 3.6 final as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码已修订以支持Java 5特性，如泛型、可变参数。引入了Spring表达式语言(SpEL)。还支持REST web应用程序的注解。扩展了对许多Java
    EE 6特性的支持，如JPA 2.0、JSF 2.0。版本3.0.5还支持hibernate 3.6最终版。
- en: 3.1GA December 2011
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1GA 2011年12月
- en: In this version Testing support has been upgraded for Junit 4.9\. It also supports
    load time weaving on the WebSphere version 7 and 8.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，测试支持已升级到Junit 4.9。还支持在WebSphere版本7和8上进行加载时间编织。
- en: 4.0 December 2013
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.0 2013年12月
- en: For very first time the full support for java 8 features has been included.
    This version uses JavaEE 6 as its baseline. Using Spring 4, now it is possible
    to define external bean configuration using Groovy DSL. Developers now can treat
    generic types as a form of qualifier. @Lazy annotation can be used on injection
    points as well as on @Bean definitions. The @Description has been introduced for
    developers using Java Based configuration. The @Conditional annotation has been
    introduced for conditional filtering. Now, there is no requirement to have default
    constructor to be used byCGLIB based proxy classes. The @RestController has been
    introduced to remove need of @ResponseBody to each of @RequestMapping, The AsynchRestTemplate
    has been included which allows non blocking asynchronous support for REST client
    development. The spring-websocket introduced as new model to provide support for
    WebSocket based two way communication between server and client. The spring- messaging
    module has been introduced for the support of WebSocket sub protocol STOMP. Most
    of the annotations from spring-test module can now be used as meta annotations
    to create custom composed annotations. The set of the mocks from org.springframework.mock.web
    is based on Servlet API 3.0
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首次全面支持Java 8特性。这个版本使用Java EE 6作为其基础。使用Spring 4，现在可以定义使用Groovy DSL的外部bean配置。开发者现在可以将泛型类型作为一种限定符形式。@Lazy注解可以用于注入点以及@Bean定义。为了开发者使用基于Java的配置，引入了@Description注解。引入了@Conditional注解进行条件过滤。现在，不再需要默认构造函数供CGLIB基于的代理类使用。引入了@RestController以去除对每个@RequestMapping的@ResponseBody的需求。包括了AsynchRestTemplate，它允许非阻塞异步支持REST客户端开发。作为新的模型引入了spring-websocket，以提供对基于WebSocket的服务器和客户端之间的双向通信的支持。引入了spring-messaging模块以支持WebSocket子协议STOMP。现在可以作为元注解使用大部分来自spring-test模块的注解来创建自定义组合注解。org.springframework.mock.web包中的mocks基于Servlet
    API 3.0。
- en: 5.0 M1 Q4 2016
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.0 M1 Q4 2016
- en: Spring 5M1 will support Java8+ but basically, it aims to track and support greatly
    to the new bee Java9\. It also will support reactive programming Spring 5 will
    focus on HTT2.0\. It also aims to focus on reactive programming through reactive
    architecture. The mock.staticmock from spring-aspects, web.view.tiles2 has been
    dropped. No more support for Portlet, Velocity, JasperReports, XMLBeans, JDO,
    Guava.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5M1将支持Java8+，但基本上，它旨在跟踪并对Java9的新特性提供大量支持。它还将支持响应式编程Spring 5将专注于HTT2.0。它还通过响应式架构关注响应式编程。spring-aspects中的mock.staticmock和web.view.tiles2已经被移除。不再支持Portlet、Velocity、JasperReports、XMLBeans、JDO、Guava。
- en: 'It can be summarized as shown in the following figure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以总结如下：
- en: '![](img/image_01_002.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_002.png)'
- en: Spring modules
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Spring模块
- en: Container-The heart of Spring
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器-Spring的心脏
- en: '* * *'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: POJO development is the backbone of Spring framework. The POJO configured in
    the and whose object instantiation, object assembly, object management is done
    by Spring IoC container is called as bean or Spring bean. We use Spring IoC as
    it on the pattern of Inversion of Control.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: POJO开发是Spring框架的基石。在Spring中配置的POJO，其对象的实例化、对象组装、对象管理都是由Spring IoC容器完成的，称为bean或Spring
    bean。我们使用Spring IoC，因为它遵循控制反转的模式。
- en: Inversion of Control (IoC)
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制反转（IoC）
- en: In every Java application, the first important thing which each developer does
    is, to get an object which he can use in the application. The state of an object
    can be obtained at runtime or it may be at compile time. But developers creates
    object where he use boiler plate code at a number of times. When the same developer
    uses Spring instead of creating object by himself he will be dependent on the
    framework to obtain object from. The term inversion of control comes as Spring
    container inverts the responsibility of object creation from developers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一个Java应用程序中，每位开发者做的第一件重要的事情就是获取一个可以在应用程序中使用的对象。一个对象的状况可以在运行时获得，也可能在编译时获得。但是开发者通常在多次使用样板代码时创建对象。当同一个开发者使用Spring而不是亲自创建对象时，他将依赖于框架来获取对象。控制反转（IoC）这个术语是因为Spring容器将对象创建的责任从开发者那里反转过来。
- en: Spring IoC container is just a terminology, the Spring framework provides two
    containers
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Spring IoC容器只是一个术语，Spring框架提供了两个容器
- en: The BeanFactory
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeanFactory
- en: The ApplicationContext
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序上下文（ApplicationContext）
- en: The BeanFactory-The history
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BeanFactory的历史
- en: The `BeanFactory` container provides the basic functionalities and framework
    configuration. Now a days, developers won't prefer to use BeanFactory. Now the
    obvious question comes to your mind then why BeanFactory is still in framerwork?
    Why has it not been removed? If not BeanFactory, then what's the alternative?
    Let's answer them one by one. The very simple answer of BeanFactory in framework
    is to support for backward compatibility of JDK1.4\. The beanFactory provides
    BeanFactoryAware, InitializingBean, DisposableBean interfaces to support backward
    compatibility for third party framework which has integration with Spring.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: BeanFactory容器提供了基本功能和框架配置。现在，开发者不会倾向于使用BeanFactory。那么，为什么BeanFactory仍然在框架中呢？为什么没有被移除呢？如果没有BeanFactory，那么替代品是什么？让我们逐一回答这些问题。BeanFactory在框架中的一个非常简单的答案是为了支持JDK1.4的向后兼容性。BeanFactory提供了BeanFactoryAware、InitializingBean、DisposableBean接口，以支持与Spring集成的第三方框架的向后兼容性。
- en: XMLBeanFactory
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: XMLBeanFactory
- en: Today's enterprise application development demands much more than ordinary development.
    The Developer will be happy to get a helping hand for managing the object life
    cycle, injecting the dependencies or reduction in boilerplate code from the IoC
    container. XMLBeanFactory is a common implementation of BeanFactory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的企业应用程序开发需求远超过普通开发。开发者将很高兴能得到帮助来管理对象生命周期、注入依赖项或减少IoC容器的样板代码。XMLBeanFactory是BeanFactory的常见实现。
- en: 'Let''s find out practically how the BeanFactory container get initialized:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际找出BeanFactory容器是如何初始化的：
- en: Create a Java application with the name `Ch01_Container_Initialization`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Ch01_Container_Initialization`的Java应用程序。
- en: 'Add the jars as shown in the following snapshot:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下快照添加jar包：
- en: '![](img/image_01_003.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_003.png)'
- en: Jars to be added
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的jar包
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that you are using JRE to 1.8 as it's a baseline for Spring5.0.0.M1.
    You can download the jars from...............
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用的是JRE 1.8，因为它 是Spring5.0.0.M1的基础。你可以从...............下载jar包。
- en: Create a class `TestBeanFactory` under the package `com.ch01.test` package.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.ch01.test`包下创建一个名为`TestBeanFactory`的类。
- en: Create a XML file `beans_classpath.xml` in the classpath where we can write
    bean definitions later. Each beans definition file contains the referencing schema
    to beans.xsd of the particular Spring version. The root tag of this XML file will
    be `<beans>`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径中创建一个名为`beans_classpath.xml`的XML文件，我们可以在以后编写bean定义。每个bean定义文件都包含对特定Spring版本的beans.xsd的引用。这个XML文件的根标签将是`<beans>`。
- en: 'Basic structure of the XML file is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: XML文件的基本结构如下：
- en: '[PRE0]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our XML file contains the same code as shown above without any beans configured.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的XML文件包含上述相同的代码，没有配置任何bean。
- en: 'In the main function lets'' write down the code to initialize the bean factory
    as shown:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在main函数中，让我们写下初始化bean工厂的代码，如下所示：
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the `bean_classpath.xml` will contain the beans definitions (For simplicity,
    we haven't added any bean definition, we will see it in detail in next chapter).
    The `ClassPathResource` loads the resource from the classpath.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bean_classpath.xml`将包含bean定义（为了简单起见，我们没有添加任何bean定义，我们将在下一章详细介绍）。`ClassPathResource`从类路径加载资源。
- en: 'Sometimes the resource will not be in the classpath and it will be in the filesystem.
    The following code can be used to load the resource from filesystem:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时资源不会在类路径中，而是在文件系统中。以下代码可用于从文件系统加载资源：
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need to create `bean_fileSystem.xml` on D drive which will contain the same
    content as that of `bean_classpath.xml`. The complete code will be as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在D驱动器上创建`bean_fileSystem.xml`，它将包含与`bean_classpath.xml`相同的内容。完整代码如下：
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There will not be any output on console apart from logging information of spring
    container as we haven''t written any output code here. But the following snapshot
    shows the XML file loads and the container got initialized:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里没有编写任何输出代码，除了Spring容器的日志信息外，控制台上不会有任何输出。但以下快照显示了XML文件加载并初始化了容器：
- en: '![](img/image_01_004.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_004.png)'
- en: The console logger output
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台日志输出
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: BeanFactory doesn't support multiple configuration files.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: BeanFactory不支持多个配置文件。
- en: 'The ApplicationContext: The present'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序上下文：现状
- en: The registration of BeanProcessor and BeanFactoryPostProcessor which plays important
    role in AOP and property place holders, needs the explicit code writing which
    makes it inconvenient to work with. Developers don't want to write the code which
    supports internationalization. The event publication to handle AOP integration
    is unavoidable. The web application needs to have application layer specific context.
    To all of these the simple solution is to expand the services provided by BeanFactory
    with ApplicationContext. The ApplicationContext is not replacement of BeanFactory
    but it's an extension for enterprise specific solutions and more advance mechanism
    for bean configuration.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注册BeanProcessor和BeanFactoryPostProcessor在AOP和属性占位符中扮演重要角色，需要显式编写代码，这使得与其配合变得不方便。开发者不想编写支持国际化的代码。处理AOP集成的事件发布是不可避免的。Web应用程序需要具有特定于应用层的内容。对于这些问题，简单的解决方案是扩展BeanFactory提供的服务，以支持ApplicationContext。ApplicationContext不是BeanFactory的替代品，而是针对企业特定解决方案的扩展，以及为bean配置提供更多高级机制。
- en: Let's look at the implementations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看实现。
- en: ClassPathXmlApplicationContext
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ClassPathXmlApplicationContext
- en: The subclass of AbstractXmlApplicationContext is used for Satndalone applications.
    It uses bean configured XML file from the class path. It the conditions of having
    more than one XML configuration files later bean definition from the XML file
    will override the earlier bean definition. It provides the advantage of writing
    new bean definition to replace the previous one.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于独立应用程序，使用AbstractXmlApplicationContext的子类。它使用类路径中的配置的bean XML文件。如果有多个XML配置文件，后来的bean定义将覆盖先前的bean定义。它提供了编写新bean定义以替换先前的定义的优势。
- en: 'Let''s find out practically how the `ClassPathXmlApplicationContext` container
    gets initialized. We will use the same `Ch01_Container_Initialization` project
    by following the steps as:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际找出`ClassPathXmlApplicationContext`容器是如何初始化的。我们将使用相同的`Ch01_Container_Initialization`项目，按照以下步骤进行：
- en: Create a class `TestClasspathApplicationContext` under the package `com.ch01.test`
    package.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.ch01.test`包下创建一个名为`TestClasspathApplicationContext`的类。
- en: Create a new XML file `beans_classpath.xml` in classpath as we had created in
    previous application.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的应用程序中，像以前一样在类路径中创建一个名为`beans_classpath.xml`的XML文件。
- en: 'In the main function let''s write down the code to initialize the bean factory
    as shown in the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在main函数中，让我们写下初始化bean工厂的代码，如下所示：
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: No need to create XML file as we already had created it for the previous example.
    `ClassPathXmlApplicationContext` loads the `bean_classpath.xml` file from the
    classpath which contains the beans definitions (For simplicity we haven't added
    any bean definition, we will see it in detail in next chapter).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要创建XML文件，因为我们已经在之前的示例中创建了它。`ClassPathXmlApplicationContext`从类路径加载`bean_classpath.xml`文件，其中包含bean定义（为了简单起见，我们没有添加任何bean定义，我们将在下一章详细介绍）。
- en: 'Run the application which will give the following output suggesting the container
    created successfully:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，输出以下内容，表明容器成功创建：
- en: '![](img/image_01_005.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_005.png)'
- en: Console output
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出
- en: 'In Java enterprise application, the project can have multiple configuration
    files as it''s easy to maintain and support modularity as well. To load multiple
    bean configuration files we can use the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java企业应用程序中，项目可以有多个配置文件，因为这样可以容易地维护和支持模块化。要加载多个bean配置文件，我们可以使用以下代码：
- en: '[PRE5]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To use the preceding code of lines we need to create `beans_classpath1.xml`
    in classpath.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面的代码行，我们需要在类路径中创建`beans_classpath1.xml`。
- en: FileSystemXmlApplicationContext
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FileSystemXmlApplicationContext
- en: Similar to ClassPathXmlApplicationContext this class also extends AbstractXmlApplicationContext
    and is used for standalone applications. But this class helps to load the bean
    XML definition from the file system. The file path it relative to the current
    working directory. In case of specifying the absolute file path one can use `file:`
    as prefix. It also provides the advantage of writing new bean definition to replace
    the previous one in case of having multiple XML configurations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与ClassPathXmlApplicationContext类似，这个类也扩展了AbstractXmlApplicationContext，用于独立应用程序。但这个类有助于从文件系统加载bean的XML定义。文件路径相对于当前工作目录。如果指定绝对文件路径，可以使用`file:`作为前缀。它还提供了在有多个XML配置的情况下，编写新的bean定义以替换之前的定义的优势。
- en: 'Let''s find out practically how the `ClassPathXmlApplicationContext` container
    gets initialized. We will use the same `Ch01_Container_Initialization` project
    by following the steps as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际找出`ClassPathXmlApplicationContext`容器是如何初始化的。我们将按照以下步骤使用相同的`Ch01_Container_Initialization`项目：
- en: Create a class `TestFileSystemApplicationContext` under the package `com.ch01.test`
    package.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.ch01.test`包下创建一个名为`TestFileSystemApplicationContext`的类。
- en: Create a new XML file `beans_fileSystem.xml` in D drive we had created in previous
    application.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前应用程序中创建的D驱动器上创建一个新的XML文件`beans_fileSystem.xml`。
- en: 'In the main function, let''s write down the code to initialize the bean factory
    as shown in the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，让我们写下以下代码来初始化bean工厂：
- en: '[PRE6]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`FileSystemXmlApplicationContext` loads the `bean_fileSystem.xml` file from
    the path specified.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystemXmlApplicationContext`从指定路径加载`bean_fileSystem.xml`文件。'
- en: Run the application which will give the following output suggesting the container
    created successfully.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，将给出以下输出，表明容器已成功创建。
- en: 'The structure of project discussed above will be as shown in the following
    snapshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述讨论的项目结构将如下所示：
- en: '![](img/image_01_006.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_006.png)'
- en: Project directory structure
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 项目目录结构
- en: WebXmlApplicationContext
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WebXmlApplicationContext
- en: The AbstractRefreshableWebApplicationContext has been extended by WebXmlApplicationContext.
    We can write the context definition in related to root application context in
    `applicationContext.xml` and keep it under WEB-INF as its the default location
    from where the context definition will be loaded. The XXX-servlet.xml file is
    loaded to load the controller definition as in case of MVC we application. Also,
    we can override the default locations by configuring `contextConfigLocation` for
    the `context-param` and `init-param`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebXmlApplicationContext`继承了`AbstractRefreshableWebApplicationContext`。我们可以在`applicationContext.xml`中编写与根应用程序上下文相关的上下文定义，并将其放在WEB-INF下，因为这是默认的位置，从这里加载上下文定义。`XXX-servlet.xml`文件用于加载控制器定义，正如在MVC应用程序中所示。此外，我们可以通过为`context-param`和`init-param`配置`contextConfigLocation`来覆盖默认位置。'
- en: How beans are available from container?
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器中如何获取bean？
- en: '* * *'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Yes, beans or object of beans will not be available without doing anything from
    development side. Spring manages bean but what to manage has to be decided and
    pass on to the container. Spring supports declarative programming via XML file
    configuration. The beans definitions configured in XML file loaded by the container
    and using org.springframework.beans the object instantiation and the property
    value injection takes place. Bean lifecycle explain the stages, phases or activities
    through which each bean object goes through from making the object usable by application
    till its cleaned up and removed from the container when application doesn't required
    by the application. We will discuss in next chapter the detail initialization
    process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，如果不从开发方面做任何事情，豆子或豆子对象将无法获得。Spring 管理豆子，但是必须决定要管理什么，并将其传递给容器。Spring 通过 XML
    文件配置支持声明式编程。在 XML 文件中配置的豆子定义由容器加载，并使用 org.springframework.beans 在容器中实例化对象和注入属性值。豆子生命周期解释了每个豆子对象从使对象可供应用程序使用直至应用程序不再需要时将其清理并从容器中移除的各个阶段、阶段或活动。我们将在下一章讨论详细的初始化过程。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '* * *'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This chapter gives an overview of Spring framework. We discussed about the general
    problems faced in Java enterprise application development and how they have been
    address by Spring framework. We have seen the overall major changes happened in
    each version of Spring from its first introduction in market. The backbone of
    Spring framework is the bean. We use Spring to simplify the work of managing them
    by the container. We discuss in detail about two Spring containers BeanFactory
    and ApplicationContext and how they can be used by the developers. The containers
    are involved in process of bean lifecycle management. In next chapter we are aiming
    to discuss in depth about the bean state management with a very famous terminology
    Dependency Injection and the bean life cycle management in detail.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了 Spring 框架。我们讨论了在 Java 企业应用程序开发中遇到的通用问题以及 Spring 框架是如何解决它们的。我们看到了自 Spring
    首次进入市场以来每个版本中发生的重大变化。Spring 框架的核心是豆子。我们使用 Spring 来简化容器管理它们的工作。我们详细讨论了两个 Spring
    容器 BeanFactory 和 ApplicationContext，以及开发人员如何使用它们。容器参与了豆子生命周期管理的过程。在下一章，我们旨在深入讨论关于豆子状态管理以及一个非常著名的术语依赖注入和豆子生命周期管理。
