- en: Chapter 10. Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。最佳实践
- en: '"It is insanity to keep doing things the same way and expect things to improve."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “继续以同样的方式做事并期望事情变得更好是一种疯狂。”
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Anonymous
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——匿名
- en: Writing clean, readable, and maintainable JUnit test cases, just like writing
    clean code, is an art. A well-written unit test can prevent maintenance nightmare
    and acts as a system documentation; however, if not used carefully, it can produce
    meaningless boilerplate test cases. Mistakes are part of the learning process
    as long as you aren't making them repeatedly. JUnit is not rocket science, so
    we can practice, follow guidelines, and learn from others to make it perfect.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 就像编写干净的代码一样，编写干净、可读和可维护的JUnit测试用例是一门艺术。一个编写良好的单元测试可以防止维护噩梦，并作为系统文档；然而，如果不小心使用，它可能会产生无意义的样板测试用例。只要你不反复犯错误，错误就是学习过程的一部分。JUnit不是火箭科学，所以我们可以练习、遵循指南并从他人那里学习，使其完美。
- en: 'This chapter covers JUnit guidelines and best practices. The following categories
    are covered in depth:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了JUnit指南和最佳实践。以下类别将深入探讨：
- en: Writing meaningful tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写有意义的测试
- en: Test automation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试自动化
- en: Test configuration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试配置
- en: Assertion convention
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言约定
- en: Exception handling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Test smells and refactoring test smells
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试异味和重构测试异味
- en: Writing meaningful tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写有意义的测试
- en: The common understanding of unit testing is testing the smallest possible part
    of software, specifically a method. In reality, we do not test methods; rather,
    we test a logical unit or the behavior of the system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的普遍理解是测试软件中最小可能的组成部分，具体来说是一个方法。实际上，我们并不测试方法；而是测试一个逻辑单元或系统的行为。
- en: Logical units can extent to a single method, to an entire class, or a collaboration
    of multiple classes. For example, a standard calculator program can have an add
    method for adding two numbers. We can verify the add behavior by invoking the
    `add` method, or we can design the calculator program to have a simple calculate
    API that can take two numbers and an operation (add, subtract, divide, and so
    on), and depending on the operand type (integer, double, and so on), the calculator
    may delegate the calculation to a collaborator class, such as a double calculator
    or a long calculator. We can still unit test the add behavior, but now multiple
    classes are involved. We can call this new test an integration test.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑单元可以扩展到单个方法、整个类或多个类的协作。例如，一个标准的计算器程序可以有一个加法方法来添加两个数字。我们可以通过调用`add`方法来验证加法行为，或者我们可以设计计算器程序以拥有一个简单的计算API，该API可以接受两个数字和一个操作（加、减、除等），并根据操作数类型（整数、双精度浮点数等），计算器可能会将计算委托给协作类，例如双精度计算器或长计算器。我们仍然可以单元测试加法行为，但现在涉及到多个类。我们可以称这个新的测试为集成测试。
- en: A unit test verifies an assumption about the behavior of the system. In addition
    to this, if a test tests the entire system, it can't be a unit test—we call these
    tests **confederation** tests because they set up the entire ecosystem, including
    setting up the necessary components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试验证关于系统行为的假设。除此之外，如果一个测试测试整个系统，它就不能是单元测试——我们称这些测试为**联盟**测试，因为它们设置了整个生态系统，包括设置必要的组件。
- en: The following section elaborates on writing meaningful tests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分详细阐述了编写有意义的测试。
- en: Improving readability
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高可读性
- en: Martin Fowler said *Any fool can write code that a computer can understand.
    Good programmers write code that humans can understand*. Writing obscure code
    can be fashionable for old timers but it's not a standard Java practice. We should
    write readable and maintainable code such that anybody can understand the purpose
    of the code and enhance or maintain the code in future.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒说：“任何傻瓜都能写出计算机能理解的代码。优秀的程序员编写的是人类能理解的代码。”编写晦涩的代码可能对老手来说很时髦，但这不是标准的Java实践。我们应该编写可读性和可维护的代码，以便任何人都能理解代码的目的，并在将来增强或维护代码。
- en: JUnit tests are written to test logical units. A test method name should portray
    the intention of the test so that a reader can understand what is being tested,
    such as the condition and the expectation or action.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 测试是编写来测试逻辑单元的。一个测试方法的名字应该表达测试的意图，以便读者可以理解正在测试的内容，例如条件、期望或动作。
- en: 'Suppose you are writing a test for a role-based system and the system denies
    unauthorized access. You can use the following patterns, but if you choose to
    follow one pattern, it''s best to stick to it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个基于角色的系统的测试，并且系统拒绝未授权的访问。你可以使用以下模式，但如果你选择遵循一种模式，最好是坚持使用它：
- en: '`testDenialOfUnauthorizedAccess()`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testDenialOfUnauthorizedAccess()`'
- en: '`when_unauthorized_user_then_denies_the_access()`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when_unauthorized_user_then_denies_the_access()`'
- en: '`should_deny_access_for_unauthorized_users()`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should_deny_access_for_unauthorized_users()`'
- en: I prefer the underscore (_) pattern as it's more readable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢下划线 (_) 模式，因为它更易读。
- en: 'For boundary value conditions, you can follow these patterns:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于边界值条件，你可以遵循以下模式：
- en: '`testRegisteringNullUser()`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testRegisteringNullUser()`'
- en: '`should_not_register_a_null_user()`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should_not_register_a_null_user()`'
- en: '`should_throw_exception_when_a_null_user_is_registered()`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should_throw_exception_when_a_null_user_is_registered()`'
- en: '`when_null_user_then_registrar_throws_exception()`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when_null_user_then_registrar_throws_exception()`'
- en: Likewise, a test class should portray the intention of the tests. Usually, we
    follow two conventions, `Test<class name>` or `<class name>Test`. Suppose you
    are testing the `UserRegistration` behavior. You can use `UserRegistrationTest`
    or `TestUserRegistration`. Several test coverage tools fail to recognize classes
    without the `Test` suffix. So, `UserRegistrationTest` is a safe choice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，测试类应该描绘测试的意图。通常，我们遵循两种约定，`Test<class name>` 或 `<class name>Test`。假设你正在测试
    `UserRegistration` 行为。你可以使用 `UserRegistrationTest` 或 `TestUserRegistration`。一些测试覆盖率工具无法识别没有
    `Test` 后缀的类。因此，`UserRegistrationTest` 是一个安全的选择。
- en: Breaking everything that could possibly break
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破坏所有可能出错的东西
- en: An Extreme Programming concept is *test everything that could possibly break*.
    This means trying all different combinations of inputs to make sure we don't miss
    any combination that can cause the class to generate an error. However, this is
    an impossible thing to do in practice. We can test boundary value conditions.
    We can even cover all branches and lines, but we cannot test all input combinations.
    Suppose a method adds two integers. We can pass `NULL`, `0`, `Integer.MAX_VALUE`,
    negative numbers, and so on, but we literally cannot test the method with all
    possible integer values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 极限编程的一个概念是*测试所有可能出错的东西*。这意味着尝试所有不同的输入组合，以确保我们没有错过任何可能导致类生成错误的组合。然而，在实践中这是不可能做到的。我们可以测试边界值条件。我们甚至可以覆盖所有分支和行，但我们不能测试所有可能的输入组合。假设一个方法添加两个整数。我们可以传递
    `NULL`、`0`、`Integer.MAX_VALUE`、负数等，但我们实际上不能测试所有可能的整数值。
- en: Ignoring simple test cases
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略简单的测试用例
- en: Writing trivial JUnits (such that for getter and setter) is mostly a waste of
    time and money. We don't have the luxury to write infinite tests as it can eat
    our development time, application build time, and reduce test maintainability.
    If we start writing tests for getter/setters, we may miss more useful test cases.
    Usually, unit tests are automated and run during a build process. A build is required
    to finish early providing feedback, but the process will be delayed if we keep
    adding trivial tests. Unit tests are system documentation, so they portray the
    system behavior; however, if we keep adding tests for trivial things, then it
    defeats the purpose. Write tests that will pay you back with information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编写简单的 JUnit 测试（例如对于 getter 和 setter）通常是时间和金钱的浪费。我们没有写无限测试的奢侈，因为这会消耗我们的开发时间、应用程序构建时间和降低测试的可维护性。如果我们开始为
    getter/setter 编写测试，我们可能会错过更多有用的测试用例。通常，单元测试是自动化的，并在构建过程中运行。构建需要尽早完成以提供反馈，但如果我们继续添加简单的测试，这个过程将会延迟。单元测试是系统文档，因此它们描绘了系统行为；然而，如果我们继续为简单的事情添加测试，那么就违背了其目的。编写能够提供信息的测试。
- en: Verifying invalid parameters
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证无效参数
- en: Test invalid parameters to every method. Your code needs to recognize and handle
    invalid data. The tests that pass using incorrect data and boundary value conditions
    provide comprehensive API documentation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 测试每个方法的无效参数。你的代码需要识别和处理无效数据。使用错误数据和边界值条件通过的测试提供了全面的 API 文档。
- en: 'Suppose you are writing a test for an `add` method. It takes two integers and
    returns an integer. The following is the `Adder` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个针对 `add` 方法的测试。它接受两个整数并返回一个整数。以下是一个 `Adder` 类：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The boundary values that can be tested are null, zero, negative numbers, and
    overflow conditions, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以测试的边界值包括 null、零、负数和溢出条件，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your class may have a public API that accepts user input and delegates input
    formatting to a dependent class or method. You should verify the user input in
    the public API only, not on all methods or dependent classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你的类可能有一个接受用户输入并将输入格式化委托给依赖类或方法的公共 API。你应该只在公共 API 中验证用户输入，而不是在所有方法或依赖类中。
- en: Suppose the class `A` has a `doSomething(String input)` method. `A` calls `B`
    to format the input. If clients can call only class `A`, then you should not worry
    about validating the null input in class `B`. However, if both `A` and `B` are
    exposed, then `B` definitely should check for the `NULL` values. Checking `NULL`
    everywhere is defensive programming.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设类`A`有一个`doSomething(String input)`方法。`A`调用`B`来格式化输入。如果客户端只能调用类`A`，那么你不需要担心在类`B`中验证空输入。然而，如果`A`和`B`都公开，那么`B`肯定应该检查`NULL`值。在所有地方检查`NULL`是防御性编程。
- en: Relying on direct testing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖于直接测试
- en: 'Suppose you have a facade class that depends on a utility class. Testing the
    facade class can cover the utility class. This is an example of indirect testing.
    The following `Facade` class depends on a `StringService` class for formatting;
    when we test the `Facade` class with a `String` value, then the `StringService`
    class is also tested:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个依赖于实用工具类的门面类。测试门面类可以覆盖实用工具类。这是一个间接测试的例子。以下`Facade`类依赖于`StringService`类进行格式化；当我们用`String`值测试`Facade`类时，`StringService`类也被测试：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We should test `StringService` directly, even though its methods are also invoked
    by the tests of the `Facade` class. We should have two test classes: `FacadeTest`
    and `StringServiceTest`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其方法也被`Facade`类的测试调用，我们应该直接测试`StringService`。我们应该有两个测试类：`FacadeTest`和`StringServiceTest`。
- en: It's not a good idea to rely on indirect testing because if we change the implementation
    of the `Facade` class, then the dependent class may be uncovered. Suppose we change
    the implementation of the `Facade` class, so that it no longer depends on `StringService`.
    The tests in `StringServiceTest` will no longer invoke the methods of `StringService`,
    so we will lose code coverage.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于间接测试不是一个好主意，因为如果我们更改`Facade`类的实现，那么依赖的类可能会被揭露。假设我们更改`Facade`类的实现，使其不再依赖于`StringService`。`StringServiceTest`中的测试将不再调用`StringService`的方法，因此我们将失去代码覆盖率。
- en: Staying away from debugging
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免调试
- en: A common practice when we find a bug is to start debugging an application—stop
    doing this. Rather, add more tests to break the code; this will enrich your test
    suite and improve the system documentation. Similarly, don't put a catch block
    to print stacktrace. Rather, assert the exception message using the `ExpectedException`
    rule (explained in the *Handling exceptions* section). Sometimes, it's not possible
    to avoid debugging entirely. So anyway, before starting to debug, create a (integration)
    test that reproduces the issue and then debug it. This will narrow down the problem,
    create a unit test for the lowest possible unit, and keep both the tests for future
    reference.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发现一个错误时，通常的做法是开始调试应用程序——停止这样做。相反，添加更多测试来破坏代码；这将丰富你的测试套件并改进系统文档。同样，不要添加捕获块来打印堆栈跟踪。相反，使用`ExpectedException`规则（在*处理异常*部分中解释）断言异常消息。有时，完全避免调试是不可能的。所以无论如何，在开始调试之前，创建一个（集成）测试来重现问题，然后进行调试。这将缩小问题范围，为最低可能的单元创建单元测试，并保留测试供将来参考。
- en: Avoiding generic matchers
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用泛型匹配器
- en: We tend to use wildcard matchers to stub mock object methods; in the same way,
    verify the method invocations with generic matchers. This is a bad practice; you
    should go for an exact parameter match when possible. The following example demonstrates
    the wildcard argument matching.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于使用通配符匹配器来模拟模拟对象的方法；同样，使用泛型匹配器验证方法调用。这是一个坏习惯；当可能时，你应该追求精确的参数匹配。以下示例演示了通配符参数匹配。
- en: 'The `StringDecorator` class decorates the input with an exclamation symbol:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringDecorator`类使用感叹号装饰输入：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `PrinterService` interface connects to a LAN printer and prints the input
    text as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrinterService`接口连接到局域网打印机，并按如下方式打印输入文本：'
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Facade` class accepts an input, decorates the input, and sends it to `PrinterService`
    for printing. To unit test this behavior, we need to mock out `PrinterService`
    with a mock object using the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Facade`类接受一个输入，装饰该输入，并将其发送到`PrinterService`进行打印。为了测试这种行为，我们需要使用以下代码使用模拟对象模拟`PrinterService`：'
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Generally, `PrintService` is stubbed with an `anyString()`generic matcher,
    and the `PrintService` call is verified using `verify(mockService).print(anyString());`,
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`PrintService`使用`anyString()`泛型匹配器进行模拟，并使用`verify(mockService).print(anyString());`进行`PrintService`调用的验证，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can use `eq("hello!")` instead of `anyString()`, as we know the `StringDecorator`
    method appends an exclamation to the `String` input; the test will fail if the
    `StringDecorator` method doesn't append the exclamation symbol. So, the side effects
    of `StringDecorator` can be identified immediately.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `eq("hello!")` 而不是 `anyString()`，因为我们知道 `StringDecorator` 方法会在 `String`
    输入后添加感叹号；如果 `StringDecorator` 方法没有添加感叹号，测试将失败。因此，`StringDecorator` 的副作用可以立即识别。
- en: Keeping away from @ignore
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用 @ignore
- en: Do not skip unit tests using the `@ignore` or `@exclude` annotations. As we
    know dead code removal is a refactoring technique, dead codes are never used.
    However, they create confusion. Similarly, when we ignore tests using the `@ignore`
    annotations, the tests are skipped, but the code remains in the file as dead code
    and creates confusion. Unit tests that are skipped provide no benefit. Instead
    of skipping unit tests, remove them from source control. If you need the test,
    you can get it from the source control history. Sometimes people create tests
    to easily understand some sort of APIs, but they don't want the tests to be executed
    when the test suite runs, or it may not be possible to run some tests on all platforms.
    With Maven (and Gradle), you can have different profiles with different test suites.
    For utility tests, it's always helpful to create a specific module for this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `@ignore` 或 `@exclude` 注解跳过单元测试。正如我们所知，死代码删除是一种重构技术，死代码永远不会被使用。然而，它们会制造混乱。同样，当我们使用
    `@ignore` 注解忽略测试时，测试会被跳过，但代码仍然保留在文件中作为死代码，造成混乱。跳过的单元测试没有任何好处。与其跳过单元测试，不如从源代码控制中删除它们。如果你需要测试，你可以从源代码控制的历史记录中获取它。有时人们创建测试以轻松理解某种API，但他们不希望当测试套件运行时执行测试，或者可能无法在所有平台上运行某些测试。对于Maven（和Gradle），你可以有不同的配置文件和不同的测试套件。对于实用程序测试，创建一个特定的模块总是有帮助的。
- en: Eluding debug messages
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免调试信息
- en: In early days, we used print (`System.out` or `System.err`) messages to console
    for debugging or unit testing code. Unit tests are system documentation, and a
    print statement does not fit in there. If you need to print something, just write
    a test and assert the expected value. Also, you can add a logging utility such
    as Log4J and log the debug messages. If a problem occurs in production, you just
    turn on these logs and see what's going on there to be able to reproduce the issue
    with tests better. So, tests and logs should rather complement each other.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，我们使用打印（`System.out` 或 `System.err`）消息到控制台进行调试或单元测试代码。单元测试是系统文档，打印语句不适合那里。如果你需要打印某些内容，只需编写一个测试并断言期望的值。此外，你可以添加一个日志工具，如Log4J，并记录调试信息。如果在生产中出现问题时，只需打开这些日志并查看那里发生了什么，以便能够通过测试更好地重现问题。因此，测试和日志应该相互补充。
- en: Automating JUnit tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化JUnit测试
- en: '[Chapter 2](part0018_split_000.html#page "Chapter 2. Automating JUnit Tests"),
    *Automating JUnit Tests*, covered the importance of test automation, CI, and test
    automation with Gradle, Maven, and Ant. This section reiterates the benefits of
    test automation.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](part0018_split_000.html#page "第二章. 自动化JUnit测试")，*自动化JUnit测试*，讨论了测试自动化、持续集成以及使用Gradle、Maven和Ant进行测试自动化的重要性。本节重申了测试自动化的好处。'
- en: 'The following are the benefits of test automation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些测试自动化的好处：
- en: Assumptions are continually verified. We refactor the code (change the internal
    structure of the code without affecting the output of the system) to improve code
    quality such as maintainability, readability, or extensibility. We can refactor
    the code with confidence if automated unit tests are running and providing feedback.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设不断得到验证。我们重构代码（在不影响系统输出结构的情况下改变代码的内部结构）以提高代码质量，如可维护性、可读性或可扩展性。如果自动化的单元测试正在运行并提供反馈，我们可以有信心地重构代码。
- en: Side effects are detected immediately. This is useful for fragile, tightly coupled
    systems when a change in one module breaks another module.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用会被立即检测到。这对于脆弱、紧密耦合的系统很有用，当一个模块发生变化时，可能会破坏另一个模块。
- en: Test automation saves time and there is no need of immediate regression testing.
    Suppose you are adding a scientific computation behavior to an existing calculator
    program and modifying the code. After every piece of change, you perform regression
    testing to verify the integrity of the system. Regression testing is tedious and
    time consuming, but if you have an automated unit test suite, then you can delay
    the regression testing until the functionality is done. This is because the automated
    suite will inform you at every stage if you disrupt an existing feature.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试节省时间，不需要立即进行回归测试。假设您正在向现有的计算器程序添加科学计算行为并修改代码。每次更改后，您都执行回归测试以验证系统的完整性。回归测试很繁琐且耗时，但如果您有一个自动化的单元测试套件，那么您可以在功能完成之前推迟回归测试。这是因为自动化套件会在每个阶段通知您是否破坏了现有功能。
- en: Always integrate your JUnits with build script and configure CI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 总是将您的JUnit与构建脚本集成并配置持续集成。
- en: Configuring tests
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置测试
- en: 'This section deals with the test configuration. Unit tests are not testing
    the system. In TDD, unit tests are written to obtain the following benefits:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节处理测试配置。单元测试不是在测试系统。在TDD中，单元测试是为了获得以下好处而编写的：
- en: They drive your design. You write a test, add code to fix the test, refactor
    code with confidence, and apply the design. This results in a simple, clean, maintainable,
    loosely coupled, and cohesive design. You write code to satisfy a failing test,
    so it limits the code you write to only what is needed.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们驱动着您的设计。您编写一个测试，添加代码以修复测试，有信心地重构代码，并应用设计。这导致了一个简单、干净、易于维护、松散耦合且紧密的设计。您编写代码以满足失败的测试，因此它限制了您编写的代码仅限于所需的内容。
- en: The tests provide fast, automated regression for refactoring and enhancing the
    code.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试提供了快速、自动化的重构和代码增强。
- en: 'You should configure your tests to follow the following principles:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该配置您的测试以遵循以下原则：
- en: Unit tests should be executed extremely fast so that they can provide quick
    feedback. Would you withdraw money from an ATM that takes 10 minutes to dispense
    money?
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该执行得非常快，以便它们可以提供快速反馈。您会从需要10分钟才能取款的ATM机中取款吗？
- en: Tests should be reliable. Tests should fail if the production code is broken.
    Your tests will be considered unreliable in situations where you break the production
    logic but the tests pass, or you don't touch the production code but still your
    tests fail.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该是可靠的。如果生产代码有误，测试应该失败。在您破坏了生产逻辑但测试通过，或者您没有修改生产代码但测试仍然失败的情况下，您的测试将被视为不可靠。
- en: The following section covers the test configuration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涵盖了测试配置。
- en: Running in-memory tests
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行内存测试
- en: Do not write unit tests that make HTTP requests, look up JNDI resources, access
    a database, call SOAP-based web services, or read from the filesystem. These actions
    are slow and unreliable, so they should not be considered as unit tests; rather,
    they are integration tests. You can mock out such external dependencies using
    Mockito. [Chapter 4](part0027_split_000.html#page "Chapter 4. Progressive Mockito"),
    *Progressive Mockito*, explains the mocking external dependencies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不要编写执行HTTP请求、查找JNDI资源、访问数据库、调用基于SOAP的Web服务或从文件系统中读取的单元测试。这些操作很慢且不可靠，因此不应被视为单元测试；相反，它们是集成测试。您可以使用Mockito模拟这些外部依赖。[第4章](part0027_split_000.html#page
    "第4章。渐进式Mockito")，*渐进式Mockito*，解释了如何模拟外部依赖。
- en: Staying away from Thread.sleep
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用`Thread.sleep`
- en: '`Thread.sleep` is used in the production code to halt the current execution
    for some time so that the current execution can sync up with the system, such
    that the current thread waits for a resource used by another thread. Why do we
    need `Thread.sleep` in a unit test? Unit tests are meant to get executed faster.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.sleep`在生产代码中用于暂停当前执行一段时间，以便当前执行可以与系统同步，这样当前线程就可以等待另一个线程使用的资源。为什么在单元测试中需要`Thread.sleep`？单元测试的目的是要快速执行。'
- en: '`Thread.sleep` can be used to wait for a long running process (this is usually
    used to test concurrency), but what if the process takes time in a slow machine?
    The test will fail though the code is not broken, and this defeats the test reliability
    principle. Avoid using `Thread.sleep` in unit tests; rather, simulate the long
    running process using a mock object.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.sleep`可以用来等待长时间运行的过程（这通常用于测试并发），但如果在慢速机器上这个过程需要时间呢？尽管代码没有错误，测试仍然会失败，这违反了测试可靠性原则。避免在单元测试中使用`Thread.sleep`；相反，使用模拟对象模拟长时间运行的过程。'
- en: Keeping unit tests away from the production code
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将单元测试与生产代码隔离开
- en: Don't deliver unit tests to customers; they are not going to execute the tests.
    The test code should be separated from the production code. Keep them in their
    respective source directory tree with the same package naming structure. This
    will keep them separate during a build.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将单元测试交付给客户；他们不会执行这些测试。测试代码应该与生产代码分离。将它们保存在各自的源目录树中，并使用相同的包命名结构。这将确保在构建过程中它们是分开的。
- en: 'The following Eclipse screenshot shows the separate source folder structure.
    Source files are located under the `src` folder, and the tests are placed under
    the `test` source folder. Note that the `Adder.java` and `AdderTest.java` files
    are placed in the same package named `com.packt.bestpractices.invalidinput`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Eclipse截图显示了单独的源文件夹结构。源文件位于`src`文件夹下，测试文件位于`test`源文件夹下。请注意，`Adder.java`和`AdderTest.java`文件被放置在名为`com.packt.bestpractices.invalidinput`的同一包中：
- en: '![Keeping unit tests away from the production code](img/00131.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![将单元测试与生产代码分离](img/00131.jpeg)'
- en: Avoiding static variables
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用静态变量
- en: Static variables hold state. When you use a static variable in your test, it
    signifies that you want to save the state of something. So, you are creating inter-test
    dependency. If the execution order changes, the test will fail though the code
    is not broken, and this defeats the test reliability principle. Do not use static
    variables in unit tests to store global state.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量持有状态。当您在测试中使用静态变量时，这表示您想要保存某个状态。因此，您正在创建测试之间的依赖关系。如果执行顺序改变，即使代码没有出错，测试也会失败，这违反了测试可靠性原则。不要在单元测试中使用静态变量来存储全局状态。
- en: Don't initialize the class to be tested as static and use the `setUp` method
    (annotated with `@Before`) to initialize objects. These will protect you from
    accidental modification problems. The following example demonstrates the accidental
    modification side effects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将待测试的类初始化为静态，并使用`setUp`方法（带有`@Before`注解）来初始化对象。这将保护您免受意外修改问题的影响。以下示例演示了意外修改的副作用。
- en: 'The `Employee` class stores employee names:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`类存储员工姓名：'
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `HRService` class has a `generateUniqueIdFor(Employee emp)` method. It
    returns a unique employee ID based on the surname. Two employees with the surname
    Smith will have the IDs `smith01` and `smith02`, respectively. Consider the following
    code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`HRService`类有一个`generateUniqueIdFor(Employee emp)`方法。它根据姓氏返回一个唯一的员工ID。具有姓氏Smith的两个员工将分别具有ID`smith01`和`smith02`。考虑以下代码：'
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The unit test class initializes the service as static. The service stores the
    input of the first test and fails the second test, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试类将服务初始化为静态。服务存储了第一个测试的输入，并导致第二个测试失败，如下所示：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following JUnit output shows the error details:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下JUnit输出显示了错误详情：
- en: '![Avoiding static variables](img/00132.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![避免使用静态变量](img/00132.jpeg)'
- en: Assuming the test execution order
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设测试执行顺序
- en: JUnit was designed to execute the tests in random order. It depends on the Java
    reflection API to execute the tests. So, the execution of one test should not
    depend on another. Suppose you are testing the database integration of `EmployeeService`,
    where the `createEmployee()` test creates a new `Employee`, `updateEmployee()`
    method and updates the new employee created in `createEmployee()`, and `deleteEmployee()`
    deletes the employee. So, we are dependent on the test execution order; if `deleteEmployee()`
    or `updateEmployee()` is executed before `createEmployee()`, the test will fail
    as the employee is not created yet.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit被设计为以随机顺序执行测试。它依赖于Java反射API来执行测试。因此，一个测试的执行不应依赖于另一个测试。假设您正在测试`EmployeeService`的数据库集成，其中`createEmployee()`测试创建了一个新的`Employee`，`updateEmployee()`方法更新了在`createEmployee()`中创建的新员工，而`deleteEmployee()`删除了员工。因此，我们依赖于测试执行顺序；如果`deleteEmployee()`或`updateEmployee()`在`createEmployee()`之前执行，测试将失败，因为员工尚未创建。
- en: To fix this problem, just merge the tests into a single test named `verifyEmployeePersistence()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，只需将测试合并为一个名为`verifyEmployeePersistence()`的单个测试即可。
- en: So, don't believe in the test execution order; if you have to change one test
    case, then you need to make changes in multiple test cases unnecessarily.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要相信测试执行顺序；如果您必须更改一个测试用例，那么您需要在多个不必要的测试用例中进行更改。
- en: Loading data from files
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件加载数据
- en: The JUnit `Theory` framework offers an `abstract` class `ParameterSupplier`
    for supplying test data for test cases. The `ParameterSupplier` implementation
    can read from a filesystem, such as a CSV or an Excel file. However, it is not
    recommended that you read from the filesystem. This is because reading a file
    is an I/O (input/output) process, and it is unpredictable and slow. We don't want
    our tests to create a delay. Also, reading from a hardcoded file path may fail
    in different machines. Instead of reading from a file, create a test data supplier
    class and return the hardcoded data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit `理论`框架提供了一个用于为测试用例提供测试数据的`抽象`类`ParameterSupplier`。`ParameterSupplier`的实现可以从文件系统读取，例如CSV或Excel文件。然而，不建议您从文件系统读取。这是因为读取文件是一个I/O（输入/输出）过程，它是不可预测且缓慢的。我们不希望我们的测试创建延迟。此外，从硬编码的文件路径读取可能会在不同机器上失败。而不是从文件读取，创建一个测试数据提供者类并返回硬编码的数据。
- en: Invoking super.setUp() and super.tearDown()
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用`super.setUp()`和`super.tearDown()`
- en: Sometimes the data setup for unit testing is monotonous and ugly. Often, we
    create a base test class, set up the data, and create subclasses to use the data.
    From subclasses, always invoke the setup of the super classes and teardown methods.
    The following example shows the fault of not invoking the super class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时单元测试的数据设置单调且丑陋。通常，我们创建一个基本测试类，设置数据，并创建子类来使用这些数据。从子类中，始终调用超类的设置和拆卸方法。以下示例显示了未调用超类的方法的错误。
- en: 'We have `EmployeeService` and `EmployeeServiceImpl` to perform some business
    logic:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`EmployeeService`和`EmployeeServiceImpl`来执行一些业务逻辑：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `BaseEmployeeTest` class is an `abstract` class, and it sets up the data
    for subclasses, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseEmployeeTest`类是一个`抽象`类，并为子类设置数据，如下所示：'
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `EmployeeServiceTest` class extends the `BaseEmployeeTest` class and uses
    the `employee` map, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeServiceTest`类扩展了`BaseEmployeeTest`类并使用`employee`映射，如下所示：'
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The test execution fails with a `NullPointerException`. The following is the
    JUnit output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 测试执行失败，抛出`NullPointerException`。以下是JUnit输出：
- en: '![Invoking super.setUp() and super.tearDown()](img/00133.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![调用super.setUp()和super.tearDown()](img/00133.jpeg)'
- en: 'To fix this, call `super.setUp()` from the `setUp()` method. The following
    is the modified `setUp()` method in `EmployeeServiceTest`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，请在`setUp()`方法中调用`super.setUp()`。以下是在`EmployeeServiceTest`中修改后的`setUp()`方法：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Staying away from side effects
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免副作用
- en: Do not write test cases that affect the data of other test cases, for example,
    you are examining the JDBC API call using an in-memory `HashMap` and a test case
    clears the map, or you are testing the database integration and a test case deletes
    the data from the database. It may affect the other test cases or external systems.
    When a test case removes data from a database, any application using the data
    can fail. It's important to roll back the changes in the final block and not just
    at the end of the test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不要编写影响其他测试用例数据的测试用例，例如，您正在使用内存中的`HashMap`检查JDBC API调用，而另一个测试用例清除了该映射，或者您正在测试数据库集成，而另一个测试用例从数据库中删除了数据。这可能会影响其他测试用例或外部系统。当一个测试用例从数据库中删除数据时，任何使用这些数据的应用程序都可能失败。在测试的最后块中回滚更改非常重要，而不仅仅是测试结束时。
- en: Working with locales
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与区域设置一起工作
- en: Be aware of internationalization while working with `NumberFormat`, `DateFormat`,
    `DecimalFormat`, and `TimeZones`. Unit tests can fail if they are run on a machine
    with a different locale.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`NumberFormat`、`DateFormat`、`DecimalFormat`和`TimeZones`时要注意国际化。如果在一个具有不同区域设置的机器上运行单元测试，测试可能会失败。
- en: The following example demonstrates the internationalization context.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了国际化上下文。
- en: 'Suppose you have a class that formats money. When you pass 100.99, it rounds
    up the amount to 101.00\. The following formatter class uses `NumberFormat` to
    add a currency symbol and format the amount:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个格式化货币的类。当您传递100.99时，它将金额四舍五入到101.00。以下格式化器类使用`NumberFormat`添加货币符号并格式化金额：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following JUnit test verifies the formatting:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下JUnit测试验证了格式化：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run this test in a different locale, the test will fail. We can simulate
    this by changing the locale and restoring back to the default locale, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在不同的区域设置下运行此测试，测试将失败。我们可以通过更改区域设置并恢复到默认区域设置来模拟这种情况，如下所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before test execution, the default locale value is stored to `defaultLocale`,
    the default locale is changed to `GERMANY`, and after test execution, the default
    locale is restored. The following is the JUnit execution failure output. In `GERMANY`,
    the currency will be formatted to **101,00 €** but our test expects **$101.00**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试执行之前，默认的区域设置值被存储到 `defaultLocale`，默认的区域设置为 `GERMANY`，在测试执行之后，默认的区域设置被恢复。以下是在
    `GERMANY` 中JUnit执行失败的输出。在 `GERMANY` 中，货币将被格式化为 **101,00 €**，但我们的测试期望的是 **$101.00**：
- en: '![Working with locales](img/00134.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![使用区域设置](img/00134.jpeg)'
- en: You can change your code to always return the USD format, or you can change
    your test to run in the US locale by changing the default locale to US, and after
    test execution, restore it back to the default one. Similarly, be careful while
    working with date and decimal formatters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的代码修改为始终返回美元格式，或者你可以将测试修改为在 US 区域设置下运行，通过将默认区域设置更改为 US，并在测试执行后将其恢复到默认设置。同样，在处理日期和小数格式化时也要小心。
- en: Working with dates
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用日期
- en: If not used carefully, dates may act bizarrely in tests. Be careful when using
    hardcoded dates in unit tests. You are working with dates and checking business
    logic with a future date. On January 1, 2014, you set a future date as April 10,
    2014\. The test works fine till April 9 and starts failing thereafter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用不当，日期在测试中可能会表现得异常。在使用硬编码的日期进行单元测试时要小心。你正在处理日期，并使用未来的日期来检查业务逻辑。在2014年1月1日，你将未来的日期设置为2014年4月10日。测试在4月9日之前运行正常，之后开始失败。
- en: 'Do not use hardcoded dates. Instead use `Calendar` to get the current date
    and time and add `MONTH`, `DATE`, `YEAR`, `HOUR`, `MINUTE`, or `SECOND` to it
    to get a future date time. The following self explanatory code snippet demonstrates
    how to create a dynamic future date:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用硬编码的日期。相反，使用 `Calendar` 获取当前日期和时间，并添加 `MONTH`、`DATE`、`YEAR`、`HOUR`、`MINUTE`
    或 `SECOND` 来获取未来的日期时间。以下自解释的代码片段演示了如何创建动态的未来日期：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following are the future dates when the program was run on April 16, 2014:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在2014年4月16日运行程序时的未来日期：
- en: '![Working with dates](img/00135.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![使用日期](img/00135.jpeg)'
- en: Working with assertions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断言
- en: An assertion is a predicate used to verify a programmer assumption (expectation)
    with an actual outcome of a program implementation. For example, a programmer
    can expect that the addition of two positive numbers will result in a positive
    number. So, the programmer can write a program to add two numbers and assert the
    expected result with the actual result.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是一个用于验证程序员假设（期望）与程序实现的实际结果的谓词。例如，程序员可以期望两个正数的相加将得到一个正数。因此，程序员可以编写一个程序来相加两个数，并用实际结果断言预期的结果。
- en: The `org.junit.Assert` package provides static overloaded methods for asserting
    expected and actual values for all primitive types, objects, and arrays.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.junit.Assert` 包提供了用于断言所有原始类型、对象和数组的预期和实际值的静态重载方法。'
- en: This section covers the proper usage of the `Assertion` APIs. The following
    are the best practices.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 `Assertion` API 的正确用法。以下是一些最佳实践。
- en: Using the correct assertion
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用正确的断言
- en: 'Use the correct assertion method. JUnit supports many assertion options, such
    as `assertEquals`, `assertTrue`, `assertFalse`, `assertNull`, `assertNotNull`,
    `assertSame`, and `assertThat`. Use the most appropriate one. The following are
    the examples:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的断言方法。JUnit 支持许多断言选项，例如 `assertEquals`、`assertTrue`、`assertFalse`、`assertNull`、`assertNotNull`、`assertSame`
    和 `assertThat`。使用最合适的一个。以下是一些示例：
- en: Use `assertTrue(yourClass.someMethod())` instead of using `assertEquals(true,
    yourClass.someMethod())`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `assertTrue(yourClass.someMethod())` 而不是使用 `assertEquals(true, yourClass.someMethod())`
- en: Use `assertFalse(yourClass.someMethod())` instead of calling `assertTrue(!yourClass.someMethod())`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `assertFalse(yourClass.someMethod())` 而不是调用 `assertTrue(!yourClass.someMethod())`
- en: Use `assertNull(yourClass.someMethod())` rather than `assertEquals(null, yourClass.someMethod())`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `assertNull(yourClass.someMethod())` 而不是 `assertEquals(null, yourClass.someMethod())`
- en: Use `assertEquals(expected, yourClass.someMethod())` instead of using `assertTrue(expected.equals(yourClass.someMethod()))`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `assertEquals(expected, yourClass.someMethod())` 而不是使用 `assertTrue(expected.equals(yourClass.someMethod()))`
- en: The `assertThat(age, is(30))` method is more readable than `assertEquals(30,
    age)`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThat(age, is(30))` 方法比 `assertEquals(30, age)` 更易读。'
- en: Similarly, `assertThat(age, is(not(33)))` is more readable than `assertTrue(age
    != 33)`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，`assertThat(age, is(not(33)))` 比起 `assertTrue(age != 33)` 更易读。
- en: Maintaining the assertEquals parameter order
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护 assertEquals 参数顺序
- en: The `assertEquals` method is a very useful method to verify the expectation.
    The `assertEquals` method has the `assertEquals(Object expected, Object actual)`
    signature.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertEquals` 方法是一个非常有用的方法来验证期望。`assertEquals` 方法具有 `assertEquals(Object expected,
    Object actual)` 签名。'
- en: 'Maintain the parameter order: first the expected value and then the actual
    result. The following JUnit snippet reverses the order, passes the actual value
    first, and then the expected result:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 维护参数顺序：首先是期望值，然后是实际结果。以下 JUnit 碎片颠倒了顺序，首先传递实际值，然后是期望结果：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the `Assertion` failure output with an informative message:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有信息性消息的 `Assertion` 失败输出：
- en: '![Maintaining the assertEquals parameter order](img/00137.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![维护 assertEquals 参数顺序](img/00137.jpeg)'
- en: Striving for one assertion per test
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 力求每个测试一个断言
- en: Strive for one assertion per test method. When you check one assertion per test
    and a unit test fails, it is much easier to determine what went wrong. When a
    unit test has more than one assertion, and one assertion fails, extra effort is
    required to determine which one failed; for one assertion per test, no extra effort
    is required.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 力求每个测试方法一个断言。当你检查每个测试的一个断言并且单元测试失败时，确定出了什么问题要容易得多。当一个单元测试有多个断言，并且其中一个断言失败时，需要额外的努力来确定哪个失败了；对于每个测试一个断言，不需要额外的努力。
- en: When a unit test performs more than one assertion, and a runtime exception is
    thrown, the assertions after the exception do not get verified; the JUnit framework
    marks the unit test as erroneous and proceeds to the next test method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元测试执行多个断言并且抛出运行时异常时，异常之后的断言不会得到验证；JUnit 框架将单元测试标记为错误并继续下一个测试方法。
- en: 'The following JUnit test asserts three conditions—the formatted amount is not
    null, the formatted amount contains a $ symbol, and the exact formatting:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 JUnit 测试断言了三个条件——格式化的金额不为空，格式化的金额包含一个 $ 符号，以及精确的格式：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When any assertion fails, the output doesn''t tell you what is wrong (you get
    the line number in the source code file, though, it is not very convenient to
    work with). The following is the JUnit output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何断言失败时，输出不会告诉你哪里出了问题（尽管你会在源代码文件中得到行号，但这并不非常方便）。以下是 JUnit 输出：
- en: '![Striving for one assertion per test](img/00138.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![力求每个测试一个断言](img/00138.jpeg)'
- en: 'Instead of using three assertions, you can create three tests, or you can pass
    meaningful error messages to the assertion methods. The following JUnit test is
    modified to pass error messages:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用三个断言，你可以创建三个测试，或者你可以向断言方法传递有意义的错误信息。以下修改后的 JUnit 测试传递了错误信息：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, the failing test gives you additional information about the failure. The
    following is the test output. It reads **Currency is not USD($)**, which means
    the second assertion failed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，失败的测试为你提供了关于失败额外的信息。以下是测试输出。它读取为**货币不是 USD($)**，这意味着第二个断言失败了：
- en: '![Striving for one assertion per test](img/00139.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![力求每个测试一个断言](img/00139.jpeg)'
- en: Handling exceptions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'Exception handling is an important part of Java coding. The Java community
    follows a set of best practices about exception handling. The following are the
    exception handling best practices for unit testing:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是 Java 编码的重要部分。Java 社区遵循一套关于异常处理的最佳实践。以下是一些单元测试的异常处理最佳实践：
- en: 'Do not write catch blocks to pass a unit test. Consider the following example
    where a `Calculator` program has a `divide` method. It takes two integers, divides,
    and returns a result. When `divide` encounters a divide by zero, the program should
    throw an exception. The following is the code:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写 catch 块来通过单元测试。考虑以下示例，其中有一个 `Calculator` 程序，它有一个 `divide` 方法。它接受两个整数，进行除法并返回结果。当
    `divide` 遇到除以零时，程序应该抛出异常。以下是其代码：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the test:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个测试：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Instead of catching `ArithmeticException`, we can apply the JUnit 4 pattern
    as follows:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是捕获 `ArithmeticException`，我们可以应用 JUnit 4 模式如下：
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A more elegant way is to check the `ExpectedException` rule. The following
    is the modified test with `ExpectedException`:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个更优雅的方法是检查 `ExpectedException` 规则。以下是使用 `ExpectedException` 修改后的测试：
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ExpectedException` expects an exception and an error message. If the exception
    is not thrown, or the message doesn''t match, the test fails.'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ExpectedException` 期望一个异常和一个错误消息。如果未抛出异常或消息不匹配，则测试失败。'
- en: 'Do not write catch blocks to fail a test; the JUnit framework takes care of
    runtime exceptions. The following is an example of an unnecessary catch block:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写 catch 块来使测试失败；JUnit 框架负责处理运行时异常。以下是一个不必要的 catch 块的示例：
- en: '[PRE27]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Instead, just write the following lines. The test will fail automatically if
    any exception is thrown:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，只需写下以下几行。如果抛出任何异常，测试将自动失败：
- en: '[PRE28]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Do not catch an exception and assert the failure to pass a test. The following
    test code catches `ArithmeticException` and sets a Boolean flag, and finally asserts
    the flag. If no exception is thrown, the flag remains false and the test fails:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要捕获异常并断言失败以通过测试。以下测试代码捕获`ArithmeticException`并设置一个布尔标志，最后断言该标志。如果没有抛出异常，则标志保持为false，测试失败：
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Use the JUnit 4 patterns explained in the preceding example.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用前面示例中解释的JUnit 4模式。
- en: 'Do not add catch blocks to test a method that throws **checked** exceptions.
    The following example explains the problem. The `sum(int… arg)` method throws
    a `NumberOverflowException` checked exception when the integer overflows:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要向抛出**检查**异常的方法添加捕获块。以下示例解释了问题。`sum(int... arg)`方法在整数溢出时抛出检查异常`NumberOverflowException`：
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A catch block is used to catch a checked exception and compile the test, as
    follows:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用捕获块来捕获检查异常并编译测试，如下所示：
- en: '[PRE31]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Do not follow this pattern; instead, use `throws Exception`. The following
    JUnit test uses the `throws Exception` clause:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要遵循这个模式；相反，使用`throws Exception`。以下JUnit测试使用了`throws Exception`子句：
- en: '[PRE32]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Do not throw specific `Exceptions` from your tests. Instead, use the generic
    `throws Exception`.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要从你的测试中抛出特定的`Exceptions`。相反，使用通用的`throws Exception`。
- en: 'The following example throws a specific `NumberOverflowException` exception:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例抛出了特定的`NumberOverflowException`异常：
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Suppose the code is changed such that it could throw either `NumberOverflowException`
    or a `ParseException`. In that case, we have to change the test method to throw
    both the exceptions to compile the test. If we use the generic `throws Exception`
    clause, then this problem won't arise.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设代码被更改，可能会抛出`NumberOverflowException`或`ParseException`。在这种情况下，我们必须更改测试方法以抛出这两个异常来编译测试。如果我们使用通用的`throws
    Exception`子句，那么这个问题就不会出现。
- en: Working with test smells
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与测试异味（test smells）一起工作
- en: 'Code smell is a technical debt or symptom that indicates a deeper problem.
    Smells are not bugs, or they don''t fail tests. Instead, they indicate a problem
    in design or code such that a rigid code cannot be enhanced or can create a maintenance
    issue. This section covers the test smells that should be refactored for maintenance
    and readability. The following topics are covered:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味是一个技术债务或症状，表明存在更深层次的问题。异味不是错误，或者它们不会使测试失败。相反，它们表明设计或代码中存在一个问题，使得僵化的代码无法增强或可能创建维护问题。本节涵盖了应该重构以进行维护和可读性的测试异味。以下主题被涵盖：
- en: Test code duplication
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码重复
- en: Conditions in test code
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码中的条件
- en: Test logic in the production code
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成代码中的测试逻辑
- en: Over engineering
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度设计
- en: Refactoring duplicates
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构重复
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Two `Person` objects and two `Address` objects are created and initialized.
    They are logically duplicate statements. Many other tests can write similar duplicate
    statements. Extract the method to refactor the duplicate smell. Extract the builder
    methods for the `Person` and `Address` objects as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并初始化了两个`Person`对象和两个`Address`对象。它们是逻辑上重复的语句。许多其他测试可以编写类似的重复语句。提取方法以重构重复异味。按照以下方式提取`Person`和`Address`对象的构建方法：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'From the test code, just pass the required values and call the build methods
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试代码中，只需传递所需的值并按照以下方式调用构建方法：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can refactor the duplicate code in many test classes by moving the common
    code to a base test class or a helper class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将公共代码移动到基测试类或辅助类来重构许多测试类中的重复代码。
- en: Refactoring the test control logic
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构测试控制逻辑
- en: Unit test code verifies the behavior of the code under test, and usually, no
    conditional logic is written to verify the code. However, when a test contains
    code that is executed based on some condition, it gets complicated for the reader.
    The test executes fine but creates a maintainability problem.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试代码验证被测试代码的行为，通常不会编写条件逻辑来验证代码。然而，当测试包含基于某些条件的执行代码时，对读者来说会变得复杂。测试执行良好，但会创建维护问题。
- en: When we post JMS messages to a destination (such as the TIBCO Enterprise Messaging
    Service), internally, the JMS provider posts administrative messages such as message
    received, message sent, and message acknowledged. However, each message contains
    the same JMS message ID. If we create a message logger program to listen to the
    JMS events (including administrative events), and log all events to a database
    for an audit trail, then the logger will save many messages with the same JMS
    message ID.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 JMS 消息发布到目的地（如 TIBCO 企业消息服务）时，JMS 提供商内部会发布管理消息，例如消息接收、消息发送和消息确认。然而，每个消息都包含相同的
    JMS 消息 ID。如果我们创建一个消息记录程序来监听 JMS 事件（包括管理事件），并将所有事件记录到数据库以供审计跟踪，那么记录器将保存许多具有相同 JMS
    消息 ID 的消息。
- en: 'The following is an example of the test control logic. The message is defined
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个测试控制逻辑的示例。消息定义如下：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `eventType` variable indicates the administrative message type (received
    is 1, sent is 2, and acknowledged is 3).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`eventType` 变量表示管理消息类型（接收的是 1，发送的是 2，确认的是 3）。'
- en: 'The `MessagingService` interface is defined as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagingService` 接口定义如下：'
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We''ll verify the logging capability as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式验证日志功能：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Test` method loops through the messages, finds a message, and then verifies
    the payload. The test contains logic. Do we need another test for this test? This
    is confusing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test` 方法遍历消息，找到一条消息，然后验证负载。测试包含逻辑。我们是否需要为这个测试再进行另一个测试？这很令人困惑。'
- en: To refactor our test, you can move the logic to the code under test. The API
    should have a method to return a specific type of message. That way, we can check
    the message object directly instead of looping and checking.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要重构我们的测试，可以将逻辑移动到被测试的代码中。API 应该有一个方法来返回特定类型的消息。这样，我们就可以直接检查消息对象，而不是循环检查。
- en: Removing the test logic from the production code
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从生产代码中移除测试逻辑
- en: Writing code for testability is a quality. Often, we put testing logic into
    the production code for unit testing, such as a new constructor or new method.
    To make the code testable, the tests require extra logic in production code to
    gain access to the code's internal state for testing configuration or result verification.
    Testing logic in production code is a smell, though it doesn't break the code
    under test but increases the complexity of the code, and this can create severe
    maintainability problems or system failure if anything gets misconfigured.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可测试的代码是一种质量。通常，我们将测试逻辑放入生产代码中进行单元测试，例如新的构造函数或新方法。为了使代码可测试，测试需要在生产代码中添加额外的逻辑，以便访问代码的内部状态进行测试配置或结果验证。生产代码中的测试逻辑是一种问题，尽管它不会破坏被测试的代码，但会增加代码的复杂性，这可能会在配置错误的情况下造成严重的维护问题或系统故障。
- en: 'The testing logic is inserted into the production code under the following
    conditions:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下条件下，将测试逻辑插入到生产代码中：
- en: 'Adding conditional logic to return a hardcoded value during testing. The code
    under test acts as a dynamic stub as shown in the following example:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试期间添加条件逻辑以返回硬编码的值。被测试的代码作为动态存根，如下例所示：
- en: '[PRE41]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`EncounterManager` cannot be overridden as the class is declared as `final`;
    so, you cannot create a mock or fake object of this class. If your code under
    test needs to stub the `save()` behavior, then somehow you need to bypass the
    database call made in the `EncounterServiceImpl` method to persist the check-in
    data into a database. So, the `save()` method has an `isHack` conditional logic.
    This Boolean variable is added for testing purposes. From test, the Boolean variable
    `isHack` is set to `true`. If accidentally this variable is set to `true`, then
    encounters will not be created in production.'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EncounterManager` 不能被覆盖，因为该类被声明为 `final`；因此，您不能创建该类的模拟或伪造对象。如果您的测试代码需要存根 `save()`
    行为，那么您需要绕过在 `EncounterServiceImpl` 方法中进行的数据库调用，以将签到数据持久化到数据库中。因此，`save()` 方法有一个
    `isHack` 条件逻辑。这个布尔变量是为了测试目的而添加的。从测试中，布尔变量 `isHack` 被设置为 `true`。如果意外地将此变量设置为 `true`，则生产中不会创建遭遇。'
- en: 'Additional code is written only for test execution, or private variables are
    exposed as public. The following is an example:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅编写用于测试执行的额外代码，或者将私有变量公开。以下是一个示例：
- en: '[PRE42]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `retrieveEncounters()` method is a private method used for lazy instantiation
    of `encounters List`. However, for testing purposes, `encounters List` is exposed
    as `public` and a `public` setter method is used. From test, either the setter
    method is called with a hardcoded `List` or directly the `encounters List` is
    set. If `encounters List` is accidentally set in production, users will see the
    wrong data in the UI.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`retrieveEncounters()` 方法是一个私有方法，用于 `encounters List` 的延迟实例化。然而，出于测试目的，`encounters
    List` 被公开暴露，并使用了一个公开的setter方法。从测试中，要么使用硬编码的 `List` 调用setter方法，要么直接设置 `encounters
    List`。如果意外地将 `encounters List` 设置在生产环境中，用户将在UI中看到错误的数据。'
- en: 'Mockito doesn''t allow stubbing the `equals()` and `hashcode()` methods, as
    they should not be overridden unless the logic is comprehensible. Yet, often for
    testing, we override the `equals()` and `hashcode()` methods and perform testing
    logic or return the hardcoded value. This is very dangerous. In production, if
    we need to put the objects in a collection or need to perform an equality check,
    then the system behaves in a bizarre fashion. The following code snippet overrides
    the `hashcode()` and `equals()` methods:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mockito不允许模拟 `equals()` 和 `hashcode()` 方法，因为除非逻辑可理解，否则不应重写它们。然而，对于测试，我们经常重写
    `equals()` 和 `hashcode()` 方法并执行测试逻辑或返回硬编码的值。这是非常危险的。在生产环境中，如果我们需要将对象放入集合或需要执行相等性检查，那么系统将以奇怪的方式运行。以下代码片段重写了
    `hashcode()` 和 `equals()` 方法：
- en: '[PRE43]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `equals()` method returns `false` in the production code and `hashcode()`
    returns `0`. The `EncounterManager` class cannot be used in conjunction with the
    Java collection framework.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码中，`equals()` 方法返回 `false`，`hashcode()` 返回 `0`。`EncounterManager` 类不能与Java集合框架一起使用。
- en: To refactor the production code, remove the final keyword, override the class
    in the test context, and return the hardcoded values. However, never ever touch
    the `equals()` and `hashcode()` methods for testing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重构生产代码，移除final关键字，在测试上下文中覆盖类，并返回硬编码的值。然而，永远不要在测试中触摸 `equals()` 和 `hashcode()`
    方法。
- en: Refactoring over engineered tests
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对过度设计的测试进行重构
- en: Tests are system documentation. They should tell the reader what is being executed.
    Often, we put too much documentation and make it more complex for the reader to
    understand the intention. Sometimes, we refactor the test and extract clean, meaningful
    methods, pass variables to the extracted methods, and from test just invoke the
    methods. Now the reader fails to understand the utility of the test case, and
    everything is carried out elsewhere.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是系统文档。它们应该告诉读者正在执行什么。通常，我们添加过多的文档，使得读者更难理解意图。有时，我们重构测试并提取干净、有意义的函数，将变量传递给提取的函数，并在测试中仅调用这些函数。现在读者无法理解测试用例的效用，所有操作都在其他地方进行。
- en: 'The following test example demonstrates `Test` with less or no information:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试示例展示了具有较少或没有信息的 `Test`：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The unit test calls three methods: `createCheckInRequestForAPatientWithAGuarantor`,
    `checkInaPatient`, and `assertResult`. From the test body, it is not possible
    to understand what is being tested, what data is created, and what is asserted.
    A test should configure data, call the actual method, and assert results.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试调用了三个方法：`createCheckInRequestForAPatientWithAGuarantor`、`checkInaPatient`
    和 `assertResult`。从测试体中，无法理解正在测试的内容、创建了什么数据以及断言了什么。测试应该配置数据、调用实际方法并断言结果。
- en: 'The following is an example of a test with overly verbose documentation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个具有过度详细文档的测试示例：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The test builds two `Person` objects and two `Address` objects. Two builder
    methods are extracted for code reuse. For better documentation, variables are
    created and the hardcoded values are set and passed to the builder methods. These
    hardcoded variables make it tough to understand what is going on.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 测试构建了两个 `Person` 对象和两个 `Address` 对象。提取了两个构建器方法以实现代码重用。为了更好的文档，创建了变量并设置了硬编码的值，然后将这些值传递给构建器方法。这些硬编码的变量使得理解正在发生的事情变得困难。
- en: Instead of creating a custom builder method in test class, you can modify the
    main data class to follow the builder pattern and build the object in multiple
    steps. That way, we don't have to create hardcoded variables such as `johnsStreetAddress`,
    we can directly call the methods we need.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在测试类中创建自定义构建器方法，您可以修改主数据类以遵循构建器模式，并在多个步骤中构建对象。这样，我们就不必创建如 `johnsStreetAddress`
    这样的硬编码变量，我们可以直接调用所需的函数。
- en: 'The `Person` class is modified; the setter methods return an instance of `this`
    as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 类已被修改；setter 方法返回 `this` 实例，如下所示：'
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: From test, we can build the object easily. The following test example needs
    only an e-mail ID, first name, and phone number for testing, so it should not
    populate other values.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试中，我们可以轻松构建对象。以下测试示例只需要一个电子邮件ID、姓名和电话号码进行测试，因此不应填充其他值。
- en: 'We can build the object in three steps, and we no longer need the hardcoded
    strings to document the behavior:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分三步构建对象，并且不再需要硬编码的字符串来记录行为：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the JUnit best practices and explained the underlying principles.
    The best practices are writing meaningful tests, automating unit tests, test configuration,
    working with assertions, exception handling in test cases, identifying test smells,
    and refactoring test smells.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了JUnit的最佳实践并解释了其背后的原理。最佳实践包括编写有意义的测试、自动化单元测试、测试配置、使用断言、测试用例中的异常处理、识别测试异味以及重构测试异味。
- en: Now you will be able to write clean and maintainable test cases.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将能够编写干净且易于维护的测试用例。
