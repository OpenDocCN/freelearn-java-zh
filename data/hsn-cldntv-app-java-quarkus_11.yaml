- en: Advanced Application Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级应用程序开发
- en: In this chapter, we will explore some advanced features of Quarkus that will
    help you design and code cutting-edge Quarkus applications. The topics we will
    learn about will cover different areas of Quarkus API, ranging from advanced configuration
    options to controlling the life cycle of a Quarkus application and firing time-based
    events using the Quarkus scheduler.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些 Quarkus 的高级功能，这些功能将帮助您设计和编写前沿的 Quarkus 应用程序。我们将学习的内容将涵盖 Quarkus
    API 的不同领域，从高级配置选项到控制 Quarkus 应用程序的生命周期以及使用 Quarkus 调度器触发基于时间的事件。
- en: 'By the end of this chapter, you will be able to leverage the following advanced
    features:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够利用以下高级功能：
- en: Using advanced MicroProfile configuration options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级 MicroProfile 配置选项
- en: Controlling the life cycle events of your services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制您服务的生命周期事件
- en: Scheduling periodic tasks in your services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的服务中安排周期性任务
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter08).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章中找到项目的源代码，在 GitHub 上的 [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter08)。
- en: Using advanced configuration options
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级配置选项
- en: As we have already learned, Quarkus relies on the MicroProfile Config specification
    to inject configuration properties into our application. So far, we have used
    the default configuration file (named `application.properties`) to provide initial
    values for the application's initial settings.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所学的，Quarkus 依赖于 MicroProfile Config 规范来将配置属性注入到我们的应用程序中。到目前为止，我们已使用默认配置文件（命名为
    `application.properties`）为应用程序的初始设置提供初始值。
- en: 'Let''s recap with a basic example of how to inject a property, including a
    default value for the attribute:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个基本示例来回顾如何注入属性，包括为属性提供默认值：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we are injecting an application property into the `fileName`
    variable. Note that property names should be carefully planned since Quarkus ships
    with an extensive set of system properties that can be used to manage its environment.
    Luckily, you don''t need to have your documentation at hand to check for all the
    available system properties. As a matter of fact, you can use Maven''s `generate-config`
    command to list all the built-in system properties, based on the extensions that
    you have currently installed:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将一个应用程序属性注入到 `fileName` 变量中。请注意，属性名称应仔细规划，因为 Quarkus 随带一套广泛的系统属性，可用于管理其环境。幸运的是，您不需要手头有文档来检查所有可用的系统属性。事实上，您可以使用
    Maven 的 `generate-config` 命令列出所有内置的系统属性，基于您当前安装的扩展：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command will create a file named `application.properties.example` under
    the `src/main/resources` folder. If you open this file, you will see that it contains
    a commented list of all the available configuration options, which are located
    under the `quarkus` namespace. Here is a brief excerpt of it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 `src/main/resources` 文件夹下创建一个名为 `application.properties.example` 的文件。如果您打开此文件，您将看到它包含一个注释列表，列出了所有可用的配置选项，这些选项位于
    `quarkus` 命名空间下。以下是其中的一段摘要：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As a side note, you can choose a different filename for `generate-command` by
    adding the `-Dfile=<filename>` option.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，您可以通过添加 `-Dfile=<filename>` 选项来为 `generate-command` 选择不同的文件名。
- en: In the upcoming sections, we will learn about some advanced configuration drills
    using the examples located in the `Chapter08/advanced-config` folder of this book's
    GitHub repository as references. We recommend importing the project into your
    IDE before you move on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习一些使用本书 GitHub 存储库中 `Chapter08/advanced-config` 文件夹中的示例作为参考的高级配置练习。我们建议在继续之前将项目导入到您的
    IDE 中。
- en: Multiple configuration sources
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个配置源
- en: 'The `application.properties` file is not the only option when it comes to setting
    application properties. As per MicroProfile''s Config specification, you can also
    use the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到设置应用程序属性时，`application.properties` 文件并非唯一的选择。根据 MicroProfile 的 Config 规范，您还可以使用以下选项：
- en: '**Java system properties**: Java system properties can be read/written programmatically
    by means of the `System.getProperty()` and `System.setProperty()` APIs. As an
    alternative, you can set a property on the command line with the `-D` option,
    as follows:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 系统属性**：可以通过 `System.getProperty()` 和 `System.setProperty()` API 以编程方式读取/写入
    Java 系统属性。作为替代，您可以使用 `-D` 选项在命令行上设置属性，如下所示：'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Environment variables**: This requires setting an environment variable for
    the property, as follows:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：这需要为属性设置一个环境变量，如下所示：'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you may have noticed, the matching environment variable name has been set
    to uppercase and the dot has been replaced with an underscore.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到的，匹配的环境变量名称已被设置为 uppercase，并且点号已被下划线替换。
- en: Please note that, in the current version of Quarkus, it is required that the
    variable is also defined in `application.properties` so that it can be overridden
    by the environment variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 Quarkus 的当前版本中，还必须在 `application.properties` 中定义该变量，以便它可以被环境变量覆盖。
- en: Finally, it is also possible to collect our configuration from an external source
    by adding a new configuration source to our application. The next section will
    show us how to do this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以通过向我们的应用程序添加一个新的配置源来从外部收集我们的配置。下一节将展示我们如何做到这一点。
- en: Configuring custom configuration sources
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自定义配置源
- en: In all the examples we've created so far, we have assumed that the application
    configuration is picked up from the `src/main/resources/application.properties`
    file, which is the default for Quarkus applications. Nevertheless, since Quarkus
    fully supports the **MicroProfile Config** specification, it is entirely possible
    to load the configuration from another source, which could be an external filesystem,
    a database, or anything that can be loaded by a Java application!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止创建的所有示例中，我们假设应用程序配置是从 `src/main/resources/application.properties` 文件中获取的，这是
    Quarkus 应用程序的默认设置。尽管如此，由于 Quarkus 完全支持 **MicroProfile Config** 规范，从另一个来源加载配置（例如外部文件系统、数据库或任何可以被
    Java 应用程序加载的东西）是完全可能的！
- en: In order to do that, you have to implement the `org.eclipse.microprofile.config.spi.ConfigSource`
    interface, which exposes a set of methods for loading properties (`getProperties`),
    retrieving the properties' names (`getPropertyNames`), and retrieving the corresponding
    value (`getValue`).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您必须实现 `org.eclipse.microprofile.config.spi.ConfigSource` 接口，该接口公开了一组用于加载属性（`getProperties`）、检索属性名称（`getPropertyNames`）和检索相应的值（`getValue`）的方法。
- en: 'As proof of concept, take a look at the following implementation, which is
    available in the `Chapter08/advanced-config` project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概念验证，请查看以下实现，该实现可在 `Chapter08/advanced-config` 项目中找到：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code itself is pretty simple if you are familiar with the `java.io` API.
    The `FileConfigSource` class attempts to load an external configuration from the
    `/tmp/config.properties` path of your filesystem. It is worth mentioning that
    an `ORDINAL` variable has been set to specify the order for this `ConfigSource`
    class in case some properties are loaded from multiple sources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 `java.io` API，代码本身相当简单。`FileConfigSource` 类尝试从您的文件系统的 `/tmp/config.properties`
    路径加载外部配置。值得一提的是，已经设置了一个 `ORDINAL` 变量来指定此 `ConfigSource` 类的顺序，以防从多个来源加载了多个属性。
- en: 'The default value for a `ConfigSource` is set to `100`, and sources with the
    highest ordinal value have priority in case the property is defined across multiple
    sources. Here is the ranking of the available configuration sources:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigSource` 的默认值设置为 `100`，在属性在多个来源中定义的情况下，具有最高序数值的来源具有优先级。以下是可用配置源的排名：'
- en: '| **Config source** | **Value** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **配置源** | **值** |'
- en: '| `application.properties` | `100` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `application.properties` | `100` |'
- en: '| Environment variables | `300` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 环境变量 | `300` |'
- en: '| System properties | `400` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 系统属性 | `400` |'
- en: Since we have set the `ORDINAL` variable to `900` in our example, it will prevail
    over the other configuration sources, if any.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在示例中将 `ORDINAL` 变量设置为 `900`，如果存在其他配置源，它将覆盖其他配置源。
- en: 'Once the custom `ConfigSource` is available in the project, we need to register
    for this class. For this purpose, we have added a file named `org.eclipse.microprofile.config.spi.ConfigSource`
    under the `resources/META-INF/services` folder of the project. Here''s a tree
    view of the project, under the `resources` folder:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦自定义 `ConfigSource` 在项目中可用，我们需要为此类进行注册。为此，我们在项目的 `resources/META-INF/services`
    文件夹下添加了一个名为 `org.eclipse.microprofile.config.spi.ConfigSource` 的文件。以下是项目的树视图，位于
    `resources` 文件夹下：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Within this file, we have specified the fully qualified name of `ConfigSource`.
    In our case, this is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们指定了 `ConfigSource` 的完全限定名。在我们的情况下，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, as soon as the application is started, the custom `ConfigSource` will be
    loaded and its properties will prevail over other potential duplicates of the
    same attributes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦应用程序启动，自定义的 `ConfigSource` 将被加载，并且其属性将覆盖其他潜在的同名属性副本。
- en: 'Within the `AdvancedConfigTest` class of your project, you will find one assertion,
    which verifies that one property has been loaded from the external `FileConfigSource`
    class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目中的 `AdvancedConfigTest` 类中，您将找到一个断言，该断言验证了一个属性已从外部的 `FileConfigSource`
    类加载：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: More details about the `AdvancedConfigTest` class will be discussed later in
    this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `AdvancedConfigTest` 类的更多细节将在本章后面讨论。
- en: Using converters in your configuration
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置中使用转换器
- en: 'To discuss configuration converters, let''s take this simple configuration
    example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论配置转换器，让我们以这个简单的配置示例为例：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, it''s perfectly fine to inject the preceding properties into our code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将前面的属性注入到我们的代码中是完全可以接受的：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Under the hood, the MicroProfile Config API provides a type-safe conversion
    for values that are not just plain strings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，MicroProfile Config API 为不仅仅是普通字符串的值提供了类型安全的转换。
- en: Also, note that we can provide a default value for a property, which will be
    used if the property hasn't been defined in our configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们可以为属性提供一个默认值，如果属性在我们的配置中未定义，则将使用该默认值。
- en: 'This happens by providing converters in the configuration model. Out of the
    box, some converters are already provided by the MicroProfile Config API by default.
    Here''s a list of the built-in converters:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在配置模型中提供转换器来实现的。默认情况下，MicroProfile Config API 已经提供了一些内置的转换器。以下是一些内置转换器的列表：
- en: '`boolean` and `java.lang.Boolean`. The following values are converted into
    Booleans (case-insensitive): `true`, `YES`, `Y`, `1`, and `ON`. Any other value
    will be `false`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean` 和 `java.lang.Boolean`。以下值被转换为布尔值（不区分大小写）：`true`、`YES`、`Y`、`1` 和 `ON`。任何其他值都将为
    `false`。'
- en: '`byte` and `java.lang.Byte`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte` 和 `java.lang.Byte`。'
- en: '`short` and `java.lang.Short`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short` 和 `java.lang.Short`。'
- en: '`int` and `java.lang.Integer`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 和 `java.lang.Integer`。'
- en: '`long` and `java.lang.Long`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 和 `java.lang.Long`。'
- en: '`float` and `java.lang.Float`. A dot `.` is used to separate the fractional
    digits.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 和 `java.lang.Float`。点 `.` 用于分隔小数位。'
- en: '`double` and `java.lang.Double`. A dot `.` is used to separate the fractional
    digits.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double` 和 `java.lang.Double`。点 `.` 用于分隔小数位。'
- en: '`char` and `java.lang.Character`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 和 `java.lang.Character`。'
- en: '`java.lang.Class`. This is based on the result of `Class.forName`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Class`。这是基于 `Class.forName` 的结果。'
- en: 'Array, list, and set are also supported. In order to inject one of these Collections
    into a class variable, you can use the comma (`,`) char as a delimiter and `\`
    as the escape character. For example, take the following configuration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数组、列表和集合也受到支持。为了将其中一个集合注入到类的变量中，您可以使用逗号（`,`）字符作为分隔符，`\` 作为转义字符。例如，考虑以下配置：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code will inject the preceding configuration into a `java.util.List`
    element:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将前面的配置注入到 `java.util.List` 元素中：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In much the same way, you can use built-in converters to generate an `Array`
    from a list of values. Take a look at the following configuration example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，您可以使用内置转换器从值列表生成 `Array`。看看以下配置示例：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding configuration can be injected into an array of strings as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置可以注入到字符串数组中如下：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Even classes can be injected as part of the configuration:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以作为配置的一部分进行注入：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At runtime, the class will be searched by the class loader and created using
    the `Class.forName` construct. We can put it in our code as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，该类将由类加载器搜索，并使用 `Class.forName` 构造创建。我们可以在代码中这样放置它：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, it''s worth mentioning that you can inject the whole `Config` object
    and retrieve the single properties each time you need them:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，您可以将整个 `Config` 对象注入，并在需要时检索单个属性：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, let's explore some more advanced strategies for creating type converters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一些更高级的策略来创建类型转换器。
- en: Adding custom converters
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义转换器
- en: 'If the list of built-in converters is not enough, you can still create custom
    converters by implementing the generic interface, that is, `org.eclipse.microprofile.config.spi.Converter`.
    The `Type` parameter of the interface is the target type the string is converted
    into:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内置转换器的列表不足以满足需求，你仍然可以通过实现通用接口，即`org.eclipse.microprofile.config.spi.Converter`来创建自定义转换器。接口的`Type`参数是字符串转换成的目标类型：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code is for the target `Type` parameter, which derives from a
    plain Java string that we have included in the configuration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是为目标`Type`参数编写的，它从一个我们已包含在配置中的普通Java字符串派生而来：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You have to register your converter in a file named `resources/META-INF/services/org.eclipse.microprofile.config.spi.Converter`.
    Include the fully qualified class name of the custom implementation. For example,
    in our case, we have added the following line:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在名为`resources/META-INF/services/org.eclipse.microprofile.config.spi.Converter`的文件中注册你的转换器。包括自定义实现的完全限定类名。例如，在我们的案例中，我们添加了以下行：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s learn how to use our custom converter in practice. To do that,
    we will add the following line to the `application.properties` file, which uses
    the pattern coded in the constructor of the `CustomConfigValue` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在实践中使用我们的自定义转换器。为此，我们将向`application.properties`文件中添加以下行，该行使用`CustomConfigValue`类构造函数中编码的模式：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the custom converter can be injected into our code as a class attribute:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，自定义转换器可以作为类属性注入到我们的代码中：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although the preceding example does nothing fancy, it shows us how we can create
    a customized property based on class definitions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子并没有做什么特别的事情，但它展示了我们如何根据类定义创建一个自定义属性。
- en: Testing advanced configuration options
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试高级配置选项
- en: Within the `Chapter08/advanced-config/src/test` folder of this chapter, you
    will find a test class named `AdvancedConfigTest`, which will verify the key concepts
    that we've learned about so far.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的`Chapter08/advanced-config/src/test`文件夹中，你会找到一个名为`AdvancedConfigTest`的测试类，它将验证我们迄今为止学到的关键概念。
- en: 'To run all of these tests successfully, copy the `customconfig.properties`
    file into the `/tmp` folder of your drive, otherwise one of the assertions contained
    in the `AdvancedConfigTest` class will fail:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行所有这些测试，请将`customconfig.properties`文件复制到你的驱动器的`/tmp`文件夹中，否则`AdvancedConfigTest`类中包含的一个断言将失败：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, simply run the `install` goal, which will trigger the test''s execution:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，简单地运行`install`目标，这将触发测试的执行：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should see that all the tests contained in `AdvancedConfigTest` pass.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到包含在`AdvancedConfigTest`中的所有测试都通过了。
- en: Configuration profiles
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置配置文件
- en: We have just learned how to create complex configurations using built-in converters
    and, for the most demanding, custom converters. What about if we need to switch
    between different configurations, for example, when moving from a development
    environment to a production one? Here, you can duplicate your configuration. However,
    the proliferation of configuration files is not always welcome in IT projects.
    Let's learn how to deal with this concern using **configuration profiles**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何使用内置转换器和，对于最复杂的情况，使用自定义转换器来创建复杂的配置。如果我们需要在不同配置之间切换，例如，从开发环境迁移到生产环境时，该怎么办？在这里，你可以复制你的配置。然而，配置文件的激增在IT项目中并不总是受欢迎。让我们学习如何使用**配置配置文件**来处理这个担忧。
- en: In a nutshell, configuration profiles allow us to specify namespaces for our
    profiles in our configuration so that we can bind each property to a specific
    profile in the same file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，配置配置文件允许我们在配置中为我们的配置文件指定命名空间，这样我们就可以将每个属性绑定到同一文件中的特定配置文件。
- en: 'Out of the box, Quarkus ships with the following configuration profiles:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Quarkus提供了以下配置配置文件：
- en: '`dev`: This is triggered when running in development mode (that is, `quarkus:dev`).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`：在开发模式下运行时触发（即`quarkus:dev`）。'
- en: '`test`: This is triggered when running tests.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：当运行测试时触发。'
- en: '**`prod`**: This is picked up when we''re not running in development or test
    mode.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`prod`**：当我们不在开发或测试模式下运行时被选中。'
- en: Besides the preceding profiles, you can define your own custom profiles, which
    will be activated according to the rules we specified in the *Activating profiles*
    section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的配置文件之外，你还可以定义自己的自定义配置文件，这些配置文件将根据我们在*激活配置文件*部分中指定的规则被激活。
- en: 'You can use the following syntax to bind a configuration parameter to a specific
    profile:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语法将配置参数绑定到特定的配置文件：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To see a practical example of this, we will go through the source code in the
    `Chapter08/profiles` folder of this book's GitHub repository. We recommend importing
    the project into your IDE before you move on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个策略的实际示例，我们将通过这本书GitHub仓库中`Chapter08/profiles`文件夹的源代码来讲解。我们建议在继续之前将项目导入到您的IDE中。
- en: 'Let''s start by checking its `application.properties` configuration file, which
    defines multiple profiles:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查其`application.properties`配置文件，它定义了多个配置文件：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding configuration, we have specified three different JDBC URLs
    for our data source connection. Each one is bound to a different profile. We have
    also set a specific connection pool setting for the production profile in order
    to grant a larger number of database connections. In the next section, we will
    learn how to activate every single profile.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的配置中，我们为我们的数据源连接指定了三个不同的JDBC URL。每个URL都绑定到不同的配置文件。我们还为生产配置文件设置了一个特定的连接池设置，以便提供更多的数据库连接。在下一节中，我们将学习如何激活每个单独的配置文件。
- en: Activating profiles
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活配置文件
- en: 'Let''s learn how to activate a specific profile by taking the `prod` profile
    in the preceding configuration as an example. First of all, we need to start a
    PostgreSQL instance named `postgresProd` and bind it to port `7432`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以先前的配置中的`prod`配置文件为例，学习如何激活特定的配置文件。首先，我们需要启动一个名为`postgresProd`的PostgreSQL实例，并将其绑定到端口`7432`：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we need to provide profile information during the `package` phase, as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在`package`阶段提供配置文件信息，如下所示：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When running the application, it will pick up the profile you specified in
    the `package` phase:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行应用程序时，它将选择在`package`阶段指定的配置文件：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As an alternative, it is also possible to specify the profile using the `QUARKUS_PROFILE`
    environment variable, like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方法，您也可以使用`QUARKUS_PROFILE`环境变量来指定配置文件，如下所示：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, it''s worth mentioning that the same strategy can be used to define
    non standard profiles. For example, let''s say we want to add a **staging** profile
    for applications that need to be checked before production:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，相同的策略也可以用来定义非标准配置文件。例如，假设我们想要为需要在生产前进行检查的应用程序添加一个**预发布**配置文件：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we can apply the same strategy we've used for other profiles, that is,
    we can either specify the profile at application startup using the Java system
    property (`quarkus-profile`) or add the necessary information to the `QUARKUS_PROFILE`
    environment variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以应用我们为其他配置文件所使用的相同策略，即我们可以在应用程序启动时使用Java系统属性（`quarkus-profile`）指定配置文件，或者将必要的信息添加到`QUARKUS_PROFILE`环境变量中。
- en: Automatic profile selection
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动配置文件选择
- en: 'To simplify development and testing, the `dev` and `test` profiles can be automatically
    triggered by the Maven plugin. So, for example, if you are executing Quarkus in
    development mode, the `dev` profile will be used eventually:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化开发和测试，`dev`和`test`配置文件可以通过Maven插件自动触发。例如，如果您正在以开发模式执行Quarkus，最终将使用`dev`配置文件：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In much the same way, the `test` profile will be activated when tests are executed,
    for example, during the `install` life cycle phase:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，当执行测试时，例如在`install`生命周期阶段，将激活`test`配置文件：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `test` profile will be activated when you execute the Maven `test` goal.
    Additionally, it''s worth knowing that you can set a different profile for your
    tests through `maven-surfire-plugin`, within its system properties:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行Maven的`test`目标时，将激活`test`配置文件。此外，值得注意的是，您可以通过`maven-surefire-plugin`的系统属性为您的测试设置不同的配置文件：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this section, we walked through application profiles. In the next section,
    we'll learn how to control the life cycle of our Quarkus applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讲解了应用程序配置文件。在下一节中，我们将学习如何控制我们的Quarkus应用程序的生命周期。
- en: Controlling the application life cycle
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制应用程序生命周期
- en: 'Controlling the application life cycle is a common requirement for your services
    to be able to bootstrap some external resources or verify the status of your components.
    One simple strategy, borrowed from the Java Enterprise API, is to include the
    **Undertow** extension (or any upper layer, such as rest services) so that you
    can leverage `ServletContextListener`, which is notified when a web application
    is created or destroyed. Here is a minimal implementation of it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 控制应用程序的生命周期是您服务能够启动外部资源或验证组件状态的一个常见要求。一个简单的策略，借鉴自Java企业API，是包含**Undertow**扩展（或任何上层，如REST服务），这样您就可以利用`ServletContextListener`，当创建或销毁Web应用程序时，它会收到通知。以下是它的最小实现示例：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Although it is perfectly fine to reuse this strategy in a Quarkus web application,
    it is recommended to use this approach for any kind of Quarkus service. This can
    be done by observing the `io.quarkus.runtime.StartupEvent` and `io.quarkus.runtime.ShutdownEvent`
    events. Additionally, in CDI applications, you can observe an event with the `@Initialized(ApplicationScoped.class)`
    qualifier, which is fired when the application context is initialized. This can
    be particularly useful for bootstrapping resources such as databases, which are
    required before the configuration is read by Quarkus.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Quarkus web应用程序中重用此策略是完全可以的，但建议为任何类型的Quarkus服务使用此方法。这可以通过观察`io.quarkus.runtime.StartupEvent`和`io.quarkus.runtime.ShutdownEvent`事件来实现。此外，在CDI应用程序中，你可以通过`@Initialized(ApplicationScoped.class)`限定符观察一个事件，该事件在应用程序上下文初始化时触发。这对于启动资源（如数据库）特别有用，这些资源在Quarkus读取配置之前是必需的。
- en: To see a practical example of this, check the source code that's available in
    the `Chapter08/lifecycle` folder of this book's GitHub repository. As usual, it's
    advised to import the project into your IDE before you move on. The purpose of
    this example is to show you how to replace the PostgreSQL database, in our customer
    service, with the H2 database ([https://www.h2database.com/](https://www.h2database.com/)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个的实际例子，请检查这本书GitHub仓库中`Chapter08/lifecycle`文件夹中可用的源代码。像往常一样，建议在继续之前将项目导入到你的IDE中。这个例子的目的是向你展示如何在我们的客户服务中用H2数据库替换PostgreSQL数据库（[https://www.h2database.com/](https://www.h2database.com/))。
- en: 'Starting with the configuration, the life cycle project doesn''t contain the
    PostgreSQL JDBC dependency anymore. To replace this, the following one has been
    included:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置开始，生命周期项目不再包含PostgreSQL JDBC依赖项。为了替换它，以下内容已被包含：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To test our customer service, we have included two H2 database configuration
    profiles: one that''s bound to the `dev` profile and one that''s bound to the
    `test` profile:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的客户服务，我们包含了两个H2数据库配置配置文件：一个绑定到`dev`配置文件，另一个绑定到`test`配置文件：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To bind the H2 database before the application context is started, we can use
    the following `DBLifeCycleBean` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序上下文启动之前绑定H2数据库，我们可以使用以下`DBLifeCycleBean`类：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This class is able to intercept the following events:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此类能够拦截以下事件：
- en: '**Context startup**: This is captured through the `observeContextInit` method.
    The database is bootstrapped in this method.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文启动**：这是通过`observeContextInit`方法捕获的。数据库在这个方法中启动。'
- en: '**Application startup**: This is captured through the `onStart` method. We
    are simply performing some logs when this event is fired.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序启动**：这是通过`onStart`方法捕获的。我们只是在事件触发时执行一些日志记录。'
- en: '**Application shutdown**: This is captured through the `onStop` method. We
    are shutting down the database in this method.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序关闭**：这是通过`onStop`方法捕获的。我们在这个方法中关闭数据库。'
- en: 'Now, you can start Quarkus in the `dev` profile as usual with the following
    command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令以`dev`配置文件启动Quarkus，就像平常一样：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When the application is started, we will be notified that the H2 database has
    been started:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，我们将收到通知，H2数据库已经启动：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we will receive one more notification on application startup, where we
    can include some extra tasks to be completed:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在应用程序启动时收到另一个通知，我们可以包括一些额外的任务来完成：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, when we stop the application, the resource will be dismissed, as shown
    in the following console logs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们停止应用程序时，资源将被取消，如下面的控制台日志所示：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Before shutting down the database, you can enjoy running your customer service
    example with a tiny in-memory database layer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭数据库之前，你可以享受使用一个小型内存数据库层运行你的客户服务示例。
- en: Activating a database test resource
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活数据库测试资源
- en: As a bonus tip, we will show you how to activate the H2 database during the
    test life cycle. This can be done by adding a class, annotated as `@QuarkusTestResource`,
    to your test classes while passing the `H2DatabaseTestResource` class as an attribute.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外提示，我们将向你展示如何在测试生命周期中激活H2数据库。这可以通过向你的测试类添加一个标记为`@QuarkusTestResource`的类，并将`H2DatabaseTestResource`类作为属性传递来实现。
- en: 'Here is an example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`H2DatabaseTestResource` basically performs the same actions that `DBLifeCycleBean`
    does, before our tests are fired. Note that the following dependency has been
    added into the project to run the preceding test class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`H2DatabaseTestResource`基本上执行了与`DBLifeCycleBean`相同的操作，在我们启动测试之前。请注意，以下依赖项已被添加到项目中以运行前面的测试类：'
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you can safely run tests against the `test` profile with the following
    command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令安全地针对`test`配置文件运行测试：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that, before our tests are executed, the following log will confirm that
    the H2 database has been started on one of our available IP addresses:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们执行测试之前，以下日志将确认H2数据库已经在我们的可用IP地址之一上启动：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Bootstrapping external resources is indeed a common use case for life cycle
    managers. Another frequent use case consists of scheduling events at the application
    startup phase. In the next section, we will discuss how to fire events using Quarkus'
    scheduler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 外部资源引导确实是生命周期管理器的常见用例。另一个常见用例是在应用程序启动阶段安排事件。在下一节中，我们将讨论如何使用Quarkus的调度器触发事件。
- en: Firing events with the Quarkus scheduler
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus调度器触发事件
- en: Quarkus includes an extension called **scheduler**, which can be used to schedule
    tasks for single or repeated execution. We can use the cron format to specify
    the number of times the scheduler fires the event.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus包含一个名为**scheduler**的扩展，可用于安排单次或重复执行的任务。我们可以使用cron格式来指定调度器触发事件的次数。
- en: 'The source code for the following example is located in the `Chapter08/scheduler`
    folder of this book''s GitHub repository. If you check the `pom.xml` file, you
    will notice that the following extension has been added to it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例的源代码位于本书GitHub存储库的`Chapter08/scheduler`文件夹中。如果您检查`pom.xml`文件，您将注意到以下扩展已被添加到其中：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our sample project generates a random token (for the sake of simplicity, a
    random string is used) every 30 seconds. The class that''s in charge of generating
    random tokens is the following `TokenGenerator` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例项目每30秒生成一个随机令牌（为了简单起见，使用随机字符串）。负责生成随机令牌的类是以下`TokenGenerator`类：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can have our token injected into the built-in REST endpoint, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的令牌注入到内置的REST端点中，如下所示：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Start the application as usual with the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令以常规方式启动应用程序：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You will notice that, every 30 seconds, the following message is printed in
    the console logs:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到，每30秒，以下消息将在控制台日志中打印：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, by requesting the `/token` URL, the randomly generated string will be
    returned:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过请求`/token` URL，将返回随机生成的字符串：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the cron scheduler format
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cron调度器格式
- en: 'Besides using time expressions (**s=seconds**, **m=minutes**, **h=hours**,
    **d=days**), you can opt for the more compact expression of the cron scheduler.
    Therefore, if you wanted to fire the event every second, then you could use the
    following cron expression:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用时间表达式（**s=seconds**，**m=minutes**，**h=hours**，**d=days**）外，您还可以选择更紧凑的cron调度器表达式。因此，如果您想每秒触发事件，则可以使用以下cron表达式：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Check the cron main page for more information about the cron format: [http://man7.org/linux/man-pages/man5/crontab.5.html](http://man7.org/linux/man-pages/man5/crontab.5.html).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 检查cron主页面以获取有关cron格式的更多信息：[http://man7.org/linux/man-pages/man5/crontab.5.html](http://man7.org/linux/man-pages/man5/crontab.5.html).
- en: Firing one-time events
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发一次性事件
- en: 'If you need to execute one-time events, then you can inject the `io.quarkus.scheduler.Scheduler`
    class into your code directly and use the `startTimer` method, which will fire
    the execution of an action in a separate thread. This can be seen in the following
    example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要执行一次性事件，则可以直接将`io.quarkus.scheduler.Scheduler`类注入到您的代码中，并使用`startTimer`方法，该方法将在单独的线程中触发动作的执行。这可以在以下示例中看到：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this brief excerpt, we can see how a single event, which will be executed
    in the `oneTimeAction()` method, can fire a one-time action after `300` milliseconds.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的摘录中，我们可以看到单个事件，该事件将在`oneTimeAction()`方法中执行，将在`300`毫秒后触发一次性动作。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we presented some advanced techniques that we can use to manage
    our configuration using converters and configuration profiles. We have also demonstrated
    how different configuration sources can be injected and prioritized over the standard
    configuration file. In the second part of this chapter, we had a look at how to
    capture the application life cycle's events and how to schedule the execution
    of future tasks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些我们可以使用的高级技术，以使用转换器和配置配置文件来管理我们的配置。我们还演示了如何注入不同的配置源，并优先于标准配置文件。在本章的第二部分，我们探讨了如何捕获应用程序生命周期的事件以及如何安排未来任务的执行。
- en: To make our applications even more scalable, in the next chapter, we will discuss
    how to build reactive applications, which are event-driven and non-blocking. Hold
    on tight!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用更加可扩展，在下一章中，我们将讨论如何构建响应式应用，这些应用是事件驱动的且非阻塞的。请系好安全带！
