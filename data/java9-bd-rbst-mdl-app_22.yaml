- en: Date Calculator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期计算器
- en: If you've been developing in Java for any serious length of time, you know one
    thing to be true--working with dates is awful. The `java.util.Date` class, with
    its related classes, shipped with 1.0, and `Calendar` and its related classes
    coming along in 1.1\. Even early on, problems were apparent. For example, the
    Javadoc on `Date` says this--*Unfortunately, the API for these functions was not
    amenable to internationalization*. As a result, `Calendar` was introduced in 1.1\.
    Sure, there have been other enhancements down through the years, but given Java's
    strict adherence to backwards compatibility, there's only so much the language
    architects can do. As much as they may want to fix those APIs, their hands are
    tied.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认真开发Java有一段时间了，你知道一件事是真实的——处理日期是糟糕的。`java.util.Date`类及其相关类在1.0版本中发布，`Calendar`及其相关类在1.1版本中推出。即使在早期，问题就很明显。例如，`Date`的Javadoc说：“不幸的是，这些函数的API不适合国际化。”因此，`Calendar`在1.1版本中被引入。当然，多年来已经进行了其他增强，但鉴于Java对向后兼容性的严格遵循，语言架构师能做的事情是有限的。尽管他们可能想修复这些API，但他们的手被束缚了。
- en: Fortunately, **Java Specification Request** (**JSR 310**) was filed. Led by
    Stephen Colebourne, an effort was begun to create a new API, based on the very
    popular open source library, Joda-Time. In this chapter, we'll take an in-depth
    look at this new API, then build a simple command-line utility to perform date
    and time math, which will give us an opportunity to see some of this API in action.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，**Java规范请求**（**JSR 310**）已被提交。由Stephen Colebourne领导，开始了一个创建新API的努力，该API基于非常流行的开源库Joda-Time。在本章中，我们将深入探讨这个新API，然后构建一个简单的命令行工具来执行日期和时间计算，这将给我们一个机会看到一些API的实际应用。
- en: 'This chapter, then, will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将涵盖以下主题：
- en: The Java 8 Date/Time API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8日期/时间API
- en: Revisiting command-line utilities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视命令行工具
- en: Text parsing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本解析
- en: Getting started
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: Like the project in [Chapter 18](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml),
    *Managing Processes in Java*, this project is fairly simple, conceptually. The
    end goal is a command-line utility to perform various date and time calculations.
    However, while we're at it, it would be very nice if the actual date/time work
    were to be put in a reusable library, so that's what we'll do. This leaves us
    with two projects, which we'll set up, like last time, as a multi-module Maven
    project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与第18章中的项目类似，[管理Java中的进程](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml)，这个项目在概念上相当简单。最终目标是创建一个命令行工具，用于执行各种日期和时间计算。然而，既然我们在做这件事，将实际的日期/时间工作放入一个可重用的库中将会非常棒，所以这就是我们将要做的。这让我们剩下两个项目，我们将像上次一样，将其设置为一个多模块Maven项目。
- en: 'The parent POM will look something like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 父POM将看起来像这样：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you read [Chapter 18](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml), *Managing
    Processes in Java*, or have worked with multi-module Maven builds before, there's
    nothing new here. It's included simply for completeness. If this is foreign to
    you, take a moment to review the first few pages of Chapter 18 before continuing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读过[第18章](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml)，*管理Java中的进程*，或者之前使用过多模块Maven构建，这里没有什么新的内容。它只是为了完整性而包含的。如果你对此感到陌生，请在继续之前花点时间回顾第18章的前几页。
- en: Building the library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建库
- en: 'Since we''d like to be able to reuse this tool in other projects, we''ll start
    by building a library that exposes its functionality. All of the functionality
    we''ll need is built into the platform, so our POM file is very simple:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望能够在其他项目中重用这个工具，我们将首先构建一个暴露其功能的库。我们需要的所有功能都内置在平台中，所以我们的POM文件非常简单：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are **almost** no external dependencies. The only dependency listed is
    on the testing library, TestNG. We didn't talk much about testing in the last
    chapter (rest assured, there are tests in the project). In this chapter, we'll
    introduce the topic of testing and show some examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有外部依赖。列出的唯一依赖是测试库TestNG。在上一个章节中我们没有过多地讨论测试（请放心，项目中确实有测试）。在本章中，我们将介绍测试的话题，并展示一些示例。
- en: 'Now we need to define our module. Remember that these are Java 9 projects,
    so we want to make use of the module functionality to help protect our internal
    classes from accidental public exposure. Our module is very simple. We need to
    give it a name, then export our public API package, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义我们的模块。记住，这些是Java 9项目，所以我们要利用模块功能来帮助保护我们的内部类免受意外公开暴露。我们的模块非常简单。我们需要给它一个名字，然后导出我们的公共API包，如下所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since everything we need is already in the JDK, we have nothing to declare beyond
    what we export.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所需的一切都已经包含在JDK中，所以我们不需要声明除了我们导出之外的内容。
- en: With our project set up, let's take a quick look at the functional requirements.
    Our intent with this project is to build a system that allows the user to provide
    an arbitrary string representing a date or time calculation expression and get
    a response. The string may look something like `"today + 2 weeks"` to find out
    the date 2 weeks from today, `"now + 3 hours 15 minutes"` to find out what time
    it is in 3 hours and 15 minutes, or `"2016/07/04 - 1776/07/04"` to find out how
    many years, months, and days are between the two dates. The processing of these
    expressions will be one line at a time, so the ability to pass in, for example,
    a text document with multiple expressions and get multiple results is explicitly
    excluded from the scope. This can be implemented easily enough, of course, by
    any consuming application or library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目设置完成后，让我们快速看一下功能需求。我们这个项目的意图是构建一个系统，允许用户提供一个表示日期或时间计算表达式的任意字符串，并得到一个响应。这个字符串可能看起来像`"today
    + 2 weeks"`来找出今天之后的2周日期，`"now + 3 hours 15 minutes"`来找出3小时15分钟后的时间，或者`"2016/07/04
    - 1776/07/04"`来找出两个日期之间有多少年、月和日。这些表达式的处理将逐行进行，因此明确排除了例如传递包含多个表达式的文本文档并得到多个结果的能力。当然，任何消费应用程序或库都可以轻松实现这一点。
- en: So, now we have a project set up and ready to go, and we have a rough sketch
    of its fairly simple functional requirements. We're ready to start coding. Before
    we do that, let's take a quick tour of the new `java.time` package to get a better
    sense of what we'll be seeing in this project, as well as some of the functionality
    we **won't** be using in this simple project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的项目已经设置好并准备就绪，我们也对其相对简单的功能需求有一个大致的草图。我们准备开始编码。在我们这样做之前，让我们快速浏览一下新的`java.time`包，以便更好地了解在这个项目中我们将看到什么，以及在这个简单项目中我们将不会使用的一些功能。
- en: A timely interlude
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个及时的小憩
- en: Prior to Java 8, two primary date-related classes were `Date` and `Calendar`
    (and, of course, `GregorianCalendar`). The new `java.time` package offers several
    new classes, such as `Duration`, `Period`, `Clock`, `Instant`, `LocalDate`, `LocalTime`,
    `LocalDateTime`, and `ZonedDateTime`. There is a plethora of supporting classes,
    but these are the primary starting points. Let's take a quick look at each.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，主要的两个日期相关类是`Date`和`Calendar`（当然，还有`GregorianCalendar`）。新的`java.time`包提供了几个新的类，例如`Duration`、`Period`、`Clock`、`Instant`、`LocalDate`、`LocalTime`、`LocalDateTime`和`ZonedDateTime`。有许多支持类，但这些都是主要的起点。让我们快速看一下每个类。
- en: Duration
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续时间
- en: '`Duration` is a **time-based unit of time**. While it may sound odd to phrase
    it that way, the wording was chosen to distinguish it from a date-based unit of
    time, which we''ll look at next. In plain English, it''s a measurement of time,
    such as **10 seconds**, **1 hour**, or **100 nanoseconds**. `Duration` is measured
    in seconds, but there are a number of methods to get a representation of the duration
    in other units of measure, which are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duration`是一个基于时间的单位。虽然这样表述可能听起来有些奇怪，但这样的措辞是为了将其与基于日期的时间单位区分开来，我们将在下一节中讨论。用简单的话说，它是一种时间的度量，例如**10秒**、**1小时**或**100纳秒**。`Duration`是以秒为单位的，但有一些方法可以将持续时间表示为其他度量单位，如下所示：'
- en: '`getNano()`: This is `Duration` in nanosecods'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNano()`: 这是基于纳秒的`Duration`'
- en: '`getSeconds()`: This is `Duration` in seconds'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSeconds()`: 这是基于秒的`Duration`'
- en: '`get(TemporalUnit)`: This is `Duration` in a unit of measure specified'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(TemporalUnit)`: 这是基于指定度量单位的`Duration`'
- en: 'There are also a variety of arithmetic methods, which are mentioned as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些不同的算术方法，如下所述：
- en: '`add`/`minus (int amount, TemporalUnit unit)`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`/`minus (int amount, TemporalUnit unit)`'
- en: '`add`/`minus (Duration)`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`/`minus (Duration)`'
- en: '`addDays`/`minusDays(long)`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addDays`/`minusDays(long)`'
- en: '`addHours`/`minusHours(long)`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addHours`/`minusHours(long)`'
- en: '`addMillis`/`minusMillis(long)`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addMillis`/`minusMillis(long)`'
- en: '`addMinutes`/`minusMinutes(long)`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addMinutes`/`minusMinutes(long)`'
- en: '`addNanos`/`minusNanos(long)`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addNanos`/`minusNanos(long)`'
- en: '`addSeconds`/`minusSeconds(long)`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSeconds`/`minusSeconds(long)`'
- en: '`dividedBy`/`multipliedBy`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dividedBy`/`multipliedBy`'
- en: 'We also have a number of convenient factory and extraction methods, such as
    the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有许多方便的工厂和提取方法，如下所示：
- en: '`ofDays(long)`/`toDays()`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofDays(long)`/`toDays()`'
- en: '`ofHours(long)`/`` `toHours()` ``'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofHours(long)`/`toHours()`'
- en: '`ofMinutes(long)`/`toMinutes()`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofMinutes(long)`/`toMinutes()`'
- en: '`ofSeconds(long)`/`toSeconds()`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofSeconds(long)`/`toSeconds()`'
- en: 'A `parse()` method is also supplied. Unfortunately, perhaps, for some, the
    input for this method may not be what you might expect. Since we''re dealing with
    a duration that is often, say, in hours and minutes, you might expect the method
    to accept something like "1:37" for 1 hour and 37 minutes. However, that will
    cause the system to throw `DateTimeParseException`. What the method expects to
    receive is a string in an ISO-8601 format, which looks like this--`PnDTnHnMn.nS`.
    That''s pretty fantastic, isn''t it? While it may be confusing at first, it''s
    not too bad once you understand it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了一个`parse()`方法。不幸的是，也许对某些人来说，这个方法输入可能不是你预期的。因为我们处理的是通常以小时和分钟为单位的持续时间，你可能会期望这个方法接受类似于"1:37"的输入来表示1小时37分钟。然而，这将导致系统抛出`DateTimeParseException`。该方法期望接收的是符合ISO-8601格式的字符串，看起来像这样--`PnDTnHnMn.nS`。这相当神奇，不是吗？虽然一开始可能会感到困惑，但一旦理解了它，就不会太糟糕：
- en: The first character is an optional `+` (plus) or `-` (minus) sign.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字符是一个可选的`+`（加号）或`-`（减号）符号。
- en: The next character is `P` and can be either uppercase or lowercase.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个字符是`P`，可以是大写或小写。
- en: What follows is at least one of four sections indicating days (`D`), hours (`H`),
    minutes (`M`), and seconds (`S`). Again, case doesn't matter.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来至少有一个四个部分，表示天数(`D`)、小时(`H`)、分钟(`M`)和秒(`S`)。同样，大小写无关紧要。
- en: They must be declared in this order.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须按照这个顺序声明。
- en: Each section has a numeric part that includes an optional `+` or `-` sign, one
    or more ASCII digits, and the unit of measure indicator. The seconds amount may
    be fractional (expressed as a floating point number) and may use a period or a
    comma.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部分都有一个数字部分，包括可选的`+`或`-`符号，一个或多个ASCII数字，以及度量单位指示符。秒数可以是分数（以浮点数表示）并且可以使用点或逗号。
- en: The letter `T` must come before the first instance of hours, minutes, or seconds.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母`T`必须出现在小时、分钟或秒的第一个实例之前。
- en: Simple, right? It may not be very friendly to a non-technical audience, but
    that it supports encoding a duration in a string that allows unambiguous parsing
    is a huge step forward.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？它可能对非技术受众不太友好，但它支持将持续时间编码为字符串，允许无歧义的解析，这是一个巨大的进步。
- en: Period
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期间
- en: '`Period` is a date-based unit of time. Whereas `Duration` was about time (hours,
    minutes, seconds, and so on), `Period` is about years, weeks, months, and so forth.
    Like `Duration`, it exposes several arithmetic methods to add and subtract, though
    these deal with years, months, and days. It also offers `plus(long amount, TemporalUnit
    unit)` (and the equivalent `minus`) as well.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period`是一个基于日期的时间单位。而`Duration`是关于时间（小时、分钟、秒等），`Period`是关于年、周、月等。像`Duration`一样，它公开了几个算术方法来添加和减去，尽管这些处理的是年、月和日。它还提供了`plus(long
    amount, TemporalUnit unit)`（以及等效的`minus`）。'
- en: 'Also, like `Duration`, `Period` has a `parse()` method, which also takes an
    ISO-8601 format that looks like this--`PnYnMnD` and `PnW`. Based on the discussion
    earlier, the structure is probably pretty obvious:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与`Duration`类似，`Period`也有一个`parse()`方法，它也接受类似于`PnYnMnD`和`PnW`的ISO-8601格式。根据前面的讨论，结构可能非常明显：
- en: The string starts with an optional sign, followed by the letter `P`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串以可选的符号开头，后跟字母`P`。
- en: After that, for the first form, come three sections, at least one of which must
    be present--years (`Y`), months(`M`), and days (`D`).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，对于第一种形式，有三个部分，其中至少有一个必须存在--年(`Y`)、月(`M`)和日(`D`)。
- en: For the second form, there is only one section--weeks (`W`).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第二种形式，只有一个部分--周(`W`)。
- en: The amount in each section can have a positive or negative sign.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部分的量可以带有正号或负号。
- en: The `W` unit can't be combined with the others. Internally, the amount is multiplied
    by `7` and treated as days.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`单位不能与其他单位组合。内部，量乘以`7`并作为天数处理。'
- en: Clock
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时钟
- en: '`Clock` is an abstract class that provides access to the current instant (which
    we will see next), date, and time using a timezone. Prior to Java 8, we would
    have to call `System.currentTimeInMillis()` and `TimeZone.getDefault()` to calculate
    these values. `Clock` provides a nice interface to get that from one object.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clock`是一个抽象类，它提供了一个使用时区访问当前时刻（我们将在下一节看到）、日期和时间的接口。在Java 8之前，我们必须调用`System.currentTimeInMillis()`和`TimeZone.getDefault()`来计算这些值。`Clock`提供了一个很好的接口，可以从一个对象中获取这些值。'
- en: The Javadoc states that the use of `Clock` is purely optional. In fact, the
    major date/time classes have a `now()` method that uses the system clock to get
    their value. If, however, you need to provide an alternate implementation (say,
    in testing, you need the `LocalTime` in another timezone), this abstract class
    can be extended to provide the functionality needed, and can then be passed to
    the appropriate `now()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc 表示使用 `Clock` 是纯粹可选的。实际上，主要的日期/时间类都有一个 `now()` 方法，它使用系统时钟来获取它们的值。然而，如果你需要提供替代实现（比如，在测试中，你需要另一个时区的
    `LocalTime`），这个抽象类可以被扩展以提供所需的功能，然后可以传递给适当的 `now()` 方法。
- en: Instant
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Instant
- en: An `Instant` is a single, exact point in time (or **on the timeline**, you'll
    see the Javadoc say). This class offers arithmetic methods, much like `Period`
    and `Duration`. Parsing is also an option, with the string being an ISO-8601 instant
    format such as `1977-02-16T08:15:30Z`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: An `Instant` 是一个单一、精确的时间点（或者**在时间线上**，你会在Javadoc中看到）。这个类提供了类似于 `Period` 和 `Duration`
    的算术方法。解析也是一个选项，字符串是一个ISO-8601即时格式，如 `1977-02-16T08:15:30Z`。
- en: LocalDate
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LocalDate
- en: '`LocalDate` is a date without a timezone. While the value of this class is
    a date (year, month, and day), there are accessor methods for other values, which
    are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate` 是一个不带时区的日期。虽然这个类的值是一个日期（年、月和日），但还有其他值的访问器方法，如下所示：'
- en: '`getDayOfWeek()`: This returns the `DayOfWeek` enum for the day of the week
    represented by the date.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDayOfWeek()`: 这返回由日期表示的星期的 `DayOfWeek` 枚举。'
- en: '`getDayOfYear()`: This returns the day of the year (1 to 365, or 366 for leap
    years) represented by the date. This is a 1-based counter from January 1 of the
    specified year.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDayOfYear()`: 这返回由日期表示的年份（1到365，闰年为366）。这是一个从指定年份1月1日起的1为基础的计数器。'
- en: '`getEra()`: This returns the ISO era for the given date.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEra()`: 这返回给定日期的 ISO 时代。'
- en: Local dates can be parsed from a string, of course, but, this time, the format
    seems much more reasonable--`yyyy-mm-dd`. If you need a different format, the
    `parse()` method has been overridden to allow you to specify the `DateTimeFormatter`
    that can handle the format of the string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，本地日期可以从字符串解析，但这次，格式似乎更加合理--`yyyy-mm-dd`。如果你需要不同的格式，`parse()` 方法已被重写，允许你指定可以处理字符串格式的
    `DateTimeFormatter`。
- en: LocalTime
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LocalTime
- en: '`LocalTime` is the time-based equivalent of `LocalDate`. It stores `HH:MM:SS`,
    but does **not** store the timezone. Parsing times requires the format above,
    but, just like `LocalDate`, does allow you to specify a `DateTimeFormatter` for
    alternate string representations.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalTime` 是 `LocalDate` 的基于时间的等效物。它存储 `HH:MM:SS`，但**不**存储时区。解析时间需要上述格式，但就像
    `LocalDate` 一样，也允许你为不同的字符串表示指定 `DateTimeFormatter`。'
- en: LocalDateTime
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LocalDateTime
- en: '`LocalDateTime` is basically a combination of the last two classes. All of
    the arithmetic, factory, and extraction methods apply as expected. Parsing the
    text is also a combination of the two, except that `T` must separate the date
    and time portions of the string--`''2016-01-01T00:00:00''`. This class **does
    not** store or represent a timezone.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDateTime` 实际上是后两个类的组合。所有的算术、工厂和提取方法都按预期应用。解析文本也是两者的组合，但 `T` 必须分隔字符串的日期和时间部分--`''2016-01-01T00:00:00''`。这个类**不**存储或表示时区。'
- en: ZonedDateTime
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZonedDateTime
- en: If you need to represent a date/time **and** a timezone, then `ZonedDateTime`
    is the class you need. As you might expect, this class' interface is a combination
    of `LocalDate` and `LocalTime`, with extra methods added for handling the timezone.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要表示日期/时间和时区，那么你需要的是 `ZonedDateTime` 类。正如你所期望的，这个类的接口是 `LocalDate` 和 `LocalTime`
    的组合，并添加了处理时区的一些额外方法。
- en: As shown at length in the overview of duration's API (and hinted at, though
    not as clearly shown in the other classes), one of the strong points of this new
    API is the ability to manipulate and process various date and time artifacts mathematically.
    It is precisely this functionality that we will spend most of our time with in
    this project as we explore this new library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如在持续时间API概述中详细展示（尽管在其他类中暗示，但并不那么明显），这个新API的一个强点是能够以数学方式操作和处理各种日期和时间元素。正是这个功能，我们将在这个项目中花费大部分时间来探索这个新库。
- en: Back to our code
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的代码
- en: 'The first part of the process we need to tackle is parsing the user-provided
    string into something we can use programmatically. If you were to search for a
    parser generator, you would find a myriad of options, with tools such as Antlr
    and JavaCC showing up near the top. It''s tempting to turn to one of these tools,
    but our purposes here are pretty simple, and the grammar is not all that complex.
    Our functional requirements include:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的过程的第一部分是将用户提供的字符串解析成我们可以编程使用的东西。如果你去搜索解析器生成器，你会找到许多选项，其中Antlr和JavaCC等工具通常会出现在顶部。转向这些工具之一很有吸引力，但我们的目的在这里相当简单，语法也不是特别复杂。我们的功能需求包括：
- en: We want to be able to add/subtract time to/from a date or a time
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够向日期或时间添加/减去时间
- en: We want to be able to subtract one date or time from another to get the difference
    between the two
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够从一个日期或时间减去另一个日期或时间，以获取两个日期或时间的差值
- en: We want to be able to convert a time from one timezone to another
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够将一个时区的时间转换到另一个时区
- en: For something as simple as this, a parser is far too expensive, both in terms
    of complexity and binary size. We can easily write a parser using tools built
    into the JDK, which is what we'll do.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样简单的事情，解析器在复杂性和二进制大小方面都过于昂贵。我们可以轻松地使用JDK内置的工具编写解析器，这正是我们将要做的。
- en: To set the stage before we get into the code, the plan is this--we will define
    a number of **tokens** to represent logical parts of a date calculation expression.
    Using regular expressions, we will break down the given string, returning a list
    of these tokens, which will then be processed **left to right** to return the
    result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入代码之前，计划是这样的——我们将定义许多**标记**来表示日期计算表达式中的逻辑部分。使用正则表达式，我们将分解给定的字符串，返回一个这些标记的列表，然后这些标记将被**从左到右**处理以返回结果。
- en: That said, let's make a list of the types of token we'll need. We'll need one
    for a date, a time, the operator, any numeric amount, the unit of measure, and
    the timezone. Obviously, we won't need each of these for every expression, but
    that should cover all of our given use cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们列出我们需要标记的类型。我们需要一个用于日期，一个用于时间，一个用于运算符，任何数值量，度量单位和时区。显然，我们不需要在每一个表达式中都需要这些，但这应该涵盖了我们的所有给定用例。
- en: 'Let''s start with a base class for our tokens. When defining a type hierarchy,
    it''s always good to ask whether you want a base class or an interface. Using
    an interface gives the developer extra flexibility with regard to the class hierarchy
    should the need arise to extend a different class. A base class, however, allows
    us to provide default behavior at the cost of some rigidity in the hierarchy of
    the type. To make our `Token` implementations as simple as possible, we''d like
    to put as much in the base class as possible, so we''ll use a base class as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的标记的基础类开始。在定义类型层次结构时，总是很好地问自己是否需要一个基础类或接口。使用接口给开发者提供了额外的灵活性，如果需要扩展不同的类，那么在类层次结构中。然而，基础类允许我们在类型层次结构中提供默认行为，但以牺牲一些刚性为代价。为了使我们的`Token`实现尽可能简单，我们希望尽可能地将内容放在基础类中，所以我们将以以下方式使用基础类：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Java 8 did introduce a means to provide default behavior from an interface,
    that being a **default methods**. A default method is a method on an interface
    that provides a concrete implementation, which is a significant departure from
    interfaces. Prior to this change, all interfaces could do was define the method
    signature and force the implementing class to define the body. This allows us
    to add methods to an interface and provide a default implementation so that existing
    implementations of the interface need not change. In our case, the behavior we're
    providing is the storing of a value (the instance variable `value`) and the accessor
    for it (`getValue()`), so an interface with a default method is not appropriate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8确实引入了一种从接口提供默认行为的方法，即**默认方法**。默认方法是一个接口上的方法，它提供了一个具体的实现，这与接口有显著的不同。在此更改之前，所有接口所能做的就是定义方法签名并强制实现类定义方法体。这允许我们在接口中添加方法并提供默认实现，这样现有的接口实现就不需要改变。在我们的情况下，我们提供的行为是存储一个值（实例变量`value`）及其访问器（`getValue()`），因此具有默认方法的接口是不合适的。
- en: Note that we've also defined a nested interface, `Info`, which we will cover
    in more detail when we get to the parser.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还定义了一个嵌套接口，`Info`，当我们到达解析器时，我们将更详细地介绍它。
- en: 'With our base class defined, we can now create the tokens we will need as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了基本类之后，我们现在可以创建我们需要的标记，如下所示：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To start the class, we define two constants. `TODAY` is a special string that
    we will allow the user to specify today''s date. The second is the regular expression
    we''ll use to identify a date string:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个类，我们定义了两个常量。`TODAY`是一个特殊字符串，我们将允许用户指定今天的日期。第二个是我们将用来识别日期字符串的正则表达式：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s no secret that regular expressions are ugly, and as these things go,
    this one''s not too terribly complicated. We''re matching 4 digits (`\d{4}`),
    either a - or / (`[-/]`), a 0 or 1 followed by any digit (`[01]\d`), another -
    or /, then a 0, 1, 2, or 3 followed by any digit. Finally, the last segment, `|today`,
    tells the system to match on the pattern that comes before, **or** the text `today`.
    All this regular expression can do is identify a string that **looks** like a
    date. In its current form, it can''t actually ensure that it is valid. We can
    probably make a regex that can do exactly that, but the complexity that would
    introduce is just not worth it. What we can do though is let the JDK validate
    the string for us, which we''ll do in the `of` method, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人会否认正则表达式很丑陋，而且按照这些规则，这个并不太复杂。我们正在匹配4个数字（`\d{4}`），要么是一个破折号或斜杠（`[-/]`），要么是一个0或1后面跟着任意数字（`[01]\d`），然后是另一个破折号或斜杠，接着是一个0、1、2或3后面跟着任意数字。最后，最后一个部分，`|today`，告诉系统匹配前面的模式，**或者**文本`today`。这个正则表达式所能做的只是识别一个看起来像日期的字符串。在其当前形式下，它实际上不能确保它是有效的。我们可能可以创建一个可以做到这一点的正则表达式，但引入的复杂性并不值得。不过，我们可以让JDK为我们验证字符串，就像在这里的`of`方法中所示：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we've defined a static method to handle the creation of the `DateToken`
    instance. If the user provides the string `today`, we provide the value `LocalDate.now()`,
    which does what you think it might. Otherwise, we pass the string to `LocalDate.parse()`,
    changing any forward slashes to dashes, as that's what the method expects. If
    the user provided an invalid date, but the regular expression still matched it,
    we'll get an error here. Since we have built-in support to validate the string,
    we can content ourselves with letting the system do the heavy lifting for us.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个静态方法来处理`DateToken`实例的创建。如果用户提供了字符串`today`，我们提供`LocalDate.now()`的值，它可能做你想的事情。否则，我们将字符串传递给`LocalDate.parse()`，将任何正斜杠转换为破折号，因为这是该方法所期望的。如果用户提供了无效的日期，但正则表达式仍然匹配它，我们会在这里得到一个错误。由于我们有内置的支持来验证字符串，我们可以放心地让系统为我们做繁重的工作。
- en: 'The other tokens look very similar. Rather than showing each class, much of
    which would be very familiar, we''ll skip most of those classes and just look
    at the regular expressions, as some are quite complex. Take a look at the following
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标记看起来非常相似。我们不会展示每个类，因为其中大部分都非常熟悉，我们将跳过大多数这些类，只看看正则表达式，因为其中一些相当复杂。看看以下代码：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Well, that one''s not too bad, is it? One or more digits will match here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，那个并不太糟糕，对吧？这里将匹配一个或多个数字：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another relatively simple one, which will match a +, a -, or the `to` text:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相对简单的，它将匹配一个加号、一个减号或`to`文本：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The regular expression breaks down like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式分解如下：
- en: '`(?:`: This is a non-capturing group. We need to group some rules together,
    but we don''t want them to show up as separate groups when we process this in
    our Java code.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:`: 这是一个非捕获组。我们需要将一些规则组合在一起，但我们不希望在Java代码处理时将它们显示为单独的组。'
- en: '`[01]?`: This is a zero or a one. The `?` indicates that this should occur
    once or not at all.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[01]?`: 这是一个零或一个一。`?`表示这可能发生一次或根本不发生。'
- en: '`|2[0-3]`: We either want to match the first half, **or** this section, which
    will be a 2 followed by a 0, 1, 2, or 3.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|2[0-3]`: 我们要么匹配前半部分，**或者**这个部分，它将是一个2后面跟着一个0、1、2或3。'
- en: '`)`: This ends the non-capturing group. This group will allow us to match 12
    or 24-hour times.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`)`: 这结束了非捕获组。这个组将允许我们匹配12小时或24小时的时间。'
- en: '`:`: This position requires a colon. Its presence is not optional.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:`: 这个位置需要一个冒号。它的存在不是可选的。'
- en: '`[0-5]\d`: Next, the pattern must match a digit of `0-5` followed by another
    digit. This is the minutes portion of the time.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0-5]\d`: 接下来，模式必须匹配一个`0-5`的数字后面跟着另一个数字。这是时间的分钟部分。'
- en: '`'' *''`: It''s hard to see, so I''ve added quotes to help indicate it, but
    we want to match 0 or more (as indicated by the asterisk) spaces.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`'' *''`: 这很难看，所以我添加了引号来帮助指示，但我们想匹配0个或多个（如星号所示）空格。'
- en: '`(?:`: This is another non-capturing group.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:`: 这是另一个非捕获组。'
- en: '`[AaPp][Mm]`: These are the `A` or `P` letters (of either case) followed by
    an `M` (also of either case).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[AaPp][Mm]`: 这些是`A`或`P`字母（任意大小写）后面跟着一个`M`（也是任意大小写）。'
- en: '`)?`: We end the non-capturing group, but mark it with a `?` to indicate that
    it should occur once or not all. This group lets us capture any `AM`/`PM` designation.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`)?`：我们结束非捕获组，但用`?`标记它，表示它应该出现一次或不出现。这个组让我们能够捕获任何`AM`/`PM`标识。'
- en: '`|now`: Much like today above, we allow the user to specify this string to
    indicate the current time.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|now`：与上面提到的今天类似，我们允许用户指定此字符串以指示当前时间。'
- en: 'Again, this pattern may match an invalid time string, but we''ll let `LocalTime.parse()`
    handle that for us in `TimeToken.of()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个模式可能会匹配一个无效的时间字符串，但我们将让`LocalTime.parse()`在`TimeToken.of()`中为我们处理这个问题：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a bit more complex than others, primarily because of the default format
    expected by `LocalTime.parse()`, which is an ISO-8601 time format. Typically,
    time is specified in a 12-hour format with an am/pm designation. Unfortunately,
    that's not how the API works, so we have to make adjustments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这比其他模式复杂一些，主要是因为`LocalTime.parse()`期望的默认格式，这是一个ISO-8601时间格式。通常，时间以12小时格式指定，带有am/pm标识。不幸的是，API并不是这样工作的，所以我们必须进行调整。
- en: First, we pad the hour, if needed. Second, we look to see if the user specified
    `"am"` or `"pm"`. If so, we need to create a special formatter, which is done
    via `DateTimeFormatterBuilder`. We start by telling the builder to build a case-insensitve
    formatter. If we don't do that, `"AM"` will work, but `"am"` will not. Next, we
    append the pattern we want, which is hours, minutes, and am/pm, then build the
    formatter. Finally, we can parse our text, which we do by passing the string and
    the formatter to `LocalTime.parse()`. If all goes well, we'll get a `LocalTime`
    instance back. If not, we get an `Exception` instance, which we will handle. Note
    that we call `replaceAll()` on our string. We do that to strip any spaces out
    between the time and am/pm. Otherwise, the parse will fail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果需要，我们填充小时。其次，我们查看用户是否指定了“am”或“pm”。如果是这样，我们需要创建一个特殊的格式化器，这是通过`DateTimeFormatterBuilder`完成的。我们首先告诉构建器构建一个不区分大小写的格式化器。如果我们不这样做，“AM”将工作，但“am”将不会。接下来，我们附加我们想要的模式，即小时、分钟和am/pm，然后构建格式化器。最后，我们可以解析我们的文本，这是通过将字符串和格式化器传递给`LocalTime.parse()`来完成的。如果一切顺利，我们将得到一个`LocalTime`实例。如果不顺利，我们将得到一个`Exception`实例，我们将处理它。注意，我们在我们的字符串上调用`replaceAll()`。我们这样做是为了去除时间和am/pm之间的任何空格。否则，解析将失败。
- en: 'Finally, we come to our `UnitOfMeasureToken`. This token isn''t necessarily
    complex, but it''s certainly not simple. For our units of measure, we want to
    support the words `year`, `month`, `day`, `week`, `hour`, `minute`, and `second`,
    all of which can be plural, and most of which can be abbreviated to their initial
    character. This makes the regular expression interesting:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到我们的`UnitOfMeasureToken`。这个标记不一定复杂，但绝对不简单。对于我们的度量单位，我们希望支持单词`year`、`month`、`day`、`week`、`hour`、`minute`和`second`，所有这些都可以是复数形式，并且大多数可以缩写为其首字母。这使得正则表达式变得有趣：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's not so much complex as ugly. We have a list of possible strings, separated
    by the logical `OR` operator, the vertical pipe. It is probably possible to write
    a regular expression that searches for each word, or parts of it, but such an
    expression will likely be very difficult to write correctly, and almost certainly
    hard to debug or change. Simple and clear is almost always better than clever
    and complex.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是那么复杂，而是丑陋。我们有一个可能的字符串列表，由逻辑“或”运算符，即竖线分隔。可能可以编写一个正则表达式来搜索每个单词或其部分，但这样的表达式可能非常难以正确编写，并且几乎肯定难以调试或更改。简单明了通常比巧妙复杂要好。
- en: 'There''s one last element here that needs discussion: `VALID_UNITS`. In a static
    initializer, we build a `Map` to allow looking up the correct `ChronoUnit`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要讨论的最后元素：`VALID_UNITS`。在静态初始化器中，我们构建一个`Map`以允许查找正确的`ChronoUnit`：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: 'We''re now ready to take a look at the parser, which is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查看解析器了，如下所示：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we build our parser, we register each of our `Token` classes in a `List`,
    but we see two new types: `Token.Info` and `InfoWrapper`. `Token.Info` is an interface
    nested inside the `Token` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建我们的解析器时，我们在一个`List`中注册每个`Token`类，但我们看到两种新的类型：`Token.Info`和`InfoWrapper`。`Token.Info`是嵌套在`Token`类中的一个接口：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have added this interface to give us a convenient way to get the regular
    expression for a `Token` class, as well as the `Token`, without having to resort
    to reflection. `DateToken.Info`, for example, looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了这个接口，以便我们能够方便地获取`Token`类的正则表达式以及`Token`，而无需求助于反射。例如，`DateToken.Info`看起来是这样的：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since this is a nested class, we get easy access to members, including statics,
    of the enclosing class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个嵌套类，我们可以轻松访问包括静态成员在内的封装类成员。
- en: 'The next new type, `InfoWrapper`, looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个新类型`InfoWrapper`看起来如下：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a simple, private class, so some of the normal encapsulation rules
    can be set aside (although, should this class ever be made public, this would
    certainly need to be cleaned up). What we''re doing, though, is storing a compiled
    version of the token''s regular expression. Note that we''re wrapping the regular
    expression with a couple of extra characters. The first, the caret (`^`), says
    that the match must be at the beginning of the text. We''re also wrapping the
    regular expression in parentheses. However, this time this is a capturing group.
    We''ll see why in the following parse method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单、私有的类，因此可以暂时忽略一些常规的封装规则（尽管，如果这个类将来被公开，这肯定需要清理）。不过，我们正在存储一个标记的正则表达式的编译版本。请注意，我们在正则表达式周围添加了一些额外的字符。第一个是尖括号（`^`），表示匹配必须位于文本的开头。我们还将正则表达式放在括号中。然而，这次这是一个捕获组。我们将在接下来的解析方法中看到原因：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We start by making sure that `text` is not null, then `trim()` it, then make
    sure it's not empty. With the sanity checks done, we loop through the `List` of
    info wrappers to find a match. Remember that the pattern compiled is a capturing
    group looking at the start of the text, so we loop through each `Pattern` until
    one matches. If we don't find a match, we throw an `Exception`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保`text`不是null，然后`trim()`它，然后确保它不是空的。在完成这些合理性检查后，我们遍历`List`中的信息包装器以找到匹配项。请记住，编译的模式是一个捕获组，它查看文本的开始，所以我们遍历每个`Pattern`直到找到一个匹配项。如果我们找不到匹配项，我们抛出一个`Exception`。
- en: Once we find a match, we extract the matching text from `Matcher`, then, using
    `Token.Info`, we call `getToken()` to get a `Token` instance for the matching
    `Pattern`. We store that in our list, then recursively call the `parse()` method,
    passing a substring of text starting after our match. That removes the matched
    text from the original, then repeats the process until the string is empty. Once
    the recursion ends and things unwind, we return a `Queue` of tokens that represent
    the string the user provided. We use a `Queue` instead of, say, a `List`, as that
    will make processing a bit easier. We now have a parser, but our work is only
    half done. Now we need to process those tokens.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到匹配项，我们就从`Matcher`中提取匹配的文本，然后使用`Token.Info`调用`getToken()`来获取匹配`Pattern`的`Token`实例。我们将它存储在我们的列表中，然后递归调用`parse()`方法，传递从我们的匹配项之后开始的文本子串。这将从原始文本中移除匹配的文本，然后重复此过程，直到字符串为空。一旦递归结束并且事情展开，我们返回一个表示用户提供的字符串的`Queue`。我们使用`Queue`而不是，比如说，`List`，因为这会使处理更容易。我们现在有了解析器，但我们的工作还只完成了一半。现在我们需要处理这些标记。
- en: 'In the spirit of Separation of Concerns, we''ve encapsulated the processing
    of these tokens--the actual calculation of the expression--in a separate class,
    `DateCalculator`, which uses our parser. Consider the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在关注点分离的精神下，我们将这些标记的处理——实际的表达式计算——封装在一个单独的类`DateCalculator`中，该类使用我们的解析器。考虑以下代码：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each time `calculate()` is called, we create a new instance of the parser. Also,
    note that, as we look at the rest of the code, we pass the `Queue` around. While
    that does make the method signatures a bit bigger, it also makes the class thread-safe,
    as there's no state held in the class itself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`calculate()`时，我们都会创建一个新的解析器实例。同时，请注意，当我们查看其余的代码时，我们在传递`Queue`。虽然这确实使方法签名更大，但它也使类线程安全，因为类本身不持有任何状态。
- en: After our `isEmpty()` check, we can see where the `Queue` API comes in handy.
    By calling `poll()`, we get a reference to the next element in the collection,
    but--and this is important--**we leave the element in the collection**. This lets
    us look at it without altering the state of the collection. Based on the type
    of the first element in the collection, we delegate to the appropriate method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`isEmpty()`检查之后，我们可以看到`Queue` API是如何派上用场的。通过调用`poll()`，我们得到集合中下一个元素的引用，但——这很重要——**我们保留元素在集合中**。这让我们可以查看它而不改变集合的状态。根据集合中第一个元素的类型，我们将任务委托给适当的方法。
- en: 'For handling dates, the expression syntax is `<date> <operator> <date | number
    unit_of_measure>`. We can start our processing, then, by extracting a `DateToken`
    and an `OperatorToken`, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理日期，表达式语法是`<date> <operator> <date | number unit_of_measure>`。因此，我们可以通过提取`DateToken`和`OperatorToken`来开始我们的处理，如下所示：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To retrieve an element from a `Queue`, we use the `poll()` method, and we can
    safely cast that to `DateToken` since we checked that in the calling method. Next,
    we `peek()` at the next element and, via the `validateToken()` method, we verify
    that the element is not null and is of the type desired. If the token is valid,
    we can `poll()` and cast safely. Next, we `peek()` at the third token. Based on
    its type, we delegate to the correct method to finish the processing. If we find
    an unexpected `Token` type, we throw an `Exception`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Queue`中检索一个元素，我们使用`poll()`方法，并且我们可以安全地将它转换为`DateToken`，因为我们已经在调用方法中检查了这一点。接下来，我们`peek()`查看下一个元素，并通过`validateToken()`方法验证该元素不是null并且是所需类型。如果标记有效，我们可以安全地`poll()`并转换。接下来，我们`peek()`第三个标记。根据其类型，我们将任务委托给正确的方法以完成处理。如果我们发现意外的`Token`类型，我们抛出`Exception`。
- en: 'Before looking at those calculation methods, let''s look at `validateToken()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这些计算方法之前，让我们看看`validateToken()`：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's nothing too terribly exciting here, but eagle-eyed readers might notice
    that we're returning the class name of our token, and, by doing so, we're leaking
    the name of a non-exported class to the end user. That's probably not ideal, but
    we'll leave fixing that as an exercise for the reader.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别激动人心的，但细心的读者可能会注意到我们正在返回我们的标记的类名，并且通过这样做，我们将非导出类的名称泄露给了最终用户。这可能不是最佳做法，但我们将把修复这个问题留给读者作为练习。
- en: 'The method to perform date math looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行日期数学的方法如下：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since we already have our starting and operator tokens, we pass those in, as
    well as the `Queue` so that we can process the remaining tokens. Our first step
    is to determine if the operator is a plus or a minus, assigning a positive `1`
    or a `-1` to `negate` as appropriate. We do this so we can use a single method,
    `LocalDate.plus()`. If the operator is a minus, we add a negative number and get
    the same result as subtracting the original number.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有起始和操作标记，我们将它们传递进去，以及`Queue`，这样我们就可以处理剩余的标记。我们的第一步是确定操作符是加号还是减号，根据需要将正`1`或负`-1`赋值给`negate`。我们这样做是为了可以使用一个单一的方法`LocalDate.plus()`。如果操作符是减号，我们添加一个负数，得到的结果与减去原始数字相同。
- en: Finally, we loop through the remaining tokens, verifying each one before we
    process it. We get the `IntegerToken`; grab its value; multiply it by our negative
    modifier, `negate`; then add that value to the `LocalDate` using the `UnitOfMeasureToken`
    to tell what **kind** of value we're adding.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遍历剩余的标记，在处理之前验证每一个。我们获取`IntegerToken`；获取其值；将其乘以我们的负数修饰符`negate`；然后使用`UnitOfMeasureToken`来告知我们添加的是哪种类型的值，将该值加到`LocalDate`上。
- en: 'Calculating the difference between dates is pretty straightforward, as we see
    here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 计算日期之间的差异相当直接，正如我们所看到的：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We extract the `LocalDate` from our two `DateToken` variables, then call `Period.between()`,
    which returns a `Period` that indicates the elapsed amount of time between the
    two dates. We do check to see which date comes first so that we return a positive
    `Period` to the user as a convenience, since most people don't typically think
    in terms of negative periods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个`DateToken`变量中提取`LocalDate`，然后调用`Period.between()`，它返回一个`Period`，表示两个日期之间的时间差。我们检查哪个日期先到，以便我们返回一个正的`Period`给用户作为便利，因为大多数人通常不会考虑负的时间段。
- en: 'The time-based methods are largely identical. The big difference is the time
    difference method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间的方 法在很大程度上是相同的。最大的区别是时间差方法：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The notable difference here is the use of `Duration.between()`. It looks identical
    to `Period.between()`, but the `Duration` class offers a method that `Period`
    does not: `abs()`. This method lets us return the absolute value of `Period`,
    so we can pass our `LocalTime` variable to `between()` in any order we want.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里明显的不同之处在于使用了`Duration.between()`。它看起来与`Period.between()`相同，但`Duration`类提供了一个`Period`类没有的方法：`abs()`。这个方法允许我们返回`Period`的绝对值，因此我们可以以任何顺序将我们的`LocalTime`变量传递给`between()`。
- en: One final note before we leave this--we are wrapping our results in a `DateCalculatorResult`
    instance. Since the various operations return several different, unrelated types,
    this allows us to return a single type from our `calculate()` method. It will
    be up to the calling code to extract the appropriate value. We'll do that in our
    command-line interface, which we'll look at in the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开之前还有一个最后的注意事项——我们正在将结果包装在`DateCalculatorResult`实例中。由于各种操作返回几种不同且不相关的类型，这使得我们可以从`calculate()`方法返回单一类型。这将由调用代码负责提取适当的价值。我们将在我们的命令行界面中这样做，我们将在下一节中查看。
- en: A brief interlude on testing
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简短的小憩：测试
- en: Before we move on, we need to visit a topic we've not discussed yet, that being
    testing. Anyone who has been in the industry for a while has likely heard the
    term **Test-Driven Development** (or **TDD** for short). It's an approach to software
    development that posits that the first thing that should be written is a test,
    which will fail (since there's no code to run), then the code should be written
    that makes the test **green**, a reference to the green indicator given in IDEs
    and other tools to indicate that the test has passed. This process repeats as
    many times as necessary to build the final system, always making changes in small
    increments, and always starting with a test. A myriad of books have been written
    on the topic, which is both hotly debated and oftentimes heavily nuanced. The
    exact way the approach is implemented, if at all, almost always comes in flavors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，我们需要讨论一个我们还没有讨论过的话题，那就是测试。任何在业界工作了一段时间的人可能都听说过术语**测试驱动开发**（或简称**TDD**）。这是一种软件开发方法，它认为首先应该编写的是测试，这个测试会失败（因为没有代码可以运行），然后应该编写代码使测试**通过**，这是一个对IDE和其他工具中给出的绿色指示器的引用，表示测试已经通过。这个过程会根据需要重复多次以构建最终系统，总是以小增量进行更改，并且始终从测试开始。关于这个主题已经写出了许多书籍，这个话题既被激烈争论，又往往具有很多细微差别。如果确实实施了这个方法，其具体实施方式几乎总是以不同的风味出现。
- en: Clearly, in our work here, we haven't followed the TDD principle strictly, but
    that doesn't mean we haven't tested. While TDD purists are likely to quibble,
    my general approach tends to be a bit looser on the testing side until my API
    starts to solidify some. How long this takes depends on how familiar I am with
    the technologies being used. If I'm very familiar with them, I might sketch out
    a quick interface, then scaffold a test based on that as a means of testing the
    API itself, then iterate over that. For new libraries, I might write a very broad
    test to help drive the investigation of the new library, using the test framework
    as a means for bootstrapping a runtime environment in which I can experiment.
    Regardless, at the end of the development effort, the new system should be **fully**
    tested (with the exact definition of **fully** being another hotly debated concept),
    which is what I have striven for here. A full treatise on testing and test-driven
    development is beyond our scope here, though.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在我们这里的工作中，我们没有严格遵循TDD原则，但这并不意味着我们没有进行测试。虽然TDD的纯粹主义者可能会挑剔，但我的总体方法在测试方面通常比较宽松，直到我的API开始稳固一些。这需要多长时间取决于我对所使用技术的熟悉程度。如果我对它们非常熟悉，我可能会快速勾勒出一个接口，然后基于这个接口构建一个测试，以此来测试API本身，然后进行迭代。对于新的库，我可能会编写一个非常广泛的测试，以帮助推动对新库的调查，使用测试框架作为在可以实验的运行环境中启动的途径。无论如何，在开发工作的最后，新的系统应该被**全面**测试（**全面**的确切定义是另一个激烈争论的概念），这正是我在这里努力追求的。不过，关于测试和测试驱动开发的全面论述超出了我们这里的范围。
- en: When it comes to testing in Java, you have a **lot** of options. However, the
    two most common ones are TestNG and JUnit, with JUnit probably being the most
    popular. Which one should you pick? That depends. If you are working with an existing
    code-base, you should probably use whatever is already in use, unless you have
    a good reason to do otherwise. For example, the library could be old and no longer
    supported, it could be demonstrably insufficient for your needs, or you've been
    given an express directive to update/replace the existing system. If any of those
    conditions, or others similar to these, are true, we circle back to the question--*Which
    should I choose?* Again, that depends. JUnit is extremely popular and common,
    so using it might make sense in order to lower the barrier of entry into a project.
    However, TestNG has what some feel to be a much better, cleaner API. For example,
    TestNG does not require the use of static methods for certain test setup methods.
    It also aims to be much more than just a unit testing framework, providing tools
    for unit, functional, end-to-end, and integration testing. For our tests here,
    we will be using TestNG.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到Java的测试时，你有许多选择。然而，最常见的是TestNG和JUnit，其中JUnit可能是最受欢迎的。你应该选择哪一个？这取决于。如果你正在使用现有的代码库，你可能会使用已经存在的任何东西，除非你有很好的理由去做其他的事情。例如，库可能已经过时且不再受支持，它可能明显不足以满足你的需求，或者你被明确指示更新/替换现有的系统。如果这些条件中的任何一个，或者类似的情况是真实的，我们将回到这个问题——*我应该选择哪一个？*
    再次，这取决于。JUnit非常流行和常见，所以使用它可能会降低进入项目的门槛。然而，TestNG被认为有一个更好、更干净的API。例如，TestNG不需要使用静态方法来执行某些测试设置方法。它还旨在成为不仅仅是一个单元测试框架，提供单元、功能、端到端和集成测试的工具。在我们的测试中，我们将使用TestNG。
- en: 'To get started with TestNG, we need to add it to our project. To do that, we
    will add a test dependency to the Maven POM file as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用TestNG，我们需要将其添加到我们的项目中。为此，我们将在Maven POM文件中添加一个测试依赖项，如下所示：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Writing the tests is very simple. With the defaults of the TestNG Maven plugin,
    the class simply needs to be in `src/test/java` and end with the `Test` string.
    Each test method needs to be annotated with `@Test`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试非常简单。使用TestNG Maven插件的默认设置，类只需要位于`src/test/java`目录中，并以`Test`字符串结尾。每个测试方法都需要用`@Test`注解。
- en: 'There are a number of tests in the library module, so let''s start with some
    of the very basic ones that test the regular expressions used by the tokens to
    identify and extract the relevant parts of the expression. For example, consider
    the following piece of code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆模块中有很多测试，所以让我们从一些非常基础的测试开始，这些测试用于检查标记符使用的正则表达式，以识别和提取表达式的相关部分。例如，考虑以下代码片段：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a very basic test of the `DateToken` regular expression. The test delegates
    to the `testPattern()` method, passing the regular expression to test, and a string
    to test it with. Our functionality is tested by following these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`DateToken`正则表达式的一个非常基础的测试。测试委托给`testPattern()`方法，传递要测试的正则表达式和一个用于测试的字符串。我们的功能通过以下步骤进行测试：
- en: Compiling the `Pattern`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译`Pattern`。
- en: Creating a `Matcher`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Matcher`。
- en: Calling the `matcher.find()` method.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`matcher.find()`方法。
- en: With that, the logic of the system under test is exercised. What remains is
    to verify that it worked as expected. We do that with our call to `Assert.assertTrue()`.
    We assert that `matcher.find()` returns `true`. If the regex is correct, we should
    get a `true` response. If the regex is not correct, we'll get a `false` response.
    In the latter case, `assertTrue()` will throw an `Exception` and the test will
    fail.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们测试了被测试系统的逻辑。剩下的是验证它是否按预期工作。我们通过调用`Assert.assertTrue()`来完成这个验证。我们断言`matcher.find()`返回`true`。如果正则表达式正确，我们应该得到一个`true`响应。如果正则表达式不正确，我们将得到一个`false`响应。在后一种情况下，`assertTrue()`将抛出一个`Exception`，测试将失败。
- en: This test is certainly very basic. It could--should--be more robust. It should
    test a greater variety of strings. It should include some strings known to be
    bad to make sure we're not getting incorrect results in our tests. There are probably
    a myriad of other enhancements that could be made. The point here, though, is
    to show a simple test to demonstrate how to set up a TestNG-based environment.
    Before moving on, let's look at a couple more examples.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试当然非常基础。它本可以——应该——更加健壮。它应该测试更多的字符串。它应该包括一些已知是错误的字符串，以确保我们的测试中没有得到错误的结果。可能还有无数的其他改进可以做出。然而，这里的目的是展示一个简单的测试，以演示如何设置基于TestNG的环境。在继续之前，让我们看看更多的一些例子。
- en: 'Here''s a test to check for failure (a **negative test**):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个用于检查失败的测试（一个**负面测试**）：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this test, we expect the call to `parse()` to fail, with a `DateCalcException`.
    Should the call **not** fail, we have a call to `Assert.fail()` that will force
    the test to fail with the message provided. If the `Exception` is thrown, it's
    swallowed silently and the test finishes successfully.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们期望`parse()`的调用会失败，并抛出`DateCalcException`。如果调用**不**失败，我们将有一个调用`Assert.fail()`的调用，这将强制测试以提供的信息失败。如果抛出了`Exception`，它将被静默捕获，并且测试将成功完成。
- en: 'Swallowing the `Exception` is one approach, but you can also tell TestNG to
    expect an `Exception` to be thrown, as we''ve done here via the `expectedExceptions`
    attribute:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获`Exception`是一种方法，但你也可以告诉TestNG预期会抛出`Exception`，就像我们在这里通过`expectedExceptions`属性所做的那样：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, we're passing a bad string to the parser. However, this time, we're telling
    TestNG to expect the exception via the annotation--`@Test(expectedExceptions =
    {DateCalcException.class})`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们向解析器传递了一个错误的字符串。然而，这次，我们通过注解告诉TestNG预期异常--`@Test(expectedExceptions =
    {DateCalcException.class})`。
- en: Much more could be written on testing in general and TestNG in particular. A
    thorough treatment of both topics is beyond our scope, but if you are not familiar
    with either topic, you would be well served to find one of the many great resources
    available and study them thoroughly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试的一般性和TestNG的特定性可以写更多。这两个主题的彻底处理超出了我们的范围，但如果你不熟悉这两个主题中的任何一个，你最好找到许多可用的优秀资源并彻底研究它们。
- en: For now, let's turn our attention to the command-line interface.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把注意力转向命令行界面。
- en: Building the command-line interface
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建命令行界面
- en: In the last chapter, we built a command-line tool using the Crest library from
    Tomitribe, and it worked out pretty well, so we will return to the library in
    building this command line as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Tomitribe的Crest库构建了一个命令行工具，并且效果相当不错，所以我们将回到这个库来构建这个命令行。
- en: 'To enable Crest in our project, we must do two things. First, we have to configure
    our POM file as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中启用Crest，我们必须做两件事。首先，我们必须按照以下方式配置我们的POM文件：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We must also update our module definition in `src/main/java/module-info.java`
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须更新我们的模块定义在`src/main/java/module-info.java`中，如下所示：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now define our CLI class like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义我们的CLI类如下：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unlike in the last chapter, this command line will be extremely simple, as the
    only input we need is the expression to evaluate. With the preceding method signature,
    we tell Crest to pass all of the command-line arguments as the `args` value, which
    we then join back together via `String.join()` into `expression`. Next, we create
    our calculator and calculate the result.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章不同，这个命令行将非常简单，因为我们需要的唯一输入是要评估的表达式。根据前面的方法签名，我们告诉Crest将所有命令行参数作为`args`值传递，然后我们通过`String.join()`将它们重新组合成`expression`。接下来，我们创建我们的计算器并计算结果。
- en: 'We now need to interrogate our `DateCalcResult` to determine the nature of
    the expression. Consider the following piece of code as an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要调查我们的`DateCalcResult`以确定表达式的性质。以下代码片段作为示例：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `LocalDate` and `LocalTime` responses are pretty straightforward--we can
    simply call the `toString()` method on them, as the defaults are, for our purposes
    here, perfectly acceptable. Duration and periods are a bit more complicated. Both
    provide a number of methods to extract the details. We will hide those details
    in separate methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate`和`LocalTime`的响应相当直接--我们只需在它们上调用`toString()`方法，因为默认值对我们来说在这里是完全可以接受的。持续时间周期稍微复杂一些。两者都提供了一些方法来提取详细信息。我们将把这些细节隐藏在单独的方法中：'
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The method itself is pretty simple--we extract the various parts from `Duration`,
    then build the string based on whether or not the part returns values.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法本身相当简单--我们从`Duration`中提取各个部分，然后根据部分是否返回值来构建字符串。
- en: 'The date-related method, `processPeriod()`, is similar:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与日期相关的方法`processPeriod()`类似：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each of these methods returns the result as a string, which we then write to
    standard out. And that's it. It's not a terribly complicated command-line utility,
    but the purpose of the exercise here is found mostly in the library.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都将结果作为字符串返回，然后我们将其写入标准输出。就是这样。这不是一个特别复杂的命令行工具，但这个练习的目的主要在于库。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our date calculator is now complete. The utility itself is not too terribly
    complex, although, it did serve as expected, which has to be a vehicle for experimenting
    with Java 8's Date/Time API. In addition to the new date/time API, we scratched
    the surface of regular expressions, a very powerful and complex tool to parse
    strings. We also revisited the command-line utility library from the last chapter,
    and dipped our toes in the waters of unit testing and test-driven development.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据计算器现在已经完成了。这个实用工具本身并不太复杂，尽管如此，它确实按照预期工作，这为我们提供了一个实验Java 8的日期/时间API的平台。除了新的日期/时间API之外，我们还对正则表达式进行了初步探索，这是一个非常强大且复杂的工具，用于解析字符串。我们还回顾了上一章中的命令行实用工具库，并尝试了单元测试和测试驱动开发。
- en: In the next chapter, we'll get a bit more ambitious and step into the world
    of social media, building an app to help us aggregate some of our favorite services
    into a single application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将变得更加雄心勃勃，进入社交媒体的世界，构建一个应用程序，帮助我们把我们的一些最喜欢的服务聚合到一个单一的应用程序中。
