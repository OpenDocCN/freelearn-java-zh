- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Avoiding Memory Leaks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免内存泄漏
- en: In the previous chapter, we examined how to configure and monitor memory management
    in the JVM. This involved knowledge of the metrics relevant to the tuning of the
    JVM. We discussed how to obtain these metrics and, consequently, how to tune the
    JVM. We also examined how to use profiling to obtain insights into the effects
    of tuning.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何配置和监控 JVM 的内存管理。这涉及到与 JVM 调优相关的指标知识。我们讨论了如何获取这些指标，以及如何据此调整 JVM。我们还探讨了如何使用分析来深入了解调整的影响。
- en: 'This chapter focuses on memory leaks. We will examine memory leaks under the
    following headings:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍内存泄漏。我们将以下标题下探讨内存泄漏：
- en: Understanding memory leaks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内存泄漏
- en: Spotting memory leaks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现内存泄漏
- en: Avoiding memory leaks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免内存泄漏
- en: Let us start with understanding memory leaks. After that, we will learn how
    to spot them in our code and see how to avoid and solve them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解内存泄漏开始。之后，我们将学习如何在我们的代码中找到它们，并了解如何避免和解决它们。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到：[https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management)。
- en: Understanding memory leaks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内存泄漏
- en: A memory leak occurs when objects that are no longer needed are not freed up.
    This causes these objects to accumulate in memory. Given that memory is a finite
    resource, this can eventually result in your application slowing down or even
    crashing (with an **out-of-memory** (**OOM**) error).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要的对象没有被释放时，就会发生内存泄漏。这导致这些对象在内存中积累。鉴于内存是一种有限的资源，这最终可能导致你的应用程序变慢，甚至崩溃（出现**内存不足**（**OOM**）错误）。
- en: Having fast servers or hosting your application in the cloud does not abstract
    you from the effects of poor memory management (memory leaks). As stated earlier,
    memory is a finite resource and even fast servers can run out of memory. If deploying
    on the cloud, it is tempting to simply scale up to address the issue of memory
    leaks; however, this results in higher costs for deploying an instance that is
    larger than it needs to be. It can even lead to hefty cloud service bills.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使拥有快速的服务器或在云端托管你的应用程序，也无法让你摆脱糟糕的内存管理（内存泄漏）的影响。正如之前所述，内存是一种有限的资源，即使是快速的服务器也可能耗尽内存。如果在云端部署，简单地扩展以解决内存泄漏问题可能很有吸引力；然而，这会导致部署比实际需要的更大的实例的成本增加。甚至可能导致昂贵的云服务账单。
- en: How fast you run out of memory depends on where in your code the memory leak
    occurs. If this is a piece of code that seldom runs, it will take a long time
    for the memory to get full. However, if this is a piece of code that runs frequently,
    it might go a lot faster.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你耗尽内存的速度取决于内存泄漏发生在你的代码的哪个位置。如果这是一段很少运行的代码，那么内存填满需要很长时间。然而，如果这是一段经常运行的代码，它可能去得很快。
- en: 'While the reasons for memory leaks may vary, one likely culprit is a bug in
    your code. This leads us to our next topic: spotting memory leaks.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然内存泄漏的原因可能各不相同，但一个可能的原因是代码中的错误。这让我们转向下一个主题：发现内存泄漏。
- en: Spotting memory leaks
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现内存泄漏
- en: So, you may wonder what typically when your application starts to respond somewhat
    slower after running for some time. The system administrator might just restart
    the application now and then to free the unnecessarily accumulated memory. This
    need for a restart is a typical symptom of a memory leak.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能想知道通常情况下，当你的应用程序运行一段时间后开始响应变慢时会发生什么。系统管理员可能会时不时地重新启动应用程序以释放不必要的累积内存。这种需要重新启动的需求是内存泄漏的典型症状。
- en: 'As memory fills up due to a memory leak, applications will slow down and even
    crash. While an application slowing down is not necessarily due to a memory leak,
    this often is the case. When faced with code that you suspect contains a memory
    leak, the following metrics are very helpful in diagnosing the application:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存泄漏，内存逐渐填满，应用程序会变慢，甚至崩溃。虽然应用程序变慢不一定是由内存泄漏引起的，但这通常是这种情况。当你面对你怀疑含有内存泄漏的代码时，以下指标对于诊断应用程序非常有帮助：
- en: Heap memory footprint
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆内存足迹
- en: Garbage collection activity
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集活动
- en: Heap dump
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆转储
- en: 'In order to demonstrate how to monitor these metrics, we will need an application
    that contains a memory leak. *Figure 7**.1* shows such a program:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何监控这些指标，我们需要一个包含内存泄漏的应用程序。*图 7.1* 展示了这样一个程序：
- en: '![Figure 7.1 – Program with a memory leak](img/Figure_7.1_B18762.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 含有内存泄漏的程序](img/Figure_7.1_B18762.jpg)'
- en: Figure 7.1 – Program with a memory leak
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 存在内存泄漏的程序
- en: In *Figure 7**.1*, we are in an infinite loop starting on *line 15*, creating
    `Person` objects and adding them to an `ArrayList` object. As each `Person` reference
    (`p`) is re-initialized, it is easy to think that each `Person` object that the
    reference previously referred to is now eligible for garbage collection. However,
    this is not the case, as those `Person` objects are being referred to from the
    `ArrayList` object and consequently cannot be reclaimed by the garbage collector.
    Therefore, while the infinite loop results in the program eventually running out
    of memory, the memory leak itself is because the garbage collector is unable to
    reclaim the `Person` objects. Let us examine how we can diagnose the running code
    to help us arrive at this conclusion.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图7.1**中，我们从**第15行**开始进入一个无限循环，创建`Person`对象并将它们添加到`ArrayList`对象中。每当`Person`引用（`p`）被重新初始化时，很容易认为之前引用的每个`Person`对象现在都符合垃圾回收的条件。然而，事实并非如此，因为这些`Person`对象正被`ArrayList`对象引用，因此垃圾回收器无法回收它们。因此，虽然无限循环最终会导致程序耗尽内存，但内存泄漏本身是因为垃圾回收器无法回收`Person`对象。让我们看看我们如何诊断正在运行的代码，以帮助我们得出这个结论。
- en: 'We will run this program using the command line as we can easily specify that
    we want the heap dumped to a file if the heap runs out of memory. The current
    directory is this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用命令行运行这个程序，因为我们很容易指定如果堆耗尽内存，我们希望将堆转储到文件中。当前目录是：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following command in the command line (written over several lines for clarity)
    achieves this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行中的以下命令（为了清晰起见，分多行书写）实现了这一点：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The interesting parts here are the `–XX` options specified. In the first instance,
    we are turning on the `HeapDumpOnOutOfMemoryError` option. This means that if
    the heap runs out of memory, the JVM will dump the heap into a file. All we need
    to do now is specify the location and name of that file. This is what the second
    `–XX` option does, using the `HeapDumpPath` flag.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是指定的`–XX`选项。在第一种情况下，我们开启了`HeapDumpOnOutOfMemoryError`选项。这意味着如果堆耗尽内存，JVM会将堆转储到一个文件中。我们现在需要指定该文件的位置和名称。这就是第二个`–XX`选项所做的事情，使用`HeapDumpPath`标志。
- en: Now that we have started our memory leak-affected application, we will use the
    **VisualVM** application to monitor the metrics of interest. VisualVM is an application
    that used to come with your Java SDK, but now you’ll have to download it separately
    from [https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml)
    (note that this is the active link at the time of writing). Let us start with
    our diagnosis using the heap memory footprint.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了受内存泄漏影响的应用程序，我们将使用**VisualVM**应用程序来监控感兴趣的指标。VisualVM是以前与Java SDK一起提供的应用程序，但现在您必须从[https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml)（注意，这是撰写本文时的有效链接）单独下载。让我们从使用堆内存占用开始我们的诊断。
- en: Heap memory footprint
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆内存占用
- en: 'What we are looking for here is not the size of the heap itself, but the amount
    of heap *used*. We are also very interested in whether or not the garbage collector
    reclaims the used heap. *Figure 7**.2* shows the heap footprint for the application
    outlined in *Figure 7**.1*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里寻找的不是堆的大小，而是堆**使用量**。我们也非常关注垃圾回收器是否回收了使用的堆。**图7.2**显示了**图7.1**中概述的应用程序的堆占用：
- en: '![Figure 7.2 – Heap memory footprint](img/Figure_7.2_B18762.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 堆内存占用](img/Figure_7.2_B18762.jpg)'
- en: Figure 7.2 – Heap memory footprint
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 堆内存占用
- en: As can be seen from the preceding screenshot, the used heap (the area between
    the *x* axis and the graph line) quickly occupies all the heap space available.
    The garbage collector does manage to reclaim some memory (the dip on the left),
    but this is not memory allocated by our application. The program runs out of memory
    and crashes due to an `OutOfMemoryError` error. This is why the used heap goes
    back to `0`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，使用的堆（*x*轴和图表线之间的区域）迅速占据了所有可用的堆空间。垃圾回收器确实设法回收了一些内存（左边的下降），但这不是我们应用程序分配的内存。程序因`OutOfMemoryError`错误而耗尽内存并崩溃。这就是为什么使用的堆回到`0`的原因。
- en: Let us examine the garbage collector activity during this period.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个期间垃圾回收器的活动。
- en: Garbage collector activity
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收器活动
- en: 'In the previous section, we saw the effect an application containing a memory
    leak has on the heap footprint. It is interesting to examine the activity of the
    garbage collector during that period. *Figure 7**.3* reflects this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了包含内存泄漏的应用程序对堆足迹的影响。有趣的是，检查垃圾收集器在那段时间的活动。*图7**.3*反映了这一点：
- en: '![Figure 7.3 – Garbage collector activity](img/Figure_7.3_B18762.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 垃圾收集器活动](img/Figure_7.3_B18762.jpg)'
- en: Figure 7.3 – Garbage collector activity
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 垃圾收集器活动
- en: '*Figure 7**.3* shows that the garbage collector is very busy during the run
    of the program. However, as per *Figure 7**.2*, we know this had no effect on
    freeing up space (allocated by our application) on the heap. Thus, in spite of
    having a busy garbage collector, the heap remains full. This is a classic sign
    of a memory leak.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7**.3*显示垃圾收集器在程序运行期间非常忙碌。然而，根据*图7**.2*，我们知道这并没有对释放堆上的空间（由我们的应用程序分配）产生影响。因此，尽管垃圾收集器很忙碌，堆仍然满载。这是一个典型的内存泄漏迹象。'
- en: So now, we have validated that we have a memory leak in our program. The next
    step is to figure out what is causing the leak. In our case, it’s rather obvious,
    but to help us understand better, let’s investigate further. The next step would
    be to look at the heap dump created by the JVM when our program crashed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经验证了我们的程序中存在内存泄漏。下一步是找出导致泄漏的原因。在我们的例子中，这相当明显，但为了更好地理解，让我们进一步调查。下一步将是查看我们的程序崩溃时JVM创建的堆转储。
- en: Heap dump
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆转储
- en: 'When we ran our application, we specified that we wanted to create a heap dump
    if the application ran out of memory. This will enable us to further debug why
    we ran out of memory in the first place. *Figure 7**.4* represents the heap dump
    summary generated:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们指定了如果应用程序内存不足，则创建堆转储。这将使我们能够进一步调试为什么最初会耗尽内存。*图7**.4*展示了生成的堆转储摘要：
- en: '![Figure 7.4 – Heap dump summary](img/Figure_7.4_B18762.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 堆转储摘要](img/Figure_7.4_B18762.jpg)'
- en: Figure 7.4 – Heap dump summary
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 堆转储摘要
- en: Two values in *Figure 7**.4* jump out straight away. The first is the number
    of *instances* (first arrow). At *205,591,192*, this is far too many. Now, we
    need to know what type of instance is causing the memory leak. The second red
    arrow highlights `ch7.Person` as the offending type, given that there are *205,544,625*
    instances of that type alone.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7**.4*中的两个值立即跳入眼帘。第一个是实例的数量（第一个箭头）。在*205,591,192*，这太多了。现在，我们需要知道导致内存泄漏的实例类型。第二个红色箭头突出显示`ch7.Person`为违规类型，因为仅该类型就有*205,544,625*个实例。'
- en: 'The heap dump also enables us to drill down further. In this case, we will
    do just that, as we want to see what is *preventing* the garbage collection of
    these `Person` objects. *Figure 7**.5* will help us discuss that:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 堆转储还使我们能够进一步深入。在这种情况下，我们将这样做，因为我们想看看是什么*阻止*了这些`Person`对象的垃圾收集。*图7**.5*将帮助我们讨论这一点：
- en: '![Figure 7.5 – Heap dump drilldown](img/Figure_7.5_B18762.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 堆转储深入分析](img/Figure_7.5_B18762.jpg)'
- en: Figure 7.5 – Heap dump drilldown
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 堆转储深入分析
- en: In the preceding screenshot, we have drilled down from the summary level to
    the object level. As we know, there are a lot of `Person` objects. By drilling
    down into any one of the `Person` objects, we can see the type that is referring
    to it. As highlighted in one of the `Person` objects (in blue), we can see that
    it is an `ArrayList` object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们已经从摘要级别深入到对象级别。正如我们所知，有很多`Person`对象。通过深入到任何一个`Person`对象，我们可以看到引用它的类型。正如在其中一个`Person`对象（以蓝色突出显示）中所示，我们可以看到它是一个`ArrayList`对象。
- en: Now, we have a much clearer idea of what is happening. We are adding `Person`
    objects to an `ArrayList` object whose reference never goes out of scope. As a
    result, the garbage collector cannot remove any of these `Person` objects from
    the heap, and we end up with an `OutOfMemoryError` error.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对正在发生的事情有了更清晰的认识。我们正在向一个`ArrayList`对象添加`Person`对象，其引用永远不会超出作用域。因此，垃圾收集器无法从堆中移除这些`Person`对象中的任何一个，最终导致`OutOfMemoryError`错误。
- en: To summarize, in this section, we diagnosed a program that contained a memory
    leak. Using the heap memory footprint and garbage collection activity, we confirmed
    the presence of a memory leak. We then analyzed the heap dump to ascertain the
    offending collection (`ArrayList`) and type (`Person`). The next section will
    deal with how to avoid memory leaks in the first place.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们诊断了一个包含内存泄漏的程序。通过使用堆内存足迹和垃圾回收活动，我们确认了内存泄漏的存在。然后我们分析了堆转储，以确定导致问题的集合（`ArrayList`）和类型（`Person`）。下一节将讨论如何从一开始就避免内存泄漏。
- en: Avoiding memory leaks
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免内存泄漏
- en: 'The best way of avoiding a memory leak is to write code that does not contain
    any leaks in the first place. In other words, objects that we no longer need should
    *not* have connections back to the stack, as that prevents the garbage collector
    from reclaiming them. Before we get into techniques that help you avoid leaks
    in your code, let us first fix the leak presented in *Figure 7**.1*. *Figure 7**.6*
    presents the leak-free code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 避免内存泄漏的最佳方式是编写不包含任何泄漏的代码。换句话说，我们不再需要的对象不应有回连到栈上的连接，因为这会阻止垃圾收集器回收它们。在我们探讨帮助您避免代码中泄漏的技术之前，让我们首先修复
    *图 7.1* 中展示的泄漏。*图 7.6* 展示了无泄漏代码：
- en: '![Figure 7.6 – Leak-free program](img/Figure_7.6_B18762.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 无泄漏程序](img/Figure_7.6_B18762.jpg)'
- en: Figure 7.6 – Leak-free program
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 无泄漏程序
- en: In *Figure 7**.6*, the infinite loop remains. However, *lines 19* to *23* are
    new. In this new section, we increment an `i` local variable every time we add
    a `Person` reference to the `ArrayList` object. Once we have done this 1,000 times,
    we re-initialize our `list` reference. This is crucial as it enables the garbage
    collector to reclaim the old `ArrayList` object and the 1,000 `Person` objects
    referred to from the `ArrayList` object. In addition, we reset `i` back to `0`.
    This will solve the leak. (Please send us an email if you find a use case for
    this specific example, and we’ll add it to the next edition of the book. It does,
    however, illustrate the example graphs well.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7.6* 中，无限循环仍然存在。然而，*第 19 行* 到 *第 23 行* 是新的。在这个新部分中，我们每次向 `ArrayList` 对象添加一个
    `Person` 引用时，都会增加一个 `i` 本地变量。当我们这样做 1,000 次之后，我们重新初始化我们的 `list` 引用。这是至关重要的，因为它使垃圾收集器能够回收旧的
    `ArrayList` 对象和从 `ArrayList` 对象引用的 1,000 个 `Person` 对象。此外，我们将 `i` 重置回 `0`。这将解决泄漏问题。（如果您发现这个特定示例有实际应用场景，请发送电子邮件给我们，我们将将其添加到下一版书籍中。然而，它确实很好地说明了示例图表。）
- en: 'We will now run the program using the same command-line arguments as before.
    The program does not generate an `OutOfMemoryError` error. We will now examine
    the code’s performance using VisualVM. *Figure 7**.6* reflects the heap memory
    footprint of the new memory leak-free code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用与之前相同的命令行参数运行程序。程序不会生成 `OutOfMemoryError` 错误。我们将现在使用 VisualVM 检查代码的性能。*图
    7.6* 反映了新无内存泄漏代码的堆内存足迹：
- en: '![Figure 7.7 – Heap memory footprint (leak-free code)](img/Figure_7.7_B18762.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 堆内存足迹（无泄漏代码）](img/Figure_7.7_B18762.jpg)'
- en: Figure 7.7 – Heap memory footprint (leak-free code)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 堆内存足迹（无泄漏代码）
- en: As we can see in the preceding screenshot, the used heap space (area between
    the *x* axis and the graph) goes up and down. The down areas reflect where the
    garbage collector reclaims memory. This pattern resembles the teeth of a saw and
    is a sign of a healthy program. Toward the end, we stopped running the program.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，使用的堆空间（*x* 轴和图表之间的区域）上下波动。下降区域反映了垃圾收集器回收内存的地方。这种模式类似于锯齿，是健康程序的标志。在最后，我们停止了程序的运行。
- en: 'Next, we will look at the garbage collector activity during that time. *Figure
    7**.8* reflects this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看那段时间的垃圾收集器活动。*图 7.8* 反映了这一点：
- en: '![Figure 7.8 – Garbage collector activity (leak-free code)](img/Figure_7.8_B18762.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 垃圾收集器活动（无泄漏代码）](img/Figure_7.8_B18762.jpg)'
- en: Figure 7.8 – Garbage collector activity (leak-free code)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 垃圾收集器活动（无泄漏代码）
- en: In *Figure 7**.3* (the graph representing the code with the memory leak), the
    garbage collector was running at over 5%. Here, in *Figure 7**.8*, however, the
    garbage collector is barely noticeable at all and almost the same as the *x* axis.
    Again, a sign of a healthy program. As this program does not run out of heap space,
    there is no need for a heap dump.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7.3*（表示有内存泄漏的代码的图表）中，垃圾收集器运行在超过 5% 的水平。然而，在 *图 7.8* 中，垃圾收集器几乎完全不可见，几乎与
    *x* 轴相同。这再次是健康程序的标志。由于这个程序没有耗尽堆空间，因此不需要堆转储。
- en: Common pitfalls and how to avoid them
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见陷阱及其避免方法
- en: Now that we have addressed the memory leak issue, we will review some common
    problems in code and how to avoid them. We will discuss techniques that will enable
    us to write leak-free code and code that uses memory in an optimal way without
    wasting resources that we actually did not need to use.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了内存泄漏问题，我们将回顾代码中的一些常见问题以及如何避免它们。我们将讨论一些技术，这些技术将使我们能够编写无泄漏的代码，并使用内存以最佳方式，而不浪费我们实际上不需要使用的资源。
- en: Some of the tips are a bit more obvious and don’t require a lot of examples,
    such as assigning a decent amount of heap space to your program if this is possible
    for the system, as well as not creating objects that you don’t need and reusing
    objects when you can. Some of them require a little more explanation, and we’ll
    elaborate on them next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一些提示比较明显，不需要很多例子，例如，如果系统允许，为你的程序分配足够的堆空间，以及不要创建不需要的对象，并在可能的情况下重用对象。其中一些需要更多的解释，我们将在下面详细说明。
- en: Unnecessary references on the stack and setting the reference to null
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈上的不必要引用和将引用设置为null
- en: It is possible that there are references on the stack that are actually no longer
    needed. In our preceding example, this was the case.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在栈上的引用实际上不再需要。在我们前面的例子中就是这样。
- en: 'Re-initializing the reference (or setting it to `null`) is the approach used
    in this section to fix the memory leak. Both approaches break the link back to
    the stack, enabling the garbage collector to reclaim the heap memory. Be careful,
    though, that you only do this when your application is finished with the objects;
    otherwise, you’ll get `NullPointerException` exceptions. You can see the following
    example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重新初始化引用（或将它设置为`null`）是本节中用来修复内存泄漏的方法。两种方法都切断了与栈的链接，使垃圾收集器能够回收堆内存。不过，请注意，只有在你应用程序完成与对象的交互时才这样做；否则，你会得到`NullPointerException`异常。你可以看到以下示例：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we’re having an object reference stored in `personObj`; when
    we no longer need it, we set it to `null`. This way, the `Person` object on the
    heap becomes eligible for garbage collection after the line where we set it to
    `null` (assuming that we didn’t assign the reference to other variables).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个对象引用存储在`personObj`中；当我们不再需要它时，我们将其设置为`null`。这样，在将引用设置为`null`的行之后，堆上的`Person`对象就变得适合垃圾回收（假设我们没有将引用分配给其他变量）。
- en: Whether or not this approach is still relevant for today’s software is questionable;
    for most modern applications, this approach is less favorable, but of course,
    there could be sensible use cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是否仍然适用于今天的软件是有疑问的；对于大多数现代应用程序，这种方法不太受欢迎，但当然，也可能有合理的用例。
- en: Resource leaks and closing resources
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源泄漏和关闭资源
- en: When you open resources such as files, databases, streams, and so on, they take
    up memory. If these resources are not closed, this could lead to resource leaks.
    In some scenarios, it could even lead to a serious depletion of the available
    resources and affect the performance of your application—for example, the buffers
    could get full. If you are producing output—for example, writing to a file or
    committing to a database—not closing the resource might actually lead to incorrect
    persistence or writing of the data, and the data might not reach its intended
    destination such as an output file or a database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开资源，如文件、数据库、流等时，它们会占用内存。如果这些资源没有被关闭，这可能导致资源泄漏。在某些情况下，甚至可能导致可用资源的严重耗尽，影响应用程序的性能——例如，缓冲区可能被填满。如果你正在生成输出——例如，写入文件或提交到数据库——不关闭资源实际上可能导致数据持久化或写入错误，数据可能无法到达预期的目的地，如输出文件或数据库。
- en: Closing resources (such as file and database connections) when finished is a
    method to prevent this from happening. Using the `finally` block or `try-with-resources`
    is of great help here. The `finally` block is always executed, regardless of whether
    or not an exception occurs. `try-with-resources` has an in-built `finally` block
    to close any resources opened in the `try` section. Using the `finally` block
    or `try-with-resources` ensures that the resources will be closed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后关闭资源（如文件和数据库连接）是防止这种情况发生的一种方法。使用`finally`块或`try-with-resources`在这里非常有帮助。`finally`块总是被执行，无论是否发生异常。`try-with-resources`有一个内置的`finally`块来关闭在`try`部分中打开的任何资源。使用`finally`块或`try-with-resources`确保资源将被关闭。
- en: 'Consider the following code of a regular `try`-`catch` block:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下常规`try`-`catch`块的代码：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `finally` block executes, whether an exception occurred or not. This way,
    we can be sure that the resources are closed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否发生异常，`finally`块都会执行。这样，我们可以确保资源被关闭。
- en: 'Since Java 7, it is more common to use the `try-with-resources`. At the end
    of the `try` block, it is going to call the `close()` method on the objects initialized
    in the `try` statement (these objects must be implementing the `AutoCloseable`
    interface). This is what the previous example would look like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 7以来，更常见的是使用`try-with-resources`。在`try`块的末尾，它将调用在`try`语句中初始化的对象的`close()`方法（这些对象必须实现`AutoCloseable`接口）。以下是一个示例：
- en: '[PRE36]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, this is much cleaner, and it prevents you from forgetting to
    close the resources. Therefore, using `try-with-resources` whenever possible is
    recommended.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这要干净得多，并且可以防止你忘记关闭资源。因此，建议尽可能使用`try-with-resources`。
- en: Avoiding unnecessary String objects using StringBuilder
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`StringBuilder`避免不必要的字符串对象
- en: '`String` objects are immutable and therefore cannot be changed after creation.
    In the background, your requested changes result in a new `String` object being
    created (which reflects your changes) while the original `String` object remains
    untouched.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象是不可变的，因此创建后不能更改。在后台，你的请求更改会导致创建一个新的`String`对象（它反映了你的更改），而原始的`String`对象保持不变。'
- en: 'For example, when you concatenate one `String` object onto another `String`
    object, you actually end up with three different objects in memory: the original
    `String` object, the `String` object you want to concatenate, and the new, resultant
    `String` object reflecting the result of the concatenation.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你将一个`String`对象连接到另一个`String`对象上时，实际上你在内存中会得到三个不同的对象：原始的`String`对象、你想要连接的`String`对象以及反映连接结果的新`String`对象。
- en: 'Put the `String` concatenation code into a loop, and many unnecessary objects
    are created in the background. Consider the following example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串连接代码放入循环中，后台会创建许多不必要的对象。考虑以下示例：
- en: '[PRE43]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is what the outputted `String` object will look like after the loop. We’ve
    omitted the middle section to not make this snippet unnecessarily lengthy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是循环结束后输出的`String`对象的样子。我们省略了中间部分，以避免使这个片段变得不必要地长：
- en: '[PRE48]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this example, we are creating a lot of objects, and every intermediate `concat`
    step creates a new object. For example, after the first two iterations, the value
    of `strIntToChar` is this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了大量的对象，并且每个中间的`concat`步骤都会创建一个新的对象。例如，在第一次和第二次迭代之后，`strIntToChar`的值如下：
- en: '[PRE55]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And after three iterations, it is this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 经过三次迭代后，结果如下：
- en: '[PRE57]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All these intermediate values are stored in a *String pool*. This is because
    `String` objects are *immutable*, and the String pool is used as an optimization
    that is working against us here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些中间值都存储在*字符串池*中。这是因为`String`对象是不可变的，而字符串池在这里被用作一个与我们作对的优化。
- en: 'The solution to this problem would be to use `StringBuilder`. `StringBuilder`
    objects are mutable. If we rewrite the previous code using `StringBuilder`, a
    lot fewer objects are created, since we are not creating a separate `String` object
    for every intermediate value. This is what the code would look like with `StringBuilder`
    instead:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法就是使用`StringBuilder`。`StringBuilder`对象是可变的。如果我们用`StringBuilder`重写之前的代码，由于我们不是为每个中间值创建一个单独的`String`对象，因此创建的对象会少得多。以下是使用`StringBuilder`的代码示例：
- en: '[PRE60]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When concatenating, there won’t be a new `StringBuilder` object created as the
    JVM manipulates the original `StringBuilder` object. As you can see, it doesn’t
    require drastic changes to the code, but it does improve memory management a lot.
    Thus, when concatenating a `String` object a lot, use `StringBuilder`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行连接操作时，JVM会操作原始的`StringBuilder`对象，因此不会创建一个新的`StringBuilder`对象。正如你所见，这不需要对代码进行大幅修改，但它确实大大提高了内存管理效率。因此，当频繁地连接`String`对象时，应使用`StringBuilder`。
- en: Managing memory usage by using primitives instead of wrapper classes
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用原始类型而不是包装类来管理内存使用
- en: Wrapper classes require a lot more memory than primitives. Sometimes, you must
    use wrapper classes—it is not optional. In other cases, using primitives instead
    of wrapper types is an option. So, for example, create a local variable of type
    `int` instead of `Integer`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类比原始类型需要更多的内存。有时，你必须使用包装类——这不是可选的。在其他情况下，使用原始类型而不是包装类型是一个选择。例如，创建一个类型为`int`的局部变量而不是`Integer`。
- en: Primitive variables occupy a small amount of memory, and if the primitive is
    local to a method, it is stored on the stack (which is faster to access than the
    heap). Wrappers, on the other hand, are class types and always result in the creation
    of an object on the heap. In addition, if it’s possible, you should use the `long`
    and `double` primitives instead of `BigInteger` and `BigDecimal`. `BigDecimal`,
    in particular, is popular due to its precision in calculations. However, this
    precision comes at the price of requiring a lot more memory and slower calculations,
    so only use this class when you really need the precision.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 原始变量占用很少的内存，如果原始变量是方法局部变量，它将存储在栈上（比堆更快访问）。另一方面，包装器是类类型，总是导致在堆上创建一个对象。此外，如果可能的话，你应该使用`long`和`double`原始类型而不是`BigInteger`和`BigDecimal`。特别是`BigDecimal`因其计算精度而受到欢迎。然而，这种精度是以需要更多内存和较慢的计算速度为代价的，因此只有在你确实需要精度时才使用这个类。
- en: Please note that this is not an actual memory leak that you’re preventing, but
    rather optimizing the usage of memory by not requiring more memory than you need
    to achieve the goals of your application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不是你正在防止的实际内存泄漏，而是通过不需要比实现应用程序目标所需的更多内存来优化内存的使用。
- en: The problem with static collections and why to avoid this
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态集合的问题以及为什么要避免使用它
- en: 'In some situations, it can be tempting to use a static collection in a class
    to keep the objects in an application, especially when you are working with a
    Java SE-only environment and you’d like to store objects. This is something that
    is quite a danger to a healthy memory footprint. This is what such an example
    could look like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会诱使你在一个类中使用静态集合来保持应用程序中的对象，尤其是在你只使用Java SE环境并且想要存储对象时。这对健康的内存足迹来说是非常危险的。这样的例子可能看起来是这样的：
- en: '[PRE65]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This could get quickly out of hand. The objects created cannot be garbage-collected
    because the static collection keeps them alive. There are a few better ways to
    go about this. If this is something you really feel you need, chances are you
    might be able to use a database instead.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会迅速失控。创建的对象不能被垃圾收集，因为静态集合使它们保持活跃。有几种更好的方法可以处理这个问题。如果你真的觉得你需要这样做，那么你可能能够使用数据库来代替。
- en: If you are using a `HashMap` class as a static collection, chances are you can
    use a `WeakHashMap` (Java 8 onward) instead. This will have weak references for
    the keys (so please note this; not the values—these are held by strong references).
    These key references are stored as weak references in the `WeakHashMap`, but this
    will not prevent the garbage collector from removing the object from the heap.
    The entries in the `WeakHashMap` will be removed if the key is no longer used
    by the rest of the application. This means that it should be all right to lose
    information that is not referenced anywhere else. So, if your intention is to
    maintain the information in a `HashMap`, you *should not* be using a `WeakHashMap`
    instead. However, if you don’t require the keys of your `HashMap` to be maintained
    on the heap if that’s the only reference, it’s possible that a `WeakHashMap` is
    an optimization for your heap usage. As always, research carefully whether this
    fits your requirements before implementing it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`HashMap`类作为静态集合，那么你很可能可以使用`WeakHashMap`（从Java 8开始）来代替。这将具有对键的弱引用（请注意这一点；不是值——这些由强引用持有）。这些键引用在`WeakHashMap`中以弱引用的形式存储，但这不会阻止垃圾收集器从堆中移除对象。如果键不再被应用程序的其他部分使用，`WeakHashMap`中的条目将被移除。这意味着，如果你不希望丢失任何其他地方没有引用的信息，那么这是完全可以的。所以，如果你的意图是在`HashMap`中维护信息，那么你*不应该*使用`WeakHashMap`。然而，如果你不需要在堆上维护`HashMap`的键，如果这是唯一的引用，那么`WeakHashMap`可能是你堆使用的一个优化。像往常一样，在实现之前仔细研究这是否符合你的要求。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to avoid memory leaks in our code. The first
    step was to understand that memory leaks occur when objects, when no longer needed,
    maintain links to the stack. This prevents the garbage collector from reclaiming
    them. Given that memory is a finite resource, this is never desirable. As these
    objects accumulate, your application slows down and eventually crashes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何避免代码中的内存泄漏。第一步是理解内存泄漏发生在对象不再需要时，但仍然保持对栈的链接。这阻止了垃圾收集器回收它们。鉴于内存是一种有限的资源，这从来不是所希望的。随着这些对象的积累，你的应用程序会变慢，最终崩溃。
- en: One common source of memory leaks is bugs in our code. However, there are ways
    to debug memory leaks. In order to demonstrate how to debug leaky code, we presented
    a program containing a memory leak. VisualVM is a tool that enables us to monitor
    the metrics of interest—the heap memory footprint, garbage collection activity,
    and the heap dump (when we run out of heap space).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏的一个常见来源是我们代码中的错误。然而，有方法可以调试内存泄漏。为了演示如何调试泄漏代码，我们展示了一个包含内存泄漏的程序。VisualVM 是一个工具，它使我们能够监控感兴趣的指标——堆内存占用、垃圾回收活动以及堆转储（当我们耗尽堆空间时）。
- en: The heap footprint validated the presence of a memory leak as it showed the
    *used* heap space totally occupying the available heap space. In other words,
    objects on the heap were not reclaimed. Meanwhile, the garbage collector was,
    in vain, extremely busy trying to free up heap space. To figure out which type
    was causing the issue, we examined the heap dump. This led us to an `ArrayList`
    object referring to a massive number of `Person` instances.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 堆占用验证了内存泄漏的存在，因为它显示了*使用*的堆空间完全占用了可用的堆空间。换句话说，堆上的对象没有被回收。同时，垃圾收集器徒劳地非常忙碌地试图释放堆空间。为了找出哪种类型导致了问题，我们检查了堆转储。这引导我们到一个`ArrayList`对象，它引用了大量的`Person`实例。
- en: We addressed the leaky code and, using VisualVM again, checked the heap footprint
    and garbage collector activity metrics. Both metrics were much healthier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理了泄漏代码，并再次使用 VisualVM 检查了堆占用和垃圾收集器活动指标。这两个指标都变得更加健康。
- en: However, the best way to avoid memory leaks is not to code them in the first
    place. This is similar to the *prevention is better than cure* principle. With
    this in mind, we discussed a few common techniques used to avoid memory leaks
    in the first place.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，避免内存泄漏的最佳方式是首先不要编写它们。这类似于“预防胜于治疗”的原则。本着这个想法，我们讨论了几种常用的避免内存泄漏的技术。
- en: That concludes the chapter. In short, we started by covering why and how memory
    leaks occur. We then diagnosed and fixed the code containing a memory leak. We
    finished by discussing what to keep in mind to prevent writing leaky code and
    how to optimize memory usage in the first place.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这一章。简而言之，我们首先介绍了内存泄漏发生的原因和方式。然后我们诊断并修复了包含内存泄漏的代码。最后，我们讨论了在编写代码时需要注意的事项以防止代码泄漏，以及如何首先优化内存使用。
- en: 'This doesn’t just conclude the chapter but also the book. We started with an
    overview of the memory and zoomed in on the different aspects. After that, we
    dived into garbage collection. The last chapters of the book focused on how to
    improve performance: how to tune the JVM and how to avoid memory leaks.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅结束了这一章，也结束了这本书。我们从一个内存概述开始，然后聚焦于不同的方面。之后，我们深入探讨了垃圾回收。这本书的最后几章专注于如何提高性能：如何调整
    JVM 以及如何避免内存泄漏。
- en: 'If you’d like to know even more about how the JVM manages memory, the official
    documentation of the JVM is out there waiting for you. You can find the latest
    version here: [https://docs.oracle.com/javase/specs/index.xhtml](https://docs.oracle.com/javase/specs/index.xhtml).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于 JVM 如何管理内存的信息，JVM 的官方文档就在那里等着你。你可以在这里找到最新版本：[https://docs.oracle.com/javase/specs/index.xhtml](https://docs.oracle.com/javase/specs/index.xhtml)。
