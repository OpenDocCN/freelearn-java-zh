- en: Chapter 7. Be assured take a test drive
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章。放心，试驾一下
- en: 'The application development is a lengthier, time consuming and expensive process.
    The development is depending upon the requirements collected from the clients
    and market requirements. But what if after the completion of the work, something
    goes wrong and everything gets collapsed. The collision is not because of the
    incorrect solution, but because it''s based on wrong assumptions which developers
    assumed before the start of the work. This collision occurred just before the
    date of delivery to the client. Now nothing can be recovered! Let''s not go into
    the details of why and what went wrong. But I am interested in, can this be avoided?
    Is there something which can be done to prevent this last moment collision? We
    always heard ''prevention is better than cure''. This phrase is applicable to
    application development as well. The situation of failure can be avoided with
    bit of extra efforts taken by the developers step by step. The cross checking
    of the code developed is according to the requirements helps developers to be
    assured of correct working of the code. This cross checking is called as testing
    of the application. In this chapter, we will discuss in depth about the testing
    with the help of following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用开发是一个漫长、耗时且成本高昂的过程。开发依赖于从客户和市场收集的需求。但是，如果在工作完成后出了问题，一切都会崩溃呢？冲突并非由于解决方案错误，而是因为开发者在工作开始前基于错误的假设。这种冲突恰好在向客户交付日期前发生。现在什么都无法挽回了！我们不必深究为什么会出现问题和具体情况。但我感兴趣的是，这种情况可以避免吗？有没有什么方法可以在最后一刻避免这种冲突呢？我们总是听说“预防胜于治疗”。这个原则也适用于应用开发。通过开发人员逐步付出的少许额外努力，可以避免失败的状况。开发人员开发的代码进行交叉检查，以满足需求，这有助于确保代码的正确运行。这种交叉检查称为应用测试。在本章中，我们将通过以下几点深入讨论测试：
- en: Why testing?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么测试？
- en: Problems in testing of Spring Controllers.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Spring控制器的问题。
- en: Mock testing.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟测试。
- en: Spring TestContext Framework.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 春季测试上下文框架。
- en: Using Mokitoto test Spring Controller.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mokitoto测试Spring控制器。
- en: Introduction to Spring Controller testing using Arquillian
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Arquillian介绍Spring控制器测试。
- en: '''Testing'' an important step'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试是一个重要的步骤
- en: '* * *'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: The application development is an expensive and time consuming process. The
    errors and mistakes occurred at the final deployment leads to very serious consequences.
    The coding is done by the developers according to the requirements, is based on
    the rules which may be based on few assumptions. Being a human we may make mistakes
    in either collection of requirement or making up the assumptions. If this is the
    work done by us, who can better understand it than us? The unit testing tests
    the code and helps in assuring it is working.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用开发是一个昂贵且耗时长的过程。在最后的部署中出现的错误和失误会导致非常严重的后果。开发者根据需求编写的代码基于一些可能基于一些假设的规则。作为人类，我们可能在需求收集或假设制定上犯错误。如果这是我们完成的工作，还有谁比我们更了解它呢？单元测试测试代码，并帮助确保其正常运行。
- en: The developers did development. Their development was based on some assumption
    and they may leave out few blind spots as well. The development is followed by
    the testing by them. It's a high risk to carry out the tests by the same person
    as they may repeat the same mistakes. Ideally someone else should do the check
    assuring they know what they are testing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者完成了开发。他们的开发基于一些假设，他们可能也会遗漏一些盲点。开发之后，他们进行测试。由同一个人进行测试是高风险的，因为他们可能会重复同样的错误。理想情况下，应该是其他人来做检查，确保他们知道他们在测试什么。
- en: Following are the few major factors which makes the testing as one of the unforgettable
    part in application development,
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使测试成为应用开发中难忘的一部分的主要因素：
- en: It helps in early detection of the defect and errors which has been done while
    development.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于尽早发现开发过程中产生的缺陷和错误。
- en: It assures least failures in application executions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保应用程序执行中的失败次数最少
- en: It helps in improving the consistency of an application
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于提高应用程序的一致性
- en: It helps in assuring better application quality
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于确保更好的应用程序质量
- en: It helps in improving the security by checking authentication and authorization
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过检查认证和授权来提高安全性
- en: Helps in saving money and more importantly time
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助节省金钱，更重要的是节省时间
- en: Each application undergoes rigorous testing before it is released to ensure
    the application is matching the requirements and the correctness of all its functionalities.
    Unit testing, Integration testing, System testing and Acceptance testing are four
    major stages through which each application needs to pass.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序在发布之前都要经过严格的测试，以确保应用程序符合要求并确保其所有功能正确无误。单元测试、集成测试、系统测试和验收测试是每个应用程序必须通过的四个主要阶段。
- en: Unit Testing
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing focuses on the unit of the component ensuring the correctness of
    the function. The unit can be referred to an individual function or a procedure.
    The unit testing mainly aims to make sure the unit is working as per the design.
    It allows the raised issues to be resolved quickly. As the unit is the very smallest
    part of the application the code can be modified easily. It's generally done by
    the developer who had developed the code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试关注组件的单元，确保功能的正确性。单元可以指单个函数或过程。单元测试的主要目的是确保单元按设计工作。它允许快速解决提出的问题。由于单元是应用程序的最小部分，因此代码可以很容易地修改。通常由编写代码的开发者进行。
- en: Integration Testing
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: Once the unit testing is successfully carried out, most of the issues occurred
    while testing the unit has been changed to match the requirements. The integration
    testing gives the opportunity to test the group of these units within a program
    execution. It helps in determining how multiple units are running together. The
    unit may work fine, but the same unit when combined with other unit may leads
    to some side effects which need to be resolved. The integration test helps in
    catching such errors giving an opportunity to correct it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦单元测试成功完成，测试单元时出现的大部分问题都已经修改以符合要求。集成测试提供了在程序执行内测试这些单元组的机会。它有助于确定多个单元是如何一起运行的。单元可能运行良好，但当与其他单元结合时，相同的单元可能会导致一些副作用，需要解决。集成测试有助于捕获此类错误，并有机会进行更正。
- en: System Testing
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统测试
- en: In previous two stages the individual unit or interaction of two units with
    one another has been tested. This is the first stage where for the first time
    the complete application will be tested. The system testing is generally done
    by the independent tester and in a close to production environment. The system
    testing makes sure whether all functional and business requirements for which
    the application developed has been mate or not.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个阶段，已经对单个单元或单元之间的相互交互进行了测试。这是第一次全面测试完整应用程序的阶段。系统测试通常由独立测试员在接近生产环境中进行。系统测试确保应用程序开发的所有功能和业务要求是否已经满足。
- en: User Acceptance Testing
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户验收测试
- en: This is the final stage in testing which determines whether the system is ready
    for the final release. The acceptance test is generally carried out by the end
    users to determine the application is meeting the requirements and have covered
    all the necessary functionalities to give the final acceptance. It gives the feel
    of final application in the production environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试的最后阶段，它确定系统是否准备好最终发布。验收测试通常由最终用户执行，以确定应用程序符合要求并涵盖了所有必要的功能以给出最终验收。它使最终应用程序在生产环境中有了预览。
- en: In this chapter we will carry out Unit testing, Integration testing and System
    Testing in three phases. But before moving ahead let's have an overview about
    the testing tools available in market.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将分三个阶段进行单元测试、集成测试和系统测试。但在前进之前，让我们先了解一下市场上可用的测试工具的概况。
- en: Testing Tools
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试工具
- en: '* * *'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Following are the available test tools for Java platform,
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是适用于Java平台的可用测试工具，
- en: JTest
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JTest
- en: JTest is automated software testing, coding standard compliance tool for Java
    platform developed by Parasoft since 1997\. The tool leverages unit as well as
    integration testing. The tool facilitates analysing the classes, generation and
    execution of test cases in the same format as that of JUnit test cases.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JTest 是由 Parasoft 自1997年以来为 Java 平台开发的自动化软件测试、编码标准合规工具。该工具利用单元测试以及集成测试。该工具便于分析类，以与
    JUnit 测试用例相同的格式生成和执行测试用例。
- en: 'Following are the features JTest:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 JTest 功能：
- en: Along with testing, it covers and exposes the runtime exceptions which normally
    a developer doesn't catch.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了测试之外，它还涵盖了正常情况下开发者无法捕获的运行时异常。
- en: The tool also verifies if the class is following **Design by Contract**(**DbC**)
    basis.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该工具还验证类是否遵循**契约式设计**（**DbC**）基础。
- en: It ensures the code follows 400 standard rules of coding and checks the code
    against 200 violation rules.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保代码遵循400个标准编码规则，并将代码与200个违规规则进行比对。
- en: It also can identify the problems like functional errors, memory leakage, and
    security vulnerabilities.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还可以识别功能错误、内存泄漏和安全漏洞等问题。
- en: '**Jcontract** is tools from JTest which verifies the functionality requirements
    during the integration testing without hampering the performance of the application.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jcontract** 是JTest工具的一部分，它在集成测试期间验证功能需求，而不会影响应用程序的性能。'
- en: Grinder
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Grinder**'
- en: Grinder is **load testing tool** for Java programming language available underthe
    BSD-style open source licence. It aims to simplify the running of a distributed
    testing using load injector machines. It has the capabilities to do load testing,
    capability testing, functional testing and stress testing. It has minimum system
    resource requirements along with it manages its own thread in test context which
    can split over the process if required.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grinder** 是一个为Java编程语言设计的负载测试工具，遵循BSD风格的开放源代码许可。它的目标是简化使用负载注入机器进行的分布式测试。它具备负载测试、能力测试、功能测试和压力测试的能力。它对系统资源的要求最低，同时在其测试上下文中管理自己的线程，如果需要可以将其分割到不同的进程。'
- en: 'Following are the features Grinder:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Grinder的特点：
- en: Easy to use Java Swing based user interface
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用的基于Java Swing的用户界面
- en: It can be used for load testing of anything which has Java API. It can be used
    for Web servers, web services based on SOAP and Rest API, application servers
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用于具有Java API的任何负载测试。它可以用于Web服务器、基于SOAP和Rest API的Web服务、应用服务器等。
- en: The Jython and Clojure languages supports in writing flexible, dynamic test
    scripts.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jython和Clojure语言支持编写灵活、动态的测试脚本。
- en: It manages client connections as well as cookies
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还管理客户端连接和cookie。
- en: JWalk
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**JWalk**'
- en: JWalk is one more unit testing tool for Java platform supporting the Lazy Systematic
    Unit testing paradigm. It has been developed by Anthony Simons. JWalk tests a
    single class and produces the test report by notions of 'lazy specification' and
    'systematic testing'. It is more favourable for agile development where no formal
    specification needs to be produced. It saves lots of time and efforts by constructing
    and presenting the automatic test cases.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWalk** 是一个为Java平台设计的单元测试工具，支持懒惰系统性单元测试范式。它由Anthony Simons开发。JWalk通过“懒惰规格”和“系统性测试”的概念来测试单个类并生成测试报告。它更适合敏捷开发，在这种开发中不需要产生正式的规格说明。通过构建和展示自动化测试用例，它能节省大量时间和精力。'
- en: 'Following are the features of JWalk:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是JWalk的特点：
- en: Systematic proposal of all probable test cases.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统性地提出所有可能的测试用例。
- en: No need to confirm the sub set of the test out come by tester.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试人员无需确认测试结果的子集。
- en: Can predict test outcomes.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以预测测试结果。
- en: Generates new test can if the class has been modified.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类被修改，它会生成新的测试用例。
- en: Suits for TDD for extreme programming in software development.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于软件开发中的极限编程的TDD。
- en: PowerMock
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**PowerMock**'
- en: PowerMock is open source created as an extension of the EasyMock and Mokito
    frameworks by adding few methods and annotations. It facilitates creation mock
    objects of the implementations from Java code. Sometimes the architecture of the
    application is design in such a way that it uses final classes, private methods
    or static methods to design the classes. Such methods or classes cannot be tested
    as their mocks can't be created. The developer has the choice to choose between
    a good design or testability. The PowerMock facilitates the mock creation of static
    methods and final classes by using custom classloader and bytecode manipulation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**PowerMock** 是一个开源项目，作为EasyMock和Mokito框架的扩展，通过添加一些方法和注解来实现。它允许从Java代码中创建模拟对象的实现。有时应用程序的架构是这样设计的，它使用最终类、私有方法或静态方法来设计类。这些方法或类无法测试，因为无法创建它们的模拟对象。开发者可以选择良好的设计或可测试性。PowerMock通过使用自定义类加载器和字节码操作，使静态方法和最终类可以被模拟。'
- en: TestNG
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**TestNG**'
- en: TestNG a powerful testing framework inspired by JUnit and NUnit testing useful
    unit testing, functional testing, integration testing. It facilitates a parameterised
    testing which is not possible by JUnit. It is empowered with many useful annotations
    like before and after )every test method(@BeforeMethod, @AfterMethod) and before
    and after class(@BeforeClass, @AfterClass) to carry out pre or post data processing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: TestNG是一个受JUnit和NUnit测试启发的强大测试框架，适用于单元测试、功能测试和集成测试。它支持参数化测试，这是JUnit不可能实现的。它配备了诸如每个测试方法（@BeforeMethod,
    @AfterMethod）和每个类（@BeforeClass, @AfterClass）之前和之后的数据预处理等许多有用注解。
- en: 'Following are the features of TestNG:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 是TestNG的功能：
- en: Easy testcase writing
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于编写测试用例
- en: It can generate HTML report
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以生成HTML报告
- en: It can generate logs
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以生成日志
- en: Good integration test support
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的集成测试支持
- en: Arquillian Framework
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arquillian Framework
- en: 'Arquillian is a testing framework for Java based applications. The framework
    facilitates the developers to deploy the application in the runtime environment
    to execute the test cases using JUnit and TestNG. The management of the runtime
    environment from within the test is made possible as Arquillian manages the following
    things in management of test the life cycle:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian是一个针对Java应用程序的测试框架。该框架使开发人员能够在运行时环境部署应用程序，以使用JUnit和TestNG执行测试用例。由于Arquillian管理以下测试生命周期管理事物，因此可以在测试内部管理运行时环境：
- en: It can manages more than one containers
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以管理多个容器
- en: It bundles the classes, resources and the test cases using ShrinkWrap
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用ShrinkWrap捆绑类、资源和测试用例
- en: It deploys the archive to the container
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将归档部署到容器中
- en: Executes the test case inside the container
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内执行测试用例
- en: Returns the result to the test runner
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果返回给测试运行器
- en: The ShrinkWrap
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ShrinkWrap
- en: The framework comprises of three major components,
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架由三个主要组件组成，
- en: Test Runners
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试运行器
- en: To execute the test case JUnit or TestNG uses Arquillian test runner. This facilitates
    the use of component model in the test case. It also manages the container life
    cycle and dependency injections which make the model available to use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试用例时，JUnit或TestNG使用Arquillian测试运行器。这使得在测试用例中使用组件模型成为可能。它还管理容器生命周期和依赖注入，使模型可供使用。
- en: Java Container
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Java容器
- en: Java containers are the major components of the test environment. Arquillian
    tests can be executed in any compatible container. The Arquillian selects the
    container to choose which container adapter is made available in the classpath.
    These container adapters controls and helps in communicating with the containers.
    Arquillian test cases even can be executed without JVM based container also. We
    can use the annotation **@RunsClientto** execute the test cases outside of the
    Java Container.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java容器是测试环境的主要组件。Arquillian测试可以在任何兼容的容器中执行。Arquillian选择容器以确定在类路径中可用的哪个容器适配器。这些容器适配器控制并帮助与容器通信。Arquillian测试用例甚至可以在没有基于JVM的容器的情况下执行。我们可以使用**@RunsClientto**注解在Java容器外部执行测试用例。
- en: Integration of test cases into the Java container
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将测试用例集成到Java容器中
- en: The framework has external dependency to use known as ShrinkWrap. It helps in
    defining the deployments and descriptors of the application to be loaded in the
    Java Container. The test cases run against these descriptors. Shrinkwrap supports
    to generate dynamic Java archive files of type JAR, WAR and EAR. It also can be
    used for addition of deployment descriptor as well as creation of the DD programmatically.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架使用名为ShrinkWrap的外部依赖。它有助于定义要加载到Java容器中的应用程序的部署和描述符。测试用例针对这些描述符运行。Shrinkwrap支持生成动态Java归档文件，类型为JAR、WAR和EAR。它还可以用于添加部署描述符以及创建DD程序化。
- en: Arquillian can be suits to use in the following scenarios,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian可以在以下场景中使用，
- en: The part of your application to test needs deployment of application within
    embedded server
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您要测试的应用程序部分需要在内嵌服务器中部署
- en: The test to be executed on hourly, after certain interval or when someone commits
    the code
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应在每小时、一定时间间隔后或有人提交代码时执行
- en: Automation of acceptance test of the application through external tools
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过外部工具自动化应用程序的验收测试
- en: JUnit
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JUnit
- en: JUnit is the most popular open source framework for Java in test driven development.
    The JUnit helps in unit testing of the component. It also widely support for tools
    such as ANT, Maven, Eclipse IDE. The unit test class is an ordinary class like
    any other classes with a major difference of use of **@Test** annotation. The
    @Test annotation lets the JUnit test runner that this annotated method needs to
    be executed to perform testing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是用于Java测试驱动开发的最受欢迎的开源框架。JUnit有助于对组件进行单元测试。它还广泛支持诸如ANT、Maven、Eclipse IDE等工具。单元测试类是像其他任何类一样的普通类，主要区别在于使用**@Test**注解。@Test注解让JUnit测试运行器知道需要执行这个注解的方法来进行测试。
- en: The class org.junit.Assertprovides a series of static assertXXX() methods which
    performs the testing by comparing the actual output to the assumed output of the
    method under test. If the comparison of the test returns normally, it indicates
    the test has passed. But if the comparison fails the execution stops indicating
    test has failed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: org.junit.Assert类提供了一系列静态的assertXXX()方法，这些方法通过比较被测试方法的预期输出和实际输出来进行测试。如果测试的比较返回正常，表示测试通过了。但是，如果比较失败，执行停止，表示测试失败。
- en: The unit test class normally called as Unit Test Case. The Test case can have
    multiple methods which will be executed one after another in the order in which
    they have written. The JUnit facilitates setting up the test data for a public
    unit under testing and does the testing against it. The initialization of data
    can be done in setUp() method or in the method which has been annotated by @Before
    annotation. By default it uses JUnit runner to run the test case. But, it has
    Suite, Parameterised, and Categories as few more built in runners. Along with
    these runner JUnit also support third party runners like SpringJUnit4ClassRunner,
    MokitoJUnitRunner, HierarchicalContextRunner.It also facilitates the use of @RunWithwhich
    facilitates using the custom runners.We will discuss in depth about the annotation
    along with Spring testing framework shortly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试类通常被称为单元测试用例。测试用例可以有多个方法，这些方法将按照编写顺序一个接一个地执行。JUnit为公共单元测试提供设置测试数据的功能，并针对它进行测试。数据的初始化可以在`setUp()`方法中完成，或者在用@Before注解标记的方法中完成。默认情况下，它使用JUnit运行器来运行测试用例。但它还有Suite、Parameterised和Categories等几个内置的运行器。除了这些运行器之外，JUnit还支持第三方运行器，如SpringJUnit4ClassRunner、MokitoJUnitRunner、HierarchicalContextRunner。它还支持使用@RunWith注解，以便使用自定义运行器。我们将在稍后详细讨论这个注解以及Spring测试框架。
- en: Following are few assertion methods which facilitates the testing using comparison,
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些通过比较进行测试的断言方法，
- en: 'assertEquals : The method tests the equality of two objects with the help of
    equals() method.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'assertEquals : 这个方法通过调用equals()方法来测试两个对象的相等性。'
- en: 'assertTrue and assertFalse : It is used to test boolean values against true
    or false conditions.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'assertTrue 和 assertFalse : 它用于将布尔值与true或false条件进行比较。'
- en: 'assertNull and assetNotNull : The method tests the value to be either null
    or not null.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'assertNull 和 assetNotNull : 这个方法测试值的null或非null。'
- en: 'assertSame and assertNotSame : It is used to test the two references passed
    as an argument point to the same object or not.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'assertSame 和 assertNotSame : 它用于测试传递给它的两个引用是否指向同一个对象。'
- en: 'assertArrayEquals : It is used to test the two array contains equal elements
    and each element from one of the array is equal to the element from other array
    with the same index.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'assertArrayEquals : 它用于测试两个数组是否包含相等的元素，并且数组中每个元素与另一个数组中相同索引的元素相等。'
- en: 'assertThat : It tests the object matches to an object of org.harmcrest.Matcher
    or not.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'assertThat : 它用于测试对象是否与org.hamcrest.Matcher中的对象匹配。'
- en: Pase I Unit testingDAO Unit testing by JUnit
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一阶段 单元测试DAO 使用JUnit进行单元测试
- en: '* * *'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Now, it's time to write the actual test case. We will start unit testing DAO
    layer. Following are general steps to write an annotation based test case,
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是编写实际测试用例的时候了。我们将从单元测试DAO层开始。以下是为编写基于注解的测试用例而遵循的一般步骤，
- en: Create a class having the name of the class under test prefixed by 'Test'.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类，该类的名称以'Test'为前缀，紧跟被测试类的名称。
- en: Write `setUp()` and `testDown()` methods for initializing the data we needed
    and releasing the resourced used by us respectively.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为初始化我们所需的数据和释放我们使用的资源分别编写`setUp()`和`testDown()`方法。
- en: The methods where test will be conducted name them as name of the method under
    test prefixed by 'test'.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行测试的方法将它们的名称命名为被测试方法名称前加上'test'。
- en: '`4\.` The method which the test runner should recognized need to be annotated
    by `@Test`'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4.` 测试运行器应该认识的方法的需用`@Test`注解标记。'
- en: Use `assertXXX()` methods as per the data under test to compare the values.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`assertXXX()`方法根据测试的数据比较值。
- en: Let's write the tests for the DAO layer which we developed in third chapter.
    We will use Ch03_JdbcTemplates as base project. You can create the new project
    or can use Ch03_JdbcTemplates by adding only test package. Let's follow the steps.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为第三章中开发的DAO层编写测试。我们将使用Ch03_JdbcTemplates作为基础项目。您可以创建一个新的项目，或者通过仅添加测试包来使用Ch03_JdbcTemplates。让我们按照以下步骤操作：
- en: Create base application.
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基本应用程序。
- en: Create Ch07_JdbcTemplates_Testing as Java project.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch07_JdbcTemplates_Testing作为Java项目。
- en: Add all the required jars for spring core, spring jdbc and JDBC which we already
    added for Ch03_JdbcTemapltes project.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Spring核心、Spring JDBC和JDBC添加所有必需的jar文件，这些文件我们已经为Ch03_JdbcTemplates项目添加了。
- en: Copy com.packt.ch03.beans and com.packt.ch03.dao package from base project.
    We will only carry out testing for BookDAO_JdbcTemplate class.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基础项目中复制com.packt.ch03.beans和com.packt.ch03.dao包。我们只对BookDAO_JdbcTemplate类进行测试。
- en: Copy connection_new.xml in classpath
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`connection_new.xml`复制到类路径中
- en: Performing testing
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行测试
- en: Create com.packt.ch07.tests package
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`com.packt.ch07.tests`包
- en: 'Use JUnit test case template from Eclipse IDE as:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Eclipse IDE中的JUnit测试用例模板：
- en: Enter the name of test case as TestBookDAO_JdbcTemplate
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入测试用例的名称TestBookDAO_JdbcTemplate
- en: Select checkboxes for setUp and teardown for initializing and releasing the
    test case components.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为初始化和释放测试用例组件选择setUp和teardown复选框。
- en: Click on browse button and select BookDAO_JdbcTemplate as class under test
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击浏览按钮，选择BookDAO_JdbcTemplate作为测试类。
- en: Click on next button
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步按钮
- en: In the Test methods Dialogue box select all the methods from BookDAO_JdbcTemplate
    class.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试方法对话框中选择BookDAO_JdbcTemplate类中的所有方法。
- en: Click on finish.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。
- en: A Dialogue will appear asking to add JUnit4 on build path. Click on Ok button.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个对话框，询问是否在构建路径上添加JUnit4。点击确定按钮。
- en: 'The steps can be summarized as shown in the figure below:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了这些步骤：
- en: '![](img/image_07_001.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_001.png)'
- en: 'After Clicking Next Button you will get the next dialogue:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步按钮后，您将看到下一个对话框：
- en: '![](img/image_07_002.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_002.png)'
- en: In the test case declare a data member as `BookDAO_Jdb`c Template.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试用例中声明一个数据成员作为`BookDAO_JdbcTemplate`。
- en: Update the `setUp()` method to initialize the data member of test case using
    ApplicationContext container.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`setUp()`方法，使用ApplicationContext容器初始化测试用例的数据成员。
- en: Update `tearDown()` to release the resources.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`tearDown()`以释放资源。
- en: Update `testAddBook()` as,
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`testAddBook()`如下：
- en: Create an object of type Book with some values, make sure the value of the ISBN
    is not available in the Book table.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Book类型的对象，并确保ISBN的值在Book表中不可用。
- en: Invoke `addBook()` from `BookDAO_JdbcTemplate` class
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`BookDAO_JdbcTemplate`类调用`addBook()`。
- en: 'Test the result using `assertEquals()`method as shown in the code below:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码中的`assertEquals()`方法测试结果：
- en: '[PRE0]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Select the `testAddBook()` method and run it as JUnit test.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`testAddBook()`方法并将其作为JUnit测试运行。
- en: 'The JUnit window will be shown with a green mark indicating the code has passed
    the unit test as shown in figure below:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下图表所示，JUnit窗口将显示一个绿色标记，表示代码已通过单元测试：
- en: '![](img/image_07_003.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_003.png)'
- en: The ISBN is a Primary Key in Book table, if you rerun the same `testAddBook()`
    it will fail showing red color instead of green. Still it proves out code is working
    as per logic. If one of the test conditions is failed the test case execution
    stops by showing AssertionError.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Book表中，ISBN是一个主键，如果你重新运行相同的`testAddBook()`，它将显示红色而不是绿色，从而失败。尽管如此，这证明了代码是根据逻辑工作的。如果测试条件之一失败，测试用例执行将停止，并显示断言错误。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Try to write test condition which will always pass.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个总是通过的测试条件。
- en: 'Let''s add `TestAddBook_Negative ()`to test what happens if we try to add book
    with same ISBN. Don''t forget to annotate the method by `@Test`. The code will
    be as shown below:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`TestAddBook_Negative ()`以测试如果我们尝试添加具有相同ISBN的书籍会发生什么。不要忘记通过`@Test`注解 annotate
    the method。代码将如下所示：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On adding duplicate key, the code will throwDuplicateKeyException.In the @Test
    annotation we had added `DuplicateKey`Exception as expected result indicating
    to the JUnit Runner as it's expected behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加重复键，代码将抛出DuplicateKeyException。在`@Test`注解中，我们添加了`DuplicateKey`Exception作为期望的结果，指示JUnit运行器这是期望的行为。
- en: 'In the same way let''s add the code to other test methods as shown below:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，让我们将以下代码添加到其他测试方法中：
- en: '[PRE2]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above code constructsfew objects such `as BookDAO_JdbcTemplate`, which have
    constructed using Spring container. In the code we consumed an object of `BookDAO_JdbcTemplate`
    which we obtained in `setUp()` using Spring Container.Can't we have better choice
    instead of doing it manually? Yes, we can do it by using custom runner provided
    by Spring. The SprinJUnit4ClassRunner is a custom runner which is an extension
    of class JUnit4Runner provides a facility to use Spring TestContext Framework
    implicitly taking out the complexity out.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码构建了几个对象，如 `BookDAO_JdbcTemplate`，这些对象是使用 Spring 容器构建的。在代码中，我们使用了在 `setUp()`
    中通过 Spring 容器获得的 `BookDAO_JdbcTemplate` 对象。我们不能手动完成，而有更好的选择吗？是的，我们可以通过使用 Spring
    提供的自定义运行器来实现。SprinJUnit4ClassRunner 是一个自定义运行器，它是 JUnit4Runner 类的扩展，提供了一个使用 Spring
    TestContext Framework 的设施，消除了复杂性。
- en: Spring TestContext Framework
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring TestContext Framework
- en: Spring empowers developers with rich Spring TestContext Framework which provides
    a strong support for unit as well as integration testing. It supports both API
    based and annotation based test case creation. The framework supports strongly
    JUnit and TestNG as testing frameworks. The TestContext encapsulates the spring
    context in which the test cases will be executed. It can also be used to load
    ApplicationContext, if requested. The TestContextManager is the main component
    which manages TestContext. The event publication is done by the TestContextManager
    and the TestExecutionListener provides the action to be taken for a published
    event.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 为开发者提供了丰富的 Spring TestContext Framework，该框架为单元测试和集成测试提供了强大的支持。它支持基于 API
    的和基于注解的测试用例创建。该框架强烈支持 JUnit 和 TestNG 作为测试框架。TestContext 封装了将执行测试用例的 spring 上下文。如果需要，它还可以用于加载
    ApplicationContext。TestContextManager 是管理 TestContext 的主要组件。TestContextManager
    通过事件发布，而 TestExecutionListener 为发布的事件提供采取的动作。
- en: The class level annotation @RunWith instructs the JUnit to invoke the class
    it is referencing to run the test cases rather than using the built in runner.
    The Spring provided SpringJUnit4ClassRunner facilitates the JUnit to use the functionalities
    provided by Spring Test Framework using TestContextManager. The org.springframework.test.context
    package provides annotation driven support of the testing. Following annotations
    are used to initialize the context,
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类级注解 @RunWith 指示 JUnit 调用其引用的类来运行测试用例，而不是使用内置的运行器。Spring 提供的 SpringJUnit4ClassRunner
    使 JUnit 能够使用 TestContextManager 提供的 Spring 测试框架功能。org.springframework.test.context
    包提供了测试的注解驱动支持。以下注解用于初始化上下文，
- en: '@ContextConfiguration'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ContextConfiguration'
- en: 'The class level annotation loads the definition to build the Spring container.The
    context is built either by referring a class or XML files. Let''s discuss them
    one by one:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类级注解加载了构建 Spring 容器的定义。上下文是通过引用一个类或 XML 文件来构建的。让我们逐一讨论它们：
- en: 'Using single XML file:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个 XML 文件：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using configuration class:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置类：
- en: '[PRE4]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using configuration class as well as XML file:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置类以及 XML 文件：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using context initializer:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文初始化器：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '@WebAppConfiguration'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@WebAppConfiguration'
- en: 'The class level annotation is used to instruct how to load the ApplicationContext
    and used by the WebApplicationContext(WAC) from default location as "file:/src/main/webapp".
    The following snippet shows loading of resource to initialize WebApplicationContext
    to be used for testing:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类级注解用于指示如何加载 ApplicationContext，并由默认位置的 WebApplicationContext（WAC）使用，文件路径为 "file:/src/main/webapp"。以下代码段显示了加载资源以初始化用于测试的
    WebApplicationContext：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Earlier developed test case was using explicit Spring Context initialization.
    In this demo we will discuss how to use SprinJUnit4ClassRunner and @RunWith.We
    will use Ch07_JdbcTemplates_Testing project and test methods of BookDAO_JdbcTemplates
    using following steps,
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之前开发的测试用例使用显式初始化 Spring 上下文。在这个示例中，我们将讨论如何使用 SprinJUnit4ClassRunner 和 @RunWith。我们将使用
    Ch07_JdbcTemplates_Testing 项目和测试 BookDAO_JdbcTemplates 的测试方法，步骤如下，
- en: Download spring-test-5.0.0.M1.jar file to use Spring testing APIs.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 spring-test-5.0.0.M1.jar 文件以使用 Spring 测试 API。
- en: Create SpringRunner_TestBookDAO_JdbcTemplate in com.packt.ch07.tests package
    as as a JUnit Test case. Select BookDAO_JdbcTemplate as class under test and all
    of its methods under testing.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.packt.ch07.tests 包中创建一个名为 SpringRunner_TestBookDAO_JdbcTemplate 的 JUnit
    测试用例。选择 BookDAO_JdbcTemplate 作为测试类和其所有测试方法。
- en: Annotate the class by @RunWith and @ContextConfiguration annotation as shown
    in the code below.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码中的 @RunWith 和 @ContextConfiguration 注解注释类。
- en: 'Add a data member of type BookDAO and apply the annotation for autowiring as
    shown in the code below:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中添加一个类型为BookDAO的数据成员，并应用自动装配注解，如下所示：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `@RunWith` annotation accepts the `SpringJUnit4ClassRunner`. The `@ContextConfiguration`
    accepts the file to initialize the container. Also we use annotation based auto
    wiring for BookDAO, instance instead of using Spring API in `setUp()` method as
    we did in earlier demo.The code for testing in `testAddBook()` remains same as
    we are not changing the logic.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@RunWith`注解接受`SpringJUnit4ClassRunner`。`@ContextConfiguration`接受文件以初始化容器。此外，我们使用基于注解的自动装配来测试BookDAO实例，而不是像早期演示中那样在`setUp()`方法中使用Spring
    API。`testAddBook()`中的测试代码保持不变，因为我们没有更改逻辑。'
- en: Execute it as JUnit test and if your ISBN is not already available in the Book
    table the test will pass.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其作为JUnit测试执行，如果您的ISBN尚未在书籍表中可用，则测试将通过。
- en: In the above code we did the testing against the actual database, which makes
    it slower and it always will be. These tests are not isolated from the environment
    and they will always be dependent upon the external dependencies, in our case
    on the database. The unit test casesalways arewritten based on few assumptions
    according to the real time values. To understand the problem and complexity while
    dealing with the real time values.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码我们对实际数据库进行了测试，这使得它变得更慢，并且始终如此。这些测试与环境不是孤立的，并且它们总是依赖于外部依赖，在我们的案例中是数据库。单元测试案例总是根据实时值基于几个假设来编写的，以便理解处理实时值时的问题和复杂性。
- en: 'We have a function for updating the book details. To update the book the function
    is having two arguments, first to accept ISBN and second to update the price of
    the book with specified ISBN as specified below:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个更新书籍详情的函数。要更新书籍，该函数有两个参数，第一个是接受ISBN，第二个是使用指定的ISBN更新书籍的价格，如下所示：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We wrote the test case to find whether the book is updated or not as shown
    below:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了以下测试用例，以确定书籍是否已更新：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We assumed ISBN exists in the database to update the book details.So, the test
    case executed successfully. But, what if in between someone changes the ISBN or
    someone deletes the row with that ISBN? The test case written by us will fail.The
    problem is not in our test case, the only problem is we are assuming the ISBN
    exists.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设ISBN存在于数据库中以更新书籍详情。所以，测试用例执行成功。但是，如果在其中有人更改了ISBN，或者有人删除了具有该ISBN的行怎么办？我们编写的测试用例将失败。问题不在我们的测试用例中，唯一的问题是我们假设ISBN存在。
- en: Another thing is, sometimes the real time environment may not be accessible.
    The controller layer testing is highly dependent upon request and response object.
    These request and response will be initialized by the container once the application
    is deployed to the server. Either the server may not be available for deployment
    or the layers on which the controller coding isdependent has not be developed
    yet. All such problems made testing more and more difficult. These problems will
    easily be solved using Mock object testing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，有时实时环境可能无法访问。控制器层测试高度依赖于请求和响应对象。这些请求和响应将在应用程序部署到服务器后由容器初始化。要么服务器不适合部署，要么控制器编码所依赖的层尚未开发。所有这些问题使得测试越来越困难。这些问题使用模拟对象测试可以轻松解决。
- en: Mock Testing
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟测试
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: Mock testing deals in testing with fake objects, these are not real objects.
    These fake objects returns the data required to conduct the test. It is helpful
    to save lots of work while carrying out actual object. The fake objects are usually
    called as 'Mock object'. The mock objects are used to replace the actual objects
    to avoid unnecessary complications and dependencies like database connections.
    These mock objects are isolated from the environment leading to the faster execution.
    The mock objects are created by setting up the data and then specifying the behavior
    of the method. The behavior includes the data to be returned on a particular scenario.
    Mockito is one of the famous testing frameworks usingthe mock objects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟测试涉及使用假对象进行测试，这些对象不是真实的。这些假对象返回进行测试所需的数据。在实际对象操作中可以节省大量工作。这些假对象通常被称为“模拟对象”。模拟对象用于替换实际对象，以避免不必要的复杂性和依赖，如数据库连接。这些模拟对象与环境隔离，导致执行速度更快。通过设置数据然后指定方法的的行为来创建模拟对象。行为包括在特定场景下返回的数据。Mockito是使用模拟对象的一个著名的测试框架。
- en: Mockito
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mockito
- en: Mockito is an open source testing framework for Java base applications which
    has released under the MIT Licence. It allows the developers to create mock objects
    for **Test Driven Development**(**TDD**) which are isolated from the framework.
    It uses Java Reflection API for creating mock objects and has simple APIs for
    writing test cases. It also facilitates the developers to have a check on the
    order in which the methods are getting invoked.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito是一个开源的Java基础应用程序测试框架，发布在MIT许可证下。它允许开发人员为**测试驱动开发**（**TDD**）创建模拟对象，使其与框架隔离。它使用Java反射API来创建模拟对象，并具有编写测试用例的简单API。它还允许开发人员检查方法被调用的顺序。
- en: Mockito has static `mock()` method, which can be used for creating mock objects.
    It also facilitates creation of mock objects by using @Mock annotation. The `methodMockitoAnnotations.initMocks(this`)
    instructs to initialize all the annotated fields which has annotated by @Mock.
    If we forget to do sothe objects would be null. The @RunWith(MokitoJUnitRunner.class)
    also does the same. The MockitoJUnitRunner is the custom runner which is used
    by the JUnit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito有一个静态的`mock()`方法，可以用来创建模拟对象。它还通过使用@Mock注解来创建模拟对象。`methodMockitoAnnotations.initMocks(this)`指示初始化所有由@Mock注解的注解字段。如果我们忘记这样做，对象将是null。`@RunWith(MokitoJUnitRunner.class)`也做同样的事情。MockitoJUnitRunner是JUnit使用的自定义运行器。
- en: Mockito works on the principle of returning predefined values when a function
    is called,**Mokito**,when() method facilitates to provide the information about
    which method will be called and Mokito,thenXXX() is used to specify what values
    the function will return.Following are the methods which is used to specify what
    values to be returned,
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito的工作原理是在调用函数时返回预定义的值，**Mokito**，when()方法提供了关于将调用哪个方法的信息，Mokito，thenXXX()用于指定函数将返回的值。以下是用以来指定要返回的值的方法，
- en: thenReturn - used to return a specified value
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenReturn` - 用于返回一个指定的值'
- en: thenThrow- throws specified exception
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenThrow`- 抛出指定的异常'
- en: then and thenAnswer returns an answer by the user defined code
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then`和`thenAnswer`通过用户定义的代码返回一个答案'
- en: thenCallRealMethod- gives a call to the real method
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenCallRealMethod`- 调用真实的方法'
- en: Mock testing is simple three step process as,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟测试是一个简单的三个步骤的过程，如下所示，
- en: Initialization the dependencies byMock object for the class under test
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过模拟对象初始化被测试类的依赖项
- en: Execute the operation to test
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试操作
- en: Write test condition to check whether the operation gives expected result or
    not
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试条件以检查操作是否给出了预期的结果
- en: Let's use Mockito to create mock object of the BookDAO and use it in testing
    step by step as,
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步使用Mockito创建`BookDAO`的模拟对象并在测试步骤中使用它，
- en: Download mokito-all-1.9.5.jar and add it to the In Ch07_JdbeTemplate_Testing
    project which we use as our base project.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载mokito-all-1.9.5.jar并将其添加到我们用作基础项目的Ch07_JdbeTemplate_Testing项目中。
- en: Create `Spring_Mokito_TestBookDAO_JdbcTemplate` as Junit test case in com.packt.ch07.unit_tests
    package.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch07.unit_tests包中创建`Spring_Mokito_TestBookDAO_JdbcTemplate`作为一个Junit测试用例。
- en: Add a data member of type `BookDAO` and annotate it with @Mock annotation.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类型为`BookDAO`的数据成员并使用@Mock注解标注它。
- en: 'To initialize the mock object invoke `initiMoks()` method of the Mockito in
    `setup()` method as shown below:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup()`方法中调用Mockito的`initMocks()`方法来初始化模拟对象，如下所示：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now add code to test addBook() where we will first define the values
    which we are expecting the function under test to return. Then we will use assertXXX()
    methods to test the behavior as shown below:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加代码来测试`addBook()`函数，我们首先定义期望测试函数返回的值。然后我们使用`assertXXX()`方法来测试以下行为：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Execute the test case and test the behavior. We will get all test case executed
    successfully.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试用例并测试行为。我们将得到所有测试用例成功执行。
- en: 'Let''s add the code for other findAllBooks(String) and deleteBook()methods
    as well:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来让我们也添加`findAllBooks(String)`和`deleteBook()`方法的其他代码：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous demo, we discussed about unit testing of DAO layer in both real
    time environment as well as using mock objects. Let's now test the controller
    using Spring MVC test framework in the following sections.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们讨论了在实时环境以及在使用模拟对象时DAO层的单元测试。现在让我们在接下来的部分使用Spring MVC测试框架来测试控制器。
- en: Spring MVC controller testing using Spring TestContext framework
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Spring TestContext框架进行Spring MVC控制器测试
- en: 'The Mockito facilitates the developers to create mock objects of the DAO layer
    in the earlier discussion. We were not having DAO object but even without it the
    testing was made possible. The Spring MVC layer testing without mock objects is
    not possible as they are highly dependent upon the request and response object
    which gets initialized by the container. The spring-test module supports creation
    of mock object for Servlet API which makes testing of the web component without
    the actual container deployment. The following table shows the list of packages
    which has been provided by Spring TestContext framework for mock creation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito为开发人员提供了创建DAO层模拟对象的功能。在前面的讨论中，我们没有DAO对象，但即使没有它，测试也是可能的。没有模拟对象，Spring
    MVC层测试是不可能的，因为它们高度依赖于初始化由容器完成的请求和响应对象。spring-test模块支持创建Servlet API的模拟对象，使在不实际部署容器的情况下测试Web组件成为可能。以下表格显示了由Spring
    TestContext框架提供的用于创建模拟对象包列表：
- en: '| **Package name** | **Provides mock implemenetation of** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **包名** | **提供模拟实现** |'
- en: '| org.springframework.mock.env | Environment and PropertySource |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| org.springframework.mock.env | 环境和属性源 |'
- en: '| org.springframework.mock.jndi | JNDI SPI |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| org.springframework.mock.jndi | JNDI SPI |'
- en: '| org.springframework.mock.web | Servlet API |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| org.springframework.mock.web | Servlet API |'
- en: '| org.springframework.mock.portlet | Portlet API |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| org.springframework.mock.portlet | Portlet API |'
- en: 'The org.springframework.mock.web provides the MockHttpServletRequest ,MockHttpServletResponse,
    MockHttpSessionas mock objects for HttpServeltRequest, HttpServletResponse and
    HttpSession for use. It also provides the class ModelAndViewAssert to test the
    ModelAndView objects from Spring MVC framework. Let''s test our SearchBookController
    step by step as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: org.springframework.mock.web提供了MockHttpServletRequest，MockHttpServletResponse，MockHttpSession作为HttpServletRequest，HttpServletResponse和HttpSession的模拟对象，供使用。它还提供了ModelAndViewAssert类，以测试Spring
    MVC框架中的ModelAndView对象。让我们逐步测试我们的SearchBookController如下：
- en: Add spring-test.jar to the `ReadMyBooks` application which we will use for testing.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将spring-test.jar添加到`ReadMyBooks`应用程序中，我们将在测试中使用它。
- en: Create `com.packt.ch06.controllers.test_controllers` package to add test cases
    for the controllers.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`com.packt.ch06.controllers.test_controllers`包，以添加控制器的测试用例。
- en: Create `TestSearchBookController` as JUnit case in the package created in earlier
    step.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前步骤创建的包中创建`TestSearchBookController`作为JUnit测试用例。
- en: Annotate it by `@WebAppConfiguration`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@WebAppConfiguration`进行注解。
- en: 'Declare data members of type SearchBookController and autowire it as shown
    in the code below:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明类型为SearchBookController的数据成员并如代码所示自动注入：
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s test add testSearchBookByAuthor() to test searchBookByAuthor() method.
    The method accepts author''s name entered by the user in the web form and returns
    list of the books written by the author. The code will be written as:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试add testSearchBookByAuthor()以测试searchBookByAuthor()方法。该方法接受用户在Web表单中输入的作者名称，并返回该作者所写的书籍列表。代码将如下所示：
- en: Initialize the data required by the method under testing
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化测试方法所需的数据
- en: Invoke the method under test
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用测试方法
- en: Assert the values.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言值。
- en: 'The final code will be as shown below:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终代码将如下所示：
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are testing the name of the view 'display' which has been written from the
    controller method.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在测试名为'display'的视图名称，该视图是从控制器方法中编写出来的。
- en: 'The Spring facilitates ModelAndViewAssert which provides the method to test
    ModelAndView returned by the controller method as shown in the code below:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring提供了ModelAndViewAssert，提供了一个测试控制器方法返回的ModelAndView的方法，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Execute the test case, the green colour indicates the test case has passed.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试用例，绿色表示测试用例已通过。
- en: We successfully tests the SearchBookController which has easy coding without
    any form submission, form model attribute binding, form validation and many more.
    Such complex code testing becomes more complex with mock objects which we just
    handled.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们成功测试了SearchBookController，其具有无需任何表单提交、表单模型属性绑定、表单验证等简单编码。我们刚刚处理的这些复杂的代码测试变得更加复杂。
- en: Spring MockMvc
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Spring MockMvc
- en: 'Spring provides the MockMVC, as the main entry point which is empowered with
    methods to start with the server side testing. The implementation of the MockMVCBuilder
    interface will be used to create a MockMVC object. The MockMVCBuilders provides
    the following static methods which gives opportunity to get implementation of
    the MockMVCBuilder:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了MockMVC，作为主要的入口点，并配备了启动服务器端测试的方法。将使用MockMVCBuilder接口的实现来创建一个MockMVC对象。MockMVCBuilders提供了以下静态方法，可以获取MockMVCBuilder的实现：
- en: 'xmlConfigSetUp(String ...configLocation) - will be used when the application
    context is configured using XML configuration files as shown below:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xmlConfigSetUp(String ...configLocation) - 当使用XML配置文件来配置应用程序上下文时使用，如下所示：
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'annotationConfigSetUp(Class ... configClasses) - will be used when we are using
    Java class to configure the application context. The following code shows how
    to use the MyConfig.java as a configuration class:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: annotationConfigSetUp(Class ... configClasses) - 当使用Java类来配置应用程序上下文时使用。以下代码显示了如何使用MyConfig.java作为一个配置类：
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'standaloneSetUp(Object ... controllers) - will be used when developers configured
    the test controllers and its required MVC components. The following code shows
    using MyController for the configuration:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: standaloneSetUp(Object ... controllers) - 当开发者配置了测试控制器及其所需的MVC组件时使用。以下代码显示了使用MyController进行配置：
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'webApplicationContextSetUp(WebApplicationContext context) - will be used when
    the developers already had fully initialized WebApplicationContext instance. The
    following code shows how to use the method:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webApplicationContextSetUp(WebApplicationContext context) - 当开发者已经完全初始化WebApplicationContext实例时使用。以下代码显示了如何使用该方法：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: MockMvc has `perform()`method which accept the instance of RequestBuilder and
    returns the ResultActions. The `MockHttpServletRequestBuilderis` an implementation
    of RequestBuilderwho has methods to build the request by setting request parameters,
    session. The following table shows the methods which facilitates building the
    request,
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: MockMvc has `perform()` method which accepts the instance of RequestBuilder
    and returns the ResultActions. The `MockHttpServletRequestBuilder` is an implementation
    of RequestBuilder who has methods to build the request by setting request parameters,
    session. The following table shows the methods which facilitate building the request,
- en: '| **Method name** | **The data method description** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **Method name** | **The data method description** |'
- en: '| accept | Helps in setting the ''Accept'' header to the given media type |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| accept | 用于将“Accept”头设置为给定的媒体类型 |'
- en: '| buildRequest | Helps in building the MockHttpServletRequest |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| buildRequest | 用于构建MockHttpServletRequest |'
- en: '| createServletRequest | Based on the ServletContext, the method creates a
    new MockHttpServletRequest |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| createServletRequest | 根据ServletContext，该方法创建一个新的MockHttpServletRequest |'
- en: '| Param | Helps in setting request parameter to the MockHttpServletRequest.
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| Param | 用于将请求参数设置到MockHttpServletRequest。 |'
- en: '| principal | Helps in setting the principal of the request. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| principal | 用于设置请求的主体。 |'
- en: '| locale . | Helps in setting the locale of the request. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| locale . | 用于设置请求的区域设置。 |'
- en: '| requestAttr | Helps in setting a request attribute. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| requestAttr | 用于设置请求属性。 |'
- en: '| Session, sessionAttr, sessionAttrs | Helps in setting session or session
    attributes to the request |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| Session, sessionAttr, sessionAttrs | 用于设置会话或会话属性到请求 |'
- en: '| characterEncoding | Helps in setting character encoding to the request |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| characterEncoding | 用于将字符编码设置为请求 |'
- en: '| content and contentType | Helps in setting the body and content type header
    of request |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| content and contentType | 用于设置请求的正文和内容类型头。 |'
- en: '| header and headers | Helps in adding one or all headers to the request. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| header and headers | 用于向请求添加一个或所有头信息。 |'
- en: '| contextPath | Helps in specifying the part of requestURI which represents
    the context path |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| contextPath | 用于指定表示请求URI的上下文路径部分 |'
- en: '| Cookie | Helps in adding cookies to the request |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| Cookie | 用于向请求添加Cookie。 |'
- en: '| flashAttr | Helps in setting input flash attribute. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| flashAttr | 用于设置输入的闪存属性。 |'
- en: '| pathInfo | Helps to specify the part of the requestURI that represents the
    pathInfo. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| pathInfo | 用于指定表示请求URI的pathInfo部分。 |'
- en: '| Secure | Helps in setting the secure property of the ServletRequest such
    as HTTPS. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| Secure | 用于设置ServletRequest的安全属性，如HTTPS。 |'
- en: '| servletPath | Helps to specify the part of the requestURIwhich represents
    the path to which the Servlet is mapped. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| servletPath | 用于指定表示Servlet映射路径的请求URI部分。 |'
- en: 'The `perfom()` method of MockMvc return the ResultActions facilitates the assertions
    of the expected result by following methods:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `perfom()` method of MockMvc returns the ResultActions, which facilitates
    the assertions of the expected result by following methods:'
- en: '| **Method name** | **Description** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **Method name** | **Description** |'
- en: '| andDo | It takes a general action. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| andDo | 它接受一个通用操作。 |'
- en: '| andExpect | It takes the expected action |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| andExpect | 它接受预期的操作 |'
- en: '| annReturn | It return the result of the expected request which can be directly
    accessed. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| annReturn | 它返回预期请求的结果，可以直接访问。 |'
- en: 'Let''s use MockMvc to test AddBookControllerstep by step:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s use MockMvc to test AddBookController step by step:'
- en: Add TestAddBookController as JUnit test case in `com.packt.ch06.controllers.test_controllers
    package`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Add TestAddBookController as JUnit test case in `com.packt.ch06.controllers.test_controllers
    package`.
- en: Annotate the class by `@WebAppConfiguration` , `@ContextConfiguration` and `@RunWith`
    as we did in earlier code.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像早期代码中一样，用`@WebAppConfiguration`、`@ContextConfiguration`和`@RunWith`注解类。
- en: Add the data members of type WebApplicationContextand `AddBookController`. Annotate
    both by `@Autowired`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加类型为WebApplicationContext和`AddBookController`的数据成员，并用`@Autowired`注解两者。
- en: 'Add data member of type MockMvc and initialize it in setup() method and release
    memory in teardown() method as shown below:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加类型为MockMvc的数据成员，并在setup()方法中初始化它，如以下所示释放内存：
- en: '[PRE21]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lets add the code to test the addBook() method in testAddBook() as:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们在testAddBook()中添加测试addBook()方法的代码：
- en: 'Initialize the request by setting values of:'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置以下值初始化请求：
- en: model attribute 'book' with default values
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型属性'book'使用默认值
- en: content-type as the form submission results in method invocation
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表单提交结果设置为内容类型
- en: URI on which the method will be invoked
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法将被调用的URI
- en: request parameters of the form
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单的请求参数：
- en: test the result by checking,
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查测试结果：
- en: view name
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图名称
- en: model attribute name
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型属性名称
- en: use andDo() to print the result of test actions on cosole
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用andDo()在控制台上打印测试动作的结果
- en: 'The code for testAddBook() method is as shown below:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 测试AddBook()方法的代码如下：
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The matching of the expected behavior in the andExpect( )is facilitated by ResultMatcher.
    The MockMvcResultMatcheris an implementation of the ResultMatcherprovides the
    methods to match the view, cookie,header, model,request and many other parameters.
    The andDo() method prints the MvcResult to the OutputStream.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在andExpect( )中的预期行为匹配由ResultMatcher提供。MockMvcResultMatcher是ResultMatcher的一个实现，提供了匹配视图、cookie、header、模型、请求和其他许多参数的方法。andDo()方法将MvcResult打印到OutputStream。
- en: 'Run the test case and surprisingly it will fail. The part of the output is
    as shown below:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试用例，令人惊讶的是它会失败。输出的一部分如下所示：
- en: '![](img/image_07_004.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_004.png)'
- en: It shows the validation error, but we had given all input as per the validation
    rules. Which validation has failed is not clear from the output. No, no need to
    panic and to check the validation one by one.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它显示了验证错误，但我们已经根据验证规则给出了所有输入。哪个验证失败了从输出中看不清楚。不，没必要惊慌，也不需要逐个检查验证。
- en: 'Instead of creating more confusion let''s add test code for validation using
    attributeHasErrors() as shown below by underlined statement:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其制造更多混乱，不如添加使用attributeHasErrors()的验证测试代码，如下划线语句所示：
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The test runs successfully proving the input has validation error. We can get
    the field whose validation failed on console output in the ''errors'' as:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试运行成功，证明输入存在验证错误。我们可以在控制台输出的'errors'中获取到验证失败的字段：
- en: '[PRE24]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Though the description has characters within the specified limit of 10 to 40\.
    Let's find out the rule to get what mistake we did in Validator2.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管描述符中的字符在10到40个指定字符的限制内。让我们找出在Validator2中犯错的规则。
- en: 'The code in the validate method for setting validation rule for publication
    is:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置发布验证规则的validate方法中的代码是：
- en: '[PRE25]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Yes, we set the validation for publicationlength as less than 40 which lead
    to failure. We made mistake. Let''s change the code to set rules as length greater
    than 40 will not be allowed. The updated code is as shown below:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，我们将发布长度设置为小于40的验证，导致失败。我们犯了一个错误。让我们更改代码，以设置规则，长度大于40将不允许。以下是更新的代码：
- en: '[PRE26]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now rerun the testAddController to find what happens.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新运行testAddController以查看发生了什么。
- en: The test case passes successfully. This is why we are carrying out the test
    cases.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试用例成功通过。这就是我们进行测试用例的原因。
- en: 'Let''s now add the code to test field validations in the testAddBook_Form_validation().as:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在testAddBook_Form_validation()中添加测试字段验证的代码：
- en: '[PRE27]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the test case where validation errors failed.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试用例，其中验证错误失败。
- en: The Controllers and DAOs are working fine.The service layer is using DAOs, so
    let's conduct the integration testing of service layer. You can conduct mock object
    testing of service layer as per we discussed and did in DAO layer testing. We
    will move on to integration testing of the service as next phase.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器和DAO正常工作。服务层使用DAO，所以让我们对服务层进行集成测试。您可以按照我们讨论的和对DAO层测试进行模拟对象测试。我们将进入服务层集成测试的下一阶段。
- en: Pase II Integration testing
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二阶段 集成测试
- en: '* * *'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Integration testing of Service and DAO layer
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务和DAO层的集成测试
- en: 'Let''s carry out integration testing of the application,Ch05_Declarative_Transaction_Management
    step by step as follow:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步进行应用程序的集成测试，Ch05_Declarative_Transaction_Management如下：
- en: Create com.packt.ch05.service.integration_tests package.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建com.packt.ch05.service.integration_tests包。
- en: Create JUnit test caseTestBookService_Integration by considering BookServiceImpl
    as class under test. Select all of its methods to test.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建JUnit测试用例TestBookService_Integration，将BookServiceImpl作为测试类。选择其所有方法进行测试。
- en: 'Declare the data member of type BookService, annotate it by @Autowired annotations
    as shown in code below:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明类型为BookService的数据成员，并用@Autowired注解注释它，如下所示：
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s test addBook() method, as we did in JUnit testing earlier. You can refer
    the code below:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试addBook()方法，就像我们之前在JUnit测试中做的那样。你可以参考下面的代码：
- en: '[PRE29]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can run the test case which will run successfully.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以运行测试用例，它将成功运行。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All other test methods from BookService can be referred from the source code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: BookService中的所有其他测试方法可以从源代码中参考。
- en: Both the layers developed by us are working as we want them to.We developed
    controllers, services and DAOs separately and tested as well. Now, we will combine
    them in single application so as one complete application will be with us and
    then using integration testing we will check whether it is working as per expectation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的两个层次都在按我们的预期工作。我们分别开发了控制器、服务和DAO，并进行了测试。现在，我们将它们组合到单个应用程序中，这样我们就会有一个完整的应用程序，然后通过集成测试，我们将检查它是否如预期般工作。
- en: Integration testing of Controller and Service Layer
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器和Service层的集成测试
- en: 'Let''s combine the three layers together in ReadMyBooks from Ch05_Declarative_Transaction_Management
    as stated by steps below:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下三个层次从Ch05_Declarative_Transaction_Management中组合到ReadMyBooks中：
- en: Add jars for jdbc and spring-jdbc and other required jars in lib folder of ReadMyBooks.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ReadMyBooks的lib文件夹中添加jdbc和spring-jdbc以及其他所需的jar文件。
- en: Copy the com.packt.ch03.dao and com.packt.ch05.service packages from Ch05_Declarative_Transaction_Management
    to ReadMyBooks application.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Ch05_Declarative_Transaction_Management中将com.packt.ch03.dao和com.packt.ch05.service包复制到ReadMyBooks应用程序。
- en: Copy connection_new.xml in the class path of ReadMyBooks application.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ReadMyBooks应用程序的类路径中复制connection_new.xml。
- en: In the Book class for Form Submission we had commentated the default constructor,
    the logic in addBook of service is to check against 98564567las default value.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Book类的表单提交中，我们注释了默认构造函数，服务中的addBook逻辑是检查98564567las的默认值。
- en: 'Change the BookService as shown below by underline keeping rest of the code
    untouched:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，通过下划线修改BookService，其余代码保持不变：
- en: '[PRE30]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The controllers needs to be updated to get a talk with under lying layer as:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器需要更新以与底层层进行通信，如下所示：
- en: Add autowired data member of type BookService in the controllers.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器中添加类型为BookService的自动装配数据成员。
- en: Invoke the methods of service layer in method of controllers as per business
    logic requirements.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据业务逻辑要求，在控制器的method中调用服务层的method。
- en: 'The addBook() method will be updated as shown below:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面将更新addBook()方法：
- en: '[PRE31]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the same way we can update all the methods from the controller. You can refer
    the complete source code.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以更新所有控制器中的方法。你可以参考完整的源代码。
- en: Let's execute the test case TestAddBookController.java to get the result.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行测试用例TestAddBookController.java以获取结果。
- en: The code will execute and gives success message. Also in the table one row with
    the ISBN and other values which we specified gets added.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将执行并给出成功消息。同时在表中添加了一行，包含了我们指定的ISBN和其他值。
- en: We had done testing of all the components successfully. We can now directly
    start with SystemTesting.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功测试了所有组件。现在我们可以直接开始系统测试。
- en: But have patience as we will discuss about the new entry to the testing framework
    'Arquillian'.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 但是要有耐心，因为我们将在测试框架“Arquillian”中讨论新的条目。
- en: Pase III System testing
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三阶段系统测试
- en: '* * *'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: All the layers are working as per expectations now it's time to test the application
    by using the web i.e. will check one by one functionalities by taking at most
    care to go step by step and not only the result but the presentation also will
    be observed which will be close to the actual deployment environment . Let's deploy
    the application to check all the functions are working and giving the correct
    results both on data base side as well as presentation side by either of the ways
    as discussed below.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有层次都按照预期工作，是时候通过网络测试应用程序了，即逐一检查功能，同时非常注意逐步进行，不仅要关注结果，还要观察演示，这将接近实际的部署环境。让我们部署应用程序，以检查所有功能是否正常工作，并在数据库和演示方面给出正确的结果，通过以下任一方式进行：
- en: Using Eclipse IDE for deployment
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Eclipse IDE进行部署
- en: 'In eclipse once you are finished with development, configure the server and
    select the project from the Project Explorer to choose **`Run on server`** option
    as shown by the arrows below:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中，一旦开发完成，配置服务器并从项目浏览器中选择项目以选择**`Run on server`**选项，如下面的箭头所示：
- en: '![](img/image_07_005.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_005.png)'
- en: The IDE will package the application in the war file and will deploy it to the
    container. Now you can check the functionalities one by one to make sure each
    and everything is as per the expectation or not. We will take care of presentation,
    look and feel as well as accuracy of the data which is displayed by the presentation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: IDE会将应用程序包装在战争文件中，并将其部署到容器中。现在，你可以逐一检查功能，以确保一切按预期进行。我们还将关注演示文稿、外观和准确性的数据，这些数据由演示文稿显示。
- en: Manually deploying the application
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动部署应用程序
- en: 'To manually deploy the application can be by the following steps:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 手动部署应用程序可以通过以下步骤进行：
- en: 'First of all we need to get the jar file of it. We can use the Eclipse IDE
    to get the war file for deployment easily by right clicking the application and
    selecting **`Export`** as shown by arrows below:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要获取它的jar文件。我们可以使用Eclipse IDE通过右键点击应用程序并选择**`Export`**来轻松获取战争文件，如下面的箭头所示：
- en: '![](img/image_07_006.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_006.png)'
- en: Select the destination where the war you want to create the war file. If you
    want you can change the war file name. I will keep ReadMyBooks as it is.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要创建战争文件的目标位置。如果你想的话，可以更改战争文件的名字。我将保持ReadMyBooks不变。
- en: Click on **`finish`** to complete the process. You will get a war file on the
    selected destination.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**`finish`**完成过程。你将在选定的目标位置得到一个战争文件。
- en: Copy the WAR file which we created in earlier step and paste it in 'webapps'
    folder under Tomcat directory.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制我们在上一步创建的WAR文件，并将其粘贴到Tomcat目录下的'webapps'文件夹中。
- en: Start tomcat by clicking `startup.bat` file from **`bin`** folder
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**`bin`**文件夹中的`startup.bat`文件来启动tomcat。
- en: Once the tomcat started, open the browser and type home url in the folrmat of
    [http://host_name:port_number_of_tomcat/war_file_name](http://host_name:port_number_of_tomcat/war_file_name).
    in our case it is [http://locathost:8080/ReadMyBooks](http://locathost:8080/ReadMyBooks).
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦tomcat启动，打开浏览器并输入主页URL，格式为[http://host_name:port_number_of_tomcat/war_file_name](http://host_name:port_number_of_tomcat/war_file_name)。在我们的案例中，它是[http://locathost:8080/ReadMyBooks](http://locathost:8080/ReadMyBooks)。
- en: Before moving ahead make sure the database parameters are correctly set otherwise
    the application will fail.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保数据库参数已正确设置，否则应用程序将失败。
- en: The home page will open where we can test the application for the functionalities
    and look and feel.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主页将打开，我们可以在这里测试应用程序的功能和外观。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '* * *'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In this chapter we disussed about what is testing and why it is so important.
    We also had a discussion about the unit testing, integration testing and User
    acceptance test as phases of testing. There are many testing tools available in
    market, we had taken an over view of these tools so that the choice of tool can
    be wisely done by you. One of the very important tool of testing is 'Junit testing',
    which we used to carry out unit testing of the DAO layer which was the starting
    of testing phase1\. But JUnit uses realtime database, we discuss the difficulties
    in testing upon the external parameters. We resolve the issue by using mock objects.
    Mokito is one of the Mock object creation tool which we explore to test the DAO
    layer. After DAO layer we tested Web layer which also was having dependency upon
    the web container whi initializes request and response objects. We discuss in
    depth about Spring TestContext framework whose MockMVC module facilitates creation
    of Mock objects of the web related components like request and responses. We used
    the the framework for testing the form validation as well. After Unit testing
    we carry out the integration testing of DAO and service layer and then web and
    service layers. The story wont ends here we carry out successful deployment and
    final checking of the product by carrying out System Testing. All the components
    developed by us are working fine and we had proved it by successfully executing
    the System Testing !!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了什么是测试以及为什么它如此重要。我们还讨论了单元测试、集成测试和用户接受测试作为测试的阶段。市场上有很多测试工具，我们对此进行了概述，以便您明智地选择工具。测试中一个非常重要的工具是'Junit测试'，我们使用它来执行DAO层的单元测试，这是测试阶段1的开始。但是JUnit使用实时数据库，我们讨论了在外部参数上测试的困难。我们通过使用模拟对象解决了这个问题。Mokito是创建模拟对象的工具之一，我们探索它来测试DAO层。在DAO层之后，我们测试了Web层，这也依赖于Web容器来初始化请求和响应对象。我们深入讨论了Spring
    TestContext框架，其MockMVC模块便于创建Web相关组件（如请求和响应）的模拟对象。我们还使用该框架进行表单验证测试。在单元测试之后，我们执行了DAO和Service层的集成测试，然后是Web和Service层的集成测试。故事不会在这里结束，我们通过进行系统测试来成功部署并最终检查产品。我们所开发的的所有组件都在正常工作，我们通过成功执行系统测试证明了这一点！！
- en: In next chapter we will go one step ahead and discuss about the role of security
    in an application along with the ways provided by Spring framework to implement
    security. Keep reading!!!!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步讨论安全性在应用程序中的角色以及Spring框架提供的实现安全性的方法。请继续阅读！！！
