- en: Chapter 7. Software Transactional Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 软件事务内存
- en: '|   | *"Everybody who learns concurrency and thinks they understand it, ends
    up finding mysterious races they thought weren''t possible, and discovers that
    they didn''t actually understand it yet after all."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"每一个学习并发并认为自己理解了它的人，最终都会发现一些他们本以为不可能出现的神秘竞态，并发现他们实际上还没有真正理解它。"* |  
    |'
- en: '|   | --*Herb Sutter* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*赫伯·萨特* |'
- en: While investigating the fundamental primitives of concurrency in [Chapter 2](ch02.html
    "Chapter 2. Concurrency on the JVM and the Java Memory Model"), *Concurrency on
    the JVM and the Java Memory Model*, we recognized the need for protecting parts
    of the program from shared access. We saw that a basic way of achieving this isolation
    is the `synchronized` statement, which uses intrinsic object locks to ensure that
    at most a single thread executes a specific part of the program at the same time.
    The disadvantage of using locks is that they can easily cause deadlocks, a situation
    in which the program cannot progress.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查[第2章](ch02.html "第2章. JVM和Java内存模型上的并发")中并发的根本原语时，即《JVM和Java内存模型上的并发》，我们认识到需要保护程序的一部分免受共享访问。我们注意到实现这种隔离性的基本方法之一是`synchronized`语句，它使用内建对象锁来确保最多只有一个线程同时执行程序的一部分。使用锁的缺点是它们很容易导致死锁，这是一种程序无法继续进行的情况。
- en: In this chapter, we will introduce **Software Transactional Memory** (**STM**),
    a concurrency control mechanism for controlling access to shared memory, which
    greatly reduces the risk of deadlocks and races. An STM is used to designate critical
    sections of the code. Instead of using locks in order to protect critical sections,
    STM tracks the reads and writes to shared memory, and serializes critical sections
    with interleaving reads and writes. The `synchronized` statement is replaced with
    the atomic blocks that express segments of the program that need to be executed
    in isolation. STM is safer and easier to use, and at the same time, guarantees
    relatively good scalability.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**软件事务内存**（**STM**），这是一种用于控制对共享内存访问的并发控制机制，它大大降低了死锁和竞态的风险。STM用于指定代码的关键部分。不是使用锁来保护关键部分，STM跟踪对共享内存的读取和写入，并通过交错读取和写入来序列化关键部分。`synchronized`语句被替换为表达需要独立执行的程序段的原子块。STM更安全、更易于使用，同时保证了相对较好的可扩展性。
- en: The idea of *memory transactions* stems from database transactions, which ensure
    that a sequence of database queries occurs in isolation. A memory transaction
    is a sequence of reads and writes to shared memory that logically occur at a single
    point in time. When a memory transaction T occurs, concurrent memory transactions
    observe the state of the memory either before the transaction T started, or after
    the transaction T completed, but not the intermediate states during the execution
    of T. This property is called **isolation**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存事务*的概念源于数据库事务，它确保一系列数据库查询在隔离状态下发生。内存事务是对共享内存进行的一系列读取和写入操作，逻辑上发生在同一时间点。当内存事务T发生时，并发内存事务观察到内存的状态要么是在事务T开始之前，要么是在事务T完成之后，但不是在T执行过程中的中间状态。这个特性被称为**隔离性**。'
- en: 'As we will see, **composability** is another important advantage of using an
    STM. Consider a lock-based hash table implementation with thread-safe `insert`
    and `remove` operations. While the individual `insert` and `remove` operations
    can be safely invoked by different threads, it is impossible to implement a method
    that removes an element from one hash table and adds it to another hash table,
    without exposing the intermediate state in which the element is not present in
    either hash table. Traditionally, STM was proposed as a part of the programming
    language with the advantage that certain transaction limitations can be ensured
    at compile time. Since this approach requires intrusive changes to a language,
    many software transactional memories are implemented as libraries. ScalaSTM is
    one such example. We will use ScalaSTM as the concrete STM implementation. Concretely,
    we cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，**可组合性**是使用STM的另一个重要优点。考虑一个基于锁的哈希表实现，具有线程安全的`insert`和`remove`操作。虽然单个`insert`和`remove`操作可以安全地由不同的线程调用，但无法实现一个方法，从一个哈希表中删除元素并将其添加到另一个哈希表中，而不暴露元素不在任一哈希表中的中间状态。传统上，STM被提议作为编程语言的一部分，具有编译时确保某些事务限制的优势。由于这种方法需要对语言进行侵入性更改，许多软件事务内存被实现为库。ScalaSTM就是这样一个例子。我们将使用ScalaSTM作为具体的STM实现。具体来说，本章涵盖了以下主题：
- en: The disadvantages of atomic variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子变量的缺点
- en: The semantics and internals of STM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM的语义和内部机制
- en: Transactional references
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务引用
- en: The interaction between transactions and external side effects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务与外部副作用之间的交互
- en: Semantics of single operation transactions and nested transactions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个操作事务和嵌套事务的语义
- en: Retrying transactions conditionally and timing out transactions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件重试事务和超时事务
- en: Transaction-local variables, transactional arrays, and transactional maps
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务局部变量、事务数组、事务映射
- en: We already learned in [Chapter 3](ch03.html "Chapter 3. Traditional Building
    Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*, that using
    atomic variables and concurrent collections allows expressing lock-free programs.
    Why not just use atomic variables to express concurrently shared data? To better
    emphasize the need for STM, we will start by presenting a situation in which atomic
    variables prove inadequate.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章](ch03.html "第3章。并发传统的构建块")，*并发的传统构建块*中学习了，使用原子变量和并发集合可以表达无锁程序。为什么不用原子变量来表示并发共享数据呢？为了更好地强调STM的需求，我们将首先展示一个原子变量证明不足的情况。
- en: The trouble with atomic variables
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子变量的麻烦
- en: Atomic variables from [Chapter 3](ch03.html "Chapter 3. Traditional Building
    Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*, are one
    of the fundamental synchronization mechanisms. We already know that volatile variables,
    introduced in [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the
    Java Memory Model"), *Concurrency on the JVM and the Java Memory Model*, allow
    race conditions, in which the program correctness is subject to the precise execution
    schedule of different threads. Atomic variables can ensure that no thread concurrently
    modifies the variable between a read and a write operation. At the same time,
    atomic variables reduce the risk of deadlocks. Regardless of their advantages,
    there are situations when using atomic variables is not satisfactory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。并发传统的构建块")，*并发的传统构建块*中的原子变量是基本同步机制之一。我们已经知道，在[第2章](ch02.html
    "第2章。JVM上的并发和Java内存模型")，*JVM上的并发和Java内存模型*中引入的volatile变量允许竞争条件，其中程序的正确性取决于不同线程的精确执行顺序。原子变量可以确保在读取和写入操作之间没有线程并发修改变量。同时，原子变量降低了死锁的风险。尽管它们有优点，但在某些情况下使用原子变量并不令人满意。'
- en: In [Chapter 6](ch06.html "Chapter 6. Concurrent Programming with Reactive Extensions"),
    *Concurrent Programming with Reactive Extensions*, we implemented a minimalistic
    web browser using the **Rx** framework. Surfing around the Web is great, but we
    would like to have some additional features in our browser. For example, we would
    like to maintain the browser's history--the list of URLs that were previously
    visited. We decide to keep the list of URLs in the Scala `List[String]` collection.
    Additionally, we decide to track the total character length of all the URLs. If
    we want to copy the URL strings into an array, this information allows us to quickly
    allocate an array of an appropriate size.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。使用响应式扩展的并发编程")，*使用响应式扩展的并发编程* 中，我们使用 **Rx** 框架实现了一个最小化的网络浏览器。在网上冲浪很棒，但我们希望在浏览器中添加一些额外的功能。例如，我们希望维护浏览器的历史记录——之前访问过的
    URL 列表。我们决定将 URL 列表保存在 Scala 的 `List[String]` 集合中。此外，我们决定跟踪所有 URL 的总字符长度。如果我们想将
    URL 字符串复制到一个数组中，这些信息允许我们快速分配一个适当大小的数组。
- en: 'Different parts of our browser execute asynchronously, so we need to synchronize
    access to this mutable state. We can keep the list of URLs and their total character
    length in private mutable fields and use the `synchronized` statement to access
    them. However, having seen the culprits of the `synchronized` statement in earlier
    chapters, we decide to avoid locks. Instead, we will use atomic variables. We
    will store the list of URLs and their total character length in two atomic variables,
    that are `urls` and `clen`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器的不同部分异步执行，因此我们需要同步访问这个可变状态。我们可以将 URL 列表及其总字符长度保存在私有可变字段中，并使用 `synchronized`
    语句来访问它们。然而，鉴于我们在前面的章节中看到了 `synchronized` 语句的罪魁祸首，我们决定避免锁。相反，我们将使用原子变量。我们将 URL
    列表及其总字符长度存储在两个原子变量中，即 `urls` 和 `clen`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Whenever the browser opens URL, we need to update these atomic variables. To
    do this more easily, we define a helper method called `addUrl`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每当浏览器打开 URL 时，我们需要更新这些原子变量。为了更容易地做到这一点，我们定义了一个名为 `addUrl` 的辅助方法：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we learned in the introductory chapters, we need to use atomic operations
    on atomic variables to ensure that their values consistently change from one state
    to another. In the previous code snippet, we use the `compareAndSet` operation
    to atomically replace the old list of URLs called `oldUrls` with the updated version
    `newUrls`. As discussed at length in [Chapter 3](ch03.html "Chapter 3. Traditional
    Building Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*,
    the `compareAndSet` operation can fail when two threads call it simultaneously
    on the same atomic variable. For this reason, we define a nested, tail-recursive
    method, `append`, which calls the `compareAndSet` method and restarts if the `compareAndSet`
    method fails. Updating the `clen` field is easier. We just call the atomic `addAndGet`
    method defined on atomic integers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍章节中学到的，我们需要在原子变量上使用原子操作来确保它们的值从一个状态一致地改变到另一个状态。在前面的代码片段中，我们使用 `compareAndSet`
    操作原子地替换名为 `oldUrls` 的旧 URL 列表为更新版本 `newUrls`。正如在 [第 3 章](ch03.html "第 3 章。并发传统的构建块")
    中详细讨论的那样，*并发传统的构建块*，当两个线程同时在同一原子变量上调用 `compareAndSet` 操作时，该操作可能会失败。因此，我们定义了一个嵌套的、尾递归的方法
    `append`，它调用 `compareAndSet` 方法，并在 `compareAndSet` 方法失败时重新启动。更新 `clen` 字段更容易。我们只需调用在原子整数上定义的原子
    `addAndGet` 方法。
- en: 'Other parts of the web browser can use the `urls` and `clen` variables to render
    the browsing history, dump it to a `log` file or to export browser data, in case
    our users decide they like Firefox better. For convenience, we define a `getUrlArray`
    auxiliary method that returns a character array in which the URLs are separated
    with a newline character. The `clen` field is a quick way to get the required
    size of the array. We call the `get` method to read the value of the `clen` field
    and allocate the array. We then call `get` to read the current list of URLs, append
    the newline character to each URL, flatten the list of strings into a single list,
    zip the characters with their indices, and store them into the array:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器的其他部分可以使用 `urls` 和 `clen` 变量来渲染浏览历史记录，将其导出到 `log` 文件或导出浏览器数据，以防我们的用户决定更喜欢
    Firefox。为了方便起见，我们定义了一个辅助方法 `getUrlArray`，它返回一个字符数组，其中 URL 由换行符分隔。`clen` 字段是获取数组所需大小的快捷方式。我们调用
    `get` 方法来读取 `clen` 字段的值并分配数组。然后我们调用 `get` 来读取当前的 URL 列表，将换行符附加到每个 URL 上，将字符串列表展平成一个单独的列表，将字符与其索引配对，并将它们存储到数组中：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To test these methods, we can simulate user interaction with two asynchronous
    computations. The first asynchronous computation calls the `getUrlArray` method
    to dump the browsing history to a file. The second asynchronous computation visits
    three separate URLs by calling the `addURL` method three times, and then prints
    the `"done browsing"` string to the standard output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些方法，我们可以通过模拟用户与两个异步计算之间的交互来测试。第一个异步计算通过调用`getUrlArray`方法将浏览历史记录到文件中。第二个异步计算通过三次调用`addURL`方法访问三个不同的URL，然后向标准输出打印`"done
    browsing"`字符串：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running this program several times reveals a bug. The program sometimes mysteriously
    crashes with an `ArrayIndexOutOfBoundsException` exception. By analyzing the `getUrlArray`
    method, we find the cause to the bug. This bug occurs when the retrieved value
    of the `clen` field is not equal to the length of the list. The `getUrlArray`
    method first reads the `clen` atomic variable, and later reads the list of the
    URLs from the `urls` atomic variable. Between these two reads, the first thread
    modifies the `urls` variable by adding an additional URL string. By the time `getUrlArray`
    reads the `urls` variable, the total character length becomes longer than the
    allocated array, and we eventually get an exception.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序几次会揭示一个错误。程序有时会神秘地崩溃，并抛出`ArrayIndexOutOfBoundsException`异常。通过分析`getUrlArray`方法，我们发现错误的根源。这个错误发生在检索到的`clen`字段的值不等于列表长度时。`getUrlArray`方法首先读取`clen`原子变量，然后从`urls`原子变量中读取URL列表。在这两次读取之间，第一个线程通过添加一个额外的URL字符串修改了`urls`变量。当`getUrlArray`读取`urls`变量时，总字符长度已经超过了分配的数组长度，我们最终得到了一个异常。
- en: This example illustrates an important disadvantage of atomic variables. Although
    specific atomic operations are themselves atomic and occur at a single point in
    time, invoking multiple atomic operations is typically not atomic. When multiple
    threads simultaneously execute multiple atomic operations, the operations might
    interleave in unforeseen ways and lead to the same kind of race conditions that
    result from using volatile variables. Note that swapping the updates to the `clen`
    and `urls` variables does not solve the problem. Although there are other ways
    to ensure atomicity in our example, they are not immediately obvious.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了原子变量的重要缺点。尽管特定的原子操作本身是原子的，并且发生在单一的时间点，但调用多个原子操作通常不是原子的。当多个线程同时执行多个原子操作时，操作可能会以不可预见的方式交错，从而导致与使用volatile变量相同类型的竞争条件。请注意，交换`clen`和`urls`变量的更新并不能解决问题。尽管在我们的例子中还有其他确保原子性的方法，但它们并不明显。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reading multiple atomic variables is not an atomic operation and it can observe
    the program data in an inconsistent state.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 读取多个原子变量不是一个原子操作，并且它可能会观察到程序数据处于不一致的状态。
- en: When all threads in the program observe that an operation occurs at the same,
    single point in time, we can say that the operation is *linearizable*. The point
    in time at which the operation occurs is called a **linearization point**. The
    `compareAndSet` and `addAndGet` operations are inherently linearizable operations.
    They execute atomically, usually as a single processor instruction and at a single
    point in time, from the perspective of all the threads. The `append` nested method
    in the previous example is also linearizable. Its linearization point is a successful
    `compareAndSet` operation, because that is the only place where `append` modifies
    the program state. On the other hand, the `addUrl` and `getUrlArray` methods are
    not linearizable. They contain no single atomic operation that modifies or reads
    the state of the program. The `addUrl` method modifies the program state twice.
    First, it calls the `append` method and then it calls the `addAndGet` method.
    Similarly, the `getUrlArray` method reads the program state with two separate
    atomic `get` operations. This is a commonly misunderstood point when using atomic
    variables, and we say that atomic variables do not compose into larger programs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中的所有线程都观察到操作在相同的时间点发生时，我们可以说该操作是*可线性化的*。操作发生的时间点被称为**线性化点**。`compareAndSet`和`addAndGet`操作是固有的可线性化操作。从所有线程的角度来看，它们原子地执行，通常作为单个处理器指令并在单个时间点执行。前一个示例中的`append`嵌套方法也是可线性化的。其线性化点是一个成功的`compareAndSet`操作，因为这是`append`修改程序状态的唯一地方。另一方面，`addUrl`和`getUrlArray`方法不可线性化。它们不包含单个原子操作来修改或读取程序状态。`addUrl`方法修改程序状态两次。首先，它调用`append`方法，然后调用`addAndGet`方法。同样，`getUrlArray`方法使用两个独立的原子`get`操作读取程序状态。这是使用原子变量时常见的误解点，我们说原子变量不能组合成更大的程序。
- en: We can fix our example by removing the `clen` atomic variable, and computing
    the required array length after reading the `urls` variable once. Similarly, we
    can use a single atomic reference to store a tuple with the URL list and the size
    of that list. Both approaches would make the `addUrl` and `getUrlArray` methods
    linearizable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过移除`clen`原子变量，并在读取`urls`变量一次后计算所需的数组长度来修复我们的示例。同样，我们可以使用单个原子引用来存储包含URL列表及其大小的元组。这两种方法都会使`addUrl`和`getUrlArray`方法可线性化。
- en: Concurrent programming experts have proven that it is possible to express any
    program state using atomic variables, and arbitrarily modify this state with linearizable
    operations. In practice, implementing such linearizable operations efficiently
    can be quite challenging. It is generally hard to implement arbitrary linearizable
    operations correctly, and it is even harder to implement them efficiently.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程专家已经证明，使用原子变量可以表达任何程序状态，并且可以使用可线性化操作任意修改此状态。在实践中，有效地实现这样的可线性化操作可能相当具有挑战性。通常很难正确实现任意的可线性化操作，而高效地实现它们则更加困难。
- en: Unlike atomic variables, multiple `synchronized` statements can be used together
    more easily. We can modify multiple fields of an object when we use the `synchronized`
    statement, and we can even nest multiple `synchronized` statements. We are thus
    left with a dilemma. We can use atomic variables and risk race conditions when
    composing larger programs, or we can revert to using the `synchronized` statement,
    but risk deadlocks. Luckily, STM is a technology that offers the best of both
    worlds; it allows you to compose simple atomic operations into more complex atomic
    operations, without the risk of deadlocks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与原子变量不同，多个`synchronized`语句可以更容易地一起使用。当我们使用`synchronized`语句时，我们可以修改对象的多个字段，甚至可以嵌套多个`synchronized`语句。因此，我们面临一个困境。我们可以使用原子变量并冒着在组合更大程序时发生竞态条件的风险，或者我们可以退回到使用`synchronized`语句，但风险死锁。幸运的是，STM是一种提供两者最佳方案的技术；它允许您将简单的原子操作组合成更复杂的原子操作，而不会出现死锁的风险。
- en: Using Software Transactional Memory
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用软件事务内存
- en: In this section, we will study the basics of using STM. Historically, multiple
    STM implementations were introduced for Scala and the JVM platform. The particular
    STM implementation described in this chapter is called **ScalaSTM**. There are
    two reasons that ScalaSTM is our STM of choice. First, ScalaSTM was authored by
    a group of STM experts who agreed on a standardized set of APIs and features.
    Future STM implementations for Scala are strongly encouraged to implement these
    APIs. Second, the ScalaSTM API is designed for multiple STM implementations, and
    comes with an efficient default implementation. Different STM implementations
    can be chosen when the program starts. Users can write applications using a standardized
    API, and seamlessly switch to a different STM implementation later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究使用 STM 的基础知识。历史上，为 Scala 和 JVM 平台引入了多个 STM 实现。本章中描述的特定 STM 实现称为 **ScalaSTM**。ScalaSTM
    成为我们的首选 STM 的有两个原因。首先，ScalaSTM 是由一组 STM 专家编写的，他们同意使用一套标准化的 API 和功能。强烈鼓励 Scala
    的未来 STM 实现实现这些 API。其次，ScalaSTM API 是为多个 STM 实现设计的，并附带一个高效的默认实现。程序启动时可以选择不同的 STM
    实现。用户可以使用标准化的 API 编写应用程序，并在以后无缝切换到不同的 STM 实现中。
- en: The `atomic` statement is a fundamental abstraction at the core of every STM.
    When the program executes a block of code marked with the `atomic` symbol, it
    starts a memory transaction, a sequence of reads and writes operations to memory
    that occur atomically for other threads in the program. The `atomic` statement
    is similar to the `synchronized` statement, and ensures that a block of code executes
    in isolation, without the interference of other threads, thus avoiding race conditions.
    Unlike the `synchronized` statement, the `atomic` statement does not cause deadlocks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`atomic` 语句是每个 STM 核心的基本抽象。当程序执行带有 `atomic` 符号的代码块时，它开始一个内存事务，这是一系列对内存的读取和写入操作，对于程序中的其他线程来说这些操作是原子性的。`atomic`
    语句类似于 `synchronized` 语句，并确保代码块在隔离的环境中执行，不受其他线程的干扰，从而避免竞争条件。与 `synchronized` 语句不同，`atomic`
    语句不会导致死锁。'
- en: 'The following methods, `swap` and `inc`, show how to use the `atomic` statement
    on a high level. The `swap` method atomically exchanges the contents of two memory
    locations, `a` and `b`. Between the time that a thread reads the memory location
    `a` (or `b`) and the time that the `atomic` statement ends, no other thread can
    effectively modify the value at location `a` (or `b`). Similarly, the `inc` method
    atomically increments the integer value at the memory location `a`. When a thread,
    which calls the `inc` method, reads the value of `a` in the `atomic` statement,
    no other thread can change the value of the memory location `a` until the `atomic`
    statement ends:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法，`swap` 和 `inc`，展示了如何在高级别使用 `atomic` 语句。`swap` 方法原子性地交换两个内存位置 `a` 和 `b`
    的内容。在某个线程读取内存位置 `a`（或 `b`）的时间与 `atomic` 语句结束的时间之间，没有其他线程能够有效地修改位置 `a`（或 `b`）的值。同样，`inc`
    方法原子性地增加内存位置 `a` 的整数值。当一个线程调用 `inc` 方法并读取 `atomic` 语句中的 `a` 的值时，直到 `atomic` 语句结束，没有其他线程可以更改位置
    `a` 的值：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The ways in which an STM implements deadlock-freedom and ensures that no two
    threads simultaneously modify the same memory locations are quite complex. In
    most STM implementations, the `atomic` statement maintains a log of read and write
    operations. Every time a memory location is read during a memory transaction,
    the corresponding memory address is added to the log. Similarly, whenever a memory
    location is written during a memory transaction, the memory address and the proposed
    value are written to the log. Once the execution reaches the end of the `atomic`
    block, all the writes from the transaction log are written to the memory. When
    this happens, we say that the transaction is committed. On the other hand, during
    the transaction, the STM might detect that another concurrent transaction performed
    by some other thread is concurrently reading or writing the same memory location.
    This situation is called a **transactional conflict**. When a transactional conflict
    occurs, one or both of the transactions are cancelled, and re-executed serially,
    one after another. We say that the STM *rolls back* these transactions. Such STMs
    are called **optimistic**. Optimistic STMs try to execute a transaction under
    the assumption that it will succeed, and roll back when they detect a conflict.
    When we say that a transaction is completed, we mean that it was either committed
    or rolled back, and re-executed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: STM 实现死锁自由并确保没有两个线程同时修改相同的内存位置的方式相当复杂。在大多数 STM 实现中，`atomic` 语句维护一个读写操作的日志。每次在内存事务中读取内存位置时，相应的内存地址都会添加到日志中。同样，每当在内存事务中写入内存位置时，内存地址和提议的值都会写入到日志中。一旦执行到达
    `atomic` 块的末尾，事务日志中的所有写入都会写入到内存中。当这种情况发生时，我们说事务已经提交。另一方面，在事务期间，STM 可能会检测到其他线程执行的一些并发事务正在同时读取或写入相同的内存位置。这种情况被称为**事务冲突**。当发生事务冲突时，一个或两个事务将被取消，并按顺序重新执行，一个接一个。我们说
    STM **回滚**了这些事务。这种 STM 被称为**乐观的**。乐观 STM 尝试在假设事务将成功的情况下执行事务，并在检测到冲突时回滚。当我们说一个事务已完成时，我们的意思是它要么已提交，要么已回滚并重新执行。
- en: 'To illustrate how a memory transaction works, we consider the scenario in which
    two threads, **T1** and **T2**, simultaneously call the `swap` and `inc` methods.
    Since both the `atomic` statements in these methods modify the memory location
    `a`, the execution results in a runtime transactional conflict. During the execution
    of the program, the STM detects that the entries in the transactional logs overlap:
    the transaction associated with the `swap` method has both memory locations `a`
    and `b` in its read and write sets, while the `inc` method has `a` in its read
    and write sets. This indicates a potential conflict. Both the transactions can
    be rolled back, and then executed serially one after another, as shown in the
    following diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明内存事务是如何工作的，我们考虑这样一个场景：两个线程 **T1** 和 **T2** 同时调用 `swap` 和 `inc` 方法。由于这些方法中的
    `atomic` 语句都修改了内存位置 `a`，执行结果导致运行时事务冲突。在程序执行过程中，STM 检测到事务日志条目重叠：与 `swap` 方法相关的事务在其读写集中都有内存位置
    `a` 和 `b`，而 `inc` 方法在其读写集中只有 `a`。这表明存在潜在的冲突。这两个事务都可以回滚，然后按顺序一个接一个地执行，如下面的图所示：
- en: '![Using Software Transactional Memory](img/image_07_001.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用软件事务内存](img/image_07_001.jpg)'
- en: We will not delve more deeply into the internals of the ScalaSTM implementation,
    as this is beyond the scope of this book. Instead, we will focus on how to use
    ScalaSTM to easily write concurrent applications. Where reasonable, we hint at
    some implementation details to better understand the reasons behind the ScalaSTM
    semantics.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨 ScalaSTM 实现的内部细节，因为这超出了本书的范围。相反，我们将关注如何使用 ScalaSTM 轻松编写并发应用程序。在合理的情况下，我们会暗示一些实现细节，以更好地理解
    ScalaSTM 语义背后的原因。
- en: In some STMs, the `atomic` statement tracks all the reads and writes to the
    memory. ScalaSTM only tracks specially marked memory locations within transactions.
    There are several reasons for this. First, an STM cannot ensure safety if some
    parts of the program access memory locations outside the `atomic` statements,
    while other parts access the same memory locations inside the `atomic` statements.
    ScalaSTM avoids accidental uses outside transactions by explicitly marking the
    memory locations that can only be used in transactions. Second, STM frameworks
    for the JVM need to use post-compilation or bytecode introspection in order to
    accurately capture all the reads and writes. ScalaSTM is a library-only STM implementation,
    so it cannot analyze and transform the program in the same way a compiler can.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些STM中，`atomic`语句跟踪对内存的所有读取和写入。ScalaSTM仅跟踪事务中特别标记的内存位置。这有几个原因。首先，如果程序的一部分访问`atomic`语句之外的内存位置，而另一部分访问`atomic`语句内的相同内存位置，STM无法确保安全性。ScalaSTM通过显式标记只能在事务中使用的内存位置来避免在事务之外意外使用。其次，JVM的STM框架需要使用编译后或字节码内省来准确捕获所有读取和写入。ScalaSTM是一个仅库的STM实现，因此它不能像编译器那样分析和转换程序。
- en: In ScalaSTM, the effects of the `atomic` statement are limited to special objects
    called **transactional references**. Before showing how to use the `atomic` statement
    to perform memory transactions, we will study how to create transactional references.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在ScalaSTM中，`atomic`语句的效果仅限于称为**事务引用**的特殊对象。在我们展示如何使用`atomic`语句执行内存事务之前，我们将研究如何创建事务引用。
- en: Transactional references
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务引用
- en: 'In this section, we will study how to declare transactional references. A transactional
    reference is a memory location that provides transactional read and write access
    to a single memory location. In ScalaSTM, transactional references to the values
    of type `T` are encapsulated within the objects of the `Red[T]` type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何声明事务引用。事务引用是一个内存位置，它为单个内存位置提供事务性的读写访问。在ScalaSTM中，类型`T`的事务引用被封装在`Red[T]`类型的对象中：
- en: 'Before we begin using STM in Scala, we need to add an external dependency to
    our project, since ScalaSTM is not a part of the Scala standard library:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在Scala中使用STM之前，我们需要将一个外部依赖项添加到我们的项目中，因为ScalaSTM不是Scala标准库的一部分：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use the ScalaSTM `atomic` statement in a compilation unit, we import the
    contents of the `scala.concurrent.stm` package:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编译单元中使用ScalaSTM的`atomic`语句，我们需要导入`scala.concurrent.stm`包的内容：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To instantiate a `Ref` object, we use the `Ref.apply` factory method on the
    `Ref` companion object. Let''s rewrite our browser history example using transactional
    memory. We start by replacing atomic variables with transactional references.
    We pass the initial value of each transactional reference to the `Ref.apply` method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个`Ref`对象，我们使用`Ref`伴生对象的`apply`工厂方法。让我们用事务内存重写我们的浏览器历史示例。我们首先用事务引用替换原子变量。我们将每个事务引用的初始值传递给`apply`方法：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Calling the `apply` method on a transactional reference returns its value, and
    calling the `update` method modifies it. However, we cannot call these methods
    from outside of a transaction. The `apply` and `update` methods take an implicit
    argument of type `InTxn` (which stands for *in transaction*), which designates
    that a transaction is under way. Without the `InTxn` object, we cannot call the
    `apply` and `update` methods. This constraint protects us from accidentally circumventing
    the ScalaSTM safety mechanisms.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务引用上调用`apply`方法返回其值，调用`update`方法修改它。然而，我们不能从事务之外调用这些方法。`apply`和`update`方法接受一个隐式参数，类型为`InTxn`（代表*在事务中*），它指定正在进行事务。没有`InTxn`对象，我们不能调用`apply`和`update`方法。这个约束保护我们免受意外绕过ScalaSTM安全机制的风险。
- en: To read and modify transactional references, we must first start a transaction
    that provides the implicit `InTxn` object. We will study how to do this next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取和修改事务引用，我们必须首先启动一个提供隐式`InTxn`对象的交易。我们将在下一节中学习如何做到这一点。
- en: Using the atomic statement
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原子语句
- en: 'After redefining the `urls` and `clen` variables as transactional references,
    we redefine the `addUrl` method. Instead of separately updating two atomic variables,
    we start a memory transaction with the `atomic` statement. In ScalaSTM, the `atomic`
    statement takes a block of type `InTxn => T`, where `InTxn` is the type of the
    previously mentioned transaction object, and `T` is the type of the return value
    of the transaction. Note that we can annotate the `InTxn` parameter with the `implicit`
    keyword:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`urls`和`clen`变量重新定义为事务引用后，我们重新定义了`addUrl`方法。我们不是分别更新两个原子变量，而是使用`atomic`语句开始一个内存事务。在ScalaSTM中，`atomic`语句接受一个类型为`InTxn
    => T`的块，其中`InTxn`是前面提到的事务对象的类型，`T`是事务的返回值类型。请注意，我们可以使用`implicit`关键字注解`InTxn`参数：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The new definition of `addUrl` is surprisingly simple. It first reads the value
    of the `urls` list, prepends a new URL to the list, and assigns the updated list
    back to the `urls` variable. Then, it reads the current value of the total character
    length `clen`, increments it by the length of the new URL, and assigns the new
    value back to `clen`. Note that the new definition of the `addUrl` method looks
    almost identical to a single-threaded implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`addUrl`的新定义非常简单。它首先读取`urls`列表的值，将一个新的URL添加到列表中，并将更新后的列表重新赋值给`urls`变量。然后，它读取当前的总字符长度`clen`，将其增加新URL的长度，并将新值重新赋值给`clen`。请注意，`addUrl`方法的新定义几乎与单线程实现完全相同。'
- en: An important limitation of the `atomic` statement in ScalaSTM is that it does
    not track reads and writes to ordinary local variables and object fields. As we
    will see later, these are considered as arbitrary side effects, and are not allowed
    inside the transaction.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaSTM中`atomic`语句的一个重要限制是它不跟踪对普通局部变量和对象字段的读写操作。正如我们稍后将看到的，这些被视为任意副作用，不允许在事务内部进行。
- en: 'We reimplement the `getUrlArray` method in a similar fashion. We start by creating
    a transaction with the `atomic` statement. The value of the `clen` variable is
    used in order to allocate a character array of an appropriate size. We then read
    the `urls` list and assign its characters to the array in a `for` loop. Again,
    the implementation of the `getUrlArray` method looks surprisingly similar to the
    corresponding single-threaded implementation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式重新实现了`getUrlArray`方法。我们首先使用`atomic`语句创建一个事务。使用`clen`变量的值来分配一个适当大小的字符数组。然后，我们读取`urls`列表，并在`for`循环中将它的字符赋值给数组。同样，`getUrlArray`方法的实现看起来与相应的单线程实现非常相似：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time, there is no danger of seeing inconsistent values of the `clen` and
    `urls` variables. When used in a transaction, the two values are always consistent
    with each other, as shown in the following program:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，看到`clen`和`urls`变量不一致值的风险已经不存在了。当在事务中使用时，这两个值总是彼此一致的，如下面的程序所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that we added the `sleep` statement in the main program, as this sets the
    timing of the two asynchronous computations to occur approximately at the same
    time. You can tweak the duration of the `sleep` statement in order to observe
    the various interleavings of the two asynchronous computations. Convince yourself
    with the fact that dumping the browsing history to the `log` file always observes
    some prefix of the three `addUrl` calls, and does not throw an exception.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在主程序中添加了`sleep`语句，因为这设置了两个异步计算的定时，以便它们大约同时发生。你可以调整`sleep`语句的持续时间，以观察两个异步计算的多种交织方式。通过以下事实来证实自己的观点：将浏览历史记录输出到`log`文件总是观察到三个`addUrl`调用的一些前缀，并且不会抛出异常。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When encoding a complex program state, use multiple transactional references.
    To atomically perform multiple changes on the program state, use the `atomic`
    statement.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当编码复杂的程序状态时，使用多个事务引用。为了原子性地对程序状态进行多个更改，使用`atomic`语句。
- en: Having seen basic way of using the `atomic` statement with transactional references,
    we will proceed to show more advanced examples and study the STM semantics in
    more detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了使用事务引用的基本方式使用`atomic`语句后，我们将继续展示更高级的示例，并更详细地研究STM语义。
- en: Composing transactions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写事务
- en: When used correctly, transactional memory is a powerful tool for building concurrent
    applications that modify shared data. Nevertheless, no technology is a silver
    bullet, and neither is STM. In this section, we will study how to compose transactions
    in larger programs and learn how transactional memory interacts with other features
    of Scala. We investigate some of the caveats of STM, and go beyond transactional
    references and the `atomic` statement blocks to show how to use STM more effectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，事务性内存是构建修改共享数据并发应用程序的强大工具。然而，没有技术是一劳永逸的，STM也不例外。在本节中，我们将研究如何在更大的程序中组合事务，并了解事务性内存如何与Scala的其他特性交互。我们探讨了STM的一些注意事项，并超越了事务性引用和`atomic`语句块，展示了如何更有效地使用STM。
- en: The interaction between transactions and side effects
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务与副作用之间的交互
- en: Previously, we learned that an STM may roll back and retry a transaction. An
    attentive reader might notice that retrying a transaction means re-executing its
    side effects. Here, the side effects are arbitrary reads and writes to regular
    `object` fields and variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们了解到STM可能会回滚并重试一个事务。一个细心的读者可能会注意到，重试一个事务意味着重新执行其副作用。在这里，副作用是对常规`object`字段和变量的任意读取和写入。
- en: 'Sometimes, side effects are not a problem. Transactional references cannot
    be modified outside a transaction, and inside a transaction their modifications
    are aborted when retrying. Still, the other kinds of side effect are not rolled
    back. Consider the following program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，副作用并不是问题。事务性引用在事务外部无法修改，并且在事务内部，它们的修改在重试时会中止。尽管如此，其他类型的副作用并不会回滚。考虑以下程序：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding program declares a `myValue` transactional reference, and an
    `inc` method that increments `myValue` inside an `atomic` block. The `inc` method
    also contains a `log` statement which prints the current value of the `myValue`
    reference. The program asynchronously calls the `inc` method twice. Upon executing
    this program, we get the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序声明了一个`myValue`事务性引用和一个在`atomic`块内增加`myValue`的`inc`方法。`inc`方法还包含一个打印`myValue`引用当前值的`log`语句。程序异步两次调用`inc`方法。执行此程序后，我们得到以下输出：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The two asynchronous computations call the `inc` method at the same time, and
    both start a transaction. One of the transactions adds the `myValue` reference
    to its read set, calls the `log` statement with the `0` value, and proceeds to
    increment the `myValue` reference by adding the `myValue` reference to its write
    set. In the meantime, the other transaction first logs the `0` value, then attempts
    to read `myValue` again, and detects that `myValue` is in a write set of another
    active transaction. The second transaction is rolled back, and retried after the
    first transaction commits. The second transaction reads the `myValue` reference
    once more, prints `1`, and then increments `myValue`. The two transactions commit,
    but the side-effecting `log` call is executed three times as a result of the rollback.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 两个异步计算同时调用`inc`方法，并且都启动了一个事务。其中一个事务将`myValue`引用添加到其读取集中，使用`0`值调用`log`语句，然后继续通过将`myValue`引用添加到其写入集中来增加`myValue`引用。与此同时，另一个事务首先记录了`0`值，然后尝试再次读取`myValue`，并检测到`myValue`处于另一个活动事务的写入集中。第二个事务被回滚，并在第一个事务提交后重试。第二个事务再次读取`myValue`引用，打印`1`，然后增加`myValue`。两个事务都提交了，但由于回滚，副作用性的`log`调用执行了三次。
- en: It might not be harmful to execute a simple `log` statement multiple times,
    but repeating arbitrary side effects can easily break the correctness of a program.
    Avoiding side effects in transactions is a recommended practice.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多次执行简单的`log`语句可能不会造成伤害，但重复任意副作用可能会轻易破坏程序的正确性。在事务中避免副作用是一种推荐的做法。
- en: Recall that an operation is idempotent if executing it multiple times has the
    same effect as executing it once, as discussed in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Programming with Reactive Extensions"), *Concurrent Programming with Reactive
    Extensions*. You might conclude that, if a side-effecting operation is idempotent,
    then it is safe to execute it in a transaction. After all, the worst thing that
    can happen is that the idempotent operation gets executed more than once, right?
    Unfortunately, this reasoning is flawed. After a transaction is rolled back and
    retried, the values of the transactional references might change. The second time
    a transaction is executed, the arguments to the idempotent operation might be
    different, or the idempotent operation might not be invoked at all. The safest
    way to avoid such situations is to avoid external side effects altogether.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，一个操作如果是幂等的，那么多次执行它产生的效果与执行一次相同，正如在[第6章](ch06.html "第6章。使用反应式扩展进行并发编程")中讨论的，*使用反应式扩展进行并发编程*。你可能会得出结论，如果一个有副作用的操作是幂等的，那么在事务中执行它是安全的。毕竟，最坏的情况是幂等操作执行了多次，对吧？不幸的是，这种推理是错误的。在事务回滚并重试后，事务引用的值可能会改变。第二次执行事务时，幂等操作的参数可能不同，或者幂等操作根本不会被调用。避免这种状况的最安全方法是完全避免外部副作用。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid external side effects inside the transactions, as transactions can be
    re-executed multiple times.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务内部避免外部副作用，因为事务可能会被多次执行。
- en: In practice, we usually want to execute a side effect only if the transaction
    commits, that is, after we are sure that the changes to the transactional references
    are visible to other threads. To do this, we use the `Txn` singleton object, which
    can schedule multiple operations that execute after the transaction commits or
    rolls back.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们通常只想在事务提交后执行副作用，也就是说，在我们确定事务引用的更改对其他线程可见之后。为此，我们使用`Txn`单例对象，它可以安排在事务提交或回滚后执行多个操作。
- en: 'After a rollback, these operations are removed, and potentially re-registered
    when retrying the transaction. Its methods can only be called from inside an active
    transaction. In the following code, we rewrite the `inc` method to call the `Txn`
    object''s `afterCommit` method, and schedule the `log` statement to execute after
    the transaction commits:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在回滚后，这些操作会被移除，并且在重试事务时可能会重新注册。它的方法只能在活动事务内部调用。在下面的代码中，我们将`inc`方法重写为调用`Txn`对象的`afterCommit`方法，并安排`log`语句在事务提交后执行：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that we read the `myValue` reference inside the transaction and assign
    the value to a local variable `valueAtStart`. The value of the `valueAtStart`
    local variable is later printed to the standard output. This is different from
    reading the `myValue` reference inside the `afterCommit` block:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在事务内部读取`myValue`引用并将其值赋给局部变量`valueAtStart`。稍后，`valueAtStart`局部变量的值会被打印到标准输出。这与在`afterCommit`块内部读取`myValue`引用不同：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Calling the last version of `inc` fails with an exception. Although the transactional
    context `txn` exists when the `afterCommit` method is called, the `afterCommit`
    block is executed later, after the transaction is already over and the `txn` object
    is no longer valid. It is illegal to read or modify transactional references outside
    a transaction. Before using it in an `afterCommit` block, we need to store the
    value of the transactional reference into a local variable in the transaction
    itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`inc`的最后一个版本会抛出异常。尽管在调用`afterCommit`方法时存在事务上下文`txn`，但`afterCommit`块是在事务结束后才执行，此时`txn`对象已经不再有效。在事务外部读取或修改事务引用是不合法的。在使用它之前，我们需要将事务引用的值存储到事务本身中的局部变量中。
- en: Why does accessing a transactional reference inside the `afterCommit` block
    only fail at runtime, when the transaction executes, instead of failing during
    compilation? The `afterCommit` method is in the **static scope** of the transaction,
    or, in other words is statically nested within an `atomic` statement. For this
    reason, the compiler resolves the `txn` object of the transaction, and allows
    you to access the transactional references, such as `myValue`. However, the `afterCommit`
    block is not executed in the dynamic scope of the transaction. In other words,
    the `afterCommit` block is run *after* the `atomic` block returns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在`afterCommit`块内访问事务引用仅在运行时失败，当事务执行时，而不是在编译时失败？`afterCommit`方法位于事务的**静态作用域**中，换句话说，它是静态地嵌套在一个`atomic`语句中的。因此，编译器解析事务的`txn`对象，并允许你访问事务引用，例如`myValue`。然而，`afterCommit`块不在事务的动态作用域中执行。换句话说，`afterCommit`块是在`atomic`块返回后运行的。
- en: By contrast, accessing a transactional reference outside of the `atomic` block
    is not in the static scope of a transaction, so the compiler detects this and
    reports an error.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在`atomic`块外部访问事务引用不在事务的静态作用域中，因此编译器会检测到这一点并报告错误。
- en: In general, the `InTxn` objects must not escape the transaction block. For example,
    it is not legal to start an asynchronous operation from within the transaction,
    and use the `InTxn` object to access transactional references.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`InTxn`对象不得从事务块中逃逸。例如，在事务内部启动异步操作并使用`InTxn`对象访问事务引用是不合法的。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Only use the transactional context within the thread that started the transaction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 只在启动事务的线程中使用事务上下文。
- en: 'In some cases, we want to execute some side-effecting operations when a rollback
    occurs. For instance, we would like to log each rollback to track the contention
    in our program. This information can help us restructure the program and eliminate
    potential performance bottlenecks. To achieve this, we use the `afterRollback`
    method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望在回滚发生时执行一些副作用操作。例如，我们可能希望记录每次回滚以跟踪程序中的竞争。这些信息可以帮助我们重构程序并消除潜在的性能瓶颈。为了实现这一点，我们使用`afterRollback`方法：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Importantly, after a rollback, the transaction is no longer under way. Just
    as in the `afterCommit` blocks, it is illegal to access the transactional references
    in the `afterRollback` blocks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，在回滚之后，事务不再进行中。就像在`afterCommit`块中一样，在`afterRollback`块中访问事务引用是不合法的。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `Txn` object's `afterCommit` and `afterRollback` methods to perform
    side-effecting operations in transactions without the danger of executing them
    multiple times.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Txn`对象的`afterCommit`和`afterRollback`方法在事务中执行副作用操作，而不用担心它们会多次执行。
- en: Not all side-effecting operations inside the transactions are bad. As long as
    the side effects are confined to mutating objects that are created inside the
    transaction, we are free to use them. In fact, such side effects are sometimes
    necessary. To demonstrate this, let's define the `Node` class for a transactional
    linked list collection. A transactional list is a concurrent, thread-safe linked
    list that is modified using memory transactions. Similar to a functional cons
    list, represented by the `List` class in Scala, the transactional `Node` class
    contains two fields that we call `elem` and `next`. The `elem` field contains
    the value of the current node. To keep things simple, the `elem` field is a value
    field and can only contain integers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有在事务内部产生副作用的操作都是不好的。只要副作用仅限于在事务内部创建的修改对象，我们就自由地使用它们。实际上，这种副作用有时是必要的。为了演示这一点，让我们定义一个用于事务性链表集合的`Node`类。事务性列表是一个并发、线程安全的链表，它使用内存事务进行修改。类似于Scala中的`List`类表示的函数式cons列表，事务性`Node`类包含两个我们称之为`elem`和`next`的字段。`elem`字段包含当前节点的值。为了保持简单，`elem`字段是一个值字段，只能包含整数。
- en: 'The `next` field is a transactional reference containing the next node in the
    linked list. We can read and modify the `next` field only inside memory transactions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`字段是一个包含链表中下一个节点的事务引用。我们只能在内存事务内部读取和修改`next`字段：'
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We now define a `nodeToString` method, which takes a transactional linked list
    node `n`, and creates a `String` representation of the transactional list starting
    with the `n` node:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义一个`nodeToString`方法，它接受一个事务性链表节点`n`，并创建以`n`节点开始的事务性列表的`String`表示形式：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code snippet, we were careful to confine the side effects
    to objects that were created inside the transaction, in this case, the `StringBuilder`
    object `b`. Had we instantiated the `StringBuilder` object before the transaction
    started, the `nodeToString` method would not work correctly:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们小心地将副作用限制在事务内部创建的对象上，在这种情况下，是`StringBuilder`对象`b`。如果我们是在事务开始之前实例化`StringBuilder`对象，`nodeToString`方法将无法正确工作：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the transaction gets rolled back in the `nodeToStringWrong` example, the
    contents of the `StringBuilder` object are not cleared. The second time a transaction
    runs, it will modify the already existing, non-empty `StringBuilder` object and
    return a string representation that does not correspond to the state of the transactional
    list.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`nodeToStringWrong`示例中事务被回滚，`StringBuilder`对象的内容不会被清除。当事务第二次运行时，它将修改已经存在的、非空的`StringBuilder`对象，并返回一个不对应事务列表状态的字符串表示。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When mutating an object inside a transaction, make sure that the object is created
    inside the transaction and that the reference to it does not escape the scope
    of the transaction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务内部修改对象时，请确保对象是在事务内部创建的，并且对该对象的引用没有超出事务的作用域。
- en: Having seen how to manage side effects inside transactions, we now examine several
    special kinds of transactions and study how to compose smaller transactions into
    larger ones.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了如何在事务内部管理副作用之后，我们现在来探讨几种特殊的交易类型，并研究如何将较小的交易组合成较大的交易。
- en: Single-operation transactions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个操作事务
- en: In some cases, we only want to read or modify a single transactional reference.
    It can be cumbersome to type the `atomic` keyword and the implicit `txn` argument
    just to read a single `Ref` object. To alleviate this, ScalaSTM defines single-operation
    transactions on transactional references. Single-operation transactions are executed
    by calling a single method on a `Ref` object. This method returns a `Ref.View`
    object, which has the same interface as a `Ref` object, but its methods can be
    called from outside a transaction. Each operation on a `Ref.View` object acts
    like a single-operation transaction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们只想读取或修改单个事务引用。为了只读取单个`Ref`对象，输入`atomic`关键字和隐式`txn`参数可能会很麻烦。为了减轻这种不便，ScalaSTM定义了在事务引用上的单个操作事务。单个操作事务通过在`Ref`对象上调用单个方法来执行。此方法返回一个`Ref.View`对象，它具有与`Ref`对象相同的接口，但其方法可以从事务外部调用。对`Ref.View`对象上的每个操作都类似于单个操作事务。
- en: 'Recall the `Node` class for transactional linked lists from the previous section,
    which stored integers in an `elem` field, and the reference to the next node in
    the transactional reference called `next`. Let''s augment `Node` with two linked
    list methods. The `append` method takes a single `Node` argument `n`, and inserts
    `n` after the current node. The `nextNode` method returns the reference to the
    next node, or `null` if the current node is at the end of the list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一节中提到的用于事务链表的`Node`类，它在`elem`字段中存储整数，并在事务引用中称为`next`的下一个节点的引用。让我们给`Node`增加两个链表方法。`append`方法接受一个名为`n`的单个`Node`参数，并在当前节点之后插入`n`。`nextNode`方法返回下一个节点的引用，或者如果当前节点是列表的末尾，则返回`null`：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `nextNode` method does a single-operation transaction. It calls single
    on the `next` transactional reference, and then calls the `apply` method in order
    to obtain the value of the next node. This is equivalent to the following definition:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextNode`方法执行单个操作的事务。它对`next`事务引用调用`single`，然后调用`apply`方法以获取下一个节点的值。这相当于以下定义：'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use our transactional `Node` class to declare a linked list called `nodes`,
    initially containing values `1`, `4`, and `5`, and then concurrently modify it.
    We start two futures `f` and `g`, which call `append` to add nodes with the values
    `2` and `3`, respectively. After the futures complete, we call `nextNode` and
    print the value of the next node. The following code snippet will print the node
    with either the value `2` or `3`, depending on which future completes last:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的事务`Node`类来声明一个名为`nodes`的链表，最初包含值`1`、`4`和`5`，然后并发地修改它。我们启动两个`f`和`g`两个未来，分别调用`append`添加值为`2`和`3`的节点。在`futures`完成之后，我们调用`nextNode`并打印下一个节点的值。以下代码片段将打印值为`2`或`3`的节点，具体取决于哪个`future`最后完成：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also use the `single` method to invoke other transactional reference
    operations. In the following code snippet, we use the `transform` operation to
    define an `appendIfEnd` method on the `Node` class, which appends a node `n` after
    the current node only if the current node is followed by `null`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`single`方法来调用其他事务引用操作。在下面的代码片段中，我们使用`transform`操作在`Node`类上定义了一个`appendIfEnd`方法，该方法仅在当前节点后面跟随`null`时才将节点`n`附加到当前节点：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `transform` operation on a `Ref` object containing the values of type `T`
    takes a transformation function of type `T => T`. It atomically performs a read
    of the transactional reference, applies the transformation function to the current
    value, and writes the new value back. Other single-operation transactions include
    `update`, `compareAndSet`, and `swap` operations. We refer the readers to the
    online documentation to learn their precise semantics.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对包含类型`T`值的`Ref`对象上的`transform`操作需要一个类型为`T => T`的转换函数。它原子地执行对事务引用的读取，将转换函数应用于当前值，并将新值写回。其他单操作事务包括`update`、`compareAndSet`和`swap`操作。我们建议读者查阅在线文档以了解它们的精确语义。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use single-operation transactions for single read, write, and CAS-like operations
    in order to avoid the syntactic boilerplate associated with the `atomic` blocks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单操作事务来执行单次读取、写入和类似CAS的操作，以避免与`atomic`块相关的语法模板。
- en: Single-operation transactions are convenience methods that are easier to type,
    and are possibly more efficient, depending on the underlying STM implementation.
    They can be useful, but as programs grow, we are more interested in building larger
    transactions from simple ones. We will investigate how to do this in the next
    section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单操作事务是方便的方法，输入更简单，并且可能更高效，这取决于底层STM实现。它们可能很有用，但随着程序的扩展，我们更感兴趣的是从简单的事务构建更大的事务。我们将在下一节中探讨如何实现这一点。
- en: Nesting transactions
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务嵌套
- en: Recall from [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the
    Java Memory Model"), *Concurrency on the JVM and the Java Memory Model*, that
    a `synchronized` statement can be nested inside other `synchronized` statements.
    This property is essential when composing programs from multiple software modules.
    For example, a money transfer module in a banking system must call operations
    from a logging module to persist the transactions. Both the modules might internally
    use arbitrary sets of locks, without the knowledge of other modules. An unfortunate
    disadvantage of arbitrarily nested `synchronized` statements is that they allow
    the possibility of a deadlock.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第2章](ch02.html "第2章。JVM和Java内存模型中的并发")，*JVM和Java内存模型中的并发*，其中`synchronized`语句可以嵌套在其他`synchronized`语句中。当从多个软件模块组成程序时，这个特性是必不可少的。例如，银行系统中的货币转账模块必须调用日志模块的操作以持久化事务。这两个模块可能内部使用任意集合的锁，而无需其他模块知道。不幸的是，任意嵌套`synchronized`语句的一个不利之处是它们允许死锁的可能性。
- en: Separate `atomic` statements can also nest arbitrarily. The motivation for this
    is the same as with the `synchronized` statement. A transaction inside a software
    module must be able to invoke operations inside other software modules, which
    themselves might start the transactions. Not having to know about the transactions
    inside an operation allows a better separation between different software components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的`atomic`语句也可以任意嵌套。这种动机与`synchronized`语句相同。软件模块内部的事务必须能够调用其他软件模块内的操作，而这些模块本身可能已经开始事务。不需要了解操作内部的事务使得不同软件组件之间的分离更好。
- en: Let's illustrate this with a concrete example. Recall the `Node` class from
    the previous section, which was used for transactional linked lists. The `Node`
    class was somewhat low-level. We can only call the `append` method to insert new
    nodes after the specified node, and call `nodeToString` on a specific node to
    convert its elements to a `String` object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个具体的例子来说明这一点。回想一下上一节中的`Node`类，它用于事务性链表。`Node`类相对较低级。我们只能调用`append`方法在指定节点之后插入新节点，并且可以在特定节点上调用`nodeToString`将其元素转换为`String`对象。
- en: 'In this section, we define the transactional sorted list class, represented
    by the `TSortedList` class. This class stores integers in ascending order. It
    maintains a single transactional reference `head`, which points to the head of
    the linked list of the `Node` objects. We define the `toString` method on the
    `TSortedList` class to convert its contents into a textual representation. The
    `toString` method needs to read the transactional reference `head`, so it starts
    by creating a new transaction. After reading the value of the `head` transactional
    reference into a local value `headNode`, the `toString` method can reuse the `nodeToString`
    method that we defined earlier:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们定义了事务性排序列表类，由`TSortedList`类表示。这个类按升序存储整数。它维护一个单独的事务性引用`head`，该引用指向`Node`对象链表的头部。我们在`TSortedList`类上定义了`toString`方法，以将其内容转换为文本表示。`toString`方法需要读取事务性引用`head`，因此它首先创建一个新的事务。在将`head`事务性引用的值读取到局部值`headNode`后，`toString`方法可以重用我们之前定义的`nodeToString`方法：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Recall that the `nodeToString` method starts another transaction to read the
    next references in each node. When the `toString` method calls `nodeToString`,
    the second transaction becomes *nested* in the transaction started by `toString`.
    The `atomic` block in the `nodeToString` method does not start a new, separate
    transaction. Instead, the nested transaction becomes a part of the existing transaction.
    This has two important consequences. First, if the nested transaction fails, it
    is not rolled back to the start of its `atomic` block in the `nodeToString` method.
    Instead, it rolls back to the start of the `atomic` block in the `toString` method.
    We say that the start of the transaction is determined by the dynamic scope, rather
    than the static scope. Similarly, the nested transaction does not commit when
    it reaches the end of the `atomic` block in the `nodeToString` method. The changes
    induced by the nested transaction become visible when the initial transaction
    commits. We say that the scope of the transaction is always that of the top-level
    transaction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`nodeToString`方法启动另一个事务以读取每个节点中的下一个引用。当`toString`方法调用`nodeToString`时，第二个事务成为`toString`启动的事务的*嵌套*。`nodeToString`方法中的`atomic`块并没有启动一个新的、独立的交易。相反，嵌套事务成为现有事务的一部分。这有两个重要的后果。首先，如果嵌套事务失败，它不会回滚到`nodeToString`方法中的`atomic`块开始处。相反，它回滚到`toString`方法中的`atomic`块开始处。我们说事务的开始是由动态作用域决定的，而不是静态作用域。同样，嵌套事务在达到`nodeToString`方法中`atomic`块的末尾时不会提交。嵌套事务引起的更改在初始事务提交时变得可见。我们说事务的作用域始终是顶级事务的作用域。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Nested `atomic` blocks result in a transaction that starts when the top-level
    `atomic` block starts, and can commit only after the top-level `atomic` block
    completes. Similarly, rollbacks retry the transaction starting from the top-level
    `atomic` block.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`atomic`块导致的事务在顶级`atomic`块开始时启动，并且只能在顶级`atomic`块完成后提交。同样，回滚会重试从顶级`atomic`块开始的事务。
- en: We now study another example of using nested transactions. Atomically converting
    transactional sorted lists to their string representation is useful, but we also
    need to insert elements in the list. We define the `insert` method, which takes
    an integer and inserts it into a proper position in the transactional list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在研究使用嵌套事务的另一个例子。原子地将事务性排序列表转换为它们的字符串表示是有用的，但我们还需要在列表中插入元素。我们定义了一个`insert`方法，它接受一个整数并将其插入到事务性列表的正确位置。
- en: 'Since `insert` can modify both the transactional reference `head` and the nodes
    in the list, it starts by creating a transaction. It then checks for two special
    cases. A list can be empty, in this case we set `head` to a new node containing
    `x`. Likewise, the `x` integer might be smaller than the first value in the list;
    in which case, the `head` reference is set to a new node containing `x`, and its
    `next` field is set to the previous value of the `head` reference. If neither
    of these conditions applies, we call a tail-recursive, nested method `insert`
    to process the remainder of the list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`insert`可以修改事务性引用`head`和列表中的节点，它首先创建一个事务。然后它检查两个特殊情况。列表可以是空的，在这种情况下我们将`head`设置为包含`x`的新节点。同样，整数`x`可能小于列表中的第一个值；在这种情况下，`head`引用被设置为包含`x`的新节点，并且其`next`字段被设置为`head`引用的前一个值。如果这两个条件都不适用，我们调用一个尾递归的嵌套方法`insert`来处理列表的其余部分：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The nested `insert` method traverses the linked list in order to find the correct
    position for the `x` integer. It takes the current node `n` and checks if the
    node is followed by `null`, indicating the end of the list, or if the next element
    is greater than `x`. In both cases, we call the `append` method on the node. If
    the node following `n` is not `null`, and its `elem` field is less than or equal
    to `x`, we call `insert` recursively on the next node.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`insert`方法按顺序遍历链表以找到整数`x`的正确位置。它获取当前节点`n`并检查该节点是否被`null`跟随，表示列表的末尾，或者下一个元素是否大于`x`。在这两种情况下，我们都会在节点上调用`append`方法。如果跟随`n`的节点不是`null`，并且其`elem`字段小于或等于`x`，我们将在下一个节点上递归调用`insert`。
- en: 'Note that the tail-recursive, nested method `insert` uses the transactional
    context `txn` of the enclosing `atomic` block. We can also define a separate tail-recursive
    method `insert` outside the scope of the transaction. In this case, we need to
    encode the transactional context `txn` as a separate implicit parameter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尾递归的嵌套方法`insert`使用封装的`atomic`块的`txn`事务上下文。我们也可以在事务作用域之外定义一个单独的尾递归方法`insert`。在这种情况下，我们需要将事务上下文`txn`编码为一个单独的隐式参数：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, we can omit the implicit `txn` transactional context parameter,
    but then we have to start a nested transaction inside the tail-recursive `insert`
    method. This might be slightly less efficient than the previous approach, but
    it is semantically equivalent:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以省略隐式的`txn`事务上下文参数，但这样我们就必须在尾递归的`insert`方法内部启动一个嵌套事务。这可能比之前的方法稍微低效一些，但从语义上是等价的：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We test our transactional sorted list with the following snippet. We instantiate
    an empty transactional sorted list and insert several integers concurrently from
    the asynchronous computations `f` and `g`. After both the corresponding futures
    complete execution, we print the contents of the sorted list:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码片段测试我们的事务排序列表。我们实例化一个空的交易排序列表，并从异步计算`f`和`g`中并发插入几个整数。在相应的未来完成执行后，我们打印排序列表的内容：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running the preceding snippet always outputs the elements `1`, `2`, `3`, and
    `4` in the same sorted order, regardless of the execution schedule of the futures.
    We created a thread-safe transactional sorted list class, and the implementation
    is almost identical to the corresponding sequential sorted list implementation.
    This example shows the true potential of STM. It allows you to create concurrent
    data structures and thread-safe data models without having to worry too much about
    concurrency.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段始终以相同的排序顺序输出元素`1`、`2`、`3`和`4`，无论未来的执行调度如何。我们创建了一个线程安全的事务排序列表类，其实现几乎与相应的顺序排序列表实现相同。这个例子展示了STM的真正潜力。它允许你创建并发数据结构和线程安全的数据模型，而无需过多担心并发问题。
- en: There is one more aspect of transactions that we have not yet considered. What
    happens if a transaction fails due to an exception? For example, the tail-recursive
    `insert` method can get called with a `null` value instead of a valid `Node` reference.
    This results in throwing a `NullPointerException`, but how does it affect the
    transaction? We will explore the exception semantics of the transactions in the
    following section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 交易还有一个方面我们尚未考虑。如果交易因异常而失败会怎样？例如，尾递归的`insert`方法可能会接收到一个`null`值而不是有效的`Node`引用。这会导致抛出`NullPointerException`，但它会如何影响交易？我们将在下一节探讨交易的异常语义。
- en: Transactions and exceptions
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易和异常
- en: From what we've learned about transactions so far, it is not clear what happens
    with a transaction if it throws an exception. An exception could roll back the
    transaction, or it could commit its changes. ScalaSTM does a rollback, by default,
    but this behavior can be overridden.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们到目前为止对事务的了解，如果事务抛出异常，不清楚会发生什么。异常可能会回滚事务，或者它可能会提交其更改。ScalaSTM默认执行回滚，但此行为可以被覆盖。
- en: Let's assume that the clients of our transactional sorted list want to use it
    as a concurrent priority queue. A *priority queue* is a collection that contains
    ordered elements, such as integers. An arbitrary element can be inserted into
    a priority queue using the `insert` method. At each point, we can retrieve the
    smallest element currently in the priority queue using the `head` method. The
    priority queue also allows you to remove the smallest element with the `pop` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的事务排序列表的客户端希望将其用作并发优先队列。*优先队列*是一个包含有序元素的集合，例如整数。可以使用`insert`方法将任意元素插入到优先队列中。在任意时刻，我们可以使用`head`方法检索优先队列中当前最小的元素。优先队列还允许您使用`pop`方法移除最小的元素。
- en: 'The transactional sorted list is already sorted and supports element insertion
    with the `insert` method, however, once added, elements cannot be removed. To
    make our transactional sorted list usable as a priority queue, we define a `pop`
    method, which removes the first `n` elements from a transactional list `xs`. We
    start a transaction inside the `pop` method, and declare a local variable `left`,
    initializing it with the number of removed elements `n`. We then use a `while`
    loop to remove nodes from `head` and decrease the `left` variable until it becomes
    0:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事务排序列表已经排序，并支持使用`insert`方法插入元素，然而，一旦添加，元素就不能被移除。为了使我们的事务排序列表可以作为优先队列使用，我们定义了一个`pop`方法，该方法从事务列表`xs`中移除前`n`个元素。我们在`pop`方法内部启动一个事务，并声明一个局部变量`left`，将其初始化为移除的元素数量`n`。然后我们使用一个`while`循环从`head`中移除节点并减少`left`变量，直到它变为0：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To test the `pop` method, we declare a new transactional list `lst`, and insert
    integers `4`, `9`, `1`, and `16`. The list is sorted, so the integers appear in
    the list in the order `1`, `4`, `9`, and `16`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`pop`方法，我们声明了一个新的事务列表`lst`，并插入整数`4`、`9`、`1`和`16`。列表已排序，因此整数按顺序`1`、`4`、`9`和`16`出现在列表中：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we start an asynchronous computation that removes the first two integers
    in the list by calling `pop`. After the asynchronous computation is successfully
    completed, we print the contents of the transactional list to the standard output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用`pop`来启动一个异步计算，该计算从列表中移除前两个整数。异步计算成功完成后，我们将事务列表的内容打印到标准输出：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So far, so good. The `log` statement outputs the list with the elements `9`
    and `16`. We proceed by starting another asynchronous computation, which removes
    the first three elements from the transactional list:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。`log`语句输出了包含元素`9`和`16`的列表。我们继续启动另一个异步计算，该计算从事务列表中移除前三个元素：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, when we call the `pop` method again, it throws a `NullPointerException`;
    there are only two elements left in the transactional list. As a result, the reference
    `head` is eventually assigned `null` during the transaction. When the `pop` method
    tries to call `next` on `null`, an exception is thrown.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们再次调用`pop`方法时，它抛出了`NullPointerException`；事务列表中只剩下两个元素。因此，在事务期间，`head`引用最终被分配为`null`。当`pop`方法尝试在`null`上调用`next`时，会抛出异常。
- en: In the `onComplete` callback, we output the name of the exception and the contents
    of the transactional list. It turns out that the transactional list still contains
    the elements `9` and `16`, although the `head` reference of the transactional
    list had been set to `null` in the transaction. When an exception is thrown, the
    effects of the transaction are reverted.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onComplete`回调中，我们输出异常的名称和事务列表的内容。结果发现，事务列表仍然包含元素`9`和`16`，尽管在事务中已将事务列表的`head`引用设置为`null`。当抛出异常时，事务的效果会被撤销。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When an exception is thrown inside a transaction, the transaction is rolled
    back and the exception is rethrown at the point where the top-level `atomic` block
    started.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当事务内部抛出异常时，事务会被回滚，并且异常会在顶级`atomic`块开始的地方重新抛出。
- en: 'Importantly, the nested transactions are also rolled back. In the following
    code snippet, the nested `atomic` block in the `pop` method completes successfully,
    but its changes are not committed. Instead, the entire transaction is rolled back
    when the `sys.error` call throws a `RuntimeException` in the enclosing top-level
    `atomic` block:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，嵌套事务也会回滚。在下面的代码片段中，`pop`方法中的嵌套`atomic`块成功完成，但其更改并未提交。相反，当在封装的顶级`atomic`块中调用`sys.error`并抛出`RuntimeException`时，整个事务被回滚：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unlike ScalaSTM, some other STM implementations do not roll back transactions
    when an exception is thrown; instead, they commit the transaction. STM experts
    have not yet reached a consensus on what the exception semantics should be. ScalaSTM
    uses a hybrid approach. Most exceptions roll back the transaction, but Scala's
    **control exceptions** are excluded from this rule. Control exceptions are exceptions
    that are used for control flow in Scala programs. They extend the `ControlThrowable`
    trait from the `scala.util.control` package, and are sometimes treated differently
    by the Scala compiler and runtime. When a control exception is thrown inside a
    transaction, ScalaSTM does not roll back the transaction. Instead, the transaction
    is committed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ScalaSTM 不同，一些其他 STM 实现不会在抛出异常时回滚事务；相反，它们提交事务。STM 专家尚未就异常语义达成共识。ScalaSTM 使用一种混合方法。大多数异常都会回滚事务，但
    Scala 的 **控制异常** 除外。控制异常是在 Scala 程序中用于控制流的异常。它们扩展了来自 `scala.util.control` 包的 `ControlThrowable`
    特质，并且有时会被 Scala 编译器和运行时以不同的方式处理。当在事务内部抛出控制异常时，ScalaSTM 不会回滚事务。相反，事务将被提交。
- en: 'Control exceptions are used to support the `break` statement in Scala, which
    is not a native language construct. The `break` statement throws a control exception,
    which is then caught by the enclosing breakable block. In the next example, we
    define a breakable block for the `break` statement and start a transaction that
    calls `pop` in a `for` loop with the values `1`, `2`, and `3`. After the first
    iteration, we break the loop. The example shows that the changes in the first
    `pop` statement are committed. The transactional list now contains only the element
    `16`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 控制异常用于在 Scala 中支持 `break` 语句，这不是一种原生语言结构。`break` 语句抛出一个控制异常，然后被包围的 `breakable`
    块捕获。在下一个示例中，我们为 `break` 语句定义了一个 `breakable` 块，并启动了一个调用 `pop` 的 `for` 循环，循环的值为
    `1`、`2` 和 `3`。在第一次迭代后，我们中断循环。示例显示第一次 `pop` 语句中的更改已被提交。事务列表现在只包含元素 `16`：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Furthermore, it is possible to override how a specific transaction handles exceptions
    by calling the `withControlFlowRecognizer` method on the atomic block. This method
    takes a partial function from `Throwable` to `Boolean`, and uses it to decide
    whether a particular exception is to be considered as a control exception or not.
    If the partial function is not defined for particular exception, the decision
    is deferred to the default control flow recognizer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以通过在原子块上调用 `withControlFlowRecognizer` 方法来覆盖特定事务如何处理异常。此方法接受一个从 `Throwable`
    到 `Boolean` 的部分函数，并使用它来决定是否将特定异常视为控制异常。如果部分函数未定义特定异常，则决定将推迟到默认控制流识别器。
- en: 'In the following example, the `atomic` block overrides the default control
    flow recognizer. For this specific transaction, subclasses of the `ControlThrowable`
    trait are considered as regular exceptions. The `pop` call removes the last element
    of the transactional list as part of this transaction, but when we call `break`;
    the transaction is rolled back. The `log` statement at the end of the asynchronous
    computation shows that the list still contains the number `16`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`atomic` 块覆盖了默认的控制流识别器。对于这个特定的交易，`ControlThrowable` 特质的子类被视为常规异常。`pop`
    调用作为此交易的一部分移除了事务列表的最后一个元素，但当调用 `break` 时，事务将被回滚。异步计算结束时的 `log` 语句显示列表仍然包含数字 `16`：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that the exceptions thrown inside the transactions can also be intercepted
    using the `catch` statement. In this case, the effects of the nested transactions
    are aborted, and the execution proceeds from the point where the exception was
    caught. In the following example, we catch the exception thrown by the second
    `pop` call:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，事务内部抛出的异常也可以使用 `catch` 语句来拦截。在这种情况下，嵌套事务的效果将被中止，并且执行将从捕获异常的点继续。在以下示例中，我们捕获了第二次
    `pop` 调用抛出的异常：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second `pop` method call should not remove any elements from the list,
    so we expect to see the element `16` at the end. Running this code snippet results
    in the following output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次 `pop` 方法调用不应从列表中移除任何元素，因此我们预计在最后看到元素 `16`。运行此代码片段的结果如下：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Interestingly, the output reveals that the first `log` statement is invoked
    twice. The reason is that, when the exception is thrown the first time, both the
    nested and the top-level transactions are rolled back. This is an optimization
    in the ScalaSTM implementation, since it is more efficient to flatten the nested
    and the top-level transaction during the first execution attempt. Note that, after
    the transactional block is executed the second time, the exception from the nested
    transaction is correctly handled.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，输出显示第一条`log`语句被调用了两次。原因是，当第一次抛出异常时，嵌套和顶级事务都被回滚。这是ScalaSTM实现中的优化，因为在第一次执行尝试期间，将嵌套和顶级事务扁平化更有效率。请注意，在事务块第二次执行后，嵌套事务的异常被正确处理。
- en: These examples are useful in understanding the semantics of exceptions inside
    the transactions. Still, the clients of our transactional sorted list want more
    than an exception when they call the `pop` method on an empty sorted list. In
    some cases, like the producer-consumer pattern from [Chapter 3](ch03.html "Chapter 3. Traditional
    Building Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*,
    a thread has to wait and repeat the transaction when the sorted list becomes non-empty.
    This is called retrying, and is the topic of the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例有助于理解事务内异常的语义。尽管如此，当客户端在空排序列表上调用`pop`方法时，他们想要的不仅仅是异常。在某些情况下，例如[第3章](ch03.html
    "第3章. 并发传统构建块")中的生产者-消费者模式，*并发的传统构建块*，当排序列表变为非空时，线程必须等待并重复事务。这被称为重试，也是下一节的主题。
- en: Retrying transactions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试事务
- en: In sequential computing, a single thread is responsible for executing the program.
    If a specific value is not available, the single thread is responsible for producing
    it. In concurrent programming, the situation is different. When a value is not
    available, some other thread, called a **producer**, might eventually produce
    the value. The thread consuming the value, called a **consumer**, can either block
    the execution until the value becomes available, or temporarily execute some other
    work before checking for the value again. We have seen various mechanisms for
    achieving this relationship, ranging from monitors and the `synchronized` statement
    from [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*, concurrent queues
    from [Chapter 3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"),
    *Traditional Building Blocks of Concurrency*; futures and promises in [Chapter
    4](ch04.html "Chapter 4.  Asynchronous Programming with Futures and Promises"),
    *Asynchronous Programming with Futures and Promises*; to event-streams in [Chapter
    6](ch06.html "Chapter 6. Concurrent Programming with Reactive Extensions"), *Concurrent
    Programming with Reactive Extensions*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序计算中，单个线程负责执行程序。如果某个特定值不可用，单个线程负责生成它。在并发编程中，情况则不同。当某个值不可用时，其他线程，称为**生产者**，可能会最终生成该值。消费该值的线程，称为**消费者**，可以选择阻塞执行直到该值可用，或者在进行下一次检查之前临时执行其他工作。我们已经看到了实现这种关系的各种机制，从[第2章](ch02.html
    "第2章. JVM和Java内存模型中的并发")中的监控器和`synchronized`语句，*JVM和Java内存模型中的并发*，[第3章](ch03.html
    "第3章. 并发传统构建块")中的并发队列，*并发的传统构建块*；[第4章](ch04.html "第4章. 使用Future和Promise的异步编程")中的Future和Promise，*使用Future和Promise的异步编程*；到[第6章](ch06.html
    "第6章. 使用响应式扩展的并发编程")中的事件流，*使用响应式扩展的并发编程*。
- en: Syntactically, the `atomic` statement best corresponds to the `synchronized`
    statement. Recall that the `synchronized` statement support the guarded block
    pattern, in which the thread acquires a monitor, checks for some condition, and
    then calls `wait` on the monitor. When some other thread fulfills this condition,
    it calls the `notify` method on the same monitor, indicating that the first thread
    should wake up and continue its work. Although sometimes fragile, this mechanism
    allows us to circumvent busy-waiting.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法上，`atomic`语句最符合`synchronized`语句。回想一下，`synchronized`语句支持受保护的块模式，其中线程获取一个监控器，检查某个条件，然后在该监控器上调用`wait`。当其他线程满足这个条件时，它会在同一个监控器上调用`notify`方法，表示第一个线程应该醒来并继续其工作。尽管有时可能脆弱，但这种机制允许我们绕过忙等待。
- en: 'From what we have learned about STMs so far, monitors and the `notify` method
    have no direct counterpart in the `atomic` statement. Without them, busy-waiting
    is the only option when a transaction needs to wait for a specific condition to
    proceed. To illustrate this, let''s consider the transactional sorted lists from
    the last section. We would like to augment the transactional sorted lists with
    the `headWait` method which takes a list and returns the first integer in the
    list if the list is non-empty. Otherwise, the execution should block until the
    list becomes non-empty:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们从STM中学到的知识表明，监视器和`notify`方法在`atomic`语句中没有直接的对应物。没有它们，当事务需要等待特定条件继续时，忙等待是唯一的选择。为了说明这一点，让我们考虑上一节中的事务排序列表。我们希望增强事务排序列表，添加一个`headWait`方法，该方法接受一个列表并返回列表中的第一个整数，如果列表非空。否则，执行应阻塞，直到列表变为非空：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `headWait` method starts a transaction, and busy-waits until the `head`
    reference of the transactional list `lst` becomes different from `null`. To test
    this method, we create an empty transaction sorted list, and start an asynchronous
    computation that calls the `headWait` method. After one second, we start another
    asynchronous computation that adds the number `1` to the list. During the one-second
    delay, the first asynchronous computation repetitively busy-waits:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`headWait`方法启动一个事务，并忙等待直到事务列表`lst`的`head`引用与`null`不同。为了测试这个方法，我们创建了一个空的交易排序列表，并启动一个异步计算，该计算调用`headWait`方法。一秒后，我们开始另一个异步计算，将数字`1`添加到列表中。在这秒的延迟期间，第一个异步计算反复忙等待：'
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first time we ran this example, it completed successfully after one second
    and reported that the first element of the list is `1`. However, this example
    is likely to fail. ScalaSTM will eventually detect that there is a conflict between
    the transaction in the `headWait` method and the transaction in the `insert` method,
    and will serialize the two transactions. In the case where the STM chooses the
    `headWait` method to execute first, number `1` is never inserted into `myList`
    value. Effectively, this program ends up in a deadlock. This example illustrates
    that busy-waiting in a transaction is just as bad as busy-waiting inside a `synchronized`
    statement.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行这个示例时，它在一秒后成功完成，并报告列表的第一个元素是`1`。然而，这个示例很可能会失败。ScalaSTM最终会检测到`headWait`方法中的事务与`insert`方法中的事务之间存在冲突，并将这两个事务序列化。在这种情况下，如果STM选择首先执行`headWait`方法，数字`1`将永远不会插入到`myList`值中。实际上，这个程序最终会陷入死锁。这个示例说明，在事务中进行忙等待与在`synchronized`语句中进行忙等待一样糟糕。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Avoid long-running transactions whenever possible. Never execute an infinite
    loop inside a transaction, as it can cause deadlocks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能避免长时间运行的事务。绝不要在事务中执行无限循环，因为这可能导致死锁。
- en: An STM is more than just support for executing isolated memory transactions.
    To fully replace monitors and the `synchronized` statement, an STM must provide
    an additional utility for transactions that block until a specific condition is
    fulfilled. ScalaSTM defines the `retry` statement for this purpose. When the execution
    inside the transaction reaches a `retry` statement, the transaction is rolled
    back to the enclosing top-level `atomic` block with a special exception, and the
    calling thread is blocked. After the rollback, the read set of the transaction
    is saved.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: STM不仅仅是支持执行隔离的内存事务。为了完全取代监视器和`synchronized`语句，STM必须为需要等待特定条件满足的事务提供额外的实用工具。ScalaSTM定义了`retry`语句来达到这个目的。当事务内部的执行达到`retry`语句时，事务会回滚到包含它的顶级`atomic`块，并抛出一个特殊异常，调用线程将被阻塞。回滚后，事务的读取集被保存。
- en: Values from the transactional references in the read set are the reason why
    the transaction decides to call the `retry` method. If and when some transactional
    reference in the read set changes its value from within another transaction, the
    blocked transaction can be retried.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 读取集中的事务引用的值是事务决定调用`retry`方法的原因。如果读取集中的某个事务引用在另一个事务中更改其值，则阻塞的事务可以重试。
- en: 'We now reimplement the `headWait` method so that it calls the `retry` method
    if the `head` value of the transactional list is `null`, indicating that the list
    is empty:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在重新实现`headWait`方法，使其在事务列表的`head`值为`null`（表示列表为空）时调用`retry`方法：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We rerun the complete program. Calling the `headWait` method is a potential
    blocking operation, so we need to use the `blocking` call inside the asynchronous
    computation. The transaction in `headWait` reads the transactional reference `head`,
    and puts it into the read set after calling the `retry` method. When the reference
    `head` later changes, the transaction is automatically retried:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新运行整个程序。调用`headWait`方法是一个潜在的阻塞操作，因此我们需要在异步计算中使用`blocking`调用。`headWait`中的事务读取事务性引用`head`，并在调用`retry`方法后将它放入读集中。当引用`head`稍后发生变化时，事务会自动重试：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This time, the program runs as expected. The first asynchronous computation
    is suspended until the second asynchronous computation adds `1` to the list. This
    awakens the first asynchronous computation and repeats the transaction.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，程序按预期运行。第一次异步计算被暂停，直到第二次异步计算将`1`添加到列表中。这唤醒了第一次异步计算并重复了事务。
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `retry` statement to block the transaction until a specific condition
    is fulfilled, and retry the transaction automatically once its read set changes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`retry`语句阻塞事务，直到满足特定条件，一旦其读集发生变化，则自动重试事务。
- en: In some cases, when a specific condition is not fulfilled and the transaction
    cannot proceed, we would like to retry a different transaction. Assume that there
    are many producer threads in the program, and a single consumer thread. To decrease
    contention between the producers, we decide to introduce two transactional sorted
    lists called `queue1` and `queue2`. To avoid creating contention by simultaneously
    accessing both lists, the consumer thread must check the contents of these transactional
    sorted lists in two separate transactions. The `orAtomic` construct allows you
    to do this.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当特定条件未满足且事务无法进行时，我们希望重试不同的交易。假设程序中有许多生产者线程和一个单独的消费者线程。为了减少生产者之间的竞争，我们决定引入两个名为`queue1`和`queue2`的交易性排序列表。为了避免同时访问这两个列表而造成的竞争，消费者线程必须分别检查这两个交易性排序列表的内容。`orAtomic`构造允许你这样做。
- en: The following snippet illustrates how to use `orAtomic` in this situation. We
    instantiate two empty transactional sorted lists: `queue1` and `queue2`. We then
    start an asynchronous computation that represents the consumer and starts a transaction
    that calls the `headWait` method on the `queue1` list. We call the `orAtomic`
    method after the first transaction. This specifies an alternative transaction
    if the first transaction calls `retry`. In the `orAtomic` block, we call the `headWait`
    method on the `queue2` list. When the first `atomic` block calls the `retry` method,
    the control is passed to the `orAtomic` block, and a different transaction starts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了如何在这种情况下使用`orAtomic`。我们实例化了两个空的交易性排序列表：`queue1`和`queue2`。然后我们启动一个异步计算，代表消费者，并开始一个调用`queue1`列表上的`headWait`方法的事务。我们在第一次事务之后调用`orAtomic`方法。这指定了如果第一次事务调用`retry`时的替代事务。在`orAtomic`块中，我们在`queue2`列表上调用`headWait`方法。当第一个`atomic`块调用`retry`方法时，控制权传递给`orAtomic`块，并开始不同的交易。
- en: 'Since both the transactional lists, `queue1` and `queue2`, are initially empty,
    the second transaction also calls the `retry` method, and the transaction chain
    is blocked until one of the transactional lists changes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交易性列表`queue1`和`queue2`最初都是空的，第二次事务也调用`retry`方法，事务链被阻塞，直到其中一个交易性列表发生变化：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We now simulate several producers that call the `insert` method 50 milliseconds
    later:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在模拟几个在50毫秒后调用`insert`方法的生成者：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The consumer first prints the `"probing queue1"` string, calls the `retry` method
    inside the `headWait` method, and proceeds to the next transaction. It prints
    the `"probing queue2"` string in the same way and then blocks its execution. After
    the first producer computation inserts `2` into the second transactional list,
    the consumer retries the chain of transactions again. It attempts to execute the
    first transaction and prints the `"probing queue1"` string again before finding
    that the `queue1` list is empty. It then prints the `"probing queue2"` string
    and successfully outputs the element `2` from the `queue2` list.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者首先打印`"probing queue1"`字符串，在`headWait`方法内部调用`retry`方法，然后继续下一个事务。它以相同的方式打印`"probing
    queue2"`字符串，然后阻塞其执行。在第一个生成者计算将`2`插入第二个交易性列表后，消费者再次重试事务链。它尝试执行第一个事务，并再次打印`"probing
    queue1"`字符串，然后发现`queue1`列表为空。然后它打印`"probing queue2"`字符串并成功从`queue2`列表输出元素`2`。
- en: Retrying with timeouts
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带超时的重试
- en: We have seen that it is useful to suspend a transaction until a specific condition
    gets fulfilled. In some cases, we want to prevent a transaction from being blocked
    forever. The `wait` method on the object monitors comes with an overload that
    takes the timeout argument. When the timeout elapses without a `notify` call from
    some other thread, an `InterruptedException` is thrown. The ScalaSTM `withRetryTimeout`
    method is a similar mechanism for handling timeouts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在某些情况下，挂起事务直到特定条件得到满足是有用的。在某些情况下，我们希望防止事务永远被阻塞。对象监视器的`wait`方法提供了一个带有超时参数的重载。当超时到期而没有其他线程的`notify`调用时，会抛出`InterruptedException`。ScalaSTM的`withRetryTimeout`方法是一个类似的机制，用于处理超时。
- en: 'In the following code snippet, we create a `message` transactional reference
    that initially contains an empty string. We then start an `atomic` block whose
    timeout is set to `1000` milliseconds. If the `message` transactional reference
    does not change its value within that time, the transaction fails by throwing
    an `InterruptedException`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们创建了一个包含空字符串的`message`事务性引用。然后我们启动一个超时设置为`1000`毫秒的`atomic`块。如果在那个时间内`message`事务性引用没有改变其值，事务将通过抛出`InterruptedException`来失败：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We deliberately set the timeout to `1025` milliseconds to create a race condition.
    This program will either print the `"Howdy!"` message or fail with an exception.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将超时设置为`1025`毫秒以创建一个竞争条件。这个程序要么打印出`"Howdy!"`消息，要么因异常而失败。
- en: We use the `withRetryTimeout` method when timing out is an exceptional behavior.
    Shutting down the application is one example of such a behavior. We want to avoid
    having a blocked transaction that prevents the program from terminating. Another
    example is waiting for a network reply. If there is no reply after some duration
    of time, we want to fail the transaction.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当超时是异常行为时，我们使用`withRetryTimeout`方法。例如，关闭应用程序就是这种行为之一。我们希望避免出现阻塞事务，从而阻止程序终止。另一个例子是等待网络响应。如果在一段时间后没有响应，我们希望使事务失败。
- en: 'In some cases, a timeout is a part of a normal program behavior. In this case,
    we wait for a specific amount of time for conditions relevant to the transaction
    to change. If they do, we roll back and retry the transaction, as before. If the
    specified amount of time elapses without any changes, the transaction should continue.
    In ScalaSTM, the method that does this is called `retryFor`. In the following
    code snippet, we rewrite the previous example using the `retryFor` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，超时是正常程序行为的一部分。在这种情况下，我们等待一段时间，以使与事务相关的条件发生变化。如果它们确实发生了变化，我们将回滚并重试事务，就像之前一样。如果在指定的时间内没有任何变化，事务应该继续。在ScalaSTM中，执行此操作的方法称为`retryFor`。在下面的代码片段中，我们使用`retryFor`方法重写了之前的示例：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This time, the transaction inside the asynchronous computation does not throw
    an exception. Instead, the transaction prints the `"no message."` string if a
    timeout occurs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，异步计算内部的事务没有抛出异常。相反，如果发生超时，事务将打印出`"no message."`字符串。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When a timeout represents exceptional program behavior, use the `withRetryTimeout`
    method to set the timeout duration in the transaction. When the transaction proceeds
    normally after a timeout, use the `retryFor` method.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当超时表示程序行为异常时，使用`withRetryTimeout`方法在事务中设置超时持续时间。当事务在超时后正常进行时，使用`retryFor`方法。
- en: The different `retry` variants are the ScalaSTM powerful additions to the standard
    STM model. They are as expressive as the `wait` and `notify` calls, and much safer
    to use. Together with the `atomic` statement, they unleash the full potential
    of synchronization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的`retry`变体是ScalaSTM对标准STM模型的强大补充。它们与`wait`和`notify`调用一样表达性强，并且使用起来更安全。与`atomic`语句一起，它们释放了同步的全部潜力。
- en: Transactional collections
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务性集合
- en: In this section, we take a step away from transactional references, and study
    more powerful transactional constructs, called, transactional collections. While
    transactional references can only hold a single value at once, transactional collections
    can manipulate multiple values. In principle, the `atomic` statements and transactional
    references are sufficient to express any kind of transaction over shared data.
    However, ScalaSTM's transactional collections are deeply integrated with the STM.
    They can be used to express shared data operations more conveniently and execute
    the transactions more efficiently.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们暂时离开事务引用，研究更强大的事务构造，称为事务集合。虽然事务引用一次只能保持一个值，但事务集合可以操作多个值。原则上，`atomic`语句和事务引用足以表达任何类型的共享数据事务。然而，ScalaSTM的事务集合与STM深度集成。它们可以更方便地表达共享数据操作并更有效地执行事务。
- en: Transaction-local variables
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务局部变量
- en: We have already seen that some transactions need to create a local mutable state
    that exists only during the execution of the transaction. Sometimes, we need to
    re-declare the same state over and over again for multiple transactions. In such
    cases, we would like to declare the same state once, and reuse it in multiple
    transactions. A construct that supports this in ScalaSTM is called a **transaction-local
    variable**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，某些事务需要在事务执行期间仅存在的本地可变状态中创建。有时，我们需要为多个事务反复重新声明相同的状态。在这种情况下，我们希望只声明一次相同的状态，并在多个事务中重用它。在ScalaSTM中支持此功能的构造称为**事务局部变量**。
- en: 'To declare a transaction-local variable, we instantiate an object of the `TxnLocal[T]`
    type, giving it an initial value of type `T`. In the following code, we instantiate
    a `myLog` transaction-local variable. We will use `myLog` inside the transactional
    sorted list operations to log the flow of different transactions:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个事务局部变量，我们实例化一个`TxnLocal[T]`类型的对象，给它一个类型为`T`的初始值。在下面的代码中，我们实例化了一个`myLog`事务局部变量。我们将在事务排序列表操作中使用`myLog`来记录不同事务的流程：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The value of the `myLog` transaction-local variable is seen separately by each
    transaction. When a transaction starts, the value of `myLog` is equal to an empty
    string, as specified when `myLog` was declared. When the transaction updates the
    value of the `myLog` variable, this change is only visible to that specific transaction.
    Other transactions behave as if they have their own separate copies of `myLog`
    variable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事务单独看到`myLog`事务局部变量的值。当事务开始时，`myLog`的值等于声明`myLog`时指定的空字符串。当事务更新`myLog`变量的值时，这种更改仅对该特定事务可见。其他事务的行为就像它们有自己的`myLog`变量单独副本一样。
- en: 'We now declare a `clearList` method that atomically removes all elements from
    the specified transactional sorted list. This method uses the `myLog` variable
    to log the elements that were removed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在声明一个`clearList`方法，该方法原子性地从指定的事务排序列表中移除所有元素。此方法使用`myLog`变量来记录被移除的元素：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Usually, we are not interested in the contents of the `myLog` variable. However,
    we might occasionally want to inspect the `myLog` variable for debugging purposes.
    Hence, we declare the `clearWithLog` method that clears the list and then returns
    the contents of `myLog`. We then call the `clearWithLog` method on a non-empty
    transactional list from two separate asynchronous computations. After both asynchronous
    computations complete execution, we output their logs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们对`myLog`变量的内容不感兴趣。然而，我们可能偶尔想检查`myLog`变量以进行调试。因此，我们声明了`clearWithLog`方法，该方法清除列表并返回`myLog`的内容。然后，我们从两个不同的异步计算中调用`clearWithLog`方法，对非空事务列表进行操作。在两个异步计算完成执行后，我们输出它们的日志：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Since the `clearList` operation is atomic, only one of the transactions can
    remove all the elements. The contents of the `myLog` object reflect this. Depending
    on the timing between the asynchronous computations, elements `14` and `22` both
    appear either in the log of the `f` future or in the log of the `g` future. This
    shows that each of the two transactions sees a separate duplicate of the `myLog`
    variable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`clearList`操作是原子的，只有一个事务可以移除所有元素。`myLog`对象的内容反映了这一点。根据异步计算之间的时机，元素`14`和`22`都出现在`f`未来的日志中或`g`未来的日志中。这表明两个事务中的每一个都看到了`myLog`变量的单独副本。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Transaction-local variables are syntactically more lightweight than creating
    transactional references and passing them between different methods.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 事务局部变量在语法上比创建事务引用并在不同方法之间传递它们更轻量级。
- en: Transaction-local variables are used while logging or gathering statistics on
    the execution of the program. The `TxnLocal` constructor additionally allows you
    to specify the `afterCommit` and `afterRollback` callbacks, invoked on the transaction-local
    variable when the transaction commits or rolls back, respectively. We refer the
    reader to the online documentation to find out how to use them. To build more
    complex concurrent data models, we use transactional arrays and maps, which we
    will study in the next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录或收集程序执行统计信息时使用事务局部变量。`TxnLocal`构造函数还允许您指定`afterCommit`和`afterRollback`回调，分别在事务提交或回滚时调用事务局部变量。我们建议读者查阅在线文档以了解如何使用它们。为了构建更复杂的同时数据模型，我们使用事务数组和映射，我们将在下一节中学习。
- en: Transactional arrays
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务数组
- en: Transactional references are a handy way to encapsulate a transactional state,
    but they come with certain overheads. First, a `Ref` object is more heavyweight
    than a simple object reference and consumes more memory. Second, every access
    to a new `Ref` object needs to add an entry in the transaction's read set. When
    we are dealing with many `Ref` objects, these overheads can become substantial.
    Let's illustrate this with an example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 事务引用是一种方便的方式来封装事务状态，但它们也带来了一定的开销。首先，`Ref`对象比简单的对象引用更重，消耗更多的内存。其次，每次访问新的`Ref`对象都需要在事务的读取集中添加一个条目。当我们处理许多`Ref`对象时，这些开销可能会变得相当大。让我们用一个例子来说明这一点。
- en: 'Assume that we are working in the marketing department of a company that does
    Scala consulting. We are asked to write a program that updates the content of
    the company website with the marketing information about the Scala 2.10 release.
    Naturally, we decide to use ScalaSTM for this task. The website consists of five
    separate pages, each represented with a string. We declare the contents of the
    website in a sequence called `pages`. We then assign the content of the pages
    to an array of transactional references. If some page changes later, we can update
    its transactional reference in a transaction:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们是一家Scala咨询公司的市场营销部门，我们被要求编写一个程序，用关于Scala 2.10发布的营销信息更新公司网站的内容。自然，我们决定为此任务使用ScalaSTM。网站由五个独立的页面组成，每个页面都由一个字符串表示。我们在一个名为`pages`的序列中声明网站的内容。然后，我们将页面的内容分配给一个事务引用数组。如果某个页面稍后发生变化，我们可以在事务中更新其事务引用：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This solution is not satisfactory. We created a lot of transactional reference
    objects, and the definition of `website` is not easily understandable. Luckily,
    ScalaSTM has an alternative called a **transactional array**. A transactional
    array, represented with the `TArray` class, is similar to an ordinary Scala array,
    but can be accessed only from within a transaction. Its modifications are only
    made visible to the other threads when a transaction commits. Semantically, a
    `TArray` class corresponds to an array of transactional references, but it is
    more memory-efficient and concise:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案并不令人满意。我们创建了大量的事务引用对象，`website`的定义也不容易理解。幸运的是，ScalaSTM有一个名为**事务数组**的替代方案。事务数组，用`TArray`类表示，与普通的Scala数组类似，但只能在事务内部访问。其修改只有在事务提交时才对其他线程可见。从语义上讲，`TArray`类对应于事务引用数组，但它更节省内存且更简洁：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Scala development proceeds at an amazing pace. Not long after Scala 2.10 was announced,
    the 2.11 release of Scala became available. The marketing team asks us to update
    the contents of the website. All occurrences of the `"2.10"` string should be
    replaced with the `"2.11"` string. We write a `replace` method that does this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的开发速度令人惊叹。在Scala 2.10宣布不久后，Scala 2.11版本就发布了。市场营销团队要求我们更新网站的内容。所有出现的`"2.10"`字符串都应该替换为`"2.11"`字符串。我们编写了一个`replace`方法来完成这个任务：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using the `TArray` class is much nicer than storing transactional references
    in an array. Not only does it spare us from a parenthesis soup resulting from
    calling the `apply` operation on the transactional references in the array, but
    it also occupies less memory. This is because a single contiguous array object
    is created for the `TArray[T]` object, whereas an `Array[Ref[T]]` object requires
    many `Ref` objects, each of which has a memory overhead.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TArray` 类比在数组中存储事务引用要方便得多。这不仅使我们免于在数组中的事务引用上调用 `apply` 操作时产生的括号汤，而且占用的内存也更少。这是因为为
    `TArray[T]` 对象创建了一个单一的连续数组对象，而 `Array[Ref[T]]` 对象则需要许多 `Ref` 对象，每个对象都有内存开销。
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `TArray` class instead of arrays of transactional references to optimize
    memory usage and make programs more concise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TArray` 类代替事务引用数组，以优化内存使用并使程序更加简洁。
- en: 'Let''s test the `TArray` class and the `replace` method in a short program.
    We first define an additional method, `asString`, which concatenates the contents
    of all the website pages. We then replace all occurrences of the `2.10` string
    with the `2.11` string. To test whether `replace` works correctly, we concurrently
    replace all occurrences of the `out` word with `"released"`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个简短的程序中测试 `TArray` 类和 `replace` 方法。我们首先定义一个额外的方法，`asString`，它连接所有网站页面的内容。然后我们将所有
    `2.10` 字符串替换为 `2.11` 字符串。为了测试 `replace` 是否正确工作，我们并发地替换所有 `out` 单词为 `"released"`：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `asString` method captured all the entries in the transactional array. In
    effect, the `asString` method atomically produced a snapshot of the state of the
    `TArray` object. Alternatively, we could have copied the contents of `website`
    into another `TArray` object, instead of a string. In either case, computing the
    snapshot of a `TArray` object requires traversing all its entries, and can conflict
    with the transactions that modify only a subset of the `TArray` class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`asString` 方法捕获了事务数组中的所有条目。实际上，`asString` 方法原子性地生成了一个 `TArray` 对象状态的快照。或者，我们也可以将
    `website` 的内容复制到另一个 `TArray` 对象中，而不是字符串。在两种情况下，计算 `TArray` 对象的快照都需要遍历其所有条目，并且可能与只修改
    `TArray` 类子集的事务发生冲突。'
- en: Recall the transactional conflict example from the beginning of this chapter.
    A transaction with many reads and writes, as in the `asString` method, can be
    inefficient, because all the other transactions need to serialize with the `asString`
    method when a conflict occurs. When the array is large, this creates a scalability
    bottleneck. In the next section, we will examine another collection capable of
    producing atomic snapshots in a much more scalable manner, namely, the transactional
    maps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下本章开头的事务冲突示例。像 `asString` 方法那样，具有许多读取和写入操作的事务可能效率低下，因为当发生冲突时，所有其他事务都需要与 `asString`
    方法进行序列化。当数组很大时，这会创建一个可扩展性瓶颈。在下一节中，我们将检查另一种能够以更可扩展的方式生成原子快照的集合，即事务性映射。
- en: Transactional maps
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务性映射
- en: Similar to transactional arrays, transactional maps avoid the need to store
    transactional reference objects inside a map. As a consequence, they reduce memory
    consumption, improve the transaction performance, and provide a more intuitive
    syntax. In ScalaSTM, transactional maps are represented with the `TMap` class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与事务性数组类似，事务性映射避免了在映射内部存储事务引用对象的需要。因此，它们减少了内存消耗，提高了事务性能，并提供了更直观的语法。在 ScalaSTM
    中，事务性映射用 `TMap` 类表示。
- en: 'ScalaSTM''s `TMap` class has an additional advantage. It exposes a scalable,
    constant-time, atomic `snapshot` operation. The `snapshot` operation returns an
    immutable `Map` object with the contents of the `TMap` object at the time of the
    snapshot. Let''s declare a transactional map, `alphabet`, which maps character
    strings to their position in the alphabet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaSTM 的 `TMap` 类有一个额外的优势。它提供了一个可扩展的、常数时间的原子 `snapshot` 操作。`snapshot` 操作返回一个包含快照时刻
    `TMap` 对象内容的不可变 `Map` 对象。让我们声明一个事务性映射，`alphabet`，它将字符字符串映射到其在字母表中的位置：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We are unsatisfied with the fact that the letter `A` is in lowercase. We start
    a transaction that atomically replaces the lowercase letter `a` with the uppercase
    letter `A`. Simultaneously, we start another asynchronous computation that calls
    the `snapshot` operation on the `alphabet` map. We tune the timing of the second
    asynchronous computation so that it creates a race condition with the first transaction:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对字母 `A` 是小写的事实不满意。我们开始一个事务，原子地将小写字母 `a` 替换为大写字母 `A`。同时，我们开始另一个异步计算，该计算在 `alphabet`
    映射上调用 `snapshot` 操作。我们调整第二次异步计算的时机，使其与第一个事务产生竞态条件：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, the `snapshot` operation cannot interleave with the two updates
    in the `atomic` block. We can run the program several times to convince ourselves
    of this. The second asynchronous computation prints either the map with the lowercase
    letter `a`, or the map with the uppercase letter `A`, but it can never output
    a map with both the lowercase and the uppercase occurrence of the letter `A`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`snapshot` 操作不能与 `atomic` 块中的两个更新交织。我们可以多次运行程序来确信这一点。第二次异步计算会打印出包含小写字母
    `a` 的映射，或者包含大写字母 `A` 的映射，但它永远不会输出同时包含小写和大写字母 `A` 的映射。
- en: Tip
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use `TMap` (instead of maps of transactional references) to optimize memory
    usage, make programs more concise, and efficiently retrieve atomic snapshots.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TMap`（而不是事务性引用的映射）来优化内存使用，使程序更加简洁，并高效地检索原子快照。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how STM works and how to apply it in concurrent
    programs. We saw the advantages of using STM's transactional references and `atomic`
    blocks over the `synchronized` statements, and investigated their interaction
    with side effects. We studied the semantics of exception handling inside transactions
    and learned how to retry and conditionally re-execute transactions. Finally, we
    learned about transactional collections, which allow us to encode shared program
    data more efficiently.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 STM 的工作原理以及如何在并发程序中应用它。我们看到了使用 STM 的事务性引用和 `atomic` 块相对于 `synchronized`
    语句的优势，并调查了它们与副作用之间的交互。我们研究了事务内异常处理的语义，并学习了如何重试和有条件地重新执行事务。最后，我们了解了事务性集合，它允许我们更有效地编码共享程序数据。
- en: These features together enable a concurrent programming model in which the programmer
    can focus on expressing the meaning of the program, without having to worry about
    handling lock objects, or avoiding deadlocks and race conditions. This is especially
    important when it comes to modularity. It is hard or near impossible to reason
    about deadlocks or race conditions in the presence of separate software components.
    STM exists to liberate the programmer from such concerns, and is essential when
    composing large concurrent programs from simpler modules.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性共同实现了一种并发编程模型，在该模型中，程序员可以专注于表达程序的意义，而无需担心处理锁对象，或避免死锁和竞态条件。这对于模块化来说尤为重要。在存在独立软件组件的情况下，很难或几乎不可能对死锁或竞态条件进行推理。STM
    的存在是为了解放程序员从这些担忧中，当从更简单的模块中组合大型并发程序时，这是必不可少的。
- en: These advantages come with a cost, however, as using an STM for data access
    is slower than using locks and the `synchronized` statement. For many applications,
    the performance penalty of using an STM is acceptable. When it is not, we need
    to revert to simpler primitives, such as locks, atomic variables, and concurrent
    data structures.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些优势也伴随着代价，因为使用 STM 进行数据访问比使用锁和 `synchronized` 语句要慢。对于许多应用程序来说，使用 STM 的性能损失是可以接受的。当它不可接受时，我们需要回退到更简单的原语，例如锁、原子变量和并发数据结构。
- en: To learn more about STMs, we recommend reading the related chapter in the book
    *The Art of Multiprocessor Programming*, *Maurice Herlihy and Nir Shavit*, *Morgan
    Kauffman*. There are many different STM implementations in the wild, and you will
    need to study various research articles to obtain an in-depth understanding of
    STMs. An extensive list of STM research literature is available at [http://research.cs.wisc.edu/trans-memory/biblio/index.html](http://research.cs.wisc.edu/trans-memory/biblio/index.html).
    To learn more about the specifics of ScalaSTM, consider reading the doctoral thesis
    entitled *Composable Operations on High-Performance Concurrent Collections*, *Nathan
    G. Bronson*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于STM的信息，我们建议阅读书籍《多处理器编程的艺术》，*Maurice Herlihy和Nir Shavit*，*Morgan Kauffman*中相关的章节。野外有许多不同的STM实现，你需要研究各种研究文章来深入理解STM。STM研究文献的详尽列表可在[http://research.cs.wisc.edu/trans-memory/biblio/index.html](http://research.cs.wisc.edu/trans-memory/biblio/index.html)找到。要了解更多关于ScalaSTM的具体信息，可以考虑阅读题为《高性能并发集合上的可组合操作》的博士论文，*Nathan
    G. Bronson*。
- en: In the next chapter, we will study the actor programming model, which takes
    a different approach to achieving memory consistency. As we will see, separate
    computations never access each other's regions of memory in the actor model, and
    communicate mainly by exchanging messages.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究actor编程模型，它采用不同的方法来实现内存一致性。正如我们将看到的，在actor模型中，独立的计算永远不会访问彼此的内存区域，主要通过交换消息进行通信。
- en: Exercises
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In the following exercises, you will use ScalaSTM to implement various transactional
    programming abstractions. In most cases, their implementation will closely resemble
    a sequential implementation, while using transactions. In some cases, you might
    need to consult external literature or ScalaSTM documentation to correctly solve
    the exercise.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将使用ScalaSTM实现各种事务编程抽象。在大多数情况下，它们的实现将非常类似于顺序实现，同时使用事务。在某些情况下，你可能需要查阅外部文献或ScalaSTM文档来正确解决练习。
- en: 'Implement the transactional pair abstraction, represented with the `TPair`
    class:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现事务对抽象，用`TPair`类表示：
- en: '[PRE54]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In addition to getters and setters for the two fields, the transactional pair
    defines the `swap` method that swaps the fields, and can only be called if types
    `P` and `Q` are the same.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了两个字段的getter和setter之外，事务对定义了交换字段的`swap`方法，并且只能在类型`P`和`Q`相同的情况下调用。
- en: 'Use ScalaSTM to implement the mutable location abstraction from Haskell, represented
    with the `MVar` class:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ScalaSTM实现从Haskell来的可变位置抽象，用`MVar`类表示：
- en: '[PRE55]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'An `MVar` object can be either full or empty. Calling `put` on a full `MVar`
    object blocks until the `MVar` object becomes empty, and adds an element. Similarly,
    calling `take` on an empty `MVar` object blocks until the `MVar` object becomes
    full, and removes the element. Now, implement a method called `swap`, which takes
    two `MVar` objects and swaps their values:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MVar`对象可以是满的或空的。在满的`MVar`对象上调用`put`会阻塞，直到`MVar`对象变为空，并添加一个元素。同样，在空的`MVar`对象上调用`take`会阻塞，直到`MVar`对象变为满，并移除元素。现在，实现一个名为`swap`的方法，该方法接受两个`MVar`对象并交换它们的值：'
- en: '[PRE56]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Contrast the `MVar` class with the `SyncVar` class from [Chapter 2](ch02.html
    "Chapter 2. Concurrency on the JVM and the Java Memory Model"), *Concurrency on
    the JVM and the Java Memory Model*. Is it possible to implement the `swap` method
    for `SyncVar` objects without modifying the internal implementation of the SyncVar
    class?
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`MVar`类与[第2章](ch02.html "第2章。JVM和Java内存模型上的并发")中的`SyncVar`类进行对比，*JVM和Java内存模型上的并发*。在不修改SyncVar类内部实现的情况下，为`SyncVar`对象实现`swap`方法是否可能？
- en: 'Implement the `atomicRollbackCount` method, which is used to track how many
    times a transaction was rolled back before it completed successfully:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于跟踪事务在成功完成前回滚次数的`atomicRollbackCount`方法：
- en: '[PRE57]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Implement the `atomicWithRetryMax` method, which is used to start a transaction
    that can be retried at most `n` times:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于启动最多可以重试`n`次的事务的`atomicWithRetryMax`方法：
- en: '[PRE58]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Reaching the maximum number of retries throws an exception.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 达到最大重试次数时抛出异常。
- en: Tip
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `Txn` object.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`Txn`对象。
- en: 'Implement a transactional **First In First Out** (**FIFO**) queue, represented
    with the `TQueue` class:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个事务性的**先进先出**（**FIFO**）队列，用`TQueue`类表示：
- en: '[PRE59]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `TQueue` class has similar semantics as `scala.collection.mutable.Queue`,
    but calling `dequeue` on an empty queue blocks until a value becomes available.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TQueue` 类与 `scala.collection.mutable.Queue` 类具有类似的语义，但在空队列上调用 `dequeue` 会阻塞，直到有值可用。'
- en: Use ScalaSTM to implement a thread-safe `TArrayBuffer` class, which extends
    the `scala.collection.mutable.Buffer` interface.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ScalaSTM 实现一个线程安全的 `TArrayBuffer` 类，它扩展了 `scala.collection.mutable.Buffer`
    接口。
- en: 'The `TSortedList` class described in this chapter is always sorted, but accessing
    the last element requires traversing the entire list, and can be slow. An AVL
    tree can be used to address this problem. There are numerous descriptions of AVL
    trees available online. Use ScalaSTM to implement the thread-safe transactional
    sorted set as an AVL tree:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中描述的 `TSortedList` 类始终是有序的，但访问最后一个元素需要遍历整个列表，可能会很慢。可以使用 AVL 树来解决这个问题。网上有大量关于
    AVL 树的描述。使用 ScalaSTM 实现线程安全的交易性有序集合作为 AVL 树：
- en: '[PRE60]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `TSortedSet` class has similar semantics as `scala.collection.mutable.Set`.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TSortedSet` 类与 `scala.collection.mutable.Set` 类具有类似的语义。'
- en: Use ScalaSTM to implement a banking system that tracks amounts of money on user
    accounts. Different threads can call the `send` method to transfer money from
    one account to another, the `deposit` and `withdraw` methods which deposit to
    or withdraw money from a specific account, respectively, and the `totalStock`
    method which returns the total amount of money currently deposited in the bank.
    Finally, implement the `totalStockIn` method that returns the total amount of
    money currently deposited in the specified set of banks.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ScalaSTM 实现一个追踪用户账户金额的银行系统。不同的线程可以调用 `send` 方法将资金从一个账户转移到另一个账户，调用 `deposit`
    和 `withdraw` 方法分别向特定账户存入或取出资金，以及调用 `totalStock` 方法返回银行当前存入的总金额。最后，实现 `totalStockIn`
    方法，该方法返回当前在指定银行组中存入的总金额。
- en: Implement the generic transactional priority queue class, represented with the
    type `TPriorityQueue`, used to sort elements. Then implement a method called `scheduleTask`,
    which adds a task to the priority queue. Each task has a priority level. A set
    of workers must wait for the queue to become non-empty, at which point they repetitively
    remove tasks with the highest priority, and execute them.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个通用的交易性优先队列类，用类型 `TPriorityQueue` 表示，用于排序元素。然后实现一个名为 `scheduleTask` 的方法，该方法将任务添加到优先队列中。每个任务都有一个优先级。一组工作者必须等待队列非空，然后重复移除具有最高优先级的任务并执行它们。
- en: Implement a generic transactional directed graph data structure, whose nodes
    are represented with the `Node` class. Then implement a method `scheduleTask`,
    which adds a task to into the graph. Each task has the list of dependencies -
    other tasks in the graph that must be executed before it begins; and this list
    represents the directed edges in the graph. A set of workers repetitively queries
    the graph, and schedules tasks for execution. A task can only be executed after
    its dependencies are done executing.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个通用的交易性有向图数据结构，其节点由 `Node` 类表示。然后实现一个 `scheduleTask` 方法，该方法将任务添加到图中。每个任务都有一个依赖列表
    - 在它开始之前必须执行的其他任务；这个列表代表了图中的有向边。一组工作者重复查询图，并安排任务执行。一个任务只能在它的依赖任务执行完毕后才能执行。
