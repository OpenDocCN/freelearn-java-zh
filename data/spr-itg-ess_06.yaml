- en: Chapter 6. Integration with External Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。与外部系统的集成
- en: 'In the previous chapter, we discussed Spring Integration components that help
    with message flow inside systems. In this chapter, let''s pull the lever further
    and see what Spring Integration has in the box when it comes to real-world integration
    challenges. We will cover Spring Integration''s support for external components
    and we will cover the following topics in detail:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了帮助系统内部消息流转的Spring Integration组件。在本章中，让我们进一步拉动杠杆，看看Spring Integration在实际集成挑战方面有什么箱子。我们将涵盖Spring
    Integration对外部组件的支持，并详细介绍以下主题：
- en: Working with files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件
- en: File exchange over FTP/FTPS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP/FTPS上的文件交换
- en: Social integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交集成
- en: Enterprise messaging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业消息传递
- en: Invoking and consuming HTTP endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用和消费HTTP端点
- en: Web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务
- en: Database integration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库集成
- en: Streaming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式处理
- en: Working with files
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件
- en: One of the most common and primitive ways to communicate is through files. Even
    after the introduction of databases, the filesystem has not lost its relevance
    and we frequently need to deal with them—in legacy applications, for dumping reports,
    shared locations, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见且原始的通信方式之一就是通过文件。即使在数据库出现之后，文件系统仍未失去其相关性，我们经常需要处理它们——在遗留应用中，用于转储报告、共享位置等等。
- en: So, how do you work with files in Java? Get the file handle, open a stream,
    work over it, and then close it. Some trivial stuff would take 10-15 lines of
    code. However, what if you forget to close the stream or the referenced file has
    been removed? The lines of code go on increasing as we handle all the corner cases.
    Spring Integration has very good support for files. It provides adapters and gateways
    that can handle file reading and writing operations with minimal lines of code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在Java中如何处理文件呢？获取文件句柄，打开一个流，对其进行操作，然后关闭它。一些琐碎的事情需要10-15行代码。但是，如果你忘记关闭流或者引用的文件已经被移除怎么办？代码行会随着我们处理所有角落案例而增加。Spring
    Integration对文件支持非常好。它提供了适配器和网关，可以以最少的代码行处理文件读写操作。
- en: Prerequisites
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'To use the file components mentioned previously, we need to declare the Spring
    namespace support and Maven entry in the following way:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面提到的文件组件，我们需要以如下方式声明Spring命名空间支持和Maven入口：
- en: 'Namespace support can be added by using the following code snippet:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间支持可以通过使用以下代码片段添加：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Maven entry can be added by using the following code snippet:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用以下代码片段添加Maven入口：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are now good to start writing our Spring Integration file components. Let''s
    discuss file support from Spring based on the two types of operation: reading
    files and writing files.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写我们的Spring Integration文件组件了。让我们讨论基于两种类型操作的Spring文件支持：读取文件和写入文件。
- en: Reading files
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'Spring Integration provides an adapter that can read a file from a directory
    and make it available as a `Message<File>` on a channel for other consumers to
    consume it. Let''s look at a snippet to see how it is configured:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了一个适配器，可以从目录中读取文件，并将其作为`Message<File>`发布在通道上，供其他消费者消费。让我们看一个片段来了解它是如何配置的：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding configuration is sufficient to read files from a *directory*
    and put it on the specified *channel*. Let''s look at the elements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置足以从*目录*读取文件并将其放在指定的*通道*上。让我们看看这些元素：
- en: '`int-file:inbound-channel-adapter`: This is the namespace for file support'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-file:inbound-channel-adapter`：这是文件支持的命名空间'
- en: '`directory`: This is the directory from where files should be read'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directory`：这是要从中读取文件的目录'
- en: '`channel`: This is the channel on which a file should be written'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：这是应该写入文件的通道'
- en: '`prevent-duplicates`: If this is enabled, files already picked up in an earlier
    run are not picked up again'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prevent-duplicates`：如果启用此选项，则在早期运行中已经拾取的文件不会再次拾取'
- en: '`filename-pattern`: This is the name pattern for the file that should be picked
    up'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename-pattern`：这是应拾取的文件的名字模式'
- en: '`int:poller`: This is the rate at which files should be polled'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int:poller`：这是应该轮询文件的速度'
- en: '`int-file:nio-locker`: If there are multiple consumers, this will lock files
    so that the same files are not picked concurrently'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-file:nio-locker`：如果有多个消费者，这将锁定文件，以防止同时选择相同的文件'
- en: You must have realized that although the configuration is simple, a lot of things
    are going on under the hood, such as preventing duplicates, filtering files, avoiding
    concurrent access, and so on. We will discuss these in detail, but before that
    let's have a peek at the class that is acting behind the scene for this adapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到，尽管配置简单，但很多事情都在幕后进行，例如防止重复、过滤文件、避免并发访问等。我们将详细讨论这些内容，但在那之前，让我们先看看为这个适配器幕后工作的类。
- en: Behind the scenes
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幕后
- en: 'The adapter declared in the previous example leverages `FileReadingMessageSource`,
    which is an implementation of `MessageSource`. It creates a message based on a
    file from a directory as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例中声明的适配器利用了`FileReadingMessageSource`，这是`MessageSource`的一个实现。它根据目录中的文件创建消息如下：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At bean declaration level, we can inject filters, locking mechanics, and so
    on—but since we are using Spring Integration, it spares us from working at bean
    declaration level. Instead, we can use adapters exposed by Spring Integration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在bean声明级别，我们可以注入过滤器、锁机制等——但由于我们使用Spring Integration，它免去了我们在bean声明级别的工作。相反，我们可以使用Spring
    Integration暴露的适配器。
- en: Filters
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器
- en: Filter is a powerful concept that can be used to prevent duplicates, select
    files based on name patterns, customize the list of files read, and perform many
    more interceptions before the required content can be presented to the next endpoint.
    There are predefined filters available for most common tasks, but in the true
    spirit of spring, we can have custom implementations as well and inject them in
    adapters provided by Spring Integration. Filters must be an instance of `FileListFilter`,
    and the default filter used is `AcceptOnceFileListFilter`. This filter keeps track
    of processed files, but the implementation is in-memory. This means that if the
    server restarts when files are being processed, it will lose track of which files
    have been processed and will re-read the same files. To overcome this issue, an
    instance of `FileSystemPersistentAcceptOnceFileListFilter` should be used, which
    will keep track of processed files by leveraging the `MetadataStore` implementation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是一个强大的概念，可以用来防止重复，根据名称模式选择文件，自定义读取的文件列表，以及在将所需内容呈现给下一个端点之前执行许多其他拦截。对于大多数常见任务，都有预定义的过滤器，但在Spring的精神下，我们也可以有自定义实现，并将它们注入由Spring
    Integration提供的适配器中。过滤器必须是`FileListFilter`的一个实例，默认使用的过滤器是`AcceptOnceFileListFilter`。此过滤器跟踪处理过的文件，但实现是在内存中。这意味着如果服务器在处理文件时重新启动，它将失去对已处理文件的跟踪，并将重新阅读相同的文件。为了解决这个问题，应使用`FileSystemPersistentAcceptOnceFileListFilter`的实例，通过利用`MetadataStore`实现来跟踪处理过的文件。
- en: 'Additionally, filename patterns and `Reg Ex` filters are available and can
    be used to filter files based on their names or by matching the name against the
    `Reg Ex` specified. Let''s see a quick example showing the use of these two filters:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，文件名模式和`Reg Ex`过滤器可供使用，可以根据它们的名称或通过与指定的`Reg Ex`匹配来过滤文件。让我们通过一个快速示例来看看这两个过滤器的使用：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s say we want a custom filter, it can easily be defined and used. The
    code is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个自定义过滤器，它可以很容易地被定义和使用。代码如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Preventing duplicates
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止重复
- en: Preventing duplicates is a subset of filter that filters out files that have
    already been picked up. Using `prevent-duplicates`, we can instruct an adapter
    to look for unique files only. The only glitch here is that a duplicate check
    is limited to a session, as the reader does not store any state. If the reader
    restarts, it will read all the files again—even though they have been read earlier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 防止重复是过滤器的一个子集，用于过滤已经选择的文件。使用`prevent-duplicates`，我们可以指示适配器只查找唯一的文件。这里的唯一问题是，重复检查限于会话，因为读者不存储任何状态。如果读者重新启动，它将再次阅读所有文件——即使它们之前已经被阅读过。
- en: Concurrent access
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发访问
- en: 'This is a very common use case in enterprises with multiple consumers, and
    we want to maintain the sanity of the files consumed. We can use the `java.nio`
    locker in the following way to lock files to ensure that they are not accessed
    concurrently:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是企业中具有多个消费者非常常见的用例，我们希望能够维护被消费文件的完整性。我们可以以下面这种方式使用`java.nio`锁来锁定文件，以确保它们不被并发访问：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code does not restrict us to use only `java.nio.locker`. Instead of using
    the `java.nio` locker, we can provide custom lockers as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码并没有限制我们只能使用`java.nio.locker`。 Instead of using the `java.nio` locker, we
    can provide custom lockers as well:'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unlocking is not explicit. It is performed by calling `FileLocker.unlock(File
    file)`; otherwise, it will result in memory leaks over the period.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁不是显式的。通过调用`FileLocker.unlock(File file)`来执行解锁；否则，在一段时间内会导致内存泄漏。
- en: Writing files
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写文件
- en: 'Spring Integration provides outbound adapters, which are the opposite of inbound
    adapters. This means that it consumes a file from a channel and writes it to a
    directory. Internally, Spring Integration uses an instance of `FileWritingMessageHandler`
    to write messages to the filesystem, and an implementation of this class can be
    used. This class can deal with files, strings, or byte array payloads. As usual,
    there is no need to use the low-level classes; instead, adapter and gateway exposed
    by spring can be used. Let''s connect an outbound adapter to the channel on which
    the inbound adapter writes files:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了出站适配器，这是入站适配器的对立面。这意味着它从一个通道中消耗文件并将其写入一个目录。内部地，Spring Integration使用`FileWritingMessageHandler`实例将消息写入文件系统，并且可以使用这个类的实现。这个类可以处理文件、字符串或字节数组有效载荷。像往常一样，没有必要使用低级类；相反，可以spring暴露的适配器和网关。让我们将出站适配器连接到写入文件的入站适配器通道：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s discuss what each element represents:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个元素代表的内容：
- en: '`int-file:outbound-channel-adapter`: This provides file namespace support for
    the outbound channel adapter'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-file:outbound-channel-adapter`：为出站通道适配器提供文件命名空间支持'
- en: '`channel`: This is the channel where the files would be written as Spring Integration
    messages'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：这是文件将被写入作为Spring Integration消息的通道。'
- en: '`directory`: This is the directory from which files are picked'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directory`：这是从中选择文件的目录。'
- en: '`delete-source-files`: If this is set to true, it will delete the files after
    processing them'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete-source-files`：如果将此设置为真，处理完文件后将会删除这些文件。'
- en: While writing files, we need to consider things such as what should be the name
    of the new file, which directory should it be written in, what should be done
    with the original file, and so on. Let's quickly touch upon these aspects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在写文件时，我们需要考虑诸如新文件的名字应该是什么，应该写入哪个目录，原始文件应该如何处理等问题。让我们快速触及这些方面。
- en: Naming the file
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名文件
- en: By default, the name of the file will be retained when it is written in the
    directory. However, this can be overridden by providing an implementation `FileNameGenerator`.
    This is the class responsible for generating the filenames—by default `FileNameGenerator`
    looks for a message header whose key matches the constant `FileHeaders.FILENAME`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当文件写入目录时，文件名将被保留。然而，这可以通过提供`FileNameGenerator`实现来覆盖。这个类负责生成文件名——默认情况下`FileNameGenerator`查找与常量`FileHeaders.FILENAME`匹配的消息头。
- en: Target directory
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标目录
- en: 'There are primarily three ways to locate the target directory:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有三种方法来定位目标目录：
- en: Statically define a directory attribute that will direct each message to a fixed
    directory.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态地定义一个目录属性，该属性将把每个消息导向一个固定的目录。
- en: Define a directory-expression attribute that should be a valid **Spring Expression
    Language** (**SpEL**) expression. This expression is evaluated for each message
    and the message header can be used to dynamically specify the output file directory.
    The expression must resolve to a string or to `java.io.File`, and this must point
    to a valid directory.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个目录表达式属性，它应该是一个有效的**Spring表达式语言**（**SpEL**）表达式。这个表达式对每个消息进行评估，并且可以使用消息头动态指定输出文件目录。该表达式必须解析为字符串或`java.io.File`，并且必须指向有效的目录。
- en: The last option is the auto create directory. If the destination directory is
    missing, it will be created automatically, including its parent directory. This
    is the default behavior; to disable this, set the `auto-create-directory` attribute
    to `false`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个选项是自动创建目录。如果目标目录缺失，它将会自动创建，包括其父目录。这是默认行为；要禁用此功能，将`auto-create-directory`属性设置为`false`。
- en: Dealing with existing filenames
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理现有文件名
- en: 'What if the file being written already exists? The correct route to take is
    using the `mode` attribute. One of following four options is available:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在写的文件已经存在怎么办？采取正确的途径是使用`mode`属性。以下四个选项中的一个可用：
- en: '`REPLACE`: This is the default mode. If a file already exists, it will be simply
    overwritten.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPLACE`：这是默认模式。如果文件已存在，它将被简单地覆盖。'
- en: '`APPEND`: This will append the content of the incoming file to the existing
    one.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APPEND`：这将把传入文件的内容追加到现有文件中。'
- en: '`FAIL`: If a duplicate is not expected, this mode should be used. This will
    throw `MessageHandlingException` if the file already exists.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAIL`：如果预期没有重复，应使用此模式。如果文件已存在，这将抛出`MessageHandlingException`。'
- en: '`IGNORE`: If no action needs to be taken if the target file exists, this option
    should be used.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IGNORE`：如果目标文件存在时不需要采取任何操作，应使用此选项。'
- en: 'So far, we have covered most of the aspects of the filesystem. However, what
    if we want to process the message after it has been written to the directory?
    Spring Integration provides an outbound gateway that can be handy here. Let''s
    have a look at this simple example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了文件系统的大多数方面。然而，如果我们想在将消息写入目录之后处理消息呢？Spring Integration提供了一个出口网关，在这里可能很有用。让我们来看看这个简单的例子：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The tags are the same as those for the output adapter; the difference is that
    it puts the files on the channel specified by `reply-channel` for further processing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 标签与输出适配器的标签相同；区别在于它将文件放置在由`reply-channel`指定的通道上以供进一步处理。
- en: 'Let''s write a simple service activator that will process these files:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的服务激活器来处理这些文件：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: File transformers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件转换器
- en: File transformers are used to transform data read from a file to an object and
    vice versa. Spring Integration has provided a few common transformers such as
    file to byte, file to string, and so on, but we can always extend the framework
    interfaces to define more advanced and appropriate file transformers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文件转换器用于将从一个文件读取的数据转换为对象，反之亦然。Spring Integration提供了一些常见的转换器，如文件到字节、文件到字符串等，但我们可以随时扩展框架接口以定义更高级和适当的文件转换器。
- en: 'Let''s complete this section with a quick discussion on some implicit file
    transformers provided by spring. Let''s start with this example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个快速讨论来结束本节，讨论一些由 spring 提供的隐式文件转换器。让我们从这个例子开始：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As it's obvious from the preceding snippet, Spring Integration has provided
    implicit transformers for most common use cases as file to byte and file to string.
    Transformers are not restricted to these two cases—custom transformers can be
    defined by implementing the transformer interface or extending `AbstractFilePayloadTransformer`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，Spring Integration为大多数常见用例提供了隐式转换器，如文件到字节和文件到字符串。转换器不仅限于这两个用例——可以通过实现转换器接口或扩展`AbstractFilePayloadTransformer`来定义自定义转换器。
- en: FTP/FTPS
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP/FTPS
- en: '**FTP**, or **File Transfer Protocol**, is used to transfer files across networks.
    FTP communications consist of two parts: server and client. The client establishes
    a session with the server, after which it can download or upload files. Spring
    Integration provides components that act as a client and connect to the FTP server
    to communicate with it. What about the server—which server will it connect to?
    If you have access to any public or hosted FTP server, use it. Else, the easiest
    way for trying out the example in this section is to set up a local instance of
    the FTP server. FTP setup is out of the scope of this book.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**FTP**，或**文件传输协议**，用于跨网络传输文件。FTP通信由两部分组成：服务器和客户端。客户端与服务器建立会话后，它可以下载或上传文件。Spring
    Integration提供了作为客户端的组件，并连接到FTP服务器与其通信。那么服务器——它将连接到哪个服务器？如果您有访问任何公共或托管FTP服务器的机会，请使用它。否则，尝试本节中示例的最简单方法是设置FTP服务器的本地实例。本
    book 中的 FTP 设置超出了范围。'
- en: Prerequisites
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'To use Spring Integration components for FTP/FTPS, we need to add a namespace
    to our configuration file and then add the Maven dependency entry in the `pom.xml`
    file. The following entries should be made:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Spring Integration组件进行FTP/FTPS，我们需要在我们的配置文件中添加一个命名空间，然后在`pom.xml`文件中添加Maven依赖项。应进行以下操作：
- en: 'Namespace support can be added by using the following code snippet:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段添加命名空间支持：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Maven entry can be added by using the following code snippet:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段添加Maven条目：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once namespace is available and the JAR has been downloaded, we are ready to
    use the components. As mentioned earlier, client components of Spring Integration
    need a session to establish with the FTP server. The details of the session is
    encapsulated in the session factory; let''s look at a sample session factory configuration:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命名空间可用并且JAR已下载，我们就可以使用这些组件了。如前所述，Spring Integration的客户端组件需要与FTP服务器建立会话。会话的详细信息封装在会话工厂中；让我们看看一个会话工厂配置示例：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `DefaultFtpSessionFactory` class is at work here`,` and it takes the following
    parameters:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultFtpSessionFactory`类在此处工作，并接受以下参数：'
- en: Host that is running the FTP server
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行FTP服务器的宿主机。
- en: Port at which it's running the server
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器正在运行的端口
- en: Username
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: Password for the server
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器的密码
- en: A session pool for the factory is maintained and an instance is returned when
    required. Spring takes care of validating that a stale session is never returned.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 会话池为工厂维护，当需要时返回一个实例。Spring负责验证永远不会返回过期的会话。
- en: Downloading files from the FTP server
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从FTP服务器下载文件
- en: 'Inbound adapters can be used to read the files from the server. The most important
    aspect is the session factory that we just discussed in the preceding section.
    The following code snippet configures an FTP inbound adapter that downloads a
    file from a remote directory and makes it available for processing:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 入站适配器可用于从服务器读取文件。最重要的方面是我们在上一节中讨论的会话工厂。以下代码片段配置了一个FTP入站适配器，从远程目录下载文件并使其可用于处理：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s quickly go through the tags used in this code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下此代码中使用的标签：
- en: '`int-ftp:inbound-channel-adapter`: This is the namespace support for the FTP
    inbound adapter.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-ftp:inbound-channel-adapter`：这是FTP入站适配器的命名空间支持。'
- en: '`channel`: This is the channel on which the downloaded files will be put as
    a message.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：下载的文件将被作为消息放在这个通道上。'
- en: '`session-factory`: This is a factory instance that encapsulates details for
    connecting to a server.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session-factory`：这是一个封装了连接服务器详细信息的工厂实例。'
- en: '`remote-directory`: This is the directory on the server where the adapter should
    listen for the new arrival of files.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote-directory`：这是适配器应该监听文件新到达的服务器目录。'
- en: '`local-directory`: This is the local directory where the downloaded files should
    be dumped.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local-directory`：这是下载文件应该被倾倒的本地目录。'
- en: '`auto-create-local-directory`: If enabled, this will create the local directory
    structure if it''s missing.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto-create-local-directory`：如果启用，如果缺失，将创建本地目录结构。'
- en: '`delete-remote-files`: If enabled, this will delete the files on the remote
    directory after it has been downloaded successfully. This will help in avoiding
    duplicate processing.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete-remote-files`：如果启用，下载成功后将在远程目录上删除文件。这将有助于避免重复处理。'
- en: '`filename-pattern`: This can be used as a filter, but only files matching the
    specified pattern will be downloaded.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename-pattern`：这可以用作过滤器，但只有与指定模式匹配的文件才会被下载。'
- en: '`local-filename-generator-expression`: This can be used to generate a local
    filename.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local-filename-generator-expression`：这可以用来自动生成本地文件名。'
- en: An inbound adapter is a special listener that listens for events on the remote
    directory, for example, an event fired on the creation of a new file. At this
    point, it will initiate the file transfer. It creates a payload of type `Message<File>`
    and puts it on the output channel. By default, the filename is retained and a
    file with the same name as the remote file is created in the local directory.
    This can be overridden by using `local-filename-generator-expression`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 入站适配器是一个特殊的监听器，监听远程目录上的事件，例如，在创建新文件时触发的事件。此时，它将启动文件传输。它创建一个类型为`Message<File>`的有效负载，并将其放在输出通道上。默认情况下，保留文件名，并在本地目录中创建与远程文件同名的新文件。这可以通过使用`local-filename-generator-expression`来覆盖。
- en: Incomplete files
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未完成文件
- en: On the remote server, there could be files that are still in the process of
    being written. Typically, there the extension is different, for example, `filename.actualext.writing`.
    The best way to avoid reading incomplete files is to use the filename pattern
    that will copy only those files that have been written completely.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程服务器上，可能还有一些文件正在被写入的过程中。通常，它们的扩展名是不同的，例如，`filename.actualext.writing`。避免读取未完成文件的最佳方法是使用文件名模式，只复制那些已经完全写入的文件。
- en: Uploading files to the FTP server
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文件上传到FTP服务器
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is a brief description of the tags used:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对使用标签的简要描述：
- en: '`int-ftp:outbound-channel-adapter`: This is the namespace support for the FTP
    outbound adapter.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-ftp:outbound-channel-adapter`：这是FTP出站适配器的命名空间支持。'
- en: '`channel`: This is the name of the channel whose payload will be written to
    the remote server.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：这是要写入远程服务器的通道的名称。'
- en: '`remote-directory`: This is the remote directory where files will be put. The
    user configured in the session factory must have appropriate permission.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote-directory`：这是文件将被放置的远程目录。会话工厂中配置的用户必须有适当的权限。'
- en: '`session-factory`: This encapsulates details for connecting to the FTP server.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session-factory`：这封装了连接FTP服务器的详细信息。'
- en: '`auto-create-directory`: If enabled, this will automatically create a remote
    directory if it''s missing, and the given user should have sufficient permission.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto-create-directory`：如果启用，这将会在远程目录缺失时自动创建，并且给定的用户应该有足够的权限。'
- en: 'The payload on the channel need not necessarily be a file type; it can be one
    of the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通道上的载荷不一定是文件类型；它可以是以下之一：
- en: '`java.io.File`: A Java file object'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.File`：一个Java文件对象。'
- en: '`byte[]`: This is a byte array that represents the file contents'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[]`：这是一个代表文件内容的字节数组。'
- en: '`java.lang.String`: This is the text that represents the file contents'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.String`：这是代表文件内容的文本。'
- en: Avoiding partially written files
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免部分写入的文件
- en: Files on the remote server must be made available only when they have been written
    completely and not when they are still partial. Spring uses a mechanism of writing
    the files to a temporary location and its availability is published only when
    it has been completely written. By default, the suffix is written, but it can
    be changed using the `temporary-file-`suffix property. This can be completely
    disabled by setting `use-temporary-file-name` to `false`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 远程服务器上的文件只有在完全写入时才可用，而不是当它们还是部分写入时。Spring使用将文件写入临时位置的机制，并且仅在文件完全写入后才发布其可用性。默认情况下，后缀被写入，但可以通过使用`temporary-file-suffix`属性来更改它。可以通过将`use-temporary-file-name`设置为`false`来完全禁用它。
- en: FTP outbound gateway
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP出站网关
- en: 'Gateway, by definition, is a two-way component: it accepts input and provides
    a result for further processing. So what is the input and output in the case of
    FTP? It issues commands to the FTP server and returns the result of the command.
    The following command will issue an `ls` command with the option `–l` to the server.
    The result is a list of string objects containing the filename of each file that
    will be put on the `reply-channel`. The code is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 网关，按定义，是一个双向组件：它接受输入并提供一个用于进一步处理的结果。那么FTP的输入和输出是什么？它向FTP服务器发出命令并返回命令的结果。以下命令将向服务器发出带有`–l`选项的`ls`命令。结果是一个包含每个文件名的字符串对象的列表，这些文件将被放在`reply-channel`上。代码如下：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The tags are pretty simple:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 标签相当简单：
- en: '`int-ftp:outbound-gateway`: This is the namespace support for the FTP outbound
    gateway'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-ftp:outbound-gateway`：这是FTP出站网关的命名空间支持。'
- en: '`session-factory`: This is the wrapper for details needed to connect to the
    FTP server'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session-factory`：这是用于连接FTP服务器的细节的包装器。'
- en: '`command`: This is the command to be issued'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：这是要发出的命令。'
- en: '`command-options`: This is the option for the command'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command-options`：这是命令的选项。'
- en: '`reply-channel`: This is the response of the command that is put on this channel'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reply-channel`：这是命令的响应，放在这个通道上。'
- en: FTPS support
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTPS支持
- en: 'For FTPS support, all that is needed is to change the factory class—an instance
    of `org.springframework.integration.ftp.session.DefaultFtpsSessionFactory` should
    be used. Note the `s` in `DefaultFtpsSessionFactory`. Once the session is created
    with this factory, it''s ready to communicate over a secure channel. Here is an
    example of a secure session factory configuration:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持FTPS，需要做的只是更改工厂类——应使用`org.springframework.integration.ftp.session.DefaultFtpsSessionFactory`的实例。注意`DefaultFtpsSessionFactory`中的`s`。一旦使用这个工厂创建了会话，它就准备好通过安全通道进行通信。以下是安全会话工厂配置的示例：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although it is obvious, I would remind you that the FTP server must be configured
    to support a secure connection and open the appropriate *port*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很显然，但我还是要提醒你，FTP服务器必须配置为支持安全连接并打开适当的*端口*。
- en: Social integration
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交集成
- en: Any application in today's context is incomplete if it does not provide support
    for social messaging. Spring Integration provides in-built support for many social
    interfaces such as e-mails, Twitter feeds, and so on. Let's discuss the implementation
    of Twitter in this section. Prior to Version 2.1, Spring Integration was dependent
    on the Twitter4J API for Twitter support, but now it leverages Spring's social
    module for Twitter integration. Spring Integration provides an interface for receiving
    and sending tweets as well as searching and publishing the search results in messages.
    Twitter uses `oauth` for authentication purposes. An app must be registered before
    we start Twitter development on it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当今任何应用程序如果它不提供对社交消息的支持就不完整。Spring Integration为许多社交接口提供内置支持，例如电子邮件、Twitter提要等等。本节我们将讨论Twitter的实现。在2.1版本之前，Spring
    Integration依赖于Twitter4J API进行Twitter支持，但现在它利用Spring的社交模块进行Twitter集成。Spring Integration提供了一个接口，用于接收和发送推文以及搜索和发布搜索结果的消息。Twitter使用`oauth`进行身份验证。应用程序必须在开始开发Twitter之前进行注册。
- en: Prerequisites
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Let''s look at the steps that need to be completed before we can use a Twitter
    component in our Spring Integration example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在Spring Integration示例中使用Twitter组件之前，需要完成以下步骤：
- en: '**Twitter account setup:** A Twitter account is needed. Perform the following
    steps to get the keys that will allow the user to use Twitter using the API:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Twitter账户设置：**需要一个Twitter账户。执行以下步骤以获取允许用户使用Twitter API的密钥：'
- en: Visit [https://apps.twitter.com/](https://apps.twitter.com/).
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://apps.twitter.com/](https://apps.twitter.com/)。
- en: Sign in to your account.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的账户。
- en: Click on **Create New App**.![Prerequisites](img/00009.jpeg)
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建新应用**。![先决条件](img/00009.jpeg)
- en: Enter the details such as **Application name**, **Description**, **Website**,
    and so on. All fields are self-explanatory and appropriate help has also been
    provided. The value for the field **Website** need not be a valid one—put an arbitrary
    website name in the correct format.![Prerequisites](img/00010.jpeg)
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入诸如**应用程序名称**、**描述**、**网站**等信息。所有字段都是自解释的，也提供了适当的帮助。字段**网站**的值不必须是有效的——在正确的格式中输入一个任意的网站名称。![先决条件](img/00010.jpeg)
- en: Click on the **Create your application** button. If the application is created
    successfully, a confirmation message will be shown and the **Application Management**
    page will appear, as shown here:![Prerequisites](img/00011.jpeg)
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建您的应用程序**按钮。如果应用程序创建成功，将显示确认消息，并且将出现**应用程序管理**页面，如下所示：![先决条件](img/00011.jpeg)
- en: Go to the **Keys and Access Tokens** tab and note the details for **Consumer
    Key (API Key)** and **Consumer Secret (API Secret)** under **Application Settings**,
    as shown in the following screenshot:![Prerequisites](img/00012.jpeg)
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**密钥和访问令牌**标签，并记下**应用程序设置**下的**消费者密钥（API密钥）**和**消费者密钥密钥（API密钥密钥）**的详细信息，如下面的屏幕截图所示：![先决条件](img/00012.jpeg)
- en: You need additional access tokens so that applications can use Twitter using
    APIs. Click on **Create my access token**; it takes a while to generate these
    tokens. Once it is generated, note down the value of **Access Token** and **Access
    Token Secret**.![Prerequisites](img/00013.jpeg)
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要额外的访问令牌，这样应用程序才能使用Twitter的API。点击**创建我的访问令牌**；生成这些令牌需要一点时间。一旦生成，记下**访问令牌**和**访问令牌密钥**的值。![先决条件](img/00013.jpeg)
- en: Go to the **Permissions** tab and provide permission to **Read, Write** **and
    Access direct messages**.![Prerequisites](img/00014.jpeg)
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**权限**标签，并提供**读取、写入**和**访问直接消息**的权限。![先决条件](img/00014.jpeg)
- en: 'After performing all these steps, and with the required keys and access token,
    we are ready to use Twitter. Let''s store these in the `twitterauth.properties`
    property file:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成所有这些步骤后，再加上所需的密钥和访问令牌，我们就可以使用Twitter了。让我们将这些信息存储在`twitterauth.properties`属性文件中：
- en: '[PRE20]'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As I mentioned, the template encapsulates all the values. Here is the order
    of the arguments:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，模板封装了所有的值。以下是参数的顺序：
- en: '`apiKey`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiKey`'
- en: '`apiSecret`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiSecret`'
- en: '`accessToken`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accessToken`'
- en: '`accessTokenSecret`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accessTokenSecret`'
- en: 'With all the setup in place, let''s now do some real work:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有设置就绪后，我们现在做一些实际的工作：
- en: 'Namespace support can be added by using the following code snippet:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段来添加命名空间支持：
- en: '[PRE21]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Maven entry can be added by using the following code snippet:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段来添加Maven入口：
- en: '[PRE22]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Receiving tweets
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收推文
- en: 'The components in this code are covered in the following bullet points:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的组件如下所述：
- en: '`int-twitter:inbound-channel-adapter`: This is the namespace support for Twitter''s
    inbound channel adapter.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-twitter:inbound-channel-adapter`：这是 Twitter 的入站通道适配器的命名空间支持。'
- en: '`twitter-template`: This is the most important aspect. The Twitter template
    encapsulates which account to use to poll the Twitter site. The details given
    in the preceding code snippet are fake; it should be replaced with real connection
    parameters.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twitter-template`：这是最重要的方面。Twitter 模板封装了要使用哪个账户轮询 Twitter 网站。前面代码片段中给出的详细信息是虚构的；它应该用真实的连接参数替换。'
- en: '`channel`: Messages are dumped on this channel.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`: 消息会被投放到这个频道。'
- en: These adapters are further used for other applications, such as for searching
    messages, retrieving direct messages, and retrieving tweets that mention your
    account, and so on. Let's have a quick look at the code snippets for these adapters.
    I will not go into detail for each one; they are almost similar to what have been
    discussed previously.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适配器进一步用于其他应用程序，例如搜索消息、接收直接消息以及接收提到您账户的推文等。让我们快速查看这些适配器的代码片段。我不会深入每个细节；它们与之前讨论的几乎相同。
- en: '**Search**: This adapter helps to search the tweets for the parameter configured
    in the query tag. The code is as follows:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：此适配器有助于搜索查询标签中配置的参数的推文。代码如下：'
- en: '[PRE23]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Retrieving Direct Messages**: This adapter allows us to receive the direct
    message for the account in use (account configured in Twitter template). The code
    is as follows:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取直接消息**：此适配器允许我们接收使用中账户的直接消息（在 Twitter 模板中配置的账户）。代码如下：'
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Retrieving Mention Messages**: This adapter allows us to receive messages
    that mention the configured account via the `@user` tag (account configured in
    the Twitter template). The code is as follows:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取提及消息**：此适配器允许我们通过 `@用户` 标签（在 Twitter 模板中配置的账户）接收提到配置账户的消息。代码如下：'
- en: '[PRE25]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Sending tweets
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送推文
- en: 'Twitter exposes outbound adapters to send messages. Here is a sample code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter 暴露出站适配器以发送消息。以下是一个示例代码：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Whatever message is put on the `twitterSendMessageChannel` channel is tweeted
    by this adapter. Similar to an inbound gateway, the outbound gateway provides
    support for sending direct messages. Here is a simple example of an outbound adapter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 无论什么消息放在 `twitterSendMessageChannel` 频道上，都会通过此适配器发布推文。与入站网关类似，出站网关也提供发送直接消息的支持。以下是一个出站适配器的简单示例：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Any message that is put on the `twitterSendDirectMessage` channel is sent to
    the user directly. But where is the name of the user to whom the message will
    be sent? It is decided by a header in the message `TwitterHeaders.DM_TARGET_USER_ID`.
    This must be populated either programmatically, or by using enrichers or SpEL.
    For example, it can be programmatically added as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 任何放在 `twitterSendDirectMessage` 频道上的消息都会直接发送给用户。但是，消息将要发送给哪个用户的名字在哪里？它由消息中的一个头
    `TwitterHeaders.DM_TARGET_USER_ID` 决定。这可以通过编程方式填充，或使用丰富器或 SpEL。例如，可以通过以下方式编程添加：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, it can be populated by using a header enricher, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'Alternatively, it can be populated by using a header enricher, as follows:
    通过使用头丰富器，如下所示：'
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Twitter search outbound gateway
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter 搜索出站网关
- en: 'As gateways provide a two-way window, the search outbound gateway can be used
    to issue dynamic search commands and receive the results as a collection. If no
    result is found, the collection is empty. Let''s configure a search outbound gateway,
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网关提供双向窗口，搜索出站网关可用于发出动态搜索命令并接收结果作为集合。如果没有找到结果，集合为空。让我们配置一个搜索出站网关，如下所示：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here is what the tags covered in this code mean:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码标签的含义：
- en: '`int-twitter:search-outbound-gateway`: This is the namespace for the Twitter
    search outbound gateway'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-twitter:search-outbound-gateway`: 这是 Twitter 搜索出站网关的命名空间。'
- en: '`request-channel`: This is the channel that is used to send search requests
    to this gateway'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request-channel`: 用于将搜索请求发送到这个网关的频道。'
- en: '`twitter-template`: This is the Twitter template reference'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twitter-template`：这是 Twitter 模板引用'
- en: '`search-args-expression`: This is used as arguments for the search'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search-args-expression`：此参数用于查询标签中的搜索'
- en: '`reply-channel`: This is the channel on which searched results are populated'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reply-channel`：在这个频道上填充搜索结果。'
- en: This gives us enough to get started with the social integration aspects of the
    spring framework.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们有足够的内容开始使用 Spring 框架的社会整合方面。
- en: Enterprise messaging
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业消息传递
- en: Enterprise landscape is incomplete without JMS—it is one of the most commonly
    used mediums of enterprise integration. Spring provides very good support for
    this. Spring Integration builds over that support and provides adapter and gateways
    to receive and consume messages from many middleware brokers such as ActiveMQ,
    RabbitMQ, Rediss, and so on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 没有JMS的企业景观是不完整的——它是企业集成中最常用的媒介之一。Spring为此提供了非常好的支持。Spring Integration在此基础上构建，为接收和消费来自许多中间件代理（如ActiveMQ、RabbitMQ、Rediss等）的消息提供了适配器和网关。
- en: Spring Integration provides inbound and outbound adapters to send and receive
    messages along with gateways that can be used in a request/reply scenario. Let's
    walk through these implementations in a little more detail. A basic understanding
    of the JMS mechanism and its concepts is expected. It is not possible to cover
    even the introduction of JMS here. Let's start with the prerequisites.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration 提供入站和出站适配器，用于发送和接收消息，同时还提供了网关，这些网关可以在请求/回复场景中使用。让我们更详细地了解这些实现。预计需要对JMS机制及其概念有一个基本了解。在这里甚至连JMS的介绍都不可能涵盖。让我们从先决条件开始。
- en: Prerequisites
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'To use Spring Integration messaging components, namespaces, and relevant Maven
    the following dependency should be added:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Spring Integration消息组件、命名空间和相关Maven，应添加以下依赖项：
- en: 'Namespace support can be added by using the following code snippet:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段来添加命名空间支持：
- en: '[PRE31]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Maven entry can be provided using the following code snippet:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过以下代码片段提供Maven入口：
- en: '[PRE32]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After adding these two dependencies, we are ready to use the components. But
    before we can use an adapter, we must configure an underlying message broker.
    Let''s configure ActiveMQ. Add the following in `pom.xml`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加这两个依赖之后，我们就准备好使用组件了。但在我们可以使用适配器之前，我们必须配置一个底层消息代理。让我们配置ActiveMQ。在`pom.xml`中添加以下内容：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After this, we are ready to create a connection factory and JMS queue that
    will be used by the adapters to communicate. First, create a session factory.
    As you will notice, this is wrapped in Spring''s `CachingConnectionFactory`, but
    the underlying provider is ActiveMQ:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们准备创建一个连接工厂和JMS队列，这些队列将由适配器用于通信。首先，创建一个会话工厂。正如您将注意到的，这被包裹在Spring的`CachingConnectionFactory`中，但底层提供者是ActiveMQ：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s create a queue that can be used to retrieve and put messages:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个队列，以便用于检索和放置消息：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we are ready to send and retrieve messages from the queue. Let's look into
    each message one by one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备从队列中发送和接收消息。让我们逐一查看每个消息。
- en: Receiving messages – the inbound adapter
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收消息——入站适配器
- en: 'Spring Integration provides two ways of receiving messages: polling and event
    listener. Both of them are based on the underlying Spring framework''s comprehensive
    support for JMS. `JmsTemplate` is used by the polling adapter, while `MessageListener`
    is used by the event-driven adapter. As the name suggests, a polling adapter keeps
    polling the queue for the arrival of new messages and puts the message on the
    configured channel if it finds one. On the other hand, in the case of the event-driven
    adapter, it''s the responsibility of the server to notify the configured adapter.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration 提供两种接收消息的方式：轮询和事件监听器。它们都基于Spring框架对JMS的全面支持。轮询适配器使用`JmsTemplate`，而事件驱动适配器使用`MessageListener`。正如名称所示，轮询适配器会不断轮询队列以等待新消息的到来，如果找到消息，则将其放入配置的通道中。另一方面，在事件驱动适配器的情况下，通知配置适配器是服务器的责任。
- en: The polling adapter
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮询适配器
- en: 'Let''s start with a code sample:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个代码示例开始：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There is a poller element, so it''s obvious that it is a polling-based adapter.
    It can be configured in one of two ways: by providing a JMS template or using
    a connection factory along with a destination. I have used the latter approach.
    The preceding adapter has a polling queue mentioned in the destination and once
    it gets any message, it puts the message on the channel configured in the `channel`
    attribute.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个轮询器元素，因此很明显它是一个基于轮询的适配器。它可以通过两种方式之一进行配置：通过提供JMS模板或使用连接工厂和目标。我使用了后者的方法。前面的适配器在目标中提到了一个轮询队列，一旦它收到任何消息，它就会将消息放入`channel`属性中配置的通道中。
- en: The event-driven adapter
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件驱动的适配器
- en: 'Similar to polling adapters, event-driven adapters also need a reference either
    to an implementation of the interface `AbstractMessageListenerContainer` or need
    a connection factory and destination. Again, I will use the latter approach. Here
    is a sample configuration:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与轮询适配器类似，事件驱动适配器也需要引用实现`AbstractMessageListenerContainer`接口的类或需要一个连接工厂和目的地。再次，我将使用后一种方法。这是一个示例配置：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There is no poller sub-element here. As soon as a message arrives at its destination,
    the adapter is invoked, which puts it on the configured channel.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有轮询器子元素。一旦消息到达其目的地，适配器就会被调用，将其放入配置的通道。
- en: Sending messages – the outbound adapter
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息——出站适配器
- en: 'Outbound adapters convert messages on the channel to JMS messages and put them
    on the configured queue. To convert Spring Integration messages to JMS messages,
    the outbound adapter uses `JmsSendingMessageHandler`. This is is an implementation
    of `MessageHandler`. Outbound adapters should be configured with either `JmsTemplate`
    or with a connection factory and destination queue. Keeping in sync with the preceding
    examples, we will take the latter approach, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 出站适配器将通道上的消息转换为JMS消息，并将其放入配置的队列中。为了将Spring Integration消息转换为JMS消息，出站适配器使用`JmsSendingMessageHandler`。这是一个`MessageHandler`的实现。出站适配器应该使用`JmsTemplate`或与目的地队列一起配置连接工厂。与前面的示例保持一致，我们将采用后一种方法，如下所示：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This adapter receives the Spring Integration message from `jmsChannel`, converts
    it to a JMS message, and puts it on the destination.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个适配器接收来自`jmsChannel`的Spring Integration消息，将其转换为JMS消息，并将其放入目标地。
- en: Gateway
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网关
- en: Gateway provides a request/reply behavior instead of a one-way send or receive.
    For example, after sending a message, we might expect a reply or we may want to
    send an acknowledgement after receiving a message.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 网关提供请求/回复行为，而不是单向发送或接收。例如，在发送消息后，我们可能期望有一个回复，或者在接收到消息后我们可能想发送一个确认。
- en: The inbound gateway
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入站网关
- en: 'Inbound gateways provide an alternative to inbound adapters when request-reply
    capabilities are expected. An inbound gateway is an event-based implementation
    that listens for a message on the queue, converts it to Spring `Message`, and
    puts it on the channel. Here is a sample code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 入站网关在预期请求回复功能时提供了入站适配器的替代方案。入站网关是一个基于事件的实现，监听队列上的消息，将其转换为Spring `Message`，并将其放入通道。这是一个示例代码：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, this is what an inbound adapter does—even the configuration is similar,
    except the namespace. So, what is the difference? The difference lies in replying
    back to the reply destination. Once the message is put on the channel, it will
    be propagated down the line and at some stage a reply would be generated and sent
    back as an acknowledgement. The inbound gateway, on receiving this reply, will
    create a JMS message and put it back on the reply destination queue. Then, where
    is the reply destination? The reply destination is decided in one of the following
    ways:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这就是入站适配器所做的——甚至配置也很相似，除了命名空间。那么区别在哪里呢？区别在于回复回复目的地。一旦消息放入通道，它将沿着线路传播，在某个阶段会产生一个回复并作为确认发送回来。当入站网关接收到这个回复时，将创建一个JMS消息并将其放回回复目的地队列。那么，回复目的地在哪里呢？回复目的地以下列方式之一决定：
- en: Original message has a property `JMSReplyTo`, if it's present it has the highest
    precedence.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始消息有一个属性`JMSReplyTo`，如果存在，它具有最高的优先级。
- en: The inbound gateway looks for a configured, default-reply-destination which
    can be configured either as a name or as a direct reference of a channel. For
    specifying channel as direct reference default-reply-destination tag should be
    used.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 入站网关寻找一个配置好的默认回复目的地，它可以作为名称或直接引用通道。为了将通道作为直接引用指定默认回复目的地，应使用default-reply-destination标签。
- en: An exception will be thrown by the gateway if it does not find either of the
    preceding two ways.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网关找不到前面两种方法中的任何一种，它将抛出一个异常。
- en: The outbound gateway
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出站网关
- en: 'Outbound gateways should be used in scenarios where a reply is expected for
    the send messages. Let''s start with an example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在预期有回复的发送消息场景中应使用出站网关。让我们从一个例子开始：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding configuration will send messages to `request-destination`. When
    an acknowledgement is received, it can be fetched from the configured `reply-destination`.
    If `reply-destination` has not been configured, JMS `TemporaryQueues` will be
    created.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置将消息发送到`request-destination`。当收到确认时，它可以从配置的`reply-destination`中获取。如果没有配置`reply-destination`，将创建JMS
    `TemporaryQueues`。
- en: HTTP
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: Spring Integration provides support to access external HTTP services as well
    as to expose HTTP services to an external application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了访问外部HTTP服务以及将HTTP服务暴露给外部应用程序的支持。
- en: Prerequisites
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Let''s add a namespace and relevant Maven dependency so that Spring Integration''s
    HTTP components are available for use in our application:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个命名空间和相关Maven依赖项，以便在我们的应用程序中可以使用Spring Integration的HTTP组件：
- en: 'Namepace support can be added using the following code snippet:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段添加命名空间支持：
- en: '[PRE42]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Maven entry can be added using the following code:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过以下代码添加Maven条目：
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The HTTP inbound gateway
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP入站网关
- en: 'Inbound gateways expose HTTP services to the external world, for example, REST-based
    web services. The application must be deployed in a web container such as Jetty
    or Tomcat for the inbound adapter or the gateway to work. The easiest way to implement
    the inbound component is by using Spring''s `HttpRequestHandlerServlet` class,
    and by defining it in the `web.xml` file. Here is a sample entry:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 入站网关将HTTP服务暴露给外部世界，例如，基于REST的Web服务。应用程序必须部署在Jetty或Tomcat等Web容器中，以便入站适配器或网关正常工作。实现入站组件的最简单方法是使用Spring的`HttpRequestHandlerServlet`类，并在`web.xml`文件中定义它。这是一个示例条目：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Alternatively, we can use the spring MVC support. This is what we have used
    in our example; let''s take a look at the `web.xml` file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用spring MVC支持。这是我们示例中使用的方法；让我们来看看`web.xml`文件：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `org.springframework.web.servlet.DispatcherServlet` class is a standard
    Spring MVC controller. Notice the configuration parameter, `http-inbound-config.xml`.
    This is the file that will have the declaration for the gateway:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.web.servlet.DispatcherServlet`类是一个标准的Spring MVC控制器。请注意配置参数，`http-inbound-config.xml`。这是将包含网关声明的文件：'
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The components used in this code are explained in the following bullet points:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中使用的组件在以下子弹点中解释：
- en: '`int-http:inbound-gateway`: This is the namespace support for the HTML gateway'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-http:inbound-gateway`: 这是对HTML网关的命名空间支持。'
- en: '`request-channel`: This will put the incoming request payload on the channel'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request-channel`: 这会将传入的请求负载放入通道中。'
- en: '`path`: This is the path exposed for incoming requests'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这是对外来请求暴露的路径。'
- en: '`supported-methods`: This is a comma-separated list of supported methods that
    use the HTTP protocol'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supported-methods`: 这是一个用逗号分隔的支持方法列表，这些方法使用HTTP协议。'
- en: 'In the following code, the service activator listens for the payload on the
    input channel and modifies it before an inbound gateway sends a response:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，服务激活器监听输入通道上的负载并在入站网关发送响应之前对其进行修改：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`HttpMessageConverter` can be used to convert `HttpServletRequest` to `Messages`.
    A gateway element produces different instances depending on whether it has to
    return just a response (for example 200 success) or it has to return a response
    with a view. If the response is a view, it produces an instance of `HttpRequestHandlingController`.
    Otherwise, it produces an instance of `HandlingMessagingGateway`. To render the
    view, any view-rendering technology supported by Spring MVC can be used.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpMessageConverter`可以用来将`HttpServletRequest`转换为`Messages`。网关元素根据它是否只需要返回一个响应（例如200成功）还是需要返回一个带有视图的响应，产生不同的实例。如果响应是一个视图，它产生一个`HttpRequestHandlingController`实例。否则，它产生一个`HandlingMessagingGateway`实例。要渲染视图，可以使用Spring
    MVC支持的任何视图渲染技术。'
- en: 'For requests that just require a confirmation that the request was successful,
    an adapter can be used instead of the gateway:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只需要确认请求成功的请求，可以使用适配器而不是网关：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The HTTP outbound gateway
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP出站网关
- en: 'The outbound gateway is used to invoke services published by external HTTP
    components. Let''s use our preceding example to test this. Create a war of the
    application that has inbound gateways and deploy it in a container. We can use
    the following example of an outbound gateway to invoke the HTTP request:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 出站网关用于调用由外部HTTP组件发布的服务。让我们用我们之前的例子来测试这个。创建一个包含入站网关的应用程序war，并在容器中部署它。我们可以使用以下出站网关示例来调用HTTP请求：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The components used in this code are explained in the following bullet points:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中使用的组件在以下子弹点中解释：
- en: '`int-http:outbound-gateway`: This is the namespace support for the HTTP outbound
    gateway'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-http:outbound-gateway`: 这是对HTTP出站网关的命名空间支持。'
- en: '`channel`: Based on the message on this channel, it will try to hit the URL'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`: 根据这个通道上的消息，它将尝试击中URL。'
- en: '`url`: This is the external URL to which a request is made'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：这是对外部URL的请求。'
- en: '`http-method`: This specifies which HTTP methods should be used while making
    the request'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http-method`：这指定了在发送请求时应使用哪些HTTP方法'
- en: '`expected-response-type`: This is the type of response expected (by default,
    it''s `String`)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expected-response-type`：这是期望的响应类型（默认情况下，它是`String`）'
- en: 'Instead of gateway, adapters can also be used. The only difference is that
    an adapter does not send a response back on the reply channel. Under the hood,
    outbound adapters use the `RestTemplate` from the Spring framework. The following
    code snippet adds the outbound adapter:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网关，还可以使用适配器。唯一的区别是适配器不会在回复通道上发送响应。在幕后，出站适配器使用Spring框架的`RestTemplate`。以下代码片段添加了出站适配器：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Web services
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务
- en: The HTTP adapter and gateways provide support for REST-based web services, but
    Spring Integration also provides support for XML-based web services such as SOAP.
    An inbound adapter or gateway is used to create and expose an endpoint as a web
    service, while an outbound adapter or gateway is used to invoke external services.
    Spring Integration support for web services is built over the spring `ws` project.
    I am not going to cover spring `ws` or any specific SOAP details such as `wsdl`,
    header, body, or payload. Instead, we will showcase the Spring Integration wrappers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP适配器和网关为基于REST的Web服务提供支持，但Spring Integration还支持基于XML的Web服务，如SOAP。入站适配器或网关用于创建和暴露Web服务端点，而出站适配器或网关用于调用外部服务。Spring
    Integration对Web服务的支持建立在spring `ws` 项目之上。我不会涵盖spring `ws` 或任何特定的SOAP细节，如`wsdl`、头部、正文或负载。相反，我们将展示Spring
    Integration封装器。
- en: Prerequisites
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'Web services support can be added by including the following namespaces and
    Maven dependencies:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过包含以下命名空间和Maven依赖项来添加Web服务支持：
- en: 'Namespace support can be added using the following code snippet:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段添加命名空间支持：
- en: '[PRE51]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Maven entry can be added using the following code:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过以下代码添加Maven条目：
- en: '[PRE52]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The inbound gateway
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入站网关
- en: 'Inbound gateways will expose a SOAP service for handling an external request,
    which will then be converted to messages and posted to the channel. A front controller
    is required to intercept requests and pass them on the configured gateway; it
    is an instance of `org.springframework.ws.transport.http.MessageDispatcherServlet`.
    This should be configured in the `web.xml` file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 入站网关将暴露一个SOAP服务以处理外部请求，然后将其转换为消息并发布到通道。需要一个前端控制器来拦截请求并将它们传递给配置的网关；它是`org.springframework.ws.transport.http.MessageDispatcherServlet`的一个实例。这应该在`web.xml`文件中进行配置：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'An implementation of `org.springframework.ws.server.EndpointMapping` must be
    provided to do the mapping between servlet and an endpoint. This can be configured
    either in the Java configuration class or property file. Let''s put it in a property
    file and inject it as `contextConfigLocation`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 必须提供一个`org.springframework.ws.server.EndpointMapping`的实现来将servlet与端点之间进行映射。这可以在Java配置类或属性文件中进行配置。让我们将其放在属性文件中并将其作为`contextConfigLocation`注入：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `org.springframework.ws.server.endpoint.mapping.UriEndpointMapping` class
    performs servlet to `Message` mapping.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.ws.server.endpoint.mapping.UriEndpointMapping`类执行servlet到`Message`的映射。'
- en: 'After that, we have the service activator that can change the response or do
    some operations on it:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有服务激活器，它可以改变响应或对其执行一些操作：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The outbound gateway
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出站网关
- en: 'This is even easier; the outbound gateway can take a URI and invoke the service,
    as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至更容易；出站网关可以接受一个URI并调用服务，如下所示：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding code, a valid SOAP payload should be put on the `request-channel`;
    this will be used by the gateway to invoke the service configured. The payload
    of the response is published on the `reply-channel`. Here is an example code snippet
    to invoke the preceding service:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，应该在`request-channel`上放置一个有效的SOAP负载；这将由网关用来调用配置的服务。响应的负载发布在`reply-channel`上。以下是一个调用前面服务的示例代码片段：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Database SQL
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库SQL
- en: It's difficult to imagine enterprise applications without any database; it is
    one of the oldest and most commonly used bridging mechanisms. Spring Integration
    provides support to read from and write to the database. Again, this support is
    based on the Spring framework's foundation for database support. It provides inbound
    and outbound adapters, gateways, and even specific adapters for stored procedures.
    Let's have a look at some of these, and others can be used on the same pattern.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象没有数据库的企业应用程序；它是最古老和最常用的桥接机制之一。Spring Integration提供了从数据库读取和写入数据库的支持。再次，这种支持是基于Spring框架对数据库支持的基础之上的。它提供了入站和出站适配器、网关，甚至还有针对存储过程的特定适配器。让我们来看看其中的一些，其他的可以使用相同的模式。
- en: Prerequisites
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Before we talk about how to use database support of Spring Integration, let''s
    add the necessary namespaces and Maven dependencies:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何使用Spring Integration的数据库支持之前，让我们添加必要的命名空间和Maven依赖项：
- en: 'Namespace support can be added using the following code snippet:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过以下代码片段添加命名空间支持：
- en: '[PRE58]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Maven entry can be added using the following code snippet:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过以下代码片段添加Maven入口：
- en: '[PRE59]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Datasource
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据源
- en: 'Before we can start using the component, we need to define a datasource. Datasource
    is a wrapper that encapsulates database connection details. A sample datasource
    for an in-memory database H2 is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用组件之前，我们需要定义一个数据源。数据源是一个封装数据库连接细节的包装器。以下是一个针对内存数据库H2的示例数据源：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For simplicity, I will use an in-memory database. But this is nothing specific
    to Spring Integration; datasource can be configured for any database supported
    by Spring. Include the following dependency in `pom.xml` for the in-memory database:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我将使用一个内存数据库。但这与Spring Integration无关；可以为Spring支持的任何数据库配置数据源。在`pom.xml`中包含以下依赖项，以使用内存数据库：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we are ready with the datasource. Let''s initialize it with some test
    data; again, Spring provides easy-to-use components that can get our task done
    in a couple of lines of configuration:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了数据源。让我们用一些测试数据来初始化它；再次，Spring提供了易于使用的组件，可以在几行配置中完成我们的任务：
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With the preceding configuration, we are now ready to explore the adapters,
    gateways, and other components provided by Spring.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面的配置，我们现在可以探索Spring提供的适配器、网关和其他组件。
- en: Reading from the database – the inbound adapter
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据库读取——入站适配器
- en: 'The inbound adapter needs a reference to `JdbcTemplate` or datasource. We will
    stick to datasource. Its task is to read data from the database and put the result
    on the specified channel. By default, the message payload is the whole result
    set expressed as a list. The result set type can be changed by defining the `RowMapper`
    strategy, support for which is provided by spring:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 入站适配器需要一个对`JdbcTemplate`或数据源的引用。我们将坚持使用数据源。它的任务是从数据库中读取数据，并将结果放置在指定的通道上。默认情况下，消息载荷是整个结果集，表示为一个列表。可以通过定义`RowMapper`策略来更改结果集类型，Spring为此提供了支持：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This configuration will connect to the database configured in the datasource.
    In our case, it's an in-memory database, that is, H2\. It will execute the query
    and issue an update. The result will be put on the configured channel. The update
    query is very handy when we want to filter out already processed records in the
    next polling cycle.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将连接到数据源中配置的数据库。在我们这个案例中，它是一个内存数据库，即H2。它将执行查询并发出更新。结果将被放置在配置的通道上。在下一轮轮询周期中，当我们想要过滤掉已经处理过的记录时，更新查询非常有用。
- en: Transaction support
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务支持
- en: 'Transaction support for the inbound adapter can be wrapped along with the poller:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 入站适配器的事务支持可以与轮询器一起包装：
- en: '[PRE65]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With transaction as a sub-element of poller, query and update will be executed
    in the same transaction. A valid transaction manager should be defined; again
    it''s nothing specific to Spring Integration. Instead, spring-based entity manager
    and transaction manager should be defined (again, this is nothing to do with Spring
    Integration; instead, it''s standard spring database support stuff). The code
    is as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当事务作为轮询器的子元素时，查询和更新将在同一个事务中执行。应该定义一个有效的事务管理器；这与Spring Integration无关。相反，应该定义基于Spring的实体管理器和事务管理器（这与Spring
    Integration无关；相反，这是标准的Spring数据库支持内容）。代码如下：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Writing to the database – the outbound adapter
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数据库写入——出站适配器
- en: 'The outbound adapter can be used to insert data in the database; it can use
    the message on the channel to construct the query and execute it. The following
    code will add the outbound adapter:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 出站适配器可用于将数据插入数据库；它可以使用通道上的消息来构建查询并执行它。以下代码将添加出站适配器：
- en: '[PRE67]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This extracts a value from the payload and writes the data in the database.
    The database to which data will be written depends on the datasource.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作从有效负载中提取一个值，并将数据写入数据库。将写入的数据库取决于数据源。
- en: Inbound and outbound gateways
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入站和出站网关
- en: 'Gateways combine input and output adapter functionalities; it fires a query
    and posts the reply on the reply channel:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 网关结合了输入和输出适配器功能；它发起一个查询并在回复通道上发布回复：
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Outbound gateways require a reference to the datasource that is used to decide
    the database to connect to.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 出站网关需要一个引用，该引用用于决定连接到哪个数据库。
- en: Stream processing
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流处理
- en: 'Spring Integration provides two implicit components for stream: one to read
    the streams and an other to write to streams. This section is small—let''s quickly
    get to the code!'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration 为流提供了两个隐式组件：一个用于读取流，另一个用于写入流。这个部分很小——让我们快速进入代码！
- en: Prerequisites
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'First, let''s add the namespaces and Maven dependencies:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加命名空间和 Maven 依赖项：
- en: 'Namespace support can be added using the following code:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码添加命名空间支持：
- en: '[PRE69]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Maven dependencies can be added using the following code snippet:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 依赖项可以使用以下代码片段添加：
- en: '[PRE70]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With the previous inclusion, we are ready to use the adapters.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的包含之后，我们准备好使用适配器了。
- en: Reading from a stream
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从流中读取
- en: 'There is a STDIN adapter provided by Spring Integration that reads from `stdin`.
    What is this `stdin`? Any stuff that is written to the command line, for example,
    `System.in` in Java. The following code snippet is used to add the STDIN adapter:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration 提供了一个 STDIN 适配器，该适配器从 `stdin` 读取。这个 `stdin` 是什么？任何写在命令行上的东西，例如
    Java 中的 `System.in`。以下代码片段用于添加 STDIN 适配器：
- en: '[PRE71]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, `int-stream:stdin-channel-adapter` is the namespace support and channel
    where the adapter puts the messages that have been written to the console.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`int-stream:stdin-channel-adapter` 是命名空间支持，通道适配器将把写入控制台的消息放进去。
- en: 'If we want to get some insider view, spring uses either `ByteStreamReadingMessageSource`
    or `CharacterStreamReadingMessageSource`, which are implementations of `MessageSource`,
    to provide the adapter functionality. `ByteStreamReadingMessageSource` needs `InputStream`,
    while `CharacterStreamReadingMessageSource` needs `Reader`, as shown in the following
    code snippet:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获得一些内部视图，Spring 分别使用 `ByteStreamReadingMessageSource` 或 `CharacterStreamReadingMessageSource`，它们是
    `MessageSource` 的实现，以提供适配器功能。`ByteStreamReadingMessageSource` 需要 `InputStream`，而
    `CharacterStreamReadingMessageSource` 需要 `Reader`，如下面的代码片段所示：
- en: '[PRE72]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Writing to a stream
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入流
- en: 'A similar adapter for writing to the console is also provided by Spring: `stdout`.
    It prints to the console whatever message it gets on the channel. Let''s plug
    a `stdout` adapter to the preceding code and the output will be directed to the
    console:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 还提供了一个类似的适配器，用于将消息写入控制台：`stdout`。它将通道上收到的任何消息打印到控制台。让我们在前面的代码中插入一个 `stdout`
    适配器，输出将被定向到控制台：
- en: '[PRE73]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`int-stream:stdout-channel-adapter` is the namespace, and channel is what the
    adapter will be polling for messages, and then print each on the console. `append-newline`
    will add a new line to output.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`int-stream:stdout-channel-adapter` 是命名空间，适配器将轮询通道中的消息，然后将每个消息打印到控制台。`append-newline`
    将添加一个新行到输出。'
- en: 'Behind the scenes, Spring uses either `ByteStreamWritingMessageHandler` or
    `CharacterStreamWritingMessageHandler`. They require a reference of `OutputStream`
    and `Writer`, respectively:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Spring 框架使用 either `ByteStreamWritingMessageHandler` 或 `CharacterStreamWritingMessageHandler`。它们分别需要一个
    `OutputStream` 和 `Writer` 的引用：
- en: '[PRE74]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This has been a long chapter and we all deserve a coffee break!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的章节，我们都应该休息一下了！
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter showcased the simplicity and abstraction that Spring Integration
    provides when it comes to handling complicated integrations, be it file-based,
    HTTP, JMS, or any other integration mechanism. Do not panic; I promise that the
    next few chapters are going to be smaller, and we will cover the testability of
    Spring Integration, performance, management, and then wrap up with an end-to-end
    example. In the next chapter, we will cover how Spring Batch and Spring Integration
    can be integrated to leverage the best of each framework.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了Spring Integration在处理复杂集成时提供的简单性和抽象能力，无论是基于文件的、HTTP的、JMS的还是其他任何集成机制。不要恐慌；我保证接下来的几章会相对简短，我们将讨论Spring
    Integration的可测试性、性能和管理的主题，最后以一个端到端的示例来结束。在下一章中，我们将介绍如何将Spring Batch和Spring Integration集成，以充分利用这两个框架的优势。
