- en: '*Chapter 4*: Exception Handling'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：异常处理'
- en: 'In [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*, we briefly introduced exceptions. In this chapter, we will treat this
    topic more systematically. There are two kinds of exceptions in Java: checked
    and unchecked. We’ll demonstrate each of them, and the differences between the
    two will be explained. Additionally, you will learn about the syntax of the Java
    constructs related to exception handling and the best practices to address (that
    is, handle) those exceptions. The chapter will end on the related topic of assertion
    statements, which can be used to debug the code in production.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*Java 17入门*中，我们简要介绍了异常。在本章中，我们将更系统地探讨这个主题。Java中有两种异常：检查型和非检查型。我们将演示每种类型，并解释两者之间的区别。此外，你还将了解与异常处理相关的Java构造的语法以及处理这些异常的最佳实践。本章将以断言语句的相关主题结束，断言语句可用于在生产环境中调试代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Java exceptions framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java异常框架
- en: Checked and unchecked (runtime) exceptions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查型和非检查型（运行时）异常
- en: The `try`, `catch`, and `finally` blocks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`、`catch`和`finally`块'
- en: The `throws` statement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throws`语句'
- en: The `throw` statement
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw`语句'
- en: The `assert` statement
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`语句'
- en: Best practices of exception handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理的最佳实践
- en: So, let’s begin!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples that are provided in this chapter,
    you will need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行本章提供的代码示例，你需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭载Microsoft Windows、Apple macOS或Linux操作系统的计算机
- en: Java SE version 17, or later
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE版本17或更高
- en: An IDE or code editor that you prefer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你偏好的IDE或代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files with the code examples for this chapter are available on GitHub
    in the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository. Please search in the `examples/src/main/java/com/packt/learnjava/ch04_exceptions`
    folder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*Java 17入门*中提供了如何设置Java SE和IntelliJ
    IDEA编辑器的说明。本章的代码示例文件可在GitHub的[https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)仓库中找到。请在`examples/src/main/java/com/packt/learnjava/ch04_exceptions`文件夹中搜索。
- en: The Java exceptions framework
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java异常框架
- en: 'As described in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting
    Started with Java 17*, an unexpected condition can cause the `catch` clause, that
    is, if the exception was thrown inside a `try` block. Let’s look at an example.
    Consider the following method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第一章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*Java 17入门*所述，一个意外的条件可以导致`catch`子句，即如果异常是在`try`块内部抛出的。让我们看一个例子。考虑以下方法：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the input parameter value is `null`, you could expect to see the output as
    `Not equal`. Unfortunately, that is not the case. The `s.equals("abc")` expression
    calls the `equals()` method on an object referred to by the `s` variable; however,
    if the `s` variable is `null`, it does not refer to any object. Let’s see what
    happens next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入参数值为`null`，你可能会看到输出为`Not equal`。不幸的是，情况并非如此。`s.equals("abc")`表达式在由`s`变量引用的对象上调用`equals()`方法；然而，如果`s`变量为`null`，它不指向任何对象。让我们看看接下来会发生什么。
- en: 'Let’s run the following code (that is, the `catchException1()` method in the
    `Framework` class):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下代码（即`Framework`类中的`catchException1()`方法）：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code includes the `waitForStackTrace()` method, allowing you
    to wait a bit until the stack trace has been generated. Otherwise, the output
    would be out of sequence. The output of this code appears as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包括`waitForStackTrace()`方法，允许你等待一段时间直到生成堆栈跟踪。否则，输出将会顺序混乱。此代码的输出如下所示：
- en: '[PRE21]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, the method prints the name of the exception class, followed
    by a **stack trace**. The name of **stack trace** comes from the way the method
    calls are stored (as a stack) in JVM memory: one method calls another, which,
    in turn, calls another, and so on. After the most inner method returns, the stack
    is walked back, and the returned method (**stack frame**) is removed from the
    stack. We will talk about the JVM memory structure, in more detail, in [*Chapter
    9*](B18388_09_ePub.xhtml#_idTextAnchor205), *JVM Structure and Garbage Collection*.
    When an exception happens, all the stack content (such as the stack frames) is
    returned as the stack trace. This allows us to track down the line of code that
    caused the problem.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该方法打印出异常类的名称，然后是**堆栈跟踪**。**堆栈跟踪**这个名字来源于方法调用在JVM内存中存储的方式（作为一个堆栈）：一个方法调用另一个方法，然后这个方法又调用另一个方法，依此类推。在最内层方法返回后，堆栈被回溯，返回的方法（**堆栈帧**）从堆栈中移除。我们将在[*第9章*](B18388_09_ePub.xhtml#_idTextAnchor205)中更详细地讨论JVM内存结构，*JVM结构和垃圾回收*。当发生异常时，所有堆栈内容（如堆栈帧）都作为堆栈跟踪返回。这使我们能够追踪到导致问题的代码行。
- en: In the preceding code example, different blocks of code were executed depending
    on the type of the exception. In our case, it was `java.lang.NullPointerException`.
    If the application code does not catch it, this exception would propagate through
    the stack of the called methods into the JVM, which will then stop executing the
    application. To avoid this happening, the exception can be caught and code can
    be executed to recover from the exceptional condition.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，根据异常的类型执行了不同的代码块。在我们的情况下，它是`java.lang.NullPointerException`。如果应用程序代码没有捕获它，这个异常就会通过被调用方法的堆栈传播到JVM，然后JVM将停止执行应用程序。为了避免这种情况发生，可以捕获异常并执行代码以从异常状态中恢复。
- en: The purpose of the exception handling framework in Java is to protect the application
    code from an unexpected condition and, if possible, recover from it. In the following
    sections, we will dissect this concept in more detail and rewrite the given example
    using the framework capability.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Java中异常处理框架的目的是保护应用程序代码免受意外情况的影响，并在可能的情况下从该情况中恢复。在接下来的章节中，我们将更详细地剖析这个概念，并使用框架功能重写给定的示例。
- en: Checked and unchecked exceptions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查型异常和非检查型异常
- en: 'If you look up the documentation of the `java.lang` package API, you will discover
    that the package contains almost three dozen exception classes and a couple of
    dozen error classes. Both groups extend the `java.lang.Throwable` class, inherit
    all the methods from it, and do not add other methods. The methods that are most
    often used in the `java.lang.Throwable` class include the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查阅`java.lang`包API的文档，你会发现该包包含近三十个异常类和几十个错误类。这两组都扩展了`java.lang.Throwable`类，继承其所有方法，并不添加其他方法。在`java.lang.Throwable`类中最常使用的方法包括以下内容：
- en: '`void printStackTrace()`: This outputs the stack trace (stack frames) of the
    method calls.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void printStackTrace()`: 这将输出方法调用的堆栈跟踪（堆栈帧）。'
- en: '`StackTraceElement[] getStackTrace()`: This returns the same information as
    `printStackTrace()` but allows programmatic access of any frame of the stack trace.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackTraceElement[] getStackTrace()`: 这返回与`printStackTrace()`相同的信息，但允许以编程方式访问堆栈跟踪的任何帧。'
- en: '`String getMessage()`: This retrieves the message that often contains a user-friendly
    explanation of the reason for the exception or error.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String getMessage()`: 这将检索通常包含对异常或错误原因的友好解释的消息。'
- en: '`Throwable getCause()`: This retrieves an optional object of `java.lang.Throwable`
    that was the original reason for the exception (but the author of the code decided
    to wrap it in another exception or error).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Throwable getCause()`: 这将检索一个可选的`java.lang.Throwable`对象，它是异常的原始原因（但代码的作者决定将其包装在另一个异常或错误中）。'
- en: 'All errors extend the `java.lang.Error` class, which, in turn, extends the
    `java.lang.Throwable` class. Typically, an error is thrown by JVM and, according
    to the official documentation, *indicates serious problems that a reasonable application
    should not try to catch*. Here are a few examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有错误都扩展了`java.lang.Error`类，该类反过来又扩展了`java.lang.Throwable`类。通常，错误由JVM抛出，根据官方文档，*表示合理的应用程序不应该尝试捕获的严重问题*。以下是一些例子：
- en: '`OutOfMemoryError`: This is thrown when the JVM runs out of memory and cannot
    clean the memory using garbage collection.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OutOfMemoryError`: 当JVM耗尽内存且无法使用垃圾回收清理内存时抛出。'
- en: '`StackOverflowError`: This is thrown when the memory allocated for the stack
    of the method calls is not enough to store another stack frame.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackOverflowError`：当为方法调用栈分配的内存不足以存储另一个栈帧时，会抛出此异常。'
- en: '`NoClassDefFoundError`: This is thrown when the JVM cannot find the definition
    of the class requested by the currently loaded class.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoClassDefFoundError`：当JVM无法找到当前加载的类请求的类定义时，会抛出此异常。'
- en: The authors of the framework assumed that an application cannot recover from
    these errors automatically, which proved to be a largely correct assumption. That
    is why programmers, typically, do not catch errors, but that is beyond the scope
    of this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的作者假设应用程序无法自动从这些错误中恢复，这证明是一个大体正确的假设。这就是为什么程序员通常不捕获错误，但这超出了本书的范围。
- en: 'On the other hand, exceptions are typically related to application-specific
    problems and often do not require us to shut down the application and allow recovery.
    Usually, that is why programmers catch them and implement an alternative (to the
    main flow) path of the application logic, or at least report the problem without
    shutting down the application. Here are a few examples:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，异常通常与特定于应用程序的问题相关，并且通常不需要我们关闭应用程序并允许恢复。通常，这就是程序员捕获它们并实现应用程序逻辑的替代（主流程）路径，或者至少在不关闭应用程序的情况下报告问题。以下是一些示例：
- en: '`ArrayIndexOutOfBoundsException`: This is thrown when the code tries to access
    the element by the index that is equal to, or bigger than, the array length (remember
    that the first element of an array has an index of `0`, so the index is equal
    to the array length points outside of the array).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayIndexOutOfBoundsException`：当代码尝试通过等于或大于数组长度的索引访问元素时，会抛出此异常（请记住，数组的第一个元素具有索引`0`，因此索引等于数组长度指向数组外部）。'
- en: '`ClassCastException`: This is thrown when the code casts a reference to a class
    or an interface not associated with the object referred to by the variable.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassCastException`：当代码尝试将引用转换为与变量所引用的对象不关联的类或接口时，会抛出此异常。'
- en: '`NumberFormatException`: This is thrown when the code tries to convert a string
    into a numeric type, but the string does not contain the necessary number format.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberFormatException`：当代码尝试将字符串转换为数值类型，但字符串不包含必要的数字格式时，会抛出此异常。'
- en: All exceptions extend the `java.lang.Exception` class, which, in turn, extends
    the `java.lang.Throwable` class. That is why, by catching an object of the `java.lang.Exception`
    class, the code catches an object of any exception type. In the *The Java exceptions
    framework* section, we demonstrated this by catching `java.lang.NullPointerException`
    in the same way.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有异常都扩展了`java.lang.Exception`类，而该类反过来又扩展了`java.lang.Throwable`类。这就是为什么通过捕获`java.lang.Exception`类的对象，代码可以捕获任何异常类型的对象。在*Java异常框架*部分，我们通过以相同的方式捕获`java.lang.NullPointerException`来演示了这一点。
- en: One of the exceptions is `java.lang.RuntimeException`. The exceptions that extend
    it are called `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ClassCastException`,
    and `NumberFormatException`. The reason they are called runtime exceptions is
    clear; the reason they are called unchecked exceptions will become clear next.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个异常是`java.lang.RuntimeException`。扩展它的异常被称为`NullPointerException`、`ArrayIndexOutOfBoundsException`、`ClassCastException`和`NumberFormatException`。它们被称为运行时异常的原因很明显；它们被称为非受检异常的原因将在下一节中变得清晰。
- en: 'Those exceptions that do not have `java.lang.RuntimeException` among their
    ancestors are called `throws` clause of the method (please refer to the *The throws
    statement* section). This design forces the programmer to make a conscious decision,
    either to catch the checked exception or inform the client of the method that
    this exception might be thrown by the method and has to be processed (handled)
    by the client. Here are a few examples of checked exceptions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那些没有`java.lang.RuntimeException`在其祖先中的异常被称为方法的`throws`子句（请参阅*抛出语句*部分）。这种设计迫使程序员做出一个有意识的决策，要么捕获受检异常，要么通知方法的客户端该方法可能会抛出此异常，并且必须由客户端处理（处理）。以下是一些受检异常的示例：
- en: '`ClassNotFoundException`: This is thrown when an attempt to load a class using
    its string name with the `forName()` method of the `Class` class has failed.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassNotFoundException`：当尝试使用`Class`类的`forName()`方法通过字符串名称加载一个类失败时，会抛出此异常。'
- en: '`CloneNotSupportedException`: This is thrown when the code tries to clone an
    object that does not implement the `Cloneable` interface.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloneNotSupportedException`：当代码尝试克隆一个没有实现`Cloneable`接口的对象时，会抛出此异常。'
- en: '`NoSuchMethodException`: This is thrown when there is no method called by the
    code.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoSuchMethodException`：当代码中没有方法被调用时抛出。'
- en: Not all exceptions reside in the `java.lang` package. Many other packages contain
    exceptions related to the functionality that is supported by the package. For
    example, there is a `java.util.MissingResourceException` runtime exception and
    a `java.io.IOException` checked exception.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有异常都位于`java.lang`包中。许多其他包包含与包支持的功能相关的异常。例如，存在一个`java.util.MissingResourceException`运行时异常和一个`java.io.IOException`检查型异常。
- en: Despite not being forced, programmers often catch runtime (unchecked) exceptions
    to have better control of the program flow, making the behavior of an application
    more stable and predictable. By the way, all errors are also runtime (unchecked)
    exceptions. However, as we mentioned already, typically, it is not possible to
    handle them programmatically, so there is no point in catching descendants of
    the `java.lang.Error` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有强制要求，程序员经常捕获运行时（非检查型）异常以更好地控制程序流程，使应用程序的行为更加稳定和可预测。顺便说一下，所有错误也都是运行时（非检查型）异常。然而，正如我们之前提到的，通常无法通过程序来处理它们，因此捕获`java.lang.Error`类的子类没有意义。
- en: The try, catch, and finally blocks
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try、catch和finally块
- en: 'When an exception is thrown inside a `try` block, it redirects the control
    flow to the first `catch` clause. If there is no `catch` block that can capture
    the exception (but the `finally` block has to be in place), the exception propagates
    up and out of the method. If there is more than one `catch` clause, the compiler
    forces you to arrange them so that the child exception is listed before the parent
    exception. Let’s look at the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`try`块内部抛出异常时，它将控制流重定向到第一个`catch`子句。如果没有可以捕获异常的`catch`块（但必须存在`finally`块），异常将向上传播并退出方法。如果有多个`catch`子句，编译器会强制你按照子异常在父异常之前列出的顺序排列它们。让我们看看以下示例：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding example, a `catch` block with `NullPointerException` is placed
    before the block with `Exception` because `NullPointerException` extends `RuntimeException`,
    which, in turn, extends `Exception`. We could even implement this example, as
    follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，一个带有`NullPointerException`的`catch`块被放置在带有`Exception`的块之前，因为`NullPointerException`扩展了`RuntimeException`，而`RuntimeException`又扩展了`Exception`。我们甚至可以按照以下方式实现这个示例：
- en: '[PRE31]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the first `catch` clause only catches `NullPointerException`. Other
    exceptions that extend `RuntimeException` will be caught by the second `catch`
    clause. The rest of the exception types (that is, all of the checked exceptions)
    will be caught by the last `catch` block. Note that errors will not be caught
    by any of these `catch` clauses. To catch them, you should add a `catch` clause
    for `Error` (in any position) or `Throwable` (after the last `catch` clause in
    the previous example). However, usually, programmers do not do it and allow errors
    to propagate into the JVM.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个`catch`子句仅捕获`NullPointerException`。其他扩展`RuntimeException`的异常将由第二个`catch`子句捕获。其余的异常类型（即所有检查型异常）将由最后的`catch`块捕获。注意，错误不会被这些`catch`子句捕获。要捕获它们，你应该添加一个`catch`子句来捕获`Error`（在任何位置）或`Throwable`（在前一个示例中的最后一个`catch`子句之后）。然而，通常程序员不会这样做，并允许错误传播到JVM。
- en: 'Having a `catch` block for each exception type allows us to provide specific
    exception type processing. However, if there is no difference in the exception
    processing, you can simply have one `catch` block with the `Exception` base class
    to catch all types of exceptions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为每种异常类型都拥有一个`catch`块允许我们提供特定的异常类型处理。然而，如果没有异常处理上的差异，你可以简单地使用一个带有`Exception`基类的`catch`块来捕获所有类型的异常：
- en: '[PRE42]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If none of the clauses catch the exception, it is thrown further up until it
    is either handled by a `try...catch` statement in one of the method callers or
    propagates all the way out of the application code. In such a case, the JVM terminates
    the application and exits.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何子句捕获异常，它将被进一步抛出，直到它被方法调用者中的一个`try...catch`语句处理，或者传播到应用程序代码之外。在这种情况下，JVM将终止应用程序并退出。
- en: 'Adding a `finally` block does not change the described behavior. If present,
    it is always executed, whether an exception has been generated or not. Usually,
    a `finally` block is used to release the resources, to close a database connection,
    a file, or similar. However, if the resource implements the `Closeable` interface,
    it is better to use the `try-with-resources` statement, which allows you to release
    the resources automatically. The following demonstrates how it can be done with
    Java 7:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`finally`块不会改变描述的行为。如果存在，它总是会被执行，无论是否已生成异常。通常，`finally`块用于释放资源，关闭数据库连接、文件或类似资源。然而，如果资源实现了`Closeable`接口，最好使用`try-with-resources`语句，它允许你自动释放资源。以下是如何使用Java
    7实现的示例：
- en: '[PRE49]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding example creates the database connection, retrieves data and processes
    it, and then closes (calls the `close()` method) the `conn` and `rs` objects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了数据库连接，检索数据并处理它，然后关闭（调用`close()`方法）`conn`和`rs`对象。
- en: 'Java 9 enhances the `try-with-resources` statement’s capabilities by allowing
    the creation of objects that represent resources outside the `try` block, along
    with the use of them in a `try-with-resources` statement, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9通过允许在`try`块外部创建表示资源的对象，并在`try-with-resources`语句中使用它们，增强了`try-with-resources`语句的功能，如下所示：
- en: '[PRE61]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The preceding code looks much cleaner, although, in practice, programmers prefer
    to create and release (close) resources in the same context. If that is your preference
    too, consider using the `throws` statement in conjunction with the `try-with-resources`
    statement.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码看起来更简洁，尽管在实践中，程序员更喜欢在相同上下文中创建和释放（关闭）资源。如果这也是你的偏好，考虑使用`throws`语句与`try-with-resources`语句结合使用。
- en: The throws statement
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出语句
- en: 'We have to deal with `SQLException` because it is a checked exception, and
    the `getConnection()`, `createStatement()`, `executeQuery()`, and `next()` methods
    declare it in their `throws` clause. Here is an example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理`SQLException`，因为它是一个检查型异常，`getConnection()`、`createStatement()`、`executeQuery()`和`next()`方法都在它们的`throws`子句中声明了它。以下是一个示例：
- en: '[PRE72]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This means that the method’s author warns the method’s users that it might
    throw such an exception, forcing them to either catch the exception or to declare
    it in the `throws` clause of their methods. In our preceding example, we have
    chosen to catch it using two `try...catch` statements. Alternatively, we can list
    the exception in the `throws` clause and, thus, remove the clutter by effectively
    pushing the burden of the exception handling onto the users of our method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着方法的作者警告方法的使用者，它可能会抛出这样的异常，迫使他们要么捕获异常，要么在它们方法的`throws`子句中声明它。在我们的前一个例子中，我们选择使用两个`try...catch`语句来捕获它。或者，我们可以在`throws`子句中列出异常，从而通过有效地将异常处理的负担推给我们的方法的使用者来清除杂乱：
- en: '[PRE73]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We got rid of the catch clause, but we need the finally block to close the created
    conn and rs objects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去掉了捕获子句，但我们需要`finally`块来关闭创建的conn和rs对象。
- en: Please, notice how we included code that closes the conn object in a try block
    and we included the code that closes the rs object in the finally block. This
    way we make sure that an exception during closing of the conn object will not
    prevent us from closing the rs object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们如何在try块中包含了关闭conn对象的代码，在finally块中包含了关闭rs对象的代码。这样我们确保在关闭conn对象时发生的异常不会阻止我们关闭rs对象。
- en: This code looks less clear than the try-with-resources statement we demonstrated
    in the previous section. We show it just to demonstrate all the possibilities
    and how to avoid possible danger (of not closing the resources) if you decide
    to do it yourself, not letting the try-with-resources statement do it for you
    automatically.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比我们在上一节中演示的`try-with-resources`语句看起来更不清楚。我们展示它只是为了演示所有可能性以及如何避免可能的危险（不关闭资源），如果你决定自己这样做，而不是让`try-with-resources`语句自动为你做。
- en: But let us get back to the discussion of the throws statement.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们回到对`throws`语句的讨论。
- en: The `throws` clause allows but does not require us to list unchecked exceptions.
    Adding unchecked exceptions does not force the method’s users to handle them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`throws`子句允许但不强制我们列出未检查的异常。添加未检查的异常不会强制方法的使用者处理它们。'
- en: Finally, if the method throws several different exceptions, it is possible to
    list the base `Exception` exception class instead of listing all of them. That
    will make the compiler happy; however, this is not considered a good practice
    because it hides the details of particular exceptions that a method’s user might
    expect.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果方法抛出几个不同的异常，可以列出基类 `Exception` 异常类，而不是列出所有异常。这将使编译器高兴；然而，这并不被认为是一种好做法，因为它隐藏了方法用户可能期望的特定异常的细节。
- en: Please note that the compiler does not check what kind of exception the code
    in the method’s body can throw. So, it is possible to list any exception in the
    `throws` clause, which might lead to unnecessary overhead. If, by mistake, a programmer
    includes a checked exception in the `throws` clause that is never actually thrown
    by the method, the method’s user could write a `catch` block for it that is never
    executed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，编译器不会检查方法体中的代码可以抛出哪种类型的异常。因此，可以在 `throws` 子句中列出任何异常，这可能会导致不必要的开销。如果程序员错误地将一个永远不会实际抛出的检查型异常包含在
    `throws` 子句中，方法用户可能会为它编写一个永远不会执行的 `catch` 块。
- en: The throw statement
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: throw 语句
- en: 'The `throw` statement allows the throwing of any exception that a programmer
    deems necessary. You can even create your own exception. To create a checked exception,
    extend the `java.lang.Exception` class as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw` 语句允许抛出程序员认为必要的任何异常。您甚至可以创建自己的异常。要创建一个检查型异常，如下扩展 `java.lang.Exception`
    类：'
- en: '[PRE94]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Also, to create an unchecked exception, extend the `java.lang.RunitmeException`
    class, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要创建一个未检查型异常，如下扩展 `java.lang.RunitmeException` 类：
- en: '[PRE100]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Notice the *add code you need to have here* comment. You can add methods and
    properties to the custom exception as with any other regular class, but programmers
    rarely do it. In fact, the best practices explicitly recommend avoiding the use
    of exceptions for driving business logic. Exceptions should be what the name implies,
    covering only exceptional or very rare situations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 *在此处添加您需要的代码* 注释。您可以将方法和属性添加到自定义异常中，就像添加任何其他常规类一样，但程序员很少这样做。事实上，最佳实践明确建议避免使用异常来驱动业务逻辑。异常应该是其名称所暗示的，仅覆盖异常或非常罕见的情况。
- en: 'However, if you need to announce an exceptional condition, use the `throw`
    keyword and the `new` operator to create and trigger the propagation of an exception
    object. Here are a few examples:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您需要宣布一个异常条件，请使用 `throw` 关键字和 `new` 运算符来创建和触发异常对象的传播。以下是一些示例：
- en: '[PRE106]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'It is even possible to throw `null`, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以抛出 `null`，如下所示：
- en: '[PRE110]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The result of the preceding statement is the same as the result of this one:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个语句的结果与这个语句的结果相同：
- en: '[PRE111]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In both cases, an object of an unchecked `NullPointerException` exception begins
    to propagate through the system, until it is caught either by the application
    or the JVM.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，一个未检查的 `NullPointerException` 异常对象开始在整个系统中传播，直到它被应用程序或 JVM 捕获。
- en: The assert statement
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: assert 语句
- en: 'Once in a while, a programmer needs to know whether a particular condition
    has happened in the code, even after the application has already been deployed
    to production. At the same time, there is no need to run this check all the time.
    That is where the `assert` branching statement comes in handy. Here is an example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序员需要知道代码中是否发生了特定的条件，即使应用程序已经部署到生产环境中。同时，也没有必要一直运行这个检查。这就是 `assert` 分支语句派上用场的地方。以下是一个示例：
- en: '[PRE112]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In the preceding code, the `assert()` method takes input from the `assertSomething()`
    method. If the `assertSomething()` method returns `false`, the program stops executing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`assert()` 方法从 `assertSomething()` 方法获取输入。如果 `assertSomething()` 方法返回
    `false`，则程序停止执行。
- en: The `assert()` method is executed only when the JVM is run using the `-ea` option.
    The `-ea` flag should not be used in production, except maybe temporarily for
    testing purposes. This is because it creates an overhead that affects the application
    performance.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert()` 方法仅在 JVM 使用 `-ea` 选项运行时执行。在生产环境中不应使用 `-ea` 标志，除非可能是为了测试目的而临时使用。这是因为它会产生额外的开销，从而影响应用程序的性能。'
- en: Best practices of exception handling
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理最佳实践
- en: Checked exceptions were designed to be used for recoverable conditions when
    an application can do something automatically to amend or work around the problem.
    In practice, this doesn’t happen very often. Typically, when an exception is caught,
    the application logs the stack trace and aborts the current action. Based on the
    logged information, the application support team modifies the code to address
    the condition that is unaccounted for or to prevent it from occurring in the future.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 已检查异常是为了在应用程序可以自动采取措施修正或绕过问题时使用的可恢复条件而设计的。在实践中，这种情况并不常见。通常，当捕获到异常时，应用程序会记录堆栈跟踪并中止当前操作。根据记录的信息，应用程序支持团队修改代码以解决未记录的条件或防止其未来发生。
- en: 'Each application is different, so best practices depend on the particular application
    requirements, design, and context. In general, it seems that there is an agreement
    in the development community to avoid using checked exceptions and to minimize
    their propagation in the application code. The following is a list of a few other
    recommendations that have proved to be useful:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都是不同的，因此最佳实践取决于特定的应用程序需求、设计和上下文。一般来说，开发社区似乎达成了一致，避免使用已检查异常并尽量减少它们在应用程序代码中的传播。以下是一些已被证明有用的其他建议列表：
- en: Always catch all checked exceptions that are close to the source.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是捕获所有接近源头的已检查异常。
- en: If in doubt, catch unchecked exceptions that are also close to the source.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有疑问，捕获接近源头的未检查异常。
- en: Handle the exception as close to the source as possible because that is where
    the context is the most specific and where the root cause resides.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能地在源头附近处理异常，因为那里的上下文最为具体，根本原因也位于那里。
- en: Do not throw checked exceptions unless you have to because you force the building
    of extra code for a case that might never happen.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你真的需要，否则不要抛出已检查异常，因为这会强制为可能永远不会发生的情况构建额外的代码。
- en: Convert third-party checked exceptions into unchecked ones by re-throwing them
    as `RuntimeException` with the corresponding message if you have to.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你必须，通过将它们作为带有相应消息的`RuntimeException`重新抛出，将第三方已检查异常转换为未检查异常。
- en: Do not create custom exceptions unless you have to.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你真的需要，否则不要创建自定义异常。
- en: Do not drive business logic by using the exception handling mechanism unless
    you have to.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你真的需要，否则不要通过异常处理机制来驱动业务逻辑。
- en: Customize generic `RuntimeException` exceptions by using the system of messages
    and, optionally, the `enum` type instead of using the exception type to communicate
    the cause of the error.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用消息系统和可选的`enum`类型而不是使用异常类型来传达错误原因，自定义通用的`RuntimeException`异常。
- en: There are many other possible tips and recommendations; however, if you follow
    these, you are probably going to be fine in the vast majority of situations. With
    that, we conclude this chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他可能的提示和建议；然而，如果你遵循这些，你很可能在大多数情况下都会做得很好。因此，我们结束这一章。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to the Java exception handling framework,
    and you learned about two kinds of exceptions—checked and unchecked (runtime)—and
    how to handle them using `try-catch-finally` and `throws` statements. Also, you
    learned how to generate (throw) exceptions and how to create your own (custom)
    exceptions. The chapter concluded with the best practices of exception handling
    which, if followed consistently, will help you to write clean and clear code,
    which is pleasant to write and easy to understand and maintain.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你被介绍了Java异常处理框架，并学习了两种类型的异常——已检查的和未检查的（运行时）——以及如何使用`try-catch-finally`和`throws`语句来处理它们。你还学习了如何生成（抛出）异常以及如何创建自己的（自定义）异常。本章以异常处理的最佳实践结束，如果始终如一地遵循这些实践，将有助于你编写干净、清晰的代码，这样的代码易于编写、理解和维护。
- en: In the next chapter, we will talk about strings and their processing in detail,
    along with input/output streams and file reading and writing techniques.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细讨论字符串及其处理，以及输入/输出流和文件读写技术。
- en: Quiz
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: 'What is a stack trace? Select all that apply:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是堆栈跟踪？选择所有适用的：
- en: A list of classes currently loaded
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前加载的类列表
- en: A list of methods currently executing
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前正在执行的列表
- en: A list of code lines currently executing
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前正在执行的代码行列表
- en: A list of variables currently used
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前使用的变量列表
- en: 'What kinds of exceptions are there? Select all that apply:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些类型的异常？选择所有适用的：
- en: Compilation exceptions
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译异常
- en: Runtime exceptions
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: Read exceptions
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取异常
- en: Write exceptions
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写异常
- en: What is the output of the following code?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE120]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: A `RuntimeException` error
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`RuntimeException`错误
- en: '`Exception Error Finally`'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Exception Error Finally`'
- en: '`RuntimeException Finally`'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RuntimeException Finally`'
- en: '`Throwable Finally`'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Throwable Finally`'
- en: Which of the following methods will compile without an error?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个方法可以无错误地编译？
- en: '[PRE121]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '`method1()`'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method1()`'
- en: '`method2()`'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method2()`'
- en: '`method3()`'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method3()`'
- en: '`method4()`'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method4()`'
- en: Which of the following statements will compile without an error?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个语句可以无错误地编译？
- en: '[PRE122]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '1'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4'
- en: Assuming that `int x = 4`, which of the following statements will compile without
    an error?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`int x = 4`，以下哪个语句可以无错误地编译？
- en: '[PRE123]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '1'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4'
- en: Which are the best practices from the following list?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下列表中哪些是最佳实践？
- en: Always catch all exceptions and errors.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是捕获所有异常和错误。
- en: Always catch all exceptions.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是捕获所有异常。
- en: Never throw unchecked exceptions.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永远不要抛出未检查的异常。
- en: Try not to throw checked exceptions unless you have to.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非你不得不这样做，否则尽量不要抛出受检异常。
