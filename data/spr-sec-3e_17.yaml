- en: Microservice Security with OAuth 2 and JSON Web Tokens
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth 2和JSON Web Tokens的微服务安全
- en: In this chapter, we will take a look at microservices-based architectures and
    look at how OAuth 2 with **JSON Web Tokens** (**JWT**) plays a role in securing
    microservices in a Spring-based application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨基于微服务的架构，并查看OAuth 2与**JSON Web Tokens**（**JWT**）在Spring基础应用程序中扮演的安全角色。
- en: 'The following is a list of topics that will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中将要覆盖的主题列表：
- en: The general difference between monolithic applications and microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体应用和微服务之间的通用区别
- en: Comparing **service-oriented architectures** (**SOA**) with microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较**服务导向架构**（**SOA**）与微服务
- en: The conceptual architecture of OAuth 2 and how it provides your services with
    trustworthy client access
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2的概念架构及其如何为您的服务提供可信的客户端访问
- en: Types of OAuth 2 access tokens
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2访问令牌的类型
- en: Types of OAuth 2 grant types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2的授权类型
- en: Examining JWT and their general structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查JWT及其一般结构
- en: Implementing a resource server and authentication server used to grant access
    rights to clients in order to access OAuth 2 resources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现资源服务器和认证服务器，以授予客户端访问OAuth 2资源的权限
- en: Implementing a RESTful client to gain access to resources through an OAuth 2
    grant flow
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现RESTful客户端以通过OAuth 2授权流程访问资源
- en: We have quite a few items to cover in this chapter, but before we dig into the
    details of how to start leveraging Spring Security to implement OAuth 2 and JWT,
    we first want to create a baseline of the calendar application that does not have
    Thymeleaf or any other browser-based user interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这章中要覆盖的内容还有很多，但在我们详细介绍如何开始利用Spring Security实现OAuth 2和JWT之前，我们首先想要创建一个没有Thymeleaf或其他基于浏览器的用户界面的日历应用程序的基本线。
- en: After removing all Thymeleaf configuration and resources, the various controllers
    have been converted to **JAX-RS REST** controllers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除所有Thymeleaf配置和资源后，各种控制器已转换为**JAX-RS REST**控制器。
- en: You should start with the code from `chapter16.00-calendar`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter16.00-calendar`的代码开始。
- en: What are microservices?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务是什么？
- en: Microservices are an architectural approach that allows the development of physically
    separated modular applications which are autonomous, enabling agility, rapid development,
    continuous deployment, and scaling.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种允许开发物理上分离的模块化应用程序的架构方法，这些应用程序是自主的，支持敏捷性、快速开发、持续部署和扩展。
- en: An application is built as a set of services, similar to SOA, such that services
    communicate through standard APIs, for example, JSON or XML, and this allows the
    aggregation of language-agnostic services. Basically, a service can be written
    in the best language for the task the service is being created for.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序作为一组服务构建，类似于SOA，这样服务可以通过标准API进行通信，例如JSON或XML，这允许聚合语言不可知的服务。基本上，服务可以用最适合创建服务任务的编程语言编写。
- en: Each service runs in its own process and is location neutral, thus it can be
    located anywhere on the access network.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务在其自己的进程中运行，且与位置无关，因此它可以在访问网络的任何位置运行。
- en: Monoliths
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体应用
- en: 'The microservices approach is the opposite of the traditional monolithic software
    approach, which consists of tightly integrated modules that ship infrequently
    and have to scale as a single unit. Traditional Java EE applications and the JBCP
    calendar application in this book are examples of monolithic applications. Take
    a look at the following diagram which depicts the monolithic architecture:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方法与传统的单体软件方法相反，后者由紧密集成的模块组成，这些模块不经常发货，必须作为一个单一单元进行扩展。本书中的传统Java EE应用程序和日历应用程序就是单体应用的例子。请查看以下图表，它描述了单体架构：
- en: '![](img/8a5ed567-edbf-45ad-bada-a2ee8e8d2dd0.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a5ed567-edbf-45ad-bada-a2ee8e8d2dd0.png)'
- en: Although the monolithic approach fits well for some organizations and some applications,
    microservices is becoming popular with companies that need more options for agility
    and scalability in their ecosystem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单体方法对于某些组织和某些应用来说非常适合，但对于需要在其生态系统中具有更多灵活性和可伸缩性的公司来说，微服务越来越受欢迎。
- en: Microservices
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'A microservice architecture is a collection of small discrete services where
    each service implements a specific business capability. These services run their
    own process and communicate via an HTTP API usually using a RESTful service approach.
    These services are created to serve only one specific business function, such
    as user management, administrative roles, an e-commerce cart, a search engine,
    social media integration, and many others. Take a look at the following diagram
    which depicts the microservices architecture:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一系列小型离散服务的集合，每个服务实现特定的业务功能。这些服务运行自己的进程，并通过HTTP API进行通信，通常使用RESTful服务方法。这些服务是为了只服务于一个特定的业务功能而创建的，比如用户管理、行政角色、电子商务购物车、搜索引擎、社交媒体集成等。请查看以下描述微服务架构的图表：
- en: '![](img/4d14f1d3-65aa-41c4-9de5-2117238b8db8.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d14f1d3-65aa-41c4-9de5-2117238b8db8.png)'
- en: Each **s**ervice can be deployed, upgraded, scaled, restarted, and removed independently
    of other services in the application and other systems in the enterprise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**s**服务可以独立于应用程序中的其他服务和企业中的其他系统进行部署、升级、扩展、重启和移除。
- en: Because each service is created independently of the other, they can each be
    written in different programming languages and use different data storage. Centralized
    service management is virtually non-existent and these services use lightweight
    HTTP, REST, or Thrift APIs for communicating among themselves.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个服务都是独立于其他服务创建的，所以它们可以分别用不同的编程语言编写，并使用不同的数据存储。集中式服务管理实际上是不存在的，这些服务使用轻量级的HTTP、REST或Thrift
    API进行相互之间的通信。
- en: The **Apache Thrift** software framework can be downloaded from [https://thrift.apache.org](https://thrift.apache.org/).
    It is a framework for developing scalable cross-language services that combines
    a software stack with a code generation engine to build services that work efficiently
    and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#,
    Cocoa, JavaScript, Node.js, Smalltalk, and other languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apache Thrift** 软件框架可以从 [https://thrift.apache.org](https://thrift.apache.org/)
    下载。它是一个用于开发可扩展的跨语言服务的框架，结合了软件栈和代码生成引擎，以高效、无缝地在C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk和其他语言之间构建服务。'
- en: Service-oriented architectures
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: You might be asking yourself, "Isn't this the same as SOA?" Not exactly, you
    could say microservices achieve what SOA promised in the first place.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，“这不是和SOA一样吗？” 不完全是，你可以说是微服务实现了SOA最初承诺的东西。
- en: An SOA is a style of software design where services are exposed to other components
    through a language-agnostic, communication protocol over a computer network.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务架构（SOA）是一种软件设计风格，其中服务通过计算机网络上的语言无关的通信协议暴露给其他组件。
- en: The basic principle of SOA is to be independent of vendors, products, and technologies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务架构（SOA）的基本原则是独立于供应商、产品和技术的。
- en: The definition of a service is a discrete unit of functionality that can be
    accessed remotely and acted upon and updated independently, such as retrieving
    a credit card statement online.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的定义是一个可以远程访问、独立操作和更新的离散功能单元，例如在线获取信用卡账单。
- en: Although similar, SOA and microservices are still different types of architectures.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相似，但SOA和微服务仍然是不同类型的架构。
- en: A typical SOA is often implemented inside deployment monoliths and is more platform
    driven, while microservices can be independently deployable and, therefore, offer
    more flexibility in all dimensions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的SOA通常在部署单体内部实现，并且更受平台驱动，而微服务可以独立部署，因此，在所有维度上提供更多的灵活性。
- en: 'The key difference, of course, is the size; the word micro says it all. Microservices
    tend to be significantly smaller than regular SOA services. As Martin Fowler said:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关键区别在于规模；单词“微”说明了一切。微服务通常比传统的SOA服务要小得多。正如Martin Fowler所说：
- en: '"We should think about SOA as a superset of microservices."'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “我们应该将SOA视为微服务的超集。”
- en: -Martin Fowler
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: -Martin Fowler
- en: Microservice security
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务安全
- en: Microservices can provide great flexibility but also introduce challenges that
    must be addressed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以提供极大的灵活性，但也会引入必须解决的问题。
- en: Service communication
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务通信
- en: Monolithic applications use in‘memory communication between processes, while
    microservices communicate over the network. The move to network communication
    raises issues of not only speed but also security.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序使用进程间的内存通信，而微服务通过网络进行通信。向网络通信的转变不仅涉及到速度问题，还有安全性问题。
- en: Tight coupling
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧密耦合
- en: Microservices use many datastores rather than a few. This creates the opportunity
    for implicit service contracts between microservices and services that are tightly
    coupled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务使用许多数据存储而不是几个。这创造了微服务与紧密集成的服务之间的隐式服务合同的机会。
- en: Technical complexity
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术复杂性
- en: Microservices can create additional complexity, which can create security gaps.
    If the team does not have the correct experience, then managing these complexities
    can quickly become unmanageable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可能会创建额外的复杂性，这可能会造成安全漏洞。如果团队没有正确的经验，那么管理这些复杂性可能会迅速变得无法管理。
- en: The OAuth 2 specification
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2规范
- en: There is sometimes a misconception that OAuth 2 is an evolution from OAuth 1,
    but it is a completely different approach. OAuth1 specification requires signatures,
    so you would have to use cryptographic algorithms to create generate and validate
    those signatures that are no longer required for OAuth 2\. The OAuth 2 encryption
    is now handled by TLS, which is required.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会有一种误解，认为OAuth 2是OAuth 1的演变，但它是完全不同的方法。OAuth1规范要求签名，因此你必须使用加密算法来创建生成和验证那些在OAuth
    2中不再需要的签名。OAuth 2的加密现在由TLS处理，这是强制性的。
- en: '**OAuth 2** *RFC-6749*, *The OAuth 2.0 Authorization Framework* ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth 2** *RFC-6749*, *OAuth 2.0授权框架*([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)):'
- en: '*The OAuth 2.0 authorization framework enables a third-party application to
    obtain limited access to an HTTP service, either on behalf of a resource owner
    by orchestrating an approval interaction between the resource owner and the HTTP
    service, or by allowing the third-party application to obtain access on its own
    behalf*.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*OAuth 2.0授权框架允许第三方应用程序获取对HTTP服务的有限访问， either on behalf of a resource owner
    by orchestrating an approval interaction between the resource owner and the HTTP
    service, or by allowing the third-party application to obtain access on its own
    behalf*.'
- en: This specification replaces and makes obsolate the OAuth 1.0 protocol described
    in *RFC 5849, The OAuth 1.0 Protocol* ([https://tools.ietf.org/html/rfc5849).](https://tools.ietf.org/html/rfc5849)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本规范取代并使*RFC 5849, The OAuth 1.0 Protocol*([https://tools.ietf.org/html/rfc5849)描述的OAuth
    1.0协议过时.*](https://tools.ietf.org/html/rfc5849)
- en: 'To properly understand how to utilize OAuth 2, we need to identify certain
    roles and the collaboration between these roles. Let''s define each of the roles
    that are participating in the OAuth 2 authorization process:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确理解如何使用OAuth 2，我们需要确定某些角色以及这些角色之间的协作。让我们定义参与OAuth 2授权过程的每个角色：
- en: '**Resource owner:** The resource owner is the entity capable of granting access
    to a protected resource that is located on a resource server'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者：**资源所有者是能够授权位于资源服务器上的受保护资源的实体。'
- en: '**Authorization server:** The authorization server is a centralized security
    gateway for issuing access tokens to the client after successfully authenticating
    the resource owner and obtaining authorization'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器：**授权服务器在成功验证资源所有者并获取授权后，向客户端发放访问令牌的一个集中的安全网关。'
- en: '**Resource server:** The resource server is the server hosting the protected
    resources and is capable of dissecting and responding to protected resource requests
    using the OAuth 2 access token'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器：**资源服务器是托管受保护资源的服务器，并能够使用OAuth 2访问令牌来解析和响应受保护资源请求。'
- en: '**Microservice client:** The client is the application making resource requests
    that are protected on behalf of the resource owner, but with their authorization'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务客户端：**客户端是代表资源所有者请求受保护资源的应用程序，但需要他们的授权。'
- en: Access tokens
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问令牌
- en: An OAuth 2 access token, commonly referred to as `access_token` in code samples,
    represents a credential that can be used by a client to access an API.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个OAuth 2访问令牌，在代码示例中通常被称为`access_token`，代表一个客户端可以用来访问API的凭据。
- en: Access token
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问令牌
- en: An access token usually has a limited lifetime and is used to enable the client
    to access protected resources when including this token in the HTTP request header
    for each request.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌通常具有限定的生命周期，当在每次请求的HTTP请求头中包含此令牌时，它被用来允许客户端访问受保护的资源。
- en: Refresh token
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新令牌
- en: A refresh token has a longer lifetime and is used to get a new access token
    once the access token has expired, but without the need to send credentials to
    the server again.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新令牌具有更长的生命周期，当访问令牌过期时用来获取新的访问令牌，而无需再次向服务器发送凭据。
- en: Grant types
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权类型
- en: Grant types are methods that a client can use to gain an access token that represents
    the permissions granted. There are different grant types that allow different
    types of access based on the needs of your application. Each grant type can support
    a different OAuth 2 flow without worrying about the technical aspects of the implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 授权类型是客户端用来获取代表授权的`access_token`的方法。根据应用程序的不同需求，有不同的授权类型允许不同类型的访问。每种授权类型都可以支持不同的OAuth
    2流程，而无需担心实现的技术方面。
- en: Authorization code
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权码
- en: The authorization code grant type, defined in *RFC 6749*, *Section 4.1* ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)),
    is a redirection-based flow where the browser receives an authorization code from
    anauthorization server and sends this to the client. The client will then interact
    with the authorization server and exchange the authorization code for `access_token`
    and, optionally, `id_token` and `refresh_token`. The client can now use this `access_token`
    to call the protected resource on behalf of the user.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 授权码授权类型，定义在*RFC 6749*的第*4.1*节([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749))中，是一种基于重定向的流程，浏览器从授权服务器接收一个授权码，并将其发送给客户端。客户端随后与授权服务器交互，用这个授权码交换`access_token`，可选的还有`id_token`和`refresh_token`。客户端现在可以使用这个`access_token`代表用户调用受保护的资源。
- en: Implicit
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式
- en: The implicit grant type, defined in *RFC 6749*, *Section 4.1* ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)),
    is similar to the authorization code grant type, but the client application receives
    `access_token` directly, without the need for `authorization_code`. This happens
    because the client application, which is usually a JavaScript application running
    within a browser and is less trusted than a client application running on the
    server, cannot be trusted with `client_secret` (which is required in the authorization
    code grant type). The implicit grant type does not send a refresh token to the
    application due to limited trust.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式授权类型，定义在*RFC 6749*的第*4.1*节([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749))中，与授权码授权类型相似，但客户端应用程序直接接收`access_token`，而无需`authorization_code`。这是因为通常在浏览器内运行、比在服务器上运行的客户端应用程序信任度较低的客户端应用程序，不能信任其拥有`client_secret`（授权码授权类型中需要）。隐式授权类型由于信任限制，不会将刷新令牌发送给应用程序。
- en: Password credentials
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码凭证
- en: The resource owner password grant type, defined in *RFC 6749*, *Section 4.3*
    ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)),
    can be used directly as an authorization grant to obtain `access_token` and, optionally,
    `refresh_token`. This grant is used when there is a high degree of trust between
    the user and the client and when other authorization grant flows are not available.
    This grant type eliminates the need for the client to store the user credentials
    by exchanging the credentials with a long-lived `access_token` or `refresh_token`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 资源所有者密码授权类型，定义在*RFC 6749*的第*4.3*节([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749))中，可以直接作为授权许可来获取`access_token`，可选的还有`refresh_token`。这种许可在用户与客户端之间有高度信任，且其他授权许可流程不可用时使用。这种许可类型通过用长期有效的`access_token`或`refresh_token`交换凭据，消除了客户端存储用户凭据的需要。
- en: Client credentials
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端证书
- en: The Client Credentials Grant's, defined in *RFC 6749*, *Section 4.4* ([https://tools.ietf.org/html/rfc6749#section-4.4](https://tools.ietf.org/html/rfc6749#section-4.4)),
    is for a non-interactive client (CLI), a daemon, or another service running. The
    client can directly ask the authorization server for `access_token` by using client-provided
    credentials (client id and client secret) to authenticate.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书授权，定义在*RFC 6749*的第*4.4*节([https://tools.ietf.org/html/rfc6749#section-4.4](https://tools.ietf.org/html/rfc6749#section-4.4))中，适用于非交互式客户端（CLI）、守护进程或其他服务。客户端可以通过使用提供的凭据（客户端ID和客户端密钥）进行身份验证，直接向授权服务器请求`access_token`。
- en: JSON Web Tokens
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web令牌
- en: JWT is an open standard, *RFC 7519* ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    that defines a compact and self-contained format for securely transmitting information
    between parties in the form of a JSON object. This information can be verified
    and trusted because it is digitally signed. JWTs can be signed using a secret
    (with the **hash-based message authentication code** (**HMAC**) **algorithm**)
    or a public/private key pair using the **Rivest-Shamir-Adleman** (**RSA**) encryption
    algorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一个开放标准，*RFC 7519* ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))，定义了一个紧凑且自包含的格式，用于在JSON对象的形式下安全地在各方之间传输信息。由于其是数字签名的，这些信息可以被验证和信任。JWT可以使用秘密（使用**基于哈希的消息认证码**（**HMAC**）**算法**）或使用**Rivest-Shamir-Adleman**（**RSA**）加密算法的公钥/私钥对进行签名。
- en: 'JWT *RFC- 7519* ([https://tools.ietf.org/html/ rfc7519](https://tools.ietf.org/html/%20rfc7519)):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'JWT *RFC- 7519* ([https://tools.ietf.org/html/ rfc7519](https://tools.ietf.org/html/%20rfc7519)):'
- en: '*JSON Web Token (JWT) is a compact, URL-safe means of representing claims to
    be transferred between two parties. The claims in a JWT are encoded as a JSON
    object that is used as the payload of a JSON Web Signature (*JWS*) structure or
    as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims
    to be digitally signed or integrity protected with a Message Authentication Code
    (MAC) and/or encrypted.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSON Web Token (JWT)是一个紧凑、URL安全的方式来表示要在两个方之间转移的主张。JWT中的主张以JSON对象的形式作为JSON
    Web签名(*JWS*)结构的载荷或作为JSON Web加密(JWE)结构的明文，使主张可以被数字签名或完整性保护Message Authentication
    Code (MAC)和/或加密.*'
- en: JWT is used to carry information related to the identity and characteristics
    (claims) of the client bearing the token. JWT is a container and is signed by
    the server in order to avoid client tampering. This token is created during the
    authentication process and is verified by the authorization server before any
    processing. It is used by a resource server to allow a client to present a token
    representing its "identity card" to the resource server, and allows the resource
    server to verify the validity and integrity of the token in a stateless, secure
    manner.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JWT用于携带与持有令牌的客户端的身份和特征（声明）相关的信息。JWT是一个容器，并且由服务器签名，以避免客户端篡改。此令牌在认证过程中创建，并在进行任何处理之前由授权服务器验证。资源服务器使用此令牌允许客户端将其“身份卡”呈现给资源服务器，并允许资源服务器以无状态、安全的方式验证令牌的有效性和完整性。
- en: Token structure
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令牌结构
- en: 'The structure of a JWT adheres to the following three-part structure including
    a header, payload, and signature:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的结构遵循以下三部分结构，包括头部、载荷和签名：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Encoded JWT
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码JWT
- en: 'The following code snippet is the complete encoded `access_token` that is returned
    based on the client request:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是基于客户端请求返回的完整编码`access_token`：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Header
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部
- en: 'The encoded header for our `access_token` JWT is **base64** encoded, as shown
    in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`access_token` JWT的编码头部是**base64**编码的，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By decoding the encoded header, we have the following payload:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解码编码头部，我们得到以下载荷：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Payload
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 载荷
- en: 'The encoded payload for our `access_token` JWT is base64 encoded, as shown
    here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`access_token` JWT的编码载荷是base64编码的，如下所示：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By decoding the encoded payload, we have the following payload claims:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解码编码载荷，我们得到以下载荷声明：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Signature
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签名
- en: 'The encoded payload for our `access_token` has been encoded with a private
    key by the authorization server, as seen in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器使用私钥对我们的`access_token`进行了编码，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is pseudo code for the creation of a JWT signature:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建JWT签名的伪代码：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: OAuth 2 support in Spring Security
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security中的OAuth 2支持
- en: The Spring Security OAuth project provides support for using Spring Security
    with OAuth 2 authorization using the standard Spring Framework and Spring Security
    programming models and configuration idioms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security OAuth项目提供了使用Spring Security进行OAuth 2授权的支持，使用标准的Spring框架和Spring
    Security编程模型以及配置习惯。
- en: Resource owner
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者
- en: The resource owner can be one or multiple sources, and in the context of the
    JBCP calendar, it is going to have the calendar application as the resource owner.
    The JBCP calendar will not have any specific configuration that is needed to denote
    its ownership aside from configuring the resource server.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 资源所有者可以是一个或多个来源，在JBCP日历的上下文中，它将拥有日历应用程序作为资源所有者。JBCP日历除了配置资源服务器外，不需要有任何特定的配置来表示其所有权。
- en: Resource server
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器
- en: 'The `@EnableResourceServer` annotation denotes the intention for the containing
    application to enable a Spring Security filter that authenticates requests via
    an incoming OAuth2 token:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableResourceServer`注解表示容器应用程序的意图，启用一个Spring Security过滤器，该过滤器通过传入的OAuth2令牌来验证请求：'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `@EnableResourceServer` annotation denotes the intention for the containing
    application to enable an `OAuth2AuthenticationProcessingFilter` filter that authenticates
    requests via an incoming OAuth 2 token. The `OAuth2AuthenticationProcessingFilter`
    filter requires web security to be enabled using the `@EnableWebSecurity` annotation
    somewhere in the application. The `@EnableResourceServer` annotation registers
    a custom `WebSecurityConfigurerAdapter` class with a hardcoded `@Order` of `3`.
    It is currently not possible to change the order of this `WebSecurityConfigurerAdapter`
    class due to technical limitations in the Spring Framework. To deal with this
    limitation, it is advised not to use other security adapters with the order of
    `3`, and Spring Security will complain in the event that you do set one in the
    same order:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableResourceServer`注解表示容器应用程序的意图，启用一个`OAuth2AuthenticationProcessingFilter`过滤器，该过滤器通过传入的OAuth
    2令牌来验证请求。`OAuth2AuthenticationProcessingFilter`过滤器需要使用`@EnableWebSecurity`注解在应用程序中的某个位置启用web安全。`@EnableResourceServer`注解注册了一个硬编码`@Order`为`3`的自定义`WebSecurityConfigurerAdapter`类。由于Spring
    Framework的技术限制，目前无法更改这个`WebSecurityConfigurerAdapter`类的顺序。为了解决这个限制，建议不要使用其他顺序为`3`的安全适配器，否则Spring
    Security会在你设置相同顺序的一个时提出抗议：'
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Authorization server
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器
- en: 'To enable the authorization server capability, we include the `@EnableAuthorizationServer`
    annotation in our configuration. The addition of this annotation will put an `o.s.s.OAuth
    2.provider.endpoint.AuthorizationEndpoint` interface and an `o.s.s.OAuth 2.provider.endpoint.TokenEndpoint`
    interface into context. The developer will be responsible for securing the `AuthorizationEndpoint`
    (/`oauth`/`authorize`) with the `@EnableWebSecurity` configuration. The `TokenEndpoint`
    (/`oauth`/`token`) will be automatically secured using HTTP basic authentication
    based on the OAuth 2 client credentials:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用授权服务器功能，我们在配置中包含了`@EnableAuthorizationServer`注解。添加此注解将在上下文中放入`o.s.s.OAuth
    2.provider.endpoint.AuthorizationEndpoint`接口和`o.s.s.OAuth 2.provider.endpoint.TokenEndpoint`接口。开发者需要负责使用`@EnableWebSecurity`配置保护`AuthorizationEndpoint`（`/oauth/authorize`）。`TokenEndpoint`（`/oauth/token`）将基于OAuth
    2客户端凭据自动使用HTTP基本身份验证进行保护：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: RSA JWT access token converter keypair
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RSA JWT访问令牌转换器密钥对
- en: 'In order to create a secure JWT encoded signature, we will create a custom
    RSA `keystore` that we will use to create a custom `o.s.s.OAuth 2.provider.token.storeJwtAccessTokenConverter`
    interface:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个安全的JWT编码签名，我们将创建一个自定义RSA `keystore`，我们将其用于创建自定义`o.s.s.OAuth 2.provider.token.storeJwtAccessTokenConverter`接口：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create a `PKCS12` certificate called `jwtConverterStore.p12`, which
    needs to be copied into the `./src/main/resources/key` directory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`jwtConverterStore.p12`的`PKCS12`证书，需要将其复制到`./src/main/resources/key`目录中。
- en: OAuth 2 resource configuration properties
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2资源配置属性
- en: 'We want to externalize the properties required to configure our JWT resources
    by providing `keyPair` attributes, including `keystore`, `alias`, and `storePassword`
    for our generated certificate, as you can see in our `application.yml` file, `src/main/resources/application.yml`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过提供`keyPair`属性来外部化配置我们的JWT资源，包括`keystore`、`alias`和`storePassword`，正如你在我们的`application.yml`文件中看到的，位于`src/main/resources/application.yml`：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: OAuth 2 client configuration properties
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2客户端配置属性
- en: 'We need to configure the client details for the client authentication, grants,
    and OAuth 2 scopes, as you can see in the `application.yml` file, `src/main/resources/application.yml`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为客户端认证、授权和OAuth 2范围配置客户端详细信息，正如你在`application.yml`文件中所看到的，位于`src/main/resources/application.yml`：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: JWT access token converter
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT访问令牌转换器
- en: 'The final step for creating JWT tokens is creating a custom `JwtAccessTokenConverter`
    that will use the generated RSA certificate for our JWT signatures. To do this,
    we need to pull our keyPair configuration and configure a custom `JwtAccessTokenConverter`
    as seen in the OAuth2AuthorizationServerConfig.java file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建JWT令牌的最后一步是创建一个自定义`JwtAccessTokenConverter`，它将使用生成的RSA证书为我们的JWT签名。为此，我们需要拉取我们的keyPair配置，并配置一个自定义`JwtAccessTokenConverter`，正如在OAuth2AuthorizationServerConfig.java文件中所看到的：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The UserDetailsService object
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户详情服务对象
- en: 'We will use `CalendarUser` credentials to assign an authorized `GrantedAuthority`
    to the client. In order to do this, we must either configure our `CalendarUserDetailsService`
    class or qualify it with the name `userDetailsService`, as you can see in the
    following `CalendarUserDetailsService.java` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`CalendarUser`凭据为客户端分配一个授权的`GrantedAuthority`。为了做到这一点，我们必须要么配置我们的`CalendarUserDetailsService`类，要么通过在下面的`CalendarUserDetailsService.java`文件中指定名称`userDetailsService`来实现，正如你所看到的：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another alternative to defining a custom name for our `@Component` annotation
    is to define an `@Bean` declaration, which we can accomplish using the following
    entry in our `SecurityConfig.java` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的`@Component`注解定义自定义名称的另一个替代方案是定义一个`@Bean`声明，我们可以通过在`SecurityConfig.java`文件中使用以下条目来实现：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the OAuth 2 server application
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行OAuth 2服务器应用程序
- en: At this point, we can start the application and we will be ready to send OAuth
    2 requests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以启动应用程序，并准备好发送OAuth 2请求。
- en: 'At this point, your code should look like this: `chapter16.01-calendar`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的代码应该看起来像这样：`chapter16.01-calendar`。
- en: Server requests
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器请求
- en: We can test the application with either a command-line tool such as `cURL` or
    `HTTPie`, or you could also use a REST client plugin such as Postman to send requests
    to the server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令行工具，如`cURL`或`HTTPie`，来测试应用程序，或者你也可以使用像Postman这样的REST客户端插件来向服务器发送请求。
- en: '`HTTPie`: a CLI, cURL-like tool for humans, `HTTPie` (pronounced aitch-tee-tee-pie)
    is a command-line HTTP client. Its goal is to make CLI interaction with web services
    as human-friendly as possible. It provides a simple HTTP command that allows for
    sending arbitrary HTTP requests using a simple and natural syntax, and displays
    colorized output. `HTTPie` can be used for testing, debugging, and generally interacting
    with HTTP servers ([https://httpie.org](https://httpie.org/)).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPie`: 一个像cURL的面向人类的CLI工具，`HTTPie`（发音为aitch-tee-tee-pie）是一个命令行HTTP客户端。它的目标是使与Web服务的CLI交互尽可能地人性化。它提供了一个简单的HTTP命令，使用简单自然的语法发送任意的HTTP请求，并显示彩色输出。`HTTPie`可用于测试、调试和与HTTP服务器进行交互（[https://httpie.org](https://httpie.org/)）。'
- en: Token requests
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令牌请求
- en: 'When we make the initial token request, we should get a successful response
    similar to the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初次请求令牌时，我们应该得到一个类似于以下的成功响应：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Specifically, we have been granted an access token that can be used in subsequent
    requests. The following is the `access_token` that will be used as our bearer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们已经获得了一个可以在后续请求中使用的访问令牌。以下是我们将用作持有者的`access_token`：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we will take the `access_token` and use that token to initiate additional
    requests to the server with the following format:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`access_token`，并使用该令牌以以下格式初始化对服务器的额外请求：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When adding the `access_token` we received in the first request, we should
    get the following request:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加第一次请求中收到的`access_token`时，我们应该得到以下请求：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can continue to make subsequent requests with the same `access_token`, such
    as retrieving the events for the current user:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用相同的`access_token`进行后续请求，例如获取当前用户的日历事件：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we have our OAuth 2 server ready to issue `access_tokens` for clients,
    we now can create a microservices client to interact with our system.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好为客户端发放`access_tokens`的OAuth 2服务器，我们可以创建一个微服务客户端来与我们的系统交互。
- en: Microservices client
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务客户端
- en: 'We start our new client application by enabling this application as an OAuth
    2 client with the addition of the `@EnableOAuth2Client` annotation. The addition
    of the `@EnableOAuth2Client` annotation will allow this application to retrieve
    and use authorization code grants from one or more OAuth2 authorization server.
    Client applications that use client credential grants do not need `AccessTokenRequest`
    or the scoped `RestOperations` (the state is global for the applications), but
    they should still use the filter to trigger `OAuth2RestOperations` to obtain a
    token when necessary. Applications that use password grants need to set the authentication
    properties in `OAuth2ProtectedResourceDetails` before using the `RestOperations`
    method, which we will configure shortly. Let''s take a look at the following steps
    and see how it is done:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加`@EnableOAuth2Client`注解使我们的新客户端应用程序作为一个OAuth 2客户端启动。添加`@EnableOAuth2Client`注解将允许这个应用程序从一台或多台OAuth2授权服务器检索和使用授权码授予。使用客户端凭据授予的客户端应用程序不需要`AccessTokenRequest`或受限于范围的`RestOperations`（对于应用程序来说，状态是全局的），但它们仍然应该使用过滤器触发`OAuth2RestOperations`在需要时获取一个令牌。使用密码授予的应用程序在使用`RestOperations`方法之前需要设置`OAuth2ProtectedResourceDetails`中的认证属性，我们稍后会进行配置。让我们来看看以下步骤，看看是如何完成的：
- en: 'We need to set up a few properties that will be used to configure the client,
    as shown in the following `JavaConfig.java` file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置一些将在以下`JavaConfig.java`文件中用于配置客户端的属性：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In addition to several standard properties we need to execute the OAuth 2 RESTful
    operations, we also need to create a `dataSource` to hold `oauth_client_token`
    that will be retrieved upon the initial request, then used in subsequent operations
    for a given resource. Now let''s create `ClientTokenServices` for managing `oauth_client_token`,
    as shown in the following `JavaConfig.java` file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了我们需要执行OAuth 2 RESTful操作的几个标准属性外，我们还需要创建一个`dataSource`来保存将在初始请求时检索并在后续操作中使用的给定资源的`oauth_client_token`。现在让我们为管理`oauth_client_token`创建一个`ClientTokenServices`，如以下`JavaConfig.java`文件所示：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we create the `OAuth2RestTemplate` that will manage the OAuth2 communication.
    We will start by creating a `ResourceOwnerPasswordResourceDetails` to hold the
    resource connection details, then construct an `OAuth2RestTemplate` to be used
    as an `OAuth2RestOperations` for the client request:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个`OAuth2RestTemplate`，它将管理OAuth2通信。我们将从创建一个`ResourceOwnerPasswordResourceDetails`来持有资源连接详细信息开始，然后构建一个`OAuth2RestTemplate`作为客户端请求的`OAuth2RestOperations`使用：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Configuring the OAuth 2 client
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置OAuth 2客户端
- en: 'Now that we have enabled our `@EnableOAuth2Client` annotation and set up a
    `ResourceOwnerPasswordResourceDetails` object, we need to configure the properties
    used to connect to the resource server and authentication server:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们启用了`@EnableOAuth2Client`注解并设置了一个`ResourceOwnerPasswordResourceDetails`对象后，我们需要配置用于连接资源服务器和认证服务器的属性：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now have the pieces in place and can start making requests with the `OAuth2RestOperations`
    object. We will start by creating `RestController` to pull remote details and
    display them as a result of RESTful requests, as shown in our `OAuth2EnabledEventsController.java`
    file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这些组件，可以开始使用`OAuth2RestOperations`对象发送请求。我们将首先创建一个`RestController`来拉取远程详细信息，并将其作为RESTful请求的结果显示，正如我们在`OAuth2EnabledEventsController.java`文件中所展示的那样：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We now should have the same codebase for a client application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应为客户端应用拥有相同的代码库。
- en: Your code should look like `chapter16.01-calendar-client`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应看起来像`chapter16.01-calendar-client`。
- en: 'We need to ensure that the `chapter16.01-calendar` application is running and
    ready to take OAuth 2 requests from clients. We can then start the `chapter16.01-calendar-client`
    application, which will expose several RESTful endpoints, including one to access
    the configured user events located at `/events/my` on the remote resource, and
    will return the following result by running `http://localhost:8888/events/my`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保`chapter16.01-calendar`应用正在运行，并准备好接收来自客户端的OAuth 2请求。然后我们可以启动`chapter16.01-calendar-client`应用，该应用将暴露几个RESTful端点，包括一个访问配置用户事件（位于远程资源上的`/events/my`）的端点，并通过运行`http://localhost:8888/events/my`返回以下结果：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the general difference between monolithic applications
    and microservices and compared SOA with microservices. You also learned the conceptual
    architecture of OAuth 2 and how it provides your services with trustworthy client
    access, and learned about the types of OAuth 2 access tokens and the types of
    OAuth 2 grant types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了单体应用和微服务之间的通用区别，并将服务导向架构（SOA）与微服务进行了比较。你还了解了OAuth 2的概念性架构以及它是如何为你的服务提供可信的客户端访问的，并学习了OAuth
    2访问令牌的类型以及OAuth 2授权类型的类型。
- en: We examined the JWT and their general structure, implemented a resource server
    and authentication server used to grant access rights to clients in order to access
    OAuth 2 resources, and implemented a RESTful client to gain access to resources
    through an OAuth 2 grant flow.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查了JWT以及它们的通用结构，实现了一个资源服务器和认证服务器，用于向客户端授予访问OAuth 2资源的权限，并实现了一个RESTful客户端，通过OAuth
    2授权流程来获取资源。
