- en: Chapter 4. Testing Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 测试工具
- en: No matter which language you are programming in, testing should be performed
    with great care, as it will not only document your code in a consistent way but
    will also be of great help for refactoring and maintenance activities, such as
    fixing bugs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种编程语言，都应该非常小心地进行测试，因为测试不仅以一致的方式记录了你的代码，而且对于重构和维护活动，如修复错误，也将大有裨益。
- en: The Scala ecosystem largely follows Java trends towards testing at all levels,
    but with some differences. At many places, we will see that Scala is using **DSLs**
    (**Domain Specific** **Languages**), which makes the testing code very clear to
    read and understand. As a matter of fact, testing can be a good area to start
    with when introducing Scala, migrating progressively from an existing Java project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 生态系统在很大程度上遵循 Java 在所有级别的测试趋势，但也有一些不同之处。在许多地方，我们会看到 Scala 正在使用 **DSLs**（**领域特定**
    **语言**），这使得测试代码非常易于阅读和理解。实际上，测试可以是介绍 Scala 时一个很好的起点，逐步从现有的 Java 项目迁移过来。
- en: In this chapter, we are going to cover some of the major testing tools and their
    usage through a number of code examples. We have already written a tiny JUnit-like
    test in Scala in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"),
    *Understanding the Scala Ecosystem*, so we will go from here and focus on BDD-style
    tests that belong to **Behavior Driven Development** (**BDD**). Agnostic to which
    technology stack is used, BDD has emerged in these past few years as a compliant
    choice for writing clear specifications in the Gherkin language (which is part
    of the cucumber framework and is explained at [http://cukes.info/gherkin.html](http://cukes.info/gherkin.html))
    on how code should behave. Already used in Java and many other languages, tests
    written in that style are often easier to understand and maintain as they are
    closer to plain English. They are one step closer to the true adoption of BDD
    that aims at making the business analysts write the test specifications in a structured
    way, which the programs can understand and implement. They often represent the
    sole documentation; it is therefore very important to keep them up to date and
    close to the domain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过一些代码示例介绍一些主要的测试工具及其用法。我们已经在 [第三章](ch03.html "第三章. 理解 Scala 生态系统")
    中编写了一个微型的 JUnit 风格的测试，即 *理解 Scala 生态系统*，因此我们将从这里开始，专注于属于 **行为驱动开发**（**BDD**）的
    BDD 风格测试。BDD 对所使用的任何技术栈都是中立的，在过去的几年中，它已成为在 Gherkin 语言（它是 cucumber 框架的一部分，并在 [http://cukes.info/gherkin.html](http://cukes.info/gherkin.html)
    中解释）中编写清晰规范的一个合规选择，说明代码应该如何表现。在 Java 和许多其他语言中已经使用，这种风格的测试通常更容易理解和维护，因为它们更接近于普通英语。它们更接近于
    BDD 的真正采用，旨在使业务分析师能够以结构化的方式编写测试规范，程序可以理解和实现。它们通常代表唯一的文档；因此，保持它们最新并与领域紧密相关非常重要。
- en: Scala primarily offers two frameworks to write tests, **ScalaTest** ([www.scalatest.org](http://www.scalatest.org))
    and **Specs2** ([etorreborre.github.io/specs2/](http://etorreborre.github.io/specs2/)).
    As they are quite similar to each other, we are only going to cover ScalaTest,
    and interested readers can look through the Specs2 documentation to understand
    their differences. Moreover, we will take a look at automated property-based testing
    using the **ScalaCheck** framework ([www.scalacheck.org](http://www.scalacheck.org)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 主要提供了两个框架来编写测试，**ScalaTest** ([www.scalatest.org](http://www.scalatest.org))
    和 **Specs2** ([etorreborre.github.io/specs2/](http://etorreborre.github.io/specs2/))。由于它们彼此之间非常相似，我们只将介绍
    ScalaTest，并对感兴趣的读者说明如何通过查看 Specs2 文档来了解它们之间的差异。此外，我们还将探讨使用 **ScalaCheck** 框架（[www.scalacheck.org](http://www.scalacheck.org)）进行的基于属性的自动化测试。
- en: Writing tests with ScalaTest
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ScalaTest 编写测试
- en: To be able to quickly start visualizing some of the tests that can be written
    with ScalaTest, we can take advantage of the `test-patterns-scala` template from
    the Typesafe Activator that we introduced in the previous chapter. It consists
    of a number of examples that essentially target the ScalaTest framework.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够快速开始可视化使用 ScalaTest 可以编写的某些测试，我们可以利用前一章中介绍的类型安全激活器（Typesafe Activator）中的
    `test-patterns-scala` 模板。它包含了一系列示例，主要针对 ScalaTest 框架。
- en: Setting up the `test-patterns-scala` activator project only requires you to
    go to the directory where you installed the Typesafe Activator, as we did earlier,
    and then, either start the GUI through the `> activator ui` command, or type `>
    activator new` to create a new project and select the appropriate template when
    prompted.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`test-patterns-scala`激活器项目只需要你前往我们之前安装Typesafe Activator的目录，然后，通过`> activator
    ui`命令启动GUI，或者输入`> activator new`来创建一个新项目，并在提示时选择适当的模板。
- en: 'The template project already contains the `sbteclipse` plugin; therefore, you
    can generate eclipse-related files by simply entering from a command prompt in
    the root directory of the project, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模板项目已经包含了`sbteclipse`插件；因此，你只需在项目的根目录中通过命令提示符输入，就可以生成与Eclipse相关的文件，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the eclipse project is successfully created, you may import it into your
    IDE workspace by selecting **File** | **Import...** | **General** |**Existing
    Projects**. As a reminder from the previous chapter, you can also create project
    files for IntelliJ or other IDEs since the Typesafe Activator is just a customized
    version of SBT.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功创建了Eclipse项目，你可以通过选择**文件** | **导入...** | **通用** | **现有项目**将其导入到你的IDE工作区。作为前一章的提醒，你也可以为IntelliJ或其他IDE创建项目文件，因为Typesafe
    Activator只是SBT的一个定制版本。
- en: You can look into the various test cases in `src/test/scala`. As some of the
    tests use frameworks such as Akka, Spray, or Slick, which we haven't covered yet,
    we will skip these for now to concentrate on the most straightforward ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看`src/test/scala`中的各种测试用例。由于一些测试使用了我们尚未覆盖的框架，如Akka、Spray或Slick，我们将暂时跳过这些测试，专注于最直接的测试。
- en: 'In its simplest form, a `ScalaTest` class (which, by the way, might also test
    Java code and not just Scala code) can be declared by extending `org.scalatest.FunSuite`.
    Each test is represented as a function value, and this is implemented in the `Test01.scala`
    class, as shown in the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单形式中，一个`ScalaTest`类（顺便说一下，它也可能测试Java代码，而不仅仅是Scala代码）可以通过扩展`org.scalatest.FunSuite`来声明。每个测试都表示为一个函数值，这已在`Test01.scala`类中实现，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To execute only this single test class, you should enter the following command
    in the command prompt:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅执行这个单个测试类，你应该在命令提示符中输入以下命令：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our case, this command will be as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这个命令将是以下这样：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The example given under `src/test/scala/scalatest/Test02.scala` within the
    `test-patterns-scala` project is very similar, but the extra `===` instead of
    `==` will give you additional info when the test fails. This is shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test-patterns-scala`项目下的`src/test/scala/scalatest/Test02.scala`中给出的示例非常相似，但使用`===`而不是`==`会在测试失败时提供额外的信息。如下所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once again running the test can be done by entering the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试可以通过输入以下命令来完成：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before fixing the failing test, this time, we can execute the test in the continuous
    mode, using the `~` character in front of `test-only` (from the activator prompt),
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复失败的测试之前，这次我们可以在连续模式下执行测试，使用`test-only`前的`~`字符（从激活器提示符中），如下所示：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The continuous mode will make SBT rerun the `test-only` command each time the
    `Test02` class is edited and saved. This feature of SBT can make you save a significant
    amount of time by running in the background tests or just programs without having
    to explicitly write the command. On the first execution of `Test02`, you can see
    some red text indicating `"abc[]" did not equal "abc[d]" (Test02.scala:10)`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 连续模式会在每次编辑并保存`Test02`类时，让SBT重新运行`test-only`命令。SBT的这个特性可以通过在后台运行测试或程序而不需要显式编写命令，为你节省大量时间。在第一次执行`Test02`时，你可以看到一些红色文本，指示`"abc[]"
    不等于 "abc[d]" (Test02.scala:10)`。
- en: As soon as you correct the `abdc` string and save the file, SBT will automatically
    re-execute the test in the background, and you can see the text turning green.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更正了`abdc`字符串并保存文件，SBT将自动在后台重新执行测试，你可以看到文本变成绿色。
- en: The continuous mode works for the other SBT commands as well, such as `~run`
    or `~test`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 连续模式也适用于其他SBT命令，如`~run`或`~test`。
- en: '`Test03` shows you how to expect or catch exceptions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test03`展示了如何期望或捕获异常：'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first scenario fails as it was expecting an `IndexOutOfBoundsException`,
    but the code is indeed returning a valid `h`, the character at index 0 of the
    `hello` string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景失败，因为它期望一个`IndexOutOfBoundsException`，但代码确实返回了一个有效的`h`，即`hello`字符串索引为0的字符。
- en: 'To be able to run ScalaTest test suites as JUnit test suites (for example,
    to run them within the IDE or when extending an existing JUnit-based project that
    is already built in Maven, or when reporting to a build server), we can use the
    available `JUnitRunner` class along with the `@RunWith` annotation, as shown in
    the following sample:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将ScalaTest测试套件作为JUnit测试套件运行（例如，在IDE中运行或在Maven中构建的现有基于JUnit的项目中扩展，或者向构建服务器报告时），我们可以使用可用的`JUnitRunner`类以及`@RunWith`注解，如下面的示例所示：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: BDD-style testing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BDD风格的测试
- en: '`Test06` is an example of a test written in a different style, namely BDD.
    In short, you specify some kind of a user story in almost plain English that describes
    the behavior of the scenario you want to test. This can be seen in the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test06`是另一种风格的测试示例，即BDD。简而言之，你几乎用纯英文指定某种用户故事来描述你想要测试的场景的行为。这可以在以下代码中看到：'
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: BDD-style tests represent a higher level of abstraction than JUnit tests, and
    are more suitable for integration and acceptance testing as well as documentation,
    for people knowledgeable about the domain. You just need to extend the `FeatureSpec`
    class, optionally with a `GivenWhenThen` trait, to describe acceptance requirements.
    More details about BDD-style tests can be found at [http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development).
    We just want to illustrate here that it is possible to write the BDD-style tests
    in Scala, but we won't go further into their details as they are already largely
    documented for Java and other programming languages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: BDD风格的测试比JUnit测试具有更高的抽象层次，更适合集成和验收测试以及文档，对于了解该领域的知识的人来说。你只需要扩展`FeatureSpec`类，可选地使用`GivenWhenThen`特质，来描述验收需求。有关BDD风格测试的更多详细信息，请参阅[http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development)。我们在这里只想说明，在Scala中可以编写BDD风格的测试，但我们不会进一步深入它们的细节，因为它们在Java和其他编程语言中已经得到了大量文档记录。
- en: 'ScalaTest provides a convenient DSL to write assertions in a way close to plain
    English. The `org.scalatest.matchers.Matchers` trait contains many possible assertions
    and you should look at its ScalaDoc documentation to see many usage examples.
    `Test07.scala` expresses a very simple matcher, as shown in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaTest提供了一个方便的DSL，可以以接近纯英文的方式编写断言。`org.scalatest.matchers.Matchers`特质包含许多可能的断言，你应该查看其ScalaDoc文档以查看许多使用示例。`Test07.scala`表达了一个非常简单的匹配器，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although built with Version 2.0 of ScalaTest, the original sample given in the
    activator project uses the now deprecated `org.scalatest.matchers.ShouldMatchers`
    trait; the preceding code sample achieves the same behavior but is more up to
    date.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然是用ScalaTest的2.0版本构建的，但activator项目中的原始示例使用的是现在已弃用的`org.scalatest.matchers.ShouldMatchers`特质；前面的代码示例实现了相同的行为，但更加更新。
- en: 'Let''s write a few more assertions using a Scala Worksheet. Right-click on
    the `scalatest` package that contains all the test files that were previously
    reviewed and then select **new** | **Scala Worksheet**. We will name this worksheet
    as `ShouldWork`. We can then write and evaluate matchers by extending a `FlatSpec`
    specification with the `Matchers` trait, as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Scala工作表编写一些更多的断言。右键单击包含所有之前审查过的测试文件的`scalatest`包，然后选择**new** | **Scala
    Worksheet**。我们将把这个工作表命名为`ShouldWork`。然后我们可以通过扩展带有`Matchers`特质的`FlatSpec`规范来编写和评估匹配器，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Saving this worksheet will not produce any output as the matcher passes the
    test. However, try to make it fail by changing one `true` to `false`. This is
    shown in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此工作表不会产生任何输出，因为匹配器通过了测试。然而，尝试通过将一个`true`改为`false`来让它失败。这在上面的代码中显示：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This time, we get a full stack trace as part of the evaluation, as shown in
    the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在评估过程中得到了完整的堆栈跟踪，如下面的屏幕截图所示：
- en: '![BDD-style testing](img/3637OS_04_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![BDD风格的测试](img/3637OS_04_03.jpg)'
- en: 'We can start evaluating many more `should` matchers, as shown in the following
    code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始评估更多的`should`匹配器，如以下代码所示：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The evaluation of the worksheet stops whenever we encounter a test failure.
    Therefore, we have to fix it in order to be able to progress in the test. This
    is identical to running the whole testsuite with the SBT `test` command, as we
    did previously, and as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到测试失败时，工作表的评估就会停止。因此，我们必须修复它才能在测试中继续前进。这与我们之前使用SBT的`test`命令运行整个测试套件是相同的，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous example, the last statement (which is the opposite of the first
    one) should fail; instead, it is not evaluated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，最后一个语句（与第一个语句相反）应该失败；然而，它没有被评估。
- en: Functional testing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: 'ScalaTest is well integrated with Selenium (it is a tool for automating testing
    in browsers and is available at [www.seleniumhq.org](http://www.seleniumhq.org))
    by providing a complete DSL, making it straightforward to write functional tests.
    `Test08` is a clear example of this integration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaTest与Selenium（它是用于自动化浏览器测试的工具，可在[www.seleniumhq.org](http://www.seleniumhq.org)找到）很好地集成，通过提供完整的DSL，使得编写功能测试变得简单直接。`Test08`是这种集成的明显例子：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's try to run a similar invocation directly into a worksheet. As worksheets
    give feedback on every statement evaluation, they are very convenient to directly
    identify what the problem is, for instance, if a link, a button, or content is
    not found as expected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试直接在工作表中运行类似的调用。由于工作表会对每个语句评估提供反馈，因此它们非常适合直接识别问题，例如，如果链接、按钮或内容没有按预期找到。
- en: Just create another worksheet called **Functional** next to the **ShouldWork**
    worksheet that is already present. Right-click on the `scalatest` package and
    select **New** | **Scala Worksheet**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在已存在的`ShouldWork`工作表旁边创建另一个名为**Functional**的工作表。右键单击`scalatest`包，然后选择**New**
    | **Scala Worksheet**。
- en: 'The worksheet can be filled as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 工作表可以按照以下方式填写：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Upon the save operation (*Ctrl* + *S*), the worksheet will be evaluated and
    should probably display some output information for every statement, except for
    the last two lines with `should` matchers, as they should evaluate to `true`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存操作（*Ctrl* + *S*）后，工作表将被评估，并且可能为每个语句显示一些输出信息，除了最后两个带有`should`匹配器的语句，因为它们应该评估为`true`。
- en: 'Try to change `("Search | Packt Publishing")` to a different value, such as
    `Results` or just `Packt Publishing`, and notice how the console output provides
    handy information on what does not match. This is shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将`("Search | Packt Publishing")`更改为不同的值，例如`Results`或仅仅是`Packt Publishing`，并注意控制台输出提供了关于不匹配内容的有用信息。这在上面的屏幕截图中有展示：
- en: '![Functional testing](img/3637OS_04_04_revised.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![功能测试](img/3637OS_04_04_revised.jpg)'
- en: This functional test just scratches the surface of what's possible. As we are
    using the Java Selenium library, in Scala, you can inherit the power of the Selenium
    framework that is available in Java.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能测试只是触及了可能性的表面。由于我们使用的是Java Selenium库，在Scala中，你可以继承Java中可用的Selenium框架的力量。
- en: Mocking with ScalaMock
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ScalaMock进行模拟
- en: Mocking is a technique by which you can test code without requiring all of its
    dependencies in place. Java offers several frameworks for mocking objects when
    writing tests. The most well known are JMock, EasyMock, and Mockito. As the Scala
    language introduces new elements such as traits and functions, the Java-based
    mocking frameworks are not enough, and this is where ScalaMock ([www.scalamock.org](http://www.scalamock.org))
    comes into play.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一种可以在不需要所有依赖项都到位的情况下测试代码的技术。Java在编写测试时提供了几个用于模拟对象的框架。最著名的是JMock、EasyMock和Mockito。随着Scala语言引入了新元素，如特性和函数，基于Java的模拟框架就不够用了，这就是ScalaMock（[www.scalamock.org](http://www.scalamock.org)）发挥作用的地方。
- en: 'ScalaMock is a native Scala-mocking framework that is typically used within
    ScalaTest (or Specs2), by importing the following dependencies into the SBT (`build.sbt`)
    file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaMock是一个本地的Scala模拟框架，通常用于ScalaTest（或Specs2）中，通过在SBT（`build.sbt`）文件中导入以下依赖项：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Within Specs2, the following dependencies need to be imported:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Specs2中，需要导入以下依赖项：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since the release of the Scala Version 2.10, ScalaMock has been rewritten, and
    the ScalaMock Version 3.*x* is the version that we are going to cover briefly
    by going through an example of mocking a trait.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Scala版本2.10发布以来，ScalaMock已经被重写，ScalaMock版本3.*x*是我们将通过模拟特例的示例简要介绍的版本。
- en: 'Let''s first define the code that we are going to test. It consists of a tiny
    currency converter (available at [http://www.luketebbs.com/?p=58](http://www.luketebbs.com/?p=58))
    that fetches currency rates from the European Central Bank. Retrieving and parsing
    the XML file of currency rates is only a matter of a few lines of code, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们将要测试的代码。它是一个微型的货币转换器（可在[http://www.luketebbs.com/?p=58](http://www.luketebbs.com/?p=58)找到），从欧洲中央银行获取货币汇率。检索和解析货币汇率XML文件只需几行代码，如下所示：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, the currency rates are fetched from a URL using the `xml.XML.load`
    method. As XML is part of the Scala standard library, there is no need for imports
    here. The load method parses and returns the XML rates as an immutable structure
    of type `Elem`, which is a case class that represents XML elements. This is shown
    in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，货币汇率是通过 `xml.XML.load` 方法从 URL 中获取的。由于 XML 是 Scala 标准库的一部分，这里不需要导入。`load`
    方法解析并返回 XML 汇率作为一个不可变的 `Elem` 类型结构，`Elem` 是一个表示 XML 元素的案例类。这在下述代码中显示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Accessing the list of currency rates from this XML document is done through
    an XPath expression by navigating inside the Cube nodes, hence the `xml.XML.load(exchangeRates)
    \ "Cube" \ "Cube" \ "Cube"` expression. A single for comprehension (the `for (…)`
    `yield (…)` construct that we introduced in the previous chapter) is required
    to loop over the currency rates and return a collection of `key -> value` pairs
    where, in our case, a key will be a string that represents the currency name,
    and `value` will be a BigDecimal value that represents the rate. Notice how the
    information is extracted from `<Cube currency="USD" rate="1.3460"/>` by writing
    `(elem \ "@currency").text` to capture the currency attribute and `(elem \ "@rate").text`
    to capture the rate respectively. The latter will be further processed by creating
    a new `BigDecimal` value from the given string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个 XML 文档中访问货币汇率列表是通过 XPath 表达式在 Cube 节点内部导航完成的，因此有 `xml.XML.load(exchangeRates)
    \ "Cube" \ "Cube" \ "Cube"` 表达式。需要一个单行 for 推导（我们在上一章中引入的 `for (…)` `yield (…)`
    构造）来遍历货币汇率，并返回一个 `key -> value` 对的集合，在我们的情况下，键将是一个表示货币名称的字符串，而 `value` 将是一个表示汇率的
    BigDecimal 值。注意信息是如何从 `<Cube currency="USD" rate="1.3460"/>` 中提取的，通过写入 `(elem
    \ "@currency").text` 来捕获货币属性，以及 `(elem \ "@rate").text` 来分别捕获汇率。后者将通过从给定的字符串创建一个新的
    `BigDecimal` 值来进一步处理。
- en: In the end, we get a `Map[String, BigDecimal]` that contains all our currencies
    with their rates. To this value, we add the mapping for the currency EUR (Euros)
    that will represent the reference rate one; this is why we use the `++` operator
    to merge two maps, that is, the one we just created together with a new map containing
    only one `key -> value` element, `Map[String,BigDecimal]("EUR"-> 1).`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到一个包含所有货币及其汇率的 `Map[String, BigDecimal]`。我们将 EUR（欧元）货币的映射添加到这个值中，它将代表参考汇率之一；这就是为什么我们使用
    `++` 运算符合并两个映射，即我们刚刚创建的映射与只包含一个 `key -> value` 元素的新的映射一起。
- en: 'Before mocking, let''s write a regular test using ScalaTest with `FlatSpec`
    and `Matchers`. We will make use of our `Converter` trait, by integrating it into
    the following `MoneyService` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟之前，让我们使用 ScalaTest 和 `FlatSpec` 以及 `Matchers` 编写一个常规测试。我们将利用我们的 `Converter`
    特质，将其集成到以下 `MoneyService` 类中：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A possible test specification derived from the `MoneyService` class is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `MoneyService` 类派生出的一个可能的测试规范如下：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To be able to instantiate the `Converter` trait, we use an `ECBConverter` class
    defined in the `Converter.scala` file as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够实例化 `Converter` 特质，我们使用在 `Converter.scala` 文件中定义的 `ECBConverter` 类，如下所示：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we execute the test from the SBT command prompt or directly within Eclipse
    (as a JUnit), we get the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 SBT 命令提示符或直接在 Eclipse 中（作为 JUnit）执行测试，我们会得到以下输出：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the URL from which we are retrieving the currency rates is not always available,
    or if the currency rates have changed a lot on one particular day and the resulting
    amount of the conversion is not in the given interval of the assertion `should
    (be > (1700) and be <= (1800))`, then our test might fail. In that case, mocking
    the converter in our test seems appropriate, and can be done as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从其中检索货币汇率的 URL 并非总是可用，或者如果某一天货币汇率变动很大，导致转换后的金额不在断言 `should (be > (1700)
    and be <= (1800))` 给定的区间内，那么我们的测试可能会失败。在这种情况下，在我们的测试中对转换器进行模拟似乎是合适的，并且可以按照以下方式完成：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `expects` method contains the arguments that we expect when our code should
    invoke the `convert` method, and the returning method contains our expected output
    in place of the real return result.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`expects` 方法包含了当我们的代码应该调用 `convert` 方法时我们期望的参数，而返回方法包含了用预期输出代替实际返回结果的预期值。'
- en: ScalaMock has many variations on how to apply the mocking code, and is planning
    to enhance the mocking syntax using the **Macros** in future releases. In short,
    Macros are functions that are called by the compiler during compilation. It is
    an experimental feature added in Scala from Version 2.10 that makes it possible
    for the developer to access the compiler APIs and apply transformations to the
    **AST** (**Abstract Syntax Tree**), that is, the tree representation of a program.
    Macros are out of the scope of this book, but among other things, they are useful
    for the Code Generation and DSLs. Their usage will improve the ScalaMock syntax;
    for instance, you can apply your mock expectations within `inSequence {… }` or
    the `inAnyOrder {… }` blocks of code or in nested combinations of these blocks,
    as illustrated in their documentation, which is available at [scalamock.org](http://scalamock.org).
    ScalaMock also supports a more Mockito-like style with a **Record-then-Verify**
    cycle rather than the **Expectations-First** style, which we have been using.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaMock 在如何应用模拟代码方面有许多变体，并计划在未来的版本中使用 **Macros** 来增强模拟语法。简而言之，Macros 是在编译期间由编译器调用的函数。这是
    Scala 从 2.10 版本开始添加的一个实验性功能，它使得开发者能够访问编译器 API 并对 **AST**（**抽象语法树**）应用转换，即程序的树形表示。Macros
    不在本书的范围之内，但它们在代码生成和领域特定语言（DSLs）方面非常有用。它们的用法将改进 ScalaMock 语法；例如，你可以在 `inSequence
    {… }` 或 `inAnyOrder {… }` 代码块中，或者在这些块的嵌套组合中应用你的模拟期望，正如它们在文档中所展示的，该文档可在 [scalamock.org](http://scalamock.org)
    上找到。ScalaMock 还支持类似于 Mockito 的风格，使用 **记录-然后-验证** 循环而不是我们一直使用的 **期望-首先** 风格。
- en: Testing with ScalaCheck
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ScalaCheck 进行测试
- en: Having a complete and consistent test suite that consists of unit, integration,
    or functional tests is essential in ensuring a good overall quality of your software
    development. However, sometimes, such a suite is not enough. While testing for
    example-specific data structures, it often happens that there are too many possible
    values to test with, which means that there is a very large amount of mocking
    or production of test data. Automated property-based testing is the aim of ScalaCheck,
    a Scala library inspired by Haskell that allows generating, more or less randomly,
    the test data to verify some properties about the code you are testing. This library
    can be applied to Scala as well as to Java projects.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个完整且一致的测试套件，该套件由单元测试、集成测试或功能测试组成，这对于确保软件开发的整体质量至关重要。然而，有时这样的套件是不够的。在测试特定数据结构时，常常会遇到有太多可能值需要测试的情况，这意味着有大量的模拟或测试数据生成。自动基于属性的测试是
    ScalaCheck 的目标，这是一个受 Haskell 启发的 Scala 库，它允许生成（或多或少随机地）测试数据来验证你正在测试的代码的一些属性。这个库可以应用于
    Scala 项目，也可以应用于 Java 项目。
- en: 'To get up and running quickly with ScalaCheck, you can include the appropriate
    library in the `build.sbt` file, as we have often done till now. This is shown
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速开始使用 ScalaCheck，你可以在 `build.sbt` 文件中包含适当的库，就像我们之前经常做的那样。这如下所示：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: From the SBT prompt, you may type `reload` instead of exiting and relaunching
    SBT, to get a fresh version of the build file, and then type `update` to fetch
    the new dependency. Once this is done, you may also type `eclipse` to update your
    project with the dependency so that it will be a part of your classpath, and the
    editor will recognize the ScalaCheck classes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SBT 提示符中，你可以输入 `reload` 而不是退出并重新启动 SBT，以获取构建文件的新版本，然后输入 `update` 来获取新的依赖项。一旦完成，你也可以输入
    `eclipse` 来更新你的项目，以便依赖项成为你的类路径的一部分，并且编辑器将识别 ScalaCheck 类。
- en: 'Let''s first run the `StringSpecification` test that is proposed by the **Quick
    start** page available at [www.scalacheck.org](http://www.scalacheck.org):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行由 [www.scalacheck.org](http://www.scalacheck.org) 上的 **快速入门** 页面提出的 `StringSpecification`
    测试：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this code snippet, ScalaCheck produces (randomly) a number of strings and
    verifies that the properties are correct; the first one is straightforward; it
    should verify that adding two strings `a` and `b` should produce a string that
    starts with `a`. It probably sounds obvious that this test will pass, no matter
    what the values of the strings are, but the second property that verifies the
    length of the concatenation of the two strings is not always true; feeding both
    `a` and `b` with the empty value `""` is a counter example that shows that the
    property is not verified. We can illustrate that by running the test via SBT as
    follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，ScalaCheck（随机）生成了一组字符串并验证了属性的正确性；第一个是直接的；它应该验证将两个字符串`a`和`b`相加应该产生以`a`开头的字符串。这个测试听起来可能很明显会通过，无论字符串的值是什么，但第二个属性验证两个字符串连接的长度并不总是正确的；将`a`和`b`都喂以空值`""`是一个反例，表明该属性没有被验证。我们可以通过以下方式通过SBT运行测试来展示这一点：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'ScalaCheck conveniently outputs a counter example, `ARG_0: ""` and `ARG_1:
    ""` that makes the test fail.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'ScalaCheck方便地输出了一个反例，`ARG_0: ""`和`ARG_1: ""`，这导致测试失败。'
- en: 'We can add a few more tests on more complex objects than just strings. Let''s
    add a new test class named `ConverterSpecification` as part of our test suite,
    to test the `Converter` that we have created in the *Mocking with ScalaMock* section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在比字符串更复杂的对象上添加更多测试。让我们在我们的测试套件中添加一个新的测试类，命名为`ConverterSpecification`，以测试我们在*使用ScalaMock进行模拟*部分中创建的`Converter`：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we run the test in SBT, the following output is displayed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在SBT中运行测试，将显示以下输出：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this specification, we added two specific generators; the first one named
    `currencies` is able to generate only a few strings taken from a list of valid
    currencies that we want to test, as otherwise, a randomly generated string would
    produce strings that are not part of the `Map`. Let''s add an invalid item `"DUMMY"`
    to the generated list to verify that the test is failing:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规范中，我们添加了两个特定的生成器；第一个名为`currencies`的生成器只能生成来自我们想要测试的有效货币列表的几个字符串，否则随机生成的字符串会产生不属于`Map`的字符串。让我们将无效项`"DUMMY"`添加到生成的列表中，以验证测试是否失败：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On saving this, the tests are rerun automatically as we specified the `~` sign
    in front of `test-only`. This is shown as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，测试会自动重新运行，因为我们指定了`test-only`前的`~`符号。如下所示：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The second generator named `conversions` illustrates the construction of a more
    complex generator that takes advantage of the power of for comprehensions. In
    particular, notice the `suchThat {_ >= 0}` filter method that makes sure that
    the arbitrary chosen integer has a positive value. This generator returns a `Tuple3`
    triplet that contains all the necessary values to test the `Converter.convert`
    method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个名为`conversions`的生成器展示了如何构建一个更复杂的生成器，该生成器利用了for推导式的强大功能。特别是，请注意`suchThat {_
    >= 0}`过滤方法确保任意选择的整数具有正值。此生成器返回一个包含所有必要值的`Tuple3`三元组，用于测试`Converter.convert`方法。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the major testing frameworks available in
    Scala, which largely inherit from the rich Java ecosystem. Moreover, by applying
    property-based testing via ScalaCheck, we explored novel approaches to enhance
    the testing quality. To further improve the quality of the software, interested
    readers can look at additional SBT plugins that are listed on the [http://www.scala-sbt.org/](http://www.scala-sbt.org/)
    website, notably `scalastyle-sbt-plugin` to check the coding style or the various
    code-coverage plugins. In the next chapter, we are going to dive into the huge
    area of web development and take advantage of the power of the Scala language
    to make the development of portals and web apps a productive and fun activity.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Scala中可用的主要测试框架，这些框架在很大程度上继承了丰富的Java生态系统。此外，通过ScalaCheck应用属性测试，我们探索了提高测试质量的新方法。为了进一步提高软件质量，感兴趣的读者可以查看[http://www.scala-sbt.org/](http://www.scala-sbt.org/)网站上列出的其他SBT插件，特别是`scalastyle-sbt-plugin`用于检查编码风格或各种代码覆盖率插件。在下一章中，我们将深入探讨庞大的Web开发领域，并利用Scala语言的力量使门户和Web应用的开发变得高效且有趣。
