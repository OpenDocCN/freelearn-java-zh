- en: Improving Application Performance Using Caching Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存模式提高应用程序性能
- en: In previous chapters, we have seen how Spring works in the backend to access
    data for the application. We also saw how the Spring JDBC Module provides the
    `JdbcTemplate` helper class for database access. Spring provides support for integration
    with ORM solutions such as Hibernate, JPA, JDO, and so on, and manages transactions
    across application. Now, in this chapter, we will see how Spring provides caching
    support to improve application performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了Spring如何在后端工作以访问应用程序的数据。我们还看到了Spring JDBC模块如何提供`JdbcTemplate`辅助类以进行数据库访问。Spring提供了与ORM解决方案（如Hibernate、JPA、JDO等）集成的支持，并管理应用程序的事务。现在，在本章中，我们将看到Spring如何提供缓存支持以提高应用程序性能。
- en: Do you ever face a volley of questions from your wife when you return home very
    late in the night from your office? Yes, I know it is very irritating to answer
    so many questions when you are tired and exhausted. It is even more irritating
    when you're asked the same questions over and over again..
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你深夜从办公室回家时，你是否经常面对你妻子连珠炮般的问题？是的，我知道当你疲惫不堪时回答这么多问题是件很烦人的事。当你被反复问相同的问题时，那就更加烦人了。
- en: Some questions can be answered with a *Yes* or *No*, but for some questions,
    you have to explain in detail. Consider what will happen if you are asked another
    lengthy question again after some time! Similarly, there are some stateless components
    in an application, where the components have been designed in such a way that
    they ask the same questions over and over again to complete each task individually.
    Similar to some questions asked by your wife, some questions in the system take
    a while to fetch the appropriate data--it may have some major complex logic behind
    it, or maybe, it has to fetch data from the database, or call a remote service.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有些问题可以用*是*或*否*来回答，但对于某些问题，你必须详细解释。考虑一下，如果你在一段时间后再次被问到另一个长问题会发生什么！同样，在应用程序中也有一些无状态组件，这些组件被设计成反复提出相同的问题以完成每个任务。类似于你妻子提出的一些问题，系统中的一些问题需要一段时间才能获取适当的数据——它可能背后有一些复杂的逻辑，或者可能需要从数据库中获取数据，或者调用远程服务。
- en: 'If we know that the answer of a question is not likely to change frequently,
    we can remember the answer to that question for later when it is asked again by
    the same system. It doesn''t make sense to go through the same channel to fetch
    it again, as it will impact your application''s performance, and will be a wasteful
    use of your resources. In an enterprise application, caching is a way to store
    those frequently needed answers so that we fetch from the cache instead of going
    through the proper channel to get the answer for the same question over and over
    again. In this chapter, we will discuss Spring''s Cache Abstraction feature, and
    how Spring declaratively supports caching implementation. It will cover the following
    points:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道某个问题的答案不太可能频繁变化，我们可以在稍后当相同系统再次询问该问题时记住这个答案。再次通过相同的渠道获取答案是没有意义的，因为它会影响应用程序的性能，并且是对你资源的浪费。在企业应用程序中，缓存是一种存储那些频繁需要答案的方法，这样我们就可以从缓存中获取，而不是每次都通过适当的渠道获取相同问题的答案。在本章中，我们将讨论Spring的缓存抽象功能，以及Spring如何声明性地支持缓存实现。它将涵盖以下要点：
- en: What is a cache?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是缓存？
- en: Where do we do this caching?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在哪里做这个缓存？
- en: Understanding the cache abstraction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解缓存抽象
- en: Enabling caching via the Proxy pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代理模式启用缓存
- en: Declarative Annotation-based caching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于声明性注解的缓存
- en: Declarative XML-based caching
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于声明性XML的缓存
- en: Configuring the cache storage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置缓存存储
- en: Implementing custom cache annotations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义缓存注解
- en: Caching best practices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存最佳实践
- en: Let's begin.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: What is cache?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是缓存？
- en: In very simple terms, **cache** is a memory block where we store preprocessed
    information for the application. In this context, a key-value storage, such as
    a map, may be a cache in the application. In Spring, cache is an interface to
    abstract and represent caching. A cache interface provides some methods for placing
    objects into a cache storage, it can retrieve from the cache storage for given
    key, it can update the object in the cache storage for a given key, it remove
    the object from the cache storage for a given key. This cache interface provides
    many functions to operate with cache.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，**缓存**是我们存储预处理的程序信息的内存块。在这个上下文中，一个键值存储，例如一个映射，可能是应用程序中的缓存。在Spring中，缓存是一个接口，用于抽象和表示缓存。缓存接口提供了一些方法来将对象放入缓存存储，它可以基于给定的键从缓存存储中检索对象，它可以更新缓存存储中给定键的对象，也可以从缓存存储中删除给定键的对象。这个缓存接口提供了许多操作缓存的功能。
- en: Where do we use caching?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在哪里使用缓存？
- en: We use caching in cases where a method always returns the same result for the
    same argument(s). This method could do anything such as calculate data on the
    fly, execute a database query, and request data via RMI, JMS, and a web-service,
    and so on. A unique key must be generated from the arguments. That's the cache
    key.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法总是为相同的参数返回相同结果的情况下使用缓存。这种方法可以执行任何操作，例如即时计算数据、执行数据库查询、通过RMI、JMS和Web服务请求数据等。必须从参数生成一个唯一键。这就是缓存键。
- en: Understanding cache abstraction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解缓存抽象
- en: Basically, caching in Java applications is applied to the Java methods to reduce
    the number of executions for the same information available in the cache. That
    means, whenever these Java methods are invoked, the cache abstraction applies
    the cache behavior to these methods based on the given arguments. If the information
    for the given argument is already available in the cache, then it is returned
    without having to execute the target method. If the required information is not
    available in the cache, then the `target` method is executed, and the result is
    cached and returned to the caller. Cache abstraction also provides other cache-related
    operations such as updating and/or removing the contents in the cache. These operations
    are useful when the data changes in the application sometimes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java应用程序中，基本上，缓存是应用于Java方法以减少缓存中相同信息的执行次数。这意味着，每当这些Java方法被调用时，缓存抽象会根据给定的参数将这些方法的行为应用于缓存。如果给定参数的信息已经在缓存中，则无需执行目标方法即可返回。如果所需信息不在缓存中，则执行目标方法，并将结果缓存并返回给调用者。缓存抽象还提供了其他与缓存相关的操作，如更新和/或删除缓存中的内容。当应用程序中的数据有时发生变化时，这些操作非常有用。
- en: Spring Framework provides cache abstraction for Spring applications by using
    the `org.springframework.cache.Cache` and `org.springframework.cache.CacheManager`
    interfaces. Caching requires the use of an actual storage to store the cache data.
    But cache abstraction only provides caching logic. It doesn't provide any physical
    storage to store the cached data. So, developers need to implement the actual
    storage for caching in the application. If you have a distributed application,
    then you will need to configure your cache provider accordingly. It depends on
    the use cases of your application. You can either make a copy of the same data
    across nodes for a distributed application, or you can make a centralized cache.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架通过使用`org.springframework.cache.Cache`和`org.springframework.cache.CacheManager`接口为Spring应用程序提供缓存抽象。缓存需要使用实际的存储来存储缓存数据。但缓存抽象只提供缓存逻辑。它不提供任何物理存储来存储缓存数据。因此，开发人员需要在应用程序中实现实际的缓存存储。如果您有一个分布式应用程序，那么您需要相应地配置您的缓存提供程序。这取决于您应用程序的使用案例。您可以为分布式应用程序在节点之间复制相同的数据，或者您可以创建一个集中式缓存。
- en: 'There are several cache providers in the market, which you could use as per
    as your application requirement. Some of them are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有一些缓存提供程序，您可以根据应用程序需求使用它们。以下是一些例子：
- en: Redis
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: '`OrmLiteCacheClient`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrmLiteCacheClient`'
- en: '`Memcached`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Memcached`'
- en: In Memory Cache
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存缓存
- en: Aws DynamoDB Cache Client
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aws DynamoDB Cache Client
- en: Azure Cache Client
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Cache Client
- en: 'To implement cache abstraction in your application, you have to take care of
    the following tasks:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中实现缓存抽象，您必须注意以下任务：
- en: '**Caching declaration**: This means that you have to recognize those methods
    in the application that need to be cached, and annotate these methods either with
    caching annotations, or you can use XML configuration by using Spring AOP'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存声明**：这意味着您必须识别应用程序中需要缓存的方法，并使用缓存注解标注这些方法，或者您可以使用Spring AOP通过XML配置来实现。'
- en: '**Cache configuration**: This means that you have to configure the actual storage
    for the cached data--the storage where the data is stored and read from'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存配置**：这意味着您必须配置缓存数据的实际存储位置——即数据存储和读取的地方'
- en: Let's now see how we can enable Spring's cache abstraction in a Spring application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在Spring应用程序中启用Spring的缓存抽象。
- en: Enabling caching via the Proxy pattern
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过代理模式启用缓存
- en: 'You can enable Spring''s cache abstraction in the following two ways:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下两种方式启用Spring的缓存抽象：
- en: Using Annotation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注解
- en: Using the XML namespace
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML命名空间
- en: 'Spring transparently applies caching to the methods of Spring beans by using
    AOP. Spring applies proxy around the Spring beans where you declare the methods
    that need to be cached. This proxy adds the dynamic behavior of caching to the
    Spring beans. The following diagram illustrates the caching behavior:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Spring通过使用AOP（面向切面编程）透明地将缓存应用于Spring bean的方法。Spring在您声明需要缓存的方法的Spring bean周围应用代理。此代理为Spring
    bean添加了动态的缓存行为。以下图示说明了缓存行为：
- en: '![](img/0cec6f6f-6fd1-4c05-a024-8fe76afe0cd8.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0cec6f6f-6fd1-4c05-a024-8fe76afe0cd8.png)'
- en: In the preceding diagram, you can see that Spring applies **Proxy** to the **AccountServiceImpl**
    class to add the caching behavior. Spring uses the GoF proxy pattern to implement
    caching in the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图中，您可以看到Spring将**代理（Proxy**）应用于**AccountServiceImpl**类以添加缓存行为。Spring使用GoF代理模式在应用程序中实现缓存。
- en: Let's look at how to enable this feature in a Spring application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Spring应用程序中启用此功能。
- en: Enabling the caching proxy using Annotation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注解启用缓存代理
- en: 'As you already know, Spring provides lots of features, but they are, mostly,
    disabled. You must enable these feature before using it. If you want to use Spring''s
    cache abstraction in your application, you have to enable this feature. If you
    are using Java configuration, you can enable cache abstraction of Spring by adding
    the `@EnableCaching` annotation to one of your configuration classes. The following
    configuration class shows the `@EnableCaching` annotation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，Spring提供了许多功能，但它们大多数都是默认禁用的。在使用之前，您必须启用这些功能。如果您想在应用程序中使用Spring的缓存抽象，您必须启用此功能。如果您使用Java配置，您可以通过将`@EnableCaching`注解添加到您的配置类之一来启用Spring的缓存抽象。以下配置类显示了`@EnableCaching`注解：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding Java configuration file, we added the `@EnableCaching` annotation
    to the configuration class `AppConfig.java`; this annotation indicates to the
    Spring Framework to enable Spring cache behavior for the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述Java配置文件中，我们向配置类`AppConfig.java`添加了`@EnableCaching`注解；此注解指示Spring框架为应用程序启用Spring缓存行为。
- en: Let's now look at how to enable Spring's cache abstraction by using XML configuration.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何通过使用XML配置来启用Spring的缓存抽象。
- en: Enabling the Caching Proxy using the XML namespace
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XML命名空间启用缓存代理
- en: 'If you''re configuring your application with XML, you can enable annotation-driven
    caching with the `<cache:annotation-driven>` element from Spring''s cache namespace,
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用XML配置应用程序，您可以使用Spring的缓存命名空间中的`<cache:annotation-driven>`元素启用注解驱动的缓存，如下所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As seen in the preceding configuration files, whether you use Java configuration
    or XML configuration, the annotation `@EnableCaching` and namespace `<cache:annotation-driven>`
    enables Spring's cache abstraction by creating an aspect with pointcuts that trigger
    off of Spring's caching annotations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述配置文件所示，无论您使用Java配置还是XML配置，注解`@EnableCaching`和命名空间`<cache:annotation-driven>`通过创建一个具有触发Spring缓存注解的切入点（pointcuts）的方面（aspect），从而启用Spring的缓存抽象。
- en: Let's see how to use Spring's caching annotations to define cache boundaries.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Spring的缓存注解来定义缓存边界。
- en: Declarative Annotation-based caching
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于声明性注解的缓存
- en: 'In Spring applications, Spring''s abstraction provides the following Annotations
    for caching declaration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，Spring的抽象提供了以下注解用于缓存声明：
- en: '`@Cacheable`: This indicates that before execution of the actual method, look
    at the return value of that method in the cache. If the value is available, return
    this cached value, if the value is not available, then invoke the actual method,
    and put the returned value into the cache.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Cacheable`：这表示在执行实际方法之前，查看该方法的返回值是否在缓存中。如果值可用，则返回此缓存值，如果值不可用，则调用实际方法，并将返回值放入缓存。'
- en: '`@CachePut`: This updates the cache without checking if the value is available
    or not. It always invokes the actual method.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CachePut`：这更新缓存而不检查值是否可用。它总是调用实际方法。'
- en: '`@CacheEvict`: This is responsible for triggering cache eviction.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheEvict`：这负责触发缓存驱逐。'
- en: '`@Caching`: This is used for grouping multiple annotations to be applied on
    a method at once.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Caching`：这用于将多个注解分组应用于方法。'
- en: '`@CacheConfig`: This indicates to Spring to share some common cache-related
    settings at the class level.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheConfig`：这表示Spring在类级别上共享一些常见的缓存相关设置。'
- en: Let us now take a closer look at each annotation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在更详细地查看每个注解。
- en: The @Cacheable annotation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Cacheable`注解'
- en: '`@Cacheable` marks a method for caching. Its result is stored in a cache. For
    all subsequent invocations of that method with the same arguments, it will fetch
    data from the cache using a key. The method will not be executed. The following
    are the `@Cacheable` attributes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Cacheable`标记一个方法进行缓存。其结果存储在缓存中。对于所有后续具有相同参数的方法调用，它将使用键从缓存中获取数据。方法将不会执行。以下是一些`@Cacheable`属性：'
- en: '**value**: This is the name of cache to use'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：这是要使用的缓存名称'
- en: '**key**: This is the key for each cached data item'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键**：这是每个缓存数据项的键'
- en: '**condition**: This is a SpEL expression to evaluate true or false; if it is
    false, then the result of caching is not applied to the method call'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：这是一个用于评估真或假的SpEL表达式；如果为假，则缓存的结果不会应用于方法调用'
- en: '**unless**: This too is a SpEL expression; if it is true, it prevents the return
    value from being put in the cache'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除非**：这同样是一个SpEL表达式；如果为真，则防止返回值被放入缓存'
- en: 'You can use SpEL and argument(s) of method. Let''s look at the following code
    for the simplest declaration of the `@Cacheable` annotation. It requires the name
    of the cache associated with that method. Please refer to the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用SpEL和方法参数。让我们看看以下代码，这是`@Cacheable`注解最简单的声明。它需要与该方法关联的缓存名称。请参考以下代码：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, the `findAccount` method is annotated with the `@Cacheable`
    annotation. This means that this method is associated with a cache. The name of
    the cache is **accountCache**. Whenever this method is called for a particular
    `accountId`, the cache is checked for the return value of this method for the
    given `accountId`. You can also give multiple names to the cache as shown next:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`findAccount`方法被标记为`@Cacheable`注解。这意味着此方法与一个缓存相关联。缓存名称为**accountCache**。每当调用特定`accountId`的方法时，都会检查该方法的返回值是否在缓存中。您也可以像下面这样为缓存提供多个名称：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The @CachePut annotation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@CachePut`注解'
- en: 'As mentioned earlier, the `@Cacheable` and `@CachePut` annotations both have
    the same goal, that is, to populate a cache. But their working is slightly different
    from each other. `@CachePut` marks a method for caching, and its result is stored
    in a cache. For each invocation of that method with the same arguments, it always
    invokes the actual method without checking whether the return value of that method
    is available in the cache or not. The following are `@CachePut` attributes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`@Cacheable`和`@CachePut`注解都有相同的目标，即填充缓存。但它们的工作方式略有不同。`@CachePut`标记一个方法进行缓存，并将结果存储在缓存中。对于具有相同参数的每个方法调用，它总是调用实际方法，而不检查该方法的返回值是否在缓存中。以下是一些`@CachePut`属性：
- en: '**value**: This is the name of the cache to use'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：这是要使用的缓存名称'
- en: '**key**: This is the key for each cached data item'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键**：这是每个缓存数据项的键'
- en: '**condition**: This is a SpEL expression to evaluate true or false; if false,
    then the result of caching is not applied to the method call'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：这是一个用于评估真或假的SpEL表达式；如果为假，则缓存的结果不会应用于方法调用'
- en: '**unless**: This is also a SpEL expression; if it is true, it prevents the
    return value from being put in the cache'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除非**：这同样是一个SpEL表达式；如果为真，则防止返回值被放入缓存'
- en: 'You can also use SpEL and argument(s) of method for the `@CachePut` annotation.
    The following code is the simplest declaration of the `@CachePut` annotation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用SpEL和方法参数为`@CachePut`注解。以下代码是`@CachePut`注解的最简单声明：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, when `save()` is invoked, it saves the `Account`. Then
    the returned Account is placed in the `accountCache` cache.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当调用`save()`时，它会保存`Account`。然后返回的Account被放置在`accountCache`缓存中。
- en: As mentioned earlier, the cache is populated by the method based on the argument
    of the method. It is actually a default cache key. In case of the `@Cachable`
    annotation, the `findAccount(Long accountId)` method has `accountId` as an argument,
    the `accountId` is used as the cache key for this method. But in case of the `@CachePut`
    annotation, the only parameter of `save()` is an Account. It is used as the cache
    key. It doesn't seem fine to use `Account` as a cache key. In this case, you need
    the cache key to be the ID of the newly saved Account and not the Account itself.
    So, you need to customize the key generation behavior. Let's see how you can customize
    the cache key.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，缓存是通过方法根据方法的参数来填充的。实际上这是一个默认的缓存键。在`@Cachable`注解的情况下，`findAccount(Long accountId)`方法有一个`accountId`参数，`accountId`被用作此方法的缓存键。但在`@CachePut`注解的情况下，`save()`的唯一参数是一个Account。它被用作缓存键。使用`Account`作为缓存键似乎并不合适。在这种情况下，您需要缓存键是新建Account的ID而不是Account本身。因此，您需要自定义键生成行为。让我们看看您如何自定义缓存键。
- en: Customizing the cache key
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义缓存键
- en: 'You can customize the cache key by using a key attribute of `@Cacheable` and
    the `@CachePut` annotation. The cache key is derived by a SpEL expression using
    properties of the object as highlighted key attribute in the following snippet
    of code. Let''s look at the following examples:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`@Cacheable`和`@CachePut`注解的key属性来自定义缓存键。缓存键是通过使用对象属性作为以下代码片段中突出显示的键属性来通过SpEL表达式派生的。让我们看看以下示例：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see in the preceding code snippets how we have created the cache key
    by using the key attribute of the `@Cacheable` annotation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的代码片段中看到，我们是如何使用`@Cacheable`注解的key属性来创建缓存键的。
- en: Let's see another attribute of these annotations in a Spring application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些注解在Spring应用中的另一个属性。
- en: Conditional caching
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件缓存
- en: 'Spring''s caching annotations allow you to turn off caching for some cases
    by using the condition attribute of `@Cacheable` and `@CachePut` annotations.
    These are given a SpEL expression to evaluate the conditional value. If the value
    of the conditional expression is true, the method is cached. If the value of the
    conditional expression is false, the method is not cached, but is executed every
    time without performing any caching operations no matter what values in the cache
    or what arguments are used. Let''s see an example. The following method will be
    cached only if the passed argument has a value greater than or equal to `2000`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的缓存注解允许您通过使用`@Cacheable`和`@CachePut`注解的条件属性来关闭某些情况下的缓存。这些注解提供了一个SpEL表达式来评估条件值。如果条件表达式的值为真，则方法将被缓存。如果条件表达式的值为假，则方法不会被缓存，每次都会执行，而不进行任何缓存操作，无论缓存中的值或使用的参数是什么。让我们看一个例子。以下方法只有在传入的参数值大于或等于`2000`时才会被缓存：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is a one more attribute of the `@Cacheable` and `@CachePut` annotations--
    `unless`. This is also given a SpEL expression. This attribute may seem the same
    as the condition attribute but there is some difference between them. Unlike condition,
    the `unless` expressions are evaluated after the method has been called. It prevents
    the value from being placed in the cache. Let''s see the following example--We
    only want to cache when the bank name does not contain HDFC:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Cacheable`和`@CachePut`注解还有一个属性--`unless`。这同样提供了一个SpEL表达式。这个属性可能看起来与条件属性相同，但它们之间有一些区别。与条件不同，`unless`表达式是在方法调用之后评估的。它阻止值被放入缓存。让我们看看以下示例--我们只想在银行名称不包含HDFC时进行缓存：'
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see in the preceding code snippet, we have used both attributes--`condition`
    and `unless`. But the `unless` attribute has a SpEL expression as `#result.bankName.contains(''HDFC'')`.
    In this expression, the result is a SpEL extension or cache SpEL metadata. The
    following is a list of the caching metadata that is available in SpEL:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中所见，我们使用了两个属性--`condition`和`unless`。但`unless`属性有一个SpEL表达式，为`#result.bankName.contains('HDFC')`。在这个表达式中，结果是SpEL扩展或缓存SpEL元数据。以下是在SpEL中可用的缓存元数据列表：
- en: '| **Expression** | **Description** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `#root.methodName` | The name of the cached method |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `#root.methodName` | 缓存方法的名称 |'
- en: '| `#root.method` | The cached method, that is, the method being invoked |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `#root.method` | 被缓存的的方法，即被调用的方法 |'
- en: '| `#root.target` | It evaluates the target object being invoked |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `#root.target` | 它评估被调用的目标对象 |'
- en: '| `#root.targetClass` | It evaluates the class of the target object being invoked
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `#root.targetClass` | 它评估被调用的目标对象的类 |'
- en: '| `#root.caches` | An array of caches against which the current method is executed
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `#root.caches` | 当前方法执行的缓存数组 |'
- en: '| `#root.args` | An array of the arguments passed into the cached method |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `#root.args` | 传递给缓存方法的参数数组 |'
- en: '| `#result` | The return value from the cached method; only available in unless
    expressions for `@CachePut` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `#result` | 缓存方法的返回值；仅在`@CachePut`的`unless`表达式中可用 |'
- en: Spring's `@CachePut` and `@Cacheable` annotations should never be used on the
    same method, because they have different behaviors. The `@CachePut` annotation
    forces the execution of the cache method in order to update the caches. But the
    `@Cacheable` annotation executes the cached method only if the return value of
    the method is not available on the cache.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`@CachePut`和`@Cacheable`注解不应在同一个方法上使用，因为它们有不同的行为。`@CachePut`注解强制执行缓存方法以更新缓存。但`@Cacheable`注解仅在方法的返回值不在缓存中时才执行缓存方法。
- en: You have seen how to add information to the cache by using Spring's `@CachePut`
    and `@Cacheable` annotations in a Spring application. But how can we remove that
    information from the cache? Spring's cache abstraction provides another annotation
    for removing cached data from the cache--the `@CacheEvict` annotation. Let's see
    how to remove the cached data from the cache by using the `@CacheEvict` annotation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何在Spring应用程序中使用Spring的`@CachePut`和`@Cacheable`注解向缓存中添加信息。但如何从缓存中移除这些信息呢？Spring的缓存抽象提供了另一个用于从缓存中移除已缓存数据的注解——`@CacheEvict`注解。让我们看看如何使用`@CacheEvict`注解从缓存中移除缓存数据。
- en: The @CacheEvict annotation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@CacheEvict`注解'
- en: 'Spring''s cache abstraction not only allows populating caches, but also allows
    removing the cached data from the cache. There is a stage in the application where
    you have to remove stale or unused data from the cache. In that case, you can
    use the `@CacheEvict` annotation, because it doesn''t add anything to the cache
    unlike the `@Cacheable` annotation. The `@CacheEvict` annotation is used only
    to perform cache eviction. Let''s see how this annotation makes the `remove()`
    method of `AccountRepository` as a cache eviction:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的缓存抽象不仅允许填充缓存，还允许从缓存中移除已缓存的的数据。在应用程序中存在一个阶段，您必须从缓存中移除过时或未使用的数据。在这种情况下，您可以使用`@CacheEvict`注解，因为它与`@Cacheable`注解不同，不会向缓存中添加任何内容。`@CacheEvict`注解仅用于执行缓存清除。让我们看看这个注解是如何使`AccountRepository`的`remove()`方法成为缓存清除的：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in the preceding code snippet, the value associated with the
    argument, `accountId`, is removed from the `accountCache` cache when the `remove()`
    method is invoked. The following are `@Cacheable` attributes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中所见，当调用`remove()`方法时，与参数`accountId`关联的值将从`accountCache`缓存中移除。以下是一些`@Cacheable`属性：
- en: '**value**: This is an array of names of the cache to use'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**: 这是一个要使用的缓存名称数组'
- en: '**key**: This is a SpEL expression to evaluate the cache key to be used'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key**: 这是一个SpEL表达式，用于评估要使用的缓存键'
- en: '**condition**: This is a SpEL expression to evaluate true or false; if it is
    false, then the result of caching is not being applied to the method call'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**condition**: 这是一个SpEL表达式，用于评估真或假；如果为假，则缓存的结果不会被应用于方法调用'
- en: '**allEntries**: This implies that if the value of this attribute is true, all
    entries will be removed from the caches'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allEntries**: 如果此属性的值为真，则从缓存中删除所有条目'
- en: '**beforeInvocation**: This means that if the value of this attribute is true,
    the entries are removed from the cache before the method is invoked, and if the
    value of this attribute is false (the default), the entries are removed after
    a successful method invocation'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**beforeInvocation**: 这意味着如果此属性的值为真，则在方法调用之前从缓存中删除条目；如果此属性的值为假（默认值），则在方法调用成功后删除条目'
- en: We can use the `@CacheEvict` annotation on any method, even a `void` one, because
    it only removes the value from the cache. But in case of the `@Cacheable` and
    `@CachePut` annotations, we have to use a non-void return value method, because
    these annotations require a result to be cached.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何方法上使用`@CacheEvict`注解，甚至是`void`方法，因为它只从缓存中删除值。但是，对于`@Cacheable`和`@CachePut`注解，我们必须使用非`void`返回值的方法，因为这些注解需要缓存结果。
- en: The @Caching annotation
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Caching`注解'
- en: 'Spring''s cache abstraction allows you to use multiple annotations of the same
    type for caching a method by using the `@Caching` annotation in a Spring application.
    The `@Caching` annotation groups other annotations such as `@Cacheable`, `@CachePut`,
    and `@CacheEvict` for the same method. For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的缓存抽象允许你通过在Spring应用程序中使用`@Caching`注解来使用同一类型的多个注解来缓存一个方法。`@Caching`注解将`@Cacheable`、`@CachePut`和`@CacheEvict`等注解组合为同一方法。例如：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The @CacheConfig annotation
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@CacheConfig`注解'
- en: 'Spring''s cache abstraction allows you to annotate `@CacheConfig` at the class
    level to avoid repeated mentioning in each method. In some cases, applying customizations
    of the caches to all methods can be quite tedious. Here, you can use the `@CacheConfig`
    annotation to all operations of the class. For example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的缓存抽象允许你在类级别上使用`@CacheConfig`注解，以避免在每个方法中重复提及。在某些情况下，将缓存的定制应用于所有方法可能相当繁琐。在这里，你可以使用`@CacheConfig`注解来处理类的所有操作。例如：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see in the preceding code snippet that the `@CacheConfig` annotation
    is used at the class level, and it allows you to share the `accountCache` cache
    with all the `cacheable` methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码片段中看到，`@CacheConfig`注解在类级别上使用，并允许你将与所有`cacheable`方法共享的`accountCache`缓存。
- en: Since Spring's cache abstraction module uses proxies, you should use the cache
    annotations only with public visibility methods. In all non-public methods, these
    annotations do not raise any error, but non-public methods annotated with these
    annotations do not show any caching behaviors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring的缓存抽象模块使用代理，你应该只将缓存注解用于具有公共可见性的方法。在所有非公共方法中，这些注解不会引发任何错误，但带有这些注解的非公共方法不会显示任何缓存行为。
- en: We have already seen that Spring also offers XML namespace to configure and
    implement cache in a Spring application. Let's see how in the next section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到Spring还提供了XML命名空间来配置和实现Spring应用程序中的缓存。让我们在下一节中看看如何实现。
- en: Declarative XML-based caching
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于声明性XML的缓存
- en: To keep your configuration codes of caching separate from business codes, and
    to maintain loose coupling between the Spring-specific annotations and your source
    code, XML-based caching configuration is much more elegant than the annotation-based
    one. So, to configure Spring cache with XML, let's use the cache namespace along
    with the AOP namespace, because caching is an AOP activity, and it uses the Proxy
    pattern behind the declarative caching behavior.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将缓存配置代码与业务代码分离，并保持Spring特定注解与源代码之间的松耦合，基于XML的缓存配置比基于注解的配置更为优雅。因此，要使用XML配置Spring缓存，请使用缓存命名空间和AOP命名空间，因为缓存是一种AOP活动，它背后使用的是代理模式来实现声明性缓存行为。
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see in the preceding XML file that we have included the `cache` and
    `aop` namespaces. The cache namespace defines the caching configurations by using
    the following elements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的XML文件中看到，我们已经包含了`cache`和`aop`命名空间。缓存命名空间通过以下元素定义缓存配置：
- en: '| **XML element** | **Caching Description** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **XML元素** | **缓存描述** |'
- en: '| `<cache:annotation-driven>` | It is equivalent to `@EnableCaching` in Java
    configuration, and is used to enable the caching behavior of Spring. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `<cache:annotation-driven>` | 它等同于Java配置中的`@EnableCaching`，并用于启用Spring的缓存行为。
    |'
- en: '| `<cache:advice>` | It defines caching advice |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `<cache:advice>` | 它定义了缓存建议 |'
- en: '| `<cache:caching>` | It is equivalent to the `@Caching` annotation, and is
    used to group a set of caching rules within the caching advice |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `<cache:caching>` | 它等同于`@Caching`注解，并用于在缓存建议中组合一组缓存规则 |'
- en: '| `<cache:cacheable>` | It is equivalent to the `@Cacheable` annotation; it
    makes any method cacheable |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `<cache:cacheable>` | 它等同于`@Cacheable`注解；它使任何方法可缓存 |'
- en: '| `<cache:cache-put>` | It is equivalent to the `@CachePut` annotation, and
    is used to populate a cache |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `<cache:cache-put>` | 它等同于`@CachePut`注解，并用于填充缓存 |'
- en: '| `<cache:cache-evict>` | It is equivalent to the `@CacheEvict` annotation,
    and is used for cache eviction. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `<cache:cache-evict>` | 它等同于`@CacheEvict`注解，并用于缓存清除。 |'
- en: Let's see the following example based on XML-based configuration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于XML配置的以下示例：
- en: Create a configuration file, `spring.xml` as follows**:**
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个配置文件，`spring.xml`如下**：**
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding XML configuration file, the highlighted code is the Spring
    cache configuration. In the cache configuration, the first thing that you see
    is the declared `<aop:config>` then `<aop:advisor>`, which have references to
    the advice whose ID is `cacheAccount`, and also has a pointcut expression to match
    the advice. The advice is declared with the `<cache:advice>` element. This element
    can have many `<cache:caching>` elements. But, in our example, we have only one
    `<cache:caching>` element, which has a `<cache:cacheable>` element, a `<cache:cache-put>`,
    and one `<cache:cache-evict>` element; each declare a method from the pointcut
    as being cacheable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的XML配置文件中，高亮显示的代码是Spring缓存配置。在缓存配置中，您首先看到的是声明的`<aop:config>`然后`<aop:advisor>`，它们引用了ID为`cacheAccount`的建议，并且还有一个匹配建议的点切表达式。建议是用`<cache:advice>`元素声明的。此元素可以有多个`<cache:caching>`元素。但，在我们的例子中，我们只有一个`<cache:caching>`元素，它包含一个`<cache:cacheable>`元素、一个`<cache:cache-put>`和一个`<cache:cache-evict>`元素；每个都声明了从点切中的方法作为可缓存的。
- en: 'Let''s see the `Service` class of the application with cache annotations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看带有缓存注解的应用程序的`Service`类：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding file definition, we have used Spring's cache annotations to
    create the cache in the application. Now let's see how to configure the cache
    storage in an application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件定义中，我们使用了Spring的缓存注解在应用程序中创建缓存。现在让我们看看如何在应用程序中配置缓存存储。
- en: Configuring the cache storage
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置缓存存储
- en: Spring's cache abstraction provides a lot of storage integration. Spring provides
    `CacheManager` for each memory storage. You can just configure `CacheManager`
    with the application. Then the `CacheManager` is responsible for controlling and
    managing the Caches. Let's explore how to set up the `CacheManager` in an application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的缓存抽象提供了大量的存储集成。Spring为每个内存存储提供`CacheManager`。您只需将`CacheManager`与应用程序配置即可。然后`CacheManager`负责控制和管理工作缓存。让我们探索如何在应用程序中设置`CacheManager`。
- en: Setting up the CacheManager
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置CacheManager
- en: You must specify a cache manager in the application for storage, and some cache
    provider given to the `CacheManager`, or you can write your own `CacheManager`.
    Spring provides several cache managers in the `org.springframework.cache` package,
    for example, `ConcurrentMapCacheManager`, which creates a `ConcurrentHashMap`
    for each cache storage unit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在应用程序中指定一个缓存管理器用于存储，以及提供给`CacheManager`的某些缓存提供者，或者您可以编写自己的`CacheManager`。Spring在`org.springframework.cache`包中提供了几个缓存管理器，例如`ConcurrentMapCacheManager`，它为每个缓存存储单元创建一个`ConcurrentHashMap`。
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`SimpleCacheManager`, `ConcurrentMapCacheManager`, and others are cache managers
    of the Spring Framework''s cache abstraction. But Spring provides support for
    integration with third-party cache managers, as we will see in the following section.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleCacheManager`、`ConcurrentMapCacheManager`和其他是Spring框架缓存抽象的缓存管理器。但Spring提供了与第三方缓存管理器集成的支持，我们将在下一节中看到。'
- en: Third-party cache implementations
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方缓存实现
- en: 'Spring''s `SimpleCacheManager` is ok for testing, but has no cache control
    options (overflow, eviction). So we have to use third-party alternatives like
    the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`SimpleCacheManager`适用于测试，但没有缓存控制选项（溢出、驱逐）。因此，我们必须使用如下的第三方替代方案：
- en: Terracotta's EhCache
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terracotta的EhCache
- en: Google's Guava and Caffeine
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google的Guava和Caffeine
- en: Pivotal's Gemfire
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal的Gemfire
- en: Let's see one of the configurations of third-party cache managers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第三方缓存管理器的一种配置。
- en: Ehcache-based cache
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Ehcache的缓存
- en: '**Ehcache** is one of the most popular cache providers. Spring allows you to
    integrate with Ehcache by configuring `EhCacheCacheManager` in the application.
    Take for example, the following Java configuration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ehcache**是最受欢迎的缓存提供者之一。Spring允许您通过在应用程序中配置`EhCacheCacheManager`来与Ehcache集成。例如，以下Java配置：'
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, the bean method, `cacheManager()`, creates an object
    of `EhCacheCacheManager`, and set it with the `CacheManager` of Ehcache. Here,
    Ehcache''s `CacheManager` is injected into Spring''s `EhCacheCacheManager`. The
    second bean method, `ehCacheManagerFactoryBean()`, creates and returns an instance
    of `EhCacheManagerFactoryBean`. Because it''s a Factory bean, it will return an
    instance of `CacheManager`. An XML file, `ehcache.xml`, has the Ehcache configuration.
    Let''s refer to the following code for `ehcache.xml`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，bean方法`cacheManager()`创建了一个`EhCacheCacheManager`的对象，并将其与Ehcache的`CacheManager`相关联。第二个bean方法`ehCacheManagerFactoryBean()`创建并返回一个`EhCacheManagerFactoryBean`的实例。因为它是一个工厂bean，所以它将返回一个`CacheManager`的实例。一个XML文件`ehcache.xml`包含了Ehcache配置。让我们参考以下代码中的`ehcache.xml`：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The contents of the `ehcache.xml` file vary from application to application,
    but you need to declare, at least, a minimal cache. For example, the following
    Ehcache configuration declares a cache named **accountCache** with 50 MB of maximum
    heap storage and a time-to-live of 100 seconds:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ehcache.xml`文件的内容因应用程序而异，但您至少需要声明一个最小缓存。例如，以下Ehcache配置声明了一个名为**accountCache**的缓存，最大堆存储为50
    MB，存活时间为100秒：'
- en: XML-based configuration
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于XML的配置
- en: 'Let''s create XML based configuration for the Eache, and it is configuring
    here `EhCacheCacheManager`. Please refer to the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为ECache创建基于XML的配置，并且在这里配置的是`EhCacheCacheManager`。请参考以下代码：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly, in case of the XML configuration, you have to configure the cache
    manager for ehcache, configure the `EhCacheManagerFactoryBean` class, and set
    the config-location value with `ehcache.xml`, which has the Ehcache configuration
    as defined in the previous section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在XML配置的情况下，您必须为ehcache配置缓存管理器，配置`EhCacheManagerFactoryBean`类，并将`config-location`值设置为`ehcache.xml`，其中包含上一节中定义的Ehcache配置。请参考以下代码：
- en: There are many more third-party caching storages which have integration support
    with the Spring Framework. In this chapter, I have discussed only the ECache manager.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多第三方缓存存储支持与Spring框架的集成。在本章中，我只讨论了ECache管理器。
- en: In the following section, we'll discuss how Spring allows you to create your
    own custom annotation for caching.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Spring如何允许您创建自己的自定义缓存注解。
- en: Creating custom caching annotations
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义缓存注解
- en: 'Spring''s cache abstraction allows you to create custom caching annotations
    for your application to recognize the cache method for the cache population or
    cache eviction. Spring''s `@Cacheable` and `@CacheEvict` annotations are used
    as Meta annotations to create custom cache annotation. Let''s see the following
    code for custom annotations in an application:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的缓存抽象允许您为您的应用程序创建自定义缓存注解，以便识别缓存方法用于缓存填充或缓存删除。Spring的`@Cacheable`和`@CacheEvict`注解用作元注解来创建自定义缓存注解。让我们看看以下代码中应用程序中的自定义注解：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code snippet, we have defined a custom annotation named as
    `SlowService`, which is annotated with Spring''s `@Cacheable` annotation. If we
    use `@Cacheable` in the application, then we have to configure it as the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个名为`SlowService`的自定义注解，该注解被Spring的`@Cacheable`注解标注。如果我们想在应用程序中使用`@Cacheable`，那么我们必须按照以下代码进行配置：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s replace the preceding configuration with our defined custom annotation,
    with the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下代码替换前面的配置，使用我们定义的自定义注解：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we use only the `@SlowService` annotation to make a method cacheable
    in the application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只使用`@SlowService`注解来使方法在应用程序中可缓存。
- en: Now let's move on to the next section, where we'll see which are the best practices
    we should consider at the time of cache implementation in anapplication.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到下一节，我们将看到在应用程序缓存实现时应考虑的最佳实践。
- en: Top caching best practices to be used in a web application
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web应用程序中应使用的顶级缓存最佳实践
- en: 'In your enterprise web application, proper use of caching enables the web page
    to be rendered very fast, minimizes the database hits, and reduces the consumption
    of the server''s resources such as memory, network, and so on. Caching is a very
    powerful technique to boost your application''s performance by storing stale data
    in the cache memory. The following are the best practices which should be considered
    at the time of design and development of a web application:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的企业Web应用程序中，适当使用缓存可以使网页渲染非常快，最小化数据库访问次数，并减少服务器资源（如内存、网络等）的消耗。缓存是将过时数据存储在缓存内存中，以提升应用程序性能的非常强大的技术。以下是在设计和开发Web应用程序时应考虑的最佳实践：
- en: In your Spring web application, Spring's cache annotations such as `@Cacheable`,
    `@CachePut`, and `@CacheEvict` should be used on concrete classes instead of application
    interfaces. However, you can annotate the interface method as well, using interface-based
    proxies. Remember that Java annotations are not inherited from interfaces, which
    means that if you are using class-based proxies by setting the attribute `proxy-target-class="true"`,
    then Spring cache annotations are not recognized by the proxying.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的Spring Web应用程序中，应将Spring的缓存注解（如`@Cacheable`、`@CachePut`和`@CacheEvict`）应用于具体类，而不是应用程序接口。然而，您也可以使用基于接口的代理来注解接口方法。请记住，Java注解不是从接口继承的，这意味着如果您通过设置属性`proxy-target-class="true"`使用基于类的代理，那么Spring缓存注解不会被代理识别。
- en: If you have annotated any method with the `@Cacheable`, @CachePut, or `@CacheEvict`
    annotations, then never call it directly by another method of the same class if
    you want to benefit from the cache in the application. This is because in direct
    calling of a cached method, the Spring AOP proxy is never applied.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您已对任何方法使用`@Cacheable`、`@CachePut`或`@CacheEvict`注解，那么如果您想从应用程序中的缓存中受益，请不要通过同一类的另一个方法直接调用它。这是因为，在直接调用缓存方法时，Spring
    AOP代理永远不会应用。
- en: 'In an enterprise application, Java Maps or any key/value collections should
    never be used as a Cache. Any key/value collection cannot be a Cache. Sometimes,
    developers use java map as a custom caching solution, but it is not a caching
    solution, because Cache provides more than a key/value storage, like the following:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在企业应用程序中，Java Maps或任何键/值集合永远不应该用作缓存。任何键/值集合都不能作为缓存。有时，开发人员将Java Map用作自定义缓存解决方案，但这不是缓存解决方案，因为缓存提供的不仅仅是键/值存储，如下所示：
- en: Cache provides eviction policies
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存提供驱逐策略
- en: You can set the max size limit of Cache
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以设置缓存的最高大小限制
- en: Cache provides a persistent store
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存提供持久存储
- en: Cache provides weak reference keys
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存提供弱引用键
- en: Cache provides statistics
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存提供统计信息
- en: The Spring Framework provides the best declarative approach to implement and
    configure the Cache solution in an application. So, always use the cache abstraction
    layer--it provides flexibility in the application. We know that the `@Cacheable`
    annotation allows you to separate business logic code from the caching cross-cutting
    concern.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架提供了在应用程序中实现和配置缓存解决方案的最佳声明式方法。因此，始终使用缓存抽象层——它为应用程序提供了灵活性。我们知道`@Cacheable`注解允许您将业务逻辑代码与缓存横切关注点分离。
- en: Be careful whenever you use cache in the application. Always use cache in a
    place where it is actually required such as a web service or an expensive database
    call, because every caching API has an overhead.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中使用缓存时务必小心。始终在确实需要的地方使用缓存，例如在Web服务或昂贵的数据库调用中，因为每个缓存API都有开销。
- en: At the time of cache implementation in an application, you have to ensure that
    the data in the cache is in sync with the data storage. You can use distributed
    cache managers like Memcached for proper cache strategy implementation to provide
    considerable performance.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中实现缓存时，您必须确保缓存中的数据与数据存储保持同步。您可以使用像Memcached这样的分布式缓存管理器来实施适当的缓存策略，以提供相当的性能。
- en: You should use cache only as second option if data fetching is very difficult
    from the database because of slow database queries. It is because, whenever we
    use caching behavior in the application, first the value is checked in the cache
    if not available then it execute actual method, so it would be unnecessary.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于数据库查询缓慢，从数据库中获取数据非常困难，那么您应该只将缓存作为第二选择。这是因为，每当我们在应用程序中使用缓存行为时，首先会在缓存中检查值，如果没有找到，则执行实际方法，所以这将是多余的。
- en: In this chapter, we saw how caching helps to improve the performance of anapplication.
    Caching mostly works on the service layer of the application. In your application,
    there is a data returned by a method; we can cache that data if the application
    code calls it over and over again from the same requirement. Caching is a great
    way to avoid execution of the application method for the same requirements. The
    return value of the method for a specific parameter is stored in a cache whenever
    this method is invoked for the first time. For further calls of the same method
    for same parameter, the value is retrieved from that cache. Caching improves application
    performance by avoiding some resource and time consuming operations for same answers
    like performing a database query.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了缓存如何帮助提高应用程序的性能。缓存主要在应用程序的服务层工作。在你的应用程序中，有一个由方法返回的数据；如果应用程序代码从相同的要求中反复调用它，我们可以缓存这些数据。缓存是一种避免为相同要求执行应用程序方法的好方法。当这个方法第一次被调用时，特定参数的方法返回值会存储在缓存中。对于相同参数的相同方法的后续调用，值将从该缓存中检索。通过避免执行一些资源消耗和时间消耗的操作，如执行数据库查询，缓存提高了应用程序的性能。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Spring provides Cache Manager to manage caching in a Spring application. In
    this chapter, you have seen how to define the caching manager for a particular
    caching technology. Spring provides some annotations for caching such as `@Cacheable`,
    `@CachePut`*,* and `@CacheEvict`, which we can use in our Spring application.
    We can also configure caching in the Spring application by using the XML configuration.
    Spring framework provides cache namespace to achieve this. The `<cache:cacheable>`,
    `<cache:cache-put>`, and `<cache:cache-evict>` elements are used instead of the
    corresponding annotations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为Spring应用程序提供了缓存管理器来管理缓存。在本章中，你已经看到了如何为特定的缓存技术定义缓存管理器。Spring提供了一些用于缓存的注解，例如`@Cacheable`、`@CachePut`*和`@CacheEvict`，我们可以在我们的Spring应用程序中使用它们。我们还可以通过使用XML配置来配置Spring应用程序中的缓存。Spring框架提供了缓存命名空间来实现这一点。使用`<cache:cacheable>`、`<cache:cache-put>`和`<cache:cache-evict>`元素代替相应的注解。
- en: Spring makes it possible to manage caching in anapplication by using Aspect-Oriented
    Programming. Caching is a cross-cutting concern for the Spring Framework. That
    means, caching is as an aspect in the Spring application. Spring implements caching
    by using around advice of the Spring AOP module.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Spring通过使用面向切面编程使得在应用程序中管理缓存成为可能。缓存是Spring框架的一个横切关注点。这意味着，缓存作为Spring应用程序的一个方面。Spring通过使用Spring
    AOP模块的环绕通知来实现缓存。
- en: In the next [Chapter 10](ef5eac66-9b41-4959-8155-96f002137409.xhtml)*, Implementing
    MVC Pattern in a Web Application using Spring*, we will explore how Spring we
    can use in the web layer and with the MVC pattern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[第10章](ef5eac66-9b41-4959-8155-96f002137409.xhtml)*，使用Spring在Web应用程序中实现MVC模式*，我们将探讨Spring如何在Web层和MVC模式中使用。
