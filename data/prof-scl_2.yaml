- en: Chapter 2. Basic Language Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 基本语言特性
- en: In the previous chapter, we learned the various aspects of setting up the development
    environment wherein we covered the structure of a Scala project and identified
    the use of `sbt` for building and running projects. We covered REPL, which is
    a command-line interface for running Scala code, and how to develop and run code
    over the IDEA IDE. Finally, we implemented interactions with our simple `chatbot`
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了设置开发环境的各个方面，其中我们涵盖了Scala项目的结构，并确定了使用`sbt`构建和运行项目。我们介绍了REPL，它是运行Scala代码的命令行界面，以及如何在IDEA
    IDE中开发和运行代码。最后，我们实现了与我们的简单`chatbot`应用程序的交互。
- en: In this chapter, we will explore the so-called 'OO' part of Scala, which allows
    us to build constructions similar to analogs in any mainstream language, such
    as Java or C++. The object-oriented part of Scala will cover classes and objects,
    traits, pattern matching, case class, and so on. Finally, we will implement the
    object-oriented concepts that we learn to our chatbot application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索所谓的Scala的“OO”部分，它允许我们构建类似于任何主流语言（如Java或C++）的类似结构。Scala的面向对象部分将涵盖类和对象、特性、模式匹配、案例类等。最后，我们将把所学的面向对象概念应用到我们的聊天机器人应用程序中。
- en: Looking at the history of programming paradigms, we will notice that the first
    generation of high-level programming languages (Fortran, C, Pascal) were procedure
    oriented, without OO or FP facilities. Then, OO become a hot topic in programming
    languages in the 1980s.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察编程范式的历史，我们会注意到第一代高级编程语言（Fortran、C、Pascal）是过程导向的，没有面向对象或函数式编程功能。然后，面向对象在20世纪80年代成为编程语言的热门话题。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下事情：
- en: Identify the structure of non-trivial Scala programs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别非平凡Scala程序的结构
- en: 'Identify how to use main object-oriented facilities: objects, classes, and
    traits'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别如何使用主要面向对象功能：对象、类和特性
- en: Recognize the details of function call syntax and parameter-passing modes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别函数调用语法和参数传递模式的细节
- en: Objects, Classes, and Traits
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象、类和特性
- en: 'Scala is a multiparadigm language, which unites functional and OO programming.
    Now, we will explore Scala''s traditional object-oriented programming facilities:
    object, classes, and traits.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种多范式语言，它结合了函数式和面向对象编程。现在，我们将探索Scala的传统面向对象编程功能：对象、类和特性。
- en: 'These facilities are similar in the sense that each one contains some sets
    of data and methods, but they are different regarding life cycle and instance
    management:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在某种意义上是相似的，因为每个都包含一些数据集和方法，但在生命周期和实例管理方面是不同的：
- en: Objects are used when we need a type with one instance (such as singletons)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要一个只有一个实例的类型（例如单例）时，会使用对象。
- en: Classes are used when we need to have many instances, which can be created with
    the help of the new operator
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要许多实例，并且可以使用new运算符创建时，会使用类。
- en: Traits are used for mix-ins into other classes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性用于将混合到其他类中
- en: Note that it is not worth navigating through code, as this is exposed in examples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有必要在代码中导航，因为这已经在示例中暴露了。
- en: Object
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'We have seen an object in the previous chapter. Let''s scroll through our codebase
    and open the file named `Main` in `Lesson 2/3-project`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了一个对象。现在让我们浏览我们的代码库，并在`Lesson 2/3-project`目录下打开名为`Main`的文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s just a set of definitions, grouped into one object, which is available
    statically. That is, the implementation of a singleton pattern: we only have one
    instance of an object of a given type.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一组定义，被组合成一个对象，并且是静态可用的。也就是说，这是单例模式的实现：我们只有一个给定类型的对象实例。
- en: 'Here, we can see the definition of the value ( `val effects`) and main functions.
    The syntax is more-or-less visible. One non-obvious thing is that the `val` and
    `var` definitions that are represented are not plain field, but internal field
    and pairs of functions: the `getter` and `setter` functions for `var-s`. This
    allows overriding `def-s` by `val-s`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到值的定义（`val effects`）和主要函数。语法或多或少是可见的。一个不那么明显的事情是，所表示的`val`和`var`定义不是普通字段，而是内部字段和函数对：`var-s`的`getter`和`setter`函数。这允许通过`val-s`覆盖`def-s`。
- en: Note that the name in the object definition is a name of an object, not a name
    of the type. The type of the object, `Chatbot3`, can be accessed as `Chatb` `ot3.type.`
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对象定义中的名称是对象的名称，而不是类型的名称。对象的类型`Chatbot3`可以通过`Chatbot3.type`访问。
- en: Let's define the object and call a method. We will also try to assign the object
    to a variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义对象并调用一个方法。我们还将尝试将对象分配给一个变量。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should have `project-3` opened in IDEA.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 IDEA 中打开 `project-3`。
- en: Navigate to the project structure and find the `com.packt.courseware.l3` package.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目结构并找到 `com.packt.courseware.l3` 包。
- en: Right-click and select `create class` in the context menu.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并从上下文菜单中选择 `创建类`。
- en: Enter `ExampleObject` in the name field and choose `object` in the kind field
    of the form.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名称字段中输入 `ExampleObject`，并在表单的类型字段中选择 `object`。
- en: IDEA will generate the file in the object.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDEA 将在对象中生成文件。
- en: 'Insert the following in the object definition:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象定义中插入以下内容：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Classes
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'Classes form the next step in abstractions. Here is an example of a class definition:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类是抽象的下一步。以下是一个类定义的示例：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here is a class with parameters ( `phi`, `radius`) specified in the class definition.
    Statements outside the class methods (such as require statements) constitute the
    body of a primary constructor.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在类定义中指定了参数（`phi`，`radius`）的类。类方法之外（如 require 语句）的语句构成了主构造函数的主体。
- en: The next definition is a secondary constructor, which must call the primary
    constructor at the first statement.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定义是一个次要构造函数，它必须在第一行调用主构造函数。
- en: 'We can create an object instance using the `new` operator:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `new` 运算符创建对象实例：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By default, member access modifiers are `public`, so once we have created an
    object, we can use its methods. Of course, it is possible to define the method
    as `protected` or `private`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，成员访问修饰符是 `public`，因此一旦我们创建了一个对象，我们就可以使用它的方法。当然，也可以将方法定义为 `protected` 或
    `private`。
- en: 'Sometimes, we want to have constructor parameters available in the role of
    class members. A special syntax for this exists:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望构造函数参数在类成员的角色中可用。为此存在一种特殊语法：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we write `val` as a modifier of the constructor argument ( `phi`), then `phi`
    becomes a member of the class and will be available as a field.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `val` 作为构造函数参数的修饰符（`phi`），那么 `phi` 就成为类的一个成员，并将作为字段可用。
- en: 'If you browse the source code of a typical Scala project, you will notice that
    an object with the same name as a class is often defined along with the class
    definition. Such objects are called `companion` objects of a class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览典型 Scala 项目的源代码，你会注意到与类定义一起经常定义一个与类同名的对象。这样的对象被称为类的 `companion` 对象：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a typical place for utility functions, which in the Java world are usually
    represented by `static` methods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是实用函数的典型位置，在 Java 世界中通常由 `static` 方法表示。
- en: Method names also exist, which allow you to use special syntax sugar on the
    call side. We will tell you about all of these methods a bit later. We will talk
    about the `apply` method now.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称也存在，这允许你在调用侧使用特殊语法糖。我们稍后会告诉你所有这些方法。现在，我们将讨论 `apply` 方法。
- en: When a method is named `apply`, it can be called via functional call braces
    (for example, `x(y)` is the same as `x.apply(y),` if `apply` is defined in `x`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法命名为 `apply` 时，它可以通过函数调用括号来调用（例如，如果 `apply` 在 `x` 中定义，则 `x(y)` 与 `x.apply(y)`
    相同）。
- en: Conventionally, the `apply` method in the companion object is often used for
    instance creation to allow the syntax without the `new` operator. So, in our example,
    `PolarPoint(3.0,5.0)` will be demangled to `PolarPoint.apply(3.0,5.0)`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，伴随对象的 `apply` 方法通常用于实例创建，以允许不使用 `new` 运算符的语法。所以，在我们的例子中，`PolarPoint(3.0,5.0)`
    将被解耦为 `PolarPoint.apply(3.0,5.0)`。
- en: Now, let's define a case class, CartesianPoint, with the method length.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个带有 `length` 方法的案例类 `CartesianPoint`。
- en: Ensure that the `Lesson 2/4-project` project is open in IDE.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 IDE 中打开了 `Lesson 2/4-project` 项目。
- en: Create a new Scala class with the name `CartesianPoint`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名称 `CartesianPoint` 创建一个新的 Scala 类。
- en: 'The code should be something like this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应该像这样：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Equality and Case Classes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平等性和案例类
- en: 'In general, two flavors of equality exist:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，存在两种类型的平等：
- en: '**Extensional**, where two objects are equal when all external properties are
    equal.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展性**，当两个对象的所有外部属性都相等时，它们是相等的。'
- en: In JVM, a user can override equals and `hashCode` methods of an object to achieve
    such a behavior.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JVM 中，用户可以通过重写对象的 `equals` 和 `hashCode` 方法来实现这种行为。
- en: In a Scala expression, `x == y` is a shortcut of `x.equals(y)` if `x` is a reference
    type (for example, a class or object).
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Scala 表达式中，如果 `x` 是引用类型（例如，一个类或对象），则 `x == y` 是 `x.equals(y)` 的快捷方式。
- en: '**Intentional** (or reference), where two objects with the same properties
    can be different because they had been created in a different time and context.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有意**（或引用），其中具有相同属性的两个对象可以不同，因为它们是在不同的时间和环境中创建的。'
- en: In JVM, this is the comparison of references; `(x == y)` in Java and `(x eq
    y)` in Scala.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JVM中，这是引用的比较；（Java中的`(x == y)`和Scala中的`(x eq y)`）。
- en: Looking at our `PolarPoint`, it looks as though if we want `PolarPoint(0,1)`
    to be equal `PolarPoint(0,1)`, then we must override `equals` and `hashCode`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的`PolarPoint`，如果我们想`PolarPoint(0,1)`等于`PolarPoint(0,1)`，那么我们必须重写`equals`和`hashCode`。
- en: The Scala language provides a flavor of classes, which will do this work (and
    some others) automatically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Scala语言提供了一种类风味，它将自动执行这项工作（以及其他一些工作）。
- en: 'Let''s see the `case` classes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`case`类：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we mark a class as a case class, the Scala compiler will generate the
    following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个类标记为案例类时，Scala编译器将生成以下内容：
- en: '`equals` and `hashCode` methods, which will compare classes by components'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals`和`hashCode`方法，这些方法将通过组件比较类'
- en: '`A toString` method which will output components'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A toString`方法，它将输出组件'
- en: '`A copy` method, which will allow you to create a copy of the class, with some
    of the fields changed:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A copy`方法，它将允许你创建类的副本，其中一些字段已更改：'
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All parameter constructors will become class values (therefore, we do not need
    to write `val`)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数构造函数都将成为类值（因此，我们不需要写`val`）
- en: The companion object of a class with the apply method (for constructor shortcuts)
    and `unapply` method (for deconstruction in case patterns)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有apply方法（用于构造器快捷方式）和`unapply`方法（用于案例模式中的解构）的类的伴生对象
- en: Now, we'll look at illustrating the differences between value and reference
    equality.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨说明值相等和引用相等之间的差异。
- en: In `test/com.packt.courseware.l4`, create a worksheet.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/com.packt.courseware.l4`中创建一个工作表。
- en: Note
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To create a worksheet, navigate to package, and right-click and choose create
    a Scala worksheet from the drop-down menu.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建工作表，导航到包，然后右键单击并从下拉菜单中选择创建Scala工作表。
- en: 'Define a non-case class with fields in this file after import:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入之后，在此文件中定义一个非案例类，包含字段：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the results are `false`.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，结果是`false`。
- en: 'Define the case class with the same fields:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义具有相同字段的案例类：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Write a similar test. Note the differences:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个类似的测试。注意差异：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pattern Matching
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配
- en: '**Pattern matching** is a construction that was first introduced into the ML
    language family near 1972 (another similar technique can also be viewed as a pattern-matching
    predecessor, and this was in REFAL language in 1968). After Scala, most new mainstream
    programming languages (such as Rust and Swift) also started to include pattern-matching
    constructs.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式匹配**是一种构造，它最初于1972年左右引入到ML语言家族中（另一种类似的技术也可以被视为模式匹配的前身，这发生在1968年的REFAL语言中）。在Scala之后，大多数新的主流编程语言（如Rust和Swift）也开始包含模式匹配结构。'
- en: 'Let''s look at pattern-matching usage:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模式匹配的使用：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On the second line, we see a match/case expression; we match `p` against the
    sequence of case-e clauses. Each case clause contains a pattern and body, which
    is evaluated if the matched expression satisfies the appropriative pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们看到一个match/case表达式；我们将`p`与case-e子句的序列进行匹配。每个case子句包含一个模式和主体，如果匹配的表达式满足适当的模式，则评估主体。
- en: In this example, the first case pattern will match any point with a radius of
    `0`, that is, `_` match any.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一个案例模式将匹配任何半径为`0`的点，即`_`匹配任何。
- en: Second–This will satisfy any `PolarPoint` with a radius of one, as specified
    in the optional pattern condition. Note that the new value ( `x`) is introduced
    into the body context.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二 - 这将满足任何半径为1的`PolarPoint`，如可选模式条件中指定的。注意新值（`x`）被引入到主体上下文中。
- en: Third – This will match any point; bind `x` and `y` to `phi` and the `radius`
    accordingly, and `v` to the pattern ( `v` is the same as the original matched
    pattern, but with the correct type).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第三 - 这将匹配任何点；将`x`和`y`绑定到`phi`和相应的`radius`，并将`v`绑定到模式（`v`与原始匹配模式相同，但具有正确的类型）。
- en: The final case expression is a `default` case, which matches any value of `p`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的案例表达式是一个`default`案例，它匹配`p`的任何值。
- en: Note that the patterns can be nested.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模式可以嵌套。
- en: As we can see, case classes can participate in case expression and provide a
    method for pushing matched values into the body's content (which is deconstructed).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，案例类可以参与案例表达式，并提供将匹配值推入主体内容的方法（这是解构）。
- en: Now, it's time to use match/case statements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用match/case语句了。
- en: Create a class file in the test sources of the current project with the name
    `Person`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前项目的测试源中创建一个名为 `Person` 的类文件。
- en: Create a case class called `Person` with the members `firstName` and `lastName:`
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个名为 `Person` 的案例类，包含成员 `firstName` 和 `lastName`: '
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create a companion object and add a method which accepts `person` and returns
    `String:`
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个伴随对象并添加一个接受 `person` 并返回 `String` 的方法：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a `case` statement, which will print:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `case` 语句，它将打印：
- en: '"`A`" if the person''s first name is "`Joe`"'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果人的名字是 "Joe"，则输出 "`A`"
- en: '"`B`" if the person does not satisfy other cases'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果人不满足其他情况，则输出 "`B`"
- en: '"`C`" if the `lastName` starts in lowercase'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `lastName` 以小写字母开头，则输出 "`C`"
- en: 'Create a test-case for this method:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此方法创建一个测试用例：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Traits
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性
- en: Traits are used for grouping methods and values which can be used in other classes.
    The functionality of traits is mixed into other traits and classes, which in other
    languages are appropriative constructions called `mixins`. In Java 8, interfaces
    are something similar to traits, since it is possible to define default implementations.
    This isn't entirely accurate, though, because Java's default method can't fully
    participate in inheritance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 特性用于对方法和值进行分组，这些方法和值可以在其他类中使用。特性的功能与其他特性和类混合，在其他语言中，这种适当的构造被称为 `mixins`。在 Java
    8 中，接口类似于特性，因为可以定义默认实现。但这并不完全准确，因为 Java 的默认方法不能完全参与继承。
- en: 'Let''s look at the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a trait, which can be extended by the `PolarPoint` class, or with the
    `CartesianPoint` with the next definition:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个特性，它可以被 `PolarPoint` 类扩展，或者与 `CartesianPoint` 使用以下定义一起使用：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Instances of traits cannot be created, but it is possible to create anonymous
    classes extending the trait:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 特性的实例不能创建，但可以创建扩展特性的匿名类：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is an example of a trait:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个特性的示例：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see, the conflicting method must be overridden:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，冲突的方法必须被覆盖：
- en: 'Yet one puzzle:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个谜题：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The result of `D1.g` will be `g.B`, and `D2.g` will be `g.C`. This is because
    traits are linearized into sequence, where each trait overrides methods from the
    previous one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`D1.g` 的结果将是 `g.B`，而 `D2.g` 将是 `g.C`。这是因为特性被线性化为序列，其中每个特性覆盖了前一个特性中的方法。'
- en: Now, let's try to represent the diamond in a trait hierarchy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在特性层次结构中表示菱形。
- en: 'Create the following entities:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下实体：
- en: '`Component` – A `base` class with the `description()` method, which outputs
    the description of a component.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component` – 一个具有 `description()` 方法的 `base` 类，该方法输出组件的描述。'
- en: '`Transmitter` – A component which generates a signal and has a method called
    `generateParams`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transmitter` – 一个生成信号并具有名为 `generateParams` 的方法的组件。'
- en: '`Receiver` – A component which accepts a signal and has a method called `receiveParams`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Receiver` – 一个接受信号并具有名为 `receiveParams` 的方法的组件。'
- en: Radio – A `Transmitter` and `Receiver`. Write a set of traits, where `A` is
    modelled as inheritance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无线电 – 一个 `Transmitter` 和 `Receiver`。编写一组特性，其中 `A` 被建模为继承。
- en: 'The answer to this should be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案应该是以下内容：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Self-Types
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自类型
- en: 'In Scale-trait, you can sometimes see the self-types annotation, for example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scale-trait 中，有时可以看到自类型注解，例如：
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的代码，请参阅 `Code Snippets/Lesson 2.scala` 文件。
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we see the `identifier => {typeName}` prefix, which is usually a self-type
    annotation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到 `identifier => {typeName}` 前缀，这通常是一个自类型注解。
- en: If the type is specified, that trait can only be mixed-in to this type. For
    example, `VanillaTrait` can only be mixed in with Drink. If we try to mix this
    with another object, we will receive an error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了类型，则该特性只能混合到该类型中。例如，`VanillaTrait` 只能与 `Drink` 混合。如果我们尝试将其与另一个对象混合，我们将收到一个错误。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If `Flavor` is not extended from `Drink`, but has access to `Drink` methods
    such as looks, as in `Flavor,` we situate it inside Drink.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Flavor` 不是从 `Drink` 扩展，但可以访问 `Drink` 方法，如 `Flavor` 中的外观，那么我们将其置于 `Drink`
    内部。
- en: 'Also, self-annotation can be used without specifying a type. This can be useful
    for nested traits when we want to call "this" of an enclosing trait:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用自注解而不指定类型。这在嵌套特性中很有用，当我们想要调用封装特性的 "this" 时：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Sometimes, we can see the organization of some big classes as a set of traits,
    grouped around one 'base'. We can visualize this as 'Cake', which consists of
    the 'Pieces:' self-annotated trait. We can change one piece to another by changing
    the mix-in traits. Such an organization of code is named the 'Cake pattern'. Note
    that using the Cake pattern is often controversial, because it's relative easy
    to create a 'God object'. Also note that the refactor class hierarchy with the
    cake-pattern inside is harder to implement.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可以将一些大型类的组织看作是一组特质，围绕一个“基础”分组。我们可以将这种组织看作是“蛋糕”，它由自注解的特质“Pieces:”组成。我们可以通过更改混入的特质来改变一个部分到另一个部分。这种代码组织方式被称为“蛋糕模式”。请注意，使用蛋糕模式通常是有争议的，因为它很容易创建一个“上帝对象”。另外，请注意，在蛋糕模式内部重构类层次结构更难实现。
- en: Now, let's explore annotations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索注解。
- en: 'Create an instance of Drink with Tee with `VanillaFlavour` which refers to
    `description`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`VanillaFlavour`的Tee实例，该实例引用`description`：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Try to override the description in the `Tee` class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在`Tee`类中覆盖描述：
- en: 'Uncomment `Tee`: `def description = plain tee` in the `Drinks` file.'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在`Drinks`文件中取消注释`Tee`: `def description = plain tee`。'
- en: Check if any error message arises.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查是否有错误信息出现。
- en: 'Create the third object, derived from `Drink` with `Tee` and `VanillaFlavour`
    with an overloaded description:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第三个对象，从`Drink`派生，带有`Tee`和`VanillaFlavour`，具有重载的描述：
- en: '[PRE25]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于完整代码，请参考`Code Snippets/Lesson 2.scala`文件。
- en: 'Also note that special syntax for methods exists, which must be ''mixed'' after
    the overriding method, for example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，存在特殊的方法语法，必须在覆盖方法之后进行“混合”，例如：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we see that the methods marked as `abstract override` can call `super`
    methods, which are actually defined in traits, not in this base class. This is
    a relatively rare technique.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到标记为`abstract override`的方法可以调用`super`方法，这些方法实际上是在特质中定义的，而不是在这个基类中。这是一种相对罕见的技巧。
- en: Special Classes
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊类
- en: 'There are a few classes with special syntax, which play a significant role
    in the Scala type system. We will cover this in detail later, but now let''s just
    enumerate some:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个类具有特殊语法，在Scala类型系统中起着重要作用。我们将在稍后详细讨论这个问题，但现在让我们只列举一些：
- en: '**Functions**: In Scala, this can be coded as `A => B`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：在Scala中，这可以编码为`A => B`。'
- en: '**Tuples**: In Scala, this can be coded as `(A,B), (A,B,C)` … and so on, which
    is a syntax sugar for `Tuple2[A,B]`, `Tuple3[A,B,C],` and so on'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：在Scala中，这可以编码为`(A,B), (A,B,C)`等等，这是`Tuple2[A,B]`、`Tuple3[A,B,C]`等的语法糖。'
- en: OO in Our Chatbot
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们聊天机器人的面向对象
- en: Now that you know the theoretical basics, let's look at these facilities and
    how they are used in our program. Let's open `Lesson 2/3-project` in our IDE and
    extend our chatbot, which was developed in the previous chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了理论基础知识，让我们看看这些设施以及它们在我们程序中的使用方式。让我们在我们的IDE中打开`Lesson 2/3-project`并扩展我们在上一章中开发的聊天机器人。
- en: Decoupling Logic and Environment
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解耦逻辑和环境
- en: To do this, we must decouple the environment and logic, and integrate only one
    in the `main` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须解耦环境和逻辑，并在`main`方法中仅集成一个。
- en: 'Let''s open the `EffectsProvider` class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`EffectsProvider`类：
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整代码，请参考`Code Snippets/Lesson 2.scala`文件。
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we encapsulate all of the effects into our traits, which can have different
    implementations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将所有效果封装到我们的特质中，这些特质可以有不同实现。
- en: 'For example, let''s look at `UserOutput`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看`UserOutput`：
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整代码，请参考`Code Snippets/Lesson 2.scala`文件。
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we can see the trait and object, which implement the current trait. This
    way, when we need to accept commands that are not from standard input, but from
    the chatbot API or from Twitter, we only need to change the implementation of
    the `UserOutput`/ `ConsoleOutput` interfaces.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到特性和对象，它们实现了当前特质。这样，当我们需要接受来自标准输入之外的命令，比如来自聊天机器人API或Twitter的命令时，我们只需要更改`UserOutput`/`ConsoleOutput`接口的实现。
- en: It's now time to implement `ConsoleOutput` and `DefaultTimeProvider`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现`ConsoleOutput`和`DefaultTimeProvider`了。
- en: Replace `???` in main with the appropriative constructor.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中将`???`替换为适当的构造函数。
- en: 'These steps for implementing `ConsoleOutput` and `DefaultTimeProvider` are
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`ConsoleOutput`和`DefaultTimeProvider`的步骤如下：
- en: Ensure that `Lesson 2/3-project` is open in IDE.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在IDE中打开`Lesson 2/3-project`。
- en: 'In the `UserOutput` file, find the `ConsoleOutput` file and change `???` to
    the body of the `write` method. The resulting method should look like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserOutput`文件中，找到`ConsoleOutput`文件，将`???`改为`write`方法的主体。结果方法应该看起来像这样：
- en: '[PRE29]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `TimeProvider` file, add the `DefaultTimeProvide` object which extends
    from `TimeProvider` and implements the `currentTime` and `currentDate` functions.
    The resulting code should look like this:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TimeProvider`文件中，添加一个扩展自`TimeProvider`并实现`currentTime`和`currentDate`函数的`DefaultTimeProvide`对象。结果代码应该看起来像这样：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Sealed Traits and Algebraic Datatypes
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封特性和代数数据类型
- en: 'Let''s deal with the second issue—let''s encapsulate the logic of chatbot modes
    into the trait, which will only deal with logic and nothing else. Look at the
    following definition:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理第二个问题——让我们将聊天机器人模式的逻辑封装到特质中，这个特质将只处理逻辑，不处理其他任何事情。看看以下定义：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For now, let''s ignore `or` and `otherwise` combinators and look at the `process`
    method. It accepts input messages and effects and returns the processing result,
    which can be a failure or message sent to a user with the next state of the mode:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们忽略`or`和`otherwise`组合子，看看`process`方法。它接受输入消息和效果，并返回处理结果，这可能是一个失败或发送给用户的消息，带有模式的下一个状态：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we can see a new modifier: `sealed`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个新修饰符：`sealed`。
- en: 'When a trait (or class) is sealed, it can only be extended in the same file,
    where it is defined. Due to this, you can be sure that, in your family of classes,
    nobody will be able to add a new class to somewhere in your project. If you do
    use case analysis with the help of the match/case expression, a compiler can do
    exhaustive checking: all of the variants are present.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个特性（或类）被密封时，它只能在定义它的同一个文件中进行扩展。由于这个原因，你可以确信，在你的类家族中，没有人能够在你的项目中添加一个新的类。如果你使用match/case表达式进行用例分析，编译器可以进行详尽的检查：所有变体都存在。
- en: Constructions from a family of case classes/objects, extended from a `sealed`
    trait, is often named an Algebraic Data Type (ADT).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个`sealed`特质扩展的case类/对象家族的构造通常被称为代数数据类型（ADT）。
- en: 'This term comes to us from the HOPE language (1972, Edinburg University), where
    all types can be created from an initial set of types with the help of algebraic
    operations: among them was a named `product` (which looks like a case class in
    Scala) and `distinct union` (modeled by the sealed trait with subtyping).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语来自1972年的HOPE语言（爱丁堡大学），在那里所有类型都可以通过代数运算从一个初始类型集合中创建：其中之一是一个命名的`product`（在Scala中看起来像case类）和`distinct
    union`（由密封特质和子类型建模）。
- en: Using ADT in domain modeling is rewarding because we can do evident case analysis
    for the domain model and have no weak abstraction; we can implement various designs
    which can be added to our model in the future.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域建模中使用ADT是有益的，因为我们可以对领域模型进行明显的用例分析，并且没有弱抽象；我们可以实现各种设计，这些设计可以在未来的模型中添加。
- en: Returning to our `ChatbotMode`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`ChatbotMode`。
- en: On `bye`, we must exit the program.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bye`时，我们必须退出程序。
- en: 'This is easy—just define the appropriative object:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单——只需定义适当的对象：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we'll look at creating the same modes for the `CurrentTime` query.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看为`CurrentTime`查询创建相同的模式。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this exercise can be found in `Lesson 2/3-project`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码可以在`Lesson 2/3-project`中找到。
- en: Create a new file in the `CurrentTime` modes package.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CurrentTime`模式包中创建一个新文件。
- en: Add one to the chain of modes in `Main` (for example, the Modify definition
    of `createInitMode`).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`中的模式链中添加一个（例如，`createInitMode`的Modify定义）。
- en: Make sure that `test`, which checks the time functionality, is passed.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过时间功能检查的`test`通过。
- en: 'The next step is to make a bigger mode from a few simpler modes. Let''s look
    at the mode, which extends two modes and can select a mode which is able to process
    incoming messages:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从几个更简单的模式中创建一个更大的模式。让我们看看这个扩展了两个模式并可以选择能够处理传入消息的模式：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, if `frs` can process a message, then the result of processing this is
    returned. It will contain an answer. `NextMode` (which will accept the next sequence)
    is the same `or` with `nextMode` from `frs,` processing the result and `snd`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`frs`可以处理一条消息，那么处理这条消息的结果将被返回。它将包含一个答案。`NextMode`（它将接受下一个序列）与`frs`中的`nextMode`相同，处理结果和`snd`。
- en: If `frs` can't answer this, then we try `snd`. If `snd's` processing is successful,
    then, in the next dialog step, the first message processor will be a `nextStep`,
    received from `snd`. This allows modes to form their own context of the dialog,
    like a person who understands your language. This will be the first thing you
    will ask next time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`frs`不能回答这个问题，那么我们尝试`snd`。如果`snd's`处理成功，那么，在下一个对话步骤中，第一个消息处理器将是一个`nextStep`，来自`snd`。这允许模式形成自己的对话上下文，就像一个理解你语言的人。这将是下次你问的第一个问题。
- en: 'We can chain simple modes into complex ones with the help of such combinators.
    Scala allows us to use fancy syntax for chains: any method with one parameter
    can be used as a binary operator. So, if we define the `or` method in `ChatbotMode`,
    we will be able to combine our modes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这样的组合子将简单的模式链接成复杂的模式。Scala允许我们使用花哨的语法进行链式调用：任何只有一个参数的方法都可以用作二元运算符。所以，如果我们定义`ChatbotMode`中的`or`方法，我们就能组合我们的模式：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And later in `main`, we can write this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`main`中，我们可以写这个：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Otherwise` looks very similar, with one difference: the second mode must always
    be second.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Otherwise`看起来非常相似，只有一个区别：第二个模式必须始终是第二个。'
- en: When we write one, it looks like this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写一个时，它看起来像这样。
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can make this a little better: let''s move first the interaction (where
    the program asks the user for their name) to mode.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使其更好：让我们首先将交互（程序询问用户姓名的地方）移动到模式。
- en: Now, we'll move the frst interaction to mode.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将第一个交互移动到模式
- en: Here, we will make `mode`, which remembers your name and can make one for you.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将创建一个`mode`，它记得你的名字并为你创建一个。
- en: 'Define a new object, which implements the `chatbot` trait and when running
    the first words, `my name is`, accepts a name and answers `hi`, and then tells
    you your name:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的对象，它实现了`chatbot`特质，当运行第一个单词`my name is`时，接受一个名字并回答`hi`，然后告诉你你的名字：
- en: '[PRE38]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Add this object to the sequence of nodes in `main:`
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此对象添加到`main:`节点序列中
- en: '[PRE39]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a test with this functionality to testcase. Notice the usage of custom
    effects:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向testcase添加一个具有此功能的测试，注意自定义效果的使用：
- en: Note
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For full code, refer to `Code Snippets/Lesson 2.scala` file.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于完整的代码，请参阅`Code Snippets/Lesson 2.scala`文件。
- en: '[PRE40]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Function Calls
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数调用
- en: Now, we'll look at how function calls are implemented in Scala.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何在Scala中实现函数调用。
- en: Syntax Goodies
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法小技巧
- en: Scala provides flexible syntax and it is worth dedicating a few minutes to this
    concept.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Scala提供了灵活的语法，值得花几分钟时间了解这个概念。
- en: Named Parameters
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'The following is a function, `f(a:Int, b:Int)`. We can call this function using
    the named parameter syntax: `f(a = 5, b=10)`. If we swap the parameters but leave
    the correct names, the method will still be correct.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个函数，`f(a:Int, b:Int)`。我们可以使用命名参数语法调用此函数：`f(a = 5, b=10)`。如果我们交换参数但保留正确的名称，方法仍然正确。
- en: It is possible to combine positional and named function calls—the first few
    arguments can be positional.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可以组合位置和命名函数调用——前几个参数可以是位置的。
- en: 'For example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Default Parameters
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'When specifying a function, we can set default parameters. Then, later, when
    we call this function, we can omit parameters and the compiler will substitute
    defaults:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定一个函数时，我们可以设置默认参数。然后，稍后当我们调用此函数时，我们可以省略参数，编译器将使用默认值：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It is possible to create a comfortable API with the help of the combination
    of named and default arguments. For example, for case classes with N components,
    the compiler generates a copy method with N arguments; all of them have defaults:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能通过命名和默认参数的组合创建一个舒适的API。例如，对于具有N个组件的案例类，编译器生成一个具有N个参数的复制方法；所有这些都有默认值：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, let's transform code in the `Or` and `Otherwise` combinators to use the
    `copy` method instead of the `Processed` constructor.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`Or`和`Otherwise`组合器中的代码转换为使用`copy`方法而不是`Processed`构造函数。
- en: Change the case expression to type, checking `(processed:Processed)` or adding
    the `bind` variable to the case class pattern (`processed@Processed(… )`)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将情况表达式更改为类型，检查`(processed:Processed)`或向情况类模式添加`bind`变量（`processed@Processed(…
    )`）
- en: 'In the case body, use the `copy` method instead of the `Processed` constructor:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在情况体中，使用`copy`方法而不是`Processed`构造函数：
- en: 'The resulting code should be as per the following cases:'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的代码应如下所示：
- en: 'If the student uses type check in the case expression:'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果学生在情况表达式中使用类型检查：
- en: '[PRE44]'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the student uses bind variable:'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果学生使用绑定变量：
- en: '[PRE45]'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Do the same transformation for the second match statement.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对第二个匹配语句做同样的转换。
- en: 'The full code looks like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码如下所示：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Currying Forms (Multiple Argument Lists)
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 柯里化形式（多个参数列表）
- en: Currying is a term used for describing the transformation of a function with
    multiple arguments into a function with one argument. We will describe this process
    in detail in the next chapter.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是一个用于描述将多个参数的函数转换为单个参数的函数的术语。我们将在下一章详细描述这个过程。
- en: 'It is vital for syntax that we can use multiple argument lists:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于语法，我们可以使用多个参数列表非常重要：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, `f2` is in its curried form. It has the same semantics as `f1`, but can
    be called with a different syntax. This is useful when you need visually separate
    arguments.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`f2`是它的柯里化形式。它与`f1`具有相同的语义，但可以以不同的语法调用。这在需要视觉上分离参数时很有用。
- en: Special Magic Methods
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊魔法方法
- en: 'The following table shows the various magic methods:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了各种魔法方法：
- en: '| x.apply(y,z) | x(y,z) |   |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| x.apply(y,z) | x(y,z) |   |'
- en: '| x.update(y,z) | x(y)=z |   |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| x.update(y,z) | x(y)=z |   |'
- en: '| x.y_=(z) | x.y=z | Method y must be also defined. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| x.y_=(z) | x.y=z | 方法y也必须被定义。|'
- en: '| x.unary- | -x | The same for +, ~, ! |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| x.unary- | -x | 同样适用于 +, ~, ! |'
- en: '| x = x + y | x += y | The same for -,*,/,&#124;,& |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| x = x + y | x += y | 同样适用于 -,*,/,&#124;,& |'
- en: Implementing + in CartesianPoint
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`CartesianPoint`中实现`+`
- en: Open the previous project from `Lesson2` and implement `+` in `CartesianPoint`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Lesson2`打开之前的项目并实现`CartesianPoint`中的`+`。
- en: In your IDE, open the previous project (4-project, named `coordinates`).
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的IDE中，打开之前的项目（4-project，命名为`coordinates`）。
- en: 'In the `CartesianPoint.scala` file, add the `+` method with the following definition:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CartesianPoint.scala`文件中，添加以下定义的`+`方法：
- en: '[PRE48]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Parameter-Passing Mode
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数传递模式
- en: 'In this section, we will learn the types of parameters which are in passing
    mode: `by value`, `by name,` and `by need`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习参数传递模式中的参数类型：`by value`、`by name`和`by need`。
- en: By Value
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过值
- en: 'In previous chapters, we used default the parameters of passing mode: `by value`,
    which is the default in most programming languages.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了默认的参数传递模式：`by value`，这是大多数编程语言的默认模式。
- en: 'In this model, the function call expression is evaluated in the following manner:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，函数调用表达式以以下方式评估：
- en: First, all arguments are evaluated from left to right
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，所有参数都从左到右进行评估
- en: 'Then, the function is called, and parameters are referred to as evaluated arguments:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，函数被调用，参数被引用为评估过的参数：
- en: '[PRE49]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Sometimes, we hear about Java parameter mode, where values are passed `by value`,
    and references are `by reference` (for example, if we pass `reference` to an object
    as a `value`)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，我们听说Java参数模式，其中值通过`by value`传递，引用通过`by reference`（例如，如果我们把`reference`作为一个`value`传递给对象）
- en: By Name
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过名称
- en: 'The essence of the `by name` parameter passing mode is that arguments are not
    evaluated before the function call, but every time the name of the parameter is
    used in the target function:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`by name`参数传递模式的核心是参数在函数调用之前不会被评估，而是在目标函数中每次使用参数名称时：'
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The name term comes to us from Algol68: passing parameters by name was described
    as a substitution of name by the parameter body. This was a challenge for compiler
    writers for many years.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 名称术语来自Algol68：通过名称传递参数被描述为用参数体替换名称。这对编译器编写者来说是一个多年的挑战。
- en: 'By name parameters can be used for defining control-flow expressions:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称参数可以用于定义控制流表达式：
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that constructor parameters can also be passed by name:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构造函数参数也可以通过名称传递：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: By Need
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过需要
- en: '`By` `need` evaluates the parameter once, only if it is necessary. This can
    be emulated with the by name call and lazy val:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`By need`仅在必要时评估参数一次。这可以通过`by name`调用和懒`val`来模拟：'
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We see the lazy modifier for val. A lazy value is evaluated at the time of the
    first usage and then stored in memory as a value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`val`的懒修饰符。懒值在第一次使用时进行评估，然后作为值存储在内存中。
- en: 'Lazy values can be components of traits, classes, and objects: this is this
    usual way to define lazy initialization.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 懒值可以是特质、类和对象的组成部分：这是定义懒初始化的常用方式。
- en: Creating a Runnable Construction
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可运行的构造
- en: Let's create a runnable construction, with the same syntax as `Scalatest FunSuite`,
    and `executor`, which will return `true`, if the code inside the `test` argument
    was evaluated without exceptions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可运行的构造，其语法与`Scalatest FunSuite`相同，并且`executor`将返回`true`，如果`test`参数内的代码评估没有异常。
- en: 'Define the parent class with variables where the code will be captured. One
    possible example is as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个父类，其中包含将要捕获代码的变量。以下是一个可能的示例：
- en: '[PRE54]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define the function with the name and by-name parameter, which will fill this
    variable:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名称和按名称参数定义函数，该函数将填充此变量：
- en: '[PRE55]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Define `executor` method, which uses named parameter inside try/catch block.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`executor`方法，该方法在try/catch块中使用命名参数。
- en: '[PRE56]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Printing the log Argument to the Console and File
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志参数打印到控制台和文件
- en: Let's create a `log` statement, which prints arguments to the console and to
    file, but only if the parameter with the name enabled in the logger constructor
    is set to true.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`log`语句，该语句将参数打印到控制台和文件，但仅当在记录器构造函数中设置名为`enabled`的参数为true时。
- en: 'Define the `logger` with the parameter and class. The signature must be something
    like this:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数和类定义`logger`。签名必须类似于以下这样：
- en: '[PRE57]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define the method with the by-need parameter, which is only used when the logger
    is enabled:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用按需参数定义方法，该参数仅在启用记录器时使用：
- en: '[PRE58]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let's make `mode` command, which understands the `store name` definition and
    `remind` definition.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`mode`命令，该命令理解`store name`定义和`remind`定义。
- en: Define a new object which implements the `ChatbotMode` trait and has a data
    structure (a sealed trait which forms a linked list) as a state.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的对象，该对象实现了`ChatbotMode`特质，并具有数据结构（一个形成链表的密封特质）作为状态。
- en: On the processing `store,` modify the state and answer `ok.` On processing,
    `remind` – answer.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理`store`时，修改状态并回答`ok.` 在处理时，`remind` – 回答。
- en: Add test to `testcase.`
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`testcase.`添加测试
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have now reached the end of this chapter. In this chapter, we covered the
    object-oriented aspects of Scala such as classes, objects, pattern matching, self-types,
    case classes, and so on. We also implemented object-oriented concepts that we
    learned in our chatbot application.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了本章的结尾。在本章中，我们涵盖了Scala的面向对象方面，如类、对象、模式匹配、自类型、案例类等。我们还实现了我们在聊天机器人应用程序中学到的面向对象概念。
- en: In the next chapter, we will cover functional programming with Scala and how
    object-oriented and functional approaches complete each other. We will also cover
    generic classes, which are often used with pattern matching. We will also cover
    how to create user-defined pattern matching and why is it useful.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Scala的函数式编程以及面向对象和函数式方法如何相互补充。我们还将介绍泛型类，这些类通常与模式匹配一起使用。我们还将介绍如何创建用户定义的模式匹配以及为什么它是有用的。
