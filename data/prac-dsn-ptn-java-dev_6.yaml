- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Concurrency Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发设计模式
- en: Previous chapters on creational, structural, and behavioral patterns proposed
    a design that concerns the base code. Their main focus was on the maintainable
    base code that operates in the main single application thread. In other words,
    the generated byte code is executed in a defined sequence to achieve the desired
    results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节在创建型、结构型和行为型模式中提出的设计关注基代码。它们的主要焦点是可维护的基代码，该代码在主单应用程序线程中运行。换句话说，生成的字节码按照定义的顺序执行，以实现预期的结果。
- en: Nowadays, business requirements have shifted the application expectations described
    by the GoF’s book over the years more and more within a concurrent and parallel
    world. This has been succeeded by a massive improvement in hardware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着硬件的巨大改进，业务需求已经将GoF书籍描述的应用程序期望在多年的并发和并行世界中越来越多地转移。这已经通过硬件的巨大改进而实现。
- en: 'The Java platform provides concurrency functionality under the hood from the
    very beginning. The Flight Recorder tool of Mission Control set helps collect
    data points about thread behavior and displays them visually, improving our awareness
    of application dynamics. In this chapter, we are going to examine some of the
    most common scenarios in the information technology industry:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台从一开始就在底层提供了并发功能。任务控制器的Flight Recorder工具帮助收集有关线程行为的数据点，并以可视化的方式显示它们，提高我们对应用程序动态的认识。在本章中，我们将检查信息技术行业中最常见的场景：
- en: Decoupling a method execution with an active object pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用活动对象模式解耦方法执行
- en: Non-blocking tasks using an async method invocation pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步方法调用模式进行非阻塞任务
- en: Delaying execution until the previous task has been completed with the balking
    pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用balking模式延迟执行直到前一个任务完成
- en: Providing a unique object instance with a double-checked locking pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双重检查锁定模式提供唯一的对象实例
- en: Using purposeful thread blocking via a read-write lock pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过读写锁模式有目的地进行线程阻塞
- en: Decoupling the execution logic with the producer-consumer pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生产者-消费者模式解耦执行逻辑
- en: Executing isolated tasks with the scheduler pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调度器模式执行隔离的任务
- en: Effective thread utilization with the thread-pool pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程池模式有效利用线程
- en: By the end of this chapter, we will have built a solid foundation for understanding
    the concurrency possibilities of the Java platform and starting to apply them
    effectively.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将为理解Java平台的并发可能性并开始有效地应用它们建立一个坚实的基础。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件：[https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06)。
- en: Decoupling a method execution with an active object pattern
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用活动对象模式解耦方法执行
- en: The active object design pattern separates and defers method execution from
    method invocation by running its own control thread.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 活动对象设计模式通过运行自己的控制线程来分离和延迟方法执行与方法调用。
- en: Motivation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The active object pattern introduces a transparently concurrent model to the
    application. It creates and starts an internal thread that executes the required
    logical, critical section. An active object instance exposes a public interface
    that a client can use to run an encapsulated critical section. An external, client-initiated
    event is queued and ready to execute. The execution step is performed by the internal
    scheduler. The result can be passed to the appropriate handler in a callback style.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 活动对象模式向应用程序引入了一个透明并发模型。它创建并启动一个内部线程来执行所需的逻辑，临界区。一个活动对象实例公开一个公共接口，客户端可以使用它来运行封装的临界区。一个外部、由客户端发起的事件被排队并准备执行。执行步骤由内部调度器执行。结果可以通过回调风格传递给适当的处理程序。
- en: Sample code
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us introduce an example of a moving vehicle with a radio system (*Example
    6.1*):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一个带有无线电系统的移动车辆示例（*示例6.1*）：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s the output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 6.1 – The SportVehicle instance allows the client to create an event
    by using its public methods
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.1 – SportVehicle实例允许客户端通过其公共方法创建事件
- en: 'The newly created abstract class, `MovingVehicle`, defines public methods –
    `move`, `turnOnRadio`, `turnOffRadio`, and `stopVehicle`. In addition to the control
    thread, the class defines a conditional queue for incoming events (*Example 6.2*):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的抽象类`MovingVehicle`定义了公共方法 – `move`、`turnOnRadio`、`turnOffRadio`和`stopVehicle`。除了控制线程外，该类还定义了一个用于接收事件的条件队列（*示例
    6.2*）：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 6.2 – MovingVehicle contains an active flag for purpose of scheduling
    events
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.2 – MovingVehicle包含一个用于调度事件的主动标志
- en: 'Events in the queue are received and fired based on an internal period. `LinkedBlockingDeque`
    provides additional functions for inserting or removing elements from the top
    or bottom, which is useful when the vehicle needs to be stopped. The `StopVehicle`
    event has priority over the radios (*Example 6.3*):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的事件根据内部周期接收和触发。`LinkedBlockingDeque`提供了从顶部或底部插入或删除元素的功能，这在车辆需要停止时很有用。`StopVehicle`事件比收音机有优先级（*示例
    6.3*）：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 6.3 – The received events are added to the queue conditionally
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.3 – 条件性地将接收的事件添加到队列中
- en: 'A lifecycle of the `SportVehicle` instance does not interfere with the main
    application thread. It is predictable and does not block the application (*Figure
    6**.1*):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`SportVehicle`实例的生命周期不会干扰主应用程序线程。它是可预测的，并且不会阻塞应用程序（*图 6**.1*）：'
- en: '![Figure 6.1 – The moving-vehicle thread shows the sequence of commands](img/B18884_06_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 移动车辆线程显示了命令的顺序](img/B18884_06_01.jpg)'
- en: Figure 6.1 – The moving-vehicle thread shows the sequence of commands
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 移动车辆线程显示了命令的顺序
- en: 'The components introduced in the example seamlessly cooperate (*Figure 6**.2*):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中引入的组件无缝协作（*图 6**.2*）：
- en: '![Figure 6.2 – The UML class diagram shows the SportVehicle class’s relation
    to the Java concurrency features](img/B18884_06_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – UML类图显示了SportVehicle类与Java并发特性的关系](img/B18884_06_02.jpg)'
- en: Figure 6.2 – The UML class diagram shows the SportVehicle class’s relation to
    the Java concurrency features
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – UML类图显示了SportVehicle类与Java并发特性的关系
- en: Conclusion
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: A well-developed active object pattern respects the SOLID design approaches
    because it encapsulates the critical parts and only exposes the control interface
    required. The instance does not interfere with the application and the whole approach
    can be generalized to the desired level. An active object can be a good candidate
    for introducing a concurrency model into an application, but there are a few challenges
    to keep in mind. One of these challenges is the number of possible application
    threads, where a high number can make the application fragile or lead to instability
    as it depends on available resources.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好发展的主动对象模式尊重SOLID设计方法，因为它封装了关键部分，并且只暴露所需的控制接口。实例不会干扰应用程序，整个方法可以推广到期望的级别。主动对象可以是一个将并发模型引入应用程序的好候选者，但有一些挑战需要记住。其中之一是可能的应用程序线程数量，大量线程可能会使应用程序变得脆弱或导致不稳定，因为它依赖于可用资源。
- en: Let’s explore the asynchronous nature of events in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中探索事件的异步特性。
- en: Non-blocking tasks using async method invocation pattern
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步方法调用模式的无阻塞任务
- en: The asynchronous method invocation pattern is a way to solve the challenge of
    not penalizing the main process thread with possibly time-consuming tasks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法调用模式是一种解决不惩罚主进程线程可能耗时任务的方法。
- en: Motivation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Asynchronous method invocation patterns introduce the ability to receive a result
    by a callback from an asynchronously running task without blocking the main process
    thread. The pattern presents the threading model and level of parallelism for
    processing the required task types. The task results are processed by dedicated
    callback handlers and provided to the main process regardless of the task’s execution
    time. These handlers may already belong to the main process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法调用模式引入了通过回调从异步运行的任务接收结果的能力，而不会阻塞主进程线程。该模式展示了处理所需任务类型的线程模型和并行级别。任务结果由专门的回调处理程序处理，并无论任务执行时间如何，都提供给主进程。这些处理程序可能已经属于主进程。
- en: Sample code
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us look at a trivial scenario of several vehicle temperature sensors required
    to provide results to the driver, which is the client (*Example 6.4*):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个车辆温度传感器的简单场景，这些传感器需要向驾驶员提供结果，即客户端（*示例 6.4*）：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 6.4 – The example task temp:26, is asynchronously executed in thread-0
    thread
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.4 – 示例任务 temp:26 在线程-0 线程中异步执行
- en: 'The instance of `TempSensorCallback` that monitors all results resides in the
    `main` process thread (*Figure 6**.3*):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 监控所有结果的 `TempSensorCallback` 实例位于 `main` 进程线程中（*图 6**.3*）：
- en: '![Figure 6.3 - TemperatoreSensorCallback instance is called asynchronously,
    therefore different thread finish times](img/B18884_06_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 - 温度传感器回调实例异步调用，因此不同线程的完成时间不同](img/B18884_06_03.jpg)'
- en: Figure 6.3 - TemperatoreSensorCallback instance is called asynchronously, therefore
    different thread finish times
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 - 温度传感器回调实例异步调用，因此不同线程的完成时间不同
- en: '`TempSensorTask` instances are handled by custom `TempSensorExecutor` instances,
    which not only provides control over initiated threads, but can also terminate
    long-running measurements of a particular sensor by providing a task reference.
    The `TempSensorExecutor` instance exposes a measure public method that provides
    a `TempSensorResult` instance of a long-running task (*Example 6.5*):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`TempSensorTask` 实例由自定义的 `TempSensorExecutor` 实例处理，它不仅提供了对启动线程的控制，还可以通过提供任务引用来终止特定传感器的长时间运行测量。`TempSensorExecutor`
    实例公开了一个测量公共方法，该方法提供了一个长时间运行任务的 `TempSensorResult` 实例（*示例 6.5*）：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 6.5 – Each new thread specific long-term measurement will pass its result
    to the callback handler
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.5 – 每个新的特定于线程的长期测量都会将结果传递给回调处理程序
- en: 'The nature of processing the information served by multiple temperature sensors
    is clearly parallel. The asynchronous method invocation patterns provide a very
    small set of classes to solve this challenge (*Figure 6**.4*):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理由多个温度传感器提供的信息的性质显然是并行的。异步方法调用模式提供了一组非常小的类来解决这个挑战（*图 6**.4*）：
- en: '![Figure 6.4 – The UML class diagram draws how data are acquired from temperature
    sensors](img/B18884_06_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – UML 类图展示了如何从温度传感器获取数据](img/B18884_06_04.jpg)'
- en: Figure 6.4 – The UML class diagram draws how data are acquired from temperature
    sensors
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – UML 类图展示了如何从温度传感器获取数据
- en: Conclusion
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The given examples clearly show how to handle a long-running task with a preliminary
    detachment from the main processing thread. In other words, it is not causing
    by delas. The Java platform provides multiple options to create this pattern.
    One of them is to employ the `Callable` interface and send an instance to the
    `ExecutorService` using its `submit` method. The `submit` method returns a result
    that implements the `Future` interface. The `Future` has similarities to the sample
    `TempSensorResult` instance but does not provide a callback function that needs
    to be handled differently. Another possibility can be explored using `CompletableFuture`,
    which not only exposes the `supplyAsync` method, but also provides many other
    useful functions. All of the suggestions mentioned can be found in the `java.base`
    module and the `java.util.concurren`t package.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 给出的示例清楚地说明了如何通过初步与主处理线程分离来处理长时间运行的任务。换句话说，这不是由延迟引起的。Java 平台提供了多种选项来创建这种模式。其中之一是使用
    `Callable` 接口，并通过其 `submit` 方法将实例发送到 `ExecutorService`。`submit` 方法返回一个实现 `Future`
    接口的结果。`Future` 与示例 `TempSensorResult` 实例有相似之处，但不提供需要不同处理的回调函数。另一种可能性是使用 `CompletableFuture`，它不仅公开了
    `supplyAsync` 方法，还提供了许多其他有用的函数。所有提到的建议都可以在 `java.base` 模块和 `java.util.concurrent`
    包中找到。
- en: The next section shows how to delay the execution of a task until the previous
    one is complete; let’s get to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何延迟任务的执行，直到前一个任务完成；让我们开始吧。
- en: Delay execution until the previous task is completed with the balking pattern
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 balking 模式延迟执行直到前一个任务完成
- en: Sometimes it is required to consider the task state changes to properly execute
    next task and fulfill the goal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要考虑任务状态的变化，以便正确执行下一个任务并实现目标。
- en: Motivation
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Although the instance mutability is not a desirable state, especially not in
    the concurrency field the ability to depend on the object state may come handy.
    The case where multiple threads try to acquire an object to execute its critical
    sections can be limited by the object state. The state can decide whether the
    processing time will be used or not in order to coordinate the resources available.
    For example, a vehicle cannot stop without being in motion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管实例的可变性不是一个理想的状态，特别是在并发领域，但依赖对象状态的能力可能会很有用。当多个线程试图获取一个对象以执行其临界区时，可以通过对象状态来限制这种情况。状态可以决定是否使用处理时间来协调可用的资源。例如，一辆车在没有运动的情况下不能停止。
- en: Sample code
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'Consider the example of one `Vehicle` instance sharing two groups of drivers.
    Although there are multiple groups, only one vehicle can operate at a time (*Example
    6.6*):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`Vehicle`实例共享两组驾驶员的例子。尽管有多个小组，但一次只能有一辆车运行（**示例6.6**）：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s the output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 6.6 – Driver groups are represented by provided threads created by ExecutorService
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.6 – 驾驶员小组由ExecutorService提供的线程表示
- en: 'The balking pattern provides a solution in which the critical section of the
    task is executed based on the `Vehicle` instance state represented by the `VehicleState`
    enum (*Example 6.7*):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 双重检查锁定模式提供了一种解决方案，其中任务的临界区基于由`VehicleState`枚举表示的`Vehicle`实例状态执行（**示例6.7**）：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 6.7 – The usage of the synchronized keyword makes the driver groups
    aware of whether the Vehicle instance is ready to use or not
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.7 – 使用synchronized关键字使驾驶员小组知道车辆实例是否准备好使用
- en: 'The driver group threads are blocked and only one is active at a time (*Figure
    6**.5*):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶员小组线程被阻塞，每次只有一个线程处于活动状态（**图6.5**）：
- en: '![Figure 6.5 – The blue and green colors represent group activity while the
    other is blocked](img/B18884_06_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 蓝色和绿色代表小组活动，而其他部分被阻塞](img/B18884_06_05.jpg)'
- en: Figure 6.5 – The blue and green colors represent group activity while the other
    is blocked
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 蓝色和绿色代表小组活动，而其他部分被阻塞
- en: 'The example presented requires a very minimal number of created classes, which
    are clearly encapsulated (*Figure 6**.6*):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供的示例需要创建非常少的类，这些类被清晰地封装（**图6.6**）：
- en: '![Figure 6.6 – The UML class diagram shows the two most required custom classes,
    Vehicle and VehicleState](img/B18884_06_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – UML类图显示了两个最需要的自定义类，Vehicle和VehicleState](img/B18884_06_06.jpg)'
- en: Figure 6.6 – The UML class diagram shows the two most required custom classes,
    Vehicle and VehicleState
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – UML类图显示了两个最需要的自定义类，Vehicle和VehicleState
- en: Conclusion
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The balking pattern is easy to implement in the Java platform. It is important
    to keep the Java memory model in mind in order to properly handle object state
    volatility. It may be particularly useful to consider using atomic types (`AtomicInteger`
    and `AtomicBoolean`, for example), which automatically come with a happens-before
    guarantee. This guarantee is part of the Java memory model to maintain memory
    consistency across the interacting threads, as we learned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*. Another option to consider
    is the `volatile` keyword, which comes with a guarantee of equal-value visibility
    across threads.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java平台上实现双重检查锁定模式很简单。为了正确处理对象状态的不确定性，需要牢记Java内存模型。考虑使用原子类型（例如`AtomicInteger`和`AtomicBoolean`），这些类型自动带有happens-before保证。这种保证是Java内存模型的一部分，用于在交互线程之间保持内存一致性，正如我们在[*第2章*](B18884_02.xhtml#_idTextAnchor037)中学习的，*探索Java平台以设计模式*。另一个可以考虑的选项是`volatile`关键字，它提供了线程间等值可见性的保证。
- en: The next section examines guaranteed instance uniqueness – let’s roll.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将检查保证实例的唯一性 – 让我们开始吧。
- en: Providing a unique object instance with a double-checked locking pattern
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供一个具有双重检查锁定模式的独特对象实例
- en: The double-checked locking pattern solves the problem of an application requiring
    only one instance of a particular class at runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 双重检查锁定模式解决了在运行时应用程序只需要特定类的一个实例的问题。
- en: Motivation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The Java platform is multi-threaded by default, as we learned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*. It’s not just the garbage
    collection threads that take care of the main program lifecycle. Different frameworks
    introduce additional tread models, which may have an unintended impact on a class
    institution’s process. A double-checked locking pattern ensures that only one
    instance of a class is present at runtime. This state can become challenging in
    a multi-threaded environment, as it may depend on its implementation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台默认是多线程的，正如我们在[*第2章*](B18884_02.xhtml#_idTextAnchor037)中学习的，*发现Java平台的设计模式*。不仅仅是垃圾收集线程负责主程序的生命周期。不同的框架引入了额外的线程模型，这可能会对类机构的进程产生意想不到的影响。双重检查锁定模式确保在运行时只有一个类的实例。在多线程环境中，这种状态可能变得具有挑战性，因为它可能取决于其实现。
- en: Sample code
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let’s use a simple `Vehicle` instance to demonstrate the importance of a double-checked
    locking pattern in a multithreading environment. The example presents two different
    implementations of the singleton pattern. `VehicleSingleton` is expected to keep
    its promise due to multiple threads accessing the `getInstance` method (*Example
    6.8*):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的`Vehicle`实例来演示在多线程环境中双重检查锁定模式的重要性。示例展示了单例模式的两种不同实现。`VehicleSingleton`由于多个线程访问`getInstance`方法而期望保持其承诺（*示例6.8*）：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example 6.8 – The VehicleSingleton constructor has been called multiple times,
    which violates the given promise through multiple instantiations (see the hashCode
    values)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.8 – VehicleSingleton构造函数已被多次调用，这通过多次实例化违反了给定的承诺（参见hashCode值）
- en: 'The `ExecutorService` instance provided by `Executors.newFixedThreadPool` receives
    multiple instances of the `Runnable` interface. The `Runnable` method’s implementation
    represents the critical section of the `getInstance` method’s call in both cases
    (*Figure 5**.5*):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executors.newFixedThreadPool`提供的`ExecutorService`实例接收多个`Runnable`接口的实例。`Runnable`方法的实现代表了两种情况下`getInstance`方法调用的临界区（*图5.5*）：'
- en: "![Figure 6.7 – All pool threads continuously execute the getInstance method\
    \ and VehicleSingletonCheck i\uFEFFs cre\uFEFFated only once](img/B18884_06_07.jpg)"
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 所有池线程持续执行getInstance方法，而VehicleSingletonCheck只被创建一次](img/B18884_06_07.jpg)'
- en: Figure 6.7 – All pool threads continuously execute the getInstance method and
    VehicleSingletonCheck is created only once
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 所有池线程持续执行getInstance方法，而VehicleSingletonCheck只被创建一次
- en: 'Both implementations differ in the very small details of the `getInstance`
    method implementation (*Example 6.9*):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现方式在`getInstance`方法实现的非常小的细节上有所不同（*示例6.9*）：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 6.9 – The getInstance method’s implementation of VehicleSingletonChecked
    uses a synchronized keyword to ensure the thread stack frame state
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.9 – VehicleSingletonChecked的getInstance方法的实现使用synchronized关键字来确保线程栈帧状态
- en: 'In both cases, the UML diagram remains the same (*Figure 6**.8*):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，UML图保持不变（*图6.8*）：
- en: '![Figure 6.8 – The UML class diagram does not highlight the implementation
    details of the double-checked singleton pattern](img/B18884_06_08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – UML类图没有突出显示双重检查单例模式的实现细节](img/B18884_06_08.jpg)'
- en: Figure 6.8 – The UML class diagram does not highlight the implementation details
    of the double-checked singleton pattern
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – UML类图没有突出显示双重检查单例模式的实现细节
- en: Conclusion
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: This example has shown a possible way to implement a double-check locking pattern.
    The Java platform may also enforce double-checked locking patterns by using an
    `Enum` construct, which provides only one element – its `INSTANCE` object of desired
    type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一种实现双重检查锁定模式的方法。Java平台也可以通过使用`Enum`构造来强制执行双重检查锁定模式，它只提供一个元素 – 它的`INSTANCE`对象，这是期望的类型。
- en: The next section demonstrates how to deal with locking exclusivity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将演示如何处理锁定独占性。
- en: Using purposeful thread blocking via a read-write lock pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过读写锁模式使用有目的的线程阻塞
- en: A concurrent application may consider granting exclusive access to a critical
    section just to update the information of the specific instance. This particular
    challenge can be solved by using a read-write lock pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序可能会考虑仅为了更新特定实例的信息而授予临界区独占访问权限。这个特定的挑战可以通过使用读写锁模式来解决。
- en: Motivation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The read-write locking pattern introduces natural exclusivity for lock acquisition.
    This context is used to differentiate the whether the critical section can be
    executed. In other words, the write action takes precedence by its nature before
    reading, as the goal of any reader is to get the most accurate and up-to-date
    value possible. Under the hood, this means that all readers are blocked when the
    writer thread is modifying data and unblocked when the writer completes its task.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 读写锁模式引入了锁获取的自然排他性。此上下文用于区分是否可以执行临界区。换句话说，由于任何读者的目标都是获取尽可能准确和最新的值，因此写入操作在本质上优先于读取操作。在底层，这意味着当写入线程修改数据时，所有读者都会被阻塞，而当写入线程完成任务时，读者会被解除阻塞。
- en: Sample code
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'Suppose that multiple sensors inside a vehicle require accurate information
    about the temperature value, but there is only one temperature device capable
    of updating the temperature value (*Example 6.10*):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设车辆内部有多个传感器需要关于温度值的准确信息，但只有一个能够更新温度值的温度设备（*示例6.10*）：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s the output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 6.10 – The SensorWriter instance that runs its own thread obtains exclusive
    access to the Sensor instance
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.10 – 运行其自身线程的`SensorWriter`实例获得对`Sensor`实例的独占访问
- en: 'Readers continuously read the sensor value without being blocked. The situation
    changes when the writer enters the game – at which point, readers are blocked
    and have to wait for the `SensorWriter` instance to finish (*Figure 6**.9*):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 读取器可以连续读取传感器值而不会被阻塞。当写入者介入时，情况发生了变化 – 此时，读取者会被阻塞并必须等待`SensorWriter`实例完成（*图6**.9*）：
- en: '![Figure 6.9 – Thread activity highlighting writer lock exclusivity when reader
    threads are being blocked](img/B18884_06_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 突出显示当读取线程被阻塞时写入锁排他性的线程活动](img/B18884_06_09.jpg)'
- en: Figure 6.9 – Thread activity highlighting writer lock exclusivity when reader
    threads are being blocked
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 突出显示当读取线程被阻塞时写入锁排他性的线程活动
- en: 'The critical section is served by two methods, `writeValue` and `readValue`.
    Both belong to the `Sensor` class (*Example 6.11*):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 临界区由两个方法`writeValue`和`readValue`提供服务。这两个方法都属于`Sensor`类（*示例6.11*）：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example 6.11 – readLock is paused when writeLock is acquired
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.11 – 当获取写锁时，读锁被暂停
- en: 'It is important to note that lock instances reside in the main thread of execution
    and are acquired by the threads provided by the `ExecutorService` instance (*Figure
    6**.10*):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，锁实例位于执行的主线程中，并由`ExecutorService`实例提供的线程获取（*图6**.10*）：
- en: '![Figure 6.10 – The UML class diagram for a read-write lock pattern](img/B18884_06_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 读写锁模式的UML类图](img/B18884_06_10.jpg)'
- en: Figure 6.10 – The UML class diagram for a read-write lock pattern
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 读写锁模式的UML类图
- en: Conclusion
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The read-write lock is very powerful and can contribute very positively to the
    stability of the application. It clearly separates the participant from the critical
    section code that drives the logic. Each example class can be generalized or adapted
    according to SOLID design principles upon request.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 读写锁非常强大，并且可以非常积极地促进应用程序的稳定性。它清楚地分离了参与者与驱动逻辑的临界区代码。根据请求，每个示例类都可以根据SOLID设计原则进行泛化或调整。
- en: The JDK defines another approach worth considering for exchanging the sensor
    value. The `java.base` module package, `java.util.concurrent`, contains the `Exchanger`
    class, which provides the required synchronization guarantees.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JDK定义了另一种值得考虑的交换传感器值的方法。`java.base`模块包中的`java.util.concurrent`包含`Exchanger`类，它提供了所需的同步保证。
- en: Let’s examine another common pattern where the instance is broadcasted to the
    target.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察另一个常见的模式，其中实例被广播到目标。
- en: Decoupling the execution logic with a producer-consumer pattern
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生产者-消费者模式解耦执行逻辑
- en: The common industrial scenario represents producing and consuming values without
    blocking the main application thread. The producer-consumer pattern helps to solve
    this challenge by decoupling the logic and separating the lines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的工业场景表示在不会阻塞主应用程序线程的情况下产生和消费值。生产者-消费者模式通过解耦逻辑和分离行来帮助解决这一挑战。
- en: Motivation
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: A common industrial scenario involves producing and consuming values without
    blocking the main execution thread. The producer-consumer pattern is designed
    exactly to rise to the challenge by decoupling the logic and separating the target
    receivers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的工业场景涉及在不阻塞主执行线程的情况下产生和消费值。生产者-消费者模式正是为了应对这一挑战而设计的，通过解耦逻辑并分离目标接收者。
- en: Sample code
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Another scenario is where the vehicle produces multiple events from multiple
    sources and these events need to be broadcasted and delivered to consumers (*Example
    6.12*):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种场景是，车辆从多个来源产生多个事件，这些事件需要被广播并传递给消费者（*示例 6.12*）：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s the output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 6.12 – Compared to producers, consumers are in the minority, not only
    in terms of quantity but also in terms of available resources
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.12 – 与生产者相比，消费者在数量上较少，不仅在数量上，而且在可用资源上
- en: 'Each of the `ExecutorService` instances uses a `ProdConThreadFactory` object
    type to provide meaningful thread names (*Figure 6**.11*):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `ExecutorService` 实例都使用 `ProdConThreadFactory` 对象类型来提供有意义的线程名称（*图 6**.11*）：
- en: '![Figure 6.11 – Consumers are in the minority and sometimes may be blocked
    as the event storage is full](img/B18884_06_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 消费者数量较少，有时可能因为事件存储已满而被阻塞](img/B18884_06_11.jpg)'
- en: Figure 6.11 – Consumers are in the minority and sometimes may be blocked as
    the event storage is full
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 消费者数量较少，有时可能因为事件存储已满而被阻塞
- en: 'The participant classes are decoupled and ready for extension (*Figure 6**.12*):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 参与类是解耦的，并准备好扩展（*图 6**.12*）：
- en: '![Figure 6.12 – The UML class diagram shows how event classes are related to
    the internals of the Java platform](img/B18884_06_12.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – UML 类图显示了事件类与 Java 平台内部的关系](img/B18884_06_12.jpg)'
- en: Figure 6.12 – The UML class diagram shows how event classes are related to the
    internals of the Java platform
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – UML 类图显示了事件类与 Java 平台内部的关系
- en: Conclusion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In the field of distributed systems, the production-consumer approach is widely
    used. It is advantageous for clearly separating and defining groups of event senders
    and receivers. The groups can be placed in different threads according to the
    desired thread model.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统领域，生产者-消费者方法被广泛使用。它有利于清楚地分离和定义事件发送者和接收者组。根据所需的线程模型，这些组可以放置在不同的线程中。
- en: The JDK 19 release comes with the newly added concept of virtual threads. Virtual
    threads attempt to simplify the use of core platform threads by introducing thread-like
    frames, and wrappers. The virtual thread wrappers are scheduled by the JVM to
    run on available platform threads by using newly added executors – for example,
    `Executors.newVirtualThreadPerTaskExecutor`. This approach fulfills the definition
    of the producer-consumer pattern, in which the producer is an application that
    uses new virtual thread executors and the platform consumes scheduled virtual
    threads.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 19 版本带来了新增加的虚拟线程概念。虚拟线程通过引入类似线程的框架和包装器来尝试简化核心平台线程的使用。虚拟线程包装器由 JVM 调度，通过使用新添加的执行器在可用的平台线程上运行，例如，`Executors.newVirtualThreadPerTaskExecutor`。这种方法满足生产者-消费者模式，其中生产者是使用新的虚拟线程执行器应用程序，平台消耗已调度的虚拟线程。
- en: Let’s uncover the scheduler approach in the next section in more detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节更详细地揭示调度器方法。
- en: Executing isolated tasks with the scheduler pattern
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调度器模式执行隔离的任务
- en: An application behaving deterministically can play a critical role in its success.
    A scheduler pattern can help to achieve the desired goal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表现确定性的应用程序在其成功中可以发挥关键作用。调度器模式可以帮助实现预期的目标。
- en: Motivation
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Although schedulers are sometimes poorly designed to keep the application busy,
    their main purpose is important. The importance of using patterns comes to light
    more with microservices or distributed approaches in which the system is required
    to behave predictably. The general goal is to determine when a specific task is
    performed so that the underlying resources are properly used or a budget estimate
    can be created for the required resources described in site reliability engineering.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管调度器有时设计得不好，无法让应用程序保持忙碌，但它们的主要目的是重要的。在需要系统表现出可预测性的微服务或分布式方法中，使用模式的必要性更为明显。一般的目标是确定何时执行特定任务，以便合理地使用底层资源或为在站点可靠性工程中描述的所需资源创建预算估计。
- en: Sample code
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The following example brings us to temperature measurement. Every vehicle contains
    temperature sensors in a mechanical or digital form. Temperature sensors play
    a key role in vehicle operation (*Example 6.13*):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将带我们进入温度测量。每辆车都包含机械或数字形式的温度传感器。温度传感器在车辆运行中起着关键作用（**示例 6.13**）：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Example 6.13 – The CustomScheduler instance executes a SensorTask instance from
    the blocking queue every 100 milliseconds
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.13 – CustomScheduler 实例每隔 100 毫秒从阻塞队列中执行一个 SensorTask 实例
- en: '`CustomerScheduler` shows a trivial implementation that administers the execution
    process (*Figure 6**.14*):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerScheduler` 展示了一个简单的实现，该实现管理执行过程（**图 6.14**）：'
- en: '![Figure 6.13 – Each task execution has a 100 ms time window allocated](img/B18884_06_13.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 每个任务执行都分配了 100 毫秒的时间窗口](img/B18884_06_13.jpg)'
- en: Figure 6.13 – Each task execution has a 100 ms time window allocated
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 每个任务执行都分配了 100 毫秒的时间窗口
- en: 'The scheduler instantiation prepares a thread with an active flag to control
    the lifecycle (*Example 6.14*):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器实例化准备了一个带有活动标志的线程来控制生命周期（**示例 6.14**）：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example 6.14 – CustomScheduler ensures that the time window is maintained
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.14 – CustomScheduler 确保时间窗口得到维护
- en: 'The task of creating a simple scheduler is trivial, but beyond that, it’s good
    to keep in mind the threading model – as in, where and how execution takes place
    (*Figure 6**.14*):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建简单调度器的任务很简单，但除此之外，还要牢记线程模型——即在何处以及如何执行（**图 6.14**）：
- en: '![Figure 6.14 – The UML class diagram highlights the CustomScheduler threading
    model](img/B18884_06_14.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – UML 类图突出了 CustomScheduler 线程模型](img/B18884_06_14.jpg)'
- en: Figure 6.14 – The UML class diagram highlights the CustomScheduler threading
    model
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – UML 类图突出了 CustomScheduler 线程模型
- en: 'In the case of the scheduler pattern, it is only fair to mention the second
    example. The second example uses the built-in JDK functions and their customizations.
    The planning process is fully managed by the platform. The application example
    is, again, similar to the first example, temperature measurement (*Example 6.15*):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在调度模式的情况下，提及第二个示例是公平的。第二个示例使用了内置的 JDK 函数及其定制。规划过程完全由平台管理。应用程序示例再次类似于第一个示例，温度测量（**示例
    6.15**）：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s the output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Example 6.15 – The period is set to 100 ms and the SensorTask instance is reused
    for each iteration
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.15 – 间隔设置为 100 毫秒，SensorTask 实例在每个迭代中重复使用
- en: 'An extended `CustomScheduledThreadPoolExecutor` instance can provide additional
    information based on task execution by overriding an available method such as
    `beforeExecute` or `afterExecute`. Using the JDK internals makes it easy to scale
    a `SensorTask` instance across threads (*Figure 6**.15*):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的 `CustomScheduledThreadPoolExecutor` 实例可以通过覆盖 `beforeExecute` 或 `afterExecute`
    等可用方法提供基于任务执行的信息。使用 JDK 内部机制可以轻松地在线程之间扩展 `SensorTask` 实例（**图 6.15**）：
- en: '![Figure 6.15 – A CustomScheduledThreadPoolExecutor instance facilitates easier
    thread management and easier management of other JDK internals](img/B18884_06_15.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – CustomScheduledThreadPoolExecutor 实例简化了线程管理以及其他 JDK 内部机制的管理](img/B18884_06_15.jpg)'
- en: Figure 6.15 – A CustomScheduledThreadPoolExecutor instance facilitates easier
    thread management and easier management of other JDK internals
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – CustomScheduledThreadPoolExecutor 实例简化了线程管理以及其他 JDK 内部机制的管理
- en: 'Leveraging the JDK internals for scheduling does not require you to create
    a customized solution while gaining better visibility into the scheduling cycle
    (*Figure 6**.16*):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 JDK 内部机制进行调度不需要您创建定制的解决方案，同时可以更好地了解调度周期（**图 6.16**）：
- en: '![Figure 6.16 – The UML class diagram shows the minimal effort required to
    create a custom scheduler with all the internals](img/B18884_06_16.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – UML 类图显示了创建具有所有内部机制的定制调度器所需的最小努力](img/B18884_06_16.jpg)'
- en: Figure 6.16 – The UML class diagram shows the minimal effort required to create
    a custom scheduler with all the internals
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – UML 类图显示了创建具有所有内部机制的定制调度器所需的最小努力
- en: Conclusion
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Both preset examples show possible uses of the scheduler pattern. Using the
    JDK internals has a number of advantages to consider. It gives the platform the
    ability to more efficiently use and optimize available resources, such as the
    dynamic JIT translation we learned about in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037)*,*
    *Discovering the Java Platform for* *Design Patterns*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 两个预设示例展示了调度器模式可能的用途。使用 JDK 内部功能有许多需要考虑的优点。它赋予平台更高效使用和优化可用资源的能力，例如我们在[*第2章*](B18884_02.xhtml#_idTextAnchor037)*，*《发现Java平台设计模式》*中了解到的动态JIT翻译。
- en: Effective thread utilization using a thread-pool pattern
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程池模式有效利用线程
- en: It is not always necessary to create a new thread for each task, as this can
    lead to improper resource usage. A thread-pool pattern may be a good solution
    to this challenge.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每次任务都需要创建一个新的线程，因为这可能导致资源使用不当。线程池模式可能是解决这一挑战的好方法。
- en: Motivation
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: A short-lived task does not need to create a new thread every time it runs,
    because each instantiation of a thread is related to the allocation of underlying
    resources. Wasting resources could result in an application throughput or performance
    penalty. A better option is described by the thread-pool pattern, which defines
    the required number of reusable threads to execute a critical section. Specific
    workers can transparently operate above the critical section code that needs to
    be executed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 短暂的任务不需要每次运行时都创建一个新的线程，因为每个线程的实例化都与底层资源的分配相关。浪费资源可能会导致应用程序吞吐量或性能惩罚。线程池模式描述了一种更好的选择，它定义了执行关键部分所需的可重用线程的数量。特定的工作者可以透明地操作需要执行的关键部分代码上方。
- en: Sample code
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us imagine again a temperature measurement by sensors with different measurement
    dynamics (*Example 6.16*):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次想象一下通过具有不同测量动态的传感器进行的温度测量（*示例6.16*）：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s the output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example 6.16 – The thread pool runs the worker temperature measurement task
    on demand
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.16 – 线程池按需运行工作温度测量任务
- en: 'A thread pool helps to use and manage created threads so that there is always
    a task to process. This positively affects the application behavior and facilitates
    planning based on the resources available (*Figure 6**.17*):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池有助于使用和管理创建的线程，以确保始终有任务可以处理。这有利于应用程序的行为，并便于根据可用资源进行规划（*图6**.17*）：
- en: '![Figure 6.17 – The behavior of the thread pool shows the usage of the created
    thread](img/B18884_06_17.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17 – 线程池的行为展示了创建的线程的使用](img/B18884_06_17.jpg)'
- en: Figure 6.17 – The behavior of the thread pool shows the usage of the created
    thread
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 线程池的行为展示了创建的线程的使用
- en: 'The core example element is `SensorWorker`. The worker implements a `Runnable`
    interface and is responsible for the `TemperatureTask` evaluation (*Example 6.17*):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 核心示例元素是`SensorWorker`。工作器实现了`Runnable`接口，并负责`TemperatureTask`的评估（*示例6.17*）：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Example 6.17 – The SensorTask instance can provide additional logic for the
    task evaluation wrapped around it
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6.17 – SensorTask实例可以为围绕其的任务评估提供额外的逻辑
- en: 'The example implementation does not require any additional custom class types
    to introduce concurrency (*Figure 6**.16*):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 示例实现不需要引入任何额外的自定义类类型来引入并发（*图6**.16*）：
- en: '![Figure 6.18 – The UML class diagram highlights that all the required thread
    pool elements are provided by the Java platform](img/B18884_06_18.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – UML类图突出显示Java平台提供了所有所需的线程池元素](img/B18884_06_18.jpg)'
- en: Figure 6.18 – The UML class diagram highlights that all the required thread
    pool elements are provided by the Java platform
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – UML类图突出显示Java平台提供了所有所需的线程池元素
- en: Conclusion
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: A thread-pool pattern can provide another acceptable way to introduce concurrency
    into an application. It not only supports the execution of class types that inherit
    the `Runnable` interface but also the `Callable` interface. Using a `Callable`
    interface allows you to create a result through a `Future` interface. The result
    of executing a `Callable` instance into an instance of the `Future` type is that
    the execution of the critical section is done asynchronously by the controlling
    thread. In other words, the time required to produce a result is not known.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池模式可以提供另一种引入并发到应用程序的可接受方式。它不仅支持继承`Runnable`接口的类类型的执行，还支持`Callable`接口。使用`Callable`接口允许您通过`Future`接口创建一个结果。将`Callable`实例执行到`Future`类型实例的结果是，关键部分的执行是由控制线程异步完成的。换句话说，产生结果所需的时间是未知的。
- en: The thread-pool pattern is also another SOLID approach to properly structuring
    your code base to ensure maintainability and resource utilization.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池模式也是另一种SOLID方法，可以正确地构建您的代码库，以确保可维护性和资源利用。
- en: Let us briefly summarize the lessons learned in this chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要总结本章学到的经验教训。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter demonstrated some of the most commonly used approaches to solving
    concurrent problems. It also showed the importance of previously acquired knowledge,
    concurrent application development requires more precision and discipline to achieve
    the desired result, similar to the knowledge of Java platform internals discussed
    in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform
    for* *Design Patterns*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了一些解决并发问题的最常用方法。它还展示了先前获得知识的重要性，并发应用程序开发需要更多的精确性和纪律，以实现预期的结果，类似于在[*第2章*](B18884_02.xhtml#_idTextAnchor037)中讨论的Java平台内部知识，*发现Java平台的设计模式*。
- en: Each currently adopted pattern forces the creation of a sustainable, clean application
    code base. Many of them clearly follow and use discussed development approaches
    such as APIE or SOLID.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目前采用的模式都迫使创建一个可持续的、清洁的应用代码库。其中许多明显遵循并使用了讨论的开发方法，如APIE或SOLID。
- en: The evolution of the Java platform tends to simplify how to approach the platform’s
    concurrency capabilities. One good example has been already mentioned in some
    of the sections in this chapter. Features such as `CompletableFuture` or `Executors`
    utils have been around for a while, but upcoming ones might be worth considering.
    The tentative goal with virtual threads is to increase application throughput
    while making proper use of the underlying resources and still maintaining threading
    conveniences such as debugging and providing relevant stack frames. Structure
    concurrency, on the other hand, attempts to provide a framework for simply designing
    callbacks while using an imperative code style. In addition to upcoming features
    that try to improve application throughput or simplify the usage of the concurrency
    framework, we should not forget about the immutability of the instances served
    by the `record` type. The `record` type provides a strong state contract due to
    equality. Instance immutability can play a critical role in thread interactions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台的演变倾向于简化如何接近平台并发能力的方法。本章的一些部分已经提到了一个很好的例子。像`CompletableFuture`或`Executors`实用工具这样的功能已经存在了一段时间，但即将推出的功能可能值得考虑。虚拟线程的初步目标是提高应用程序吞吐量，同时合理利用底层资源，并仍然保持线程便利性，如调试和提供相关的堆栈帧。另一方面，结构并发试图提供一个框架，以简单设计回调，同时使用命令式代码风格。除了尝试提高应用程序吞吐量或简化并发框架使用的即将推出的功能外，我们不应忘记由`record`类型提供的实例不可变性。由于相等性，`record`类型提供了一种强大的状态合约。实例不可变性在线程交互中可以发挥关键作用。
- en: The entire application development can sometimes deviate from the desired goal.
    Some common symptoms have already been identified in this kind of situation. These
    signals could signal our attention to reconsider the direction of development.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序开发有时会偏离预期的目标。在这种情况下，已经识别出一些常见的症状。这些信号可能会引起我们注意，重新考虑开发方向。
- en: We will touch on some of them in the next chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中涉及其中的一些。
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What challenges are solved by the double-check singleton pattern?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双重检查单例模式解决了哪些挑战？
- en: What is the best way to create the desired thread pool with the JDK?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JDK创建所需线程池的最佳方式是什么？
- en: Which concurrent design pattern reflects the variability of an instance to process
    the next step?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个并发设计模式反映了实例处理下一步的变异性？
- en: What is the best pattern for handling a repeatable task?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理可重复任务的最佳模式是什么？
- en: What pattern helps separate the dispatch logic and event handling?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种模式有助于分离调度逻辑和事件处理？
- en: Further reading
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计模式：可复用面向对象软件元素*》由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides著，Addison-Wesley，1995年
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计原则与设计模式*》由Robert C. Martin著，Object Mentor，2000年
- en: '*JEP-425: Virtual* *Threads*, [https://openjdk.org/jeps/425](https://openjdk.org/jeps/425)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP-425: 虚拟* *线程*，[https://openjdk.org/jeps/425](https://openjdk.org/jeps/425)'
- en: '*JSR-428: Structured Concurrency (**Incubator)* ([https://openjdk.org/jeps/428](https://openjdk.org/jeps/428))'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSR-428: 结构化并发（**孵化器**）* ([https://openjdk.org/jeps/428](https://openjdk.org/jeps/428))'
- en: '*Patterns of Enterprise Application Architecture* by Martin Fowler, Pearson
    Education, Inc, 2003'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*企业应用架构模式*》由Martin Fowler著，Pearson Education, Inc，2003年
- en: '*Effective Java, Third Edition* by Joshua Bloch, Addison-Wesley, 2018'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*有效Java，第三版*》由Joshua Bloch著，Addison-Wesley，2018年
- en: '*JDK 17: Class* *Exchanger* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html))'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JDK 17: 类* *Exchanger* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html))'
- en: '*JDK 17: Class* *CompletableFuture* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html))'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JDK 17: 类* *CompletableFuture* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html))'
- en: '*JDK 17: Class* *Executors* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html))'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JDK 17: 类* *Executors* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html))'
- en: '*Java Mission* *Control* ([https://wiki.openjdk.org/display/jmc](https://wiki.openjdk.org/display/jmc))'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java任务* *控制* ([https://wiki.openjdk.org/display/jmc](https://wiki.openjdk.org/display/jmc))'
- en: Answers
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The challenge solved by the double-checked singleton pattern is ensuring that
    only one class instance is present in the running JVM to avoid possible leaks
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双重检查单例模式解决的问题是在运行中的JVM中确保只有一个类实例存在，以避免可能的泄漏
- en: The usage of the `Executors` utility that resides in the `java.base` module
    and `java.util.concurrent` package
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位于`java.base`模块和`java.util.concurrent`包中的`Executors`实用工具的使用
- en: The balking pattern depends on the instance stat
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拒绝模式依赖于实例状态
- en: The scheduler pattern
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度器模式
- en: The producer-consumer pattern is one of the most common concurrent design patterns,
    with clearly separated and addressed logic
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产者-消费者模式是最常见的并发设计模式之一，具有清晰分离和处理的逻辑
