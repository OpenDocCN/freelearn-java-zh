- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'This chapter shows how to unit test your APIs before they are integrated with
    other components. Sometimes, we would have to stub dependencies with some dummy
    data, and this can be done by mocking the dependencies. We will show you how to
    do this using a mocking library. We will also show you how to write fixtures to
    populate test data and then how you can test the behavior of your application
    by integrating different APIs and testing them together. We will cover the following
    recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何在API与其他组件集成之前对其进行单元测试。有时，我们需要用一些虚拟数据来模拟依赖，这可以通过模拟依赖来实现。我们将向您展示如何使用模拟库来完成这项工作。我们还将向您展示如何编写固定值来填充测试数据，然后如何通过集成不同的API并一起测试它们来测试应用程序的行为。我们将涵盖以下食谱：
- en: Unit testing of an API using JUnit
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JUnit进行API的单元测试
- en: Unit testing by mocking dependencies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟依赖进行单元测试
- en: Using fixtures to populate data for testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定值来填充测试数据
- en: Behavioral testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测试
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Well-tested code provides a peace of mind to the developer. If you get a feeling
    that writing a test for the new method you are developing is too much of an overhead,
    then you usually don't get it right the first time.. This is because you have
    to test your method anyway. Doing this in the context of the application only
    requires time to set things up (especially if you are trying to test all the possible
    input and conditions). Then, if the method changes, you need to redo the setup
    again. And you do it manually. You can avoid this by creating an automated test
    at the same time you were developing the new method (we assume not-too complex
    code, of course; setters and getters do not count). This would save you time in
    the long run.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 经过良好测试的代码能让开发者感到安心。如果你觉得为正在开发的新方法编写测试过于繁琐，那么你通常第一次就做不对。这是因为你无论如何都需要测试你的方法。在应用程序的上下文中进行测试只需要时间来设置（尤其是如果你试图测试所有可能的输入和条件）。然后，如果方法发生变化，你需要重新设置。而且你是手动做的。你可以在开发新方法的同时创建一个自动化的测试来避免这种情况（当然，我们假设代码不是太复杂；设置器和获取器不计入）。这将在长期内为你节省时间。
- en: Why do we get this feeling of overhead sometimes? It's probably because we are
    not prepared psychologically. When we think about how long it would take to add
    the new functionality, we often forget to include the time needed for writing
    the test. It is even worse when we forget this while providing an estimate to
    a manager. Often, we shy away from giving a higher estimate because we do not
    want to look not perception we have of not being very knowledgeable or skilled
    enough. Whatever the reason, it happens. Only after years of experience, we learn
    to include tests in our estimates and earn enough respect and clout to be able
    to assert publicly that doing things right requires more time up front, but saves
    much more time in the long run. Besides, doing it right leads to a better quality
    of the result with far less stress, which means a better quality of life overall.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有时我们会觉得有额外的负担？可能是因为我们在心理上没有做好准备。当我们思考添加新功能需要多长时间时，我们常常忘记包括编写测试所需的时间。当我们向经理提供估算时忘记这一点会更糟。我们常常回避给出更高的估算，因为我们不想显得不够知识渊博或技能不足。无论什么原因，这种情况都会发生。只有经过多年的经验，我们才学会在我们的估算中包含测试，并赢得足够的尊重和影响力，能够公开宣称正确做事需要前期投入更多时间，但长期来看可以节省更多时间。此外，正确做事可以带来更好的结果质量，压力更小，这意味着整体生活质量更高。
- en: If you are still not convinced, make note of the date when you read this and
    check back every year until this advice becomes obvious to you. Then, please share
    your experiences with others. This is how humanity makes progress, by passing
    knowledge from one generation to the next.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不确信，请记下你阅读这篇文档的日期，并每年检查一次，直到这些建议对你来说显而易见。然后，请与他人分享你的经验。这就是人类进步的方式，通过将知识从一代传到下一代。
- en: 'However, if you would like to learn how to write tests that will help you produce
    good quality Java code, this chapter is for you. Methodologically, this is applicable
    to other languages and professions too. This chapter is written primarily for
    Java developers and assumes the authorship of tested code. Another assumption
    is that testing happens during the early stages of code writing so that code weaknesses
    discovered during the testing can be fixed immediately. Writing automated tests
    early is the best time to do it for two other reasons:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要学习如何编写有助于你生成高质量Java代码的测试，那么这一章就是为你准备的。从方法论上讲，这也适用于其他语言和职业。这一章主要面向Java开发者，并假设测试代码的作者。另一个假设是测试发生在代码编写的早期阶段，这样在测试过程中发现的代码弱点可以立即修复。尽早编写自动化测试是最佳时机，还有两个其他原因：
- en: You can easily restructure your code to make it more testable
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松地重构你的代码，使其更容易进行测试
- en: It saves you time by eliminating guesswork, which in turn makes your development
    process more productive
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过消除猜测来节省你的时间，这反过来又使得你的开发过程更加高效
- en: Another good moment to write a test (or enhance the existing one) is when a
    defect is discovered in production. It helps your investigation of the root cause
    if you recreate the problem and demonstrate it in a failed test and then show
    how the issue disappears (and the test does not fail anymore) in the new version
    of the code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个编写测试（或增强现有测试）的好时机是在生产中发现缺陷时。如果你重新创建问题并在失败的测试中展示它，然后展示在新版本的代码中问题消失（并且测试不再失败），这将有助于你调查根本原因。
- en: Unit testing of an API using JUnit
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JUnit对API进行单元测试
- en: According to Wikipedia, *A research survey performed in 2013 across 10,000 Java
    projects hosted on GitHub found that JUnit, (in a tie with slf4j-api), was the
    most commonly included external library. Each library was used by 30.7% of projects.* JUnit
    is a testing framework--one of a family of unit testing frameworks collectively
    known as xUnit that originated with SUnit. It is linked as a JAR at compile time
    and resides (since JUnit 4) in the `org.junit` package.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，*2013年在GitHub上托管在GitHub上的10,000个Java项目中进行的调查发现，JUnit（与slf4j-api并列），是最常包含的外部库。每个库都被30.7%的项目使用。JUnit是一个测试框架——xUnit家族中单元测试框架之一，起源于SUnit。它在编译时链接为一个JAR文件，并驻留在`org.junit`包中（自JUnit
    4以来）。
- en: Here's an excerpt from another article on Wikipedia, *In object-oriented programming,
    a unit is often an entire interface, such as a class, but could be an individual
    method.* We've found the last part--a unit as an individual method--the most useful
    in practice. It will be the basis for the examples of the recipes of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是维基百科上另一篇文章的摘录，*在面向对象编程中，一个单元通常是一个完整的接口，如一个类，但也可以是一个单独的方法。*我们发现最后一部分——一个作为单独方法的单元——在实践中最有用。它将成为本章食谱示例的基础。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'At the time of this writing, the latest stable version of JUnit is 4.12, which
    can be used by adding the following Maven dependency to the `pom.xml` project
    level:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，JUnit的最新稳定版本是4.12，可以通过在`pom.xml`项目级别添加以下Maven依赖项来使用：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After this, you can write your first JUnit test. Let''s assume you have the `Vehicle` class
    created in the `src/main/java/com/packt/cookbook.ch02_oop.a_classes` folder (this
    is exactly the code we discussed in [Chapter 2](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml), *Fast
    Track to OOP - Classes and Interfaces*, of this book):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你可以编写你的第一个JUnit测试。假设你已经在`src/main/java/com/packt/cookbook.ch02_oop.a_classes`文件夹中创建了`Vehicle`类（这正是我们在本书[第2章](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml)，*快速掌握面向对象编程
    - 类和接口*中讨论的代码）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now you can create the `src/test/java/com/packt/cookbook.ch02_oop.a_classes` folder
    (notice the new folder tree that starts with `test`, created in parallel to the
    tree of `main`) and create a new file in it called `VehicleTest.java` that contains
    the `VehicleTest` class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建`src/test/java/com/packt/cookbook.ch02_oop.a_classes`文件夹（注意以`test`开头的新的文件夹结构，它与`main`文件夹结构并行创建）并在其中创建一个名为`VehicleTest.java`的新文件，该文件包含`VehicleTest`类：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run it using your favorite IDE or just with the `mvn test` command. You will
    see an output that will include the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的IDE或直接使用`mvn test`命令运行它。你将看到以下输出：
- en: '![](img/44d4630b-d846-41c3-b270-c9ed50889d93.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44d4630b-d846-41c3-b270-c9ed50889d93.png)'
- en: Congratulations! You have created your first test class. It does not test anything
    yet, but it is an important setup--the overhead that is necessary for doing things
    the right way. In the next section, we will start with the actual testing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经创建了你的第一个测试类。它目前还没有测试任何内容，但它是一个重要的设置——正确做事所必需的额外开销。在下一节中，我们将开始实际的测试。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s look at the `Vehicle` class closer. Testing the getters would be of
    little value, but we can still do it, making sure that the value passed to the
    constructor is returned by the corresponding getter. The exception in the constructor
    belongs to the must-test features as well as the `getSpeedMph()` method. There
    is also an object of the `Engine` class that has the `getHorsePower()` method.
    Can it return `null`? We should look in the `Engine` class too:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `Vehicle` 类。测试获取器可能价值不大，但我们仍然可以这样做，确保传递给构造函数的值由相应的获取器返回。构造函数中的异常也属于必须测试的功能，以及
    `getSpeedMph()` 方法。还有一个 `Engine` 类的实例，它有 `getHorsePower()` 方法。它能否返回 `null`？我们也应该在
    `Engine` 类中查看：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is not much behavior in this class to test and it cannot return `null`.
    But returning a negative value is a definite possibility, which in turn can cause
    problems for the `Math.sqrt()` function of the `getSpeedMph()` method. Should
    we make sure that the horsepower value will never be negative? It depends on how
    limited is the method's usage and the source of the input data for it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中要测试的行为不多，它不能返回 `null`。但是返回一个负值是肯定的可能性，这反过来又可能对 `getSpeedMph()` 方法的 `Math.sqrt()`
    函数造成问题。我们应该确保马力值永远不会是负数吗？这取决于该方法的使用限制和输入数据的来源。
- en: Similar considerations are applicable to the value of the `weightPounds` property of
    the `Vehicle` class. It can stop the application with `ArithmeticException` caused
    by the division by zero in the `getSpeedMph()` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的考虑也适用于 `Vehicle` 类的 `weightPounds` 属性的值。它可能会因为 `getSpeedMph()` 方法中的除零错误而引发
    `ArithmeticException`，从而停止应用程序。
- en: However, in practice, there is little chance that the values of an engine's
    horsepower and vehicle weight will be negative or close to zero, so we will assume
    this and will not add these checks to the code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，发动机马力值和车辆重量为负数或接近零的可能性很小，所以我们将假设这一点，并且不会将这些检查添加到代码中。
- en: Such analysis is the daily routine and the background thoughts of every developer,
    and that is the first step in the right direction. The second step is to capture
    all these thoughts and doubts in the unit tests and verify the assumptions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的分析是每个开发者的日常工作和背景思考，这是正确方向的第一步。第二步是将所有这些思考和疑问捕捉到单元测试中，并验证假设。
- en: 'Let''s go back to the test class we have created and enhance it. As you may
    have probably noticed, the `@Test` annotation makes a certain method a test method.
    This means it will be run by your IDE or Maven every time you issue a command
    to run tests. The method can be named any way you like, but a best practice advises
    to indicate which method (of the `Vehicle` class, in this case) you are testing.
    So, the format usually looks like `test<methodname><scenario>`, where  `scenario`
    indicates a particular test case: a happy path, a failure, or some other condition
    you would like to test. In our example, we do not use suffix as an indication
    that we are going to test the main functionality that is working successfully
    (without any errors or edge cases). Later, we will show examples of methods that
    test other scenarios.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们创建的测试类，并对其进行增强。你可能已经注意到了，`@Test` 注解将某个方法标记为测试方法。这意味着每次你发出运行测试的命令时，IDE
    或 Maven 都会运行它。你可以按任何你喜欢的名称命名该方法，但最佳实践建议表明你正在测试哪个方法（在这种情况下是 `Vehicle` 类的方法）。因此，格式通常看起来像
    `test<methodname><scenario>`，其中 `scenario` 表示特定的测试用例：一条成功路径、一个失败，或者你想要测试的其他条件。在我们的例子中，我们没有使用后缀来表示我们将要测试的是运行成功的主要功能（没有任何错误或边缘情况）。稍后，我们将展示测试其他场景的方法示例。
- en: 'In such a test method, you can call the application method you are testing,
    provide it with the data, and assert the result. You can create your own assertions
    (methods to compare the actual results with the expected ones) or you can use
    assertions provided by JUnit. To do the latter, just add `static` import:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的测试方法中，你可以调用你正在测试的应用程序方法，提供数据，并断言结果。你可以创建自己的断言（比较实际结果与预期结果的方法），或者你可以使用 JUnit
    提供的断言。要实现后者，只需添加 `static` 导入：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you use a modern IDE, you can type `import static org.junit.Assert` and
    see how many different assertions are available (or go to JUnit''s API documentation
    and see it there). There is a dozen or more overloaded methods available: `assertArrayEquals()`,
    `assertEquals()`, `assertNotEquals()`, `assertNull()`, `assertNotNull()`, `assertSame()`,
    `assertNotSame()`, `assertFalse()`, `assertTrue()`, `assertThat()`, and `fail()`.
    It would be helpful if you spend a few minutes reading what these methods do.
    You can also guess their purpose by name. Here is an example of the usage of the `assertEquals()` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用现代IDE，你可以输入`import static org.junit.Assert`并查看有多少不同的断言可用（或者去JUnit的API文档中查看）。有十几个或更多的重载方法可用：`assertArrayEquals()`、`assertEquals()`、`assertNotEquals()`、`assertNull()`、`assertNotNull()`、`assertSame()`、`assertNotSame()`、`assertFalse()`、`assertTrue()`、`assertThat()`和`fail()`。如果你花几分钟阅读这些方法的作用会很有帮助。你也可以通过名称猜测它们的目的。以下是对`assertEquals()`方法使用的一个示例：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We compare the actual length of the word `Hello` and the expected length, that
    is, `4`. We know that the correct number would be `5`, but we would like the test to
    fail to demonstrate the failing behavior and advise how to read the failing test
    results (you don''t need to read happy results, do you?). If you run this test,
    you''ll get the following result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较单词`Hello`的实际长度和期望长度，即`4`。我们知道正确的数字应该是`5`，但我们希望测试失败以展示失败行为，并指导如何阅读失败的测试结果（你不需要阅读成功的结果，对吧？）。如果你运行这个测试，你会得到以下结果：
- en: '![](img/5d13c64e-732d-456c-a2a5-c25dd93a2b83.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d13c64e-732d-456c-a2a5-c25dd93a2b83.png)'
- en: 'You can see that the expected value was `4`, while the actual is `5`. Say,
    you switch the order like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到期望值是`4`，而实际值是`5`。比如说，你这样交换顺序：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result of this will be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果将是这样的：
- en: '![](img/63be96a0-04c4-4610-9117-d330ea82b6e5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63be96a0-04c4-4610-9117-d330ea82b6e5.png)'
- en: This is incorrect because `5` is the actual result, while `4` is the expected
    (although erroneous, for demonstration purposes only).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不正确的，因为`5`是实际结果，而`4`是期望的（尽管是为了演示目的而错误的）。
- en: It is important to remember that in each of the asserting methods, the parameter
    with the expected value is located (in the signature of an assertion) ***before***
    the actual one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在每种断言方法中，具有期望值的参数都位于（在断言的签名中）**之前**实际值的位置。
- en: 'After the test is written, you will do something else, and months later, you
    will probably forget what each assertion actually evaluated. But it may well be
    that one day the test will fail (because you or somebody will change the application
    code). You will see the test method name, expected value, and the actual value,
    but you will have to dig through the code to figure which of the assertion failed
    (there are often several of them in each test method). You will probably be forced
    to add a debug statement and run the test several times in order to figure it
    out. To help you avoid this extra digging, each of the JUnit assertions allows
    you to add a message that describes the particular assertion. For example, run
    this version of the test:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试之后，你将做其他事情，几个月后，你可能会忘记每个断言实际上评估了什么。但很可能有一天测试会失败（因为你或其他人会更改应用程序代码）。你会看到测试方法名、期望值和实际值，但你必须挖掘代码以确定哪个断言失败了（每个测试方法中通常有几个断言）。你可能被迫添加调试语句并多次运行测试以找出原因。为了帮助你避免这种额外的挖掘，JUnit断言中的每一个都允许你添加一个描述特定断言的消息。例如，运行这个版本的测试：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you do this, the result will be much more readable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，结果将更加易于阅读：
- en: '![](img/1c3dda9b-be51-4f34-9f36-ad39c2a0410d.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c3dda9b-be51-4f34-9f36-ad39c2a0410d.png)'
- en: 'To complete this demonstration, we change the expected value to `5`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个演示，我们将期望值更改为`5`：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will be your test output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是你的测试输出：
- en: '![](img/6e1d30c5-ecf8-41da-9c7f-e1f117d5e3cc.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e1d30c5-ecf8-41da-9c7f-e1f117d5e3cc.png)'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Equipped with some knowledge of the JUnit framework, we can now write a real
    test method for the main case: the calculation of the speed of a vehicle of certain
    weight with an engine of certain horsepower to determine where it can reach in
    a certain period of time. We take the formula we used for writing the code (provided
    originally by the domain expert) and calculate the expected value. For example,
    if the vehicle has an engine of 246 hp and weight of 4,000 lb, then in 10 sec,
    its speed can reach 117 mph. Since the speed is of the type `double`, we will
    use this assertion:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在具备一些JUnit框架知识的基础上，我们现在可以为主案例编写一个真正的测试方法：计算具有特定重量和特定马力的车辆的行驶速度，以确定它在一定时间内能到达哪里。我们使用编写代码时使用的公式（最初由领域专家提供）来计算预期值。例如，如果车辆有一个246马力的引擎和4,000磅的重量，那么在10秒内，其速度可以达到117英里/小时。由于速度是`double`类型，我们将使用以下断言：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, `delta` is allowable precision (we decided that 1 percent is good enough).
    The resulting implementation of the `test` method will look as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`delta` 是允许的精度（我们决定1%已经足够好）。`test` 方法的实现结果如下：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we run this test, the output will be as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个测试，输出结果如下：
- en: '![](img/f19a21ab-44cb-4b1f-be96-07db70a1c7dc.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f19a21ab-44cb-4b1f-be96-07db70a1c7dc.png)'
- en: 'To make sure the test is working, we set the expected value to 119 mph (more
    than 1 percent different) and run the test again. The result will be as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保测试正常工作，我们将预期值设置为119英里/小时（超过1%的差异）并再次运行测试。结果如下：
- en: '![](img/56312767-34f4-4dc3-b1ee-9f4111bd91e5.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56312767-34f4-4dc3-b1ee-9f4111bd91e5.png)'
- en: We change the expected value back to 117 and continue writing other test cases
    we discussed while analyzing the code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将预期值改回117，并继续编写我们在分析代码时讨论的其他测试用例。
- en: 'Let''s make sure that the exception is thrown when expected. Let''s add another
    import:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保当预期时抛出异常。让我们添加另一个导入：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, write the following test:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编写以下测试：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This test runs successfully too. To make sure that the test works correctly,
    we temporarily assign it with the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试也运行成功。为了确保测试正确工作，我们暂时将其分配以下内容：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we observe the output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们观察输出：
- en: '![](img/c6f0d5e3-84b1-4d0c-852f-16e0091e5a1a.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6f0d5e3-84b1-4d0c-852f-16e0091e5a1a.png)'
- en: This way, we get a level of confidence that we did not code something that is
    going to be correct always, no matter the code changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们获得了一种信心，即我们没有编写出总是正确的代码，无论代码如何变化。
- en: As you can see, the best way to write these tests is in the process of writing
    application code, so you can test the code as it grows in complexity. Otherwise,
    especially in more complex code, you might have problems debugging it after all
    of the code is written already.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编写这些测试的最佳方式是在编写应用程序代码的过程中，这样您可以在代码复杂性增长的同时测试代码。否则，特别是在更复杂的代码中，在所有代码编写完成后，您可能会在调试时遇到问题。
- en: There are quite a few other annotations and JUnit features that can be helpful
    to you, so please refer to the JUnit documentation for more in-depth understanding
    of all the framework capabilities.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他注释和JUnit特性可能对您有所帮助，因此请参阅JUnit文档以深入了解所有框架功能。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下食谱：
- en: Unit testing by mocking dependencies
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟依赖进行单元测试
- en: Using fixtures to populate data for testing
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定值填充测试数据
- en: Behavioral testing
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测试
- en: Unit testing by mocking dependencies
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模拟依赖进行单元测试
- en: Writing a unit test requires unit isolation. In case a method uses several other
    methods from different objects, there arises a need to limit the depth of testing so
    that each layer can be tested in isolation as a unit. This is when the need for
    mocking the lower level comes into focus.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试需要单元隔离。如果一个方法使用了来自不同对象的几个其他方法，就需要限制测试的深度，以便每个层可以作为一个单元单独测试。这时，对低层进行模拟的需求就凸显出来了。
- en: 'Mocking can not only be done vertically, but also horizontally: at the same
    level, but already isolated from the underlying functionality. If a method is
    long and complicated, you might consider breaking it into several smaller methods
    so you can test only one of them while mocking the others. This is another advantage
    of unit testing code along with its development; it is easier to redesign code
    for better testability before it is hardened.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟不仅可以垂直进行，也可以水平进行：在同一级别，但已经与底层功能隔离。如果一个方法很长且复杂，您可能需要将其分解成几个更小的方法，这样您就可以在模拟其他方法的同时只测试其中一个。这是与代码开发一起进行单元测试的另一个优点；在代码变得固定之前，更容易重新设计代码以提高可测试性。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Mocking other methods and classes is straightforward. Coding to an interface
    (as described in [Chapter 2](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml), *Fast
    Track to OOP - Classes and Interfaces*) makes it much easier, although there are
    mocking frameworks that allow you to mock classes that do not implement any interface
    (we will see examples of such framework usage in the next section of this recipe).
    Also, using object and method factories helps you create test-specific implementations
    of such factories so they can generate objects with methods that return the expected
    hardcoded values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟其他方法和类是直接的。按照[第2章](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml)，*快速掌握面向对象 -
    类和接口*中描述的方法进行编码，这会容易得多，尽管有一些模拟框架允许您模拟不实现任何接口的类（我们将在本食谱的下一节中看到此类框架使用的示例）。此外，使用对象和方法工厂可以帮助您创建特定于测试的工厂实现，这样它们就可以生成具有返回预期硬编码值的方法的对象。
- en: 'For example, in [Chapter 4](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml), *Going
    Functional*, we introduced `FactoryTraffic`, which produced one or many objects
    of `TrafficUnit`. In a real system, this factory would draw data from some external
    system that has data about traffic for a certain geographic location and time
    of the day. Using the real system as the source would complicate the code setup
    for you when you run the examples. To get around this problem, we have mocked
    the data by generating them according to the distribution that somewhat resembles
    the real one: a bit more cars than trucks, the weight of the vehicle depending
    on the type of the car, the number of passengers and weight of the payload, and
    similar. What is important for such a simulation is that the range of values (min
    and max) should reflect those coming from the real system, so the application
    would be tested on the full range of possible real data.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第4章](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml)，*功能化编程*中，我们介绍了`FactoryTraffic`，它产生一个或多个`TrafficUnit`对象。在一个真实系统中，这个工厂会从某些外部系统中获取有关特定地理位置和一天中某个时间点的交通数据的系统中的数据。使用真实系统作为数据源会在您运行示例时使代码设置变得复杂。为了解决这个问题，我们通过生成与真实数据分布相似的数据来模拟数据：比卡车多一点的汽车，车辆的重量取决于汽车类型，乘客数量和货物的重量，等等。对于这样的模拟来说，重要的是值的范围（最小值和最大值）应该反映来自真实系统的值，这样应用程序就可以在所有可能的真实数据范围内进行测试。
- en: The important constraint for mocking code is that it should not be too complicated.
    Otherwise, its maintenance would require an overhead that would either decrease
    the team productivity or decrease (if not abandon completely) the test coverage.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟代码的重要约束是它不应该太复杂。否则，其维护将需要额外的开销，这可能会降低团队的生产力或减少（如果不是完全放弃）测试覆盖率。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here is how the mock of `FactoryTraffic` will look like:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`FactoryTraffic`的模拟示例：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It assembles a collection of `TrafficUnit` objects. In a real system, these
    objects would be created from the rows of the result of some database query, for
    example. But in our case, we just mock the result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它组装了一系列的`TrafficUnit`对象。在一个真实系统中，这些对象会从某些数据库查询的结果行中创建，例如。但在我们的情况下，我们只是模拟结果：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we used a random number generator to pick up the value from
    a range for each of the parameters. The range is in line with the ranges of the
    real data. This code is very simple and it does not require much maintenance,
    but it provides the application with the flow of data similar to the real one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用随机数生成器为每个参数从一定范围内选取值。这个范围与真实数据的范围一致。这段代码非常简单，不需要太多的维护，但它为应用程序提供了类似于真实数据流的流程。
- en: 'You can use another technique for testing the method that has some dependencies
    that you would like to isolate in order to get the predictable result. For example,
    let''s revisit the `VechicleTest` class. Instead of creating a real `Engine` object,
    we can mock it using one of the mocking frameworks. In this case, we use Mockito.
    Here is the Maven dependency for it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用另一种技术来测试具有一些依赖关系的方法，你希望将其隔离以获得可预测的结果。例如，让我们回顾一下`VechicleTest`类。我们不是创建一个真实的`Engine`对象，而是可以使用mocking框架之一来mock它。在这种情况下，我们使用Mockito。以下是它的Maven依赖项：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The test method now looks like this (the two lines that were changed are highlighted):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法现在看起来是这样的（更改的两行被突出显示）：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, we instruct the `mock` object to return a fixed value when
    the `getHorsePower()` method is called. We can even go as far as creating a mock
    object for the method we want to test:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们指示`mock`对象在调用`getHorsePower()`方法时返回一个固定值。我们甚至可以进一步创建一个用于我们想要测试的方法的mock对象：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, it always returns the same value:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它总是返回相同的值：
- en: '![](img/bc805877-a5bd-42db-bd36-cbf6908cbb6d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc805877-a5bd-42db-bd36-cbf6908cbb6d.png)'
- en: However, this would defeat the purpose of testing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会违背测试的目的。
- en: 'You can use another technique while testing a stream''s pipeline methods. Let''s
    assume we need to test the `trafficByLane()` method in the `TrafficDensity1` class (we
    are going to have  `TrafficDensity2` and `TrafficDensity3`, too):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试流式处理的管道方法时，你可以使用另一种技术。假设我们需要测试`TrafficDensity1`类中的`trafficByLane()`方法（我们还将有`TrafficDensity2`和`TrafficDensity3`）：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It uses two support classes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了两个支持类：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It also uses the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使用了以下内容：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We demonstrated the use of such support classes in [Chapter 3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml), *Modular*
    *Programming*, while talking about streams. Now we realize that testing this class
    might not be easy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论流时，在[第3章](488da544-ff73-4ef7-9d57-00b67479defd.xhtml)，*模块化* *编程*中展示了此类支持类的使用。现在我们意识到测试此类可能并不容易。
- en: 'Because the `SpeedModel` object is an input parameter for the `trafficByLane()` method,
    we could test its `getSpeedMph()` method in isolation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`SpeedModel`对象是`trafficByLane()`方法的输入参数，我们可以单独测试其`getSpeedMph()`方法：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Refer to the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, unfortunately, the current implementation of `FactorySpeedModel` requires
    the `TrafficUnit` object (in order to get the traction value). We need to modify
    it to extract `SpeedModel` without any dependency in `TrafficUnit` because we
    will now apply traction in the `calcSpeed()` method. The new version of `FactorySpeedModel` will
    now look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，不幸的是，`FactorySpeedModel`的当前实现需要`TrafficUnit`对象（为了获取牵引力值）。我们需要修改它，以便在不依赖`TrafficUnit`的情况下提取`SpeedModel`，因为我们现在将在`calcSpeed()`方法中应用牵引力。`FactorySpeedModel`的新版本现在看起来是这样的：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The test method could now be implemented as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法现在可以实施如下：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, the `calcSpeed()` method in `TrafficUnitWrapper` remains untested.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`TrafficUnitWrapper`中的`calcSpeed()`方法尚未经过测试。
- en: 'We could test the `trafficByLane()` method as a whole:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`trafficByLane()`方法作为一个整体进行测试：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, this would require you to create a stream of objects of `TrafficUnit`
    with fixed data:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这需要你创建具有固定数据的`TrafficUnit`对象流：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is not clear how the data in the `TrafficUnit` object resulted in a different
    speed value. Besides, we would need to add a variety of test data--for different
    vehicle types and other parameters--and that is a lot of code to write and maintain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不清楚`TrafficUnit`对象中的数据是如何导致不同的速度值的。此外，我们还需要添加各种测试数据——针对不同车辆类型和其他参数——而这需要编写和维护大量的代码。
- en: This means we need to revisit the design of the `trafficByLane()` method. To
    get confidence that the method will work correctly, we need to test each step
    of the calculations inside the method in isolation so that each test would require
    little input data and allow you to have a clear understanding of the expected
    results.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要重新审视`trafficByLane()`方法的设计。为了对方法正确工作的信心，我们需要单独测试方法内部计算的每一步，这样每个测试都只需要少量输入数据，并允许你对预期的结果有清晰的理解。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you look closely at the `trafficByLane()` method, you will notice that the
    problem is caused by the location of the calculation--inside the private class `TrafficUnitWrapper`.
    We can move it from there and create a new method of the `TrafficDensity` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看`trafficByLane()`方法，你会注意到问题是由计算的地点引起的——在私有类`TrafficUnitWrapper`内部。我们可以将其从那里移出，并为`TrafficDensity`类创建一个新的方法：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we can change its signature to this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其签名更改为这样：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add these two methods to the `TrafficUnitWrapper` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个方法添加到`TrafficUnitWrapper`类中：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now rewrite the stream pipeline like this (the line changed is in bold
    font):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像这样重写流管道（粗体字表示更改的行）：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By making the `calcSpeed()` method protected and assuming that the `Vehicle`
    class is tested in its own test class `VehicleTest`, we can now write `testCalcSpeed()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`calcSpeed()`方法设置为受保护的，并假设`Vehicle`类在其自己的测试类`VehicleTest`中测试，我们现在可以编写`testCalcSpeed()`：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The remaining functionality can now be tested by mocking the `calcSpeed()`
    method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过模拟`calcSpeed()`方法来测试剩余的功能：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This experience has made us aware that using an inner private class can make
    the functionality untestable in isolation. Let''s try and get rid of the `private`
    class `CountByLane`. This leads us to the third version of the `TrafficDensity3`
    class (we have shown the code that has changed in bold):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种经验让我们意识到，使用内部私有类可能会使功能在隔离状态下不可测试。让我们尝试去除`private`类`CountByLane`。这导致我们到达`TrafficDensity3`类的第三个版本（我们用粗体显示了已更改的代码）：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This change allows us to extend the class in the test:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改使我们能够扩展测试中的类：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It also allows us to change the test method `calcLaneNumber()` in isolation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许我们独立地更改测试方法`calcLaneNumber()`：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See also
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Using fixtures to populate data for testing
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定值来填充测试数据
- en: Behavioral testing
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测试
- en: Using fixtures to populate data for testing
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用固定值来填充测试数据
- en: In more complex applications (which use a database, for example), there is often
    a need to set up the same data before each test and clean it up after each test
    is run. Some parts of the data need to be set before each test method and cleaned afterwards.
    You'd also need to have another setup configured before you run the test class,
    and it should be cleaned up afterwards.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的应用程序（例如使用数据库的应用程序）中，通常需要在每次测试之前设置相同的数据，并在每次测试运行后清理。某些数据部分需要在每次测试方法之前设置，并在之后清理。你还需要在运行测试类之前配置另一个设置，并在之后清理。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To accomplish this, you can dedicate a method that does the setup by writing
    a `@Before` annotation in front of it. The corresponding cleaning method is identified
    by the `@After` annotation. Similar class-level methods are annotated by `@BeforeClass`
    and `@AfterClass`. Here is a quick demo of this. Add the following methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以编写一个设置方法，并在其前面写一个`@Before`注解。相应的清理方法由`@After`注解标识。类似的类级别方法由`@BeforeClass`和`@AfterClass`注解。以下是一个快速演示。添加以下方法：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you run the tests now, you''ll get the following result:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，你会得到以下结果：
- en: '![](img/fca629ca-04df-4c56-a42d-40b00d388119.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fca629ca-04df-4c56-a42d-40b00d388119.png)'
- en: Such methods that "fix" the test context are called **fixtures**. Notice that
    they have to be public, and the class-level setup/cleanup fixtures have to be
    static. The upcoming JUnit 5 plans to lift these constraints, though.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的方法被称为**固定值**，它们必须是公开的，并且类级别的设置/清理固定值必须是静态的。尽管即将到来的JUnit 5计划取消这些限制。
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A typical example of such a usage would be creating necessary tables before
    the first test method is run and removing them after the last method of the test
    class is finished. The setup/cleanup methods can also be used to create/close
    a database connection unless your code does it in the try-with-resources construct
    (refer to [Chapter 12](01ba0219-7bd3-4ad9-a856-ac2f81e98057.xhtml), *Memory Management
    and Debugging*).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法的典型例子是在第一个测试方法运行之前创建必要的表，并在测试类的最后一个方法完成后删除它们。设置/清理方法也可以用来创建/关闭数据库连接，除非你的代码在try-with-resources构造中这样做（请参阅[第12章](01ba0219-7bd3-4ad9-a856-ac2f81e98057.xhtml)，*内存管理和调试*）。
- en: 'Here is an example of the usage of fixtures (refer to [Chapter 6](41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml),
    *Database Programming* on how to set up a database for running it). Let''s assume
    we need to test the `DbRelatedMethods` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是固定值使用的一个示例（有关如何设置数据库以运行它的说明，请参阅[第6章](41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml)，*数据库编程*）。让我们假设我们需要测试`DbRelatedMethods`类：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We would like to make sure that this method always updates all the records
    of the `text` table with the provided value. Our first test is to update all the
    existing records:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想确保这个方法始终更新`text`表中的所有记录为提供的值。我们的第一个测试是更新所有现有记录：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This means that the table has to exist in the test database and should have
    a record in it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着表格必须在测试数据库中存在，并且应该在其中有一个记录。
- en: 'Our second test makes sure that all the records are updated even if there is
    more than one record, and each record contains a different value:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二次测试确保即使有多个记录，并且每个记录包含不同的值，所有记录都会被更新：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Both the tests use the same table, that is, `text`. Therefore, there is no
    need to drop it after each test. This is why we create and drop it at the class
    level:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试都使用相同的表格，即`text`。因此，在每次测试后没有必要删除它。这就是为什么我们在类级别上创建和删除它的原因：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This means that all we need to do is populate the table before each test and
    clean it up:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们只需要在每个测试之前填充表格并在测试后清理它：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Also, since we can use the same object for all the tests, let''s create it
    on the class level too (as the test class''s property):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们可以为所有测试使用相同的对象，让我们也在类级别上创建它（作为测试类的属性）：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we run all the tests of the `test` class now, the output would look like
    this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行`test`类的所有测试，输出将如下所示：
- en: '![](img/85cfcf20-c1a0-4a23-af85-6161b5635397.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85cfcf20-c1a0-4a23-af85-6161b5635397.png)'
- en: The printed messages allow you to trace the sequence of all the method calls
    and see that they are executed as expected.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的消息允许你追踪所有方法调用的顺序，并查看它们是否按预期执行。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipe in this chapter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下配方：
- en: Behavioral testing
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测试
- en: Behavioral testing
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为测试
- en: If you have read all the chapters and have looked at the code examples, you
    may have probably noticed that by now, we have discussed and built all the components
    necessary for a typical distributed application. Now is the time to put all the
    components together and see whether they cooperate as expected. This process is
    called integration.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了所有章节并查看过代码示例，你可能已经注意到现在，我们已经讨论并构建了典型分布式应用所需的所有组件。现在是时候将所有组件组合起来，看看它们是否按预期协作。这个过程被称为集成。
- en: While doing this, we will look closely at assessing whether the application
    behaves according to the requirements. In cases where functional requirements
    are presented in an executable form (using the Cucumber framework, for example),
    we can run them and check whether all the checks pass. Many software companies
    follow a behavior-driven development process and perform testing very early, sometimes
    even before any substantial amount of code is written (such tests fail, of course,
    but succeed as soon as the expected functionality is implemented). As mentioned
    already, early testing can be very helpful for writing focused, clear, and well-testable
    code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在做这件事的时候，我们将仔细评估应用程序是否按照要求运行。在功能需求以可执行形式呈现的情况下（例如使用Cucumber框架），我们可以运行它们并检查是否所有检查都通过。许多软件公司遵循行为驱动开发过程，并在代码编写早期进行测试，有时甚至在大量代码编写之前（当然，这些测试会失败，但一旦预期的功能实现，它们就会成功）。如前所述，早期测试对于编写专注、清晰且易于测试的代码非常有帮助。
- en: However, even without strict adherence to the *test-first* process, the integration
    phase naturally includes some kind of behavioral testing. In this recipe, we will
    see several possible approaches and specific examples related to this.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使没有严格遵循*测试驱动*过程，集成阶段自然也包括某种形式的行为测试。在这个配方中，我们将看到几个可能的途径和与这个相关的具体示例。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You might have noticed that in the course of this book, we have built several
    classes that compose an application that analyzes and models traffic. For your
    convenience, we have included all of them in the `com.packt.cookbook.ch15_testing` package.
    You''re already familiar with (from Chapters 2, 4, 5, and 7) the five interfaces
    in the `api` folder: `Car`, `SpeedModel`, `TrafficUnit`, `Truck`, and `Vehicle`.
    Their implementations are encapsulated inside classes called *factories* in the
    folder with the same name (used in Chapters 2, 4, 5, and 7): `FactorySpeedModel`,
    `FactoryTraffic`, and `FactoryVehicle`. These factories produced input for the
    functionality of the `AverageSpeed` classes ([Chapter 7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml),
    *Concurrent and Multithreaded Programming*) and `TrafficDensity` (based on [Chapter
    5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml), *Stream Operations and Pipelines*
    but created and discussed in the current chapter)--the core classes of our demo
    application. They produce the values that motivated the development of this particular
    application in the first place.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这本书的过程中，我们构建了几个类，它们组成一个分析并模拟交通的应用程序。为了方便起见，我们将它们全部包含在`com.packt.cookbook.ch15_testing`包中。你已经熟悉（从第2、4、5和7章）`api`文件夹中的五个接口：`Car`、`SpeedModel`、`TrafficUnit`、`Truck`和`Vehicle`。它们的实现封装在具有相同名称的文件夹中称为*工厂*的类中（在第2、4、5和7章中使用）：`FactorySpeedModel`、`FactoryTraffic`和`FactoryVehicle`。这些工厂为`AverageSpeed`类的功能提供了输入（[第7章](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml)，*并发和多线程编程*）和`TrafficDensity`（基于[第5章](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml)，*流操作和管道*，但在本章中创建和讨论）——我们演示应用程序的核心类。它们产生最初推动这个特定应用程序发展的值。
- en: The main functionality of the application is straightforward. For a given number
    of lanes and speed limit for each lane, `AverageSpeed` calculates (estimates)
    the actual speed of each lane (assuming all the drivers are behaving rationally,
    taking the lane according to their speed), while `TrafficDensity` calculates the number
    of vehicles in each lane after 10 sec (assuming all the cars start at the same
    time after the traffic light). The calculations are done based on the data from
    `numberOfTrafficUnits` vehicles collected at a certain location and time of the
    year. It does not mean that all the thousand vehicles were racing at the same
    time. These 1,000 measuring points have been collected over 50 years for approximately
    20 vehicles that drove at the specified intersection during the specified hour
    (which means one vehicle every three minutes on average).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的主要功能很简单。对于给定的车道数量和每条车道的速度限制，`AverageSpeed`计算（估计）每条车道的实际速度（假设所有驾驶员都表现理性，根据他们的速度选择车道），而`TrafficDensity`计算10秒后每条车道上的车辆数量（假设所有车辆在红灯后同时启动）。这些计算基于在特定位置和一年中的特定时间收集的`numberOfTrafficUnits`车辆的数据。这并不意味着所有一千辆车都在同一时间竞赛。这1,000个测量点在过去50年中收集了大约20辆车在指定小时（这意味着平均每三分钟一辆车）在指定交叉口行驶的数据。
- en: 'The overall infrastructure of the application is supported by the classes in
    the `process` folder: `Dispatcher`, `Processor`, and `Subscription` (we discussed
    their functionality and demonstrated them in [Chapter 7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml),
    *Concurrent and Multithreaded Programming* ). These classes allow distributed
    processing. The `Dispatcher` class sends a request for processing to the population
    of `Processors` in a pool, using the `Subscription` class. Each `Processor` class
    performs the task according to the request (using the `AverageSpeed` and `TraffciDensity` classes)
    and stores the results in the database (using the `DbUtil` class in the `utils`
    folder, based on the functionality discussed in [Chapter 6](41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml),
    *Database Programming*).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的整体基础设施由`process`文件夹中的类支持：`Dispatcher`、`Processor`和`Subscription`（我们在[第7章](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml)，*并发和多线程编程*）中讨论了它们的功能并进行了演示）。这些类允许分布式处理。`Dispatcher`类使用`Subscription`类将处理请求发送到池中的`Processors`群体。每个`Processor`类根据请求执行任务（使用`AverageSpeed`和`TrafficDensity`类）并将结果存储在数据库中（使用`utils`文件夹中的`DbUtil`类，基于第6章[41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml]，*数据库编程*中讨论的功能）。
- en: We have tested most of these classes as units. Now we are going to integrate
    them and test the application as a whole for correct behavior.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这些类作为单元进行了测试。现在我们将它们集成在一起，以整体测试应用程序的正确行为。
- en: The requirements were made up just for demo purposes. The goal was to have something
    well motivated (resembling real data) and at the same time simple enough to understand
    without special knowledge of traffic analysis and modeling.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求只是为了演示目的。目标是有一个有良好动机（类似于真实数据）的东西，同时足够简单，无需特殊知识即可理解交通分析和建模。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are several levels of integration. We need to integrate the classes and
    subsystems of the application and also integrate our application with the external
    system (the source of the traffic data developed and maintained by a third party).
    Here is an example of class-level integration (see the `demo1_class_level_integration()`
    method in the `Chapter15Testing` class):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个集成级别。我们需要集成应用程序的类和子系统，并将我们的应用程序与外部系统（由第三方开发和维护的交通数据源）集成。以下是一个类级别集成的示例（请参阅`Chapter15Testing`类中的`demo1_class_level_integration()`方法）：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we integrated each of the two main classes, namely `AverageSpeed`
    and `TrafficDensity`, with factories and implementation of their API interfaces.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将两个主要类，即`AverageSpeed`和`TrafficDensity`，与工厂和它们的API接口实现进行了集成。
- en: 'The results are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/da2c3168-be61-45cc-83e9-990473e412e2.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da2c3168-be61-45cc-83e9-990473e412e2.png)'
- en: Notice that the results are slightly different from one run to another. This
    is because the data produced by `FactoryTraffic` varies from one request to another.
    But, at this stage, we just have to make sure that everything works together and
    produce some more or less accurate-looking results. We have tested the code by
    units and have a level of confidence that it is doing what it is supposed to do.
    We will get back to the results' validation during the actual integration *testing* process,
    not during integration.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果在不同的运行中略有不同。这是因为`FactoryTraffic`产生的数据从一次请求到另一次请求是变化的。但在这个阶段，我们只需确保一切都能协同工作，并产生一些或多或少看起来准确的结果。我们已经通过单元测试了代码，并对它正在执行预期操作有一定的信心。我们将在实际集成测试过程中，而不是在集成过程中验证结果。
- en: 'After finishing the integration at the class level, see how the subsystems
    work together (see the `demo1_subsystem_level_integration()` method in the `Chapter15Testing`
    class):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成类级别的集成后，看看子系统是如何协同工作的（请参阅`Chapter15Testing`类中的`demo1_subsystem_level_integration()`方法）：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this code, you can see that we used `DBUtil` to create the necessary table
    that holds the input data and the results (produced and recorded by `Processor`).
    The `Dispatcher` class sends a request and inputs data to the objects of the `Processor` class,
    as shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你可以看到我们使用了`DBUtil`来创建必要的表，该表持有输入数据和结果（由`Processor`产生并记录）。`Dispatcher`类发送请求并将数据输入到`Processor`类的对象中，如所示：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `Subscription` class is used to send/get the message (refer to [Chapter
    7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml), *Concurrent and Multithreaded
    Programming* for a description of this functionality):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscription`类用于发送/获取消息（有关此功能的描述，请参阅第7章，*并发和多线程编程*）：'
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The processors are doing their job; we just need to wait for a few seconds
    (you might adjust this time if the computer you are using requires more time to
    finish the job) before we get the results (using DBUtil for reading the recorded
    results from the database):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器正在执行其任务；在我们得到结果（使用DBUtil从数据库读取记录的结果）之前，我们只需等待几秒钟（如果你使用的计算机需要更多时间来完成这项工作，你可能需要调整这个时间）：
- en: '![](img/065b3686-1952-49c0-a757-b0684adf772f.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/065b3686-1952-49c0-a757-b0684adf772f.png)'
- en: The names of the `Process` enum class point to the corresponding records in
    the `result` table in the database. Again, at this stage, we are primarily looking
    for getting any results at all, not at how correct the values are.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process`枚举类的名称指向数据库中`result`表中的对应记录。再次强调，在这个阶段，我们主要是在寻找得到任何结果，而不是结果的正确性。'
- en: 'After the successful integration between the subsystems of our application
    (based on the generated data from `FactoryTraffic`), we can try and connect to
    the external system that provides real traffic data. Inside `FactoryTraffic`,
    we would now switch from generating `TrafficUnit` objects to getting data from
    a real system:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序的子系统（基于`FactoryTraffic`生成的数据）成功集成后，我们可以尝试连接到提供真实交通数据的第三方外部系统。在`FactoryTraffic`内部，我们现在将切换到从真实系统中获取数据以生成`TrafficUnit`对象：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The switch can be implemented as a Boolean property in the class (as seen in
    the preceding code) or the project configuration property. We leave out the details
    of the connection to a particular source of real traffic data as this is not relevant
    to the purpose of this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该开关可以作为类中的一个布尔属性（如前述代码所示）或项目配置属性来实现。我们省略了连接到特定真实交通数据源的细节，因为这与本书的目的无关。
- en: The main focus at this stage has to be the performance and having a smooth data
    flow between the external source of real data and our application. After we have
    made sure that everything works and produces results (that look realistic) with
    satisfactory performance, we can turn to integration *testing* (with the actual
    results' assertion).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，主要关注点必须是性能，以及在外部真实数据源和我们的应用程序之间保持流畅的数据流。在确保一切正常工作并产生满意性能的结果（看起来很真实）之后，我们才能转向集成*测试*（对实际结果的断言）。
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For testing, we need to set the expected values, which we can then can compare
    with the (actual) values, produced by the application that processes real data.
    But real data change slightly from run to run, and an attempt to predict the resulting
    values either makes the test fragile or forces the introduction of a huge margin
    of error, which may effectively defeat the purpose of testing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，我们需要设置预期的值，然后我们可以将它们与由处理真实数据的应用程序产生的（实际）值进行比较。但是，真实数据在每次运行中都会略有变化，尝试预测结果值要么使测试变得脆弱，要么迫使引入巨大的误差范围，这可能会有效地抵消测试的目的。
- en: We cannot even mock the generated data (as we did in the case of unit testing)
    because we are at the integration stage and have to use the real data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至无法模拟生成数据（如我们在单元测试中所做的那样），因为我们处于集成阶段，必须使用真实数据。
- en: One possible solution would be to store the incoming real data and the result
    our application produced along with them in the database. Then, a domain specialist
    can walk through each record and assert whether the results are as expected.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是将传入的真实数据和我们的应用程序产生的结果存储在数据库中。然后，领域专家可以遍历每条记录并断言结果是否符合预期。
- en: 'To accomplish this, we introduced a boolean switch in the `TrafficDensity` class,
    so it records the input along with each unit of the calculations:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们在`TrafficDensity`类中引入了一个布尔开关，因此它记录了每个计算单元的输入：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We have also introduced a static property to keep the same database connection
    across all the class instances. Otherwise, the connection pool should be very
    big because, as you may recall from [Chapter 7](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml), *Concurrent
    and Multithreaded Programming*, the number of workers that execute the task in
    parallel grows with the growth of the amount of work to do.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还引入了一个静态属性，以在所有类实例之间保持相同的数据库连接。否则，连接池应该非常大，因为，如你从[第7章](e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml)，“并发和多线程编程”中可能记得的，执行并行任务的工人数会随着要完成的工作量的增长而增长。
- en: 'If you look at `DbUtils`, you will see a new method that creates the `data` table
    (designed to hold `TrafficUnits` coming from `FactoryTraffic`) and the `data_common` table
    that keeps the main parameters used for data requests and calculations: requested
    traffic units'' number, the date and geolocation of the traffic data, time in
    seconds (the point when the speed is calculated), and the speed limit for each
    lane (its size defines how many lanes we plan to use while modeling the traffic).
    Here is the code that we configure to do the recording:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`DbUtils`，你会看到一个创建`data`表的新方法（设计用于存储来自`FactoryTraffic`的`TrafficUnits`）和`data_common`表，该表保存用于数据请求和计算的主要参数：请求的交通单元数量、交通数据的日期和地理位置、以秒为单位的时间（计算速度的点）以及每条车道的速度限制（其大小定义了我们计划在建模交通时使用的车道数量）。以下是配置用于记录的代码：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After the recording is completed, we can turn the data over to a domain specialist
    who can assert the correctness of the application behavior.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 记录完成后，我们可以将数据转交给领域专家，他们可以断言应用程序行为的正确性。
- en: 'The verified data can now be used for integration testing. We can add another
    switch to `FactoryTrafficUnit` and force it to read the recorded data instead
    of the unpredictable real or generated ones:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 经验证的数据现在可用于集成测试。我们可以在`FactoryTrafficUnit`中添加另一个开关，并强制它读取记录的数据而不是不可预测的真实或生成数据：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you may have noticed, we have also added method `isEnoughData()` that checks
    whether there is enough recorded data:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们还添加了`isEnoughData()`方法，该方法检查是否有足够记录的数据：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will help avoid the unnecessary frustration of debugging the test problem,
    especially in the case of testing a more complex system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有助于避免调试测试问题的不必要挫折，尤其是在测试更复杂的系统时。
- en: 'Now we can predict not only the input data, but also the expected results that
    we can use to assert the application behavior. Both are now included in the `TrafficUnit`
    object. To be able to do this, we took advantage of the new Java interface feature
    discussed in [Chapter 2](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml), *Fast Track
    to OOP - Classes and Interfaces*, which is the default method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅可以预测输入数据，还可以预测我们可以用来断言应用程序行为的预期结果。这两者现在都包含在`TrafficUnit`对象中。为了能够做到这一点，我们利用了在[第2章](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml)中讨论的新Java接口功能，即《快速掌握面向对象
    - 类和接口》，这是默认方法：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So, we can attach the result to the input data. See the following method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将结果附加到输入数据上。请参见以下方法：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can attach the result to the `DbUtil` class and the `TrafficUnitImpl` class inside `DbUtil`
    too:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果附加到`DbUtil`类以及`DbUtil`内部的`TrafficUnitImpl`类：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can attach it inside the `DbUtil` class too.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将它附加到`DbUtil`类内部。
- en: 'Now we can write an integration test. First, we will test the speed model using
    the recorded data:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个集成测试。首先，我们将使用记录的数据来测试速度模型：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A similar test can be written for testing the speed calculation of the `AverageSpeed`
    class with real data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为测试`AverageSpeed`类的速度计算编写类似的测试，使用真实数据。
- en: 'Then, we can write an integration test for the class level:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为类级别编写集成测试：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Similar code can be written for the class level testing of class `TrafficDensity` too:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，也可以为`TrafficDensity`类的类级别测试编写代码：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we can write the integration test for the subsystem level as well:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以为子系统级别编写集成测试：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All of them can be run successfully now and may be used for application regression
    testing any time later.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些现在都可以成功运行，并且可以在以后任何时候用于应用程序回归测试。
- en: An automated integration test between our application and the source of the
    real traffic data can be created only if the latter has a test mode from where
    the same flow of data can be sent our way so we can use them in the same manner
    we use recorded data (which is essentially the same thing).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当真实交通数据的来源有一个测试模式，可以从那里发送相同的数据流到我们这里，以便我们可以像使用记录的数据那样使用它们（这本质上是一回事），才能创建我们应用程序和真实交通数据源之间的自动化集成测试。
- en: One parting thought. All of this integration testing is possible when the amount
    of processing data is statistically significant. This is because we do not have
    full control over the number of workers and how the JVM decides to split the load.
    It is quite possible that on a particular occasion, the provided code would not
    work. In such a case, try to increase the number of requested traffic units. This
    will ensure more space for the load-distributing logic.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个额外的想法。所有这些集成测试只有在处理数据的数量具有统计学意义时才可行。这是因为我们没有完全控制工作者的数量以及JVM如何决定分配负载。在特定情况下，提供的代码可能不会工作。在这种情况下，尝试增加请求的交通单元数量。这将确保有更多的空间用于负载分配逻辑。
