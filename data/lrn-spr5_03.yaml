- en: Chapter 3. Accelerate with Spring DAO
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章。使用Spring DAO加速
- en: In the second chapter, we discussed in depth about dependency injection. Obviously,
    we discussed various ways to use DI in the configuration files as well as using
    annotations, but still somewhere due to unavailability of real time application
    it was incomplete. We were not having any choice as these were the most important
    basics, which each of Spring framework developer should be aware of. Now, we will
    start with handling database which is the backbone of application using the co
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章节中，我们深入讨论了依赖注入。显然，我们讨论了在配置文件中以及使用注解的各种使用DI的方法，但由于缺乏实时应用程序，这些讨论仍然不完整。我们没有其他选择，因为这些都是每个Spring框架开发者都应该了解的最重要的基础知识。现在，我们将开始处理数据库，这是应用程序的核心。
- en: 'nfigurations which we discussed. In this chapter we will discuss the following
    points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下配置：
- en: We will discuss about DataSource and its configuration using JNDI, pooled DataSource,
    and JDBCDriver based DataSource
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论关于DataSource及其使用JNDI、池化DataSource和JDBCDriver based DataSource的配置。
- en: We will learn how to integrate database in the application using DataSource
    and JDBCTemplate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何使用DataSource和JDBCTemplate将数据库集成到应用程序中。
- en: Understanding ORM and its configuration in application using SessionFactory
    will be the next point to discuss
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来我们将讨论如何使用SessionFactory在应用程序中理解ORM及其配置。
- en: We will configure HibernateTemplate to talk with database using ORM.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将配置HibernateTemplate以使用ORM与数据库通信。
- en: We will cover configuring cache manager to enable the support of caching the
    data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论如何配置缓存管理器以支持缓存数据。
- en: As we are well aware that, the database gives easy structuring of the data facilitating
    easy access using various ways. Not only many ways are available but also there
    are number of databases available in market. On one hand it's good to have many
    options of databases but on other its complex as each of them needs to handle
    separately. The Java application on enormous stages needs the persistency for
    accessing, updating, deleting, adding the records in database. JDBC APIs helps
    in accessing such records through drivers. JDBC provides the low level database
    operations as defining, opening and closing the connections, creation of statements,
    iterating through the ResultSet to fetch the data, processing the exceptions and
    many more. But at one point, this became repetitive operation and tightly coupled.
    The Spring Framework gives loosely coupled, high level, clean solution with a
    range of customized exceptions using DAO design pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，数据库为数据提供了易于结构化的方式，从而可以使用各种方法轻松访问。不仅有许多可用的方法，市场上还有许多不同的数据库。一方面，拥有多种数据库选项是好事，但另一方面，因为每个数据库都需要单独处理，所以这也使得事情变得复杂。在Java应用程序的庞大阶段，需要持久性来访问、更新、删除和添加数据库中的记录。JDBC
    API通过驱动程序帮助访问这些记录。JDBC提供了诸如定义、打开和关闭连接，创建语句，通过ResultSet迭代获取数据，处理异常等低级别的数据库操作。但是，到了某个点，这些操作变得重复且紧密耦合。Spring框架通过DAO设计模式提供了一种松耦合、高级、干净的解决方案，并有一系列自定义异常。
- en: How Spring handles database?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring如何处理数据库？
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In Java application the developers generally uses a concept of utility class
    to create, open and close database connection. A pretty sound, smart and reusable
    way for connection management but still the application is tightly coupled with
    the utility class. Any change in the either the database or its connectivity as
    URL, username, password or schema, it need to be changed in the class. This needs
    to be followed by the recompilation and redeployment of the code. In such scenario
    externalizing the connection parameters will be a good solution. We cannot externalise
    the Connection object, that still has to be managed by the developer and so do
    the exceptions while handling it. Spring has a elegant, loosely coupled ways to
    manage the connection using the DataSource at centre.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java应用程序中，开发者通常使用一个工具类概念来创建、打开和关闭数据库连接。这是一种非常可靠、智能且可重用的连接管理方式，但应用程序仍然与工具类紧密耦合。如果数据库或其连接性（如URL、用户名、密码或模式）有任何更改，需要在类中进行更改。这需要重新编译和部署代码。在这种情况下，外部化连接参数将是一个好的解决方案。我们无法外部化Connection对象，这仍然需要开发者来管理，同样处理它时出现的异常也是如此。Spring有一种优雅的方式来管理连接，使用位于中心的DataSource。
- en: The DataSource
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DataSource
- en: 'The DataSource is the factory for data source connections similar to the DriverManager
    in JDBC who helps for Connection management. Following are some of the implementations
    which can be used in the application to obtain the Connection object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源是数据源连接的工厂，类似于JDBC中的DriverManager，它有助于连接管理。以下是一些可以在应用程序中使用的实现，以获取连接对象：
- en: '**DriverManagerDataSource** : The `DriverManager` class provides a simple implementation
    of the DataSource to be used in test or standalone application which enable a
    new Connection object on every request via getConnection().'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DriverManagerDataSource**：该类提供了一个简单的DataSource实现，用于在测试或独立应用程序中，每次请求通过getConnection()获取一个新的Connection对象。'
- en: '**SingleConnectionDataSource**: The class is an implementation of the SmartDatSource
    which gives a single Connection object which doesn''t get closed after its use.
    It''s useful only in single threaded applications and in making testing easy outside
    of the application server.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SingleConnectionDataSource**：这个类是SmartDatSource的一个实现，它提供了一个不会在使用后关闭的单一Connection对象。它只适用于单线程应用程序，以及在应用程序服务器之外简化测试。'
- en: '**DataSourceUtils**: This is a helper class who has static methods for obtaining
    the database Connection from DataSource.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DataSourceUtils**：这是一个辅助类，它有静态方法用于从DataSource获取数据库连接。'
- en: '**DataSourceTransactionManager**: This class is an implementation of the PlatformTransactionManager
    for a Connection per data source.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DataSourceTransactionManager**：这个类是PlatformTransactionManager的一个实现，用于每个数据源的连接。'
- en: Configuring DataSource
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置数据源
- en: 'The DataSource can be configured by following ways in the application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源可以通过以下方式在应用程序中配置：
- en: '**Obtained from JNDI look up** : Spring helps in maintaining large scale JavaEE
    application which run in application servers like Glassfish, JBoss, Wlblogic,
    Tomcat. All these servers support facility to configure the pool of data sources
    which can be acquired by the Java Naming Directory Interface (JNDI) look up helps
    in better performance. The jee namespace can be used to obtain data source configured
    in the application as shown below:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从JNDI查找获取**：Spring有助于维护在应用程序服务器（如Glassfish、JBoss、Wlblogic、Tomcat）中运行的大型Java
    EE应用程序。所有这些服务器都支持通过Java命名目录接口（JNDI）查找配置数据源池的功能，这有助于提高性能。可以使用以下方式获取在应用程序中配置的数据源：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Where:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中：
- en: '**jndi-name** : specifies name of the resource configured on server in JNDI'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jndi-name**：指定在JNDI中配置的服务器上的资源名称。'
- en: '**id** : id of the bean which gives object of DataSource'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id**：bean的id，提供DataSource对象。'
- en: '**resource-ref** : specifies whether to prefix with java:comp/env or not.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resource-ref**：指定是否需要前缀java:comp/env。'
- en: 'Fetched from the pooled connection : Spring doesn''t have pooled data source
    but, we can configure pooled data source provided by Jakarta Commons Database
    Connection Pooling. The DBCP provided BasicDataSource can be configured as,'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从池中获取连接：Spring没有池化数据源，但是，我们可以配置由Jakarta Commons Database Connection Pooling提供的池化数据源。DBCP提供的BasicDataSource可以配置为，
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Where:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中：
- en: '**initialSize**: specifies how many connections to be created when the pool
    is started'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**initialSize**：指定了当池启动时应创建的连接数量。'
- en: '**maxActive**: specifies how many connections can be allocated from the pool.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxActive**：指定可以从池中分配的连接数量。'
- en: Along with these attributes we can even specify the time which needs to wait
    till the connection is returned from the pool(maxWait), the maximum/ minimum number
    of connections that can be idle in the pool(maxIdle/ minIdle), the maximum number
    of prepared statements that can be allocated from the statement pool (maxOperationPreparedStatements).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了这些属性，我们还可以指定等待连接从池中返回的时间（maxWait），连接可以在池中空闲的最大/最小数量（maxIdle/minIdle），可以从语句池分配的最大预处理语句数量（maxOperationPreparedStatements）。
- en: 'With the help of JDBC driver : One can use of the following class to configure
    the simplest way to get and object of the DataSource:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDBC驱动器：可以利用以下类以最简单的方式获取DataSource对象：
- en: '* **SingleConnectionDataSource**: As we already discussed it returns single
    connection.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '* **SingleConnectionDataSource**：正如我们已经在讨论中提到的，它返回一个连接。'
- en: '* **DriverManagerDataSource**: It returns a new connection object on a request.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '* **DriverManagerDataSource**：它在一个请求中返回一个新的连接对象。'
- en: 'The DriverMangerDataSource configuration can be done as follows:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以按照以下方式配置DriverMangerDataSource：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SingleConnectionDataSource is suiltable for small single threaded applications.
    DriverManagerDataSource supports multithreaded application but hampers the performance
    due to managing number of connections. It's recommended to use pooled data source
    for better performance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单连接数据源适用于小型单线程应用程序。驱动管理数据源支持多线程应用程序，但由于管理多个连接，会损害性能。建议使用池化数据源以获得更好的性能。
- en: Let's develop a sample demo using loosely coupled modules so that we will understand
    the practical aspects of Spring framework application development.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个使用松耦合模块的示例demo，以便我们了解Spring框架应用程序开发的实际方面。
- en: The DataSource facilitates handling of connection with database so it needs
    to be injected in the module. The choice of using setter DI or constructor DI
    can be totally decided by you as you are well aware of both of these dependency
    injections. We will use setter DI. Instead of starting from the class we will
    start by considering interface as it's the best way to do programming by contract.
    The interfaces can have multiple implementations. So the use of interface and
    Spring configuration helps to achieve loosely coupled modules. We will declare
    the methods for database operations, you are free to choose the signature. But
    make sure that they will be testable. As loose coupling is major feature of the
    framework the application will also demonstrate why we keep on saying loosely
    coupled modules can be easily written using Spring? You can use any database but
    we will use MySQL throughout the book. Whatever the database you choose make sure
    to install it before moving ahead So let's start by following the steps!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源有助于处理与数据库的连接，因此需要在模块中注入。使用setter DI或构造函数DI的选择完全由您决定，因为您很清楚这两种依赖注入。我们将使用setter
    DI。我们从考虑接口开始，因为这是根据合同进行编程的最佳方式。接口可以有多个实现。因此，使用接口和Spring配置有助于实现松耦合模块。我们将声明数据库操作的方法，您可以选择签名。但请确保它们可以被测试。由于松耦合是框架的主要特性，应用程序也将演示为什么我们一直在说松耦合模块可以使用Spring轻松编写？您可以使用任何数据库，但本书将使用MySQL。无论您选择哪种数据库，都要确保在继续之前安装它。让我们按照步骤开始！
- en: 'Case 1: using XML configuration of DriverManagerDataSource'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 案例1：使用DriverManagerDataSource的XML配置
- en: 'Create a Core Java application as Ch03_DataSourceConfiguration and add to it
    jar for Spring and JDBC as shown in the outline of the application below:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Ch03_DataSourceConfiguration的核心Java应用程序，并添加Spring和JDBC的jar，如下所示：
- en: '![](img/image_03_001.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_001.png)'
- en: 'Create a Book POJO in com.ch03.packt.beans package as shown below:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch03.packt.beans包中创建一个Book POJO，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Declare an interface BookDAO in com.ch03.packt.dao package. (DAO means Data
    access Object).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.ch03.packt.dao包中声明一个BookDAO接口。（DAO表示数据访问对象）。
- en: 'Add to it a method for adding a book to the database. The code will be as shown
    below:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库中添加书籍的方法如下所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an implementation class for BookDAO as BookDAOImpl and add a data member
    of type DataSource in the class as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为BookDAO创建一个实现类BookDAOImpl，并在类中添加一个DataSource类型的数据成员，如下所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Don't forget to use standard bean naming conventions.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记使用标准的bean命名约定。
- en: As we are following setter injection write or generate setters for DataSource.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们采用setter注入，请为DataSource编写或生成setter方法。
- en: 'The overridden method will deal with getting the connection from DataSource
    and using PreaparedStatement insert a book object in the table as we do in JDBC
    as shown in the code below:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖的方法将处理从DataSource获取连接，并使用PreaparedStatement将book对象插入表中，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create connection.xml in classpath to configure the beans.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径中创建connection.xml以配置beans。
- en: Now the question will be how many beans to be declared and what has to be their
    id's?
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在问题变成了需要声明多少个bean以及它们各自的id是什么？
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A very simple thumb rule: First find out class to configure and then what are
    its dependencies?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的经验法则：首先找出要配置的类，然后找出它的依赖关系是什么？
- en: 'Here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是：
- en: '* A bean for BookDAOImpl'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个BookDAOImpl的bean。**'
- en: '* BookDAOImpl has DataSource as a dependency so a bean for DataSource.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**BookDAOImpl依赖于DataSource，因此需要一个DataSource的bean。**'
- en: You will be wondering that DataSource is an interface! So, how could we create
    and inject its object? Yes, this is what our point is! This is what we are talking
    about loosely coupled modules. The DataSource implementation which we are using
    here is, DriverManagerDataSource. But, if we inject directly DriverManagerDataSource
    then the class will be tightly coupled on it. Also, if tomorrow instead of using
    DriverManagerDataSource the team decides to use some other implementation then
    the code has to be changed which leads to recompilation and redeployment. That
    mean the better solution will be using interface and injecting its implementation
    from the configuration.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶DataSource是一个接口！那么我们是如何创建并注入其对象的呢？是的，这就是我们观点所在！这就是我们所说的松耦合模块。在这里使用的DataSource实现是DriverManagerDataSource。但如果我们直接注入DriverManagerDataSource，那么类将与它紧密耦合。此外，如果明天团队决定使用其他实现而不是DriverManagerDataSource，那么代码必须更改，这导致重新编译和重新部署。这意味着更好的解决方案将是使用接口，并从配置中注入其实现。
- en: 'The id''s can be of developers choice, but don''t neglect to take the advantage
    of auto wiring and then accordingly set the id. Here we will use auto wiring ''byName''
    so choose the id''s accordingly. (If you are confused or want to dig about auto
    wiring you can refer the previous chapter.) So the final configuration in XML
    will be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: id可以是开发者的选择，但不要忽略利用自动装配的优势，然后相应地设置id。这里我们将使用自动装配'byName'，所以请选择相应的id。（如果您困惑或想深入了解自动装配，可以参考上一章。）因此，XML中的最终配置将如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You use may need to customize the URL, username, password to match your connection
    parameters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要根据您的连接参数自定义URL、用户名和密码。
- en: 'Normally, the DAO layer will be invoked by the Service layer but here we are
    not dealing with it as the application proceed we will add it. As we yet not discussed
    about testing we will write a code with main function to find out the output of
    it. The main function will get BookDAO bean and invoke on it a method to insert
    the Book. If the value of the row returned by the implementation code is greater
    than zero the book got successfully added otherwise not. Create a class MainBookDAO
    and add the following code to it:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，DAO层将由服务层调用，但在这里我们不处理它，因为随着应用程序的进行，我们将添加它。由于我们还没有讨论测试，我们将编写带有main函数的代码来找出它的输出。main函数将获取BookDAO
    bean并在其上调用插入Book的方法。如果实现代码返回的行值大于零，则书籍成功添加，否则不添加。创建一个名为MainBookDAO的类，并向其添加以下代码：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you keenly observed though we configure object of BookDAOImpl we are accepting
    it in BookDAO interface which helps in writing flexible code where the main code
    is unaware of in actual whose object is giving implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察我们会配置BookDAOImpl对象，我们是在BookDAO接口中接受它，这有助于编写灵活的代码，在这种代码中，主代码实际上不知道是哪个对象在提供实现。
- en: 'Open your MYSQL console, use credentials to login. Fire query to create BookDB
    schema and Book table as shown below:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的MYSQL控制台，使用凭据登录。运行以下查询创建BookDB架构和Book表：
- en: '![](img/image_03_002.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_002.png)'
- en: All set to execute the code to get "book inserted successfully" on console.
    You can fire "select * from book" in MySQL to get the book details as well.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切都准备好了，执行代码以在控制台获得“book inserted successfully”（书籍插入成功）的提示。你也可以在MySQL中运行“select
    * from book”来获取书籍详情。
- en: 'Case2: Using Annotations for DriverManagerDataSource'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Case2：使用注解DriverManagerDataSource
- en: 'We will use the same Java application Ch03_DataSourceConfiguration developed
    in Case1:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在Case1中开发的同一个Java应用程序Ch03_DataSourceConfiguration：
- en: Declare a class BookDAO_Annotation implementing BookDAO in com.packt.ch03.dao
    package and annotate it with @Repository as it deals with database and specify
    id as 'bookDAO_new'.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个类BookDAO_Annotation，在com.packt.ch03.dao包中实现BookDAO，并用@Repository注解它，因为它处理数据库，并指定id为'bookDAO_new'。
- en: Declare a data member of type DataSource and annotate it with @Autowired to
    support auto wiring.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个类型为DataSource的数据成员，并用@Autowired注解它以支持自动装配。
- en: Don't forget to use standard bean naming conventions.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记使用标准的bean命名约定。
- en: 'The overridden method will deal database to insert book in table. The code
    will be as shown below:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被覆盖的方法将处理数据库将书籍插入表中。代码将如下所示：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can edit the same connection.xml from Case1 but that may complex the configuration.
    So, let''s create connection_new.xml in classpath to configure the instructions
    for container to consider annotation and search for stereotype annotations as
    follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以编辑Case1中的同一个connection.xml，但这可能会使配置复杂。所以，让我们在类路径中创建connection_new.xml，以配置容器考虑注解并搜索如下立体注解：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To find out addition of context namespace and using annotation you can refer
    to second chapter.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找出如何添加上下文命名空间和使用注解，请参考第二章。
- en: 'It''s now time to find the output with the help of following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候通过以下代码找到输出：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Execute the code to add the book in database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码以将书籍添加到数据库中。
- en: You may have observed that, we never come to know who is providing the implementation
    of the JDBC code and the injection is loosely coupled due to configuration. Though,
    we will able to insert the data in database we will be still involved in the JDBC
    code like getting Connection, creating Statements from it and then setting the
    values for the columns of table where we want to insert the records. This is very
    preliminary demo which is rarely used in JavaEE applications. The better solution
    is to use template classes provided by Spring.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们从未知道是谁提供了JDBC代码的实现，并且由于配置，注入是松耦合的。尽管如此，我们还是能够将数据插入数据库，但仍然需要处理JDBC代码，例如获取连接、从它创建语句，然后为表的列设置值，以插入记录。这是一个非常初步的演示，很少在JavaEE应用程序中使用。更好的解决方案是使用Spring提供的模板类。
- en: Using Template classes to perform JDBC operations
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模板类执行JDBC操作
- en: Template classes provides an abstract way to define operations by giving rid
    from common issues as opening and maintaining the connection, the boiler plate
    code as getting the Statement objects. Spring provides many such template classes
    where dealing with the JDBC, JMS and Transaction management becomes easy than
    ever before. JdbcTemplate is one of such core component by Spring who helps in
    handling JDBC. To handle JDBC we can use any one of the following three templates.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模板类提供了一种抽象的方式来定义操作，通过摆脱常见的打开和维护连接、获取Statement对象等冗余代码的问题。Spring提供了许多这样的模板类，使得处理JDBC、JMS和事务管理变得比以往任何时候都容易。JdbcTemplate是Spring的这样一个核心组件，它帮助处理JDBC。要处理JDBC，我们可以使用以下三种模板之一。
- en: JDBCTemplate
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JDBCTemplate
- en: The JdbcTemplate helps the developers to concentrate on the core business logic
    of the application without getting involved in how to open or mange the Connection.
    They don't have to be worried about what if they forget to release connection?
    All these things will be elegantly done by the JdbcTemplate for you. It provides
    specifying indexed parameters to use in SQL queries for JDBC operations as we
    normally do in PreparedStatements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JdbcTemplate帮助开发者专注于应用程序的核心业务逻辑，而无需关心如何打开或管理连接。他们不必担心如果忘记释放连接会怎样？所有这些事情都将由JdbcTemplate为您优雅地完成。它提供了指定索引参数以在SQL查询中使用JDBC操作的方法，就像我们在PreparedStatements中通常做的那样。
- en: SimpleJdbcTemplate
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SimpleJdbcTemplate
- en: This is very similar to JDBCTemplate along with an advantage of Java5 features
    as generics, var-args, autoboxing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这与JDBCTemplate非常相似，同时具有Java5特性的优势，如泛型、可变参数、自动装箱。
- en: NamedParameterJdbcTemplate
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NamedParameterJdbcTemplate
- en: The JdbcTemplate uses index to specify the values of the parameters in SQL which
    may become complicate to remember the parameters with their indexes. If you are
    uncomfortable with numbers or more number of parameters to set we can use the
    NamedParamterJdbcTemplate who facilitates use of named-parameters to specify parameters
    in the SQL. Each parameter will have a named prefixed with a colon(:). We will
    see the syntax shortly while developing the code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JdbcTemplate使用索引来指定SQL中参数的值，这可能使记住参数及其索引变得复杂。如果您不习惯数字或需要设置更多参数，我们可以使用NamedParamterJdbcTemplate，它允许使用命名参数来指定SQL中的参数。每个参数都将有一个以冒号(:)为前缀的命名。我们将在开发代码时看到语法。
- en: Let's demonstrate these templates one by one.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一演示这些模板。
- en: Using JdbcTemplate
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用JdbcTemplate
- en: We will use the similar outline of the project used in Ch03_DataSourceConfiguration
    and redevelop it with the help of following steps,
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与Ch03_DataSourceConfiguration中相似的项目结构，并按照以下步骤重新开发它，
- en: Create a new Java application named Ch03_JdbcTemplate and add jar which we used
    in Ch03_DataSourceIntegration. Along with it add spring-tx-5.0.0.M1.jar as well.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Ch03_JdbcTemplate的新Java应用程序，并添加我们在Ch03_DataSourceIntegration中使用的jar文件。同时添加spring-tx-5.0.0.M1.jar。
- en: Create or copy Book in com.packt.ch03.beans package.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch03.beans包中创建或复制Book。
- en: Create or copy BookDAO in com.packt.ch03.dao package.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch03.dao包中创建或复制BookDAO。
- en: Create BookDAOImpl_JdbcTemplate in com.packt.ch03.dao package and add to it
    JdbcTemplate as data member.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch03.dao包中创建BookDAOImpl_JdbcTemplate，并向其添加JdbcTemplate作为数据成员。
- en: Annotate the class with @Repository and data member JdbcTemplate with @Autowired
    annotation respectively.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别用@Repository注解类，用@Autowired注解数据成员JdbcTemplate。
- en: 'The overridden methods will deal with insertion of Book in table. But we don''t
    have to get the connection. Also we will not do creation and setting the parameters
    of the PreparedStatement. The JdbcTemplate will do it for us. Things will be pretty
    clear from the code shown below:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖的方法将处理表中书籍的插入。但我们不需要获取连接。同时，我们也不会创建并设置PreparedStatement的参数。JdbcTemplate会为我们完成这些工作。从下面的代码中，事情会变得相当清晰：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The JdbcTemplate has update() method where the developers need to pass the SQL
    query followed by the values of the parameters in the query. So, we can use it
    for insertion, updation as well as deletion of data. Rest all will be done by
    the template. If you keenly observe, we are not handling any exceptions. We forgot
    to? No, we don't care to handle them as Spring provides the DataAccessException
    which is unchecked exception. So leave the worries. In the upcoming pages we will
    discuss about the exceptions Spring provides.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JdbcTemplate有一个update()方法，开发人员需要在该方法中传递SQL查询以及查询参数的值。因此，我们可以用它来插入、更新和删除数据。其余的都由模板完成。如果你仔细观察，我们没有处理任何异常。我们忘记了吗？不，我们不关心处理它们，因为Spring提供了DataAccessException，这是一个未检查的异常。所以放心吧。在接下来的页面中，我们将讨论Spring提供的异常。
- en: 'Let''s add method in the code for updating book''s price as well as deleting
    the book. Don''t forget to change the interface implementation first. The code
    is as shown below:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中添加一个更新书籍价格以及删除书籍的方法。不要忘记首先更改接口实现。代码如下：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s add beans configuration file as connection_new.xml. You can simply copy
    it from Ch03_DataSourceIntegration project. We are using JdbcTemplate who has
    DataSource as its dependency. So, we need to configure two beans one for DataSource
    and another for JdbcTemplate as shown below:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在connection_new.xml中添加一个beans配置文件。你可以简单地从Ch03_DataSourceIntegration项目中复制它。我们使用的是JdbcTemplate，它依赖于DataSource。因此，我们需要像下面所示配置两个bean，一个用于DataSource，另一个用于JdbcTemplate：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Write the code to get ''bookDAO_jdbcTemplate'' bean and execute the operations
    in MainBookDAO_operations as shown below:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以获取'bookDAO_jdbcTemplate' bean，并在MainBookDAO_operations中执行操作，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using NamedParameterJdbc Template
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用NamedParameterJdbc模板
- en: We will use Ch03_JdbcTemplates to add new class for this demonstration with
    the help of following steps.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Ch03_JdbcTemplates来添加一个新的类进行此次演示，具体步骤如下。
- en: Add BookDAO_NamedParameter class in com.packt.ch03.dao package which is implementing
    BookDAO and annotate it with @Repository as we did earlier.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch03.dao包中添加BookDAO_NamedParameter类，它实现了BookDAO，并用我们之前所做的@Repository注解。
- en: Add to it NamedParameterJdbcTemplate as a data member and annotate it with @Autowired.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加一个NamedParameterJdbcTemplate作为数据成员，并用@Autowired注解它。
- en: 'Implement the overridden methods to perform JDBC operations with the help of
    update(). The NamedParameterJdbcTemplate supports giving names to the parameters
    in SQL query. Find the below query to add Book:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用update()实现覆盖方法以执行JDBC操作。NamedParameterJdbcTemplate支持在SQL查询中给参数命名。找到以下查询以添加书籍：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each parameter has to be prefixed with colon as :name_of_parameter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都必须以前缀冒号：name_of_parameter。
- en: 'If these are the names of the parameters then these have to be registered so
    that the framework will place them in the query. To do this we have to create
    a Map where these parameter names acts as keys whose values will be specified
    by the developer. The following code will give a clear idea:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这些是参数的名称，那么这些参数需要注册，以便框架将它们放置在查询中。为此，我们必须创建一个Map，其中这些参数名称作为键，其值由开发者指定。以下代码将给出清晰的概念：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a bean in connection_new.xml for NamedParameterJdbcTemplate as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在connection_new.xml中为NamedParameterJdbcTemplate添加一个bean，如下所示：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In all other demos we have used setter injection but here we cannot use setter
    injection, as the class doesn't have default constructor. So, use constructor
    dependency injection only.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他所有示例中我们都使用了setter注入，但在这里我们无法使用setter注入，因为该类没有默认构造函数。所以，只使用构造函数依赖注入。
- en: 'Use the MainBookDAO_operations.java developed to test how JdbcTemplate work.
    You just have to update the statement which will get **BookDAO_named** bean to
    execute operations. The changed code will be:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用开发的MainBookDAO_operations.java来测试JdbcTemplate的工作。你只需要更新将获取**BookDAO_named**
    bean以执行操作的语句。更改后的代码将是：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can find the complete code in MainBookDAO_NamedTemplate.java
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在MainBookDAO_NamedTemplate.java中找到完整的代码。
- en: Execute the code to get success message.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码以获取成功消息。
- en: In small Java application the code will have less number of DAO classes. So,
    to the developers handling DAOs with Template classes in each of them to handle
    JDBC will not be complex. This also leads to duplication of the code. But the
    complexity becomes difficult to handle when we deal with enterprise applications
    with more number of classes. The alternative will be instead of injecting the
    template class in each of the DAO, choose a parent who has the ability as that
    of Template classes. Spring has JdbcDaoSupport, NamedParameterJdbcSupport as such
    supportive DAOs. These abstract support class provide a common base leaving out
    repetition of the code, wiring of properties in each DAO.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在小型Java应用程序中，代码将具有较少的DAO类。因此，对于每个DAO使用模板类来处理JDBC，对开发人员来说不会很复杂。这也导致了代码的重复。但是，当处理具有更多类的企业应用程序时，复杂性变得难以处理。替代方案将是，不是在每个DAO中注入模板类，而是选择一个具有模板类能力的父类。Spring具有JdbcDaoSupport，NamedParameterJdbcSupport等支持性DAO。这些抽象支持类提供了一个公共基础，避免了代码的重复，在每个DAO中连接属性。
- en: 'Let''s take the same project ahead to use supportive DAOs. We will use JdbcDaoSupport
    class to understand the practical aspects:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续同一个项目使用支持DAO。我们将使用JdbcDaoSupport类来了解实际方面：
- en: Add BookDAO_JdbcTemplateSupport.java in com.packt.ch03.dao which extends JdbcDaoSupport
    and implementing BookDAO.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch03.dao中添加BookDAO_JdbcTemplateSupport.java，它继承了JdbcDaoSupport并实现了BookDAO。
- en: 'Override the methods from interface which will deal with database. The BookDAO_JdbcTemplateSupport
    class inherits JdbcTemplate from JdbcDaoSupport. So the code remains same as we
    did in using JdbcTemplate with a little change. The JdbcTemplate has to be accessed
    through getter method as shown by underlining in the code below:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从接口覆盖方法，这些方法将处理数据库。BookDAO_JdbcTemplateSupport类从JdbcDaoSupport继承了JdbcTemplate。所以代码保持不变，就像我们使用JdbcTemplate时一样，稍作改动。必须通过下面的代码中加粗的getter方法访问JdbcTemplate：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To use DAO classes the dependencies will be injected through constructor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DAO类时，依赖将通过构造函数注入。
- en: 'We already had discussed couple of pages back about handling the exceptions
    in short. Let''s find out more in detail about it. The JDBC code forces handling
    of exception through checked exceptions. But, they are generalized and handled
    only through DataTrucationException, SQLException, BatchUpdateException, SQLWarning.
    Opposite to JDBC Spring support various unchecked exceptions for different scenarios
    providing specialized information. The following table shows few of them which
    we may need frequently:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在几页中讨论了关于简短处理异常的内容。让我们更详细地了解它。JDBC代码强制通过检查异常处理异常。但是，它们是泛化的，并且仅通过DataTrucationException，SQLException，BatchUpdateException，SQLWarning处理。与JDBC相反，Spring支持各种未检查异常，为不同场景提供专门的信息。以下表格显示了我们可能需要频繁使用的其中一些：
- en: '| **Spring Exceptions** | **When they get thrown?** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **Spring异常** | **它们什么时候被抛出？** |'
- en: '| DataAccessException | This is the root of the Spring Exception hierarchy
    we can use it for all situations. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 数据访问异常 | 这是Spring异常层次结构的根，我们可以将其用于所有情况。 |'
- en: '| PermissionDeniedDataAccessEception | When trying to access the data without
    correct authorization to access the data |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 权限被拒数据访问异常 | 当尝试在没有正确授权的情况下访问数据时 |'
- en: '| EmptyResultDataAccessException | On no row returned from the database but
    at least one is expected. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 空结果数据访问异常 | 从数据库中没有返回任何行，但至少期望有一个。 |'
- en: '| IncorrectResultSizeDataAccessException | When the result size is mismatching
    with the expected result size. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 结果大小不匹配数据访问异常 | 当结果大小与期望的结果大小不匹配时。 |'
- en: '| TypeMismatchDataAccessException | On mismatch of the data type between Java
    and database. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 类型不匹配数据访问异常 | Java和数据库之间的数据类型不匹配。 |'
- en: '| CannotAccqireLockException | On failure to acquire the lock while an update
    of the data |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 无法获取锁异常 | 在更新数据时未能获取锁 |'
- en: '| DataRetrivalFailureException | When searching and retrieving of the data
    using Id using ORM tool |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 数据检索失败异常 | 当使用ORM工具通过ID搜索和检索数据时 |'
- en: While handling the database operations using Spring DataSource, Template classes,
    DAOSupport classes we still are involved in JDBC operations using SQL queries
    without Object centric operations. The easy way to handle database operations
    is by keeping Object at the center using Object Relational Mapping.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Spring DataSource，模板类，DAOSupport类处理数据库操作时，我们仍然涉及使用SQL查询进行JDBC操作，而不进行面向对象的操作。处理数据库操作的最简单方法是使用对象关系映射将对象置于中心。
- en: Object Relation Mapping
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象关系映射
- en: '* * *'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The JDBC APIs gives a means for performing relational database operations to
    achieve persistency. The Java developers are rigorously involved in writing SQL
    queries to do such database operations. But Java is Object Oriented Programming
    Language (OOPs) and database uses **Sequential Query Language** (**SQL**). OOPs
    has object at its centre which SQL has database. OOPs doesn't have Primary Key
    concept, as it has identity. OOPS uses inheritance but SQL does not have. These
    and many more mismatches makes JDBC operations difficult to perform without sound
    hands on knowledge of database and its structure. A good solution has been provided
    by the ORM tools. ORM deals with database operations keeping object at centre
    developers without asking developers to deal with SQL. The iBATIS, JPA, Hibernate
    are some of the ORM frameworks in the market.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC API 提供了执行关系数据库操作的手段以实现持久化。Java 开发人员积极参与编写 SQL 查询以进行此类数据库操作。但是 Java 是一种面向对象编程语言（OOP），而数据库使用
    **顺序查询语言**（**SQL**）。OOP 的核心是对象，而 SQL 有数据库。OOP 没有主键概念，因为它有身份。OOP 使用继承，但 SQL 没有。这些以及许多其他不匹配之处使得没有深入了解数据库及其结构的情况下，JDBC
    操作难以执行。一些优秀的 ORM 工具已经提供了解决方案。ORM 处理数据库操作，将对象置于核心位置，而无需开发者处理 SQL。市场上的 iBATIS、JPA
    和 Hibernate 都是 ORM 框架的例子。
- en: Hibernate
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hibernate
- en: Hibernate is one of the famous middleware tool among the developers for ORM
    solutions. It provides a solution to problems of granularity, inheritance, identity,
    relational association and navigation in easy way. The developers doesn't have
    to hard code the SQL queries as Hibernate provides rich API to deal with CRUD
    database operations making it more maintainable and easy. The SQL queries are
    database dependant but in Hibernate there is no need to write SQL as it provides
    vendor independence. It also supports Hibernate Query Language (HQL) and native
    SQL support to perform customised database operations by writing queries. Using
    Hibernate developers can reduce in development time leading to increase in productivity.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 是开发者在 ORM 解决方案中使用的高级中间件工具之一。它以一种简单的方式提供了细粒度、继承、身份、关系关联和导航问题的解决方案。开发者无需手动编写
    SQL 查询，因为 Hibernate 提供了丰富的 API 来处理 CRUD 数据库操作，使得系统更易于维护和开发。SQL 查询依赖于数据库，但在 Hibernate
    中无需编写 SQL 语句，因为它提供了数据库无关性。它还支持 Hibernate 查询语言（HQL）和原生 SQL 支持，通过编写查询来自定义数据库操作。使用
    Hibernate，开发者可以缩短开发时间，从而提高生产力。
- en: Hibernate Architecture
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hibernate 架构
- en: 'The following figure shows the architecture of the hibernate and the interfaces
    in it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了 Hibernate 的架构及其中的接口：
- en: '![](img/image_03_003.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_003.png)'
- en: The Hibernate has Session, SessionFactory, Configuration, Transaction, Query,
    Criteria interfaces at its core helping in providing the ORM support to the developers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hibernate** 拥有 Session、SessionFactory、Configuration、Transaction、Query 和 Criteria
    接口，为核心提供了 ORM 支持，帮助开发者进行对象关系映射。'
- en: Configuration interface
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Configuration 接口
- en: The instance of Configuration is used to specify the database properties like
    URL, username and password, the location of mapping files or class containing
    information about mapping of data members to the tables and their columns. This
    Configuration instance is then used to obtain instance of the SessionFactory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Configuration 实例来指定数据库属性，如 URL、用户名和密码，映射文件的路径或包含数据成员与表及其列映射信息的类。这个 Configuration
    实例随后用于获取 SessionFactory 的实例。
- en: SessionFactory interface
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SessionFactory 接口
- en: SessionFactory is heavy weight and every application typically has single instance
    per application. But sometimes an application uses more than one database which
    leads to one instance per database. SessionFactory is used to obtain the instance
    of Session. It is very important as it caches the generated SQL statements and
    the data generated which Hibernate uses at runtime in one unit of work as First
    level cache.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SessionFactory 是重量级的，每个应用程序通常只有一个实例。但是有时一个应用程序会使用多个数据库，这就导致每个数据库都有一个实例。SessionFactory
    用于获取 Session 的实例。它非常重要，因为它缓存了生成的 SQL 语句和数据，这些是 Hibernate 在一个工作单元内运行时使用的，作为第一级缓存。
- en: Session interface
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Session 接口
- en: The Session interface is the basic interface which each Hibernate the application
    uses to perform database operations obtained from SessionFactory. Session is light
    weight, inexpensive component. As Sessionfactory is per application, the developer
    creates Session instance per request.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Session 接口是每个使用 Hibernate 的应用程序用来执行数据库操作的基本接口，这些接口是从 SessionFactory 获取的。Session
    是轻量级、成本低的组件。因为 SessionFactory 是针对每个应用程序的，所以开发者为每个请求创建一个 Session 实例。
- en: Transaction interface
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Transaction 接口
- en: Transaction helps the developers to bind number of operations as a unit of work.
    JTA, JDBC provides the implementation of the Transaction implementation. Unless
    the developers don't commit the transaction, the data won't reflect in database.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 事务帮助开发人员将多个操作作为工作单元。JTA、JDBC提供事务实现的实现。除非开发者提交事务，否则数据不会反映在数据库中。
- en: Query interface
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询接口
- en: Query interface provides a facility to write queries using Hibernate Query Language(HQL)
    or native SQL to perform database operations. It also allows developers to bind
    values to the SQL parameters, specify how many number of results are returned
    from the query.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 查询接口提供使用Hibernate查询语言（HQL）或原生SQL来执行数据库操作的功能。它还允许开发人员将值绑定到SQL参数，指定查询返回多少个结果。
- en: Criteria interface
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件接口
- en: The Criteria interface is similar to Query interface allows the developers to
    write criteria query object to get result based on some restrictions or criteria.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 条件接口与查询接口类似，允许开发人员编写基于某些限制或条件的条件查询对象以获取结果。
- en: 'In Spring framework developers has the choice of using SessionFactory instance
    or HibernateTemplate to do Hibernate integrations. The SessionFactory is obtained
    from the configuration of database connectivity parameters and location of the
    mapping which then using DI can be used in Spring application. The `SessionFactory`
    can be configured as shown below:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，开发者可以选择使用SessionFactory实例或HibernateTemplate进行Hibernate集成。SessionFactory从数据库连接参数配置和映射位置获取，然后使用DI可以在Spring应用程序中使用。`SessionFactory`可以如下配置：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**dataSource** - provides information about the database properties.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dataSource** - 提供数据库属性的信息。'
- en: '**mappingResource**- specifies the name of files which provides information
    about mapping of the data members to the table and it''s columns.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mappingResource** - 指定提供数据成员到表及其列映射信息的文件名称。'
- en: '**hibernateProperties**- provides information about hibernate properties'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hibernateProperties** - 提供关于hibernate属性的信息'
- en: '* **dialect** - it is used by the framework to genertae SQL queries as per
    the under laying database.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**方言** - 它用于生成符合底层数据库的SQL查询。'
- en: '* **show_sql** - it displays the SQL query fired by framework on console.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**show_sql** - 它显示框架在控制台上发出的SQL查询。'
- en: '* **hbm2ddl.auto**- it provides the info whether to create, update the table
    with which operations to perform.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**hbm2ddl.auto** - 它提供了是否创建、更新表以及要执行哪些操作的信息。'
- en: 'While using SessionFactory the developers are not writing code which uses Spring
    APIs. But we already had discussed about Template classes few pages back. HibenateTemplate
    is one of such template which helps developers to write decoupled applications.
    The HibernateTemplate configuration is as:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SessionFactory时，开发人员不会编写使用Spring API的代码。但我们之前已经讨论过模板类。HibenateTemplate是这样一个模板，它帮助开发人员编写松耦合的应用程序。HibernateTemplate配置如下：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's integrate SessionFactory in our Book project one by one with the help
    of following steps.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤逐一将SessionFactory集成到我们的Book项目中。
- en: 'Case1: Using SessionFactory'
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 案例1：使用SessionFactory
- en: 'Create Java application named Ch03_Spring_Hibernate_Integration and add to
    it jars for Spring, JDBC and hibernate as shown in the outline below:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Ch03_Spring_Hibernate_Integration的Java应用程序，并添加Spring、JDBC和hibernate的jar文件，如下
    outline 所示：
- en: '![](img/image_03_004.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_004.png)'
- en: You can download the zip containing jar for hibernate framework from official
    website of Hibernate.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从Hibernate的官方网站下载包含hibernate框架jar的zip文件。
- en: Copy or create Book.java in com.packt.ch03.beans package.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch03.beans包中复制或创建Book.java。
- en: 'Create book.hbm.xml in classpath to map the Book class to the book_hib table
    as shown in the configuration below:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径中创建book.hbm.xml，将Book类映射到book_hib表，如下配置所示：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Where the configuration of tags are as:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中标签配置如下：
- en: '* **id**- defines mapping for primary key from table to book class'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**id** - 定义从表到图书类的主键映射'
- en: '* **property**- provides mapping of data members to the columns in the table'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性** - 提供数据成员到表中列的映射'
- en: Add BookDAO interface as we did in Ch03_JdbcTemplate application.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像在Ch03_JdbcTemplate应用程序中一样添加BookDAO接口。
- en: 'Implement BookDAO by BookDAO_SessionFactory and override the methods. Annotate
    the class with @Repository. Add a data member of type SessionFactory annotated
    with @Autowired. The code is as shown below:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过BookDAO_SessionFactory实现BookDAO并覆盖方法。用@Repository注解类。添加一个类型为SessionFactory的数据成员，并用@Autowired注解。代码如下所示：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add connection_new.xml to configure SessionFactory and other details as shown
    below:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加connection_new.xml以配置SessionFactory和其他详细信息，如下所示：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create or copy MainBookDAO_operations.java to get the bean ''bookDAO_sessionFactory''
    to test the application. The code will be:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MainBookDAO_operations.java创建或复制以获取bean 'bookDAO_sessionFactory'以测试应用程序。代码将是：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We already had seen how to configure the HibernateTemplate in the XML. It extensively
    works with Transaction but we yet have not discussed anything about what is transaction,
    it's configuration and how to manage it? We will discuss it after few chapters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何配置HibernateTemplate在XML中。它与事务广泛工作，但我们还没有讨论过什么是事务，它的配置以及如何管理它？我们将在接下来的几章中讨论它。
- en: The real time applications handles huge amount of data in each step. Let's say
    we want to find a book. Using hibernate we will simply invoke a method which returns
    the book depending upon the ISBN of it. In day today use the book will be searched
    countless times and each time the database will be hit leading to performance
    issues. Instead of that it will be great to have a mechanism which will use the
    outcome of the previous query next time if someone asks for it again. The Spring
    3.1 introduced effective yet simplest way 'a cache' mechanism to achieve it and
    added JSR-107 annotation support in 4.1\. The cached result will be stored in
    the cache repository and will be used next time to unnecessary hits to the database.
    You might be thinking of buffer, but it's different from cache. The buffer is
    an intermediate temporary storage to write and read data once. But cache is hidden
    to improve the performance of an application and from where the data is read multiple
    times.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实时应用在每个步骤中处理大量数据。比如说我们想要找一本书。使用hibernate我们只需调用一个返回书籍的方法，这个方法取决于书籍的ISBN。在日常生活中，这本书会被搜索无数次，每次数据库都会被访问，导致性能问题。相反，如果有一种机制，当再次有人索求这本书时，它会使用前一次查询的结果，那就太好了。Spring
    3.1引入了有效且最简单的方法——'缓存'机制来实现它，并在4.1中添加了JSR-107注解支持。缓存的结果将存储在缓存库中，下次将用于避免不必要的数据库访问。你可能想到了缓冲区，但它与缓存不同。缓冲区是用于一次性写入和读取数据的临时中间存储。但缓存是为了提高应用程序的性能而隐藏的，数据在这里被多次读取。
- en: The cache repository is the location where the objects fetched from the database
    will be saved in key-value pair. Spring supports following the repositories,
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存库是对象从数据库获取后保存为键值对的位置。Spring支持以下库，
- en: '**JDK based ConcurrentMap cache:**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于JDK的ConcurrentMap缓存：**'
- en: In JDK ConcurrentMap is used as backing Cache store. Spring framework has SimpleCacheManager
    to get CacheManager and giving it a name. This cache is best for relatively small
    data which doesn't change frequently. But it cannot be used outside of Java heap
    to store data also there is no built in way to share the data between multiple
    JVMs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在JDK ConcurrentMap中用作后端缓存存储。Spring框架具有SimpleCacheManager来获取缓存管理器并给它一个名称。这种缓存最适合相对较小的数据，这些数据不经常更改。但它不能用于Java堆之外存储数据，而且没有内置的方法可以在多个JVM之间共享数据。
- en: '**EhCache based cache:**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于EhCache的缓存：**'
- en: EhcacheChacheManager is used to get a cache manager where the Ehcache configuration
    specifications to be configured in the configuration file generally named ehcache.xml.
    The developers can use different cache manager for different databases with different
    configurations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: EhcacheChacheManager用于获取一个缓存管理器，其中配置Ehcache配置规范，通常配置文件名为ehcache.xml。开发者可以为不同的数据库使用不同的缓存管理器。
- en: '**Caffeine cache:**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**Caffeine缓存：**'
- en: Caffeine is Java8 based caching library to provide high performance. It helps
    in overcoming the important drawback of ConcurrentHashMap that it persist the
    data until explicitly removed. Along with it also provides automatic loading of
    the data, expiration of data based on time, provides notification of the evicted
    data entries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Caffeine是一个基于Java8的缓存库，提供高性能。它有助于克服ConcurrentHashMap的重要缺点，即它直到显式移除数据才会持久化。除此之外，它还提供数据的自动加载、基于时间的数据过期以及被驱逐的数据条目的通知。
- en: Spring provides both XML based as well as annotation based cache configuration.
    The easiest way is to use annotation based configuration. From Spring 3.1 onward
    versions have enables JSR-107 support. To take advantage of the cache using JSR-107
    the developers need to first do cache declaration which will help in identifying
    the methods to be cached and second configuring the cache to inform where the
    data is stored.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了基于 XML 以及注解的缓存配置。最简单的方法是使用注解 based 配置。从 Spring 3.1 开始，版本已启用 JSR-107
    支持。为了利用 JSR-107 的缓存，开发人员需要首先进行缓存声明，这将帮助识别要缓存的方法，然后配置缓存以通知数据存储在哪里。
- en: The cache declaration
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存声明
- en: 'The cache declaration can be done using Annotation as well as XML based. Following
    are the annotations which developers can use for the declaration:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存声明可以使用注解以及基于 XML 的方法。以下开发人员可以使用注解进行声明：
- en: '@Cacheable:'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`@Cacheable`:'
- en: The annotation is used to declare that result of these methods is going to be
    stored in the cache. It takes the name of the cache associated with it. Each time
    when the developers invoked the methods first off all cache is checked to find
    out whether the invocation is already done or not.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该注解用于声明这些方法的结果将被存储在缓存中。它带有与之一致的缓存名称。每次开发人员调用方法时，首先检查缓存以确定调用是否已经完成。
- en: '@Caching:'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`@Caching`:'
- en: The annotation is used when more than one annotations as @CacheEvict, @CachePut
    need to be nested on the same method.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在同一个方法上嵌套多个 `@CacheEvict`、`@CachePut` 注解时使用该注解。
- en: '@CacheConfig:'
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`@CacheConfig`:'
- en: The annotation @CacheConfig is used to annotate the class. In the class whose
    methods annotated using cache based annotations to specify the cache name each
    time. If the class has multiple methods annotating it with @CacheConfig allows
    us to specify cache name only once.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注解 `@CacheConfig` 来注解类。对于使用基于缓存的注解 annotated 的类方法，每次指定缓存名称。如果类有多个方法，则使用 `@CacheConfig`
    注解允许我们只指定一次缓存名称。
- en: '@CacheEvict:'
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`@CacheEvict`:'
- en: It is used to remove the unused data from the cache region.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从缓存区域删除未使用数据。
- en: '@CachePut'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`@CachePut`'
- en: The annotation is used to update the cache result each time the method annotated
    with it is invoked. The annotation behaves exactly opposite to that of @Cacheable
    as it forcefully invokes the method to update the cache and @Cacheable skip the
    execution.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该注解用于在每次调用被其注解的方法时更新缓存结果。该注解的行为与 `@Cacheable` 正好相反，因为它强制调用方法以更新缓存，而 `@Cacheable`
    跳过执行。
- en: 'The cache configuration:'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存配置：
- en: 'To enable the use of annotation based configuration first off all the Spring
    has to be registered using cache namespace. The following configuration can be
    used to declare the namespace for cache and to register the annotation:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了启用基于注解的配置，Spring 必须使用缓存命名空间进行注册。以下配置可用于声明缓存命名空间并注册注解：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once the registration is done now it's time to provide the configuration to
    specify what is the name of the repository and using which cache manager repository
    the results will be cached. We will define the configuration very soon in the
    sample demo for the `SimpleCacheManager`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注册完成后，现在是提供配置以指定存储库的名称以及使用哪个缓存管理器存储库结果的时候了。我们将在 `SimpleCacheManager` 的示例演示中很快定义这些配置。
- en: Let's integrate JDK based ConcurrentMap repository in our Book application.
    We will use Ch03_Spring_Hibernate_Integration as base project for the demonstration.
    Follow the steps for the integration,
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的 Book 应用程序中集成 JDK 基于的 `ConcurrentMap` 存储库。我们将使用 `Ch03_Spring_Hibernate_Integration`
    作为演示的基础项目。按照集成的步骤操作，
- en: Create a new Java application named Ch03_CacheManager and add to it jars for
    Spring, JDBC and hibernate. You can refer to the Ch03_Spring_Hibernate_Integration
    application as well.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Ch03_CacheManager` 的新 Java 应用程序，并添加 Spring、JDBC 和 hibernate 的 jar 文件。你也可以参考
    `Ch03_Spring_Hibernate_Integration` 应用程序。
- en: Create or copy Book.java in com.packt.ch03.beans package.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.packt.ch03.beans` 包中创建或复制 `Book.java` 文件。
- en: 'Create or copy BookDAO interface in com.packt.ch03.dao package and add to it
    a method to search the book from database using ISBN. The signature of the method
    is as shown below:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.packt.ch03.dao` 包中创建或复制 `BookDAO` 接口，并向其添加一个使用 ISBN 从数据库中搜索书籍的方法。该方法的签名如下所示：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the methods in BookDAO_SessionFactory_Cache as we already did in
    the BookDAO_SessionFactory.java from Hibernate application. The method to get
    the book from database will be as:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BookDAO_SessionFactory_Cache` 中实现方法，正如我们在 Hibernate 应用程序中的 `BookDAO_SessionFactory.java`
    中所做的那样。从数据库获取书籍的方法将是：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method is going to use 'repo' repository for caching the result.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将使用'repo'存储库来缓存结果。
- en: Copy book.hbm.xml in classpath.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将book.hbm.xml复制到类路径中。
- en: 'Add the MainBookDAO_Cache.java with main function to get the data from the
    database but purposely we will fetch the data twice as shown below:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加带有主函数的MainBookDAO_Cache.java，以从数据库获取数据，但故意我们会如下的获取两次数据：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before execution make sure the ISBN we are searching is already present in
    the database. We will get the following output:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行之前，请确保我们要搜索的ISBN已经存在于数据库中。我们将得到以下输出：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The above output clearly shows the query to search for book is executed twice,
    denoting the database has been hit twice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出清楚地显示了搜索书籍的查询执行了两次，表示数据库被访问了两次。
- en: Let's now configure the Cache manager to cache the result of the search book
    as follow,
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们配置Cache manager以缓存搜索书籍的结果，如下所示，
- en: 'Annotate the method whose result to be cached by @Cacheable as shown below:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用@Cacheable注解来标记那些结果需要被缓存的方法，如下所示：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Configure the cache namespace in the connection_new.xml as we already discussed.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在connection_new.xml中配置缓存命名空间，正如我们已经在讨论中提到的。
- en: 'Register the annotation based cache in the XML as shown below:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XML中注册基于注解的缓存，如下所示：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the CacheManger for setting the repository as ''repo'' as shown in the
    following configuration:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为设置存储库为'repo'添加CacheManger，如下配置所示：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Execute the MainBookDAO_Cache.java without change to get the following output:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不更改地执行MainBookDAO_Cache.java以得到以下输出：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The console output shows the query has been fired only once even we searched
    the book twice. The result of the book fetched first time by `getBook()` is cached
    and used next time whenever someone ask for the book without heating the database.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出显示，即使我们两次搜索了书籍，查询也只执行了一次。由`getBook()`第一次获取的书籍结果被缓存起来，下次有人请求这本书而没有加热数据库时，会使用这个缓存结果。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: '* * *'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: In this chapter we discussed in depth about the persistency layer. The discussion
    gave us orientation about how to integrate JDBC in application using Spring via
    DataSource. But using JDBC still exposes the developers to JDBC APIs and its operations
    like getting Statement, PreparedStatement and ResultSet. But the JdbcTemplate
    and JdbcDaoSupport provides a means to perform database operations without getting
    involved in JDBC APIs. We also have seen the exception hierarchy given by Spring
    which can be used according to the situation in the application. We also discuss
    about Hibernate as ORM tool and its integration in the framework. Cache helps
    in minimum hits to the database and enhancing the performance. We discuss about
    cache mangers and how to integrate the CacheManger in the application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入讨论了持久层。讨论使我们了解了如何通过Spring使用DataSource将JDBC集成到应用程序中。但使用JDBC仍然会让开发者接触到JDBC
    API及其操作，如获取Statement、PreparedStatement和ResultSet。但JdbcTemplate和JdbcDaoSupport提供了一种在不涉及JDBC
    API的情况下执行数据库操作的方法。我们还看到了Spring提供的异常层次结构，可以根据应用程序的情况使用它。我们还讨论了Hibernate作为ORM工具及其在框架中的集成。缓存有助于最小化对数据库的访问并提高性能。我们讨论了缓存管理器以及如何将CacheManger集成到应用程序中。
- en: In the next chapter we will discuss about Aspect Oriented Programming which
    helps in handling cross cutting technologies.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论面向方面的编程，它有助于处理交叉技术。
