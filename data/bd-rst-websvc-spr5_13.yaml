- en: Ticket Management – Advanced CRUD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 票务管理-高级CRUD
- en: Our application has to meet real-time business cases, such as Ticket management.
    This chapter will review most of the topics covered in the book's previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序必须满足实时业务案例，如票务管理。本章将回顾本书前几章涵盖的大部分主题。
- en: In this chapter, we will create a real-time scenario and implement the business
    requirements for our scenario—Ticket management by the user, **customer service
    representative** (**CSR**), and admin.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个实时场景，并实现我们场景的业务需求——用户、客户服务代表（CSR）和管理员的票务管理。
- en: 'Our final chapter includes the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一章包括以下主题：
- en: Creating a ticket by customer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户创建票务
- en: Updating the ticket by customer, CSR, and admin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户、CSR和管理员更新票务
- en: Deleting the ticket by customer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户删除票务
- en: CSR/admin deletes multiple tickets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSR/管理员删除多张票
- en: Ticket management using CRUD operations
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CRUD操作进行票务管理
- en: Before moving on to the Ticket Management System, we will cover business requirements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向票务管理系统之前，我们将介绍业务需求。
- en: Let's say we have a banking web application that can be used by our customers,
    Peter and Kevin, and we have Sammy, our admin, and Chloe, the CSR, to help in
    case of any application issues.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个银行网站应用程序，可以由我们的客户Peter和Kevin使用，我们有Sammy，我们的管理员，和Chloe，CSR，在应用程序出现问题时提供帮助。
- en: Peter and Kevin are facing some problems in the payment process. When they try
    to click on the payment transaction submit button, it's not working. Also, the
    transaction view is in a web page. So our users (Peter and Kevin) will create
    a ticket to share their problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Peter和Kevin在付款过程中遇到一些问题。当他们尝试点击付款交易提交按钮时，它不起作用。此外，交易视图在一个网页上。因此，我们的用户（Peter和Kevin）将创建一个票务来分享他们的问题。
- en: Once the ticket is created, it can be updated by customer/CSR/admin. Also, a
    customer can delete their own ticket. While updating, anyone can change the severity;
    however, only CSR and admin can change the status, as the ticket's status is related
    to official activities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦票务创建完成，客户/CSR/管理员可以对其进行更新。此外，客户可以删除自己的票务。在更新时，任何人都可以更改严重性；然而，只有CSR和管理员可以更改状态，因为票务状态与官方活动有关。
- en: Customers can view their tickets in total or as a single ticket, but they can
    delete only one ticket at a time. The Multi-delete option is available for both
    CSR and admin. However, CSR can only delete three tickets at once. Admin will
    have full control in the Ticket management application and can delete any number
    of tickets at any time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 客户可以查看他们的票务总数或单张票，但一次只能删除一张票。多删除选项适用于CSR和管理员。但是，CSR一次只能删除三张票。管理员将在票务管理应用程序中拥有完全控制，并可以随时删除任意数量的票。
- en: Registration
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: Let's start our coding to fulfill the preceding requirements. At first, we need
    to start with customer, CSR, and admin registration. As these users have different
    roles, we will give different user types for each user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编码以满足上述要求。首先，我们需要从客户、CSR和管理员注册开始。由于这些用户具有不同的角色，我们将为每个用户分配不同的用户类型。
- en: User types
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户类型
- en: 'To differentiate users, we came up with three different user types so their
    authorization will be varied when they access our REST APIs. Here are the three
    different user types:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分用户，我们提出了三种不同的用户类型，因此当他们访问我们的REST API时，他们的授权将有所不同。以下是三种不同的用户类型：
- en: '| **Name** | **User type** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **用户类型** |'
- en: '| General user/customer | 1 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 普通用户/客户 | 1 |'
- en: '| CSR | 2 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| CSR | 2 |'
- en: '| Admin | 3 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 管理员 | 3 |'
- en: User POJO
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户POJO
- en: 'In our previous `User` class, we only had the `userid` and `username`. We may
    need two more variables to fulfill the business requirements we mentioned earlier.
    We will add `password` and `usertype` to our existing `User` class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的`User`类中，我们只有`userid`和`username`。为了满足我们之前提到的业务需求，我们可能需要两个更多的变量。我们将在现有的`User`类中添加`password`和`usertype`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we have just added `password` and `usertype`. Also, we
    have added getter and setter methods for our variables.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们刚刚添加了`password`和`usertype`。此外，我们为我们的变量添加了getter和setter方法。
- en: You can view the full `User` class on our GitHub repository ([https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Spring-5-Second-Edition](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Spring-5-Second-Edition)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub存储库上查看完整的`User`类（[https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Spring-5-Second-Edition](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Spring-5-Second-Edition)）。
- en: You may be tired of adding getter and setter methods, so we will replace them
    with Lombok library, which we will discuss later in this chapter. However, Lombok
    library has some conflict issues with Eclipse or STS IDE, which you might need
    to be aware of. In certain versions of these IDEs, you won't get expected behavior
    on class creation because of Lombok library issues. Also, some developers mentioned
    that they have deployment issues with Lombok.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经厌倦了添加getter和setter方法，因此我们将用Lombok库替换它们，这将在本章后面讨论。但是，Lombok库与Eclipse或STS
    IDE存在一些冲突问题，您可能需要注意。在这些IDE的某些版本中，由于Lombok库的问题，您在类创建时将无法获得预期的行为。此外，一些开发人员提到他们在Lombok上有部署问题。
- en: In order to automatically generate user ID from our `User` class, we will use
    a separate counter. We will keep a static variable to do that; it's not recommended
    in real application to keep a static counter. To simplify our implementation logic,
    we have used the static counter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的`User`类中自动生成用户ID，我们将使用一个单独的计数器。我们将保留一个静态变量来做到这一点；在真实应用程序中保留静态计数器是不推荐的。为了简化我们的实现逻辑，我们使用了静态计数器。
- en: 'The following code will be added to our `User` class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将被添加到我们的`User`类中：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have started with `100` users. Whenever a new user is added, it will automatically
    increment the `userid` and assign it to the new user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始有`100`个用户。每当添加一个新用户时，它将自动增加`userid`并将其分配给新用户。
- en: There is no restriction on the `userCounter` starting point. By keeping user
    series in `2` (2XX) and ticket in series `3` (3XX), it's easier for the reader
    to differentiate user and ticket.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`userCounter`的起始点没有限制。通过将用户系列保持在`2`（2XX）和票务系列保持在`3`（3XX），读者更容易区分用户和票务。'
- en: 'Now we will create a new constructor to add the user to our application. Also,
    we shall increment the `usercounter` parameter and assign it as `userid` for each
    new user:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个新的构造函数来将用户添加到我们的应用程序中。此外，我们将增加`usercounter`参数并将其分配为每个新用户的`userid`：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding constructor will fill all user details, including the `userid`
    (from `usercounter`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述构造函数将填充所有用户详情，包括`userid`（来自`usercounter`）。
- en: 'Here, we will add a new user with `username`, `password`, and `usertype` in
    the `UserServiceImpl` class; `usertype` will vary for each user (for example,
    `usertype` for admin is `3`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在`UserServiceImpl`类中添加一个新用户，包括`username`、`password`和`usertype`；每个用户的`usertype`都会有所不同（例如，管理员的`usertype`是`3`）：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have created a new user and added it to the existing
    user list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个新用户并将其添加到现有用户列表中。
- en: In the preceding code, we didn't mention the abstract method in `UserService`.
    It is assumed that every concrete method will have an abstract method in the interface.
    Hereafter, consider adding all abstract methods in appropriate interfaces.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们没有在`UserService`中提及抽象方法。我们假设每个具体方法在接口中都有一个抽象方法。以后，请考虑在适当的接口中添加所有抽象方法。
- en: Customer registration
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户注册
- en: Now it is time to add a customer. A new customer will have to create an account
    by adding a username and password details.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是添加客户的时候了。新客户将需要通过添加用户名和密码详情来创建一个账户。
- en: 'We will talk about the customer registration API. This API will help any new
    customer to register their account with us:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论客户注册API。这个API将帮助任何新客户注册他们的账户：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we have added an API to register a customer. Whoever
    is calling this API will be considered a customer (not admin/CSR). As you can
    see, we have mentioned `1` as the `usertype`, so it will be considered a customer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已经添加了一个API来注册客户。调用这个API的人将被视为客户（而不是管理员/CSR）。正如你所看到的，我们已经将`usertype`设为`1`，因此它将被视为客户。
- en: 'Here''s the screenshot of SoapUI for customer registration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户注册的SoapUI截图：
- en: '![](img/d9eac2ba-9b15-4ae9-a9ac-a42f13ec356d.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9eac2ba-9b15-4ae9-a9ac-a42f13ec356d.png)'
- en: 'Also, in the preceding code, we have used `getSuccessResult` from our `Util`
    class. We will see other `Util` methods, shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在上述代码中，我们使用了来自我们的`Util`类的`getSuccessResult`。我们将在以下代码中看到其他`Util`方法：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we created a `Util` class to keep generic methods that
    will be used in different controllers, such as `Ticket` and `User`. These `Util`
    methods are used to avoid code duplication in our application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个`Util`类，用于保存将在不同控制器中使用的通用方法，例如`Ticket`和`User`。这些`Util`方法用于避免我们应用程序中的代码重复。
- en: To simplify the flow, we haven't used any exception-handling mechanism in this
    code. You may need to implement the methods with proper exception handling-techniques.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化流程，在这段代码中我们没有使用任何异常处理机制。您可能需要使用适当的异常处理技术来实现这些方法。
- en: Admin registration
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理员注册
- en: Every application will have an admin to control all actions, such as deleting
    the customer and changing status. Here, we will talk about the admin registration
    API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都将有一个管理员来控制所有操作，例如删除客户和更改状态。在这里，我们将讨论管理员注册API。
- en: 'The admin registration API will also use the `createUser` method to create
    admin. Here''s the code for admin registration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员注册API也将使用`createUser`方法来创建管理员。以下是管理员注册的代码：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have added code for admin registration while mentioning
    `3` (user type for admin) in the `createUser` constructor call. Also, you can
    see that we use the `POST` method for registration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在管理员注册中添加了代码，同时在`createUser`构造函数调用中提及了`3`（管理员的用户类型）。此外，您可以看到我们使用`POST`方法进行注册。
- en: 'The following is the screenshot for the `http://localhost:8080/user/register/admin`
    admin registration SoapUI API call:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`http://localhost:8080/user/register/admin`管理员注册SoapUI API调用的截图：
- en: '![](img/0a8e6410-d5aa-4212-80d6-72cc3fda461c.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a8e6410-d5aa-4212-80d6-72cc3fda461c.png)'
- en: In our Ticket management, we didn't have any restrictions on duplicating the
    user, which means we can have many users with the same name. We recommend that
    you avoid duplicating them, as this will disrupt the flow. To simplify our implementation
    as much as possible, we have ignored such restrictions. However, you can implement
    the restriction to improve the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的票务管理中，我们没有对用户重复注册进行任何限制，这意味着我们可以有许多具有相同名称的用户。我们建议您避免重复注册，因为这将破坏流程。为了尽可能简化我们的实现，我们忽略了这种限制。但是，您可以实现限制以改进应用程序。
- en: CSR registration
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSR注册
- en: In this section, we will talk about CSR registration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论CSR注册。
- en: 'There is only one difference in customer registration—`usertype`. Other than
    `usertype` and API path, nothing is different from the other registration calls:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 客户注册只有一个区别——`usertype`。除了`usertype`和API路径之外，与其他注册调用没有任何不同：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we did with the other APIs, we have used `2` (user type for CSR) to register
    a CSR. Let''s see the API call in SoapUI, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他API一样，我们使用`2`（CSR的用户类型）来注册CSR。让我们看看在SoapUI中的API调用，如下所示：
- en: '![](img/723a18ce-d4aa-4368-a785-d3f29bab0331.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/723a18ce-d4aa-4368-a785-d3f29bab0331.png)'
- en: Login and token management
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录和令牌管理
- en: In the last section, we have covered user registration topics, such as customer,
    admin, and CSR. Once the user is successfully registered, they will have to log
    in to perform an action. So, let's create login- and session-related API and business
    implementations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经涵盖了用户注册主题，例如客户、管理员和CSR。一旦用户成功注册，他们将需要登录以执行操作。因此，让我们创建与登录和会话相关的API和业务实现。
- en: Before moving to login and session, we will talk about JSON Web Token, which
    will be used for session authentication. As we already have the `createToken`
    method in our `securityService` class, we will only talk about the `subject` used
    in token generation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在转到登录和会话之前，我们将讨论JSON Web Token，它将用于会话认证。由于我们已经在我们的`securityService`类中有`createToken`方法，我们只会讨论令牌生成中使用的`subject`。
- en: Generating a token
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成令牌
- en: 'We may need to use the JSON Web Token for session purposes. We will use our
    existing token generation method to keep our user details:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要使用JSON Web Token来进行会话。我们将使用现有的令牌生成方法来保留用户详细信息：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have used `user.getUserid()+"="+user.getUsertype()` as a subject. Also, we
    have mentioned `15` minutes as an expiry time, so the token will be valid for
    only `15` minutes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`user.getUserid()+"="+user.getUsertype()`作为主题。此外，我们已经提到`15`分钟作为到期时间，因此令牌将只在`15`分钟内有效。
- en: Customer login
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户登录
- en: 'Let''s create a login API for customers. The customer has to provide the username
    and password details as parameters. In a real application, these details might
    come from an HTML form as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为客户创建一个登录API。客户必须提供用户名和密码详细信息作为参数。在实际应用中，这些详细信息可能来自HTML表单，如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we have called the `getUser` method from `userService`
    by passing all the necessary parameters. As the user type is `1`, we have passed
    `1` in our method. Once we get the user, we have checked whether it's null or
    not. If null, we will simply throw the error. If the user is not null, we create
    a token subject (`user.getUserid()+"="+user.getUsertype()`) and create a token
    with `15` minutes expiry time, as we mentioned earlier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过传递所有必要的参数从`userService`调用了`getUser`方法。由于用户类型是`1`，我们在我们的方法中传递了`1`。一旦我们得到用户，我们就会检查它是否为空。如果为空，我们将简单地抛出错误。如果用户不为空，我们将创建一个令牌主题（`user.getUserid()+"="+user.getUsertype()`）并创建一个具有`15`分钟到期时间的令牌，正如我们之前提到的那样。
- en: If everything goes as we expected, we will create a result map and return the
    map as an API response. This map will be shown as a JSON response in our result
    when we call this API.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如我们所期望的那样，我们将创建一个结果映射并将映射作为API响应返回。当我们调用此API时，这个映射将显示为我们结果中的JSON响应。
- en: Also, in the preceding code, we have used `getUserNotAvailableError` to return
    error details. As we will be using this error in all session-related APIs, we
    have created a separate method to avoid code duplication.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在前面的代码中，我们使用了`getUserNotAvailableError`来返回错误详情。由于我们将在所有与会话相关的API中使用此错误，我们已经创建了一个单独的方法来避免代码重复。
- en: 'Here, we can see the customer login SoapUI screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到客户登录的SoapUI截图：
- en: '![](img/a56d9b3e-92e6-4a2e-bfb3-6f202490f25b.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a56d9b3e-92e6-4a2e-bfb3-6f202490f25b.png)'
- en: 'In case of a successful user login, we will get a token in the response JSON.
    We will have to use the token for session-related APIs, such as add ticket.A sample
    token is given here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户成功登录的情况下，我们将在响应JSON中获得一个令牌。我们将不得不使用令牌进行与会话相关的API，如添加票务。这里提供了一个示例令牌：
- en: '`eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMDM9MSIsImV4cCI6MTUxNTg5MDMzN30.v9wtiG-fNWlpjgJmou7w2oxA9XjXywsH32cDZ-P4zM4`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMDM9MSIsImV4cCI6MTUxNTg5MDMzN30.v9wtiG-fNWlpjgJmou7w2oxA9XjXywsH32cDZ-P4zM4
- en: In some methods, we may see the `<T> T` return type that is a part of Java generics.
    By keeping such generics, we can return any object by casting it properly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些方法中，我们可能会看到`<T> T`返回类型，这是Java泛型的一部分。通过保持这样的泛型，我们可以通过适当地进行转换来返回任何对象。
- en: 'Here''s a sample:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: The `return (T) map;` return type
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`return (T) map;` 返回类型'
- en: Admin login
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理员登录
- en: As we have seen the customer login section, we will also have a login API for
    admin.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到客户登录部分时，我们也将为管理员创建一个登录API。
- en: 'Here, we will create an API for admin login and generate a token after successful
    authentication:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将为管理员登录创建一个API，并在成功验证后生成一个令牌：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding login API will be used only for admin purposes. We have used `usertype`
    as `3` to create an admin user. Also, we have used the `Util` method `getUserNotAvailableError`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的登录API将仅用于管理员目的。我们已经使用`usertype`作为`3`来创建一个管理员用户。此外，我们已经使用了`Util`方法`getUserNotAvailableError`。
- en: 'Here''s the SoapUI screenshot for the admin login:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理员登录的SoapUI截图：
- en: '![](img/4d2b4240-5fc3-436e-a1b9-1aabac37f114.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d2b4240-5fc3-436e-a1b9-1aabac37f114.png)'
- en: CSR login
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSR登录
- en: 'In this section, we will talk about CSR login and token generation for CSR
    in `TicketController`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论CSR登录和在`TicketController`中为CSR生成令牌：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As usual, we will get the user from our list and check for null. If the user
    is not available, we will throw an error, otherwise the code will fall through.
    As we did with other user types, we will create a separate API for CSR and pass
    `usertype` as `1` to create a CSR.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将从我们的列表中获取用户并检查是否为空。如果用户不可用，我们将抛出一个错误，否则代码将继续执行。与其他用户类型一样，我们将为CSR创建一个单独的API，并将`usertype`作为`1`传递以创建一个CSR。
- en: 'You can see the CSR login API in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下截图中看到CSR登录API：
- en: '![](img/e554a0dc-aad3-4f8e-aa6c-2131061e3374.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e554a0dc-aad3-4f8e-aa6c-2131061e3374.png)'
- en: Ticket management
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 票务管理
- en: In order to create a ticket, we need to create a `Ticket` class and store the
    tickets in the list. We will talk more about the `Ticket` class, ticket list,
    and other ticket-related work, such as user Ticket management, admin Ticket management,
    and CSR Ticket management.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个票，我们需要创建一个`Ticket`类并将票存储在列表中。我们将更多地讨论`Ticket`类，票务列表和其他与票务相关的工作，如用户票务管理，管理员票务管理和CSR票务管理。
- en: Ticket POJO
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 票务POJO
- en: 'We will create a `Ticket` class with some basic variables involved to store
    all details related to ticket. The following code will help us understand the
    `Ticket` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Ticket`类，并涉及一些基本变量来存储与票务相关的所有细节。以下代码将帮助我们理解`Ticket`类：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code will store ticket details such as `ticketid`, `creatorid`,
    `createdat`, `content`, `severity`, and `status`. Also, we have used a static
    counter called `ticketCounter` to increment the `ticketid` upon ticket creation.
    By default, it will start with `300`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将存储票务详情，如`ticketid`，`creatorid`，`createdat`，`content`，`severity`和`status`。此外，我们使用了一个名为`ticketCounter`的静态计数器来在创建票务时递增`ticketid`。默认情况下，它将从`300`开始。
- en: Also, we have used a constructor and the `toString` method, as we will be using
    them in our implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们已经使用了构造函数和`toString`方法，因为我们将在我们的实现中使用它们。
- en: We will have to create the `TicketService` interface (for abstract methods)
    and the `TicketServiceImpl` concrete class for all ticket-related business logic
    implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不创建`TicketService`接口（用于抽象方法）和`TicketServiceImpl`具体类，用于所有与票务相关的业务逻辑实现。
- en: 'The following code will show how to add a ticket:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将显示如何添加一张票：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Getting a user by token
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过令牌获取用户
- en: For all ticket-related operations, we need the user session. In the login method,
    we got the token after successful logging in. We can use the token to get the
    user details. If the token is not available, not matched, or expired, we won't
    be able to get the user details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有与票务相关的操作，我们需要用户会话。在登录方法中，我们在成功登录后获得了令牌。我们可以使用令牌来获取用户详细信息。如果令牌不可用，不匹配或过期，我们将无法获取用户详细信息。
- en: 'Here, we will implement the method to get the user details from the token:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将实现从令牌中获取用户详细信息的方法：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we have used the token to get the user details. We are
    using JWT parser to get the claim first, and then we will get the subject. If
    you remember, we have used `user.getUserid()+"="+user.getUsertype()` as a subject
    when we created a token for all user login options. So the subject will be in
    the same format, for example, `101` (user ID)=`1` (user type) for a customer,
    as the customer's user type is `1`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用令牌来获取用户详细信息。我们使用JWT解析器首先获取声明，然后我们将获取主题。如果您记得，我们在为所有用户登录选项创建令牌时使用了`user.getUserid()+"="+user.getUsertype()`作为主题。因此，主题将采用相同的格式，例如，`101`（用户ID）=`1`（用户类型）表示客户，因为客户的用户类型是`1`。
- en: Also, we do check whether the subject is valid or not with `subject.split("=").length
    != 2`. In case we use a different token, it will simply return null.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还要检查主题是否有效，使用`subject.split("=").length != 2`。如果我们使用不同的令牌，它将简单地返回null。
- en: Once we get the proper subject, we will get the `userid` and `usertype`, and
    then we will return the user by creating a `User` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了正确的主题，我们将获取`userid`和`usertype`，然后我们将通过创建`User`对象来返回用户。
- en: Because `getUserByToken` is common for all users, it will be used for all of
    our user retrieval methods.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`getUserByToken`对所有用户都是通用的，所以它将用于我们所有的用户检索方法。
- en: User Ticket management
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户票务管理
- en: First of all, to simplify our business requirements, we keep the rule that only
    customers can create a ticket. Neither admin nor CSR can create a ticket. In real-time
    situations, you may have different approaches to Ticket management. However, we
    will keep the business requirements as simple as possible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了简化我们的业务需求，我们保持只有客户可以创建票据的规则。管理员和CSR都不能创建票据。在实时情况下，您可能有不同的票务管理方法。但是，我们将尽量保持业务需求尽可能简单。
- en: Ticket controller
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 票务控制器
- en: 'Here, we will discuss creating a ticket by a customer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论客户创建一张票据：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the user submits a ticket, they will send only the details about what problem
    they face in the application. We have provided the content variable for such details.
    Also, we get the user details from the token they pass in the header.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交一张票据时，他们只会发送关于他们在应用程序中遇到的问题的详细信息。我们为这样的详细信息提供了内容变量。此外，我们从他们在标头中传递的令牌中获取用户详细信息。
- en: 'We can see the success response in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到成功的响应：
- en: '![](img/b5e4bc53-015e-4f74-8bdd-5814b033e219.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5e4bc53-015e-4f74-8bdd-5814b033e219.png)'
- en: In the previous API, we have used the `@UserTokenRequired` annotation to validate
    the user token. We will check the details of annotation and implementation here.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的API中，我们已经使用了`@UserTokenRequired`注解来验证用户令牌。我们将在这里检查注解和实现的详细信息。
- en: The UserTokenRequired interface
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserTokenRequired接口
- en: 'Here, we will introduce the `UserTokenRequired` interface and follow up with
    validation logic in the next section:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍`UserTokenRequired`接口，并在下一节中跟进验证逻辑：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The UserTokenRequiredAspect class
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserTokenRequiredAspect类
- en: 'This class will check the user token for user ID and user type validation after
    decrypting it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将在解密后检查用户令牌的用户ID和用户类型验证：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding `UserTokenRequiredAspect` class, we have just got the token
    from the header and verified whether the token is valid or not. If the token is
    invalid, we will throw an exception.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`UserTokenRequiredAspect`类中，我们刚刚从标头中获取了令牌，并验证了令牌是否有效。如果令牌无效，我们将抛出异常。
- en: If the user is null (perhaps there is a wrong or empty token), it will return
    `"User Not Available"` in the response. Once the necessary token is provided,
    we will add the ticket by calling the `addTicket` method in `TicketServiceImpl`,
    which we mentioned earlier.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户为空（也许有错误或空令牌），它将在响应中返回`"用户不可用"`。一旦提供了必要的令牌，我们将通过调用`TicketServiceImpl`中的`addTicket`方法来添加票据，这是我们之前提到的。
- en: 'Severity levels are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 严重级别如下：
- en: 'Minor: Level 1'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要：级别1
- en: 'Normal: Level 2'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常：级别2
- en: 'Major: Level 3'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要：级别3
- en: 'Critical: Level 4'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键：级别4
- en: Level 1 is considered low, and level 4 is considered high, as seen here
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 级别1被认为是低的，级别4被认为是高的，如下所示
- en: '`@SuppressWarnings ("unchecked")`. In some places, we might have used the `@SuppressWarnings`
    annotation where we need to tell the compiler that it doesn''t need to worry about
    proper casting, as it will be taken care of.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SuppressWarnings ("unchecked")`。在某些地方，我们可能已经使用了`@SuppressWarnings`注解，告诉编译器不需要担心正确的转换，因为这将得到处理。'
- en: 'If the user passes the wrong `JWT` in any session-related APIs, we will get
    the error, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在任何与会话相关的API中传递了错误的`JWT`，我们将得到以下错误：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding error simply mentions that the `JWT` string is empty or null.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述错误只是提到`JWT`字符串为空或null。
- en: Getting my tickets – customer
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取我的票据-客户
- en: 'Once the ticket is created, the customer can see their tickets by calling the
    `/my/tickets` API. The following method will handle the get ticket requirements:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦票据创建，客户可以通过调用`/my/tickets` API来查看他们的票据。以下方法将处理获取票据的要求：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we have validated the user session by token and got
    the tickets for the user available in the session:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过令牌验证了用户会话，并获得了会话中用户的票务：
- en: '![](img/be7771c2-6b32-4669-9f88-738774ebb075.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be7771c2-6b32-4669-9f88-738774ebb075.png)'
- en: Allowing a user to view their single ticket
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许用户查看他们的单张票
- en: 'Like viewing all customer tickets, customers also can view each of their own
    ticket details by calling the `/{ticketid}` API. Let''s see how his method works:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与查看所有客户票务一样，客户也可以通过调用`/{ticketid}`API查看他们自己的每张票的详细信息。让我们看看这个方法是如何工作的：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding API, after validating the session, we have used the `getTicket`
    method in `TicketServiceImpl` to get the user ticket details.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的API中，在验证会话后，我们使用`TicketServiceImpl`中的`getTicket`方法来获取用户票务详情。
- en: 'You can verify the result with the help of this screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此截图来验证结果：
- en: '![](img/27a05da9-9e44-4918-8d49-0d71298d7545.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27a05da9-9e44-4918-8d49-0d71298d7545.png)'
- en: You can clearly see that the token is used in our header. Without the token,
    the API will throw an exception, as it is a session-related transaction.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清楚地看到令牌在我们的标题中使用。没有令牌，API将抛出异常，因为它是与会话相关的交易。
- en: Allowing a customer to update a ticket
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许客户更新票务
- en: Let's assume that the customer wants to update their own ticket for some reason,
    such as adding extra information. We will be given an option for the customer
    to update the ticket.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设客户想要出于某种原因更新他们自己的票务，例如添加额外信息。我们将为客户提供更新票务的选项。
- en: Updating a ticket – service (TicketServiceImpl)
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新票务-服务（TicketServiceImpl）
- en: 'For the updating option, we will add the `updateTicket` method to our `TicketServiceImpl`
    class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新选项，我们将在我们的`TicketServiceImpl`类中添加`updateTicket`方法：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding method, we retrieved the ticket by the `getTicket` method and
    then updated the necessary information such as `content`, `severity`, and `status`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们通过`getTicket`方法检索了票务，然后更新了必要的信息，如`content`，`severity`和`status`。
- en: 'Now we can use the `updateTicket` method in our API, which is mentioned here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的API中使用`updateTicket`方法，这里提到了：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, after validating the session, we called `updateTicket`
    and passed the new content. Also, upon successful completion, we sent the proper
    response to the caller.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在验证会话后，我们调用了`updateTicket`并传递了新内容。此外，在成功完成后，我们向呼叫者发送了适当的响应。
- en: '![](img/39034ed5-a27c-4b1e-9233-bc2a16b5905f.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39034ed5-a27c-4b1e-9233-bc2a16b5905f.png)'
- en: For the updating option, we have used the `PUT` method, as it is the appropriate
    HTTP method for updating purposes. However, we can also use the `POST` method
    for such operations, as there is no restriction on it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新选项，我们使用了`PUT`方法，因为这是用于更新目的的适当HTTP方法。但是，我们也可以使用`POST`方法进行此类操作，因为没有限制。
- en: Deleting a ticket
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除票务
- en: So far, we have covered the create, read, and update actions of a ticket. In
    this section, we will talk about the delete option for the customer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了票务的创建、读取和更新操作。在本节中，我们将讨论客户的删除选项。
- en: Deleting a service – service (TicketServiceImpl)
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除服务-服务（TicketServiceImpl）
- en: 'We will add the `deleteMyTicket` method in our `TicketServiceImpl` class, assuming
    that we have already added the abstract method to our interface:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的`TicketServiceImpl`类中添加`deleteMyTicket`方法，假设我们已经在我们的接口中添加了抽象方法：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we have used the `removeIf` Java Streams option to find
    and remove the item from the stream. If the userid and ticket is matched, the
    item will automatically be removed from the stream.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`removeIf` Java Streams选项来查找并从流中删除项目。如果匹配了userid和ticket，该项目将自动从流中删除。
- en: Deleting my ticket – API (ticket controller)
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除我的票务-API（票务控制器）
- en: 'We can call the `deleteMyTicket` method that we created earlier in our API:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用我们在API中早期创建的`deleteMyTicket`方法：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As usual, we will check the session and call the `deleteTicketByUser` method
    in our `TicketServiceImpl` class. Once the delete option is finished, we will
    simply return the map that says `"success"` as a result.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将检查会话并在我们的`TicketServiceImpl`类中调用`deleteTicketByUser`方法。一旦删除选项完成，我们将简单地返回一个说“成功”的地图作为结果。
- en: 'Here''s the SoapUI response after deleting the ticket:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除票务后，这是SoapUI的响应：
- en: '![](img/4e8498ff-5291-4cb1-9108-c9405564da10.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e8498ff-5291-4cb1-9108-c9405564da10.png)'
- en: In our ticket CRUD, we don't have an option to throw an exception when it is
    empty. If you delete all of your existing tickets and call get tickets, you will
    get a success message with empty values. You can improve the application by adding
    an empty check and restrictions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的票务CRUD中，当它为空时，我们没有选项来抛出异常。如果您删除了所有现有的票务并调用获取票务，您将获得一个带有空值的成功消息。您可以通过添加空检查和限制来改进应用程序。
- en: Admin Ticket management
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理员票务管理
- en: In the previous section, we saw Ticket management by the customer. The customer
    has control over their tickets alone and can't do anything with other customers'
    tickets. In the admin mode, we can have control over any tickets available in
    the application. In this section, we'll see Ticket management done by admin.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了客户的票务管理。客户只对他们自己的票务有控制权，不能对其他客户的票务做任何事情。在管理员模式下，我们可以控制应用程序中的任何可用票务。在本节中，我们将看到管理员执行的票务管理。
- en: Allowing a admin to view all tickets
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许管理员查看所有票务
- en: As admin has full control to view all tickets in the application, we keep the
    view ticket method very simple in `TicketServiceImpl` class without any restrictions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于管理员可以完全控制查看应用程序中的所有票务，因此我们在`TicketServiceImpl`类中保持查看票务方法非常简单，没有任何限制。
- en: Getting all tickets – service (TicketServiceImpl)
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有票务-服务（TicketServiceImpl）
- en: 'Here we will discuss about the admin implementation part to get all the tickets
    in the application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论管理员实现部分，以获取应用程序中的所有票务：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we don't have any specific restrictions and simply return
    all tickets from our ticket list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们没有任何特定的限制，只是从我们的票务列表中返回所有票务。
- en: Getting all tickets – API (ticket controller)
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有票务-API（票务控制器）
- en: 'In the ticket controller API, we will add a method to get all the tickets for
    admin:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在票务控制器API中，我们将添加一个方法来获取管理员的所有票务：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding API, `/by/admin` will be called when the admin needs to view all
    tickets. We have called the `getAllTickets` method in our `TicketServiceImpl`
    class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的API`/by/admin`将在管理员需要查看所有票务时调用。我们在`TicketServiceImpl`类中调用了`getAllTickets`方法。
- en: We have used a simple AOP for validating the admin token called `@AdminTokenRequired`.
    Let's see the implementation part of this API.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个简单的AOP来验证管理员令牌，称为`@AdminTokenRequired`。让我们看看这个API的实现部分。
- en: The AdminTokenRequired interface
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AdminTokenRequired接口
- en: 'The `AdminTokenRequired` interface will be the base for our implementation,
    which we will cover later:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdminTokenRequired`接口将是我们实现的基础，我们稍后会涵盖：'
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we introduced the interface for validating an admin token.
    The validation method will follow up in the `AdminTokenRequiredAspect` class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为验证管理员令牌引入了接口。验证方法将在`AdminTokenRequiredAspect`类中跟进。
- en: The AdminTokenRequiredAspect class
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AdminTokenRequiredAspect类
- en: 'In the aspect class, we will do the validation of an admin token:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在切面类中，我们将对管理员令牌进行验证：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we have provided the token validation technique in the
    `AdminTokenRequiredAspect` class. This aspect component will be executed before
    the method execution. Also, in this method, we checked the token for empty and
    null as well as the user type of the token.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`AdminTokenRequiredAspect`类中提供了令牌验证技术。这个切面组件将在方法执行之前执行。此外，在这个方法中，我们检查了令牌是否为空和null，以及令牌的用户类型。
- en: 'Check the SoapUI response for tickets view by admin:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 检查管理员查看票务的SoapUI响应：
- en: '![](img/109ba20b-8859-4994-aed3-afbe8e2d7345.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/109ba20b-8859-4994-aed3-afbe8e2d7345.png)'
- en: 'If we use the wrong token or an empty token, we will get a response like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用错误的令牌或空令牌，我们将得到这样的响应：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By keeping an AOP annotation, we can have a few lines on each method, as the
    annotation will take care of the business logic.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持AOP注解，我们可以在每个方法上有几行代码，因为注解会处理业务逻辑。
- en: Admin updates a ticket
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理员更新票务
- en: Once the ticket is created, it can be viewed by the admin. Unlike a customer,
    admin has more control to update the ticket status and severity in addition to
    its content.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦票务创建完成，管理员就可以查看。与客户不同，管理员有更多的控制权，可以更新票务的状态和严重性，以及其内容。
- en: Updating a ticket by admin – service (TicketServiceImpl)
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过管理员更新票务 - 服务（TicketServiceImpl）
- en: 'Here we will implement the method for ticket update by admin:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将实现管理员更新票务的方法：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we have used the `/by/admin` path in our API to differentiate
    this API from the customer's update method. Also, we get severity and status parameters
    from the request. Once the admin is validated by token, we will call the `updateTicket`
    method. If you see this `updateTicket` method, we haven't hard-coded anything.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在API中使用了`/by/admin`路径来区分这个API和客户的更新方法。此外，我们从请求中获取了严重性和状态参数。一旦管理员通过令牌验证，我们将调用`updateTicket`方法。如果你看到这个`updateTicket`方法，我们没有硬编码任何内容。
- en: 'Once the update process is done, we return the result `"success"` as a response,
    which you can check in the screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新过程完成，我们将返回结果`"success"`作为响应，你可以在截图中检查到：
- en: '![](img/8a05a3ad-c4d4-4523-9e51-e1bcea63a61e.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a05a3ad-c4d4-4523-9e51-e1bcea63a61e.png)'
- en: In real applications, admin might not have control over customers' content,
    such as problems. However, we have provided an option for admin to edit the content
    to make our business logic easy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，管理员可能无法控制客户的内容，比如问题。然而，我们为管理员提供了编辑内容的选项，以使我们的业务逻辑更加简单。
- en: Allowing admin to view a single ticket
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许管理员查看单个票务
- en: As admin has full control of a ticket, they can also view any single ticket
    created by users. As we have already defined the `getTicket` API `/{ticketid}`,
    we can use the same API for admin viewing purposes as well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于管理员对票务有完全的控制权，他们也可以查看用户创建的任何单个票务。由于我们已经定义了`getTicket`API`/{ticketid}`，我们也可以将同样的API用于管理员的查看目的。
- en: Allowing admin to delete tickets
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许管理员删除票务
- en: As admin has more control, we have given an unlimited multi-delete option for
    admin to delete in the application. This will be very handy when admin needs to
    delete a bunch of tickets in one shot.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于管理员有更多的控制权，我们为管理员提供了无限的多删除选项，以便在应用程序中一次性删除一大堆票务时非常方便。
- en: 'Deleting tickets – service (TicketServiceImpl):'
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除票务 - 服务（TicketServiceImpl）：
- en: 'In the following code we will talk about multiple ticket delete option by admin:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将讨论管理员的多票删除选项：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we have given admin the power to delete multiple tickets.
    As admin has full control, there are no specific filters we applied here. We use
    Java Streams to get tickets as list and then match them with ticket ID to delete
    from the ticket list.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们赋予管理员删除多个票务的权力。由于管理员有完全的控制权，我们在这里没有应用特定的过滤器。我们使用Java Streams将票务作为列表获取，然后将它们与票务ID匹配以从票务列表中删除。
- en: 'Deleting tickets by admin – API (ticket controller):'
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过管理员删除票务 - API（票务控制器）：
- en: 'The following method will forward the `ticketids` to the corresponding `TicketServiceImpl`
    method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将把`ticketids`转发到相应的`TicketServiceImpl`方法：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we first check the session by `@AdminTokenRequired` and
    then delete the ticket once the session is validated.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先通过`@AdminTokenRequired`检查会话，然后在会话验证通过后删除票务。
- en: 'We can check the API result with this SoapUI screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这个SoapUI截图检查API的结果：
- en: '![](img/94842506-c2a9-45ff-b19e-d6d2f8a9c111.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94842506-c2a9-45ff-b19e-d6d2f8a9c111.png)'
- en: In the multiple-ticket-delete option, we have used comma separated values to
    send multiple ticket IDs. A single `ticketid` also can be used to call this API.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在多票删除选项中，我们使用逗号分隔的值来发送多个票务ID。也可以使用单个`ticketid`来调用这个API。
- en: CSR Ticket management
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSR票务管理
- en: Finally, we will talk about CSR Ticket management in this section. CSR may not
    have controls like admin; however, in most cases, they have an option to match
    admin in Ticket management application. In the following section, we will talk
    about all CSR authorized CRUD operations on a ticket.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在本节讨论CSR工单管理。CSR可能没有像管理员那样的控制权；然而，在大多数情况下，他们在工单管理应用程序中有与管理员匹配的选项。在接下来的部分中，我们将讨论CSR在工单上的所有授权CRUD操作。
- en: CSR updates a ticket
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSR更新工单
- en: 'In this section, we will talk about updating a ticket by CSR with new content,
    severity, and status in Ticket management:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论CSR通过工单管理更新工单的新内容、严重程度和状态：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we get all the necessary information, such as content,
    severity, and status, and supply this information to the `updateTicket` method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们获取了所有必要的信息，如内容、严重程度和状态，并将这些信息提供给`updateTicket`方法。
- en: We have used a simple AOP for validating the admin token called `@CSRTokenRequired`.
    Let's look at the implementation part of this API.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个简单的AOP来验证名为`@CSRTokenRequired`的管理员令牌。让我们来看看这个API的实现部分。
- en: CSRTokenRequired AOP
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRTokenRequired AOP
- en: 'The `AdminTokenRequired` interface will be the base for our implementation
    that we will go through later:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdminTokenRequired`接口将是我们稍后将要实现的基础：'
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we introduced the annotation for validating admin token.
    The validation method will follow up in the `CSRTokenRequiredAspect` class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们引入了验证管理员令牌的注解。验证方法将在`CSRTokenRequiredAspect`类中跟进。
- en: CSRTokenRequiredAspect
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRTokenRequiredAspect
- en: 'In the `CSRTokenRequiredAspect` class, we will do the validation of admin token:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CSRTokenRequiredAspect`类中，我们将对管理员令牌进行验证：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we have provided the token validation technique in our
    `CSRTokenRequiredAspect` class. This aspect component will be executed before
    the method execution. Also, in this method, we check the token for empty and null
    as well as the user type of the token.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在`CSRTokenRequiredAspect`类中提供了令牌验证技术。这个方面组件将在方法执行之前执行。此外，在这个方法中，我们检查令牌是否为空和null，以及令牌的用户类型。
- en: 'Here''s the screenshot of our `/ticket/{ticketid}` update API:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们`/ticket/{ticketid}`更新API的截图：
- en: '![](img/7d526f83-2b48-42f1-aebc-c85ce3062793.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d526f83-2b48-42f1-aebc-c85ce3062793.png)'
- en: CSR view all tickets
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSR查看所有工单
- en: In terms of viewing all tickets, CSR has the same rights as admin, so we don't
    need to change the service implementation. However, we may need to validate the
    token to ensure that the user is CSR.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看所有工单方面，CSR与管理员拥有相同的权限，因此我们不需要更改服务实现。但是，我们可能需要验证令牌以确保用户是CSR。
- en: Viewing all tickets by CSR – API (ticket controller)
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过CSR查看所有工单 - API（工单控制器）
- en: 'The following will get all the tickets for CSR when it''s called by any CSR:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何CSR调用时，以下内容将获取CSR的所有工单：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding API, we have used only `@CSRTokenRequired` to validate the
    user. Everything other than the API path and annotation is the same, as admin
    views all the tickets.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述API中，我们只使用了`@CSRTokenRequired`来验证用户。除了API路径和注解之外，其他都与管理员查看所有工单相同。
- en: When we check the screenshot of SoapUI, we can clearly see two tickets created
    by customers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查SoapUI的截图时，我们可以清楚地看到客户创建的两张工单。
- en: '![](img/01b56fe6-7f3e-41e3-b07f-dd8c79d62dba.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01b56fe6-7f3e-41e3-b07f-dd8c79d62dba.png)'
- en: CSR view single ticket
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSR查看单个工单
- en: Other than the multi-delete option, CSR has equal rights as admin, we can use
    the same `/{ticketid}`, which we used for both CSR and admin view single ticket
    API here.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除了多删除选项外，CSR与管理员拥有相同的权限，我们可以在这里使用相同的`/{ticketid}`，用于CSR和管理员查看单个工单API。
- en: CSR delete tickets
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSR删除工单
- en: Deleting tickets by CSR is almost like deleting tickets in admin mode. However,
    our business requirements say that CSR should not be able to delete more than
    three tickets at a time. We will add the specific logic to our existing method.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CSR删除工单几乎就像在管理员模式下删除工单一样。然而，我们的业务要求规定CSR一次不能删除超过三张工单。我们将在现有方法中添加具体逻辑。
- en: Deleting tickets – service (TicketServivceImpl)
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除工单 - 服务（TicketServivceImpl）
- en: 'Here comes the service implementation for deleting multiple tickets by CSR:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是CSR删除多张工单的服务实现：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For deleting multi-tickets, we have used the existing code in the `TicketServiceImpl`
    class. However, as per our business requirements, our CSR can't delete more than
    three tickets, so we have added extra logic to check the ticket size. If the ticket
    list size is more than three, we throw an exception, otherwise we will remove
    those tickets.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除多张工单，我们在`TicketServiceImpl`类中使用了现有的代码。然而，根据我们的业务要求，我们的CSR不能删除超过三张工单，因此我们添加了额外的逻辑来检查工单数量。如果工单列表大小超过三，我们会抛出异常，否则我们将删除这些工单。
- en: Deleting tickets by CSR – API (ticket controller)
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过CSR删除工单 - API（工单控制器）
- en: 'In the API, we will simply call the `deleteTickets` method that we implemented
    earlier:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在API中，我们将简单地调用我们之前实现的`deleteTickets`方法：
- en: '[PRE38]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Other than the max ticket restriction on the delete option, there is no big
    change needed for CSR to delete tickets. However, we have added the `@CSRTokenRequired`
    annotation used in our API.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了删除选项上的最大工单限制外，CSR删除工单不需要进行太大的更改。但是，我们已经在我们的API中添加了`@CSRTokenRequired`注解。
- en: 'This is the screenshot of SoapUI for CSR deletes multiple tickets:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CSR删除多张工单的SoapUI截图：
- en: '![](img/5eb0c235-4419-4280-a7d1-d41b61629899.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5eb0c235-4419-4280-a7d1-d41b61629899.png)'
- en: The Postman tool may have an issue with the `DELETE` option, including parameters
    (as of version 5.4.0), you may not get the expected results when you use multiple-delete
    API in both admin and CSR. For such scenarios, please use SoapUI client.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Postman工具可能存在与`DELETE`选项相关的问题，包括参数（截至版本5.4.0），当您在管理员和CSR中使用多删除API时，可能无法获得预期的结果。对于这种情况，请使用SoapUI客户端。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we have implemented a small Ticket Management System
    by meeting all the business requirements that we mentioned in the first section
    of this chapter. This implementation covers ticket CRUD operations by customer,
    CSR, and admin. Also, our implementation met the business requirements, such as
    why CSR can't delete more than three tickets at a time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们通过满足本章第一节中提到的所有业务需求，实现了一个小型的票务管理系统。这个实现涵盖了顾客、客服代表和管理员的票务CRUD操作。此外，我们的实现满足了业务需求，比如为什么客服代表不能一次删除超过三张票。
