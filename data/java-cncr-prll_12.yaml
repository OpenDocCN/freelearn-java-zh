- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: The Horizon Ahead
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前方的地平线
- en: As cloud technologies continue to evolve at a rapid pace, it is crucial for
    developers and organizations to stay ahead of the curve and prepare for the next
    wave of innovations. This chapter will explore the emerging trends and advancements
    in the cloud computing landscape, with a particular focus on Java’s role in shaping
    these future developments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算技术以快速的速度不断发展，开发者和组织必须保持领先，为下一波创新做好准备。本章将探讨云计算领域的兴起趋势和进步，特别关注Java在塑造这些未来发展中扮演的角色。
- en: We will begin by examining the evolution of serverless Java, where frameworks
    such as Quarkus and Micronaut are redefining the boundaries of **functions as
    a service**. These tools leverage innovative techniques, such as native image
    compilation, to deliver unprecedented performance and efficiency in serverless
    environments. Additionally, we will delve into the concept of serverless containers,
    which allow for the deployment of entire Java applications in a serverless fashion,
    harnessing the benefits of container orchestration platforms such as Kubernetes
    and **Amazon Web Services** (**AWS**) Fargate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨无服务器Java的演变，其中像Quarkus和Micronaut这样的框架正在重新定义**函数即服务**的边界。这些工具利用创新技术，如原生图像编译，以在无服务器环境中提供前所未有的性能和效率。此外，我们还将深入研究无服务器容器的概念，它允许以无服务器的方式部署整个Java应用程序，利用Kubernetes和**亚马逊网络服务**（**AWS**）Fargate等容器编排平台的优势。
- en: Next, we will explore the role of Java in the emerging paradigm of edge computing.
    As data processing and decision-making move closer to the source, Java’s platform
    independence, performance, and extensive ecosystem make it an ideal candidate
    for building edge applications. We will discuss the key frameworks and tools that
    enable Java developers to leverage the power of edge computing architectures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Java在新兴的边缘计算范式中的作用。随着数据处理和决策越来越接近源头，Java的平台独立性、性能和广泛的生态系统使其成为构建边缘应用的理想选择。我们将讨论使Java开发者能够利用边缘计算架构的强大功能的键框架和工具。
- en: Furthermore, we will investigate Java’s evolving position in the integration
    of **artificial intelligence** (**AI**) and **machine learning** (**ML**) within
    cloud-based ecosystems. From serverless AI/ML workflows to the seamless integration
    of Java with cloud-based AI services, we will explore the opportunities and challenges
    that this convergence presents.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将调查Java在云生态系统内人工智能（**AI**）和机器学习（**ML**）集成中的演变位置。从无服务器AI/ML工作流到Java与基于云的AI服务的无缝集成，我们将探讨这种融合带来的机会和挑战。
- en: Finally, we will delve into the captivating realm of **quantum computing**,
    a field that promises to revolutionize various industries. While still in its
    early stages, understanding the fundamental principles of quantum computing, such
    as qubits, quantum gates, and algorithms, can prepare developers for future advancements
    and their potential integration with Java-based applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入探讨迷人的**量子计算**领域，这个领域承诺将彻底改变各个行业。虽然仍处于早期阶段，但了解量子计算的基本原理，如量子比特、量子门和算法，可以为开发者准备未来的进步及其与基于Java的应用程序的潜在集成。
- en: By the end of this chapter, you will have a comprehensive understanding of the
    emerging trends in cloud computing and Java’s pivotal role in shaping these innovations.
    You will be equipped with the knowledge and practical examples to position your
    applications and infrastructure for success in the rapidly evolving cloud landscape.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将全面了解云计算的兴起趋势以及Java在塑造这些创新中的关键作用。你将具备知识和实际示例，以定位你的应用程序和基础设施，在快速发展的云计算领域中取得成功。
- en: 'The following are the key topics that will be covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Future trends in cloud computing and Java’s role
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算的未来趋势和Java的角色
- en: Edge computing and Java
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘计算和Java
- en: AI and ML integration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能和机器学习集成
- en: Emerging concurrency and parallel processing tools in Java
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中新兴的并发和并行处理工具
- en: Preparing for the next wave of cloud innovations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备迎接下一波云计算创新
- en: So, let’s get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To fully engage with [*Chapter 12*](B20937_12.xhtml#_idTextAnchor295)’s content
    and examples, ensure the following are installed and configured:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分参与[*第12章*](B20937_12.xhtml#_idTextAnchor295)的内容和示例，请确保以下内容已安装并配置：
- en: '**Java Development Kit** **or JDK**:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java开发工具包**（**JDK**）：'
- en: 'Quarkus requires a JDK to run. If you don’t have one, download and install
    a recent version (JDK 17 or newer is recommended) from the official source:'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus需要JDK来运行。如果您没有，请从官方源下载并安装最新版本（推荐使用JDK 17或更高版本）：
- en: '**AdoptOpenJDK**: [https://adoptium.net/](https://adoptium.net/)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AdoptOpenJDK**: [https://adoptium.net/](https://adoptium.net/)'
- en: '**OpenJDK**: [https://openjdk.org/](https://openjdk.org/)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenJDK**: [https://openjdk.org/](https://openjdk.org/)'
- en: '`choco install quarkus`) or Scoop (`scoop` `install quarkus`)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choco install quarkus`) 或 Scoop (`scoop` `install quarkus`)'
- en: Alternatively, use JBang (`jbang app install --``fresh quarkus@quarkusio`)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，使用JBang (`jbang app install --``fresh quarkus@quarkusio`)
- en: '**Quarkus CLI installation** **guide**: [https://quarkus.io/guides/cli-tooling](https://quarkus.io/guides/cli-tooling)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quarkus CLI安装** **指南**: [https://quarkus.io/guides/cli-tooling](https://quarkus.io/guides/cli-tooling)'
- en: '`GRAALVM_HOME` environment variable to the GraalVM installation directory.*   Add
    `%GRAALVM_HOME%\bin` to your PATH environment variable.*   **Docker Desktop**:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`GRAALVM_HOME`环境变量设置为GraalVM安装目录。*   将`%GRAALVM_HOME%\bin`添加到您的PATH环境变量中。*   **Docker
    Desktop**：
- en: Download and install Docker Desktop for Windows from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)下载并安装Windows版的Docker
    Desktop。
- en: Follow the installation wizard and configure Docker as needed.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装向导进行操作，并根据需要配置Docker。
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Future trends in cloud computing and Java’s role
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算的未来趋势及Java的角色
- en: As cloud computing continues to evolve, several emerging trends are shaping
    the future of this technology landscape. Innovations such as edge computing, AI
    and ML integration, and serverless architectures are at the forefront, driving
    new possibilities and efficiencies. Java, with its robust ecosystem and continuous
    advancements, is playing a pivotal role in these developments. This section will
    explore the latest trends in cloud computing, how Java is adapting to and facilitating
    these changes, and provide real-world examples of Java’s adoption in cutting-edge
    cloud technologies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算的持续发展，几个新兴趋势正在塑造这一技术领域的未来。边缘计算、AI和ML的集成以及无服务器架构等创新处于前沿，推动新的可能性和效率。Java凭借其强大的生态系统和持续进步，在这些发展中扮演着关键角色。本节将探讨云计算的最新趋势，Java如何适应并促进这些变化，并提供Java在尖端云计算技术中的实际应用案例。
- en: Emerging trends in cloud computing – serverless Java beyond function as a service
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云计算的新兴趋势 – 无服务器Java超越函数即服务
- en: Emerging trends in cloud computing are reshaping the landscape of serverless
    Java, extending beyond the traditional functions-as-a-service model. Innovations
    in serverless Java frameworks such as Quarkus and Micronaut are driving this evolution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算的新兴趋势正在重塑无服务器Java的格局，超越了传统的函数即服务模型。Quarkus和Micronaut等无服务器Java框架的创新正在推动这一演变。
- en: Quarkus
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Quarkus
- en: '**Quarkus**, recognized for its strengths in microservices, is now making a
    substantial impact in serverless environments. It empowers developers to build
    serverless functions that adhere to microservice principles, seamlessly merging
    these two architectural approaches. A standout feature is Quarkus’ native integration
    with GraalVM, enabling the compilation of Java applications into native executables.
    This is a game-changer for serverless computing, as it tackles the long-standing
    issue of cold start latency. By harnessing GraalVM, Quarkus dramatically reduces
    startup times for Java applications, often from seconds to mere milliseconds,
    compared to traditional **Java virtual machine** (**JVM**) based alternatives.
    Moreover, the resulting native binaries are more memory efficient, facilitating
    optimized scaling and resource utilization in the dynamic world of serverless
    environments. These advancements are revolutionizing serverless Java, providing
    developers with a powerful toolkit to create high-performance, cloud-native applications
    that are both efficient and responsive.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quarkus**，因其微服务方面的优势而闻名，现在正在无服务器环境中产生重大影响。它赋予开发者构建遵循微服务原则的无服务器函数的能力，无缝地融合了这两种架构方法。一个突出的特性是
    Quarkus 与 GraalVM 的原生集成，使得可以将 Java 应用程序编译成原生可执行文件。这对于无服务器计算来说是一个变革，因为它解决了长期存在的冷启动延迟问题。通过利用
    GraalVM，Quarkus 显著减少了 Java 应用程序的启动时间，通常从秒级减少到仅仅毫秒级，与传统 **Java 虚拟机**（**JVM**）基于的替代方案相比。此外，生成的原生二进制文件更节省内存，有助于在无服务器环境的动态世界中实现优化的扩展和资源利用。这些进步正在改变无服务器
    Java，为开发者提供了一套强大的工具集，用于创建高效、响应迅速的高性能云原生应用程序。'
- en: Micronaut
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Micronaut
- en: '**Micronaut** is another innovative framework making significant progress in
    the serverless Java space. It is designed to optimize the performance of microservices
    and serverless applications through several key features:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micronaut** 是另一个在无服务器 Java 领域取得显著进展的创新框架。它通过几个关键特性设计用于优化微服务和无服务器应用程序的性能：'
- en: '**Compile-time dependency injection**: Unlike traditional frameworks that resolve
    dependencies at runtime, Micronaut performs this task during compilation. This
    approach eliminates the need for runtime reflection, resulting in faster startup
    times and reduced memory consumption.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时依赖注入**：与在运行时解决依赖的传统框架不同，Micronaut 在编译时执行这项任务。这种方法消除了运行时反射的需求，从而实现了更快的启动时间和更低的内存消耗。'
- en: '**Aspect-oriented programming (AOP)**: AOP is a programming paradigm that increases
    modularity by allowing the separation of cross-cutting concerns. In Micronaut,
    AOP is implemented at compile time rather than runtime. This means that features
    such as transaction management, security, and caching are woven into the bytecode
    during compilation, eliminating the need for runtime proxies and further reducing
    memory usage and startup time.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向方面编程（AOP**）：AOP 是一种编程范式，通过允许分离横切关注点来提高模块化。在 Micronaut 中，AOP 是在编译时而不是在运行时实现的。这意味着事务管理、安全性和缓存等特性在编译期间被编织到字节码中，消除了运行时代理的需求，并进一步减少了内存使用和启动时间。'
- en: These compile-time techniques make Micronaut an ideal choice for building lightweight,
    fast, and efficient serverless applications. The framework’s design is particularly
    well suited to environments where rapid startup and low resource consumption are
    crucial.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编译时技术使 Micronaut 成为构建轻量级、快速和高效无服务器应用程序的理想选择。该框架的设计特别适合于快速启动和低资源消耗至关重要的环境。
- en: Additionally, Micronaut supports the creation of GraalVM native images. This
    feature further enhances its suitability for serverless environments by minimizing
    cold start times and resource usage, as native images can start almost instantaneously
    and consume less memory compared to traditional JVM-based applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Micronaut 支持创建 GraalVM 原生镜像。这一特性通过最小化冷启动时间和资源使用，进一步增强了其在无服务器环境中的适用性，因为原生镜像可以几乎瞬间启动，并且相比传统的基于
    JVM 的应用程序消耗更少的内存。
- en: Serverless containers and Java applications
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无服务器容器和 Java 应用程序
- en: Serverless containers represent another dimension of serverless computing, enabling
    the deployment of entire Java applications rather than individual functions. This
    approach leverages container orchestration platforms such as Kubernetes and AWS
    Fargate to run containers in a serverless fashion. Java applications packaged
    as containers benefit from the same serverless advantages of automatic scaling
    and pay-per-use pricing, but with more control over the runtime environment compared
    to traditional serverless functions. Developers can ensure consistency across
    different environments by packaging the application with its dependencies. Full
    control over the runtime environment allows for the inclusion of necessary libraries
    and tools, providing flexibility that is sometimes lacking in traditional serverless
    functions. Additionally, serverless containers can scale automatically based on
    demand, offering the benefits of serverless computing while maintaining the robustness
    of containerized applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器无服务器容器代表了无服务器计算的一个新维度，它使得整个Java应用的部署成为可能，而不仅仅是单个函数。这种方法利用了Kubernetes和AWS
    Fargate等容器编排平台以无服务器的方式运行容器。打包为容器的Java应用可以享受与无服务器函数相同的无服务器优势，如自动扩展和按使用付费定价，但与传统无服务器函数相比，对运行时环境有更多的控制。开发者可以通过将应用程序及其依赖项打包在一起来确保不同环境之间的一致性。对运行时环境的完全控制允许包含必要的库和工具，提供传统无服务器函数中有时缺乏的灵活性。此外，无服务器容器可以根据需求自动扩展，提供无服务器计算的好处，同时保持容器化应用的稳健性。
- en: By combining the innovations in serverless Java frameworks such as Quarkus and
    Micronaut with the flexibility of serverless containers, developers can create
    highly scalable, efficient, and responsive Java applications that meet the demands
    of modern cloud-native environments. These advancements are paving the way for
    the next generation of serverless Java, moving beyond simple functions to encompass
    full-fledged applications and services.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合Quarkus和Micronaut等无服务器Java框架的创新与无服务器容器的灵活性，开发者可以创建高度可扩展、高效且响应迅速的Java应用，以满足现代云原生环境的需求。这些进步正在为下一代无服务器Java铺平道路，它超越了简单的函数，涵盖了完整的应用和服务。
- en: Example use-case – building a serverless REST API with Quarkus and GraalVM
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例用例 - 使用Quarkus和GraalVM构建无服务器REST API
- en: '**Objective**: Create a serverless REST API for product management and deploy
    it on AWS Lambda using Quarkus, demonstrating key Quarkus features and integration
    with AWS services.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**：创建一个用于产品管理的无服务器REST API，并使用Quarkus在AWS Lambda上部署它，展示Quarkus的关键特性和与AWS服务的集成。'
- en: This example covers key concepts and elements of Quarkus. The full application
    will be available in the GitHub repository.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本例涵盖了Quarkus的关键概念和元素。完整的应用程序将在GitHub仓库中提供。
- en: '**Set up the project**: Use Quarkus CLI or Maven to bootstrap a new project.
    For this example, we’ll use Maven. Run the following Maven command to create the
    Quarkus project:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置项目**：使用Quarkus CLI或Maven创建一个新的项目。在这个例子中，我们将使用Maven。运行以下Maven命令以创建Quarkus项目：'
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '@Path("/api/products")'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Path("/api/products")'
- en: '@Produces(MediaType.APPLICATION_JSON)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Produces(MediaType.APPLICATION_JSON)'
- en: '@Consumes(MediaType.APPLICATION_JSON)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Consumes(MediaType.APPLICATION_JSON)'
- en: '@Tag(name = "Product",'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Tag(name = "Product",'
- en: description = "Product management operations")
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: description = "产品管理操作")
- en: public class ProductResource {
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public class ProductResource {
- en: '@Inject'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Inject'
- en: ProductRepository productRepository;
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ProductRepository productRepository;
- en: '@GET'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@GET'
- en: '@Counted(name = "getAllProductsCount",'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Counted(name = "getAllProductsCount",'
- en: description = "How many times getAllProducts has been         invoked")
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: description = "getAllProducts被调用的次数")
- en: '@Timed(name = "getAllProductsTimer",'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Timed(name = "getAllProductsTimer",'
- en: description = "A measure of how long it takes to perform         getAllProducts",
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: description = "衡量执行getAllProducts所需时间的指标",
- en: unit = MetricUnits.MILLISECONDS)
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = MetricUnits.MILLISECONDS)
- en: '@Operation(summary = "Get all products",'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Operation(summary = "获取所有产品",'
- en: description = "Returns a list of all products with         pagination and sorting")
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: description = "返回所有产品的列表，带有分页和排序")
- en: public Response getAllProducts(@QueryParam(
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public Response getAllProducts(@QueryParam(
- en: '"page") @DefaultValue("0") int page,'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"page") @DefaultValue("0") int page,'
- en: '@QueryParam("size") @DefaultValue("20") int size,'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@QueryParam("size") @DefaultValue("20") int size,'
- en: '@QueryParam("sort") @DefaultValue("name") String             sort) {'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@QueryParam("sort") @DefaultValue("name") String sort) {'
- en: // Implementation omitted for brevity
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 省略实现以节省篇幅
- en: '}'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '@POST'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@POST'
- en: '@Operation(summary = "Create a new product",'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Operation(summary = "创建一个新的产品",'
- en: description = "Creates a new product and returns the         created product")
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: description = "创建一个新的产品并返回创建的产品")
- en: public Response createProduct(Product product) {
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public Response createProduct(Product product) {
- en: // Implementation omitted for brevity
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 省略实现以节省篇幅
- en: '}'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: // Additional CRUD methods omitted for brevity
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 省略其他 CRUD 方法以节省篇幅
- en: '}'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE1]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`ProductRepository`: The `ProductRepository` class acts as the data access
    layer, managing interactions with *AWS DynamoDB* for product data persistence.
    It demonstrates Quarkus’ seamless integration with AWS `DynamoDbClient`, showcasing
    how Quarkus simplifies cloud service integration. It implements methods for **create,
    read, update, and delete** (**CRUD**) operations, translating between Java objects
    and DynamoDB item representations, thus demonstrating how Quarkus applications
    can efficiently work with NoSQL databases in a cloud environment:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductRepository`：`ProductRepository` 类充当数据访问层，管理与 *AWS DynamoDB* 的交互以实现产品数据持久化。它展示了
    Quarkus 与 AWS `DynamoDbClient` 的无缝集成，展示了 Quarkus 如何简化云服务集成。它实现了 **创建、读取、更新和删除**
    （**CRUD**） 操作的方法，在 Java 对象和 DynamoDB 项目表示之间进行转换，从而展示了 Quarkus 应用程序如何在云环境中高效地与
    NoSQL 数据库协同工作：'
- en: '[PRE2]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`ImageAnalysisCoordinator`: The `ImageAnalysisCoordinator` class showcases
    Quarkus’ ability to create AWS Lambda functions that interact with multiple AWS
    services. It demonstrates handling **Simple Storage Service** (**S3**) events
    and triggering **Elastic Container Service** (**ECS**) tasks, illustrating how
    Quarkus can be used to build complex, event-driven architectures. This class uses
    dependency injection for AWS clients (ECS and S3), showing how Quarkus simplifies
    working with multiple cloud services in a single component. It’s an excellent
    example of using Quarkus for serverless applications that orchestrate other AWS
    services:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ImageAnalysisCoordinator`：`ImageAnalysisCoordinator` 类展示了 Quarkus 创建与多个 AWS
    服务交互的 AWS Lambda 函数的能力。它展示了处理 **简单存储服务** （**S3**） 事件和触发 **弹性容器服务** （**ECS**） 任务，说明了
    Quarkus 可以用于构建复杂的事件驱动架构。该类使用依赖注入来处理 AWS 客户端（ECS 和 S3），展示了 Quarkus 如何简化在单个组件中与多个云服务协同工作。它是使用
    Quarkus 为无服务器应用程序编排其他 AWS 服务的优秀示例：'
- en: '[PRE3]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`ProductHealthCheck`: The `ProductHealthCheck` class implements Quarkus’ health
    check mechanism, which is crucial for maintaining application reliability in cloud
    environments. It demonstrates the use of Microprofile Health, allowing the application
    to report its status to orchestration systems such as Kubernetes. The class checks
    the accessibility of the DynamoDB table, showcasing how Quarkus applications can
    provide meaningful health information about external dependencies. This component
    is essential for implementing robust microservices that can self-report their
    operational status:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductHealthCheck`：`ProductHealthCheck` 类实现了 Quarkus 的健康检查机制，这对于在云环境中维护应用程序可靠性至关重要。它展示了
    Microprofile Health 的使用，允许应用程序向编排系统（如 Kubernetes）报告其状态。该类检查 DynamoDB 表的可访问性，展示了
    Quarkus 应用程序如何提供有关外部依赖的有意义健康信息。该组件对于实现能够自我报告其操作状态的健壮微服务至关重要：'
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`pom.xml` file includes a profile for native builds. This will specify the
    necessary dependencies and plugins for GraalVM:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pom.xml` 文件包含一个用于原生构建的配置文件。这将指定 GraalVM 所需的依赖项和插件：'
- en: '[PRE5]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Dockerfile.native`: The provided Dockerfile is essential for building and
    packaging a Quarkus application with GraalVM for deployment on AWS Lambda. It
    starts by using a GraalVM image to compile the application into a native executable,
    ensuring optimal performance and minimal startup time. The build stage includes
    copying the project files and running the Maven build process. Subsequently, the
    runtime stage uses a minimal base image to keep the final image lightweight. The
    compiled native executable is copied from the build stage to the runtime stage,
    where it is set as the entry point for the container. This setup guarantees a
    streamlined and efficient deployment process for serverless environments:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dockerfile.native`：提供的 Dockerfile 对于使用 GraalVM 构建和打包 Quarkus 应用程序以部署到 AWS
    Lambda 是必需的。它首先使用 GraalVM 镜像将应用程序编译成原生可执行文件，确保最佳性能和最短的启动时间。构建阶段包括复制项目文件和运行 Maven
    构建过程。随后，运行时阶段使用最小的基础镜像以保持最终镜像轻量。编译后的原生可执行文件从构建阶段复制到运行时阶段，在那里它被设置为容器的入口点。这种设置确保了在无服务器环境中的部署过程流畅且高效：'
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This Dockerfile describes a two-stage build process for a Quarkus native application:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Dockerfile 描述了一个用于 Quarkus 原生应用程序的两个阶段构建过程：
- en: '**Build stage**:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建阶段**:'
- en: Uses a GraalVM-based image to compile the application
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于 GraalVM 的镜像来编译应用程序
- en: Copies project files and builds a native executable
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制项目文件并构建原生可执行文件
- en: '**Runtime stage**:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时阶段**：'
- en: Uses a minimal Red Hat UBI as the base image
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最小化的 Red Hat UBI 作为基础镜像
- en: Copies the native executable from the build stage
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从构建阶段复制原生可执行文件
- en: Sets the executable as the entry point
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可执行文件设置为入口点
- en: 'Multi-stage builds have the following benefits:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建有以下优点：
- en: '**Smaller image size**: The final image is lean, containing only the necessary
    runtime dependencies'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**较小的镜像大小**：最终镜像精简，仅包含必要的运行时依赖项'
- en: '**Improved security**: Reduces the attack surface by including fewer tools
    and packages'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进安全性**：通过包含更少的工具和包来减少攻击面'
- en: '**Clear separation**: Simplifies maintenance by separating the build environment
    from the runtime environment'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的分离**：通过将构建环境与运行时环境分离来简化维护'
- en: Note for Apple Silicon Users
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果硅用户注意事项
- en: When building Docker images on Apple Silicon (M1 or M2) devices, you might encounter
    compatibility issues due to the default **Advance RISC Machine** (**ARM**) architecture.
    Most cloud environments, including AWS, Azure, and Google Cloud, use AMD64 (x86_64)
    architecture. To avoid these issues, specify the target platform when building
    Docker images to ensure compatibility.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当在苹果硅（M1 或 M2）设备上构建 Docker 镜像时，您可能会遇到由于默认的 **高级精简指令集架构**（**ARM**）导致的兼容性问题。大多数云环境，包括
    AWS、Azure 和 Google Cloud，使用 AMD64（x86_64）架构。为了避免这些问题，在构建 Docker 镜像时指定目标平台，以确保兼容性。
- en: Specify the `--platform` argument when building Docker images on Apple Silicon
    devices to ensure compatibility with cloud environments.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在苹果硅设备上构建 Docker 镜像时指定 `--platform` 参数，以确保与云环境兼容。
- en: 'For example, use the following command to build an image compatible with AMD64
    architecture:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令构建与 AMD64 架构兼容的镜像：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While the `application.properties` file is not directly used for enabling native
    builds, you can include properties to optimize the application for running as
    a native image. Here is a sample `application.properties` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `application.properties` 文件不是直接用于启用原生构建，但您可以包含属性以优化应用程序作为原生镜像运行。以下是一个示例 `application.properties`
    文件：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Deploy to** **AWS Lambda:**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署到** **AWS Lambda**：'
- en: '`Template.yaml`: An AWS **Serverless Application Model** (**SAM**) template
    that defines the infrastructure for our Quarkus-based Lambda function, specifying
    its runtime environment, handler, resource allocations, and necessary permissions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Template.yaml`：一个 AWS **无服务器应用程序模型**（**SAM**）模板，它定义了基于 Quarkus 的 Lambda 函数的基础设施，指定其运行时环境、处理程序、资源分配和必要的权限：'
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`.``jar` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`.``jar` 文件：'
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Deploy with SAM CLI**: Use the AWS SAM CLI to package and deploy our Quarkus-based
    Lambda function: the first command packages the application and uploads it to
    an Amazon S3 bucket, while the second command deploys the packaged application
    to AWS, creating or updating a CloudFormation stack with the necessary resources
    and permissions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 SAM CLI 部署**：使用 AWS SAM CLI 打包和部署基于 Quarkus 的 Lambda 函数：第一个命令打包应用程序并将其上传到
    Amazon S3 桶，而第二个命令将打包的应用程序部署到 AWS，创建或更新一个包含必要资源和权限的 CloudFormation 堆栈：'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By following these steps, you will have successfully built a serverless REST
    API using Quarkus, packaged it as a native image with GraalVM, and deployed it
    to AWS Lambda. This setup ensures optimal performance and reduces cold start times
    for your serverless application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，您将成功构建一个使用 Quarkus 的无服务器 REST API，将其打包为带有 GraalVM 的原生镜像，并部署到 AWS Lambda。这种设置确保了最佳性能，并减少了无服务器应用程序的冷启动时间。
- en: The serverless paradigm continues to evolve, with Java frameworks such as Quarkus
    leading the charge in optimizing for cloud-native, serverless environments. As
    we’ve seen, modern serverless Java applications can leverage advanced features
    such as rapid startup times, low memory footprints, and seamless integration with
    cloud services. This enables developers to build complex, scalable applications
    that go far beyond simple function executions, encompassing full-fledged microservices
    architectures.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器范式正在不断发展，Java 框架如 Quarkus 领先于优化云原生、无服务器环境。正如我们所见，现代无服务器 Java 应用程序可以利用快速启动时间、低内存占用和与云服务无缝集成的先进功能。这使开发者能够构建复杂、可扩展的应用程序，这些应用程序远远超出了简单函数执行的范围，涵盖了完整的微服务架构。
- en: 'As the cloud computing landscape continues to evolve, another emerging trend
    is gaining significant traction: edge computing. Let’s explore how Java is adapting
    to meet the unique challenges and opportunities presented by edge computing environments.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算领域的持续演变，另一个新兴趋势正在获得显著的吸引力：边缘计算。让我们探讨Java如何适应边缘计算环境所提出的独特挑战和机遇。
- en: Edge computing and Java
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘计算与Java
- en: Edge computing represents a paradigm shift in how data is processed, with computation
    occurring at or near the data source instead of relying solely on centralized
    cloud data centers. This approach reduces latency, optimizes bandwidth usage,
    and improves response times for critical applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘计算代表了数据处理范式的一次转变，计算发生在数据源附近或数据源处，而不是仅仅依赖于集中的云数据中心。这种方法减少了延迟，优化了带宽使用，并提高了关键应用的响应时间。
- en: Java’s role in edge computing architectures
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java在边缘计算架构中的作用
- en: Java, with its mature ecosystem and robust performance, is increasingly becoming
    a pivotal player in edge computing architectures.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Java，凭借其成熟的生态系统和强大的性能，正日益成为边缘计算架构中的关键玩家。
- en: Java’s versatility and platform independence make it an ideal candidate for
    edge computing environments, which often consist of heterogeneous hardware and
    **operating systems** (**OSs**). Java’s ability to run on various devices, from
    powerful servers to constrained **internet of things** (**IoT**) devices, ensures
    that developers can leverage a consistent programming model across the entire
    edge-to-cloud continuum. Additionally, the extensive set of libraries and frameworks
    available in the Java ecosystem enables rapid development and deployment of edge
    applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java的通用性和平台独立性使其成为边缘计算环境的理想选择，这些环境通常由异构硬件和**操作系统**（**OSs**）组成。Java能够在各种设备上运行，从强大的服务器到受限的**物联网**（**IoT**）设备，确保开发者可以在整个边缘到云的连续体上利用一致的编程模型。此外，Java生态系统中可用的广泛库和框架使得边缘应用的快速开发和部署成为可能。
- en: 'Key benefits of using Java in edge computing include the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘计算中使用Java的关键优势包括以下内容：
- en: '**Cross-platform compatibility**: Java’s “write once, run anywhere” philosophy
    allows edge applications to be deployed across diverse hardware platforms without
    modification'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台兼容性**：Java的“一次编写，到处运行”理念允许边缘应用在多种硬件平台上部署而无需修改'
- en: '**Performance and scalability**: Java’s robust performance and efficient memory
    management are critical for handling the resource-constrained environments often
    found in edge devices'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和可伸缩性**：Java强大的性能和高效的内存管理对于处理边缘设备中常见的资源受限环境至关重要'
- en: '**Security**: Java provides a strong security model, which is essential for
    safeguarding sensitive data processed at the edge'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：Java提供强大的安全模型，这对于保护边缘处理敏感数据至关重要'
- en: These advantages make Java a compelling choice for edge computing. To further
    empower developers, several frameworks and tools have been developed to streamline
    Java-based edge application development and deployment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势使Java成为边缘计算的有力选择。为了进一步赋能开发者，已经开发出几个框架和工具，以简化基于Java的边缘应用的开发和部署。
- en: Frameworks and tools for Java-based edge applications
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于基于Java的边缘应用的框架和工具
- en: 'To effectively leverage Java in edge computing, developers can utilize a variety
    of frameworks and tools specifically designed for building and managing edge applications.
    Some of the prominent frameworks and tools include the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地利用Java进行边缘计算，开发者可以利用专门为构建和管理边缘应用而设计的各种框架和工具。以下是一些突出的框架和工具：
- en: '**Eclipse Foundation’s** **IoT initiative**:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse基金会**的**物联网倡议**：'
- en: '**Eclipse Kura**: An open-source framework for building IoT gateways. It provides
    a set of Java APIs for accessing hardware interfaces, managing network configurations,
    and interacting with cloud services.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse Kura**：一个用于构建物联网网关的开源框架。它提供了一套Java API，用于访问硬件接口、管理网络配置以及与云服务交互。'
- en: '**Eclipse Kapua**: A modular IoT cloud platform that works in conjunction with
    Eclipse Kura to provide end-to-end IoT solutions. It offers features such as device
    management, data management, and application integration.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse Kapua**：一个模块化的物联网云平台，与Eclipse Kura协同工作，提供端到端的物联网解决方案。它提供设备管理、数据管理和应用集成等功能。'
- en: '**Apache Edgent**: Apache Edgent (formerly known as Quarks) is a lightweight,
    embeddable programming model and runtime for edge devices. It allows developers
    to create analytics applications that can run on small-footprint devices and integrate
    with central data systems.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Edgent**：Apache Edgent（之前称为Quarks）是一个轻量级、可嵌入的编程模型和运行时，适用于边缘设备。它允许开发者创建可以在小尺寸设备上运行并集成到中央数据系统的分析应用程序。'
- en: '**Vert.x**: Vert.x is a toolkit for building reactive applications on the JVM.
    Its event-driven architecture and lightweight nature make it well suited for edge-computing
    scenarios where low latency and high concurrency are essential.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vert.x**：Vert.x是一个用于在JVM上构建反应式应用程序的工具包。其事件驱动架构和轻量级特性使其非常适合需要低延迟和高并发的边缘计算场景。'
- en: '**AWS IoT Greengrass**: AWS IoT Greengrass extends AWS capabilities to edge
    devices, enabling them to act locally on the data they generate while still using
    the cloud for management, analytics, and durable storage. Java developers can
    create Greengrass Lambda functions to process and respond to local events.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS IoT Greengrass**：AWS IoT Greengrass将AWS的能力扩展到边缘设备，使它们能够在本地处理它们生成的数据，同时仍然使用云进行管理、分析和持久存储。Java开发者可以创建Greengrass
    Lambda函数来处理和响应本地事件。'
- en: '**Azure IoT Edge**: Azure IoT Edge allows developers to deploy and run containerized
    applications at the edge. Java applications can be packaged in Docker containers
    and deployed using Azure IoT Edge runtime, enabling seamless integration with
    Azure cloud services.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure IoT Edge**：Azure IoT Edge允许开发者将容器化应用程序部署和运行在边缘。Java应用程序可以打包在Docker容器中，并使用Azure
    IoT Edge运行时进行部署，从而实现与Azure云服务的无缝集成。'
- en: '**Google Cloud IoT Edge**: Google Cloud IoT Edge brings Google Cloud’s ML and
    data processing capabilities to edge devices. Java developers can utilize TensorFlow
    Lite and other Google Cloud services to create intelligent edge applications.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud IoT Edge**：Google Cloud IoT Edge将Google Cloud的ML和数据处理能力带到边缘设备。Java开发者可以利用TensorFlow
    Lite和其他Google Cloud服务来创建智能边缘应用程序。'
- en: Java’s robust ecosystem, platform independence, and extensive library support
    make it a strong contender for edge computing. By leveraging frameworks and tools
    designed for edge environments, Java developers can build efficient, scalable,
    and secure edge applications that harness the full potential of edge computing
    architectures. As edge computing continues to evolve, Java is well positioned
    to play a critical role in shaping the future of distributed and decentralized
    data processing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Java的强大生态系统、平台独立性和广泛的库支持使其成为边缘计算的强劲竞争者。通过利用为边缘环境设计的框架和工具，Java开发者可以构建高效、可扩展且安全的边缘应用程序，充分利用边缘计算架构的潜力。随着边缘计算不断演进，Java在塑造分布式和去中心化数据处理未来方面处于有利位置。
- en: AI and ML integration
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI和ML集成
- en: As we look toward the future of Java in cloud computing, the integration of
    AI and ML presents exciting opportunities and challenges. While [*Chapter 7*](B20937_07.xhtml#_idTextAnchor187)
    focused on Java’s concurrency mechanisms for ML workflows, this section explores
    Java’s evolving role in cloud-based AI/ML ecosystems and its integration with
    advanced cloud AI services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展望Java在云计算的未来时，AI和ML的集成带来了令人兴奋的机会和挑战。虽然[第7章](B20937_07.xhtml#_idTextAnchor187)专注于Java在ML工作流程中的并发机制，但本节探讨了Java在基于云的AI/ML生态系统中的演变角色及其与高级云AI服务的集成。
- en: Java’s position in cloud-based AI/ML workflows
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java在基于云的AI/ML工作流程中的位置
- en: 'Here are some of Java’s evolving roles in cloud-based AI/ML ecosystems:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java在基于云的AI/ML生态系统中的演变角色：
- en: '**Serverless AI/ML with Java**: The future of Java in cloud-based AI/ML workflows
    is increasingly serverless. Frameworks such as AWS Lambda and Google Cloud Functions
    allow developers to deploy AI/ML models as serverless functions. This trend is
    expected to grow, enabling more efficient and scalable AI/ML operations without
    the need for managing infrastructure.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器AI/ML与Java**：Java在基于云的AI/ML工作流程中的未来越来越趋向于无服务器。如AWS Lambda和Google Cloud
    Functions之类的框架允许开发者将AI/ML模型作为无服务器函数部署。这一趋势预计将增长，使AI/ML操作更加高效和可扩展，无需管理基础设施。'
- en: '**Java as an orchestrator**: Java is positioning itself as a powerful orchestrator
    for complex AI/ML pipelines in the cloud. Its robustness and extensive ecosystem
    make it ideal for managing workflows that involve multiple AI/ML services, data
    sources, and processing steps. Expect to see more Java-based tools and frameworks
    designed specifically for AI/ML pipeline orchestration in cloud environments.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 作为编排器**：Java 正在将自己定位为云中复杂 AI/ML 管道的高效编排器。其稳健性和广泛的生态系统使其非常适合管理涉及多个 AI/ML
    服务、数据源和处理步骤的工作流程。预计将出现更多针对云环境中 AI/ML 管道编排设计的基于 Java 的工具和框架。'
- en: '**Edge AI with Java**: As edge computing gains prominence, Java’s *write once,
    run anywhere* philosophy becomes increasingly valuable. Java is being adapted
    for edge AI applications, allowing models trained in the cloud to be deployed
    and run on edge devices. This trend will likely accelerate, with Java serving
    as a bridge between cloud-based training and edge-based inference.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 与边缘 AI**：随着边缘计算的兴起，Java 的“一次编写，到处运行”的理念变得越来越有价值。Java 正在适应边缘 AI 应用程序，允许在云中训练的模型部署并在边缘设备上运行。这一趋势可能会加速，Java
    将作为云端训练和边缘端推理之间的桥梁。'
- en: Next, let’s explore Java’s integration with advanced cloud-based AI services.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索 Java 与高级基于云的 AI 服务的集成。
- en: Integration of Java with cloud AI services
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 与云 AI 服务的集成
- en: 'Integrating Java applications with cloud-based AI services opens up a world
    of possibilities for developers, enabling the creation of intelligent and adaptive
    software solutions. Cloud AI services offer pre-trained models, scalable infrastructure,
    and APIs that make it easier to implement advanced ML and AI capabilities without
    the need for extensive in-house expertise. The following is a list of popular
    cloud AI services that can be integrated with Java applications:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 应用程序与基于云的 AI 服务集成，为开发者打开了无限可能，使他们能够创建智能和自适应的软件解决方案。云 AI 服务提供预训练模型、可扩展的基础设施和
    API，使得在不需大量内部专业知识的情况下实现高级机器学习和 AI 功能变得更加容易。以下是可以与 Java 应用程序集成的流行云 AI 服务列表：
- en: '**Native Java SDKs for cloud AI services**: Major cloud providers are investing
    in developing a robust **Java Development Kit** (**JDK**) for their AI services.
    For example, AWS has released the AWS SDK for Java 2.0, which provides streamlined
    access to services such as Amazon SageMaker. Google Cloud has also enhanced its
    Java client libraries for AI and ML services. This trend is expected to continue,
    making it easier for Java developers to integrate cloud AI services into their
    applications.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云 AI 服务的原生 Java SDK**：主要云服务提供商正在投资开发用于其 AI 服务的强大 **Java 开发工具包**（**JDK**）。例如，AWS
    已经发布了 AWS SDK for Java 2.0，它提供了对 Amazon SageMaker 等服务的简化访问。Google Cloud 也增强了其
    AI 和 ML 服务的 Java 客户端库。这一趋势预计将持续，使 Java 开发者更容易将云 AI 服务集成到他们的应用程序中。'
- en: '**Java-friendly AutoML platforms**: Cloud providers are developing AutoML platforms
    that are increasingly Java friendly. For instance, Google Cloud AutoML now offers
    Java client libraries, allowing Java applications to easily train and deploy custom
    ML models without extensive ML expertise. This trend is likely to expand, making
    advanced AI capabilities more accessible to Java developers.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 友好的 AutoML 平台**：云服务提供商正在开发越来越友好的 AutoML 平台。例如，Google Cloud AutoML 现在提供
    Java 客户端库，允许 Java 应用程序轻松训练和部署定制的 ML 模型，而无需广泛的 ML 专业知识。这一趋势可能会扩展，使高级 AI 功能更容易为
    Java 开发者所获取。'
- en: '**Containerized Java AI/ML deployments**: The future of Java in cloud AI/ML
    workflows is closely tied to containerization. Platforms such as Kubernetes are
    becoming the de facto standard for deploying and managing AI/ML workloads in the
    cloud. Java’s compatibility with containerization technologies positions it well
    for this trend. Expect to see more tools and best practices emerge for deploying
    Java-based AI/ML applications in containerized environments.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化的 Java AI/ML 部署**：Java 在云 AI/ML 工作流程中的未来与容器化紧密相连。Kubernetes 等平台正在成为在云中部署和管理
    AI/ML 工作负载的事实标准。Java 与容器化技术的兼容性使其非常适合这一趋势。预计将出现更多工具和最佳实践，用于在容器化环境中部署基于 Java 的
    AI/ML 应用程序。'
- en: '**Java in federated learning**: Federated learning is an ML technique that
    trains algorithms across multiple decentralized edge devices or servers holding
    local data samples, without exchanging them. This approach addresses growing privacy
    concerns by allowing model training on distributed datasets without centrally
    pooling the data.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联邦学习中的 Java**：联邦学习是一种机器学习技术，它在不交换数据的情况下，在多个持有本地数据样本的分散边缘设备或服务器上训练算法。这种方法通过允许在分布式数据集上训练模型而不集中汇总数据，解决了日益增长的隐私问题。'
- en: As privacy concerns grow, federated learning is gaining traction. Java’s robust
    security features and its wide adoption in enterprise environments make it a strong
    candidate for implementing federated learning systems. Cloud providers are likely
    to offer more support for Java in their federated learning offerings, enabling
    models to be trained across decentralized data sources without compromising privacy.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着隐私问题的日益突出，联邦学习正在获得关注。Java 的强大安全特性和其在企业环境中的广泛采用使其成为实现联邦学习系统的有力候选者。云提供商可能会在其联邦学习产品中提供更多对
    Java 的支持，使模型能够在不损害隐私的情况下跨分散数据源进行训练。
- en: '**Java for Machine Learning Operations (MLOps)**: The emerging field of MLOps
    is seeing increased adoption of Java. Its stability and extensive tooling make
    Java well suited for building robust MLOps pipelines in the cloud. Expect to see
    more Java-based MLOps tools and integrations with cloud CI/CD services specifically
    designed for AI/ML workflows.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习操作 (MLOps) 中的 Java**：新兴的 MLOps 领域正在越来越多地采用 Java。其稳定性和广泛的工具使得 Java 非常适合在云中构建健壮的
    MLOps 管道。预计将看到更多基于 Java 的 MLOps 工具和与云 CI/CD 服务的集成，这些服务专门为 AI/ML 工作流程设计。'
- en: In conclusion, Java’s role in cloud-based AI/ML is evolving beyond just a language
    for implementing algorithms. It’s becoming a crucial part of the broader AI/ML
    ecosystem in the cloud, from serverless deployments to edge computing, and from
    AutoML to MLOps. As cloud AI services continue to mature, Java’s integration with
    these services will deepen, offering developers powerful new ways to build intelligent,
    scalable applications in the cloud.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Java 在基于云的 AI/ML 中的作用正在从仅仅是一种实现算法的语言转变为更广泛的 AI/ML 生态系统的一部分。它正成为云中从无服务器部署到边缘计算，从
    AutoML 到 MLOps 的关键部分。随着云 AI 服务的不断成熟，Java 与这些服务的集成将更加深入，为开发者提供构建智能、可扩展云应用程序的强大新方法。
- en: Use case – serverless AI image analysis with AWS Lambda and Fargate
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 - 使用 AWS Lambda 和 Fargate 的无服务器 AI 图像分析
- en: This use case demonstrates a scalable, serverless architecture for AI-powered
    image analysis using AWS Lambda and Fargate. AWS Fargate is AWS’s implementation
    of serverless containers. This technology allows for the deployment of entire
    Java applications in a serverless fashion, leveraging container orchestration
    platforms such as Kubernetes and AWS Fargate. By packaging Java applications as
    containers, developers can enjoy the benefits of serverless computing – such as
    automatic scaling and pay-per-use pricing – while maintaining control over the
    runtime environment. This approach ensures consistency across different environments,
    provides flexibility with the inclusion of necessary libraries and tools, and
    offers robust scalability.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本用例展示了使用 AWS Lambda 和 Fargate 的可扩展、无服务器架构，用于基于 AI 的图像分析。AWS Fargate 是 AWS 对无服务器容器的实现。这项技术允许以无服务器方式部署整个
    Java 应用程序，利用 Kubernetes 和 AWS Fargate 等容器编排平台。通过将 Java 应用程序打包为容器，开发者可以享受无服务器计算的好处——如自动扩展和按使用付费定价——同时保持对运行时环境的控制。这种方法确保了不同环境之间的一致性，通过包含必要的库和工具提供了灵活性，并提供了强大的可伸缩性。
- en: 'The system consists of two main components, each built as a separate Quarkus
    project:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统由两个主要组件组成，每个组件都作为一个独立的 Quarkus 项目构建：
- en: '`ImageAnalysisCoordinator`:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageAnalysisCoordinator`：'
- en: Built as a native executable for optimal performance in a serverless environment
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为无服务器环境中的原生可执行文件构建，以实现最佳性能
- en: Triggered when an image is uploaded to an S3 bucket
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当图像上传到 S3 桶时触发
- en: Performs quick analysis using Amazon Rekognition
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amazon Rekognition 进行快速分析
- en: Initiates a more detailed analysis by launching an AWS Fargate task
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过启动 AWS Fargate 任务来启动更详细的分析
- en: '`FargateImageAnalyzer`:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FargateImageAnalyzer`：'
- en: Built as a JVM-based application and containerized using Docker
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为基于 JVM 的应用程序构建，并使用 Docker 容器化
- en: Runs as a task in AWS Fargate when triggered by the Lambda function
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Lambda 函数触发时，作为 AWS Fargate 中的任务运行
- en: Performs in-depth image processing using advanced AI techniques
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用先进的 AI 技术进行深入图像处理
- en: Stores detailed analysis results back in S3
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将详细分析结果存储回 S3
- en: 'This two-component architecture allows for efficient resource utilization:
    the lightweight Lambda function handles the initial processing and orchestration,
    while the Fargate container manages the more intensive computational tasks. Together,
    they form a robust, scalable solution for serverless AI-powered image analysis.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种双组件架构允许高效地利用资源：轻量级的Lambda函数处理初始处理和编排，而Fargate容器管理更密集的计算任务。它们共同构成了一个强大、可扩展的无服务器AI图像分析解决方案。
- en: '**Step 1: Create a** **Fargate container**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1：创建一个** **Fargate容器**：'
- en: '`Dockerfile.jvm`: The `Dockerfile.jvm` is used to build the Docker image for
    the Fargate container component of the serverless AI image analysis architecture.
    Unlike the Lambda function, which is built as a native executable, the Fargate
    container runs the `FargateImageAnalyzer` application as a JVM-based Quarkus application.
    This choice is due to the Fargate container being responsible for the more computationally
    intensive image processing tasks, where the benefits of the Quarkus framework
    can outweigh the potential performance advantages of a native executable.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile.jvm`: `Dockerfile.jvm`用于构建服务器端AI图像分析架构中Fargate容器组件的Docker镜像。与作为本地可执行文件构建的Lambda函数不同，Fargate容器以基于JVM的Quarkus应用程序运行`FargateImageAnalyzer`应用程序。这种选择是因为Fargate容器负责更计算密集型的图像处理任务，Quarkus框架的好处可能超过本地可执行文件潜在的性能优势。'
- en: 'This Dockerfile defines the steps to build a Docker image for a Quarkus application.
    The image is designed to run within a Red Hat **Universal Base Image** (**UBI**)
    environment with OpenJDK 17:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此Dockerfile定义了构建Quarkus应用程序Docker镜像的步骤。该镜像设计为在带有OpenJDK 17的Red Hat **通用基础镜像**（**UBI**）环境中运行：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`FargateImageAnalyzer.java` performs in-depth image processing:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`FargateImageAnalyzer.java`执行深入图像处理：'
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `FargateImageAnalyzer` class is the main application that runs inside the
    Fargate container as part of the serverless AI image analysis architecture. It
    is designed as a Quarkus application and implements the `QuarkusApplication` interface.
    The class is responsible for extracting the S3 bucket and object key information,
    using the AWS Rekognition client to perform image analysis, generating a detailed
    analysis result, and storing it back in the same S3 bucket. It is designed to
    run as a standalone Quarkus application within the Fargate task, leveraging the
    benefits of running in a containerized environment and the ease of deployment
    and scaling that Fargate provides.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`FargateImageAnalyzer`类是作为无服务器AI图像分析架构一部分在Fargate容器内运行的主要应用程序。它被设计为Quarkus应用程序并实现了`QuarkusApplication`接口。该类负责提取S3存储桶和对象键信息，使用AWS
    Rekognition客户端执行图像分析，生成详细的分析结果，并将其存储回同一S3存储桶。它被设计为在Fargate任务中作为独立的Quarkus应用程序运行，利用容器化环境运行的好处以及Fargate提供的部署和扩展的便利性。'
- en: '**Step 2: Create a** **Lambda function**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2：创建一个** **Lambda函数**：'
- en: '`Dockerfile.native`: This Dockerfile is used to build the Docker image for
    the native executable of the Lambda function component in the serverless AI image
    analysis architecture. This Dockerfile follows the Quarkus convention for building
    native executables by using the `quay.io/quarkus/ubi-quarkus-native-image` base
    image and performing the necessary build steps. By using `Dockerfile.native`,
    the Lambda function can be packaged as a native executable, which provides improved
    performance and reduced cold start times compared to a JVM-based deployment. This
    is particularly beneficial for serverless applications where rapid response times
    are crucial:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile.native`: 这个Dockerfile用于构建服务器端AI图像分析架构中Lambda函数组件的本地可执行Docker镜像。此Dockerfile遵循Quarkus构建本地可执行文件的约定，通过使用`quay.io/quarkus/ubi-quarkus-native-image`作为基础镜像并执行必要的构建步骤。使用`Dockerfile.native`可以将Lambda函数打包为本地可执行文件，与基于JVM的部署相比，这提供了改进的性能和减少的冷启动时间。这对于需要快速响应时间的无服务器应用程序特别有益：'
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ImageAnalysisCoordinator.java`: This is an AWS Lambda function that gets triggered
    when a new image is uploaded to an S3 bucket:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageAnalysisCoordinator.java`: 这是一个AWS Lambda函数，当新图像上传到S3存储桶时被触发：'
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ImageAnalysisCoordinator` class is an AWS Lambda function that serves
    as the entry point for the serverless AI image analysis architecture. Its primary
    responsibilities are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageAnalysisCoordinator`类是一个AWS Lambda函数，作为服务器端AI图像分析架构的入口点。其主要职责如下：'
- en: Extracting the S3 bucket and object key information from the incoming S3 event
    that triggers the Lambda function
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从触发 Lambda 函数的传入 S3 事件中提取 S3 存储桶和对象键信息。
- en: Initiating a Fargate task to perform the computationally intensive image analysis
    by launching an ECS task and passing the necessary environment variables (bucket
    and key)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过启动 ECS 任务并传递必要的环境变量（存储桶和键）来启动 Fargate 任务以执行计算密集型的图像分析。
- en: Handling any errors that occur during the Fargate task launch process and returning
    appropriate status messages
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理在 Fargate 任务启动过程中发生的任何错误，并返回适当的状态消息。
- en: This Lambda function acts as a lightweight coordinator, responsible for orchestrating
    the overall image analysis workflow. It triggers the more resource-intensive processing
    to be performed by the Fargate container, which runs the `FargateImageAnalyzer`
    application. By separating the responsibilities in this way, the architecture
    achieves efficient resource utilization and scalability.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Lambda 函数充当轻量级协调器，负责协调整体图像分析工作流程。它触发由运行 `FargateImageAnalyzer` 应用的 Fargate
    容器执行的资源密集型处理。通过这种方式分离责任，该架构实现了高效的资源利用和可扩展性。
- en: '**Step 3: Build** **the projects**:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 3 步：构建** **项目**：'
- en: 'For the Lambda function, run the following command to package the function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Lambda 函数，运行以下命令来打包函数：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the Fargate container, run the following command to build the Docker image:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Fargate 容器，运行以下命令来构建 Docker 镜像：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Step** **4: Deploy**:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 4 步：部署**：'
- en: 'To streamline the deployment of the serverless AI infrastructure, an AWS CloudFormation
    template has been prepared. This template automates the entire deployment process,
    including the following steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化无服务器 AI 基础设施的部署，已准备了一个 AWS CloudFormation 模板。此模板自动化整个部署过程，包括以下步骤：
- en: 'Create the necessary AWS resources, such as the following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的 AWS 资源，例如以下内容：
- en: S3 bucket for storing the images and analysis results
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: S3 存储桶用于存储图像和分析结果。
- en: ECS cluster and task definition for the Fargate container
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fargate 容器的 ECS 集群和任务定义。
- en: Lambda function for the `ImageAnalysisCoordinator` class
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageAnalysisCoordinator` 类的 Lambda 函数。'
- en: Upload the built artifacts (Lambda function `.jar` file and Docker image) to
    the appropriate locations.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建的工件（Lambda 函数 `.jar` 文件和 Docker 镜像）上传到适当的位置。
- en: Configure the necessary permissions and triggers for the Lambda function to
    be invoked when an image is uploaded to the S3 bucket.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Lambda 函数所需的权限和触发器，以便在图像上传到 S3 存储桶时调用。
- en: Deploy the Fargate task definition and set up the necessary network configurations.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署 Fargate 任务定义并设置必要的网络配置。
- en: To use the CloudFormation template, you can find it in the book’s accompanying
    GitHub repository alongside the source code. Simply download the template, fill
    in any necessary parameters, and deploy it using the AWS CloudFormation service.
    This will set up the entire serverless AI infrastructure for you, streamlining
    the deployment process and ensuring consistency across different environments.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 CloudFormation 模板，您可以在本书的配套 GitHub 仓库中找到它，与源代码一起。只需下载模板，填写任何必要的参数，然后使用 AWS
    CloudFormation 服务部署它。这将为您设置整个无服务器 AI 基础设施，简化部署过程并确保不同环境之间的一致性。
- en: Emerging concurrency and parallel processing tools in Java
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 中出现的并发和并行处理工具。
- en: As Java continues to evolve, new tools and frameworks are being developed to
    address the growing demands of concurrent and parallel programming. These advancements
    aim to simplify development, improve performance, and enhance scalability in modern
    applications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Java 的不断发展，新的工具和框架正在被开发出来，以解决并发和并行编程不断增长的需求。这些进步旨在简化开发、提高性能并增强现代应用程序的可扩展性。
- en: Introduction to Project Loom – virtual threads for efficient concurrency
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Project Loom 简介 – 高效并发的虚拟线程。
- en: '**Project Loom** is an ambitious initiative by the OpenJDK community to enhance
    Java’s concurrency model. The primary goal is to simplify writing, maintaining,
    and observing high-throughput concurrent applications by introducing virtual threads
    (also known as **fibers**).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**Project Loom** 是 OpenJDK 社区的一项雄心勃勃的倡议，旨在通过引入虚拟线程（也称为 **fibers**）来增强 Java
    的并发模型。主要目标是简化编写、维护和观察高吞吐量并发应用程序，使其更加容易。'
- en: Virtual threads are lightweight and are managed by the Java runtime rather than
    the OS. Unlike traditional threads, which are limited by the number of OS threads,
    virtual threads can scale to handle millions of concurrent operations without
    overwhelming system resources. They allow developers to write code in a synchronous
    style while achieving the scalability of asynchronous models.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程轻量级，由 Java 运行时管理，而不是操作系统。与传统线程受限于操作系统线程数量不同，虚拟线程可以扩展以处理数百万个并发操作，而不会耗尽系统资源。它们允许开发者以同步风格编写代码，同时实现异步模型的可扩展性。
- en: 'Its key features include the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 其关键特性包括以下内容：
- en: '**Lightweight nature**: Virtual threads are much lighter than traditional OS
    threads, reducing memory and context-switching overhead'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级特性**：虚拟线程比传统的操作系统线程轻得多，减少了内存和上下文切换的开销'
- en: '**Blocking calls**: They handle blocking calls efficiently, suspending only
    the virtual thread while keeping the underlying OS thread available for other
    tasks'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞调用**：它们高效地处理阻塞调用，仅挂起虚拟线程，同时保持底层操作系统线程可用于其他任务'
- en: '**Simplicity**: Developers can write straightforward, readable code using familiar
    constructs such as loops and conditionals without resorting to complex asynchronous
    paradigms'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：开发者可以使用熟悉的构造，如循环和条件语句编写简单、易读的代码，而无需依赖复杂的异步范式'
- en: To illustrate the practical application of Project Loom and virtual threads,
    let’s explore a code example that demonstrates implementing a high-concurrency
    microservice using Project Loom and Akka within an AWS cloud environment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 Project Loom 和虚拟线程的实际应用，让我们探索一个代码示例，该示例展示了如何在 AWS 云环境中使用 Project Loom 和
    Akka 实现一个高并发微服务。
- en: Code example – implementing a high-concurrency microservice using Project Loom
    and Akka for the AWS cloud environment
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 - 使用 Project Loom 和 Akka 在 AWS 云环境中实现高并发微服务
- en: 'In this section, we will demonstrate how to implement a high-concurrency microservice
    using Project Loom and Akka, designed to run in an AWS cloud environment. This
    example will showcase how to leverage virtual threads from Project Loom and the
    actor model provided by Akka to build a scalable and efficient microservice:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用 Project Loom 和 Akka 实现一个高并发微服务，该服务设计用于在 AWS 云环境中运行。此示例将展示如何利用
    Project Loom 的虚拟线程和 Akka 提供的演员模型构建一个可扩展且高效的微服务：
- en: '`pom.xml` dependencies:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml` 依赖项：'
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Step 2:** **Code implementation**:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2**：**代码实现**：'
- en: '`HighConcurrencyService.java`: The main entry point for the service, which
    sets up `ActorSystem` and uses `ExecutorService` to manage virtual threads:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`HighConcurrencyService.java`：服务的主要入口点，它设置 `ActorSystem` 并使用 `ExecutorService`
    管理虚拟线程：'
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `HighConcurrencyService` class serves as the entry point for a high-concurrency
    microservice application designed to handle numerous requests efficiently. Utilizing
    Akka’s actor model and Java’s concurrency features, this class demonstrates how
    to manage thousands of concurrent tasks effectively. The main function initializes
    `ActorSystem` for creating and managing actors, sets up an S3 client for interacting
    with AWS S3 services, and employs an executor service to submit multiple tasks.
    Each task involves creating a new actor instance to handle a specific request,
    showcasing how to leverage virtual threads and actors for scalable and concurrent
    processing in a cloud environment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`HighConcurrencyService` 类作为高并发微服务应用的入口点，旨在高效处理大量请求。利用 Akka 的演员模型和 Java 的并发特性，此类展示了如何有效地管理数千个并发任务。主函数初始化
    `ActorSystem` 以创建和管理演员，设置 S3 客户端以与 AWS S3 服务交互，并使用执行器服务提交多个任务。每个任务都涉及创建一个新的演员实例来处理特定的请求，展示了如何在云环境中利用虚拟线程和演员进行可扩展和并发处理。'
- en: '`RequestHandlerActor.java`: This actor handles individual requests to process
    data and interact with AWS S3:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestHandlerActor.java`：此演员处理单个请求以处理数据和与 AWS S3 交互：'
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `RequestHandlerActor` class defines the behavior of an actor responsible
    for handling individual requests in the high-concurrency microservice. It processes
    requests to store data in AWS S3 by utilizing the S3 client. The `HandleRequest`
    inner class encapsulates the details of a request, including the S3 bucket name,
    key, and content to be stored. The actor’s behavior is defined as receiving these
    `HandleRequest` messages, processing the request by interacting with the S3 service,
    and logging the result. This class exemplifies the use of Akka’s actor model to
    manage and process concurrent tasks efficiently, ensuring scalability and robustness
    in cloud-based applications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestHandlerActor` 类定义了处理高并发微服务中单个请求的演员的行为。它通过使用 S3 客户端处理存储数据到 AWS S3 的请求。`HandleRequest`
    内部类封装了请求的详细信息，包括要存储的 S3 存储桶名称、键和内容。演员的行为定义为接收这些 `HandleRequest` 消息，通过与 S3 服务交互处理请求，并记录结果。此类展示了
    Akka 的演员模型在高效管理和处理并发任务方面的应用，确保了基于云应用程序的可扩展性和健壮性。'
- en: '**Step 3: Deployment** **to AWS**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：部署到 AWS**：'
- en: '**Dockerfile**: The Dockerfile should be created and saved in the root directory
    of your application project. This is the standard location for the Dockerfile,
    as it allows the Docker build process to access all the necessary files and resources
    without requiring additional context switches:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile**：Dockerfile 应该创建并保存在您的应用程序项目根目录中。这是 Dockerfile 的标准位置，因为它允许 Docker
    构建过程访问所有必要的文件和资源，而无需进行额外的上下文切换：'
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The key points about this Dockerfile are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此 Dockerfile 的要点如下：
- en: 'It uses the `amazoncorretto: 17-alpine` base image, which provides the Java
    17 runtime environment based on the Alpine Linux distribution'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '它使用基于 Alpine Linux 分发的 `amazoncorretto: 17-alpine` 基础镜像，该镜像提供了 Java 17 运行时环境'
- en: 'It follows a two-stage build process:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遵循两阶段构建过程：
- en: The *builder* stage compiles the application and packages it into a JAR file
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建器* 阶段编译应用程序并将其打包成 JAR 文件'
- en: The final stage copies the packaged JAR file and sets the entry point to run
    the application
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后阶段复制打包的 JAR 文件并设置入口点以运行应用程序
- en: '**Deploy using** **AWS ECS/Fargate**:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用** **AWS ECS/Fargate** **部署**：'
- en: 'We have also prepared a CloudFormation template for these processes, which
    can be found in the code repository. Follow these steps to deploy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还准备了一个 CloudFormation 模板用于这些流程，可以在代码仓库中找到。按照以下步骤进行部署：
- en: '**Create an ECS cluster and task definition in AWS**: Set up your ECS cluster
    and define the task that will run your Docker container.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 AWS 中创建 ECS 集群和任务定义**：设置您的 ECS 集群并定义将运行您的 Docker 容器的任务。'
- en: '**Upload the Docker image to Amazon Elastic Container Registry (ECR)**: Push
    the Docker image to Amazon ECR for easy deployment.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将 Docker 镜像上传到 Amazon Elastic Container Registry (ECR)**：将 Docker 镜像推送到 Amazon
    ECR 以便于部署。'
- en: '**Configure ECS service to use Fargate and run the container**: Configure your
    ECS service to use AWS Fargate, a serverless compute engine, to run the containerized
    application.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置 ECS 服务以使用 Fargate 并运行容器**：配置您的 ECS 服务以使用 AWS Fargate，一个无服务器计算引擎，来运行容器化应用程序。'
- en: This streamlined process ensures that your high-concurrency microservice is
    efficiently deployed in a scalable cloud environment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此简化流程确保您的 高并发微服务在可扩展的云环境中高效部署。
- en: This high-concurrency microservice example demonstrates the power of leveraging
    Project Loom’s virtual threads and Akka’s actor model to build scalable, efficient,
    and cloud-ready applications. By harnessing these advanced concurrency tools,
    developers can simplify their code, improve resource utilization, and enhance
    the overall performance and responsiveness of their services, particularly in
    the context of the AWS cloud environment. This lays the foundation for exploring
    the next wave of cloud innovations, where emerging technologies such as AWS Graviton
    processors and Google Cloud Spanner can further enhance the scalability and capabilities
    of cloud-based applications.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此高并发微服务示例展示了利用 Project Loom 的虚拟线程和 Akka 的演员模型构建可扩展、高效且适用于云的应用程序的力量。通过利用这些高级并发工具，开发者可以简化代码，提高资源利用率，并提升其服务的整体性能和响应速度，尤其是在
    AWS 云环境背景下。这为探索下一波云创新奠定了基础，其中新兴技术如 AWS Graviton 处理器和 Google Cloud Spanner 可以进一步增强基于云应用程序的可扩展性和功能。
- en: Preparing for the next wave of cloud innovations
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备迎接下一波云创新
- en: 'As cloud technologies continue to evolve rapidly, developers and organizations
    must stay ahead of the curve. Anticipating advancements in cloud services, here’s
    how you can prepare for upcoming advancements in cloud services:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算技术的快速发展，开发者和组织必须保持领先。预测云计算服务的进步，以下是如何为即将到来的云计算服务进步做准备：
- en: '**AWS Graviton**: AWS Graviton is a family of ARM-based processors designed
    by AWS to offer improved price performance compared to traditional x86-based processors,
    particularly for workloads that can take advantage of the parallel processing
    capabilities of ARM architecture. The latest **Graviton3** iteration can provide
    up to 25% better performance and 60% better price performance than previous-generation
    Intel-based EC2 instances.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Graviton**：AWS Graviton 是 AWS 设计的基于 ARM 的处理器系列，旨在提供比传统 x86 基础处理器更好的性价比，尤其是对于可以利用
    ARM 架构并行处理能力的负载。最新的 **Graviton3** 版本可以提供比上一代基于 Intel 的 EC2 实例高达 25% 的性能提升和 60%
    的性价比提升。'
- en: '**Amazon Corretto**: On the other hand, Amazon Corretto is a no-cost, multiplatform,
    production-ready distribution of the OpenJDK, a free and open-source implementation
    of the Java platform. Corretto is available for both x86-based and ARM-based (including
    Graviton) architectures, providing a certified, tested, and supported version
    of the JDK for AWS customers. The ARM-based Corretto JDK is optimized to run on
    AWS Graviton-powered instances.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Corretto**：另一方面，Amazon Corretto 是一个无需付费、多平台、生产就绪的 OpenJDK 发行版，是 Java
    平台的免费开源实现。Corretto 支持基于 x86 和 ARM（包括 Graviton）的架构，为 AWS 客户提供经过认证、测试和支持的 JDK 版本。基于
    ARM 的 Corretto JDK 已针对 AWS Graviton 驱动的实例进行了优化。'
- en: 'Consider using the Amazon Corretto JDK. Here is a code snippet to build a Docker
    image:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用 Amazon Corretto JDK。以下是一个构建 Docker 镜像的代码片段：
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build and push run the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并推送以下命令：
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Google Cloud Spanner**: Cloud Spanner is a fully managed, scalable, relational
    database service offering strong consistency and high availability:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud Spanner**：Cloud Spanner 是一个完全托管、可扩展的关系型数据库服务，提供强一致性和高可用性：'
- en: '**Global distribution**: Spanner supports multi-regional and global deployment,
    providing high availability and low-latency access to data'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局分布**：Spanner 支持多区域和全球部署，提供高可用性和低延迟的数据访问'
- en: '**Strong consistency**: Unlike many NoSQL databases, Spanner maintains strong
    consistency, making it suitable for applications that require transactional integrity'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强一致性**：与许多 NoSQL 数据库不同，Spanner 维护强一致性，使其适用于需要事务完整性的应用程序'
- en: '**Seamless scaling**: Spanner automatically handles horizontal scaling, allowing
    applications to grow without compromising performance or availability'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无缝扩展**：Spanner 自动处理水平扩展，允许应用程序在不影响性能或可用性的情况下增长'
- en: '**Example**: Using Java with Cloud Spanner:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：使用 Java 与 Cloud Spanner：'
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code snippet demonstrates the use of the Java client library to interact
    with Google Cloud Spanner. The code first creates a Spanner client using the `SpannerOptions`
    builder and retrieves the service instance. It then gets a `DatabaseClient` instance,
    which is used to interact with a specific Spanner database identified by the `projectId`,
    `instanceId`, and `databaseId` parameters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段展示了使用 Java 客户端库与 Google Cloud Spanner 交互的使用方法。代码首先使用 `SpannerOptions` 构建器创建
    Spanner 客户端并检索服务实例。然后获取一个 `DatabaseClient` 实例，用于与由 `projectId`、`instanceId` 和
    `databaseId` 参数指定的特定 Spanner 数据库交互。
- en: Within a try-with-resources block, the code creates a single-use, read-only
    transaction using the `singleUse()` method and executes a `SQL SELECT` query to
    retrieve all records from the `Users` table. The results are then iterated through,
    and the `UserId` and `Name` columns are printed for each user record.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 try-with-resources 块中，代码使用 `singleUse()` 方法创建一个单次使用的只读事务，并执行一个 `SQL SELECT`
    查询以检索 `Users` 表中的所有记录。然后遍历结果，并为每个用户记录打印 `UserId` 和 `Name` 列。
- en: This example showcases the basic usage of the Google Cloud Spanner Java client
    library, including establishing a connection to the database, executing a query,
    and processing the results, while ensuring proper resource management and cleanup.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了 Google Cloud Spanner Java 客户端库的基本用法，包括建立数据库连接、执行查询和处理结果，同时确保适当的资源管理和清理。
- en: Quantum computing
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子计算
- en: '**Quantum computing**, though still in its early stages, promises to revolutionize
    various industries by solving complex problems that are infeasible for classical
    computers. Quantum computers leverage the principles of quantum mechanics, such
    as superposition and entanglement, to perform computations in parallel.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**量子计算**，尽管仍处于早期阶段，但通过解决经典计算机无法解决的复杂问题，有望彻底改变各个行业。量子计算机利用量子力学的原理，如叠加和纠缠，以并行的方式执行计算。'
- en: While not immediately practical for most applications, it’s beneficial to start
    learning about quantum computing principles and how they might apply to your domain.
    Key concepts to explore include qubits, quantum gates, and quantum algorithms
    such as Shor’s algorithm for factoring large numbers and Grover’s algorithm for
    search problems.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于大多数应用来说并不立即实用，但开始学习量子计算原理以及它们如何应用于您的领域是有益的。需要探索的关键概念包括量子比特、量子门以及如Shor算法（用于大数分解）和Grover算法（用于搜索问题）等量子算法。
- en: Understanding these principles will prepare you for future advancements and
    potential integration of quantum computing into your workflows. By familiarizing
    yourself with the foundational concepts now, you’ll be better positioned to take
    advantage of quantum computing as it becomes more accessible and applicable to
    real-world problems.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些原理将使您为未来的进步和量子计算与您的工作流程的潜在集成做好准备。通过现在熟悉基础概念，您将更好地定位自己，以便在量子计算变得更加易于获取并适用于现实世界问题时充分利用它。
- en: Staying informed and exploring these technologies, even at an introductory level,
    will help ensure your organization is ready to adapt and thrive in the rapidly
    evolving cloud landscape.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 保持信息灵通并探索这些技术，即使在入门级别，也将帮助确保您的组织准备好适应并在这快速发展的云环境中蓬勃发展。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As the final chapter of this book, we now stand at the precipice of the future,
    where cloud technologies continue to evolve at a breathtaking pace. In this concluding
    section, we explored the emerging trends and advancements that are poised to reshape
    the way we develop and deploy applications in the cloud, with a particular emphasis
    on Java’s pivotal role in shaping these innovations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的最后一章，我们现在站在未来的边缘，云技术正以惊人的速度持续发展。在本节的结尾部分，我们探讨了即将重塑我们在云中开发和部署应用程序方式的新兴趋势和进步，特别强调了Java在塑造这些创新中的关键作用。
- en: We began by delving into the evolution of serverless Java, where we saw how
    frameworks such as Quarkus and Micronaut are redefining the boundaries of function
    as a service. These cutting-edge tools leverage techniques such as native image
    compilation to deliver unprecedented performance and efficiency in serverless
    environments, while also enabling the deployment of full-fledged Java applications
    as serverless containers. This represents a significant shift, empowering developers
    to create highly scalable, responsive, and cloud-native applications that go beyond
    simple function executions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先深入研究了无服务器Java的演变，我们看到Quarkus和Micronaut等框架如何重新定义了函数即服务的边界。这些尖端工具利用原生图像编译等技术，在无服务器环境中提供前所未有的性能和效率，同时使完整的Java应用程序作为无服务器容器进行部署。这代表了一个重大转变，使开发者能够创建高度可扩展、响应迅速且云本地的应用程序，这些应用程序超越了简单的函数执行。
- en: Next, we turned our attention to the edge computing landscape, where data processing
    and decision-making are moving closer to the source. Java’s platform independence,
    performance, and extensive ecosystem make it an ideal choice for building edge
    applications. We introduced the key frameworks and tools that enable Java developers
    to leverage the power of edge computing, ensuring their applications can seamlessly
    integrate with this rapidly advancing paradigm.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将注意力转向边缘计算领域，数据处理和决策正越来越接近源头。Java的平台独立性、性能和广泛的生态系统使其成为构建边缘应用的理想选择。我们介绍了关键框架和工具，这些框架和工具使Java开发者能够利用边缘计算的力量，确保他们的应用程序能够无缝集成这一快速发展的范式。
- en: Furthermore, we explored Java’s evolving role in the integration of AI and ML
    within cloud-based ecosystems. From serverless AI/ML workflows to the seamless
    integration of Java with cloud-based AI services, we uncovered the opportunities
    and challenges that this convergence presents, equipping you with the knowledge
    to harness the power of these technologies in your Java-based applications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了 Java 在云生态系统内 AI 和 ML 集成中不断发展的作用。从无服务器 AI/ML 工作流到 Java 与基于云的 AI 服务的无缝集成，我们揭示了这种融合带来的机遇和挑战，为你提供了利用这些技术在基于
    Java 的应用程序中发挥其力量的知识。
- en: Finally, we ventured into the captivating realm of quantum computing, a field
    that promises to revolutionize various industries. While still in its early stages,
    understanding the fundamental principles of quantum computing, such as qubits,
    quantum gates, and algorithms, can prepare developers for future advancements
    and their potential integration with Java-based applications.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们勇敢地进入了迷人的量子计算领域，这个领域承诺将彻底改变各个行业。尽管仍处于早期阶段，但理解量子计算的基本原理，如量子比特、量子门和算法，可以为开发者准备未来的进步以及它们与基于
    Java 的应用的潜在集成。
- en: As we conclude this book, you now possess a comprehensive understanding of the
    emerging trends in cloud computing and Java’s pivotal role in shaping these innovations.
    Armed with this knowledge, you are poised to position your applications and infrastructure
    for success in the rapidly evolving cloud landscape, ensuring your organization
    can adapt and thrive in the years to come.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的结束，你现在对云计算的兴起趋势和 Java 在塑造这些创新中的关键作用有了全面的理解。凭借这些知识，你将能够为你的应用程序和基础设施在快速发展的云计算环境中取得成功定位，确保你的组织能够在未来几年中适应并蓬勃发展。
- en: Questions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a key benefit of using Quarkus and GraalVM for building serverless Java
    applications?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Quarkus 和 GraalVM 构建无服务器 Java 应用程序的关键好处是什么？
- en: Improved startup time and reduced memory usage
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改善启动时间和减少内存使用
- en: Easier integration with cloud-based AI/ML services
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更容易与基于云的 AI/ML 服务集成
- en: Seamless deployment across multiple cloud providers
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多个云提供商之间无缝部署
- en: All of the above
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述选项
- en: Which of the following is a key advantage of using Java in edge computing environments?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是使用 Java 在边缘计算环境中使用的关键优势？
- en: Platform independence
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平台独立性
- en: Extensive library support
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 广泛的库支持
- en: Robust security model
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强大的安全模型
- en: All of the above
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述选项
- en: Which cloud AI service allows Java developers to easily train and deploy custom
    ML models without extensive ML expertise?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个云人工智能服务允许 Java 开发者轻松训练和部署定制的机器学习模型，而无需广泛的机器学习专业知识？
- en: AWS SageMaker
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AWS SageMaker
- en: Google Cloud AutoML
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google Cloud AutoML
- en: Microsoft Azure Cognitive Services
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微软 Azure 认知服务
- en: IBM Watson Studio
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: IBM Watson Studio
- en: Which quantum computing concept is demonstrated in the provided code example
    that puts a qubit into superposition and measures the outcome?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的代码示例中，哪个量子计算概念展示了将量子比特置于叠加并测量结果？
- en: Quantum entanglement
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 量子纠缠
- en: Quantum teleportation
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 量子传输
- en: Quantum superposition
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 量子叠加
- en: Quantum tunneling
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 量子隧穿
- en: What is a key benefit of using serverless containers for Java applications in
    the cloud?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无服务器容器在云中为 Java 应用程序构建的关键好处是什么？
- en: Reduced operational overhead for managing infrastructure
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 降低管理基础设施的运营开销
- en: Increased cold start times for serverless functions
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器函数的冷启动时间增加
- en: Inability to include custom libraries and dependencies
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法包含自定义库和依赖项
- en: Limited control over the runtime environment
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对运行时环境的有限控制
- en: 'Appendix A: Setting up a Cloud-Native Java Environment'
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A：设置云原生 Java 环境
- en: 'In [*Appendix A*](B20937_AppA.xhtml#_idTextAnchor321), you will learn how to
    set up a cloud-native environment for Java applications. This comprehensive guide
    covers everything from building and packaging Java applications to deploying them
    on popular cloud platforms like **Amazon Web Services** (**AWS**), **Microsoft
    Azure**, and **Google Cloud Platform** (**GCP**). Key topics include:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*附录 A*](B20937_AppA.xhtml#_idTextAnchor321)中，你将学习如何为 Java 应用程序设置云原生环境。本指南全面涵盖了从构建和打包
    Java 应用程序到在流行的云平台（如**亚马逊网络服务**（**AWS**）、**微软 Azure**和**谷歌云平台**（**GCP**））上部署它们的所有内容。关键主题包括：
- en: '**Building and packaging**: Step-by-step instructions on using build tools
    like Maven and Gradle to create and manage Java projects.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建和打包**：使用 Maven 和 Gradle 等构建工具创建和管理 Java 项目的逐步说明。'
- en: '**Ensuring cloud-readiness**: Best practices for making your Java applications
    stateless and configurable to thrive in cloud environments.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保云就绪**：使Java应用程序无状态和可配置的最佳实践，以便在云环境中茁壮成长。'
- en: '**Containerization**: How to create Docker images for your Java applications
    and deploy them using Docker.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化**：如何为Java应用程序创建Docker镜像并使用Docker进行部署。'
- en: '**Cloud deployments**: Detailed procedures for deploying Java applications
    on AWS, Azure, and GCP, including setting up the necessary cloud environments,
    creating and managing cloud resources, and using specific cloud services like
    Elastic Beanstalk, Kubernetes, and serverless functions.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云部署**：在AWS、Azure和GCP上部署Java应用程序的详细步骤，包括设置必要的云环境、创建和管理云资源，以及使用特定的云服务如Elastic
    Beanstalk、Kubernetes和无服务器函数。'
- en: By the end of this appendix, you will have a solid understanding of how to effectively
    build, package, containerize, and deploy Java applications in a cloud-native environment.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到附录结束时，你将牢固地理解如何有效地构建、打包、容器化和部署Java应用程序到云原生环境中。
- en: General approach – build and package Java applications
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用方法 - 构建和打包Java应用程序
- en: This section provides a detailed guide on the essential steps required to build
    and package your Java applications, ensuring they are ready for deployment in
    a cloud environment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了构建和打包Java应用程序的必要步骤的详细指南，确保它们在云环境中部署就绪。
- en: Ensure your app is cloud-ready
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的应用程序已准备好云部署
- en: '`application.properties` or `application.yaml` files, or by using a configuration
    management tool. Here is an example:'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`application.properties`或`application.yaml`文件，或使用配置管理工具来配置。以下是一个示例：
- en: '[PRE25]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Use a Build tool like Maven or Gradle
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用构建工具如Maven或Gradle
- en: '`pom.xml` file in your project root directory if it doesn’t already exist.
    Add the necessary dependencies. Here is an example of `pom.xml`:'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的项目根目录中还没有`pom.xml`文件，请添加必要的依赖项。以下是一个`pom.xml`的示例：
- en: '[PRE26]'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`build.gradle` file in your project root directory if it doesn’t already exist.
    Add the necessary dependencies, here is an example of `build.gradle`:'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的项目根目录中还没有`build.gradle`文件，请添加必要的依赖项，以下是一个`build.gradle`的示例：
- en: '[PRE27]'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Build the JAR file**: Build the JAR file using Maven or Gradle.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建JAR文件**：使用Maven或Gradle构建JAR文件。'
- en: '**Maven**: Run the following command:'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**：运行以下命令：'
- en: '[PRE28]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command will generate a JAR file in the target directory, typically named
    `myapp-1.0-SNAPSHOT.jar`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在目标目录中生成一个JAR文件，通常命名为`myapp-1.0-SNAPSHOT.jar`。
- en: '**Gradle**: Run the following command:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gradle**：运行以下命令：'
- en: '[PRE29]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command will generate a JAR file in the build/libs directory, typically
    named `myapp-1.0-SNAPSHOT.jar`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在build/libs目录中生成一个JAR文件，通常命名为`myapp-1.0-SNAPSHOT.jar`。
- en: 'Note:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: If you are not using containers, you can stop here. The JAR file located in
    the target or build/libs directory can now be used to run your application directly.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用容器，你可以在这里停止。位于目标或build/libs目录中的JAR文件现在可以直接用来运行你的应用程序。
- en: Containerize your application using Docker
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker容器化你的应用程序
- en: '**Create a Dockerfile**: Create a Dockerfile in your project root directory
    with the following content:'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建Dockerfile**：在你的项目根目录中创建一个Dockerfile，内容如下：'
- en: '[PRE30]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Make sure to adjust the COPY instruction if your JAR file is located in a different
    directory or has a different name.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保根据你的JAR文件所在的不同目录或不同的名称调整COPY指令。
- en: '**Build the** **Docker Image**:'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建Docker镜像**：'
- en: 'Build the Docker image using the Docker build command. Run this command in
    the directory where your Dockerfile is located:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Docker build命令构建Docker镜像。在你的Dockerfile所在目录中运行此命令：
- en: '[PRE31]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command will create a Docker image named `myapp` with the tag `1.0`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将创建一个名为`myapp`的Docker镜像，带有标签`1.0`。
- en: '**Run the Docker Container**: Run the Docker container using the docker run
    command:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行Docker容器**：使用docker run命令运行Docker容器：'
- en: '[PRE32]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command will start a container from the `myapp:1.0` image and map port
    `8080` of the container to port 8080 on your host machine.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将从`myapp:1.0`镜像启动一个容器，并将容器的8080端口映射到宿主机的8080端口。
- en: This section provides a detailed guide on the essential steps required to build
    and package your Java applications, ensuring they are ready for deployment in
    a cloud environment.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了构建和打包Java应用程序的必要步骤的详细指南，确保它们在云环境中部署就绪。
- en: After learning how to build and package your Java applications, the next step
    is to explore the specific procedures for deploying these applications on popular
    cloud platforms.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何构建和打包您的Java应用程序之后，下一步是探索在流行的云平台上部署这些应用程序的具体步骤。
- en: '**Step-by-step guides for deploying Java applications on popular** **cloud
    platforms:**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**逐步指南：在流行的云平台上部署Java应用程序：**'
- en: Setting Up the AWS environment
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置AWS环境：
- en: '`aws configure` and enter your AWS Access Key, Secret Key, region, and output
    format.'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aws configure`并输入您的AWS访问密钥、秘密密钥、区域和输出格式。'
- en: '`trust-policy.json`'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`trust-policy.json`'
- en: '[PRE33]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Deploy your Java application to AWS using WAS CLI: Elastic Beanstalk (PaaS)'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用WAS CLI将Java应用程序部署到AWS：Elastic Beanstalk（PaaS）
- en: 'Create the IAM role:'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建IAM角色：
- en: '[PRE34]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Attach the required policies to the role:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的策略附加到角色：
- en: '[PRE35]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the instance profile:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实例配置文件：
- en: '[PRE36]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the role to the instance profile:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角色添加到实例配置文件：
- en: '[PRE37]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Deploying to Elastic Beanstalk
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到Elastic Beanstalk：
- en: 'Create an Elastic Beanstalk Application:'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Elastic Beanstalk应用程序：
- en: '[PRE38]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Create a new Elastic Beanstalk environment using the latest Corretto 21 version
    on Amazon Linux 2023.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最新的Corretto 21版本在Amazon Linux 2023上创建一个新的Elastic Beanstalk环境。
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Uploads `my-application.jar` to the deployments folder in the my-bucket S3 bucket.
    Adjust the parameters as needed for your specific use case.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`my-application.jar`上传到my-bucket S3存储桶中的部署文件夹。根据您的特定用例调整参数。
- en: '[PRE40]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create a new application version in Elastic Beanstalk
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Elastic Beanstalk中创建新的应用程序版本：
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Update the Elastic Beanstalk environment to use the new application version
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Elastic Beanstalk环境以使用新的应用程序版本
- en: '[PRE42]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Check the environment health
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查环境健康：
- en: '[PRE43]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Deploy your Java application: ECS (Containers)'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署您的Java应用程序：ECS（容器）
- en: 'Push the Docker image to Amazon **Elastic Container Registry** (**ECR**): First,
    create an ECR repository:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker镜像推送到Amazon **弹性容器注册库**（**ECR**）：首先，创建一个ECR存储库：
- en: '[PRE44]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Authenticate Docker to your ECR:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker认证到您的ECR：
- en: '[PRE45]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Tag your Docker image:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记您的Docker镜像：
- en: '[PRE46]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Push your Docker image to ECR:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的Docker镜像推送到ECR：
- en: '[PRE47]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Set up `task-definition.json` with the task definition configuration:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任务定义配置设置`task-definition.json`：
- en: '[PRE48]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Register the task definition:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册任务定义：
- en: '[PRE49]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a Cluster:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建集群：
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Create a Service**: Create a service using the following command:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建服务**：使用以下命令创建服务：'
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Important notes
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项：
- en: Replace subnet-XXXXXXXXXXXXXXXXX with the actual ID of the subnet where you
    want to run your tasks.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 将subnet-XXXXXXXXXXXXXXXXX替换为您要运行任务的子网的实际ID。
- en: Replace sg-XXXXXXXXXXXXXXXXX with the actual ID of the security group you want
    to associate with your tasks.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将sg-XXXXXXXXXXXXXXXXX替换为您要关联任务的实际安全组ID。
- en: This command uses forward slashes (\) for line continuation, which is appropriate
    for Unix-like environments (Linux, macOS, Git Bash on Windows).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用正斜杠（\）进行行续接，这在Unix-like环境中（Linux、macOS、Windows上的Git Bash）是合适的。
- en: For Windows Command Prompt, replace the backslashes (\) with caret symbols (^)
    for line continuation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows命令提示符，将反斜杠（\）替换为连字符符号（^）以进行行续接。
- en: For PowerShell, use backticks (`) at the end of each line instead of backslashes
    for line continuation.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PowerShell，在每个行的末尾使用反引号（`）而不是反斜杠进行行续接。
- en: The --desired-count 1 parameter specifies that you want one task running at
    all times.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: --desired-count 1参数指定您希望始终运行一个任务。
- en: The --launch-type FARGATE parameter specifies that this service will use AWS
    Fargate, which means you don’t need to manage the underlying EC2 instances.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: --launch-type FARGATE参数指定此服务将使用AWS Fargate，这意味着您不需要管理底层的EC2实例。
- en: Deploy your Java serverless Lambda function
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署您的无服务器Java Lambda函数
- en: 'Create an AWS Lambda function role:'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建AWS Lambda函数角色：
- en: '[PRE52]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Attach the `AWSLambdaBasicExecutionRole` policy to the role:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AWSLambdaBasicExecutionRole`策略附加到角色：
- en: '[PRE53]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create the Lambda function:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Lambda函数：
- en: '[PRE54]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Invoke the Lambda function**: When using the aws lambda invoke command to
    test your AWS Lambda function, it’s important to update the --payload parameter
    to match the expected input format of your specific Lambda function.'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用Lambda函数**：当使用aws lambda invoke命令测试您的AWS Lambda函数时，更新--payload参数以匹配您特定Lambda函数的预期输入格式非常重要。'
- en: '[PRE55]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Check the response:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查响应：
- en: '[PRE56]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that you have an understanding of how to set up a cloud-native Java environment
    and deploy your applications on various cloud platforms, you may want to dive
    deeper into specific cloud services. The following links provide additional resources
    and documentation to help you further your knowledge and skills in deploying and
    managing Java applications in the cloud.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了如何设置云原生 Java 环境，并在各种云平台上部署应用程序，您可能想深入了解特定的云服务。以下链接提供了额外的资源和文档，以帮助您进一步了解和掌握在云中部署和管理
    Java 应用程序的知识和技能。
- en: Useful links for further information on AWS
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS 的有用链接，以获取更多关于 AWS 的信息
- en: '**Amazon EC2**: Getting Started with Amazon EC2 ([https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html))'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon EC2**：Amazon EC2 入门指南（[https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html)）'
- en: '**AWS Elastic Beanstalk**: Getting Started with AWS Elastic Beanstalk ([https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html))'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Elastic Beanstalk**：AWS Elastic Beanstalk 入门指南（[https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html)）'
- en: '**Amazon ECS**: Getting Started with Amazon ECS ([https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html))'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon ECS**：Amazon ECS 入门指南（[https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html)）'
- en: '**AWS Lambda**: Getting Started with AWS Lambda ([https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html](https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html))'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Lambda**：AWS Lambda 入门指南（[https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html](https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html)）'
- en: '**Managing environment variables**: Best practices for managing environment
    variables in AWS Lambda ([https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html))'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理环境变量**：在 AWS Lambda 中管理环境变量的最佳实践（[https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html)）'
- en: Microsoft Azure
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软 Azure
- en: In this section, you will learn the steps required to deploy Java applications
    on Microsoft Azure. This includes setting up the Azure environment, deploying
    applications on virtual machines and containers, and utilizing **Azure Kubernetes
    Service** (**AKS**) for containerized applications. Additionally, you will explore
    how to deploy Java functions on Azure Functions, enabling you to leverage serverless
    computing for your Java applications.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习部署 Java 应用程序在 Microsoft Azure 上的步骤。这包括设置 Azure 环境、在虚拟机和容器上部署应用程序，以及利用
    **Azure Kubernetes 服务**（**AKS**）为容器化应用程序。此外，您还将了解如何在 Azure Functions 上部署 Java
    函数，使您能够利用无服务器计算来部署 Java 应用程序。
- en: 'Set up the Azure environment:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Azure 环境：
- en: '**Download and install Azure CLI**: Follow the official installation instructions
    for your operating system from the Azure CLI installation guide ([https://learn.microsoft.com/en-us/cli/azure/install-azure-cli](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli)).'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载并安装 Azure CLI**：请从 Azure CLI 安装指南中根据您的操作系统遵循官方安装说明（[https://learn.microsoft.com/en-us/cli/azure/install-azure-cli](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli)）。'
- en: '**Configure Azure CLI**: Open your terminal or command prompt and run the following
    command to log in to your Azure account:'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置 Azure CLI**：打开您的终端或命令提示符，并运行以下命令以登录您的 Azure 账户：'
- en: '[PRE57]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Follow the instructions to log in to your Azure account.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照说明登录您的 Azure 账户。
- en: Next, you will learn how to deploy a regular Java application on Azure Virtual
    Machines.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何在 Azure 虚拟机上部署常规 Java 应用程序。
- en: '**Deploying a Regular Java Application on Azure** **Virtual Machines**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 Azure 虚拟机上部署常规 Java 应用程序** **虚拟机**'
- en: 'Create a Resource Group:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建资源组：
- en: '[PRE58]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a Virtual Machine:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟机：
- en: '[PRE59]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Open port 8080:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 8080 端口：
- en: '[PRE60]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'SSH into the VM:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到 VM：
- en: '[PRE61]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Install Java on the VM:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VM 上安装 Java：
- en: '[PRE62]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Transfer and Run the JAR File:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转移并运行 JAR 文件：
- en: '[PRE63]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Once you have successfully deployed your Java application on an Azure Virtual
    Machine, you can manage and scale your application as needed using the Azure portal
    and CLI tools. This approach provides a solid foundation for running traditional
    Java applications in a cloud environment.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 Azure 虚拟机上成功部署了你的 Java 应用程序，你可以使用 Azure 门户和 CLI 工具根据需要管理和扩展你的应用程序。这种方法为在云环境中运行传统的
    Java 应用程序提供了坚实的基础。
- en: Next, you will learn how to deploy a Java application in containers using AKS,
    which offers a more flexible and scalable solution for containerized applications.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用 AKS 部署 Java 应用程序到容器中，AKS 为容器化应用程序提供了一个更灵活和可扩展的解决方案。
- en: '**Deploying a Java Application in Containers** **on AKS**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 AKS 上部署 Java 应用程序到容器**'
- en: 'Create an **Azure Container** **Registry** (**ACR**):'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **Azure 容器注册库**（**ACR**）：
- en: '[PRE64]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Login to ACR:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 ACR：
- en: '[PRE65]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Tag and push Docker image to ACR:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记并推送 Docker 镜像到 ACR：
- en: '[PRE66]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create AKS Cluster:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 AKS 集群：
- en: '[PRE67]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Get AKS Credentials:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 AKS 凭据：
- en: '[PRE68]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Deploy the application to AKS:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序部署到 AKS：
- en: 'Create a Deployment YAML file (`deployment.yaml`):'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个部署 YAML 文件（`deployment.yaml`）：
- en: '[PRE69]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Apply the deployment:'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用部署：
- en: '[PRE70]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Expose the deployment:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露部署：
- en: '[PRE71]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This completes the process of deploying a containerized Java application to
    AKS. However, for scenarios where you need more granular control over your application’s
    execution or want to build serverless microservices, Azure Functions provides
    an excellent alternative. Next, you will learn how to deploy Java functions on
    Azure Functions, enabling you to take advantage of serverless computing for event-driven
    applications and microservices.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了将容器化 Java 应用程序部署到 AKS 的过程。然而，对于需要更细粒度控制应用程序执行或想要构建无服务器微服务的场景，Azure Functions
    提供了一个出色的替代方案。接下来，你将学习如何在 Azure Functions 上部署 Java 函数，使你能够利用无服务器计算为事件驱动应用程序和微服务提供支持。
- en: '**Deploying Java Functions on** **Azure Functions**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 Azure Functions 上部署 Java 函数**'
- en: 'Install Azure functions core tools:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Azure Functions 核心工具：
- en: '**Windows**: Use MSI installer ([https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp#v2](https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp#v2))'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**：使用 MSI 安装程序（[https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp#v2](https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp#v2)）'
- en: '**macOS**:'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**macOS**：'
- en: '[PRE72]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a new function app:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的函数应用：
- en: '[PRE73]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Build the function:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建函数：
- en: '[PRE74]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Deploy to Azure:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到 Azure：
- en: '[PRE75]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Notes
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: Replace placeholders like <vm-ip-address>, <your-region>, <FunctionAppName>,
    etc., with your actual values.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 将如 <vm-ip-address>、<your-region>、<FunctionAppName> 等占位符替换为你的实际值。
- en: 'For detailed information on configuring environment variables and managing
    configurations specifically for Azure environments, you can refer to the official
    Azure documentation:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置环境变量和管理 Azure 环境特定配置的详细信息，你可以参考官方 Azure 文档：
- en: '**Azure App Service configuration**: Configure apps in Azure App Service ([https://learn.microsoft.com/en-us/azure/app-service/configure-common?tabs=portal](https://learn.microsoft.com/en-us/azure/app-service/configure-common?tabs=portal))'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure App Service 配置**：配置 Azure App Service 中的应用程序（[https://learn.microsoft.com/en-us/azure/app-service/configure-common?tabs=portal](https://learn.microsoft.com/en-us/azure/app-service/configure-common?tabs=portal)）'
- en: '**AKS configuration**: Best practices for cluster and node pool configuration
    in AKS ([https://learn.microsoft.com/en-us/azure/aks/operator-best-practices-scheduler](https://learn.microsoft.com/en-us/azure/aks/operator-best-practices-scheduler))'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AKS 配置**：AKS 中集群和节点池配置的最佳实践（[https://learn.microsoft.com/en-us/azure/aks/operator-best-practices-scheduler](https://learn.microsoft.com/en-us/azure/aks/operator-best-practices-scheduler)）'
- en: '**Azure functions configuration**: Configure function app settings in Azure
    functions ([https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=azure-portal%2Cto-premium](https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=azure-portal%2Cto-premium))'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Functions 配置**：在 Azure Functions 中配置函数应用设置（[https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=azure-portal%2Cto-premium](https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=azure-portal%2Cto-premium)）'
- en: Now that you’ve learned how to deploy Java applications on various Azure services,
    including virtual machines, AKS, and Azure Functions, let’s explore another major
    cloud provider. The following section will guide you through similar deployment
    processes on GCP, allowing you to broaden your cloud deployment skills across
    different environments.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何在各种 Azure 服务上部署 Java 应用程序，包括虚拟机、AKS 和 Azure Functions，让我们探索另一个主要的云服务提供商。接下来的章节将指导您在
    GCP 上进行类似的部署过程，让您能够在不同的环境中扩展您的云部署技能。
- en: Google Cloud Platform
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Platform
- en: In this section, you’ll learn how to deploy Java applications on **Google Cloud
    Platform** or **GCP**, one of the leading cloud service providers. GCP offers
    a wide range of services that cater to various deployment needs, from virtual
    machines to containerized environments and serverless functions. We’ll cover the
    setup process for GCP and guide you through deploying Java applications using
    different GCP services, including **Google Compute Engine** (**GCE**), **Google
    Kubernetes Engine** (**GKE**), and Google Cloud Functions. This knowledge will
    empower you to leverage GCP’s robust infrastructure and services for your Java
    applications.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在 **Google Cloud Platform** 或 **GCP** 上部署 Java 应用程序，GCP 是领先的云服务提供商之一。GCP
    提供了一系列服务，满足各种部署需求，从虚拟机到容器化环境和无服务器函数。我们将介绍 GCP 的设置过程，并指导您使用不同的 GCP 服务部署 Java 应用程序，包括
    **Google Compute Engine** (**GCE**), **Google Kubernetes Engine** (**GKE**), 和
    Google Cloud Functions。这些知识将使您能够利用 GCP 强大的基础设施和服务来支持您的 Java 应用程序。
- en: Setting up the Google Cloud Environment
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Google Cloud 环境
- en: Create a Google Cloud account if you don’t have one.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有，请创建一个 Google Cloud 账户。
- en: Install the Google Cloud SDK. Follow the instructions for your operating system
    from the official Google Cloud SDK documentation ([https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install))
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Google Cloud SDK。请从官方 Google Cloud SDK 文档中获取您操作系统的说明（[https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install)）
- en: 'Initialize the Google Cloud SDK:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 Google Cloud SDK：
- en: '[PRE76]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Follow the prompts to log in and select your project.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按提示登录并选择您的项目。
- en: 'Set your project ID:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置您的项目 ID：
- en: '[PRE77]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With your Google Cloud environment successfully set up, you are now prepared
    to deploy and manage Java applications using GCP’s robust infrastructure. In the
    next sections, you will explore specific methods for deploying Java applications
    on GCE, GKE, and Google Cloud Functions.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功设置您的 Google Cloud 环境之后，您现在可以准备使用 GCP 强大的基础设施部署和管理 Java 应用程序。在接下来的章节中，您将探索在
    GCE、GKE 和 Google Cloud Functions 上部署 Java 应用程序的具体方法。
- en: Deploy your Java application to Google Cloud
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将您的 Java 应用程序部署到 Google Cloud
- en: '**GCE for regular** **Java Applications**:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**GCE 用于常规** **Java 应用程序**：'
- en: 'Create a VM instance:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟机实例：
- en: '[PRE78]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'SSH into the VM:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 SSH 登录到虚拟机：
- en: '[PRE79]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Install Java on the VM:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟机上安装 Java：
- en: '[PRE80]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Transfer your JAR file to the VM:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的 JAR 文件传输到虚拟机：
- en: '[PRE81]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run your Java application:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的 Java 应用程序：
- en: '[PRE82]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: By following these steps, you can efficiently deploy and manage your Java applications
    on Google Cloud, leveraging the various services and tools provided by GCP. With
    your Java application successfully deployed to Google Cloud, you are now ready
    to explore containerized deployments using GKE, which offers powerful orchestration
    capabilities for managing containers at scale.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，您可以在 Google Cloud 上高效地部署和管理您的 Java 应用程序，利用 GCP 提供的各种服务和工具。在您的 Java
    应用程序成功部署到 Google Cloud 之后，您现在可以探索使用 GKE 的容器化部署，GKE 提供了强大的编排能力来管理大规模的容器。
- en: GKE for containerized applications
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GKE 用于容器化应用程序
- en: In this section, you will learn how to deploy Java applications in containers
    using GKE. GKE provides a managed environment for deploying, managing, and scaling
    containerized applications using Kubernetes. You will be guided through setting
    up a GKE cluster, deploying your Docker images, and managing your containerized
    applications efficiently.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 GKE 在容器中部署 Java 应用程序。GKE 提供了一个管理环境，用于使用 Kubernetes 部署、管理和扩展容器化应用程序。您将指导设置
    GKE 集群、部署您的 Docker 镜像以及高效管理您的容器化应用程序。
- en: 'Create a GKE cluster:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 GKE 集群：
- en: '[PRE83]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Get credentials for the cluster:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取集群的凭证：
- en: '[PRE84]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Push your Docker image to **Google Container** **Registry** (**GCR**):'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的 Docker 镜像推送到 **Google Container** **Registry** (**GCR**)：
- en: '[PRE85]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create a Kubernetes deployment: Create a file named deployment.yaml:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Kubernetes 部署：创建一个名为 deployment.yaml 的文件：
- en: '[PRE86]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Apply the deployment:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用部署：
- en: '[PRE87]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Expose the deployment:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露部署：
- en: '[PRE88]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: By leveraging GKE, you can take full advantage of Kubernetes’ robust features
    to ensure your containerized Java applications are highly available, scalable,
    and easy to maintain.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 GKE，您可以充分利用 Kubernetes 的强大功能，确保您的容器化 Java 应用程序具有高可用性、可扩展性和易于维护。
- en: Google Cloud Functions for serverless Java functions
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Cloud Functions 用于无服务器 Java 函数
- en: In this section, you will learn how to deploy Java functions using Google Cloud
    Functions, enabling you to run event-driven code in a fully managed serverless
    environment. You will be guided through setting up your development environment,
    creating and deploying your Java functions, and managing them effectively using
    Google Cloud’s powerful serverless tools.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 Google Cloud Functions 部署 Java 函数，使您能够在完全托管的无服务器环境中运行事件驱动的代码。您将指导设置您的开发环境，创建和部署您的
    Java 函数，并使用 Google Cloud 的强大无服务器工具有效地管理它们。
- en: 'Create a new directory for your function:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的函数创建一个新的目录：
- en: '[PRE89]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Initialize a new Maven project:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的 Maven 项目：
- en: '[PRE90]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Add the necessary dependencies to your `pom.xml`:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将必要的依赖项添加到您的 `pom.xml`：
- en: '[PRE91]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create your function class:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您的函数类：
- en: '[PRE92]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Deploy the function:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署函数：
- en: '[PRE93]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: These instructions provide a basic setup for deploying Java applications to
    Google Cloud using different services. Remember to adjust the commands and configurations
    based on your specific application requirements and Google Cloud project settings.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明提供了将 Java 应用程序部署到 Google Cloud 的基本设置，使用不同的服务。请记住，根据您特定的应用程序需求和 Google Cloud
    项目设置调整命令和配置。
- en: Useful links for further information
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的链接以获取更多信息
- en: '**Google Compute Engine**: Get started creating and managing virtual machines
    in GCP with the Compute Engine quickstart guide: [https://cloud.google.com/compute/docs/quickstart](https://cloud.google.com/compute/docs/quickstart)'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Compute Engine**：使用计算引擎快速入门指南开始创建和管理 GCP 中的虚拟机：[https://cloud.google.com/compute/docs/quickstart](https://cloud.google.com/compute/docs/quickstart)'
- en: '**Google Kubernetes Engine**: Dive into container orchestration with GKE and
    deploy your first Kubernetes cluster using the GKE quickstart: [https://cloud.google.com/kubernetes-engine/docs/quickstart](https://cloud.google.com/kubernetes-engine/docs/quickstart)'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Kubernetes Engine**：通过 GKE 深入容器编排，使用 GKE 快速入门指南部署您的第一个 Kubernetes
    集群：[https://cloud.google.com/kubernetes-engine/docs/quickstart](https://cloud.google.com/kubernetes-engine/docs/quickstart)'
- en: '**Google Cloud Functions**: Develop and deploy serverless functions that respond
    to events with the Cloud Functions deployment guide: [https://cloud.google.com/functions/docs/deploying](https://cloud.google.com/functions/docs/deploying)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud Functions**：使用云函数部署指南开发和部署响应事件的函数：[https://cloud.google.com/functions/docs/deploying](https://cloud.google.com/functions/docs/deploying)'
- en: '**Managing environment** **variables**: [https://cloud.google.com/run/docs/configuring/services/environment-variables](https://cloud.google.com/run/docs/configuring/services/environment-variables)'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理环境变量** [https://cloud.google.com/run/docs/configuring/services/environment-variables](https://cloud.google.com/run/docs/configuring/services/environment-variables)'
- en: 'Appendix B: Resources and Further Reading'
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B：资源和进一步阅读
- en: Recommended books, articles, and online courses
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐的书籍、文章和在线课程
- en: Chapters 1–3
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1-3 章
- en: Books
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 书籍
- en: '*Cloud Native Java: Designing Resilient Systems with Spring Boot, Spring Cloud,
    and Cloud Foundry* by Josh Long and Kenny Bastani. This comprehensive guide offers
    practical insights into building scalable, resilient Java applications for cloud
    environments, covering Spring Boot, Spring Cloud, and Cloud Foundry technologies.
    Link: [https://www.amazon.com/Cloud-Native-Java-Designing-Resilient/dp/1449374646](https://www.amazon.com/Cloud-Native-Java-Designing-Resilient/dp/1449374646)'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*云原生 Java：使用 Spring Boot、Spring Cloud 和 Cloud Foundry 设计弹性系统*》由 Josh Long 和
    Kenny Bastani 著。这本综合指南提供了构建适用于云环境的可扩展、弹性 Java 应用程序的实际见解，涵盖了 Spring Boot、Spring
    Cloud 和 Cloud Foundry 技术。链接：[https://www.amazon.com/Cloud-Native-Java-Designing-Resilient/dp/1449374646](https://www.amazon.com/Cloud-Native-Java-Designing-Resilient/dp/1449374646)
- en: '*Java Concurrency in Practice* by Brian Goetz et al. A seminal work on Java
    concurrency, this book provides in-depth coverage of concurrent programming techniques,
    best practices, and pitfalls to avoid when developing multi-threaded applications.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Java 并发实践*》由 Brian Goetz 等人著。这是一部关于 Java 并发的开创性作品，本书深入介绍了并发编程技术、最佳实践以及开发多线程应用程序时需要避免的陷阱。
- en: '*Parallel and Concurrent Programming in Haskell* by Simon Marlow. While focused
    on Haskell, this book offers valuable insights into parallel programming concepts
    that can be applied to Java, providing a broader perspective on concurrent and
    parallel application design. Link: [https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/](https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/)'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Haskell 中的并行和并发编程》* 由 Simon Marlow 撰写。虽然专注于 Haskell，但本书提供了对并行编程概念的宝贵见解，这些概念可以应用于
    Java，为并发和并行应用程序设计提供了更广阔的视角。链接：[https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/](https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/)'
- en: '*Designing Distributed Systems: Patterns and Paradigms for Scalable, Reliable
    Services* by Brendan Burns (Microsoft Azure). This explores essential patterns
    for building scalable and reliable distributed systems, offering insights from
    Microsoft Azure’s experience in cloud computing. Link: [https://www.amazon.com/Designing-Distributed-Systems-Patterns-Paradigms/dp/1491983647](https://www.amazon.com/Designing-Distributed-Systems-Patterns-Paradigms/dp/1491983647)'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《设计分布式系统：构建可扩展、可靠服务的模式和范式》* 由 Brendan Burns（Microsoft Azure）撰写。本书探讨了构建可扩展和可靠分布式系统的基本模式，提供了来自微软
    Azure 在云计算方面的经验见解。链接：[https://www.amazon.com/Designing-Distributed-Systems-Patterns-Paradigms/dp/1491983647](https://www.amazon.com/Designing-Distributed-Systems-Patterns-Paradigms/dp/1491983647)'
- en: Articles
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文章
- en: '*Microservices Patterns* by Chris Richardson (microservices.io). A comprehensive
    guide to microservices architecture patterns, this article helps developers understand
    and implement effective microservices-based systems. Link: [https://microservices.io/patterns/index.html](https://microservices.io/patterns/index.html)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微服务模式》* 由 Chris Richardson（microservices.io）撰写。这是一本关于微服务架构模式的全面指南，帮助开发者理解和实施有效的基于微服务的系统。链接：[https://microservices.io/patterns/index.html](https://microservices.io/patterns/index.html)'
- en: '*A Java Fork/Join Framework* by Doug Lea. An in-depth look at the Fork/Join
    framework by its creator, providing valuable insights into its design and implementation
    for parallel processing in Java. Link: [http://gee.cs.oswego.edu/dl/papers/fj.pdf](http://gee.cs.oswego.edu/dl/papers/fj.pdf)'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Java Fork/Join 框架》* 由 Doug Lea 撰写。这是其创造者对 Fork/Join 框架的深入探讨，提供了关于其在 Java
    中实现并行处理的设计和实现的宝贵见解。链接：[http://gee.cs.oswego.edu/dl/papers/fj.pdf](http://gee.cs.oswego.edu/dl/papers/fj.pdf)'
- en: '*Amdahl’s Law in the Multicore Era* by Mark D. Hill and Michael R. Marty. This
    article offers a modern perspective on Amdahl’s Law and its implications for parallel
    computing, helping developers understand the limits and potential of parallel
    processing in contemporary systems. Link: [https://research.cs.wisc.edu/multifacet/papers/ieeecomputer08_amdahl_multicore.pdf](https://research.cs.wisc.edu/multifacet/papers/ieeecomputer08_amdahl_multicore.pdf)'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《多核时代下的 Amdahl 定律》* 由 Mark D. Hill 和 Michael R. Marty 撰写。这篇文章提供了对 Amdahl 定律的现代视角及其对并行计算的影响，帮助开发者理解当代系统中并行处理的局限性和潜力。链接：[https://research.cs.wisc.edu/multifacet/papers/ieeecomputer08_amdahl_multicore.pdf](https://research.cs.wisc.edu/multifacet/papers/ieeecomputer08_amdahl_multicore.pdf)'
- en: Online courses
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线课程
- en: '*Java Multithreading, Concurrency & Performance Optimization* by Udemy. This
    comprehensive course covers Java multithreading, concurrency, and performance
    optimization techniques, providing practical examples and hands-on exercises to
    master advanced Java programming concepts. Link:[https://www.udemy.com/course/java-multithreading-concurrency-performance-optimization/](https://www.udemy.com/course/java-multithreading-concurrency-performance-optimization/)'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Java 多线程、并发与性能优化》* 由 Udemy 提供。这门全面的课程涵盖了 Java 多线程、并发和性能优化技术，提供了实际示例和动手练习，以掌握高级
    Java 编程概念。链接：[https://www.udemy.com/course/java-multithreading-concurrency-performance-optimization/](https://www.udemy.com/course/java-multithreading-concurrency-performance-optimization/)'
- en: '*Concurrency in Java* by Coursera (offered by Rice University). Focusing on
    the foundational principles of concurrency in Java, this course offers practical
    exercises to solidify understanding of concurrent programming concepts and techniques.
    Link: [https://www.coursera.org/learn/concurrent-programming-in-java](https://www.coursera.org/learn/concurrent-programming-in-java)'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Java 并发编程》* 由 Coursera（由 Rice 大学提供）。该课程专注于 Java 并发的基础原则，提供了实际练习来巩固对并发编程概念和技术理解。链接：[https://www.coursera.org/learn/concurrent-programming-in-java](https://www.coursera.org/learn/concurrent-programming-in-java)'
- en: '*Reactive Programming in Modern Java using Project Reactor* by Udemy. A comprehensive
    course on reactive programming in Java using Project Reactor, teaching developers
    how to build reactive applications for better scalability and resilience in modern
    software architectures. Link: [https://www.udemy.com/course/reactive-programming-in-modern-java-using-project-reactor/](https://www.udemy.com/course/reactive-programming-in-modern-java-using-project-reactor/)'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Udemy 上的 *《使用 Project Reactor 在现代 Java 中进行响应式编程》*。这是一门关于使用 Project Reactor 在
    Java 中进行响应式编程的全面课程，教导开发者如何构建适用于现代软件架构中更好可扩展性和弹性的响应式应用。链接：[https://www.udemy.com/course/reactive-programming-in-modern-java-using-project-reactor/](https://www.udemy.com/course/reactive-programming-in-modern-java-using-project-reactor/)
- en: '*Parallel, Concurrent, and Distributed Programming in Java Specialization*
    on Coursera by Rice University. This specialization offers a comprehensive coverage
    of advanced concurrency topics in Java, including parallel, concurrent, and distributed
    programming techniques for developing high-performance applications. Link: [https://www.coursera.org/specializations/pcdp](https://www.coursera.org/specializations/pcdp)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Java 并行、并发与分布式编程专项课程》*，由莱斯大学在 Coursera 上提供。本专项课程全面覆盖了 Java 中的高级并发主题，包括用于开发高性能应用的并行、并发和分布式编程技术。链接：[https://www.coursera.org/specializations/pcdp](https://www.coursera.org/specializations/pcdp)'
- en: Key blogs and websites
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键博客和网站
- en: '*Baeldung* offers comprehensive tutorials and articles on Java, Spring, and
    related technologies, including in-depth content on concurrency and parallelism.
    Their concurrency section is particularly valuable for learning advanced Java
    threading concepts. Link: [https://www.baeldung.com/java-concurrency](https://www.baeldung.com/java-concurrency)'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Baeldung》* 提供了关于 Java、Spring 以及相关技术的全面教程和文章，包括关于并发和并行性的深入内容。他们的并发部分特别有价值，有助于学习高级
    Java 线程概念。链接：[https://www.baeldung.com/java-concurrency](https://www.baeldung.com/java-concurrency)'
- en: '*DZone Java Zone* is a community-driven platform, offering a wealth of articles,
    tutorials, and guides on Java and cloud-native development. The Java Zone is an
    excellent resource for staying up-to-date with the latest trends and best practices
    in Java development. Link: [https://dzone.com/java-jdk-development-tutorials-tools-news](https://dzone.com/java-jdk-development-tutorials-tools-news)'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《DZone Java 区》* 是一个社区驱动的平台，提供了大量关于 Java 和云原生开发的文章、教程和指南。Java 区是了解 Java 开发最新趋势和最佳实践的绝佳资源。链接：[https://dzone.com/java-jdk-development-tutorials-tools-news](https://dzone.com/java-jdk-development-tutorials-tools-news)'
- en: '*InfoQ Java* provides news, articles, and interviews on software development,
    with a strong focus on Java, concurrency, and cloud-native technologies. InfoQ
    is particularly useful for gaining insights into industry trends and emerging
    technologies in the Java ecosystem. Link: [https://www.infoq.com/java/](https://www.infoq.com/java/)'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《InfoQ Java》* 提供关于软件开发新闻、文章和访谈，重点在于 Java、并发和云原生技术。InfoQ 特别有助于深入了解 Java 生态系统中的行业趋势和新兴技术。链接：[https://www.infoq.com/java/](https://www.infoq.com/java/)'
- en: Chapters 4–6
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 4-6 章
- en: Books
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 书籍
- en: '*Patterns for Distributed Systems* by Unmesh Joshi (InfoQ)'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Unmesh Joshi（InfoQ）的 *《分布式系统模式》* '
- en: 'This book provides an overview of common patterns used in distributed systems,
    offering practical advice for designing robust and scalable architectures. Link:
    [https://www.amazon.com/Patterns-Distributed-Systems-Addison-Wesley-Signature/dp/0138221987](https://www.amazon.com/Patterns-Distributed-Systems-Addison-Wesley-Signature/dp/0138221987)'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书概述了在分布式系统中使用的常见模式，提供了设计稳健和可扩展架构的实用建议。链接：[https://www.amazon.com/Patterns-Distributed-Systems-Addison-Wesley-Signature/dp/0138221987](https://www.amazon.com/Patterns-Distributed-Systems-Addison-Wesley-Signature/dp/0138221987)
- en: Articles and blogs
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文章和博客
- en: 'Martin Fowler’s blog on microservices and distributed systems. This blog is
    a treasure trove of information on microservices and distributed systems, offering
    in-depth articles and thought leadership on modern software architecture. Link:
    [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·福勒关于微服务和分布式系统的博客。这个博客是关于微服务和分布式系统的信息宝库，提供了深入的文章和现代软件架构的见解和领导力。链接：[https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)
- en: '*LMAX Disruptor documentation and performance guide* is a high-performance
    inter-thread messaging library for Java. This resource provides documentation
    and performance guides for implementing low-latency, high-throughput systems.
    Link: [https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/)'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LMAX Disruptor文档和性能指南*是Java的高性能线程间消息库。该资源提供了实现低延迟、高吞吐量系统的文档和性能指南。链接：[https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/)'
- en: Online courses
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线课程
- en: '*Microservices Architecture* by the University of Alberta. This course provides
    a comprehensive introduction to microservices architecture, covering design principles,
    implementation strategies, and best practices for building scalable and maintainable
    systems. Link: [https://www.coursera.org/specializations/software-design-architecture](https://www.coursera.org/specializations/software-design-architecture)'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阿尔伯塔大学的微服务架构*。这门课程全面介绍了微服务架构，包括设计原则、实施策略以及构建可扩展和可维护系统的最佳实践。链接：[https://www.coursera.org/specializations/software-design-architecture](https://www.coursera.org/specializations/software-design-architecture)'
- en: '*Building Scalable Java Microservices with Spring Boot and Spring Cloud* on
    Coursera by Google Cloud Offered by Google Cloud, this course teaches how to build
    scalable Java microservices using Spring Boot and Spring Cloud, with a focus on
    cloud-native development practices. Link: [https://www.coursera.org/learn/google-cloud-java-spring](https://www.coursera.org/learn/google-cloud-java-spring)'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Coursera上使用Spring Boot和Spring Cloud构建可扩展的Java微服务*，由谷歌云提供。谷歌云提供的这门课程教授如何使用Spring
    Boot和Spring Cloud构建可扩展的Java微服务，重点在于云原生开发实践。链接：[https://www.coursera.org/learn/google-cloud-java-spring](https://www.coursera.org/learn/google-cloud-java-spring)'
- en: Chapters 7–9
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7-9章
- en: Books
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 书籍
- en: '*Serverless Architectures on AWS* by Peter Sbarski This book provides comprehensive
    coverage of serverless concepts and practical implementations on AWS, offering
    valuable insights for developers looking to build scalable and cost-effective
    applications. Link: [https://www.amazon.com/Serverless-Architectures-AWS-Peter-Sbarski/dp/1617295426](https://www.amazon.com/Serverless-Architectures-AWS-Peter-Sbarski/dp/1617295426)'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS上的无服务器架构*，作者彼得·斯巴斯基。本书全面覆盖了无服务器概念和AWS上的实际应用，为寻求构建可扩展和成本效益应用的开发者提供了宝贵的见解。链接：[https://www.amazon.com/Serverless-Architectures-AWS-Peter-Sbarski/dp/1617295426](https://www.amazon.com/Serverless-Architectures-AWS-Peter-Sbarski/dp/1617295426)'
- en: Articles
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文章
- en: '*Serverless Computing: One Step Forward, Two Steps Back* by Joseph M. Hellerstein
    et al. This article provides a critical analysis of serverless computing, discussing
    its advantages and limitations, and offering a balanced perspective on its place
    in modern architecture. Link: [https://arxiv.org/abs/1812.03651](https://arxiv.org/abs/1812.03651)'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无服务器计算：向前一步，退两步*，作者约瑟夫·M·赫勒斯坦等。这篇文章对无服务器计算进行了批判性分析，讨论了其优势和局限性，并对其在现代架构中的地位提供了平衡的观点。链接：[https://arxiv.org/abs/1812.03651](https://arxiv.org/abs/1812.03651)'
- en: '*Serverless Architecture Patterns and Best Practices* by freeCodeCamp'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无服务器架构模式和最佳实践*，由freeCodeCamp提供'
- en: 'This article provides an overview of key serverless patterns like messaging,
    function focus, and event-driven architecture, emphasizing the benefits of decoupling
    and scalability. Link: [https://www.freecodecamp.org/news/serverless-architecture-patterns-and-best-practices/](https://www.freecodecamp.org/news/serverless-architecture-patterns-and-best-practices/)'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这篇文章概述了关键的无服务器模式，如消息传递、函数重点和事件驱动架构，强调了解耦和可扩展性的好处。链接：[https://www.freecodecamp.org/news/serverless-architecture-patterns-and-best-practices/](https://www.freecodecamp.org/news/serverless-architecture-patterns-and-best-practices/)
- en: Online courses
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线课程
- en: '*Developing Serverless Solutions on AWS* by the AWS training team. This includes
    comprehensive coverage of AWS Lambda, best practices, frameworks, and hands-on
    labs. Link: [https://aws.amazon.com/training/classroom/developing-serverless-solutions-on-aws/](https://aws.amazon.com/training/classroom/developing-serverless-solutions-on-aws/)'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在AWS上开发无服务器解决方案*，由AWS培训团队提供。这包括对AWS Lambda的全面覆盖，最佳实践、框架和动手实验室。链接：[https://aws.amazon.com/training/classroom/developing-serverless-solutions-on-aws/](https://aws.amazon.com/training/classroom/developing-serverless-solutions-on-aws/)'
- en: Technical papers
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术论文
- en: '*Serverless Computing: Current Trends and Open Problems* by Ioana Baldini et
    al. This academic paper provides a thorough examination of serverless computing,
    discussing current trends, challenges, and future directions in this rapidly evolving
    field. Link: [https://arxiv.org/abs/1706.03178](https://arxiv.org/abs/1706.03178)'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无服务器计算：当前趋势和开放问题* 由 Ioana Baldini 等人撰写。这篇学术论文对无服务器计算进行了全面审查，讨论了该快速发展的领域的当前趋势、挑战和未来方向。链接：[https://arxiv.org/abs/1706.03178](https://arxiv.org/abs/1706.03178)'
- en: Online resources
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线资源
- en: 'AWS Lambda Developer Guide: [https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AWS Lambda 开发者指南: [https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)'
- en: 'Azure Functions Java developer guide: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-java](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-java)'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure Functions Java 开发者指南: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-java](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-java)'
- en: 'Google Cloud Functions Java Tutorials: [https://codelabs.developers.google.com/codelabs/cloud-starting-cloudfunctions#](https://codelabs.developers.google.com/codelabs/cloud-starting-cloudfunctions#)'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Google Cloud Functions Java 教程: [https://codelabs.developers.google.com/codelabs/cloud-starting-cloudfunctions#](https://codelabs.developers.google.com/codelabs/cloud-starting-cloudfunctions#)'
- en: Chapters 10–12
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10-12 章
- en: Books
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 书籍
- en: '*Quantum Computing for Developers* by Johan Vos. This groundbreaking book offers
    a developer-friendly introduction to quantum computing, bridging the gap between
    theoretical concepts and practical implementation. It provides clear explanations
    of quantum principles and includes hands-on examples using Java-based frameworks,
    preparing software developers for the emerging quantum computing landscape. The
    author, Johan Vos, expertly guides readers through quantum algorithms, quantum
    gates, and quantum circuits, demonstrating how to leverage existing programming
    skills in this cutting-edge field. Link: [https://www.manning.com/books/quantum-computing-for-developers](https://www.manning.com/books/quantum-computing-for-developers)'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Johan Vos 编著的 *开发者量子计算*。这本开创性的书籍为开发者提供了量子计算的友好介绍，架起了理论概念与实际应用之间的桥梁。它对量子原理进行了清晰的解释，并包括使用基于
    Java 的框架的实践示例，为软件开发者准备即将出现的量子计算领域。作者 Johan Vos 精通量子算法、量子门和量子电路，展示了如何利用现有的编程技能在这个前沿领域。链接：[https://www.manning.com/books/quantum-computing-for-developers](https://www.manning.com/books/quantum-computing-for-developers)
- en: Articles
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文章
- en: '*Transitioning your service or application* by Amazon Web Services'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过渡您的服务或应用程序* 由亚马逊网络服务'
- en: 'This article explores optimizing Java applications to provide more details
    regarding the individual steps involved in transitioning an application to Graviton2\.
    Link: [https://docs.aws.amazon.com/whitepapers/latest/aws-graviton2-for-isv/transitioning-your-service-or-application.html](https://docs.aws.amazon.com/whitepapers/latest/aws-graviton2-for-isv/transitioning-your-service-or-application.html)'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本文探讨了优化 Java 应用程序以提供更多关于将应用程序过渡到 Graviton2 所涉及的各个步骤的详细信息。链接：[https://docs.aws.amazon.com/whitepapers/latest/aws-graviton2-for-isv/transitioning-your-service-or-application.html](https://docs.aws.amazon.com/whitepapers/latest/aws-graviton2-for-isv/transitioning-your-service-or-application.html)
- en: '*Java in the Era of Cloud Computing* by Cogent University. This article focuses
    on the cloud-native advancements in Java, with frameworks like Spring Boot and
    Quarkus facilitating cloud-based development. It also mentions tools like Maven,
    Gradle, and JUnit for enhancing productivity and ensuring code quality. Link:
    [https://www.cogentuniversity.com/post/java-in-the-era-of-cloud-computing](https://www.cogentuniversity.com/post/java-in-the-era-of-cloud-computing)'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Cogent University 编著的 *云计算时代的 Java*。这篇文章重点介绍了 Java 的云原生进步，Spring Boot 和 Quarkus
    等框架促进了基于云的开发。它还提到了 Maven、Gradle 和 JUnit 等工具，用于提高生产力和确保代码质量。链接：[https://www.cogentuniversity.com/post/java-in-the-era-of-cloud-computing](https://www.cogentuniversity.com/post/java-in-the-era-of-cloud-computing)
- en: Online courses
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线课程
- en: '*Parallel, Concurrent, and Distributed Programming in Java Specialization*
    by Rice University on Coursera. This specialization covers advanced concurrency
    topics in Java, which apply to cloud computing environments and auto-scaling scenarios.
    Link: [https://www.coursera.org/specializations/pcdp](https://www.coursera.org/specializations/pcdp)'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由莱斯大学在 Coursera 提供的 *Java 并行、并发和分布式编程专项课程*。本专项课程涵盖了 Java 中的高级并发主题，这些主题适用于云计算环境和自动扩展场景。链接：[https://www.coursera.org/specializations/pcdp](https://www.coursera.org/specializations/pcdp)
- en: '*Serverless Machine Learning with Tensorflow on Google Cloud Platform* by Google
    Cloud on Coursera. This course explores the intersection of serverless computing
    and machine learning, aligning with discussions on AI/ML integration in cloud
    environments and future trends in cloud computing. Link: [https://www.coursera.org/learn/serverless-machine-learning-gcp-br](https://www.coursera.org/learn/serverless-machine-learning-gcp-br)'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Coursera上由Google Cloud提供的*《在Google Cloud Platform上使用Tensorflow的无服务器机器学习》*。这门课程探讨了无服务器计算和机器学习的交汇点，与云环境中AI/ML集成讨论和云计算的未来趋势相一致。链接：[https://www.coursera.org/learn/serverless-machine-learning-gcp-br](https://www.coursera.org/learn/serverless-machine-learning-gcp-br)'
- en: This appendix provides a curated selection of resources, including books, articles,
    and online courses, to deepen your understanding of concurrency, parallelism,
    and cloud-native development in Java. Leveraging these materials will enhance
    your knowledge and skills, enabling you to build robust, scalable, and efficient
    cloud-native Java applications.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录提供了一系列精选资源，包括书籍、文章和在线课程，以加深你对并发、并行性和Java原生开发的了解。利用这些材料将增强你的知识和技能，使你能够构建健壮、可扩展和高效的Java原生应用程序。
- en: Answers to the end-of-chapter multiple-choice questions
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节末尾的多项选择题答案
- en: 'Chapter 1: Concurrency, Parallelism, and the Cloud: Navigating the Cloud-Native
    Landscape'
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章：并发、并行性和云：导航云原生景观
- en: B) Easier to scale and maintain individual services
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 更容易扩展和维护单个服务
- en: B) Synchronization
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 同步
- en: D) Stream API
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D) 流式API
- en: C) Automatic scaling and management of resources
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 自动扩展和管理资源
- en: B) Data consistency and synchronization
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 数据一致性和同步
- en: 'Chapter 2: Introduction to Java’s Concurrency Foundations: Threads, Processes,
    and Beyond'
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章：Java并发基础介绍：线程、进程及其他
- en: C) Threads share a memory space, while processes are independent and have their
    own memory.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 线程共享一个内存空间，而进程是独立的，并且有自己的内存。
- en: B) It offers a set of classes and interfaces for managing threads and processes
    efficiently.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 它提供了一套用于高效管理线程和进程的类和接口。
- en: B) Allowing multiple threads to read a resource concurrently but requiring exclusive
    access for writing.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 允许多个线程并发读取资源，但写入时需要独占访问。
- en: B) It allows a set of threads to wait for a series of events to occur.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 它允许一组线程等待一系列事件发生。
- en: B) It allows for lock-free thread-safe operations on a single integer value.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 它允许对单个整数值进行无锁线程安全操作。
- en: 'Chapter 3: Mastering Parallelism in Java'
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三章：掌握Java中的并行性
- en: B) To enhance parallel processing by recursively splitting and executing tasks
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 通过递归拆分和执行任务来增强并行处理
- en: A) `RecursiveTask` returns a value, while `RecursiveAction` does not
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A) `RecursiveTask`返回一个值，而`RecursiveAction`不返回
- en: B) It allows idle threads to take over tasks from busy threads
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 它允许空闲线程接管忙碌线程的任务
- en: B) Balancing task granularity and parallelism level
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 平衡任务粒度和并行级别
- en: B) The task’s nature, resource availability, and team expertise
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 任务的性质、资源可用性和团队的专业知识
- en: 'Chapter 4: Java Concurrency Utilities and Testing in the Cloud Era'
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章：云计算时代的Java并发工具和测试
- en: C) To efficiently manage thread execution and resource allocation
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 为了有效地管理线程执行和资源分配
- en: B) `CopyOnWriteArrayList`
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) `CopyOnWriteArrayList`
- en: B) Enables asynchronous programming and non-blocking operations
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 使异步编程和非阻塞操作成为可能
- en: B) They enable efficient data handling and reduce locking overhead in concurrent
    access scenarios
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 它们使高效的数据处理成为可能，并减少并发访问场景中的锁定开销
- en: C) By offering more control over lock management and reducing lock contention
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 通过提供对锁管理的更多控制并减少锁竞争
- en: 'Chapter 5: Mastering Concurrency Patterns in Cloud Computing'
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五章：掌握云计算中的并发模式
- en: C) To prevent failures in one service from affecting other services
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 防止一个服务中的故障影响其他服务
- en: B) Employing a lock-free ring buffer to minimize contention
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 使用无锁环形缓冲区以最小化竞争
- en: C) It isolates services to prevent failures in one from cascading to others.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 它将服务隔离开来，防止一个服务的故障级联到其他服务。
- en: B) Scatter-Gather pattern
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) Scatter-Gather模式
- en: D) Resilience and data flow management
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D) 弹性和数据流管理
- en: 'Chapter 6: Java and Big Data – a Collaborative Odyssey'
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第六章：Java与大数据——一次协作之旅
- en: B) Volume, velocity, and variety
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 体积、速度和多样性
- en: A) **Hadoop Distributed File** **System** (**HDFS**)
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A) **Hadoop分布式文件系统**（**HDFS**）
- en: C) Spark offers faster in-memory data processing capabilities.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) Spark提供了更快的内存数据处理能力。
- en: A) Spark can only process structured data.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A) Spark只能处理结构化数据。
- en: C) It helps to break down large datasets into smaller, manageable chunks for
    processing.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 它有助于将大型数据集分解为更小、更易于管理的块进行处理。
- en: 'Chapter 7: Concurrency in Java for Machine Learning'
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章：Java机器学习中的并发
- en: C) To optimize computational efficiency
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 为了优化计算效率
- en: C) Parallel Streams
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 并行流
- en: C) They improve scalability and manage large-scale computations.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 它们提高了可伸缩性并管理大规模计算。
- en: B) To perform data preprocessing and model training more efficiently
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 更高效地执行数据预处理和模型训练
- en: B) Combining Java concurrency with generative AI
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 将Java并发与生成式AI结合
- en: 'Chapter 8: Microservices in the Cloud and Java’s Concurrency'
  id: totrans-620
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章：云中的微服务和Java的并发
- en: C) Independent deployment and scalability
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 独立部署和可伸缩性
- en: C) CompletableFuture
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) CompletableFuture
- en: B) Distributing incoming network traffic across multiple instances
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 在多个实例之间分配传入的网络流量
- en: C) Circuit breaker pattern.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 断路器模式。
- en: C) Assigning a separate managed database instance for each microservice
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 为每个微服务分配一个单独管理的数据库实例
- en: 'Chapter 9: Serverless Computing and Java’s Concurrent Capabilities'
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章：无服务器计算与Java的并发能力
- en: C) Automatic scaling and reduced operational overhead.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 自动扩展和减少操作开销。
- en: B) CompletableFuture.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) CompletableFuture.
- en: C) Managing recursive tasks by dividing them into smaller subtasks.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 通过将任务划分为更小的子任务来管理递归任务。
- en: B) Optimize function size and use provisioned concurrency.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 优化函数大小并使用预留并发。
- en: B) Improved performance through concurrent data processing.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 通过并发数据处理提高性能。
- en: 'Chapter 10: Synchronizing Java’s Concurrency with Cloud Auto-Scaling Dynamics'
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章：同步Java的并发与云自动扩展动态
- en: C) Dynamic resource allocation based on demand
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 根据需求动态分配资源
- en: B) `CompletableFuture`
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) `CompletableFuture`
- en: A) Managing a fixed number of threads
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A) 管理固定数量的线程
- en: C) Implementing stateless services
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 实现无状态服务
- en: C) Improving performance through concurrent data processing
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 通过并发数据处理提高性能
- en: 'Chapter 11: Advanced Java Concurrency Practices in Cloud Computing'
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章：云计算中的高级Java并发实践
- en: D) User interface design
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D) 用户界面设计
- en: C) Improved performance for parallel tasks
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 并行任务性能提升
- en: B) VisualVM
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) VisualVM
- en: B) Minimize data loss and improve availability
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) 最小化数据丢失并提高可用性
- en: C) Difficulty in obtaining a cohesive view of distributed operations
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 获取分布式操作的统一视图的困难
- en: 'Chapter 12: The Horizon Ahead'
  id: totrans-644
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章：未来的展望
- en: A) Improved startup time and reduced memory usage
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A) 改善启动时间并减少内存使用
- en: D) All of the above
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D) 以上所有
- en: B) Google Cloud AutoML
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B) Google Cloud AutoML
- en: C) Quantum superposition
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C) 量子叠加
- en: A) Reduced operational overhead for managing infrastructure
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A) 减少管理基础设施的操作开销
