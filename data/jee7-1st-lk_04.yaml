- en: Chapter 4. The Java Persistence API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 Java持久化API
- en: 'This chapter deals with the improvements in APIs for communicating with data
    sources. Although Java is object oriented, it is designed to handle data of relational
    models as objects, which might pose a serious problem because the two concepts
    are not theoretically compatible. In addition to introducing you to the world
    of object-relational mapping, this chapter will show you how to manipulate (create,
    delete, search, or edit) the data of relational models as objects transparently
    and transactional. Topics covered in this chapter are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了与数据源通信的API的改进。尽管Java是面向对象的，但它被设计成可以以对象的形式处理关系模型中的数据，这可能会引起严重问题，因为这两个概念在理论上并不兼容。除了向您介绍对象关系映射的世界之外，本章还将向您展示如何透明地以事务方式操作（创建、删除、搜索或编辑）关系模型的数据。本章涵盖的主题包括：
- en: Java Persistence API 2.1
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java持久化API 2.1
- en: Java Transaction API 1.2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java事务API 1.2
- en: Java Persistence API 2.1
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java持久化API 2.1
- en: The Java Persistence API 2.1 Specification was developed under **JSR-338**.
    This section just gives you an overview of the improvements in the API. The complete
    document specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr338/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr338/index.html).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java持久化API 2.1规范是在**JSR-338**下开发的。本节仅为您概述API的改进。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr338/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr338/index.html)下载。
- en: JPA (Java Persistence API)
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPA（Java持久化API）
- en: '**JPA** (**Java Persistence API**) is a Java specification that aims to define
    the standard features of **ORM**s (**Object-Relational Mappings**). However, JPA
    is not a product but a set of interfaces that require implementations. The most
    well-known implementations are as follows: **Hibernate**, **Toplink**, **OpenJPA,**
    and **EclipseLink**, which is the reference implementation.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**JPA**（**Java持久化API**）是一个旨在定义ORM（**对象关系映射**）标准特性的Java规范。然而，JPA不是一个产品，而是一组需要实现接口。最著名的实现如下：**Hibernate**、**Toplink**、**OpenJPA**和**EclipseLink**，这是参考实现。'
- en: Briefly, we can say that an ORM is an API used to establish a correspondence
    between the object model and a relational database. It gives you the ability to
    handle the data of your database as if they were objects, without too much worry
    about the physical schema.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们可以这样说，ORM（对象关系映射）是一个用于在对象模型和关系数据库之间建立对应关系的API。它使您能够像处理对象一样处理数据库中的数据，而不必过多地担心物理模式。
- en: JPA in action
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPA实践
- en: 'JPA is based on the concept of entities, in order to make object-relational
    mapping possible. An entity is a simple Java class (like **POJO**) with `@Entity`
    annotation (or XML equivalent) whose name is by default associated with the table
    having the same name in the database. In addition to the `@Entity` annotation,
    an entity class must have at least one primary key equivalent attribute that is
    designated with the `@Id` annotation (or XML equivalent). For the other attributes
    of the entity, the provider associates each of them to the column having the same
    name in the table, as shown in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JPA基于实体概念，以便实现对象关系映射。实体是一个简单的Java类（如**POJO**），带有`@Entity`注解（或XML等效），其名称默认与数据库中具有相同名称的表相关联。除了`@Entity`注解之外，实体类还必须至少有一个与`@Id`注解（或XML等效）指定的主键等效属性。对于实体的其他属性，提供者将它们中的每一个关联到表中具有相同名称的列，如下面的截图所示：
- en: '![JPA in action](img/9235OT_04_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![JPA实践](img/9235OT_04_01.jpg)'
- en: The parameters that indicate the database that will be associated to a set of
    entities must be defined in the persistence unit within the `persistence.xml`
    file of your application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 指示将关联到一组实体的数据库的参数必须在应用程序的`persistence.xml`文件中的持久化单元中定义。
- en: 'The following code is an example of the persistence unit of a Java SE Application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是Java SE应用程序持久化单元的示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Concerning the manipulation of entities, JPA offers through the `EntityManager`
    interface a set of methods to create, read, update, and delete the data (see the
    following table).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实体的操作，JPA通过`EntityManager`接口提供了一套创建、读取、更新和删除数据的方法（见下表）。
- en: 'The following table presents some methods for manipulating the entities:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了操作实体的一些方法：
- en: '| Method | Description |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `void persist(Object o)` | This is used to save the entity passed as a parameter.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `void persist(Object o)` | 这用于保存作为参数传递的实体。 |'
- en: '| `T merge(T t)` | This allows you to merge the entity passed as a parameter
    with the persistence context. It returns a managed version of the entity to be
    merged. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `T merge(T t)` | 这允许您将作为参数传递的实体与持久化上下文合并。它返回要合并的实体的管理版本。 |'
- en: '| `void remove(Object o)` | This allows you to delete the entity passed as
    parameter in the database. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `void remove(Object o)` | 这允许您在数据库中删除作为参数传递的实体。 |'
- en: '| `T find(Class<T> type, Object o)` | This allows you to search for an entity
    using its identifier. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `T find(Class<T> type, Object o)` | 这允许您使用其标识符搜索实体。 |'
- en: '| `void detach(Object o)` | This allows you to detach an entity from the persistence
    context so that the changes will not be saved |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `void detach(Object o)` | 这允许您将实体从持久化上下文中分离出来，以便更改不会被保存 |'
- en: 'The following code demonstrates how to save, read, update, and delete the data
    using JPA in a Java SE application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何在Java SE应用程序中使用JPA进行保存、读取、更新和删除数据：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The latest improvements of JPA 2.1 in action
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPA 2.1的最新改进在行动中
- en: 'Since its last version (JPA 2.0), the JPA Specification has had many enhancements.
    The most important enhancements are in the following features: persistence context
    synchronization, Entities, **JPQL**, **Criteria API**, and **Data Definition Language**
    (**DDL**) generation.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它的上一个版本（JPA 2.0）以来，JPA规范已经进行了许多增强。最重要的增强是在以下功能中：持久化上下文同步、实体、**JPQL**、**Criteria
    API**和**数据定义语言**（**DDL**）生成。
- en: Persistence context synchronization
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化上下文同步
- en: Before JPA 2.1, the container-managed persistence context was automatically
    joined to the current transaction, and any update made to the persistence context
    was propagated to the underlying resource manager. With the new specification,
    it is now possible to have a persistence context that will not be automatically
    enlisted in any JTA transaction. This can be done by simply creating a container-managed
    entity manager of synchronization type `SynchronizationType.UNSYNCHRONIZED` as
    shown in the following code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在JPA 2.1之前，容器管理的持久化上下文会自动加入当前事务，并且对持久化上下文所做的任何更新都会传播到底层资源管理器。根据新的规范，现在可以有一个不会自动注册到任何JTA事务中的持久化上下文。这可以通过简单地创建一个同步类型为`SynchronizationType.UNSYNCHRONIZED`的容器管理实体管理器来实现，如下面的代码所示。
- en: 'Creation and enlistment of a `SynchronizationType.UNSYNCHRONIZED` persistence
    context:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和注册`SynchronizationType.UNSYNCHRONIZED`持久化上下文：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, you will notice that we called the `EntityManager.joinTransaction()`
    method; this is justified by the fact that a persistence context of type `SynchronizationType.UNSYNCHRONIZED`
    is enlisted in a JTA transaction only after calling the `EntityManager.joinTransaction()`
    method, and after a commit or rollback, the `SynchronizationType.UNSYNCHRONIZED`
    persistence context will be dissociated from the transaction to which it was enlisted.
    You need to call the `EntityManager.joinTransaction()` method again to enlist
    the dissociated persistence context.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您会注意到我们调用了`EntityManager.joinTransaction()`方法；这是有道理的，因为只有在调用`EntityManager.joinTransaction()`方法之后，类型为`SynchronizationType.UNSYNCHRONIZED`的持久化上下文才会被注册到JTA事务中，并且在提交或回滚之后，`SynchronizationType.UNSYNCHRONIZED`持久化上下文将与它注册的事务解除关联。您需要再次调用`EntityManager.joinTransaction()`方法来注册解除关联的持久化上下文。
- en: Entity
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体
- en: An entity listener is a simple Java class (not an entity), which allows you
    to define the lifecycle callback methods that can be invoked for the lifecycle
    events of one or many entities. The JPA 2.1 Specification adds to these classes
    the support of **CDI injection** and the ability to define `@PostConstruct` and
    `@PreDestroy` lifecycle callback methods. These methods are respectively called
    after the dependency injections and before the destruction of the entity listener.
    The following code presents an entity listener that has the post construct and
    pre destroy methods with an **EJB injection**. It is followed by code that shows
    how to associate an entity listener to an entity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实体监听器是一个简单的Java类（不是一个实体），它允许您定义可以用于一个或多个实体生命周期事件的回调方法。JPA 2.1规范向这些类添加了对**CDI注入**的支持以及定义`@PostConstruct`和`@PreDestroy`生命周期回调方法的能力。这些方法分别在依赖注入之后和实体监听器销毁之前被调用。以下代码展示了一个具有后构造和预销毁方法的实体监听器，其中包含**EJB注入**。之后是展示如何将实体监听器关联到实体的代码。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: New annotations
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的注解
- en: JPA 2.1 added an annotation (`@Index`) to create indexes on tables when a schema
    is generated from entities and an annotation (`@ForeignKey`) to designate foreign
    keys of a table.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2.1增加了一个注解（`@Index`），用于在从实体生成模式时在表上创建索引，以及一个注解（`@ForeignKey`）用于指定表的键。
- en: 'The `@Index` annotation has one mandatory parameter (`columnList`) to list
    the columns that make up the index with different sort orders. It also has two
    optional parameters: the `name` parameter, which allows you to change the default
    name of the index, and the `unique` parameter to set the index as unique or not
    unique. In parallel, `@Index` annotation was added as a part of `Table`, `SecondaryTable`,
    `CollectionTable`, `JoinTable`, and `TableGenerator` annotations.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Index`注解有一个强制参数（`columnList`），用于列出构成索引的列以及不同的排序顺序。它还有两个可选参数：`name`参数，允许你更改索引的默认名称，以及`unique`参数，用于设置索引是否为唯一。同时，`@Index`注解被添加为`Table`、`SecondaryTable`、`CollectionTable`、`JoinTable`和`TableGenerator`注解的一部分。'
- en: 'The `@ForeignKey` can be used as element of `JoinColumn`, `JoinColumns`, `MapKeyJoinColumn`,
    `MapKeyJoinColumns`, `PrimaryKeyJoinColumn`, `PrimaryKeyJoinColumns`, `CollectionTable`,
    `JoinTable`, `SecondaryTable`, and `AssociationOverride` annotations to either
    define or modify the foreign key constraints on a table. It takes three parameters:
    name, value for the constraint, and the definition of the foreign key. The three
    parameters are optional.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ForeignKey`可以用作`JoinColumn`、`JoinColumns`、`MapKeyJoinColumn`、`MapKeyJoinColumns`、`PrimaryKeyJoinColumn`、`PrimaryKeyJoinColumns`、`CollectionTable`、`JoinTable`、`SecondaryTable`和`AssociationOverride`注解的元素，用于定义或修改表上的外键约束。它接受三个参数：名称、约束的值和外键的定义。这三个参数都是可选的。'
- en: 'An example of an entity with a foreign key and indexed columns is shown in
    the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了具有外键和索引列的实体示例：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Entity graphs
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体图
- en: When we talk about an entity graph, we have to keep in mind a data structure
    involving several related entities. With the previous version of JPA, the efficient
    loading of data of an entity was essentially managed through the fetch setting.
    The consequence was that it was necessary to set the fetch attribute of some annotations
    before compiling the application (or before deployment in the case of XML configuration)
    in order to request that an entity attribute be loaded **eagerly** (when entity
    is loaded) or **lazily** (when data is needed). Through entity graphs, you can
    now override or change the fetch setting at runtime.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论实体图时，必须牢记涉及多个相关实体的数据结构。在JPA的早期版本中，实体数据的有效加载主要通过获取设置来管理。结果是，在编译应用程序（或在XML配置的情况下部署之前）之前，必须设置某些注解的获取属性，以请求实体属性被**预先加载**（当加载实体时）或**延迟加载**（当需要数据时）。通过实体图，你现在可以在运行时覆盖或更改获取设置。
- en: An entity graph can be defined statically by using a vast `NamedEntityGraph`,
    `NamedEntityGraphs`, `NamedSubgraph`, and `NamedAttributeNode` annotations, or
    dynamically through `EntityGraph`, `subgraph`, and `AttributeNode` interfaces.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实体图可以通过使用大量的`NamedEntityGraph`、`NamedEntityGraphs`、`NamedSubgraph`和`NamedAttributeNode`注解静态定义，或者通过`EntityGraph`、`subgraph`和`AttributeNode`接口动态定义。
- en: Static or named entity graphs
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态或命名实体图
- en: 'The `@NamedEntityGraph` annotation is used to define an entity graph that can
    be used at runtime when executing queries or using the `find()` method. The following
    code shows an example of the definition of a named entity graph with one field:
    `students`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NamedEntityGraph`注解用于定义一个实体图，该图可以在执行查询或使用`find()`方法时在运行时使用。以下代码显示了定义具有一个字段`students`的命名实体图的示例。'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once defined, we need to retrieve our named entity graph using the `getEntityGraph()`
    method of `EntityManager` in order to use it as a property when searching with
    the find method or as a **query hint** with a query. After executing the following
    code, you will notice that in the first search, the `students` attribute will
    not be loaded while in the second search it will be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，我们需要使用`EntityManager`的`getEntityGraph()`方法检索我们的命名实体图，以便在执行查找方法或查询时将其用作属性，或者作为查询的**提示**。执行以下代码后，你将注意到在第一次搜索中，`students`属性不会被加载，而在第二次搜索中它会被加载。
- en: 'The following code is an example of using a named entity graph:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用命名实体图的示例：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Dynamic entity graphs
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态实体图
- en: Entity graphs can also be defined at runtime. To do this, we must use the `createEntityGraph()`
    method of the entity manager and not `getEntityGraph()` as with the named entity
    graphs. Once defined, the **dynamic entity graph** is associated with the `find()`
    method or a query in the same way as a named entity graph as shown in the following
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实体图也可以在运行时定义。为此，我们必须使用实体管理器的`createEntityGraph()`方法，而不是像命名实体图那样使用`getEntityGraph()`。一旦定义，**动态实体图**就像命名实体图一样与`find()`方法或查询相关联，如下面的代码所示。
- en: 'The following code is an example of using a dynamic entity graph:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用动态实体图的示例：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JPQL
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JPQL
- en: '**JPQL** (**Java Persistence Query Language**) is an object-oriented SQL-like
    query language. It is platform independent and allows you to access your data
    through entities instead of manipulating the physical structure of your database.
    The following code demonstrates how to query for all registered students whose
    ID is greater than 123.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**JPQL**（**Java Persistence Query Language**）是一种面向对象的类似SQL的查询语言。它是平台无关的，允许你通过实体而不是操作数据库的物理结构来访问你的数据。以下代码演示了如何查询所有ID大于123的已注册学生。'
- en: 'The following code is an example of a JPQL query:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是JPQL查询的示例：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Despite its power and its vastness, the JPQL continues to receive significant
    improvements. In JPA 2.1, it has among other enhancements integrated support for
    stored procedures, added new reserved identifiers, and the support for creation
    of named queries at runtime.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JPQL功能强大且内容丰富，但它仍在持续获得重大改进。在JPA 2.1中，它除了其他增强之外，还集成了对存储过程的支持，增加了新的保留标识符，并支持在运行时创建命名查询。
- en: Support for stored procedures
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储过程支持
- en: JPA 2.1 now allows you to execute stored procedures. Through the various API
    that it offers, you can define and execute named stored procedures or dynamically
    stored procedures.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2.1现在允许你执行存储过程。通过它提供的各种API，你可以定义和执行命名存储过程或动态存储过程。
- en: 'The following script is an example of a script to create a stored procedure
    in MySQL:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在MySQL中创建存储过程的脚本示例：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code demonstrates how to execute the stored procedure `getStudentsName`
    we just created:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何执行我们刚刚创建的`getStudentsName`存储过程：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: New reserved identifiers
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的保留标识符
- en: 'The JQPL has introduced the following new keywords:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JQPL引入了以下新关键字：
- en: '`ON`: This keyword allows us to make explicit joins as in SQL with the `ON`
    condition. Before, joins were made with the liaison attributes between the two
    entities, which required minimal configuration. The following code demonstrates
    the use of `ON`:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON`: 此关键字允许我们使用`ON`条件进行显式连接，就像SQL中的连接一样。在此之前，连接是通过两个实体之间的联系属性来完成的，这需要最少的配置。以下代码演示了`ON`的使用：'
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`FUNCTION`: This keyword allows you to invoke functions in your queries other
    than those originally intended by JPQL (such `SUBSTRING`, `LENGTH`, `ABS`, `TRIM`,
    and so on). With this keyword, you can use a database function or functions that
    you have defined yourself. The following query gives us the list of students born
    in July by using the `month()` method of **derby database** in order to extract
    the month from a birth date:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FUNCTION`: 此关键字允许你在查询中调用除JPQL（如`SUBSTRING`、`LENGTH`、`ABS`、`TRIM`等）原本意图之外的功能。使用此关键字，你可以使用数据库函数或你自己定义的函数。以下查询通过使用**derby数据库**的`month()`方法来提取出生日期的月份，从而得到7月出生的学生名单：'
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`TREAT`: This keyword allows you to do the **downcasting** of an entity in
    order to obtain a subclass state. It is used in the `FROM` and `WHERE` clauses.
    In the following code, the entity `Appuser` inherits from the entity `Person`;
    with the keyword `TREAT` we can put conditions on attributes that are not contained
    in the base entity (`Person`).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TREAT`: 此关键字允许你对实体进行**向下转型**以获得子类状态。它在`FROM`和`WHERE`子句中使用。在以下代码中，实体`Appuser`继承自实体`Person`；使用`TREAT`关键字，我们可以对基实体（`Person`）中不包含的属性设置条件。'
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Support for creating named queries at runtime
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 支持在运行时创建命名查询
- en: 'Before JPA 2.1, named queries were defined statically as metadata before compiling
    the program. Through the `addNamedQuery` method that was added to the `EntityManagerFactory`
    interface, you can now create a named query at runtime as shown in the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在JPA 2.1之前，命名查询是在编译程序之前作为元数据静态定义的。通过添加到`EntityManagerFactory`接口的`addNamedQuery`方法，你现在可以在运行时创建命名查询，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Criteria API
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估API
- en: 'JPA since Version 2.0 offers two options for defining queries on entities.
    The first option is the JPQL which is a query language based on SQL. The second
    option is the Criteria API where a query is constructed essentially with Java
    objects, as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自从JPA 2.0版本以来，JPA提供了两种定义实体查询的选项。第一种选项是JPQL，它是一种基于SQL的查询语言。第二种选项是Criteria API，其中查询主要是用Java对象构建的，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Given that the two solutions do not evolve at the same rate, the major changes
    in the Criteria API are support for bulk update/delete and new reserved identifiers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个解决方案的发展速度不同，Criteria API的主要变化是支持批量更新/删除和新保留标识符。
- en: Support for bulk update/delete
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 批量更新/删除的支持
- en: 'The bulk update and delete in the Criteria API are respectively constructed
    with `javax.persistence.criteria.CriteriaUpdate` and `javax.persistence.criteria.CriteriaDelete`
    interfaces. The following code demonstrates how to update a lot of information
    with just one Criteria API request:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Criteria API中，批量更新和删除分别使用`javax.persistence.criteria.CriteriaUpdate`和`javax.persistence.criteria.CriteriaDelete`接口构建。以下代码演示了如何仅通过一个Criteria
    API请求来更新大量信息：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Support for new reserved identifiers
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新保留标识符的支持
- en: 'Just like the JPQL, the Criteria API incorporates the possibility of making
    downcasts and defines joins using `ON` conditions. To do that, overloaded `treat()`
    methods have been added to the `javax.persistence.criteria.CriteriaBuilder` interface
    for downcasting, while `on()` and `getOn()` methods have been added to some interfaces
    (such as `Join`, `ListJoin`, `SetJoin`, `MapJoin`, `CollectionJoin`,and `Fetch`)
    of the `javax.persistence.criteria` package for joins with `ON` conditions. The
    following query is equivalent to the JPQL downcasting shown in the preceding code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像JPQL一样，Criteria API包含了进行向下转型的可能性，并使用`ON`条件定义连接。为此，在`javax.persistence.criteria.CriteriaBuilder`接口中添加了重载的`treat()`方法以实现向下转型，同时向`javax.persistence.criteria`包的一些接口（如`Join`、`ListJoin`、`SetJoin`、`MapJoin`、`CollectionJoin`和`Fetch`）添加了`on()`和`getOn()`方法以实现带有`ON`条件的连接。以下查询与前面代码中显示的JPQL向下转型等效：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: DDL generation
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DDL生成
- en: Since the previous version of the JPA Specification, it is possible to create
    or drop and create tables. However, the support for this feature was not required
    and the specification document made us understand that the use of this feature
    could reduce application portability. Well, with JPA 2.1, the **DDL** (**Data
    Definition Language**) generation was not only standardized but has been expanded
    and is now required.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自从JPA规范的前一个版本以来，可以创建或删除并创建表。然而，这个功能的支持并非必需，规范文档让我们明白使用这个功能可能会降低应用程序的可移植性。好吧，随着JPA
    2.1的推出，**DDL**（**数据定义语言**）生成不仅被标准化，而且还得到了扩展，现在成为必需。
- en: 'In this case, new properties have been added. You have for example the following
    properties:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，已添加了新的属性。例如，你有以下属性：
- en: '`javax.persistence.schema-generation.database.action`: This defines the action
    (none, create, drop-and-create, or drop) that should be taken by the provider.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.persistence.schema-generation.database.action`: 这定义了提供者应采取的操作（无、创建、删除并创建或删除）。'
- en: '`javax.persistence.schema-generation.create-source`: This defines the source
    (entities, specific scripts, or both) to be used by the provider in the case of
    a DDL generation.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.persistence.schema-generation.create-source`: 这定义了在DDL生成的情况下，提供者将使用的源（实体、特定脚本或两者兼具）。'
- en: '`javax.persistence.schema-generation.drop-source`: This defines the source
    (entities, specific scripts, or both) to be used by the provider in the case of
    drop table.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.persistence.schema-generation.drop-source`: 这定义了在删除表的情况下，提供者将使用的源（实体、特定脚本或两者兼具）。'
- en: '`javax.persistence.schema-generation.connection`: This defines the **JDBC**
    connection parameters to use for the DDL schema generation in order to take into
    account the management of privileges in some databases such as Oracle. This parameter
    was thought of for Java EE environments.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.persistence.schema-generation.connection`: 这定义了用于DDL模式生成的**JDBC**连接参数，以便考虑某些数据库（如Oracle）中权限的管理。这个参数是为Java
    EE环境考虑的。'
- en: The following persistence unit provides an example of configuration to generate
    tables at the creation of `EntityManagerFactory`. This generation will be based
    on entities' information (metadata) and it will take place if and only if the
    tables to be created do not exist, because we defined create instead of drop-and-create
    for the action of the provider.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下持久化单元提供了一个在创建 `EntityManagerFactory` 时生成表的配置示例。此生成将基于实体信息（元数据）进行，并且只有在要创建的表不存在时才会发生，因为我们为提供者的操作定义了创建而不是先删除再创建。
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another aspect of this standardization is the addition of a new method (`Persistence.generateSchema()`),
    which provides more opportunity for the generation. Before (in JPA 2.0), the DDL
    generation was done at the creation of the entity manager. Henceforth, you can
    generate your tables before, during, or after the creation of the `EntityManagerFactory`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化的另一个方面是添加了一个新方法（`Persistence.generateSchema()`），这提供了更多的生成机会。在此之前（在 JPA 2.0
    中），DDL 生成是在实体管理器创建时进行的。从现在起，您可以在创建 `EntityManagerFactory` 之前、期间或之后生成您的表。
- en: 'The following code demonstrates how to generate tables regardless of the creation
    of the `EntityManagerFactory`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何在不考虑 `EntityManagerFactory` 创建的情况下生成表：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code demonstrates another way to generate the tables at the creation
    of the `EntityManagerFactory`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了在创建 `EntityManagerFactory` 时生成表的另一种方法：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Java Transaction API 1.2
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 事务 API 1.2
- en: The Java Transaction API 1.2 Specification was developed under JSR 907\. This
    section just gives you an overview of improvement in the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/mrel/jsr907/index2.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr907/index2.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java 事务 API 1.2 规范是在 JSR 907 下开发的。本节仅为您概述了 API 的改进。完整的文档规范（更多信息）可以从 [http://jcp.org/aboutJava/communityprocess/mrel/jsr907/index2.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr907/index2.html)
    下载。
- en: The Java Transaction API
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 事务 API
- en: 'The **Java Transaction API** (**JTA**) is a standard Java API for managing
    transactions on one or more resources (distributed transactions) in server environments.
    It consist of three main APIs: `javax.transaction.UserTransaction` interface used
    by applications for explicit transaction demarcation, `javax.transaction.TransactionManager`
    interface used by application servers to demarcate transactions implicitly on
    behalf of the application, and `javax.transaction.xa.XAResource`, which is a Java
    mapping of the standard XA interface for distributed transaction processing.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 事务 API**（**JTA**）是用于在服务器环境中管理一个或多个资源（分布式事务）的标准 Java API。它包括三个主要 API：`javax.transaction.UserTransaction`
    接口，由应用程序用于显式事务界定；`javax.transaction.TransactionManager` 接口，由应用程序服务器代表应用程序隐式界定事务；以及
    `javax.transaction.xa.XAResource`，它是用于分布式事务处理的标准化 XA 接口的 Java 映射。'
- en: JTA in action
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JTA 实战
- en: 'As we said, JTA transactions are used in Java EE environments. In order to
    enable this transaction type, the `transaction-type` attribute of the persistence
    unit should be set to `JTA` instead of `RESOURCE_LOCAL` and the data source (if
    there is one), should be defined within the `<jta-datasource>` element. The following
    code gives an example of a persistence unit to manage transactions using JTA:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，JTA 事务在 Java EE 环境中使用。为了启用此事务类型，持久化单元的 `transaction-type` 属性应设置为 `JTA`
    而不是 `RESOURCE_LOCAL`，并且数据源（如果有），应在 `<jta-datasource>` 元素内定义。以下代码给出了一个使用 JTA 管理事务的持久化单元示例：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After declaring a `JTA` transaction type persistence unit, the developer can
    either leave the transaction management to the server (by default, the container
    considers a method as a transaction) or take control and define the transaction
    boundaries programmatically.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了 `JTA` 事务类型持久化单元之后，开发者可以选择将事务管理留给服务器（默认情况下，容器将方法视为事务）或者接管控制并程序化定义事务边界。
- en: 'The following code is an example of a container-managed transaction:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个容器管理事务的示例：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code is an example of bean-managed transaction:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个 Bean 管理事务的示例：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Innovations introduced by JTA 1.2
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JTA 1.2 引入的创新
- en: Unlike the JPA Specification, JTA has known only a few improvements that can
    be summarized in the following lines. First we have the addition of two new annotations.
    The first is `javax.transaction.Transactional`, which provides the possibility
    to demarcate transactions declaratively on CDI-managed beans or classes defined
    as managed beans by the Java EE Specification. The second annotation added is
    the `javax.transaction.TransactionScoped` annotation, which provides the possibility
    to define beans whose lifecycle is identical with the current transaction. The
    JTA API also added one exception class `javax.transaction.TransactionalException`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与JPA规范不同，JTA只有少数改进，以下是一些总结。首先，我们增加了两个新的注解。第一个是`javax.transaction.Transactional`，它提供了在CDI管理的bean或由Java
    EE规范定义为管理bean的类上声明性标记事务的可能性。第二个增加的注解是`javax.transaction.TransactionScoped`，它提供了定义与当前事务生命周期相同的bean的可能性。JTA
    API还增加了一个异常类`javax.transaction.TransactionalException`。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have, with examples, presented and analyzed the improvements
    provided by two APIs whose major objective is to facilitate interaction with your
    data base. The first presented was JPA API, which gives you the ability to create,
    read, update, and delete data from a database by using Java objects. The second
    was JTA API, which is an API designed for transparent management of transactions
    in one or more data sources.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过示例介绍了两个API提供的改进，这两个API的主要目标是简化与数据库的交互。第一个介绍的是JPA API，它通过使用Java对象，使您能够创建、读取、更新和删除数据库中的数据。第二个是JTA
    API，这是一个为在一个或多个数据源中透明管理事务而设计的API。
- en: In the next chapter, we'll talk about **EJB**s and we will make a small example,
    which will consist of putting together most of the APIs that we have studied.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论**EJB**，并且会制作一个小示例，这个示例将包括将我们所学的大多数API组合在一起。
