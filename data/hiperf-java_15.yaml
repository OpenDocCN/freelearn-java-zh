- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Optimizing Your Database and SQL Queries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的数据库和SQL查询
- en: Databases are a key component of large software systems. These systems constantly
    retrieve and update data using database connections and queries. The scale of
    data in modern systems is extremely large, resulting in more data to query, update,
    and display. This increased scale can result in negative performance issues for
    our Java application, underscoring the significance of ensuring our databases
    and queries are optimized.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是大型软件系统的一个关键组件。这些系统不断使用数据库连接和查询检索和更新数据。现代系统中的数据规模极其庞大，导致需要查询、更新和显示的数据更多。这种增加的规模可能导致我们的Java应用程序出现性能问题，强调了确保我们的数据库和查询得到优化的重要性。
- en: This chapter examines critical database design concepts, including database
    schemas, indexing strategies, and data partitioning techniques. Database queries
    are also examined, with a specific focus on **Structured Query Language** (**SQL**)
    queries. Our coverage of query optimizations includes best practices for writing
    efficient queries, query execution planning, and advanced SQL techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了关键的数据库设计概念，包括数据库模式、索引策略和数据分区技术。数据库查询也被检查，特别关注**结构化查询语言**（**SQL**）查询。我们对查询优化的覆盖包括编写高效查询的最佳实践、查询执行计划和高级SQL技术。
- en: The chapter also covers advanced SQL techniques such as database configuration,
    performance monitoring, and database maintenance. The chapter ends with several
    real-world case studies that help demonstrate how to identify and resolve database-related
    performance issues in existing systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了高级SQL技术，如数据库配置、性能监控和数据库维护。本章以几个现实世界的案例研究结束，这些案例研究有助于展示如何识别和解决现有系统中的数据库相关性能问题。
- en: By the end of this chapter, you should have a foundational understanding of
    strategies to optimize your databases and database queries. Armed with this understanding,
    and leveraging your experience gained from hands-on exercises, you should be able
    to improve the performance of your Java applications that incorporate databases
    and database queries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该对优化数据库和数据库查询的策略有基础的了解。有了这种理解，并利用从实际练习中获得的经验，你应该能够提高包含数据库和数据库查询的Java应用程序的性能。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Database design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库设计
- en: SQL query optimizations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL查询优化
- en: Additional strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的策略
- en: Case studies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究
- en: Database design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库设计
- en: For new systems, we have the luxury of designing our databases with performance
    in mind. Our database’s design can have a significant impact on the efficiency
    of our SQL queries. In this section, we will examine key principles of database
    design, including schema, indexing, partitioning, and sharding.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新系统，我们有在设计数据库时考虑性能的便利。我们的数据库设计可以显著影响SQL查询的效率。在本节中，我们将检查数据库设计的关键原则，包括模式、索引、分区和分片。
- en: Schema principles
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式原则
- en: Database schema
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式
- en: A database schema is the design of the database, serving as a blueprint to create
    it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式是数据库的设计，作为创建它的蓝图。
- en: Before we create our database, we should create a **schema** to document how
    our data will be organized and to indicate how it is interrelated. Our goal is
    to design a schema that makes querying the database more efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建数据库之前，我们应该创建一个**模式**来记录我们的数据如何组织以及它们是如何相互关联的。我们的目标是设计一个使查询数据库更高效的模式。
- en: An early decision to make is whether our database will be **normalized** or
    **denormalized**. A denormalized database involves reducing the number of tables
    to decrease the complexity of queries. Conversely, normalization involves creating
    separate tables to eliminate duplicative data. Let’s look at an example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的早期决定之一是确定我们的数据库将是**规范化**还是**非规范化**。非规范化数据库涉及减少表的数量以降低查询的复杂性。相反，规范化涉及创建单独的表以消除重复数据。让我们来看一个例子。
- en: The following table shows duplicative data for both the author and publisher
    fields.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了作者和出版社字段中的重复数据。
- en: '| **BookID** | **Author** | **Title** | **Publisher** | **Price ($)** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **BookID** | **Author** | **Title** | **Publisher** | **Price ($)** |'
- en: '| 1 | N. Anderson | *Introduction* *to Zion* | Packt | 65.99 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1 | N. Anderson | *Zion的介绍* | Packt | 65.99 |'
- en: '| 2 | N. Anderson | *Illustrated History* *of Zion* | Packt | 123.99 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 2 | N. Anderson | *Zion的插图历史* | Packt | 123.99 |'
- en: '| 3 | W. Rabbit | *Astro Mechanics* | Packt | 89.99 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 3 | W. Rabbit | *天体力学* | Packt | 89.99 |'
- en: '| 4 | W. Rabbit | *Gyro Machinery* | Forest Press | 79.99 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 4 | W. Rabbit | *Gyro Machinery* | Forest Press | 79.99 |'
- en: Table 15.1 – A Denormalized table
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.1 – 一个非归一化表
- en: As you can see in the preceding table, there are two entries for two different
    authors, and one publisher is listed more than once. This is an unnormalized table.
    To normalize the table, we will create three tables, one each for the books, authors,
    and publishers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的表中可以看到，有两个条目对应两位不同的作者，一个出版社被列出了不止一次。这是一个未归一化的表。为了归一化这个表，我们将创建三个表，每个表分别对应书籍、作者和出版社。
- en: '| **BookID** | **Title** | **AuthorID** | **PublisherID** | **Price ($)** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **BookID** | **Title** | **AuthorID** | **PublisherID** | **Price ($)** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | *Introduction* *to Zion* | 1 | 1 | 65.99 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *Zion* 的 *介绍* | 1 | 1 | 65.99 |'
- en: '| 2 | *Illustrated History* *of Zion* | 1 | 1 | 123.99 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *Zion* 的 *插图历史* | 1 | 1 | 123.99 |'
- en: '| 3 | *Astro Mechanics* | 2 | 1 | 89.99 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *Astro Mechanics* | 2 | 1 | 89.99 |'
- en: '| 4 | *Gyro Machinery* | 2 | 2 | 79.99 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *Gyro Machinery* | 2 | 2 | 79.99 |'
- en: Table 15.2 – The Books table
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.2 – 书籍表
- en: 'The `Books` table references the `AuthorID` and `PublisherID` fields. Those
    are established in the following tables. Here is the `Authors` table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Books` 表引用了 `AuthorID` 和 `PublisherID` 字段。这些字段在以下表中建立。以下是 `Authors` 表：'
- en: '| **AuthorID** | **Author** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **AuthorID** | **Author** |'
- en: '| 1 | N. Anderson |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 1 | N. Anderson |'
- en: '| 2 | W. Rabbit |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 2 | W. Rabbit |'
- en: Table 15.3 – The Authors table
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.3 – 作者表
- en: 'Our final table is for the **Publishers**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个表是**出版社**的表：
- en: '| **PublisherID** | **Publisher** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **PublisherID** | **Publisher** |'
- en: '| 1 | Packt |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Packt |'
- en: '| 2 | Forest Press |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Forest Press |'
- en: Table 15.4 – The Publishers table
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.4 – 出版社表
- en: The decision to implement a normalized or denormalized database involves considering
    the complexity of queries, the size of your database, and the read-write load
    on your database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实施归一化或非归一化数据库的决定涉及考虑查询的复杂性、您数据库的大小以及数据库的读写负载。
- en: 'Another important database design consideration is the data type for each of
    your columns. For example, it is appropriate to use an `Authors` table with appropriate
    data types using SQL:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的数据库设计考虑因素是每列的数据类型。例如，使用 SQL 创建具有适当数据类型的 `Authors` 表是合适的：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After we have designed our database tables and decided on data types, we need
    to implement indexing. Let’s look at that in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设计好数据库表并确定数据类型后，我们需要实现索引。让我们在下一节中看看这一点。
- en: Indexing
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: We index our databases so that data can be found quickly. Our indexing strategy
    has a direct impact on our query performance, so due diligence is required. There
    are two types of indexing. The first type is **balanced tree** (**B-tree**), which
    is what is implemented in most databases. This type of index keeps data sorted
    and permits sequential access, insertions, and deletions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们索引数据库，以便快速找到数据。我们的索引策略直接影响到我们的查询性能，因此需要尽职尽责。有两种索引类型。第一种是**平衡树**（**B-tree**），这是大多数数据库中实现的方式。这种索引保持数据排序，并允许顺序访问、插入和删除。
- en: The second type of database indexing is **hash indexes**. This type of indexing
    is ideal when equality comparisons are needed but is not adequate for range queries.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库索引的第二种类型是**哈希索引**。当需要等值比较时，这种索引类型是理想的，但它不适合范围查询。
- en: 'Index creation is simple and demonstrated by the following SQL statement:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 索引创建很简单，以下 SQL 语句展示了这一点：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you have an existing database and frequently use `WHERE`, `JOIN`, `ORDER
    BY`, or `GROUP BY`, you can likely benefit from indexing. Let’s look at an example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个现有的数据库，并且经常使用 `WHERE`、`JOIN`、`ORDER BY` 或 `GROUP BY`，您可能可以从索引中受益。让我们看看一个例子。
- en: 'We could use the following SQL statement when we do not have an index:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有索引时，我们可以使用以下 SQL 语句：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following SQL statement searches for the same author but uses an index:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 SQL 语句搜索相同的作者，但使用了索引：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the second example will provide results a bit faster than the non-indexed
    approach. Note that indexes do take up additional storage space and add additional
    processing overhead when using the `INSERT`, `DELETE`, and `UPDATE` operations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二个例子将比非索引方法提供更快的结果。请注意，索引确实会占用额外的存储空间，并在使用 `INSERT`、`DELETE` 和 `UPDATE` 操作时增加额外的处理开销。
- en: In the next section, we will examine partitioning and sharding as approaches
    to improve the efficiency of our database and database queries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查分区和分片作为提高数据库和数据库查询效率的方法。
- en: Partitioning and sharding
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区与分片
- en: Partitioning and sharding are strategies used to improve the performance of
    large databases and their queries by dividing large datasets into smaller components.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分区和分片是用于通过将大型数据集划分为更小的组件来提高大型数据库及其查询性能的策略。
- en: Partitioning
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区
- en: 'There are two types of partitioning, **horizontal partitioning** and **vertical
    partitioning**. Horizontal partitioning is accomplished by splitting tables into
    rows, and each horizontal partition contains a subset of those rows. A typical
    use case for this is creating a partition based on date ranges. The following
    example creates three tables, each with a specific year’s worth of order information:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种分区类型，**水平分区**和**垂直分区**。水平分区是通过将表拆分为行来实现的，每个水平分区包含这些行的一个子集。这种方法的典型用例是基于日期范围创建分区。以下示例创建了三个表，每个表包含特定年份的订单信息：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Vertical partitioning splits the database table into columns, each partition
    containing a subset of columns. To demonstrate vertical partitioning, let’s look
    at a `Books` table that has not been partitioned:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直分区将数据库表拆分为列，每个分区包含列的子集。为了演示垂直分区，让我们看看一个尚未分区的`Books`表：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, using vertical partitioning, let’s create two tables, each with a subset
    of columns:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用垂直分区，让我们创建两个表，每个表包含列的子集：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By splitting our table into two partitions, we can search more efficiently,
    since we do not need to process any unrelated data (i.e., when searching the catalog
    data, we are not concerned with sales data).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的表拆分为两个分区，我们可以更有效地搜索，因为我们不需要处理任何无关数据（即，在搜索目录数据时，我们不关心销售数据）。
- en: Let’s now look at another strategy to increase the efficiency of our databases,
    called sharding.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看另一种提高数据库效率的策略，称为**分片**。
- en: Sharding
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分片
- en: '**Sharding** is the process of distributing our data over multiple servers,
    moving the data closer to users. This strategy has two primary benefits – moving
    the data to servers closer to users reduces network latency and the load on individual
    servers. A common use case is to shard based on geographic region. Here is an
    example of how we can accomplish that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**分片**是将我们的数据分布到多个服务器上的过程，将数据移动到用户附近。这种策略有两个主要好处——将数据移动到靠近用户的服务器可以减少网络延迟和单个服务器的负载。一个常见的用例是基于地理位置进行分片。以下是一个示例，说明我们如何实现这一点：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example creates two tables. The next step would be to store each
    table on different servers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了两个表。下一步是将每个表存储在不同的服务器上。
- en: A purposeful approach to partitioning and sharding can result in a performance-ready
    database design. It can make your SQL queries more efficient, thereby improving
    the overall performance of your Java application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有目的的分区和分片方法可以导致一个性能就绪的数据库设计。它可以提高你的SQL查询效率，从而提高Java应用程序的整体性能。
- en: Query optimizations
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询优化
- en: Now that we have a basic understanding of how to design our databases with performance
    in mind, we are ready to look at best practices for writing efficient queries.
    We will also look at query execution plans and some advanced SQL techniques. To
    make our example SQL statements relatable, we will use a book inventory and order
    processing database throughout this section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何以性能为导向设计数据库有了基本的了解，我们可以开始探讨编写高效查询的最佳实践。我们还将探讨查询执行计划和一些高级SQL技术。为了使本节中的示例SQL语句更具相关性，我们将使用一个图书库存和订单处理数据库。
- en: Query execution
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询执行
- en: Understanding how queries are handled by our database is key to being able to
    optimize them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我们的数据库如何处理查询是能够对其进行优化的关键。
- en: A query execution plan
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查询执行计划
- en: A query execution plan provides details on how a database engine executes queries
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查询执行计划提供了数据库引擎执行查询的详细信息
- en: 'A query execution plan includes details on database query operations, such
    as joins and sorts. Let’s look at a simple query that gives us a specific book’s
    total sales:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查询执行计划包括数据库查询操作（如连接和排序）的详细信息。让我们看看一个简单的查询，它给出了特定书籍的总销售额：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s add an `EXPLAIN` command to the same query to reveal the steps the
    database engine follows to execute our query:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向相同的查询添加一个`EXPLAIN`命令，以揭示数据库引擎执行我们的查询的步骤：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By viewing the query execution plan, we can identify potential bottlenecks,
    providing us with an opportunity to further optimize our database and queries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看查询执行计划，我们可以识别潜在的瓶颈，这为我们进一步优化数据库和查询提供了机会。
- en: Next, let’s look at some best practices for writing efficient queries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看编写高效查询的一些最佳实践。
- en: Best practices
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Our goals when writing SQL queries are to minimize resource use and reduce execution
    time. To achieve these goals, we should follow best practices, including the ones
    detailed as follows for the `SELECT` statement, `JOIN` operations, **subqueries**,
    and **common table** **expressions** (**CTEs**).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 SQL 查询时的目标是尽量减少资源使用并减少执行时间。为了实现这些目标，我们应该遵循最佳实践，包括以下针对 `SELECT` 语句、`JOIN`
    操作、**子查询**和**公用表表达式**（**CTEs**）的详细说明。
- en: SELECT statement
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SELECT` 语句'
- en: There are three best practices involved with using the `SELECT` statement. First,
    we should avoid using `SELECT *` and only specify the columns we need. For example,
    instead of using `SELECT * FROM Books;`, use `SELECT Title, AuthorID, Genre` `FROM
    Books;`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SELECT` 语句有三个最佳实践。首先，我们应该避免使用 `SELECT *`，而只指定我们需要的列。例如，不要使用 `SELECT * FROM
    Books;`，而应使用 `SELECT Title, AuthorID, Genre FROM Books;`。
- en: 'Another best practice is to use the `WHERE` clause to narrow down our results
    to the maximum extent possible. Here is an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是使用 `WHERE` 子句尽可能缩小我们的结果集。以下是一个示例：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A third best practice for using the `SELECT` statement is to limit the number
    of rows returned by our query. We can use the `LIMIT` clause, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SELECT` 语句的第三个最佳实践是限制查询返回的行数。我们可以使用 `LIMIT` 子句，如下所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The three best practices for working with the `SELECT` statement are key to
    improving the efficiency of our queries. Next, let’s look at best practices for
    using `JOIN` operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SELECT` 语句的三个最佳实践对于提高查询效率至关重要。接下来，让我们看看使用 `JOIN` 操作的最佳实践。
- en: JOIN operations
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JOIN 操作
- en: There are two best practices for using `JOIN` operations. First, we should ensure
    that all columns used in `JOIN` conditions are indexed. This will improve the
    efficiency of these operations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `JOIN` 操作有两个最佳实践。首先，我们应该确保在 `JOIN` 条件中使用的所有列都已建立索引。这将提高这些操作的效率。
- en: Another best practice is to use the appropriate `JOIN` type, as indicated in
    the following table.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是使用以下表格中指示的适当 `JOIN` 类型。
- en: '| **Type** | **Purpose** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **用途** |'
- en: '| `INNER JOIN` | Used to match rows |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `INNER JOIN` | 用于匹配行 |'
- en: '| `LEFT JOIN` | To include all rows from the left table |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `LEFT JOIN` | 包括左表中的所有行 |'
- en: '| `RIGHT JOIN` | To include all rows from the right table |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `RIGHT JOIN` | 包括右表中的所有行 |'
- en: 'Table 15.5: JOIN type and its purpose'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.5：JOIN 类型及其用途
- en: Next, let’s look at the concept of subqueries and their related best practices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨子查询的概念及其相关最佳实践。
- en: Subqueries
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子查询
- en: 'As the title suggests, **subqueries** are used to break a complex query into
    multiple, simpler queries. Here is an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如标题所示，**子查询**用于将复杂查询分解成多个更简单的查询。以下是一个示例：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let’s look at CTEs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 CTEs。
- en: CTEs
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CTEs
- en: 'CTEs can be used to make complex queries more readable. This increases their
    reusability and eases their maintainability. Here is an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CTEs 可以用来使复杂查询更易于阅读。这增加了它们的可重用性并简化了它们的可维护性。以下是一个示例：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have reviewed several best practices for writing queries, let’s
    look at some advanced SQL techniques.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查了编写查询的几个最佳实践，让我们看看一些高级 SQL 技术。
- en: Advanced SQL techniques
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级 SQL 技术
- en: This section demonstrates three advanced SQL techniques – window functions,
    recursive queries, and temporary tables and views.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本节演示了三种高级 SQL 技术——窗口函数、递归查询和临时表及视图。
- en: Window functions
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口函数
- en: 'A **window function** is used to calculate across a set of rows related to
    a current row. Here is an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口函数**用于计算与当前行相关的一组行的值。以下是一个示例：'
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Recursive queries
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归查询
- en: 'Recursive queries are complicated and can be useful when you have hierarchical
    data, such as book categories and subcategories. Here is an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 递归查询是复杂的，但在处理具有层次结构的数据（如书籍类别和子类别）时非常有用。以下是一个示例：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Temporary tables and views
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时表和视图
- en: 'Another advanced technique is to use temporary tables and views to achieve
    better performance and help manage complex queries. Here is an example of a temporary
    table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种高级技术是使用临时表和视图来提高性能并帮助管理复杂查询。以下是一个临时表的示例：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following SQL statement is an example of a temporary view:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 SQL 语句是一个临时视图的示例：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Experimenting with the advanced techniques presented in this section can improve
    your ability to write efficient queries, contributing to the overall performance
    of your Java application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中尝试使用所介绍的高级技术可以提高编写高效查询的能力，从而有助于提高 Java 应用程序的整体性能。
- en: Additional strategies
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外策略
- en: So far, this chapter has covered designing a database schema for efficiency
    and how to write efficient SQL queries. There are several additional strategies
    we can employ, including fine-tuning, monitoring, and maintenance. Each of these
    strategies is explored in this section and uses the same book inventory and ordering
    example from the previous section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经涵盖了为效率设计数据库模式以及如何编写高效的SQL查询。我们还可以采用一些其他策略，包括微调、监控和维护。本节将探讨这些策略，并使用上一节中相同的图书库存和订购示例。
- en: Fine-tuning
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微调
- en: 'We can fine-tune our database server’s configuration parameters to ensure that
    our queries make efficient use of resources. This fine-tuning can be categorized
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以微调数据库服务器的配置参数，以确保我们的查询能够高效地使用资源。这种微调可以归类如下：
- en: '**Database** **server parameters**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库** **服务器参数**'
- en: '`innodb_buffer_pool_size` parameter in MySQL with the `SET shared_buffers =
    ''3GB'';` SQL statement.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MySQL中的`innodb_buffer_pool_size`参数和`SET shared_buffers = '3GB';` SQL语句。
- en: '**Connection pooling**: As detailed in [*Chapter 10*](B21942_10.xhtml#_idTextAnchor172),
    *Connection Pooling*, we can pool our database connections to reduce overhead
    and improve overall application performance.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接池**：如[*第10章*](B21942_10.xhtml#_idTextAnchor172)中详细介绍的*连接池*，我们可以将数据库连接进行池化，以减少开销并提高整体应用性能。'
- en: '`SET query_cache_size = 256MB'';` will enable query caching.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET query_cache_size = 256MB'';`将启用查询缓存。'
- en: '**Memory management**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**'
- en: '**Database caching**: We can cache databases to speed up read operations for
    frequently accessed data. Tools such as **Redis** can be used to aid in this technique.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库缓存**：我们可以缓存数据库以加快对频繁访问数据的读取操作。可以使用**Redis**等工具来辅助这项技术。'
- en: Next, let’s explore how we can monitor and profile our database’s performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨如何监控和评估数据库的性能。
- en: Database performance monitoring
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库性能监控
- en: Once our database is up and running and all our queries are established, we
    are ready to monitor our database’s performance. Monitoring can help us identify
    potential bottlenecks and allow us to make refinements to improve overall performance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的数据库启动并运行，并且所有查询都已建立，我们就可以准备监控数据库的性能。监控可以帮助我们识别潜在的瓶颈，并允许我们对性能进行优化。
- en: 'A proven approach to identify bottlenecks is to enable **slow query logging**.
    This can help us identify which queries take longer than we desire to execute.
    Here is how this can be enabled:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 识别瓶颈的一个有效方法是启用**慢查询日志**。这可以帮助我们识别哪些查询的执行时间超过了我们的期望。以下是启用方法：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The use of query profiling tools can help us analyze and optimize slow queries.
    There are various tools available, depending on your database type and service.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询分析工具可以帮助我们分析和优化慢查询。根据您的数据库类型和服务，有各种可用的工具。
- en: Monitoring and profiling can help identify opportunities for refinement. In
    the next section, we will explore database maintenance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和评估可以帮助识别优化机会。在下一节中，我们将探讨数据库维护。
- en: Database maintenance
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库维护
- en: 'Databases are dynamic and need to be maintained with regularly scheduled maintenance.
    This is a proactive, vice reactive approach to maintaining your databases. Here
    are some tips:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是动态的，需要通过定期维护来维护。这是一种主动而非被动的方法来维护数据库。以下是一些建议：
- en: Regularly run `VACUUM` to reclaim storage.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期运行`VACUUM`以回收存储空间。
- en: After each run of `VACUUM`, run `ANALYZE` so that the query planner has updated
    statistics.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次运行`VACUUM`之后，运行`ANALYZE`以便查询规划器更新统计信息。
- en: Use `REINDEX` to periodically reindex your database. This will improve query
    performance.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`REINDEX`定期重新索引数据库。这将提高查询性能。
- en: Archive old data that is no longer needed. You can partition this data into
    a historical database.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档不再需要的老数据。您可以将这些数据分区到历史数据库中。
- en: Purge data that is not needed. This will free up storage and should improve
    query performance.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除不再需要的数据。这将释放存储空间并应提高查询性能。
- en: The strategies presented in this section can help you further enhance your query
    performance, the database performance, and the overall performance of your Java
    application. These strategies are especially important for large databases and
    those with high transaction rates.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提出的策略可以帮助您进一步优化查询性能、数据库性能以及Java应用程序的整体性能。这些策略对于大型数据库和高交易率数据库尤为重要。
- en: In the next section, we will review several real-world case studies to help
    you contextualize the concepts presented in this chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾几个现实世界的案例研究，以帮助您将本章中提出的概念置于上下文中。
- en: Case studies
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: This section presents three real-world case studies using the book inventory
    and order processing database featured throughout this chapter. A review of the
    case studies will demonstrate how the strategies and techniques presented in this
    chapter can be used to solve common database performance problems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了三个使用本章中提到的书籍库存和订单处理数据库的真实案例研究。对案例研究的回顾将展示本章中提出的策略和技术如何用于解决常见的数据库性能问题。
- en: 'Each case study is presented in the following format:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个案例研究都按照以下格式展示：
- en: The scenario
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景
- en: The initial SQL query
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始 SQL 查询
- en: The problem
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题
- en: The optimization steps
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化步骤
- en: The result
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果
- en: Case study 1
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 1
- en: '**Scenario**: Every time the bookstore’s administrator runs the sales report,
    it takes several minutes – much longer than it should. The report simply summarizes
    total sales by title. The database schema is the same as the one presented earlier
    in this chapter.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**：每次书店管理员运行销售报告时，都需要几分钟时间——比应有的时间要长得多。报告只是简单地按标题总结总销售额。数据库模式与本章前面展示的相同。'
- en: '**Initial** **SQL query**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始** **SQL 查询**：'
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Books` and `Orders` tables. This results in slow performance.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Books` 和 `Orders` 表。这导致性能缓慢。'
- en: '**Optimization steps**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化步骤**：'
- en: 'The database administrator added indexes to the `BookID` columns in both the
    `Books` and `Orders` tables:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库管理员在 `Books` 和 `Orders` 表的 `BookID` 列上添加了索引：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The query was refined to only include columns that were needed to retrieve
    the desired data:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询被优化，仅包括检索所需数据所需的列：
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`EXPLAIN ANALYZE` command, showed a significant query time reduction. The sales
    report now runs in less than one minute.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPLAIN ANALYZE` 命令显示查询时间显著减少。销售报告现在在一分钟内完成。'
- en: Case study 2
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 2
- en: '`Orders` table now contains millions of records. Running queries for specific
    years is extremely slow.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Orders` 表现在包含数百万条记录。对特定年份的查询运行速度极慢。'
- en: '**Initial** **SQL query**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始** **SQL 查询**：'
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Problem**: The query performs a full table scan, which results in slow performance.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：查询执行了全表扫描，导致性能缓慢。'
- en: '**Optimization steps**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化步骤**：'
- en: 'The database administrator performed horizontal partitioning, creating tables
    for each year:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库管理员执行了水平分区，为每年的数据创建表：
- en: '[PRE23]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After partitioning the data, the administrator updated the queries to target
    the specific partitions:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据分区后，管理员更新了查询以针对特定的分区：
- en: '[PRE24]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Result**: The query performance significantly improved, running at a fraction
    of the previous time.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：查询性能显著提高，运行时间仅为之前的一小部分。'
- en: Case study 3
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 3
- en: '`Books` table resulted in a significant and unnecessary load on the database.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Books` 表导致数据库产生显著且不必要的负载。'
- en: '**Initial** **SQL query**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始** **SQL 查询**：'
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Problem**: Identical queries were repeatedly sent to the database, creating
    a high load and slow response time.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：数据库被反复发送相同的查询，导致高负载和缓慢的响应时间。'
- en: '**Optimization step**: The database administrator used **Redis** to cache book
    details.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化步骤**：数据库管理员使用 **Redis** 缓存书籍详情。'
- en: '**Result**: The database load was significantly reduced, and the response times
    were drastically shorter.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：数据库负载显著减少，响应时间大幅缩短。'
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explored essential strategies and techniques to optimize databases
    and SQL queries. The chapter’s overall aim was to introduce database-related enhancements
    and best practices to improve the performance of your data-driven applications.
    We began with the fundamentals of database design, including schema normalization,
    appropriate indexing, and partitioning strategies. We then explored how to write
    efficient SQL queries. Our coverage also included query execution plans and leveraging
    advanced SQL techniques, such as window functions and recursive queries. Additional
    strategies, including database configuration, monitoring, profiling, and regular
    maintenance, were also discussed. The chapter ended with real-world case studies
    to demonstrate the practical application of the strategies and techniques covered
    in the chapter. You should now be confident in implementing these best practices
    and ensuring your database systems can handle large datasets and complex queries
    with ease.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了优化数据库和SQL查询的必要策略和技术。本章的总体目标是介绍与数据库相关的增强和最佳实践，以提高您数据驱动应用程序的性能。我们从数据库设计的根本原则开始，包括模式规范化、适当的索引和分区策略。然后我们探讨了如何编写高效的SQL查询。我们的覆盖范围还包括查询执行计划和利用高级SQL技术，如窗口函数和递归查询。本章还讨论了包括数据库配置、监控、分析和定期维护在内的其他策略。本章以实际案例研究结束，以展示本章中涵盖的策略和技术的实际应用。现在，您应该有信心实施这些最佳实践，并确保您的数据库系统可以轻松处理大型数据集和复杂查询。
- en: In the next chapter, we will examine the concepts of code monitoring and code
    maintenance, with an ever-vigilant eye on the high performance of our Java applications.
    Our approaches to code monitoring and maintenance will include conducting code
    reviews to identify potential performance issues before they become problematic.
    Specifically, we will look at **application performance management** (**APM**)
    tools, code reviews, log analysis, and continuous improvement.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨代码监控和代码维护的概念，始终保持对我们的Java应用程序高性能的警觉。我们的代码监控和维护方法将包括在问题出现之前进行代码审查，以识别潜在的性能问题。具体来说，我们将探讨**应用性能管理**（**APM**）工具、代码审查、日志分析和持续改进。
