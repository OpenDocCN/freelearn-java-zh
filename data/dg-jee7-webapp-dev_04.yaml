- en: Chapter 4. JSF Validation and AJAX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. JSF验证和AJAX
- en: '|   | *"It always seems impossible until it is done."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"直到完成，这似乎总是不可能的。" |   |'
- en: '|   | --*Nelson Mandela* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*纳尔逊·曼德拉* |'
- en: So far, we have created a digital customer journey that accomplishes the common
    create, retrieve, update, and delete, that is, the famous CRUD requirement. The
    results are attractive to the stakeholder and to the product owner, but the user
    members of our team are not satisfied with the form, because it lacks the ability
    to verify the data entries made by members of the general public.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个数字客户旅程，实现了常见的创建、检索、更新和删除，即著名的CRUD需求。这些结果对利益相关者和产品所有者都有吸引力，但我们的团队成员的用户对表单不满意，因为它缺乏验证公众成员数据输入的能力。
- en: When we think about it, validation is important for the user as he or she is
    the one entering the data in a web application. It saves time and frustration
    for the user, because they know that the entry is wrong as they enter the data.
    It avoids the costs incurred for fixing of the wrongly submitted data by the database
    administrator. Validation improves the efficiency of a web application that works
    24/7 over the Internet. As more of our daily lives get dependent on the digital
    adaptation of traditional services, e-commerce is now a necessity; it is essential
    that we give the general public the right information at the right time, that
    is, at the point-of-sale or point-of-capture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考时，验证对用户很重要，因为是他们正在输入网络应用程序中的数据。它节省了用户的时间和挫败感，因为他们知道他们在输入数据时输入是错误的。它避免了数据库管理员因错误提交数据而产生的成本。验证提高了在互联网上24/7工作的网络应用程序的效率。随着我们日常生活中的更多活动依赖于传统服务的数字化，电子商务现在成为了一种必需品；我们有必要在正确的时间向公众提供正确的信息，即在销售点或捕获点。
- en: Validation methods
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证方法
- en: In this chapter, taking the basic JSF form as a base, we will learn how to apply
    validation on the server side and on the client-server side. There are certain
    advantages to both the strategies; we will learn about the pros and cons of both
    the approaches.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，以基本的JSF表单为基础，我们将学习如何在服务器端和客户端应用验证。这两种策略都有一定的优势；我们将了解这两种方法的优缺点。
- en: Server-side validation
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端验证
- en: Form validation can be achieved on the server-side in a Java EE application
    running on the application server or the servlet container. The information is
    sent from the web browser to the web application as a normal HTTP form submission.
    In this mode, the form is submitted as a traditional HTML form element. The web
    framework, in this case Java EE, validates the input and sends back a response
    to the client. If the form fails the validation, the page that contains the web
    form is redisplayed and error messages are shown.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE应用程序中，可以在运行在应用服务器或servlet容器上的服务器端实现表单验证。信息以正常HTTP表单提交的形式从Web浏览器发送到Web应用程序。在这种模式下，表单作为传统的HTML表单元素提交。在这种情况下，Java
    EE框架验证输入并向客户端发送响应。如果表单验证失败，包含Web表单的页面将被重新显示，并显示错误消息。
- en: The server-side quick validation is secure in the sense that it will protect
    the database even if JavaScript is disabled or unavailable in a web browser. On
    the other hand, this type of validation requires a round trip from the client
    to the server side. The users will not get feedback about the form data until
    they submit the form.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端快速验证在安全方面是可靠的，因为它即使在Web浏览器中禁用或不可用时也会保护数据库。另一方面，这种验证需要客户端到服务器端的往返。用户在提交表单之前不会得到关于表单数据的反馈。
- en: There always seems to be an exception to a rule. If the server-side form validation
    is submitted using AJAX, then we can get around the slow response. AJAX validation
    is a nice compromise, because the form can be validated as and when the user enters
    the data on the form. On the other hand, AJAX requires JavaScript to be enabled
    in the web browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 规则似乎总有例外。如果使用AJAX提交服务器端表单验证，那么我们可以绕过缓慢的响应。AJAX验证是一个很好的折衷方案，因为表单可以在用户在表单上输入数据时进行验证。另一方面，AJAX需要在Web浏览器中启用JavaScript。
- en: Client-side validation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端验证
- en: The user-experience person in our team really prefers the client-side validation,
    but this type of validation requires the presence of JavaScript in the browser
    (or an equivalent type of dynamic scripting technology). Client-side validation
    affords a more responsive and richer user interaction with the form.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们团队中的用户体验人员真的很喜欢客户端验证，但这种验证类型需要在浏览器（或等效的动态脚本技术）中存在JavaScript。客户端验证提供了更响应和丰富的用户与表单的交互。
- en: Client-side validation ensures that the form is always correct before the user
    is allowed to submit the form. With JavaScript being a progressive language, there
    are many ways to inform the user how to better interact with the form submission
    process. Technologies such as jQuery allow the programmers to add hinting and
    validation error messages in flight as the user types the data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端验证确保在用户被允许提交表单之前，表单始终是正确的。由于JavaScript是一种渐进式语言，有许多方法可以通知用户如何更好地与表单提交过程交互。例如jQuery这样的技术允许程序员在用户输入数据时实时添加提示和验证错误消息。
- en: There are situations where JavaScript is disabled or unavailable in the web
    browser. I can readily think of government security or specialist centers where
    the sandbox is strictly controlled. When JavaScript is turned off by the user
    or by the administrator of the device, client-side validation will certainly fail,
    and the user is able to bypass the validation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，JavaScript在浏览器中可能被禁用或不可用。我可以想到政府安全部门或专业中心，这些地方沙盒是严格控制的。当用户或设备管理员关闭JavaScript时，客户端验证肯定会失败，用户能够绕过验证。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Combine client-side and server-side validation**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**结合客户端和服务器端验证**'
- en: In professional applications for businesses, I strongly recommend that you combine
    both the approaches to validation in order to get the best of both worlds. Client-side
    validation provides a faster and richer experience and server-side validation
    protects your data and database from bad data and hacking.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向企业的专业应用中，我强烈建议您结合两种验证方法，以获得两者的最佳效果。客户端验证提供了更快、更丰富的体验，而服务器端验证则保护您的数据和数据库免受不良数据和黑客攻击。
- en: Before we go through the technical topic of validation, we must understand how
    messages are represented in JSF.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论验证的技术主题之前，我们必须了解消息在JSF中的表示方式。
- en: Faces messages
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Faces消息
- en: The JSF provides two custom tags to display error messages. The `<h:message>`
    tag displays messages that are bound to specific components. The `<h:messages>`
    tag displays messages that are not bound to specific components.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JSF提供了两个自定义标签来显示错误消息。`<h:message>`标签显示绑定到特定组件的消息。`<h:messages>`标签显示未绑定到特定组件的消息。
- en: 'We saw our first use of `<h:message>` in [Chapter 3](part0035.xhtml#aid-11C3M2
    "Chapter 3. Building JSF Forms"), *Building JSF Forms*. The tag is typically associated
    with a form control. We can add messages to our JSF pages with the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](part0035.xhtml#aid-11C3M2 "第3章。构建JSF表单")中看到了`<h:message>`的第一个使用，*构建JSF表单*。该标签通常与表单控件相关联。我们可以使用以下方式向我们的JSF页面添加消息：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The tag is added to the top of the content. The attribute `globalStyle` is a
    Boolean value, and it specifies whether the tag should display messages that are
    not associated with a component. Here, we are using the Bootstrap CSS selectors
    again.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标签被添加到内容顶部。属性`globalStyle`是一个布尔值，它指定标签是否应显示与组件无关的消息。在这里，我们再次使用Bootstrap CSS选择器。
- en: 'The following is a table of the attributes that are shared between the JSF
    tags, `<h:messages>` and `<h:message>`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表格，列出了JSF标签`<h:messages>`和`<h:message>`之间共享的属性：
- en: '| Attribute | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Id` | Specifies the unique identifier |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `Id` | 指定唯一标识符 |'
- en: '| `errorClass` | Specifies the CSS class selectors for error messages |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `errorClass` | 指定错误消息的CSS类选择器 |'
- en: '| `errorStyle` | Specifies the style for error messages |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `errorStyle` | 指定错误消息的样式 |'
- en: '| `infoClass` | Specifies the CSS class selector for information messages |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `infoClass` | 指定信息消息的CSS类选择器 |'
- en: '| `infoStyle` | Specifies the CSS styles for information messages |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `infoStyle` | 指定信息消息的CSS样式 |'
- en: '| `for` | Specifies the component that a message is associated with |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `for` | 指定与消息关联的组件 |'
- en: '| `rendered` | Sets a Boolean value to specify whether the tag is rendered
    to the page or not |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `rendered` | 设置一个布尔值以指定标签是否渲染到页面 |'
- en: '| `style` | Defines the CSS selectors for all the message types |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `style` | 定义所有消息类型的CSS选择器 |'
- en: '| `styleClass` | Defines the CSS style for all the message types |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `styleClass` | 定义所有消息类型的CSS样式 |'
- en: Behind the scenes, these tags render the content from the `javax.faces.HtmlMessages`
    and `javax.faces.HtmlMessages` components respectively, which in turn, rely on
    the list collection of the `javax.faces.application.FacesMessage` elements. As
    a JSF digital developer, we do not have to worry too much about the `HtmlMessage`
    and `HtmlMessages` components from day-to-day, as they lie under the car bonnet.
    If we were in the business of writing a new JSF renderer or an extension, then
    we would have to look at the Javadoc and JSF specifications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，这些标签分别渲染了`javax.faces(HtmlMessages)`和`javax.faces(HtmlMessages)`组件的内容，而这些组件又依赖于`javax.faces.application.FacesMessage`元素的列表集合。作为一个JSF数字开发者，我们不必太担心日常的`HtmlMessage`和`HtmlMessages`组件，因为它们位于引擎盖下。如果我们从事编写新的JSF渲染器或扩展的工作，那么我们就必须查看Javadoc和JSF规范。
- en: 'In [Chapter 3](part0035.xhtml#aid-11C3M2 "Chapter 3. Building JSF Forms"),
    *Building JSF Forms*, you were introduced to the application, `FacesMessage`,
    for creating the JSF CRUD style forms. In the Controller, we can create a validation
    error message that is not associated to any `UIComponent` in the form. Therefore
    this validation error is accessible only through global error messages. Here is
    code that generates such a validation error:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0035.xhtml#aid-11C3M2 "第3章。构建JSF表单")中，*构建JSF表单*，你被介绍到`FacesMessage`应用程序，用于创建JSF
    CRUD风格表单。在控制器中，我们可以创建一个与表单中任何`UIComponent`无关的验证错误消息。因此，这个验证错误只能通过全局错误消息访问。以下是一个生成此类验证错误的代码示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `FacesMessage` object represents a validation message with a severity level.
    We add it to the `FacesContext` object. The `FacesMessage` constructor is of the
    form:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`FacesMessage`对象代表一个具有严重级别的验证消息。我们将其添加到`FacesContext`对象中。`FacesMessage`构造函数的形式如下：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The severity can be of four static constants defined in the `FaceMessages` class,
    which are `SEVERITY_INFO`, `SERVERITY_WARNING`, `SEVERITY_ERROR`, and `SEVERITY_FATAL`.
    These values are actually instantiations of a private inner class `Severity` that,
    unfortunately, is not accessible outside the enclosing class, so we can invent
    our own severities.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 严重性可以是`FaceMessages`类中定义的四个静态常量之一，这些常量分别是`SEVERITY_INFO`、`SEVERITY_WARNING`、`SEVERITY_ERROR`和`SEVERITY_FATAL`。这些值实际上是私有内部类`Severity`的实例化，不幸的是，这个类在封装类外部不可访问，因此我们可以发明我们自己的严重性级别。
- en: A Faces message also requires a summary of the message and, optionally, details
    about the invalidation message.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Faces消息还需要消息摘要，以及可选的无效消息的详细信息。
- en: '`javax.faces.context.FacesContext` is an aggregate holder for the current incoming
    request and the potential response. The object instance is instantiated on the
    initial JSF incoming request (Faces Request), and it will stay alive until the
    subsequent JSF `release()` method is triggered, which is usually deep inside the
    framework. `FacesContext` is the place from where a `FacesMessage` is added and
    from where the list collection of messages can be retrieved.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.faces.context.FacesContext`是当前传入请求和潜在响应的聚合持有者。对象实例在初始JSF传入请求（Faces请求）时实例化，并且它将一直存活，直到后续的JSF
    `release()`方法被触发，这通常在框架的深处。`FacesContext`是添加`FacesMessage`的地方，也是检索消息列表集合的地方。'
- en: '`FacesContext` has several interesting methods including `isValidationFailed()`,
    which is useful to detect any validation failure earlier in the JSF lifecycle.
    We shall see an example of this call later with Bean Validation. There are other
    methods as well like using `getViewRoot()` to get the view root, `getCurrentPhaseId()`
    to get the current phase in the JSF lifecycle, and `getRenderKit()` to retrieve
    the render kit form. With the `isPostback()` method, we can find out if the request
    was an HTML form and if the JSF framework is about to send the data back to the
    same form. There is much more to the context objects.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`FacesContext`有几个有趣的方法，包括`isValidationFailed()`，这个方法在JSF生命周期早期检测任何验证失败非常有用。我们将在稍后的Bean
    Validation示例中看到这个调用的例子。还有其他方法，例如使用`getViewRoot()`获取视图根，`getCurrentPhaseId()`获取JSF生命周期中的当前阶段，以及`getRenderKit()`检索渲染套件。使用`isPostback()`方法，我们可以找出请求是否是HTML表单，以及JSF框架是否即将将数据发送回同一表单。上下文对象还有很多其他功能。'
- en: 'The method to add a faces message to the context looks as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将faces消息添加到上下文的方法如下：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the `clientId` attribute is null, the message is a globally available message
    and is not associated with any view component.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`clientId`属性为null，则消息是全局可用的消息，并且与任何视图组件无关。
- en: Now that we've understood how to generate JSF- specific messages, let's delve
    into the validation of a JSF application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何生成 JSF 特定的消息，让我们深入了解 JSF 应用程序的验证。
- en: Validation
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: There are a two main ways of achieving validation on the server side. One route
    to follow is through the use of Bean Validation version 1.1 from the Java EE 7
    specification, and the other traditional route takes you through JSF validation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端实现验证主要有两种方式。一种途径是遵循 Java EE 7 规范中 Bean Validation 1.1 版本的使用，另一种传统途径是通过
    JSF 验证。
- en: Constraining form content with Bean Validation
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bean Validation 限制表单内容
- en: Bean Validation is a specification that allows the developers to annotate the
    POJOs and entity beans and then call a custom validator instance to verify the
    properties. The validation framework works with Java annotation and thus, the
    digital engineer can firmly say how a property or even a method is validated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 是一种规范，允许开发者对 POJOs 和实体豆进行注解，然后调用自定义验证器实例来验证属性。验证框架与 Java 注解一起工作，因此数字工程师可以明确地说一个属性或甚至一个方法是如何被验证的。
- en: I devoted an entire chapter to Bean Validation in the *Java EE 7 Developer Handbook*;
    nevertheless, I will run through the basics with you here, in this Digital Web
    Application book. There are several annotations in the Bean Validation 1.1 standard
    that you can use straightaway. However, if your platform allows or if you decide
    to add Hibernate Validator, then many more useful validation annotations are available.
    The developer can also create custom validations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '我在 *Java EE 7 开发者手册* 中专门用了一章来介绍 Bean Validation；尽管如此，我仍将在本数字网络应用程序书中与您一起简要介绍基础知识。Bean
    Validation 1.1 标准中有几个注解您可以直接使用。然而，如果您的平台允许或您决定添加 Hibernate Validator，那么还有更多有用的验证注解可供使用。开发者还可以创建自定义验证。 '
- en: 'Let''s use the `ContactDetail` entity again, but this time we have added Bean
    Validation annotations to the properties, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用 `ContactDetail` 实体，但这次我们在属性中添加了 Bean Validation 注解，如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We added the annotations `@Pattern`, `@Past`, `@NotNull`, and `@Size` to the
    properties of the `ContactDetail` entity. The annotations can be found in the
    Java package `javax.validation.constraints`, reserved for Bean Validation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `ContactDetail` 实体的属性中添加了 `@Pattern`、`@Past`、`@NotNull` 和 `@Size` 注解。这些注解可以在
    Java 包 `javax.validation.constraints` 中找到，为 Bean Validation 保留。
- en: 'The following is a table of the important Bean Validation annotations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个重要的 Bean Validation 注解表：
- en: '| Constraint Name | Description | Allowed Types |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 约束名称 | 描述 | 允许类型 |'
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@Null` | Specifies that the element must be a null reference pointer. |
    Any |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `@Null` | 指定元素必须是一个 null 引用指针。 | 任何 |'
- en: '| `@NotNull` | Specifies that the element must not be a null reference pointer.
    | Any |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `@NotNull` | 指定元素必须不是一个 null 引用指针。 | 任何 |'
- en: '| `@Min` | Specifies that the element must be a number value that is greater
    than or equal to the minimum value supplied. Because of floating arithmetic rounding
    errors, float and double are not supported. | `BigDecimal, BigInteger, byte, short,
    int, and long` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `@Min` | 指定元素必须是一个数值，该数值大于或等于提供的最小值。由于浮点数四舍五入错误，不支持 float 和 double。 | `BigDecimal,
    BigInteger, byte, short, int, 和 long` |'
- en: '| `@Max` | Specifies that the element must be a number value that is less than
    or equal to the minimum value supplied. Because of floating arithmetic rounding
    errors, float and double are not supported. | `BigDecimal, BigInteger, byte, short,
    int, and long` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `@Max` | 指定元素必须是一个数值，该数值小于或等于提供的最小值。由于浮点数四舍五入错误，不支持 float 和 double。 | `BigDecimal,
    BigInteger, byte, short, int, 和 long` |'
- en: '| `@DecimalMin` | Similar to `@Min` but adds the ability to set the value as
    a String parameter. The number value must be greater than or equal to the supplied
    value. FP restriction also applies here. | `BigDecimal, BigInteger,``CharSequence,
    byte, short, int, and long` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `@DecimalMin` | 与 `@Min` 类似，但增加了将值设置为字符串参数的能力。数值必须大于或等于提供的值。FP 限制也适用于此处。
    | `BigDecimal, BigInteger,` `CharSequence, byte, short, int, 和 long` |'
- en: '| `@DecimalMax` | Similar to `@Max` but adds the ability to set the value as
    a String parameter. The number value must be less than or equal to the supplied
    value. FP restriction also applies here. | `BigDecimal, BigInteger,``CharSequence,
    byte, short, int, and long` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `@DecimalMax` | 与 `@Max` 类似，但增加了将值设置为字符串参数的能力。数值必须小于或等于提供的值。FP 限制也适用于此处。
    | `BigDecimal, BigInteger,` `CharSequence, byte, short, int, 和 long` |'
- en: '| `@Size` | The element''s size must be inside the supplied inclusive boundary
    limits. | `CharSequence, Collection, Map and primitive array` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `@Size` | 元素的大小必须在提供的包含边界限制内。 | `CharSequence, Collection, Map 和原始数组` |'
- en: '| `@Past` | The element must be a date in the past according to the current
    time of the Java Virtual Machine. | `java.util.Date and java.util.Calendar` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `@Past` | 元素必须是 Java 虚拟机当前时间的过去日期。 | `java.util.Date 和 java.util.Calendar`
    |'
- en: '| `@Future` | The element must be a date in the future according to the current
    time of the Java Virtual Machine. | `java.util.Date and java.util.Calendar` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `@Future` | 元素必须是 Java 虚拟机当前时间的未来日期。 | `java.util.Date 和 java.util.Calendar`
    |'
- en: '| `@Pattern` | The element must match against a supplied regular expression
    pattern that conforms to the Java convention. | `CharSequence` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `@Pattern` | 元素必须匹配一个符合 Java 习惯的提供的正则表达式模式。 | `CharSequence` |'
- en: Bean Validation annotations typically accept a message attribute, which is the
    validation message for the user, or it can be a value in brackets, which is a
    trigger for the validation framework to search for a message from `java.util.ResourceBundle`.
    Certain annotations like `@Min`, `@Max`, `@DecimalMin`, and `@DecimalMax` have
    additional attributes like `min` and `max` to specify the obvious boundaries.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 注解通常接受一个消息属性，这是用户的验证消息，或者它可以是括号中的值，这是验证框架从 `java.util.ResourceBundle`
    中搜索消息的触发器。某些注解如 `@Min`、`@Max`、`@DecimalMin` 和 `@DecimalMax` 有额外的属性如 `min` 和 `max`
    来指定明显的边界。
- en: 'We can define an `@NotNull` constraint on the property with the validation
    message, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在具有验证消息的属性上定义一个 `@NotNull` 约束，如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is a good approach, possibly for prototyping a website; but as we know from
    our knowledge of software archaeology. This could be a maintenance nightmare,
    because we are writing a digital copy directly into Java code. It is far better
    to write a text copy inside a property file that can be picked up by the standard
    `ResourceBundle`, which Bean Validation uses. Jenny, our resident digital strategist
    and copywriting expert, will thank us for sending her a property file instead
    of Java source code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种好的方法，可能适用于原型设计一个网站；但正如我们从软件考古学知识中了解的那样，这可能会成为一个维护噩梦，因为我们正在将数字副本直接写入 Java
    代码中。将文本副本写入属性文件中，该文件可以被标准 `ResourceBundle` 捕获，这对于 Bean Validation 来说是更好的选择。我们的驻场数字策略师和文案专家珍妮会感谢我们发送给她属性文件而不是
    Java 源代码。
- en: 'So let''s rewrite this constraint on the property as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将此属性上的约束重写如下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Bean Validation can be integrated with JSF by placing the messages at a specific
    location. The programmer need only create a `ValidationMessages.properties` file
    in the folder `WEB-INF/classes`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将消息放置在特定位置，Bean Validation 可以与 JSF 集成。程序员只需在 `WEB-INF/classes` 文件夹中创建一个 `ValidationMessages.properties`
    文件。
- en: 'The following is an extract of the message properties file for the `ContactDetail`
    entity:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 `ContactDetail` 实体消息属性文件的摘录：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With Bean Validation, we can add placeholders that are denoted with curly brackets
    to enrich the messages that the user will see. The placeholders are specific like
    `{min}` and `{max}`. The other advantage of property files is that the `ResourceBundle`
    in the JDK already handles the tricky topic of internationalization for different
    locales.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bean Validation，我们可以添加用花括号表示的占位符，以丰富用户将看到的消息。占位符是特定的，如 `{min}` 和 `{max}`。属性文件的另一个优点是
    JDK 中的 `ResourceBundle` 已经处理了不同区域设置的国际化难题。
- en: There are big disadvantages to just relying on Bean Validation using JSF. It
    is great for protecting a database from poorly entered data, and with the Java
    EE 7 application server that the digital developer gets almost for free, validation
    is added or amended to the database before each record. However, the Bean Validation
    has no connection to the JSF frontend. The framework does not have any association
    with the page author's content. Nor would we want this dependency between the
    presentation and the model layer in modern day software engineering. One of the
    best practices in object-oriented programming is the SOLID principle. We certainly
    want the layers to be singularly responsible for a purpose; open to extension,
    but closed to modification and, most importantly, to prevent the leaky abstractions
    that cause a technical debt in the software as it ages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 仅依赖 JSF 的 Bean Validation 存在很大的缺点。它对于保护数据库免受错误输入数据的影响非常出色，并且由于数字开发者几乎免费获得的 Java
    EE 7 应用服务器，验证在每条记录之前都会添加或修改到数据库中。然而，Bean Validation 与 JSF 前端没有任何关联。框架与页面作者的內容没有任何关联。在当今的软件工程中，我们也不希望表现层和模型层之间存在这种依赖关系。面向对象编程的最佳实践之一是
    SOLID 原则。我们当然希望各层只为一个目的负责；易于扩展，但封闭于修改，最重要的是，防止随着时间的推移导致软件技术债务的抽象泄漏。
- en: Another disadvantage about just relying on Bean Validation is that the verification
    of the data depends solely on the skills of the Java digital engineer. It means
    that the page author or designer cannot innovate, edit, or remove validation on
    the road to a better user-centric experience.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 仅依赖 Bean Validation 的另一个缺点是，数据的验证完全依赖于 Java 数字工程师的技能。这意味着页面作者或设计师无法创新、编辑或删除验证，以实现更好的以用户为中心的体验。
- en: Bean Validation is great for adding validation in the application logic. You
    can ensure that the contact detail's title is never blank, if this is a business
    requirement. Complex and group validations for properties can be achieved. Refer
    to my book, *Java EE 7 Developer Handbook*, for further details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 对于在应用程序逻辑中添加验证非常出色。如果您有业务需求，可以确保联系详情的标题永远不会为空。可以实现对属性进行复杂和分组验证。有关更多详细信息，请参阅我的书籍《Java
    EE 7 开发者手册》。
- en: 'The following screenshot shows `bean-validation`/`createContactDetail.xhtml`
    in action from the book source code. The screenshot shows what happens when the
    user just submits the form without filling it in:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了来自书籍源代码的 `bean-validation`/`createContactDetail.xhtml` 的实际应用。截图显示了当用户仅提交未填写的表单时会发生什么：
- en: '![Constraining form content with Bean Validation](img/image00385.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Bean Validation 限制表单内容](img/image00385.jpeg)'
- en: Screenshot of Bean Validation on the contact details application
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 联系详情应用程序上的 Bean Validation 捕获图
- en: The `<h:messages>` tag with the setting `globalStyle=true` shows the output
    of the validation messages that the framework discovers in the `ContactDetail`
    entity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 具有设置 `globalStyle=true` 的 `<h:messages>` 标签显示了框架在 `ContactDetail` 实体中发现的验证消息输出。
- en: Validating user input with JSF
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSF 验证用户输入
- en: JSF has always had a validation framework since its inception in 2004\. It was
    a feature that separated JSF from the de facto Apache Struts web framework, at
    the time, as the latter had no built-in support for validation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 自 2004 年推出以来就始终拥有一个验证框架。这是将 JSF 与当时没有内置验证支持的 Apache Struts 实际上使用的 Web 框架区分开来的特性。
- en: It is helpful to remember that conversion and validation occur at different
    phases of the JavaServer Faces lifecycle (review the diagram from [Chapter 2](part0025.xhtml#aid-NQU22
    "Chapter 2. JavaServer Faces Lifecycle"), *JavaServer Faces Lifecycle*, *The execute
    and render lifecycle* section). As a reminder, JSF will set the values in a component
    during the Apply-Request values phase and then use various conversions, if required,
    to transform the input String values to the target object. Validation occurs during
    the Process-Validations phase and this lifecycle follows by design. In order to
    transform the input data from the HTML request, JSF attempts and checks whether
    the parameters can be set in the backing bean. The Update-Model-Values phase follows
    the earlier phases. If a validation or a conversion error occurs in the lifecycle,
    then it is effectively shortened. JSF moves directly to the Render-Response phase
    and it converts the properties in the backing bean to Strings so that the web
    client can display them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，转换和验证发生在JavaServer Faces生命周期的不同阶段（请参阅[第2章](part0025.xhtml#aid-NQU22 "第2章。JavaServer
    Faces生命周期")中的图表，“JavaServer Faces生命周期”，“执行和渲染生命周期”部分）。作为提醒，JSF将在“应用请求值”阶段设置组件中的值，然后根据需要使用各种转换将输入字符串值转换为目标对象。验证发生在“处理验证”阶段，并且这个生命周期是按设计顺序进行的。为了将HTML请求中的输入数据转换为输入数据，JSF尝试并检查是否可以在后端bean中设置参数。更新模型值阶段跟在早期阶段之后。如果在生命周期中发生验证或转换错误，则它实际上会被缩短。JSF直接进入“渲染响应”阶段，并将后端bean中的属性转换为字符串，以便Web客户端可以显示它们。
- en: 'JSF provides a small set of prebuilt validator tags, which you can apply to
    mark up as a page author, A table of the Core JSF Custom Tags has been given in
    [Chapter 3](part0035.xhtml#aid-11C3M2 "Chapter 3. Building JSF Forms"), *Building
    JSF Forms*. Some of them are as follows: `<f:validateDoubleRange>`, `<f:validateLength>`,
    `<f:validateLongRange>`, `<f:validateRegex>`, and `<f:validateRequired>`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: JSF提供了一组预构建的验证器标签，您可以将它们应用于标记页面，[第3章](part0035.xhtml#aid-11C3M2 "第3章。构建JSF表单")中给出了核心JSF自定义标签表，*构建JSF表单*。以下是一些示例：`<f:validateDoubleRange>`，`<f:validateLength>`，`<f:validateLongRange>`，`<f:validateRegex>`
    和 `<f:validateRequired>`。
- en: 'We can apply these tags to the contact detail CRUD example. So let''s start
    with the `createContact.xhtml` page. The following is a short extract from the
    page:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些标签应用于联系详情CRUD示例。因此，让我们从 `createContact.xhtml` 页面开始。以下是页面上的一个简短摘录：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We placed the `<f:validateRequired>`, `<f:validateLength>`, and `<f:validateLongRange>`
    tags inside the body content of the JSF HTML rendering tags like `<h:inputText>`
    and `<h:selectOneMenu>`. The `validateLength` tag verifies the length of String
    property. The tag accepts a maximum parameter, but it can also take a minimum
    attribute.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `<f:validateRequired>`，`<f:validateLength>` 和 `<f:validateLongRange>` 标签放置在JSF
    HTML渲染标签（如 `<h:inputText>` 和 `<h:selectOneMenu>`）的正文内容中。`validateLength` 标签验证字符串属性的长度。该标签接受一个最大参数，但也可以接受一个最小属性。
- en: 'We also added a `<h:message>` tag close to its respective HTML input field.
    The `styleClass` attribute specifies a custom CSS selector that forces the validation
    message on a separate new line. The CSS for this looks like as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在其相应的HTML输入字段附近添加了 `<h:message>` 标签。`styleClass` 属性指定了一个自定义CSS选择器，该选择器将验证消息强制显示在单独的新行上。此CSS看起来如下所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to avoid JSF sugared names like `<jsf_form>:<form_property_name>`
    to the validation error message, which would give a result like `contactDetail:title
    -Validation Error: Value is required`, we specify the label attribute for each
    HTML render tag. The title input field has an attribute setting `label="Title"`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免将JSF糖化名称（如 `<jsf_form>:<form_property_name>`）添加到验证错误消息中，这会导致结果如“contactDetail:title
    -验证错误：值是必需的”，我们为每个HTML渲染标签指定了标签属性。标题输入字段有一个设置 `label="Title"` 的属性。
- en: The `<f:validateLongRange>` tag checks if the actual content of the String is
    a numerical value between the minimum and maximum attributes. We use this tag
    in the `date-of-birth` fields.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:validateLongRange>` 标签检查字符串的实际内容是否在最小和最大属性之间是一个数值。我们在 `出生日期` 字段中使用此标签。'
- en: 'The following extract is the authoring for the day field in the DOB group:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从DOB组中天字段的编写摘录：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code demonstrates how the `<f:validateLongRange>` tag enforces
    the day-of-the month field in the form. We rinse and repeat for the other DOB
    fields.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了 `<f:validateLongRange>` 标签如何强制在表单中执行月份字段。我们对其他出生日期字段重复此操作。
- en: 'The `<f:validateRegex>` tag matches the input property string against a regular
    expression. We use this tag for the `email` property. The following is the code
    for this validation check:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:validateRegex>` 标签将输入属性字符串与正则表达式匹配。我们使用这个标签来验证 `email` 属性。以下是对这个验证检查的代码：'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is interesting to note that the overbearing pattern attribute value, the
    regular expression, is almost exactly the same as in the Bean Validation `@Pattern`.
    We had to convert the double backslash characters to single backslash, because
    we do not need to escape the literal in a normal regular expression, not set in
    Java code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，强制模式属性值，正则表达式，几乎与Bean Validation `@Pattern`中的完全相同。我们不得不将双反斜杠字符转换为单反斜杠，因为在正常的正则表达式中我们不需要转义字面量，在Java代码中也没有设置。
- en: 'The following is a screenshot of the page `jsf-validation`/`createContactDetail.xhtml`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对页面 `jsf-validation`/`createContactDetail.xhtml` 的截图：
- en: '![Validating user input with JSF](img/image00386.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用JSF验证用户输入](img/image00386.jpeg)'
- en: A screenshot demonstrating JSF built-in validation rules
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 展示JSF内置验证规则的截图
- en: Customizing JSF validation
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义JSF验证
- en: 'If you have played around with the source code and ran the example, I bet you
    would have noticed some glaring issues with the JSF validation. For instance,
    when the `email` field has a value that is not a valid e-mail address, you will
    see a validation message like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩过源代码并运行了示例，我敢打赌你会注意到JSF验证中的一些明显问题。例如，当 `email` 字段有一个不是有效电子邮件地址的值时，你会看到一个像这样的验证消息：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Clearly, this very detailed application message fails the user-centric design
    and clean language for the public. What can we do with JSF to avoid these messages?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个非常详细的应用程序消息违反了以用户为中心的设计和清晰的语言。我们能用JSF做些什么来避免这些消息？
- en: 'There are three attributes that can be applied to the HTML rendering tags for
    input fields like `<h:inputText>` and `<h:selectOneMenu>`. The following table
    shows the attributes that can help customize the JSF validation messages:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用于输入字段（如 `<h:inputText>` 和 `<h:selectOneMenu>`）的HTML渲染标签有三个属性。以下表格显示了可以帮助自定义JSF验证消息的属性：
- en: '| Attribute | Description |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `requiredMessage` | Defines a value-based expression that will be used as
    a message text if the field is required. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `requiredMessage` | 定义了一个基于值的表达式，如果字段是必需的，它将被用作消息文本。|'
- en: '| `validatorMessage` | Defines a value-based expression that will be used as
    a validation text if the field and property fails validation. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `validatorMessage` | 定义了一个基于值的表达式，如果字段和属性验证失败，它将被用作验证文本。|'
- en: '| `conversionMessage` | Defines a value-based expression that will be used
    as a message if the field can be converted to the target type. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `conversionMessage` | 定义了一个基于值的表达式，如果字段可以转换为目标类型，它将被用作消息。|'
- en: 'With this information, we can easily solve our issue with the messages by applying
    the `requiredMessage` attribute to our field:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，我们可以通过将 `requiredMessage` 属性应用于我们的字段来轻松解决消息问题：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `requiredMessage`, `validatorMessage`, and `conversionMessage` override
    any message that is set by the JSF validator on the server side. Note that these
    attributes can accept value expressions. This is great for page authors to dictate
    the method. On the other side of the fence though, our e-mail address field has
    two validation constraints, a regular expression check and a length-of-field constraint.
    The message is not appropriate for `validateLength`. So we have a problem there
    if we use more than one type of validator following this approach.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`requiredMessage`、`validatorMessage` 和 `conversionMessage` 会覆盖服务器端JSF验证器设置的任何消息。请注意，这些属性可以接受值表达式。这对页面作者来说是一个很好的方法来指定方法。然而，在另一边，我们的电子邮件地址字段有两个验证约束，一个是正则表达式检查，另一个是字段长度约束。对于
    `validateLength`，这个消息并不合适。所以如果我们使用这种方法来使用多个类型的验证器，我们就会遇到问题。'
- en: 'There is another approach that we could take. How about overriding the validation
    messages globally in the JSF framework? We can configure our own version of the
    JSF validator messages. In order to achieve this goal, first, we configure the
    framework with the information regarding the location for loading these messages.
    We set up a message bundle in the `WEB-INF/faces-config.xml` file, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以采取另一种方法。在JSF框架中全局覆盖验证消息怎么样？我们可以配置我们自己的JSF验证器消息版本。为了实现这个目标，首先，我们使用有关加载这些消息的位置的信息来配置框架。我们在
    `WEB-INF/faces-config.xml` 文件中设置了一个消息包，如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This configuration file defines the Faces resources for the application, and
    here we can configure a message bundle that references a property file. The path
    to the property file is actually `uk/co/xenonique/digital/JSFVMessages.properties`,
    which you find in the project resources `ch04/jsf-crud-validation/src/main/resources`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件定义了应用程序的 Faces 资源，在这里我们可以配置一个引用属性文件的消息包。属性文件的路径实际上是 `uk/co/xenonique/digital/JSFVMessages.properties`，您可以在项目资源
    `ch04/jsf-crud-validation/src/main/resources` 中找到。
- en: 'Secondly, we supply our own message-bundle file. The contents of this property
    file `JSFVMessages.properties` are simply the following property definitions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们提供自己的消息包文件。此属性文件 `JSFVMessages.properties` 的内容仅仅是以下属性定义：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we have overridden the property `RegexValidator.NOT_MATCHED`
    to provide a new message. The original definitions are found in the JAR file in
    the application server or bundle as a third party JAR in your servlet container.
    The definitions can be found in the package of the JAR (`jsf-api-2.2.jar`) `javax/faces/Messages.properties`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已覆盖属性 `RegexValidator.NOT_MATCHED` 以提供新的消息。原始定义位于应用程序服务器或捆绑包中的 JAR 文件中，作为您的
    servlet 容器中的第三方 JAR。这些定义可以在 JAR 包（`jsf-api-2.2.jar`）的 `javax/faces/Messages.properties`
    文件中找到。
- en: 'The original definitions for the regular expression validator look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式验证器的原始定义如下所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can examine this file in the source code at [http://svn.apache.org/repos/asf/myfaces/core/branches/2.0.x/api/src/main/resources/javax/faces/Messages.properties](http://svn.apache.org/repos/asf/myfaces/core/branches/2.0.x/api/src/main/resources/javax/faces/Messages.properties).
    As you can see, they are quite technical and user-unfriendly. Many property definitions
    in the message bundle do accept placeholders for the parameters. The `NOT_MATCHED`
    accepts two parameters: the first parameter `{0}` is the pattern and the second
    parameter `{1}` is the label of the input field.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在源代码中检查此文件，地址为 [http://svn.apache.org/repos/asf/myfaces/core/branches/2.0.x/api/src/main/resources/javax/faces/Messages.properties](http://svn.apache.org/repos/asf/myfaces/core/branches/2.0.x/api/src/main/resources/javax/faces/Messages.properties)。如您所见，它们相当技术性且对用户不友好。消息包中的许多属性定义都接受参数的占位符。`NOT_MATCHED`
    接受两个参数：第一个参数 `{0}` 是模式，第二个参数 `{1}` 是输入字段的标签。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Java EE 7, the placeholders for parameterization in JSF validation are different
    from those in the Bean Validation framework. JSF uses integer indices, whereas
    Bean Validation can use named placeholders.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 7 中，JSF 验证中参数化的占位符与 Bean Validation 框架中的不同。JSF 使用整数索引，而 Bean Validation
    可以使用命名占位符。
- en: 'At the time of writing, there is a bug in the reference implementation of the
    JSF validator, which prevents the developers from using some of the placeholders
    in a message property. We would have enjoyed a property definition like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，JSF 验证器的参考实现中存在一个错误，这阻止了开发人员在使用消息属性中的某些占位符时使用。我们本希望有一个这样的属性定义：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sadly, the current bug in Mojarra prevents us from writing this out as production
    code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，当前 Mojarra 中的错误阻止我们将此代码作为生产代码编写。
- en: There is an alternative strategy to customizing the JSF validation. We can define
    our own validators in order to extend the functionality of the framework.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代策略可以自定义 JSF 验证。我们可以定义自己的验证器来扩展框架的功能。
- en: Custom validation methods
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义验证方法
- en: JSF allows the digital engineer to configure a method in a managed bean controller
    that will be called to validate a field. Adding the attribute validator to the
    HTML render tags accomplishes this strategy, and it is a value expression.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 允许数字工程师在管理器控制器中配置一个方法，该方法将在验证字段时被调用。将属性验证器添加到 HTML 渲染标签中实现了这一策略，并且它是一个值表达式。
- en: 'The following is a way to add a custom validation method to the `emailAddress`
    property of the contact detail form:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将自定义验证方法添加到联系详情表单的 `emailAddress` 属性的方法：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The attribute validator references the method `validateEmailAddress()` in the
    modified `ContactDetailControllerJV` bean. This method looks like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 属性验证器引用修改后的 `ContactDetailControllerJV` 实例中的 `validateEmailAddress()` 方法。此方法如下所示：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding method `validateEmailAddress()`, the incoming parameters are
    the `FacesContext`, the component being validated is of type UIComponent, and
    the pending value to be checked is of type Object. This method is validating two
    constraints: it checks that the length of the field is not too long and that the
    field is an e-mail address. We use the JDK standard library `javax.regex` package
    to fulfill this. To assert the validation errors, if any, we create the `FacesMessage`
    objects and add them to the current `FacesContext` instance.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法 `validateEmailAddress()` 中，传入的参数是 `FacesContext`，正在验证的组件类型为 UIComponent，待检查的待定值类型为
    Object。此方法验证两个约束：检查字段长度不要太长，并且该字段是电子邮件地址。我们使用 JDK 标准库 `javax.regex` 包来完成此操作。为了断言验证错误（如果有），我们创建
    `FacesMessage` 对象并将它们添加到当前的 `FacesContext` 实例中。
- en: Defining custom validators
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义自定义验证器
- en: Writing validators in controllers or a CDI named bean is a helpful strategy.
    However, the disadvantage is that you always need an indirect POJO in your application.
    There is another strategy where JSF allows us to define custom validators, which
    are integrated within the framework. A developer may choose to write a POJO that
    is declared with the annotation `javax.faces.validator.FacesValidator`. The POJO
    must implement the interface `javax.faces.validator.Validator`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器或 CDI 命名 bean 中编写验证器是一种有用的策略。然而，缺点是您始终需要在您的应用程序中有一个间接的 POJO。还有一种策略，JSF 允许我们定义集成在框架内的自定义验证器。开发者可以选择编写一个使用
    `javax.faces.validator.FacesValidator` 注解声明的 POJO。该 POJO 必须实现 `javax.faces.validator.Validator`
    接口。
- en: 'Let''s move our e-mail address checking code into a custom validator. The code
    for `FacesEmailAddressValidator` is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把电子邮件地址检查代码移入一个自定义验证器。`FacesEmailAddressValidator` 的代码如下：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This class is annotated with `@FacesValidator`, and the single argument identifies
    the name of the validator in the page view. The method `validate()` implements
    the design by constraint in the validator interface. JSF passes in the `FacesContext`,
    the associated component with the input value, and the value itself.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此类使用 `@FacesValidator` 注解，单个参数标识页面视图中验证器的名称。`validate()` 方法实现了验证器接口中的设计约束。JSF
    传入 `FacesContext`、与输入值关联的组件以及值本身。
- en: We retrieve the input value as a text string. The regular expression code that
    validates the e-mail address is almost the same as before except for the message
    key. The error key is `{application.emailAddress.pattern}`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输入值作为文本字符串检索。验证电子邮件地址的正则表达式代码几乎与之前相同，只是消息键不同。错误键是 `{application.emailAddress.pattern}`。
- en: 'With our POJO custom validator in place, we can rewrite the HTML on the page
    view to use it. The following is the extract view from `login.xhtml`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 POJO 自定义验证器就绪后，我们可以重写页面视图上的 HTML 以使用它。以下是从 `login.xhtml` 的提取视图：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The only difference is the validator attribute in the `<h:inputText>` element.
    This attribute specifies the custom validator by name as `emailValidator`. As
    we can see, we can combine the custom validator with the default standard validators.
    There is still a `<f:validateRequired>` element.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是 `<h:inputText>` 元素中的验证器属性。此属性通过名称指定自定义验证器为 `emailValidator`。正如我们所见，我们可以将自定义验证器与默认标准验证器结合使用。仍然有一个
    `<f:validateRequired>` 元素。
- en: 'The following screenshot shows the rendered output of `LoginControllerJV`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `LoginControllerJV` 的渲染输出：
- en: '![Defining custom validators](img/image00387.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![定义自定义验证器](img/image00387.jpeg)'
- en: A front-end page view demonstration two-factor security login and validation
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前端页面视图演示两因素安全登录和验证
- en: Validating groups of properties
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证属性组
- en: Now that we have knowledge of the JSF custom validators, we can write a custom
    validator to verify the group Date-of-Birth input fields. We can achieve this
    goal, because the `FacesContext` has been passed. It is possible to look up the
    UI components individually, separate from the context.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 JSF 自定义验证器，我们可以编写一个自定义验证器来验证日期出生输入字段组。我们可以实现这个目标，因为 `FacesContext`
    已经传入。可以单独查找 UI 组件，与上下文分开。
- en: We shall use the JSF technique called binding inside a page view. Binding effectively
    publishes the instance of `javax.faces.component.UIInput` in JSF value and makes
    it available elsewhere in a page. The attribute binding on the HTML rendering
    JSF tags binds a component's reference in the component tree to a scoped variable.
    The following is the relevant JSF code. In particular, pay close attention to
    the JSF hidden input element at the start of the code extract from `jsf-validation/createContact.xhtml`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用页面视图中的JSF绑定技术。绑定有效地在JSF值中发布了`javax.faces.component.UIInput`的实例，并在页面的其他地方使其可用。HTML渲染JSF标签上的属性绑定将组件树中的组件引用绑定到作用域变量。以下是与`jsf-validation/createContact.xhtml`代码提取中JSF隐藏输入元素相关的JSF代码。特别是，请注意代码提取开始处的JSF隐藏输入元素。
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We utilize the hidden field, which is identified as `aggregateDobHidden` with
    a dummy form parameter name `hiddenField1`. It always sends a true value. The
    `<f:attribute>` element appends additional binding information to this UI component.
    We need three attributes with the names `dob_dotm` (day of the month), `dob_moty`
    (month of the year), and `dob_year`. These attributes are value expressions for
    the similarly-named page scope variables `#{dob_dotm}`, `#{dob_moty}`, and `#{dob_year}`
    respectively.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用一个标识为`aggregateDobHidden`的隐藏字段，具有一个虚拟的表单参数名称`hiddenField1`。它始终发送一个true值。`<f:attribute>`元素向这个UI组件附加额外的绑定信息。我们需要三个具有名称`dob_dotm`（月份中的日）、`dob_moty`（年份中的月）和`dob_year`的属性。这些属性是相应命名的页面作用域变量`#{dob_dotm}`、`#{dob_moty}`和`#{dob_year}`的值表达式。
- en: 'We add a binding attribute to each of the JSF selection components. Look at
    the following first field, again:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个JSF选择组件添加一个绑定属性。再次看看以下第一个字段：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The attribute binding associates the component to the view and makes it available
    in the page scope variable defined by the literal String definition `#{dob_dotm}`.
    This is an instance of the `javax.faces.component.UIInput` class, which has a
    `getSubmittedValue()` method to get the submitted value. We repeat adding the
    binding for the other two properties. During a form submission, `hiddenField1`
    has the record of bound values for each of the individual properties. This property
    is different from the individual day, month, and year properties.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定将组件与视图关联，并使其在由字面字符串定义的页面作用域变量`#{dob_dotm}`中可用。这是一个`javax.faces.component.UIInput`类的实例，它有一个`getSubmittedValue()`方法来获取提交的值。我们重复添加其他两个属性的绑定。在表单提交期间，`hiddenField1`记录了每个单独属性的绑定值。这个属性与单独的日、月和年属性不同。
- en: 'This trick with the binding allows us to group properties together for form
    validation. The following source code shows the validation on the server side:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绑定技巧允许我们将属性组合在一起进行表单验证。以下源代码显示了服务器端的验证：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The POJO `FacesDateOfBirthValidator` verifies the three DOB properties. It does
    this using a technique in JSF called binding in the page view, which we will see
    in a minute. Binding allows JSF input properties to be propagated to another named
    scope variable that can be used elsewhere on the page. As for the validator, we
    use an HTML hidden element as a vehicle to retrieve these bounded values as attributes.
    This is the purpose of the code that casts the component to `javax.faces.component.UIInput`
    and then extracts a value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: POJO `FacesDateOfBirthValidator` 验证三个出生日期属性。它使用JSF页面视图中的一个技术，称为绑定，我们将在下一分钟看到。绑定允许JSF输入属性传播到另一个命名作用域变量，可以在页面的其他地方使用。至于验证器，我们使用HTML隐藏元素作为检索这些绑定值的载体。这就是将组件转换为`javax.faces.component.UIInput`并提取值的目的。
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have a helper method, `parsePositiveInteger()` for converting the text value
    to an integer. Before that, we create a list collection to store any error messages.
    We then validate the boundary for the day-of-the month from 1 to 31\. The logic
    is almost identical for the month property.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个辅助方法`parsePositiveInteger()`，用于将文本值转换为整数。在此之前，我们创建一个列表集合来存储任何错误消息。然后我们验证月份的边界从1到31。对于月份属性，逻辑几乎相同。
- en: 'For the year property, we take a different step. Using the JDK Calendar and
    Date classes, we build two Date instances: one represents the current date exactly
    100 years ago and the other represents the current date 18 years ago. We can then
    compare if the user''s entry date falls inside these two birthday limits.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于年份属性，我们采取不同的步骤。使用JDK Calendar和Date类，我们构建两个Date实例：一个代表100年前确切的当前日期，另一个代表18年前的当前日期。然后我们可以比较用户的输入日期是否落在这两个生日限制之间。
- en: If there are any errors at the end of the method `validate()`, then it raises
    a `ValidatorException` exception with the error collections. Note that we elect
    to use the alternative constructor.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`validate()`方法的末尾有任何错误，则它将引发一个带有错误集合的`ValidatorException`异常。请注意，我们选择使用替代构造函数。
- en: 'To complete the validator, the helper method `parsePositiveInteger()` can be
    written as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成验证器，辅助方法`parsePositiveInteger()`可以编写如下：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is a screenshot of the contact detail that demonstrates the group
    validator in use:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个截图，展示了正在使用的群组验证器的联系详细信息：
- en: '![Validating groups of properties](img/image00388.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![验证属性组](img/image00388.jpeg)'
- en: A screenshot of the date of birth validators
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 生日验证器的截图
- en: Converters
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换器
- en: The standard JSF validators allow the digital developer to achieve a lot of
    functionality. There are circumstances when the requirements exceed the default
    behavior. Converters are JSF classes that convert between strings and objects.
    Similar to the way in which annotations define the custom validator, JSF permits
    the registration of custom convertors. A converter is associated with a JSF component.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的JSF验证器允许数字开发者实现很多功能。在某些情况下，需求会超出默认行为。转换器是JSF类，用于在字符串和对象之间进行转换。类似于注解定义自定义验证器的方式，JSF允许注册自定义转换器。转换器与一个JSF组件相关联。
- en: 'The annotation `@java.faces.convert.FacesConverter` denotes that a POJO is
    a custom JSF converter. This type must implement the `javax.faces.convert.Converter`
    interface, which has the following methods:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注解`@java.faces.convert.FacesConverter`表示一个POJO是一个自定义JSF转换器。此类型必须实现`javax.faces.convert.Converter`接口，该接口具有以下方法：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The method `getAsObject()` converts a string representation from the client
    to the target object. The other method `getAsString()` converts the object to
    the string representation, which is rendered in the client browser.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAsObject()`方法将客户端的字符串表示转换为目标对象。另一个方法`getAsString()`将对象转换为字符串表示，该表示在客户端浏览器中渲染。'
- en: 'We shall exemplify the custom JSF converter with one that converts a string
    to the suits of playing cards. We can write this using a simple Java enumeration
    class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个将字符串转换为扑克牌花色的自定义JSF转换器来举例。我们可以使用简单的Java枚举类来编写这个转换器：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the full listing for the custom converter `FrenchSuitConverter`
    class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为自定义转换器`FrenchSuitConverter`类提供的完整列表：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The POJO is the annotated `@FacesConverter`, and the value becomes the identifier
    in the page view.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: POJO是注解了`@FacesConverter`的，其值成为页面视图中的标识符。
- en: JSF invokes the `getAsObject()` method with the text representation, which is
    trimmed and transformed to the uppercase in order to make the comparisons easier.
    At the beginning of the method, there is a possibility that the new value could
    be a blank string. If this is true, then we retrieve the text representation from
    the already submitted value. For this particular converter, the use case of an
    empty value is a possibility, so we add the guard. If there is an issue with the
    process, the method raises an exception, `javax.faces.convert.ConverterException`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: JSF使用文本表示调用`getAsObject()`方法，该文本表示被修剪并转换为大写，以便于比较。在方法开始时，新值可能是空字符串。如果是这样，那么我们从已提交的值中检索文本表示。对于这个特定的转换器，空值的用例是可能的，因此我们添加了保护措施。如果过程中出现任何问题，该方法将引发异常，`javax.faces.convert.ConverterException`。
- en: JSF calls the `getAsString()` method in order to convert the object representation
    to a String. Depending on the object type, the method defends against the different
    types of input. The input value may be just a string, or it may be an instance
    of the `FrenchSuit` enumeration. If the input value is not one of these, the method
    raises `ConverterException`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JSF调用`getAsString()`方法将对象表示转换为字符串。根据对象类型，该方法针对不同类型的输入进行防御。输入值可能只是一个字符串，或者它可能是`FrenchSuit`枚举的一个实例。如果输入值不是这些之一，该方法将引发`ConverterException`。
- en: In the real world, we know that there will always be four suits in a set of
    playing cards, and therefore, we can be fairly confident about the maintainability
    of our enumeration. As a digital developer, you may not have such luxuries, and
    hence, applying the principle of defensive programming in a converter and a validator
    can go a long way to tracking down bugs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们知道一副扑克牌中始终有四种花色，因此我们可以相当有信心地保证枚举的可维护性。作为一个数字开发者，你可能不会有这样的奢侈，因此，在转换器和验证器中应用防御性编程原则可以大大有助于追踪错误。
- en: 'The following is an extract from the page `/jsf-validation/french-suit.xhtml`
    that exercises the custom converter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从页面`/jsf-validation/french-suit.xhtml`中摘录的代码，它练习了自定义转换器：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding view, we are using a dropdown menu `<h:selectOneMenu>` that
    allows the user to select a card suit. The code should be very familiar to you
    by now. The difference lies in the value expressions for each card suit, which
    are all method invocations with a String-literal parameter. The Expression Language
    allows you to call methods with parameters. Therefore, the expression: `#{frenchSuitController.suitEnumValue(''HEARTS'')}`
    translates to a method call on the controller.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的视图中，我们使用了一个下拉菜单`<h:selectOneMenu>`，允许用户选择一张牌的花色。现在代码应该对你来说非常熟悉了。区别在于每个牌的花色的值表达式，它们都是带有字符串字面量参数的方法调用。表达式语言允许你带有参数调用方法。因此，表达式`#{frenchSuitController.suitEnumValue('HEARTS')}`等价于对控制器的一个方法调用。
- en: 'Inside the body content of `<h:selectOneMenu>`, we explicitly reference the
    custom converter by an identifier, and associate it with the UI component through
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<h:selectOneMenu>`的体内容中，我们通过一个标识符显式引用自定义转换器，并通过以下方式将其与UI组件关联：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: JSF then invokes the custom converter in order to translate the individual `FrenchSuit`
    enumeration to a String from the page view. It sounds like a roundabout way to
    show a list of values, but this example demonstrates that the method `getAsString()`
    in `FrenchSuitConverter` is being called. Additionally, it illustrates how to
    reference Java enumeration in a page view and in a controller in a robust manner.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JSF调用自定义转换器，将页面视图中的单个`FrenchSuit`枚举转换为字符串。这听起来像是一种绕弯子展示值列表的方法，但这个例子展示了`FrenchSuitConverter`中的`getAsString()`方法被调用。此外，它还说明了如何在页面视图和控制器中以健壮的方式引用Java枚举。
- en: 'Let''s examine the controller now:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查控制器：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are jumping ahead slightly with this code for `FrenchSuitController`. First,
    let me draw your attention to the method `suitEnumValue()`, which converts a String
    literal to the enumeration type `FrenchSuit`. This is a nice handy trick for obtaining
    enumerations in the page view, because Expression Language does not allow direct
    access to the Java enumerations. It will especially work with enumerations that
    change over time through different project releases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们对`FrenchSuitController`进行了稍微的跳进。首先，让我将你的注意力引到`suitEnumValue()`方法上，它将一个字符串字面量转换为枚举类型`FrenchSuit`。这是一个在页面视图中获取枚举的好用技巧，因为表达式语言不允许直接访问Java枚举。它特别适用于随不同项目版本更新而改变的枚举。
- en: The `doAction()` and `cancel()` methods return the URI with a special query
    parameter `redirect=true`. This is an instruction for JSF to return a bookmarkable
    URL; we shall cover this topic much later in this chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAction()`和`cancel()`方法返回带有特殊查询参数`redirect=true`的URI。这是对JSF返回可书签URL的指令；我们将在本章的后面部分详细讨论这个主题。'
- en: Within `doAction()` we are making use of the Flash scope in JSF for the first
    time. The Flash scope is a temporary context that allows the controllers to pass
    on data to the next navigation view. Remember that the View scope is only valid
    for the current controller that navigates to the same page view. The `@ViewScoped`
    managed beans go out of scope when the `FacesContext` moves to the next page view.
    The methods set a key value association in the `javax.faces.context.Flash` instance.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`doAction()`方法中，我们首次使用了JSF中的Flash作用域。Flash作用域是一个临时上下文，允许控制器将数据传递给下一个导航视图。请记住，视图作用域仅对导航到同一页面视图的当前控制器有效。当`FacesContext`移动到下一个页面视图时，`@ViewScoped`管理Bean将超出作用域。这些方法在`javax.faces.context.Flash`实例中设置键值关联。
- en: 'The final piece of the puzzle demonstrates how we use the Flash scope in a
    page view. This code can be found in the file `/jsf-validation/french-suit-complete.xhtml`.
    The following code is an extract from the same:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图展示了我们如何在页面视图中使用Flash作用域。这段代码可以在文件`/jsf-validation/french-suit-complete.xhtml`中找到。以下代码是同一文件的摘录：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this page view, we use the map expression to retrieve values from the Flash
    scope. The expression `#{flash['suit']}` is the suit that the user selected. The
    reader is also directed to look at the documentation for the default JSF converter
    `javax.faces.convert.EnumConverter`. In the same package, there are other standard
    converters such as `BigDecimalConverter`, `BigIntegerConverter`, `DateTimeConverter`,
    `ByteConverter`, `LongConverter`, and `DoubleConverter`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面视图中，我们使用映射表达式从Flash作用域中检索值。表达式`#{flash['suit']}`是用户所选的牌型。读者还被指引查看默认JSF转换器`javax.faces.convert.EnumConverter`的文档。在同一个包中，还有其他标准转换器，例如`BigDecimalConverter`、`BigIntegerConverter`、`DateTimeConverter`、`ByteConverter`、`LongConverter`和`DoubleConverter`。
- en: 'I will leave you with the screenshot for the form view `french-suit.xhtml`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把`french-suit.xhtml`表单视图的截图留给你：
- en: '![Converters](img/image00389.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![转换器](img/image00389.jpeg)'
- en: A screenshot of the suites of cards with the JSF convertor
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JSF转换器的卡片套件截图
- en: The following is a screenshot showing the end state of `french-suit-complete.xhtml`.
    The mark up shows nice visuals in the CSS jumbotron style from Bootstrap.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个截图，显示了`french-suit-complete.xhtml`的最终状态。标记显示从Bootstrap的CSS jumbotron风格中获得的良好视觉效果。
- en: '![Converters](img/image00390.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![转换器](img/image00390.jpeg)'
- en: The second screen from the house of cards example after form submission and
    validation
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片屋示例提交和验证后的第二屏
- en: We have covered a lot of validation that happens on the server side. Let's now
    move on to AJAX validation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在服务器端发生的许多验证。现在让我们继续讨论AJAX验证。
- en: Validating immediately with AJAX
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AJAX立即验证
- en: '**Asynchronous JavaScript and XML** (**AJAX**) is a group of technologies that
    together solve the restriction to the retrieving of partial updates to a web page
    and that provide a rich interactive user experience. The key to AJAX is the term
    *asynchronous*, which builds on a **World Wide Web Consortium** (**W3C**) standard
    namely, the `XmlHttpRequest` object. It was introduced in the Internet Explorer
    in 2006 and all modern web browsers by now support this object. The asynchronous
    mode allows the browser to make a data transfer request to the server on a separate
    connection; the enterprise backend response responds with a data result, usually
    JSON or XML. These AJAX data transfers tend to be smaller in comparison to reloading
    the entire page each time.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步JavaScript和XML**（**AJAX**）是一组技术，它们共同解决了检索网页部分更新的限制，并提供了一个丰富的交互式用户体验。AJAX的关键是术语*异步*，它基于一个**万维网联盟**（**W3C**）标准，即`XmlHttpRequest`对象。它在2006年的Internet
    Explorer中引入，现在所有现代网络浏览器都支持这个对象。异步模式允许浏览器在单独的连接上向服务器发送数据传输请求；企业后端响应以数据结果响应，通常是JSON或XML。与每次重新加载整个页面相比，这些AJAX数据传输通常要小得多。'
- en: JSF has built-in support for AJAX requests and responses; the developer does
    not have to know the finer details of `XmlHttpRequest` and JavaScript programming
    to get the benefit of an immediate response. The digital developer can start with
    the default JavaScript library for performing AJAX interaction.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: JSF内置了对AJAX请求和响应的支持；开发者不需要了解`XmlHttpRequest`和JavaScript编程的细节，就可以获得即时响应的好处。数字开发者可以从执行AJAX交互的默认JavaScript库开始。
- en: It is very easy to get started with AJAX in JSF with the `<f:ajax>` tag. This
    Core JSF tag registers the AJAX behavior with a UI component, and it is used to
    perform validation on a field. Developers are only required to place the tag inside
    the body content of an HTML JSF tag that represents a component, which requires
    validation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<f:ajax>`标签在JSF中开始AJAX非常简单。这个核心JSF标签将AJAX行为与UI组件注册，并用于对字段进行验证。开发者只需将标签放置在代表需要验证的组件的HTML
    JSF标签的正文内容中即可。
- en: 'The following code shows how to use this tag with the contact details application:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何在与联系详情应用程序一起使用此标签：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `tag` attribute event establishes when the framework would invoke the AJAX
    validation. The blur value denotes that it occurs when the user moves from this
    component field to the next input field. So when the user presses the *Tab* key
    on a desktop computer or navigates the UI on a phone or a tablet, validation occurs
    immediately, because JavaScript fires an AJAX request to the server. The second
    attribute, render, informs the framework about the specific UI component to render
    the error message to, if any. JSF receives an AJAX response, and if there is an
    error, it knows the HTML component ID to update with the validation message.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag` 属性的事件确定框架何时调用 AJAX 验证。blur 值表示当用户从该组件字段移动到下一个输入字段时发生。因此，当用户在台式计算机上按下
    *Tab* 键或在手机或平板电脑上导航 UI 时，验证会立即发生，因为 JavaScript 会向服务器发送 AJAX 请求。第二个属性，render，通知框架如果有的话，将错误消息渲染到特定的
    UI 组件中。JSF 接收到 AJAX 响应，如果有错误，它知道要更新验证消息的 HTML 组件 ID。'
- en: 'Let''s look at the project `ch04/jsf-crud-ajax-validation`, which is the full
    extract of the page view `jsf-validation/createContactDetail.xhtml`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看项目 `ch04/jsf-crud-ajax-validation`，这是页面视图 `jsf-validation/createContactDetail.xhtml`
    的完整提取：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This page view exemplifies that adding the AJAX validation to a page is extremely
    easy in JSF. The `<f:ajax>` Core JSF tag is embedded in the corresponding HTML
    JSF tag, as you can see for the first and last name fields. The other difference
    between the non-AJAX and AJAX page for contact details is the addition of the
    identifiers such as `firstNameError` and `lastNameError` to the `<h:message>`
    tag. We need to add the HTML identifier elements for allowing JavaScript to look
    up the HTML element by ID from the browser's **Document Object Model** (**DOM**).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面视图表明在 JSF 中向页面添加 AJAX 验证非常简单。`<f:ajax>` 核心JSF标签嵌入到相应的 HTML JSF 标签中，如您在姓名和姓氏字段中看到的那样。非
    AJAX 和 AJAX 页面之间的另一个区别是为 `<h:message>` 标签添加了标识符，例如 `firstNameError` 和 `lastNameError`。我们需要添加
    HTML 标识符元素，以便 JavaScript 可以从浏览器中的 **文档对象模型** (**DOM**) 通过 ID 查找 HTML 元素。
- en: The page has an AJAX validation added to all the properties except for the middle
    name and the newsletter HTML checkbox field. AJAX validation also works with custom
    validators and converters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 页面除了中间名和新闻通讯 HTML 复选框字段外，所有属性都添加了 AJAX 验证。AJAX 验证也适用于自定义验证器和转换器。
- en: 'The following screenshot illustrates the single property AJAX validation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了单属性 AJAX 验证的示例：
- en: '![Validating immediately with AJAX](img/image00391.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![使用 AJAX 立即验证](img/image00391.jpeg)'
- en: A screenshot demonstrating single validations for each input fields
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 展示每个输入字段单独验证的截图
- en: Validating groups of input fields
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证输入字段组
- en: So far we have seen the JSF AJAX validation on single instances of input fields.
    The `<f:ajax>` tag also works with validation on a group of components. We can
    enclose the tag around one or more JSF input fields and then the `<f:ajax>` tag
    becomes the parent of the UI component. This causes JSF to apply the AJAX validation
    to multiple components.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 JSF AJAX 验证在单个输入字段实例上的应用。`<f:ajax>` 标签也可以与组件组的验证一起使用。我们可以将标签包围在一个或多个
    JSF 输入字段周围，然后 `<f:ajax>` 标签成为 UI 组件的父级。这导致 JSF 将 AJAX 验证应用于多个组件。
- en: 'Let''s add the group validation to the Date-of-Birth fields in the contact
    details form with the following page view:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在联系详情表单的出生日期字段中添加以下页面视图的组验证：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, we surround the DOB input fields with an encompassing `<f:ajax>`
    tag. The event attribute is still set to `blur`. The render attribute is set to
    a list of the HTML element IDs for specific validation messages, namely `dobDayError`,
    `dobMonthError`, and `dobYearError`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们用包含的 `<f:ajax>` 标签包围了 DOB 输入字段。事件属性仍然设置为 `blur`。渲染属性设置为特定验证消息的 HTML 元素
    ID 列表，即 `dobDayError`、`dobMonthError` 和 `dobYearError`。
- en: The `aggregationDobHidden` HTML hidden element is kept the same as in the non-AJAX
    example in order to illustrate that the validation does not interfere with the
    custom validation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`aggregationDobHidden` HTML 隐藏元素与非 AJAX 示例中保持一致，以便说明验证不会干扰自定义验证。'
- en: To recap, use the `<f:ajaxTag>`, and embed it inside any JSF component. To validate
    over a group of multiple components, surround the components with `<f:ajaxTag>`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，使用 `<f:ajaxTag>` 并将其嵌入任何 JSF 组件内部。要验证多个组件组，请将组件用 `<f:ajaxTag>` 包围起来。
- en: The following screenshot depicts the multiple component AJAX validation around
    the DOB fields. The month-of-the-year component had the browser's focus last and
    hence, the corresponding validation message depicts the `onblur` DOM JavaScript
    event. Similarly, tabbing across this set of fields produces the error messages
    one by one.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了围绕出生日期字段的多个组件 AJAX 验证。年份组件最后获得了浏览器的焦点，因此相应的验证消息描述了 `onblur` DOM JavaScript
    事件。同样，在一系列字段之间按 Tab 键会逐个显示错误消息。
- en: '![Validating groups of input fields](img/image00392.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![验证输入字段组](img/image00392.jpeg)'
- en: A screenshot of the group validation for date of birth input fields
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是出生日期输入字段的分组验证截图
- en: AJAX custom tag in depth
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AJAX 自定义标签深入探讨
- en: It is useful to understand the attributes that can be applied to this Core JSF
    custom tag. The following table describes the attributes for `<f:ajax>`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 了解可以应用于此 Core JSF 自定义标签的属性很有用。以下表格描述了 `<f:ajax>` 的属性。
- en: '| Attribute | Description |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `delay` | Specifies the delay in milliseconds between sending multiple AJAX
    requests to the server. Requests are queued up by the JSF implementation. Setting
    the value to none disables the feature. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `delay` | 指定在向服务器发送多个 AJAX 请求之间的延迟（以毫秒为单位）。请求由 JSF 实现排队。将值设置为 none 禁用此功能。|'
- en: '| `disabled` | Specifies a Boolean value to indicate the tag status. If set
    to true, then the AJAX behavior is not rendered. The default value is false. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | 指定一个布尔值以指示标签状态。如果设置为 true，则 AJAX 行为不会渲染。默认值是 false。|'
- en: '| `event` | Defines a String enumeration that represents the event type of
    the AJAX action. By default, JSF determines the event name for the component.
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `event` | 定义一个表示 AJAX 动作事件类型的字符串枚举。默认情况下，JSF 确定组件的事件名称。|'
- en: '| `execute` | Enumerates a space-delimited collection of names that represent
    the components that are executed on the server. The value can be a string or a
    value expression. The default value is `@this`, which indicates the parent component
    of the AJAX behavior. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `execute` | 列出代表在服务器上执行的组件的空格分隔名称集合。值可以是字符串或值表达式。默认值是 `@this`，表示 AJAX 行为的父组件。|'
- en: '| `immediate` | States a Boolean value that indicates whether the input value
    is processed early in the JSF lifecycle. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `immediate` | 声明一个布尔值，指示输入值是否在 JSF 生命周期早期处理。|'
- en: '| `listener` | Indicates the name of the listener method that will be called
    during a broadcast event, namely `AjaxBehaviorEvent`. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `listener` | 指示在广播事件期间将被调用的监听器方法的名称，即 `AjaxBehaviorEvent`。|'
- en: '| `onerror` | Specifies the name of a JavaScript function that will accept
    errors. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `onerror` | 指定一个 JavaScript 函数的名称，该函数将接受错误。|'
- en: '| `onevent` | Specifies the name of a JavaScript function that will handle
    the UI events. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `onevent` | 指定一个 JavaScript 函数的名称，该函数将处理 UI 事件。|'
- en: '| `render` | Enumerates a collection of UI components that will be rendered
    on the client when the AJAX behavior completes. This value can be a space-delimited
    collection of component identifiers, or it can be a value expression. The default
    value is `@none`, which means that no components are rendered. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `render` | 列出在 AJAX 行为完成后将在客户端渲染的 UI 组件集合。此值可以是组件标识符的空格分隔集合，也可以是值表达式。默认值是
    `@none`，表示不渲染任何组件。|'
- en: 'From this preceding table, you will notice that the execute and render attributes
    may indicate additional meaningful values. The execute attribute stipulates the
    components to be executed on the server. The render attribute determines the affected
    UI components for when the AJAX behavior completes. The following table lists
    the attribute values:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表中，您会注意到执行和渲染属性可能指示额外的有意义的值。执行属性规定要在服务器上执行的组件。渲染属性确定在 AJAX 行为完成后受影响的 UI
    组件。以下表格列出了属性值：
- en: '| Value | Description |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@all` | Specifies that all the components are executed or rendered in the
    view. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `@all` | 指定在视图中执行或渲染所有组件。|'
- en: '| `@form` | Specifies that only the components that are the children of the
    form are executed or rendered. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `@form` | 指定仅执行或渲染表单的子组件。|'
- en: '| `@none` | Specifies that no components are executed or rendered. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `@none` | 指定不执行或渲染任何组件。|'
- en: '| `@this` | Specifies that only the current component that triggered the AJAX
    request is executed or rendered. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `@this` | 指定仅执行或渲染触发 AJAX 请求的当前组件。|'
- en: '| `List of component identifiers` | Enumerates the identifiers of the UI components
    that are explicitly executed or rendered as an AJAX request. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `组件标识列表` | 列出了显式执行或作为 AJAX 请求渲染的 UI 组件的标识符。|'
- en: '| `Expression language` | Specifies a value expression that ultimately returns
    a collection of Strings, which indicates the UI components that are executed or
    rendered as an AJAX request-response. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `表达式语言` | 指定一个值表达式，该表达式最终返回一个字符串集合，表示执行或作为 AJAX 请求-响应渲染的 UI 组件。|'
- en: A partial JSF lifecycle
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个部分 JSF 生命周期
- en: The JSF lifecycle is, in effect, for all Faces requests and responses including
    those that emanate from the AJAX-enabled components. Behind the scenes, JSF instantiates
    a special object, `javax.faces.context.PartialViewContext` for the AJAX requests
    and responses, and that is entered into the processing lifecycle. This context
    object contains the information that allows JSF to update the component model
    on the server-side. Based on the partial context, JSF decides whether to accomplish
    partial processing of the selected UI component and/or partial rendering of the
    UI components. Partial processing corresponds to the Apply-Requests-Values, Process-Validations,
    and Update-Model-Values phases of the lifecycle. Partial rendering refers to the
    Render-Response phase.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 生命周期实际上适用于所有 Faces 请求和响应，包括来自启用 AJAX 的组件产生的请求和响应。在幕后，JSF 为 AJAX 请求和响应实例化一个特殊对象，`javax.faces.context.PartialViewContext`，并将其加入到处理生命周期中。此上下文对象包含允许
    JSF 在服务器端更新组件模型的信息。基于部分上下文，JSF 决定是否完成所选 UI 组件的部分处理和/或 UI 组件的部分渲染。部分处理对应于生命周期的
    Apply-Requests-Values、Process-Validations 和 Update-Model-Values 阶段。部分渲染指的是 Render-Response
    阶段。
- en: '![A partial JSF lifecycle](img/image00393.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![一个部分 JSF 生命周期](img/image00393.jpeg)'
- en: Partial request – response lifecycle for AJAX submissions
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 部分请求-响应生命周期用于 AJAX 提交
- en: The preceding diagram encapsulates our understanding of the partial context
    for the AJAX request and response in the JSF lifecycle.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表封装了我们对于 JSF 生命周期中 AJAX 请求和响应的部分上下文的理解。
- en: Handling views
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理视图
- en: In this chapter, we've chiefly examined the validation of the users' input with
    JSF. There were some miscellaneous concepts regarding navigation that we glossed
    over. Let's now talk about handling views and navigation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要检查了使用 JSF 验证用户输入。我们简要地提到了一些关于导航的杂项概念。现在让我们来谈谈处理视图和导航。
- en: Invoking controller methods
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用控制器方法
- en: There are several ways to invoke the controller from a page view with parameters.
    For many situations in the digital e-commerce applications, developers need to
    retrieve a particular data record, trigger a server-side action, or save a certain
    state from the client-side at the backend.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从页面视图调用控制器并传递参数。在许多数字电子商务应用的情况中，开发者需要检索特定的数据记录、触发服务器端操作或在后端从客户端保存某种状态。
- en: Parameterized method invocations
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化方法调用
- en: JSF allows the developer to pass parameters to methods in the page view using
    the Expression Language . The first feature given in [Chapter 3](part0035.xhtml#aid-11C3M2
    "Chapter 3. Building JSF Forms"), *Building JSF Forms* is called Method Expression
    Invocation, which was introduced in JSF 2.0.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 允许开发者使用表达式语言将参数传递到页面视图中的方法。在 [第 3 章](part0035.xhtml#aid-11C3M2 "第 3 章。构建
    JSF 表单") 中给出的第一个特性，*构建 JSF 表单* 被称为方法表达式调用，它在 JSF 2.0 中引入。
- en: 'The following is an extract from the page view `/jsf-miscellany/examplar-methods.xhtml`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容是从页面视图 `/jsf-miscellany/examplar-methods.xhtml` 的摘录：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code depicts the `<h:commandButton>` tag with an action value
    expression, which is `#{examplarController.methodThreeArgs('Obiwan','Ben','Kenobi')}`.
    This is a method invocation with three arguments of literal string.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码描述了具有操作值表达式的 `<h:commandButton>` 标签，该表达式是 `#{examplarController.methodThreeArgs('Obiwan','Ben','Kenobi')}`。这是一个带有三个字面字符串参数的方法调用。
- en: 'The arguments can also be references to other JSF scope instances. The following
    is another invocation with only two arguments that show this off:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 参数也可以是其他 JSF 范围实例的引用。以下是一个只有两个参数的另一个调用示例，展示了这一点：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The arguments are dynamically set from the controller bean properties. Let''s
    look at the controller `ExamplarController` now:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是从控制器 bean 属性动态设置的。现在让我们看看控制器 `ExamplarController`：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There are three methods that are called `methodOneArg()`, `methodTwoArgs()`,
    and `methodThreeArgs()`. The names are self-explanatory for the number of arguments
    that can be passed; each one saves an output result in the JSF Flash scope, before
    moving to the next page view, `/jsf-miscellany/examplar-methods-complete.xhtml`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法被调用，分别是`methodOneArg()`、`methodTwoArgs()`和`methodThreeArgs()`。这些名称对于可以传递的参数数量是自解释的；每个方法在移动到下一个页面视图`/jsf-miscellany/examplar-methods-complete.xhtml`之前，都会在JSF
    Flash作用域中保存一个输出结果。
- en: 'The following is the extract of the end state Facelet view, `exemplar-methods-complete.xhtml`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从最终状态Facelet视图中提取的内容，`exemplar-methods-complete.xhtml`：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Passing parameters to the controller
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向控制器传递参数
- en: Before the JSF 2.0 specification was created, it was possible to send parameters
    to a backing bean controller using the `<f:param>` tag inside of the body of a
    `<h:commandLink>`, `<h:commandButton>`, or `<h:link>` tag. Although this technique
    is superseded by the method invocation expressions in JSF 2.0, it is still a useful
    technique to send out-of-bounds communication to the controller.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF 2.0规范创建之前，可以通过在`<h:commandLink>`、`<h:commandButton>`或`<h:link>`标签的体内容中使用`<f:param>`标签将参数发送到后端bean控制器。尽管这种技术在JSF
    2.0中被方法调用表达式所取代，但它仍然是一种向控制器发送超出范围通信的有用技术。
- en: 'The following code shows the recipe, and we embed two `<f:param>` elements
    in a `<h:commandButton>` custom tag:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了配方，我们在`<h:commandButton>`自定义标签中嵌入两个`<f:param>`元素：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The authoring on this page view invokes the controller's no argument method,
    `methodPassingParameters()`. JSF passes two parameters to the target method through
    the Faces request with the key names `callToActionText` and `customerType`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面视图上的编写调用控制器的不带参数方法`methodPassingParameters()`。JSF通过带有键名`callToActionText`和`customerType`的Faces请求将两个参数传递给目标方法。
- en: 'Let''s look at the controller method that handles this invocation:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理此调用的控制器方法：
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Inside the method `methodPassingParameters()`, we retrieve the parameters from
    the `FacesContext` instance by using the nested call `getRequestParameterMap()`.
    It is then straightforward to access the parameters from the map collection of
    type `Map<String,String>`. It is interesting to note that the parameters can only
    be Strings, and that this technique can be combined with method parameters invocations
    in JSF 2.0 and later.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`methodPassingParameters()`方法内部，我们通过嵌套调用`getRequestParameterMap()`从`FacesContext`实例中检索参数。然后，从类型为`Map<String,String>`的映射集合中访问参数变得非常直接。值得注意的是，参数只能是字符串，并且这种技术可以与JSF
    2.0及以后版本中的方法参数调用相结合。
- en: 'The following screenshot displays the page to demonstrate the method invocation
    techniques described in this section:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了页面，以演示本节中描述的方法调用技术：
- en: '![Passing parameters to the controller](img/image00394.jpeg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![向控制器传递参数](img/image00394.jpeg)'
- en: A screenshot of the method invocation JSF example
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用JSF示例的截图
- en: Invoking an action event listener
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用动作事件监听器
- en: The final technique for handling views invokes an action listener in the controller.
    Any instance method that accepts a single argument of `javax.faces.event.ActionEvent`
    can be an action event listener. An action listener is associated with a UI component
    in the page markup. JSF invokes action listeners before invoking the actions,
    so this technique is helpful for hooking in the business logic and setting up
    data for the action call.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 处理视图的最终技术是在控制器中调用动作监听器。任何接受单个`javax.faces.event.ActionEvent`参数的实例方法都可以是动作事件监听器。动作监听器与页面标记中的UI组件相关联。JSF在调用动作之前调用动作监听器，因此这种技术有助于挂钩业务逻辑并为动作调用设置数据。
- en: 'The following is an extract from the method invocation page that enacts this
    technique. We will dispense with the Bootstrap CSS markup in this code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从实现此技术的调用方法页面中提取的内容。在此代码中，我们将省略Bootstrap CSS标记：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `<h:commandButton>` tag has an additional `actionListener` attribute set
    to the expression that references the action listener method, `attributeListener()`.
    The tag also embeds an `<f:attribute>` to define a passed attribute. The action
    attribute references the method `performAction()`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:commandButton>`标签有一个额外的`actionListener`属性，设置为引用动作监听器方法的表达式，即`attributeListener()`。该标签还嵌入了一个`<f:attribute>`来定义传递的属性。动作属性引用`performAction()`方法。'
- en: 'Let''s examine our `ExamplarController` backing bean to see the code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的`ExamplarController`后端bean以查看代码：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: On submission of the command button, JSF invokes the method `attributeListener()`
    first with an `ActionEvent` instance. We can find the component responsible for
    the invocation and retrieve the attributes stored on it. In this case, we retrieve
    the value for the attribute keyed in as `contactName`. This value is stored in
    the controller's instance variable. (We must be careful with this technique if
    the scope of our backing bean is set to a scope other than `@RequestScope` or
    `@ViewScope`, because the instance variable will be shared between multiple requests
    over time!)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交命令按钮后，JSF首先使用一个`ActionEvent`实例调用`attributeListener()`方法。我们可以找到负责调用的组件，并检索其上存储的属性。在这种情况下，我们检索键入为`contactName`的属性值。这个值存储在控制器的实例变量中。（如果我们把后端bean的作用域设置为`@RequestScope`或`@ViewScope`以外的范围，我们必须小心使用这种技术，因为实例变量将在多个请求之间共享！）
- en: After the action listener returns, eventually, JSF invokes the action method
    `performAction()`. The instance variable `contactName` is available and has the
    current value from the page. The method proceeds to the next page view.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 动作监听器返回后，JSF最终会调用`performAction()`动作方法。实例变量`contactName`可用，并具有页面上的当前值。该方法继续到下一页视图。
- en: Redirection pages
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向页面
- en: If you have been following the examples in this chapter, you must have noticed
    that the page views have been suffixed with a query parameter `redirect=true`
    (or `faces-redirect=true`, according to the official JSF specification). This
    is an instruction to JSF for sending an HTTP Response back to the web client to
    be redirected to a URL. Why is this suffix required? It allows the user to bookmark
    page views, because the JSF framework effectively hides the current page view
    from the user by just rendering the output. The main issue is internal page forwarding
    that makes it difficult for the customers using a digital application to remember
    or bookmark their location. If the customer has a deeply nested site of information
    architecture, the ability to provide page redirection is key. The secondary issue
    is that if your web application exercises a flow of process in a linear fashion,
    then the web browser's URL is updated, but always shows the previous page in the
    process.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随本章中的示例，你一定注意到了页面视图后面都附加了一个查询参数`redirect=true`（或根据官方JSF规范为`faces-redirect=true`）。这是对JSF的一个指令，要求它发送HTTP响应回网络客户端以重定向到URL。为什么需要这个后缀？它允许用户将页面视图添加到书签，因为JSF框架通过仅渲染输出实际上有效地隐藏了当前页面视图。主要问题是内部页面转发，这使得使用数字应用程序的客户难以记住或添加书签。如果客户有一个深层嵌套的信息架构网站，提供页面重定向的能力是关键。次要问题是，如果你的网络应用程序以线性方式执行流程，那么网络浏览器的URL会更新，但总是显示流程中的上一页。
- en: Redirection works in controller methods `examplar-methods-complete?redirect=true`
    that cause JSF to send an HTTP Response Redirect to the browser. The web browser
    interprets the redirect to another HTTP GET request for a URL such as `http://localhost:8080/jsf-crud-ajax-validation-1.0-SNAPSHOT/jsf-miscellany/examplar-methods.xhtml`.
    The consequence of the redirection is that there are at least two request-response
    events occurring for each page navigation or action. If you remember, the scope
    of `@ViewScoped` or `@RequestScoped` bean is available only for a short duration.
    By the time JSF processes the HTTP GET from the redirection instruction, the original
    bean has already disappeared. This is the reason why the examples use the Flow
    scope; that scope guarantees that the data from the controller business logic
    survives till the next page view is displayed.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向在控制器方法`examplar-methods-complete?redirect=true`中起作用，这会导致JSF向浏览器发送HTTP响应重定向。网络浏览器将重定向解释为对URL（如`http://localhost:8080/jsf-crud-ajax-validation-1.0-SNAPSHOT/jsf-miscellany/examplar-methods.xhtml`）的另一个HTTP
    GET请求。重定向的结果是，每个页面导航或动作至少发生两个请求-响应事件。如果你还记得，`@ViewScoped`或`@RequestScoped`bean的作用域仅可用很短的时间。当JSF处理重定向指令的HTTP
    GET时，原始bean已经消失。这就是为什么示例使用Flow作用域的原因；该作用域保证了控制器业务逻辑中的数据能够持续到下一个页面视图显示。
- en: 'The other way to specify page redirection is through `faces-config.xml` for
    particular navigation cases. We can define a case as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 指定页面重定向的另一种方式是通过`faces-config.xml`针对特定的导航情况。我们可以定义一个案例如下：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This style of configuration can be useful in setting up third-party JSF packages.
    Of course, it also provides flexibility for library writers, and it does not pollute
    the Java-managed bean redirect strings. I suppose it is a horses-for-courses situation
    and, therefore, depends on the purpose of the project.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置风格在设置第三方JSF包时可能很有用。当然，它也为库编写者提供了灵活性，并且不会污染Java管理的bean重定向字符串。我想这是一个因材施教的情况，因此取决于项目的目的。
- en: 'Finally, the developer can set redirection directly to page views through submission
    links and buttons. The following code shows this technique:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开发者可以通过提交链接和按钮直接将重定向设置到页面视图。以下代码展示了这种技术：
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Debugging the JSF content
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试JSF内容
- en: Maybe I should have introduced this feature of JSF earlier, because learning
    to develop with JSF can be puzzling to beginners. It is possible to get debuggable
    output in a JSF application if you include the `<ui:debug/>` custom tag element
    inside one of the template views. Actually, the Facelet view renderer output of
    the framework is responsible for this feature.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我应该早点介绍JSF的这个特性，因为对于初学者来说，学习使用JSF进行开发可能会感到困惑。如果你在模板视图之一中包含`<ui:debug/>`自定义标签元素，就可以在JSF应用程序中获得可调试的输出。实际上，框架的Facelet视图渲染器负责这个特性。
- en: By embedding a single `<ui:debug>` inside a `<ui:insert>` tag causes JSF to
    add a special UI component to the UI hierarchy tree. This debug component captures
    the Facelet view information and current state of the UI hierarchy, including
    any scoped variables in the application. Information is captured at the time of
    rendering . If the user presses the keys *Ctrl* + *Shift* + *D*, JSF opens a separate
    browser window showing the debuggable information, which is really useful in tough
    situations. The main template of the application is the best place to add the
    `<ui:debug>` tag.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<ui:insert>`标签内嵌入单个`<ui:debug>`会导致JSF向UI层次结构树添加一个特殊的UI组件。这个调试组件捕获Facelet视图信息和UI层次结构的状态，包括应用程序中的任何作用域变量。信息是在渲染时捕获的。如果用户按下*Ctrl*
    + *Shift* + *D*键，JSF将打开一个单独的浏览器窗口，显示可调试的信息，这在困难情况下非常有用。应用程序的主要模板是添加`<ui:debug>`标签的最佳位置。
- en: 'The `<ui:debug>` tag accepts the following attributes:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ui:debug>`标签接受以下属性：'
- en: '| Name | Type | Description |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `hotkey` | `String` | Defines the single character of the hotkey that causes
    the debuggable window to open. The default is `d`. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `hotkey` | `String` | 定义了触发可调试窗口打开的热键的单个字符。默认为`d`。|'
- en: '| `rendered` | `ValueExpression` | Specifies if the debug component is rendered
    or not. It must be a value expression or a String literal that evaluates to `true`
    or `false`. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `rendered` | `ValueExpression` | 指定调试组件是否渲染。它必须是一个值表达式或一个评估为`true`或`false`的字符串字面量。|'
- en: 'The following screenshot shows the exemplar method invocations:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了示例方法调用：
- en: '![Debugging the JSF content](img/image00395.jpeg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![调试JSF内容](img/image00395.jpeg)'
- en: Clicking on the plus (**+**) symbols expands the content so that the developers
    see more information dynamically.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 点击加号（**+**）符号可以展开内容，以便开发者动态地看到更多信息。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter focused on the different forms of JSF validation, because it is
    extremely important for the user to know if the data has been entered correctly.
    We examined the two forms of validation methods: client side and server side.
    We looked at the `FacesMessage` instances and learnt how to create them. Afterwards,
    we proceeded to cover validation from the server side, particularly, the Bean
    Validation framework in Java EE 7\. We then took an extended developer journey
    into JSF validation. We learnt how to create custom validators and converters.
    We also learnt how to perform immediate mode validation with AJAX and understood
    the partial context life cycle. Finally, we spent a good deal of time on handling
    views and passing information from the page view to the controller. Along the
    way, we addressed the JSF flow scope and page redirection.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了JSF验证的不同形式，因为对于用户来说，知道数据是否正确输入非常重要。我们研究了两种验证方法：客户端和服务器端。我们查看了`FacesMessage`实例，并学习了如何创建它们。之后，我们继续介绍从服务器端进行的验证，特别是Java
    EE 7中的Bean Validation框架。然后，我们进行了JSF验证的深入开发者之旅。我们学习了如何创建自定义验证器和转换器。我们还学习了如何使用AJAX进行即时模式验证，并理解了部分上下文生命周期。最后，我们花了大量时间处理视图，并将信息从页面视图传递到控制器。在这个过程中，我们解决了JSF流程作用域和页面重定向的问题。
- en: In the next chapter, we will turn our attention to conversational scopes and
    start putting the useful process flow applications together. At this point, we
    add finesse and sophistication to our burgeoning digital JSF applications. I will
    you see there.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向对话作用域，并开始组装有用的流程应用程序。在这个时候，我们给我们的新兴数字 JSF 应用程序增添优雅和复杂性。我会让你看到这一点。
- en: Exercises
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What is the fundamental difference between the `<h:outputLink>` and `<h:commandButton>`
    elements? How do you style the control elements appropriately with a CSS framework
    such as Bootstrap?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<h:outputLink>` 和 `<h:commandButton>` 元素之间的基本区别是什么？你如何使用像 Bootstrap 这样的 CSS
    框架来适当地设置控件样式？'
- en: In the previous chapter, there were exercises around developing a web application
    for registering new people to a local hobbyist book-reading club. Did you happen
    to write content in separate pages with no reuse?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一章中，有一些围绕为注册新成员到当地爱好读书俱乐部开发网络应用程序的练习。你是否偶然在单独的页面上编写了内容而没有重用？
- en: Apply the UI template compositing to your hobby book club project. Call this
    version two and save the first version for your reference. Make use of the Template
    Composition tags `<ui:define>`, `<ui:composition>`, and `<ui:insert>` only at
    this stage.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 UI 模板组合应用于你的爱好读书俱乐部项目。将其版本称为二，并将第一个版本保存为参考。在这个阶段，仅使用 `<ui:define>`、`<ui:composition>`
    和 `<ui:insert>` 模板组合标签。
- en: Add a `<ui:debug>` custom tag to master the template page. What does this special
    tag do for the developer?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向模板页面添加 `<ui:debug>` 自定义标签以掌握它。这个特殊标签对开发者有什么作用？
- en: An annoyed business stakeholder arrives at your office and tells you about an
    issue that they are having with spoof data. It seems that some naughty people
    on the Internet are faking data entry and this is causing more burden for the
    caseworkers. As a consultant with JSF, explain how you can protect the data in
    the backend database using validation. Would only a server-side validation work?
    Would only client-side validation work?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一位烦恼的业务利益相关者来到你的办公室，告诉你他们与伪造数据有关的问题。似乎有一些不怀好意的人在互联网上伪造数据输入，这给案件工作人员带来了更多负担。作为一名
    JSF 咨询师，解释你是如何通过验证来保护后端数据库中的数据的。只有服务器端验证有效吗？只有客户端验证有效吗？
- en: With reference to the previous Hobby Book Club application, let's now add validation
    to the JSF form elements that you created.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考先前的爱好读书俱乐部应用程序，现在让我们向你创建的 JSF 表单元素添加验证。
- en: Add Bean Validation to the registrant class (`Registrant.java`—you may have
    named this class differently in your own project). Will your users be satisfied
    with the validation output?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Bean Validation 添加到注册者类（`Registrant.java`——你可能在你的项目中将此类命名为不同的名称）。你的用户会对验证输出满意吗？
- en: What happens when you add only the server-side validation to an application?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你只向应用程序添加服务器端验证时，会发生什么？
- en: What are the differences between Bean Validation and JSF validation?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bean Validation 和 JSF 验证之间有什么区别？
- en: What are the similarities between Bean Validation and JSF validation?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bean Validation 和 JSF 验证之间有哪些相似之处？
- en: How appropriate are the error messages for Bean Validation and JSF validation
    according to the users ?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户，Bean Validation 和 JSF 验证的错误消息有多合适？
- en: Start with the creation page. Validate against the registrant's name. You can
    validate with `<f:validateRequired>` and `<f:validateLength>` directly on the
    page view. Add appropriate `<h:messages>` to the page view.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建页面开始。对注册者的姓名进行验证。你可以在页面视图中直接使用 `<f:validateRequired>` 和 `<f:validateLength>`
    进行验证。向页面视图添加适当的 `<h:messages>`。
- en: Some registrants use social networks like Facebook, Twitter, and Instagram.
    Add some properties to the Registrant POJO. Add a URL validator to verify that
    the social network properties are correct. Use the regular expression validator
    to verify the Twitter account syntax or, perhaps, write your own custom validator.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些注册者使用 Facebook、Twitter 和 Instagram 等社交网络。向注册者 POJO 添加一些属性。添加一个 URL 验证器来验证社交网络属性是否正确。使用正则表达式验证器来验证
    Twitter 账户语法，或者也许你可以编写自己的自定义验证器。
- en: Download the book's source code example and run the sample code for Chapter
    4\. Study how validation occurs from the server side.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载本书的源代码示例并运行第 4 章的示例代码。研究从服务器端发生验证的方式。
- en: Given that you have developed your project with server-side validation, you
    must take the Hobby Book Club web application up a notch. Add client-side validation
    with AJAX for control elements. You will need to add appropriate `<f:ajax>` elements
    to your JSF form control elements. Don't forget that each control requires an
    area to render a specific error message; so, you will not add a corresponding
    `<h:message>` element on the page in close proximity.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你使用服务器端验证开发了你的项目，你必须将 Hobby Book Club 网络应用程序提升到一个新的水平。为控制元素添加带有 AJAX 的客户端验证。你需要在你的
    JSF 表单控制元素中添加适当的 `<f:ajax>` 元素。别忘了每个控制都需要一个区域来渲染特定的错误消息；因此，你不会在页面上添加一个相应的 `<h:message>`
    元素，并且与控制元素紧密相邻。
- en: Download the Chrome Developer Web Tools or similar web page inspection development
    tools, and inspect the HTML content of the JSF application. What do you observe
    and notice about the naming of the various HTML elements, especially the forms?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Chrome 开发者网络工具或类似的网页检查开发工具，并检查 JSF 应用的 HTML 内容。你观察和注意到各种 HTML 元素的命名情况如何，尤其是表单的命名？
- en: Take a breather and add modern CSS styles to the Hobby Book Club application.
    Ask a colleague or friend to evaluate the user experience of your application
    and gather feedback. Act on the feedback; change the content around.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 休息一下，并为 Hobby Book Club 应用程序添加现代 CSS 样式。请同事或朋友评估你应用程序的用户体验并收集反馈。根据反馈采取行动；更改内容。
- en: Add a cancel operation to your CRUD application; what do you need to ensure
    that JSF does not validate the input?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 CRUD 应用程序中添加取消操作；你需要确保 JSF 不验证输入？
