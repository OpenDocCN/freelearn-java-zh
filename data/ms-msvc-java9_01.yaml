- en: A Solution Approach
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案方法
- en: As a prerequisite, you should have a basic understanding of microservices and
    software architecture style. Having a basic understanding could help you to understand
    the concepts and this book thoroughly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为先决条件，你应该对微服务和软件架构风格有一个基本的理解。具备基本理解可以帮助你彻底理解概念和本书。
- en: After reading this book, you could implement microservices for on-premise or
    cloud production deployment and learn the complete life-cycle from design, development,
    testing, and deployment with continuous integration and deployment. This book
    is specifically written for practical use and to ignite your mind as a solution
    architect. Your learning will help you to develop and ship products for any type
    of premise, including SaaS, PaaS, and so on. We'll primarily use the Java and
    Java-based framework tools such as Spring Boot and Jetty, and we will use Docker
    as a container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本书后，你可以实现用于本地或云生产部署的微服务，并学习从设计、开发、测试到部署的完整生命周期，以及持续集成和部署。本书专为实际应用和激发您作为解决方案架构师的思维而编写。你的学习将帮助你开发和交付任何类型的场所的产品，包括SaaS、PaaS等。我们将主要使用Java和基于Java的框架工具，如Spring
    Boot和Jetty，并且我们将使用Docker作为容器。
- en: In this chapter, you will learn the eternal existence of microservices, and
    how it has evolved. It highlights the large problems that on-premise and cloud-based
    products face and how microservices deals with it. It also explains the common
    problems encountered during the development of SaaS, enterprise, or large applications
    and their solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习微服务的永恒存在及其演变。它突出了本地和基于云的产品面临的重大问题以及微服务如何解决这些问题。它还解释了在开发SaaS、企业或大型应用程序过程中遇到的常见问题及其解决方案。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习以下主题：
- en: Microservices and a brief background
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务及其简要背景
- en: Monolithic architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构
- en: Limitation of monolithic architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构的限制
- en: The benefits and flexibility that microservices offer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务提供的优势和灵活性
- en: Microservices deployment on containers such as Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker等容器上部署微服务
- en: Evolution of microservices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的演变
- en: 'Martin Fowler explains:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒解释道：
- en: The term microservice was discussed at a workshop of software architects near
    Venice in May 2011 to describe what the participants saw as a common architectural
    style that many of them had been recently exploring. In May 2012, the same group
    decided on µServices as the most appropriate name.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的术语是在2011年5月靠近威尼斯的一次软件架构师研讨会上讨论的，以描述与会者认为的一种共同的架构风格，他们中很多人最近都在探索这种风格。2012年5月，同一群人决定将“微服务”（µServices）作为最合适的名称。
- en: Let's get some background on the way it has evolved over the years. Enterprise
    architecture evolved more from historic mainframe computing, through client-server
    architecture (two-tier to n-tier) to **Service-Oriented Architecture** (**SOA**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下它是如何在过去几年中发展的。企业架构更多地是从历史的大型机计算，通过客户机-服务器架构（两层到多层）发展到**服务导向架构**（**SOA**）。
- en: The transformation from SOA to microservices is not a standard defined by an
    industry organization, but a practical approach practiced by many organizations.
    SOA eventually evolved to become microservices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务导向架构（SOA）到微服务的转变并非由某个行业协会定义的标准，而是许多组织实践的实用方法。SOA最终演变为微服务。
- en: 'Adrian Cockcroft, a former Netflix Architect, describes it as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前Netflix架构师阿德里安·科克洛夫特（Adrian Cockcroft）将其描述为：
- en: Fine grain SOA. So microservice is SOA with emphasis on small ephemeral components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 细粒度SOA。因此，微服务是强调小型短暂组件的SOA。
- en: 'Similarly, the following quote from Mike Gancarz, a member that designed the
    X Windows system, which defines one of the paramount precepts of Unix philosophy,
    suits the microservice paradigm as well:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，来自设计X窗口系统的成员迈克·甘卡兹（Mike Gancarz）的以下引言，定义了Unix哲学的一个基本原则，同样适用于微服务范式：
- en: Small is beautiful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 小即是美。
- en: Microservices shares many common characteristics with SOA, such as the focus
    on services and how one service decouples from another. SOA evolved around monolithic
    application integration by exposing API that was mostly **Simple Object Access
    Protocol** (**SOAP**) based. Therefore, middleware such as **Enterprise Service
    Bus** (**ESB**) is very important for SOA. Microservices are less complex, and
    even though they may use the message bus it is only used for message transport
    and it does not contain any logic. It is simply based on smart endpoints.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务与 SOA 有很多共同的特征，比如对服务和如何让一个服务与另一个服务解耦的关注。SOA 是围绕单体应用集成而演变的，通过暴露大部分基于**简单对象访问协议**
    (**SOAP**) 的 API。因此，中间件如**企业服务总线** (**ESB**) 对 SOA 非常重要。微服务更简单，尽管它们可能使用消息总线，但只是用于消息传输，其中不包含任何逻辑。它仅仅基于智能端点。
- en: 'Tony Pujals defined microservices beautifully:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Tony Pujals 对微服务做了很好的定义：
- en: In my mental model, I think of self-contained (as in containers) lightweight
    processes communicating over HTTP, created and deployed with relatively small
    effort and ceremony, providing narrowly-focused APIs to their consumers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的心智模型中，我想象的是自我包含（如同容器）的轻量级进程，通过 HTTP 进行通信，创建和部署相对简单，为消费者提供狭窄焦点的 API。
- en: Though Tony only talks about the HTTP, event-driven microservices may use the
    different protocol for communication. You can make use of Kafka for implementing
    the event-driven microservices. Kafka uses the wire protocol, a binary protocol
    over TCP.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Tony 只提到了 HTTP，但事件驱动的微服务可能使用不同的协议进行通信。你可以使用 Kafka 来实现事件驱动的微服务。Kafka 使用的是线协议，一种基于
    TCP 的二进制协议。
- en: Monolithic architecture overview
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构概述
- en: Microservices is not something new, it has been around for many years. For example,
    Stubby, a general purpose infrastructure based on **Remote** **Procedure** **Call**
    (**RPC**) was used in Google data centers in the early 2000s to connect a number
    of service with and across data centers. Its recent rise is owing to its popularity
    and visibility. Before microservices became popular, there was primarily monolithic
    architecture that was being used for developing on-premise and cloud applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Microservices 并不是什么新鲜事物，它已经存在了很多年。例如，Stubby 是一个基于**远程** **过程** **调用** (**RPC**)
    的通用基础设施，早在2000年代初，它就被用于连接 Google 数据中心内和跨数据中心的多个服务。它近期之所以受到关注，是因为它的流行度和可见度。在微服务变得流行之前，开发本地和云应用程序主要采用的是单体架构。
- en: Monolithic architecture allows the development of different components such
    as presentation, application logic, business logic, and **Data Access Objects**
    (**DAO**), and then you either bundle them together in **Enterprise Archive**
    (**EAR**) or **Web Archive** (**WAR**), or store them in a single directory hierarchy
    (for example, Rails, NodeJS, and so on).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构允许开发不同的组件，如表示层、应用逻辑、业务逻辑和**数据访问对象** (**DAO**)，然后你可以将它们捆绑在**企业存档** (**EAR**)
    或**网络存档** (**WAR**) 中，或者将它们存储在单个目录层次结构中（例如，Rails、NodeJS 等）。
- en: Many famous applications such as Netflix have been developed using microservices
    architecture. Moreover, eBay, Amazon, and Groupon have evolved from monolithic
    architecture to a microservices architecture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多著名的应用程序，如 Netflix，都是使用微服务架构开发的。此外，eBay、Amazon 和 Groupon 也从单体架构演变为微服务架构。
- en: Now that you have had an insight into the background and history of microservices,
    let's discuss the limitations of a traditional approach, namely monolithic application
    development, and compare how microservices would address them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经对微服务的背景和历史有了了解，那么让我们讨论一下传统方法，即单体应用开发的局限性，并比较微服务如何解决这些问题。
- en: Limitation of monolithic architecture versus its solution with microservices
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构的限制及其微服务的解决方案
- en: As we know, change is eternal. Humans always look for better solutions. This
    is how microservices became what it is today and it may evolve further in the
    future. Today, organizations are using Agile methodologies to develop applications--it
    is a fast-paced development environment and it is also on a much larger scale
    after the invention of cloud and distributed technologies. Many argue that monolithic
    architecture could also serve a similar purpose and be aligned with Agile methodologies,
    but microservices still provides a better solution to many aspects of production-ready
    applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，变化是永恒的。人类总是寻求更好的解决方案。这就是微服务成为今天这个样子，并可能在未来进一步发展的原因。今天，组织正在使用敏捷方法开发应用程序——这是一个快速的开发环境，并且在云计算和分布式技术发明之后规模也更大了。许多人认为单体架构也可以达到类似的目的，并且与敏捷方法论保持一致，但微服务仍在许多方面为生产就绪应用程序提供了更好的解决方案。
- en: To understand the design differences between monolithic and microservices, let's
    take an example of a restaurant table-booking application. This application may
    have many services such as customers, bookings, analytics and so on, as well as
    regular components such as presentation and database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解单体和微服务之间的设计差异，让我们以一个餐厅预订应用程序为例。这个应用程序可能有很多服务，如客户、预订、分析等，以及常规组件，如展示和数据库。
- en: We'll explore three different designs here; traditional monolithic design, monolithic
    design with services, and microservices design.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨三种不同的设计：传统的单体设计、带服务的单体设计以及微服务设计。
- en: Traditional monolithic design
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的单体设计
- en: 'The following diagram explains the traditional monolithic application design.
    This design was widely used before SOA became popular:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表解释了传统的单体应用程序设计。这种设计在SOA变得流行之前被广泛使用：
- en: '![](img/8fb71694-894b-43f1-babd-d1bebad0c078.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fb71694-894b-43f1-babd-d1bebad0c078.png)'
- en: Traditional monolithic application design
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的单体应用程序设计
- en: In traditional monolithic design, everything is bundled in the same archive
    such as **Presentation** code, **Application Logic** and **Business Logic** code,
    and **DAO** and related code that interacts with the database files or another
    source.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的单体设计中，一切都被打包在同一个档案中，如**展示**代码、**应用逻辑**和**业务逻辑**代码，以及**DAO**和相关代码，这些代码与数据库文件或其他来源交互。
- en: Monolithic design with services
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带服务的单体设计
- en: 'After SOA, applications started being developed based on services, where each
    component provides the services to other components or external entities. The
    following diagram depicts the monolithic application with different services;
    here services are being used with a **Presentation** component. All services,
    the **Presentation** component, or any other components are bundled together:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在SOA之后，基于服务的应用程序开始被开发，每个组件为其他组件或外部实体提供服务。下面的图表展示了带有不同服务的单体应用程序；在这里，服务与**展示**组件一起使用。所有服务、**展示**组件或任何其他组件都被捆绑在一起：
- en: '![](img/56e1f42d-382d-47e8-82da-b8014ad4e11a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56e1f42d-382d-47e8-82da-b8014ad4e11a.png)'
- en: Services design
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务设计
- en: The following third design depicts the microservices. Here, each component represents
    autonomy. Each component could be developed, built, tested, and deployed independently.
    Here, even the application **User Interface** (**UI**) component could also be
    a client and consume the microservices. For the purpose of our example, the layer
    designed is used within µService.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的第三种设计展示了微服务。在这里，每个组件都代表自主性。每个组件可以独立开发、构建、测试和部署。在这里，即使是应用程序**用户界面**（**UI**）组件也可以是一个客户端，并消费微服务。为了我们的示例，设计层在µService内部使用。
- en: 'The **API Gateway** provides the interface where different clients can access
    the individual services and solve the following problems:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**API网关**提供接口，不同的客户端可以访问单个服务，解决以下问题：'
- en: What do you do when you want to send different responses to different clients
    for the same service? For example, a booking service could send different responses
    to a mobile client (minimal information) and a desktop client (detailed information)
    providing different details, and something different again to a third-party client.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要为同一服务发送不同响应给不同客户端时，你会怎么做？例如，一个预订服务可以为移动客户端（最小信息）和桌面客户端（详细信息）发送不同的响应，提供不同的详细信息，对第三个客户端再次发送不同的信息。
- en: 'A response may require fetching information from two or more services:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个响应可能需要从两个或更多服务中获取信息：
- en: '![](img/2111f31f-e230-4141-bd2d-f52e304ca197.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2111f31f-e230-4141-bd2d-f52e304ca197.png)'
- en: After observing all the sample design diagrams, which are very high-level designs,
    you might find out that in monolithic design, the components are bundled together
    and tightly coupled.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察了所有的高级设计样本图后，你可能会发现，在单体设计中，组件是捆绑在一起的，并且耦合度很高。
- en: All the services are part of the same bundle. Similarly, in the second design
    figure, you can see a variant of the first figure where all services could have
    their own layers and form different APIs, but, as shown in the figure, these are
    also all bundled together.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务都是同一个捆绑包的一部分。同样，在第二个设计图中，你可以看到第一个图的一个变体，其中所有服务可能都有自己的层并形成不同的API，但是，如图所示，这些也都是捆绑在一起的。
- en: Conversely, in microservices, design components are not bundled together and
    have loose coupling. Each service has its own layers and **DB**, and is bundled
    in a separate archive. All these deployed services provide their specific APIs
    such as Customers, Bookings, or Customer. These APIs are ready to consume. Even
    the UI is also deployed separately and designed using µService. For this reason,
    it provides various advantages over its monolithic counterpart. I would still
    remind you that there are some exceptional cases where monolithic application
    development is highly successful, such as Etsy, and peer-to-peer e-commerce web
    applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在微服务中，设计组件是不捆绑在一起的，并且耦合度很低。每个服务都有自己的层和**DB**，并且打包在单独的归档文件中。所有这些部署的服务提供它们特定的API，如客户（Customers）、预订（Bookings）或客户（Customer）。这些API是即取即用的。即便是UI也是单独部署的，并且使用微服务进行设计。因此，它比单体应用有众多优势。我还是要提醒你，在某些特殊情况下，单体应用开发是非常成功的，如Etsy和点对点电子商务网站。
- en: Now let us discuss the limitations you'd face while working with Monolithic
    applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论在使用单体应用时您可能会遇到的限制。
- en: One dimension scalability
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一维度的可扩展性
- en: Monolithic applications that are large when scaled, scale everything as all
    the components are bundled together. For example, in the case of a restaurant
    table reservation application, even if you would like to scale the table-booking
    service, it would scale the whole application; it cannot scale the table-booking
    service separately. It does not utilize the resources optimally.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当单体应用规模变大时，它会捆绑在一起扩展所有组件。例如，在餐厅预订桌位的应用中，即使你想要扩展桌位预订服务，它也会扩展整个应用；它不能单独扩展桌位预订服务。它没有充分利用资源。
- en: In addition, this scaling is one-dimensional. Running more copies of the application
    provides the scale with increasing transaction volume. An operation team could
    adjust the number of application copies that were using a load-balancer based
    on the load in a server farm or a cloud. Each of these copies would access the
    same data source, therefore increasing the memory consumption, and the resulting
    I/O operations make caching less effective.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种扩展是单一维度的。随着交易量的增加，运行更多应用副本提供了扩展。运维团队可以根据服务器农场或云中的负载，通过负载均衡器调整应用副本的数量。这些副本都会访问相同的数据源，因此增加了内存消耗，而产生的I/O操作使缓存效果大打折扣。
- en: Microservices gives the flexibility to scale only those services where scale
    is required and it allows optimal utilization of the resources. As we mentioned
    previously, when it is needed, you can scale just the table-booking service without
    affecting any of the other components. It also allows two-dimensional scaling;
    here we can not only increase the transaction volume, but also the data volume
    using caching (Platform scale).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务赋予了灵活性，只扩展那些需要扩展的服务，并允许资源的最优利用。如我们之前提到的，当需要时，你可以只扩展桌位预订服务，而不影响其他任何组件。它还允许二维扩展；在这里，我们不仅可以增加交易量，还可以通过缓存增加数据量（平台扩展）。
- en: A development team can then focus on the delivery and shipping of new features,
    instead of worrying about the scaling issues (Product scale).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队可以专注于新特性的交付和 shipping，而不是担心扩展问题（产品扩展）。
- en: Microservices could help you scale platform, people, and product dimensions
    as we have seen previously. People scaling here refers to an increase or decrease
    in team size depending on microservices' specific development and focus needs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，微服务可以帮助你扩展平台、人力和产品维度。这里的人力扩展指的是根据微服务的特定开发和关注需求，增加或减少团队规模。
- en: Microservice development using RESTful web-service development makes it scalable
    in the sense that the server-end of REST is stateless; this means that there is
    not much communication between servers, which makes it horizontally scalable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RESTful Web服务开发的微服务架构使系统在服务器端是无状态的；这意味着服务器之间的通信不多，这使得系统可以水平扩展。
- en: Release rollback in case of failure
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在失败的情况下进行发布回滚
- en: Since monolithic applications are either bundled in the same archive or contained
    in a single directory, they prevent the deployment of code modularity. For example,
    many of you may have experienced the pain of delaying rolling out the whole release
    due to the failure of one feature.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单体应用程序要么打包在同一个归档文件中，要么包含在单个目录中，因此它们阻止了代码模块化的部署。例如，许多人都可能有过因一个功能失败而推迟整个发布的痛苦经历。
- en: To resolve these situations, microservices gives us the flexibility to rollback
    only those features that have failed. It's a very flexible and productive approach.
    For example, let's assume you are the member of an online shopping portal development
    team and want to develop an application based on microservices. You can divide
    your application based on different domains such as products, payments, cart,
    and so on, and package all these components as separate packages. Once you have
    deployed all these packages separately, these would act as single components that
    can be developed, tested, and deployed independently, and called µService.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，微服务为我们提供了灵活性，只回滚失败的功能。这是一种非常灵活且高效的方法。例如，假设你是在线购物门户开发团队的一员，并希望基于微服务开发应用程序。你可以根据不同的领域（如产品、支付、购物车等）将应用程序进行划分，并将所有这些组件作为单独的包进行打包。一旦你单独部署了所有这些包，它们将作为可以独立开发、测试和部署的单一组件，并被称为微服务。
- en: Now, let's see how that helps you. Let's say that after a production release
    launching new features, enhancements, and bug fixes, you find flaws in the payment
    service that need an immediate fix. Since the architecture you have used is based
    on microservices, you can rollback the payment service instead of rolling back
    the whole release, if your application architecture allows, or apply the fixes
    to the microservices payment service without affecting the other services. This
    not only allows you to handle failure properly, but it also helps to deliver the
    features/fixes swiftly to a customer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这如何帮助你。假设在生产环境中推出新功能、增强功能和修复程序后，你发现支付服务存在缺陷需要立即修复。由于你使用的架构是基于微服务的，因此如果你的应用程序架构允许，你可以只回滚支付服务，而不是整个发布，或者在不影响其他服务的情况下将修复程序应用于微服务支付服务。这不仅使你能够恰当地处理失败，而且还帮助您迅速将功能/修复传递给客户。
- en: Problems in adopting new technologies
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用新技术的问题
- en: Monolithic applications are mostly developed and enhanced based on the technologies
    primarily used during the initial development of a project or a product. It makes
    it very difficult to introduce new technology at a later stage of the development
    or once the product is in a mature state (for example, after a few years). In
    addition, different modules in the same project, that depend on different versions
    of the same library, make this more challenging.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序主要是基于项目或产品最初开发阶段主要使用的技术进行开发和增强的。这使得在开发的后期阶段或产品成熟后（例如，几年后）引入新技术变得非常困难。此外，同一项目中依赖不同版本的同一库的不同模块使这更具挑战性。
- en: Technology is improving year on year. For example, your system might be designed
    in Java and then, a few years later, you want to develop a new service in Ruby
    on Rails or NodeJS because of a business need or to utilize the advantages of
    new technologies. It would be very difficult to utilize the new technology in
    an existing monolithic application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 技术每年都在进步。例如，您的系统可能设计为用Java实现，然后几年后，由于业务需求或利用新技术的优势，您可能希望用Ruby on Rails或NodeJS开发一个新服务。在一个现有的单体应用程序中利用新技术将非常困难。
- en: It is not just about code-level integration, but also about testing and deployment.
    It is possible to adopt a new technology by re-writing the entire application,
    but it is time-consuming and a risky thing to do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是代码级别集成的問題，还包括测试和部署。可以通过重写整个应用程序来采用新技术，但这既耗时又冒险。
- en: On the other hand, because of its component-based development and design, microservices
    gives us the flexibility to use any technology, new or old, for its development.
    It does not restrict you to using specific technologies, it gives a new paradigm
    to your development and engineering activities. You can use Ruby on Rails, NodeJS,
    or any other technology at any time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于其基于组件的开发和设计，微服务为我们提供了使用任何技术的灵活性，无论是新的还是旧的。它不会限制你使用特定的技术，为你的开发和工程活动提供了新的范式。你随时可以使用Ruby
    on Rails、NodeJS或其他任何技术。
- en: So, how is it achieved? Well, it's very simple. Microservices-based application
    code does not bundle into a single archive and is not stored in a single directory.
    Each µService has its own archive and is deployed separately. A new service could
    be developed in an isolated environment and could be tested and deployed without
    any technical issues. As you know, microservices also owns its own separate processes;
    it serves its purpose without any conflict such as shared resources with tight
    coupling, and processes remain independent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何实现的呢？嗯，其实很简单。基于微服务的应用程序代码不会打包成一个单一的归档，也不会存储在单一的目录中。每个微服务都有自己的归档，并且是独立部署的。一个新的服务可以在一个隔离的环境中开发，并且可以没有任何技术问题地进行测试和部署。正如你所知，微服务也有自己的独立进程；它在不存在紧耦合的共享资源冲突的情况下完成其功能，并且进程保持独立。
- en: Since a microservice is by definition a small, self-contained function, it provides
    a low-risk opportunity to try a new technology. That is definitely not the case
    where monolithic systems are concerned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务定义上是一个小型的、自包含的功能，它提供了一个尝试新技术的低风险机会。而在单体系统中，情况绝对不是这样。
- en: You can also make your microservice available as open source software so it
    can be used by others, and if required it may interoperate with a closed source
    proprietary one, which is not possible with monolithic applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以让你的微服务作为开源软件提供给他人使用，如果需要，它还可以与闭源专有软件互操作，这是单体应用程序所不可能实现的。
- en: Alignment with Agile practices
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与敏捷实践的对齐
- en: 'There is no question that monolithic applications can be developed using Agile
    practices, and these are being developed. **Continuous Integration (CI)** and
    **Continuous Deployment (CD)** could be used, but the question is—does it use
    Agile practices effectively? Let''s examine the following points:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，可以使用敏捷实践来开发单体应用程序，而且这样的应用程序正在被开发。可以采用**持续集成（CI）**和**持续部署（CD）**，但问题在于——它是否有效地使用了敏捷实践？让我们来分析以下几点：
- en: For example, when there is a high probability of having stories dependent on
    each other, and there could be various scenarios, a story could not be taken up
    until the dependent story is complete
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，当有高概率的故事相互依赖，并且有各种场景时，只有在依赖的故事完成后才能开始一个故事。
- en: The build takes more time as the code size increases
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着代码规模的增加，构建所需的时间也会增加。
- en: The frequent deployment of a large monolithic application is a difficult task
    to achieve
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁部署大型单体应用程序是一项难以实现的任务。
- en: You would have to redeploy the whole application even if you updated a single
    component
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使你只更新了一个组件，你也必须重新部署整个应用程序。
- en: Redeployment may cause problems to already running components, for example,
    a job scheduler may change whether components impact it or not
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新部署可能会对正在运行的组件造成问题，例如，作业调度器可能会改变无论组件是否受其影响。
- en: The risk of redeployment may increase if a single changed component does not
    work properly or if it needs more fixes
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果单个更改的组件不能正常工作或需要更多的修复，重新部署的风险可能会增加。
- en: UI developers always need more redeployment, which is quite risky and time-consuming
    for large monolithic applications
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界面开发者总是需要更多的重新部署，这对于大型单体应用程序来说是非常冒险和耗时的。
- en: The preceding issues can be tackled very easily by microservices, for example,
    UI developers may have their own UI component that can be developed, built, tested,
    and deployed separately. Similarly, other microservices might also be deployable
    independently and, because of their autonomous characteristics, the risk of system
    failure is reduced. Another advantage for development purposes is that UI developers
    can make use of the JSON object and mock Ajax calls to develop the UI, which can
    be taken up in an isolated manner. After development completes, developers can
    consume the actual APIs and test the functionality. To summarize, you could say
    that microservices development is swift and it aligns well with the incremental
    needs of businesses.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以很轻松地解决前面提到的问题，例如，UI开发者可能有自己的UI组件，可以独立地开发、构建、测试和部署。同样，其他微服务也可能可以独立部署，由于它们具有自主特性，因此降低了系统失败的风险。对于开发来说，另一个优点是UI开发者可以利用JSON对象和模拟Ajax调用来开发UI，这种方式是隔离的。开发完成后，开发者可以消费实际的API并进行功能测试。总结来说，可以说微服务开发是迅速的，并且很好地适应了企业逐步增长的需求。
- en: Ease of development – could be done better
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发容易度 - 可以做得更好
- en: Generally, large monolithic application code is the toughest to understand for
    developers, and it takes time before a new developer can become productive. Even
    loading the large monolithic application into IDE is troublesome, and it makes
    IDE slower and the developer less productive.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大型单体应用程序的代码对于开发者来说是最难以理解的，新开发者需要时间才能变得高效。即使将大型单体应用程序加载到IDE中也是麻烦的，这会使得IDE变慢，并降低开发者的效率。
- en: A change in a large monolithic application is difficult to implement and takes
    more time due to a large code base, and there will be a high risk of bugs if impact
    analysis is not done properly and thoroughly. Therefore, it becomes a prerequisite
    for developers to do thorough impact analysis before implementing changes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型单体应用程序中进行更改是困难的，并且由于代码库庞大，需要更多的时间，如果没有进行彻底的影响分析，就会有很高的bug风险。因此，在实施更改之前，开发者进行彻底的影响分析是一个前提条件。
- en: In monolithic applications, dependencies build up over time as all components
    are bundled together. Therefore, the risk associated with code change rises exponentially
    as code changes (number of modified lines of code) grows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序中，随着时间的推移，依赖关系逐渐建立，因为所有组件都捆绑在一起。因此，与代码更改（修改的代码行数）增长相关的风险呈指数级上升。
- en: When a code base is huge and more than 100 developers are working on it, it
    becomes very difficult to build products and implement new features because of
    the previously mentioned reason. You need to make sure that everything is in place,
    and that everything is coordinated. A well-designed and documented API helps a
    lot in such cases.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码库很大且有超过100个开发者正在工作时，由于之前提到的原因，构建产品和实施新功能变得非常困难。你需要确保一切就绪，并且一切协调一致。在这种情况下，设计良好且文档齐全的API会有很大帮助。
- en: Netflix, the on-demand internet streaming provider, had problems getting their
    application developed, with around 100 people working on it. Then, they used a
    cloud and broke up the application into separate pieces. These ended up being
    microservices. Microservices grew from the desire for speed and agility and to
    deploy teams independently.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix，这个按需互联网流媒体服务提供商，在他们有大约100人在开发应用程序时遇到了问题。然后，他们使用了云，并将应用程序拆分成不同的部分。这些最终成为了微服务。微服务源于对速度和敏捷性的渴望，以及独立部署团队的需求。
- en: Micro-components are made loosely coupled thanks to their exposed API, which
    can be continuously integration tested. With microservices' continuous release
    cycle, changes are small and developers can rapidly exploit them with a regression
    test, then go over them and fix the eventual defects found, reducing the risk
    of a deployment. This results in higher velocity with a lower associated risk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微组件通过暴露的API实现了松耦合，可以持续进行集成测试。在微服务的持续发布周期中，变化很小，开发人员可以快速地进行回归测试，然后进行审查并修复发现的缺陷，从而降低了部署的风险。这导致了更高的速度和较低的相关风险。
- en: Owing to the separation of functionality and single responsibility principle,
    microservices makes teams very productive. You can find a number of examples online
    where large projects have been developed with minimum team sizes such as eight
    to ten developers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于功能分离和单一责任原则，微服务使团队非常高效。你可以在网上找到许多例子，大型项目是用最小的团队规模（如八到十名开发者）开发的。
- en: Developers can have better focus with smaller code and resultant better feature
    implementation that leads to a higher empathic relationship with the users of
    the product. This conduces better motivation and clarity in feature implementation.
    An empathic relationship with users allows a shorter feedback loop and better
    and speedy prioritization of the feature pipeline. A shorter feedback loop also
    makes defect detection faster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以拥有更小的代码和更好的特性实现，从而与产品的用户建立更强的共情关系。这有助于在特性实现上取得更好的动机和清晰度。与用户的共情关系可以实现更短的反馈循环，更好地快速优先处理特性管道。更短的反馈循环也可以使缺陷检测更快。
- en: Each microservices team works independently and new features or ideas can be
    implemented without being coordinated with larger audiences. The implementation
    of end-point failures handling is also easily achieved in the microservices design.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务团队独立工作，可以无需与更多人协调就实施新功能或想法。在微服务设计中，端点失败处理也很容易实现。
- en: Recently, at one of the conferences, a team demonstrated how they had developed
    a microservices-based transport-tracking application including iOS and Android
    applications within 10 weeks, which had Uber-type tracking features. A big consulting
    firm gave a seven months estimation for the same application to its client. It
    shows how microservices is aligned with Agile methodologies and CI/CD.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，在一场会议中，一个团队展示了他们如何在一个为期10周的项目中开发了一个基于微服务的运输跟踪应用程序，包括iOS和Android应用程序，并具有Uber类型的跟踪功能。一家大型咨询公司为其客户提供了一个为期七个月的同一应用程序估计。这显示了微服务如何与敏捷方法和持续集成/持续部署（CI/CD）保持一致。
- en: Microservices build pipeline
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务构建管道
- en: Microservices could also be built and tested using the popular CI/CD tools such
    as Jenkins, TeamCity, and so on. It is very similar to how a build is done in
    a monolithic application. In microservices, each microservice is treated like
    a small application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务也可以使用流行的持续集成/持续部署（CI/CD）工具如Jenkins、TeamCity等来构建和测试。这与在单体应用中进行构建非常相似。在微服务中，每个微服务都被当作一个小应用程序来对待。
- en: 'For example, once you commit the code in the repository (SCM), CI/CD tools
    trigger the build process:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一旦您在仓库（SCM）中提交代码，CI/CD工具就会触发构建过程：
- en: Cleaning code
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理代码
- en: Code compilation
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编译
- en: Unit test execution
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行单元测试
- en: Contract/Acceptance test execution
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同/验收测试执行
- en: Building the application archives/container images
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序归档/容器镜像
- en: Publishing the archives/container images to repository management
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将归档/容器镜像发布到仓库管理
- en: Deployment on various Delivery environments such as Dev, QA, Stage, and so on
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各种交付环境（如Dev、QA、Stage等）上进行部署
- en: Integration and Functional test execution
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成和功能测试执行
- en: Any other steps
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他任何步骤
- en: Then, release-build triggers that change the SNAPSHOT or RELEASE version in
    `pom.xml` (in case of Maven) build the artifacts as described in the normal build
    trigger. Publish the artifacts to the artifacts repository. Tag this version in
    the repository. If you use the container image then build the container image
    as a part of the build.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`pom.xml`（对于Maven）中，发布构建触发器会更改SNAPSHOT或RELEASE版本，按照正常的构建触发器描述构建工件。将工件发布到工件仓库。在仓库中为此版本打上标签。如果您使用容器镜像，则将容器镜像作为构建的一部分来构建。
- en: Deployment using a container such as Docker
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用如Docker之类的容器进行部署
- en: Owing to the design of microservices, you need to have an environment that provides
    flexibility, agility, and smoothness for continuous integration and deployment
    as well as for shipment. Microservices deployments need speed, isolation management,
    and an Agile life-cycle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的设计，您需要一个提供灵活性、敏捷性和平滑性的环境，以便进行持续集成和部署，以及发货。微服务的部署需要速度、隔离管理以及敏捷的生命周期。
- en: Products and software can also be shipped using the concept of an intermodal-container
    model. An intermodal-container is a large standardized container, designed for
    intermodal freight transport. It allows cargo to use different modes of transport—truck,
    rail, or ship without unloading and reloading. This is an efficient and secure
    way of storing and transporting stuff. It resolves the problem of shipping, which
    previously had been a time consuming, labor-intensive process, and repeated handling
    often broke fragile goods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 产品和软件也可以使用集装箱模型进行运输。集装箱是一种大型标准化容器，专为多式联运而设计。它允许货物使用不同的运输方式——卡车、铁路或船舶，而无需卸载和装载。这是一种存储和运输物品高效且安全的方式。它解决了运输问题，过去这是一个耗时、劳动密集型的过程，重复处理经常会损坏易碎物品。
- en: Shipping containers encapsulate their content. Similarly, software containers
    are starting to be used to encapsulate their contents (products, applications,
    dependencies, and so on).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运输集装箱封装了它们的内容。同样，软件容器正开始被用来封装它们的内容（产品、应用程序、依赖项等）。
- en: Previously, **Virtual Machines** (**VMs**) were used to create software images
    that could be deployed where needed. Later, containers such as Docker became more
    popular as they were compatible with both traditional virtual stations systems
    and cloud environments. For example, it is not practical to deploy more than a
    couple of VMs on a developer's laptop. Building and booting a VM is usually I/O
    intensive and consequently slow.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，**虚拟机**（**VM**）被用来创建可以在需要时部署的软件镜像。后来，像Docker这样的容器变得更为流行，因为它们既兼容传统的虚拟站系统，也兼容云环境。例如，在开发人员的笔记本电脑上部署多个虚拟机是不切实际的。构建和引导虚拟机通常是I/O密集型的，因此速度较慢。
- en: Containers
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: A container (for example, Linux containers) provides a lightweight runtime environment
    consisting of the core features of virtual machines and the isolated services
    of operating systems. This makes the packaging and execution of microservices
    easy and smooth.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 容器（例如，Linux容器）提供了一个轻量级的运行时环境，该环境包括了虚拟机的核心功能和操作系统的隔离服务。这使得微服务的打包和执行变得容易且流畅。
- en: As the following diagram shows, a container runs as an application (microservice)
    within the **Operating** **System**. The OS sits on top of the hardware and each
    OS could have multiple containers, with a container running the application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图表所示，容器作为应用程序（微服务）在**操作系统**内运行。操作系统位于硬件之上，每个操作系统可能具有多个容器，其中一个容器运行应用程序。
- en: 'A container makes use of an operating system''s kernel interfaces, such as
    **cnames** and **namespaces**, that allow multiple containers to share the same
    kernel while running in complete isolation to one another. This gives the advantage
    of not having to complete an OS installation for each usage; the result being
    that it removes the overhead. It also makes optimal use of the **Hardware**:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 容器利用操作系统的内核接口，如**cnames**和**namespaces**，使得多个容器能够在完全隔离的情况下共享同一个内核。这使得不需要为每个使用情况完成一个操作系统安装；结果是它消除了开销。它还使硬件**得到最佳利用**：
- en: '![](img/a8adb807-2da8-4607-a466-8fe5b9cf4a0f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8adb807-2da8-4607-a466-8fe5b9cf4a0f.png)'
- en: Layer diagram for containers
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 容器层图
- en: Docker
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Container technology is one of the fastest growing technologies today, and Docker
    leads this segment. Docker is an open source project and it was launched in 2013\.
    10,000 developers tried it after its interactive tutorial launched in August 2013\.
    It was downloaded 2.75 million times by the time of the launch of its 1.0 release
    in June 2013\. Many large companies have signed the partnership agreement with
    Docker, such as Microsoft, Red Hat, HP, OpenStack, and service providers such
    as Amazon Web Services, IBM, and Google.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术是当今发展最快的技术之一，Docker领导这一领域。Docker是一个开源项目，它于2013年启动。2013年8月其互动教程发布后，10,000名开发者尝试了它。到2013年6月其1.0版本发布时，它已经被下载了275万次。许多大型公司已经与Docker签署了合作伙伴协议，如微软、红帽、惠普、OpenStack，以及服务提供商如亚马逊网络服务、IBM和谷歌。
- en: As we mentioned earlier, Docker also makes use of the Linux kernel features,
    such as cgroups and namespaces, to ensure resource isolation and packaging of
    the application with its dependencies. This packaging of dependencies enables
    an application to run as expected across different Linux operating systems/distributions,
    supporting a level of portability. Furthermore, this portability allows developers
    to develop an application in any language and then easily deploy it from a laptop
    to a test or production server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Docker也利用了Linux内核的功能，如cgroups和namespaces，以确保资源隔离和应用及其依赖的打包。这种依赖的打包使得应用能够如预期地在不同的Linux操作系统/发行版上运行，支持一定程度的可移植性。此外，这种可移植性允许开发者在任何语言中开发应用程序，然后轻松地将它从笔记本电脑部署到测试或生产服务器。
- en: Docker runs natively on Linux. However, you can also run Docker on Windows and
    MacOS using VirtualBox and boot2docker.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker原生运行在Linux上。然而，你也可以使用VirtualBox和boot2docker在Windows和MacOS上运行Docker。
- en: Containers are comprised of just the application and its dependencies including
    the basic operating system. This makes it lightweight and efficient in terms of
    resource utilization. Developers and system administrators get interested in container's
    portability and efficient resource utilization.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 容器只包括应用程序及其依赖项，包括基本操作系统。这使得它在资源利用方面轻量且高效。开发人员和系统管理员对容器的可移植性和高效资源利用感兴趣。
- en: Everything in a Docker container executes natively on the host and uses the
    host kernel directly. Each container has its own user namespace.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器中的所有内容都在宿主机上以原生方式执行，并直接使用宿主机内核。每个容器都有自己的用户命名空间。
- en: Docker's architecture
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的架构
- en: 'As specified on Docker documentation, Docker architecture uses client-server
    architecture. As shown in the following figure (sourced from Docker''s website:
    [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)),
    the Docker client is primarily a user interface that is used by an end user; clients
    communicate back and forth with a Docker daemon. The Docker daemon does the heavy
    lifting of the building, running, and distributing of your Docker containers.
    The Docker client and the daemon can run on the same system or different machines.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如Docker文档所述，Docker架构采用客户端-服务器架构。如图所示（来源于Docker官网：[https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)），Docker客户端主要是用户界面，用于终端用户；客户端与Docker守护进程进行通信。Docker守护进程负责构建、运行和分发你的Docker容器。Docker客户端和守护进程可以运行在同一系统或不同机器上。
- en: The Docker client and daemon communicate via sockets or through a RESTful API.
    Docker registers are public or private Docker image repositories from which you
    upload or download images, for example, Docker Hub ([hub.docker.com](https://hub.docker.com/))
    is a public Docker registry.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端和守护进程通过套接字或通过RESTful API进行通信。Docker注册表是公开或私有的Docker镜像仓库，你可以从中上传或下载镜像，例如，Docker
    Hub（[hub.docker.com](https://hub.docker.com/)）是一个公开的Docker注册表。
- en: '![](img/0ad926bf-861d-4c67-9004-46caa8f4fe7f.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ad926bf-861d-4c67-9004-46caa8f4fe7f.png)'
- en: Docker's architecture
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的架构
- en: 'The primary components of Docker are:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的主要组件包括：
- en: '**Docker image**: A Docker image is a read-only template. For example, an image
    could contain an Ubuntu operating system with Apache web server and your web application
    installed. Docker images are a build component of Docker and images are used to
    create Docker containers. Docker provides a simple way to build new images or
    update existing images. You can also use images created by others and/or extend
    them.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：Docker镜像是一个只读模板。例如，一个镜像可能包含一个带有Apache网页服务器和你的网页应用的Ubuntu操作系统。Docker镜像
    是Docker构建组件之一，镜像用于创建Docker容器。Docker提供了一种简单的方法来构建新的镜像或更新现有镜像。你也可以使用他人创建的镜像，/或扩展它们。'
- en: '**Docker container**: A Docker container is created from a Docker image. Docker
    works so that the container can only see its own processes, and have its own filesystem
    layered onto a host filesystem and a networking stack, which pipes to the host-networking
    stack. Docker **Containers** can be run, started, stopped, moved, or deleted.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker容器**：Docker容器是从Docker镜像创建的。Docker的工作原理是，容器只能看到自己的进程，并且在其宿主文件系统之上有自己的文件系统层和网络堆栈，这些管道到宿主网络堆栈。Docker**容器**可以被运行、启动、停止、移动或删除。'
- en: Deployment
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'Microservices deployment with Docker deals with three parts:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker进行微服务部署涉及三个部分：
- en: Application packaging, for example, JAR
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序打包，例如，JAR
- en: Building Docker image with a JAR and dependencies using a Docker instruction
    file, the Dockerfile, and command `docker build`. It helps to repeatedly create
    the image
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker指令文件，Dockerfile和命令`docker build`构建包含JAR和依赖项的Docker镜像。它有助于反复创建镜像。
- en: Docker container execution from this newly built image using command `docker
    run`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令`docker run`从新构建的镜像中执行Docker容器。
- en: 'The preceding information will help you to understand the basics of Docker.
    You will learn more about Docker and its practical usage in [Chapter 5](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml),
    *Deployment and Testing*. Source and reference, refer to: [https://docs.docker.com](https://docs.docker.com).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的信息将帮助你理解Docker的基础知识。你将在[第5章](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml)，*部署与测试*中了解更多关于Docker及其实际应用。源代码和参考资料，参考：
    [https://docs.docker.com](https://docs.docker.com)。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned or recapped the high-level design of large
    software projects, from traditional monolithic to microservices applications.
    You were also introduced to a brief history of microservices, the limitation of
    monolithic applications, and the benefits and flexibility that microservices offer.
    I hope this chapter helped you to understand the common problems faced in a production
    environment by monolithic applications and how microservices can resolve such
    problem. You were also introduced to lightweight and efficient Docker containers
    and saw how containerization is an excellent way to simplify microservices deployment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了大型软件项目的高级设计，从传统的单体应用到微服务应用。你还简要了解了微服务的历史、单体应用的局限性以及微服务所提供的优势和灵活性。我希望这一章能帮助你理解单体应用在生产环境中遇到的一些常见问题以及微服务如何解决这些问题。你还了解到了轻量级且高效的Docker容器，并看到了容器化是简化微服务部署的绝佳方式。
- en: In the next chapter, you will get to know about setting up the development environment
    from IDE, and other development tools, to different libraries. We will deal with
    creating basic projects and setting up Spring Boot configuration to build and
    develop our first microservice. We will be using Java 9 as the language and Spring
    Boot for our project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解到如何从IDE设置开发环境，以及其他开发工具和不同的库。我们将处理创建基本项目并设置Spring Boot配置来构建和开发我们的第一个微服务。我们将使用Java
    9作为编程语言和Spring Boot来完成项目。
