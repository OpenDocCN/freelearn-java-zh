- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Java Concurrency Utilities and Testing in the Cloud Era
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云时代下的 Java 并发工具和测试
- en: Remember the bustling kitchen from the last chapter, where chefs collaborated
    to create culinary magic? Now, imagine a cloud kitchen, where orders fly in from
    all corners, demanding parallel processing and perfect timing. That’s where Java
    concurrency comes in, the secret sauce for building high-performance cloud applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 记得上一章中繁忙的厨房，厨师们合作创造烹饪魔法？现在，想象一下云厨房，订单从四面八方飞来，要求并行处理和完美的时间。这就是 Java 并发的作用，是构建高性能云应用的秘密调料。
- en: This chapter is your guide to becoming a master chef of Java concurrency. We’ll
    explore the Executor framework, your trusty sous chef for managing threads efficiently.
    We’ll dive into Java’s concurrent collections, ensuring data integrity even when
    multiple cooks are stirring the pot.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是您成为 Java 并发大师的指南。我们将探讨 Executor 框架，您的可靠副厨师，用于高效管理线程。我们将深入研究 Java 的并发集合，确保在多个厨师同时搅拌锅中的食材时数据完整性。
- en: But a kitchen thrives on coordination! We’ll learn synchronization tools such
    as `CountDownLatch`, `Semaphore`, and `CyclicBarrier`, guaranteeing ingredients
    arrive at the right time and chefs don’t clash over shared equipment. We’ll even
    unlock the secrets of Java’s locking mechanisms, mastering the art of sharing
    resources without culinary chaos.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但厨房需要协调！我们将学习同步工具，如 `CountDownLatch`、`Semaphore` 和 `CyclicBarrier`，确保食材在正确的时间到达，厨师不会因为共享设备而发生冲突。我们甚至将揭示
    Java 锁定机制的秘诀，掌握在避免烹饪混乱的情况下共享资源的艺术。
- en: Finally, we’ll equip you with testing and debugging strategies, the equivalent
    of a meticulous quality check before serving your dishes to the world. By the
    end, you’ll be a Java concurrency ninja, crafting cloud applications that run
    smoothly and efficiently, and leave your users raving for more.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为您提供测试和调试策略，这相当于在将菜肴呈献给世界之前进行细致的质量检查。到那时，您将成为一位 Java 并发大师，制作出运行流畅且高效的云应用，让用户对更多功能赞不绝口。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need **Visual Studio Code** (**VS Code**) installed. Here is the URL
    to download it: [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装 **Visual Studio Code** （**VS Code**）。以下是下载的 URL：[https://code.visualstudio.com/download](https://code.visualstudio.com/download)。
- en: VS Code offers a lightweight and customizable alternative to the other options
    on this list. It’s a great choice for developers who prefer a less resource-intensive
    **integrated development environment** (**IDE**) and want the flexibility to install
    extensions tailored to their specific needs. However, it may not have all the
    features out of the box compared to the more established Java IDEs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 提供了比列表中其他选项更轻量级和可定制的替代方案。对于更喜欢资源消耗较少的 **集成开发环境** （**IDE**）并希望安装针对其特定需求定制的扩展的开发者来说，这是一个不错的选择。然而，与更成熟的
    Java IDE 相比，它可能没有所有开箱即用的功能。
- en: 'You will need to install Maven. To do so, follow these steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装 Maven。为此，请按照以下步骤操作：
- en: '**Download Maven**:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载 Maven**：'
- en: 'Go to the Apache Maven website: [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Apache Maven 网站：[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)
- en: Select the **Binary zip archive** if you are on Windows or the **Binary tar.gz
    archive** if you are on Linux or macOS.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是 Windows，请选择 **二进制 zip 存档**；如果您使用的是 Linux 或 macOS，请选择 **二进制 tar.gz 存档**。
- en: '`C:\Program Files\Apache\Maven on Windows or /opt/apache/maven` `on Linux`).'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`C:\Program Files\Apache\Maven` （在 Windows 上）或 `/opt/apache/maven` （在 Linux
    上）。'
- en: '`MAVEN_HOME`: Create an environment variable named `MAVEN_HOME` and set its
    value to the directory where you extracted Maven (e.g., `C:\Program Files\Apache\Maven\apache-maven-3.8.5`).'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MAVEN_HOME`：创建一个名为 `MAVEN_HOME` 的环境变量，并将其值设置为提取 Maven 的目录（例如，`C:\Program Files\Apache\Maven\apache-maven-3.8.5`）。'
- en: '`PATH`: Update your `PATH` environment variable to include the Maven bin directory
    (e.g., `%MAVEN_HOME%\bin`).'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PATH`：更新您的 `PATH` 环境变量，包括 Maven bin 目录（例如，`%MAVEN_HOME%\bin`）。'
- en: '`~/.bashrc or ~/.bash_profile file:` `export PATH=/opt/apache-maven-3.8.5/bin:$PATH`.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`~/.bashrc 或 ~/.bash_profile 文件`：`export PATH=/opt/apache-maven-3.8.5/bin:$PATH`。'
- en: '`mvn -version`. If installed correctly, you’ll see the Maven version, Java
    version, and other details.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mvn -version`。如果安装正确，您将看到 Maven 版本、Java 版本和其他详细信息。'
- en: Uploading your JAR file to AWS Lambda
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将您的 JAR 文件上传到 AWS Lambda
- en: 'Here are the prerequisites:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是先决条件：
- en: '**AWS account**: You’ll need an AWS account with permission to create a Lambda
    function.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS 账户**：您需要一个具有创建 Lambda 函数权限的 AWS 账户。'
- en: '**JAR file**: Your Java project is compiled and packaged into a JAR file (using
    tools such as Maven or Gradle).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAR文件**: 您的Java项目被编译并打包成一个JAR文件（使用Maven或Gradle等工具）。'
- en: 'Log in to the AWS console:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 登录AWS控制台：
- en: '**Go to AWS Lambda**: Navigate to the AWS Lambda service within your AWS console.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**转到AWS Lambda**: 在您的AWS控制台中导航到AWS Lambda服务。'
- en: '**Create function**: Click **Create Function**. Choose **Author from Scratch**,
    give your function a name, and select the Java runtime.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建函数**: 点击**创建函数**。选择**从头开始创建作者**，为您的函数命名，并选择Java运行时。'
- en: '**Upload code**: In the **Code source** section, choose **Upload from: Upload
    .zip or .jar file**, and then click **Upload**. Select your JAR file.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**上传代码**: 在**代码源**部分，选择**从以下位置上传：上传.zip或.jar文件**，然后点击**上传**。选择您的JAR文件。'
- en: '`com.example.MyHandler`). A Java AWS Lambda handler class is a Java class that
    defines the entry point for your Lambda function’s execution, containing a method
    named `handleRequest` to process incoming events and provide an appropriate response.
    For detailed information, see the following documentation:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`com.example.MyHandler`)。Java AWS Lambda处理器类是一个Java类，它定义了Lambda函数执行的入口点，包含一个名为`handleRequest`的方法来处理传入的事件并提供适当的响应。有关详细信息，请参阅以下文档：'
- en: '**Java**: [https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html](https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java**: [https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html](https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html)'
- en: '**Save**: Click **Save** to create your Lambda function.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**: 点击**保存**以创建您的Lambda函数。'
- en: 'Here are some important things to consider:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的事情需要考虑：
- en: '**Dependencies**: If your project has external dependencies, you’ll either
    need to package them into your JAR (sometimes called an *uber-jar* or *fat jar*)
    or utilize Lambda layers for those dependencies.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**: 如果您的项目有外部依赖项，您可能需要将它们打包到您的JAR文件中（有时称为*uber-jar*或*fat jar*）或使用Lambda层来处理这些依赖项。'
- en: '**IAM role**: Your Lambda function needs an IAM role with appropriate permissions
    to interact with other AWS services if it will do so.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IAM角色**: 如果您的Lambda函数需要与其他AWS服务交互，则需要具有适当权限的IAM角色。'
- en: 'Further, the code in this chapter can be found on GitHub:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Introduction to Java concurrency tools – empowering cloud computing
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java并发工具简介 – 推动云计算
- en: 'In the ever-expanding realm of cloud computing, building applications that
    can juggle multiple tasks simultaneously is no longer a luxury, but a necessity.
    This is where **Java concurrency utilities** (**JCU**) emerge as a developer’s
    secret weapon, offering a robust toolkit to unlock the true potential of concurrent
    programming in the cloud. Here are the useful features of JCU:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算不断扩大的领域中，构建能够同时处理多个任务的应用程序不再是奢侈品，而是一种必需品。这就是**Java并发工具**（**JCU**）作为开发者的秘密武器出现的地方，它提供了一套强大的工具集，以释放云计算中并发编程的真正潜力。以下是JCU的实用功能：
- en: '**Unleashing scalability**: Imagine a web application effortlessly handling
    a sudden surge in user traffic. This responsiveness and ability to seamlessly
    scale up is a key benefit of JCU. By leveraging features such as thread pools,
    applications can dynamically allocate resources based on demand, preventing bottlenecks
    and ensuring smooth performance even under heavy load.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放可伸缩性**: 想象一下，一个Web应用能够轻松地处理用户流量的突然激增。这种响应性和无缝扩展的能力是JCU的关键优势。通过利用线程池等特性，应用程序可以根据需求动态分配资源，防止瓶颈，即使在重负载下也能确保平稳的性能。'
- en: '**Speed is king**: In today’s fast-paced world, latency is the enemy of a positive
    user experience. JCU helps combat this by optimizing communication and minimizing
    wait times. Techniques such as non-blocking I/O and asynchronous operations ensure
    requests are processed swiftly, leading to quicker response times and happier
    users.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度为王**: 在当今快节奏的世界里，延迟是积极用户体验的敌人。JCU通过优化通信和最小化等待时间来帮助对抗这一点。非阻塞I/O和异步操作等技术确保请求迅速处理，从而缩短响应时间，让用户更满意。'
- en: '**Every resource counts**: Cloud environments operate on a pay-as-you-go model,
    making efficient resource utilization crucial. JCU acts as a wise steward, carefully
    managing threads and resources to avoid wastage. Features such as concurrent collections,
    designed for concurrent access, reduce locking overhead and ensure efficient data
    handling, ultimately keeping cloud costs under control.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每一资源都至关重要**：云环境采用按需付费模式，因此高效利用资源至关重要。JCU扮演着明智的管家角色，仔细管理线程和资源，以避免浪费。如并发集合等特性，专为并发访问设计，可以减少锁定开销并确保高效的数据处理，最终将云成本控制在合理范围内。'
- en: '**Resilience in the face of adversity**: No system is immune to occasional
    hiccups. In the cloud, these can manifest as temporary failures or glitches. Thankfully,
    JCU’s asynchronous operations and thread safety act as a shield, enabling applications
    to recover quickly from setbacks and maintain functionality with minimal disruption.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逆境中的韧性**：没有系统能够完全避免偶尔的故障。在云环境中，这些问题可能表现为暂时性的故障或故障。幸运的是，JCU的异步操作和线程安全性充当了一道屏障，使应用程序能够快速从挫折中恢复，并保持功能，最小化中断。'
- en: '**Seamless integration**: Modern cloud development often involves integrating
    with various cloud-specific services and libraries. JCU’s standards-compliant
    design ensures smooth integration, providing a unified approach to managing concurrency
    across different cloud platforms and technologies.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无缝集成**：现代云开发通常涉及与各种云特定服务和库的集成。JCU的标准化设计确保了平滑的集成，提供了一种统一的方法来管理不同云平台和技术之间的并发。'
- en: '`ConcurrentHashMap` readily address, but others might require additional configuration
    for cross-region communication and synchronization.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`可以轻松解决，但其他可能需要额外的配置来实现跨区域通信和同步。'
- en: '**Security first**: As with any powerful tool, security is paramount. JCU offers
    features such as atomic variables and proper locking mechanisms to help prevent
    concurrency vulnerabilities such as race conditions, but it’s crucial to adopt
    secure coding practices to fully fortify cloud applications against potential
    threats.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全至上**：与任何强大的工具一样，安全性至关重要。JCU提供原子变量和适当的锁定机制等特性，以帮助防止并发漏洞，如竞态条件，但采用安全的编码实践对于完全巩固云应用程序以抵御潜在威胁至关重要。'
- en: In conclusion, JCU are not just tools, but an empowering force for developers
    seeking to build cloud applications that are not only efficient and scalable but
    also resilient. By understanding and harnessing their power, along with navigating
    the considerations with care, developers can create digital solutions that thrive
    in the ever-evolving cloud landscape.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，JCU不仅仅是工具，而是寻求构建既高效又可扩展且具有韧性的云应用程序的开发者的强大力量。通过理解和利用其力量，并谨慎处理相关考虑因素，开发者可以创建在不断演变的云环境中茁壮成长的数字解决方案。
- en: Real-world example – building a scalable application on AWS
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际案例 - 在AWS上构建可扩展的应用程序
- en: Imagine an e-commerce platform experiencing surges in image uploads during product
    launches or promotions. Traditional, non-concurrent approaches can struggle with
    such spikes, leading to slow processing, high costs, and frustrated customers.
    This example demonstrates how JCU and AWS Lambda can be combined to create a highly
    scalable and cost-effective image processing pipeline.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个电子商务平台在产品发布或促销期间会经历图像上传激增。传统的非并发方法可能难以应对这种峰值，导致处理缓慢、成本高昂和客户不满。这个例子展示了JCU和AWS
    Lambda如何结合使用，以创建一个高度可扩展且成本效益高的图像处理管道。
- en: Let’s look at this scenario – our e-commerce platform needs to process uploaded
    product images by resizing them for various display sizes, optimizing them for
    web delivery, and storing them with relevant metadata for efficient retrieval.
    This process must handle sudden bursts in image uploads without compromising performance
    or incurring excessive costs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个场景 - 我们的电子商务平台需要通过调整大小为各种显示尺寸处理上传的产品图像，优化它们以适应网络传输，并使用相关元数据存储它们以实现高效检索。这个过程必须处理图像上传的突发高峰，而不会影响性能或产生过高的成本。
- en: The following Java code demonstrates how to use JCU within an AWS Lambda function
    to perform image processing tasks in parallel. This example includes using `ExecutorService`
    for executing tasks such as image resizing and optimization, `CompletableFuture`
    for asynchronous operations, such as calling external APIs or fetching data from
    DynamoDB, and illustrates a conceptual approach for non-blocking I/O operations
    with Amazon S3 integration.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Java代码演示了如何在AWS Lambda函数中使用JCU并行执行图像处理任务。本例包括使用`ExecutorService`执行图像大小调整和优化等任务，使用`CompletableFuture`进行异步操作，如调用外部API或从DynamoDB获取数据，并展示了与Amazon
    S3集成的非阻塞I/O操作的概念方法。
- en: 'For Maven users, add the `aws-java-sdk` dependency to `pom.xml`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Maven用户，将`aws-java-sdk`依赖项添加到`pom.xml`中：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码片段：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the code explanation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码解释：
- en: '`ExecutorService`: This manages a pool of threads for concurrent tasks. Here,
    it is used to resize and optimize images asynchronously.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`：这个服务管理着一组线程以处理并发任务。在这里，它被用来异步地调整和优化图像的大小。'
- en: '`CompletableFuture`: This enables asynchronous programming. This example uses
    it for making non-blocking calls to external APIs or services such as DynamoDB
    and processing their results.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`：这个功能使得异步编程成为可能。本例中使用它来进行非阻塞的外部API或服务（如DynamoDB）的调用，并处理它们的返回结果。'
- en: '`AmazonS3ClientBuilder` is used to create an S3 client, which is then used
    to upload processed images.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AmazonS3ClientBuilder`创建S3客户端，然后用于上传处理后的图像。
- en: '`RequestHandler<S3Event, String>` to process incoming S3 events, indicating
    it’s triggered by S3 events (e.g., new image uploads).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestHandler<S3Event, String>`用于处理传入的S3事件，表明它是由S3事件（例如，新的图像上传）触发的。'
- en: This example omits actual image processing, API calls, and AWS SDK setup details
    for brevity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，本例省略了实际的图像处理、API调用和AWS SDK设置细节。
- en: This example showcases how JCU, combined with the serverless architecture of
    AWS Lambda, empowers developers to build highly scalable, cost-effective, and
    efficient cloud-based applications. By leveraging JCU’s concurrency features and
    integrating them seamlessly with AWS services, developers can create robust solutions
    that thrive in the dynamic and demanding cloud environment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本例展示了如何将JCU与AWS Lambda的无服务器架构相结合，赋予开发者构建高度可扩展、成本效益高且高效的云应用程序的能力。通过利用JCU的并发特性和与AWS服务的无缝集成，开发者可以创建在动态和需求高的云环境中茁壮成长的强大解决方案。
- en: Taming the threads – conquering the cloud with the Executor framework
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驯服线程——用Executor框架征服云
- en: Remember those single-threaded applications, struggling to keep up with the
    ever-changing demands of the cloud? Well, forget them! The **Executor framework**
    is here to unleash your inner cloud architect, empowering you to build applications
    that adapt and thrive in this dynamic environment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记得那些单线程应用程序，它们在努力跟上云的持续变化需求吗？好吧，忘掉它们吧！**Executor框架**在这里，旨在释放你内心的云架构师，赋予你构建能够适应并在这个动态环境中茁壮成长的应用程序的能力。
- en: 'Think of it like this: your cloud application is a bustling city, constantly
    handling requests and tasks. The Executor framework is your trusty traffic manager,
    ensuring smooth operation even during peak hours.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：你的云应用就像一座繁忙的城市，不断处理请求和任务。Executor框架就像是你的可靠交通管理员，即使在高峰时段也能确保顺畅运行。
- en: 'The key players of the Executor framework are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Executor框架的关键角色如下：
- en: '`ExecutorService`: The adaptable city planner, dynamically adjusting the number
    of available *lanes* (threads) based on real-time traffic (demand). No more idle
    threads or bottlenecked tasks!'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`：这位适应性强的城市规划师，根据实时交通（需求）动态调整可用的*车道*（线程）数量。不再有闲置的线程或瓶颈任务！'
- en: '`ScheduledExecutorService`: The punctual timekeeper, meticulously scheduling
    events, reminders, and tasks with precision. Whether it’s daily backups or quarterly
    reports, everything runs like clockwork.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScheduledExecutorService`：这位守时的计时员，精确地安排事件、提醒和任务。无论是每日备份还是季度报告，一切都能像时钟一样运行。'
- en: '`ThreadPoolExecutor`: The meticulous jeweler, carefully crafts thread pools
    with just the right size and configuration. They balance the city’s needs with
    resource efficiency, ensuring every thread shines like a gem.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`：这位细致的珠宝匠，精心打造了恰好大小和配置的线程池。它们平衡城市的需要与资源效率，确保每个线程都像宝石一样闪耀。'
- en: '**Work queues**: The city’s storerooms, each with unique strategies for organizing
    tasks before execution. Choose the right strategy (such as first in first out
    or priority queues) to keep tasks flowing smoothly and avoid resource overload.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作队列**：城市的储藏室，每个储藏室在执行前都有独特的组织任务策略。选择正确的策略（如先进先出或优先队列）以保持任务流畅并避免资源过载。'
- en: The Executor framework doesn’t just manage resources; it prioritizes them too.
    Imagine a sudden surge in visitors (requests). The framework ensures critical
    tasks are handled first, even when resources are stretched thin, keeping your
    city (application) running smoothly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Executor 框架不仅管理资源，还优先考虑它们。想象一下游客（请求）的突然激增。框架确保即使在资源紧张的情况下，也会首先处理关键任务，保持您的城市（应用程序）平稳运行。
- en: The symphony of cloud integration and adaptation
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云集成和适应的交响曲
- en: Our city, though grand, does not stand alone. It is but a part of a greater
    kingdom – the cloud. By integrating the Executor framework with the cloud’s myriad
    services and APIs, our city can stretch beyond its walls, tapping into the vast
    reservoirs of the cloud to dynamically adjust its resources, much like drawing
    water from the river during a drought or opening the gates during a flood.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的城市宏伟，但它并不孤立。它只是更大王国——云的一部分。通过将 Executor 框架与云的众多服务和 API 集成，我们的城市可以超越其城墙，利用云的巨大资源库动态调整其资源，就像在干旱时从河流中取水或在洪水时打开闸门一样。
- en: Adaptive execution strategies are the city’s scouts, constantly surveying the
    landscape and adjusting the city’s strategies based on the ever-changing conditions
    of the cloud. Whether it’s a surge in visitors or an unexpected storm, the city
    adapts, ensuring optimal performance and resource utilization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应执行策略是城市的侦察兵，不断勘察地形并根据云的持续变化条件调整城市的策略。无论是游客激增还是意外风暴，城市都会适应，确保最佳性能和资源利用率。
- en: The chronicles of best practices
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践的编年史
- en: As our tale comes to a close, the importance of monitoring and metrics emerges
    as the sage’s final piece of advice. Keeping a vigilant eye on the city’s operations
    ensures that decisions are made not in the dark, but with the full light of knowledge,
    guiding the city to scale gracefully and efficiently.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的故事即将结束，监控和指标的重要性凸显为智者最后的忠告。密切关注城市的运营确保决策不是在黑暗中做出，而是在知识的全面光照下，引导城市优雅而高效地扩展。
- en: So, our journey through the realms of the Executor framework for cloud-based
    applications concludes. By embracing dynamic scalability, mastering resource management,
    and integrating seamlessly with the cloud, developers can forge applications that
    not only withstand the test of time but thrive in the ever-evolving landscape
    of cloud computing. The tale of the Executor framework is a testament to the power
    of adaptation, efficiency, and strategic foresight in the era of cloud computing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过云应用程序的 Executor 框架领域的旅程就此结束。通过拥抱动态可伸缩性，掌握资源管理，并与云无缝集成，开发者可以构建不仅能够经受时间的考验，而且在云计算不断演变的领域中蓬勃发展的应用程序。Executor
    框架的故事是对云计算时代适应力、效率和战略远见的证明。
- en: Real-world examples of thread pooling and task scheduling in cloud architectures
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云架构中线程池和任务调度的实际示例
- en: Moving beyond theory, let’s dive into real-world scenarios where Java’s concurrency
    tools shine in cloud architectures. These examples showcase how to optimize resource
    usage and ensure application responsiveness under varying loads.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 超越理论，让我们深入现实场景，在这些场景中，Java 的并发工具在云架构中大放异彩。这些示例展示了如何优化资源使用并确保在变化负载下的应用程序响应性。
- en: Example 1 – keeping data fresh with scheduled tasks
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1 – 使用计划任务保持数据新鲜
- en: Imagine a cloud-based application that needs to regularly crunch data from various
    sources. Scheduled tasks are your secret weapon, ensuring data is always up to
    date, even during peak hours.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个需要定期从各种来源处理数据的基于云的应用程序。计划任务是您的秘密武器，确保数据始终保持最新，即使在高峰时段也是如此。
- en: '**Objective:** Process data from multiple sources periodically, scaling with
    data volume.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标：** 定期处理来自多个来源的数据，并随着数据量的增加而扩展。'
- en: '**Environment**: A distributed system gathering data from APIs for analysis.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境**：一个分布式系统，从 API 收集数据进行分析。'
- en: 'Here is the code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码片段：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The key points from the preceding example are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例的关键点如下：
- en: '`scheduleAtFixedRate` method ensures regular data updates, even under varying
    loads.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheduleAtFixedRate` 方法确保即使在变化负载下也能定期更新数据。'
- en: '**Resource efficiency**: A dedicated executor with a configurable thread pool
    size allows for efficient resource management, scaling up during peak processing.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源效率**：具有可配置线程池大小的专用执行器允许高效资源管理，在高峰处理期间进行扩展。'
- en: Example 2 – adapting to the cloud’s dynamics
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2 – 适应云的动态变化
- en: Cloud resources are like the weather – ever-changing. This example shows how
    to customize thread pools for optimal performance and resource utilization in
    AWS, handling diverse workloads and fluctuating resource availability.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 云资源就像天气一样——变化无常。这个例子展示了如何为AWS中的线程池定制以实现最佳性能和资源利用率，处理多样化的工作负载和波动的资源可用性。
- en: '**Objective**: Adapt a thread pool to handle varying computational demands
    in AWS, ensuring efficient resource use and cloud resource adaptability.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**：调整线程池以处理AWS中的不同计算需求，确保高效资源使用和云资源适应性。'
- en: '**Environment**: An application processing both lightweight and intensive tasks,
    deployed in an AWS environment with dynamic resources.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境**：一个处理轻量级和密集型任务的应用程序，部署在具有动态资源的AWS环境中。'
- en: 'Here is the code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码片段：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The key points from the preceding example are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例的关键点如下：
- en: '`AWSCloudResourceManager` class initializes `ThreadPoolExecutor` with a configurable
    core and maximum pool sizes. This setup allows the application to start with a
    conservative resource usage model, scaling up as demand increases or more AWS
    resources become available.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`AWSCloudResourceManager`类使用可配置的核心和最大池大小初始化`ThreadPoolExecutor`。这种设置允许应用程序以保守的资源使用模型开始，随着需求的增加或更多AWS资源的可用性而扩展。'
- en: '`adjustThreadPoolParameters` method, the application can dynamically adapt
    its thread pool configuration in response to AWS resource availability changes.
    This might be triggered by metrics from AWS CloudWatch or other monitoring tools,
    enabling real-time scaling decisions.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adjustThreadPoolParameters`方法，应用程序可以动态调整其线程池配置以响应AWS资源可用性的变化。这可能会由AWS CloudWatch或其他监控工具的指标触发，从而实现实时扩展决策。'
- en: '`ArrayBlockingQueue` for the executor’s work queue provides a clear strategy
    for managing task overflow. By limiting the queue size, the system can apply backpressure
    when under heavy load, preventing resource exhaustion.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为执行器的工作队列提供`ArrayBlockingQueue`，为管理任务溢出提供了一个清晰的策略。通过限制队列大小，系统可以在负载过重时应用背压，防止资源耗尽。
- en: '`CallerRunsPolicy` rejection policy ensures that tasks are not lost during
    peak loads but rather executed on the calling thread, adding a layer of robustness.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallerRunsPolicy`拒绝策略确保在高峰负载期间任务不会丢失，而是在调用线程上执行，增加了一层鲁棒性。'
- en: These examples demonstrate how Java’s concurrency tools empower cloud-based
    applications to thrive in dynamic environments. By embracing dynamic scaling,
    resource management, and cloud integration, you can build applications that are
    both responsive and cost-effective, regardless of the ever-changing cloud landscape.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了Java的并发工具如何使基于云的应用程序在动态环境中蓬勃发展。通过采用动态扩展、资源管理和云集成，您可以构建无论云景观如何变化，都能快速响应且成本效益高的应用程序。
- en: Utilizing Java’s concurrent collections in distributed systems and microservices
    architectures
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在分布式系统和微服务架构中利用Java的并发集合
- en: 'In the intricate world of distributed systems and microservices architectures,
    akin to a bustling city where data zips across the network like cars on a freeway,
    managing shared resources becomes a vital endeavor. Java’s concurrent collections
    step into this urban sprawl, offering efficient pathways and junctions for data
    to flow unhindered, ensuring that every piece of information reaches its destination
    promptly and accurately. Let’s embark on a journey through two pivotal structures
    in this landscape: `ConcurrentHashMap` and `ConcurrentLinkedQueue` and explore
    how they enable us to build applications that are not only scalable and reliable
    but also high performing.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在错综复杂的分布式系统和微服务架构的世界中，就像一个熙熙攘攘的城市，数据在网络中穿梭，如同高速公路上的汽车，管理共享资源成为一项至关重要的任务。Java的并发集合进入这个城市扩张，为数据流动提供高效的路径和交汇点，确保每一块信息都能及时准确地到达目的地。让我们开始一段旅程，探索这个领域中两个关键结构：`ConcurrentHashMap`和`ConcurrentLinkedQueue`，了解它们如何使我们能够构建不仅可扩展和可靠，而且性能高的应用程序。
- en: Navigating through data with ConcurrentHashMap
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ConcurrentHashMap导航数据
- en: Let us first understand the landscape of `ConcurrentHashMap`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解`ConcurrentHashMap`的景观。
- en: '**Scenario**: Picture a scenario in a sprawling metropolis where every citizen
    (microservice) needs quick access to a shared repository of knowledge (data cache).
    Traditional methods might cause traffic jams – delays in data access and potential
    mishaps in data consistency.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**：想象一下在一个庞大的都市中，每个市民（微服务）都需要快速访问一个共享的知识库（数据缓存）。传统方法可能会导致交通堵塞——数据访问延迟和潜在的数据一致性故障。'
- en: '`ConcurrentHashMap` acts as a high-speed metro system for data, offering a
    thread-safe way to manage this shared repository. It enables concurrent read and
    write operations without the overhead of full-scale synchronization, akin to having
    an efficient, automated traffic system that keeps data flowing smoothly at rush
    hour.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap` 作为数据的高速地铁系统，提供了一种线程安全的方式来管理这个共享仓库。它允许并发读写操作，而不需要全规模同步的开销，就像拥有一个高效的自动化交通系统，在高峰时段保持数据流畅。'
- en: 'Here is an example of the usage of `ConcurrentHashMap`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `ConcurrentHashMap` 使用的示例：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple snippet demonstrates how a user’s data can be cached and retrieved
    with `ConcurrentHashMap`, ensuring fast access and thread safety without the complexity
    of manual synchronization.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的代码片段展示了如何使用 `ConcurrentHashMap` 缓存和检索用户数据，确保快速访问和线程安全，而不需要手动同步的复杂性。
- en: Processing events with ConcurrentLinkedQueue
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ConcurrentLinkedQueue 处理事件
- en: Now, let us explore the landscape of `ConcurrentLinkedQueue`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索 `ConcurrentLinkedQueue` 的领域。
- en: '**Scenario**: Imagine our city bustling with events – concerts, parades, and
    public announcements. There needs to be a system to manage these events efficiently,
    ensuring they’re organized and processed in a timely manner.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**：设想我们的城市充满活动——音乐会、游行和公共通告。需要有一个系统来高效地管理这些活动，确保它们能够及时地组织和处理。'
- en: '`ConcurrentLinkedQueue` serves as the city’s event planner, a non-blocking,
    thread-safe queue that efficiently handles the flow of events. It’s like having
    a dedicated lane on the freeway for emergency vehicles; events are processed swiftly,
    ensuring the city’s life pulse remains vibrant and uninterrupted.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedQueue` 作为城市的活动策划者，是一个非阻塞、线程安全的队列，能够高效地处理事件流。它就像在高速公路上为紧急车辆预留的专用车道；事件被迅速处理，确保城市的生命脉搏保持活力和连续性。'
- en: 'Here is an example of the usage of `ConcurrentLinkedQueue`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `ConcurrentLinkedQueue` 使用的示例：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, events such as user signups are added to and processed from
    the queue, showcasing how `ConcurrentLinkedQueue` supports concurrent operations
    without locking, making event handling seamless and efficient.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户注册等事件被添加到队列中并从队列中处理，展示了 `ConcurrentLinkedQueue` 如何支持无锁的并发操作，使事件处理无缝且高效。
- en: Best practices for using Java’s concurrent collections
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Java 并发集合的最佳实践
- en: 'Here are the best practices for our consideration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要考虑的最佳实践：
- en: '`ConcurrentHashMap` is ideal for caches or frequent read/write operations,
    while `ConcurrentLinkedQueue` excels in FIFO event processing scenarios.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap` 对于缓存或频繁的读写操作非常理想，而 `ConcurrentLinkedQueue` 在 FIFO 事件处理场景中表现出色。'
- en: '`CopyOnWriteArrayList` or the non-blocking nature of `ConcurrentLinkedQueue`,
    to fully leverage their capabilities.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArrayList` 或 `ConcurrentLinkedQueue` 的无阻塞特性，以充分利用它们的性能。'
- en: '**Monitor performance**: Keep an eye on the performance of these collections,
    especially in high-load scenarios. Tools such as JMX or Prometheus can help identify
    bottlenecks or contention points, allowing for timely optimizations.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控性能**：关注这些集合的性能，尤其是在高负载场景下。工具如 JMX 或 Prometheus 可以帮助识别瓶颈或竞争点，从而实现及时优化。'
- en: By integrating Java’s concurrent collections into your distributed systems and
    microservices, you empower your applications to handle the complexities of concurrency
    with grace, ensuring data is managed efficiently and reliably amidst the bustling
    activity of your digital ecosystem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 Java 的并发集合集成到您的分布式系统和微服务中，您使您的应用程序能够优雅地处理并发复杂性，确保在您数字生态系统的繁忙活动中，数据得到高效和可靠的管理。
- en: Advanced locking strategies for tackling cloud concurrency
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决云并发的先进锁定策略
- en: This section delves into sophisticated locking strategies within Java, spotlighting
    mechanisms that extend well beyond basic synchronization techniques. These advanced
    methods provide developers with enhanced control and flexibility, crucial for
    addressing concurrency challenges in environments marked by high concurrency or
    intricate resource management needs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了 Java 中的复杂锁定策略，突出了超越基本同步技术的机制。这些高级方法为开发者提供了增强的控制和灵活性，这对于解决在高并发或复杂资源管理需求的环境中的并发挑战至关重要。
- en: Revisiting lock mechanisms with a cloud perspective
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从云的角度重新审视锁定机制
- en: 'Here’s a breakdown of how each advanced locking strategy can benefit cloud
    applications:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何让每种高级锁定策略为云应用带来益处的分解：
- en: '`ReentrantLock` surpasses traditional intrinsic locks by offering detailed
    control, including the ability to specify a timeout for lock attempts. This prevents
    threads from being indefinitely blocked, a vital feature for cloud applications
    dealing with shared resources such as cloud storage or database connections. For
    example, managing access to a shared cloud service can leverage `ReentrantLock`
    to ensure that if one task is waiting too long for a resource, other tasks can
    continue, enhancing overall application responsiveness.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock` 通过提供详细控制，包括指定锁定尝试的超时时间，超越了传统的内置锁。这防止了线程被无限期地阻塞，对于处理共享资源（如云存储或数据库连接）的云应用来说，这是一个至关重要的特性。例如，管理对共享云服务的访问可以利用
    `ReentrantLock` 确保如果一个任务等待资源时间过长，其他任务可以继续，从而提高整体应用程序的响应性。'
- en: '`ReadWriteLock` is pivotal in scenarios where cloud applications experience
    a high volume of read operations but fewer write operations, such as caching layers
    or configuration data stores. Utilizing `ReadWriteLock` can significantly improve
    performance by allowing concurrent reads, while still ensuring data integrity
    during writes.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云应用经历大量读取操作但较少写入操作的场景中，`ReadWriteLock` 至关重要，例如缓存层或配置数据存储。利用 `ReadWriteLock`
    可以通过允许并发读取来显著提高性能，同时在写入时确保数据完整性。
- en: '`StampedLock`, introduced in Java 8, is particularly suited for cloud applications
    due to its versatility in handling read and write access. It supports optimistic
    reading, which can reduce lock contention in read-heavy environments such as real-time
    data analytics or monitoring systems. The ability to upgrade from a read to a
    write lock is especially useful in cloud environments where data states can change
    frequently.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StampedLock` 在 Java 8 中引入，由于其处理读取和写入访问的灵活性，特别适合云应用。它支持乐观读取，可以在读取密集型环境（如实时数据分析或监控系统）中减少锁竞争。从读取锁升级到写入锁的能力在数据状态频繁变化的云环境中特别有用。'
- en: '`ReentrantLock`, offer a refined mechanism for managing inter-thread communication,
    crucial for orchestrating complex workflows in cloud applications. This approach
    is more advanced and flexible compared to the traditional wait-notify mechanism,
    facilitating efficient resource utilization and synchronization among distributed
    tasks.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock` 提供了一种管理线程间通信的精细机制，这对于在云应用中编排复杂的流程至关重要。与传统的等待-通知机制相比，这种方法更先进、更灵活，有助于提高分布式任务中的资源利用率和同步效率。'
- en: Consider a scenario managing comments in a cloud-based application, showcasing
    how to apply different locking mechanisms for optimizing both read-heavy and write-heavy
    operations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个管理基于云的应用程序中注释的场景，展示如何应用不同的锁定机制以优化读取密集型和写入密集型操作。
- en: 'Here is a code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码片段：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The key points from the preceding code example are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码示例中的关键点如下：
- en: '`ReadWriteLock` ensures that multiple threads can concurrently read comments
    without blocking each other, maximizing efficiency in high-read scenarios typical
    in cloud applications.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteLock` 确保多个线程可以同时读取注释而不会相互阻塞，在云应用中常见的读取密集型场景中最大化效率。'
- en: '`StampedLock` is used for adding comments, providing a mechanism to ensure
    that writes are performed with exclusive access, yet efficiently managed to minimize
    blocking.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StampedLock` 用于添加注释，提供了一种确保以独占访问方式执行写入的机制，同时高效管理以最小化阻塞。'
- en: Understanding and leveraging these advanced Java locking strategies empowers
    developers to address cloud-specific concurrency challenges effectively. By judiciously
    applying these techniques, cloud applications can achieve improved performance,
    scalability, and resilience, ensuring robust management of shared resources in
    complex, distributed cloud environments. Each locking mechanism serves a distinct
    purpose, allowing for tailored solutions based on the application’s requirements
    and the concurrency model it employs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并利用这些高级Java锁定策略使开发者能够有效地解决云特定的并发挑战。通过审慎地应用这些技术，云应用程序可以实现改进的性能、可扩展性和弹性，确保在复杂、分布式的云环境中对共享资源进行稳健的管理。每种锁定机制都服务于特定的目的，允许根据应用程序的要求和它采用的并发模型定制解决方案。
- en: Advanced concurrency management for cloud workflows
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云工作流的高级并发管理
- en: 'Cloud architectures introduce unique challenges in workflow management, necessitating
    precise coordination across multiple services and efficient resource allocation.
    This section advances the discussion from [*Chapter 2*](B20937_02.xhtml#_idTextAnchor048),
    *Introduction to Java’s Concurrency Foundations: Threads, Processes, and Beyond*,
    introducing sophisticated Java synchronizers suited for orchestrating complex
    cloud workflows and ensuring seamless inter-service communication.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 云架构在流程管理中引入了独特的挑战，需要跨多个服务进行精确的协调和高效的资源分配。本节从 [*第2章*](B20937_02.xhtml#_idTextAnchor048)，《Java并发基础：线程、进程及其他》的介绍中进一步讨论，引入了适合编排复杂云工作流并确保无缝服务间通信的复杂Java同步器。
- en: Sophisticated Java synchronizers for cloud applications
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用于云应用程序的复杂Java同步器
- en: This section explores advanced Java synchronizers that go beyond basic functionality,
    empowering you to orchestrate complex service startups with grace and efficiency.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了超越基本功能的Java同步器，使您能够优雅且高效地编排复杂的服务启动。
- en: Enhanced CountDownLatch for service initialization
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务初始化的增强型 CountDownLatch
- en: Beyond basic synchronization, an advanced **CountDownLatch** can facilitate
    the phased startup of cloud services, integrating health checks and dynamic dependencies.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，高级 **CountDownLatch** 可以促进云服务的分阶段启动，集成健康检查和动态依赖。
- en: 'Let’s delve into an enhanced example of using `CountDownLatch` for initializing
    cloud services, incorporating dynamic checks and dependencies resolution. This
    example illustrates how an advanced `CountDownLatch` mechanism can be employed
    to manage the complex startup sequence of cloud services, ensuring that all initialization
    tasks are completed, considering service dependencies and health checks:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨使用 `CountDownLatch` 初始化云服务的增强示例，包括动态检查和依赖关系解决。此示例说明了如何使用高级 `CountDownLatch`
    机制来管理云服务的复杂启动序列，确保所有初始化任务都已完成，考虑到服务依赖性和健康检查：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The key points from the preceding code example are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码示例的关键点如下：
- en: '`CloudServiceInitializer` class encapsulates the logic for initializing a predefined
    number of services, defined by `TOTAL_SERVICES`. It creates and starts a separate
    thread for each service initialization task, passing a shared `CountDownLatch`
    to each.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloudServiceInitializer` 类封装了初始化预定义数量服务的逻辑，这些服务由 `TOTAL_SERVICES` 定义。它为每个服务初始化任务创建并启动一个单独的线程，并将共享的
    `CountDownLatch` 传递给每个线程。'
- en: '`ServiceInitializer`: Each instance of `ServiceInitializer` represents a task
    to initialize a particular service. It simulates the initialization process with
    a random sleep duration. Upon completion, it decrements the latch’s count using
    `countDown()`, signaling that it has finished its initialization task.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceInitializer`：`ServiceInitializer` 的每个实例代表初始化特定服务的任务。它通过随机睡眠持续时间模拟初始化过程。完成初始化后，它使用
    `countDown()` 减少latch的计数，表示其初始化任务已完成。'
- en: '`awaitServicesInitialization` method in `CloudServiceInitializer` waits for
    the count of `CountDownLatch` to reach zero, indicating that all services have
    been initialized. This method blocks the main thread until all services report
    readiness, after which it prints a message indicating that the system is ready
    to accept requests.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloudServiceInitializer` 中的 `awaitServicesInitialization` 方法等待 `CountDownLatch`
    的计数达到零，这表示所有服务都已初始化。此方法阻塞主线程，直到所有服务报告就绪，之后它会打印一条消息，表明系统已准备好接受请求。'
- en: '`CountDownLatch` ensuring that the main application flow proceeds only after
    all services are up and running. This model is particularly useful in cloud environments
    where services may have interdependencies or require health checks before they
    can be deemed ready.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`确保主应用程序流程仅在所有服务都启动并运行后才继续。这种模型在云环境中特别有用，因为服务可能存在相互依赖性或需要在被视为准备就绪之前进行健康检查。'
- en: This enhanced `CountDownLatch` usage showcases how Java concurrency utilities
    can be effectively applied to manage complex initialization sequences in cloud
    applications, ensuring robust startup behavior and dynamic dependency management.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种增强的`CountDownLatch`使用展示了如何有效地应用Java并发工具来管理云应用程序中的复杂初始化序列，确保稳健的启动行为和动态依赖管理。
- en: Semaphore for controlled resource access
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于受控资源访问的信号量
- en: In cloud environments, **Semaphore** can be fine-tuned to manage access to shared
    cloud resources such as databases or third-party APIs, preventing overloading
    while maintaining optimal throughput. This mechanism is critical in environments
    where resource constraints are dynamically managed based on current load and **service-level**
    **agreements** (**SLAs**).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，**信号量**可以微调以管理对共享云资源（如数据库或第三方API）的访问，防止过载同时保持最佳吞吐量。这种机制在基于当前负载和**服务级别协议**（**SLAs**）动态管理资源约束的环境中至关重要。
- en: 'Here’s an example of how Semaphore can be used to coordinate access to a shared
    data resource in a cloud environment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明如何在云环境中使用信号量来协调对共享数据资源的访问：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the code explanation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码解释：
- en: '`Semaphore`: It uses a **Semaphore** object with limited permits (configurable
    via constructor) to control access'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore`：它使用具有有限许可（可通过构造函数配置）的**信号量**对象来控制访问。'
- en: '`acquire()`: Threads trying to access data call `acquire()`, blocking if no
    permits are available'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acquire()`：尝试访问数据的线程调用`acquire()`，如果没有可用许可则阻塞。'
- en: '`System.out.println` and sleep)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.out.println`和睡眠)'
- en: '`release()`: After accessing data, `release()` is called to return the permit
    and allow other threads to acquire it'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release()`：在访问数据后，调用`release()`以返回许可并允许其他线程获取它。'
- en: '`accessData`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accessData`'
- en: CyclicBarrier for batch processing
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CyclicBarrier用于批处理
- en: 'Imagine a complex data pipeline in the cloud, where processing happens in distinct
    stages across distributed services. Ensuring each stage is completed successfully
    before moving on is crucial. This is where **CyclicBarrier** shines as a powerful
    tool for coordinating batch-processing workflows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个复杂的云中数据管道，处理在分布式服务的不同阶段发生。在继续之前确保每个阶段成功完成至关重要。这就是**CyclicBarrier**作为协调批处理工作流程的强大工具大放异彩的地方：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The key points from the preceding code example are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码示例的关键点如下：
- en: '`CyclicBarrier`: Utilizes `CyclicBarrier` to synchronize batch processing stages.
    The barrier is set with a specific number of permits (`batchSize`) and an optional
    action to perform when all threads reach the barrier.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`：利用`CyclicBarrier`同步批处理阶段。屏障设置为特定的许可数（`batchSize`）和当所有线程达到屏障时执行的可选操作。'
- en: '`barrier.await()`, blocking until the specified number of threads (`batchSize`)
    reaches this point, ensuring all parts of the batch are processed before moving
    on'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`barrier.await()`，阻塞直到指定的线程数（`batchSize`）达到此点，确保在继续之前处理完批次的全部部分。'
- en: '**Shared data access**: While this example doesn’t directly manipulate shared
    data, it simulates processing and synchronization points. In real scenarios, threads
    would operate on shared resources here.*   `CyclicBarrier` initialization executes
    once all participating threads reach the barrier. It marks the completion of a
    batch stage and allows for collective post-processing or setup before the next
    stage begins.*   `BatchProcessingWorkflow` with a `CyclicBarrier` configured for
    5 permits (matching `batchSize`).*   **Concurrent execution**: It starts 10 threads
    to simulate concurrent processing of batch parts. Since the barrier is set for
    5 permits, it demonstrates two rounds of batch processing, waiting for 5 parts
    to complete before proceeding in each round.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享数据访问**：虽然此示例没有直接操作共享数据，但它模拟了处理和同步点。在实际场景中，线程将在这里操作共享资源。*   `CyclicBarrier`初始化在所有参与线程达到屏障时执行一次。它标志着批次阶段的完成，并在下一阶段开始之前允许进行集体后处理或设置。*   `BatchProcessingWorkflow`配置了5个许可的`CyclicBarrier`（与`batchSize`匹配）。*   **并发执行**：它启动10个线程来模拟批处理部分的并发处理。由于屏障设置为5个许可，它展示了两个批处理轮次，在每个轮次中等待5个部分完成后再继续。'
- en: This code structure is ideal for scenarios requiring precise coordination between
    threads, like in distributed systems or complex data processing pipelines, where
    each processing stage must be completed across all services before moving to the
    next stage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码结构非常适合需要线程之间精确协调的场景，如分布式系统或复杂的数据处理管道，每个处理阶段必须在所有服务完成之前才能进入下一阶段。
- en: Utilizing tools for diagnosing concurrency problems
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用诊断并发问题的工具
- en: In the world of Java development, especially when navigating the complexities
    of cloud-based applications, understanding and diagnosing concurrency issues becomes
    a critical skill. Like detectives at a crime scene, developers often need to piece
    together evidence to solve the mysteries of application slowdowns, freezes, or
    unexpected behavior. This is where thread dumps and lock monitors come into play.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java开发的世界里，尤其是在导航基于云的应用程序的复杂性时，理解和诊断并发问题成为一项关键技能。就像犯罪现场的侦探一样，开发者经常需要拼凑证据来解决应用程序减速、冻结或意外行为之谜。这就是线程转储和锁监控器发挥作用的地方。
- en: Thread dumps – the developer’s snapshot
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程转储——开发者的快照
- en: 'Imagine you’re walking through a bustling marketplace – each stall and shopper
    representing threads within a **Java virtual machine** (**JVM**). Suddenly, everything
    freezes. A thread dump is like taking a panoramic photo of this scene, capturing
    every detail: who’s talking to whom, who’s waiting in line, and who’s just browsing.
    It’s a moment-in-time snapshot that reveals the state of all threads running in
    the JVM, including their current actions, who they’re waiting for, and who’s blocking
    their path.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在穿过一个熙熙攘攘的市场——每个摊位和购物者都代表着**Java虚拟机**（**JVM**）中的线程。突然，一切停止了。线程转储就像为这个场景拍摄全景照片，捕捉每一个细节：谁在和谁交谈，谁在排队等待，谁正在浏览。这是一个时间点的快照，揭示了JVM中所有运行线程的状态，包括它们当前的动作、它们在等待什么，以及谁阻碍了它们的道路。
- en: 'Here are the features of thread dumps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是线程转储的特点：
- en: '**Capturing the moment**: Generating these insightful snapshots can be done
    in various ways, each like choosing the right lens for your camera'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕捉瞬间**：以各种方式生成这些有洞察力的快照，就像为你的相机选择合适的镜头一样'
- en: '`jstack`, a tool as handy as a Swiss army knife, allows developers to generate
    a thread dump from the command line'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jstack`，一个像瑞士军刀一样方便的工具，允许开发者从命令行生成线程转储'
- en: '**IDEs:** Modern IDEs, such as IntelliJ IDEA or Eclipse, come equipped with
    built-in tools or plugins for generating and analyzing thread dumps'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDEs**：现代IDE，如IntelliJ IDEA或Eclipse，都配备了生成和分析线程转储的内置工具或插件'
- en: '**JVM options**: For those who prefer setting traps to catch the moment automatically,
    configuring the JVM to generate thread dumps under specific conditions is like
    installing a high-tech security camera system in the marketplace'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM选项**：对于那些喜欢自动捕捉瞬间的陷阱设置者，将JVM配置为在特定条件下生成线程转储，就像在市场上安装高科技安全监控系统一样'
- en: Real-world cloud adventures
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实世界的云冒险
- en: Consider a cloud-based Java application, akin to a sprawling marketplace spread
    across multiple cloud regions. This application begins to experience intermittent
    slowdowns, much like congestion happening at unpredictable intervals. The development
    team suspects deadlocks or thread contention but needs evidence.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个基于云的Java应用程序，就像一个遍布多个云区域的庞大市场。该应用程序开始出现间歇性减速，就像不可预测时间间隔发生的拥堵一样。开发团队怀疑存在死锁或线程竞争，但需要证据。
- en: 'The investigation process involves the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 调查过程包括以下内容：
- en: '**Monitoring and alerting**: First, set up surveillance using cloud-native
    tools or third-party solutions'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和警报**：首先，使用云原生工具或第三方解决方案建立监控'
- en: '**Generating thread dumps**: Upon an alert, akin to a congestion notification,
    they use cloud-native tools such as CloudWatch with AWS Lambda, Azure Monitor
    with Azure Functions, or Stackdriver logging with Google Cloud Monitoring to take
    snapshots within the affected cloud *regions* (containers)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成线程转储**：在收到警报，类似于拥堵通知时，他们使用云原生工具，如AWS Lambda的CloudWatch、Azure Functions的Azure
    Monitor或Google Cloud Monitoring的Stackdriver日志，在受影响的云**区域**（容器）内进行快照'
- en: '**Analyzing the evidence**: With snapshots in hand, the team analyzes them
    to identify any threads stuck in a deadlock, to see where the congestion started'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析证据**：手握快照，团队分析它们以识别任何陷入死锁的线程，以查看拥堵是从哪里开始的'
- en: Lock monitors – the guardians of synchronization
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁监控器——同步的守护者
- en: '**Lock monitors** are like sentries guarding access to resources within your
    application. Tools such as Java VisualVM and JConsole act as the central command
    center, providing real-time insights into thread lock dynamics, memory usage,
    and CPU usage.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁监视器**就像守卫着您应用程序中资源访问的哨兵。例如，Java VisualVM 和 JConsole 这样的工具充当中央指挥中心，提供对线程锁定动态、内存使用和CPU使用的实时洞察。'
- en: Imagine your microservice architecture experiencing latency spikes like a flash
    mob suddenly flooding the marketplace. With Java VisualVM, you can connect to
    the affected service’s JVM and see threads waiting in line, blocked by a single
    lock. This real-time observation helps you identify bottlenecks and take immediate
    action, like dispatching security to manage the crowd.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的微服务架构像突然涌入市场的群体一样，经历了延迟峰值。使用Java VisualVM，您可以连接到受影响服务的JVM，并看到等待在队列中的线程，它们被单个锁阻塞。这种实时观察有助于您识别瓶颈并立即采取行动，比如派遣安全人员管理人群。
- en: The takeaway after exploring thread dumps and lock monitors is that they maintain
    order and performance. By utilizing thread dumps and lock monitors, you can transform
    the chaotic scenes of concurrency issues into orderly queues. This ensures each
    thread completes its tasks efficiently, keeping your cloud applications running
    smoothly and delivering a positive user experience.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 探索线程转储和锁监视器后的收获是，它们维护了秩序和性能。通过利用线程转储和锁监视器，您可以将并发问题的混乱场景转化为有序队列。这确保了每个线程都能高效地完成任务，使您的云应用运行顺畅，并提供良好的用户体验。
- en: Remember, these tools are just a starting point. Combine them with your understanding
    of your application’s architecture and behavior for even more effective troubleshooting!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些工具只是起点。结合您对应用程序架构和行为的理解，可以更有效地进行故障排除！
- en: The quest for clarity – advanced profiling techniques
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻求清晰 – 高级分析技术
- en: 'The vast landscapes of cloud-native applications, with their intricate networks
    of microservices, can pose challenges for traditional profiling methods. These
    methods often struggle to navigate the distributed nature and complex interactions
    within these environments. Enter advanced profiling techniques, acting as powerful
    tools to shed light on performance bottlenecks and optimize your cloud applications.
    Here are three powerful techniques to demystify your cloud journeys:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用的广阔天地，其微服务错综复杂的网络可能会对传统的分析方法构成挑战。这些方法通常难以应对这些环境中的分布式特性和复杂的交互。这时，先进的分析技术便应运而生，它们作为强大的工具，可以帮助我们揭示性能瓶颈并优化您的云应用。以下是三种强大的技术，可以帮助您揭开云之旅的神秘面纱：
- en: '**Distributed tracing – illuminating the request journey**: Think of distributed
    tracing as charting the stars. While traditional profiling shines a light on individual
    nodes, tracing follows requests as they hop between microservices, revealing hidden
    latency bottlenecks and intricate service interactions. Imagine the following:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式追踪 – 揭示请求之旅**：将分布式追踪想象成绘制星星。虽然传统的分析关注于单个节点，但追踪则跟随请求在微服务之间跳跃，揭示隐藏的延迟瓶颈和复杂的服务交互。想象以下场景：'
- en: '**Pinpointing slow service calls**: Identify which service is causing delays
    and focus optimization efforts'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定位缓慢的服务调用**：确定哪个服务导致了延迟，并集中优化努力'
- en: '**Visualizing request flow**: Understand the intricate dance of microservices
    and identify potential bottlenecks'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化请求流**：理解微服务的复杂舞蹈并识别潜在的瓶颈'
- en: '**Service-level aggregation – zooming out for the big picture**: Imagine profiling
    data as scattered islands. Service-level aggregation gathers them into a cohesive
    view, showing how each service contributes to overall performance. It’s like looking
    at the forest, not just the trees:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务级别聚合 – 从宏观角度观察整体情况**：将分析数据想象成散落的岛屿。服务级别聚合将它们汇集成一个统一的视图，展示每个服务如何贡献于整体性能。这就像观察森林，而不仅仅是树木：'
- en: '**Spot service performance outliers**: Quickly identify services impacting
    overall application responsiveness'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发现服务性能异常值**：快速识别影响整体应用程序响应性的服务'
- en: '**Prioritize optimization efforts**: Focus resources on services with the most
    room for improvement'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先优化努力**：将资源集中在改进空间最大的服务上'
- en: '**Automated anomaly detection – predicting performance storms**: Leveraging
    machine learning, automated anomaly detection acts as a weather forecaster for
    your application. It scans for subtle shifts in performance patterns, alerting
    you to potential issues before they cause major disruptions:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动异常检测 – 预测性能风暴**：利用机器学习，自动异常检测充当你应用程序的天气预报员。它扫描性能模式中的微妙变化，在它们造成重大破坏之前提醒你潜在的问题：'
- en: '**Catch performance regressions early**: Proactively address issues before
    they impact users.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽早捕捉性能退化**：在问题影响用户之前主动解决问题。'
- en: '**Reduce time spent troubleshooting**: Focus your efforts on confirmed problems,
    not chasing ghosts.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少故障排除时间**：将你的精力集中在已确认的问题上，而不是追逐幽灵。'
- en: These techniques are just the starting point. Choosing the right tool for your
    specific needs and workflow is crucial.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术只是起点。选择适合你特定需求和流程的正确工具至关重要。
- en: Weaving the web – integrating profiling tools into CI/CD pipelines
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将网络编织在一起——将分析工具集成到 CI/CD 管道中
- en: As your cloud application evolves, continuous performance optimization is key.
    Embedding profiling tools into your CI/CD pipeline is akin to giving your application
    a heart that beats in rhythm with performance best practices.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的云应用程序的发展，持续的性能优化至关重要。将分析工具嵌入到 CI/CD 管道中，就像给你的应用程序植入一个与性能最佳实践同步跳动的心脏。
- en: 'Think of your tools as weapons in your performance optimization arsenal, and
    consider the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的工具视为性能优化武器库中的武器，并考虑以下因素：
- en: '**Seamless integration**: Select tools that integrate smoothly into your existing
    CI/CD workflow'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无缝集成**：选择能够顺畅集成到现有 CI/CD 工作流程中的工具'
- en: '**Automation capability**: Opt for tools that support automated data collection
    and analysis'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化能力**：选择支持自动化数据收集和分析的工具'
- en: '**Actionable insights**: Ensure the tools provide clear, actionable insights
    to guide optimization efforts'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可操作见解**：确保工具提供清晰、可操作的建议，以指导优化工作'
- en: 'Some popular options include the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的选项包括以下：
- en: '**Distributed tracing tools**: Jaeger and Zipkin'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式跟踪工具**：Jaeger 和 Zipkin'
- en: '**Service-level profiling tools**: JProfiler and Dynatrace'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务级分析工具**：JProfiler 和 Dynatrace'
- en: '**CI/CD integration tools**: Jenkins and GitLab CI'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD 集成工具**：Jenkins 和 GitLab CI'
- en: In addition to these tools, consider tools such as Grafana for visualizing performance
    data, and leverage machine learning-powered insights from tools such as Dynatrics
    and New Relic.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具之外，考虑使用 Grafana 等工具来可视化性能数据，并利用 Dynatrics 和 New Relic 等工具的机器学习驱动的见解。
- en: Continuously refine your tools and practices based on experience and evolving
    needs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验和不断变化的需求，持续改进你的工具和实践。
- en: By weaving performance into the fabric of your CI/CD pipeline, you can ensure
    your cloud applications operate at their peak, delivering consistent and exceptional
    performance for your users.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将性能编织到你的 CI/CD 管道中，你可以确保你的云应用程序在顶峰运行，为用户提供一致和卓越的性能。
- en: In the following sections, we’ll delve deeper into specific techniques such
    as service mesh integration and APM solutions, further enriching your performance
    optimization toolbox.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将更深入地探讨特定技术，如服务网格集成和 APM 解决方案，进一步丰富你的性能优化工具箱。
- en: Service mesh and APM – your cloud performance powerhouse
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格和 APM – 你的云性能动力源
- en: 'Imagine your cloud application as a bustling marketplace, with microservices
    such as vendors conducting transactions. Without a conductor, things get chaotic.
    Service mesh, such as Istio and Linkerd, ensures each microservice plays its part
    flawlessly:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你的云应用程序就像一个繁忙的市场，其中微服务如商家进行交易。没有指挥者，事情会变得混乱。服务网格，如 Istio 和 Linkerd，确保每个微服务都能完美地发挥作用：
- en: '**Transparent observability**: See how data flows between services, identify
    bottlenecks, and debug issues, all without modifying your code'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明的可观察性**：查看数据在服务之间的流动情况，识别瓶颈，调试问题，而无需修改你的代码'
- en: '**Traffic management**: Route requests efficiently, avoiding overloads and
    ensuring smooth performance even during peak traffic'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量管理**：高效路由请求，避免过载，即使在高峰流量期间也能确保平稳的性能'
- en: '**Consistent policy enforcement**: Set rules (e.g., retry policies, rate limits)
    globally for all services, simplifying management and guaranteeing predictable
    behavior'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的策略执行**：为所有服务全局设置规则（例如，重试策略、速率限制），简化管理并保证可预测的行为'
- en: 'Now, imagine a skilled musician analyzing the marketplace soundscape. That’s
    what APM solutions such as Dynatrace, New Relic, and Elastic APM do:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一位熟练的音乐家分析市场声音景观。这正是 APM 解决方案，如 Dynatrace、New Relic 和 Elastic APM 所做的：
- en: '**Observability beyond monitoring**: Go beyond basic metrics to correlate logs,
    traces, and metrics for a holistic view of application health and performance'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超越监控的可观察性**：超越基本指标，关联日志、跟踪和指标，以获得应用程序健康和性能的整体视图。'
- en: '**AI-powered insights**: Leverage machine learning to predict issues, diagnose
    problems faster, and suggest optimizations, keeping your application performing
    at its best'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AI 驱动的洞察力**：利用机器学习来预测问题、更快地诊断问题并提出优化建议，以保持您的应用程序性能最佳。'
- en: '**Business impact analysis**: Understand how performance affects user satisfaction
    and business outcomes, enabling data-driven decisions'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务影响分析**：了解性能如何影响用户满意度和业务成果，从而实现数据驱动的决策。'
- en: By combining service mesh and APM, you gain a comprehensive performance powerhouse
    for your cloud applications.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合服务网格和 APM，您为您的云应用程序获得了一个全面的性能动力源。
- en: Incorporating concurrency frameworks
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成并发框架
- en: In the grand tapestry of Java application development, where the threads of
    concurrency and distributed systems intertwine, frameworks such as Akka and Vert.x
    emerge as the artisans, sculpting scalable, resilient, and responsive systems
    from the raw fabric of code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 应用程序开发的宏伟画卷中，并发和分布式系统的线索交织在一起，框架如 Akka 和 Vert.x 作为工匠出现，从原始的代码材料中塑造出可扩展、弹性且响应迅速的系统。
- en: Akka – building resilient real-time systems with actors
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Akka – 使用演员构建具有弹性的实时系统
- en: Imagine a bustling marketplace, where merchants and customers work independently
    yet collaborate seamlessly. This analogy captures the essence of **Akka**, a concurrency
    framework empowering you to build scalable, resilient, and responsive real-time
    systems in Java.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个熙熙攘攘的市场，商人和顾客独立工作但协作无间。这个类比捕捉了 **Akka** 的精髓，这是一个并发框架，让您能够在 Java 中构建可扩展、弹性且响应迅速的实时系统。
- en: Actors rule the roost in Akka’s domain. Actors are sovereign entities, each
    tasked with their own responsibilities, communicating through immutable messages.
    This design sidesteps the quagmires of shared-memory concurrency, rendering the
    system more comprehensible and less prone to errors.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 演员在 Akka 的领域中占据主导地位。演员是主权实体，每个演员都有自己的职责，通过不可变的消息进行通信。这种设计避开了共享内存并发的泥潭，使系统更易于理解且更不易出错。
- en: 'Here’s what makes Akka stand out:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使 Akka 独具特色的原因：
- en: '**Actor-based design**: Each actor handles its own tasks independently, simplifying
    concurrent programming and reducing the risk of errors.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于演员的设计**：每个演员独立处理自己的任务，简化了并发编程并降低了出错的风险。'
- en: '**Location transparency**: Actors can reside anywhere within your cluster,
    allowing you to scale your application dynamically across nodes.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置透明性**：演员可以存在于您的集群中的任何位置，允许您动态地跨节点扩展应用程序。'
- en: '**Built-in resilience**: Akka embraces the *let it crash* philosophy. If an
    actor fails, it’s automatically restarted, ensuring your system remains highly
    available.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置的弹性**：Akka 接受“让它崩溃”的哲学。如果演员失败，它会自动重启，确保您的系统始终保持高度可用性。'
- en: Akka shines in scenarios where you need to process data streams in real time.
    Imagine receiving data from various sources such as sensors or social media feeds.
    Using Akka actors, you can efficiently process each data point independently,
    achieving high throughput and low latency.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 在需要实时处理数据流的情况下表现出色。想象一下从各种来源接收数据，如传感器或社交媒体流。使用 Akka 演员可以高效地独立处理每个数据点，实现高吞吐量和低延迟。
- en: In order to run an Akka project with Maven, you’ll need to set up your `pom.xml`
    file to include dependencies for Akka actors and any other Akka modules you plan
    to use.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Maven 运行 Akka 项目，您需要设置您的 `pom.xml` 文件以包含 Akka 演员以及您计划使用的任何其他 Akka 模块依赖项。
- en: 'Include the `akka-actor-typed` library in your `pom.xml` file under `<dependencies>`
    to use Akka Typed actors:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pom.xml` 文件的 `<dependencies>` 下包含 `akka-actor-typed` 库以使用 Akka Typed 演员：
- en: '[PRE10]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Akka uses SLF4J for logging. You must add an SLF4J implementation, such as
    Logback, as a dependency:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 使用 SLF4J 进行日志记录。您必须添加一个 SLF4J 实现，例如 Logback，作为依赖项：
- en: '[PRE11]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the simplified code to demonstrate how Akka is used for a data processing
    project:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是简化后的代码，演示了 Akka 在数据处理项目中的应用：
- en: '[PRE12]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code snippet demonstrates how Akka actors can be used for simple data
    processing. Here’s a breakdown of how it works:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段演示了如何使用 Akka 演员进行简单的数据处理。以下是它的工作原理分解：
- en: '`DataProcessor` class extends `AbstractBehavior<DataProcessor.DataCommand>`,
    which is a base class provided by Akka for defining actors'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataProcessor` 类扩展了 `AbstractBehavior<DataProcessor.DataCommand>`，这是 Akka
    提供的一个基类，用于定义角色'
- en: The `DataCommand` interface serves as the base type for the messages that the
    `DataProcessor` actor can receive
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataCommand` 接口是 `DataProcessor` 角色可以接收的消息的基础类型'
- en: '`createReceive()` method defines the behavior of the actor when it receives
    messages*   It uses the `newReceiveBuilder()` to create a `Receive` object that
    specifies how the actor should handle different message types*   `ProcessData`
    message, the `onProcessData()` method is invoked*   This method contains the logic
    for processing the data received in the message*   `onProcessData()` method includes
    error handling using a try-catch block*   If an exception occurs during data processing,
    the actor’s behavior is changed to `Behaviors.stopped()`, which stops the actor'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createReceive()` 方法定义了角色在接收到消息时的行为*   它使用 `newReceiveBuilder()` 创建一个 `Receive`
    对象，该对象指定了角色应该如何处理不同类型的消息*   `ProcessData` 消息，将调用 `onProcessData()` 方法*   此方法包含处理消息中接收到的数据的逻辑*   `onProcessData()`
    方法使用 try-catch 块进行错误处理*   如果在数据处理过程中发生异常，角色的行为将更改为 `Behaviors.stopped()`，这将停止角色'
- en: Akka’s actor model provides a way to structure the application around individual
    units of computation (actors) that can process messages concurrently and independently.
    In the context of processing real-time data streams, Akka actors offer benefits
    such as concurrency, isolation, asynchronous communication, and scalability.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 的actor模型提供了一种方法，可以在单个计算单元（actor）周围构建应用程序，这些actor可以并发和独立地处理消息。在处理实时数据流的情况下，Akka
    actors提供了并发、隔离、异步通信和可扩展性等好处。
- en: This is a simplified example. Real-world scenarios involve more complex data
    structures, processing logic, and potential interactions with other actors.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的示例。现实世界的场景涉及更复杂的数据结构、处理逻辑以及与其他角色的潜在交互。
- en: In the next section, we’ll explore Vert.x, another powerful framework for building
    reactive applications in Java. We’ll also delve into advanced testing and debugging
    techniques crucial for mastering concurrency in cloud environments.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 Vert.x，这是另一个用于在 Java 中构建反应式应用程序的强大框架。我们还将深入研究对掌握云环境中并发性至关重要的高级测试和调试技术。
- en: Vert.x – embracing the reactive paradigm for web applications
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vert.x – 拥抱面向 Web 应用程序的反应式范式
- en: Imagine a vibrant city humming with activity, its residents and systems constantly
    interacting. **Vert.x** embodies this dynamic spirit, enabling you to build reactive,
    responsive, and scalable web applications in Java, JavaScript, Kotlin, and more.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个充满活力的城市，其居民和系统不断互动。**Vert.x** 体现了这种动态精神，使您能够在 Java、JavaScript、Kotlin 等语言中构建反应式、响应性和可扩展的
    Web 应用程序。
- en: 'The key highlights of Vert.x are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 的关键亮点如下：
- en: '**Event-driven magic**: Unlike traditional approaches, Vert.x revolves around
    a non-blocking event loop, handling multiple requests simultaneously, making it
    ideal for I/O-intensive tasks.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动魔法**：与传统方法不同，Vert.x 围绕一个非阻塞的事件循环，可以同时处理多个请求，使其非常适合 I/O 密集型任务。'
- en: '**Polyglot prowess**: Ditch language limitations! Vert.x embraces diverse tongues,
    from Java and JavaScript to Python and Ruby, empowering you to choose the tool
    that best suits your project and team.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多语言能力**：摆脱语言限制！Vert.x 拥抱多种语言，从 Java 和 JavaScript 到 Python 和 Ruby，让您能够选择最适合您项目和团队的工具。'
- en: '**Reactive revolution**: Vert.x champions the reactive programming paradigm,
    fostering applications that are resilient, elastic, and responsive to user interactions
    and system changes.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反应式革命**：Vert.x 倡导反应式编程范式，培养出对用户交互和系统变化具有弹性、可扩展性和响应性的应用程序。'
- en: '**Microservices made easy**: Vert.x shines in the microservices ecosystem.
    Its lightweight, modular architecture and event-driven nature make it a perfect
    fit for building independent, yet interconnected, microservices that seamlessly
    collaborate.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务变得简单**：Vert.x 在微服务生态系统中表现出色。其轻量级、模块化架构和事件驱动特性使其非常适合构建独立但互联的微服务，这些微服务可以无缝协作。'
- en: 'Let’s dive into a simplified example: creating an HTTP server. This server
    will greet every request with a cheerful *Hello, World!*, showcasing Vert.x’s
    straightforward approach to web development:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一个简化的示例：创建一个 HTTP 服务器。这个服务器将对每个请求以欢快的 *Hello, World!* 来问候，展示了 Vert.x 在
    Web 开发中的直接方法：
- en: '`pom.xml` file:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pom.xml` 文件：'
- en: '[PRE13]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`AbstractVerticle`, the fundamental unit of Vert.x execution:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AbstractVerticle`，Vert.x 执行的基本单元：'
- en: '[PRE14]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, we create a `VertxHttpServerExample` class that extends `AbstractVerticle`,
    which is the base class for Vert.x verticles:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本例中，我们创建了一个 `VertxHttpServerExample` 类，它扩展了 `AbstractVerticle`，这是 Vert.x verticles
    的基类：
- en: In the `start()` method, we create an instance of `HttpServer` using `vertx.createHttpServer()`.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `start()` 方法中，我们使用 `vertx.createHttpServer()` 创建了一个 `HttpServer` 实例。
- en: We set up a request handler using `server.requestHandler()` to handle incoming
    HTTP requests. In this example, we check the request path and respond with `"Hello,
    Vert.x!"` for the `"/hello"` path and a `"Not Found"` response for any other path.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `server.requestHandler()` 设置一个请求处理程序来处理传入的 HTTP 请求。在本例中，我们检查请求路径，对于 `"/hello"`
    路径返回 `"Hello, Vert.x!"`，对于任何其他路径返回 `"Not Found"`。
- en: We start the server using `server.listen()`, specifying the port number (`8080`
    in this case) and a handler to handle the result of the server startup.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `server.listen()` 启动服务器，指定端口号（在本例中为 `8080`）以及一个处理程序来处理服务器启动的结果。
- en: In the `main()` method, we create an instance of `Vertx` and deploy our `VertxHttpServerExample`
    verticle using `vertx.deployVerticle()`.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 方法中，我们创建了一个 `Vertx` 实例，并使用 `vertx.deployVerticle()` 将我们的 `VertxHttpServerExample`
    verticle 部署。
- en: 'To run this example, compile the Java file and run the main class. Once the
    server is started, you can access it in your web browser or using a tool such
    as `cURL: curl http://localhost:8080/hello`, which will output: *Hello, Vert.x!*.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，编译 Java 文件并运行主类。一旦服务器启动，您可以通过 Web 浏览器或使用 `cURL` 等工具访问它：`curl http://localhost:8080/hello`，它将输出：*Hello,
    Vert.x!*。
- en: This simple example highlights Vert.x’s ability to quickly build web applications.
    Its event-driven approach and polyglot nature make it a versatile tool for modern
    web development, empowering you to create flexible, scalable, and responsive solutions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例突出了 Vert.x 快速构建 Web 应用程序的能力。其事件驱动方法和多语言特性使其成为现代 Web 开发的多功能工具，让您能够创建灵活、可伸缩和响应式的解决方案。
- en: Both Akka and Vert.x offer unique strengths for building concurrent and distributed
    applications. While Akka excels in real-time processing with actors, Vert.x shines
    in web development with its event-driven and polyglot nature. Explore these frameworks
    and discover which aligns best with your specific needs and preferences.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 和 Vert.x 都为构建并发和分布式应用程序提供了独特的优势。虽然 Akka 在使用 actors 进行实时处理方面表现出色，但 Vert.x
    在其事件驱动和多语言特性方面在 Web 开发中脱颖而出。探索这些框架，并发现哪个最适合您的具体需求和偏好。
- en: In the following sections, we’ll delve deeper into advanced testing and debugging
    techniques for ensuring the robustness of your cloud-based Java applications.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入了解确保云端 Java 应用程序健壮性的高级测试和调试技术。
- en: Mastering concurrency in cloud-based Java applications – testing and debugging
    tips
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云端 Java 应用程序中的并发掌握——测试和调试技巧
- en: Building robust, scalable Java applications in cloud environments demands expertise
    in handling concurrency challenges. Here are key strategies and tools to elevate
    your testing and debugging game.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在云端环境中构建健壮、可伸缩的 Java 应用程序需要处理并发挑战的专业知识。以下是一些关键策略和工具，以提升您的测试和调试水平。
- en: 'The key testing strategies are as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的测试策略如下：
- en: '**Unit testing with concurrency**: Use frameworks such as JUnit to test individual
    units with concurrent scenarios. Mocking frameworks help simulate interactions
    for thorough testing.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发单元测试**：使用 JUnit 等框架测试具有并发场景的各个单元。模拟框架有助于模拟交互以进行彻底的测试。'
- en: '**Integration testing for microservices**: Tools such as Testcontainers and
    WireMock help test how interconnected components handle concurrent loads in distributed
    architectures.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务的集成测试**：如 Testcontainers 和 WireMock 等工具帮助测试分布式架构中相互连接的组件如何处理并发负载。'
- en: '**Stress and load testing**: Tools such as Gatling and JMeter push your applications
    to their limits, revealing bottlenecks and scalability issues under high concurrency.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力和负载测试**：如 Gatling 和 JMeter 等工具将您的应用程序推向极限，揭示在高并发下的瓶颈和可伸缩性问题。'
- en: '**Chaos engineering for resilience**: Introduce controlled chaos with tools
    such as Netflix’s Chaos Monkey to test how your application handles failures and
    extreme conditions, fostering resilience.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混沌工程以提高弹性**：使用 Netflix 的 Chaos Monkey 等工具引入可控的混乱，以测试您的应用程序如何处理故障和极端条件，培养弹性。'
- en: 'Here are the best practices for robust concurrency:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是健壮并发的最佳实践：
- en: '**Embrace immutability**: Design with immutable objects whenever possible to
    avoid complexity and ensure thread safety'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥抱不可变性**：尽可能使用不可变对象进行设计，以避免复杂性并确保线程安全'
- en: '**Use explicit locking**: Go for explicit locks over synchronized blocks for
    finer control over shared resources and to prevent deadlocks'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用显式锁定**：选择显式锁而不是同步块，以对共享资源有更精细的控制，并防止死锁'
- en: '`java.util.concurrent` package for effective thread, task, and synchronization
    management'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包用于有效管理线程、任务和同步'
- en: '**Stay up to date**: Continuously learn about the latest advancements in Java
    concurrency and cloud computing to adapt and improve your practices'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持最新**：持续学习Java并发和云计算的最新进展，以适应和改进你的实践'
- en: By combining these strategies, you can build cloud-based Java applications that
    are not only powerful but also resilient, scalable, and ready to handle the demands
    of modern computing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这些策略，你可以构建不仅强大而且具有弹性、可扩展且能够处理现代计算需求的云基础Java应用程序。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a deep dive into the advanced facets of Java concurrency,
    focusing on the Executor framework and Java’s concurrent collections. This chapter
    is instrumental for developers aiming to optimize thread execution and maintain
    data integrity within concurrent applications, especially in cloud-based environments.
    The journey began with the Executor framework, which highlighted its role in efficient
    thread management and task delegation, akin to a head chef orchestrating a kitchen’s
    operations. Concurrent collections were explored after that, which offered insights
    into managing data access amidst concurrent operations effectively.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了Java并发的先进方面，重点关注Executor框架和Java的并发集合。对于旨在优化线程执行并在并发应用程序中维护数据完整性的开发者来说，本章至关重要。旅程始于Executor框架，强调了它在高效线程管理和任务委派中的作用，类似于主厨指挥厨房的运作。随后探讨了并发集合，提供了在并发操作中有效管理数据访问的见解。
- en: Key synchronization tools such as `CountDownLatch`, `Semaphore`, and `CyclicBarrier`
    were detailed, and their importance in ensuring coordinated execution across different
    parts of an application was demonstrated. The chapter further delved into Java’s
    locking mechanisms, which provided strategies to safeguard shared resources and
    prevent concurrency-related issues. The narrative extended to cover service mesh
    and APM for optimizing application performance, alongside frameworks such as Akka
    and Vert.x for building reactive and resilient systems. It concluded with a focus
    on testing and debugging, which equipped developers with essential tools and methodologies
    for identifying and resolving concurrency challenges and ensuring high-performing,
    scalable, and robust Java applications in cloud environments. Through practical
    examples and expert advice, this chapter armed readers with the knowledge to master
    advanced concurrency concepts and apply them successfully in their cloud computing
    endeavors.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 关键同步工具，如`CountDownLatch`、`Semaphore`和`CyclicBarrier`被详细阐述，并展示了它们在确保应用程序不同部分协调执行中的重要性。本章进一步深入探讨了Java的锁定机制，提供了保护共享资源并防止并发相关问题的策略。叙述扩展到涵盖服务网格和APM以优化应用程序性能，以及用于构建反应性和弹性系统的框架，如Akka和Vert.x。它以关注测试和调试结束，为开发者提供了识别和解决并发挑战以及确保在云环境中高性能、可扩展和健壮的Java应用程序的基本工具和方法。通过实际示例和专家建议，本章使读者掌握了掌握高级并发概念并在他们的云计算努力中成功应用它们的知识。
- en: This groundwork sets the stage for delving into **Java concurrency patterns**
    in the next chapter, promising deeper insights into asynchronous programming and
    thread pool management for crafting efficient, robust cloud solutions.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这为下一章深入探讨**Java并发模式**奠定了基础，承诺对异步编程和线程池管理有更深入的见解，以构建高效、健壮的云解决方案。
- en: Questions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the primary purpose of the Executor framework in Java?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java的Executor框架的主要目的是什么？
- en: To schedule future tasks for execution
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了调度未来任务执行
- en: To manage a fixed number of threads within an application
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中管理固定数量的线程
- en: To efficiently manage thread execution and resource allocation
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了有效地管理线程执行和资源分配
- en: To lock resources for synchronized access
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了锁定资源以实现同步访问
- en: Which Java utility is best suited for handling scenarios with high read operations
    and fewer write operations to ensure data integrity during writes?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Java实用工具最适合处理高读操作和少量写操作的场景，以确保写操作期间的数据完整性？
- en: '`ConcurrentHashMap`'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`'
- en: '`CopyOnWriteArrayList`'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArrayList`'
- en: '`ReadWriteLock`'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadWriteLock`'
- en: '`StampedLock`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StampedLock`'
- en: What advantage does `CompletableFuture` provide in Java concurrency?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`在Java并发中提供了什么优势？'
- en: Reduces the need for callbacks by blocking the thread until completion
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过阻塞线程直到完成来减少回调的需要
- en: Enables asynchronous programming and non-blocking operations
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使异步编程和非阻塞操作成为可能
- en: Simplifies the management of multiple threads
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化了多线程的管理
- en: Allows for manual locking and unlocking of resources
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许手动锁定和解锁资源
- en: In the context of cloud computing, why are Java’s concurrent collections important?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在云计算的背景下，为什么Java的并发集合很重要？
- en: They provide a mechanism for manual synchronization of threads
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们提供了一种手动同步线程的机制
- en: They enable efficient data handling and reduce locking overhead in concurrent
    access scenarios
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们使高效的数据处理成为可能，并减少并发访问场景中的锁定开销
- en: They are necessary for creating new threads and processes
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们对于创建新线程和进程是必要的
- en: They replace traditional collections for all use cases
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们替换了所有用例中的传统集合
- en: How do advanced locking mechanisms such as `ReentrantLock` and `StampedLock`
    improve application performance in the cloud?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级锁定机制，如`ReentrantLock`和`StampedLock`，如何提高云应用中的性能？
- en: By allowing unlimited concurrent read operations
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过允许无限的并发读操作
- en: By completely removing the need for synchronization
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过完全消除同步的需要
- en: By offering more control over lock management and reducing lock contention
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供对锁定管理的更多控制并减少锁定竞争
- en: By automatically managing thread pools without developer input
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过自动管理线程池而不需要开发者输入
