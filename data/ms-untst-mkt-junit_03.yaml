- en: Chapter 3. Test Doubles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 测试替身
- en: This chapter covers the concept of test doubles and explains various test double
    types, such as mock, fake, dummy, stub, and spy. Sometimes, it is not possible
    to unit test a piece of code because of unavailability of collaborator objects
    or the cost of instantiation for the collaborator. Test doubles alleviate the
    need for a collaborator.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了测试替身的概念，并解释了各种测试替身类型，如模拟、伪造、假设、存根和间谍。有时，由于协作对象不可用或实例化的成本，可能无法对一段代码进行单元测试。测试替身减轻了对协作对象的需求。
- en: We know about stunt doubles—a trained replacement used for dangerous action
    sequences in movies, such as jumping out of the Empire State building, a fight
    sequence on top of a burning train, jumping from an airplane, or similar actions.
    Stunt doubles are used to protect the real actors or chip in when the actor is
    not available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解替身——一种用于电影中危险动作序列的受过训练的替代品，例如从帝国大厦跳下，在一辆燃烧的火车上打斗，从飞机上跳下或类似动作。替身用于保护真实演员或当演员不在场时进行补充。
- en: While testing a class that communicates with an API, you don't want to hit the
    API for every single test; for example, when a piece of code is dependent on database
    access, it is not possible to unit test the code unless the database is accessible.
    Similarly, while testing a class that communicates with a payment gateway, you
    can't submit payments to a real payment gateway to run tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试与API通信的类时，你不想在每次测试时都调用API；例如，当一段代码依赖于数据库访问时，除非数据库可访问，否则无法对代码进行单元测试。同样，在测试与支付网关通信的类时，你不能向真实的支付网关提交支付以运行测试。
- en: Test doubles act as stunt doubles. They are skilled replacements for collaborator
    objects. Gerard Meszaros coined the term test doubles and explained test doubles
    in his book *xUnit Test Patterns*, *Pearson Education*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身充当替身。它们是协作对象的熟练替代品。Gerard Meszaros提出了测试替身这个术语，并在他的书籍《xUnit Test Patterns》中解释了测试替身。*Pearson
    Education*。
- en: 'Test doubles are categorized into five types. The following diagram shows these
    types:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身被分为五种类型。以下图表显示了这些类型：
- en: '![Test Doubles](img/00049.jpeg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![测试替身](img/00049.jpeg)'
- en: Dummy
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设
- en: An example of a dummy would be a movie scene where the double doesn't perform
    anything but is only present on the screen. They are used when the actual actor
    is not present, but their presence is needed for a scene, such as watching the
    tennis finale of a US Open match.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设的一个例子是电影场景中，替身演员没有进行任何表演，只是在屏幕上出现。它们在实际演员不在场但需要出现在场景中时使用，例如观看美国公开赛网球决赛。
- en: 'Similarly, dummy objects are passed to avoid `NullPointerException` for mandatory
    parameter objects as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为了避免对强制参数对象传递`NullPointerException`，会传递假设对象，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, a dummy member was created and passed to a book
    object to test whether a book can report the number of times it was issued. Here,
    a member object is not used anywhere but it's needed to issue a book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，创建了一个假设成员并将其传递给一个图书对象，以测试图书能否报告其被借阅的次数。在这里，成员对象在别处没有使用，但它需要用于借阅图书。
- en: Stub
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存根
- en: A stub delivers indirect inputs to the caller when the stub's methods are called.
    Stubs are programmed only for the test scope. Stubs may record other information
    such as the number of times the methods were invoked and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当存根的方法被调用时，存根会向调用者提供间接输入。存根仅针对测试范围进行编程。存根可能会记录其他信息，例如方法被调用的次数等。
- en: 'Account transactions should be rolled back if the ATM''s money dispenser fails
    to dispense money. How can we test this when we don''t have the ATM machine, or
    how can we simulate a scenario where the dispenser fails? We can do this using
    the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ATM的货币分配器未能分配现金，则应回滚账户交易。当我们没有ATM机器或如何模拟分配器失败的场景时，我们如何测试这一点？我们可以使用以下代码来完成：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, `AlwaysFailingDispenserStub` raises an error whenever
    the `dispense()` method is invoked. It allows us to test the transactional behavior
    when the hardware is not present.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`AlwaysFailingDispenserStub`在调用`dispense()`方法时引发错误。这允许我们在硬件不存在的情况下测试事务行为。
- en: Mockito allows us to mock interfaces and concrete classes. Using Mockito, you
    can stub the `dispense()` method to throw an exception.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito允许我们模拟接口和具体类。使用Mockito，你可以模拟`dispense()`方法以抛出异常。
- en: Fake
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪造
- en: 'Fake objects are working implementations; mostly, the fake class extends the
    original class, but it usually hacks the performance, which makes it unsuitable
    for production. The following example demonstrates the fake object:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象是工作实现；大多数情况下，模拟类扩展了原始类，但它通常会对性能进行修改，这使得它不适合生产环境。以下是一个模拟对象的示例：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`AddressDAO` extends from a Spring framework class and provides an API for
    mass update. The same method is used to create a new address and update an existing
    one; if the count doesn''t match, then an error is raised. This class cannot be
    tested directly, and it needs `getSimpleJdbcTemplate()`. So, to test this class,
    we need to bypass the JDBC collaborator; we can do this by extending the original
    DAO class but by overriding the collaborator method. The following `FakeAddressDao`
    class is a fake implementation of `AddressDao`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddressDAO`类继承自Spring框架类，并提供了一个用于批量更新的API。同一个方法用于创建新地址和更新现有地址；如果计数不匹配，则会引发错误。这个类不能直接进行测试，需要`getSimpleJdbcTemplate()`。因此，为了测试这个类，我们需要绕过JDBC协作者；我们可以通过扩展原始DAO类但重写协作者方法来实现。以下`FakeAddressDao`类是`AddressDao`的模拟实现：'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`FakeAddressDao` extends `AddressDao` but only overrides `getSimpleJdbcTemplate()`
    and returns a JDBC template stub. We can use Mockito to create a mock version
    of the `JdbcTemplate` and return it from the fake implementation. This class cannot
    be used in production as it uses a mock `JdbcTemplate`; however, the fake class
    inherits all functionalities of the DAO, so this can be used for testing. The
    fake classes are very useful for legacy code.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`FakeAddressDao`扩展了`AddressDao`，但只重写了`getSimpleJdbcTemplate()`并返回一个JDBC模板存根。我们可以使用Mockito创建`JdbcTemplate`的模拟版本，并从模拟实现中返回它。这个类不能用于生产，因为它使用了一个模拟的`JdbcTemplate`；然而，模拟类继承了DAO的所有功能，因此可以用于测试。模拟类对于遗留代码非常有用。'
- en: Mock
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: Mock objects have expectations; a test expects a value from a mock object, and
    during execution, a mock object returns the expected result. Also, mock objects
    can keep track of the invocation count, that is, the number of times a method
    on a mock object is invoked.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象有期望值；测试会从模拟对象中期望得到一个值，在执行过程中，模拟对象返回期望的结果。此外，模拟对象可以跟踪调用次数，即模拟对象上的方法被调用的次数。
- en: The following example is a continuation of the ATM example with a mock version.
    In the previous example, we stubbed the dispense method of the `Dispenser` interface
    to throw an exception; here, we'll use a mock object to replicate the same behavior.
    We'll explain the syntax in [Chapter 4](part0027_split_000.html#page "Chapter 4. Progressive
    Mockito"), *Progressive Mockito*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是ATM示例的延续，使用模拟版本。在前一个示例中，我们模拟了`Dispenser`接口的dispense方法以抛出异常；这里，我们将使用模拟对象来复制相同的行为。我们将解释语法在[第4章](part0027_split_000.html#page
    "第4章。渐进式Mockito")，*渐进式Mockito*。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code is the mock (Mockito) version of the ATM test. The same object
    can be used in different tests; just the expectation needs to be set. Here, `doThrow()`
    raises an error whenever the mock object is called with any `BigDecimal` value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是ATM测试的模拟（Mockito）版本。同一个对象可以在不同的测试中使用；只需设置期望值。在这里，`doThrow()`会在模拟对象被任何`BigDecimal`值调用时引发错误。
- en: Spy
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间谍
- en: 'Spy is a variation of a mock/stub, but instead of only setting expectations,
    spy records the calls made to the collaborator. The following example explains
    this concept:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍（Spy）是模拟/存根（Mock/Stub）的一种变体，但它不仅设置期望值，还会记录对协作者的调用。以下示例解释了这一概念：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To test the `print` behavior of the `ResourceAdapter` class, we need to know
    whether the `printer.print()` method gets invoked when a user has permissions.
    Here, the `printer` collaborator doesn't do anything; it is just used to verify
    the `ResourceAdapter` behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`ResourceAdapter`类的`print`行为，我们需要知道当用户有权限时，`printer.print()`方法是否被调用。在这里，`printer`协作者不做任何事情；它只是用来验证`ResourceAdapter`的行为。
- en: 'Now, consider the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`SpyPrinter` implements the `Printer.print()` call, increments a `noOfTimescalled`
    counter, and `getInvocationCount` returns the count. Create a fake implementation
    of the `SecurityService` class to return `true` from the `canAccess(String printerName,
    String userId)` method. The following is the fake implementation of the `SecurityService`
    class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpyPrinter`实现了`Printer.print()`调用，增加一个`noOfTimescalled`计数器，`getInvocationCount`返回计数。创建一个`SecurityService`类的模拟实现，使其从`canAccess(String
    printerName, String userId)`方法返回`true`。以下是`SecurityService`类的模拟实现：'
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Fake `SecurityService` and a `SpyPrinter` objects are created and passed to
    the `ResourceAdapter` class and then `adapter.print` is called. In turn, it is
    expected that the `securityService` object will return `true` and the printer
    will be accessed, and `spyPrinter.print(…)` will increment the `noOfTimescalled`
    counter. Finally, in the preceding code, we verified that the count is 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个假的 `SecurityService` 对象和一个 `SpyPrinter` 对象，并将它们传递给 `ResourceAdapter` 类，然后调用
    `adapter.print`。反过来，预期 `securityService` 对象将返回 `true`，并且将访问打印机，`spyPrinter.print(…)`
    将增加 `noOfTimescalled` 计数器。最后，在前面代码中，我们验证了计数为 1。
- en: Summary
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided an overview of test doubles with examples. The following
    topics covered dummy, stub, mock, fake, and spy. This chapter is a prerequisite
    for Mockito.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过示例概述了测试替身，包括哑元、存根、模拟、伪造和间谍。本章是 Mockito 的先决条件。
- en: The next chapter will cover the Mockito framework and its advanced uses. Mockito
    is a mocking framework for Java. It provides the API for mock, spy, and stub creation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 Mockito 框架及其高级用法。Mockito 是一个用于 Java 的模拟框架。它提供了创建模拟、间谍和存根的 API。
