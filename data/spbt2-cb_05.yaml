- en: Application Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序测试
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating tests for MVC controllers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 MVC 控制器创建测试
- en: Configuring a database schema and populating it
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据库模式并填充数据
- en: Creating tests using an in-memory database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存数据库创建测试
- en: Creating tests using mock objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟对象创建测试
- en: Creating a JPA component test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 JPA 组件测试
- en: Creating a WebMvc component test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 WebMvc 组件测试
- en: Writing tests using Cucumber
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cucumber 编写测试
- en: Writing tests using Spock
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spock 编写测试
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, we did a lot of coding. We created a new Spring Boot
    application from scratch, added an MVC component and some database services to
    it, made a few tweaks to the application behavior, and even wrote our very own
    Spring Boot starter. It is now time to take the next step and learn what kind
    of tools and capabilities Spring Boot offers when it comes to testing all this
    code, and how well it integrates with the other popular testing frameworks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们做了大量的编码工作。我们从零开始创建了一个新的 Spring Boot 应用程序，向其中添加了一个 MVC 组件和一些数据库服务，对应用程序的行为进行了一些调整，甚至编写了我们自己的
    Spring Boot starter。现在是时候迈出下一步，了解 Spring Boot 在测试所有这些代码时提供了哪些工具和功能，以及它与其他流行测试框架的集成情况如何。
- en: We will see how to use Spring JUnit integration to create unit tests. Next,
    we will explore the options of setting up the database with test data to test
    against it. We will then look to the **behavior-driven development** (**BDD**)
    tools Cucumber and Spock and see how they integrate with Spring Boot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何使用 Spring JUnit 集成创建单元测试。接下来，我们将探索设置数据库并使用测试数据对其进行测试的选项。然后，我们将查看 **行为驱动开发**（**BDD**）工具
    Cucumber 和 Spock，了解它们如何与 Spring Boot 集成。
- en: Creating tests for MVC controllers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 MVC 控制器创建测试
- en: In the previous chapters, we made a lot of progress in gradually creating our
    application, but how do we know that it actually does what we want it to do? More
    importantly, how do we know for sure that after six months, or even a year from
    now, it will still continue to do what we expected it to do at the very beginning?
    This question is best answered by creating a set of tests, preferably automated,
    that run a suite of assertions against our code. This ensures that we constantly
    get the same and expected output given the specific input. Tests give us the much-needed
    peace of mind that our application not only elegantly is coded and looks beautiful,
    but that it also performs reliably and is as error-free as possible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们在逐步创建我们的应用程序方面取得了很大的进展，但我们如何知道它实际上确实做了我们想要它做的事情？更重要的是，我们如何确保六个月后，甚至一年后，它仍然会继续做我们最初期望它做的事情？这个问题最好的答案就是创建一系列测试，最好是自动化的，对我们的代码运行一系列断言。这确保了在给定的特定输入下，我们始终获得相同和预期的输出。测试给我们带来了急需的安心，我们的应用程序不仅代码优雅、外观美观，而且性能可靠，尽可能无错误。
- en: In [Chapter 4](6139967b-794e-479a-8461-d3197eb0322e.xhtml), *Writing Custom
    Spring Boot Starters*, we left off with our web application fitted with a custom-written
    Spring Boot starter. We will now create some basic tests to test our web application
    and to ensure that all the controllers expose the expected RESTful URLs, which
    we can rely on as the service API. This type of testing is a bit beyond what is
    commonly known as **unit testing** as it tests the entire web application, it
    requires the application context to be fully initialized, and all the beans should
    be wired together in order to work. This kind of testing is sometimes referred
    to as **integration** or **service testing**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](6139967b-794e-479a-8461-d3197eb0322e.xhtml) *编写自定义 Spring Boot Starter*
    中，我们停止了我们的 Web 应用程序安装了自定义编写的 Spring Boot starter。现在我们将创建一些基本的测试来测试我们的 Web 应用程序，并确保所有控制器都公开了预期的
    RESTful URL，我们可以依赖这些 URL 作为服务 API。这种测试类型略高于通常所说的 **单元测试**，因为它测试了整个 Web 应用程序，需要应用程序上下文完全初始化，并且所有
    bean 都应该连接在一起才能工作。这种测试有时被称为 **集成** 或 **服务测试**。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Spring Boot gets us going by creating a placeholder test file, `BookPubApplicationTests.java`,
    in the `src/test/java/com/example/bookpub` directory at the root of our project
    with the following content:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Boot 通过在项目根目录的 `src/test/java/com/example/bookpub` 目录中创建一个占位符测试文件，名为
    `BookPubApplicationTests.java`，来启动我们的项目，其内容如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `build.gradle`, we also get a test dependency on `spring-boot-starter-test`,
    as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.gradle` 中，我们还添加了对 `spring-boot-starter-test` 的测试依赖项，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will go ahead and extend the basic template test to contain the following
    code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续扩展基本模板测试，包含以下代码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Execute the tests by running `./gradlew clean test`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试。
- en: 'By looking at the console output, we can tell that our tests have succeeded
    and are running, but we don''t really see much information besides the following
    lines (truncated for brevity):'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看控制台输出，我们可以知道我们的测试已经成功运行，但我们实际上并没有看到很多信息，除了以下几行（为了简洁而截断）：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Better insight can be gathered by viewing the HTML reports that are generated
    by Gradle, which can be opened in the browser and reside in `build/reports/tests/index.html`,
    as shown in the following screenshot:![](img/a8e039b4-e823-4444-844c-b06e415813e1.png)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看Gradle生成的HTML报告可以获得更好的洞察力，这些报告可以在浏览器中打开，并位于`build/reports/tests/index.html`，如下截图所示：![](img/a8e039b4-e823-4444-844c-b06e415813e1.png)
- en: Clicking on `com.example.bookpub.BookPubApplicationTests` will take us to the
    individual test case breakdown, which shows the status of each test and how long
    it took to get executed, as follows:![](img/5eb6b09a-d98f-485a-b232-0fb40bfcc16d.png)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`com.example.bookpub.BookPubApplicationTests`将带我们到单个测试用例分解，显示每个测试的状态以及执行所需的时间，如下截图所示：![](img/5eb6b09a-d98f-485a-b232-0fb40bfcc16d.png)
- en: The more curious minds can also click on the Standard output button in order
    to see the runtime application logs that are produced during the execution of
    the test.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好奇心更强的人也可以点击标准输出按钮，以便在测试执行期间查看生成的运行时应用程序日志。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now that we have created our first test, let's examine the code in detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了第一个测试，让我们详细检查代码。
- en: 'We will first look at the following annotations that have been declared for
    the `BookPubApplicationTests` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看为`BookPubApplicationTests`类声明的以下注解：
- en: '`@RunWith(SpringRunner.class)`: This is a standard JUnit annotation that we
    can configure so as to use the `SpringRunner`, providing functionality to bootstrap the
    Spring Boot framework to the standard JUnit tests.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RunWith(SpringRunner.class)`: 这是一个标准的JUnit注解，我们可以配置它以使用`SpringRunner`，为标准的JUnit测试提供引导Spring
    Boot框架的功能。'
- en: '`@SpringBootTest(webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT)`:
    This is an annotation that marks the class as a Spring Boot test. It will use
    the Spring Boot framework to configure the test class instance, provide appropriate
    configuration, autowiring, and so on. The `webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT`
    attribute means that the current test is going to use a real, running service
    instance and will require a complete context initialization and application startup,
    as if it were the real deal. The `RANDOM_PORT` value is used to tell Spring Boot
    to start the Tomcat server on a randomly-chosen HTTP port, which we will later
    obtain by declaring the `@LocalServerPortprivate int port;` value field. This
    ability to select a random HTTP port is very handy when running tests on a Jenkins
    or any other CI server where, if multiple jobs are running in parallel, you could
    encounter port collision.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SpringBootTest(webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT)`:
    这是一个标记类为Spring Boot测试的注解。它将使用Spring Boot框架来配置测试类实例，提供适当的配置、自动装配等。`webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT`属性意味着当前测试将使用一个真实、运行的服务实例，并需要完整的上下文初始化和应用启动，就像真实的一样。`RANDOM_PORT`值用于告诉Spring
    Boot在随机选择的HTTP端口上启动Tomcat服务器，我们稍后将通过声明`@LocalServerPortprivate int port;`值字段来获取这个端口。当在Jenkins或其他任何CI服务器上运行测试时，这种选择随机HTTP端口的能力非常方便，因为在并行运行多个作业时可能会遇到端口冲突。'
- en: With the class annotations magic dispelled, let's look at the content of the
    class itself. As this is a Spring Boot test, we can declare any objects that are
    managed by Spring to be `@Autowired` during the execution or set to a specific
    environment value using a `@Value` annotation. In our test, we autowired the `WebApplicationContext`
    and `BookRepository` objects, as well as an instance of `TestRestTemplate`, which
    we will use in the execution of the standard JUnit `@Test` annotated test cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法类注解消失后，让我们看看类本身的内容。由于这是一个Spring Boot测试，我们可以在执行期间将Spring管理的任何对象声明为`@Autowired`，或者使用`@Value`注解将其设置为特定的环境值。在我们的测试中，我们自动装配了`WebApplicationContext`和`BookRepository`对象，以及一个`TestRestTemplate`实例，我们将在执行标准的JUnit
    `@Test`注解测试用例时使用它。
- en: In the first test case, the `contextLoads()` method, we will just assert that
    we have the `BookRepository` connection established and that it contains one book
    entry.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试用例`contextLoads()`中，我们将断言我们已经建立了`BookRepository`连接，并且它包含一个书籍条目。
- en: Our second test will ensure that our web application responds to a RESTful URL
    for a `Book` lookup via `ISBN - "/books/{isbn}"`. For this test, we will use the
    instance of `TestRestTemplate` and make a RESTful call to the running instance
    on a randomly-selected port. Spring Boot provides the value of the `port` field.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个测试将确保我们的Web应用程序能够响应一个通过`ISBN`查找`Book`的RESTful URL - `"/books/{isbn}"`。为此测试，我们将使用`TestRestTemplate`的实例，并在随机选择的端口上对运行实例进行RESTful调用。Spring
    Boot提供了`port`字段的值。
- en: In the `webappBookIsbnApi` test, we are using a full URL with the starting part
    being `"http://localhost:" + port`, which is technically not required if `TestRestTemplate`
    was autowired and injected by Spring Boot. In this case, it is possible to use
    a relative URL, looking like `Book book = restTemplate.getForObject("/books/978-1-78528-415-1",
    Book.class);`, and `TestRestTemplate` will automatically determine the port of
    the running test server instance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`webappBookIsbnApi`测试中，我们使用了一个完整的URL，其起始部分为`"http://localhost:" + port`，如果`TestRestTemplate`被Spring
    Boot自动装配和注入，技术上是不需要的。在这种情况下，可以使用一个相对URL，看起来像`Book book = restTemplate.getForObject("/books/978-1-78528-415-1",
    Book.class);`，并且`TestRestTemplate`将自动确定运行中的测试服务器实例的端口号。
- en: Alternatively, we can execute the same flavor of tests by going through the
    `MockMvc` object. This is provided by the Spring Test Framework and allows you
    to perform MVC testing without actually doing client-side-based testing through
    `RestTemplate`, but instead doing it fully on the server side where the controller
    requests are executed from the same context as the tested application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过`MockMvc`对象执行相同类型的测试。这是由Spring Test框架提供的，允许我们在不通过`RestTemplate`进行基于客户端的测试的情况下执行MVC测试，而是完全在服务器端进行，控制器请求是从与测试应用程序相同的上下文中执行的。
- en: In order to use `MockMvc`, we will use the `MockMvcBuilders` utility to build
    an instance using `@Autowired WebApplicationContext`. We will do this in the setup
    method so that we don't have to do it in every test explicitly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`MockMvc`，我们将使用`MockMvcBuilders`实用工具，通过`@Autowired WebApplicationContext`构建一个实例。我们将在设置方法中这样做，这样我们就不必在每个测试中明确执行它。
- en: It is also possible to get Spring Boot to automatically create an instance of
    `MockMvc`, if we annotate our test using `WebEnvironment.MOCK` instead of `RANDOM_PORT`.
    That configuration will only make the test run in the mock context, and no real
    server will be started. Our example shows how to combine having a real server
    instance and `MockMVC` in the same test class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`WebEnvironment.MOCK`而不是`RANDOM_PORT`来注释我们的测试，Spring Boot也可以自动创建一个`MockMvc`实例。这种配置将只使测试在模拟上下文中运行，而不会启动任何真实服务器。我们的示例展示了如何在同一个测试类中结合使用真实服务器实例和`MockMVC`。
- en: '`MockMvc` provides us with a very extensive set of capabilities in order to
    execute assertions on practically all the things that are related to a web request.
    It is designed to be used in a method-chained fashion, allowing us to link the
    various tests together and forming a nice, continuous logical chain:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockMvc`为我们提供了一套非常广泛的功能，以便对与网络请求相关的几乎所有事物执行断言。它被设计成以方法链的形式使用，允许我们将各种测试链接在一起，形成一个良好、连续的逻辑链：'
- en: '`perform(get(...))`: This method sets up the web request. In our particular
    case, we perform a GET request but the `MockMvcRequestBuilders` class provides
    us with static helper functions for all the common method calls.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perform(get(...))`：此方法设置网络请求。在我们的特定情况下，我们执行一个GET请求，但`MockMvcRequestBuilders`类为我们提供了所有常见方法调用的静态辅助函数。'
- en: '`andExpect(...)`: This method can be invoked multiple times, where each call
    represents an evaluation of a condition against the result of the `perform(...)`
    call. The argument of this call is any implementation of the `ResultMatcher` interface
    along with many stock ones that are provided by the `MockMvcResultMatchers` static
    utility class. This really opens up the possibility of having an infinite number
    of different checks such as verifying the response status, content type, values
    stored in a session, flash scope, verify redirects, contents of the rendering
    model or headers, and much more. We will use a third-party `json-path` add-on
    library (which is automatically brought as a `spring-boot-test` dependency) to
    test the JSON response data in order to ensure that it contains the right elements
    in the right tree hierarchy. `andExpect(jsonPath("$.name").value("Packt"))` validates
    that we have a name element at the root of the JSON document with a value of `Packt`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`andExpect(...)`: 这个方法可以被多次调用，每次调用都代表对`perform(...)`调用结果的某个条件的评估。这个调用的参数是`ResultMatcher`接口的任何实现，以及由`MockMvcResultMatchers`静态实用类提供的许多内置实现。这实际上打开了进行无限多种不同检查的可能性，例如验证响应状态、内容类型、会话中存储的值、闪存作用域、验证重定向、渲染模型的内
    容或头信息，等等。我们将使用第三方`json-path`附加库（作为`spring-boot-test`依赖自动引入）来测试JSON响应数据，以确保它包含正确的元素，并且位于正确的树结构中。`andExpect(jsonPath("$.name").value("Packt"))`验证了在JSON文档的根处有一个值为`Packt`的`name`元素。'
- en: To learn more about the various possibilities that are available in MockMvc,
    you can refer to [https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc](https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于MockMvc中可用的各种可能性，您可以参考[https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc](https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc)。
- en: Configuring a database schema and populating it
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据库模式和填充数据
- en: Earlier in the book, in [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml),
    *Configuring Web Applications*, we manually added a few entries to the database
    in the `StartupRunner's run(...)` method. While doing so programmatically can
    be a quick and easy way to get something going very quickly, in the long run,
    it is not really a good idea to do so, especially when you are dealing with a
    large amount of data. It is also good practice to separate the database preparations,
    changes, and other configurations from the rest of the running application code,
    even if it is setting up the test cases. Thankfully, Spring has provided you with
    the support to make this task fairly easy and straightforward.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期部分，在[第2章](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml)“配置Web应用程序”中，我们在`StartupRunner`的`run(...)`方法中手动添加了一些数据库条目。虽然这样做可以快速简单地启动某些内容，但从长远来看，这并不是一个好主意，尤其是当你处理大量数据时。将数据库的准备、更改和其他配置与运行应用程序的其余代码分离，即使是在设置测试用例时，也是一种良好的实践。幸运的是，Spring为我们提供了支持，使这项任务变得相当简单和直接。
- en: We will continue with the state of the application as we left it in the previous
    recipe. Spring provides us with a couple of ways to define how both the structure
    and data should be populated in the database. The first way relies on using Hibernate
    to automatically create the table structure by inferring it from our defined `@Entity`
    objects and using the `import.sql` file to populate the data. The second approach
    is to use the plain old Spring JDBC capability, which relies on using the `schema.sql`
    file that contains the database table definition and a corresponding `data.sql`
    file that contains the data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前配方中留下的应用程序状态。Spring为我们提供了几种定义如何在数据库中填充结构和数据的方法。第一种方法依赖于Hibernate自动创建表结构，通过从我们定义的`@Entity`对象推断，并使用`import.sql`文件来填充数据。第二种方法是通过使用普通的Spring
    JDBC功能，这依赖于包含数据库表定义的`schema.sql`文件和包含数据的相应`data.sql`文件。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we will remove the programmatic database population which we created
    in [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml), *Configuring Web Applications*.
    So let''s comment out the following code from the `StartupRunner''s run(...)`
    method:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将移除在[第2章](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml)“配置Web应用程序”中创建的程序化数据库填充。所以，让我们从`StartupRunner`的`run(...)`方法中注释掉以下代码：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we were to run our tests, they might fail if the `test.h2.db` file is missing
    because they expect the data to be in the database. We will populate the database
    by creating a Hibernate `import.sql` file in the `src/main/resources` directory
    at the root of our project with the following content:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行测试，如果缺少 `test.h2.db` 文件，它们可能会失败，因为它们期望数据在数据库中。我们将通过在项目根目录的 `src/main/resources`
    目录下创建以下内容的 Hibernate `import.sql` 文件来填充数据库：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On running the tests again by running `./gradlew clean test`, they are magically
    started and get passed again.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过再次运行 `./gradlew clean test` 来执行测试，它们神奇地启动并通过了。
- en: 'Another way to do this is to use the Spring JDBC support for `schema.sql` and
    `data.sql`. Let''s rename the newly-created `import.sql` file to `data.sql` and
    create a `schema.sql` file in the same directory with the following content:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法是使用 Spring JDBC 对 `schema.sql` 和 `data.sql` 的支持。让我们将新创建的 `import.sql` 文件重命名为
    `data.sql`，并在同一目录下创建一个包含以下内容的 `schema.sql` 文件：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we are now manually creating the database schema, we will need to tell the
    Hibernate mapper not to automatically derive one from the entities and populate
    the database with it. So, let's set the `spring.jpa.hibernate.ddl-auto=none` property
    in the `application.properties` file in the `src/main/resources` directory at
    the root of our project.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在正在手动创建数据库模式，我们需要告诉 Hibernate 映射器不要从实体中自动推导出一个，并用它来填充数据库。因此，让我们在项目根目录的
    `src/main/resources` 目录下的 `application.properties` 文件中设置 `spring.jpa.hibernate.ddl-auto=none`
    属性。
- en: Execute the tests by running `./gradlew clean test` and they should get passed.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean test` 来执行测试，它们应该会通过。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we actually explored two ways of achieving the same thing, and
    this is quite common when you are living in the Spring ecosystem. Depending on
    the components that are used, whether it's a plain Spring JDBC, Spring JPA with
    Hibernate, or the Flyway or Liquibase migrations, the approach of populating and
    initializing the database differs but the end result remains pretty much the same.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们实际上探索了两种实现相同目标的方法，这在 Spring 生态系统中是很常见的。根据使用的组件不同，无论是纯 Spring JDBC、Spring
    JPA 与 Hibernate，还是 Flyway 或 Liquibase 迁移，填充和初始化数据库的方法会有所不同，但最终结果基本上是相同的。
- en: Both Flyway and Liquibase are frameworks that provide incremental database migration
    capabilities. This comes in very handy when one wants to maintain the incremental
    log of the database changes in a programmatic, describable fashion with the ability
    to quickly put the database in a desired state for a particular version. While
    these frameworks differ in their approach in terms of providing such support,
    they are similar in their purpose. More detailed information can be obtained at
    their respective sites, [http://flywaydb.org](http://flywaydb.org) and [http://www.liquibase.org](http://www.liquibase.org).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway 和 Liquibase 都是提供增量数据库迁移功能的框架。当一个人想要以程序化、可描述的方式维护数据库变化的增量日志，并能够快速将数据库置于特定版本所需的状态时，这非常有用。虽然这些框架在提供此类支持的方法上有所不同，但它们的目的相似。更详细的信息可以在它们各自的网站上获得，[http://flywaydb.org](http://flywaydb.org)
    和 [http://www.liquibase.org](http://www.liquibase.org)。
- en: In the preceding example, we explored two different ways of populating and initializing
    the database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们探讨了两种不同的填充和初始化数据库的方法。
- en: Initializing the database with Spring JPA and Hibernate
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring JPA 和 Hibernate 初始化数据库
- en: 'In this approach, most of the work is actually done by the `Hibernate` library
    and we merely set up the appropriate configurations and create conventionally
    expected files that are needed for Hibernate to do the work:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，大部分工作实际上是由 `Hibernate` 库完成的，我们只是设置了适当的配置并创建了 Hibernate 进行工作所需的常规预期文件：
- en: The `spring.jpa.hibernate.ddl-auto=create-drop` setting instructs Hibernate
    to use the `@Entity` models and, based on their structure, automatically deduces
    the database schema. Upon starting the application, the calculated schema will
    be used to preinitialize the database table structure; when the application is
    shut down, it will all be destroyed. Even in the event that the application was
    forcefully terminated or it abruptly crashed, upon startup, if the existing tables
    are detected, they will be dropped and recreated from scratch. So it's probably
    not a good idea to rely on this for a production environment.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.jpa.hibernate.ddl-auto=create-drop`设置指示Hibernate使用`@Entity`模型，并根据其结构自动推断数据库模式。在应用程序启动时，将使用计算出的模式预初始化数据库表结构；当应用程序关闭时，它将被全部销毁。即使在应用程序被强制终止或突然崩溃的情况下，在启动时，如果检测到现有表，它们将被删除并从头开始重新创建。因此，对于生产环境来说，依赖这种方式可能不是一个好主意。'
- en: If the `spring.jpa.hibernate.ddl-auto` property is not explicitly configured,
    Spring Boot uses create-drop for embedded databases such as H2 by default, so
    be careful and set it appropriately.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确配置`spring.jpa.hibernate.ddl-auto`属性，Spring Boot默认使用create-drop为嵌入式数据库，如H2，因此请小心并适当设置它。
- en: Hibernate expects that the `import.sql` file is residing in the root of the
    classpath. This is used to execute the declared SQL statements upon application
    startup. While any valid SQL statement can go in the file, it is recommended that
    you put in the data-importing statements such as `INSERT` or `UPDATE` and steer
    clear of table structure mutations, as the schema definition is already taken
    care of by Hibernate.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate期望`import.sql`文件位于类路径的根目录中。该文件用于在应用程序启动时执行声明的SQL语句。虽然文件中可以放入任何有效的SQL语句，但建议您放入数据导入语句，如`INSERT`或`UPDATE`，并避免对表结构进行修改，因为模式定义已经由Hibernate处理。
- en: Initializing the database with Spring JDBC
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring JDBC初始化数据库
- en: 'If the application does not use JPA, or you don''t want to depend on the Hibernate
    functionality explicitly, Spring offers you another way of getting the database
    set up, as long as the `spring-boot-starter-jdbc` dependency is present. So let''s
    take a look at what we did to get it to work, as shown in the following list:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序不使用JPA，或者您不想明确依赖Hibernate功能，只要存在`spring-boot-starter-jdbc`依赖项，Spring就提供了另一种设置数据库的方法。因此，让我们看看我们是如何让它工作的，如下所示列表所示：
- en: The `spring.jpa.hibernate.ddl-auto=none` setting tells Hibernate not to do any
    automatic handling of the database if the Hibernate dependency also exists, as
    it does in our case. This setting is good practice for a production environment
    as you probably don't want to get all of your database tables wiped clean inadvertently.
    That would be one hell of a disaster, that's for sure!
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.jpa.hibernate.ddl-auto=none`设置告诉Hibernate，如果Hibernate依赖项也存在（如我们案例中所示），不要对数据库进行任何自动处理。在生产环境中，这是一个好的实践，因为您可能不希望意外地清除所有数据库表。那将是一场灾难，这是肯定的！'
- en: The `schema.sql` file is expected to exist in the root of the classpath. It
    is executed by Spring during the schema creation of the database upon every startup
    of the application. However, unlike Hibernate, this will not drop any of the existing
    tables automatically, so it might be a good idea to either use `DROP TABLE IF
    EXISTS` to delete an existing table before creating the new one, or use `CREATE
    TABLE IF NOT EXISTS` as part of the table creation SQL if you only want to create
    new tables when they don't already exist. This makes it a lot more flexible to
    declare the database structure evolution logic, thus making it safer to be used
    in production as well.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期`schema.sql`文件存在于类路径的根目录中。Spring会在每次应用程序启动时，在数据库创建模式时执行该文件。然而，与Hibernate不同，它不会自动删除任何现有的表，因此在使用`DROP
    TABLE IF EXISTS`删除现有表并在创建新表之前是一个好主意，或者如果您只想在表不存在时创建新表，可以将`CREATE TABLE IF NOT
    EXISTS`作为表创建SQL的一部分。这使得声明数据库结构演变逻辑更加灵活，因此在生产环境中使用也更加安全。
- en: The `data.sql` file is expected to exist in the root of the classpath. This
    is used to execute the data population SQL, so this is where all the `INSERT INTO`
    statements go.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期`data.sql`文件存在于类路径的根目录中。该文件用于执行数据填充SQL，因此所有`INSERT INTO`语句都应放在这里。
- en: Given that this is a Spring native functionality, we will also get the ability
    to define the schema and data files not only globally, but also as per the specific
    database platform. For example, we can have one set of files that we can use for
    Oracle, `schema-oracle.sql`, and a different one for MySQL, `schema-mysql.sql`.
    The same applies to the `data.sql` variants as well; however, they don't have
    to be defined per platform, so while you might have platform-specific schema files,
    there could be a shared data file. The `spring.datasource.platform` configuration
    value can be explicitly set if you want to override Spring Boot's automatically
    deduced value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个Spring原生功能，我们还将获得定义模式和数据文件的能力，不仅限于全局，还可以根据特定的数据库平台。例如，我们可以有一组文件，我们可以用于Oracle，`schema-oracle.sql`，以及另一组用于MySQL，`schema-mysql.sql`。同样适用于`data.sql`变体；然而，它们不必按平台定义，因此虽然你可能有一些特定平台的模式文件，但可能有一个共享的数据文件。如果你想覆盖Spring
    Boot自动推断的值，可以显式设置`spring.datasource.platform`配置值。
- en: In case one wants to override the default names of `schema.sql` and `data.sql`,
    Spring Boot provides the configuration properties, which we can use to control
    `spring.datasource.schema` and `spring.datasource.data`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人想覆盖`schema.sql`和`data.sql`的默认名称，Spring Boot提供了配置属性，我们可以使用这些属性来控制`spring.datasource.schema`和`spring.datasource.data`。
- en: Creating tests using an in-memory database
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存数据库创建测试
- en: In the previous recipe, we explored how to get our databases set up with the
    desired tables and populated with the required data. When it comes to testing,
    one of the typical challenges is to get the environment set up correctly and predictably
    so that when the tests are executed, we can safely assert the behavior in a deterministic
    fashion. In an application that connects to a database, making sure that the database
    contains a deterministic dataset on which the assertions can be evaluated is extremely
    important. For an elaborate test suite, it is also necessary to be able to refresh
    or change that dataset based on the tests. Thankfully, Spring has some nice facilities
    that aid you in accomplishing this task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们探讨了如何设置我们的数据库，使其包含所需的表并填充所需的数据。当涉及到测试时，一个典型的挑战是如何正确且可预测地设置环境，以便在执行测试时，我们可以安全地以确定性的方式断言行为。在一个连接到数据库的应用程序中，确保数据库包含一个确定性的数据集，以便可以对断言进行评估，这一点非常重要。对于一个详尽的测试套件，根据测试来刷新或更改该数据集也是必要的。幸运的是，Spring提供了一些很好的功能，可以帮助你完成这项任务。
- en: We will pick up from the state of our `BookPub` application as we left it in
    the previous recipe. At this point, we have the `schema.sql` file defining all
    the tables, and we also need the database with some starting data that is defined
    in `data.sql`. In this recipe, we will extend our tests to use the specific data
    fixture files that are tailored to a particular test suite.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们在之前的菜谱中留下的`BookPub`应用程序的状态开始。在这个阶段，我们有一个定义所有表的`schema.sql`文件，我们还需要一个数据库，其中包含在`data.sql`中定义的一些起始数据。在这个菜谱中，我们将扩展我们的测试，以使用针对特定测试套件定制的特定数据固定文件。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Our first step will be to create a `resources` directory in the `src/test` directory
    at the root of our project.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是在项目的根目录下的`src/test`目录中创建一个名为`resources`的目录。
- en: 'In this directory, we will start placing our fixture SQL data files. Let''s
    create a new file named `test-data.sql` in the resources directory with the following
    content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个目录中，我们将开始放置我们的固定SQL数据文件。让我们在资源目录中创建一个名为`test-data.sql`的新文件，内容如下：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now need a way to load this file when our test runs. We will modify our
    `BookPubApplicationTests` class in the following way:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一种方法在测试运行时加载此文件。我们将按照以下方式修改我们的`BookPubApplicationTests`类：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Execute the tests by running `./gradlew clean test`, and they should continue
    to get passed despite us adding another book and its author to the database.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，尽管我们向数据库中添加了另一本书及其作者，但测试应该继续通过。
- en: 'We can also use the method of populating the database that we learned in the
    previous recipe. As the test code has its own `resources` directory, it is possible
    to add another `data.sql` file to it, and Spring Boot will use both the files
    to populate the database. Let''s go ahead and create the `data.sql` file in the
    `src/test/resources` directory at the root of our project with the following content:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用之前菜谱中学到的填充数据库的方法。由于测试代码有自己的`resources`目录，我们可以在其中添加另一个`data.sql`文件，Spring
    Boot将会使用这两个文件来填充数据库。让我们继续在项目根目录下的`src/test/resources`目录中创建一个名为`data.sql`的文件，并包含以下内容：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As Spring Boot collects all the occurrences of the data filesfrom the classpath, it
    is possible to place the data files in JARs or different physical locations that
    all end up being at the root of the classpath. It is also important to remember
    that the loading order of these scripts is not deterministic, and if you rely
    on certain referential IDs, it is better if you use selects to get them instead
    of making assumptions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Boot收集了类路径中所有数据文件的出现，因此可以将数据文件放在JAR文件或不同的物理位置中，最终它们都会位于类路径的根目录。同样重要的是要记住，这些脚本的加载顺序不是确定的，如果你依赖于某些参照性ID，最好使用选择来获取它们，而不是做出假设。
- en: 'As we added another book to the database and we now have three of them, we
    should fix the assertion in our `contextLoads()` test method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们向数据库中添加了另一本书，现在我们有三本了，我们应该在我们的`contextLoads()`测试方法中修复断言：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Execute the tests by running `./gradlew clean test` and they should continue
    to get passed.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，它们应该继续通过。
- en: 'It would be a fair statement to say that when running unit tests, an in-memory
    database is probably more suitable for the role than a persistent one. Let''s
    create a dedicated test configuration instance of the `application.properties`
    file in the `src/test/resources` directory at the root of our project with the
    following content:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以公平地说，当运行单元测试时，内存数据库可能比持久性数据库更适合这个角色。让我们在项目根目录下的`src/test/resources`目录中创建一个专门的`application.properties`文件配置实例，并包含以下内容：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is important to know that Spring Boot loads only one `application.properties`
    file from the classpath. When we created another `application.properties` in `src/test/resources`,
    the previous one from `src/main/resources` was no longer loaded and thus none
    of the properties defined in it were merged in the environment. For this reason,
    you should configure all of the property values that are required. In our case,
    we had to redefine the `spring.jpa.hibernate.dll-auto` property, even though it
    was already declared in the `src/main/resources/application.properties` location.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Spring Boot只从类路径中加载一个`application.properties`文件。当我们创建了一个新的`application.properties`文件在`src/test/resources`中时，之前的`src/main/resources`中的那个就不再被加载，因此其中定义的所有属性都没有合并到环境中。因此，你应该配置所有需要的属性值。在我们的例子中，我们必须重新定义`spring.jpa.hibernate.dll-auto`属性，尽管它已经在`src/main/resources/application.properties`位置中声明过了。
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to get passed.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，测试应该继续通过。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we relied on the facility that is provided by Spring to initialize
    and populate the database in order to get our database populated with the data
    required to run the tests and assert on them. However, we also wanted to be able
    to use some data that was only relevant to a particular test suite. For this,
    we turned to the `ResourceDatabasePopulator` and `DatabasePopulatorUtils` classes
    to insert the desired data right before the test got executed. These are exactly
    the same classes that are used internally by Spring in order to handle the `schema.sql`
    and `data.sql` files, except now, we are explicitly defining the script files
    that we want to execute.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们依赖于Spring提供的初始化和填充数据库的功能，以便用所需的数据填充数据库，以便运行测试并对它们进行断言。然而，我们还想能够使用一些只与特定测试套件相关的数据。为此，我们转向了`ResourceDatabasePopulator`和`DatabasePopulatorUtils`类，在测试执行之前插入所需的数据。这些正是Spring内部用来处理`schema.sql`和`data.sql`文件的相同类，但现在，我们明确地定义了我们想要执行的脚本文件。
- en: 'So, let''s break up what we did step by step, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们一步一步地分解我们所做的工作，如下所示：
- en: We created a setup method named `loadDataFixtures()`, which we annotated with
    a `@Before` annotation to tell JUnit to run it before every test.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`loadDataFixtures()`的设置方法，并用`@Before`注解标注它，以告诉JUnit在每次测试之前运行它。
- en: In this method, we obtained a resource handle to the `classpath:/test-data.sql`
    data file that resides in our application's classpath and where we store our test
    data and execute it against `@Autowired DataSource ds`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们获取了`classpath:/test-data.sql`数据文件的资源句柄，该文件位于我们的应用程序类路径中，我们在这里存储测试数据并对其执行`@Autowired
    DataSource ds`。
- en: As Spring can only autowire dependencies in the instances of the class, and
    the `@Before` annotated setup methods get executed for every test, we had to get
    a little creative in order to avoid repopulating our database with the duplicate
    data for every test instead of once per test suite/class. To achieve this, we
    created a `static boolean loadDataFixtures` variable that retained its state for
    every instance of the `BookPubApplicationTests` class, thus ensuring that we executed `DatabasePopulatorUtils`
    only once. The reason that the variable has to be static is as a new instance
    of the test class gets created for every test method that it runs in the class;
    having the `boolean` flag at the instance level will not do the trick.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Spring只能在类的实例中自动注入依赖项，并且`@Before`注解的设置方法会为每个测试执行，因此我们必须稍微发挥一点创意，以避免每次测试而不是每次测试套件/类执行时重复填充我们的数据库。为了实现这一点，我们创建了一个`static
    boolean loadDataFixtures`变量，它为`BookPubApplicationTests`类的每个实例保留其状态，从而确保我们只执行一次`DatabasePopulatorUtils`。变量必须是静态的，因为每次测试方法在类中运行时都会创建一个新的测试类实例；在实例级别上拥有`boolean`标志将无法达到目的。
- en: Alternatively, we could have used the `@Sql` annotation instead of the `loadDataFixtures()`
    method and marked our `BookPubApplicationTests` class as `@Transactional` to make
    sure that the `test-data.sql` file got populated before every test method was
    run. Then we could have rolled back to the pre-execution state of the database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用`@Sql`注解代替`loadDataFixtures()`方法，并将我们的`BookPubApplicationTests`类标记为`@Transactional`，以确保在运行每个测试方法之前填充`test-data.sql`文件。然后我们可以将数据库回滚到执行前的状态。
- en: This makes test setup a bit simpler and the transactional part allows for having
    tests that mutate the data in the database without worrying about race conditions,
    but this has the downside of executing the SQL population before every test, which
    adds a bit of extra latency.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试设置变得稍微简单一些，事务部分允许测试在数据库中修改数据，而不必担心竞争条件，但缺点是每次测试之前都会执行SQL填充，这会增加一些额外的延迟。
- en: 'To make this work, we need to remove the `loadDataFixtures()` method and add
    the following annotations to the `BookPubApplicationTests` class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个功能工作，我们需要移除`loadDataFixtures()`方法，并将以下注解添加到`BookPubApplicationTests`类中：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For the finishing touch, we decided to have a separate `application.properties`
    file to be used for testing purposes. We added this to our `src/test/resources`
    classpath with a testing configuration of the in-memory database instead of using
    the file-based persistent one.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了最后的润色，我们决定有一个单独的`application.properties`文件用于测试目的。我们将它添加到我们的`src/test/resources`类路径中，使用内存数据库的测试配置，而不是使用基于文件的持久配置。
- en: Unlike `application.properties`, where only one file can be loaded from the
    classpath, Spring supports a number of profile configurations which will be merged
    together. So, instead of declaring a completely separate `application.properties`
    file, we could create an `application-test.properties` file and set an active
    profile to test while running the tests.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`application.properties`不同，其中只能从类路径加载一个文件，Spring支持多个配置文件，这些配置文件将被合并。因此，我们不必声明一个完全独立的`application.properties`文件，我们可以创建一个`application-test.properties`文件，并在运行测试时设置一个活动配置文件为测试。
- en: Creating tests using mock objects
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟对象创建测试
- en: In the previous recipe, we used a data fixture file to populate an in-memory
    database in order to run our tests on predictable and static sets of data. While
    this makes the tests consistent and deterministic, we are still paying the price
    of having to create a database, populate it with data, and initialize all the
    JPA and connectivity components, which could be viewed as an excessive step for
    a test. Luckily, Spring Boot provides internal support for being able to mock
    beans and inject them as components in the tests for setup and further use as
    dependencies within an application context.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们使用数据固定文件来填充内存数据库，以便在可预测和静态的数据集上运行我们的测试。虽然这使得测试一致且可预测，但我们仍然需要为创建数据库、用数据填充它以及初始化所有JPA和连接组件付费，这可以被视为测试的一个过度步骤。幸运的是，Spring
    Boot提供了内部支持，能够模拟bean并将它们作为组件注入测试中，以便在测试设置和作为应用程序上下文中的依赖项进一步使用。
- en: Let's examine how we can use the power of Mockito so that we don't need to rely
    on the database at all. We will learn how to elegantly mock the `Repository` instance
    objects using the Mockito framework and some `@MockBean` annotation cleverness.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用Mockito的力量，这样我们就不需要完全依赖数据库了。我们将学习如何优雅地使用Mockito框架和一些`@MockBean`注解的巧妙性来模拟`Repository`实例对象。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'First, we will create a new `MockPublisherRepositoryTests` test class in the
    `src/test/java/com/example/bookpub` directory at the root of our project with
    the following content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在项目根目录下的`src/test/java/com/example/bookpub`目录中创建一个新的`MockPublisherRepositoryTests`测试类，内容如下：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Execute the tests by running `./gradlew clean test` and the tests should get
    passed
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，并且测试应该通过
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are a few magical things happening here. Let''s start with the annotations
    that we put into the `MockPublisherRepositoryTests` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些神奇的事情。让我们从我们放入`MockPublisherRepositoryTests`类的注解开始：
- en: The `@SpringBootTest` annotation's `webEnvironment` attribute was replaced with
    `WebEnvironment.NONE`. This is to inform Spring Boot that we don't want a full
    application web server to be initialized for this test, since we will only be
    interacting with the repository object, without making calls to controllers or
    using any part of the WebMvc stack. We did this to save test startup time, and
    if one is curious to see the difference, just simply switching it back to the `WebEnvironment.RANDOM_PORT`
    value and rerunning the test would show that the time has almost doubled. (On
    my beefy MacBook Pro, it increased from 5 seconds to almost 9.)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SpringBootTest`注解的`webEnvironment`属性被替换为`WebEnvironment.NONE`。这是为了通知Spring
    Boot我们不想为这个测试初始化一个完整的应用程序Web服务器，因为我们只会与仓库对象进行交互，而不会调用控制器或使用WebMvc堆栈的任何部分。我们这样做是为了节省测试启动时间，如果有人好奇想看看差异，只需简单地将它切换回`WebEnvironment.RANDOM_PORT`值并重新运行测试，就会显示时间几乎翻倍。（在我的MacBook
    Pro上，它从5秒增加到近9秒。）'
- en: 'With the application changes examined, let''s now look at what we did in the
    `MockPublisherRepositoryTests` class itself:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了应用程序的更改之后，现在让我们看看我们在`MockPublisherRepositoryTests`类本身中做了什么：
- en: The `@MockBean` annotation instructs Spring that this dependency is not a real
    instance, but a `mock` object currently backed by the Mockito framework. This
    has an interesting effect in that it actually replaces our `PublisherRepository`
    bean instance in the context with the mock one, so, everywhere within the context,
    all dependencies for `PublisherRepository` get wired with the mocked version instead
    of a real, database-backed one.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MockBean`注解指示Spring这个依赖项不是一个真实实例，而是一个由Mockito框架支持的`mock`对象。这有一个有趣的效果，它实际上用模拟实例替换了上下文中的`PublisherRepository`bean实例，所以，在上下文中，所有对`PublisherRepository`的依赖都连接到模拟版本，而不是真实的、数据库支持的版本。'
- en: 'Now that we know how the mocked instance of `PublisherRepository` gets injected
    into our tests, let''s take a look at the newly-created test setup methods. The
    two methods of particular interest are `setupPublisherRepositoryMock()` and `resetPublisherRepositoryMock()`.
    They are described as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了`PublisherRepository`的模拟实例是如何被注入到我们的测试中的，让我们来看看新创建的测试设置方法。其中两个特别感兴趣的方法是`setupPublisherRepositoryMock()`和`resetPublisherRepositoryMock()`。它们被描述如下：
- en: The `setupPublisherRepositoryMock()` method is annotated with `@Before`, which
    tells JUnit to execute this method before running every `@Test` method in the
    class. We will use the Mockito framework in order to configure the behavior of
    our mocked instance. We configure it such, that when the `repository.count()`
    method is called, it will return `5` as a result. The Mockito, Junit, and Hamcrest
    libraries provide us with many convenient DLS-like methods, which we can use to
    define such rules with an English-like, easy-to-read style.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setupPublisherRepositoryMock()`方法被`@Before`注解标记，这告诉JUnit在运行类中的每个`@Test`方法之前执行此方法。我们将使用Mockito框架来配置我们模拟实例的行为。我们这样配置它，当调用`repository.count()`方法时，它将返回`5`作为结果。Mockito、JUnit和Hamcrest库为我们提供了许多方便的DLS-like方法，我们可以使用这些方法以类似英语的、易于阅读的风格定义这样的规则。'
- en: The `resetPublisherRepositoryMock()` method is annotated with `@After`, which
    tells JUnit to execute this method after running every `@Test` method in the class.
    At the end of every test, we will need to reset the mocked behavior, so we will
    use the `reset(...)` method call to clear out all of our settings and get the
    mock ready for the next test, which can be used in another test suite altogether.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resetPublisherRepositoryMock()`方法被`@After`注解标记，这告诉JUnit在每个`@Test`方法运行后执行此方法。在每个测试结束时，我们需要重置mock的行为，因此我们将使用`reset(...)`方法调用来清除所有设置，并使mock为下一个测试做好准备，这个测试可以用于另一个测试套件。'
- en: Ideally, there is no need to reset the `mock` object at the end of the test
    run, as each test class gets its own context spawned up, so between test classes
    the instance of a mock is not shared. It is considered good practice to create
    many smaller tests instead of a single large one. There are, however, some use
    cases that warrant resetting the mock when it is being managed by a container
    injection, so I thought it was worth mentioning. For the best practices on using
    `reset(...)`, see [https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock](https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，在测试运行结束时没有必要重置`mock`对象，因为每个测试类都会启动自己的上下文，所以测试类之间不会共享mock的实例。通常认为，创建多个较小的测试而不是一个大的测试是一个好的实践。然而，有些情况下，当mock对象由容器注入管理时，重置mock是有必要的，因此我认为这一点值得提及。关于使用`reset(...)`的最佳实践，请参阅[https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock](https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock)。
- en: Creating a JPA component test
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个JPA组件测试
- en: Most of our previous test examples had to start up the entire application and
    configure all the beans in order to execute. While that is not a big issue for
    our simple application, which has little code, it might prove an expensive and
    lengthy process for some larger, more complex enterprise-grade services. Considering
    that one of the key aspects of having good test coverage is a low execution time,
    we might want to opt out of having to bootstrap the entire application in order
    to test just one component, or *slice*, as Spring Boot refers to it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的多数测试示例都需要启动整个应用程序并配置所有bean才能执行。虽然这对我们这个代码量很少的简单应用程序来说不是大问题，但对于一些更大、更复杂的面向企业的服务来说，可能是一个昂贵且耗时的过程。考虑到良好的测试覆盖率的关键方面之一是低执行时间，我们可能希望避免启动整个应用程序来测试单个组件，或者像Spring
    Boot所说的那样，测试一个“切片”。
- en: In this recipe, we will try to create a similar test to our previous `PublisherRepository`
    one, but without starting the entire container and initializing all the beans.
    Conveniently, Spring Boot provides us with the `@DataJpaTest` annotation, which
    we can put on our test class, and it will automatically configure all the components
    necessary for the JPA functionality, but not the entire context. So beans like
    controllers, services, and so on, will be missing. This test is very good at quickly
    testing the validity of entity domain object bindings, to make sure the field
    names, associations, and so on, have been configured correctly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将尝试创建一个类似于我们之前的`PublisherRepository`测试的测试，但不需要启动整个容器和初始化所有bean。方便的是，Spring
    Boot为我们提供了`@DataJpaTest`注解，我们可以将其放在我们的测试类上，它将自动配置所有必要的JPA功能组件，但不是整个上下文。因此，像控制器、服务之类的bean将会缺失。这个测试非常适合快速测试实体领域对象的绑定有效性，以确保字段名、关联等配置正确。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s create a new `JpaAuthorRepositoryTests` test class in the `src/test/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目根目录下的`src/test/java/com/example/bookpub`目录中创建一个新的`JpaAuthorRepositoryTests`测试类，其内容如下：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to pass
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，并且测试应该继续通过
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key difference from our previous test is the absence of the `@SpringBootTest`
    annotation, which has been replaced with the `@DataJpaTest` annotation. The apparent
    simplicity of the test class itself is possible thanks to the `@DataJpaTest` annotation
    doing the bulk of the declarations and workload to configure the test environment.
    If we look inside the annotation definition, we will see a myriad of different
    internal annotations configuring all the necessary components. The important ones
    are the `@AutoConfigure*` annotations, such as `@AutoConfigureDataJpa` or `@AutoConfigureTestDatabase`.
    Those annotations essentially instruct Spring Boot to import the necessary component
    configurations when bootstrapping the test. For example, in `@DataJpaTest`, only
    `Cache`, `DataJpa`, `TestDatabase`, and `TestEntityManager` components would be
    configured and made available, which significantly reduces the test footprint,
    both memory-wise as well as startup and execution times. The specific configuration
    classes are then loaded, as we've seen before, from the `META-INF/spring.factories`
    descriptors provided by various artifacts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的测试相比，关键的区别在于缺少 `@SpringBootTest` 注解，它已被 `@DataJpaTest` 注解所取代。测试类本身的明显简单性得益于
    `@DataJpaTest` 注解承担了大部分的声明和负载，以配置测试环境。如果我们查看注解定义，我们会看到无数不同的内部注解配置了所有必要的组件。其中重要的是
    `@AutoConfigure*` 注解，如 `@AutoConfigureDataJpa` 或 `@AutoConfigureTestDatabase`。这些注解本质上指导
    Spring Boot 在引导测试时导入必要的组件配置。例如，在 `@DataJpaTest` 中，只有 `Cache`、`DataJpa`、`TestDatabase`
    和 `TestEntityManager` 组件会被配置并可用，这显著减少了测试的足迹，无论是从内存角度还是启动和执行时间。然后，具体的配置类将从我们之前看到的
    `META-INF/spring.factories` 描述符中加载，这些描述符由各种工件提供。
- en: With the right components initialized, we can take advantage of some preconfigured
    beans, such as `TestEntityManager`, which gives us the ability to interact with
    the test instance of the database, pre-initialize the desired state of its content,
    and manipulate test data. This gives us the guarantee that after each test suite
    is done executing, we will get a clean slate for the next set without the need
    of an explicit cleanup. This makes it easier to write tests, without having to
    worry about the order of execution and potential over stepping of changes from
    test suite to test suite, avoiding the inadvertent dirty state that makes tests
    inconsistent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化了正确的组件后，我们可以利用一些预配置的豆（beans），例如 `TestEntityManager`，它赋予我们与测试数据库实例交互的能力，预先初始化其内容所需的状态，并操作测试数据。这保证了在每个测试套件执行完毕后，我们将为下一个套件获得一个干净的起点，无需显式清理。这使得编写测试更加容易，无需担心执行顺序和测试套件之间潜在的变化越界，避免因意外的不一致状态而使测试结果不一致。
- en: Creating a WebMvc component test
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 WebMvc 组件测试
- en: Another one of the collection of `*Test` slices is `@WebMvcTest`, which allows
    us to create tests for the WebMvc part of the application, quickly testing controllers,
    filters, and so on, while providing ability to use `@MockBean` to configure the
    necessary dependencies such as services, data repositories, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`*Test` 切片集合中的另一个是 `@WebMvcTest`，它允许我们为应用程序的 WebMvc 部分创建测试，快速测试控制器、过滤器等，同时提供使用
    `@MockBean` 配置必要依赖项的能力，如服务、数据存储库等。'
- en: This is another very useful testing slice provided by the Spring Boot Test Framework,
    and we will explore its use in this recipe, taking a look at how we can create
    an Mvc layer test for our `BookController` file, mocking the `BookRepository`
    service with a predefined dataset and making sure the returned JSON document is
    what we would expect based on that data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Spring Boot 测试框架提供的另一个非常有用的测试切片，我们将在这个配方中探讨其使用方法，看看我们如何为我们的 `BookController`
    文件创建一个 Mvc 层测试，使用预定义的数据集模拟 `BookRepository` 服务，并确保返回的 JSON 文档是我们根据该数据预期的那样。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we will create a new `WebMvcBookControllerTests` test class in the `src/test/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在项目根目录下的 `src/test/java/com/example/bookpub` 目录中创建一个新的 `WebMvcBookControllerTests`
    测试类，内容如下：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to pass
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean test` 来执行测试，并且测试应该继续通过
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The functionality of `@WebMvcTest` is very similar to the `@DataJpaTest` annotation
    we have seen in the previous recipe. The difference is really just a set of components
    that get initialized during the test bootstrap. Unlike `@DataJpaTest`, this time
    there are no database components that are provided for us, but instead we get
    the `WebMvc` and `MockMvc` configurations, which bring all the necessary foundations
    for initializing controllers, filters, interceptors, and so on. For that reason,
    we had to add `AuthorRepository` and `PublisherRepository` as mock beans into
    our test code, because otherwise the test would fail to start because Spring Boot
    would be unable to satisfy the bean dependency that the `StartupRunner` class
    has on those two repositories.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebMvcTest`的功能与我们之前在配方中看到的`@DataJpaTest`注解非常相似。真正的区别仅仅在于测试引导过程中初始化的一组组件。与`@DataJpaTest`不同，这次没有为我们提供数据库组件，而是我们得到了`WebMvc`和`MockMvc`配置，这些配置为初始化控制器、过滤器、拦截器等提供了所有必要的基石。因此，我们必须将`AuthorRepository`和`PublisherRepository`作为模拟豆子添加到我们的测试代码中，否则测试将无法启动，因为Spring
    Boot将无法满足`StartupRunner`类对这两个存储库的豆依赖。'
- en: Another solution to this problem could be removing the dependency on those two
    repositories from the `StartupRunner` class, since we've commented out the code
    that uses them earlier in this chapter, in the *Configuring database schema and
    populating it* recipe. If that was not possible, I wanted to demonstrate how to
    handle the situation where you have bean dependencies in other classes, unrelated
    directly to the test, but causing startup failures during initialization and execution.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一个方案可能是从`StartupRunner`类中移除对这两个存储库的依赖，因为我们已经在本章的“配置数据库模式和填充它”配方中注释掉了使用它们的代码。如果那不可能，我想展示如何处理你拥有其他类中的bean依赖的情况，这些类与测试没有直接关系，但在初始化和执行期间会导致启动失败。
- en: As one can see, unlike our previous recipe test, where we did not use any bean
    mocking since it was testing a lower-layer component without further dependencies,
    this time we need to provide a `BookRepository` mock, which is being used by our
    `BookController` class, the functionality of which we are testing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，与我们的先前的配方测试不同，那次我们没有使用任何bean模拟，因为它是测试一个没有进一步依赖的底层组件，这次我们需要提供一个`BookRepository`模拟，它被我们的`BookController`类使用，我们正在测试其功能。
- en: We have already seen how to use the `@Before` annotation to preconfigure mock
    objects in the `MockPublisherRepositoryTests` class, so this time we are doing
    the configuration directly in the `webappBookApi` test method, similar to the
    style you will see when we learn about writing tests using the Spock framework.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在`MockPublisherRepositoryTests`类中使用`@Before`注解预先配置模拟对象，所以这次我们在`webappBookApi`测试方法中直接进行配置，这与我们将要学习使用Spock框架编写测试时看到的风格相似。
- en: Inside the `given(...)` call, we pre-configure the behavior of the `BookRepository`
    mock object, instructing it to return a specific `Book` instance when its `findBookByIsbn`
    method gets called with `"978-1-78528-415-1"` as an argument.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`given(...)`调用内部，我们预先配置了`BookRepository`模拟对象的行为，指示它在`findBookByIsbn`方法被调用并传入参数`"978-1-78528-415-1"`时返回一个特定的`Book`实例。
- en: Our next call to `mockMvc.perform`with `/books/978-1-78528-415-1` triggers the
    invocation of the `BookController``getBook` method, which delegates the pre-wired
    mocked instance of `bookRepository` and uses our pre-configured `Book` object
    instance to run validation logic upon.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一次调用`mockMvc.perform`并传入`/books/978-1-78528-415-1`将触发`BookController`的`getBook`方法的调用，该方法委托预先连接的模拟实例`bookRepository`，并使用我们预先配置的`Book`对象实例来运行验证逻辑。
- en: As evident from the log, we can see that only the WebMvc layer has been bootstrapped.
    No database or other components have been initialized, which has resulted in significant
    savings in runtime, taking only 3 seconds compared to the 9 seconds it took for
    a complete application bootstrap test earlier.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志中可以看出，我们只能看到WebMvc层已经引导。没有初始化数据库或其他组件，这导致了运行时的显著节省，仅用3秒，而之前的完整应用程序引导测试需要9秒。
- en: Writing tests using Cucumber
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cucumber编写测试
- en: Unit testing has been an expected part of the software development life cycle
    for quite some time now, and one can hardly imagine writing code without having
    unit tests along with it. The art of testing does not stay the same, and advances
    in testing philosophies have extended the concept of unit testing even further,
    introducing things such as service testing, integration testing, and, lastly,
    what is known as BDD that proposes to create the test suites describing the application
    behavior at large without getting down to the minute implementation details at
    the lower levels of the code. One such framework, which has gained a lot of popularity
    first in the Ruby world and later expanding to other languages including Java,
    is the Cucumber BDD.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试已经很长时间是软件开发生命周期的一个预期部分，几乎没有人会想象编写没有单元测试的代码。测试的艺术并不停滞不前，测试哲学的进步甚至将单元测试的概念进一步扩展，引入了诸如服务测试、集成测试，最后是被称为BDD的测试，它建议创建描述应用程序行为的测试套件，而不必深入到代码较低层次的实现细节。这样一个在Ruby世界首先获得大量流行，后来扩展到包括Java在内的其他语言的框架是Cucumber
    BDD。
- en: For the purpose of this recipe, we will pick up on our previous example and
    continue enhancing the testing suite by adding the Cucumber-JVM implementation,
    which will provide us with the Java-based version of the original Ruby Cucumber
    framework, and create a few tests in order to demonstrate the capabilities and
    integration points with the Spring Boot application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，我们将继续使用之前的示例，通过添加Cucumber-JVM实现来增强测试套件，这将为我们提供原始Ruby Cucumber框架的Java版本，并创建一些测试来展示与Spring
    Boot应用程序的能力和集成点。
- en: This recipe is by no means intended to cover the entire set of functionalities
    provided by the Cucumber testing framework and is mostly focused on the integration
    points of Cucumber and Spring Boot. To learn more about Cucumber-JVM, you can
    go to [https://cukes.info/docs#cucumber-implementations](https://cukes.info/docs#cucumber-implementations)
    or [https://github.com/cucumber/cucumber-jvm](https://github.com/cucumber/cucumber-jvm)
    for details.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱绝不是为了涵盖Cucumber测试框架提供的所有功能，它主要关注Cucumber和Spring Boot的集成点。要了解更多关于Cucumber-JVM的信息，您可以访问[https://cukes.info/docs#cucumber-implementations](https://cukes.info/docs#cucumber-implementations)或[https://github.com/cucumber/cucumber-jvm](https://github.com/cucumber/cucumber-jvm)以获取详细信息。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The first thing that we need to do is add the necessary dependencies for the
    Cucumber libraries to our `build.gradle` file, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将Cucumber库的必要依赖项添加到我们的`build.gradle`文件中，如下所示：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will need to create a test driver class to run Cucumber tests. Let''s
    create a `RunCukeTests.java` file in the `src/test/java/com/example/bookpub` directory
    at the root of our project with the following content:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个测试驱动类来运行Cucumber测试。让我们在我们的项目根目录的`src/test/java/com/example/bookpub`目录下创建一个名为`RunCukeTests.java`的文件，并包含以下内容：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the driver class created, we are ready to start writing what Cucumber
    refers to as Step Definitions. I will talk briefly about what these are in the
    *How it works...* section of this recipe. For now, let''s create a `RepositoryStepdefs.java`
    file in the `src/test/java/com/example/bookpub` directory at the root of our project
    with the following content:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动类创建完成后，我们就准备好开始编写Cucumber所说的步骤定义了。我将在本菜谱的*如何工作...*部分简要介绍这些内容。现在，让我们在我们的项目根目录的`src/test/java/com/example/bookpub`目录下创建一个名为`RepositoryStepdefs.java`的文件，并包含以下内容：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we will need to create a corresponding testing feature definition file
    named `repositories.feature` in the `src/test/resources/com/example/bookpub` directory
    at the root of our project with the following content:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在项目根目录的`src/test/resources/com/example/bookpub`目录下创建一个名为`repositories.feature`的相应测试功能定义文件，内容如下：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, we will create one more data SQL file named `packt-books.sql` in the
    `src/test/resources` directory at the root of our project with the following content:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在项目根目录的`src/test/resources`目录下创建一个名为`packt-books.sql`的更多数据SQL文件，内容如下：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Execute the tests by running `./gradlew clean test` and the tests should get
    passed.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，测试应该会通过。
- en: With the addition of Cucumber, we also get the results of the tests in both
    the JUnit report and Cucumber-specific report HTML files. If we open `build/reports/tests/index.html`
    in the browser and click on the Classes button, we will see our scenario in the
    table, as shown in the following screenshot:![](img/2f667267-e14b-457e-9ecc-f67e44bbc81e.png)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着Cucumber的添加，我们也在JUnit报告和Cucumber特定的报告HTML文件中获得了测试结果。如果我们打开浏览器中的`build/reports/tests/index.html`并点击“类”按钮，我们将在表中看到我们的场景，如下面的截图所示！[](img/2f667267-e14b-457e-9ecc-f67e44bbc81e.png)
- en: 'Selecting the Scenario: Load one book link will take us to the detailed report
    page, as shown in the following screenshot:![](img/eb744c2f-eb47-4d40-a585-809d15dfc6c8.png)'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择场景：点击一个书籍链接将带我们到详细报告页面，如下面的截图所示！[](img/eb744c2f-eb47-4d40-a585-809d15dfc6c8.png)
- en: As we can see, the descriptions are nicer than the class and method names that
    we saw in the original JUnit-based test cases.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们所见，描述比我们在原始基于JUnit的测试用例中看到的类和方法名称更友好。
- en: Cucumber also generates its own report, which can be viewed by opening `build/reports/cucumber/index.html`
    in the browser.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cucumber还会生成自己的报告，可以通过在浏览器中打开`build/reports/cucumber/index.html`来查看。
- en: 'Being a behavior-driven testing framework, the feature files allow us not only
    to define individual conditions, but also to declare entire scenario outlines,
    which make the defining of multiple assertions of similar data easier. Let''s
    create another feature file named `restful.feature` in the `src/test/resources/com/example/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一种行为驱动测试框架，特征文件不仅允许我们定义单个条件，还可以声明整个场景概述，这使得定义多个类似数据的断言更容易。让我们在项目根目录的`src/test/resources/com/example/bookpub`目录中创建另一个名为`restful.feature`的特征文件，其内容如下：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will also create a corresponding `RestfulStepdefs.java` file in the `src/test/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在项目根目录的`src/test/java/com/example/bookpub`目录中创建一个相应的`RestfulStepdefs.java`文件，其内容如下：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to get passed.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，并且测试应该继续通过。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you feel a bit lost after looking at all this code and following along without
    having a full understanding of what exactly is going on, here you will find a
    detailed breakdown of everything that we did.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看了所有这些代码并跟随着，但没有完全理解到底发生了什么，这里将详细说明我们所做的一切。
- en: Let's start with a quick overview of what **Step Definitions** are. As the Cucumber
    framework uses the **Gherkin** feature document files in order to describe the
    business rules that are to be tested, which are represented in the form of English-like
    sentence statements, these need to be translated into executable code. This is
    the job of the Step Definition classes. Every step in a defined feature scenario
    needs to be matched to a method in a Step Definition class that will execute it.
    This matching is done by declaring a regular expression in the step annotations
    above the methods. The regex contains the matching groups that Cucumber uses so
    as to extract the method arguments and pass them to the executing method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对**步骤定义**的快速概述开始。由于Cucumber框架使用**Gherkin**特征文档文件来描述要测试的业务规则，这些规则以类似英语的句子陈述形式表示，因此这些规则需要被转换成可执行代码。这就是步骤定义类的工作。定义的特征场景中的每个步骤都需要与步骤定义类中的一个方法相匹配，以便执行它。这种匹配是通过在方法上方的步骤注释中声明正则表达式来完成的。正则表达式包含Cucumber使用的匹配组，以便提取方法参数并将它们传递给执行方法。
- en: 'In `RepositoryStepdefs`, we can see this in the following method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RepositoryStepdefs`中，我们可以在以下方法中看到这一点：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `@Given` annotation contains the regular expression that matches the `Given
    packt-books fixture is loaded` text, loaded from `repositories.feature` file,
    and extracts the `packt-books` text from the pattern, which is then passed as
    a `fixtureName` argument to the method. The `@When` and `@Then` annotations work
    on exactly the same principle. So, in effect, what the Cucumber framework does
    is it matches the English-like worded rules from the feature files to the matched
    patterns of the executing methods and extracts parts of the rules as arguments
    to the matched methods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Given` 注解包含匹配 `Given packt-books fixture is loaded` 文本的正则表达式，该文本从 `repositories.feature`
    文件加载，并从模式中提取 `packt-books` 文本，然后将其作为 `fixtureName` 参数传递给方法。`@When` 和 `@Then` 注解按照完全相同的原则工作。因此，实际上
    Cucumber 框架所做的就是将特性文件中的类似英语的规则与执行方法的匹配模式相匹配，并将规则的部分作为参数传递给匹配的方法。'
- en: More information on Gherkin and how to use it can be found at [https://cukes.info/docs/reference#gherkin](https://cukes.info/docs/reference#gherkin).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Gherkin 及其使用方法的信息可以在 [https://cukes.info/docs/reference#gherkin](https://cukes.info/docs/reference#gherkin)
    找到。
- en: With the basic Cucumber overview explained, let's shift our focus to how the
    tests integrate with Spring Boot and are configured.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了 Cucumber 的基本概述后，让我们将注意力转向测试如何与 Spring Boot 集成以及如何进行配置。
- en: 'It all starts with the driver harness class, which in our case is `RunCukeTests`.
    This class itself does not contain any tests, but it has two important annotations
    that stitch things together, `@RunWith(Cucumber.class)` and `@CucumberOptions`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都始于驱动程序工具类，在我们的案例中是 `RunCukeTests`。这个类本身不包含任何测试，但它有两个重要的注解来连接这些元素，`@RunWith(Cucumber.class)`
    和 `@CucumberOptions`：
- en: '`@RunWith(Cucumber.class)`: This is a JUnit annotation that indicates that
    JUnit runner should use the Cucumber feature files to execute the tests.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RunWith(Cucumber.class)`: 这是一个 JUnit 注解，表示 JUnit 运行器应该使用 Cucumber 特性文件来执行测试。'
- en: '`@CucumberOptions`: This provides additional configuration for Cucumber:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`@CucumberOptions`: 这为 Cucumber 提供了额外的配置：'
- en: '`plugin={"pretty", "html:build/reports/cucumber"}`: This tells Cucumber to
    generate its reports in HTML format in the `build/reports/cucumber` directory.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugin={"pretty", "html:build/reports/cucumber"}`: 这告诉 Cucumber 在 `build/reports/cucumber`
    目录中以 HTML 格式生成其报告。'
- en: '`glue = {"cucumber.api.spring", "classpath:com.example.bookpub"}`: This is
    a very important setting, as it tells Cucumber which packages to load and from
    where to load them during the execution of the tests. The `cucumber.api.spring`
    package needs to be present in order to take advantage of the `cucumber-spring`
    integration library, and the `com.example.bookpub` package is the location of
    our Step Definition implementation classes.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glue = {"cucumber.api.spring", "classpath:com.example.bookpub"}`: 这是一个非常重要的设置，因为它告诉
    Cucumber 在测试执行期间要加载哪些包以及从哪里加载它们。`cucumber.api.spring` 包需要存在，以便利用 `cucumber-spring`
    集成库，而 `com.example.bookpub` 包是我们步骤定义实现类的位置。'
- en: '`monochrome = true`: This tells Cucumber not to print the output with the ANSI
    color as we integrate with JUnit, as it will not look correct in the saved console
    output files.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monochrome = true`: 这告诉 Cucumber 在与 JUnit 集成时不要使用 ANSI 颜色打印输出，因为这在保存的控制台输出文件中看起来不会正确。'
- en: A complete list of the options can be found at [https://cukes.info/docs/reference/jvm#list-all-options](https://cukes.info/docs/reference/jvm#list-all-options).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 选项的完整列表可以在 [https://cukes.info/docs/reference/jvm#list-all-options](https://cukes.info/docs/reference/jvm#list-all-options)
    找到。
- en: 'Now let''s look at the `RepositoryStepdefs` class. It starts with the following
    annotations at the class level:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `RepositoryStepdefs` 类。它在类级别开始于以下注解：
- en: '`@WebAppConfiguration` instructs Spring that this class needs `WebApplicationContext` to
    be initialized, and it will be used for testing purposes during the execution'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebAppConfiguration` 指示 Spring 该类需要初始化 `WebApplicationContext`，并在执行过程中用于测试目的。'
- en: '`@ContextConfiguration(classes = BookPubApplication.class` and `loader = SpringBootContextLoader.class)`
    instruct Spring to use the `BookPubApplication` class as a configuration for the
    Spring application context, as well as to use the `SpringBootContextLoader` class
    from Spring Boot in order to bootstrap the testing harness'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ContextConfiguration(classes = BookPubApplication.class` 和 `loader = SpringBootContextLoader.class)`
    指示 Spring 使用 `BookPubApplication` 类作为 Spring 应用程序上下文的配置，以及使用 Spring Boot 中的 `SpringBootContextLoader`
    类来引导测试工具。'
- en: It is important to note that these annotations have to match  all the Step Definition
    classes, or only one of the classes will be annotated with the `@ContextConfiguration`
    annotation to wire in the Spring support for the Cucumber test.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这些注释必须与所有步骤定义类匹配，否则只有其中一个类会被`@ContextConfiguration`注释标注，以便将Spring对Cucumber测试的支持连接起来。
- en: As the `cucumber-spring` integration does not know about Spring Boot but only
    about Spring, we can't use the `@SpringBootTest` meta-annotation. We have to resort
    to using only the annotations from Spring in order to stitch things together.
    Thankfully, we don't have to go through many hoops, but just declare the exact
    annotation that `SpringBootTest` facades by passing the desired configuration
    classes and loader.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`cucumber-spring`集成不了解Spring Boot，只知道Spring，所以我们不能使用`@SpringBootTest`元注释。我们必须求助于仅使用Spring的注释来将事物连接起来。幸运的是，我们不必经历许多繁琐的过程，只需通过传递所需的配置类和加载器来声明`SpringBootTest`封装的确切注释即可。
- en: Once the proper annotations are in place, Spring and Spring Boot will take over
    and provide us with the same convenience of autowiring beans as dependencies of
    our Step Definition classes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦放置了适当的注释，Spring和Spring Boot将接管并提供与我们的步骤定义类依赖项自动装配相同的便利性。
- en: One interesting characteristic of the Cucumber tests is the instantiation of
    a new instance of the Step Definition class for every execution of a **Scenario**.
    Even though the method namespace is global—meaning that we can use the methods
    that are declared in the different Step Definition classes—they operate on states
    defined in them and are not directly shared. It is, however, possible to `@Autowire`
    an instance of another Step Definition in a different Step Definition instance
    and rely on public methods or fields to access and mutate the data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber测试的一个有趣特性是为每次执行**场景**创建一个新的步骤定义类实例。尽管方法命名空间是全局的——这意味着我们可以使用在不同步骤定义类中声明的各种方法——但它们操作的是它们中定义的状态，并且不是直接共享的。然而，在另一个步骤定义实例中`@Autowire`另一个步骤定义的实例是可能的，并依赖于公共方法或字段来访问和修改数据。
- en: As a new instance gets created per scenario, the definition classes are stateful
    and rely on internal variables to keep a state among transitions from assertion
    to assertion. For example, in the `@When` annotated method, a particular state
    gets set, and in the `@Then` annotated method, a set of assertions on that state
    get evaluated. In our example of the `RepositoryStepdefs` class, we will internally
    set the state of the `loadedBook` class variable in its `searching_for_book_by_isbn(...)` method,
    which later gets used to assert on so as to verify the match of the book's title
    in the `book_title_will_be(...)` method afterwards. Due to this, if we mix the
    rules from the different definition classes in our feature files, the internal
    states would not be accessible among the multiple classes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个场景都会创建一个新的实例，定义类是具有状态的，并且依赖于内部变量在断言之间的转换中保持状态。例如，在`@When`标注的方法中，设置特定的状态，而在`@Then`标注的方法中，对该状态的断言集将被评估。在我们的`RepositoryStepdefs`类示例中，我们将在其`searching_for_book_by_isbn(...)`方法中内部设置`loadedBook`类变量的状态，稍后它将被用于在`book_title_will_be(...)`方法中断言，以验证书籍标题的匹配。因此，如果我们在我们特征文件中混合来自不同定义类的规则，内部状态将无法在多个类之间访问。
- en: When integrating with Spring, one can use the injection of the mocked objects—as
    we have seen in `MockPublisherRepositoryTests` from one of our previous examples—and
    can have the shared `@Given` annotated method be used to set up the particular
    behavior of the mock for the given test. Then we can use the same dependency instance
    and inject it into another definition class that can be used in order to evaluate
    the `@Then` annotated assertion methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Spring集成时，可以使用模拟对象的注入——正如我们在之前的示例中在`MockPublisherRepositoryTests`中看到的——并且可以使用共享的`@Given`标注方法来设置特定测试的模拟行为。然后我们可以使用相同的依赖实例并将其注入到另一个定义类中，以便用于评估`@Then`标注的断言方法。
- en: Another approach is the one that we saw in the second definition class, `RestfulStepdefs`,
    where we injected `BookRepository`. However, in `restful.feature`, we will be
    using the `Given packt-books fixture is loaded` behavior declaration that translates
    to the invocation of `data_fixture_is_loaded` method from the `RepositoryStepdefs` class,
    which shares the same instance of the injected `BookRepository` object, inserting
    the `packt-books.sql` data into it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是我们在第二个定义类中看到的，即`RestfulStepdefs`，其中我们注入了`BookRepository`。然而，在`restful.feature`中，我们将使用`Given
    packt-books fixture is loaded`行为声明，这相当于从`RepositoryStepdefs`类调用`data_fixture_is_loaded`方法，该类共享相同的注入`BookRepository`对象实例，将其中的`packt-books.sql`数据插入其中。
- en: If we were to have a need to access the value of the `loadedBook` field from
    the `RepositoryStepdefs` instance inside the `RestfulStepdefs` class, we could
    declare the `@Autowired RepositoryStepdefs` field inside `RestfulStepdefs` and
    make the `loadedBook` field `public` instead of `private` to make it accessible
    to the outside world.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在`RestfulStepdefs`类内部访问`RepositoryStepdefs`实例中的`loadedBook`字段值，我们可以在`RestfulStepdefs`内部声明`@Autowired
    RepositoryStepdefs`字段，并将`loadedBook`字段设置为`public`而不是`private`，以便使其对外部世界可访问。
- en: Another neat feature of the Cucumber and Spring integration is the use of the
    `@txn` annotation in the feature files. This tells Spring to execute the tests
    in a transaction wrapper, reset the database between the test executions, and
    guarantee a clean database state for every test.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber和Spring集成的另一个巧妙功能是在特性文件中使用`@txn`注解。这告诉Spring在事务包装器中执行测试，在测试执行之间重置数据库，并保证每个测试都有一个干净的数据库状态。
- en: Due to the global method namespace among all the Step Definition classes and
    test behavior defining feature files, we can use the power of Spring injection
    to our advantage so as to reuse the testing models and have a common setup logic
    for all of the tests. This makes the tests behave similarly to how our application
    would function in a real production environment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有步骤定义类之间的全局方法命名空间和定义特性文件的测试行为，我们可以利用Spring注入的力量，以便重用测试模型并为所有测试提供一个共同的设置逻辑。这使得测试的行为类似于我们的应用程序在实际生产环境中的功能。
- en: Writing tests using Spock
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spock编写测试
- en: Another no-less-popular testing framework is Spock, which was written in Groovy
    by Peter Niederwieser. Being a Groovy-based framework, it is ideally suited to
    create testing suites for a majority of the JVM-based languages, especially for
    Java and Groovy itself. The dynamic language traits of Groovy make it well suited
    to write elegant, efficient, and expressive specifications in the Groovy language
    without the need for translations. It is done in Cucumber with the help of the
    Gherkin library. Being based on top of JUnit, and integrating with it through
    the JUnit's `@RunWith` facility, just like Cucumber does, it is an easy enhancement
    to the traditional unit tests and works well with all the existing tools, which
    have built-in support or integration with JUnit.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个同样受欢迎的测试框架是Spock，它是由Peter Niederwieser用Groovy编写的。作为一个基于Groovy的框架，它非常适合为大多数基于JVM的语言创建测试套件，尤其是Java和Groovy本身。Groovy的动态语言特性使得在Groovy语言中编写优雅、高效和表达性的规范变得非常合适，无需翻译。这是通过Cucumber和Gherkin库实现的。基于JUnit之上，并通过JUnit的`@RunWith`功能与之集成，就像Cucumber做的那样，它是对传统单元测试的一个简单增强，并且与所有现有工具配合良好，这些工具内置了对JUnit的支持或集成。
- en: In this recipe, we will pick up from where the previous recipe left off and
    enhance our test collection with a couple of Spock-based tests. In these tests,
    we will see how to set up MockMVC using the Spring dependency injection and testing
    harnesses. These will be used by the Spock test specifications in order to validate
    the fact that our data repository services will return the data as expected.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从上一个菜谱留下的地方开始，并使用几个基于Spock的测试来增强我们的测试集合。在这些测试中，我们将看到如何使用Spring依赖注入和测试工具来设置MockMVC。这些将被Spock测试规范用来验证我们的数据存储服务将返回预期的数据。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to add the Spock tests to our application, we will need to make a
    few changes to our `build.gradle` file first. As Spock tests are written in Groovy,
    the first thing to do is add a `groovy` plugin to our `build.gradle` file, as
    follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将Spock测试添加到我们的应用程序中，我们首先需要修改我们的`build.gradle`文件。由于Spock测试是用Groovy编写的，所以首先要做的是在我们的`build.gradle`文件中添加一个`groovy`插件，如下所示：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will also need to add the necessary Spock framework dependencies to the
    `build.gradle` dependencies block:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将必要的Spock框架依赖项添加到`build.gradle`依赖项块中：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As the tests will be in Groovy, we will need to create a new source directory
    for the files. Let's create the `src/test/groovy/com/example/bookpub` directory
    in the root of our project.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于测试将使用Groovy编写，我们需要为文件创建一个新的源目录。让我们在项目根目录中创建`src/test/groovy/com/example/bookpub`目录。
- en: 'Now we are ready to write our first test. Create a `SpockBookRepositorySpecification.groovy`
    file in the `src/test/groovy/com/example/bookpub` directory at the root of our
    project with the following content:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写我们的第一个测试了。在项目根目录下的`src/test/groovy/com/example/bookpub`目录中创建一个名为`SpockBookRepositorySpecification.groovy`的文件，并包含以下内容：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Execute the tests by running `./gradlew clean test` and the tests should get
    passed.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，并且测试应该通过。
- en: 'As Spock integrates with JUnit, we can see the execution report of the Spock
    tests together with the rest of our test suite. If we open `build/reports/tests/index.html`
    in the browser and click the Classes button, we will see our specification in
    the table, as shown in the following screenshot:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Spock与JUnit集成，我们可以看到Spock测试的执行报告与我们的其他测试套件一起。如果我们打开浏览器中的`build/reports/tests/index.html`并点击“类”按钮，我们将在表中看到我们的规范，如下面的截图所示：
- en: '![](img/a534256a-f4a6-4297-995e-5e37da0f0deb.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a534256a-f4a6-4297-995e-5e37da0f0deb.png)'
- en: 'Selecting the com.example.bookpub.SpockBookRespositorySpecification link will
    take us to the detailed report page, which is as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`com.example.bookpub.SpockBookRespositorySpecification`链接将带我们到详细报告页面，如下所示：
- en: '![](img/a2d3fda6-0523-4366-a865-e45b874fdb76.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2d3fda6-0523-4366-a865-e45b874fdb76.png)'
- en: 'Next, we will take our tests a bit further and explore the mocking functionality
    of the database repositories. Let''s use `PublisherRepository` as our candidate
    to mock, and wire it into the `BookController` class to provide a `getBooksByPublisher`
    functionality. Let''s add the following content to the `BookController` class
    in the `src/main/java/com/example/bookpub/controllers` directory at the root of
    our project:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将进一步扩展我们的测试，并探索数据库仓库的模拟功能。让我们以`PublisherRepository`作为我们的模拟候选，并将其连接到`BookController`类以提供`getBooksByPublisher`功能。让我们将以下内容添加到项目根目录下的`src/main/java/com/example/bookpub/controllers`目录中的`BookController`类中：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s add the following to the `Publisher` class in the `src/main/java/com/example/bookpub/entity`
    directory at the root of our project:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将以下内容添加到项目根目录下的`src/main/java/com/example/bookpub/entity`目录中的`Publisher`类中：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lastly, let''s add a getter and setter for the books to the `Publisher` entity
    class as well:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将获取器和设置器添加到`Publisher`实体类中的书籍属性：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With all the code additions completed, we are ready to add another test to
    the `SpockBookRepositorySpecification.groovy` file in the `src/test/groovy/com/example/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成所有代码添加后，我们准备向项目根目录下的`src/test/groovy/com/example/bookpub`目录中的`SpockBookRepositorySpecification.groovy`文件添加另一个测试，内容如下：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to get passed.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean test`来执行测试，并且测试应该继续通过。
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you saw from this example, writing tests can be just as elaborate and sophisticated
    as the production code being tested itself. Let's examine the steps that we took
    in order to get the Spock tests integrated into our Spring Boot application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本示例中看到的，编写测试可以像被测试的生产代码本身一样详细和复杂。让我们检查我们为了将Spock测试集成到我们的Spring Boot应用程序中而采取的步骤。
- en: The first thing that we did was to add a Groovy plugin in order to make our
    build Groovy-friendly, and we also added the required Spock library dependencies
    of `spock-core` and `spock-spring`, both of which are required to make Spock work
    with Spring's dependency injection and contexts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加了一个Groovy插件，以便使我们的构建对Groovy友好，我们还添加了所需的Spock库依赖项`spock-core`和`spock-spring`，这两者都是使Spock与Spring的依赖注入和上下文一起工作所必需的。
- en: The next step was to create the `SpockBookRepositorySpecification` Spock specification,
    which extends the Spock's specification abstract base class. Extending the `Specification`
    class is very important because this is how JUnit knows that our class is the
    test class that needs to be executed. If we look in the `Specification` source,
    we will see the `@RunWith(Sputnik.class)` annotation, just like the one that we
    used in the Cucumber recipe. In addition to the JUnit bootstrapping, the `Specification`
    class provides us with many helpful methods and mocking support as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 `SpockBookRepositorySpecification` Spock 规范，它扩展了 Spock 的规范抽象基类。扩展 `Specification`
    类非常重要，因为这是 JUnit 知道我们的类是需要执行测试类的方式。如果我们查看 `Specification` 源代码，我们会看到 `@RunWith(Sputnik.class)`
    注解，就像我们在 Cucumber 菜谱中使用的那样。除了 JUnit 引导之外，`Specification` 类还为我们提供了许多有用的方法和模拟支持。
- en: For more information about the detailed capabilities that are offered by Spock,
    you can refer to the Spock documentation that is available at [http://spockframework.github.io/spock/docs/current/index.html](http://spockframework.github.io/spock/docs/current/index.html).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Spock 提供的详细功能，你可以参考可用的 Spock 文档，网址为 [http://spockframework.github.io/spock/docs/current/index.html](http://spockframework.org/spock/docs/current/index.html)。
- en: 'It is also worth mentioning that we used the same annotations for the `SpockBookRepositorySpecification`
    class as we did for our Spring Boot-based tests, as shown in the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们为 `SpockBookRepositorySpecification` 类使用了与我们的基于 Spring Boot 的测试相同的注解，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The reason that we had to add `@AutoConfigureMockMvc` in addition to `@SpringBootTest`
    is to add functionality to allow us to use the `@Autowire MockMvc` instance instead
    of having to create one ourselves. Regular `@SpringBootTest` does not automatically
    create and configure an instance of a `MockMvc` object, so we could have either
    created it manually, as we did in `BookPubApplicationTests`, or added the `@AutoConfigureMockMvc`
    annotation, which is what gets used inside `@WebMvcTest`, to let Spring handle
    it for us. The good news is that we can always use the same annotation compositions
    as used by Spring Boot, and annotate our classes directly, which is exactly what
    we did.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以必须添加 `@AutoConfigureMockMvc` 而不是仅仅使用 `@SpringBootTest`，是为了添加功能，允许我们使用 `@Autowire
    MockMvc` 实例，而不是必须自己创建它。常规的 `@SpringBootTest` 并不会自动创建和配置 `MockMvc` 对象的实例，因此我们可能需要手动创建，就像我们在
    `BookPubApplicationTests` 中所做的那样，或者添加 `@AutoConfigureMockMvc` 注解，这是在 `@WebMvcTest`
    内部使用的，让 Spring 为我们处理它。好消息是我们可以始终使用与 Spring Boot 相同的注解组合，并直接注解我们的类，这正是我们所做的。
- en: 'Unlike Cucumber, Spock combines all the aspects of the test in one `Specification`
    class, dividing it into multiple blocks, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Cucumber 不同，Spock 将测试的所有方面结合在一个 `Specification` 类中，将其划分为多个块，如下所示：
- en: '`setup`: This block is used to configure the specific test with variables,
    populating data, building mocks, and so on.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup`: 这个块用于配置特定的测试，包括变量设置、数据填充、构建模拟对象等。'
- en: '`expect`: This block is one of the stimulus blocks, as Spock defines it, designed
    to contain simple expressions asserting a state or condition. Besides evaluating
    the conditions, we can only define variables in this block, and nothing else is
    allowed.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`: 这个块是 Spock 定义的一个刺激块，设计用来包含简单的表达式，断言状态或条件。除了评估条件之外，我们只能在这个块中定义变量，不允许做其他任何事情。'
- en: '`when`: This block is another stimulus type block, which always goes together
    with `then`. It can contain any arbitrary code and is designed to define the behavior
    that we are trying to test.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when`: 这个块是另一种刺激类型块，它总是与 `then` 一起使用。它可以包含任何任意代码，并设计用来定义我们试图测试的行为。'
- en: '`then`: This block is a response type block. It is similar to `expect` and
    can only contain conditions, exception checking, variable definition, and object
    interactions, such as how many times a particular method has been called and so
    forth.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then`: 这个块是一个响应类型块。它与 `expect` 类似，只能包含条件、异常检查、变量定义和对象交互，例如特定方法被调用的次数等。'
- en: More information on interaction testing is available on Spock's website at [http://spockframework.github.io/spock/docs/current/interaction_based_testing.html](http://spockframework.org/spock/docs/1.0/interaction_based_testing.html).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 关于交互测试的更多信息可以在 Spock 的网站上找到，网址为 [http://spockframework.github.io/spock/docs/current/interaction_based_testing.html](http://spockframework.org/spock/docs/1.0/interaction_based_testing.html)。
- en: '`cleanup`: This block is used to clean the state of the environment and potentially
    undo whatever changes were done as part of the individual test execution. In our
    recipe, this is where we will reset our `PublisherRepository` mock object.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cleanup`：这个块用于清理环境的状态，并可能撤销作为单个测试执行部分所做的任何更改。在我们的配方中，这是我们重置`PublisherRepository`模拟对象的地方。'
- en: Spock provides us with the instance-based `setup()` and `cleanup()` methods
    as well, which can be used to define the setup and cleanup behavior that is common
    to all the tests in the specification.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Spock还为我们提供了基于实例的`setup()`和`cleanup()`方法，这些方法可以用来定义适用于规范中所有测试的通用设置和清理行为。
- en: If we look at our `setup()` method, this is where we can configure the database
    population with the test data. An interesting and important nuance is that the `setup()`
    method gets executed before every test method, not once per class. It is important
    to keep that in mind when doing things like populating a database to avoid re-insertion
    of the same data multiple times without proper rollback.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看我们的`setup()`方法，这就是我们可以配置数据库以测试数据填充的地方。一个有趣且重要的细微差别是，`setup()`方法在每次测试方法之前执行，而不是每个类执行一次。在做诸如填充数据库之类的事情时，这一点很重要，以避免在不适当的回滚下多次重新插入相同的数据。
- en: To help us with that is the `@Transactional` annotation of the test methods.
    Just like the `@txn` tag in the Cucumber feature files, this annotation instructs
    Spock to execute the annotated method and its corresponding `setup()` and `cleanup()`
    executions with a transaction scope, which get rolled back after the particular
    test method is finished. We rely on this behavior to get a clean database state
    for every test, so we don't end up inserting duplicate data during the execution
    of the `setup()` method every time each of our tests runs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助我们实现这一点的就是测试方法的`@Transactional`注解。就像Cucumber功能文件中的`@txn`标签一样，这个注解指示Spock以事务作用域执行注解方法及其相应的`setup()`和`cleanup()`执行，这些执行在特定测试方法完成后会被回滚。我们依赖于这种行为来为每个测试获得一个干净的数据库状态，这样我们就不需要在每次运行每个测试时在`setup()`方法的执行中插入重复的数据。
- en: Most of you are probably wondering why we had to add the `@JsonBackReference`
    annotation to our `Publisher` entity class. The answer has to do with the Jackson
    JSON parser and how it handles circular dependency. In our model, we have a book
    belonging to a publisher and each publisher has multiple books. When we created
    our `Publisher` class with the `Books` mock and assigned a publisher instance
    to a book—which later got put in the publisher's book collection—we created a
    circular reference. During the execution of the `BookController.getBooksByPublisher(...)`
    method, the Jackson renderer would have thrown `StackOverflowError` while trying
    to write the object model to JSON. By adding this annotation to `Publisher`, we
    told Jackson how the objects reference each other, so instead of trying to write
    out the complete object tree, Jackson now handles it correctly, thus avoiding
    the circular reference loop situation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人可能都在想，为什么我们不得不在我们的`Publisher`实体类中添加`@JsonBackReference`注解。答案与Jackson JSON解析器及其处理循环依赖的方式有关。在我们的模型中，我们有一本书属于一个出版社，每个出版社有多本书。当我们用`Books`模拟创建`Publisher`类并将一个出版社实例分配给一本书——后来这本书被放入出版社的书籍集合中——我们就创建了一个循环引用。在执行`BookController.getBooksByPublisher(...)`方法期间，Jackson渲染器在尝试将对象模型写入JSON时可能会抛出`StackOverflowError`。通过在`Publisher`上添加这个注解，我们告诉Jackson对象是如何相互引用的，因此，Jackson现在正确地处理它，从而避免了循环引用循环的情况。
- en: The last thing that is important to keep in mind is how Spring Boot handles
    and processes the repository interfaces that are annotated with `@RepositoryRestResource`.
    Unlike the `BookRepository` interface, which we have annotated with a plain `@Repository`
    annotation and later explicitly declared as an autowire dependency of our `BookController`
    class, we did not create an explicit controller to handle RESTful requests for
    the rest of our repository interfaces such as `PublisherRepository` and others.
    These interfaces get scanned by Spring Boot and automatically wrapped with the
    mapped endpoints that trap the requests and delegate the calls to the backing
    `SimpleJpaRepository` proxy. Due to this setup, we can use only the mock object
    replacement approach for these objects that have been explicitly injected as bean
    dependencies such as with our example of `BookRepository`. The good news is that
    in these situations, where we don't explicitly expect beans to be wired and only
    use some annotations to stereotype the interfaces for Spring Boot to do its magic,
    we can rely on Spring Boot to do the job correctly. We know that it has tested
    all the functionalities behind it so that we don't have to test them. To test
    the actual repository and entity functionality, we can use the `@DataJpaTest`
    annotation to do a specific JPA slice test instead.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要记住的重要一点是Spring Boot如何处理和加工被`@RepositoryRestResource`注解的仓库接口。与被我们用普通的`@Repository`注解注解的`BookRepository`接口不同，我们后来明确将其声明为`BookController`类的自动装配依赖项，我们没有为其他仓库接口（如`PublisherRepository`等）创建显式的控制器来处理RESTful请求。这些接口会被Spring
    Boot扫描，并自动包装成映射的端点，捕获请求并将调用委托给后端的`SimpleJpaRepository`代理。由于这种设置，我们只能为这些被明确注入为bean依赖项的对象（例如我们的`BookRepository`示例）使用模拟对象替换方法。好消息是，在这些情况下，我们并没有明确期望bean进行连接，只是使用一些注解来为Spring
    Boot提供接口的元数据以执行其魔法，我们可以依赖Spring Boot正确地完成这项工作。我们知道它已经测试了其背后的所有功能，所以我们不需要测试它们。为了测试实际的仓库和实体功能，我们可以使用`@DataJpaTest`注解来进行特定的JPA切片测试。
