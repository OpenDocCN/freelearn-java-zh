- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Wrapping Business Rules inside Domain Hexagon
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在领域六边形内封装业务规则
- en: In the previous chapter, we learned about the Domain as the first hexagon in
    hexagonal architecture. By being the innermost hexagon, the Domain does not depend
    on any code from the Application and Framework hexagons. Also, we make all the
    other hexagons depend on the Domain to conduct their operations. This kind of
    arrangement confers the Domain hexagon a degree of responsibility and relevance
    far higher than other hexagons. We employ such an arrangement because it is in
    the Domain where we group all the business rules and data that most represent
    the problem we try to solve.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了领域作为六边形架构中的第一个六边形。由于是内层六边形，领域不依赖于应用和框架六边形中的任何代码。我们还让所有其他六边形都依赖于领域来执行它们的操作。这种安排使领域六边形具有比其他六边形更高的责任和相关性。我们采用这种安排是因为在领域中，我们汇集了所有代表我们试图解决的问题的最具代表性的业务规则和数据。
- en: Among the techniques to model a problem domain, **Domain-Driven Design** (**DDD**)
    is widely adopted in projects that emphasize software code as a medium to convey
    knowledge about a business. An ever-present concern to separate what constitutes
    the core problem domain and what is secondary to it makes DDD a suitable approach
    to support the hexagonal architecture goal of separating technology code from
    business code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模问题域的技术中，**领域驱动设计**（**DDD**）在强调将软件代码作为传达业务知识媒介的项目中被广泛采用。一个持续的担忧是区分构成核心问题域的内容和次要内容，这使得
    DDD 成为支持六边形架构目标——将技术代码与业务代码分离——的合适方法。
- en: The principles and techniques we will see in this chapter will serve as the
    basis to build the Domain hexagon.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将看到的原理和技术将作为构建领域六边形的基石。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Modeling a problem domain with entities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实体建模问题域
- en: Enhancing descriptiveness with value objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用值对象增强描述性
- en: Assuring consistency with aggregates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保聚合的一致性
- en: Working with domain services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与领域服务一起工作
- en: Using policy and specification patterns to deal with business rules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略和规范模式处理业务规则
- en: Defining business rules as **Plain Old Java** **Objects** (**POJOs**)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将业务规则定义为**普通 Java 对象**（**POJOs**）
- en: By the end of this chapter, you will have learned the building blocks of DDD
    and will be able to apply the presented concepts in the development of hexagonal
    applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会 DDD 的基本构建块，并能够将所介绍的概念应用于六边形应用的开发。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: To compile and run the code examples presented in this chapter, you need the
    latest **Java Standard Edition** (**SE**) development kit and **Maven 3.8** installed
    on your computer. They are all available for the Linux, Mac, and Windows operating
    systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中提供的代码示例，你需要在你的计算机上安装最新的**Java 标准版**（**SE**）开发工具包和**Maven 3.8**。它们都适用于
    Linux、Mac 和 Windows 操作系统。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter02).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码文件，链接为 [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter02)。
- en: Modeling a problem domain with entities
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实体建模问题域
- en: In DDD, before any code is written, there must be lots of discussions between
    developers and domain experts—the people who have a deep understanding of their
    business, which may include other developers as well. Those discussions provide
    valuable information, acquired through a process called knowledge crunching, which
    is based on brainstorming between those developers and domain experts. That knowledge
    is then incorporated into the **ubiquitous language**. This language works as
    the *lingua franca* among everyone involved in the project and is present in documentation,
    day-to-day conversations, and – of course – in code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DDD 中，在编写任何代码之前，开发者和领域专家之间必须进行大量的讨论——这些人对其业务有深刻的理解，可能包括其他开发者。这些讨论提供了宝贵的信息，这些信息是通过知识压缩过程获得的，该过程基于开发者和领域专家之间的头脑风暴。然后，这种知识被纳入**通用语言**。这种语言在所有参与项目的人之间作为**通用语言**使用，存在于文档、日常对话中——当然，也在代码中。
- en: When we deal with entities, we must always pay attention to how much we can
    learn about a business by just reading code. Even though just reading code may
    not be enough. That’s when techniques such as knowledge-crunching, where we speak
    with domain experts to learn more about a business, are instrumental in helping
    us continuously evolve the ubiquitous language and translate the business knowledge
    into working code. That’s the basis for rich entities that really capture relevant
    behaviors and are more than mere data objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理实体时，我们必须始终注意仅通过阅读代码就能了解多少关于业务的信息。尽管仅仅阅读代码可能还不够。这时，像知识压缩这样的技术就变得至关重要，我们通过与领域专家交谈来了解更多关于业务的信息，这有助于我们不断演进通用语言并将业务知识转化为工作代码。这是真正捕捉相关行为并不仅仅是数据对象的丰富实体的基础。
- en: For an entity to be considered an entity, it must have an identity; so, we’ll
    see how to assign identity in a way that is aligned with the hexagonal architecture
    goal to separate concerns between business and technology code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个实体被视为实体，它必须有一个身份；因此，我们将看到如何以与六边形架构目标一致的方式分配身份，以在业务和技术代码之间分离关注点。
- en: The purity of domain entities
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域实体的纯粹性
- en: When we model a problem domain, the main focus is to capture, as precisely as
    possible, a real-life scenario in code. That scenario is often composed of several
    processes working together to support an organization’s goals to meet customer
    expectations. This ability to fulfill customer needs will ultimately determine
    the organization’s capacity to generate profit. So, the problem-domain modeling
    effort is crucial to determine the overall success of any organization that relies
    on its software to make money. A failure to understand and translate business
    requirements into code will obviously result in not satisfied customer expectations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们建模问题域时，主要重点是尽可能精确地用代码捕捉现实生活中的场景。这个场景通常由几个协同工作的流程组成，以支持组织的目标，满足客户期望。满足客户需求的能力最终将决定组织的盈利能力。因此，问题域建模的努力对于确定任何依赖其软件赚钱的组织总体成功至关重要。未能理解和将业务需求转化为代码显然会导致客户期望得不到满足。
- en: Central to that problem-domain modeling effort is the creation of entities.
    Due to the proximity entities have to business requirements, we should strive
    to shield these entities from technical requirements. We do this to prevent the
    blurring of business-related code with technology-related code. By technology,
    I mean those things that exist and make sense only in the context of software.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那个问题域建模工作的核心是实体的创建。由于实体与业务需求之间的邻近性，我们应该努力保护这些实体免受技术需求的影响。我们这样做是为了防止与业务相关的代码与技术相关的代码混淆。在这里，我指的是那些仅在软件上下文中存在并具有意义的那些事物。
- en: Those same technology concerns would not make sense if we were only considering
    the business requirements without the software. We also have to recognize that
    a problem domain may not always refer to pure business requirements. A problem
    domain may be purely technological, such as creating a new development framework.
    I don’t think hexagonal architecture is the best approach in those scenarios because
    its emphasis is on projects trying to solve conventional business problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只考虑业务需求而不考虑软件，那些相同的技术担忧就不再有意义。我们还得认识到，问题域可能并不总是指纯业务需求。问题域可能完全是技术性的，例如创建一个新的开发框架。我认为在这些情况下，六边形架构并不是最佳方法，因为它的重点在于试图解决传统业务问题的项目。
- en: Domain entities should be pure in the sense that they deal only with business
    concerns. For technology-specific things, we have the option to utilize ports,
    use cases, and adapters, as we’ll see in the following chapters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 领域实体应该纯粹地处理业务关注点。对于特定于技术的事情，我们有选择使用端口、用例和适配器的选项，正如我们将在以下章节中看到的。
- en: Relevant entities
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关实体
- en: A relevant entity is characterized by the presence of two elements – business
    rules and business data. It is not unusual to see entity classes modeled almost
    like database entity objects that express only the data part and forget the business
    rules represented through the behaviors provided by the entity class methods.
    These business rules may end up in parts of code other than the Domain hexagon.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的实体由两个要素的存在来表征——业务规则和业务数据。看到实体类几乎像数据库实体对象建模，只表达数据部分而忽略了通过实体类方法提供的行为所代表的业务规则，这是很常见的。这些业务规则可能最终出现在域六边形之外的代码部分。
- en: This kind of leak, where the business rules end up outside the Domain hexagon,
    can be harmful because it may make it difficult to understand what the domain
    entity does. That happens when business rules are defined outside the Domain hexagon
    and depend, for example, on code that handles database entities, which are not
    part of the domain model but are a technical detail supporting the domain model.
    That phenomenon is prevalent in what is called an **anemic domain model**. The
    entity objects coming from anemic domain models generally have data but lack behavior.
    By not coupling data with behavior, the anemic domain model goes against the very
    essence of **Object-Oriented Programming** (**OOP**). When behavior is not present
    in domain objects, we have to go somewhere else to fully grasp what the entity
    is supposed to do, thus generating a mental overload that can quickly become an
    onerous burden as a code base grows.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种泄露，即业务规则最终出现在领域六边形之外，可能是有害的，因为它可能使理解领域实体做什么变得困难。这种情况发生在业务规则在领域六边形之外定义，并依赖于例如处理数据库实体的代码时，这些数据库实体不是领域模型的一部分，而是支持领域模型的技术细节。这种现象在所谓的
    **贫血领域模型** 中很普遍。来自贫血领域模型的实体对象通常有数据，但缺乏行为。通过不将数据与行为耦合，贫血领域模型违反了 **面向对象编程** （**OOP**）
    的本质。当领域对象中没有行为时，我们必须去其他地方才能完全理解实体应该做什么，从而产生一种随着代码库增长而迅速变成沉重负担的心理负担。
- en: Conversely, we should not overload entity classes with logic that is not intrinsic
    to the entity we try to model. That’s not a trivial thing to do because, at first,
    we may think an operation is a part of the entity, only to discover later on that
    it’s not.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们不应该在实体类中添加与实体本身无关的逻辑。这并非易事，因为一开始我们可能认为某个操作是实体的一部分，但后来发现它并不是。
- en: For things considered not intrinsic to entity behavior, we have the option to
    use a domain service. With services, we can accommodate those operations that
    don’t fit smoothly into an entity class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于被认为不是实体行为固有属性的事物，我们有使用领域服务的选项。通过服务，我们可以容纳那些不适合平滑地集成到实体类中的操作。
- en: 'In the previous chapter, we created a `retrieveRouter` method to filter and
    list routers in the `Router` class, as illustrated in the following code snippet:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个 `retrieveRouter` 方法来过滤和列出 `Router` 类中的路由器，如下代码片段所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Could we consider this list router’s behavior an intrinsic characteristic
    of routers in the real world?* If our problem domain says the opposite, then we
    should remove this behavior from the entity class. *And what about the constraints
    that we use to check the router type before we add a router to the list?* If we
    consider this verification a router-intrinsic behavior, we have the following
    options:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们能否将这个列表路由器的行为视为现实世界中路由器的固有特征？* 如果我们的问题域表示相反，那么我们应该从实体类中移除这种行为。*那么，在我们将路由器添加到列表之前用于检查路由器类型的约束又如何呢？*
    如果我们认为这种验证是路由器固有的行为，我们有以下选项：'
- en: Embed this constraint directly in the entity class
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此约束直接嵌入到实体类中
- en: Create a specification to assert the constraint
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个规范来断言约束
- en: 'Specifications are a subject we will cover later in this chapter, but for now,
    you can see specifications as predicate mechanisms to ensure we work with the
    correct objects. The following code snippet provides an example of a `Router`
    entity class with the router type-check constraints embedded directly in it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 规范是我们将在本章后面讨论的主题，但到目前为止，你可以将规范视为谓词机制，以确保我们与正确的对象一起工作。以下代码片段提供了一个示例，展示了具有直接嵌入的
    `routerTypeCheck` 约束的 `Router` 实体类：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To accommodate the domain service method, we need first to create a domain
    service class called `RouterSearch` and move to it the `retrieveRouter` method
    from the `Router` class, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应领域服务方法，我们首先需要创建一个名为 `RouterSearch` 的领域服务类，并将 `Router` 类中的 `retrieveRouter`
    方法移动到该类中，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `isCore`, `isEdge`, and `filterRouterByType` constraint methods continue
    to exist in the `Router` entity class. We only moved the `retrieveRouter` method
    from `Router` to `RouterSearch`. That `retrieveRouter` method can now be consumed
    as a service by other objects in the domain and in other hexagons. Later in this
    chapter, in the *Working with domain services* section, we will take a closer
    look at domain services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`isCore`、`isEdge` 和 `filterRouterByType` 约束方法继续存在于 `Router` 实体类中。我们只是将 `retrieveRouter`
    方法从 `Router` 移动到 `RouterSearch`。现在，`retrieveRouter` 方法可以作为服务被领域中的其他对象和其他六边形消费。在本章的后续部分，在
    *与领域服务一起工作* 部分中，我们将更详细地探讨领域服务。'
- en: A question that may arise is how complex the domain model methods should be,
    especially those that are part of the domain entities. My take is that the complexity
    will be determined by our knowledge of the problem domain and our ability to translate
    it into a domain entity that captures, through proper method definitions, only
    the necessary behaviors required to change the entity state according to the conditions
    presented by the problem domain. A weak problem domain knowledge may yield unnecessary
    complexity. So, as our knowledge of the problem domain increases, it also increases
    our capacity to provide the right level of complexity to the methods we define
    for the domain entities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现的疑问是领域模型方法应该有多复杂，尤其是那些属于领域实体的方法。我的看法是，复杂性将由我们对问题域的了解以及我们将它转化为领域实体的能力所决定，通过适当的方法定义，仅捕获根据问题域提出的条件所必需的行为，以改变实体状态。薄弱的问题域知识可能导致不必要的复杂性。因此，随着我们对问题域的了解增加，我们也增加了为定义的领域实体提供正确复杂性的能力。
- en: One fundamental characteristic of entities is that they have an identity that
    uniquely identifies them. Having an identity mechanism is paramount to ensuring
    that our entities are unique across a system. One way to provide such identity
    is through the use of UUIDs, a subject we will explore in the section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的一个基本特征是它们有一个唯一标识它们的身份。拥有一个身份机制对于确保我们的实体在整个系统中是唯一的至关重要。提供这种身份的一种方式是通过使用UUID，我们将在本节中探讨这个主题。
- en: Using UUIDs to define identity
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用UUID定义身份
- en: You may be familiar with **identifier** (**ID**)-generation techniques that
    rely on database sequence mechanisms to generate and avoid duplication of IDs.
    Although it’s convenient to delegate this responsibility to a database, by doing
    so, we couple a crucial aspect of our software to an external system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉**标识符**（**ID**）生成技术，这些技术依赖于数据库序列机制来生成和避免ID的重复。虽然将这项责任委托给数据库很方便，但这样做会将我们软件的一个关键方面与外部系统耦合起来。
- en: Let’s suppose we’re aiming to develop a hexagonal application that lets us evolve
    business code with as few technology dependencies as possible. In this case, we
    need to find a way to turn this identity generation into an independent process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们旨在开发一个六边形应用，使我们能够以尽可能少的科技依赖性来演进业务代码。在这种情况下，我们需要找到一种方法将这种身份生成转化为一个独立的过程。
- en: 'A common approach to establishing an identity that does not rely on a central
    authority is with a **universally unique identifier** (**UUID**). This is a 128-bit
    number widely used to assure universal uniqueness in computer systems. There are
    four different methods to generate UUIDs – time-based, **Distributed Computer
    Environment** (**DCE**) security, name-based, and randomly generated. The following
    code snippet shows how you can create name-based and randomly generated UUIDs:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 建立不依赖于中央权威的身份的常见方法是通过**通用唯一标识符**（**UUID**）。这是一个广泛用于确保计算机系统普遍唯一性的128位数字。有四种不同的方法可以生成UUID
    - 基于时间的、**分布式计算机环境**（**DCE**）安全、基于名称和随机生成。以下代码片段显示了如何创建基于名称和随机生成的UUID：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Beware of UUIDs, you can have performance issues if your data source is a relational
    database. Because UUIDs are strings, they consume more memory than the integers
    created by autogenerated IDs provided by relational databases. The use of UUIDs
    can cause a considerable impact on the size and index management of databases.
    There is no free lunch. Computer resources are the price to be paid for such an
    agnostic ID-generation solution. It’s up to you to decide whether the benefits
    of this approach outweigh the disadvantages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 小心UUID，如果你的数据源是关系型数据库，你可能会遇到性能问题。因为UUID是字符串，它们比关系型数据库提供的自动生成的ID消耗更多的内存。UUID的使用可能会对数据库的大小和索引管理产生相当大的影响。没有免费的午餐。计算机资源是这种无差别的ID生成解决方案的代价。这取决于你决定这种方法的优点是否超过了缺点。
- en: 'Once defined, the entity ID should not change, so it becomes an immutable attribute.
    This immutable characteristic makes the entity ID attribute a suitable candidate
    to be modeled as a value object. Based on the topology and network inventory example
    that we dealt with in the previous chapter, the following code snippet shows us
    a simple approach to creating a value object class to represent the ID of our
    `Router` entity:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，实体 ID 就不应该改变，因此它成为一个不可变的属性。这种不可变的特性使得实体 ID 属性成为建模为价值对象的合适候选。基于我们在上一章中处理过的拓扑和网络库存示例，以下代码片段展示了创建一个表示我们的
    `Router` 实体 ID 的价值对象类的一个简单方法：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `withId` factory method allows the reconstitution of `Router` entities when
    we have the ID. The `withoutId` factory method enables the generation of new IDs
    if we deal with a new `Router` entity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`withId` 工厂方法允许我们在拥有 ID 的情况下重新构成 `Router` 实体。`withoutId` 工厂方法使我们能够为新的 `Router`
    实体生成新的 ID。'
- en: The `withId` and `withoutId` methods are both applications of a pattern called
    the static factory method that allows us to encapsulate object creation. These
    methods are part of the domain model because they enable identity provisioning,
    through IDs, on either new or existing router entities.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`withId` 和 `withoutId` 方法都是静态工厂模式的运用，这种模式允许我们封装对象创建。这些方法属于领域模型，因为它们通过 ID 在新的或现有的路由实体上提供身份验证。'
- en: Entities are first-class citizens in a hexagonal architecture. They are the
    foundational elements from which other software components will derive. However,
    they alone aren’t enough to create rich domain models because not everything in
    a domain possesses an identity. We need something to express objects that don’t
    need to be uniquely identified. We fill this need with value objects, a type of
    object intended to help us increase the descriptiveness of a problem domain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是六边形架构中的第一类公民。它们是其他软件组件从中派生的基础元素。然而，仅凭它们本身不足以创建丰富的领域模型，因为领域中的并非所有事物都具有身份。我们需要某种东西来表达不需要唯一标识的对象。我们通过价值对象来满足这一需求，这是一种旨在帮助我们增加问题域描述性的对象类型。
- en: Enhancing descriptiveness with value objects
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用价值对象增强描述性
- en: In the book *Implementing Domain-Driven Design*, the author Vernon Vaughn points
    out that we should use value objects to measure, quantify, or describe things
    from our problem domain. For example, you can describe an ID attribute with a
    value object instead of a long or integer value. You can wrap a double or big
    decimal attribute into a specific value object to express quantification more
    clearly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在《实现领域驱动设计》这本书中，作者 Vernon Vaughn 指出，我们应该使用价值对象来衡量、量化或描述我们的问题域中的事物。例如，你可以用一个价值对象来描述
    ID 属性，而不是用长或整数值。你可以将双精度或大十进制属性包装在一个特定的价值对象中，以更清晰地表达量化。
- en: We’re not fully satisfied with just using the built-in language types to model
    a problem domain. To make a system more explicit about its nature and purposes,
    we wrap those built-in language data types – and even our own created types –
    in well-defined value objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对仅仅使用内置语言类型来建模问题域并不完全满意。为了使系统更明确其性质和目的，我们将这些内置语言数据类型——甚至我们自己的创建类型——封装在定义良好的价值对象中。
- en: 'This effort to convey meaning is based on the following two fundamental characteristics
    of value objects:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传达意义的努力基于价值对象以下两个基本特征：
- en: They are immutable
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的
- en: They don’t have an identity
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有身份
- en: Suppose you have painted a picture. Imagine how strange would it be if, for
    some reason, after you’ve finished your work, parts of your picture mysteriously
    change colors. In this analogy, colors are like value objects that we use to create
    a picture, and each color can be a different value object. So, to ensure that
    our paint will persist, the colors, once used, must not change and must be immutable
    once used. I base my argument for value objects on the idea that some characteristics
    must never change because they are the raw material we use to describe a problem
    domain.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你画了一幅画。想象一下，如果你完成作品后，出于某种原因，画中的部分神秘地改变了颜色，那会多么奇怪。在这个类比中，颜色就像我们用来创建画面的价值对象，每种颜色都可以是一个不同的价值对象。因此，为了确保我们的颜料持久，一旦使用，颜色就不能改变，一旦使用就必须是不可变的。我关于价值对象的论点基于这样一个观点：某些特征必须永远不变，因为它们是我们用来描述问题域的原始材料。
- en: Raw material alone neither expresses much meaning nor has much value. The real
    value comes when we combine and work with that raw stuff to form relevant and
    discernable things. Because value objects alone are like raw material, we don’t
    bother to replace them or throw them away. *And if they are not so important,
    why should we assign them an identity and take the same care we have* *with entities?*
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹的原料本身既不表达很多意义，也没有多少价值。真正的价值在于当我们将原料结合并与之合作，形成相关且可辨识的事物时。因为值对象本身就像原料一样，我们不会费心去替换它们或丢弃它们。*而且如果它们并不那么重要，我们为什么还要赋予它们一个身份，并像对待实体一样给予同样的关注呢？*
- en: The bottom line is that value objects should be discardable and easily replaceable
    objects that we use to compose an entity or other type of object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，值对象应该是可丢弃的且易于替换的对象，我们使用它们来组合实体或其他类型的对象。
- en: Using value objects to compose entities
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值对象来组合实体
- en: 'When modeling an entity class, for example, we have two options – to use or
    not use value objects on entity attributes. Here is an example of the second approach:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当对实体类进行建模时，例如，我们有两种选择——在实体属性上使用或不使用值对象。以下是一个第二种方法的例子：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Consider the following log excerpt as data entries we want to parse into the
    `Event` objects:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下日志摘录作为我们想要解析到`Event`对象中的数据条目：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After being properly parsed, we would have `Event` objects with network traffic
    activity string fields, as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 经过适当的解析后，我们会得到具有网络流量活动字符串字段的`Event`对象，如下所示：
- en: '**casanova.58183 >** **menuvivofibra.br.domain**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**casanova.58183 >** **menuvivofibra.br.domain**'
- en: 'Before the greater-than sign, we have the source host and, after, the destination
    host. For the sake of this example, let’s see it as an activity representing the
    source and destination of a packet. By being a string, it leaves a burden for
    clients that want to retrieve the source or destination host from it, as illustrated
    here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在大于号之前，我们有源主机，之后是目标主机。为了这个例子，让我们把它看作是一个表示数据包源和目标的活动。作为一个字符串，它给想要从其中检索源或目标主机的客户端留下了负担，如下所示：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s try it with an `Activity` value object, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个`Activity`值对象来尝试，如下所示：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we update the `Event` entity class, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更新`Event`实体类，如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The client code becomes clearer and more expressive, as we can see in the following
    snippet. Also, clients don’t need to handle the data themselves to retrieve the
    source and destination hosts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码变得更加清晰和表达性强，正如我们可以在以下代码片段中看到。此外，客户端不需要自己处理数据来检索源和目标主机：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With value objects, we have more flexibility and control over our data, letting
    us express the domain model in a more cohesive way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用值对象，我们对自己的数据有更多的灵活性和控制力，使我们能够以更一致的方式表达领域模型。
- en: Assuring consistency with aggregates
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保聚合的一致性
- en: So far, we’ve seen how valuable entities are to represent things in a problem
    domain. Also, we saw how value objects are essential to enhance the descriptiveness
    of the model we use. *However, how do we proceed when we have a group of related
    entities and value objects that express a whole concept when put together?* For
    such a scenario, we should employ the use of **aggregates**. The idea is that
    objects inside an aggregate operate in a consistent and isolated manner. To achieve
    such consistency, we must ensure that any change on any aggregate object is conditioned
    to the variants imposed by such an aggregate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到实体在表示问题域中的事物方面是多么有价值。我们还看到了值对象是如何对我们使用的模型的可描述性至关重要的。*然而，当我们有一组相关的实体和值对象，当它们组合在一起时表达了一个整体概念时，我们该如何进行呢？*对于这种情况，我们应该使用**聚合**。其理念是聚合内的对象以一致和隔离的方式操作。为了实现这种一致性，我们必须确保任何对任何聚合对象的更改都是基于该聚合施加的变体条件。
- en: An aggregate is like an orchestrator that orchestrates data and behavior on
    the objects it controls. For this approach to work, we need to define an entry
    point to interact with the aggregate realm. This entry point is also known as
    the aggregate root, which keeps references to the entities and value objects that
    are part of the aggregate. With the boundary provided by aggregates, we’re in
    a better position to assure consistency in the operations conducted by the objects
    within that boundary. By formally establishing conceptual boundaries to ensure
    consistency in the activities based on our problem domain, it will be easier for
    us to incorporate techniques such as optimistic or pessimistic locking, and technologies
    such as the **Java Transaction API** (**Java JTA**) to support consistent transactional
    operations. With well-structured aggregates, we have better conditions to apply
    whatever approach we think is good to enable transactions on our system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合体就像一个指挥者，它在其控制的对象上编排数据和行为。为了使这种方法有效，我们需要定义一个入口点来与聚合体领域交互。这个入口点也被称为聚合体根，它保留了对聚合体中实体和值对象的引用。有了聚合体提供的边界，我们更有能力确保在该边界内对象操作的一致性。通过正式建立概念边界以确保基于我们的问题域的活动的一致性，我们将更容易采用诸如乐观或悲观锁定等技术，以及诸如**Java事务API**（**Java
    JTA**）等技术来支持一致的事务操作。有了结构良好的聚合体，我们有更好的条件来应用我们认为好的任何方法，以使我们的系统能够进行事务处理。
- en: From a performance and scalability perspective, we should always strive to keep
    our aggregates as small as possible. The reason is simple – large aggregate objects
    consume more memory. Too many aggregate objects being instantiated at the same
    time can compromise the overall **Java Virtual Machine** (**JVM**) performance.
    This rule applies to anything in the OOP world, but we emphasize aggregates because
    of their ability to integrate objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能和可扩展性的角度来看，我们应该始终努力使我们的聚合体尽可能小。原因很简单——大的聚合体对象消耗更多的内存。同时实例化太多的聚合体对象可能会损害整体**Java虚拟机**（**JVM**）的性能。这条规则适用于OOP世界中的任何事物，但我们强调聚合体，因为它们能够集成对象。
- en: A small aggregate generally contains just one entity that acts as the aggregate
    root and other value objects. The way to make two different aggregates interact
    with each other is through their aggregate root, which happens to be an entity
    root with its unique ID. The aggregate root is used for persistence purposes as
    well. So, you’ll perform changes on aggregate child objects through the aggregate
    root, and when your changes are done, you’ll use the same aggregate root to commit
    those changes to your persistence system.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的聚合体通常只包含一个实体，该实体作为聚合体的根，以及其他值对象。使两个不同的聚合体相互交互的方式是通过它们的聚合体根，它恰好是一个具有唯一ID的实体根。聚合体根也用于持久化目的。因此，您将通过聚合体根对聚合体子对象进行更改，当您的更改完成后，您将使用相同的聚合体根将那些更改提交到您的持久化系统中。
- en: Conversely, if you don’t see the non-functional requirements of performance
    and scalability as something critical, I think, with proper care, that aggregates
    can grow to have more than one entity.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果您不认为性能和可扩展性这样的非功能性需求是至关重要的，我认为，只要适当关注，聚合体可以增长到包含多个实体。
- en: Modeling an aggregate
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型化一个聚合体
- en: 'To illustrate how we can model an aggregate, let’s return to our network and
    topology inventory scenario. One of the business needs is to catalog the equipment
    and networks connected to a specific **Edge Router**. Below this **Edge Router**,
    we have a **Level 3 Switch**, responsible for creating **Virtual Local-Area Networks**
    (**VLANs**) for different networks. The structure would be something like the
    one shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们如何模型化一个聚合体，让我们回到我们的网络和拓扑库存场景。一个业务需求是对连接到特定**边缘路由器**的设备和网络进行编目。在下面的**三层交换机**下面，我们有一个负责为不同网络创建**虚拟局域网**（**VLANs**）的**三层交换机**。结构可能像下面这样：
- en: '![Figure 2.1 – Network components](img/B19777_02_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 网络组件](img/B19777_02_01.jpg)'
- en: Figure 2.1 – Network components
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 网络组件
- en: The catalog of equipment, networks, and relationships is used by the infrastructure
    department to help them plan and implement changes in the overall network. A router
    or switch alone doesn’t tell us too much about the network. The real value comes
    when we aggregate all the network components and their interconnections.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 设备、网络和关系的目录被基础设施部门用来帮助他们计划和实施整体网络的变更。一个路由器或交换机单独并不能告诉我们太多关于网络的信息。真正的价值在于当我们聚合所有网络组件及其互连时。
- en: 'This kind of information will allow the infrastructure department to have more
    visibility and make well-based decisions. The epicenter of our aggregate is the
    edge router entity, which happens to be our aggregate root. The switch is also
    an entity. We model its VLAN networks as value objects. The context here is clear
    – a network composed of HR, marketing, and engineering VLAN networks connected
    to a switch that, in turn, is connected to the edge router. The internet or other
    networks can be considered in a different context. Here is a **Unified Modeling
    Language** (**UML**)-like representation of the aggregate root:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这类信息将使基础设施部门有更多的可见性，并做出基于事实的决策。我们聚合的核心是边缘路由器实体，它恰好是我们的聚合根。交换机也是一个实体。我们将其VLAN网络建模为值对象。这里的上下文很清晰——一个由HR、市场和工程VLAN网络组成的网络连接到一个交换机，而该交换机反过来又连接到边缘路由器。互联网或其他网络可以在不同的上下文中考虑。以下是一个类似于**统一建模语言**（**UML**）的聚合根表示：
- en: '![Figure 2.2 – The aggregate grouping together all network components](img/B19777_02_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 将所有网络组件聚集在一起](img/B19777_02_02.jpg)'
- en: Figure 2.2 – The aggregate grouping together all network components
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 将所有网络组件聚集在一起
- en: 'Starting from the bottom level, we have `Network` as a value object, as illustrated
    in the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从最底层开始，我们有`Network`作为一个值对象，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that the **Internet Protocol** (**IP**) address attribute is a value object
    as well, as shown in the following code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**互联网协议**（**IP**）地址属性也是一个值对象，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may have noted some validation rules in the constructors of the `IP` and
    `Network` value objects’ classes. Those validations work as guards to prevent
    the wrong construction of value objects. Putting those guards in instance creation
    is one way to free clients from the burden of validating value objects. That’s
    exactly what happens on the `Network` class, where we just validate the `cidr`
    attribute because `IP` will come already validated.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在`IP`和`Network`值对象类的构造函数中注意到了一些验证规则。这些验证规则作为守护者，用于防止值对象被错误地构建。将这些守护者在实例创建中放置是一种让客户端摆脱验证值对象负担的方法。这正是`Network`类所发生的事情，我们只是验证了`cidr`属性，因为`IP`已经预先进行了验证。
- en: 'There’s also a `Protocol` `enum` value object that we will use to compose the
    `IP` value object, as illustrated in the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于组合`IP`值对象的`Protocol`枚举值对象，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After modeling the `IP`, `Network`, and `Protocol` value objects, we have now
    the necessary objects to model the `Switch` entity class, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`IP`、`Network`和`Protocol`值对象进行建模之后，我们现在有了建模`Switch`实体类的必要对象，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because networks are directly connected to a switch, we create an `addNetwork`
    method to support the capability to add more networks to a switch. This method
    first retrieves the existing networks from the router, adding them to a list.
    Then, it adds the new network to the list of existing networks. Note that `addNetwork`
    does not change the current `Switch` object but, rather, creates a new `Switch`
    instance containing the network we added.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为网络直接连接到交换机，我们创建了一个`addNetwork`方法来支持向交换机添加更多网络的能力。此方法首先从路由器检索现有网络，将它们添加到列表中。然后，它将新网络添加到现有网络的列表中。请注意，`addNetwork`不会更改当前的`Switch`对象，而是创建一个新的`Switch`实例，其中包含我们添加的网络。
- en: 'On top of all the value objects we have created so far, and the `Switch` entity,
    we need to formalize a boundary with an aggregate root. That’s the role of our
    `Router` entity class, as illustrated in the following code snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止创建的所有值对象和`Switch`实体之上，我们需要与一个聚合根正式化一个边界。这就是我们的`Router`实体类的作用，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Along with the `RouterType` and `RouterId` value objects, there is also an entity
    for the switch. The `networkSwitch` entity represents the switch connected directly
    to this router. Then, we add two methods, one to create a new network and another
    to connect an existing network to the switch.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`RouterType`和`RouterId`值对象之外，还有一个代表交换机的实体。`networkSwitch`实体表示直接连接到该路由器的交换机。然后，我们添加了两个方法，一个用于创建新的网络，另一个用于将现有网络连接到交换机。
- en: By putting these methods on the aggregate root, we delegate to it the responsibility
    to handle all the objects under its context, thus enhancing consistency when we
    deal with such an aggregation of objects. Also, this is an effort to prevent the
    anemic domain model approach, whereby entities are just data objects without any
    kind of behavior.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些方法放在聚合根上，我们将处理其上下文中所有对象的职责委托给它，从而在处理这种对象聚合时增强了一致性。此外，这也是防止贫血领域模型方法的一种努力，其中实体只是没有任何行为的数据对象。
- en: Next, we will see how to use domain services to call those operations contained
    in the aggregate.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用领域服务来调用聚合体中包含的操作。
- en: Working with domain services
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与领域服务一起工作
- en: When modeling a problem domain, we’ll certainly face situations where the task
    at hand does not fit adequately into any of the object categories that we’ve seen
    so far in the domain hexagon – entities, value objects, and aggregates. Earlier
    in this chapter, we encountered a situation where we removed from the `Router`
    entity a method responsible for retrieving a list of routers. That method seemed
    to be in the wrong place because, in our topology and network inventory scenario,
    a router usually doesn’t list other routers. To deal with this cumbersome situation,
    we’ve refactored the router list method in a separate object. Eric Evans calls
    such objects **domain services**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当对问题域进行建模时，我们肯定会遇到手头的任务不适合领域六边形中我们迄今为止看到的任何对象类别的情况——实体、值对象和聚合体。在本章的早期，我们遇到了从`Router`实体中移除一个负责检索路由器列表的方法的情况。这个方法似乎位置不正确，因为在我们拓扑和网络库存场景中，路由器通常不会列出其他路由器。为了处理这种繁琐的情况，我们已经将路由器列表方法重构为一个单独的对象。埃里克·埃文斯称这样的对象为**领域服务**。
- en: I believe it’s important to distinguish domain services from any other type
    of service. For example, in **Model-View-Controller** (**MVC**) architectures,
    services are often seen as bridges that connect the different facets of an application,
    handling data and orchestrating calls within and outside the system. Their usage
    is often associated with software development frameworks such as Spring that even
    have a service annotation. However, independent of the context, I believe the
    main difference between distinguished service types lies not in the meaning but
    in the scope.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为区分领域服务与其他任何类型的服务非常重要。例如，在**模型-视图-控制器**（**MVC**）架构中，服务通常被视为连接应用程序不同方面的桥梁，处理数据和协调系统内外部的调用。它们的用法通常与软件开发框架相关联，例如Spring，甚至有服务注解。然而，无论在何种情境下，我认为不同服务类型之间的主要区别不在于意义，而在于范围。
- en: '*What makes something a service?* It’s the ability to perform some worthwhile
    effort. This characteristic is inherent to any service, both in the real world
    and with computers. However, in the latter case, we should care about the **Separation
    of Concerns** (**SoC**), modularization, decoupling, and other relevant stuff
    for good architecture. It’s based on those concerns that we put domain services
    inside the domain hexagon. They perform worthwhile tasks – as with any other services
    – but within the constrained scope of our problem domain. This means domain services
    should not call services or other objects that operate in application or framework
    hexagons. Instead, objects from those hexagons are clients who call domain services.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是服务？* 它是执行某些有价值工作的能力。这种特性在任何服务中都是固有的，无论是在现实世界还是在计算机中。然而，在后一种情况下，我们应该关注**关注点分离**（**SoC**）、模块化、解耦和其他与良好架构相关的内容。这些关注点是我们在领域六边形中将领域服务放入其中的基础。它们执行有价值的工作——就像任何其他服务一样——但仅限于我们的问题域的约束范围内。这意味着领域服务不应调用在应用程序或框架六边形中操作的服务或其他对象。相反，来自这些六边形的对象是客户端，它们调用领域服务。'
- en: 'In the previous section, we created the following two methods in our `Router`
    entity class, which is also the aggregate root:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在我们的`Router`实体类中创建了以下两个方法，它也是聚合根：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the following code snippet, we have a service class operating over those
    two `Router` entity methods:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们有一个服务类操作这两个`Router`实体方法：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have a method called `createNewNetwork` that is responsible for creating
    a new network object and adding it to the switch linked to our router. We should
    meet two constraints to be able to create a network. The first, simple one checks
    whether the minimum **Classless Inter-Domain Routing** (**CIDR**) has not been
    violated. The second constraint is somewhat more elaborate. It verifies whether
    the network address is already used on the whole network.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`createNewNetwork`的方法，它负责创建一个新的网络对象并将其添加到与我们的路由器相连的交换机。为了能够创建一个网络，我们必须满足两个约束。第一个，简单的一个是检查是否没有违反最小**无类别域间路由**（**CIDR**）。第二个约束稍微复杂一些。它验证网络地址是否在整个网络上已被使用。
- en: With this approach, we’re delegating to the `NetworkOperation` domain service
    class the responsibility to deal with tasks that don’t fit neatly into entities
    or value objects. It's also a good way to prevent entity and value object classes
    from growing too large, with far more features than necessary according to a problem
    domain.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们将处理那些不适合整齐地放入实体或值对象中的任务的职责委托给`NetworkOperation`域服务类。这也是防止实体和值对象类变得过于庞大、具有比问题域所需更多的特性的好方法。
- en: Until now, we’ve dealt with invariants directly on entities, value objects,
    or service classes. Next, we’ll see an approach to accommodate those invariants
    in a more orderly and organized way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在实体、值对象或服务类上直接处理不变量。接下来，我们将看到一种更有序、更组织化的方法来适应这些不变量。
- en: Using policy and specification to deal with business rules
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用策略和规范处理业务规则
- en: One of the most valuable things a system possesses is its codified business
    rules. Those rules represent a vital effort to understand a real-world problem
    and translate that understanding into working software. That’s not a trivial task,
    for sure. In DDD, we learn how crucial it is to work closely with domain experts
    to model our problem domain correctly. If domain experts are not available, we
    should seek developers with knowledge of a business. If none of them is available,
    we have no choice but to embark on a knowledge-seeking journey through books and
    any other resources that can help us grasp our problem domain’s inner workings.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个系统拥有的最有价值的东西之一就是其编码的业务规则。这些规则代表了理解现实世界问题并将这种理解转化为工作软件的重要努力。这绝对不是一项微不足道的工作。在领域驱动设计中，我们了解到与领域专家紧密合作来正确地建模我们的问题域是多么关键。如果领域专家不可用，我们应该寻找了解业务的开发者。如果他们都不可用，我们就别无选择，只能通过书籍和其他任何可以帮助我们掌握问题域内部运作的资源开始知识寻求之旅。
- en: Once the business knowledge is acquired and we have enough relevant information
    about the problem domain’s steps and processes, we can then start the adventure
    to transform that knowledge into code. At first glance, this process to understand
    business needs and transform them into software seems simple. Instead, it’s been
    the fruit of very good debates that have given rise to various methodologies and
    even an important manifesto called the **Agile Manifesto**. It’s not my goal here
    to discuss the best approach to understanding business needs. Instead, the idea
    here is to present some of the techniques we can use to transform that business
    knowledge into working software.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了业务知识，并且我们对问题域的步骤和过程有了足够的相关信息，我们就可以开始将那些知识转化为代码的冒险之旅。乍一看，这个过程似乎很简单，即理解业务需求并将它们转化为软件。然而，这实际上是经过非常好的辩论的结果，产生了各种方法论，甚至产生了一个重要的宣言，即**敏捷宣言**。在这里，我的目标不是讨论理解业务需求的最佳方法。相反，这里的想法是展示我们可以用来将业务知识转化为工作软件的一些技术。
- en: We always have the option to do things our way, sometimes ignoring the knowledge
    resulting from the experience of others who came before us. When dealing with
    business rules, this is by no means different. In the previous examples, we did
    this very thing, scattering business rules around code without a second thought.
    We now have an opportunity to fix that approach and tap into the knowledge of
    others who came before us.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总有选择以自己的方式做事，有时会忽略来自我们之前经验的知识。在处理业务规则时，这绝对没有不同。在先前的例子中，我们就是这样做的，不加思考地将业务规则散布在代码中。我们现在有机会修正这种方法，并利用我们之前的人的知识。
- en: Policy and specification patterns are two patterns that can help us better organize
    our code’s business rules.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式和规范模式是两种可以帮助我们更好地组织代码业务规则的模式。
- en: A **policy**, also known as a strategy, is a pattern that encapsulates part
    of the problem domain in a block of code. For those familiar with the Strategy
    pattern (*Gang of Four*), the term *algorithm* can be used to describe that encapsulated
    block of code. The main characteristic of a policy is that it performs some action
    or processing in the data provided. Policies are intentionally kept separate from
    entities and value objects to avoid coupling. This decoupling provides the well-known
    benefit of evolving one part without direct impact or side effects on the other.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略**，也称为策略模式，是一种封装问题域一部分的代码模式。对于那些熟悉策略模式（*四人帮*）的人来说，可以使用术语*算法*来描述封装的代码块。策略的主要特征是它在提供的数据上执行某些操作或处理。策略故意与实体和值对象保持分离，以避免耦合。这种解耦提供了众所周知的优点，即在不直接影响或产生副作用的情况下，可以独立地演进某个部分。'
- en: Conversely, **specifications** are like conditions or predicates used to ensure
    the properties of an object. However, what characterizes a specification is its
    care to encapsulate those predicates in a more expressive way than mere logical
    operators. Once encapsulated, those specifications can be reused and even combined
    to express the problem domain better.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**规范**就像用于确保对象属性的条件或谓词。然而，定义规范的是它以比简单的逻辑运算符更表达性的方式封装这些谓词。一旦封装，这些规范就可以被重用，甚至可以组合起来更好地表达问题域。
- en: When used together, policies and specifications are sound techniques to improve
    the robustness and consistency of our business rules across code. A specification
    ensures that only suitable objects are handled by our policies. We have a catalog
    of different and easily changeable algorithms at our disposal with policies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当政策和规范一起使用时，它们是提高我们业务规则在代码中鲁棒性和一致性的有效技术。规范确保只有合适的对象被我们的策略处理。我们有一系列不同且易于更改的算法可供策略使用。
- en: To better illustrate how specifications and policies work, we will now explore
    how to implement them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明规范和策略的工作原理，我们现在将探讨如何实现它们。
- en: Creating specifications
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建规范
- en: 'Let’s first see how we can refactor our `NetworkOperation` service class to
    use specifications. We’ll start by creating a `Specification` interface, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何重构我们的`NetworkOperation`服务类以使用规范。我们将从创建一个`Specification`接口开始，如下所示：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It’s through the `isSatisfiedBy` implementation that we will define our predicates.
    Followed by this interface, we need to create an abstract class that implements
    the `and` method to allow us to combine specifications, as illustrated in the
    following code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`isSatisfiedBy`的实现，我们将定义我们的谓词。在接口之后，我们需要创建一个抽象类来实现`and`方法，以便我们可以组合规范，如下代码片段所示：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, there is only a method for the `AND` operator because we are not dealing
    with other operators such as `OR` and `NOT`, although it’s common to implement
    methods for those operators. To conclude the creation of our base types, we implement
    the `AndSpecification` class, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有`AND`运算符的方法，因为我们不处理其他运算符，如`OR`和`NOT`，尽管实现这些运算符的方法很常见。为了完成我们基础类型的创建，我们实现了`AndSpecification`类，如下所示：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are now ready to create our own specifications. The first one is about the
    business rule that limits the minimum CIDR allowed for the creation of new networks.
    The code is illustrated in the following snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们自己的规范了。第一个是关于限制创建新网络所允许的最小CIDR的业务规则。代码如下所示：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The corresponding specification will look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的规范将如下所示：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we’ll deal with the business rules that check whether the network address
    is not already used, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理检查网络地址是否已被使用的业务规则，如下所示：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The refactoring of the previous code basically consists of moving the `isNetworkAvailable`
    method from the entity to the specification class, as shown in the following code
    snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的重构基本上是将`isNetworkAvailable`方法从实体移动到规范类中，如下代码片段所示：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To illustrate how to combine two specifications with the `and` method, we will
    create two more specifications. The first one is to establish the maximum allowed
    networks and is shown in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用`and`方法组合两个规范，我们将创建另外两个规范。第一个是确定允许的最大网络数量，如下代码片段所示：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And the second specification is to ensure that we deal only with edge or core
    routers. This is shown in the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个规范是确保我们只处理边缘或核心路由器。这在上面的代码片段中显示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have defined our specifications, we can use a feature introduced
    first as a preview in Java 15 and then as definitive in Java 17, allowing us to
    constrain which classes are permitted to implement an interface or a class. We
    call it a *sealed class/interface*. As the name implies, this feature seals the
    class/interface, so it cannot be implemented unless the implementing class/interface
    name is explicitly declared on the sealed class or interface. Let’s check how
    this feature can work with the specification we just created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的规范，我们可以使用 Java 15 首次作为预览引入并随后在 Java 17 中作为最终版本引入的功能，允许我们约束哪些类被允许实现一个接口或类。我们称之为
    *密封类/接口*。正如其名所示，这个特性密封了类/接口，因此除非实现类/接口的名称在密封类或接口上明确声明，否则它不能被实现。让我们看看这个特性如何与刚刚创建的规范一起工作。
- en: 'We want to restrict who can implement the `Specification` interface and the
    `AbstractSpecification` abstract class. In the following code snippet, we can
    see how we can apply it to the `Specification` interface:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望限制谁可以实现 `Specification` 接口和 `AbstractSpecification` 抽象类。在下面的代码片段中，我们可以看到我们如何将其应用于
    `Specification` 接口：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that we restrict which class can implement the interface by using the
    `permits` clause. Let’s seal the `AbstractSpecification` abstract class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过使用 `permits` 子句来限制哪些类可以实现该接口。让我们密封 `AbstractSpecification` 抽象类：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The permit clause now includes all the other classes implementing the `AbstractSpecification`.
    We still need to ensure the implementing classes are `final`. Therefore, we need
    to add the `final` clause on every one of those classes, as shown in the following
    example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 允许子句现在包括了所有实现 `AbstractSpecification` 的其他类。我们仍然需要确保实现这些类的 `final` 状态。因此，我们需要在每个这些类上添加
    `final` 子句，如下例所示：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once we have finished adjusting the `final` keyword on the implementing specification
    classes, we have a well-defined set of sealed classes/interfaces, describing which
    specification classes can be used to define a system’s business rules.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了对实现规范类的 `final` 关键字的调整，我们就有一个定义良好的密封类/接口集合，描述了哪些规范类可以用来定义系统的业务规则。
- en: 'We’re now ready to refactor our domain service, responsible for creating new
    networks to use those specifications, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好重构我们的领域服务，该服务负责创建新的网络以使用这些规范，如下所示：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have explored how to implement specifications, let’s see how we
    can create policies.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何实现规范，让我们看看我们如何创建策略。
- en: Creating policies
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建策略
- en: To understand how policies work, we will create a service class to help us retrieve
    a list of network events based on a specific algorithm to parse raw event data.
    This parse algorithm can or cannot be considered part of the problem domain; usually,
    it’s not, but for the sake of this example, let’s assume it is.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解策略是如何工作的，我们将创建一个服务类来帮助我们根据特定的算法检索基于原始事件数据的网络事件列表。这个解析算法可能或可能不被认为是问题域的一部分；通常情况下不是，但为了这个示例，让我们假设它是。
- en: We will create two policies – the first is to parse string log entries into
    `Event` objects using a pure **regular expression** (**regex**)-based algorithm,
    where we explicitly inform the regex pattern, while the second one will accomplish
    the same thing but with a split-based algorithm that uses just a space delimiter.
    The choice between both policies can be based on performance and the ability to
    customize the parsing mechanisms, among other factors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个策略——第一个是将字符串日志条目解析为 `Event` 对象，使用基于纯 **正则表达式**（**regex**）的算法，我们明确地告知正则表达式模式，而第二个将使用基于分割的算法，仅使用空格作为分隔符来完成相同的事情。这两种策略之间的选择可以基于性能和定制解析机制的能力，以及其他因素。
- en: 'First, we will create an `EventParser` interface, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 `EventParser` 接口，如下所示：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We’ll use the `formatter` attribute in both event-parser implementation classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在两个事件解析实现类中使用 `formatter` 属性。
- en: 'Let’s start implementing the regex parser policy, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现正则表达式解析策略，如下所示：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The split parser policy seems simpler, as we can see here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 分割解析策略看起来更简单，如下所示：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we did previously with specifications, the `EventParser` interface can be
    turned into a sealed interface:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前处理规范一样，`EventParser` 接口可以被转换为一个密封接口：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Don’t forget to include the final keyword on the `RegexEventParser` and `SplitEventParser`
    classes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`RegexEventParser`和`SplitEventParser`类中包含`final`关键字。
- en: 'Now, returning to the parser policy implementation, note that the `Event` constructor
    is called with the parsed attributes. We need to update our `Event` entity class
    to enable it to work with our policies. We can do so with the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到解析策略实现，请注意`Event`构造函数是用解析后的属性调用的。我们需要更新我们的`Event`实体类，使其能够与我们的策略一起工作。我们可以通过以下代码来实现：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The switch that allows us to choose between policies relies on the following
    enum:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们在策略之间进行选择的开关依赖于以下枚举：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We’re now ready to create an `EventSearch` service class with a method to retrieve
    network events. This domain service will allow us to choose which kind of parse
    algorithm to use when retrieving events. Here’s the code we’ll need for this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建一个具有检索网络事件方法的`EventSearch`服务类。这个领域服务将允许我们在检索事件时选择使用哪种解析算法。以下是实现此功能所需的代码：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we are acquainted with policy and specification patterns, let’s see
    the benefits of modeling our business rules on POJOs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了策略和规范模式，让我们看看将我们的业务规则建模在POJOs上的好处。
- en: Defining business rules as POJOs
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将业务规则定义为POJOs
- en: Back in the day, when enterprise development was strongly influenced by Java
    2 Platform, **Enterprise Edition** (**J2EE**) (known today as **Jakarta EE**),
    there was a technology called **Enterprise JavaBeans** (**EJBs**), responsible
    for lifting from developers all the heavyweight jobs required to manage software
    development plumbing activities, relating to transaction management, security,
    and object life cycles. The EJB promise was that developers could focus their
    energy on developing business features, while the J2EE container would take care
    of all the infrastructure details. EJBs fulfilled this promise, but not without
    a price. It was time-consuming and boring to create and maintain EJBs in their
    first versions. There were lots of things to do, involving various **Extensible
    Markup Language** (**XML**) configurations and deployment descriptors, and to
    make things worse, there was little space to reuse these EJB objects because they
    had so much boilerplate. They weren’t like POJOs – simple and reusable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时代，当企业开发强烈受到Java 2 Platform, **Enterprise Edition** (**J2EE**)（今天被称为**Jakarta
    EE**）的影响时，有一种称为**Enterprise JavaBeans** (**EJBs**)的技术，负责从开发者手中接管所有管理软件开发管道活动（涉及事务管理、安全和对象生命周期）的重型工作。EJB的承诺是开发者可以集中精力开发业务功能，而J2EE容器将负责所有基础设施细节。EJBs实现了这一承诺，但并非没有代价。在第一版中创建和维护EJB既耗时又无聊。有许多事情要做，涉及各种**可扩展标记语言**
    (**XML**)配置和部署描述符，而且更糟糕的是，由于有太多的样板代码，几乎没有空间重用这些EJB对象。它们不像POJOs那样——简单且可重用。
- en: This issue with the first EJB versions – version 2 especially – helped to motivate
    the creation of improved solutions that could leverage the simplicity of POJOs.
    Among those solutions, we can mention EJB 3 and the technologies derived from
    frameworks such as Spring and Quarkus. What all those technologies have in common,
    though, is the incentive and flexibility to work with POJOs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一版EJB（特别是版本2）的问题帮助我们激发了创建改进解决方案的动机，这些解决方案可以利用POJOs的简单性。在这些解决方案中，我们可以提到EJB 3以及从Spring和Quarkus等框架派生出来的技术。然而，所有这些技术共同的特点是激励和灵活性，以便与POJOs一起工作。
- en: POJOs are appealing because they are nothing more than regular Java objects.
    It is simple to understand a POJO because we deal only with Java standard **Application
    Programming Interfaces** (**APIs**) instead of custom libraries and frameworks.
    That’s what makes POJOs a category of developer-friendly objects that are easier
    to understand and reuse across different parts of an application. If we aim for
    change-tolerant applications, then the use of POJOs is always recommended to diminish
    coupling with specific technologies, allowing an application to switch between
    different technologies or frameworks without much friction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: POJOs很有吸引力，因为它们不过就是普通的Java对象。理解POJO很简单，因为我们只处理Java标准**应用程序编程接口** (**APIs**)，而不是自定义库和框架。这就是POJOs成为一类开发者友好对象的原因，它们更容易理解和在不同的应用程序部分之间重用。如果我们旨在开发容错性高的应用程序，那么使用POJOs总是推荐的做法，以减少与特定技术的耦合，允许应用程序在不同技术或框架之间切换而不会产生太多摩擦。
- en: This flexibility offered by POJOs allows them to participate, simultaneously
    if needed, in different system departments. For example, nothing prevents someone
    from using the same POJO in transactional, persistence, and user-presentation
    contexts. We can also use POJOs to represent business rules – the entity, policy,
    and specification objects presented in this chapter are good examples of how we
    can embody business rules within POJOs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种由POJO提供的灵活性允许它们在需要时同时参与不同的系统部门。例如，没有人阻止某人在事务性、持久性和用户展示上下文中使用相同的POJO。我们还可以使用POJO来表示业务规则——本章中展示的实体、政策和规范对象是我们在POJO中体现业务规则的优秀例子。
- en: By using POJOs to model business rules, we leverage all the benefits related
    to reusability and simplicity that a POJO can provide. They also go hand in hand
    with the important goal of keeping domain objects shielded from any technological
    details, which will ultimately contribute to the essential SoC efforts to support
    more supple and sober designs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用POJO来建模业务规则，我们利用了与可重用性和简单性相关的所有好处。它们也与保持领域对象免受任何技术细节影响的重要目标相一致，这最终将有助于支持更灵活和清醒的设计的必要SoC（分离关注点）努力。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The DDD topics we covered in this chapter are paramount in our effort to develop
    hexagonal applications, as it’s through the use of DDD techniques that we’ll be
    able to shape a decoupled, consistent, and business-oriented domain hexagon that
    will be the foundation for the application and framework hexagons.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的DDD主题对于开发六边形应用至关重要，因为正是通过使用DDD技术，我们才能塑造出一个解耦的、一致的、面向业务领域的六边形，这将成为应用和框架六边形的基础。
- en: It’s always essential to understand the basics. By looking closer into the main
    DDD concepts, we found the basic techniques to aid us in developing the domain
    hexagon. We covered how to make pure and relevant entities and how to assign an
    identity to them. With value objects, we understood how important they are in
    conveying meaning and enhancing the descriptiveness of a problem domain. Aggregates
    showed us how to group related entities and value objects to describe whole operations
    in our problem domain. Also, we saw how aggregates are instrumental in assuring
    consistency with transactions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 理解基础知识始终是至关重要的。通过更深入地研究主要的DDD概念，我们发现了一些基本技术，这些技术有助于我们开发领域六边形。我们讨论了如何创建纯净且相关的实体以及如何为它们分配身份。通过值对象，我们理解了它们在传达意义和增强问题域描述性方面的重要性。聚合体向我们展示了如何将相关的实体和值对象分组，以描述我们问题域中的整体操作。此外，我们还看到了聚合体如何确保与事务的一致性。
- en: Following aggregates, we learned that domain services let us express behaviors
    that don’t fit well into entities or value objects, and to better organize business
    rules, we learned about policy and specification patterns. Finally, we assessed
    the benefits of the reusability and simplicity that POJOs provide when defining
    business rules. With the ideas and techniques explored in this chapter, we can
    now build a domain hexagon that captures and properly arranges into code the business
    rules that will influence the behavior of an entire application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习聚合体之后，我们了解到领域服务让我们能够表达不适合放入实体或值对象中的行为，为了更好地组织业务规则，我们学习了策略和规范模式。最后，我们评估了POJO在定义业务规则时提供的可重用性和简单性的好处。通过本章探讨的思想和技术，我们现在可以构建一个领域六边形，它能够捕捉并正确地将影响整个应用行为的业务规则编码到代码中。
- en: We’re now ready to move one step higher in the ladder by entering the realm
    of the application hexagon, where we’ll see how to combine and orchestrate business
    rules to create software functionality through use cases and ports.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在阶梯上迈出更高的一步，进入应用六边形的领域，我们将看到如何通过用例和端口结合和编排业务规则来创建软件功能。
- en: Questions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main attribute of entities not found in value objects?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体与值对象相比，主要属性是什么？
- en: Can value objects be mutable?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值对象是否可以是可变的？
- en: Every aggregate must have an entry-point object to allow communication with
    other objects controlled by the aggregate. What is the name of this entry-point
    object?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个聚合体都必须有一个入口点对象，以便与其他由聚合体控制的对象进行通信。这个入口点对象的名称是什么？
- en: Are domain services allowed to call objects on other hexagons?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 领域服务是否允许调用其他六边形上的对象？
- en: What is the difference between a policy and a specification?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 政策和规范之间有什么区别？
- en: What is the benefit of defining business rules as a POJO?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将业务规则定义为POJO有什么好处？
- en: Further reading
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Implementing Domain-Driven Design* (Vernon, 2016)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《实现领域驱动设计》（Vernon，2016年）
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* (Evans,
    2003)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《领域驱动设计：软件核心的复杂性处理》（Evans，2003年）
- en: '*Extreme Programming Explained: Embrace Change* (Beck, 1999)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《极限编程之道：拥抱变化》（Beck，1999年）
- en: Answers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Contrary to value objects, entities have an identity.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与值对象相反，实体具有一个身份。
- en: No. The most important property of a value object is its immutability.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不。值对象最重要的属性是其不可变性。
- en: The entry-point object for any aggregate is called an aggregate root.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何聚合的入口点对象被称为聚合根。
- en: No, but objects from other domains and other hexagons can call domain services.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，但来自其他领域和其他六边形的对象可以调用领域服务。
- en: A policy is a pattern that encapsulates part of the problem domain knowledge
    in a block of code or an algorithm. A specification is a pattern that works with
    predicates to assert the validity of the properties of objects.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 政策是一种模式，它将部分问题领域知识封装在代码块或算法中。规范是一种与谓词一起工作的模式，用于断言对象属性的合法性。
- en: Because a POJO doesn’t depend on external technology details, such as a feature
    provided by an external library or a framework. Instead, a POJO relies only on
    a standard Java API, which makes POJOs simple and easy-to-reuse objects. POJOs
    are helpful for creating business rules objects that aren’t blurred by technology
    details.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为POJO不依赖于外部技术细节，例如外部库或框架提供的功能。相反，POJO仅依赖于标准的Java API，这使得POJO成为简单且易于重用的对象。POJO对于创建不受技术细节模糊的业务规则对象很有帮助。
