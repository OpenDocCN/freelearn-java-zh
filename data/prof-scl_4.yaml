- en: Chapter 4. Scala Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 Scala 集合
- en: In the previous chapter, we covered functional programming with Scala and how
    object-oriented and functional approaches complete each other. We also covered
    generic classes, which are often used with pattern matching. Finally, we covered
    how to create user-defined pattern matching and why it is useful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了使用 Scala 的函数式编程以及面向对象和函数式方法如何相互补充。我们还介绍了泛型类，它们通常与模式匹配一起使用。最后，我们讨论了如何创建用户定义的模式匹配以及为什么它是有用的。
- en: In this chapter, we will cover the Scala Collection library. We will start by
    learning how to work with lists, which will make us familiar with some design
    principles of the whole collections library. Afterward, we'll generalize to sequences
    and cover some more relevant data structures. At the end, we'll look at how collections
    relate to monads and how we can use that knowledge to make some powerful abstractions
    in our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Scala 集合库。我们将从学习如何处理列表开始，这将使我们熟悉整个集合库的设计原则。之后，我们将推广到序列，并介绍一些相关的数据结构。最后，我们将探讨集合与单子之间的关系，以及我们如何利用这些知识在代码中创建一些强大的抽象。
- en: Scala's collection library is very rich, being comprised of data structures
    for very different use cases and performance considerations. It is particularly
    rich in immutable data structures, which we will be covering in greater detail
    during this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的集合库非常丰富，由适用于非常不同用例和性能考虑的数据结构组成。它在不可变数据结构方面尤其丰富，我们将在本章中更详细地介绍。
- en: Collections available in the Scala collection library inherit from common high-level
    abstract classes and traits and, as such, share some common functionalities, which
    makes working with them easier once you become familiar with certain methods and
    design principles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 集合库中可用的集合继承自常见的顶级抽象类和特质，因此它们共享一些共同的功能性，这使得一旦熟悉了某些方法和设计原则，使用它们就会变得更容易。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Identify the Scala collections available in the standard library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别标准库中可用的 Scala 集合
- en: Identify how to abstract sequences by using higher-order functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别如何使用高阶函数抽象序列
- en: Implement the important design principles for working with Scala collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现与 Scala 集合一起工作的关键设计原则
- en: Working with Lists
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与列表一起工作
- en: Lists are probably the most commonly used data structures in Scala programs.
    Learning how to work with lists is important both from a data structure standpoint
    but also as an entry point to designing programs around recursive data structures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可能是 Scala 程序中最常用的数据结构。学习如何处理列表不仅从数据结构的角度来看很重要，而且也是设计围绕递归数据结构的程序的一个切入点。
- en: Constructing Lists
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建列表
- en: 'In order to be able to use l `ists`, one must learn how to construct them.
    `Lists` are recursive in nature, and build upon two basic building blocks: `Nil`
    (representing the empty list) and `::` (pronounced cons, from the `cons` function
    of most Lisp dialects).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用列表，必须学习如何构建它们。`Lists` 是递归的，并且基于两个基本构建块：`Nil`（表示空列表）和 `::`（发音为 cons，来自大多数
    Lisp 方言的 `cons` 函数）。
- en: 'We will now create Lists in Scala:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在 Scala 中创建列表：
- en: 'Start the Scala `REPL`, which should provide you with a prompt:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Scala `REPL`，它应该为你提供一个提示符：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `list` of strings using the following:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法创建一个字符串 `list`：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Show that the `::` operation is the right associative by omitting the parentheses
    and getting the same result:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过省略括号并得到相同的结果来展示 `::` 操作是右结合的：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create lists of different types.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建不同类型的列表。
- en: 'Show that the `apply` method of the `List` companion object offers a convenient
    way to create a list from a variable number of arguments:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示 `List` 伴生对象的 `apply` 方法提供了一个方便的方式来从可变数量的参数创建列表：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering how is it possible for the `::` operator to be right-associative,
    note that the associativity of an operator is determined by the operator's last
    character. Operators ending in a colon `:` are right-associative. All other operators
    are left-associative. Since `::` ends with a colon, it is right-associative.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道 `::` 操作符如何是右结合的，请注意操作符的结合性由操作符的最后一个字符决定。以冒号 `:` 结尾的操作符是右结合的。所有其他操作符都是左结合的。由于
    `::` 以冒号结尾，因此它是右结合的。
- en: Operations on Lists
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表上的操作
- en: The `List` class provides the `head`, `tail,` and `isEmpty` methods. `head`
    returns the first element of the list, while the `tail` method returns the list
    without its first element. The `isEmpty` method returns `true` if the list is
    empty, and `false` otherwise. `head` and `tail` are only defined for non-empty
    lists and throw an exception on empty ones.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 类提供了 `head`、`tail` 和 `isEmpty` 方法。`head` 返回列表的第一个元素，而 `tail` 方法返回不包含第一个元素的列表。`isEmpty`
    方法在列表为空时返回 `true`，否则返回 `false`。`head` 和 `tail` 只在非空列表上定义，并在空列表上抛出异常。'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Calling `head` and `tail` in empty lists (such as `Nil.head` and `Nil.tail`)
    throws an exception.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在空列表（如 `Nil.head` 和 `Nil.tail`）中调用 `head` 和 `tail` 会抛出异常。
- en: 'To implement the `evenInts` method with the following signature, use the following
    code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用以下签名实现 `evenInts` 方法，请使用以下代码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method should return a list with all even integers of list l. Use the `head`,
    `tail,` and `isEmpty` methods of `List`. A possible solution for this problem
    is the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法应返回包含列表 l 中所有偶数的列表。使用 `List` 的 `head`、`tail` 和 `isEmpty` 方法。此问题的可能解决方案如下：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pattern Matching on Lists
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表上的模式匹配
- en: Pattern matching is a powerful mechanism for checking a value against a pattern
    in Scala and provides an idiomatic way to decompose lists. You can pattern match
    on `::`, which mimics the list structure, or on `List(...)` to match all of the
    list's values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是 Scala 中检查值与模式的一种强大机制，并提供了一种习惯用法来分解列表。您可以在 `::` 上进行模式匹配，它模仿列表结构，或在 `List(...)`
    上进行匹配以匹配列表的所有值。
- en: Let's experiment with pattern matching in the Scala `REPL`. Make sure to show
    examples of both pattern matching with `List(...)` and with `::`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Scala 的 `REPL` 中进行模式匹配实验。请确保展示使用 `List(...)` 和 `::` 的模式匹配示例。
- en: 'One possible example to show is:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可能的示例：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using pattern matching is generally more idiomatic than using `if` and `else`
    to structure programs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配通常比使用 `if` 和 `else` 来结构化程序更符合习惯用法。
- en: 'Now, we will implement the method `evenInts` again. This time, we will not
    use the `head`, `tail,` and `isEmpty` methods of `List`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次实现 `evenInts` 方法。这次，我们不会使用 `List` 的 `head`、`tail` 和 `isEmpty` 方法：
- en: Open the file where we have written the `evenInts` method.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们已写入 `evenInts` 方法的文件。
- en: Do not use the `head`, `tail`, and `isEmpty` methods of `list`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要使用 `list` 的 `head`、`tail` 和 `isEmpty` 方法。
- en: 'A possible solution for this problem is the following:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此问题的可能解决方案如下：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First-Order Methods on List
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表上的第一阶方法
- en: The `List` class provides various helpful first-order methods. A first-order
    method is one that does not take a function as an argument. We'll cover some of
    the most-used methods in the following subsection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 类提供了各种有用的第一阶方法。第一阶方法是不接受函数作为参数的方法。我们将在以下小节中介绍一些最常用的方法。'
- en: Appending and Concatenation
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和连接
- en: We've learned about `::` to append an element at the head of a list. If we want
    to append an element at the end of a list, we can use the `:+` operator. In order
    to concatenate two lists, we can use the `:::` operator. Note, however, that the
    `:+` operator has a time complexity of `O(n)`, where `n` is the number of elements
    in the list. The `:::` operator has a time complexity of `O(n)`, `n` being the
    number of elements in the first list. Note that the `:::` operator also has right-associativity,
    like the `::` operator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 `::` 在列表的头部添加一个元素。如果我们想在列表的末尾添加一个元素，我们可以使用 `:+` 操作符。为了连接两个列表，我们可以使用
    `:::` 操作符。请注意，然而，`:+` 操作符的时间复杂度为 `O(n)`，其中 `n` 是列表中元素的数量。`:::` 操作符的时间复杂度也是 `O(n)`，`n`
    是第一个列表中的元素数量。请注意，`:::` 操作符也具有右结合性，就像 `::` 操作符一样。
- en: 'Example code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Taking the Length of a List
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取列表的长度
- en: Taking the length of a list is a useful operation. All lists have a definite
    size and, as such, they provide the `length` method that returns their size. We'll
    be covering potentially infinite data structures in another topic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列表的长度是一个有用的操作。所有列表都有确定的大小，因此它们提供了返回其大小的 `length` 方法。我们将在另一个主题中介绍可能无限的数据结构。
- en: Note that `length` is an expensive operation on lists, as it needs to traverse
    the whole list to find its end, taking time proportional to the number of elements
    in the list.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`length` 在列表上是一个昂贵的操作，因为它需要遍历整个列表以找到其末尾，所需时间与列表中元素的数量成比例。
- en: Reversing a List
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转列表
- en: If you require frequent access to the end of a list, it is convenient to reverse
    it once and work with the result. The `reverse` method creates a new list with
    the elements of the original list reversed. The reverse method has linear complexity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要频繁访问列表的末尾，反转一次并使用结果会更方便。`reverse` 方法创建一个新列表，其元素与原始列表相反。`reverse` 方法的复杂度为线性。
- en: Prefixes and Suffixes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前缀和后缀
- en: 'The `take` and `drop` methods of `List` return arbitrary prefixes or suffixes
    of a list. They both take an integer as an argument: the number of elements to
    take or drop, respectively.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 的 `take` 和 `drop` 方法返回列表的任意前缀或后缀。它们都接受一个整数作为参数：分别是要取或丢弃的元素数量。'
- en: 'Example code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Element Selection
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素选择
- en: 'Even though it is not a common operation for lists, the `List` class supports
    random element selection through its apply method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于列表来说这不是一个常见的操作，`List` 类通过其 `apply` 方法支持随机元素选择：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since apply is implicitly inserted when an object appears in the function position
    in a method call, we can also do:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在方法调用中对象出现在函数位置时，会隐式插入 `apply`，因此我们也可以这样做：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Display
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示
- en: 'Use `toString` to get the canonical string representation of a list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `toString` 获取列表的规范字符串表示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `mkString` method is a bit more flexible as it allows you to specify the
    prefix to print before all elements, the separator to print between elements,
    and the suffix to print after all elements. The `mkString` method has two overloaded
    variants which allow you to drop the prefix and suffix arguments if they''re empty
    strings. You can also call `mkString` without arguments if you want an empty string
    as a separator:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkString` 方法更加灵活，因为它允许你指定打印在所有元素之前的前缀、打印在元素之间的分隔符以及打印在所有元素之后的后缀。`mkString`
    方法有两个重载变体，允许你在前缀和后缀参数为空字符串时省略它们。如果你想要一个空字符串作为分隔符，也可以不带参数调用 `mkString`：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the Scaladoc for the `scala.collection.` `immutable.List` class at
    [https://www.scala-lang.org/api/current/scala/collection/immutable/List.html](https://www.scala-lang.org/api/current/scala/collection/immutable/List.html).
    If you are interested in other useful methods, you can take a look at what the
    class has to offer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [https://www.scala-lang.org/api/current/scala/collection/immutable/List.html](https://www.scala-lang.org/api/current/scala/collection/immutable/List.html)
    上的 Scaladoc，了解 `scala.collection.` `immutable.List` 类。如果你对其他有用的方法感兴趣，可以查看该类提供的内容。
- en: 'Activity: Creating a New Mode for Chatbot Using Lists'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：使用列表为 Chatbot 创建新模式
- en: 'In this activity, we will be building a new mode for the Chatbot that we created
    on the first day of this book. This new mode will be capable of keeping and updating
    a `todo` list of entries. We will be using `lists` as the primary data structure
    to hold our information, and we want to support at least the following commands:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个新的模式，这个模式是我们在这本书的第一天创建的 Chatbot 的。这个新模式将能够保持和更新条目的 `todo` 列表。我们将使用
    `lists` 作为主要的数据结构来存储我们的信息，并且我们希望至少支持以下命令：
- en: '`todo list`: Lists all current items the bot is currently aware of.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo list`：列出机器人当前所知的所有当前项。'
- en: '`todo new <item description>`: Inserts a new TODO item with the provided description.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo new <item description>`：插入一个带有提供描述的新 TODO 项。'
- en: '`todo done <item number>:` Removes the item numbered <item number> from the
    list. The number of the item should be shown when using `todo` list.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo done <item number>`：从列表中删除编号为 `<item number>` 的项。使用 `todo list` 时应显示项的编号。'
- en: '`todo done <item description>`: Removes the item whose description matches
    <item description>.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo done <item description>`：删除与 `<item description>` 匹配的项。'
- en: 'Start by defining a new class that extends `ChatbotMode`. It''s enough to model
    our TODO list items as strings, so our new mode could just be defined as `case
    class TodoList(todos: List[String]) extends ChatbotMode`.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先定义一个新的类，该类扩展 `ChatbotMode`。由于我们的 TODO 列表项只需要作为字符串建模，因此我们的新模式可以定义为 `case class
    TodoList(todos: List[String]) extends ChatbotMode`。'
- en: Implement the required `process` method. Regexes might come in handy to parse
    the `line` argument. Depending on the provided input, we want to create a new
    instance of `TodoList` with the value of `todos` possibly modified. Return `None`
    in invalid inputs (unrecognizable commands or attempts to delete a non-existent
    item, for example).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现所需的 `process` 方法。正则表达式可能有助于解析 `line` 参数。根据提供的输入，我们希望创建一个新的 `TodoList` 实例，其
    `todos` 的值可能已修改。在无效输入（不可识别的命令或尝试删除不存在的项等）时返回 `None`。
- en: Experiment with your newly defined mode in the previously implemented Chatbot.
    See how well it plays with the other already defined modes.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前实现的聊天机器人中实验你新定义的模式。看看它与其他已定义的模式如何协同工作。
- en: In this section, we covered lists in the perspective of one of the major workhorses
    of Scala programs. We've learned the operations we can perform on lists and covered
    some idiomatic ways to handle lists in Scala code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们从Scala程序的主要工作马视角之一来介绍列表。我们学习了可以在列表上执行的操作，并介绍了Scala代码中处理列表的一些习惯用法。
- en: Abstracting on Sequences
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在序列上抽象
- en: All Scala collections descend from a common trait called `Traversable`. The
    design adopted for Scala collections allows one to use higher-order functions
    similarly in nearly all collections, with proper return types in specific instances.
    Treating collections as sequences, or as containers of elements, allows one to
    use different data structures seamlessly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Scala集合都源自一个名为`Traversable`的共同特质。Scala集合采用的设计允许在几乎所有集合中使用类似高阶函数，并在特定实例中具有适当的返回类型。将集合视为序列或元素容器，允许无缝地使用不同的数据结构。
- en: The Traversable Trait
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可遍历特质
- en: 'At the root of the collections hierarchy is the `Traversable` trait. The `Traversable`
    trait has a single abstract method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 集合层次结构的根部是`Traversable`特质。`Traversable`特质有一个抽象方法：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The implementation of this method is sufficient for the `Traversable` trait
    to provide a series of useful higher-order methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的实现足以使`Traversable`特质提供一系列有用的更高阶方法。
- en: We would like to focus on the `map` operations. The `map` method takes a function
    and applies it to every element of the collection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望专注于`map`操作。`map`方法接受一个函数并将其应用于集合的每个元素。
- en: 'Let''s experiment with the `map` method in the Scala `REPL` and show how it
    applies to different types of collections. For now, create a function that multiplies
    an integer by 2 and apply it to a `List` and an `Array`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Scala的REPL中实验`map`方法，并展示它如何应用于不同类型的集合。现在，创建一个将整数乘以2的函数，并将其应用于`List`和`Array`：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the return type of the `map` method varies according to the collection
    type it is called on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`map`方法的返回类型根据其被调用的集合类型而变化。
- en: The `flatMap` is slightly different. It takes a function from the type of elements
    in the collection to another collection which is then "flattened" in the returned
    collection.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`略有不同。它接受一个从集合元素类型到另一个集合的函数，然后在该返回集合中“扁平化”。'
- en: 'As an example for the `flatMap` method, consider a function that takes an integer
    and creates a list of the integer size filled with 1\. See what the return value
    is when that function is applied to a `list` via `map` and `flatMap`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`flatMap`方法的示例，考虑一个接受整数并创建一个填充1的整数大小列表的函数。看看当该函数通过`map`和`flatMap`应用于`list`时返回值是什么。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note how the lists are flattened in the `flatMap` call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`flatMap`调用中列表是如何被扁平化的。
- en: These kind of operations closely resemble those of a m `onad`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这类操作与单子的操作非常相似。
- en: 'A `monad` is a wrapper and a mechanism of sequencing operations. It provides
    two basic operations: `identity`, to wrap a value in a `monad`, and `bind`, to
    transform the underlying value of a m `onad`. `Monads` will be covered in greater
    detail in [Chapter 7](ch07.html "Chapter 7. Functional Idioms"), *Functional Idioms*,
    so don''t worry if you don''t quite grasp all the intricacies of them just yet.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是一个包装和操作序列化的机制。它提供了两个基本操作：`identity`，用于将值包装在单子中，以及`bind`，用于转换单子的底层值。`单子`将在第7章[功能习惯](ch07.html
    "Chapter 7. Functional Idioms")中更详细地介绍，所以如果你现在还没有完全掌握它们的复杂性，请不要担心。
- en: The monadic mechanism of chaining `flatMaps` is so common that Scala provides
    a special syntax for it in for-comprehensions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 链接`flatMaps`的单子机制非常常见，以至于Scala在for-comprehensions中为此提供了特殊语法。
- en: Monadic operations provide the programmer with a way to abstract and chain computations,
    where `map` and `flatMap` are the glue. The fact that `map` and `flatMap` are
    higher-order functions, in other words, they take other functions as arguments,
    allows the programmer to reuse components ( `functions`) in their code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 单子操作为程序员提供了一种抽象和链式计算的方法，其中`map`和`flatMap`是粘合剂。事实上，`map`和`flatMap`是高阶函数，换句话说，它们接受其他函数作为参数，这使得程序员可以在他们的代码中重用组件（函数）。
- en: Other important higher-order functions provided by the collections API are `folds`.
    Generically, folds provide ways to combine elements of a container with some binary
    operator. Folds are different from reduces in the sense that with fold you provide
    a starter value, whereas with `reduce` you only use the elements of the container.
    The `*Left` and `*Right` variants determine the order in which the elements are
    combined.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 集合API提供的其他重要高阶函数是`folds`。一般来说，折叠提供了将容器中的元素与某些二元运算符组合的方法。折叠与减少的不同之处在于，使用折叠时你提供了一个起始值，而使用`reduce`时你只使用容器中的元素。`*Left`和`*Right`变体决定了元素组合的顺序。
- en: 'We will now implement sum on a List by using foldLeft. A possible solution
    to this problem is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过使用`foldLeft`来实现列表上的求和。这个问题的可能解决方案如下：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Iterators
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Right beneath the `Traversable` trait in the Scala collections hierarchy is
    the `Iterable` trait. An `Iterable` is a trait with a single abstract method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala集合层次结构中，紧接在`Traversable`特质之下的是`Iterable`特质。`Iterable`是一个具有单个抽象方法的特质：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An `Iterator` provides a method to step through the collection's elements one
    by one. One important thing to note is that an `Iterator` is mutable, as most
    of its operations change its state. Namely, calling `next` on an `iterator` changes
    the in-place position of its `head`. Since an `Iterator` is simply something with
    `next` and `hasNext` methods, it is possible to create an iterator that isn't
    backed by any collection. Since all Scala collections also descend from `Iterable`,
    all of them have an `iterator` method to return an `Iterator` for its elements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`提供了一个方法来逐个遍历集合的元素。需要注意的是，`Iterator`是可变的，因为其大多数操作都会改变其状态。具体来说，在`iterator`上调用`next`会改变其`head`的当前位置。由于`Iterator`只是具有`next`和`hasNext`方法的东西，因此可以创建一个没有任何集合支持的迭代器。由于所有Scala集合也源自`Iterable`，因此它们都有一个`iterator`方法来返回其元素的`Iterator`。'
- en: Streams
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流
- en: '**Streams** provide an implementation of lazy lists where elements are only
    evaluated when they are needed. Streams also have a recursive structure, similar
    to `Lists,` based on the `#::` and `Stream.empty` building blocks (analogous to
    `::` and `Nil`). The biggest difference is that `#::` is lazy, and will only evaluate
    the tail when elements from it are needed. One important feature of Streams is
    that they''re memoized, so values won''t be recomputed if they were already computed
    once. The disadvantage of this is that if you keep hold of a reference to the
    head of a `Stream`, you will keep references to all the elements of the `Stream`
    computed so far.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**提供了一种惰性列表的实现，其中元素仅在需要时才被评估。流也具有递归结构，类似于`列表`，基于`#::`和`Stream.empty`构建块（类似于`::`和`Nil`）。最大的区别在于`#::`是惰性的，并且只有当需要其中的元素时才会评估尾部。流的一个重要特性是它们被缓存，所以如果值已经被计算过一次，就不会重新计算。这种方法的缺点是，如果你保留了对`Stream`头部的引用，你将保留对到目前为止已计算的`Stream`中所有元素的引用。'
- en: 'Activity: Implementing Fibonacci Series Using Streams and Iterators'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：使用流和迭代器实现斐波那契数列
- en: In mathematics, the sequence known as Fibonacci is defined by the number which
    generated by adding the two integers prior to the number. By definition, the first
    two integers in the series should be 1 and 1, or 0 and 1.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，被称为斐波那契的序列是由加在数字之前的两个整数生成的数定义的。根据定义，该系列中的前两个整数应该是1和1，或者0和1。
- en: 'Implement the infinite sequence of Fibonacci numbers using Streams and Iterators:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流和迭代器实现斐波那契数的无限序列：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One possible solution for these implementations is the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现的可能解决方案如下：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this section, we've covered `Traversables` as an abstract way to use and
    reason about collections in Scala. We also covered Iterators and Streams and their
    usefulness in implementing potentially infinite sequences.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了`Traversable`作为在Scala中使用和推理集合的抽象方式。我们还介绍了迭代器和流以及它们在实现可能无限序列中的有用性。
- en: Other Collections
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他集合
- en: Now that we've covered the List and some relevant `Traversables` in the Scala
    standard library, we should also visit some other useful collections Scala provides.
    Even though this section has less theoretical material, this means that we'll
    have more time on the final activities of the chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Scala标准库中的`List`和一些相关的`Traversable`，我们也应该访问Scala提供的一些其他有用的集合。尽管本节的理论材料较少，这意味着我们将有更多时间用于本章的最终活动。
- en: Sets
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: '`Sets` are `Iterables` that contain no duplicate elements. The `Set` class
    provides methods to check for the inclusion of an element in the collection, as
    well as combining different collections. Note that since `Set` inherits from `Traversable`,
    you can apply all the higher-order functions we''ve seen previously on it. Due
    to the nature of its `apply` method, a `Set` can be seen as a function of type
    `A =>` `Boolean`, which returns `true` if the element is present in the set, and
    `false` otherwise.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sets`是`Iterables`，不包含重复元素。`Set`类提供了检查集合中元素包含的方法，以及合并不同集合的方法。请注意，由于`Set`继承自`Traversable`，你可以将其应用于之前看到的所有高阶函数。由于其`apply`方法的特点，`Set`可以被视为一个类型为`A
    => Boolean`的函数，如果元素存在于集合中，则返回`true`，否则返回`false`。'
- en: Tuples
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: A tuple is a class capable of containing an arbitrary number of elements of
    different types. A tuple is created by enclosing its elements in parentheses.
    A tuple is typed according to the type of its elements.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个能够包含任意数量不同类型元素的类。元组通过将元素括在括号中创建。元组的类型根据其元素的类型进行定义。
- en: 'Let''s now create tuples in REPL and access their elements by following these
    steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤在REPL中创建元组并访问它们的元素：
- en: Create some tuples in the `REPL` and access their elements.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`REPL`中创建一些元组并访问它们的元素。
- en: Observe the type of the tuples created, and how it depends on the enclosing
    elements' types.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察创建的元组的类型，以及它是如何依赖于封装元素的类型的。
- en: Use pattern matching as a way to destructure tuples.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模式匹配作为解构元组的方法。
- en: 'The full code looks as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码如下：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Maps
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: A `Map` is an `Iterable` of tuples of size two (pairs of key/values), which
    are also called mappings or associations. A `Map` can't have repeated keys. One
    interesting fact about maps in Scala is that `Map[A, B]` extends `PartialFunction[A,
    B]`, so you can use a `Map` in places where you need a `PartialFunction`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`是一个大小为两的元组序列（键/值对的配对），也称为映射或关联。`Map`不能有重复的键。关于Scala中的映射的一个有趣的事实是，`Map[A,
    B]`扩展了`PartialFunction[A, B]`，因此你可以在需要`PartialFunction`的地方使用`Map`。'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information, refer to the Scaladoc of the Map trait here: [https://www.scala-lang.org/api/current/scala/collection/Map.html](https://www.scala-lang.org/api/current/scala/collection/Map.html).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参阅Map特质的Scaladoc，链接如下：[https://www.scala-lang.org/api/current/scala/collection/Map.html](https://www.scala-lang.org/api/current/scala/collection/Map.html)。
- en: Mutable and Immutable Collections
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变和不可变集合
- en: So far, we've been covering mostly immutable collections (with the exception
    of `Iterators`, which are inherently mutable since most operations over it change
    its state—do note that iterators obtained from the `iterator` method of Scala
    collections are not expected to mutate the underlying collection). It is important
    to note, however, that Scala also provides a set of mutable collections in the
    `scala.collection.mutable` package. Mutable collections provide operations to
    change the collection in place.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要介绍的是不可变集合（除了`Iterators`，因为大多数操作都会改变其状态，所以它是固有的可变的——请注意，从Scala集合的`iterator`方法获得的迭代器不期望改变底层集合）。然而，值得注意的是，Scala还提供了`scala.collection.mutable`包中的一组可变集合。可变集合提供在原地更改集合的操作。
- en: A useful convention for using both immutable and mutable collections in the
    same place is to import the `scala.collection.mutable` package and prefix collection
    declaration with the mutable keyword, which is `Map` vs `mutable.Map`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一位置使用不可变和可变集合的一个有用约定是导入`scala.collection.mutable`包，并在集合声明前使用可变关键字作为前缀，即`Map`与`mutable.Map`。
- en: 'The following code shows the difference between the immutable and mutable Maps
    of Scala, showing that the latter has an `update` method that changes the collection
    in place:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了Scala中不可变和可变映射之间的区别，显示后者有一个`update`方法，该方法会原地更改集合：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Activity: Implementing the Tower of Hanoi Problem'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：实现汉诺塔问题
- en: 'We want to create a solver for the Tower of Hanoi problem. If you are not familiar
    with the puzzle, visit the Wikipedia page at [https://en.wikipedia.org/wiki/Tower_of_Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi)
    This is a good entry point for it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个解决汉诺塔问题的求解器。如果你不熟悉这个谜题，请访问维基百科页面[https://en.wikipedia.org/wiki/Tower_of_Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi)。这是了解它的一个好起点：
- en: 'Implement the `paths``inner` function of the following function:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下函数的`paths`内部函数：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `path` function should return the shortest path from the `from` node to
    the `to` node in the `graph` graph. The `graph` is defined as an adjacency list
    encoded as a `Map[Int, List[Int]]`. The `path's` `inner` function should return
    a `Stream` of paths in increasing length (in a breadth-first search manner).
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`path`函数应该返回`graph`图中从`from`节点到`to`节点的最短路径。`graph`被定义为编码为`Map[Int, List[Int]]`的邻接表。`path`的`inner`函数应该返回按长度递增的路径`Stream`（以广度优先搜索的方式）。'
- en: 'Implement the `nextHanoi` function:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下`nextHanoi`函数：
- en: '[PRE24]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `nextHanoi` function should return a list of valid states one can achieve
    from the current `HanoiState`. For example: `nextHanoi((List(1, 2, 3), Nil, Nil))`
    should return `List((List` `(2, 3),List(1),List()), (List(2, 3),List(),List(1)))`.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`nextHanoi`函数应该返回一个列表，其中包含从当前`HanoiState`可以实现的合法状态。例如：`nextHanoi((List(1, 2,
    3), Nil, Nil))`应该返回`List((List(2, 3),List(1),List()), (List(2, 3),List(),List(1)))`。'
- en: 'Generalize the previously implemented path method to be parameterized on the
    type of state we''re operating on:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前实现的路径方法泛化，使其参数化为我们正在操作的状态类型：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this new implementation, you should be able to solve the Tower of Hanoi
    problem by calling, for example:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新的实现，你应该能够通过调用，例如，来解决汉诺塔问题：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A possible implementation of the proposed activity is the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建议的活动的可能实现如下：
- en: '[PRE27]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the Scala Collection library. We covered how to
    work with lists, which will make us familiar with some design principles of the
    whole collections library. We also covered how to generalize to sequences and
    covered some more relevant data structures. Finally, we also covered how collections
    relate to monads and how we can use that knowledge to use some powerful abstractions
    in our code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Scala集合库。我们介绍了如何处理列表，这将使我们熟悉整个集合库的一些设计原则。我们还介绍了如何泛化到序列，并介绍了一些相关的数据结构。最后，我们还介绍了集合与单子之间的关系，以及我们如何利用这些知识在我们的代码中使用一些强大的抽象。
- en: In the next chapter, we will cover the `type` system and polymorphism. We will
    also cover the different types of variance, which provides a way to constrain
    parameterized types. Finally, we will cover some advanced `types` like abstract
    type members, option, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍`type`系统和多态性。我们还将介绍不同类型的变异性，这提供了一种约束参数化类型的方法。最后，我们还将介绍一些高级`type`，如抽象类型成员、选项等。
