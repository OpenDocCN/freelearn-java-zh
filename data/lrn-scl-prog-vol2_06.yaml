- en: Next Steps in Object-Oriented Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象Scala的下一步
- en: '"I was born not knowing and have only had a little time to change that here
    and there."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我生来无知，只有一点时间在这里和那里改变这一点。”
- en: – Richard Feynman
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 理查德·费曼
- en: 'The idea of companion objects gave us the feeling that it''s important to know
    how your programming language treats the constructs you write. Suppose you were
    given a task to generate a `case` class with some sensitive parameters (by sensitive,
    we mean when trying to print that class, those sensitive fields should print some
    dummy values). What you are going to do in order to achieve that entirely depends
    on your knowledge of how Scala treats the `case` classes, and we learned that
    in the previous chapter. So, what now? Now it''s time to do some composition as
    well as use inheritance. Remember, we talked about how we should think of a class
    as a type that we can define? It''s a really useful and fun task to mix these
    types all together and try to make sense out of them and at the same time, add
    functionalities. That''s why we have static typing, isn''t it? Let me tell you,
    it''s fun to learn composition while mixing in those types, creating more than
    one way to access such constructs. And that''s what we''re going to do in this
    chapter. We''ll have fun and learn. So, this is how we are going to proceed:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象的想法让我们觉得了解你的编程语言如何处理你编写的结构是很重要的。假设你被分配了一个任务，生成一个带有一些敏感参数的 `case` 类（敏感的意思是，当尝试打印该类时，那些敏感字段应打印一些占位符值）。你将如何实现这一点完全取决于你对Scala如何处理
    `case` 类的了解，我们已经在上一章中学到了这一点。那么现在呢？现在是时候做一些组合，并使用继承。记住，我们讨论过我们应该如何将类视为可以定义的类型吗？将所有这些类型混合在一起，并试图理解它们，同时添加功能，这是一项非常有用且有趣的任务。这就是为什么我们有静态类型，不是吗？让我告诉你，在学习组合的同时混合这些类型，创造多种访问这些结构的方法是很有趣的。这正是我们将在本章中做的事情。我们将享受乐趣并学习。所以，这就是我们将如何进行：
- en: Composition versus inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合与继承的比较
- en: Class inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类继承
- en: Default and parameterized constructors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认和参数化构造函数
- en: Traits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性
- en: Traits as mix-ins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性作为混合体
- en: Linearization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性化
- en: Packaging and importing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包与导入
- en: Visibility rules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性规则
- en: Sealed traits
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密封特性
- en: Before we move forward I want to clear this up. The terms *composition* and
    *i**nheritance* will be used in this chapter a lot*.* It's better if we differentiate
    these two up front.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，我想澄清这一点。在本章中，我们将大量使用 *组合* 和 *继承* 这两个术语。最好一开始就区分这两个概念。
- en: Composition and inheritance
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合与继承
- en: 'In programming terms, to inherit or extend our classes we use the `extends`
    or `with` keywords. These are essential for the relationship between two or more
    classes or similar constructs. This association or relation between two classes
    or similar constructs can be in the form of inheritance (Is-A) or composition
    (Has-A). They are two different notions but they converge to some extent. In simple
    words, **inheritance** is a superclass-subclass relationship where the subclass
    inherits the implementation of the superclass, whereas **composition** is when
    a class depends on another object to provide some or all functionality. With an
    inheritance relationship, you can use the subclass object wherever superclass
    is expected. Think of it as this relationship between a `Dictionary` and a `Book`
    class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，要继承或扩展我们的类，我们使用 `extends` 或 `with` 关键字。这些对于两个或更多类或类似结构之间的关系是必不可少的。这种两个类或类似结构之间的关联或关系可以是继承（是-A）或组合（有-A）。它们是两个不同的概念，但在某种程度上它们是趋同的。简单来说，**继承**
    是一个超类-子类关系，其中子类继承了超类的实现，而**组合** 是一个类依赖于另一个对象以提供某些或全部功能的情况。在继承关系中，你可以在期望超类的地方使用子类对象。想想看，这是
    `字典` 和 `书` 类之间的关系：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can picture the **Book** and **Dictionary** relationship as shown in the
    following figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `书` 和 `字典` 的关系如图所示：
- en: '![](img/00027.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: 'Here, a `Dictionary` class is inheriting from a `Book` class, so it means that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`字典` 类正在继承自 `书` 类，这意味着：
- en: '`Dictionary` is a subclass of `Book`. It can be used as a `Book` type wherever
    required.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字典` 是 `书` 的一个子类。它可以在需要的地方用作 `书` 类型。'
- en: Dictionary has access to all the fields (data) and member functions (behavior)
    of the `Book` class. This means that you're allowed to override the behavior of
    a particular function from the superclass, as well as define your own functions
    in terms of behavior from superclass functions.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典可以访问`Book`类的所有字段（数据）和成员函数（行为）。这意味着你可以覆盖超类中特定函数的行为，以及根据超类函数定义自己的函数。
- en: These points in a way make it easier to understand the inheritance relationship
    and help you to form a good object-oriented design. However, sometimes you as
    a developer feel duty-bound to change the behavior of the superclass as it's now
    a dependency for other subtypes as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点在某种程度上使理解继承关系变得更容易，并帮助你形成良好的面向对象设计。然而，有时作为开发者，你可能会觉得有责任去改变超类的行为，因为现在它也成为其他子类依赖的一部分。
- en: 'Composition also may look similar when implemented (in case of traits mix-ins)
    but it''s different in nature. As the name suggests, composition actually makes
    the whole out of parts. It''s easier to understand with the help of an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 组合在实现时（在特质混入的情况下）可能看起来相似，但本质上不同。正如其名所示，组合实际上是将部分组合成一个整体。通过一个例子更容易理解：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we have shown a `Book` class that consists of a set of
    chapters. Each chapter is represented by a `Chapter` class. This is a *Has-a*
    relationship between the `Book` and `Chapter` classes. This relationship is also
    called **aggregation**. And as a special form of aggregation, our topic of interest
    for now is composition. There's a field named `chapters` in the `Book` class that
    is composed of `chapters`. Without the `Chapter` construct, there's no possibility
    of forming a book object that makes sense.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们展示了一个由一组章节组成的`Book`类。每个章节由一个`Chapter`类表示。这是`Book`类和`Chapter`类之间的*具有*关系。这种关系也称为**聚合**。作为聚合的特殊形式，我们现在感兴趣的主题是组合。`Book`类中有一个名为`chapters`的字段，它由`chapters`组成。没有`Chapter`结构，就不可能形成有意义的书籍对象。
- en: 'This is composition and it''s directional. The following figure will help us
    to understand the concept:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是组合，并且它是具有方向的。以下图将帮助我们理解这个概念：
- en: '![](img/00028.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00028.jpeg)'
- en: Composition relationship between a Book and Chapter
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍与章节之间的组合关系
- en: 'With the `Set` object in `chapters`, we can extend some functionalities that
    can only be performed on `Chapter` objects. I bet you get the idea of composition.
    The reason why we''re discussing this is because we''ll be doing that using mix-ins
    of traits in Scala, and it looks almost like we''re extending them as part of
    inheritance, but that''s not the case. So the idea is clear:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapters`中的`Set`对象，我们可以扩展一些只能在`Chapter`对象上执行的功能。我敢打赌你已经明白了组合的概念。我们讨论这个的原因是因为我们将在Scala中使用特质的混入来实现这一点，这看起来几乎像是我们在继承中扩展它们，但实际上并非如此。所以，想法是清晰的：
- en: Composition is not just code reuse but also making a whole out of parts. The
    existence of `Book` is unclear without a `Chapter` object.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合不仅仅是代码复用，更是将部分组合成一个整体。没有`Chapter`对象的存在，`Book`的存在是不清晰的。
- en: Composition also adds up functionalities to our already defined class constructs
    (we'll see this when we talk about *traits as mix-ins* later in the chapter).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合还向我们的已定义类结构添加了功能（我们将在本章后面讨论*特质作为混入*时看到这一点）。
- en: It's important to know the difference between these two. You may only have a
    vague idea of how to implement inheritance or composition in Scala for now, but
    the terms and their meaning are clear. It's going to make the way clear for us
    to move forward and discuss how we can implement class inheritance in Scala.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这两者之间的区别很重要。现在你可能对如何在Scala中实现继承或组合只有一个模糊的概念，但术语及其含义是清晰的。这将为我们指明前进的道路，并讨论我们如何在Scala中实现类继承。
- en: Class inheritance
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类继承
- en: You already know that inheritance plays an important role in good object-oriented
    design. We are lucky enough to have constructs such as classes with names, and
    we can increase the possibility of relating those with other classes by using
    inheritance. Inheritance is about forming a meaningful hierarchy of classes to
    solve the purpose of code reuse. And mark my words, I mentioned *meaningful hierarchies.*
    I'll justify my words later. Let's take a look at how we can extend classes to
    make a hierarchy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道继承在良好的面向对象设计中起着重要作用。我们很幸运有诸如命名类这样的结构，我们可以通过使用继承来增加将它们与其他类相关联的可能性。继承是关于形成有意义的类层次结构以实现代码复用的目的。记住我提到的
    *有意义的层次结构*。我稍后会解释我的话。让我们看看我们如何扩展类以形成一个层次结构。
- en: Extending classes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类
- en: 'We use the `extend` keyword to inherit a class. Let''s see our `Book` example
    to understand this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `extend` 关键字来继承一个类。让我们看看我们的 `Book` 示例来理解这一点：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that `Dictionary` inherits from `Book` or `Dictionary` and is a subclass
    of the `Book` superclass. It's important to know that all classes, regardless
    of using the `extends` keyword, explicitly inherit `Any` in Scala. It means that
    our `Book` class inherits `Any`. Now with the establishment of this relationship,
    if you try to create an instance of `Dictionary`, you'll have access to all non-private
    members of the superclass. That's the reason we're able to print the title of
    our dictionary. That's code reuse. If you don't want to allow a particular member
    to be accessible from outside, you may make it `private`, an access modifier.
    We'll learn about access levels later in this chapter. With this inheritance relationship,
    it's possible to use a `Dictionary` instance wherever a `Book` instance is expected.
    The reason for this is that `dictionary` is a subtype of the `Book` type. To make
    things clearer, let's talk about subtyping and subclassing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`Dictionary` 类继承自 `Book` 或 `Dictionary`，是 `Book` 超类的子类。重要的是要知道，在 Scala
    中，所有类，无论是否使用 `extends` 关键字，都明确地继承自 `Any`。这意味着我们的 `Book` 类继承自 `Any`。现在，随着这种关系的建立，如果你尝试创建一个
    `Dictionary` 实例，你将能够访问超类中所有非私有成员。这就是我们能够打印出字典标题的原因。这就是代码复用的体现。如果你不希望某个成员从外部访问，你可以将其设置为
    `private`，这是一个访问修饰符。我们将在本章后面学习访问级别。通过这种继承关系，可以在需要 `Book` 实例的地方使用 `Dictionary`
    实例。这是因为 `dictionary` 是 `Book` 类型的子类型。为了使事情更清晰，让我们谈谈子类型和子类。
- en: Subtyping versus subclassing
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类型与子类
- en: Classes are not types in Scala*.* When we inherit from a class, we form a superclass-subclass
    relationship between the two. And for most cases, the notion of subclassing and
    subtyping are the same. But in cases where *variance (*inheritance behavior under
    parameterized classes*)* plays its part, things become different. Under variance,
    subclassing doesn't guarantee subtyping as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，类不是类型。当我们从一个类继承时，我们在这两个类之间形成了一个超类-子类关系。在大多数情况下，子类和子类型的概念是相同的。但在 *方差（参数化类下的继承行为）*
    发挥作用的场合，事情就变得不同了。在方差下，子类不保证子类型。
- en: 'We will take a look at both cases, positive and negative. Let''s say a dictionary
    inherits from book, and it makes sense to say that a stack of dictionaries is
    a stack of books. This is the positive scenario, where subclassing and subtyping
    are similar in nature. But what about the second scenario? Suppose the `Keyboard`
    class extends from the `Button` class*.* `Button` has a value and also the functionality.
    So, while forming a meaningful keyboard object, we used the `Button` class. But
    do you think a stack of keyboards is the same as a stack of buttons? No! Hence
    here, the subclassing is perfect between `Keyboard` and `Button` classes, but
    we''re not allowed to say that the `Keyboard` is a subtype of `Button`. I think
    you get the idea of subtyping and subclassing and their differences. Still, in
    programming terms, let''s see it this way: if `Dictionary` is a subtype of `Book`,
    then `List`[`Dictionary`] is going to be a subtype of `List`[`Book`]. We call
    this property **covariance**. In the other case, `Keyboard` sub-classes `Button`
    but it''s not a subtype of `Button`. Let''s visualize what we just tried to understand:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看两种情况，正面和负面。假设字典继承自书籍，并且可以说一摞字典是一摞书籍。这是正面场景，其中子类化和子类型在本质上相似。但第二种情况呢？假设`Keyboard`类扩展自`Button`类*.*
    `Button`有一个值，也有功能。所以，在形成有意义的键盘对象时，我们使用了`Button`类。但你觉得一摞键盘和一摞按钮是一样的吗？不！因此，在这里，`Keyboard`和`Button`类之间的子类化是完美的，但我们不允许说`Keyboard`是`Button`的子类型。我想你已经理解了子类型和子类化以及它们之间的区别。然而，在编程术语中，让我们这样看待它：如果`Dictionary`是`Book`的子类型，那么`List`[`Dictionary`]将是`List`[`Book`]的子类型。我们称这个属性为**协变**。在另一种情况下，`Keyboard`子类化`Button`，但它不是`Button`的子类型。让我们可视化我们刚刚试图理解的内容：
- en: '![](img/00029.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: Sub-classing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 子类化
- en: This relationship speaks for itself. In the case of keyboard and buttons, it's
    better to choose composition instead of inheritance. But that's a different perspective.
    For now, it has become clear we should differentiate between subtyping and subclassing.
    So now, let's go over one more interesting topic—overriding the behavior of superclasses.
    Yes, it's possible for us to override the functions defined in a superclass.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系不言自明。在键盘和按钮的情况下，选择组合而不是继承会更好。但这是一种不同的观点。目前，我们已经清楚，我们应该区分子类型和子类化。所以现在，让我们再探讨一个更有趣的话题——覆盖超类的行为。是的，我们可以覆盖超类中定义的函数。
- en: Overriding data and behavior
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖数据和行为
- en: We know that subclasses have access to all non-private members of a superclass,
    hence we can call or invoke functions from a superclass to show some behavior.
    If we want to manipulate the behavior, it's possible in Scala to override any
    function or value from a superclass. Let's see how we can do that. We'll refer
    to our previously mentioned `Book` and `Dictionary` example. Suppose in the `Book`
    class we have a function named `cover` that for demonstration purposes simply
    takes a `String` object as `cover`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道子类可以访问超类中所有非私有成员，因此我们可以从超类中调用或调用函数来展示一些行为。如果我们想操纵行为，在Scala中，我们可以覆盖超类中的任何函数或值。让我们看看我们如何做到这一点。我们将参考之前提到的`Book`和`Dictionary`示例。假设在`Book`类中我们有一个名为`cover`的函数，为了演示目的，它简单地接受一个`String`对象作为`cover`。
- en: 'We inherit from `Book` and create a `Dictionary` class that wants to override
    the functionality of this function named `cover`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Book`类继承并创建一个`Dictionary`类，该类想要覆盖名为`cover`的函数的功能：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can `override` the definition of the `cover` method by simply adding the
    modifier keyword named `override`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地添加名为`override`的修饰符关键字来覆盖`cover`方法的定义：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the preceding example, we''ve overridden the `cover` method*.*
    What if we don''t use this keyword named `override`? In that case, the Scala compiler
    will give us an error stating the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个示例所示，我们已经覆盖了`cover`方法*.* 如果我们不使用名为`override`的这个关键字，会怎样呢？在这种情况下，Scala编译器会给我们一个错误，指出以下内容：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `cover` method needs the `override` modifier. Method overriding works if
    we''ve kept the signature in the subclass intact. If you try to change the signature,
    the compiler will give you an error stating that the `cover` method overrides
    nothing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`cover`方法需要`override`修饰符。如果我们在子类中保留了签名，方法覆盖就会生效。如果你尝试更改签名，编译器会给你一个错误，指出`cover`方法覆盖了无内容：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So it's important to keep the method signature as it is in the subclass to override
    it. Scala requires you to provide the `override` keyword whenever you try reusing
    the same method in a subclass. In Java, the `override` keyword is optional. This
    causes problems in real-time scenarios when writing code. Let's suppose you want
    to change the behavior in the `Book` superclass to support the newly introduced
    `Cover` class as a parameter in the `cover` method, and you have overridden this
    `cover` method in a few places, such as the `Dictionary` class. What happens in
    scenarios where the `override` keyword is not mandatory? you may ask. Hence, Scala
    requires you to add it. So at compile time, you're going to get an error that
    the `cover` method in `Dictionary` overrides nothing, and you can change the definition
    as needed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在子类中覆盖方法时，保持方法签名不变是很重要的。Scala要求你在子类中重用相同的方法时，始终提供`override`关键字。在Java中，`override`关键字是可选的。这在编写代码的实际场景中会导致问题。假设你想要在`Book`超类中更改行为，以支持新引入的`Cover`类作为`cover`方法的参数，并且你在几个地方覆盖了此`cover`方法，例如在`Dictionary`类中。如果没有强制使用`override`关键字会发生什么情况？你可能想知道。因此，Scala要求你添加它。所以，在编译时，你将得到一个错误，指出`Dictionary`中的`cover`方法没有覆盖任何内容，你可以根据需要更改定义。
- en: 'One more important thing to know: for understanding overriding behaviors thoroughly
    we must understand the scope of them. It''s possible to override a non-parameter
    `def` member with a `val` field. What do we mean by this? Let''s take a look:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件重要的事情需要了解：为了彻底理解覆盖行为，我们必须了解它们的范围。我们可以用`val`字段覆盖非参数`def`成员。我们这是什么意思？让我们看看：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This example shows you that a non-parameter method named `coverType` in `Book`
    can be overridden in the `Dictionary` subclass with a `val` object. It''s perfectly
    legal to perform such overriding operations. If you try to do this the other way
    around, it''s not possible. The Scala compiler will not allow you to perform such
    an operation stating that the `coverType` method needs to be a stable, immutable
    value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向你展示了`Book`中的非参数方法`coverType`可以在`Dictionary`子类中用`val`对象覆盖。进行这样的覆盖操作是完全合法的。如果你尝试反过来做，这是不可能的。Scala编译器将不允许你执行这样的操作，并指出`coverType`方法需要是一个稳定、不可变的价值：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It's logical; what you're trying to do here is to make something mutable, a
    definition is mutable. This shouldn't be allowed and the Scala compiler is intelligent
    enough to tell you this. Suppose you want a particular member of your superclass
    to be intact, and not changeable. You want to restrict following subclasses from
    overriding behavior of the superclass, what'll you do in that case? That's what
    we'll learn next.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '这是合乎逻辑的；你在这里试图做的是使某个东西可变，定义是可变的。这不应该被允许，Scala编译器足够智能，能够告诉你这一点。假设你希望你的超类中的某个特定成员保持完整，不可更改。你想要限制后续子类覆盖超类的行为，在这种情况下你会怎么做？这就是我们接下来要学习的。 '
- en: Restricting inheritance – final keyword
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制继承 – `final`关键字
- en: 'If you want to restrict subclasses from overriding a particular behavior or
    some data, you may use the `final` keyword to do so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要限制子类覆盖特定的行为或某些数据，你可以使用`final`关键字来实现：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we have declared our `coverType` value as `final`. If you try to override
    this, the Scala compiler will throw an error stating the value cannot override
    the `final` member:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将`coverType`值声明为`final`。如果你尝试覆盖它，Scala编译器将抛出一个错误，指出值不能覆盖`final`成员：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's useful for when there's some data you want to remain intact and still have
    this superclass-subclass relationship working. With this overriding of behaviors
    in several related classes, there comes confusion when you try to invoke a particular
    method that's in a superclass as well as subclasses. That confusion is solved
    using the concept of dynamic binding. So, let's explain where dynamic binding
    is used before we learn how it works in detail. Dynamic binding is used to resolve
    which member function will get invoked when classes are in an inheritance relationship.
    This is resolved on the basis of objects at runtime. Let's talk in detail about
    it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你想保持某些数据完整的同时，仍然让超类-子类关系正常工作的情况下很有用。在几个相关类中覆盖行为时，当你尝试调用超类以及子类中的特定方法时，会出现混淆。这种混淆是通过动态绑定概念解决的。所以，在我们详细了解它的工作原理之前，让我们先解释一下动态绑定在哪里被使用。动态绑定用于解决当类之间存在继承关系时，哪个成员函数将被调用。这是在运行时基于对象来解决的。让我们详细谈谈它。
- en: Dynamic binding in function invocation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数调用中的动态绑定
- en: 'We talked about the dynamic binding of objects to their references and invocation
    of methods. The invocation takes place based on the type of object on which that
    method is called. This is easier to understand with an example. Take a look at
    the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了对象与其引用的动态绑定以及方法的调用。调用是基于调用该方法的对象的类型。用例子来说明这一点更容易理解。看一下下面的例子：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Take a closer look at the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看以下内容：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we have created three different objects with the same return types, `Book`.
    The first thing to notice is that the class on the left-hand side of the equals
    operator will always be higher in the inheritance hierarchy. Secondly, all three
    are different instances. So, when you try to invoke a member function named `cover`
    from all these instances, you may observe different behavior in all three cases
    and see that the invocation is done based on the runtime type of the class. What
    do we mean by the runtime type of the class? It means that at compile time, all
    three expressions were of the same type, `Book`, but at runtime, things are different.
    Invocation of `Dictionary`, `Encyclopedia`, and `Book` takes place resulting in
    invocation of their respective versions of the cover method. In our case, the
    result that gets printed out shows the expected behavior. This behavior is termed
    **dynamic binding** in object-oriented languages.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了三个具有相同返回类型`Book`的不同对象。首先要注意的是，等于运算符左侧的类在继承层次结构中总是更高的。其次，这三个都是不同的实例。所以，当你尝试从所有这些实例中调用名为`cover`的成员函数时，你可能会观察到三种情况下的不同行为，并看到调用是基于类的运行时类型。我们说的类的运行时类型是什么意思？这意味着在编译时，所有三个表达式都是同一类型`Book`，但在运行时，情况就不同了。`Dictionary`、`Encyclopedia`和`Book`的调用发生，导致调用它们各自的封面方法。在我们的例子中，打印出来的结果显示了预期的行为。这种行为在面向对象语言中被称为**动态绑定**。
- en: By now, I'm sure that you're pretty well-versed in the concept of inheritance,
    and are ready to take this characteristic into account when designing models for
    your next application, right? Well to make it clearer, we'll think of inheritance
    as a concept that solves the issue of code duplication, by code reuse. But it's
    our responsibility to keep in mind that with the relationship that these classes
    form using inheritance, they also transmit some significant semantic information.
    What do we mean by that? We mean that it's important to understand that when we
    inherit from some superclass, it becomes a public interface/construct representing
    our subclass.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我相信你已经非常熟悉继承的概念，并且准备好在为你的下一个应用程序设计模型时考虑这个特性，对吧？为了使它更清晰，我们将继承视为一个通过代码复用来解决代码重复问题的概念。但是，我们必须记住，使用继承形成的这些类之间的关系，它们也传递了一些重要的语义信息。我们这是什么意思呢？我们的意思是，理解当我们从某个超类继承时，它就变成了代表我们的子类的公共接口/构造体是很重要的。
- en: Hence, when inheriting dictionary from book, if it also keeps semantic information
    about whether the book is going to have a title, pages, cover, author, or other
    information, then its subclass is also expected to have this information available.
    The reason for this is that a `Book` is a public interface for a `dictionary`
    because of the inheritance relationship. And that's where sometimes we find ourselves
    using inheritance in the wrong way. Let's discuss this in brief.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当从`book`继承字典时，如果它还保留有关书籍是否将具有标题、页数、封面、作者或其他信息的语义信息，那么其子类也预计将具有这些信息可用。原因在于，由于继承关系，`Book`是`dictionary`的公共接口。这就是我们有时发现自己错误地使用继承的地方。让我们简要讨论一下。
- en: Misusing inheritance
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承滥用
- en: 'Take a look at this example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个例子：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, a class named `CustomStack` is inheriting from `ArrayList[String]`. What
    you see here is a semantic code smell. Just because your `CustomStack` class has
    extended from `ArrayList` means that you have access to all of its public members.
    Anyone with a stack object is not only going to have access to `push` or `pop`,
    but a whole set of methods like `get`, `set`, `add`, `remove`, and so on. This
    is wrong; you''re allowed to use an array list object internally to form a stack
    object but the public interface should have nothing to do with it. In our case,
    our code shows that if you have access to `CustomStack`, you have access to all
    those methods. You should avoid using this in the `Stack` construct. The reality
    is that both of these are different concepts altogether so we should avoid using
    such types of modeling where it is semantically wrong. Although it may be a design
    choice, still we should keep in mind a few points when making these decisions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个名为 `CustomStack` 的类正在继承自 `ArrayList[String]`。你所看到的是一种语义代码异味。仅仅因为你的 `CustomStack`
    类扩展了 `ArrayList`，并不意味着你能够访问其所有公共成员。任何拥有栈对象的用户不仅将能够访问 `push` 或 `pop`，还将能够访问一系列方法，如
    `get`、`set`、`add`、`remove` 等等。这是错误的；你可以在内部使用数组列表对象来形成一个栈对象，但公共接口应该与此无关。在我们的例子中，我们的代码表明如果你能够访问
    `CustomStack`，你将能够访问所有这些方法。你应该避免在 `Stack` 构造中使用这种做法。实际上，这两个概念完全不同，因此我们应该避免使用这种在语义上错误的建模方式。尽管这可能是一个设计选择，但我们仍然应该在做出这些决策时牢记以下几点：
- en: Check for Is-A relationship, if it holds true.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Is-A 关系，如果它成立。
- en: Check if rules for encapsulation, such as data hiding, hold true. You should
    never expose internal implementation details to the outer world. In our case,
    `Stack` should've implemented the array list internally instead of inheriting
    from it.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查封装规则，如数据隐藏，是否成立。你永远不应该向外部世界暴露内部实现细节。在我们的例子中，`Stack` 应该在内部实现数组列表，而不是从它继承。
- en: We should check for domains of each construct, the cross domain inheritance
    model is not a good choice, for sure. `Stack` and `ArrayList` are different conceptually.
    One can be composed using the other but should not inherit the other.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该检查每个构造的域，交叉域继承模型肯定不是一个好的选择。`Stack` 和 `ArrayList` 在概念上是不同的。一个可以用另一个来组合，但不应该继承另一个。
- en: If you follow these points, you'll make a better design choice for modeling
    inheritance relationships.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这些要点，你将能做出更好的设计选择来建模继承关系。
- en: Well, you remember we learned about `case` classes and the way we used to instantiate
    them without the `new` keywords? That makes me wonder, what if we want to have
    more than one way to construct new objects of such a `case` class? If you're also
    thinking the same; good! It's possible to have parameterized constructors in Scala.
    Let's talk about them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你还记得我们学习了关于 `case` 类以及我们如何使用不带 `new` 关键字的方式来实例化它们吗？这让我想知道，如果我们想要有超过一种方式来构造这种
    `case` 类的新对象呢？如果你也在想同样的事情；太好了！Scala 中可以有参数化构造函数。让我们来谈谈它们。
- en: Default and parameterized constructors
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认和参数化构造函数
- en: 'The primary constructor for any class defined in Scala is the body itself.
    It means that whatever you declare and define inside a class body gets instantiated
    when you make an instance of it. There are other ways to define secondary/auxiliary
    constructors as well. Take a look at the following `case` classes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中定义的任何类的首要构造函数是其本身。这意味着你在一个类体内声明的和定义的任何内容，在创建其实例时都会被实例化。还有其他方法可以定义二级/辅助构造函数。看看下面的
    `case` 类：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see two `case` classes named `Employee` and `StartUp`. You may wonder
    why `Employee` is specific to our `StartUp` class. The `StartUp` case class takes
    a few attributes such as `founder`, `coFounder`, `members`, and `foundingDate`.
    So, for creating instances of these `case` classes, we have to provide values
    for each member. In this case, if someone on the client side wants to use this
    `case` class and does not want to provide `members` or `coFounder` information,
    they still have to give dummy values. Now, the solution to this could be to construct
    auxiliary constructors for our client''s sake. This can be done if we provide
    alternative invocation strategies for the `StartUp` case class. Let''s do that:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两个名为 `Employee` 和 `StartUp` 的 `case` 类。你可能想知道为什么 `Employee` 是特定于我们的 `StartUp`
    类的。`StartUp` `case` 类接受一些属性，如 `founder`、`coFounder`、`members` 和 `foundingDate`。因此，为了创建这些
    `case` 类的实例，我们必须为每个成员提供值。在这种情况下，如果客户端某个人想使用这个 `case` 类并且不想提供 `members` 或 `coFounder`
    信息，他们仍然必须给出占位符值。现在，这个解决方案可能是为我们的客户端构建辅助构造函数。如果我们为 `StartUp` `case` 类提供替代调用策略，这就可以做到。让我们这样做：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A few points to note here. Firstly, we can define overloaded versions of `this`
    method that work as auxiliary constructors. Secondly, in each definition, we''re
    making a call to the main constructor with some other values. This practice can
    be done on either of these sides. By this we mean that passing optional values
    can be done either at the time of declaring these `case` classes or on the client
    side where we use these. We''ve done it while declaring these classes. Now let''s
    use them in our `StartUpApp`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的点。首先，我们可以定义 `this` 方法的重载版本，它们可以作为辅助构造函数工作。其次，在每个定义中，我们都在调用主构造函数，并传递一些其他值。这种做法可以在这些类的任一边进行。这意味着在声明这些
    `case` 类时或在客户端使用这些类时传递可选值都可以。我们已经在这类声明时这样做过了。现在让我们在 `StartUpApp` 中使用它们：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It was easy to use these auxiliary constructor versions of the `StartUp` case
    class. We can see that we only passed the needed parameters, and if the version
    was available to us, we were able to create an instance for it. But wait a second,
    we had these case classes and yet still we used the `new` keyword to create an
    instance for the `StartUp` class. What if we try to create an instance without
    using the `new` keyword? Let''s try that:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些 `StartUp` `case` 类的辅助构造函数版本很容易。我们可以看到我们只传递了所需的参数，如果这个版本对我们可用，我们就能为其创建一个实例。但是等等，我们已经有这些
    `case` 类，但我们仍然使用 `new` 关键字为 `StartUp` 类创建实例。如果我们尝试不使用 `new` 关键字创建实例会怎样呢？让我们试试：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you try to do so, the Scala compiler will throw an error stating the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这样做，Scala 编译器会抛出一个错误，如下所示：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This happens because when you declare `case` classes, the compiler generates
    a companion object with the `apply` method for it and the `apply` method takes
    all the parameters of the `case` class definition. When we define auxiliary constructors,
    we don''t really overload the `apply` method defined in companion objects. Hence,
    when we try to use `case` class instantiation without the `new` keyword, the Scala
    compiler is not able to find a corresponding `apply` method version and gives
    an error. If you really want to use it that way, you can define overloaded versions
    of the `apply` method in companion objects. We''ll try to overload an implementation
    with only two parameters, `name` and `founder`*.* Let''s do this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当你声明 `case` 类时，编译器会为它生成一个伴随对象，其中包含一个 `apply` 方法，并且 `apply` 方法接受 `case` 类定义的所有参数。当我们定义辅助构造函数时，我们并没有真正地覆盖伴随对象中定义的
    `apply` 方法。因此，当我们尝试不使用 `new` 关键字使用 `case` 类实例化时，Scala 编译器无法找到相应的 `apply` 方法版本，并给出错误。如果你真的想那样使用它，你可以在伴随对象中定义
    `apply` 方法的重载版本。我们将尝试只使用两个参数（`name` 和 `founder`）的重载实现*。让我们这样做：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It''s easy to do. Defining an `apply` method that takes only `name` and `founder`
    gives us the option to create an instance of our `StartUp` object without using
    the `new` keyword:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事很简单。定义一个只接受 `name` 和 `founder` 的 `apply` 方法，我们可以选择创建我们的 `StartUp` 对象实例而不使用
    `new` 关键字：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These are just a few ways; we can make the client's life easier by providing
    a variety of options to construct new objects. Now that we have seen how we can
    define various options for a class construct and also how inheritance can be effective
    if used properly, we can make our constructs more powerful by using traits in
    Scala. That's what we're going to explore next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是几种方法；我们可以通过提供构建新对象的各种选项来使客户的体验更轻松。现在我们已经看到了我们如何为类构造定义各种选项，以及如果正确使用，继承可以如何有效，我们可以通过在Scala中使用特性来使我们的构造更强大。这就是我们将要探索的。
- en: Traits
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性
- en: 'What are traits? For those coming from a Java background, it''s tempting to
    see them as interfaces, but in reality they are something different. **Trait**
    constructs may look similar but are of a different nature to interfaces in Java.
    The meaning of the word trait is: a distinguishing quality or characteristic,
    typically one belonging to a person. One of the purposes of traits is the same.
    What if you want to add a particular characteristic to our hierarchy of classes
    or a single class? You can do this by extending or mixing in a trait. It''s easier
    to say that we mix-in traits rather than extend from them. How are these two different?
    We''ll talk about this as we go along but for now, let''s take a look at how we
    define a `trait` in Scala:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 特性是什么？对于来自Java背景的人来说，他们可能会倾向于将特性视为接口，但实际上它们是不同的东西。**特性**构造可能看起来相似，但与Java中的接口在本质上不同。特性这个词的含义是：一种区别质量或特征，通常是指一个人的。特性的一种用途也是一样的。如果你想要向我们的类层次结构或单个类添加特定的特性，你可以通过扩展或混合特性来实现。我们说混合特性而不是扩展特性更容易。这两者有什么不同？我们将随着讨论的进行来讨论这个问题，但现在，让我们看看如何在Scala中定义一个`trait`：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Look at it this way. One of the qualities of people who tend to socialize well
    is that they greet you wholeheartedly when they meet you. In programming terms,
    you want to make a class named `Person` social. You can create a `trait` named
    `Socialize`, which for now just defines a method `greet`. This is simple: by defining
    a `trait`, we use the keyword `trait` and give it a name. We''ll talk about this
    as we go along but for now, let''s take a look at how we define a `trait` in Scala:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看吧。那些善于社交的人的一个特点是，当他们遇见你时，他们会全心全意地问候你。在编程术语中，你想要创建一个名为`Person`的社交类。你可以创建一个名为`Socialize`的`trait`，目前它只定义了一个方法`greet`。这很简单：通过定义一个`trait`，我们使用关键字`trait`并给它一个名字。我们将随着讨论的进行来讨论这个问题，但现在，让我们看看如何在Scala中定义一个`trait`：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Traits do not take parameters
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性不接受参数
- en: Traits can also form an inheritance hierarchy, a trait can mix-in another trait
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性也可以形成一个继承层次结构，一个特性可以混合另一个特性
- en: You can't have a class and trait with the same name in the same scope
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一个作用域内，你不能有一个类和一个具有相同名称的特性
- en: The order in which we mix-in traits matters and can affect the behavior of your
    implementation
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合特性的顺序很重要，并且可能会影响你的实现行为
- en: 'We can define traits by observing the previous points, but it''s also good
    to know how Scala treats traits at compile time. To understand this, we can use
    the `javap` command on our `Socialize` class. It''s going to show the compiled
    form of our trait:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过观察前面的点来定义特性，但了解Scala在编译时如何处理特性也是很好的。为了理解这一点，我们可以使用`javap`命令在我们的`Socialize`类上。它将显示我们特性的编译形式：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding example shows that we can have abstract, as well as concrete
    members, as part of our traits. Here we have just declared our `linkToSocialNetwork`
    method without definition and also our previous method, named `greet`, that has
    its definition:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例显示，我们的特性可以包含抽象成员以及具体成员。在这里，我们只是声明了我们的`linkToSocialNetwork`方法而没有定义，以及我们之前的方法，名为`greet`，它有它的定义：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have given its implementation in the `Employee` class, which mixes in this
    trait. With this abstraction, we now can compare traits to abstract classes in
    Scala. What's the distinction between these two? First, you may see that we can't
    pass constructor parameters to our traits. Second, as constructs, traits are heavier
    than abstract classes. So it's a matter of choice for you to decide between these
    two. The recommendation is to select a trait if you're extending any functionality,
    or if only as a class hierarchy, then an abstract class could be a good choice.
    One more aspect of a trait is that it's stackable. This means it's obvious you
    can mix-in more than one and its effect can be used in a stackable manner. Let's
    take a look at how traits can be used to showcase stackable behavior.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `Employee` 类中给出了它的实现，这个类混合了这个特性。有了这种抽象，我们现在可以将特性与 Scala 中的抽象类进行比较。这两者之间的区别是什么？首先，你可能注意到我们不能向我们的特性传递构造函数参数。其次，作为构造，特性比抽象类更重。所以，选择哪一个取决于你。建议如果你正在扩展任何功能，或者如果只是作为一个类层次结构，那么抽象类可能是一个不错的选择。特性的另一个方面是它是可堆叠的。这意味着很明显你可以混合多个特性，并且其效果可以以堆叠的方式使用。让我们看看特性如何被用来展示可堆叠行为。
- en: Traits as mix-ins
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性作为混合体
- en: 'The way we do trait mix-ins is no different than inheriting any class in Scala;
    the only difference is that you can mix-in more than one trait and for that we
    have this nice keyword called `with`. Why do we call it mix-in? We could have
    called it something else. Well, yes but this explains almost everything you can
    do with traits. It''s easy to modify or add up behaviors to an already existing
    functionality or construct without affecting already existing behavior. We''ll
    see that in a bit. Traits can be used in a variety of use cases such as:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行特性混合的方式与在 Scala 中继承任何类没有不同；唯一的区别是你可以混合多个特性，为此我们有一个叫做 `with` 的关键字。我们为什么叫它混合体？我们本可以叫它别的名字。好吧，是的，但这几乎解释了你可以用特性做的一切。很容易修改或添加到现有功能或构造中的行为，而不影响现有的行为。我们很快就会看到这一点。特性可以在各种用例中使用，例如：
- en: Composable mix-ins; to make already existing interfaces richer
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可组合的混合体；使现有的接口更丰富
- en: Stackable modifications
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可堆叠的修改
- en: Traits as composable mix-ins
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性作为可组合的混合体
- en: By **composable mix-ins** we mean that we can create an instance of a particular
    type, with mix-ins of a trait, that can have certain additive functionalities.
    If you're thinking why would we want to do that, then the answer is maybe you
    want to add some particular behavior that makes sense to your functionality and
    you want it to behave as if it has come from the library itself. As a client of
    such constructs or libraries, we want them to feel as natural as they are. Traits
    help us add certain functions, keeping the real library intact.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 **可组合的混合体** 我们意味着我们可以创建一个特定类型的实例，带有特性的混合，它可以具有某些附加功能。如果你在想我们为什么要这样做，那么答案是也许你想要添加一些特定的行为，这些行为对你的功能有意义，并且你希望它表现得好像它来自库本身。作为这种构造或库的客户，我们希望它们感觉尽可能自然。特性帮助我们添加某些功能，同时保持真正的库完整。
- en: 'We can understand this better with the help of an example. So, suppose you
    have an already existing `CreditCard` functionality. For demonstration purposes,
    we''ll limit our expectations from this `CreditCard` functionality. This class
    has a certain way of generating credit card numbers for each subscriber. This
    is a thing of the past. Now, in the future, let''s say in the next few days, we
    want to introduce certain new `CreditCard` subscriptions with more offers (conditions
    apply). Also, we want to have our own way of generating `CreditCard` numbers,
    without affecting the already existing functionalities or the business. The reality
    might be different, but for learning purposes it''s fine to generate credit card
    numbers ourselves, isn''t it? So, now that you have this picture in mind. Let''s
    see what we already have:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个例子更好地理解这一点。所以，假设你已经有了一个现有的 `CreditCard` 功能。为了演示目的，我们将限制我们对这个 `CreditCard`
    功能的期望。这个类有生成每个订阅者信用卡号码的特定方式。这是过去的事情了。现在，在未来的几天里，我们想要引入一些新的带有更多优惠（适用条件）的 `CreditCard`
    订阅。此外，我们希望有自己的方式生成 `CreditCard` 号码，而不影响现有的功能或业务。现实可能不同，但为了学习目的，我们自己生成信用卡号码是可以的，不是吗？所以，现在你有了这个画面。让我们看看我们已经有什么：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can see how this `CreditCard` abstract class is defined, and our client
    `CCApp` is accessing that to create a new credit card account with a certain amount.
    Also, if you take a closer look, we didn''t try to define isolated concrete classes
    that extend our abstract class named `CreditCard`, but we directly instantiated
    `CreditCard`, which is only possible because Scala generates and instantiates
    an anonymous class for us and expects us to define the abstract method, in our
    case `creditLimit`. Now, our requirement is that without playing with the already
    available code, we want to have our own version of the `creditCardNumber` generator
    that generates the credit card number for us. Let''s do that then. But think about
    it, how are we going to do that and make it look natural? We want to do it this
    way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到这个`CreditCard`抽象类的定义，我们的客户端`CCApp`正在访问它以创建一个具有特定金额的新信用卡账户。如果你仔细观察，我们没有尝试定义独立的具体类来扩展我们名为`CreditCard`的抽象类，而是直接实例化了`CreditCard`，这是由于
    Scala 为我们生成并实例化了一个匿名类，并期望我们定义抽象方法，在我们的例子中是`creditLimit`。现在，我们的要求是在不修改现有代码的情况下，我们想要有一个自己的`creditCardNumber`生成器版本，它可以为我们生成信用卡号。那么让我们来做这件事。但是想想看，我们如何做才能让它看起来很自然？我们希望这样做：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For this, we can define a `trait`, let''s say `CreditCardOps`, that''s going
    to define the functionality with which we can refer to the new logic without affecting
    the logic previously implemented. And for the clients it''s going to be natural.
    Let''s take a look at the implementation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，我们可以定义一个`trait`，比如说`CreditCardOps`，它将定义我们可以用来引用新逻辑而不影响之前实现的功能。对于客户端来说，这将很自然。让我们看看实现：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The usage didn''t change too much, and we also achieved what we intended. The
    only new thing we introduced was a `trait` named `CreditCardOps`. This `trait`
    has defined the new logic that we wanted. A few points to note about this implementation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式变化不大，我们也实现了我们的目标。我们引入的唯一新事物是一个名为`CreditCardOps`的`trait`。这个`trait`定义了我们想要的新逻辑。关于这个实现，有几个需要注意的点：
- en: First, we need to mix-in this `trait` to our `CreditCard` implementations whenever
    we want this synthetic behavior.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们想要这种合成行为的时候，将这个`trait`混合到我们的`CreditCard`实现中。
- en: 'We also may want to ensure that this `trait` is specific to `CreditCard` types,
    hence any other traits or classes should not be allowed to mix-in this. We have
    eventually ensured that too. If you try to do something like the following:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可能想要确保这个`trait`仅针对`CreditCard`类型，因此不允许其他特质或类混合使用这个。我们最终也确保了这一点。如果你尝试做以下类似的事情：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The Scala compiler will not allow us to do this; the reason being that the
    syntax we choose to write while defining our trait is as follows:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 编译器不会允许我们这样做；原因是我们在定义特质时选择的语法如下：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This syntax gives a bit of information to the Scala compiler about upcoming
    statements in the current scope, as well as also limiting the trait's availability
    for certain types. Because of this syntax, we're only allowed to mix-in the `CreditCardOps`
    trait to `CreditCard` types.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个语法给 Scala 编译器提供了一些关于当前作用域中即将到来的语句的信息，同时也限制了特质对某些类型的可用性。因为这个语法，我们只能将`CreditCardOps`特质混合到`CreditCard`类型中。
- en: 'Look at the following implementation:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看下面的实现：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We are able to refer to `ccType` and `ccNum`, members of the `CreditCard` class,
    only because of this `self` type declaration*.* This declaration gives us access
    to members of the type specified.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够引用`ccType`和`ccNum`，`CreditCard`类的成员，仅仅是因为这个`self`类型声明*。* 这个声明让我们可以访问指定类型的成员。
- en: We've just modified the logic for `ccNum` and consumed the previous logic to
    create the new one. This was possible because of mix-ins.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只是修改了`ccNum`的逻辑，并消耗了之前的逻辑来创建新的逻辑。这是由于混合使用（mix-ins）实现的。
- en: 'Also, one constraint that we faced is that you may have wanted to `override`
    the value, `ccNum`, so that the clients of your `CreditCard` object, when accessing
    `ccNum`, could get the value based on the new logic, something similar to the
    following:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们面临的一个约束是，你可能想要`重写`（`override`）`ccNum`的值，这样当你的`CreditCard`对象的客户端访问`ccNum`时，他们可以得到基于新逻辑的值，类似于以下内容：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But, that's not possible. The compiler will let you do so but at runtime, the
    value will be null. A closer look will tell you that `self` is just a reference
    to the `CreditCard` type, hence you'll be able to refer to members, like we did
    while doing pattern matching, but if you try to `override`, it won't show the
    expected behavior. One reason for that is traits evaluate at runtime.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这是不可能的。编译器会允许你这样做，但在运行时，值将是null。仔细观察你会发现`self`只是`CreditCard`类型的引用，因此你将能够引用成员，就像我们在进行模式匹配时做的那样，但如果你尝试`override`，它不会显示预期的行为。造成这种情况的一个原因是特性在运行时评估。
- en: With this, we are finally able to get add-on behavior for only `CreditCard`
    types. This is the way we can make already existing constructs more powerful and
    can also modify them to suite our specific needs. We have a term for this process,
    we call it making thin interfaces rich through composable mix-ins. Why rich? Because
    of additive or selective modifications. There's more to traits based on our own
    use-cases. It's natural for an entity to have more than one trait, isn't it? Also,
    its understood if two or more composable behaviors are applied together, they'll
    both have their impact. It's an interesting topic; the way these behaviors are
    implemented. One of the ways these can be implemented is as *stackable modifications.*
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们最终能够只为`CreditCard`类型添加附加行为。这是我们使现有结构更强大的方法，也可以根据我们的特定需求对其进行修改。我们有一个术语来描述这个过程，我们称之为通过可组合混入使薄接口丰富。为什么是丰富的？因为它是可添加的或选择性的修改。基于我们的用例，特性还有更多。一个实体自然会有多个特性，不是吗？另外，如果两个或多个可组合的行为一起应用，它们都会产生影响。这是一个有趣的话题；这些行为是如何实现的。这些行为可以实现的其中一种方式是作为*可堆叠修改*。
- en: Traits as stackable modifications
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性作为可堆叠修改
- en: 'Before we learn about **stackable modifications*,*** we should know why we
    may need them, shouldn''t we? Yes, so the best way to understand that is by using
    an example. Suppose there''s a consumer of a service. He can pay to subscribe
    to a particular service. That service, for example your DTH TV subscription service,
    includes several channel packages. Now, what''s of interest to us here is that
    we may want to implement this service. For implementation, we want to have a list
    of channels or packages the consumer is subscribed to. At the beginning of the
    month, he subscribed to a particular package, let''s say `BasicPackage`. So we
    said the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习**可堆叠修改**之前，我们应该知道我们为什么可能需要它们，不是吗？是的，所以理解这个最好的方式是通过使用一个例子。假设有一个服务的消费者。他可以付费订阅特定的服务。例如，你的DTH电视订阅服务包括几个频道包。现在，对我们来说，有趣的是我们可能想要实现这个服务。为了实现，我们想要有一个消费者订阅的频道或包列表。在月初，他订阅了一个特定的包，比如`BasicPackage`。所以我们说了以下内容：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This, in fact is self-explanatory. We created a `Service` with `BasicPackage`.
    Thinking programmatically, we can assume that we''ve a particular value in our
    `Service` class that has the list of packages/channels listed in a certain package.
    So with this declaration, that attribute must''ve been updated with the value.
    Up till now, everything has been fine. What if the consumer wants to subscribe
    to one more package? And we don''t want to have a mechanism that explicitly modifies
    the list of channels for us, but it should happen by default. This is like a behavior
    that''s getting modified as we keep adding different packages. This kind of situation
    gets you to the concept of stackable modifications:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是很直观的。我们创建了一个带有`BasicPackage`的`Service`。从编程的角度来看，我们可以假设在我们的`Service`类中有一个特定的值，它包含在某个包中列出的包/频道列表。因此，根据这个声明，该属性必须已经更新了值。到目前为止，一切都很顺利。如果消费者想要订阅更多的包怎么办？我们不希望有一个明确修改我们频道列表的机制，但这是默认发生的。这就像随着我们不断添加不同的包，行为在不断地被修改。这种情况下，你会接触到可堆叠修改的概念：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With each added package, a list of channels/packages is going to update. We''ll
    see in a bit how the implementation implicitly stacks modifications as we add
    more packages. These modifications can be done on some data structure, where we
    can pipeline operations on data, or scenarios like we just mentioned. A sequence
    of operations/modifications in terms of traits can be added. Let''s take another
    example and work on it. For that we''ll take our `CreditCard` abstract class and
    modify it to suit our newly introduced `GoldCreditCard` and `PlatinumCreditCard`.
    These new card subscriptions have a lot to offer to consumers along with an increased
    limit. Subscribers to the gold card will get a credit limit of 10% more than the
    standard/basic credit card. The increased limit amount for a platinum card is
    25% more than a standard card, apart from the other goodies that they bring. A
    consumer who is adventurous enough may want to opt for both subscriptions together.
    So how do you think we can implement this? One hint, we may be using stackable
    modifications, which we just discussed*.* So, let''s take a look what we already
    have:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每添加一个包，通道/包的列表都会更新。我们稍后会看到，当我们添加更多包时，实现会隐式地堆叠修改。这些修改可以在某些数据结构上进行，我们可以在数据上管道操作，或者像我们刚才提到的场景。可以添加一系列关于特质的操作/修改。让我们再举一个例子并对其进行处理。为此，我们将使用我们的
    `CreditCard` 抽象类并将其修改为适合我们新引入的 `GoldCreditCard` 和 `PlatinumCreditCard`。这些新的卡片订阅为消费者提供了很多好处，同时还有更高的信用额度。金卡订阅者将获得比标准/基本信用卡高出
    10% 的信用额度。白金卡的信用额度增加量比标准卡高出 25%，除此之外，它们还带来了其他好处。一个足够冒险的消费者可能想要同时选择这两种订阅。那么你认为我们该如何实现呢？一个提示，我们可能会使用我们刚才讨论的堆叠修改。那么，让我们看看我们已经有的是什么：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Nothing different here. We have our old abstract `CreditCard` class. We may
    want to create a standard/basic credit card:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么不同。我们有一个旧的抽象 `CreditCard` 类。我们可能想要创建一个标准/基本信用卡：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This isn''t alien code, it''s easy to understand. We created a `BasicCreditCard`
    class extending `CreditCard` and we are overriding the `creditLimit` method. This
    method is simply returning the `Amount` object for the limit amount. Now, let''s
    take a look at the implementation of other subscription types:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是陌生的代码，很容易理解。我们创建了一个扩展 `CreditCard` 的 `BasicCreditCard` 类，并且我们正在重写 `creditLimit`
    方法。这个方法简单地返回限制金额的 `Amount` 对象。现在，让我们看看其他订阅类型的实现：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Two more types named `GoldSubscription` and `PlatinumSubscription` as we discussed
    in terms of traits are added. What''s different here? Syntactical analysis will
    say that this has an `abstract override` modifier, but how? How can you have these
    two together? We declare something `abstract` if we are not willing to provide
    its definition and use `override` to redefine something already in scope. So,
    the thing is, both of these are conflicting. However, Scala, as we already know,
    is intelligent enough to know that this is done in the context of a trait, which
    gets evaluated at runtime, and when you try to create an instance of such a trait
    or mix-in with some already created concrete class, it''s going to override the
    particular definition. See the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前讨论的特性，增加了两个名为 `GoldSubscription` 和 `PlatinumSubscription` 的类型。这里有什么不同呢？语法分析会说这有一个
    `abstract override` 修饰符，但它是如何实现的？如何将这两个结合在一起呢？如果我们不打算提供其定义，我们会声明某个东西为 `abstract`，并使用
    `override` 来重新定义已经存在于作用域中的某个东西。所以，问题是，这两个都是冲突的。然而，正如我们已知的，Scala 足够智能，知道这是在特质的上下文中完成的，特质在运行时会被评估，当你尝试创建这样一个特质的实例或与某个已经创建的具体类混合时，它将覆盖特定的定义。看下面的例子：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we are going to expect a concrete implementation of `CreditCard` to mix-in
    this trait. Let''s take a look at the implementation `CCApp` to understand better:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们期望有一个 `CreditCard` 的具体实现来混合这个特质。让我们看看 `CCApp` 的实现来更好地理解：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The result is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding code is the implementation of the solution we came up with
    for our problem using stackable modifications. A few points to note here are as
    follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，是使用堆叠修改为我们的问题找到的解决方案的实现。这里有几个需要注意的点：
- en: 'Consider the following code snippet:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We didn't try to define some explicit logic implementation but made a *super*
    call to an already defined method with certain *additions*/*limitations*/*modifications*
    in a parameter value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有尝试定义一些明确的逻辑实现，而是在一个已经定义的方法上进行了 `super` 调用，并在参数值中添加了 *添加*/*限制*/*修改*。
- en: With this, we're allowed to pass the same type of parameter and as it is composed,
    the value we'll get will be modified.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们可以传递相同类型的参数，并且随着它的组合，我们将得到的值将被修改。
- en: 'We can apply as many `CreditCard` subscriptions as we want and based on the
    logic, we''ll get the expected value for `creditLimit`. That''s why we were able
    to call the following:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以应用任意多的`CreditCard`订阅，根据逻辑，我们将得到预期的`creditLimit`值。这就是为什么我们能够调用以下内容：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Last but not least, we mix-in the traits to concrete classes with overridden
    implementations for our abstract method, that's why `abstract override` worked
    here.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将特性与具有覆盖我们抽象方法的实现的具体类混合，这就是为什么在这里`abstract override`可以工作。
- en: This was interesting, you know. We passed a `creditLimit` value of `15000` for
    all the different instances and we got corresponding values. All of this is due
    to trait's use of stackable modifications.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，你知道。我们为所有不同的实例传递了`15000`的`creditLimit`值，并得到了相应的值。所有这些都是由于特性使用可堆叠的修改。
- en: Linearization
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性化
- en: 'The reason why multiple inheritances become a burden when we try to implement
    them is due to *the diamond problem*. Take a look at the following image:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试实现多重继承时，它变得负担沉重的原因是*菱形问题*。看看下面的图像：
- en: '![](img/00030.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: Diamond problem
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 菱形问题
- en: Here, suppose we have an abstract class named `Language`, that has a method
    named `sayHello`. Two traits, named `British` and `Spanish`, extend the abstract
    `Language` class and define their own implementation of the `sayHello` method.
    Then we create a trait, named `Socializer`, that mixes in the other two traits
    with a `super` call to the `sayHello` method implementation. Now, confusion occurs
    as to which implementation of `sayHello` is getting called when we invoke this
    method. The primary reason for this problem is there's no multiple inheritance
    in Java, but Scala supports a form of multiple inheritance through *trait mix-in*.
    The concept Scala uses to resolve the problem of super calls is linearization.
    Let's first code for the problem and see it's behavior, then we'll understand
    linearization and the rules that justify the behavior we are going to see.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，假设我们有一个名为`Language`的抽象类，它有一个名为`sayHello`的方法。两个特性，名为`British`和`Spanish`，扩展了抽象的`Language`类，并定义了它们自己的`sayHello`方法实现。然后我们创建了一个名为`Socializer`的特性，它通过调用`sayHello`方法实现的`super`来混合其他两个特性。现在，当我们调用此方法时，关于哪个`sayHello`实现被调用产生了混淆。这个问题的主要原因是Java中没有多重继承，但Scala通过*特性混合*支持一种形式的多重继承。Scala用于解决超调用问题的概念是线性化。让我们首先为这个问题编写代码并观察其行为，然后我们将了解线性化以及证明我们即将看到的行为的规则。
- en: 'Suppose we code for the problem shown in the preceding image. It''s going to
    look as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为前面图像中显示的问题编写代码。它将如下所示：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The result is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Did you expect this result? We had declared our class `Socializer`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望这个结果吗？我们已声明我们的类`Socializer`：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result shows that the call made to `super.sayHello` invoked `sayHello`
    from the `Spanish` trait. Well, such behavior is due to linearization. But how
    does it work? The rules for linearization are as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，调用`super.sayHello`调用了`Spanish`特性中的`sayHello`。嗯，这种行为是由于线性化。但它是如何工作的？线性化的规则如下：
- en: We'll start with the very first extended trait/class and think of the hierarchy.
    We'll consider `AnyRef` and `Any` are also part of the inheritance hierarchy.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从第一个扩展的特性/类开始，考虑层次结构。我们将考虑`AnyRef`和`Any`也是继承层次结构的一部分。
- en: 'This is going to give us the following result:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下结果：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let's call this a **linearized hierarchy **for now.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时称这为**线性化层次结构**。
- en: 'Take the next trait/class and write a hierarchy down for it:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为下一个特性/类写下它的层次结构：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Remove the traits/classes from this hierarchy that already exist in the linearized
    hierarchy.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个层次结构中删除已经存在于线性化层次结构中的特性/类。
- en: 'So we''ll remove `AnyRef -> Any`. Remaining syntax will be:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将删除`AnyRef -> Any`。剩余的语法将是：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Add the remaining traits/classes to the bottom of the already available linearized
    hierarchy.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将剩余的特性/类添加到已存在的线性化层次结构的底部。
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Repeat *step 2* for all traits/classes.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有特性/类重复*步骤 2*。
- en: 'Finally, place the trait/class at the very first position from the left:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将特性/类放置在左侧的第一个位置：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The direction of super calls is going to be from *left* to *right.* And for
    our implementation, where we extended from `Spanish` with `British`, we now know
    that the `super` call invoked is on the `Spanish` trait due to linearization.
    The result was from the `Spanish` trait.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 超类调用的方向将是从 *左* 到 *右*。对于我们的实现，我们通过 `British` 扩展了 `Spanish`，我们现在知道由于线性化，`super`
    调用是在 `Spanish` 特质上进行的。结果是来自 `Spanish` 特质。
- en: 'The result is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This understanding can help us a lot to learn the usual behavior of trait mix-ins
    and inheritance. Knowing how linearization works is essential to understanding
    already written code and creating a good design yourself. Now that you know how
    linearization works, why not learn another important concept in object-oriented
    programming?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理解可以帮助我们更好地学习特质混合和继承的常规行为。了解线性化是如何工作的对于理解已编写的代码和创建良好的设计至关重要。既然你已经知道了线性化是如何工作的，为什么不学习面向对象编程中的另一个重要概念呢？
- en: Packaging and importing
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和导入
- en: One of the important aspects of object-oriented programs is how we define modular,
    reusable, and hierarchical structures. We're allowed to put all the code that
    we write, constructs like classes, traits, and objects, in some particular package.
    By using *packaging* and *visibility* rules, we can make our code more to reason
    about, means to expose some method to other classes or  and we get structured
    and modular code as an added advantage. There are a couple of ways you're allowed
    to write package statements in Scala; we'll take a look at those.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象程序的一个重要方面是我们如何定义模块化、可重用和层次化的结构。我们允许将我们编写的所有代码，如类、特性和对象，放入某个特定的包中。通过使用 *打包*
    和 *可见性* 规则，我们可以使我们的代码更容易推理，意味着将某些方法暴露给其他类，并且我们得到了结构化和模块化的代码作为额外的优势。在 Scala 中，你可以以几种方式编写包声明；我们将查看这些。
- en: Package statements
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包声明
- en: 'We can write package statements at the beginning of the file. One of the simplest
    examples is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在文件的开始处编写包声明。一个最简单的例子如下：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we defined the package name as `country`. Now, whatever we define in
    the corresponding file is going to stay within the scope of this `country` package.
    This is the reason why, when we wanted to use a function in the `Country` companion
    object*,* we did not need to explicitly put the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将包名定义为 `country`。现在，无论我们在相应的文件中定义什么，都将保持在 `country` 包的作用域内。这就是为什么当我们想要在
    `Country` 伴生对象中使用一个函数时，我们不需要明确地放置以下内容：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The ending `_` underscore symbol, is Scala's ways of doing a wildcard import.
    It means that non-private members are going to be accessible within the current
    scope.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾的下划线 `_` 符号，是 Scala 实现通配符导入的方式。这意味着非私有成员将在当前作用域内可访问。
- en: Multiple package statements in a file
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件中的多个包声明
- en: 'Scala also allows us to put multiple package declarations and nested package
    declarations. First let''s take a look at how:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 还允许我们放置多个包声明和嵌套包声明。首先让我们看看如何：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding code we see how we can define multiple package statements within
    a file. A thing worth noticing is the way we did this. We used curly parentheses
    along with a `package` keyword to tell the Scala compiler that here's our package.
    Whatever we write inside this is going to reside in that package. Here, we defined
    three packages. One is `country`, to define country-specific constructs, another
    one is `state`, to define state specific constructs. The last one is a `customutil`
    package, which, as the name tells us, is to define utility functions for all the
    country/state functionalities. The `averagePopulation` function is not specific
    to country or state but can be used in both cases, hence it is defined in separate
    packages and imported globally at the top. With that import, we've gotten access
    for `customutil` to the scope of the whole compilation unit. One more thing we
    could have done is to declare package `state` as a nested package to `country`,
    because it's obvious multiple `country` constructs and members should be directly
    accessible to `state` constructs as well. Let's see how it's going to look.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到我们如何在文件中定义多个包声明。值得注意的是我们这样做的方式。我们使用了花括号和`package`关键字来告诉Scala编译器，这里是我们的包。我们在这个包内部写下的任何内容都将属于这个包。在这里，我们定义了三个包。一个是`country`，用于定义特定国家的结构；另一个是`state`，用于定义特定州的结构。最后一个是一个`customutil`包，正如其名称所表明的，它是为了定义所有国家/州功能性的实用函数。`averagePopulation`函数既不特定于国家也不特定于州，因此可以在两种情况下使用，因此它被定义在单独的包中，并在顶部全局导入。有了这个导入，我们就为`customutil`获得了整个编译单元的作用域。我们还可以做的一件事是将包`state`声明为嵌套在`country`中的包，因为很明显，多个`country`结构和成员也应该直接对`state`结构可用。让我们看看它将如何看起来。
- en: Nested package statements
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套包声明
- en: 'We know there might be times when we need some `country` package constructs
    directly available to the `state` package. In those scenarios we can define the
    `state` package as a nested package inside `country`. Let''s write that as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，有时我们可能需要将一些`country`包结构直接提供给`state`包。在这些场景中，我们可以将`state`包定义为`country`内部的嵌套包。让我们这样写：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we have a package `state` declaration nested inside a `country` package
    declaration. What this does is to avoid making explicit mentions to the full package
    declaration while importing. Also, it makes code easier to understand and more
    structured. It shows that it's OK to expect a country to be a `Region`, and a
    state can also be treated as a region. Thus, nesting of packages is also a good
    way to document your code. It shows an understanding of the structure.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包`state`声明嵌套在一个`country`包声明内部。这样做的作用是，在导入时避免明确提及完整的包声明。同时，它使代码更容易理解，结构更清晰。这表明，预期一个国家是`Region`，一个州也可以被视为一个区域是合理的。因此，包的嵌套也是一种很好的代码文档方式。它显示了对于结构的理解。
- en: Chaining package statements
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接包声明
- en: There's another way we can put up these package declarations, and that is by
    chaining the declarations of packages. How can we do this?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过链式声明包来放置这些包声明。我们如何做到这一点？
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: By keeping the `Region` class in the `country` package, if we declare the `State`
    class with the preceding syntax, things will work out fine, and your class `State`
    is going to reside in package `country.state`. That means `state` is going to
    be a nested package. This way of writing package names is widely used in several
    libraries, you may find this out when you explore some of them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Region`类放在`country`包中，如果我们使用前面的语法声明`State`类，一切都会顺利，你的类`State`将位于包`country.state`中。这意味着`state`将是一个嵌套包。这种编写包名的方式在许多库中广泛使用，当你探索其中一些时，你可能会发现这一点。
- en: These are all ways you can declare package names, and now you also know the
    reasoning behind it. Just because of the fact that we have the license to declare
    multiple package names, means it's easier for us to separate constructs based
    on their usage. For example, it's perfectly fine to declare a package for a `TestSuite`
    for your classes in the same file with a different package name. Everyone has
    their ways of writing and structuring package names. With these, declarations,
    we also have more than one way of importing these constructs in other scopes.
    Importing packages in Scala can also be done in some interesting ways; why not
    take a dig at that.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是你可以声明包名的方法，现在你也知道了背后的原因。仅仅因为我们有声明多个包名的许可，这意味着我们更容易根据它们的用途来分离结构。例如，为同一文件中的类声明一个名为`TestSuite`的包是完全可行的。每个人都有自己的编写和结构化包名的方式。有了这些声明，我们也有多种方法在其他作用域中导入这些结构。Scala导入包的方式也很有趣；为什么不深入研究一下。
- en: Importing packages
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入包
- en: 'In simpler scenarios, just to bring some objects into scope, we put an `import`
    statement before it. This is how importing can be done:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在更简单的场景中，为了将一些对象引入作用域，我们在它们之前放置一个`import`语句。这就是导入的方式：
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The result is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We use an `import` keyword and give the name of the import. A few points to
    note down while using `import` in Scala:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`import`关键字并给出导入的名称。在使用Scala中的`import`时，以下几点需要注意：
- en: We are allowed to use imports anywhere in the file
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在文件的任何地方使用导入
- en: In instances where two imports collide, we have the right to hide one over the
    other
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个导入冲突的情况下，我们有权利隐藏一个覆盖另一个
- en: We can also rename some imports
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以重命名一些导入
- en: 'With this, we get flexibility while importing packages. Let''s take a look
    at some of these:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们在导入包时获得了灵活性。让我们看看其中的一些：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding examples, we declared an `import` statement just before we
    wanted to use it. Also, see the following statement:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们是在想要使用它之前声明了一个`import`语句。另外，还可以看看以下语句：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This allowed us to use `u` in place of the `Util` object*:*
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们用`u`代替`Util`对象*：*
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Using these depends on the scenario; most often we need to take care of code
    readability. For example, renaming `scala.collection.mutable` to something shorter
    is a good thing to do—developers following the code are going to find it easier
    to understand. Also, if you take a closer look, we renamed the object `Util`,
    so it''s proven that Scala allows us to import as well as rename objects. Moreover,
    Scala is capable enough of renaming the function names, and why not? Those are
    members that we are importing. We did just that in the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些（方法）取决于场景；大多数情况下，我们需要注意代码的可读性。例如，将`scala.collection.mutable`重命名为更短的名字是一个很好的做法——跟随代码的开发者会发现这更容易理解。此外，如果你仔细观察，我们发现重命名了对象`Util`，这证明了Scala允许我们导入并重命名对象。此外，Scala足够强大，可以重命名函数名，为什么不呢？这些都是我们正在导入的成员。我们就在下面的例子中这样做了：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We renamed the `averagePopulation` function to `ap`*,* and used that in the
    following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`averagePopulation`函数重命名为`ap`*，并在以下内容中使用它：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We may need to keep in mind the same point: we may be renaming whenever it
    makes sense to do so—in our example, it doesn''t. But for demonstration purposes,
    it''s OK to consider that it does. Scala''s extensive ways for packaging and importing
    makes things easier for us. In namespace collision scenarios, we''ve ways to hide
    a definition over the other. That can be done with the following syntax:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要记住同一个点：我们可能在有意义的任何时候重命名——在我们的例子中，它并不适用。但为了演示的目的，考虑它是可以的。Scala广泛的打包和导入方式使我们更容易处理。在命名空间冲突场景中，我们有方法隐藏一个定义覆盖另一个。这可以通过以下语法完成：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You see? The declaration is self-explanatory. We renamed a particular package/member
    to a wildcard. It no longer provides any means to using this particular `Member`
    in the current scope and hides it. This is Scala's way of hiding a particular
    package/member.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你看？声明是自我解释的。我们将一个特定的包/成员重命名为通配符。它不再提供在当前作用域中使用这个特定的`Member`的任何手段，并隐藏了它。这是Scala隐藏特定包/成员的方式。
- en: These multiple ways of packaging and importing make our code easy to understand,
    but this is not all. We can also provide a few modifiers to control access to
    our members. We can make them `private`, `protected`, or by default `public`.
    Let's discuss them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多种打包和导入方式使我们的代码易于理解，但这还不是全部。我们还可以提供一些修饰符来控制成员的访问权限。我们可以将它们设置为`private`、`protected`，或者默认为`public`。让我们来讨论它们。
- en: Visibility rules
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见性规则
- en: 'There are times when we don''t want to let another class or similar construct
    use a few members. Here, we can use Scala''s provided access modifiers. How we
    achieve control over the accessibility of members of our classes/traits/objects
    is through `private`, `public`, or `protected` access modifiers. Take a look at
    the following example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不想让另一个类或类似的结构使用一些成员。在这里，我们可以使用 Scala 提供的访问修饰符。我们通过 `private`、`public` 或
    `protected` 访问修饰符来控制我们类/特质/对象的成员的可访问性。看看以下例子：
- en: '[PRE74]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here, we have some trait named `Kitchen`. It has a secret way of cooking a
    really tasty dish, but only for `PrivateRestaurant` types. The secret cannot be
    shared outside the kitchen. In those scenarios, we can keep the secret as it is
    by declaring it with a modifier named `private`. With this, when we try to access
    the secret recipe, we are not able to do that. The Scala compiler gives an error
    stating: *Symbol secret is inaccessible from this place.* With that we were able
    to keep our secret intact. But what if you want to let your private restaurant
    access the secret and no one else. In that case you can make it `protected`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为 `Kitchen` 的特性。它有一种秘密的方法来烹饪一道非常美味的菜肴，但仅限于 `PrivateRestaurant` 类型。这个秘密不能在厨房外分享。在这些情况下，我们可以通过使用名为
    `private` 的修饰符来保持秘密不变。有了这个，当我们尝试访问秘密食谱时，我们无法做到。Scala 编译器会显示一个错误，指出：*符号 `secret`
    在此处不可访问*。这样我们就能保持我们的秘密完好无损。但如果你想让你的私人餐厅访问这个秘密，而其他人则不行。在这种情况下，你可以将其设置为 `protected`。
- en: 'After making our secret protected, we can get access to it only if `PrivateRestaurant`
    extends `Kitchen`. If you remember, this is doing composition and thus we''ll
    have access to the secret by just changing the `private` modifier to `protected`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的秘密设置为受保护之后，我们只能通过 `PrivateRestaurant` 扩展 `Kitchen` 来访问它。如果你记得，这是在执行组合，因此我们只需将
    `private` 修饰符更改为 `protected` 就可以访问秘密：
- en: '[PRE75]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We should know, for `protected` to work, it''s a must to inherit the member
    class/trait. What we mean by this is the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该知道，为了使 `protected` 起作用，必须继承成员类/特质。我们这里的意思是以下内容：
- en: '[PRE76]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As you can see, we have this mix-in. That''s the reason why, after applying
    the `protected` modifier, we got access to the secret recipe. By the way, when
    we don''t specify any access modifiers, Scala treats the members as `public` and
    those members can be accessed if in scope. When it comes to controlling the access
    levels, Scala has more to offer than what we just learnt. We can also specify
    the scope of protection. By scope of protection we mean that the particular member
    is visible up to a certain level. Here, it depends on us what level we define.
    Let''s look at an example to understand this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们有一个这样的混合。这就是为什么在应用了 `protected` 修饰符之后，我们能够访问秘密食谱的原因。顺便说一句，当我们没有指定任何访问修饰符时，Scala
    会将成员视为 `public`，并且如果成员在作用域内，则可以访问。当涉及到控制访问级别时，Scala 提供的比我们刚刚学到的更多。我们还可以指定保护的范围。通过保护范围，我们指的是特定的成员在某个级别上是可见的。在这里，我们定义什么级别取决于我们。让我们通过一个例子来理解这一点：
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'With a proper look at the code, there are some points that we can consider:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码进行适当的审查，有一些要点我们可以考虑：
- en: 'In the following declaration, it makes it clear that the secret value is going
    to be privately accessible within this package named `privaterestaurant`:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下声明中，它清楚地表明秘密值将在这个名为 `privaterestaurant` 的包内私下访问：
- en: '[PRE78]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Also, the Scala compiler is not going to complain about the way you used these
    scopes, but at runtime you can expect an exception if your scope is not within
    the package. It means that for our following declaration:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，Scala 编译器不会对您使用这些范围的方式提出异议，但如果你在运行时期望的范围不在包内，你可以预期会抛出异常。这意味着对于我们的以下声明：
- en: '[PRE79]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: For it to work properly, we need to be part of this package. That's logically
    correct, otherwise it's not wise to apply privacy to something that's not ours.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确工作，我们需要是这个包的一部分。这是逻辑上正确的，否则对不属于我们的东西应用隐私是不明智的。
- en: Similar to `private[X]`, we can also define `protected[Y]` and so on. Defining
    `protected` for some package is going to make it available to classes in the inheritance
    tree.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `private[X]` 类似，我们也可以定义 `protected[Y]` 等。为某个包定义 `protected` 将使其对继承树中的类可用。
- en: There's another level of protection, that is, `private[this]`. It's going to
    make a particular member available to an instance of the same class.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有另一个级别的保护，那就是 `private[this]`。这将使特定的成员对同一类的实例可用。
- en: It's really important to control the access level. With it we can have fine-grain
    scope for every construct. This keeps the client away from unnecessary details
    that you might not want them to access. This is all about limiting the scope for
    members. There are a few more construct such as `sealedtraits`, that help us structure
    the code in a good way, but that's just one thing about them. There's much more
    to know about.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 控制访问级别非常重要。有了它，我们可以为每个结构提供精细的粒度范围。这使客户端远离你可能不希望他们访问的不必要细节。这完全是关于限制成员的访问范围。还有一些其他结构，如
    `sealedtraits`，有助于我们以良好的方式组织代码，但这只是它们的一个方面。还有更多需要了解的内容。
- en: Sealed traits
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密封特质
- en: 'One good thing about **sealed traits** is that standard Scala library uses
    these constructs a lot, and you''ve also seen them many times so far. It''s time
    to learn about them. We''ll start with an example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **密封特质** 的一个好处是，标准的 Scala 库大量使用了这些结构，你到目前为止也已经看到过很多次了。是时候学习它们了。我们将从一个例子开始：
- en: '[PRE80]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The result is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE81]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we defined a sealed trait named `Season`. Then there're a few child season
    case objects extending from the `sealed trait Season`. By the way, case objects
    are like `case` classes with the difference being that these are only instances
    with already available names, unlike the `case` classes. There're a few points
    to note about the preceding implementation of the sealed trait named `Season`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `Season` 的密封特质。然后，有几个从 `sealed trait Season` 继承的子季节案例对象。顺便说一下，案例对象类似于
    `case` 类，不同之处在于这些对象只有已经可用的名称，而 `case` 类则不同。关于名为 `Season` 的密封特质的先前实现，有几个要点需要注意。
- en: All children extending the `Season` trait should be defined in the same file.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有扩展 `Season` 特质的子类都应该定义在同一个文件中。
- en: Constructs such as sealed traits come with a license to perform pattern matching.
    This is good for design constructs.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像密封特质这样的结构允许我们进行模式匹配。这对设计结构很有好处。
- en: Also, when we perform *pattern matching* on sealed traits, we need to take care
    of all the possibilities. Otherwise, as we know, the Scala compiler is intelligent
    enough to come up with a warning about the remaining scenarios whenever it sees
    that the pattern match is on a sealed trait.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，当我们对密封特质进行模式匹配时，我们需要注意所有可能性。否则，正如我们所知，Scala 编译器足够智能，会在看到模式匹配是在密封特质上时，对剩余场景发出警告。
- en: A few good and known examples of sealed traits are `Option` type to two children
    named `Some` and `None`. Then, `List` is also defined as a sealed trait. This
    was a short introduction to sealed traits with the license for you to experiment
    with the construct. With sealed traits we have come to the end of the chapter.
    Let's summarize what we have learnt so far.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一些好的和已知的密封特质示例包括 `Option` 类型到两个名为 `Some` 和 `None` 的子类。然后，`List` 也是一个密封特质。这是对密封特质的简要介绍，并允许你实验这个结构。有了密封特质，我们就结束了这一章。让我们总结一下到目前为止我们学到了什么。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was more exciting. We learnt about inheritance in Scala and discussed
    composition and inheritance. It's really going to help us when we take design
    decisions about our implementation. Then we learnt about this amazing construct
    named traits and we tried various ways of using traits. Then we learnt about the
    concept of linearization which it helped us understand how super calls are resolved.
    Then we talked about packaging and importing which was exciting as Scala provides
    different ways to use them. Finally, we learnt about *visibility rules* and *sealed
    traits*. And after going through all these concepts, we can say with confidence
    that we now understand the object-oriented concepts in Scala. So, it's time for
    us to do some real functional programming. In the next few chapters our focus
    will be on using functions in Scala.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章非常有趣。我们学习了 Scala 中的继承，并讨论了组合和继承。这真的有助于我们在实现设计决策时做出选择。然后我们学习了名为特质的这个惊人的结构，并尝试了各种使用特质的方法。然后我们学习了线性化的概念，这有助于我们理解超调用是如何解决的。然后我们讨论了打包和导入，这在
    Scala 中提供了不同的使用方式，非常有趣。最后，我们学习了 *可见性规则* 和 *密封特质*。在了解了所有这些概念之后，我们可以自信地说，我们现在已经理解了
    Scala 中的面向对象概念。所以，是我们做一些真正的函数式编程的时候了。在接下来的几章中，我们的重点将放在 Scala 中的函数使用上。
