- en: RESTful APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful APIs
- en: In this chapter, we will learn about the basics of REST and how to use Postman
    and Spring for accessing and writing REST APIs. Lastly, we will build an app with
    a REST interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 REST 的基础知识以及如何使用 Postman 和 Spring 访问和编写 REST API。最后，我们将构建一个具有 REST
    接口的应用程序。
- en: Postman is a GUI-driven app for interacting with HTTP APIs by constructing requests
    and reading responses.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是一个通过构建请求和读取响应与 HTTP API 交互的图形界面应用程序。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Explain the fundamentals of REST
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 REST 的基本原理
- en: Utilize Postman to access both public and personal REST APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Postman 访问公共和个人 REST API
- en: Utilize Spring for writing REST APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring 编写 REST API
- en: Build an app with a REST interface, based on the blogmania app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于blogmania应用程序构建具有 REST 接口的应用程序
- en: What is a RESTful API?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 RESTful API？
- en: An **Application Programming Interface** (**API**) is an access point to a software
    meant for machines (or other software products) rather than people. It has become
    kind of a buzzword lately, even though the concept has been there for decades.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）是面向机器（或其他软件产品）而不是人的软件的访问点。最近它成了一种流行语，尽管这个概念已经存在了几十年。'
- en: APIs, and more specifically (and more recently) REST APIs, are the backbone
    of communication services. They are what modern distributed cloud-based applications
    work through. They are also the way that modern browser user interfaces communicate
    with their backend services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: API，尤其是（和最近）REST API，是通信服务的骨干。它们是现代分布式云应用程序工作的基础。它们也是现代浏览器用户界面与其后端服务通信的方式。
- en: 'For communication services, there are different styles of API. What kinds can
    you come up with? Examples include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通信服务，存在不同的 API 风格。你能想到哪些？以下是一些例子：
- en: RPC
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC
- en: SOAP
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP
- en: REST
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST
- en: REST – Formal Definition
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST – 正式定义
- en: The acronym **REST** stands for **REpresentational State Transfer**. The term
    was coined in the influential work *Architectural Styles and the Design of Network-Based
    Software Architectures*, (University of California, Irvine, 2000) by Roy Fielding.
    As this was his doctoral dissertation, few people have actually read it, and it
    is far beyond the scope of a Spring Boot book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写 **REST** 代表 **REpresentational State Transfer**。这个术语是在Roy Fielding的具有影响力的作品《*Architectural
    Styles and the Design of Network-Based Software Architectures*》（加州大学欧文分校，2000年）中提出的。由于这是他的博士论文，实际上很少有人真正阅读过它，而且它远远超出了Spring
    Boot书籍的范围。
- en: Fielding's original work can be viewed online at [https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Fielding 的原始作品可在网上查看：[https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
- en: for your reference.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 供您参考。
- en: For a more hands-on view, similar to what we will take in this book, you may
    go to [https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer](https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer)
    instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更实际的观点，类似于本书中我们将要采取的方法，你可以访问 [https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer](https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer)。
- en: The RESTful API – Practitioner's Definition
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API – 实践者定义
- en: 'For a programmer, a slightly relaxed set of rules is sufficient for daily work.
    On the other hand, we use some fixed defaults where the REST architecture allows
    different choices:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，一套稍微宽松的规则就足够日常工作了。另一方面，我们在 REST 架构允许不同选择的地方使用一些固定的默认值：
- en: HTTP calls using all the verbs—Calls in RESTful APIs are done using the well-known
    HTTP protocol. This allows us to use all the infrastructure of the web, such as
    load balancers or caches. In addition to GET and POST calls, a RESTful API also
    uses `PUT` and `DELETE`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所有动词的 HTTP 调用——RESTful API 中的调用是通过众所周知的 HTTP 协议完成的。这使我们能够使用所有网络基础设施，如负载均衡器或缓存。除了
    GET 和 POST 调用外，RESTful API 还使用 `PUT` 和 `DELETE`。
- en: Pass options in the URL or in headers—It is customary to put real data in the
    body of requests, but only options that influence the search or the requested
    representation of the response in URL parameters or even HTTP headers.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 URL 或头信息中传递选项——通常将真实数据放在请求体中，但只有影响搜索或响应请求表示的选项会放在 URL 参数或甚至 HTTP 头中。
- en: Answer status as HTTP status code—HTTP offers a wide range of response codes.
    On the WWW, you mostly see only 200 (OK) and 404 (Not Found), but there are codes
    to signify that the request was in a bad format or that a new entity was created.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应状态作为HTTP状态码——HTTP提供了广泛的各种响应码。在WWW上，你通常只看到200（OK）和404（未找到），但有一些代码表示请求格式不正确或创建了新的实体。
- en: Request and answer payload in JSON format—JSON is the de facto standard these
    days. This excludes, of course, binary data such as images, which are transmitted
    as is.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和响应有效载荷以JSON格式——JSON现在是事实上的标准。当然，这排除了像图像这样的二进制数据，它们以原样传输。
- en: Showing the Yes/No API in Postman
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Postman中展示Yes/No API
- en: 'When starting Postman for the first time, you must get past two dialogs: the
    first prompts you to register, but there is a link to take you to the app without
    registering. The second creates a collection of queries, and Postman requires
    at least one such collection, even if you do not intend to save your queries at
    all.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次启动Postman时，你必须通过两个对话框：第一个提示你注册，但有一个链接可以带你去应用而无需注册。第二个创建一个查询集合，Postman至少需要一个这样的集合，即使你根本不打算保存你的查询。
- en: Once inside the main window, enter [https://yesno.wtf/api](https://yesno.wtf/api)
    into the field for the URL. In front of this field, there is a dropdown for the
    HTTP method; leave it at GET. After pressing the Enter key (or the Send button),
    the request is performed, and you can see the response status (which should be
    200 OK) and the response body in JSON format.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入主窗口，将[https://yesno.wtf/api](https://yesno.wtf/api)输入到URL字段中。在这个字段前面有一个HTTP方法的下拉菜单；保持它为GET。按下Enter键（或发送按钮）后，请求将被执行，你可以看到响应状态（应该是200
    OK）和以JSON格式显示的响应体。
- en: 'The response body contains a field called `answer` which is either yes or no.
    For fun, you can click and follow the link to the image:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体包含一个名为`answer`的字段，其值为是或否。为了好玩，你可以点击并跟随链接到图片：
- en: '![](img/2ee6d8f8-3067-4123-a0e3-02c1d7192b2d.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ee6d8f8-3067-4123-a0e3-02c1d7192b2d.png)'
- en: REST Guiding Principles
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST指导原则
- en: Now that you have seen a REST call in action, let's revisit some guiding principles
    that a good REST API should follow in more detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了REST调用的实际操作，让我们更详细地回顾一下一个好的REST API应该遵循的一些指导原则。
- en: A web browser can navigate to any kind of website. Just like this, a REST client
    should be able to navigate to a REST API. (Of course, in practice, this is limited
    by the intelligence of the machine.) This means that, ideally, all you need for
    an API is the starting point, and then all navigation only follows links that
    were embedded in a previous response. This principle is called **hypertext** or
    **hypermedia** - and, yes, that is the `HT` part in both **HTML** (**Hypertext
    Markup Language**) and **HTTP** (**Hypertext Transfer Protocol**).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器可以导航到任何类型的网站。就像这样，REST客户端应该能够导航到REST API。（当然，在实践中，这受限于机器的智能。）这意味着，理想情况下，你需要的只是一个API的起点，然后所有导航都只遵循先前响应中嵌入的链接。这个原则被称为**超文本**或**超媒体**——是的，**HTML**（**超文本标记语言**）和**HTTP**（**超文本传输协议**）中的`HT`部分都是这个意思。
- en: The second principle is to make proper use of the HTTP verbs. There are quite
    a few of them, some rather technical and only concerned with the protocol itself,
    others for very special purposes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原则是正确使用HTTP动词。它们有很多，其中一些相当技术性，只与协议本身有关，而另一些则用于非常特殊的目的。
- en: REST Resource Examples
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST资源示例
- en: 'Take a look at the following table that highlights the main methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下表格，它突出了主要方法：
- en: '![](img/599068f3-d67e-43db-9879-2db79e781491.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/599068f3-d67e-43db-9879-2db79e781491.png)'
- en: 'The third principle is to use resources instead of remote procedure calls.
    This becomes very apparent when it comes to the naming of endpoints: endpoints
    are not verbs (after all, that is what the HTTP verbs are for), but they are nouns.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个原则是使用资源而不是远程过程调用。当涉及到端点的命名时，这一点变得非常明显：端点不是动词（毕竟，HTTP动词就是为此而设计的），而是名词。
- en: 'To visualize the lifecycle of a resource, take a look at the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化资源的生命周期，请看以下图表：
- en: '![](img/1617a1d2-688e-4fc4-8f5a-4282fc32e844.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1617a1d2-688e-4fc4-8f5a-4282fc32e844.png)'
- en: Utilizing SWAPI
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用SWAPI
- en: The aim is to view a good REST API in action. We'll be exploring or testing
    an existing API. Unfortunately, in the beginning, this will be a read-only API,
    so we will only see GET requests. The API we are using here is **SWAPI**, the
    **Star Wars API**. It is a REST API that allows you to browse planets, spaceships,
    vehicles, people, films, and species of the Star Wars universe. This API is public
    and not access-controlled.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是查看一个良好的REST API在实际中的应用。我们将探索或测试一个现有的API。不幸的是，一开始，这将是一个只读API，所以我们只会看到GET请求。我们在这里使用的API是**SWAPI**，**星球大战API**。这是一个允许你浏览星球大战宇宙中的行星、宇宙飞船、车辆、人物、电影和物种的REST
    API。这个API是公开的，不受访问控制。
- en: Before beginning, you should open Postman. If your Postman app is freshly installed,
    you can tell it that you do not want to register at the first prompt. At the second,
    you have to create a collection (any name is fine, although **Default** may just
    be a good choice here). You are presented with the main window. Depending on the
    size of the window, the request history may or may not be displayed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你应该打开Postman。如果你的Postman应用是新安装的，你可以告诉它你不想在第一次提示时注册。在第二次，你必须创建一个集合（任何名字都可以，尽管**默认**可能是一个不错的选择）。你会看到主窗口。根据窗口的大小，请求历史可能显示或不显示。
- en: 'The steps for completion are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤如下：
- en: 'Go to the entry URL of SWAPI: [https://swapi.co/api/](https://swapi.co/api/).'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往SWAPI的入口URL：[https://swapi.co/api/](https://swapi.co/api/).
- en: 'You will see as an answer a set of links to other resources: a resource for
    people, a resource for planets, and so on. Follow the resource for people.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到一个指向其他资源的链接集合：一个用于人物的资源，一个用于行星的资源，等等。跟随人物的资源。
- en: 'In *step 2*, you get a not only people answer, since you accessed a collection
    resource. There are two things to take note of here: first, it is not a list containing
    all the people, but only the first ten, with a link to the next ten (if applicable,
    you may get a link to the previous ten as well). Second, each entry has a link
    to itself, not only an ID that could be used to construct such a link.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，你得到的不只是一个人物的答案，因为你访问了一个集合资源。这里有两点需要注意：首先，它不是一个包含所有人物的列表，而只有前十个，还有一个链接指向下一个十个（如果适用，你可能会得到一个指向前十个的链接）。其次，每个条目都有一个指向自身的链接，而不仅仅是一个可以用来构造这种链接的ID。
- en: Follow the link for Luke.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Luke的链接。
- en: 'The result of *step 3*, however, is a single entry: a resource that ends with
    an ID:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*步骤3*的结果是一个单独的条目：一个以ID结尾的资源：
- en: '![](img/a2075a66-361e-4534-943b-a85a908a5c48.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2075a66-361e-4534-943b-a85a908a5c48.png)'
- en: 'Have a look in the **Headers** area of the response and find the **Content-Type**
    header to confirm that the server sent JSON:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在响应的**头部**区域查看，找到**Content-Type**头部以确认服务器发送了JSON：
- en: '![](img/99369fbb-bd37-4699-ba4a-45ea977eb350.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99369fbb-bd37-4699-ba4a-45ea977eb350.png)'
- en: Back in the Body area, you can choose to view the raw answer of the server instead
    of the pretty-printed version that Postman presents to us.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Body”区域，你可以选择查看服务器的原始答案，而不是Postman向我们展示的格式化版本。
- en: 'Now, do some research: what is Luke''s homeworld?'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，做一些研究：Luke的家乡在哪里？
- en: You may find that Luke's homeworld is Tatooine, but the important thing to note
    here is that you can follow the links and explore the data just as you would on
    a traditional web page in a browser.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现Luke的家乡是塔图因，但这里要注意的重要事情是，你可以像在浏览器中的传统网页上一样跟随链接和探索数据。
- en: All of the source code for this chapter, including some Postman collections
    in JSON format to be imported in Postman, can be found at [https://bit.ly/2QxGni4](https://bit.ly/2QxGni4)
     in the accompanying GitHub repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码，包括一些可以导入到Postman中的JSON格式的Postman集合，可以在配套的GitHub仓库中找到：[https://bit.ly/2QxGni4](https://bit.ly/2QxGni4)。
- en: 'Take a look at the following Postman screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的Postman截图：
- en: '![](img/957ece56-981f-4513-ad9e-9573070f2a45.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/957ece56-981f-4513-ad9e-9573070f2a45.png)'
- en: REST Controllers in Spring
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的REST控制器
- en: Now that we have recapped what REST APIs are, you probably want to know how
    to use them with Spring. You will see that you already know most of what you need
    for this. The key is in the little enhancements that Spring provides.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经回顾了REST API是什么，你可能想知道如何使用Spring来操作它们。你会发现你已经知道大部分你需要的东西了。关键是Spring提供的那些小增强功能。
- en: What makes a REST Controller Different?
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么使REST控制器与众不同？
- en: You have seen many controller functions in the preceding chapters. Spring is
    enormously flexible in the signatures that controller functions are allowed to
    have, both in the parameters they take and the results they return; but in most
    cases, the return value of such a controller function is not the actual response
    sent to the browser, but a view name that is then resolved against static content
    or a view rendered by a template engine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前面的章节中已经看到了许多控制器函数。Spring 在控制器函数的签名方面非常灵活，无论是它们接受的参数还是返回的结果；但在大多数情况下，这种控制器函数的返回值并不是实际发送到浏览器的响应，而是一个视图名称，然后这个名称会被解析为静态内容或由模板引擎渲染的视图。
- en: 'For a REST controller, this is different— we want to return data instead. We
    can do this directly or by using an implicit mapper, as you will see. You have
    already seen in *[Chapter 4](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml): The
    MVC Pattern, in the Additional Annotations and Parameters for Handler*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 REST 控制器来说，这有所不同——我们希望返回数据。我们可以直接这样做，或者使用隐式映射器，正如你将要看到的。你已经在 *[第 4 章](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml)：MVC
    模式，在处理器的附加注解和参数*] 中看到了。
- en: '*Methods* section how to return data instead of the view name from a controller—The
    controller needs to be annotated with `@ResponseBody`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法* 部分如何从控制器返回数据而不是视图名称——控制器需要使用 `@ResponseBody` 注解。'
- en: Actually, that's all you need to know for REST controllers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是你需要了解的关于 REST 控制器的一切。
- en: The rest of this section will show you how to implement all the REST-guiding
    principles that we introduced previously. These advanced elements are not REST-specific
    and can sometimes become useful in a normal Spring MVC context, but they are indispensable
    for implementing REST controllers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将向你展示如何实现我们之前介绍的所有 REST 指导原则。这些高级元素并非 REST 特有的，有时在正常的 Spring MVC 上下文中也可能很有用，但它们对于实现
    REST 控制器是必不可少的。
- en: '"Response Body" in Detail'
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “响应体”详细说明
- en: In this section, we will look at short code excerpts to bring the main concepts
    to you step by step. More complete code that is an extension to the blog application
    (from the previous chapter) will come a bit later.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过逐步展示代码片段来介绍主要概念。更完整的代码，作为前一章博客应用的扩展（将在稍后提供）。
- en: 'Let''s consider the following piece of code, which is a complete Spring controller
    class in Java (lacking only the imports):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码片段，这是一个完整的 Spring 控制器类（仅缺少导入部分）：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that the `@Controller` annotation also marks this class as a Spring
    component that will be found in the `classpath` scanning. The `@RequestMapping`
    annotation marks a method as a method to map to a certain path, given here as
    its argument. Finally, the `@ResponseBody` annotation lets Spring return the literal
    data of the method's return value instead of mapping it using a view name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`@Controller` 注解也将这个类标记为 Spring 组件，它将在 `classpath` 扫描中找到。`@RequestMapping`
    注解将一个方法标记为映射到特定路径的方法，这里以它的参数给出。最后，`@ResponseBody` 注解让 Spring 返回方法的返回值的实际数据，而不是使用视图名称进行映射。
- en: 'Now, what will the outcome be? You can actually follow that link in your web
    browser or in Postman, but for this document, we will use a notation that looks
    like the HTTP communication on the wire, with only some details left off. If you
    are interested, you can look at this for yourself by using telnet, but mostly
    it is very convenient for showing both the client''s request and the server''s
    response:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果会是什么？你实际上可以在你的网络浏览器或 Postman 中跟随那个链接，但为了这份文档，我们将使用一种类似于网络上的 HTTP 通信的符号，只是省略了一些细节。如果你感兴趣，你可以通过使用
    telnet 自己查看这些内容，但通常这非常方便地展示了客户端的请求和服务器端的响应：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the String return value of our method is also the data that
    the server sends out. Spring filled out some response headers automatically—it
    set the Content-Length to `8` (this is measured in bytes), and it set the Content-Type
    (also known as the MIME type or media type) of the response to plain text in UTF-8
    encoding. (Encoding is a misnamed charset in many contexts.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们方法返回的字符串值也是服务器发送出的数据。Spring 自动填充了一些响应头——它将 Content-Length 设置为 `8`（这是以字节为单位的），并将响应的
    Content-Type（也称为 MIME 类型或媒体类型）设置为 UTF-8 编码的纯文本。（在许多情况下，编码是一个误命名的 charset。）
- en: Of course, producing text instead of HTML is good, but the standard format for
    data exchange in REST controllers these days is JSON, so let's make the controller
    return this.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，输出文本而不是 HTML 是好的，但如今 REST 控制器中数据交换的标准格式是 JSON，所以让我们让控制器返回这个格式。
- en: Returning JSON Manually
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动返回 JSON
- en: 'Let''s try the straightforward way first. Take a look at the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试直接的方法。看看以下代码：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The only thing that changed here is the returned string. It now contains JSON,
    with a log of backslashes to encode the necessary double quotes within a Java
    string. The result of the request, then, is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一改变的是返回的字符串。它现在包含JSON，其中包含用于在Java字符串中编码必要双引号的反斜杠日志。因此，请求的结果如下：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are a few things to criticize here. The first thing is that the JSON is
    cumbersome to write. Java makes this very hard because the embedded double quotes
    need to be escaped. JSON may be a reasonably easy format, but, still, particularly
    for bigger data structures than the one returned here, creating it by hand is
    error-prone.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以批评的地方。首先，JSON的编写很繁琐。Java使得这一点非常困难，因为嵌入的双引号需要转义。JSON可能是一个相对容易的格式，但仍然，尤其是对于比这里返回的大得多的数据结构，手动创建它是容易出错的。
- en: Second, and more importantly, the content type is still set to plain text! Some
    clients may ignore the Content-Type header anyway and just expect JSON to be returned,
    and those clients will work with our faulty server. Well-behaved clients, however,
    will not recognize it as JSON. They may accept it as text (albeit weird text)
    or altogether reject it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，更重要的是，内容类型仍然设置为纯文本！一些客户端可能无论如何都会忽略内容类型（Content-Type）头，并期望返回JSON，这些客户端将能够与我们的有缺陷的服务器一起工作。然而，行为良好的客户端将不会将其识别为JSON。他们可能会将其接受为文本（尽管是奇怪的文本）或者完全拒绝它。
- en: Postman, for instance, honors the Content-Type header. By default, it will show
    the output of a call to this controller as plain text. You may, however, choose
    JSON by hand, thereby overriding the detected Content-Type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Postman会尊重内容类型（Content-Type）头。默认情况下，它将显示对控制器调用的输出为纯文本。然而，你可以手动选择JSON，从而覆盖检测到的内容类型。
- en: In rare circumstances, this might be a quick hack to satisfy some required interface,
    but surely we can do much better!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，这可能是为了满足某些接口要求而快速修补的一种方法，但肯定我们可以做得更好！
- en: Manual JSON, Correct Content-Type
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动JSON，正确的内容类型
- en: 'The main problem with the preceding code is that it created an incorrect HTTP
    response for what we intended:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的主要问题在于它为我们打算的HTTP响应创建了一个不正确的响应：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What changed here in this code excerpt is only the `@RequestMapping` line. We
    add a second parameter that produces the annotation, which then gives the value
    of the Content-Type HTTP header. Actually, it's not the verbatim header, as you'll
    see in a moment; also, repeating such a value may lead to subtle errors, and you
    will see a better alternative later on. The path parameter is the same as the
    implicit value parameter that was used before when we only had one argument for
    the annotation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中发生变化的只有 `@RequestMapping` 行。我们添加了一个第二个参数来生成注解，然后它给出了内容类型HTTP头的值。实际上，它不是字面意义上的头，正如你一会儿会看到的；此外，重复这样的值可能会导致微妙的错误，你将在稍后看到更好的替代方案。路径参数与之前我们只有一个参数时使用的隐式值参数相同。
- en: 'The outcome of this controller has improved greatly:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器的结果有了很大的改进：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We get the same Content-Length here and in fact the same payload, but the Content-Type
    header is now pointing to JSON as we wanted! Notice how Spring added the encoding
    on its own. Now, Postman will, by default, show this as JSON.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们得到了相同的内容长度，实际上相同的有效载荷，但内容类型（Content-Type）头现在指向了JSON，正如我们想要的！注意Spring是如何自动添加编码的。现在，Postman默认会将其显示为JSON。
- en: 'Once more, we will go through a demo, using Postman to access a REST resource,
    but this time accessing our own application instead of something from the internet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将通过Postman访问REST资源进行演示，但这次访问的是我们自己的应用程序而不是互联网上的东西：
- en: 'Use the "rest-intro" project provided on GitHub, and start the `RestIntroApplication`
    class within it: navigate to the class and then either press *Ctrl-Shift-F10*
    or click on any of the green triangles in the gutter of the editor.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub上提供的 "rest-intro" 项目，并在其中启动 `RestIntroApplication` 类：导航到该类，然后按 *Ctrl-Shift-F10*
    或点击编辑器侧边栏中的任何绿色三角形。
- en: 'Start Postman. You should import the Postman collections that are available
    on GitHub, so that you can easily use the pre-defined queries. The "REST-Intro"
    collection contains the requests needed here. Execute the queries `greeting/string`,
    `greeting/fakeJson` and `greeting/manualJson`:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动Postman。你应该导入GitHub上可用的Postman集合，这样你就可以轻松地使用预定义的查询。 "REST-Intro" 集合包含了这里需要的请求。执行查询
    `greeting/string`、`greeting/fakeJson` 和 `greeting/manualJson`：
- en: Show both the **Body** and the **Headers** panes. The first query will return
    a proper string, the second one returns a hybrid (a string that looks like JSON),
    and the third will return a proper JSON.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示**主体**和**标题**窗格。第一个查询将返回一个合适的字符串，第二个返回一个混合体（看起来像JSON的字符串），第三个将返回一个合适的JSON。
- en: 'The other drawback remains: hand-written JSON is probably not what we want.
    Though slightly more complicated in these toy examples, the following sections
    will show you how to deal with JSON in real life.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个缺点是：手动编写的JSON可能不是我们想要的。虽然在这些玩具示例中稍微复杂一些，但以下章节将向你展示如何在现实生活中处理JSON。
- en: Mapping Data to JSON
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据映射到JSON
- en: 'To conclude this section on simple REST controllers, these two methods will
    return proper JSON, but you will see nothing of that in the code as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节关于简单REST控制器的内容，这两个方法将返回合适的JSON，但你不会在下面的代码中看到任何东西：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Wow! That was easy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这很简单。
- en: Both variants produce exactly the same outcome (except for the text itself,
    that is). It is also the same as in the preceding code, only that for non-string
    return values, Spring does not automatically add the Content-Length header. This
    is a bit unfortunate, but since most clients do not make much use of it, it is
    generally acceptable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种变体产生的是完全相同的结果（除了文本本身）。这也与前面的代码相同，只是对于非字符串返回值，Spring不会自动添加Content-Length头。这有点不幸，但鉴于大多数客户端很少使用它，通常是可以接受的。
- en: What happened here? Upon finding a complex return type, Spring will look for
    an `HttpMessageConverter` bean in the application context and relay processing
    to it. A very good library for converting between Java objects and JSON is *Jackson*
    by *FasterXML* (you can find the project homepage at [https://github.com/ FasterXML/jackson](https://github.com/FasterXML/jackson)).
    Spring comes with a specific `HttpMessageConverter` implementation called `MappingJackson2HttpMessageConverter`,
    which uses Jackson for the job.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？当发现一个复杂的返回类型时，Spring会在应用上下文中查找`HttpMessageConverter` bean并将其处理任务转交给它。一个在Java对象和JSON之间转换的非常好的库是*FasterXML*的*Jackson*（你可以在[https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)找到项目主页）。Spring自带一个特定的`HttpMessageConverter`实现，称为`MappingJackson2HttpMessageConverter`，它使用Jackson来完成这项工作。
- en: 'All you have to do to use this implementation is nothing at all. The `spring-boot-starter-
    web` dependency that we use for this Spring MVC project already depends on `spring-boot-starter-json`
    that, in turn, depends on Jackson. Now, Spring''s magic kicks in: when Jackson
    is found in the Java `classpath` upon startup, then all the necessary Beans are
    created automatically. This way, returning JSON just works - out of the box!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个实现，你什么都不用做。我们用于这个Spring MVC项目的`spring-boot-starter-web`依赖项已经依赖于`spring-boot-starter-json`，而它反过来又依赖于Jackson。现在，Spring的魔法开始发挥作用：当启动时在Java
    `classpath`中找到Jackson，那么所有必要的Beans都会自动创建。这样，返回JSON就自然而然地成功了！
- en: 'The only question that remains is whether you would prefer to create specialized
    Java classes for all different kinds of JSON payloads that you expect, or whether
    you would rather go with (nested) maps. One is more type-safe; one is more flexible;
    the choice is up to you. Throughout this book, we are giving preference to sections
    of Java that are easy enough to create with Project Lombok, which was introduced
    in *[Chapter 1](9c691a93-c936-4976-b836-8ec08d62bffb.xhtml): The Spring Project
    and Framework*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一问题是，你更愿意为所有不同类型的JSON有效负载创建专门的Java类，还是更愿意选择（嵌套）映射。一个是更类型安全的；另一个更灵活；选择权在你。在这本书中，我们更倾向于使用Project
    Lombok创建的Java部分，这是在*[第1章](9c691a93-c936-4976-b836-8ec08d62bffb.xhtml)：Spring项目和框架*中引入的。
- en: REST Controllers in Spring
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的REST控制器
- en: To wrap it up, please remind yourself that most of the annotations that were
    mentioned can not only go on a method, but also on the class level. The semantics
    are then that those annotations are for all methods in the class,
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，请记住，大多数提到的注解不仅可以放在方法上，还可以放在类级别。其语义是，这些注解适用于类中的所有方法，
- en: Some annotations serve as defaults for all methods. They count if they are not
    overwritten on the method. An example of this would be `@RequestBody`, which turns
    all methods in a class that are also annotated as mapped into REST endpoints.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些注解作为所有方法的默认值。如果它们没有被方法覆盖，它们就有效。一个例子是`@RequestBody`，它将类中所有也注解为映射到REST端点的所有方法转换为方法。
- en: Some annotations are additive. The `@RequestMapping` annotation is one of those.
    It does not turn each method into an endpoint, but it gives a common path prefix
    for all methods that are also endpoints. In an extreme scenario, these methods
    do not need to specify any path if they only differ in the produced MIME type
    or the HTTP method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些注解是可添加的。`@RequestMapping` 注解就是其中之一。它不会将每个方法转换为端点，但它为所有也是端点的方法提供了一个公共路径前缀。在极端情况下，如果这些方法仅在产生的
    MIME 类型或 HTTP 方法上有所不同，则它们不需要指定任何路径。
- en: The combination of `@Controller` and a class-level `@RequestBody` annotation
    is so common and useful for REST controllers that there is a specialized annotation
    just for this case, and it is, rather unsurprisingly, called `@RestController`.
    It is this annotation that will be used throughout this book.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Controller` 和类级别的 `@RequestBody` 注解的组合对于 REST 控制器来说非常常见且非常有用，因此有一个专门的注解专门用于这种情况，它并不令人意外地被称为
    `@RestController`。这本书将使用这个注解。'
- en: Implementing REST Endpoints
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现REST端点
- en: 'The aim is to implement your first REST endpoint by returning JSON. You have
    an existing application that needs another endpoint. The project is completely
    set up, so adding a single class is enough. Before beginning, open the rest-intro
    project in IntelliJ and make sure that you can start the `RestIntroApplication`. The
    steps for completion are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是通过返回 JSON 实现你的第一个 REST 端点。你有一个现有的应用程序需要另一个端点。项目已经完全设置，因此添加一个类就足够了。在开始之前，请打开
    IntelliJ 中的 rest-intro 项目，并确保你可以启动 `RestIntroApplication`。完成步骤如下：
- en: Add a new class – you may call it `DateTimeController`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新类——你可以称它为 `DateTimeController`。
- en: Annotate it with `@RestController`. Use auto-completion or *Ctrl+Space* in IntelliJ
    to complete the annotation and add the import.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@RestController` 注解它。使用 IntelliJ 的自动完成或 *Ctrl+Space* 完成注解并添加导入。
- en: Add a new inner static class called `DateTime` with some String fields such
    as date and time. Add the appropriate getters and constructor. Lombok will be
    very helpful here.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `DateTime` 的新内部静态类，其中包含一些字符串字段，如日期和时间。添加适当的获取器和构造函数。Lombok 在这里将非常有帮助。
- en: Add a new method that returns an instance of the new data class. It does not
    need any arguments.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个返回新数据类实例的新方法。它不需要任何参数。
- en: Annotate the method with `@GetMapping` and make it react to some path, for instance,
    to `/api/datetime`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@GetMapping` 注解方法，使其响应某些路径，例如 `/api/datetime`。
- en: 'Extract the current time and date, put them into a new instance of `DateTime`,
    and return that. You can use the following code snippet:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取当前时间和日期，将它们放入一个新的 `DateTime` 实例中，并返回该实例。你可以使用以下代码片段：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Re-run the program and access your new resource with Postman.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行程序，并使用 Postman 访问您的新资源。
- en: 'The answer will, of course, depend on your local time and date, but it will
    be JSON (application/json) format and look something along the lines of:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 答案当然将取决于你的本地时间和日期，但它将是 JSON（application/json）格式，大致如下：
- en: '**{"date":"1989-11-09","time":"19:01:30.123","zone":"Central European Time
    (CET)","zoneId":"Europe/Berlin","zoneOffset":"+01:00"}**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**{"date":"1989-11-09","time":"19:01:30.123","zone":"Central European Time
    (CET)","zoneId":"Europe/Berlin","zoneOffset":"+01:00"}**'
- en: You can find a possible solution that also returns the time zone in the GitHub
    repository by going to [https://bit.ly/2qABGIY](https://bit.ly/2qABGIY). Go
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 [https://bit.ly/2qABGIY](https://bit.ly/2qABGIY) 并进入 GitHub 仓库，找到返回时区的一个可能的解决方案。走
- en: to [https://bit.ly/2xaeSlT](https://bit.ly/2xaeSlT) to access the complete code
    for the `RestIntroApplicationTests.java` file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到 [https://bit.ly/2xaeSlT](https://bit.ly/2xaeSlT) 访问 `RestIntroApplicationTests.java`
    文件的完整代码。
- en: Content Types
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容类型
- en: We already saw Content-Types in the preceding responses.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的响应中看到了内容类型。
- en: All content has some type (or many, mixed). Humans are good at reading and understanding
    content by just looking at it, but computers work best if they are told beforehand
    what to expect. For that purpose, and originally as an extension to the internet
    mail standard, RFC 2046 specifies Media Types (formerly known as MIME types).
    A list of agreed-upon Media Types is coordinated by the IANA.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内容都有某种类型（或多种，混合）。人类擅长通过观察内容本身来阅读和理解内容，但计算机如果事先被告知预期内容，则工作效果最佳。为此目的，并且最初作为互联网邮件标准的扩展，RFC
    2046 规定了媒体类型（以前称为 MIME 类型）。一组协议的媒体类型由 IANA 协调。
- en: 'Refer to the following resources for the standards:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下资源以获取标准：
- en: 'RFC 2046: [https://tools.ietf.org/html/rfc2046](https://tools.ietf.org/html/rfc2046).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'RFC 2046: [https://tools.ietf.org/html/rfc2046](https://tools.ietf.org/html/rfc2046).'
- en: 'IANA: [http://www.iana.org/assignments/media-types/mediatypes.xhtml](http://www.iana.org/assignments/media-types/mediatypes.xhtml).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'IANA: [http://www.iana.org/assignments/media-types/mediatypes.xhtml](http://www.iana.org/assignments/media-types/mediatypes.xhtml)。'
- en: 'The content types most interesting in the web application context are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序上下文中最有趣的内容类型如下：
- en: text/html when HTML pages are returned to the browser
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将 HTML 页面返回到浏览器时使用 text/html
- en: text/css, text/javascript, and image/jpeg for the content linked in web pages
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: text/css、text/javascript 和 image/jpeg 用于网页中链接的内容
- en: text/plain as a fallback for plain text
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: text/plain 作为纯文本的回退
- en: application/x-www-form-urlencoded as the default format, where the browser sends
    data entered in a form to the browser
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认格式为 application/x-www-form-urlencoded，其中浏览器将表单中输入的数据发送到浏览器
- en: application/json for AJAX calls
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX 调用使用 application/json
- en: 'The HTTP protocol has two headers that deal with content types:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 协议有两个处理内容类型的标题：
- en: '`Accept` in the *request* to specify what is accepted as a result. This can
    be a list of accepted types ('
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *request* 中使用 `Accept` 来指定接受的结果。这可以是一个接受类型的列表 (
- en: or the header can be repeated), and it can contain wildcards and weights to
    specify preferences.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者标题可以重复），并且它可以包含通配符和权重来指定偏好。
- en: This header has companions such as Accept-Charset and Accept-Language that are
    of lesser interest, meaning that you will not be concerned with them generally.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此标题有如 Accept-Charset 和 Accept-Language 等伴随者，它们不太重要，这意味着您通常不会关心它们。
- en: '`Content-Type` in the *response* to specify what the actual result is. This
    header has similar companions to the Accept header.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *response* 中使用 `Content-Type` 来指定实际的结果是什么。此标题具有与 Accept 标题相似的伴随者。
- en: Producing Different Content Types
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成不同的内容类型
- en: You already saw that the produced content type may change when you return different
    things from your controller, and that you can also influence the content type
    manually.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，当您从控制器返回不同内容时，产生的内容类型可能会改变，并且您也可以手动影响内容类型。
- en: An important principle of REST is that we use the HTTP protocol to its full
    extent, using the right HTTP methods (or verbs), but also leave content negotiation
    and caching to the protocol and the intermediary nodes. Therefore, you shall never
    have two resources called `/api/customers.json` and `/api/customers.xml` if you
    need the same logical resource in two different formats.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: REST 的重要原则之一是我们充分利用 HTTP 协议，使用正确的 HTTP 方法（或动词），同时也将内容协商和缓存留给协议和中间节点。因此，如果您需要在两种不同格式中具有相同的逻辑资源，则不应有两个名为
    `/api/customers.json` 和 `/api/customers.xml` 的资源。
- en: Spring, by the way, allows just that if you configure it that way, but this
    will not be shown here on purpose. It used to be the default in previous versions,
    but is now deprecated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，Spring 允许这样做，如果您这样配置它，但这里故意不展示。它曾是旧版本的默认设置，但现在已弃用。
- en: 'The following code seems to specify the same resource twice:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码似乎指定了同一资源两次：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note how the path to the resource is only specified at the class level. The
    two functions only provide GET endpoints, and they do differ— one of them returns
    a String that will be sent to the client as plain text, and the other one returns
    a complex object that will be turned into JSON by the mapper. You have already
    seen the produces option; it is still of String type, but this time, we use predefined
    constants in the `MediaType` class to avoid duplication.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意资源路径仅在类级别指定。这两个函数仅提供 GET 端点，并且它们确实不同——其中一个返回一个将被发送到客户端的纯文本字符串，而另一个返回一个将被映射器转换为
    JSON 的复杂对象。您已经看到了 produces 选项；它仍然是 String 类型，但这次我们使用 `MediaType` 类中的预定义常量来避免重复。
- en: 'These two endpoints will react to different requests:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个端点将对不同的请求做出反应：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Both requests go to the same resource, but with different Accept headers. As
    you can see, Spring, by default, added the charset, which is UTF-8 in this case,
    to the response. That way, the client is able to understand the encoding of the
    response body. Currently, Spring controllers will return the JSON if no Accept
    header is given, but you should not rely on such behavior.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 两个请求都指向同一资源，但具有不同的 Accept 标题。如您所见，Spring 默认添加了字符集，在这种情况下是 UTF-8，到响应中。这样，客户端就能理解响应体的编码。目前，如果未提供
    Accept 标题，Spring 控制器将返回 JSON，但您不应依赖于这种行为。
- en: All that was needed was the differing product options. The method names are
    ignored by Spring, and they are different only to avoid a name clash, and also
    to document our intention.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的只是不同的产品选项。Spring 会忽略方法名称，它们的不同只是为了避免名称冲突，并且也是为了记录我们的意图。
- en: 'The content negotiation, and later the dispatch to one of our functions, is
    done by the `DispatcherServlet`, which you already heard about in *[Chapter 4](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml):
    The MVC Pattern*. If no method can provide the requested (or **accepted**) `Content-Type`,
    then the HTTP status **406 Not Acceptable** is issued to the client.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 内容协商以及后续将请求分派到我们的函数之一是由`DispatcherServlet`完成的，您已经在*[第4章](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml)：MVC模式*中听说过。如果没有方法可以提供请求的（或**接受的**）`Content-Type`，则向客户端发出HTTP状态**406不可接受**。
- en: Responding with XML to the Rest-intro Application
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Rest-intro应用程序响应XML
- en: 'The aim is to demonstrate responding with XML to the rest-intro application.
    The steps for completion are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是展示对rest-intro应用程序响应XML。完成步骤如下：
- en: Start the `RestIntroApplication` in the rest-intro project.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在rest-intro项目中启动`RestIntroApplication`。
- en: Use Postman to call the resources and show that they indeed return text and
    JSON, respectively.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman调用资源，并展示它们确实分别返回文本和JSON。
- en: 'You can use the provided Postman collection **Content-Types** for that. Also,
    try to request XML: Postman will show you an HTTP response status of **406 Not
    Acceptable**. This was to be expected since we did not provide an endpoint for
    that representation.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用提供的Postman集合**Content-Types**进行操作。此外，尝试请求XML：Postman将显示HTTP响应状态**406不可接受**。这是预期的，因为我们没有提供该表示形式的端点。
- en: Note that the application's log remains quite quiet about this in the default
    settings. Also, note that you can request many other unsupported types, but if
    you should request text/html, then alongside the 406 status code, you actually
    do get a bit of HTML showing the error, and you can also view that in the **Preview**
    pane.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在默认设置下，应用程序的日志对此相当安静。此外，注意您还可以请求许多其他不受支持的类型，但如果您请求text/html，那么除了406状态码之外，您实际上还会得到一些显示错误的HTML，您也可以在**预览**窗格中查看它。
- en: 'Now, add the ability to return XML to the resource! You need to add a new method
    to `ContentTypeController`, which is basically a copy of `greetJson()`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向资源添加返回XML的能力！您需要向`ContentTypeController`添加一个新方法，这基本上是`greetJson()`的副本：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you were to run the application with debug logging, you would see that Spring
    tries to use this new method when you request XML, but fails later on because
    there is no message converter. To add one, all we need is Jackson XML on the classpath,
    and the rest will be wired automatically. Add the following dependency to the
    POM:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以调试日志运行应用程序，您会看到当您请求XML时，Spring会尝试使用这个新方法，但后来失败了，因为没有消息转换器。要添加一个，我们只需要在类路径上添加Jackson
    XML，其余的将自动连接。将以下依赖项添加到POM中：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, run the application and demonstrate that we also respond with XML.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并展示我们也响应XML。
- en: 'Similar to the JSON data structure that you know, the answer will now be this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与您所知的JSON数据结构类似，答案现在将是这样的：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Go to [https://bit.ly/2Abj4Vb](https://bit.ly/2Abj4Vb) to access the complete
    code for the `RestIntroApplication.java` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://bit.ly/2Abj4Vb](https://bit.ly/2Abj4Vb)访问`RestIntroApplication.java`文件的完整代码。
- en: Job Aid
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作辅助
- en: You could also just add a second media type to the existing `greetJson()`, but
    then the contained text would be the same, of course. In general, though, you
    do not want to send different data when different Content-Types are requested.
    You only want to send different representations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以仅仅向现有的`greetJson()`方法添加第二种媒体类型，但当然，包含的文本将是相同的。不过，通常情况下，您不希望在请求不同的`Content-Type`时发送不同的数据。您只想发送不同的表示形式。
- en: You can add as many media types to a handler method as you want.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向处理程序方法添加任意多的媒体类型。
- en: You can also choose not to add any media type at all, as Spring will try to
    find the best matching handler method that can produce the requested `Content-Type`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择完全不添加任何媒体类型，因为Spring会尝试找到可以生成请求的`Content-Type`的最佳匹配处理程序方法。
- en: Consuming Different Content Types
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费不同的内容类型
- en: JSON is by far the most common data exchange format for REST services today.
    However, it used to be XML. Some flexibility in accepting different formats may
    mean more clients are able to connect to your service.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是目前REST服务中最常见的数据交换格式。然而，它曾经是XML。接受不同格式的灵活性可能意味着更多的客户端能够连接到您的服务。
- en: Another thing to consider is that web applications can only send JSON with the
    help of JavaScript. However, a simple HTML form can also issue a POST, but it
    cannot send JSON. The default format has the `Content-Type application/x-www-form-urlencoded`,
    which is basically a simple string of key/value pairs. If our server can accept
    this, it can react to actions from a form (you saw this earlier in this chapter).
    This format may even be preferable in other contexts, since it will not need preflight
    requests.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的事情是，Web 应用程序只能借助 JavaScript 发送 JSON。然而，简单的 HTML 表单也可以发出 POST 请求，但不能发送
    JSON。默认格式具有 `Content-Type application/x-www-form-urlencoded`，这基本上是一系列键/值对。如果我们的服务器可以接受这种格式，它可以对表单操作做出反应（你在这个章节的早期已经看到了）。这种格式在其他上下文中可能甚至更可取，因为它不需要预检请求。
- en: See [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
    for a discussion of Cross-Origin Resource Sharing. In particular, note that "simple
    requests" do not need preflight, which is an additional request the client would
    issue to find out allowed methods. Such a simple request may only have a `Content-Type
    of application/xwww-form-urlencoded`, and not JSON. Avoiding preflight requests
    may speed up a client application considerably on networks with high latency.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于跨源资源共享的讨论，请参阅 [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。特别是要注意，“简单请求”不需要预检，这是一个客户端会发出以确定允许方法的额外请求。这样的简单请求可能只有
    `Content-Type of application/xwww-form-urlencoded`，而不是 JSON。避免预检请求可能会在延迟较高的网络上显著加快客户端应用程序的速度。
- en: 'Let''s see this in code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码来看一下：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Go to [https://bit.ly/2pVBBz7](https://bit.ly/2pVBBz7) to access the complete
    code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 访问完整代码，请前往 [https://bit.ly/2pVBBz7](https://bit.ly/2pVBBz7)。
- en: 'The mappings use the same endpoint as before, but now utilize the POST method
    instead. This makes the dispatch possible. The result of calling these is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 映射使用与之前相同的端点，但现在使用 POST 方法，这使得分发成为可能。调用这些方法的结果如下：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is (almost) as easy as putting the consumes option on the mapping annotation.
    For historical reasons, however, form values are handled a bit differently than
    JSON. For JSON and other formats with a mapper (XML, for instance), we use the
    `@RequestBody` annotation on the Java method's formal parameter. This illustrates
    quite well that the value for the actual parameter is to be taken from the request
    body.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这（几乎）与在映射注解上放置 consumes 选项一样简单。然而，由于历史原因，表单值与 JSON 的处理方式略有不同。对于 JSON 和其他具有映射器（例如
    XML）的格式，我们在 Java 方法的形式参数上使用 `@RequestBody` 注解。这很好地说明了实际参数的值应从请求体中获取。
- en: For form encoding, each of the expected form values is passed on its own to
    a parameter that is annotated with `@RequestParameter` (which is mapped by the
    name of the formal parameter, if not overridden). Note that this is the same annotation
    that we would use to extract URL parameters. In fact, a method that does not have
    a consumes option on the mapping, but `@RequestParameter` annotations will be
    able to take the values both from form-encoded values in the request body and
    from URL parameters.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表单编码，每个预期的表单值都单独传递给一个带有 `@RequestParameter` 注解的参数（如果没有覆盖，则通过形式参数的名称映射）。请注意，这与我们用于提取
    URL 参数的相同注解。实际上，一个没有在映射上设置 consumes 选项但具有 `@RequestParameter` 注解的方法将能够从请求体的表单编码值和
    URL 参数中获取值。
- en: For GET requests, it is not portable to have a request body. The HTTP specification
    does not require anybody handling for GET, and intermediate proxies and clients
    may strip the body if one is sent. Therefore, GET mappings cannot consume anything.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GET 请求，携带请求体是不可移植的。HTTP 规范不要求对 GET 进行处理，并且中间代理和客户端可能会在发送时删除体。因此，GET 映射不能消费任何内容。
- en: The only reliable way to pass values to a GET request is via URL parameters
    such as in `/api/greeting?addressee=John`. This is done using the `@RequestParam`
    annotation and, in code, looks the same as accepting a form with POST.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 向 GET 请求传递值的唯一可靠方式是通过 URL 参数，例如 `/api/greeting?addressee=John`。这是通过使用 `@RequestParam`
    注解来完成的，在代码中看起来与接受 POST 表单相同。
- en: HTTP Status Code and Important Headers
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 状态码和重要头信息
- en: 'Up until now, we only cared for the body of the response (and the content-type,
    since it is so closely linked). HTTP, however, has two more very important channels
    to convey information back to the client: These are the status code and a number
    of further HTTP headers.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关心响应体（以及内容类型，因为它与之紧密相关）。然而，HTTP还有两个非常重要的渠道将信息传达回客户端：这些就是状态码和一系列进一步的HTTP标头。
- en: 'A status code comes with every response from the server. It is a quick way
    to triage the success of the query, even before looking into the content. The
    status codes fall into five categories, the important ones in our context being
    the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个响应都伴随着一个状态码。这是一个快速判断查询成功与否的方法，甚至在查看内容之前。状态码分为五类，在我们这个环境中重要的是以下这些：
- en: 'The 2xx range: Everything went well.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2xx范围：一切顺利。
- en: 'The 4xx range: The request was faulty.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4xx范围：请求有误。
- en: 'The 5xx range: The server had a problem that is not the client''s responsibility.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5xx范围：服务器出现了不是客户端责任的问题。
- en: For the full list of return codes, consult external resources such as RFC 7231\.
    Of course, there is no need to use all of them, but choosing wisely can enhance
    the meaningfulness of your API.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回码的完整列表，请参考外部资源，如RFC 7231。当然，没有必要使用它们全部，但明智地选择可以增强你API的意义。
- en: 'You have already seen some status codes, and we will see some more throughout
    this book:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些状态码，我们将在整本书中看到更多：
- en: '![](img/5c0bf73b-139d-424c-a525-b07b52f65fe0.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c0bf73b-139d-424c-a525-b07b52f65fe0.png)'
- en: 'Headers are too numerous to even scrape the surface here, but the ones you
    will see here are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 标头太多，甚至无法触及表面，但这里你会看到以下内容：
- en: Content-Type
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Content-Type
- en: Location (with 201 code (see the previous table) or 3xx codes) to point to the
    real location.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置（使用201代码（见前表）或3xx代码）指向实际位置。
- en: Allow (with 405 code (see the previous table) and for `OPTION` requests) to
    list allowed request methods.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许（使用405代码（见前表）和`OPTION`请求）列出允许的请求方法。
- en: Cache-Control and ETag (and others) for controlling how content should be cached
    and when to update the values in the caches.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cache-Control和ETag（以及其他）用于控制内容应该如何缓存以及何时更新缓存中的值。
- en: Finally, headers starting with X-… are commonly used for various application-specific
    purposes.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，以X-…开头的标头通常用于各种特定于应用程序的目的。
- en: You can read more about RFC 7231 at [https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)了解更多关于RFC
    7231的信息。
- en: 'In a nutshell, the HTTP status is as per the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，HTTP状态码如下：
- en: 1XX – Hold on
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1XX – 等一下
- en: 2XX – Here you go
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2XX – 这里是
- en: 3XX – Look elsewhere
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3XX – 去别处看看
- en: 4XX – You messed up
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4XX – 你搞砸了
- en: 5XX – I messed up
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5XX – 我搞砸了
- en: Declarative Status Code
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式状态码
- en: 'The simplest way to control the response status code is to simply declare it
    using the `@ResponseStatus` annotation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 控制响应状态码的最简单方法就是简单地使用`@ResponseStatus`注解声明它：
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is no useful information to be sent back from the PUT request, so the
    method returns void and carries an annotation to return **204 No Content**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从PUT请求中返回没有有用的信息，因此该方法返回void并带有返回**204 No Content**的注释。
- en: This is the easiest case, and especially useful to get you started. When your
    demands grow, you may need more fine-grained control and have to influence the
    response programmatically.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最容易的情况，特别有助于你开始。当你的需求增长时，你可能需要更精细的控制，并必须程序化地影响响应。
- en: Programmatic Status Code
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序化状态码
- en: If the status code is always the same, unconditionally, what's the point of
    setting it anyway? Most of the time, the return values depend somehow on the input,
    or on the state of the overall system. If that is the case, we can only decide
    on which answer to send after checking some conditions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态码始终相同，无条件地设置它有什么意义呢？大多数时候，返回值以某种方式依赖于输入或整个系统的状态。如果是这种情况，我们只能在检查了一些条件之后才能决定发送哪个答案。
- en: The key here is to make use of a response entity, that is, a data object wrapping
    both the returned data and the all the metadata for the HTTP response. Consequently,
    Spring offers a parameterized type called `ResponseEntity<T>`, where T is the
    data that we want to be sent as JSON. This class comes with a number of static
    functions wherein each creates a response entity builder to add more information
    step by step.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是利用响应实体，即包装返回数据和 HTTP 响应所有元数据的数据对象。因此，Spring 提供了一个参数化类型 `ResponseEntity<T>`，其中
    T 是我们想要以 JSON 格式发送的数据。这个类提供了一系列静态函数，每个函数都创建一个响应实体构建器，逐步添加更多信息。
- en: 'Consider the following code fragment:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Go to [https://bit.ly/2xeqODe](https://bit.ly/2xeqODe) to access the complete
    code for this section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://bit.ly/2xeqODe](https://bit.ly/2xeqODe) 访问本节完整的代码。
- en: The resource `/api/mottos` is a REST collection resource. With POST, new messages
    can be posted to the list of mottos. We do not want a motto to appear twice, so
    the method checks for uniqueness and has two different paths to create a return
    value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 资源 `/api/mottos` 是一个 REST 集合资源。使用 POST，可以将新消息发布到格言列表中。我们不希望格言重复出现，因此该方法检查唯一性，并有两个不同的路径来创建返回值。
- en: If the motto already exists, a new builder (actually called `BodyBuilder`, a
    name that may make you smile a bit, even though it is perfectly reasonable) is
    created with the `static status()` method of the `ResponseEntity` class. It takes
    as its sole argument the required response status. To actually build the response
    with an empty body, `build()` is called.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果格言已经存在，将使用 `ResponseEntity` 类的 `static status()` 方法创建一个新的构建器（实际上称为 `BodyBuilder`，这个名字可能会让你微微一笑，尽管它完全合理）。它只接受一个参数，即所需响应状态。为了实际构建具有空体的响应，调用
    `build()`。
- en: Otherwise, the `ok()` method is used to create the builder; this is a shortcut
    for a very common status code, and `status()` could have been used as well. This
    time, a body of the correct type is sent along as well. The `body()` function
    can be used once at most and will immediately build the result.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，使用 `ok()` 方法创建构建器；这是一个非常常见状态码的快捷方式，也可以使用 `status()`。这次，还发送了正确类型的正文。`body()`
    函数最多只能使用一次，并将立即构建结果。
- en: The `uniqueAppend()` method had `ResponseEntity<Message>` as its return type.
    But, if you look closely, it is almost like cheating, because a message was only
    sent in one of the two branches. It just so happens that an empty body is compatible
    with every generic type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniqueAppend()` 方法返回类型为 `ResponseEntity<Message>`。但如果你仔细观察，这几乎像是作弊，因为消息只在一组两个分支中的一个被发送。碰巧的是，空体与每个泛型类型都是兼容的。'
- en: Spring is enormously flexible in the signatures it accepts for handler mapping
    functions (go to the Spring documentation under [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods)
    to verify this claim). The dispatch is done at runtime.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 在接受处理映射函数的签名方面非常灵活（请转到 Spring 文档中的 [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods)
    以验证这一说法）。分发是在运行时完成的。
- en: We hit a Java restriction here. We cannot return either a message or a specific
    error object from the same function and stay within the type system. You will
    see one way to circumvent this for most applications (error handling). If you
    really must return different types from one method, you may declare it as returning
    `ResponseEntity<?>` (a practice that static code checkers will likely criticize)
    or even `Object`. You will lose the type checking of the compiler, so be sure
    to write proper unit tests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们遇到了 Java 的限制。我们不能从同一个函数中返回消息或特定的错误对象，同时保持在类型系统中。你将看到一种绕过这个限制的方法（适用于大多数错误处理应用）。如果你确实必须从一个方法中返回不同的类型，你可以将其声明为返回
    `ResponseEntity<?>`（静态代码检查器可能会批评这种做法）或甚至 `Object`。你将失去编译器的类型检查，所以请确保编写适当的单元测试。
- en: Global Error Handling
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局错误处理
- en: The error handling in each method may be quite similar and repetitive. It is
    often the same for all methods. It may also bury the main intention of the method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法中的错误处理可能非常相似且重复。对于所有方法来说，这通常是相同的。它也可能隐藏了方法的主要意图。
- en: Cross-cutting concerns such as these are often handled by aspects, and Spring
    uses quite a number of these. However, global error handling is provided through
    a different mechanism here, which is called an **exception handler**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些跨领域关注点通常由方面（aspects）来处理，Spring使用了相当多的这些方面。然而，在这里，全局错误处理是通过不同的机制提供的，这被称为**异常处理器**。
- en: A method annotated with `@ExceptionHandler` can handle exceptions for many handler
    mappers within the same controller (or, using `@ControllerAdvice`, more globally,
    which will be explained a bit later).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用`@ExceptionHandler`注解的方法可以处理同一控制器（或，使用`@ControllerAdvice`，更全局地，这将在稍后解释）内的多个处理器映射的异常。
- en: A JavaScript Evaluator
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript评估器
- en: 'Let''s implement a controller that has more than one possible cause for problems,
    and do so without cluttering the business logic:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个控制器，它有多个可能的问题原因，并且在不使业务逻辑混乱的情况下实现它：
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Go to [https://bit.ly/2x9HZWM](https://bit.ly/2x9HZWM) to access the complete
    code for this section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://bit.ly/2x9HZWM](https://bit.ly/2x9HZWM)访问本节完整的代码。
- en: The controller accepts a JavaScript expression as a parameter and returns the
    result as a JSON wrapped message. It contains a bit of argument checking before
    feeding the parameter straight into the built-in JavaScript interpreter. Note
    that you do not want to do this outside a protected environment because of security
    implications, but it is fine as an example.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器接受一个JavaScript表达式作为参数，并将结果作为JSON封装的消息返回。在将参数直接输入内置的JavaScript解释器之前，它包含一些参数检查。请注意，由于安全影响，你不想在受保护的环境之外做这件事，但作为一个例子，这是可以的。
- en: Now, what could possibly go wrong?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可能会出什么问题呢？
- en: One thing is the `IllegalArgumentException` that we throw ourselves, and the
    other is the checked `ScriptException` and another unchecked `ParserException`
    that Nashorn may throw. The error handling that we have in place right now only
    replaces one exception with a more informative one. The exceptions will escape
    our handler mapping. What will Spring do about it? The answer is that, by default,
    it will generate a rather helpful error object and a response status code of **500
    Internal Server Error**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面是我们自己抛出的`IllegalArgumentException`，另一方面是Nashorn可能抛出的已检查的`ScriptException`和另一个未检查的`ParserException`。我们现在实施的错误处理只将一个异常替换为一个更具有信息量的异常。异常将逃逸出我们的处理器映射。Spring将如何处理这个问题？答案是，默认情况下，它将生成一个相当有用的错误对象和一个响应状态码为**500内部服务器错误**。
- en: 'That is not quite satisfying, since the error really was on the client''s side,
    and we should properly signal that to the client. To handle the two exceptions,
    we add two error handlers to the class:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全令人满意，因为错误实际上是在客户端，我们应该正确地向客户端发出信号。为了处理这两个异常，我们在类中添加了两个错误处理器：
- en: '[PRE18]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `handleArgument()` method handles the `IllegalArgumentException`, while
    `handleParse()` handles the two Nashorn exceptions. The exception argument is
    entirely optional and can have any compatible type. Again, the signatures are
    very flexible, and we could choose to return a `ResponseEntity<>` for a specialized
    error object instead.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleArgument()`方法处理`IllegalArgumentException`，而`handleParse()`处理两个Nashorn异常。异常参数完全是可选的，可以具有任何兼容类型。再次强调，签名非常灵活，我们可以选择返回一个`ResponseEntity<>`以获取一个专门的错误对象。'
- en: Advising Many Controllers at Once
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时建议多个控制器
- en: '**Advices**, in Spring MVC, are methods that declare certain aspects of handler
    functions. There are three of such advices in Spring, two of which are out of
    the scope of this introductory book (but you have seen the second briefly in Chapter
    4):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**建议**（Advices），在Spring MVC中，是声明处理器函数某些方面的方法。Spring中有三种这样的建议，其中两种超出了这本入门书的范围（但你已经在第四章中简要地看到了第二种）：'
- en: '`@InitBinder` — to configure automatic conversion from primitive parameters
    to custom domain objects.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@InitBinder` — 用于配置从原始参数到自定义域对象的自动转换。'
- en: '`@ModelAttribute` — to control common attributes in the controllers model (such
    as data).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ModelAttribute` — 用于控制控制器模型中的常见属性（如数据）。'
- en: '`@ExceptionHandler` — to convert thrown exceptions to proper responses.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ExceptionHandler` — 用于将抛出的异常转换为适当的响应。'
- en: All of these are scoped to the controller that they were defined in.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在它们被定义的控制器范围内。
- en: Sometimes, we want a more global approach. For that, we need to define a Spring
    Bean annotated with `@ControllerAdvice`. When we do not need view resolution on
    our exception handlers, but message conversion on the response bodies instead,
    we can either put `@ResponseBody` in the appropriate places or simply use the
    `@RestControllerAdvice` annotation on the advising class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望采用更全局的方法。为此，我们需要定义一个带有 `@ControllerAdvice` 注解的 Spring Bean。当我们不需要在异常处理器上进行视图解析，而是需要在响应体上进行消息转换时，我们可以在适当的位置放置
    `@ResponseBody`，或者简单地在建议类上使用 `@RestControllerAdvice` 注解。
- en: 'Such a controller advice annotation is global for all controllers by default.
    To narrow it down, there are several options to the annotation to limit the scope
    to certain packages or even to specific annotations. One very useful example would
    be as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此类控制器建议注解对所有控制器都是全局的。为了缩小范围，有几种选项可以限制注解的范围到某些包，甚至到特定的注解。一个非常有用的例子如下：
- en: '[PRE19]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Controlling Headers
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制头部
- en: To polish the responses, we may want to control the response headers. The builder
    we get from the static functions in `ResponseEntity` is actually an extension
    of a `HeaderBuilder`, so we can build both headers and a body with it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使响应更加完美，我们可能想要控制响应头部。我们从 `ResponseEntity` 中的静态函数获得的构建器实际上是 `HeaderBuilder`
    的扩展，因此我们可以用它来构建头部和正文。
- en: 'In the most basic form, we can use the `header()` method on this builder. For
    some common headers, specialized methods exist. Look at these examples:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式中，我们可以使用此构建器上的 `header()` 方法。对于一些常见的头部，存在专门的函数。看看以下示例：
- en: '[PRE20]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: GET requests can profit greatly from caching. For that to work, the server needs
    to know how long to cache values. Alternatively, sometimes also in conjunction,
    the client may send along with the request some data from which the server can
    determine whether the content has changed in the meantime. Without going into
    the details here, the preceding code adds the Cache-Control and the ETag headers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: GET 请求可以从缓存中受益很大。为了使其工作，服务器需要知道缓存值的时长。或者，有时客户端也可能在请求中发送一些数据，服务器可以根据这些数据确定内容在此期间是否已更改。不深入细节，前面的代码添加了
    Cache-Control 和 ETag 头部。
- en: Instead of the normative RFCs, you may want to read the excellent documentation
    on the Mozilla Development Network (for instance, on ETag at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag))
    when you want to know more about HTTP.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与规范性的 RFC 相比，当您想了解更多关于 HTTP 的信息时，您可能想阅读 Mozilla 开发网络上的优秀文档（例如，关于 ETag 的 [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)）。
- en: As stated earlier, when posting to a list resource, the new entity will be assigned
    a new ID that the client cannot know. To relay that information back to the client,
    we set the Location header with a URL pointing to the newly created entity. Spring
    supports this by the argument to the `created()` function.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在向列表资源发送请求时，新实体将分配一个新的 ID，客户端无法知道。为了将此信息传达给客户端，我们设置 Location 头部，其中包含指向新创建实体的
    URL。Spring 通过 `created()` 函数的参数支持这一点。
- en: Finally, as an example, we set the X-Copyright header. Headers starting with
    X-… are not standardized and can be used for application-specific purposes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为一个例子，我们设置了 X-Copyright 头部。以 X-… 开头的头部没有标准化，可以用于特定应用程序的目的。
- en: Returning Different Status Codes
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回不同的状态码
- en: A code review asks you not to throw exceptions that you can easily avoid, so
    you should alter the code for `retrieveById()` to check its argument. (This is
    a fictional scenario where the style you find in the controller is quite acceptable,
    but remains a matter of taste.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查要求您不要抛出可以轻松避免的异常，因此您应该修改 `retrieveById()` 的代码以检查其参数。（这是一个虚构的场景，其中您在控制器中找到的风格相当可接受，但仍然是一个品味问题。）
- en: 'The aim is to use different strategies for returning different status codes. As
    we did previously before beginning, open the rest-intro project. Navigate to the
    `MottoController` and notice that it is, in fact, a bit more useful that shown
    previously in this script: it also has an implementation for GET that uses an
    `@ExceptionHandler` to return a **404 Not Found** message. The steps for completion
    are as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是使用不同的策略来返回不同的状态码。正如我们在开始之前所做的那样，打开 rest-intro 项目。导航到 `MottoController` 并注意，实际上它比脚本中之前展示的更有用：它还有一个使用
    `@ExceptionHandler` 返回 **404 Not Found** 消息的 GET 实现方式。完成步骤如下：
- en: Change the return value of `retrieveById()` to `ResponseEntity<Message>`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`retrieveById()`的返回值更改为`ResponseEntity<Message>`。
- en: Add a condition to check whether the ID is within the range of accepted indexes
    (using `id < 1 || id > motto.size()`).
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个条件来检查ID是否在接受的索引范围内（使用`id < 1 || id > motto.size()`）。
- en: For the out-of-bounds case, return a `ResponseEntity` with HTTP status **404
    Not Found**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于超出范围的用例，返回一个带有HTTP状态**404 Not Found**的`ResponseEntity`。
- en: For the within-bounds case, return a `ResponseEntity` with HTTP status 200 OK
    and the correct motto.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在范围内的用例，返回一个带有HTTP状态200 OK和正确格言的`ResponseEntity`。
- en: Finally, you can remove the `@ExceptionHandler` that is now superfluous.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以移除现在多余的`@ExceptionHandler`。
- en: Check with Postman that the endpoint still reacts in the same way.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman检查端点是否仍然以相同的方式反应。
- en: The observed behavior of the program has not changed, but we are using an alternative
    way to achieve the result.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 程序观察到的行为没有改变，但我们正在使用一种替代方式来实现结果。
- en: You may use `ResponseEntity.ok()` to create the response entity builder and
    then add the body, or just put the body into the `ok()` invocation as a shortcut.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`ResponseEntity.ok()`来创建响应实体构建器，然后添加正文，或者直接将正文放入`ok()`调用中作为快捷方式。
- en: 'You may use either `ResponseEntity.notFound()` or `ResponseEntity.status(HttpStatus.NOT_FOUND)`
    to create the response entity builder. However, while the second alternative returns
    a proper `BodyBuilder`, the first alternative only returns a `HeaderBuilder`.
    This means that you cannot add a body. It is unfortunate that Spring decided to
    go that way. Go to [https://bit.ly/2CZSx0S](https://bit.ly/2CZSx0S) to access
    the complete code for the `MottoController.java` file. You have to use for example
    the `mottos #1` post request first otherwise any request returns a **404** because
    the list is empty.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以使用`ResponseEntity.notFound()`或`ResponseEntity.status(HttpStatus.NOT_FOUND)`来创建响应实体构建器。然而，虽然第二个选择返回一个适当的`BodyBuilder`，但第一个选择只返回一个`HeaderBuilder`。这意味着您不能添加正文。Spring决定这样做是不幸的。前往[https://bit.ly/2CZSx0S](https://bit.ly/2CZSx0S)访问`MottoController.java`文件的完整代码。您必须首先使用例如`mottos
    #1`的POST请求，否则任何请求都会返回**404**，因为列表为空。'
- en: 'You can find a possible solution in the GitHub repository, or you can view
    the excerpt shown here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库中找到一个可能的解决方案，或者您可以看到这里显示的摘录：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hypermedia with Spring Boot
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot的超媒体
- en: Hypermedia is an extension to hypertext that allows handling of sound and video.
    It is a key aspect of REST as it enables the creation of services that decouple
    the client and server and thus allowing them to develop independently.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体是超文本的扩展，允许处理声音和视频。它是REST的关键方面，因为它能够创建将客户端和服务器解耦的服务，从而允许它们独立开发。
- en: HATEOAS Introduction
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HATEOAS简介
- en: Imagine that someone gives you the link to a website. Usually, it is a link
    to the top-level page on the site or even the only page; usually, you only have
    this link. As you look at the page, you start to read and explore—you follow links
    to other pages, read on, and follow other links. You discover the whole site just
    by following the links.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有人给你提供了一个网站的链接。通常，这是一个指向网站顶级页面的链接，甚至是唯一的页面；通常，您只有这个链接。当您查看页面时，您开始阅读和探索——您跟随链接到其他页面，继续阅读，并跟随其他链接。您只需通过跟随链接就可以发现整个网站。
- en: Should a REST API not be the same? It can be made fully discoverable by following
    links that are embedded in the answers, so all you ever need is the start URL.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: REST API难道不应该是一样的吗？通过遵循嵌入在答案中的链接，它可以被完全发现，所以您需要的只是起始URL。
- en: This is generally known as **hypermedia**, or **hypertext**. It is part of the
    main REST principle in Fielding's original work, and at the same time, the most
    often violated property in many REST APIs. However, it is not a mere academic
    proposal; there are APIs that follow this principle closely. Remember the beginning
    of this chapter, when we discovered the SWAPI Star Wars API from a single entry
    link?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被称为**超媒体**或**超文本**。它是Fielding原始工作中主要REST原则的一部分，同时也是许多REST API中最常违反的性质。然而，它不仅仅是一个学术提议；有一些API非常遵循这个原则。记得本章的开头，当我们从单个条目链接中发现SWAPI星球大战API吗？
- en: This principle is known as **Hypermedia As The Engine Of Application State**,
    or as the unwieldy and unpronounceable acronym **HATEOAS**. Used correctly, it
    gives the server and client much more flexibility.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则被称为**超媒体作为应用状态引擎**，或者称为难以驾驭且难以发音的缩写**HATEOAS**。正确使用时，它为服务器和客户端提供了更多的灵活性。
- en: 'Consider the following use cases:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用例：
- en: A blog entry has an author. How would you represent this in the REST response?
    We could just embed the author, losing track of the reverse relation. We could
    return the author's ID, but how does the client know with which URL to use for
    this ID? Finally, we can just return a link to the author, solving both problems.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇博客条目有一个作者。你如何在 REST 响应中表示这一点？我们可以简单地嵌入作者，但会失去反向关系。我们可以返回作者的 ID，但客户端如何知道使用哪个
    URL 来使用这个 ID？最后，我们可以直接返回一个指向作者的链接，解决这两个问题。
- en: The REST answer may contain different links for different regions of the clients.
    This provides a single point of entry combined with location-based load balancing.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 响应可能包含针对客户端不同区域的多个链接。这提供了一个单一的入口点，并结合基于位置的负载均衡。
- en: When changing an endpoint, we lose backward compatibility. If, however, the
    clients are not supposed to access arbitrary URLs buried deeply in our application,
    but to follow links, we can just change the link list on the entry point.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当更改端点时，我们会失去向后兼容性。然而，如果客户端不应该访问我们应用程序中埋藏的任意 URL，而是遵循链接，我们只需更改入口点的链接列表。
- en: There are many ways to meet the goals of the principle. The main challenge is
    to produce all the links, particularly in a way that allows maintenance of the
    software. The Spring HATEOAS subproject simplifies the creation and consumption
    of HATEOAS resources and offers convenient functions for link creation. In this
    book, we will only touch the surface of it and add a link back to the entity itself.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 实现原则目标有许多方法。主要挑战是生成所有链接，尤其是在允许维护软件的方式下。Spring HATEOAS 子项目简化了 HATEOAS 资源创建和消费的过程，并为链接创建提供了便捷的功能。在这本书中，我们只会触及表面，并添加一个链接回到实体本身。
- en: Consider the `ContentTypeController` and its endpoint, `/api/greeting`, which
    could produce greetings to a person requested in the URL.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `ContentTypeController` 和其端点 `/api/greeting`，它可以为 URL 中请求的人生成问候语。
- en: 'When querying the endpoint with `/api/greeting?addressee=John`, the answer
    is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `/api/greeting?addressee=John` 查询端点时，答案是以下内容：
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The addressee was given in the request, and we can see it in the message, too.
    Now, why would we return the addressee? To make it easier to recreate the link
    that we used to get the resource. This, however, means that we have to construct
    the URL from the parameter using our knowledge of the API. Let''s turn this into
    the following answer:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 收件人在请求中给出，我们也可以在消息中看到它。现在，为什么我们要返回收件人？为了使重新创建我们用来获取资源的链接更容易。然而，这意味着我们必须使用我们对
    API 的了解从参数中构造 URL。让我们将其转换为以下答案：
- en: '[PRE23]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time, we have a reference to the original link stored alongside the data.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们有一个与数据一起存储的原始链接引用。
- en: Extending an Application with Spring HATEOAS
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring HATEOAS 扩展应用程序
- en: 'In Spring HATEOAS, data objects with the ability to link to others via URL
    links are called resources (a term which has many overloaded meanings). One way
    to turn your data into such a resource is to let it extend the `ResourceSupport`
    class. This class provides the necessary mapping to JSON and an `add()` method
    to add a link. Assuming that message is such an object, a link to itself can be
    created like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring HATEOAS 中，具有通过 URL 链接链接到其他对象的数据对象被称为资源（这个术语有许多过载的含义）。将你的数据转换为这种资源的一种方法是通过让它扩展
    `ResourceSupport` 类。这个类提供了必要的映射到 JSON 以及一个 `add()` 方法来添加链接。假设消息是这样的对象，可以这样创建一个指向自身的链接：
- en: '[PRE24]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This needs some explaining. Both `linkTo()` and `methodOn()` are static helper
    functions in `ControllerLinkBuilder`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些解释。`linkTo()` 和 `methodOn()` 都是 `ControllerLinkBuilder` 中的静态辅助函数。
- en: The outer expression `linkTo(…).withSelfRel()` will create the link itself and
    give it a relation called self. Other styles of linking than the shown JSON exist.
    For instance, you may have seen HTML anchors with a `rel` attribute.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 外部表达式 `linkTo(…).withSelfRel()` 将创建链接本身，并给它一个名为 self 的关系。除了显示的 JSON 链接样式之外，还存在其他链接样式。例如，你可能见过带有
    `rel` 属性的 HTML 锚点。
- en: The inner expression is similar to what can be seen in mocking frameworks. What
    may look like a call to the actual controller function is indeed against a proxy
    object. The effect of this and quite some reflection magic is that Spring HATEOAS
    is able to evaluate the annotations that are present on the referenced method.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 内部表达式类似于在模拟框架中可以看到的内容。看起来是对实际控制器函数的调用实际上是对代理对象的调用。这种和相当多的反射魔法的效果是，Spring HATEOAS
    能够评估引用方法上存在的注解。
- en: Creating a HATEOAS Resource
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 HATEOAS 资源
- en: Now you have started to lay out your REST API and are faced with the requirement
    to make it HATEOAS compliant. You go ahead and enhance the API using Spring HATEOAS.
    The aim is to create a HATEOAS resource that exhibits a link to itself.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经开始构建您的 REST API，并面临使其符合 HATEOAS 要求的需求。您继续使用 Spring HATEOAS 来增强 API。目标是创建一个展示自身链接的
    HATEOAS 资源。
- en: 'Before beginning, open the `hateoas-intro` project. This is a much stripped-down
    version of the rest-intro project. Only the `ContentTypeController` and a single
    handler method are left. The steps for completion are as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，打开 `hateoas-intro` 项目。这是 rest-intro 项目的简化版本。只剩下 `ContentTypeController`
    和一个处理方法。完成步骤如下：
- en: 'You need one more dependency in the POM. As usual, no version is required,
    as the version already comes with the Spring Boot parent POM:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要在一个 POM 中添加一个额外的依赖项。通常情况下，不需要指定版本，因为 Spring Boot 父 POM 已经包含了版本：
- en: '[PRE25]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `ContentTypeController`, make the `Message` class extend Spring's `ResourceSupport`.
    Remove the `addressee` field that is not needed anymore.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ContentTypeController` 中，使 `Message` 类继承 Spring 的 `ResourceSupport`。删除不再需要的
    `addressee` 字段。
- en: Fix the code in the `greetFromPath()` method and introduce a variable message
    instead of immediately returning the result of the constructor call. (You can
    use the shortcut *Ctrl-Alt-V* to extract a variable.)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复 `greetFromPath()` 方法中的代码，并引入一个变量 `message` 而不是立即返回构造函数调用的结果。（您可以使用快捷键 *Ctrl-Alt-V*
    提取变量。）
- en: 'Now, before returning the message, add the link with the code snippet you have
    already seen:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在返回消息之前，添加您已经看到的代码片段中的链接：
- en: '[PRE26]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Test the application in Postman now that it is complete.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应用已完成，请在 Postman 中测试该应用。
- en: 'The produced JSON now contains an `additional _links` field that contains a
    reference to the resource itself:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 JSON 现在包含一个 `additional _links` 字段，其中包含对资源的引用：
- en: '[PRE27]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Refer to the complete code placed in [https://bit.ly/2PHxyoD](https://bit.ly/2PHxyoD).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 参考放置在 [https://bit.ly/2PHxyoD](https://bit.ly/2PHxyoD) 的完整代码。
- en: Go to [https://bit.ly/2MsadRU](https://bit.ly/2MsadRU) to access the complete
    code for the `HateoasIntroApplicationTests.java` file. You will even find the
    solution in the `exercises/hateoas-intro-after` folder.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://bit.ly/2MsadRU](https://bit.ly/2MsadRU) 访问 `HateoasIntroApplicationTests.java`
    文件的完整代码。您甚至可以在 `exercises/hateoas-intro-after` 文件夹中找到解决方案。
- en: 'Activity: Creating a List of Blog Articles as a REST Resource'
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：将博客文章列表作为 REST 资源创建
- en: '**Prerequisites**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: We are building this activity upon the `blogmania` application that we built
    in the previous chapters. It already has a human-facing web frontend. You can
    find the source code at [https://bit.ly/2OxaeoF](https://bit.ly/2OxaeoF). It is
    the same as we left it in the previous activity that we've covered, so you can
    reuse that project or create a new one as you wish.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这个活动上构建的是我们在前几章中构建的 `blogmania` 应用程序。它已经有一个面向人类的前端。您可以在 [https://bit.ly/2OxaeoF](https://bit.ly/2OxaeoF)
    找到源代码。它与我们在上一个活动中留下的代码相同，因此您可以重用该项目或创建一个新的项目，根据您的意愿。 '
- en: '**Aim**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To create a list of current blog articles that will be available as a REST resource
    to query with Postman.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个当前博客文章列表，该列表将作为 REST 资源，可通过 Postman 进行查询。
- en: '**Scenario**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: You have a working application for humans and are asked to add another interface
    to it, suited for other programs as clients. You decide to do it the RESTful way.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经有一个面向人类的工作应用，现在需要为它添加另一个接口，使其适合其他程序作为客户端。您决定采用 RESTful 方式来实现。
- en: '**Steps for Completion**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Take the `blogmania` application and find the `BlogPostController`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿 `blogmania` 应用程序并找到 `BlogPostController`。
- en: Write a REST controller that gives a list of all the articles under the URL
    `/api/blogposts`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 REST 控制器，在 URL `/api/blogposts` 下提供一个所有文章的列表。
- en: Add the full path to each method.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个方法添加完整路径。
- en: Add one or two dependencies to the class.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个或两个依赖项。
- en: Add a mapping function to get all of the blog articles via REST.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个映射函数，通过 REST 获取所有博客文章。
- en: 'Start the application and use Postman to access `localhost:8080/api/blogposts`.
    We are doing this to see the list of blog articles returned as a JSON list:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序，并使用 Postman 访问 `localhost:8080/api/blogposts`。我们这样做是为了查看作为 JSON 列表返回的博客文章列表：
- en: '![](img/5f85486a-888b-45e4-b58c-54587c5e1e7f.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f85486a-888b-45e4-b58c-54587c5e1e7f.png)'
- en: '**Outcome**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: The list of current blog articles will be available as a REST resource to query
    with Postman.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当前博客文章的列表将作为 REST 资源，可通过 Postman 进行查询。
- en: Go to [https://bit.ly/2xezb1A](https://bit.ly/2xezb1A) to access the code for
    the `BlogPostController.java` file. Go to [https://bit.ly/2NFjris](https://bit.ly/2NFjris)
    to access the code for the `BlogPostRestController.java` file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://bit.ly/2xezb1A](https://bit.ly/2xezb1A)访问`BlogPostController.java`文件的代码。前往[https://bit.ly/2NFjris](https://bit.ly/2NFjris)访问`BlogPostRestController.java`文件的代码。
- en: Go to [https://bit.ly/2QrByao](https://bit.ly/2QrByao) to access the `activity/`
    folder. To refer to the detailed steps, go to the *Solutions* section at the end
    of this book on page 260.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://bit.ly/2QrByao](https://bit.ly/2QrByao)访问`activity/`文件夹。要参考详细步骤，请参阅本书末尾第260页的“解决方案”部分。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter built straight on top of the concepts of the previous chapters,
    expanding your mastery of Spring MVC controllers to different responses. This
    is flexible enough to return any kind of data but is particularly suited to serve
    REST APIs. You have learned what REST principles are and how to implement those
    with Spring. This included returning the most appropriate HTTP status code and
    various useful HTTP headers.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本章直接基于前几章的概念构建，扩展了你对Spring MVC控制器不同响应的掌握。这足够灵活，可以返回任何类型的数据，但特别适合于提供REST API。你已经学习了REST原则以及如何使用Spring来实现这些原则。这包括返回最合适的HTTP状态码和多种有用的HTTP头信息。
- en: Right now, everybody can post articles in our blogging app. We need to restrict
    this access, so we will turn our attention toward security in the next chapter.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，任何人都可以在我们的博客应用中发布文章。我们需要限制这种访问，因此我们将注意力转向下一章的安全问题。
