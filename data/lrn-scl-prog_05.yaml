- en: Property-Based Testing in Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的基于属性的测试
- en: Unit testing is a daily activity of many programmers. It is performed in order
    to verify the behavior of the software under development. Property-based testing
    is an alternative and supplementary approach to unit testing. It allows for the
    description of the expected properties of software and for their verification,
    if these properties hold using automatically generated data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是许多程序员日常活动的一部分。它是为了验证正在开发的软件的行为而进行的。基于属性的测试是单元测试的替代和补充方法。它允许描述软件的预期属性，并使用自动生成数据对这些属性进行验证，如果这些属性保持不变。
- en: In this chapter, we'll discuss the situations in which property-based testing
    can be especially useful, and look at how the expected properties can be formulated
    and the test data can be produced.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在哪些情况下基于属性的测试特别有用，并探讨如何制定预期的属性以及生成测试数据。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The concept of property-based testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于属性的测试概念
- en: Properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Generators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Shrinkers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩减器
- en: Properties as laws
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性作为法则
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: JDK 1.8+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+
- en: SBT 1.2+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The source code for this chapter is available under: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter05](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下链接获取：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter05](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter05).
- en: Introduction to property-based testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于属性的测试简介
- en: The concept of unit testing should be well-known by any professional developer.
    A unit test usually contains a number of test cases. Each test case describes
    the expected behavior of a part of the program. The description is usually formulated
    in the form: *for this unit of code in that specific state we expect given input
    to produce the following output*. The developer then replicates such test cases
    with some deviations in the initial state and/or input data and expectations of
    the result in order to cover different code paths.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的概念应该为任何专业开发者所熟知。单元测试通常包含多个测试用例。每个测试用例描述了程序一部分的预期行为。描述通常以以下形式制定：*对于这个代码单元在该特定状态下，我们期望给定的输入产生以下输出*。然后，开发者通过在初始状态和/或输入数据以及结果期望中引入一些偏差来复制此类测试用例，以覆盖不同的代码路径。
- en: The specification of the test case is represented in the form of a test code
    relying on a testing framework. As at the moment of this writing, there are two
    popular testing frameworks for Scala projects, `ScalaTest` and `Specs2`. It is
    arguable that at least one of them should be familiar to any Scala developer,
    so we won't cover them in this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的规范以测试代码的形式表示，该代码依赖于测试框架。截至撰写本文时，Scala项目有两个流行的测试框架，`ScalaTest`和`Specs2`。至少有一个应该为任何Scala开发者所熟悉，因此我们不会在本书中介绍它们。
- en: Instead, we'll take a look at alternative ways to formulate expectations about
    the behavior of the program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将探讨其他制定关于程序行为预期的替代方法。
- en: From unit tests to properties
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单元测试到属性
- en: It turns out that testing scenarios (sometimes also called example-based tests)
    are just one of the many ways to define how the system is expected to work. Examples
    just describe some properties of the software having a specific state. The state
    usually affects the output in response to a provided input.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，测试场景（有时也称为基于示例的测试）只是定义系统预期如何工作的许多方法之一。示例仅描述了软件在特定状态下的某些属性。状态通常会影响输出，以响应提供的输入。
- en: 'Generally speaking, in addition to properties described via examples, there
    are other types of properties which characterize software, such as:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，除了通过示例描述的属性外，还有其他类型的属性可以表征软件，例如：
- en: Universally quantified properties
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全称量化属性
- en: Conditional properties
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件属性
- en: With them we can tell something about the system which should hold for any valid
    input and possibly for all possible states.  This form of testing is called **property-based
    testing** (**PBT**). In contrast to the concrete scenario in a unit-testing case,
    the property is an abstract specification.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过它们，我们可以了解关于系统的某些信息，这些信息应该适用于任何有效输入，并且可能适用于所有可能的状态。这种测试形式被称为**基于属性的测试**（**PBT**）。与单元测试案例中的具体场景相比，属性是一个抽象规范。
- en: The same way that unit-testing frameworks provide functionality to structure
    tests and to formulate the expectations in the forms of unit tests, there is a
    Scala framework for PBT.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试框架提供结构化测试和以单元测试形式制定期望的功能相同，Scala框架也提供了PBT（参数化测试）的功能。
- en: ScalaCheck
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ScalaCheck
- en: ScalaCheck ([http://www.scalacheck.org](http://www.scalacheck.org)) is a framework
    for automated PBT in Scala. It works great with SBT or IntelliJ IDEA and also
    has a built-in test runner and can be used standalone because of this. It also
    integrates well with `ScalaTest` and `specs2`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaCheck ([http://www.scalacheck.org](http://www.scalacheck.org)) 是Scala中自动化PBT（参数化测试）的框架。它与SBT或IntelliJ
    IDEA配合得很好，并且内置了测试运行器，因此可以独立使用。它还很好地与`ScalaTest`和`specs2`集成。
- en: '`ScalaCheck` is an external dependency, so we need to add it to the `build.sbt`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalaCheck`是一个外部依赖项，因此我们需要将其添加到`build.sbt`中：'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to be able to play with the code in REPL, we'll need to add it to the
    default scope (by removing the `% Test` part (this is already done in the chapter's
    code) and start the REPL with SBT dependencies. If you don't know how to do this,
    please refer to the [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml),
    *Preparing the Environment and Running Code Samples*, where we explain it in detail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在REPL（Read-Eval-Print Loop）中玩弄代码，我们需要将其添加到默认作用域中（通过移除`% Test`部分（这已经在章节的代码中完成）并使用SBT依赖项启动REPL。如果您不知道如何做，请参阅[附录A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml)，*准备环境和运行代码示例*，其中我们详细解释了它）。
- en: 'Now, we can define and verify our first property:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义和验证我们的第一个属性：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We just defined and verified that all `Strings` have non-negative lengths! Confused
    a bit? Let's take a closer look how it was done.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义并验证了所有`Strings`都具有非负长度！有点困惑吗？让我们更仔细地看看这是如何完成的。
- en: In the first line, we imported a `forAll` property factory. In essence, its
    purpose is to convert functions into properties.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们导入了一个`forAll`属性工厂。本质上，它的目的是将函数转换为属性。
- en: In our case, in the second line the function is of a type `String => Boolean`.
    Naturally, there is some implicit magic in play. Among other things, there is
    an implicit conversion `Boolean => Property` and an `Arbitrary[String]` which
    provides a test data, in our case, random strings.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，在第二行中，函数的类型是`String => Boolean`。自然，这里有一些隐式魔法在起作用。其中之一是一个隐式转换`Boolean
    => Property`和一个`Arbitrary[String]`，它提供了测试数据，在我们的例子中是随机字符串。
- en: In the third line we call a `check` method available on the `Prop` (`ScalaCheck`
    uses this name as an abbreviation for `"property"`) among other combination and
    execution methods to execute our test using the default configuration. Hence,
    it runs with 100 random strings as an input data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们调用了一个`check`方法，这是在`Prop`（ScalaCheck使用这个名字作为“属性”的缩写）以及其他组合和执行方法中可用的，用于使用默认配置执行我们的测试。因此，它使用100个随机字符串作为输入数据。
- en: Now that we've got a feeling for how the PBT looks in general, we'll rigorously
    approach each aspect of it, starting with properties.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对PBT（参数化测试）的一般形式有了感觉，我们将严格地处理它的每个方面，从属性开始。
- en: Properties
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: Defining properties is the most important aspect of PBT. It is impossible to
    test a system properly without having good properties definition. The transition
    from testing scenarios to properties is usually the hardest part for developers
    starting to adopt PBT.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 定义属性是PBT（参数化测试）最重要的方面。如果没有良好的属性定义，就无法正确测试系统。从测试场景到属性的过渡通常是刚开始采用PBT的开发者面临的最困难的部分。
- en: Therefore, it is useful to have some kind of system which would help to approach
    the task of defining a property in a systematic manner. Often, the first step
    in systematizing something is classification.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拥有某种系统来帮助以系统化的方式定义属性是有用的。通常，系统化某事物的第一步是分类。
- en: Types of properties
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性类型
- en: We already said that there are universally quantified and conditional properties,
    depending upon if some property holds always or just for some subset of all possible
    inputs. Now, we want to break down properties in different dimensions—by how they
    are defined. Let's see how we could describe some operations in general terms.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，存在普遍量化的属性和条件属性，这取决于某个属性是否始终成立或仅对所有可能输入的某个子集成立。现在，我们想要从不同的维度分解属性——根据它们的定义方式。让我们看看我们如何用一般术语描述一些操作。
- en: Commutativity
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换律
- en: 'If order operands do not matter, we say that the operation is commutative.
    The most trivial examples would be addition and multiplication. The property should
    be universal for both of these operations. In the following code, we''re creating
    two properties, one for addition and one for multiplication, and checking that
    our assumption is correct by comparing results of computations with the changed
    order of operands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数的顺序不重要，我们说该操作是交换的。最简单的例子就是加法和乘法。这个属性应该适用于这两个操作。在下面的代码中，我们创建了两个属性，一个用于加法，一个用于乘法，并通过比较运算结果的改变顺序来检查我们的假设是否正确：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For strings, the addition is defined as a concatenation but is not commutative
    in general:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串，加法定义为连接，但在一般情况下不是交换的：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we can also see how `ScalaCheck` generates random inputs and
    finds some minimal failing case. If at least one of the strings is empty, the
    property becomes commutative which can be demonstrated with the following modification
    of the previous test where `b` is assigned an empty string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还可以看到`ScalaCheck`如何生成随机输入并找到一些最小失败案例。如果至少有一个字符串为空，该属性变为交换的，这可以通过以下修改之前的测试来证明，其中`b`被分配一个空字符串：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is an example of a conditional test for string concatenation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个字符串连接条件测试的示例。
- en: Associativity
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合性
- en: The associativity is the same for operators as commutativity is for operands—if
    there are multiple operations, then the order in which operations are performed
    does not matter as long as the order of operands does not change.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性与交换性对于操作数相同——如果有多个操作，则只要操作数的顺序不变，操作执行的顺序并不重要。
- en: 'The associativity properties for multiplication and addition again look very
    similar, as in the following example where we have three properties, each comparing
    results of two computations with a different order of operations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和加法的结合性属性看起来非常相似，如下例所示，其中我们有三个属性，每个属性比较两种不同运算顺序的计算结果：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last line demonstrates that string concatenation is associative as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行证明了字符串连接也是结合的。
- en: Identity
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恒等性
- en: 'The identity property of some operation states that if one of the operands
    is the identity value, then the result of the operation will be equal to another
    operand. For multiplication, the identity value is one; for addition, it is zero.
    Because of the commutativity of both multiplication and addition, the identity
    value can appear in any position. For example, in the next snippet the identity
    element appears as the first and as the second operand for all of them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 某些操作的恒等性属性表明，如果操作数之一是恒等值，则操作的结果将等于另一个操作数。对于乘法，恒等值是1；对于加法，它是0。由于乘法和加法的交换性，恒等值可以出现在任何位置。例如，在下面的代码片段中，恒等元素作为所有这些的第一个和第二个操作数出现：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For string concatenation, the identity is an empty string. It turns out our
    conditional commutativity property for strings was just a manifestation of the
    universal identity property!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串连接，恒等性是一个空字符串。结果证明，我们为字符串定义的条件交换性属性只是普遍恒等性属性的一种表现！
- en: Invariants
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变量
- en: 'Invariant properties are those which should never change in the context of
    the operation. For example, sorting the contents of the string or changing the
    case of it should never change its length. The next property demonstrates that
    it holds for normal as well as for uppercase strings:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量属性是指在操作上下文中永远不会改变的属性。例如，对字符串内容进行排序或更改其大小写不应改变其长度。下一个属性证明了它对普通字符串以及大写字符串都成立：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or well, for `toUpperCase` at least it should work if the locale matches the
    contents of the string or the string only contains ASCII symbols:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，至少对于`toUpperCase`来说，如果区域设置与字符串内容匹配或字符串只包含ASCII符号，它应该可以工作：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we went a bit ahead of ourselves and used `Gen.asciiStr` to generate strings
    which only contain ASCII chars.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有点超前，使用了`Gen.asciiStr`来生成只包含ASCII字符的字符串。
- en: Idempotence
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幂等性
- en: Idempotent operations only change their operand once. After the initial change,
    any follow-up application should leave the operand unchanged. Sorting and uppercasing
    the contents of the string are good examples of idempotent operations. Please
    note that the same operations had the length property invariant in the previous
    example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等操作只改变它们的操作数一次。在初始更改之后，任何后续应用都应该保持操作数不变。对字符串内容进行排序和转换大小写是幂等操作的良例。请注意，在之前的例子中，相同的操作具有长度属性的不变量。
- en: 'We can demonstrate that operations `toUpperCase` and sorted are idempotent
    by applying them a different number of times and expecting that the result is
    the same as after the first application:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过应用不同次数的操作并期望结果与第一次应用相同来证明 `toUpperCase` 和 sorted 操作是幂等的：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For multiplications, the natural idempotent element is by definition the identity
    element. But it is also a zero:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于乘法，自然幂等元素按定义是单位元素。但它也是一个零：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The logical `AND` and `OR` are idempotent for the Boolean values `false` and
    `true`, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑 `AND` 和 `OR` 分别对布尔值 `false` 和 `true` 是幂等的。
- en: Induction
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归纳
- en: Inductive properties reflect those of their operand(s). They are usually formulated
    for the inductive case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳属性反映了它们的操作数属性。它们通常用于归纳情况。
- en: 'For example, the factorial function for any argument should obey the factorial
    definition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何参数的阶乘函数都应该遵守阶乘定义：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Which is, of course, a conditional property for `n > 2`, which we specify using
    the implication operator `==>` (more about this operator later).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个对于 `n > 2` 的条件属性，我们使用蕴涵运算符 `==>` 来指定（关于这个运算符的更多内容稍后介绍）。
- en: Symmetry
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称性
- en: Symmetry is a type of invariance. It states that the operand will have its original
    form after the application of some ordered set of operations . Often this set
    is limited to a pair of operations or even to a single symmetric operation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对称性是一种不变性类型。它表明操作数在应用一些有序操作集之后将保持其原始形式。通常这个集合限于一对操作，甚至限于一个对称操作。
- en: 'For our usual experimental string, there is a symmetric operation `reverse`;
    for numbers, we could define a pair of addition and subtraction:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们常用的实验字符串，有一个对称操作 `reverse`；对于数字，我们可以定义一对加法和减法：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is possible to define another pair with multiplication and division as operands
    (with respect to division by zero, overflow, and precision).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能定义另一对，以乘法和除法作为操作数（关于除以零、溢出和精度）：
- en: The symmetry property is often called a **round-trip** property. For a single
    operation it must hold for any inversible function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对称属性通常被称为 **往返** 属性。对于单个操作，它必须对任何可逆函数成立。
- en: Test Oracle
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试预言者
- en: Strictly speaking, the test oracle does not belong to this list because it does
    not specify an intrinsic quality of the operation. Still, it is a useful and convenient
    way to pinpoint an expected behavior.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，测试预言者不属于这个列表，因为它没有指定操作的内禀质量。尽管如此，它是一种有用且方便的方式来指明预期的行为。
- en: 'The principle is simple and especially useful during a refactoring or rewriting
    of the existing system. It uses given trusted implementation to verify the behavior
    of the new code. Back to our string examples, we might use Java''s Array as a
    test oracle for the sorting of the contents of the string, by expecting that the
    results of sorting the string and an array, which consists of its elements, would
    be the same:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 原则很简单，特别是在重构或重写现有系统时特别有用。它使用给定的可信实现来验证新代码的行为。回到我们的字符串示例，我们可能使用 Java 的数组作为字符串内容排序的测试预言者，通过期望字符串排序和由其元素组成的数组的排序结果相同：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But, of course, in the real refactoring scenario on the place of an array, the
    existing implementation would be used.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当然，在真实的重构场景中，在数组的位置上会使用现有的实现。
- en: Defining a property
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义属性
- en: We've defined all different type's properties in the same way, using the most
    concise version of the `forAll` constructor and a `check` method. There are some
    ways to customize them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相同的方式定义了所有不同类型的属性，使用 `forAll` 构造函数的最简洁版本和 `check` 方法。有一些方法可以自定义它们。
- en: Checking property
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查属性
- en: 'The `check()` method accepts `Test.Parameters`, which allow for the configuration
    of a few aspects of how the check is executed. The most useful describe a minimum
    number of successful tests, the number of workers to run in parallel, a test callback
    to execute after each test, the maximum discard ratio between passed and discarded
    tests for conditional tests, and an initial seed which can help to make the property
    evaluation deterministic. It is also possible to limit the time the test is allowed
    to execute. Here is an example, which uses both test parameters and a time limit:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`check()` 方法接受 `Test.Parameters`，允许配置检查执行的一些方面。最有用的是描述最小成功测试次数、并行运行的工人数、每个测试后执行的测试回调、条件测试中通过和丢弃测试之间的最大丢弃比率，以及一个初始种子，这有助于使属性评估确定性。还可以限制测试允许执行的时间。以下是一个示例，它使用了测试参数和时间限制：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we used the `Test.check` method, which executes a property with given parameters
    and returns test statistics back. We can see that our test has failed because
    of the timeout.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`Test.check`方法，该方法执行带有给定参数的属性并返回测试统计信息。我们可以看到，我们的测试因为超时而失败了。
- en: 'Besides `within`, there are other wrapper methods defined on `Prop`. For instance,
    it is possible to convert exceptions thrown by the property into test failures,
    to evaluate properties lazily, or to collect data for the test report:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`within`之外，还在`Prop`上定义了其他包装方法。例如，可以将属性抛出的异常转换为测试失败，可以延迟评估属性，或者收集测试报告的数据：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The difference between `==` and `?=` used in the previous code is subtle—the
    `==` compares two values and returns a Boolean, which is then implicitly converted
    to the `Prop`; the `?=` creates a `Prop` directly and sometimes it can be useful
    in the situations where properties are combined, as we'll see further.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中使用的`==`和`?=`之间的区别是微妙的——`==`比较两个值并返回一个布尔值，然后隐式转换为`Prop`；`?=`直接创建一个`Prop`，有时在属性组合的情况下可能很有用，正如我们将在后面看到的。
- en: 'A property can also be labelled, which makes it easier to spot in the results:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以被标记，这使得在结果中更容易找到它：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we also used the `protect` method to convert the exception into the test
    failure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也使用了`protect`方法将异常转换为测试失败。
- en: Combining properties
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合属性
- en: 'Until now, we were talking about single, isolated properties. Sometimes, it
    is useful, or even required, to make sure that some combination of properties
    holds. For instance, we might want to define a property which holds if and only
    if all other properties hold. Or we might want to have a property which is true
    if at least one property from a set of properties is true. There are combination
    methods defined on `Prop` exactly for such use cases. The result is just another
    property which can be checked the same way we already did:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在谈论单个、孤立的属性。有时，确保某些属性的组合成立是有用的，甚至是有必要的。例如，我们可能想要定义一个属性，该属性仅在所有其他属性都成立时成立。或者我们可能想要有一个属性，该属性在属性集中至少有一个属性为真时为真。`Prop`上定义了组合方法，正好用于此类用例。结果是另一个属性，我们可以像之前那样进行检查：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a nested combination of properties. The topmost one holds if both `multiplicationLaws`
    and `stringProps` hold. The `stringProps` verifies that any `String` is either
    empty or non-empty; only one of these properties can be true at the same time.
    For `multiplicationLaws`, all nested properties must hold.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个属性的嵌套组合。最顶层的属性在`multiplicationLaws`和`stringProps`都成立的情况下成立。`stringProps`验证任何`String`要么为空，要么非空；同时只能有一个这样的属性为真。对于`multiplicationLaws`，所有嵌套属性都必须成立。
- en: There are also more specific combinators, for example `someFailing` and `noneFailing`
    which hold in the case if some underlying properties are failing or none are failing
    respectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些更具体的组合器，例如`someFailing`和`noneFailing`，它们分别在底层属性失败或没有任何属性失败的情况下成立。
- en: Generators
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: We have had a detailed discussion of properties, but haven't mentioned yet where
    the input data for these properties comes from. Let's correct this omission and
    give generators the care they deserve.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对属性进行了详细的讨论，但还没有提到这些属性的输入数据来自哪里。让我们纠正这个遗漏，并给予生成器应有的关注。
- en: The idea of the generator comes from the general concept of types. In a sense, a
    type is a specification of possible values complying to that type. In other words, types
    describe the rules that values must comply to. These rules give us the possibility
    to generate ranges of data values for given types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的想法来源于类型的通用概念。从某种意义上说，类型是对符合该类型可能值的规范。换句话说，类型描述了值必须遵守的规则。这些规则为我们提供了为给定类型生成数据值范围的可能性。
- en: 'For some types there are more values; for others, there are less. As we already
    know, there are literal types which contain a single value. The same applies for
    `Unit` type with its `()` value. For `Boolean`, there are two values that exist:
    `true` and `false`. Two values would also exist for an imaginary equality relation
    type—equal and non-equal. With the same principle, we can say that full ordering
    takes one of three values: less than, equal, or greater than.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型，值更多；对于其他类型，值更少。正如我们已知的那样，存在包含单个值的字面类型。对于具有`()`值的`Unit`类型，情况也是如此。对于`Boolean`类型，存在两个值：`true`和`false`。对于想象中的等价关系类型，也存在两个值——相等和非相等。按照同样的原则，完整的排序可以取三个值之一：小于、等于或大于。
- en: Properties defined in terms of types with such limited sets of possible values
    are called *provable*. This is because it is possible to try out all values of
    a given type (or combinations, if there are multiple parameters) and prove that
    the program is correct for all possible inputs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在具有如此有限可能值集合的类型上的属性被称为 *可证明* 属性。这是因为可以尝试给定类型的所有值（如果有多个参数，则是组合），并证明程序对所有可能的输入都是正确的。
- en: The other type of properties are *falsifiable* properties. It is not possible
    (or does not make sense) to try out all possible values of input parameters, hence
    it is only possible to tell that the functionality under test works for some subset
    of all inputs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的属性是可证伪属性。尝试所有可能的输入参数值是不可能的（或没有意义），因此只能说明正在测试的功能对于所有输入的某个子集是有效的。
- en: To make falsifiable properties more trustworthy, existing `ScalaCheck` generators
    for `Byte`, `Short`, `Int`, and `Long` place additional weight on `zero`, `+1`,
    `-1`, and both `minValue` and `maxValue` for the type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使可证伪属性更加可信，现有的 `ScalaCheck` 生成器为 `Byte`、`Short`、`Int` 和 `Long` 类型在 `zero`、`+1`、`-1`
    以及 `minValue` 和 `maxValue` 上增加了额外的权重。
- en: Let's take a look at which generators are included in the `ScalaCheck` and how
    we can use them to create new generators for the data types specific for our code.
    We'll also briefly touch the topic of gradually reducing the test data for failing
    cases known as shrinking.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `ScalaCheck` 中包含哪些生成器，以及我们如何使用它们为特定于我们代码的数据类型创建新的生成器。我们还将简要讨论逐渐减少已知失败案例的测试数据，即缩小。
- en: Existing generators
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现有生成器
- en: Speaking about existing generators, ScalaCheck provides a lot of them out of
    the box, such as all subtypes of `AnyVal`, `Unit`, `Function0`, chars and strings
    with different contents (`alphaChar`, `alphaLowerChar`, `alphaNumChar`, `alphaStr`,
    `alphaUpperChar`, `numChar`, `numStr`), containers, lists and maps (`containerOf`,
    `containerOf1`, `containerOfN`, `nonEmptyContainerOf`, `listOf`, `listOf1`, `listOfN`, `nonEmptyListOf`, `mapOf`,
    `mapOfN`, `nonEmptyMap`), numbers (`chooseNum`, `negNum`, `posNum`), duration,
    `Calendar`, `BitSet`, and even `Test.Parameters`!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 说到现有生成器，ScalaCheck 提供了许多内置生成器，例如 `AnyVal` 的所有子类型、`Unit`、`Function0`、具有不同内容的字符和字符串（`alphaChar`、`alphaLowerChar`、`alphaNumChar`、`alphaStr`、`alphaUpperChar`、`numChar`、`numStr`）、容器、列表和映射（`containerOf`、`containerOf1`、`containerOfN`、`nonEmptyContainerOf`、`listOf`、`listOf1`、`listOfN`、`nonEmptyListOf`、`mapOf`、`mapOfN`、`nonEmptyMap`）、数字（`chooseNum`、`negNum`、`posNum`）、持续时间、`Calendar`、`BitSet`，甚至
    `Test.Parameters`！
- en: 'If there is no generator  suitable for the testing purposes available, it is
    possible to create a custom generator by implementing a `Gen` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有适合测试目的的生成器可用，可以通过实现一个 `Gen` 类来创建一个自定义生成器：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is an abstract class, which is basically just a function taking test parameters
    and returning an optional value of the required type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个抽象类，它基本上就是一个接受测试参数并返回所需类型可选值的函数。
- en: 'It is partially implemented, but still, it''s a bit mundane to extend it manually.
    Hence new generators are usually implemented by reusing already existing ones. As
    an exercise, let''s implement a generator for literal types:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然部分实现了它，但手动扩展它仍然有点枯燥。因此，通常通过重用现有的生成器来实现新的生成器。作为一个练习，让我们实现一个字面类型生成器：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first line, we're creating a generator factory for literal types by delegating
    the value generation to the `Gen.const`. This is safe to do because, by definition,
    literal types contain just a single value. The second line creates an `implicit
    Arbitrary[42]`, which is expected to be in scope by the `forAll` property.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们通过将值生成委托给 `Gen.const` 来创建一个字面类型生成器工厂。这样做是安全的，因为根据定义，字面类型只包含单个值。第二行创建了一个
    `implicit Arbitrary[42]`，它期望通过 `forAll` 属性在作用域内。
- en: Combining generators
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器的组合
- en: Though it is not very hard to create a custom one, the absolute majority of
    generators is built by combining existing implementations. `Gen` offers a couple
    of methods that are very useful in such scenarios. The classic example is to use
    the `map` and `flatMap` methods to create a generator for a case class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建一个自定义生成器并不非常困难，但绝大多数生成器是通过组合现有实现来构建的。`Gen` 提供了一些在这种情况下非常有用的方法。一个经典的例子是使用
    `map` 和 `flatMap` 方法为案例类创建生成器。
- en: 'Let''s demonstrate this with an example of playing cards:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个玩牌的例子来演示这一点：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First, we need some generators for suits and ranks which we can create by reusing
    existing `oneOf` and `choose` constructors:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些用于花色和点数的生成器，我们可以通过重用现有的 `oneOf` 和 `choose` 构造函数来创建它们：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can combine our generators into the card generator using `for` comprehension:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`for`推导式将我们的生成器组合到牌生成器中：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We also use `Gen.frequency` in order to have a proper distribution of numbers
    and symbols produced by our combined generator.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`Gen.frequency`以确保我们的组合生成器产生的数字和符号有适当的分布。
- en: 'It is easy to change this generator to only make cards for a pique pack by
    using the `suchThat` combinator:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`suchThat`组合器很容易将这个生成器改为只为牌组生成牌：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can check that our generators produce trustworthy values by using the `Prop.collect`
    method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Prop.collect`方法来检查我们的生成器是否产生可信的值：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Of course, it is also possible to generate a handfull of cards from the deck
    using one of the container generator methods:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以使用容器生成器方法之一从牌堆中生成一些牌：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And use it as before:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像以前一样使用它：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Oh, we have duplicate cards in our hand. It turns out that we need to use a
    more general form of the container generator, which takes both the type of the
    container and the type of the element as type parameters:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我们的手中有多张重复的牌。结果是，我们需要使用容器生成器的更一般形式，它接受容器类型和元素类型的类型参数：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That is better, but now it seems that the duplicate elements have just disappeared
    so that we still don't have an expected behavior. Moreover, another issue is obvious—a
    lot of tests are discarded. This happens because our `piquet` generator is defined
    in terms of filtering the output of the more general `full` generator. `ScalaCheck`
    notices that there are too many tests which do not qualify as a valid input and
    gives up earlier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好，但现在看起来重复的元素似乎消失了，所以我们仍然没有预期的行为。此外，还有一个明显的问题——许多测试被丢弃。这是因为我们的`piquet`生成器是在过滤更通用的`full`生成器的输出定义的。`ScalaCheck`注意到有太多测试不符合有效输入的资格，因此提前放弃。
- en: 'Let''s fix our `piquet` generator and an issue with missing cards. For the
    first one, we will use the same approach as we''ve used for the `full` generator.
    We''ll just change the number used for the rank:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复我们的`piquet`生成器和一个缺失牌的问题。对于第一个问题，我们将使用与`full`生成器相同的方法。我们只需更改用于排名的数字：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Please note how the frequency changed in respect to the changed set of possible
    values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，频率是如何相对于可能值的变化而变化的。
- en: 'To fix the second issue, we will repeatedly generate the set of cards until
    it has an expected size using `retryUntil` combinator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复第二个问题，我们将使用`retryUntil`组合器反复生成牌组，直到它达到预期的尺寸：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, our hands are generated as expected.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的手牌生成正如预期的那样。
- en: Of course, there are even more useful combinator methods, which can be used
    to create other sophisticated generators. Please refer to the documentation ([https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md](https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md))
    or the source code for further details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多有用的组合方法，可以用来创建其他复杂的生成器。请参阅文档([https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md](https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md))或源代码以获取更多详细信息。
- en: Shrinkers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩减器
- en: We have looked at two cornerstones of PBT—properties and generators. There is
    still one aspect we should take a look at before considering ourselves done.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了PBT的两个基石——属性和生成器。在我们认为自己完成之前，还有一个方面我们应该看看。
- en: 'In PBT, the test data comes from generators and it is kind of random. Given
    this fact, we could expect that it might be hard to find out why a test is failing.
    Consider the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在PBT中，测试数据来自生成器，它有点随机。考虑到这个事实，我们可能会预期很难找出为什么测试失败。考虑以下示例：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we can see that our property was falsified by the number `2008612603`,
    which is arguably not very useful. It is more or less obvious for an `Int`, but
    consider a case with a list of many elements and a property formulated for these
    elements:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的属性被数字`2008612603`所否定，这个数字可以说是没有太大用处。对于一个`Int`来说，这几乎是显而易见的，但考虑一个包含许多元素的列表和为这些元素制定的属性的情况：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Obviously, it is near to impossible to find out which of 1,000 strings had a
    wrong length in this test.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这个测试中找出哪个1,000个字符串长度错误几乎是不可能的。
- en: 'At this moment, the new component comes into play: the `Shrink`. The job of
    the shrinker is to find a minimal test data with which the property does not hold.
    In two previous examples, we used a `forAllNoShrink` property constructor and
    thus had no shrinker active. This is how the result will look like if we change
    the definition to the normal `forAll`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，新的组件开始发挥作用：`Shrink`。收缩器的作用是找到使属性不成立的最小测试数据。在前两个例子中，我们使用了`forAllNoShrink`属性构造器，因此没有激活收缩器。如果我们将定义更改为正常的`forAll`，结果将如下所示：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we can see that the minimal list, which falsifies our property, is the
    list with one empty string. The original failing input is shown as `ARG_0_ORIGINAL`
    and it is of a similar length and complexity as we've seen before.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，使我们的属性为假的极小列表是包含一个空字符串的列表。原始的失败输入以`ARG_0_ORIGINAL`的形式展示，其长度和复杂性与我们之前看到的相似。
- en: 'The `Shrink` instances are passed as implicit parameters, so we can summon
    one to see how they work. We''ll do this with our failing value for `Int` property:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shrink`实例作为隐式参数传递，因此我们可以召唤一个来查看它们是如何工作的。我们将使用我们的`Int`属性失败值来做这件事：'
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `shrink` method generates a stream of values and we evaluate it by converting
    it to the list. It is easy to see the pattern—the values produced by the `Shrink`
    lie symmetrically to the **central** value of `0` (zero), starting from the initial
    failing value, and then are each time divided by two until they converge to the
    zero. This is pretty much how it is implemented for numbers, including hardcoded
    values of `+-two`, `+-one`, and `zero`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`shrink`方法生成一个值流，我们通过将其转换为列表来评估它。很容易看出模式——`Shrink`产生的值相对于`0`（零）的**中心**值对称，从初始的失败值开始，然后每次都除以二，直到它们收敛到零。这基本上就是它对数字的实现方式，包括硬编码的`+-two`、`+-one`和`zero`值。'
- en: 'It is easy to see that numbers produced by the `Shrink` will depend on the
    initial failing argument. This is why for the first property the returned value
    will differ each time:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，`Shrink`生成的数字将取决于初始的失败参数。这就是为什么对于第一个属性，返回的值每次都会不同的原因：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, the resulting failing value depends on the original failing value
    and is never `43`, but sometimes it lies quite close.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，产生的失败值取决于原始的失败值，永远不会是`43`，但有时它非常接近。
- en: Shrinkers are essential at the time there are some properties which do not hold,
    especially if the input data is of significant size.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在一些不成立的属性时，收缩器是必不可少的，尤其是如果输入数据具有显著的大小。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Property-based testing is a supplementary technique to the traditional unit
    testing and behavior-driven development. It allows one to describe program properties
    in the form of an abstract specification, and the test data in the form of rules
    to apply for its generation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试是传统单元测试和行为驱动开发的一种补充技术。它允许人们以抽象规范的形式描述程序属性，并以规则的形式描述用于生成测试数据的规则。
- en: Properly generated data includes edge cases, which are often ignored during
    example-based testing, and allows for higher code coverage.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正确生成的数据包括边缘情况，这些情况在基于示例的测试中通常被忽略，并允许更高的代码覆盖率。
- en: The `ScalaCheck` is a framework for property-based testing with Scala. It has
    three main components—properties, generators, and shrinkers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalaCheck`是一个基于Scala的属性测试框架。它有三个主要组件——属性、生成器和收缩器。'
- en: Universally quantified properties must hold for any test data in any state of
    the program. Conditional properties are defined for some subset of the data or
    specific states of the system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 全称量化属性必须适用于程序任何状态的任何测试数据。条件属性是为数据的一个子集或系统的特定状态定义的。
- en: '`ScalaCheck` provides a lots of generators for standard types out of the box.
    The best way to create generators for custom types is by combining existing generators
    using suitable methods defined on them.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalaCheck`提供了大量标准类型的生成器。创建自定义类型的生成器的最佳方式是通过使用它们上定义的合适方法组合现有生成器。'
- en: The role of an optional shrink is to reduce a test data set for a failing property,
    helping to identify a minimal failing test case.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可选收缩器的作用是减少失败属性的测试数据集，帮助识别最小失败测试用例。
- en: There are a few extension libraries available which allow one to generate arbitrary
    case classes and ADTs ([scalacheck-shapeless](https://github.com/alexarchambault/scalacheck-shapeless)),
    cats type class instances ([cats-check](https://github.com/non/cats-check)), and
    other common cases ([scalacheck-toolbox](https://github.com/47deg/scalacheck-toolbox)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个扩展库可供使用，允许用户生成任意的案例类和ADT（[scalacheck-shapeless](https://github.com/alexarchambault/scalacheck-shapeless)），cats类型类实例（[cats-check](https://github.com/non/cats-check)），以及其他常见情况（[scalacheck-toolbox](https://github.com/47deg/scalacheck-toolbox)）。
- en: Now, we are properly equipped to start our journey into the land of functional
    programming concepts, which we will cover in the next part of the book. We will
    start by examining some types present in the standard library, which are known
    as effects, such as `Option`, `Try`, `Either`, and `Future`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始我们的功能性编程概念之旅，这部分内容将在本书的下一部分中介绍。我们将从检查标准库中的一些类型开始，这些类型被称为效果，例如`Option`、`Try`、`Either`和`Future`。
- en: Questions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Define an invariant property for sorting a list
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于排序列表的不变量性质
- en: Define an idempotent property for sorting a list
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于排序列表的幂等性质
- en: Define an inductive property for sorting a list
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于排序列表的归纳性质
- en: Define a generator for a `List[Lists[Int]]`, such that elements of the nested
    list are positive
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个生成器，用于`List[Lists[Int]]`，使得嵌套列表的元素都是正数
- en: Define a generator for a `Map[UUID, () => String]`
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个生成器，用于`Map[UUID, () => String]`
