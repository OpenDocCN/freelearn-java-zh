- en: 'Chapter 6: Exploring Essential Java Architectural Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：探索基本的Java架构模式
- en: In the last chapter, you had an overview of the most common development models,
    from the older (but still used) **Waterfall model** to the widely used and appreciated
    **DevOps** and **Agile**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你对最常见的发展模型有了概述，从较老但仍被使用的**瀑布模型**到广泛使用且受到赞赏的**DevOps**和**敏捷**。
- en: In this chapter, you will have a look at some very common architectural patterns.
    These architectural definitions are often considered basic building blocks that
    are useful to know about in order to solve common architectural problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将查看一些非常常见的架构模式。这些架构定义通常被认为是基本构建块，了解它们对于解决常见的架构问题非常有用。
- en: 'You will learn about the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: Encapsulation and hexagonal architectures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装和六边形架构
- en: Learning about multi-tier architectures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解多层架构
- en: Exploring Model View Controller
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索模型-视图-控制器
- en: Diving into event-driven and reactive approaches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解事件驱动和响应式方法
- en: Designing for large-scale adoption
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计适用于大规模采用
- en: Case studies and examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究和示例
- en: After reading this chapter, you'll know about some useful tools that can be
    used to translate requirements into well-designed software components that are
    easy to develop and maintain. All the patterns described in this chapter are,
    of course, orthogonal to the development models that we have seen in the previous
    chapters; in other words, you can use all of them regardless of the model used.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你将了解一些有用的工具，可以将需求转换为易于开发和维护的精心设计的软件组件。本章中描述的所有模式当然都是与我们在前几章中看到的开发模型正交的；换句话说，你可以使用它们中的任何一个，无论使用哪种模型。
- en: 'Let''s start with one of the most natural architectural considerations: encapsulation
    and hexagonal architectures.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最自然的架构考虑因素之一开始：封装和六边形架构。
- en: Encapsulation and hexagonal architectures
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和六边形架构
- en: '**Encapsulation** is a concept taken for granted by programmers who are used
    to working with object-oriented programming and, indeed, it is quite a basic idea.
    When talking about encapsulation, your mind goes to the getters and setters methods.
    To put it simply, you can hide fields in your class, and control how the other
    objects interact with them. This is a basic way to protect the status of your
    object (internal data) from the outside world. In this way, you decouple the state
    from the behavior, and you are free to switch the data type, validate the input,
    change formats, and so on. In short, it''s easy to understand the advantages of
    this approach.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**是习惯于使用面向对象编程的程序员所接受的概念，确实，它是一个非常基本的概念。当谈到封装时，你的思维会转向获取器和设置器方法。简单来说，你可以在你的类中隐藏字段，并控制其他对象如何与之交互。这是一种基本的方法，可以保护你的对象状态（内部数据）不受外界影响。这样，你就可以将状态与行为解耦，你可以自由地切换数据类型、验证输入、更改格式等等。简而言之，这种方法的优点很容易理解。'
- en: However, encapsulation is a concept that goes beyond simple getters and setters.
    I personally find some echoes of this concept in other modern approaches, such
    as APIs and microservices (more on this in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*). In my opinion, encapsulation (also known
    as **information hiding**) is all about modularization, in that it's about having
    objects talk to each other by using defined contracts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，封装是一个超越简单获取器和设置器的概念。我个人在其他现代方法中找到了这个概念的回声，例如API和微服务（更多内容请参阅[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，*设计云原生架构*）。在我看来，封装（也称为**信息隐藏**）完全是关于模块化的，因为它涉及到通过定义的合约让对象相互通信。
- en: If those contracts (in this case, normal method signatures) are stable and generic
    enough, objects can change their internal implementation or can be swapped with
    other objects without breaking the overall functionality. That is, of course,
    a concept that fits nicely with interfaces. An interface can be seen as a *super
    contract* (a set of methods) and a way to easily identify compatible objects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些合约（在这种情况下，普通方法签名）足够稳定和通用，对象可以更改其内部实现或与其他对象交换而不破坏整体功能。当然，这是一个非常适合接口的概念。接口可以被视为一种*超级合约*（一组方法）以及识别兼容对象的一种方式。
- en: 'In my personal view, the concept of encapsulation is extended with the idea
    of hexagonal architectures. Hexagonal architectures, theorized by Alistair Cockburn
    in 2005, visualize an application component as a hexagon. The following diagram
    illustrates this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我个人看来，封装的概念通过六边形架构的想法得到了扩展。六边形架构是由Alistair Cockburn在2005年提出的理论，它将应用程序组件可视化为六边形。以下图解说明了这一点：
- en: '![Figure 6.1 – Hexagonal architecture schema'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 六边形架构图'
- en: '](img/Figure_6.01_B16354.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B16354.jpg)'
- en: Figure 6.1 – Hexagonal architecture schema
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 六边形架构图
- en: 'As you can see in the preceding diagram, the business logic stays at the core
    of this representation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，业务逻辑是这个表示的核心：
- en: '**Core**: The core can be intended to be the domain model, as seen in [*Chapter
    4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089), *Best Practices for Design
    and Development*. It''s the real distinctive part of your application component
    – the one solving the business problem.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心**：核心可以是指领域模型，如在第[*第4章*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089)中看到的，*设计和开发最佳实践*。它是您应用程序组件的真实独特部分——解决业务问题的那部分。'
- en: '**Port**: Around the core, the ports are represented. The domain model uses
    the ports as a way to communicate with other application components, being other
    modules or systems (such as databases and other infrastructures). The ports are
    usually mapped to use cases of the module itself (such as sending payments). However,
    more technical interpretations of ports are not unusual (such as persisting to
    a database).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：在核心周围表示端口。领域模型使用端口作为与其他应用程序组件（如其他模块或系统，例如数据库和其他基础设施）通信的方式。端口通常映射到模块本身的用例（例如发送支付）。然而，端口的技术解释并不罕见（例如持久化到数据库）。'
- en: '**Adapter**: The layer outside the ports represents the adapters. The Adapter
    is a well-known pattern in which a piece of software acts as an interpreter between
    two different sides. In this case, it translates from the domain model to the
    outside world, and vice versa, according to what is defined in each port. While
    the diagram is in the shape of a hexagon, that''s not indicative of being limited
    to six ports or adapters. That''s just a graphical representation, probably related
    to the idea of representing the ports as discrete elements (which is hard to do
    if you represent the layers as concentric circles). The hexagonal architecture
    is also known as **Ports and Adapters**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：端口外层的层代表适配器。适配器是一种广为人知的模式，其中软件作为两个不同方面之间的解释器。在这种情况下，它根据每个端口中定义的内容将领域模型转换为外部世界，反之亦然。虽然这个图是六边形的形状，但这并不表明它仅限于六个端口或适配器。这只是一个图形表示，可能与其将端口表示为离散元素（如果你将层表示为同心圆则很难做到）的想法有关。六边形架构也被称为**端口和适配器**。'
- en: 'Important Note:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示：
- en: 'There is another architectural model implementing encapsulation that is often
    compared to hexagonal architectures: **Onion architectures**. Whether the hexagonal
    architecture defines the roles mentioned earlier, such as core, ports, and adapters,
    the Onion architecture focuses the modeling on the concept of layers. There is
    an inner core (the Domain layer) and then a number of layers around it, usually
    including a repository (to access the data of the Domain layer), services (to
    implement business logic and other interactions), and a presentation layer (for
    interacting with the end user or other systems). Each layer is supposed to communicate
    only with the layer above itself.'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另有一种实现封装的架构模型，常与六边形架构相比较：**洋葱架构**。无论六边形架构是否定义了之前提到的角色，如核心、端口和适配器，洋葱架构将建模重点放在层概念上。有一个内部核心（领域层），然后是围绕它的多个层，通常包括存储库（以访问领域层的数据）、服务（以实现业务逻辑和其他交互）和表示层（与最终用户或其他系统交互）。每个层只应与它上面的层进行通信。
- en: Hexagonal architectures and Domain Driven Design
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 六边形架构和领域驱动设计
- en: Encapsulation is a cross-cutting concern, applicable to many aspects of a software
    architecture, and hexagonal architectures are a way to implement this concept.
    As we have seen, encapsulation has many touchpoints with the concept of **Domain-Driven
    Design** (**DDD**). The core, as mentioned, can be seen as the domain model in
    DDD. The Adapter pattern is also very similar to the concept of the Infrastructure
    layer, which in DDD is the layer mapping the domain model with the underlying
    technology (and abstracting such technology details).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是一个横切关注点，适用于软件架构的许多方面，而六边形架构是实现这一概念的一种方式。正如我们所见，封装与**领域驱动设计**（**DDD**）的概念有很多接触点。核心，正如所提到的，可以看作是DDD中的领域模型。适配器模式也非常类似于基础设施层的概念，在DDD中，这一层是将领域模型与底层技术（以及抽象这些技术细节）映射的层。
- en: It's then worth noticing that DDD is a way more complete approach, as seen in
    [*Chapter 4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089), *Best Practices
    for Design and Development*, tackling things such as defining a language for creating
    domain model concepts and implementing some peculiar use cases (such as where
    to store data, where to store implementations, how to make different models talk
    to each other). Conversely, hexagonal architectures are a more practical, immediate
    approach that may directly address a concern (such as implementing encapsulation
    in a structured way), but do not touch other aspects (such as how to define the
    objects in the core).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，DDD是一种更完整的方法，如[*第4章*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089)，“设计和开发的最佳实践”中所示，它处理诸如定义创建领域模型概念的语言和实现一些特殊用例（如数据存储的位置、实现存储的位置、如何使不同的模型相互通信）等问题。相反，六边形架构是一种更实际、更直接的方法，可以直接解决一个关注点（如以结构化的方式实现封装），但不涉及其他方面（如如何定义核心中的对象）。
- en: Encapsulation and microservices
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装和微服务
- en: While we are going to talk about microservices in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, I'm sure you are familiar with, or at
    least have heard about, the concept of microservices. In this section, it's relevant
    to mention that the topic of encapsulation is one of the core reasonings behind
    microservices. Indeed, a microservice is considered to be a disposable piece of
    software, easy to scale and to interoperate with other similar components through
    a well-defined API.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，“设计云原生架构”中讨论微服务时，我相信你已经熟悉，或者至少听说过微服务的概念。在本节中，提到封装是微服务背后的核心理由之一是相关的。确实，一个微服务被认为是一块可丢弃的软件，易于扩展，并且可以通过一个定义良好的API与其他类似组件进行交互。
- en: Moreover, each microservice composing an application is (in theory) a product,
    with a dedicated team behind it and using a set of technologies (including the
    programming language itself) different from the other microservices around it.
    For all those reasons, encapsulation is the basis of the microservices applications,
    and the concepts behind it (as the ones that we have seen in the context of hexagonal
    architectures) are intrinsic in microservices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组成应用程序的每个微服务（在理论上）都是一个产品，它背后有一个专门的团队，并使用一套技术（包括编程语言本身），与周围的微服务不同。出于所有这些原因，封装是微服务应用程序的基础，其背后的概念（如我们在六边形架构的上下文中看到的）是微服务内在的。
- en: So, as you now know, the concept of modularization is in some way orthogonal
    to software entities. This need to define clear responsibilities and specific
    contracts is a common way to address complexity, and it has a lot of advantages,
    such as testability, scaling, extensibility, and more. Another common way to define
    roles in a software system is the multi-tier architecture.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你现在所知道的，模块化的概念在某种程度上与软件实体是正交的。这种定义清晰责任和具体契约的需求是解决复杂性的常见方法，并且它有很多优点，如可测试性、可扩展性、可扩展性等。在软件系统中定义角色的另一种常见方法是多层架构。
- en: Learning about multi-tier architectures
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解多层架构
- en: '**Multi-tier architectures**, also known as **n-tier architectures**, are a
    way to categorize software architectures based on the number and kind of tiers
    (or layers) encompassing the components of such a system. A tier is a logical
    grouping of the software components, and it''s usually also reflected in the physical
    deployment of the components. One way of designing applications is to define the
    number of tiers composing them and how they communicate with each other. Then,
    you can define which component belongs to which tier. The most common types of
    multi-tier applications are defined in the following list:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**多层架构**，也称为**n层架构**，是根据包含系统组件的层数和类型来分类软件架构的一种方式。层是软件组件的逻辑分组，通常也反映在组件的物理部署中。设计应用程序的一种方法是为它们定义层数以及它们如何相互通信。然后，您可以定义哪个组件属于哪个层。以下列表中定义了最常见的多层应用程序类型：'
- en: The simplest (and most useless) examples are **single-tier applications**, where
    every component falls into the same layer. So, you have what is called a monolithic
    application.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单（也是最无用的）例子是**单层应用程序**，其中每个组件都属于同一层。因此，您拥有所谓的单体应用程序。
- en: Things get slightly more interesting in the next iteration, that is, **two-tier
    applications**. These are commonly implemented as client-server systems. You will
    have a layer including the components provided to end users, usually through some
    kind of graphical or textual user interfaces, and a layer including the backend
    systems, which normally implement the business rules and the transactional functionalities.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一个迭代中，事情会变得稍微有趣一些，即**两层应用程序**。这些通常作为客户端-服务器系统实现。您将有一个包含提供给最终用户的组件的层，通常通过某种图形或文本用户界面，以及一个包含后端系统的层，这些系统通常实现业务规则和事务功能。
- en: '**Three-tier applications** are a very common architectural setup. In this
    kind of design, you have a presentation layer taking care of interaction with
    end users. We also have a business logic layer implementing the business logic
    and exposing APIs consumable by the presentation layer, and a data layer, which
    is responsible for storing data in a persistent way (such as in a database or
    on a disk).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三层应用程序**是一种非常常见的架构设置。在这种设计中，您有一个负责与最终用户交互的表现层。我们还有一个实现业务逻辑并暴露给表现层使用的API的业务逻辑层，以及一个负责以持久方式存储数据的数据层（例如在数据库或磁盘上）。'
- en: More than three layers can be contemplated, but that is less conventional, meaning
    that the naming and roles may vary. Usually, the additional tiers are specializations
    of the business logic tier, which was seen in the previous point. An example of
    a four-tier application was detailed in [*Chapter 4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089),
    *Best Practices for Design and Development*, when talking about the layered architecture
    of DDD.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以考虑超过三层，但这不太常见，意味着命名和角色可能有所不同。通常，额外的层是业务逻辑层的特殊化，这在前面已经提到。一个四层应用程序的例子在[*第4章*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089)，*设计和开发的最佳实践*中详细描述，当时讨论了DDD的分层架构。
- en: 'The following diagram illustrates the various types of multi-tier architectures:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了各种类型的多层架构：
- en: '![Figure 6.2 – Multi-tier architectures'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 多层架构'
- en: '](img/Figure_6.02_B16354.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B16354.jpg)'
- en: Figure 6.2 – Multi-tier architectures
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 多层架构
- en: 'The advantages of a multi-tier approach are similar to those that you can achieve
    with the modularization of your application components (more on this in [*Chapter
    9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing Cloud-Native Architectures*).
    Some of the advantages are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多层架构的优点与通过模块化您的应用程序组件所能实现的优势相似（更多关于这一点请参阅[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，*设计云原生架构*）。以下是一些优点：
- en: 'The most relevant advantage is probably **scalability**. This kind of architecture
    allows each layer to scale independently from each other. So, if you have more
    load on the business (or frontend, or database) layer, you can scale it (vertically,
    by adding more computational resources, or horizontally, by adding more instances
    of the same component) without having a huge impact on the other components. And
    that is also linked to increased stability overall: an issue on one of the layers
    is not so likely to influence the other layers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最相关的优势可能是**可扩展性**。这种架构允许每一层独立于其他层进行扩展。因此，如果你在业务（或前端，或数据库）层有更多的负载，你可以对其进行扩展（垂直扩展，通过添加更多计算资源，或水平扩展，通过添加更多相同组件的实例），而不会对其他组件产生巨大影响。这也与整体稳定性的提高有关：一个层的问题不太可能影响其他层。
- en: Another positive impact is improved **testability**. Since you are forced to
    define clearly how the layers communicate with each other (such as by defining
    some APIs), it becomes easier to test each layer individually by using the same
    communication channel.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个积极的影响是提高了**可测试性**。由于你必须明确定义层之间如何通信（例如，通过定义一些API），因此使用相同的通信通道单独测试每个层变得更加容易。
- en: '**Modularity** is also an interesting aspect. Having layers talking to each
    other will enforce a well-defined API to decouple each other. For this reason,
    it is possible (and is very common) to have different actors on the same layer,
    interacting with the other layer. The most widespread example here is related
    to the frontend. Many applications have different versions of the frontend (such
    as a web GUI and a mobile app) interacting with the same underlying layer.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**也是一个有趣的方面。层与层之间的交互将强制执行一个定义良好的API来解耦它们。因此，在同一层上可以有不同角色，与另一层交互。最普遍的例子是前端。许多应用程序有不同的前端版本（如Web
    GUI和移动应用）与同一底层层交互。'
- en: Last but not least, by **layering** your application, you will end up having
    more parallelization in the development process. Sub teams can work on a layer
    without interfering with each other. The layers, in most cases, can be released
    individually, reducing the risks associated with a big bang release.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，通过**分层**你的应用程序，你将在开发过程中获得更多的并行化。子团队可以在不相互干扰的情况下工作在某一层。在大多数情况下，层可以单独发布，从而降低与一次性发布相关联的风险。
- en: There are, of course, drawbacks to the multi-tier approach, and they are similar
    to the ones you can observe when adopting other modular approaches, such as microservices.
    The main disadvantage is to do with **tracing**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，多级方法也有其缺点，它们与采用其他模块化方法时观察到的缺点相似，例如微服务。主要缺点与**跟踪**有关。
- en: It may become hard to understand the end-to-end path of each transaction, especially
    (as is common) if one call in a layer is mapped to many calls in other layers.
    To mitigate this, you will have to adopt specific monitoring to trace the path
    of each call; this is usually done by injecting unique IDs to correlate the calls
    to each other to help when troubleshooting is needed (such as when you want to
    spot where the transactions slow down) and in general to give better visibility
    into system behavior. We will study this approach (often referred to as tracing
    or observability) in more detail in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 理解每个事务的端到端路径可能变得很困难，特别是如果一层中的一个调用映射到其他层中的多个调用（这是常见的）。为了减轻这种情况，你必须采用特定的监控来跟踪每个调用的路径；这通常是通过注入唯一的ID来关联调用，以帮助在需要故障排除时（例如，当你想找出事务变慢的地方）以及在一般情况下提供更好的系统行为可见性。我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)中更详细地研究这种方法（通常称为跟踪或可观察性），*设计云原生架构*。
- en: 'In the next section, we will have a look at a widespread pattern: Model View
    Controller.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一个广泛使用的模式：模型-视图-控制器。
- en: Exploring Model View Controller
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模型-视图-控制器
- en: At first glance, **Model View Controller** (**MVC**) may show some similarities
    with the classical three-tier architecture. You have the classification of your
    logical objects into three kinds and a clear separation between presentation and
    data layers. However, MVC and the three-tier architecture are two different concepts
    that often coexist.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，**模型-视图-控制器**（**MVC**）可能显示出与经典三层架构的一些相似之处。你的逻辑对象被分为三类，并且表示层和数据层之间有明确的分离。然而，MVC和三层架构是两个不同的概念，它们经常共存。
- en: The three-tier architecture is an architectural style where the elements (presentation,
    business, and data) are split into different deployable artifacts (possibly even
    using different languages and technologies). These elements are often executed
    on different servers in order to achieve the already discussed goals of scalability,
    testability, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 三层架构是一种架构风格，其中元素（表示层、业务层和数据层）被分割成不同的可部署组件（可能使用不同的语言和技术）。这些元素通常在不同的服务器上执行，以实现已经讨论过的可扩展性、可测试性等目标。
- en: On the other hand, MVC is not an architectural style, but a design pattern.
    For this reason, it does not suggest any particular deployment model regarding
    its components, and indeed, very often the Model, View, and Controller coexist
    in the same application layer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MVC不是一种架构风格，而是一种设计模式。因此，它不提出任何特定的组件部署模型，实际上，模型、视图和控制器经常共存于同一应用程序层。
- en: Taking apart the *philosophical* similarity and differences, from a practical
    point of view, MVC is a common pattern for designing and implementing the presentation
    layer in a multi-tier architecture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，剥离哲学上的相似性和差异，MVC是多层架构中设计和实现表示层的常见模式。
- en: 'In MVC, the three essential components are listed as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC中，三个基本组件如下列出：
- en: '**Model**: This component takes care of abstracting access to the data used
    by the application. There is no logic to the data presented here.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**: 此组件负责抽象化应用程序使用的数据访问。这里展示的数据没有逻辑。'
- en: '**View**: This component takes care of the interaction with the users (or other
    external systems), including the visual representation of data (if expected).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**: 此组件负责与用户（或其他外部系统）的交互，包括数据的视觉表示（如果需要）。'
- en: '**Controller**: This component receives the commands (often mediated by the
    view) from the users (or other external systems) and updates the other two components
    accordingly. The **Controller** is commonly seen as a facilitator (or glue) between
    the **Model** and **View** components.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**: 此组件接收来自用户（或其他外部系统）的命令（通常由视图中介），并相应地更新其他两个组件。**控制器**通常被视为**模型**和**视图**组件之间的促进者（或粘合剂）。'
- en: 'The following diagram shows you the essential components of MVC:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了MVC的基本组件：
- en: '![Figure 6.3 – MVC components'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – MVC组件'
- en: '](img/Figure_6.03_B16354.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.03_B16354.jpg)'
- en: Figure 6.3 – MVC components
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – MVC组件
- en: 'Another difference between MVC and the three-tier architecture is clear from
    the interaction of the three components described previously: in a three-tier
    architecture, the interaction is usually linear; that is, the presentation layer
    does not interact directly with the data layer. MVC classifies the kind and goal
    of each interaction but also allows all three components to interact with each
    other, forming a triangular model.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: MVC与三层架构之间的另一个区别可以从前面描述的三个组件的交互中清楚地看出：在三层架构中，交互通常是线性的；也就是说，表示层不直接与数据层交互。MVC对每种交互的类型和目标进行分类，但同时也允许所有三个组件相互交互，形成一个三角形模型。
- en: MVC is commonly implemented by a framework or middleware and is used by the
    developer, specific interfaces, hooks, conventions, and more.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: MVC通常通过框架或中间件实现，并由开发者使用特定接口、钩子、约定等使用。
- en: In the real world, this pattern is commonly implemented either at the server
    side or the client side.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，此模式通常在服务器端或客户端实现。
- en: Server-side MVC
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端MVC
- en: The **Java Enterprise Edition** (**JEE**) implementation is a widely used example
    (even if not really a modern one) of an MVC server-side implementation. In this
    section, we are going to mention some *classical* Java implementations of web
    technologies (such as JSPs and servlets) that are going to be detailed further
    in [*Chapter 10*](B16354_10_Final_JM_ePUB.xhtml#_idTextAnchor250), *Implementing
    User Interaction*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java企业版**（**JEE**）实现是MVC服务器端实现的一个广泛使用的例子（即使它不是一个真正的现代例子）。在本节中，我们将提到一些*经典*的Java
    Web技术实现（如JSP和servlets），这些将在[*第10章*](B16354_10_Final_JM_ePUB.xhtml#_idTextAnchor250)
    *实现用户交互*中进一步详细说明。'
- en: 'In terms of relevance to this chapter, it''s worthwhile knowing that in the
    JEE world, the MVC model is implemented using Java beans, the view is in the form
    of JSP files, and the controller takes the form of servlets, as shown in the following
    diagram:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就本章的相关性而言，了解在JEE世界中，MVC模型使用Java beans实现，视图以JSP文件的形式存在，控制器以servlets的形式存在，如下所示：
- en: '![Figure 6.4 – MVC with JEE'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 使用JEE的MVC'
- en: '](img/Figure_6.04_B16354.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.04_B16354.jpg)'
- en: Figure 6.4 – MVC with JEE
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 使用JEE的MVC
- en: As you can see, in this way, the end user interacts with the web pages generated
    by the **JSPs** (the **View**), which are bound to the Java **Beans** (the **Model**)
    keeping the values displayed and collected. The overall flow is guaranteed by
    the **Servlets** (the **Controller**), which take care of things such as the binding
    of the Model and View, session handling, page routing, and other aspects that
    *glue* the application together. Other widespread Java MVC frameworks, such as
    **Spring MVC**, adopt a similar approach.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过这种方式，最终用户与由**JSPs**（视图）生成的网页交互，这些视图绑定到Java **Beans**（模型），保持显示和收集的值。整体流程由**Servlets**（控制器）保证，它们负责诸如模型和视图的绑定、会话处理、页面路由以及其他将应用程序粘合在一起的方面。其他广泛使用的Java
    MVC框架，如**Spring MVC**，采用类似的方法。
- en: Client-side MVC
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端MVC
- en: MVC can also be completely implemented on the client side, which usually means
    that all three roles are played by a web browser. The de facto standard language
    for client-side MVC is **JavaScript**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MVC也可以完全在客户端实现，这通常意味着所有三个角色都由一个网络浏览器扮演。客户端MVC的事实标准语言是**JavaScript**。
- en: Client-side MVC is almost identical to **single-page applications**. We will
    see more about single-page applications in [*Chapter 10*](B16354_10_Final_JM_ePUB.xhtml#_idTextAnchor250),
    *Implementing User Interaction*, but basically, the idea is to minimize page changes
    and full-page reloads in order to provide a near-native experience to users while
    keeping the advantages of a web application (such as simplified distribution and
    centralized management).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端MVC几乎与**单页应用程序**相同。我们将在[*第10章*](B16354_10_Final_JM_ePUB.xhtml#_idTextAnchor250)中了解更多关于单页应用程序的内容，*实现用户交互*，但基本想法是尽量减少页面更改和完整页面重新加载，以便在保持Web应用程序（如简化分发和集中管理）优势的同时，为用户提供接近原生的体验。
- en: The single-page applications approach is not so different from server-side MVC.
    This technology commonly uses a templating language for views (similar to what
    we have seen with JSPs on the server side), a model implementation for keeping
    data and storing it in local browser storage or remotely calling the remaining
    APIs exposed from the backend, and controllers for navigation, session handling,
    and more support code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序方法与服务器端MVC并没有太大的不同。这项技术通常使用模板语言来处理视图（类似于我们在服务器端看到的JSPs），用于保持数据和将其存储在本地浏览器存储或远程调用后端暴露的剩余APIs的模型实现，以及用于导航、会话处理和其他支持代码的控制器。
- en: In this section, you learned about MVC and related patterns, which are considered
    a classical implementation for applications and have been useful for nicely setting
    up all the components and interactions, separating the user interface from the
    implementation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了MVC和相关模式，这些被认为是应用程序的经典实现，并且对于很好地设置所有组件和交互、将用户界面与实现分离非常有用。
- en: In the next section, we will have a look at the event-driven and reactive approaches.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨事件驱动和响应式方法。
- en: Diving into event-driven and reactive approaches
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨事件驱动和响应式方法
- en: '**Event-driven architecture** isn''t a new concept. My first experiences with
    it were related to GUI development (with **Java Swing**) a long time ago. But,
    of course, the concept is older than that. And the reason is that events, meaning
    *things that happen*, are a pretty natural phenomenon in the real world.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动架构**不是一个新概念。我第一次接触它是在很久以前与GUI开发（使用**Java Swing**）相关。但当然，这个概念比那还要古老。原因是事件，即*发生的事情*，在现实世界中是一种相当自然的现象。'
- en: There is also a technological reason for the event-driven approach. This way
    of programming is deeply related to (or in other words, is most advantageous when
    used together with) asynchronous and non-blocking approaches, and these paradigms
    are inherently efficient in terms of the use of resources.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动方法还有一个技术原因。这种编程方式与（或者说，最有利于与）异步和非阻塞方法密切相关，而这些范例在资源使用方面本质上效率很高。
- en: 'Here is a diagram representing the event-driven approach:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个表示事件驱动方法的图表：
- en: '![Figure 6.5 – Event -driven approach'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – 事件驱动方法'
- en: '](img/Figure_6.05_B16354.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.05_B16354.jpg)'
- en: Figure 6.5 – Event-driven approach
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 事件驱动方法
- en: As shown in the previous diagram, the whole concept of the event-driven approach
    is to have our application architecture react to external events. When it comes
    to GUIs, such events are mostly user inputs (such as clicking a button, entering
    data in text fields, and so on), but events can be many other things, such as
    changes in the price of a stock option, a payment transaction coming in, data
    being collected from sensors, and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，事件驱动方法的整体概念是让我们的应用程序架构对外部事件做出反应。当涉及到GUI时，这些事件主要是用户输入（如点击按钮、在文本字段中输入数据等），但事件可以是许多其他事情，如股票期权价格的变动、支付交易的到来、从传感器收集的数据等。
- en: Another pattern worth mentioning is the **actor model** pattern, which is another
    way to use messaging to maximize the concurrency and throughput of a software
    system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的模式是**actor模型**模式，这是另一种使用消息来最大化软件系统并发性和吞吐量的方式。
- en: I like to think that **reactive programming** is an evolution of all this. Actually,
    it is probably an evolution of many different techniques.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢认为**响应式编程**是这一切的进化。实际上，它可能是对许多不同技术的进化。
- en: It is a bit harder to define reactive, probably because this approach is still
    relatively new and less widespread. Reactive has its roots in functional programming,
    and it's a complete paradigm shift from the way you think about and write your
    code right now. While it's out of the scope of this book to introduce functional
    programming, we will try to understand some principles of reactive programming
    with the usual goal of giving you some more tools you can use in your day-to-day
    architect life and that you can develop further elsewhere if you find them useful
    for solving your current issues.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 定义响应式可能有点困难，可能是因为这种方法仍然相对较新且不太普及。响应式编程的根源在于函数式编程，并且它是一种从你现在思考和使用代码的方式的完全范式转变。虽然介绍函数式编程超出了本书的范围，但我们将尝试理解响应式编程的一些原则，以通常的目标为你提供一些你可以在日常架构生活中使用的工具，如果你发现它们对你的当前问题有用，你还可以在其他地方进一步开发。
- en: 'But first, let''s start with a cornerstone concept: events.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们从一个基石概念开始：事件。
- en: Defining events, commands, and messages
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义事件、命令和消息
- en: From a technological point of view, an event can be defined as something that
    changes the status of something. In an event-driven architecture, such a change
    is then propagated (notified) as a message that can be picked up by components
    *interested* in that kind of event.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，一个事件可以定义为改变某物状态的东西。在一个事件驱动的架构中，这种变化随后被传播（通知）为一个可以被对这种事件感兴趣的部分捕获的消息。
- en: For this reason, the terms **event-driven** and **message-driven** are commonly
    used interchangeably (even if the meaning may be slightly different).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，术语**事件驱动**和**消息驱动**通常可以互换使用（即使意义可能略有不同）。
- en: So, an **event** can be seen as a more abstract concept to do with new information,
    while a message can be seen as how this information is propagated throughout our
    system. Another core concept is the **command**. Roughly speaking, a command is
    the expression of an action, while an event is an expression of something happening
    (such as a change in the status of something).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个**事件**可以被视为与新的信息有关的一个更抽象的概念，而一个消息可以被视为这种信息在我们系统中传播的方式。另一个核心概念是**命令**。简而言之，命令是对动作的表达，而事件是对发生的事情（如某物状态的改变）的表达。
- en: So, an event reflects a change in data (and somebody downstream may need to
    be notified of the change and need to do something accordingly), while a command
    explicitly asks for a specific action to be done by somebody downstream.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个事件反映了数据的变化（并且下游的某人可能需要被通知这种变化并相应地采取行动），而一个命令明确要求某人下游执行特定的动作。
- en: Again, generally speaking, an event may have a broader audience (many consumers
    might be interested in it), while a command is usually targeted at a specific
    system. Both types of messages are a nice way to implement loose coupling, meaning
    it's possible to switch at any moment between producer and consumer implementations,
    given that the contract (the message format) is respected. It could be even done
    live with zero impact on system uptime. That's why the usage of messaging techniques
    is so important in application design.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一般来说，一个事件可能有更广泛的受众（可能许多消费者对此感兴趣），而命令通常针对特定的系统。这两种类型的消息都是实现松耦合的好方法，这意味着在尊重合同（消息格式）的情况下，可以在任何时刻在生产者和消费者实现之间切换。甚至可以在不影响系统正常运行时间的情况下实时进行。这就是为什么在应用程序设计中使用消息技术如此重要的原因。
- en: Since these concepts are so important and there are many different variations
    on brokers, messages, and how they are propagated and managed, we will look at
    more on messaging in [*Chapter 8*](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200),
    *Designing Application Integration and Business Automation*. Now, let's talk about
    the event-driven approach in detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些概念非常重要，并且关于代理、消息以及它们如何传播和管理有许多不同的变体，我们将在[*第8章*](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200)中进一步探讨消息传递，*设计应用程序集成和业务自动化*。现在，让我们详细谈谈事件驱动方法。
- en: Introducing the event-driven pattern and event-driven architecture
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍事件驱动模式和事件驱动架构
- en: The **event-driven pattern** is a pattern and architectural style focused on
    reacting to things happening around (or inside of) our application, where notifications
    of actions to be taken appear in the form of events.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动模式**是一种模式和架构风格，专注于对发生在我们应用程序周围（或内部）的事情做出反应，其中要执行的操作的通告以事件的形式出现。'
- en: In its simplest form, expressed in imperative languages (as is widespread in
    embedded systems), event-driven architecture is managed via infinite loops in
    code that continuously poll against event sources (queues), and actions are performed
    when messages are received.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，用命令式语言（如嵌入式系统中广泛使用的那样）表达，事件驱动架构通过代码中的无限循环来管理，这些循环持续轮询事件源（队列），并在接收到消息时执行操作。
- en: However, **event-driven architecture** is orthogonal to the programming style,
    meaning that it can be adopted both in imperative models and other models, such
    as object-oriented programming.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**事件驱动架构**与编程风格正交，这意味着它可以在命令模型和其他模型（如面向对象编程）中采用。
- en: With regard to **Object-Oriented Programming** (**OOP**), there are plenty of
    Java-based examples when it comes to user interface development, with a widely
    known one being the Swing framework. Here you have objects (such as buttons, windows,
    and other controls) that provide handlers for user events. You can register one
    or more handlers (consumers) with those events, which are then executed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**面向对象编程**（**OOP**），在用户界面开发方面有很多基于Java的例子，其中广为人知的一个是Swing框架。在这里，你有对象（如按钮、窗口和其他控件），它们为用户事件提供处理程序。你可以为这些事件注册一个或多个处理程序（消费者），然后执行这些处理程序。
- en: From the point of view of the application flow, you are not defining the order
    in which the methods are executing. You are just defining the possibilities, which
    are then executed and composed according to the user inputs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序流程的角度来看，你并不是定义方法的执行顺序。你只是在定义可能性，然后根据用户输入执行和组合这些可能性。
- en: But if you abstract a bit, many other aspects of Java programming are event-driven.
    Servlets inherently react to events (such as an incoming HTTP request), and even
    error handling, with try-catch, defines the ways to react if an unplanned event
    occurs. In those examples, however, the events are handled internally by the framework,
    and you don't have a centralized middleware operating them (such as a messaging
    broker or queue manager). Events are simply a way to define the behavior of an
    application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你稍微抽象一下，Java编程的许多其他方面都是事件驱动的。Servlets本质上是响应事件的（例如，一个传入的HTTP请求），甚至错误处理，通过try-catch，定义了在意外事件发生时的响应方式。然而，在这些例子中，事件是由框架内部处理的，你没有中央中间件来操作它们（例如，消息代理或队列管理器）。事件只是定义应用程序行为的一种方式。
- en: Event-driven architecture can be extended as an architectural style. Simply
    put, an event-driven architecture prescribes that all interactions between the
    components of your software system are done via events (or commands). Such events,
    in this case, are mediated by a central messaging system (a broker, or bus).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构可以作为一种架构风格进行扩展。简单来说，事件驱动架构规定你的软件系统组件之间的所有交互都通过事件（或命令）来完成。在这种情况下，这些事件由一个中央消息系统（代理或总线）来协调。
- en: In this way, you can extend the advantages of the event-driven pattern, such
    as loose coupling, better scalability, and a more natural way to represent the
    use case, beyond a single software component. Moreover, you will achieve the advantage
    of greater visibility (as you can inspect the content and number of messages exchanged
    between the pieces of your architecture). You will also have better manageability
    and uptime (because you can start, stop, and change every component without directly
    impacting the others, as a consequence of loose coupling).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以扩展事件驱动模式的优势，如松散耦合、更好的可扩展性和更自然地表示用例，而不仅仅是单个软件组件。此外，你还将获得更大的可见性优势（因为你可以检查架构各部分之间交换的消息内容和数量）。你还将拥有更好的可管理性和可用性（因为你可以启动、停止和更改每个组件，而不会直接影响到其他组件，这是松散耦合的结果）。
- en: Challenges of the event-driven approach
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件驱动方法面临的挑战
- en: So far, we have seen the advantages of the event-driven approach. In my personal
    opinion, they greatly outweigh the challenges that it poses, so I strongly recommend
    using this kind of architecture wherever possible. As always, take into account
    that the techniques and advice provided in this book are seldom entirely prescriptive,
    so in the real world I bet you will use some bits of the event-driven pattern
    even if you are using other patterns and techniques as your main choice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了事件驱动方法的优势。就我个人而言，它们的优势远大于它带来的挑战，所以我强烈建议在可能的情况下使用这种架构。一如既往，请注意，本书中提供的技巧和建议很少是完全规定性的，所以在现实世界中，我敢打赌你即使使用其他模式和技巧作为主要选择，也会使用一些事件驱动模式的部分。
- en: 'However, for the sake of completeness, I think it is worth mentioning the challenges
    I have faced while building event-driven architectures in the past:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了完整性，我认为值得提及我在过去构建事件驱动架构时遇到的挑战：
- en: '**Message content**: It''s always challenging to define what should be inside
    a message. In theory, you should keep the message as simple and as light as possible
    to avoid hogging the messaging channels and achieve better performance. So, you
    usually have only a message type and references to data stored elsewhere.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息内容**：始终很难定义消息中应该包含什么。理论上，你应该尽可能保持消息简单和轻量，以避免占用消息通道并实现更好的性能。因此，你通常只有消息类型和指向存储在其他地方的数据的引用。'
- en: However, this means that downstream systems may not have all the data needed
    for the computation in the message, and so they would complete the data from external
    systems (typically, a database). Moreover, most of the messaging frameworks and
    APIs (such as **JMS**) allow you to complete your message with metadata, such
    as headers and attachments. I've seen endless discussions about what should go
    into a message and what the metadata is. Of course, I don't have an answer here.
    My advice, as always, is to keep it as simple as possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着下游系统可能没有所需的所有数据来完成消息中的计算，因此它们会从外部系统（通常是数据库）中补充数据。此外，大多数消息框架和API（如**JMS**）允许你通过元数据（如头和附件）来完善你的消息。我见过无数关于消息中应该包含什么以及元数据是什么的讨论。当然，我这里没有答案。我的建议，一如既往，是尽可能保持简单。
- en: '**Message format**: Related to the previous point, the message format is also
    very relevant. Hence, after you establish what information type should be contained
    in each message, the next step is to decide the shape this information should
    have. You will have to define a message schema, and this should be understandable
    by each actor. Also, message validation could be needed (to understand whether
    each message is a formally valid one), and a schema repository could be useful,
    in order to have a centralized infrastructure that each actor can access to extract
    metadata about how each message should be formatted.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息格式**：与前面的观点相关，消息格式也非常重要。因此，在你确定每条消息应包含哪种信息类型之后，下一步就是决定这些信息应具有的形状。你需要定义一个消息架构，并且每个参与者都应该能够理解它。此外，可能需要进行消息验证（以了解每条消息是否是形式上有效的），并且一个架构存储库可能很有用，以便每个参与者都可以访问它，提取有关如何格式化每条消息的元数据。'
- en: '**Transactional behavior**: The write or read of a message, in abstract, constitutes
    access to external storage (not so different from accessing a database). For this
    reason, if you are building a traditional enterprise application, when you are
    using messaging, you will need to extend your transactional behavior.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务行为**：在抽象上，消息的写入或读取构成了对外部存储的访问（与访问数据库没有太大区别）。因此，如果你正在构建一个传统的企业应用，当你使用消息传递时，你需要扩展你的事务行为。'
- en: It's a very common situation that if your consumer needs to update the database
    as a consequence of receiving a message, you will have a transaction encompassing
    the read of the message and the write to the database. If the write fails, you
    will roll back the read of the message. In the Java world, you will implement
    this with a two-phase commit. While it's a well-known problem and many frameworks
    offer some facilities to do this, it's still not a simple solution; it can be
    hard to troubleshoot (and recover from) and can have a non-negligible performance
    hit.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的消费者需要因为接收消息而更新数据库时，这是一个非常常见的情况，你将会有一个包含读取消息和写入数据库的操作的事务。如果写入失败，你需要回滚读取消息的操作。在Java领域，你会通过两阶段提交来实现这一点。虽然这是一个众所周知的问题，许多框架也提供了一些工具来解决这个问题，但这仍然不是一个简单的解决方案；它可能很难调试（和恢复），并且可能会对性能产生不可忽视的影响。
- en: '**Tracing**: If the system starts dispatching many messages between many systems,
    including intermediate steps such as message transformations and filtering, it
    may become difficult to reconstruct a user transaction end to end. This could
    lead to a lack of visibility (from a logical/use case point of view) and make
    troubleshooting harder. However, you can easily solve this aspect with the propagation
    of transaction identifiers in messages and appropriate logging.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：如果系统开始在许多系统之间分发大量消息，包括中间步骤，如消息转换和过滤，那么从头到尾重建用户事务可能会变得困难。这可能导致从逻辑/用例角度来看的可视性不足，并使调试更加困难。然而，你可以通过在消息中传播事务标识符和适当的日志记录轻松解决这个问题。'
- en: '**Security**: You will need to apply security practices at many points. In
    particular, you may want to authenticate the connections to the messaging system
    (both for producing and consuming messages), define access control for authorization
    (you can read and write only to authorized destinations), and even sign messages
    to ensure the identity of the sender. This is not a big deal, honestly, but is
    one more thing to take into account.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：你需要在许多地方应用安全实践。特别是，你可能想要验证连接到消息系统的连接（无论是生产还是消费消息），定义访问控制以进行授权（你只能读取和写入授权的目的地），甚至签名消息以确保发送者的身份。说实话，这并不是什么大问题，但又是需要考虑的一件事。'
- en: As you can see, the challenges are not impossible to face, and the advantages
    will probably outweigh them for you. Also, as we will see in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, many of these challenges are not exclusive
    to event-driven architecture, as they are also common in distributed architectures
    such as microservices.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这些挑战并非不可能面对，而且对于你来说，优势可能会超过这些挑战。此外，正如我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)“设计云原生架构”中看到的，许多这些挑战并非仅限于事件驱动架构，它们在分布式架构（如微服务）中也同样常见。
- en: Event-driven and domain model
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件驱动和领域模型
- en: We have already discussed many times the importance of correctly modeling a
    business domain, and how this domain is very specific to the application boundaries.
    Indeed, in [*Chapter 4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089), *Best
    Practices for Design and Development*, we introduced the idea of bounded context.
    Event-driven architectures are dealing almost every time with the exchange of
    information between different bounded contexts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次讨论了正确建模业务领域的重要性，以及这个领域如何非常具体地对应于应用边界。实际上，在[*第4章*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089)《设计和开发最佳实践》中，我们介绍了边界上下文的概念。事件驱动架构几乎每次都在处理不同边界上下文之间信息交换的问题。
- en: As already discussed, there are a number of techniques for dealing with such
    kinds of interactions between different bounded contexts, including the shared
    kernel, customer suppliers, conformity, and anti-corruption layer. As already
    mentioned, unfortunately, a perfect approach does not exist for ensuring that
    different bounded contexts can share meaningful information but stay correctly
    decoupled.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，处理不同边界上下文之间此类交互的技术有很多，包括共享内核、客户供应商、一致性以及反腐败层。正如已经提到的，不幸的是，不存在一种完美的方法来确保不同的边界上下文可以共享有意义的信息，同时保持正确的解耦。
- en: My personal experience is that the often-used approach here is the shared kernel.
    In other words, a new object is defined and used as an event format. Such an object
    contains the minimum amount of information needed for the different bounded contexts
    to communicate. This does not necessarily mean that the communication will work
    in every case and no side effects will occur, but it's a solution good enough
    in most cases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的经验是，这里常用的方法是共享内核。换句话说，定义并使用一个新的对象作为事件格式。这样的对象包含不同边界上下文之间通信所需的最小信息量。这并不一定意味着在所有情况下通信都会成功，并且不会发生副作用，但它在大多数情况下是一个足够好的解决方案。
- en: In the next section, we are going to touch on a common implementation of the
    event-driven pattern, known as the actor model.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论事件驱动模式的一种常见实现，即演员模型。
- en: Building on the event-driven architecture – the actor model
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于事件驱动架构——演员模型
- en: The **actor model** is a stricter implementation of the event-driven pattern.
    In the actor model, the actor is the most elementary unit of computation, encapsulating
    the state and behavior. An actor can communicate with other actors only through
    messages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**演员模型**是事件驱动模式的一种更严格的实现。在演员模型中，演员是最基本的计算单元，封装了状态和行为。演员只能通过消息与其他演员进行通信。'
- en: An actor can create other actors. Each actor encapsulates its internal status
    (no actor can directly manipulate the status of another actor). This is usually
    a nice and elegant way to take advantage of multithreading and parallel processing,
    thereby maintaining integrity and avoiding explicit locks and synchronizations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以创建其他演员。每个演员封装其内部状态（没有演员可以直接操作另一个演员的状态）。这通常是一种很好且优雅的方式，可以充分利用多线程和并行处理，从而保持完整性，避免显式的锁和同步。
- en: In my personal experience, the actor model is a bit too prescriptive when it
    comes to describing bigger use cases. Moreover, some requirements, such as session
    handling and access to relational databases, are not an immediate match with the
    actor model's logic (though they are still implementable within it). You will
    probably end up implementing some components (maybe core ones) with the actor
    model while having others that use a less rigorous approach, for the sake of simplicity.
    The most famous actor model implementation with Java is probably **Akka**, with
    some other frameworks, such as **Vert.x**, taking some principles from it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我个人的经验中，当描述更大的用例时，演员模型（actor model）有点过于规定性。此外，一些要求，如会话处理和访问关系数据库，与演员模型的逻辑并不完全匹配（尽管它们仍然可以在其中实现）。你可能最终会使用演员模型来实现一些组件（可能是核心组件），而其他组件则采用不那么严格的方法，以简化流程。最著名的Java演员模型实现可能是**Akka**，还有一些其他框架，如**Vert.x**，从中吸取了一些原则。
- en: So far, we have elaborated on generic messaging with both the event-driven approach
    and the actor model.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经详细介绍了事件驱动方法和演员模型中的通用消息传递。
- en: It is now important, for the purpose of this chapter, to introduce the concept
    of **streaming**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了本章的目的，引入**流式处理**的概念是很重要的。
- en: Introducing streaming
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入流式处理
- en: '**Streaming** has grown more popular with the rise of Apache Kafka even if
    other popular alternatives, such as Apache Pulsar, are available. Streaming shares
    some similarities with messaging (there are still producers, consumers, and messages
    flowing, after all), but it also has some slight differences.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**流式传输**随着Apache Kafka的兴起而变得更加流行，即使其他流行的替代品，如Apache Pulsar，也是可用的。流式传输与消息传递有一些相似之处（毕竟，仍然有生产者、消费者和流动的消息），但它也有一些细微的差异。'
- en: From a purely technical point of view, streaming has one important difference
    compared with messaging. In a streaming system, messages persist for a certain
    amount of time (or, if you want, a specified number of messages can be maintained),
    regardless of whether they have been consumed or not.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的技术角度来看，流式传输与消息传递有一个重要的区别。在流式传输系统中，消息会持续一段时间（或者，如果你愿意，可以保持指定数量的消息），无论它们是否已被消费。
- en: This creates a kind of *sliding window*, meaning that consumers of a streaming
    system can rewind messages, following the flow from a previous point to the current
    point. This means that some of the information is moved from the messaging system
    (the broker, or bus) to the consumers (which have to maintain a cursor to keep
    track of the messages read and can move back in time).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这创造了一种**滑动窗口**，意味着流式传输系统的消费者可以回放消息，从先前的一个点跟随流向当前点。这意味着一些信息从消息系统（代理或总线）移动到消费者（消费者必须维护一个游标以跟踪读取的消息并可以回溯时间）。
- en: This behavior also enables some advanced use cases. Since consumers can see
    a consolidated list of messages (the stream, if you like), complex logic can be
    applied to such messages. Different messages can be combined for computation purposes,
    different streams can be merged, and advanced filtering logic can be implemented.
    Moreover, the offloading of part of the logic from the server to the consumers
    is one factor that enables the management of high volumes of messages with low
    latencies, allowing for near real-time scenarios.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为也使得一些高级使用场景成为可能。因为消费者可以看到消息的汇总列表（如果你愿意，就是流），可以对这类消息应用复杂的逻辑。不同的消息可以为了计算目的而组合，不同的流可以合并，并且可以实现高级过滤逻辑。此外，将部分逻辑从服务器卸载到消费者，是能够以低延迟管理大量消息的一个因素，允许实现近乎实时的场景。
- en: Given those technical differences, streaming also offers some conceptual differences
    that lead to use cases that are ideal for modeling with this kind of technology.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些技术差异，流式传输还提供了一些概念上的差异，这些差异导致了一些非常适合用这种技术建模的使用场景。
- en: With streams, the events (which are then propagated as messages) are seen as
    a whole information flow as they usually have a constant rate. And moreover, a
    single event is normally less important than the sequence of events. Last but
    not least, the ability to rewind the event stream leads to better consistency
    in distributed environments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流，事件（随后作为消息传播）被视为一个整体的信息流，因为它们通常有一个恒定的速率。而且更重要的是，单个事件通常不如事件序列重要。最后但同样重要的是，能够回放事件流的能力，使得分布式环境中的一致性更好。
- en: Imagine adding more instances of your application (scaling). Each instance can
    reconstruct the status of the data by looking at the sequence of messages collected
    until that moment, in an approach commonly defined as **Event Sourcing**. This
    is also a commonly used pattern to improve resiliency and return to normal operations
    following a malfunction or disaster event. This characteristic is one of the reasons
    for the rising popularity of streaming systems in microservice architectures.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下添加更多应用程序实例（扩展）。每个实例都可以通过查看收集到那一刻的消息序列来重建数据的状态，这种方法通常被定义为**事件溯源**。这也是在故障或灾难事件后提高弹性和恢复正常操作的一种常用模式。这种特性是流式传输系统在微服务架构中日益流行的一个原因。
- en: Touching on reactive programming
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简要提及响应式编程
- en: I like to think of **reactive programming** as event-driven architecture being
    applied to data streaming. However, I'm aware that that's an oversimplification,
    as reactive programming is a complex concept, both from a theoretical and technological
    point of view.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将**响应式编程**视为将事件驱动架构应用于数据流。然而，我意识到这只是一个过于简化的说法，因为响应式编程是一个复杂的概念，从理论和技术的角度来看都是如此。
- en: To fully embrace the benefits of reactive programming, you have to both master
    the tools for implementing it (such as **RxJava**, **Vert.x**, or even **BaconJS**)
    and switch your reasoning to the reactive point of view. We can do this by modeling
    all our data as streams (including changes in variables content) and writing our
    code on the basis of a declarative approach.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分享受响应式编程的好处，你必须同时掌握实现它的工具（例如 **RxJava**、**Vert.x** 或甚至 **BaconJS**）并切换你的推理到响应式视角。我们可以通过将所有数据建模为流（包括变量内容的变更）并在声明式方法的基础上编写代码来实现这一点。
- en: Reactive programming considers data streams as the primary construct. This makes
    the programming style an elegant and efficient way to write asynchronous code,
    by observing streams and reacting to signals. I understand that this is not easy
    at all to grasp at first glance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程将数据流视为主要结构。这使得编程风格成为观察流并对信号做出反应的优雅且高效的方式，从而编写异步代码。我理解这并不容易一眼看懂。
- en: 'It''s also worth noting that the term *reactive* is also used in the context
    of reactive systems, as per the **Reactive** **Manifesto**, produced in 2014 by
    the community to implement responsive and distributed systems. The Reactive Manifesto
    focuses on building systems that are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，术语 *响应式* 也在响应式系统的上下文中使用，正如2014年由社区发布的 **响应式** **宣言**，旨在实现响应式和分布式系统。响应式宣言侧重于构建以下系统：
- en: '**Responsive**: This means replying with minimal and predictable delays to
    inputs (in order to maximize the user experience).'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：这意味着以最小和可预测的延迟对输入做出响应（为了最大限度地提高用户体验）。'
- en: '**Resilient**: This means that a failure in one of the components is handled
    gracefully and impacts the whole system''s availability and responsiveness as
    little as possible.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这意味着一个组件的失败会被优雅地处理，对整个系统的可用性和响应性的影响尽可能小。'
- en: '**Elastic**: This means that the system can adapt to variable workloads, keeping
    constant response times.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这意味着系统可以适应可变的工作负载，保持恒定的响应时间。'
- en: '**Message-driven**: This means that systems that adhere to the manifesto use
    a message-driven communication model (hence achieving the same goals as described
    in the *Introducing the event-driven pattern and event-driven architecture* section).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：这意味着遵循宣言的系统使用基于消息的通信模型（因此实现了在 *介绍事件驱动模式和事件驱动架构* 部分中描述的相同目标）。'
- en: While some of the goals and techniques of the Reactive Manifesto resonate with
    the concepts we have explored so far, reactive systems and reactive programming
    are different things.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然响应式宣言的一些目标和技巧与我们迄今为止探讨的概念相呼应，但响应式系统和响应式编程是不同的事物。
- en: The Reactive Manifesto does not prescribe any particular approach to achieve
    the preceding four goals, while reactive programming does not guarantee, per se,
    all the benefits pursued by the Reactive Manifesto.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式宣言并没有规定达到前面四个目标的具体方法，而响应式编程本身也不保证实现响应式宣言所追求的所有好处。
- en: A bit confusing, I know. So, now that we've understood the differences between
    a reactive system (as per the Reactive Manifesto) and reactive programming, let's
    shift our focus back to reactive programming.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这有点令人困惑。所以，现在我们已经理解了响应式系统（根据响应式宣言）和响应式编程之间的区别，让我们将注意力转回响应式编程。
- en: As we have said, the concept of data streaming is central to reactive programming.
    Another fundamental ingredient is the **declarative approach** (something similar
    to functional programming). In this approach, you express what you want to achieve
    instead of focusing on all the steps needed to get there. You declare the final
    result (leveraging standard constructs such as filter, map, and join) and attach
    it to a stream of data to which it will be applied.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，数据流的概念是响应式编程的核心。另一个基本成分是 **声明式方法**（类似于函数式编程）。在这种方法中，你表达你想要实现的目标，而不是关注达到目标所需的所有步骤。你声明最终结果（利用如过滤、映射和连接等标准结构），并将其附加到将要应用的数据流上。
- en: The final result will be compact and elegant, even if it may not be immediate
    in terms of readability. One last concept that is crucial in reactive programming
    is **backpressure**. This is basically a mechanism for standardizing communication
    between producers and consumers in a reactive programming model in order to regulate
    flow control.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果将既紧凑又优雅，即使它在可读性方面可能不是立即的。在响应式编程中至关重要的最后一个概念是 **背压**。这基本上是一种标准化响应式编程模型中生产者和消费者之间通信的机制，以调节流量控制。
- en: This means that if a consumer can't keep up with the pace of messages received
    from the producer (typically because of a lack of resources), it can send a notification
    about the problem upstream so that it can be managed by the producer or any other
    intermediate entity in the stream chain (in reactive programming, an event stream
    can be manipulated by intermediate functions). In theory, backpressure can bubble
    up to the first producer, which can also be a human user in the case of interactive
    systems.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果消费者无法跟上从生产者接收到的消息速度（通常是因为资源不足），它可以向上游发送一个关于问题的通知，以便由生产者或流链中的任何其他中间实体（在响应式编程中，事件流可以被中间函数操作）来管理。从理论上讲，背压可以向上冒泡到第一个生产者，在交互式系统中，这也可以是人工用户。
- en: When a producer is notified of backpressure, it can manage the issue in different
    ways. The most simple is to slow down the speed and just send less data, if possible.
    A more elaborate technique is to buffer the data, waiting for the consumer to
    get up to speed (for example, by scaling its resources). A more destructive approach
    (but one that is effective nevertheless) is to drop some messages. However, this
    may not be the best solution in every case.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当生产者被通知背压时，它可以以不同的方式来处理这个问题。最简单的方法是减慢速度，如果可能的话，发送更少的数据。一种更复杂的技术是缓冲数据，等待消费者赶上速度（例如，通过扩展其资源）。一种更具破坏性的方法（但仍然有效）是丢弃一些消息。然而，这可能在每种情况下都不是最佳解决方案。
- en: With that, we have finished our quick look at reactive programming. I understand
    that some concepts have been merely mentioned, and things such as the functional
    and declarative approaches may require at least a whole chapter on their own.
    However, a full deep dive into the topic is beyond the scope of this book. I hope
    I gave you some hints to orient yourself toward the best architectural approach
    when it comes to message- and event-centric use cases.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经快速浏览了响应式编程。我理解有些概念只是被提及，像函数式和声明式方法可能至少需要一整章来单独介绍。然而，对这个主题的全面深入研究超出了本书的范围。我希望我给了您一些提示，帮助您在消息和事件为中心的使用案例中找到最佳的架构方法。
- en: In this section, you learned about the basic concepts and terms to do with reactive
    and event-driven programming, which, if well understood and implemented, can be
    used to create high-performance applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了与响应式和事件驱动编程相关的基本概念和术语，如果理解并实施得当，可以用来创建高性能应用程序。
- en: In the next section, we will start discussing how to optimize our architecture
    for performance and scalability purposes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始讨论如何为了性能和可扩展性目的优化我们的架构。
- en: Designing for large-scale adoption
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计适用于大规模采用
- en: So far, in this chapter, we have discussed some widespread patterns and architectural
    styles that are well used in the world of enterprise Java applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经讨论了一些在企业Java应用领域中广泛使用的模式和架构风格。
- en: One common idea around the techniques that we have discussed is to organize
    the code and the software components not only for better readability, but also
    for performance and scalability.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们讨论的技术的一个常见观点是，不仅要为了更好的可读性，还要为了性能和可扩展性来组织代码和软件组件。
- en: As you can see (and will continue to see) in this book, in current *web-scale*
    applications, it is crucial to think ahead in terms of planning to absorb traffic
    spikes, minimize resource usage, and ultimately have good performance. Let's have
    a quick look at what this all means in our context.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这本书中可以看到的（并且将继续看到），在当前的*大规模网络*应用中，提前规划以吸收流量高峰、最小化资源使用，并最终获得良好的性能至关重要。让我们快速了解一下在我们这个背景下这一切意味着什么。
- en: Defining performance goals
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义性能目标
- en: '**Performance** is a very broad term. It can mean many different things, and
    often you will want to achieve all performance goals at once, which is of course
    not realistic.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能**是一个非常广泛的概念。它可以意味着很多不同的事情，并且通常您会希望一次性实现所有性能目标，这当然是不现实的。'
- en: 'In my personal experience, there are some main performance indicators to look
    after, as they usually have a direct impact on the business outcome:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我个人的经验中，有一些主要性能指标需要关注，因为它们通常对业务结果有直接影响：
- en: '**Throughput**: This is measured as the number of transactions that can be
    managed per time unit (usually in seconds). The tricky part here is to define
    exactly what a transaction is in each particular context, as probably your system
    will manage different transaction types (with different resources being needed
    for each kind of transaction). Business people understand this metric instantaneously,
    knowing that having a higher throughput means that you will spend less on hardware
    (or cloud) resources.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：这是指每单位时间可以管理的交易数量（通常以秒为单位）。这里棘手的部分是确切地定义在每个特定上下文中什么是交易，因为很可能你的系统将管理不同类型的交易（每种交易都需要不同的资源）。商人会立即理解这个指标，知道更高的吞吐量意味着你将在硬件（或云）资源上的花费更少。'
- en: '**Response time**: This term means many different things. It usually refers
    to the time it takes to load your web pages or the time it takes to complete a
    transaction. This has to do with customer satisfaction (the quicker, the better).
    You may also have a contractual **Service** **Level** **Agreement** (**SLA**);
    for example, your system must complete a transaction in no more than *x* milliseconds.
    Also, you may want to focus on an average time or set a maximum time threshold.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应时间**：这个术语意味着很多不同的事情。它通常指的是加载你的网页所需的时间或完成交易所需的时间。这与客户满意度（越快越好）有关。你可能还有一个合同中的**服务**
    **水平** **协议**（**SLA**）；例如，你的系统必须在不超过*x*毫秒内完成交易。此外，你可能想要关注平均时间或设定一个最大时间阈值。'
- en: '**Elapsed time**: This basically means the amount of time needed to complete
    a defined chunk of work. This is common for batch computations (such as in big
    data or other calculations). This is kind of a mix of the previous two metrics.
    If you are able to do more work in parallel, you will spend less on your infrastructure.
    You may have a fixed deadline that you have to honor (such as finishing all your
    computations before a branch opens to the public).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已用时间**：这基本上指的是完成定义好的工作块所需的时间。这在批量计算（如在大数据或其他计算中）中很常见。这有点像是前两个指标的结合。如果你能够并行处理更多的工作，你将在基础设施上的花费会更少。你可能有一个固定的最后期限必须遵守（例如，在分支对公众开放之前完成所有计算）。'
- en: '**Performance tuning** is definitely a broad topic, and there is no magic formula
    to easily achieve the best performance. You will need to get real-world experience
    by experimenting with different configurations and get a lot of production traffic,
    as each case is different. However, here are some general considerations for each
    performance goal that we have seen:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能调优**绝对是一个广泛的话题，没有魔法公式可以轻松实现最佳性能。你需要通过实验不同的配置来获得实际经验，并处理大量的生产流量，因为每个案例都是不同的。然而，以下是我们看到每个性能目标的一些一般性考虑：'
- en: To enhance throughput, your best bet is to parallelize. This basically means
    leveraging threading where possible. It's unbelievable how often we tend to chain
    our calls in a sequential way. Unless it is strictly necessary (because of data),
    we should parallelize as much as we can and then merge the results.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高吞吐量，最好的办法是并行化。这基本上意味着尽可能利用线程。令人难以置信的是，我们往往倾向于以顺序方式链式调用。除非绝对必要（因为数据），我们应该尽可能并行化，然后合并结果。
- en: This entails, basically, splitting each call wherever possible (by delegating
    it to another thread), waiting for all the subcalls to complete in order to join
    the results in the main thread, and returning the main thread to the caller. This
    is particularly relevant where the subcalls involve calling to external systems
    (such as via web services). When parallelizing, the total elapsed time to answer
    will be equal to the longest subcall, instead of being the sum of the time of
    each subcall.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着尽可能在每个调用中分割（通过将其委托给另一个线程），等待所有子调用完成以便在主线程中合并结果，并将主线程返回给调用者。这在子调用涉及调用外部系统（如通过Web服务）的情况下尤其相关。在并行化时，回答的总已用时间将等于最长的子调用，而不是每个子调用时间的总和。
- en: 'In the next diagram, you can see how parallelizing calls can help in reducing
    the total elapsed time needed to complete the execution of an application feature:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个图表中，你可以看到并行化调用如何有助于减少完成应用程序功能执行所需的总已用时间：
- en: '![Figure 6.6 – Sequential versus parallel approach'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 – 顺序与并行方法'
- en: '](img/Figure_6.06_B16354.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.06_B16354.jpg)'
- en: Figure 6.6 – Sequential versus parallel approach
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 顺序与并行方法
- en: There should be a physical separation of our service based on the load and the
    performance expectations (something greatly facilitated by containers and microservices
    architecture). Instead of mixing all your APIs, you may want to dedicate more
    resources to the more critical ones (perhaps even dynamically, following the variation
    of traffic) by isolating them from the other services.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应根据负载和性能预期对服务进行物理分离（容器和微服务架构极大地促进了这一点）。您可能不想将所有API混合在一起，您可能希望为更关键的API分配更多资源（甚至可能是动态的，根据流量变化），通过将它们与其他服务隔离来实现。
- en: For better response times, async is the way to go. After reviewing the previous
    sections for advice, I suggest working with your business and functional analysts
    and fighting to have everything be as asynchronous as possible from a use case
    perspective.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更好的响应时间，异步是最佳选择。在回顾了前面的章节以获取建议后，我建议您与您的业务和功能分析师合作，争取从用例的角度使一切尽可能异步。
- en: It is very uncommon to have really strict requirements in terms of checking
    everything on every backend system before giving feedback to your users. Your
    best bet is to do a quick validation and reply with an acknowledgment to the customer.
    You will, of course, need an asynchronous channel (such as an email, a notification,
    or a webhook) to notify regarding progression of the transaction. There are countless
    examples in real life; for example, when you buy something online, often, your
    card funds won't even be checked in the first interaction. You are then notified
    by email that the payment has been completed (or has failed). Then, the package
    is shipped, and so on. Moreover, optimizing access to data is crucial; caching,
    pre-calculating, and de-duplicating are all viable strategies.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在向用户反馈之前，对每个后端系统进行全面检查的要求非常罕见。您的最佳选择是进行快速验证，并向客户回复确认。当然，您需要一个异步通道（如电子邮件、通知或webhook）来通知有关交易进度的信息。现实生活中有无数这样的例子；例如，当您在网上购买东西时，通常，您的卡资金甚至不会在第一次互动中被检查。然后，您会通过电子邮件收到付款已完成（或已失败）的通知。然后，包裹被发货，等等。此外，优化数据访问至关重要；缓存、预计算和去重都是可行的策略。
- en: 'When optimizing for elapsed time, you may want to follow the advice previously
    given: parallelizing and optimizing access to data is key. Also, here, you may
    want to rely on specialized infrastructure, such as scaling to have a lot of hardware
    (maybe in the cloud) and powering it off when it is not needed, or using infrastructures
    optimized for input/output. But the best advice is to work on the use case to
    maximize the amount of parallelizable work, possibly duplicating part of the information.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当优化经过时间时，您可能想要遵循之前给出的建议：并行化和优化数据访问是关键。在这里，您可能还想依赖专门的设施，比如扩展到拥有大量硬件（可能在云中）并在不需要时关闭电源，或者使用针对输入/输出优化的基础设施。但最好的建议是专注于用例，以最大化可并行化工作的数量，可能还需要复制部分信息。
- en: We will learn more about performance in [*Chapter 12*](B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292),
    *Cross-Cutting Concerns*. Let's now review some key concepts linked to scalability.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第12章*](B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292)中了解更多关于性能的内容，*跨切面关注点*。现在，让我们回顾一些与可伸缩性相关的关键概念。
- en: Stateless
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态
- en: '**Stateless** is a very recurrent concept (we will see it again in [*Chapter
    9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing Cloud-Native Architectures*).
    It is difficult to define with simple words, however.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**无状态**是一个非常常见的概念（我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)中再次看到，*设计云原生架构*）。它很难用简单的词语来定义，然而。'
- en: Let's take the example of an ATM versus a workstation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以自动柜员机和工作站为例。
- en: Your workstation is something that is usually difficult to replace. Yes, you
    have backups and you probably store some of your data online (in your email inbox,
    on the intranet, or on shared online drives). But still, when you have to change
    your laptop for a new one, you lose some time ensuring that you have copied any
    local data. Then, you have to export and reimport your settings, and so on. In
    other words, your laptop is very much stateful. It has a lot of local data that
    you don't want to lose.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您的工作站通常是难以替换的东西。是的，您有备份，您可能在网上存储了一些数据（在您的电子邮件收件箱中、内网上或共享的在线驱动器上）。但是，当您需要更换笔记本电脑时，您会花费一些时间确保已复制任何本地数据。然后，您必须导出并重新导入您的设置，等等。换句话说，您的笔记本电脑非常具有状态性。它有很多您不想丢失的本地数据。
- en: Now, let's think about an ATM. Before you insert your card, it is a perfectly
    empty machine. It then loads your data, allows cash withdrawal (or whatever you
    need), and then it goes back to the previous (empty) state, ready for the next
    client to serve. It is stateless from this point of view. It is also engineered
    to minimize the impact if something happens while you are using it. It's usually
    enough to end your current session and restart from scratch.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个ATM。在你插入卡片之前，它是一台完美的空机器。然后它加载你的数据，允许取款（或你需要的东西），然后它回到之前（空）的状态，准备好为下一个客户服务。从这个角度来看，它是无状态的。它也被设计成在使用过程中发生任何事情时最小化影响。通常，只需要结束当前会话并从头开始即可。
- en: 'But back to our software architecture: *how do we design an architecture to
    be stateless?*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但回到我们的软件架构：*我们如何设计一个无状态的架构？*
- en: 'The most common ways are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的方法如下：
- en: '**Push the state to clients**: This can mean having a cookie in the customer
    browser or having your APIs carry a token (such as a **JWT**). Every time you
    get a request, you may get to choose the best instance for your software (be it
    a container, a new JVM instance, or simply a thread) to handle it – *which will
    it be: the closest to the customer, the closest to the data, or simply the one
    with the least amount of load at that moment?*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将状态推送到客户端**：这可能意味着在客户浏览器中有一个cookie，或者你的API携带一个令牌（例如**JWT**）。每次你收到一个请求，你都可以选择处理它的最佳实例（无论是容器、新的JVM实例，还是简单的线程）——*它将是哪一个：最接近客户的，最接近数据的，或者简单地说，在那一刻负载最少的那个？*'
- en: '**Push the state to an external system**: You can offload the state to a dedicated
    system, such as a distributed cache. Your API (and business logic) only need to
    identify the user. All the session data is then loaded from a dedicated system.
    Any new instance can simply ask for the session data. Of course, your problem
    is then how to scale and maximize the uptime of such a caching system.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将状态推送到外部系统**：你可以将状态卸载到专用系统，例如分布式缓存。你的API（和业务逻辑）只需要识别用户。然后所有会话数据都从专用系统加载。任何新的实例都可以简单地请求会话数据。当然，你的问题是如何扩展并最大化这种缓存系统的正常运行时间。'
- en: Whatever your approach is, think always about the *phoenix*; that is, you should
    be able to reconstruct the data from the ashes (and quickly). In this way, you
    can maximize scaling, and as a positive side effect, you will boost availability
    and disaster recovery capabilities. As highlighted in the *Introducing streaming*
    section, events (and the event sourcing technique) are a good way to implement
    similar approaches. Indeed, provided that you have persisted all the changes in
    your data into a streaming system, such changes could be replayed in case of a
    disaster, and you can reconstruct the data from scratch.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的方法是什么，始终要想到*凤凰*；也就是说，你应该能够从灰烬中重建数据（并且快速）。这样，你可以最大化扩展性，作为一个积极的副作用，你将提高可用性和灾难恢复能力。正如在*介绍流*部分所强调的，事件（以及事件溯源技术）是实现类似方法的好方法。确实，如果你已经将你的数据更改持久化到流系统中，那么在灾难发生时，这些更改可以被重放，你可以从头开始重建数据。
- en: Beware of the concept of **stickiness** (pointing your clients to the same instance
    whenever possible). It's a quick win at the beginning, but it may lead you to
    unbalanced infrastructure and a lack of scalability. The next foundational aspect
    of performance is data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕**粘性**的概念（尽可能将客户端指向相同的实例）。一开始这可能是一个快速的成功，但它可能导致你的基础设施不平衡和缺乏可扩展性。性能的下一个基础方面是数据。
- en: Data
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据
- en: '**Data** is very often a crucial aspect of performance management. Slow access
    times to the data you need will frustrate all other optimizations in terms of
    parallelizing or keeping interactions asynchronous. Of course, each type of data
    has different optimization paths: indexing for relational databases, proximity
    for in-memory caching, and low-level tuning for filesystems.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**往往是性能管理的一个关键方面。对你所需数据的慢速访问将使所有其他关于并行化或保持交互异步的优化都感到沮丧。当然，每种类型的数据都有不同的优化路径：关系型数据库的索引，内存缓存的邻近性，以及文件系统的底层调整。'
- en: 'However, here are my considerations as regards the low-hanging fruit when optimizing
    access to data:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下是我关于优化数据访问的低垂果实的考虑：
- en: '**Sharding**: This is a foundational concept. If you can split your data into
    smaller chunks (such as by segmenting your users by geographical areas, sorting
    using alphabetical order, or using any other criteria compliant with your data
    model), you can dedicate a subset of the system (such as a database schema or
    a file) to each data shard.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片（Sharding）**：这是一个基础概念。如果你能将你的数据分成更小的块（例如，通过按地理区域划分用户、按字母顺序排序或使用任何符合你的数据模型的其他标准），你就可以为每个数据分片分配系统的一个子集（例如，数据库模式或文件）。'
- en: This will boost your resource usage by minimizing the interference between different
    data segments. A common strategy to properly cluster data in shards is **hashing**.
    If you can define a proper hashing function, you will have a quick and reliable
    way to identify where your data is located by mapping the result of the hashing
    operation to a specific system (containing the realm that is needed). If you still
    need to access data across different shards (such as for performing computations
    or for different representations of data), you may consider a different sharding
    strategy or even duplicating your data (but this path is always complex and risky,
    so be careful with that).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过最小化不同数据段之间的干扰来提高你的资源使用率。在分片中正确聚类数据的一个常见策略是**哈希（hashing）**。如果你可以定义一个合适的哈希函数，你将通过将哈希操作的结果映射到特定的系统（包含所需领域）来快速可靠地识别你的数据位置。如果你仍然需要访问不同分片中的数据（例如，进行计算或以不同的数据表示形式），你可以考虑不同的分片策略，甚至复制你的数据（但这条路径总是复杂且风险高，所以请小心）。
- en: '**Consistency point**: This is another concept to take care of. It may seem
    like a lower-level detail, but it''s worthwhile exploring. To put it simply: *how
    often do you need your data to persist?* Persistence particularly common in long
    transactions (such as ones involving a lot of submethods). Maybe you just don''t
    need to persist your data every time; you can keep it in the memory and batch
    all the persistence operations (this often includes writing to files or other
    intensive steps) together.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性点（Consistency point）**：这是另一个需要关注的点。它可能看起来像是一个更底层的细节，但值得探索。简单来说：*你需要多久持久化一次数据？*
    持久化在长事务中尤其常见（例如涉及许多子方法的事务）。也许你并不需要每次都持久化数据；你可以将其保存在内存中，并将所有持久化操作（这通常包括写入文件或其他密集型步骤）一起批量处理。'
- en: For sure, if the system crashes, you might lose your data (and whether to take
    this risk is up to you), but are you sure that incongruent data (which is what
    you'd have after saving only a part of the operations) is better than no data
    at all? Moreover, maybe you can afford a crash because your data has persisted
    elsewhere and can be recovered (think about streaming, which we learned about
    previously). Last but not least, *is it okay if your use case requires persistence
    at every step?* Just be aware of that. Very often, we simply don't care about
    this aspect, and we pay a penalty without even knowing it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果系统崩溃，你可能会丢失数据（是否承担这个风险取决于你），但你确定不完整的数据（即只保存部分操作后的数据）比没有数据更好吗？此外，也许你可以承受崩溃，因为你的数据在其他地方已经持续存在并且可以恢复（想想我们之前学过的流式传输）。最后但同样重要的是，*如果你的用例要求每一步都需要持久性，这可以吗？*
    只要注意这一点。很多时候，我们根本不在乎这个方面，甚至不知道我们为此付出了代价。
- en: '**Caching**: This is the most common technique. Memory is cheap, after all,
    and almost always has better access times than disk storage. So, you may just
    want to have a caching layer in front of your persistent storage (database, filesystem,
    or whatever). Of course, you will end up dealing with stale data and the propagation
    of changes, but it''s still a simple and powerful concept, so it''s worth a try.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存（Caching）**：这是最常见的技术。毕竟，内存很便宜，并且几乎总是比磁盘存储有更好的访问时间。所以，你可能在你的持久化存储（数据库、文件系统或任何其他）前面添加一个缓存层。当然，你最终会处理过时数据和变化的传播，但这仍然是一个简单而强大的概念，所以值得一试。'
- en: Caching may be implemented in different ways. Common implementations include
    caching data in the working memory of each microservice (in other words, in the
    heap, in the case of Java applications), or relying on external caching systems
    (such as client-server, centralized caching systems such as Infinispan or Redis).
    Another implementation makes use of external tools (such as Nginx or Varnish)
    sitting in front of the API of each microservice and caching everything at that
    level.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可以以不同的方式实现。常见的实现包括在每个微服务的运行内存中缓存数据（换句话说，在Java应用程序的情况下，在堆中），或者依赖于外部缓存系统（如客户端-服务器、集中式缓存系统，如Infinispan或Redis）。另一种实现方式是使用外部工具（如Nginx或Varnish）位于每个微服务API的前面，并在该级别缓存一切。
- en: 'We will see more about data in [*Chapter 11*](B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271),
    *Dealing with Data*, but for now, let me give you a spoiler about my favorite
    takeaway here: you must have multiple ways of storing and retrieving data and
    using it according to the constraints of your use case. Your mobile application
    has a very different data access pattern from a batch computation system. Now,
    let''s go to the next section and have a quick overview of scaling techniques.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第11章*](B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271)，“处理数据”中了解更多关于数据的内容，但就目前而言，让我给你透露一下我最喜欢的收获：你必须有多种存储和检索数据以及根据你的用例约束使用数据的方式。你的移动应用程序的数据访问模式与批处理计算系统非常不同。现在，让我们快速浏览一下下一节，对扩展技术进行简要概述。
- en: Scaling
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展
- en: '**Scaling** has been the main mantra so far for reaching performance goals
    and is one of the key reasons why you would want to architect your software in
    a certain way (such as in a multi-tier or async fashion). And honestly, I''m almost
    certain that you already know what scaling is and why it matters. However, let''s
    quickly review the main things to consider when we talk about scaling:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展**到目前为止一直是实现性能目标的主要咒语，也是你想要以某种方式（如多级或异步方式）架构你的软件的关键原因之一。说实话，我几乎可以肯定你已经知道什么是扩展以及为什么它很重要。然而，让我们快速回顾一下在讨论扩展时需要考虑的主要事项：'
- en: '**Vertical scaling** is, somewhat, the most traditional way of scaling. To
    achieve better performance, you need to add more resources to your infrastructure.
    While it is still common and advisable in some scenarios (such as when trying
    to squeeze more performance from databases, caches, or other stateful systems),
    it is seldom a long-term solution.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直扩展**在某种程度上是扩展的最传统方式。为了实现更好的性能，你需要向你的基础设施添加更多资源。尽管在某些情况下（例如，试图从数据库、缓存或其他有状态系统中挤出更多性能时）仍然很常见且建议使用，但它很少是长期解决方案。'
- en: You will hit a blocking limit sooner or later. Moreover, vertical scaling is
    not very dynamic, as you may need to purchase new hardware or resize your virtual
    machine, and maybe downtime will be needed to make effective changes. It is not
    something you can do in a few seconds to absorb a traffic spike.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你迟早会遇到一个瓶颈限制。此外，垂直扩展并不非常灵活，因为你可能需要购买新的硬件或调整你的虚拟机大小，可能还需要停机来实施有效的变更。这不是你可以在几秒钟内完成以吸收流量峰值的事情。
- en: '**Horizontal scaling** is way more popular nowadays as it copes well with cloud
    and PaaS architectures. It is also the basis of stateless, sharding, and the other
    concepts discussed previously. You can simply create another instance of a component,
    and that''s it. In this sense, the slimmer, the better. If your service is very
    small and efficient and takes a very short time to start (*microservices,* *anyone?*),
    it will nicely absorb traffic spikes.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平扩展**现在更为流行，因为它很好地适应了云和PaaS架构。它也是无状态、分片以及其他之前讨论的概念的基础。你可以简单地创建一个组件的另一个实例，就这样。在这种情况下，越瘦越好。如果你的服务非常小且高效，启动时间非常短（*微服务，有人吗？*），它将很好地吸收流量峰值。'
- en: You can take this concept to the extreme and shut down everything (thereby saving
    money) when you have no traffic. As we will see in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, scaling to zero (so that no instance is
    running if there are no requests to work with) is the concept behind serverless.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有流量时，你可以将这个概念发挥到极致，关闭一切（从而节省资金）。正如我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，“设计云原生架构”中看到，将扩展到零（即在没有请求处理时没有实例运行）是无服务器背后的概念。
- en: We are naturally led to think about scaling in a **reactive way**. You can get
    more traffic and react by scaling your components. The key here is identifying
    which metric to look after. It is usually the number of requests, but memory and
    CPU consumption are the other key metrics to look after. The advantage of this
    approach is that you will consume the resources needed for scaling *just in time*,
    hence you will mostly use it in an efficient way. The disadvantage is that you
    may end up suffering a bit if traffic increases suddenly, especially if the new
    instances take some time to get up and running.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们自然会想到以**反应式**的方式考虑扩展。你可以通过扩展你的组件来获得更多流量并做出反应。这里的关键是确定要关注的指标。这通常是请求数量，但内存和CPU消耗也是其他需要关注的指标。这种方法的优点是，你将仅在需要扩展时消耗所需的资源，因此你将主要以高效的方式使用它。缺点是，如果流量突然增加，你可能会有些不适，尤其是如果新实例需要一些时间才能启动和运行。
- en: The opposite of reactive scaling is, of course, **proactive scaling**. You may
    know in advance that a traffic spike is expected, such as in the case of Black
    Friday or during the tax payment season. If you manage to automate your infrastructure
    in the right way, you can schedule the proper growth of the infrastructure in
    advance. This may be even more important if scaling takes some time, as in vertical
    scaling. The obvious advantage of this approach is that you will be ready in no
    time in case of a traffic increase, as all the instances needed are already up
    and running. The disadvantage is that you may end up wasting resources, especially
    if you overestimate the expected traffic.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与反应式扩展相反的是，当然，是**主动扩展**。你可能事先知道会有流量激增，比如在黑色星期五或税收支付季节。如果你能以正确的方式自动化你的基础设施，你可以在事先安排适当的基础设施增长。如果扩展需要一些时间，比如垂直扩展，这可能更为重要。这种方法的明显优点是，在流量增加的情况下，你将立即做好准备，因为所有需要的实例都已经启动和运行。缺点是，你可能会浪费资源，特别是如果你高估了预期的流量。
- en: With this section, we achieved the goals of this chapter. There was quite a
    lot of interesting content. We started with hexagonal architectures (an interesting
    example of encapsulation), before moving on to multi-tier architectures (a very
    common way to organize application components). Then, you learned about MVC (a
    widely used pattern for user interfaces), event-driven (an alternative way to
    design highly performant applications), and finally, we looked at some common-sense
    suggestions about building highly scalable and performant application architectures.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本节，我们实现了本章的目标。有很多有趣的内容。我们以六边形架构（封装的一个有趣例子）开始，然后转向多层架构（组织应用程序组件的一种非常常见的方式）。然后，你了解了MVC（用户界面广泛使用的模式），事件驱动（设计高性能应用程序的另一种方式），最后，我们查看了一些关于构建高度可扩展和高效应用程序架构的常识性建议。
- en: It is not possible to get into all the details of all the topics discussed in
    this chapter. However, I hope to have given you the foundation you need to start
    experimenting and learning more about the topics that are relevant to you.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 无法深入了解本章讨论的所有主题的细节。然而，我希望我已经给了你开始实验和学习与你相关主题所需的基础。
- en: And now, let's have a look at some practical examples.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些实际例子。
- en: Case studies and examples
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究和例子
- en: As with other chapters in this book, let's end this chapter with some practical
    considerations about how to apply the concepts we've looked at to our recurrent
    example involving a mobile payment solution. Let's start with encapsulation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这本书中的其他章节一样，让我们以一些关于如何将我们探讨的概念应用到我们反复使用的涉及移动支付解决方案的例子中的实际考虑结束这一章。让我们从封装开始。
- en: Encapsulating with a hexagonal architecture
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用六边形架构进行封装
- en: 'A common way to map hexagonal concepts in Java is to encompass the following
    concept representations:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中映射六边形概念的一种常见方式是包括以下概念表示：
- en: The core maps into the domain model. So, here you have the usual entities (**Payment**,
    in our example), services (**PaymentService**, in this case), value objects, and
    so on. Basically, all the elements in the core are **Plain Old Java Objects**
    (**POJOs**) and some business logic implementations.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心映射到领域模型。因此，这里有你通常的实体（在我们的例子中是**Payment**），服务（在这种情况下是**PaymentService**），值对象等等。基本上，核心中的所有元素都是**Plain
    Old Java Objects**（**POJOs**）和一些业务逻辑实现。
- en: Here, the ports are the interfaces. They are somewhere in the middle, between
    a logical concept in the domain realm (enquire, notify, and store, in our example)
    and the respective technical concepts. This will promote the decoupling of the
    business logic (in the core) and the specific technology (which may change and
    evolve).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，端口是接口。它们位于中间，介于领域域中的逻辑概念（在我们的例子中是查询、通知和存储）和相应的技术概念之间。这将促进业务逻辑（在核心）和特定技术（可能发生变化和演变）的解耦。
- en: The adapters are implementations of such interfaces. So, an enquire interface
    will be implemented by **SoapAdapter**, **RestAdapter**, and **GraphQLAdapter**,
    in this particular case.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器是实现此类接口的实例。因此，在这个特定情况下，查询接口将由 **SoapAdapter**、**RestAdapter** 和 **GraphQLAdapter**
    实现。
- en: Outside of the hexagon, the external actors (such as the mobile app, databases,
    queues, or even external applications) interact with our application domain via
    the adapters provided.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在六角形外部，外部参与者（如移动应用、数据库、队列或甚至外部应用程序）通过提供的适配器与我们的应用领域进行交互。
- en: 'The following diagram illustrates the preceding points:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了前面的点：
- en: '![Figure 6.7 – Hexagonal architecture example'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – 六角架构示例'
- en: '](img/Figure_6.07_B16354.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.07_B16354.jpg]'
- en: Figure 6.7 – Hexagonal architecture example
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 六角架构示例
- en: 'Here are some key considerations:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关键考虑因素：
- en: The cardinality is completely arbitrary. You are not limited to six ports or
    adapters. Each port can map to one or more adapters. Each external system can
    be bound to one or more adapters. Each adapter can be consumed by more than one
    external system (they are not exclusive unless you want them to be).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器的数量是完全任意的。你不仅限于六个端口或适配器。每个端口可以映射到一个或多个适配器。每个外部系统可以绑定到一个或多个适配器。每个适配器可以被多个外部系统消费（除非你想让它们是专有的）。
- en: This logical grouping can be seen at the level that you want. This could be
    an application, meaning that everything inside the hexagon is deployed on a single
    artifact – an **Enterprise Application Archive** (**EAR**) or a **Java Application
    Archive** (**JAR**) – in a machine, or it could be a collection of different artifacts
    and machines (as in a microservices setup). In this case, most probably you will
    decouple your interfaces with REST or something similar, to avoid sharing dependencies
    across your modules.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑分组可以在你想要的层面上看到。这可能是一个应用程序，意味着六角形内部的所有内容都部署在单个工件上 – 一个 **企业应用程序存档** (**EAR**)
    或 **Java 应用程序存档** (**JAR**) – 在一台机器上，或者它可能是一组不同的工件和机器（如微服务设置）。在这种情况下，你很可能会使用 REST
    或类似技术解耦你的接口，以避免在模块之间共享依赖项。
- en: The advantage in terms of test coverage is obvious. You can switch each adapter
    into a mock system, to test in environments that don't have the complete infrastructure.
    So, you can test your notifications without the need for a queue, or test persistence
    without the need for a database. This, of course, will not replace end-to-end
    testing, in which you have to broaden your test and attach it to real adapters
    (such as in automating tests that call REST or SOAP APIs) or even external systems
    (such as in testing the mobile app or the web app itself).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试覆盖率方面，优势是显而易见的。你可以将每个适配器切换到模拟系统，以在缺乏完整基础设施的环境中测试。因此，你可以测试通知而无需队列，或者测试持久性而无需数据库。当然，这并不能取代端到端测试，在端到端测试中，你必须扩大你的测试范围，并将其附加到真实的适配器（例如在自动化测试中调用
    REST 或 SOAP API）或外部系统（例如在测试移动应用或网页应用本身）。
- en: As usual, I think that considering hexagonal modeling as a tool can be useful
    when implementing software architecture. Let's now have a quick look at multi-tier
    architecture.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我认为在实现软件架构时，将六角建模视为一个工具是有用的。现在让我们快速看一下多层架构。
- en: Componentizing with multi-tier architecture
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多层架构进行组件化
- en: '**Multi-tier architecture** gives us occasion to think about componentization
    and, ultimately, the evolution of software architectures. If we think about our
    mobile payment application, a three-tier approach may be considered a good fit.
    And honestly, it is. Historically, you probably wouldn''t have had many other
    options than a pure, centralized, client-server application. Even with a modern
    perspective, starting with a less complex approach, such as the three-tier one,
    it can be a good choice for two reasons:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**多层架构**让我们有机会思考组件化，最终是软件架构的演变。如果我们考虑我们的移动支付应用，三层方法可能是一个不错的选择。说实话，它确实是。从历史的角度来看，你可能没有太多其他选择，除了一个纯中央化的客户端-服务器应用。即使在现代的视角下，从一个更简单的方法开始，比如三层方法，它可能有两个原因是一个好的选择：'
- en: It can be considered a *prototypization* phase, with the goal of building a
    **Minimum Viable Product** (**MVP**). You will have something to showcase and
    test soon, which means you can check whether you have correctly understood the
    requirements or whether users like (and use) your product. Moreover, if you designed
    your application correctly (using well-designed APIs), maybe you can evolve your
    backend (toward multi-tier or microservices) with minimal impact on the clients.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以被视为一个*原型化*阶段，目标是构建**最小可行产品**（**MVP**）。你很快就会有一些东西可以展示和测试，这意味着你可以检查你是否正确理解了需求，或者用户是否喜欢（并使用）你的产品。此外，如果你正确地设计了你的应用（使用设计良好的API），也许你可以以最小的对客户端的影响来演变你的后端（向多层或微服务发展）。
- en: It can be a good benchmark for your domain definition. As per the famous Martin
    Fowler article (*Monolith First*), you may want to start with a simpler, all-in-one
    architecture in order to understand the boundaries of your business logic, and
    then correctly decomponentize it in the following phase (maybe going toward a
    cloud-native approach).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以成为你领域定义的好基准。根据著名的马丁·福勒文章（*Monolith First*），你可能想从一个更简单、一体化架构开始，以便理解你的业务逻辑的边界，然后在下一阶段正确地分解它（可能走向云原生方法）。
- en: 'In the next diagram, you can see a simple representation of an application''s
    evolution from three-tier to microservices:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图中，你可以看到应用程序从三层架构到微服务的演变过程的简单表示：
- en: '![Figure 6.8 – Tier segmentation evolution'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.8 – Tier segmentation evolution'
- en: '](img/Figure_6.08_B16354.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.8 – Tier segmentation evolution](img/Figure_6.08_B16354.jpg)'
- en: Figure 6.8 – Tier segmentation evolution
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 层分段演变
- en: 'As you can see in the previous diagram, each component change has a role and
    name. There are some key considerations to make about this kind of evolution:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一张图中看到的，每个组件的变化都有一个角色和名称。关于这种演变有一些关键考虑因素：
- en: We will see more about microservices in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*. For now, consider the fact that this example
    will only represent architectural evolution over time and how your tier segmentation
    can evolve. Microservices is probably not similar to multi-tier architecture,
    as some concepts (such as responsibilities in terms of data representation in
    views) are orthogonal to it (in other words, you can still have concepts from
    three-tier on top of microservices).
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)“设计云原生架构”中了解更多关于微服务的内容。现在，考虑这样一个事实，这个例子将只代表随着时间的推移架构的演变以及你的层分段如何演变。微服务可能并不类似于多层架构，因为一些概念（如视图中的数据表示的责任）与它是正交的（换句话说，你仍然可以在微服务之上有来自三层架构的概念）。
- en: We are starting with three tiers because it is simply an antipattern to have
    business logic mixed together with your data in terms of being deployed to the
    database (with stored procedures and such). However, in my opinion, having an
    external database does not constitute a data layer *per se*. So, in this example,
    the three-tier architecture can also be seen as a two-tier/client-server architecture,
    with the external database simply being a technological detail.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从三层开始，因为将业务逻辑与数据混合部署到数据库（使用存储过程等）是一种反模式。然而，在我看来，拥有一个外部数据库本身并不构成一个数据层。因此，在这个例子中，三层架构也可以被视为一个两层/客户端-服务器架构，外部数据库只是一个技术细节。
- en: In the real world, there is no defined boundary between one architectural view
    (such as three-tier) and another alternative (such as microservices). It's not
    as if one day you will transition from client-server (or three-tier) to microservices.
    You will probably start adding more layers, and then reorganize some capabilities
    into a complete microservice from the ground up and offload some capabilities
    to it.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中，一个架构视图（如三层）和另一个替代方案（如微服务）之间没有明确的界限。并不是说有一天你会从客户端-服务器（或三层）过渡到微服务。你可能会开始添加更多的层，然后将一些能力重新组织成从零开始构建的完整微服务，并将一些能力卸载到它上面。
- en: In general, it is possible to have a few differing architectural choices coexisting
    in the same application, perhaps just for a defined (limited) time, leading to
    a transition to a completely different architecture. In other words, your three-tier
    architecture can start with some modularized microservices alongside tiers (making
    it a hybrid architecture, bringing different styles together), and then the tiered
    part can be progressively reduced and the microservices part increased, before
    a final and complete move to a microservices implementation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在同一个应用程序中可以存在几个不同的架构选择，可能只是定义（有限）的时间，导致过渡到完全不同的架构。换句话说，你的三层架构可以从一些模块化的微服务开始，与层并存（使其成为混合架构，将不同的风格结合起来），然后逐步减少分层部分，增加微服务部分，最终完全迁移到微服务实现。
- en: Once again, this is designed to give you some food for thought as to how to
    use some key concepts seen in this chapter in the real world. It's important to
    understand that it's rare (and maybe wrong) to completely and religiously embrace
    just one model, for instance, starting with a pure three-tier model and staying
    with it even if the external conditions change (if you start using a cloud-like
    environment, for example).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是为了给你一些思考，关于如何在现实世界中应用本章中看到的一些关键概念。重要的是要理解，完全和虔诚地只拥抱一个模型是很罕见的（也许是不正确的），例如，从一个纯三层模型开始，即使外部条件发生变化（例如，如果你开始使用类似云的环境），也要坚持这个模型。
- en: Planning for performance and scalability
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能和可扩展性规划
- en: 'As seen in the previous sections, performance is a broad term. In our example,
    it is likely that we will want to optimize for both throughput and response time.
    It is, of course, a target that is not easy to reach, but it is a common request
    in this kind of project:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，性能是一个广泛的概念。在我们的例子中，我们可能希望同时优化吞吐量和响应时间。当然，这是一个不容易达到的目标，但在这个类型的项目中，这是一个常见的请求：
- en: '**Throughput** means a more sustainable business, with a lower cost for each
    transaction (considering hardware, power, software licenses, and so on).'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**意味着更可持续的业务，每个交易的代价更低（考虑到硬件、电力、软件许可等等）。'
- en: '**Response time** means having a happier customer base and, ultimately, the
    success of the project. Being an online product, it is expected today that access
    to this kind of service (whether it is for making a payment or accessing a list
    of transactions) happens with zero delay; every hiccup could lead a customer to
    switch to alternative platforms.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应时间**意味着拥有更满意的客户群，最终，项目的成功。作为一个在线产品，今天人们期望这种服务（无论是支付还是访问交易列表）能够实现零延迟；任何的延迟都可能导致客户转向替代平台。'
- en: Also, you may want to have a hard limit. It is common to have a timeout, meaning
    that if your payment takes more than 10 seconds, it is considered to have failed
    and is forcefully dropped. That's for limiting customer dissatisfaction and avoiding
    the overloading of the infrastructure.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能想要有一个硬性限制。设置超时是常见的，这意味着如果你的支付超过10秒，它被认为是失败的，并被强制取消。这是为了限制客户的不满，避免基础设施过载。
- en: '*But how do you design your software architecture to meet such objectives?*
    As usual, there is no magic recipe for this. Performance tuning is a continuous
    process in which you have to monitor every single component for performance and
    load, experiment to find the most efficient solution, and then switch to the next
    bottleneck. However, there are a number of considerations that can be made upfront:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是，你如何设计你的软件架构以满足这样的目标呢？* 通常，并没有什么神奇的配方。性能调优是一个持续的过程，在这个过程中，你必须监控每个组件的性能和负载，进行实验以找到最有效的解决方案，然后切换到下一个瓶颈。然而，有一些考虑因素可以在一开始就做出：'
- en: First of all, there is **transactional behavior**. We will see in [*Chapter
    9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing Cloud-Native Architectures*,
    how heavily decentralized architectures, such as microservices, do not cope well
    with long and distributed transactions. Even if you are not yet in such a situation
    and you are starting with a simpler, three-tier architecture, having long transaction
    boundaries will cause serialization in your code, penalizing your performance.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，是**事务行为**。我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，“设计云原生架构”中看到，高度去中心化的架构，如微服务，并不擅长处理长和分布式的事务。即使你还没有处于这种情况，而是从一个更简单的三层架构开始，拥有长事务边界将会导致代码的序列化，从而影响你的性能。
- en: To avoid this, you have to restrict the transaction as much as possible and
    handle consistency in different ways wherever possible. You may want to have your
    transaction encompass the payment request and the check of monetary funds (as
    in the classic examples about transactions), but you can take most of the other
    operations elsewhere. So, notifications and updates of non-critical systems (such
    as CRMs or data sources only used for inquiries) can be done outside of the transactions
    and retried in the case of failures.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，你应尽可能限制交易，并在可能的情况下以不同的方式处理一致性。你可能希望你的交易包括支付请求和货币资金的检查（如在关于交易的经典例子中），但你可以在其他地方进行大部分其他操作。因此，非关键系统的通知和更新（如仅用于查询的CRM或数据源）可以在交易之外完成，并在失败时重试。
- en: As a follow-up from the previous point, it should be taken into account that
    you don't have to penalize the most common cases to avoid very remote cases unless
    they have dramatic consequences. So, it is okay to check funds before making the
    payments in a strict way (as in the same transaction), because a malfunction there
    can cause bad advertising and a loss of trust in your platform, with potentially
    devastating consequences.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对前一点的补充，应该考虑到，除非有戏剧性的后果，否则你不需要惩罚最常见的案例以避免非常罕见的情况。因此，在严格的方式（如在同一交易中）进行支付前检查资金是完全可以接受的，因为那里的故障可能会导致不良的广告和对你平台的信任损失，从而产生潜在的灾难性后果。
- en: But you can probably afford to have a notification lost or sent twice from time
    to time if this means that 99% of the other transaction are performing better.
    And the rules can also be adapted to your specific context. Maybe the business
    can accept skipping some online checks (such as anti-fraud checks) in payment
    transactions of small amounts. The damage of some fraudulent transactions slipping
    through (or only being identified after the fact) may be lower than the benefit
    in terms of performance for the vast majority of licit traffic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你这意味着99%的其他交易表现更好，那么偶尔丢失或重复发送通知可能是可以接受的。规则也可以根据你的具体情况进行调整。也许业务可以接受在小额支付交易中跳过一些在线检查（如反欺诈检查）。一些欺诈交易溜走（或仅在事后被发现）的损失可能低于对大量合法流量在性能方面的好处。
- en: In terms of **asynchronous behavior**, as has been seen, it is expected that
    you only do synchronously what's essential to do synchronously. So, apart from
    the obvious things such as notifications, every other step should be made asynchronous
    if possible – for example, updating downstream systems.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**异步行为**方面，正如我们所看到的，预期你只做那些必须同步执行的事情。所以，除了通知等明显的事情之外，其他每一步如果可能的话都应该异步执行——例如，更新下游系统。
- en: So, in our use case, if we have a transactional database (or a legacy system)
    storing the user position that is used to authorize payments, it should be checked
    and updated synchronously to keep consistency. But if we have other systems, such
    as a CRM that stores the customer position, perhaps it's okay to place an update
    request in a queue and update that system after a few seconds, when the message
    is consumed and acted upon.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的用例中，如果我们有一个用于授权支付的存储用户位置的事务数据库（或遗留系统），那么它应该同步检查和更新以保持一致性。但如果我们有其他系统，例如存储客户位置的CRM，那么将更新请求放入队列并在消息被消费并采取行动后几秒钟更新该系统可能是可以接受的。
- en: Last but not least, in terms of **scaling**, the more your component will be
    stateless, the better. So, if we have each step of the payment process carrying
    over all the data needed (such as the customer identifier and transaction identifier),
    maybe we can minimize the lookups and checks on the external systems.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，在**扩展性**方面，组件越是无状态的，就越好。因此，如果我们让支付流程的每一步都携带所需的所有数据（例如客户标识符和交易标识符），也许我们可以最小化对外部系统的查找和检查。
- en: In the case of more load, we can (in advance, if it is planned, or reactively
    if it is an unexpected peak) create more instances of our components. Then, they
    will be immediately able to take over for the incoming requests, even if they
    originated from existing instances.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在负载更多的情况下，我们可以（如果事先有计划，则提前；如果是意外高峰，则反应性）创建更多组件的实例。然后，它们将能够立即接管传入的请求，即使这些请求来自现有的实例。
- en: So, if you imagine a payment transaction being completed in more than one step
    (as in first checking for the existence of the recipient, then making a payment
    request, then sending a confirmation), then it may be possible that each of those
    steps is worked on by different instances of the same component. Think about what
    would happen if you had to manage all those steps on the same instance that started
    the process because the component stored the data in an internal session. In cases
    of high traffic, new instances would not be able to help with the existing transactions,
    which would have to be completed where they originated. And the failure of one
    instance would likely create issues for users.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想象一个支付交易需要多步完成（例如，首先检查收款人的存在，然后发起支付请求，然后发送确认），那么可能每个步骤都是由同一组件的不同实例处理的。想想看，如果你必须管理所有这些步骤在同一个启动过程的实例上，因为组件将数据存储在内部会话中，会发生什么。在高流量情况下，新实例无法帮助处理现有交易，这些交易必须在其起源处完成。而且，一个实例的失败可能会给用户造成问题。
- en: This completes the content of this chapter. Let's quickly recap the key concepts
    that you have seen.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了本章的内容。让我们快速回顾一下你看到的关键概念。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have seen a lot of the cornerstone concepts when it comes
    to architectural patterns and best practices in Java. In particular, you started
    with the concept of encapsulation; one practical way to achieve it is the hexagonal
    architecture. You then moved to multi-tier architectures, which is a core concept
    in Java and JEE (especially the three-tier architecture, which is commonly implemented
    with beans, servlets, and JSPs).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了许多关于Java架构模式和最佳实践的基石概念。特别是，你从封装的概念开始；实现封装的一个实用方法是六边形架构。然后，你转向多层架构，这是Java和JEE（特别是三层架构，通常使用bean、servlet和JSP实现）的核心概念。
- en: There was a quick look at MVC, which is more a design pattern than an architectural
    guideline but is crucial to highlight some concepts such as the importance of
    separating presentation from business logic. You then covered the asynchronous
    and event-driven architecture concepts, which apply to a huge portion of different
    approaches that are popular right now in the world of Java. These concepts are
    known for their positive impacts on performance and scalability, which were also
    the final topics of this chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对MVC进行了简要的介绍，它与其说是架构指南，不如说是设计模式，但对于强调一些概念（如将表示层与业务逻辑分离的重要性）至关重要。然后，你介绍了异步和事件驱动架构的概念，这些概念适用于当今Java世界中流行的许多不同方法。这些概念以其对性能和可扩展性的积极影响而闻名，也是本章的最后一个主题。
- en: While being covered further in other chapters, such as [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, and [*Chapter 12*](B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292),
    *Cross-Cutting Concerns*, here you have seen some general considerations about
    architecture that will link some of the concepts that you've seen so far, such
    as tiering and asynchronous interactions, to specific performance goals.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在其他章节中也有进一步的讨论，例如[第9章](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)“设计云原生架构”和[第12章](B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292)“横切关注点”，但在这里你已经看到了一些关于架构的一般性考虑，这些考虑将把一些你之前看到的概念（如分层和异步交互）与特定的性能目标联系起来。
- en: In the next chapter, we will look in more detail at what middleware is and how
    it's evolving.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨中间件是什么以及它是如何演变的。
- en: Further reading
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Hexagonal architecture*, by Alistair Cockburn ([https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/))'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《六边形架构》，由阿利斯泰尔·科克本著（[https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/））
- en: '*Java Performance: The Definitive Guide: Getting the Most Out of Your Code*,
    by Scott Oaks, published by O''Reilly Media (2014)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Java 性能：终极指南：充分利用您的代码》，由斯科特·奥克斯著，由奥莱利媒体出版（2014年）
- en: '*Kafka Streams in Action*, by William P. Bejeck Jr., published by Manning'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Kafka Streams in Action》，由威廉·P·贝杰克著，由曼宁出版
- en: '*Scalability Rules 50 Principles for Scaling Web Sites*, by Martin L. Abbott
    and Michael T. Fisher, published by Pearson Education (2011)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《可扩展性规则：50个扩展网站的原则》，由马丁·L·艾博特和迈克尔·T·费舍尔著，由培生教育出版（2011年）
- en: '*Monolith First*, by Martin Fowler ([https://www.martinfowler.com/bliki/MonolithFirst.html](https://www.martinfowler.com/bliki/MonolithFirst.html))'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《单体优先》，由马丁·福勒著（[https://www.martinfowler.com/bliki/MonolithFirst.html](https://www.martinfowler.com/bliki/MonolithFirst.html））
