- en: Web Services with JAX-WS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX-WS 的 Web 服务
- en: The Java EE specification includes the JAX-WS API as one of its technologies.
    JAX-WS is the standard way to develop **SOAP** (**Simple Object Access Protocol**)
    web services in the Java platform and stands for Java API for XML Web Services.
    JAX-WS is a high-level API; invoking web services via JAX-WS is done via remote
    procedure calls. JAX-WS is a very natural API for Java developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 规范将 JAX-WS API 作为其技术之一。JAX-WS 是在 Java 平台上开发 **SOAP**（**简单对象访问协议**）网络服务的标准方式，代表
    Java API for XML Web Services。JAX-WS 是一个高级 API；通过 JAX-WS 调用网络服务是通过远程过程调用完成的。JAX-WS
    对于 Java 开发者来说是一个非常自然的 API。
- en: Web services are application programming interfaces that can be invoked remotely.
    Web services can be invoked from clients written in any language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是可以远程调用的应用程序编程接口。网络服务可以从任何语言的客户端调用。
- en: 'Some of the topics we will cover include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的一些主题包括：
- en: Developing web services with the JAX-WS API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-WS API 开发网络服务
- en: Developing web service clients with the JAX-WS API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-WS API 开发网络服务客户端
- en: Adding attachments to web service calls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向网络服务调用添加附件
- en: Exposing EJBs as web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 EJB 作为网络服务公开
- en: Developing web services with JAX-WS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX-WS 开发网络服务
- en: 'JAX-WS is a high-level API that simplifies the development of SOAP-based web
    services. JAX-WS stands for **Java API for XML Web Services**. Developing a web
    service via JAX-WS consists of writing a class with public methods to be exposed
    as web services. The class needs to be decorated with the `@WebService` annotation.
    All public methods in the class are automatically exposed as web services. They
    can optionally be decorated with the `@WebService` annotation. The following example
    illustrates this process:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-WS 是一个高级 API，它简化了基于 SOAP 的网络服务的开发。JAX-WS 代表 **Java API for XML Web Services**。通过
    JAX-WS 开发网络服务包括编写一个公共方法以供作为网络服务公开的类。该类需要用 `@WebService` 注解进行装饰。类中的所有公共方法都会自动公开为网络服务。它们可以选择性地用
    `@WebService` 注解进行装饰。以下示例说明了这个过程：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding class exposes its two methods as web services. The `add()` method
    simply adds the two `int` primitives it receives as parameters and returns the
    result; the `substract()` method subtracts its two parameters and returns the
    result.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类将其两个方法公开为网络服务。`add()` 方法简单地将它接收的两个 `int` 原始参数相加并返回结果；`substract()` 方法从其两个参数中减去并返回结果。
- en: We indicate that the class implements a web service by decorating it with the
    `@WebService` annotation. Any methods that we would like to expose as web services
    can be decorated with the `@WebMethod` annotation, but this isn't necessary; all
    public methods are automatically exposed as web services. We can still use the
    `@WebMethod` annotation for clarity, but it isn't strictly necessary to deploy
    our web service; we simply need to package it in a WAR file as usual.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过用 `@WebService` 注解装饰类来表示该类实现了网络服务。任何我们希望公开为网络服务的方法都可以用 `@WebMethod` 注解进行装饰，但这不是必需的；所有公共方法都会自动公开为网络服务。我们仍然可以使用
    `@WebMethod` 注解以提高清晰度，但这并不是部署我们的网络服务所必需的；我们只需像往常一样将其打包到 WAR 文件中即可。
- en: Web service clients need a **WSDL** (**Web Services Definition Language**) file
    in order to generate executable code that they can use to invoke the web service.
    WSDL files are typically placed in a web server and accessed by the client via
    its URL.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务客户端需要一个 **WSDL**（**Web 服务定义语言**）文件来生成它们可以用来调用网络服务的可执行代码。WSDL 文件通常放置在 Web
    服务器上，并通过客户端的 URL 访问。
- en: 'When deploying web services developed using JAX-WS, a WSDL is automatically
    generated for us. The exact URL for the generated WSDL varies depending on the
    Java EE 8 application server we are using. When using GlassFish, URLs for JAX-WS
    WSDLs follow the following format:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署使用 JAX-WS 开发的网络服务时，会自动为我们生成一个 WSDL。生成的 WSDL 的确切 URL 依赖于我们使用的 Java EE 8 应用服务器。当使用
    GlassFish 时，JAX-WS WSDL 的 URL 格式如下：
- en: '`[http|https]://[server]:[port]/[context root]/[service name]?wsdl`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`[http|https]://[server]:[port]/[context root]/[service name]?wsdl`'
- en: In our example, the URL for our web service's WSDL (when deployed to GlassFish)
    would be `http://localhost:8080/calculatorservice/CalculatorService?wsdl` (assuming
    GlassFish is running on our local workstation, and GlassFish is listening for
    HTTP connections on its default 8080 port).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，当我们的网络服务（部署到 GlassFish）的 WSDL 的 URL 为 `http://localhost:8080/calculatorservice/CalculatorService?wsdl`（假设
    GlassFish 在我们的本地工作站上运行，并且 GlassFish 在其默认的 8080 端口上监听 HTTP 连接）。
- en: Developing a web service client
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发网络服务客户端
- en: As we mentioned earlier, executable code needs to be generated from a web service's
    WSDL. A web service client will then invoke this executable code to access the
    web service.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，需要从网络服务的WSDL生成可执行代码。然后，网络服务客户端将调用这个可执行代码来访问网络服务。
- en: 'The **Java Development Kit** (**JDK**) includes a utility to generate Java
    code from a WSDL. The name of the utility is `wsimport`. It can be found under
    `$JAVA_HOME/bin`. The only required argument for `wsimport` is the URL of the
    WSDL corresponding to the web service, for example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java开发工具包**（**JDK**）包括一个从WSDL生成Java代码的工具。这个工具的名称是 `wsimport`。它可以在 `$JAVA_HOME/bin`
    下找到。`wsimport` 的唯一必需参数是与网络服务对应的WSDL的URL，例如：'
- en: '`wsimport http://localhost:8080/calculatorservice/CalculatorService?wsdl`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsimport http://localhost:8080/calculatorservice/CalculatorService?wsdl`'
- en: 'The preceding command will generate a number of compiled Java classes that
    allow client applications to access our web service:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将生成多个编译后的Java类，允许客户端应用程序访问我们的网络服务：
- en: '`Add.class`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add.class`'
- en: '`AddResponse.class`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddResponse.class`'
- en: '`Calculator.class`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Calculator.class`'
- en: '`CalculatorService.class`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculatorService.class`'
- en: '`ObjectFactory.class`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectFactory.class`'
- en: '`package-info.class`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-info.class`'
- en: '`Subtract.class`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subtract.class`'
- en: '`SubtractResponse.class`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubtractResponse.class`'
- en: 'Keeping generated source code: By default, the source code for the generated
    class files is automatically deleted; it can be kept by passing the `-keep` parameter
    to `wsimport`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 保持生成的源代码：默认情况下，生成的类文件的源代码会被自动删除；可以通过传递 `-keep` 参数给 `wsimport` 来保留它。
- en: These classes need to be added to the client's `CLASSPATH` in order for them
    to be accessible to the client's code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类需要添加到客户端的 `CLASSPATH` 中，以便它们可以被客户端代码访问。
- en: 'If we are using Apache Maven to build our code, we can take advantage of the
    JAX-WS Maven plugin to automatically invoke `wsimport` when building our client
    code. This approach is illustrated in the following `pom.xml` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Apache Maven来构建我们的代码，我们可以利用JAX-WS Maven插件在构建客户端代码时自动调用 `wsimport`。这种方法在下面的
    `pom.xml` 文件中得到了说明：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding `pom.xml` Maven build file will automatically invoke the `wsimport`
    utility whenever we build our code via the `mvn package` or `mvn install` commands.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `pom.xml` Maven构建文件将在我们通过 `mvn package` 或 `mvn install` 命令构建代码时自动调用 `wsimport`
    工具。
- en: 'At this point, we are ready to develop a simple client to access our web service.
    We will implement our client as a JSF application. The most relevant parts of
    our client application source code are shown as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好开发一个简单的客户端来访问我们的网络服务。我们将实现我们的客户端作为一个JSF应用程序。我们客户端应用程序源代码中最相关的部分如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `@WebServiceRef` annotation injects an instance of the web service into
    our client application. Its `wsdlLocation` attribute contains the URL of the WSDL
    corresponding to the web service we are invoking.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebServiceRef` 注解将一个网络服务实例注入到我们的客户端应用程序中。它的 `wsdlLocation` 属性包含我们正在调用的网络服务的WSDL的URL。'
- en: Notice that the web service class is an instance of a class called `CalculatorService`.
    This class was created when we invoked the `wsimport` utility, as `wsimport` always
    generates a class whose name is the name of the class we implemented plus the
    service suffix. We use this service class to obtain an instance of the web "Service"
    class we developed. In our example, we do this by invoking the `getCalculatorPort()`
    method on the `CalculatorService` instance. In general, the method to invoke to
    get an instance of our web service class follows the pattern `getNamePort()`,
    where `Name` is the name of the class we wrote to implement the web service. Once
    we get an instance of our web service class, we can simply invoke its methods
    as with any regular Java object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个网络服务类是名为 `CalculatorService` 的类的实例。这个类是在我们调用 `wsimport` 工具时创建的，因为 `wsimport`
    总是生成一个类，其名称是我们实现的类名加上服务后缀。我们使用这个服务类来获取我们开发的网络“服务”类的实例。在我们的例子中，我们通过在 `CalculatorService`
    实例上调用 `getCalculatorPort()` 方法来实现这一点。一般来说，获取我们网络服务类实例的方法遵循 `getNamePort()` 的模式，其中
    `Name` 是我们编写的实现网络服务的类的名称。一旦我们获取了我们的网络服务类实例，我们就可以像使用任何常规Java对象一样调用它的方法。
- en: Strictly speaking, the `getNamePort()` method of the service class returns an
    instance of a class implementing an interface generated by `wsimport`. This interface
    is given the name of our web service class and declares all of the methods we
    declared to be web services. For all practical purposes, the object returned is
    equivalent to our web service class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，服务类的`getNamePort()`方法返回一个实现由`wsimport`生成的接口的类的实例。这个接口被赋予我们的Web服务类的名称，并声明了我们声明的所有作为Web服务的方法。从所有实际目的来看，返回的对象等同于我们的Web服务类。
- en: 'The user interface for our simple client application is developed using Facelets,
    as customary when developing JSF applications:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单客户端应用程序的用户界面是使用Facelets开发的，这在开发JSF应用程序时是惯例：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The user interface uses Ajax to invoke the relevant methods on the `CalculatorClientController`
    CDI named bean (refer to [Chapter 2](9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml),
    *JavaServer Faces*, for details).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面使用Ajax调用`CalculatorClientController` CDI命名豆上的相关方法（有关详细信息，请参阅[第2章](9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml)，*JavaServer
    Faces*）。
- en: 'After deploying our code, our browser should render our page as follows (shown
    after entering some data and clicking the corresponding buttons):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我们的代码后，我们的浏览器应按以下方式渲染我们的页面（在输入一些数据并点击相应的按钮后显示）：
- en: '![](img/c9383d7d-0b52-4b8c-b662-8388510477bf.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9383d7d-0b52-4b8c-b662-8388510477bf.png)'
- en: In this example, we passed `Integer` objects as parameters and return values.
    Of course, it is also possible to pass primitive types both as parameters and
    as return values. Unfortunately, not all standard Java classes or primitive types
    can be used as method parameters or return values when invoking SOAP-based web
    services implemented via JAX-WS. The reason for this is that, behind the scenes,
    method parameters and return types get mapped to XML definitions, and not all
    types can be properly mapped.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们传递了`Integer`对象作为参数和返回值。当然，也可以将原始类型作为参数和返回值传递。不幸的是，当通过JAX-WS实现基于SOAP的Web服务时，并非所有标准Java类或原始类型都可以用作方法参数或返回值。这是因为，在幕后，方法参数和返回类型被映射到XML定义，并且并非所有类型都可以正确映射。
- en: 'Valid types that can be used in JAX-WS web service calls are listed here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列出了可用于JAX-WS Web服务调用的有效类型：
- en: '`java.awt.Image`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.Image`'
- en: '`java.lang.Object`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Object`'
- en: '`Java.lang.String`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Java.lang.String`'
- en: '`java.math.BigDecimal`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.math.BigDecimal`'
- en: '`java.math.BigInteger`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.math.BigInteger`'
- en: '`java.net.URI`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.net.URI`'
- en: '`java.util.Calendar`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Calendar`'
- en: '`java.util.Date`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Date`'
- en: '`java.util.UUID`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.UUID`'
- en: '`` `javax.activation.DataHandler` ``'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `javax.activation.DataHandler` ``'
- en: '`javax.xml.datatype.Duration`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.datatype.Duration`'
- en: '`javax.xml.datatype.XMLGregorianCalendar`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.datatype.XMLGregorianCalendar`'
- en: '`javax.xml.namespace.QName`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.namespace.QName`'
- en: '`javax.xml.transform.Source`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.transform.Source`'
- en: 'Additionally, the following primitive types can be used:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下原始类型也可以使用：
- en: '`Boolean`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`'
- en: '`byte`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`byte[]`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[]`'
- en: '`double`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`float`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`int`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`long`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`short`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`'
- en: We can also use our own custom classes as method parameters and/or return values
    for web service methods, but member variables of our classes must be one of the
    listed types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用我们自己的自定义类作为Web服务方法的参数和/或返回值，但我们的类的成员变量必须是列出的类型之一。
- en: Additionally, it is legal to use arrays both as method parameters and return
    values; however, when executing `wsimport`, these arrays get converted to lists,
    generating a mismatch between the method signature in the web service and the
    method call invoked in the client. For this reason, it is preferred to use lists
    as method parameters and/or return values, since this is also legal and does not
    create a mismatch between the client and the server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用数组作为方法参数和返回值也是合法的；然而，在执行`wsimport`时，这些数组会被转换为列表，导致Web服务中的方法签名与客户端调用的方法调用之间产生不匹配。因此，更倾向于使用列表作为方法参数和/或返回值，因为这同样是合法的，并且不会在客户端和服务器之间产生不匹配。
- en: JAX-WS uses the Java Architecture for XML Binding (JAXB) internally to create
    SOAP messages from method calls. The types we are allowed to use for method calls
    and return values are the ones that JAXB supports. For more information on JAXB,
    see [https://github.com/javaee/jaxb-v2.](https://github.com/javaee/jaxb-v2)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-WS内部使用Java Architecture for XML Binding (JAXB)来从方法调用创建SOAP消息。我们允许用于方法调用和返回值的类型是JAXB支持的类型。有关JAXB的更多信息，请参阅[https://github.com/javaee/jaxb-v2](https://github.com/javaee/jaxb-v2)。
- en: Sending attachments to web services
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Web服务发送附件
- en: 'In addition to sending and accepting the data types discussed in the previous
    sections, `web service` methods can send and accept file attachments. The following
    example illustrates how to do this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发送和接受上一节讨论的数据类型外，`web service` 方法还可以发送和接受文件附件。以下示例说明了如何做到这一点：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to write a web service method that receives one or more attachments,
    all we need to do is add a parameter of type `javax.activation.DataHandler` for
    each attachment the method will receive. In the preceding example, the `attachFile()`
    method takes a single parameter of this type and simply writes it to the filesystem.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个接收一个或多个附件的 Web 服务方法，我们只需要为方法将接收到的每个附件添加一个类型为 `javax.activation.DataHandler`
    的参数。在先前的示例中，`attachFile()` 方法接受一个此类参数并将其简单地写入文件系统。
- en: At this point, we need to package our code in a WAR file and deploy it as usual.
    Once deployed, a WSDL will automatically be generated. We then need to execute
    the `wsimport` utility to generate code that our web service client can use to
    access the web service. As previously discussed, the `wsimport` can be invoked
    directly from the command line or via an Apache Maven plugin.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要将我们的代码打包到 WAR 文件中，并按常规部署。一旦部署，就会自动生成 WSDL。然后，我们需要执行 `wsimport` 工具来生成我们的
    Web 服务客户端可以使用以访问 Web 服务的代码。如前所述，`wsimport` 可以直接从命令行或通过 Apache Maven 插件调用。
- en: 'Once we have executed `wsimport` to generate code to access the web service,
    we can write and compile our client code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `wsimport` 生成访问 Web 服务的代码后，我们可以编写和编译我们的客户端代码：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Web service attachments need to be sent as a `byte` array to the web service,
    therefore, web service clients need to convert the file to attach to this type.
    In our example, we send an image as an attachment, we load the image into memory
    by creating an instance of `java.net.URL`, passing the URL of the image in question
    as a parameter to its constructor. We then obtain an `InputStream` instance corresponding
    to the image by invoking the `openStream()` method on our `URL` instance, convert
    our `InputStream` instance to a byte array, then pass this byte array to the `web
    service` method that expects an attachment.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务附件需要以 `byte` 数组的形式发送到 Web 服务，因此，Web 服务客户端需要将需要附加的文件转换为这种类型。在我们的示例中，我们发送一个图像作为附件，通过创建一个
    `java.net.URL` 实例并将图像的 URL 作为参数传递给其构造函数来将图像加载到内存中。然后，我们通过在 `URL` 实例上调用 `openStream()`
    方法来获取与图像对应的 `InputStream` 实例，将我们的 `InputStream` 实例转换为字节数组，然后将这个字节数组传递给期望附件的 `web
    service` 方法。
- en: Notice that, unlike when passing standard parameters, the parameter type used
    when the client invokes a method expecting an attachment is different from the
    parameter type of the method in the web server code. The method in the web server
    code expects an instance of `javax.activation.DataHandler` for each attachment;
    however, the code generated by `wsimport` expects an array of bytes for each attachment.
    These arrays of bytes are converted to the right type ( `javax.activation.DataHandler`
    ) behind the scenes by the `wsimport` generated code. As application developers,
    we don't need to concern ourselves with the details of why this happens; we just
    need to keep in mind that, when sending attachments to a web service method, parameter
    types will be different in the web service code and in the client invocation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与传递标准参数不同，当客户端调用期望附件的方法时使用的参数类型与 Web 服务器代码中方法的参数类型不同。Web 服务器代码中的方法期望每个附件都有一个
    `javax.activation.DataHandler` 实例；然而，由 `wsimport` 生成的代码期望每个附件都是一个字节数组。这些字节数组在
    `wsimport` 生成的代码背后被转换为正确的类型（`javax.activation.DataHandler`）。作为应用程序开发者，我们不需要关心为什么会发生这种情况；我们只需要记住，当向
    Web 服务方法发送附件时，Web 服务代码和客户端调用中的参数类型将不同。
- en: Exposing EJBs as web services
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 EJBs 公开为 Web 服务
- en: 'In addition to creating web services as described in the previous section,
    public methods of stateless session beans can easily be exposed as web services
    by simply adding an annotation to the EJB class. The following example illustrates
    how to do this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建上一节中描述的 Web 服务外，可以通过简单地在 EJB 类上添加注解，轻松地将无状态会话 Bean 的公共方法公开为 Web 服务。以下示例说明了如何做到这一点：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the only thing we need to do to expose a stateless session bean's
    public methods is to decorate its class declaration with the `@WebService` annotation.
    Needless to say, since the class is a session bean, it also needs to be decorated
    with the `@Stateless` annotation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，要公开无状态会话Bean的公共方法，我们只需要用`@WebService`注解装饰其类声明。不用说，由于这个类是一个会话Bean，它也需要用`@Stateless`注解进行装饰。
- en: Just like regular stateless session beans, the ones whose methods are exposed
    as web services need to be deployed in a JAR file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规的无状态会话Bean一样，那些将方法公开为Web服务的Bean需要部署在一个JAR文件中。
- en: Just like standard web services, WSDL URLs for EJB web services depend on the
    application server being used. Consult your application server documentation for
    details.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如标准Web服务一样，EJB Web服务的WSDL URL取决于所使用的应用服务器。请查阅您的应用服务器文档以获取详细信息。
- en: EJB web service clients
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB Web服务客户端
- en: 'The following class illustrates the procedure to be followed to access an EJB
    web service methods from a client application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类展示了从客户端应用程序访问EJB Web服务方法的步骤：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, nothing special needs to be done when accessing an EJB web service
    from a client. The procedure is the same as with standard web services.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，当从客户端访问EJB Web服务时，不需要做任何特别的事情。过程与标准Web服务相同。
- en: 'The preceding class is a CDI named bean, and the following screenshot illustrates
    a simple JSF web-based user interface utilizing the preceding class to invoke
    our web service:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类是一个CDI（上下文依赖注入）命名Bean，下面的截图展示了使用前面的类来调用我们的Web服务的简单JSF基于Web的用户界面：
- en: '![](img/416a894e-7643-45a8-987e-b72fa1c2a24f.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/416a894e-7643-45a8-987e-b72fa1c2a24f.png)'
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to develop web services and web service clients
    via the JAX-WS API. We explained how to incorporate web service code generation
    for web service clients when using ANT or Maven as a build tool. We also covered
    the valid types that can be used for remote method calls via JAX-WS. Additionally,
    we discussed how to send attachments to a web service. We also covered how to
    expose an EJB's methods as web services.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何通过JAX-WS API开发Web服务和Web服务客户端。我们解释了在使用ANT或Maven作为构建工具时如何将Web服务客户端的代码生成集成到Web服务中。我们还介绍了可以通过JAX-WS进行远程方法调用时可以使用的有效类型。此外，我们还讨论了如何向Web服务发送附件。我们还介绍了如何将EJB的方法公开为Web服务。
