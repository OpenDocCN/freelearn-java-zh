- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Using Spring Cloud Gateway to Hide Microservices behind an Edge Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway隐藏微服务背后的边缘服务器
- en: In this chapter, we will learn how to use Spring Cloud Gateway as an edge server,
    to control what APIs are exposed from our microservices-based system landscape.
    We will see how microservices that have public APIs are made accessible from the
    outside through the edge server, while microservices that have private APIs are
    only accessible from the inside of the microservice landscape. In our system landscape,
    this means that the product composite service and the discovery server, Netflix
    Eureka, will be exposed through the edge server. The three core services, `product`,
    `recommendation`, and `review`, will be hidden from the outside.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Spring Cloud Gateway作为边缘服务器，以控制从我们的基于微服务系统景观中公开的API。我们将看到具有公共API的微服务如何通过边缘服务器从外部访问，而具有私有API的微服务仅从微服务景观的内部访问。在我们的系统景观中，这意味着产品组合服务和发现服务器Netflix
    Eureka将通过边缘服务器公开。三个核心服务`product`、`recommendation`和`review`将对外隐藏。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding an edge server to our system landscape
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将边缘服务器添加到我们的系统景观中
- en: Setting up Spring Cloud Gateway, including configuring routing rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Gateway，包括配置路由规则
- en: Trying out the edge server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用边缘服务器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章*，*macOS安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章*，*使用WSL 2和Ubuntu的Microsoft Windows安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter10`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都来自`$BOOK_HOME/Chapter10`中的源代码。
- en: If you want to view the changes applied to the source code in this chapter –
    that is, see what it took to add Spring Cloud Gateway as an edge server to the
    microservices landscape – you can compare it with the source code for *Chapter
    9*, *Adding Service Discovery Using Netflix Eureka*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看对本章源代码所做的更改——即查看将Spring Cloud Gateway作为边缘服务器添加到微服务景观中所需的工作——您可以将其与*第9章*，*使用Netflix
    Eureka添加服务发现*的源代码进行比较。
- en: You can use your favorite `diff` tool and compare the two folders, `$BOOK_HOME/Chapter09`
    and `$BOOK_HOME/Chapter10`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您喜欢的`diff`工具比较两个文件夹，`$BOOK_HOME/Chapter09`和`$BOOK_HOME/Chapter10`。
- en: Adding an edge server to our system landscape
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将边缘服务器添加到我们的系统景观中
- en: 'In this section, we will see how the edge server is added to the system landscape
    and how it affects the way external clients access the public APIs that the microservices
    expose. All incoming requests will now be routed through the edge server, as illustrated
    by the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到边缘服务器是如何添加到系统景观中，以及它如何影响外部客户端访问微服务公开的公共API的方式。现在，所有传入的请求都将通过边缘服务器路由，如下图所示：
- en: '![Graphical user interface, diagram, text  Description automatically generated](img/B19825_10_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，图表，文本 描述自动生成](img/B19825_10_01.png)'
- en: 'Figure 10.1: Adding an edge server'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：添加边缘服务器
- en: As we can see from the preceding diagram, external clients send all their requests
    to the edge server. The edge server can route the incoming requests based on the
    URL path. For example, requests with a URL that starts with `/product-composite/`
    are routed to the product composite microservice, and a request with a URL that
    starts with `/eureka/` is routed to the discovery server based on Netflix Eureka.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，外部客户端将所有请求发送到边缘服务器。边缘服务器可以根据URL路径路由传入的请求。例如，以`/product-composite/`开头的请求被路由到产品组合微服务，而以`/eureka/`开头的请求根据Netflix
    Eureka被路由到发现服务器。
- en: To make the discovery service work with Netflix Eureka, we don’t need to expose
    it through the edge server. The internal services will communicate directly with
    Netflix Eureka. The reasons for exposing it are to make its web page and API accessible
    to an operator that needs to check the status of Netflix Eureka, and to see what
    instances are currently registered in the discovery service.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使发现服务与Netflix Eureka一起工作，我们不需要通过边缘服务器公开它。内部服务将直接与Netflix Eureka通信。公开它的原因是为了使操作员能够检查Netflix
    Eureka的状态，并查看当前在发现服务中注册的实例。
- en: 'In *Chapter 9*, *Adding Service Discovery Using Netflix Eureka*, we exposed
    both the `product-composite` service and the discovery server, Netflix Eureka,
    to the outside. When we introduce the edge server in this chapter, this will no
    longer be the case. This is implemented by removing the following port declarations
    for the two services in the Docker Compose files:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 9 章*，*使用 Netflix Eureka 添加服务发现* 中，我们暴露了 `product-composite` 服务和发现服务器 Netflix
    Eureka 的外部。当我们在本章介绍边缘服务器时，这种情况将不再存在。这是通过从 Docker Compose 文件中删除以下两个服务的端口声明来实现的：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the edge server introduced, we will learn how to set up an edge server
    based on Spring Cloud Gateway in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入边缘服务器后，我们将在下一节学习如何基于 Spring Cloud Gateway 设置边缘服务器。
- en: Setting up Spring Cloud Gateway
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Spring Cloud Gateway
- en: 'Setting up Spring Cloud Gateway as an edge server is straightforward and can
    be done with the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Spring Cloud Gateway 设置为边缘服务器非常简单，可以按照以下步骤进行：
- en: Create a Spring Boot project using Spring Initializr, as described in *Chapter
    3*, *Creating a Set of Cooperating Microservices* – refer to the *Using Spring
    Initializr to generate skeleton code* section.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Spring Initializr 创建一个 Spring Boot 项目，如 *第 3 章*，*创建一组协作微服务* 中所述 – 请参阅 *使用
    Spring Initializr 生成骨架代码* 部分。
- en: Add a dependency on `spring-cloud-starter-gateway`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 `spring-cloud-starter-gateway` 的依赖。
- en: To be able to locate microservice instances through Netflix Eureka, also add
    the `spring-cloud-starter-netflix-eureka-client` dependency.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够通过 Netflix Eureka 定位微服务实例，还需要添加 `spring-cloud-starter-netflix-eureka-client`
    依赖。
- en: 'Add the edge server project to the common build file, `settings.gradle`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边缘服务器项目添加到通用构建文件 `settings.gradle` 中：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add a `Dockerfile` with the same content as for the microservices; see the `Dockerfile`
    content in the folder `$BOOK_HOME/Chapter10/microservices`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个与微服务相同的 `Dockerfile`；请参阅 `$BOOK_HOME/Chapter10/microservices` 文件夹中的 `Dockerfile`
    内容。
- en: 'Add the edge server to our three Docker Compose files:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边缘服务器添加到我们的三个 Docker Compose 文件中：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the preceding code, we can see that the edge server exposes port `8080`
    to the outside of Docker Engine. To control how much memory is required, a memory
    limit of `512` MB is applied to the edge server, in the same way as we did for
    the other microservices.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到边缘服务器将端口 `8080` 暴露给 Docker 引擎的外部。为了控制所需的内存量，对边缘服务器应用了一个 `512`
    MB 的内存限制，这与我们对其他微服务所做的方式相同。
- en: Since the edge server will handle all incoming traffic, we will move the composite
    health check from the product composite service to the edge server. This is described
    in the *Adding a composite health check* section next.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于边缘服务器将处理所有传入流量，我们将组合健康检查从产品组合服务移动到边缘服务器。这将在下一节 *添加组合健康检查* 中描述。
- en: Add configuration for routing rules and more. Since there is a lot to configure,
    it is handled in a separate section below, *Configuring a Spring Cloud Gateway*.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加路由规则和更多配置。由于有很多配置项，因此它们在下面的单独部分 *配置 Spring Cloud Gateway* 中处理。
- en: You can find the source code for the Spring Cloud Gateway in `$BOOK_HOME/Chapter10/spring-cloud/gateway`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `$BOOK_HOME/Chapter10/spring-cloud/gateway` 中找到 Spring Cloud Gateway 的源代码。
- en: Adding a composite health check
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加组合健康检查
- en: With an edge server in place, external health check requests also have to go
    through the edge server. Therefore, the composite health check that checks the
    status of all microservices has been moved from the `product-composite` service
    to the edge server. See *Chapter 7*, *Developing Reactive Microservices* – refer
    to the *Adding a health API* section for implementation details for the composite
    health check.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经设置了边缘服务器，外部健康检查请求也必须通过边缘服务器进行。因此，检查所有微服务状态的组合健康检查已从 `product-composite`
    服务移动到边缘服务器。请参阅 *第 7 章*，*开发反应式微服务* – 请参阅 *添加健康 API* 部分以获取组合健康检查的实现细节。
- en: 'The following has been added to the edge server:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容已添加到边缘服务器中：
- en: 'The `HealthCheckConfiguration` class has been added, which declares the reactive
    health contributor:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已添加 `HealthCheckConfiguration` 类，它声明了反应式健康贡献者：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the preceding code, we can see that a health check for the `product-composite`
    service has been added, instead of the health check used in *Chapter 7*, *Developing
    Reactive Microservices*!
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到已为 `product-composite` 服务添加了健康检查，而不是在 *第 7 章*，*开发反应式微服务* 中使用的健康检查！
- en: 'The main application class, `GatewayApplication`, declares a `WebClient.Builder`
    bean to be used by the implementation of the health indicator, as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主应用程序类 `GatewayApplication` 声明了一个 `WebClient.Builder` 实例，该实例将被用于健康指标的实现，如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the preceding source code, we can see that `WebClient.builder` is annotated
    with `@LoadBalanced`, which makes it aware of microservice instances registered
    in the discovery server, Netflix Eureka. Refer to the *Service Discovery with
    Netflix Eureka in Spring Cloud* section in *Chapter 9*, *Adding Service Discovery
    Using Netflix Eureka*, for more details.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的源代码中，我们可以看到 `WebClient.builder` 被注解为 `@LoadBalanced`，这使得它知道在发现服务器 Netflix
    Eureka 中注册的微服务实例。有关更多详细信息，请参阅第 9 章 *使用 Netflix Eureka 添加服务发现* 中的 *Spring Cloud
    中 Netflix Eureka 的服务发现* 部分。
- en: With a composite health check in place for the edge server, we are ready to
    look at the configuration that needs to be set up for Spring Cloud Gateway.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于边缘服务器，我们已设置复合健康检查，现在可以查看需要为 Spring Cloud Gateway 设置的配置。
- en: Configuring Spring Cloud Gateway
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Spring Cloud Gateway
- en: 'When it comes to configuring Spring Cloud Gateway, the most important thing
    is setting up the routing rules. We also need to set up a few other things in
    the configuration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到配置 Spring Cloud Gateway 时，最重要的是设置路由规则。我们还需要在配置中设置一些其他事项：
- en: Since Spring Cloud Gateway will use Netflix Eureka to find the microservices
    it will route traffic to, it must be configured as a Eureka client in the same
    way as described in *Chapter 9*, *Adding Service Discovery Using Netflix Eureka*
    – refer to the *Configuring clients to the Eureka server* section.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Spring Cloud Gateway 将使用 Netflix Eureka 来查找它将路由流量到的微服务，因此它必须像第 9 章 *使用 Netflix
    Eureka 添加服务发现* 中所述的那样配置为 Eureka 客户端 – 请参阅 *配置 Eureka 服务器客户端* 部分。
- en: 'Configure Spring Boot Actuator for development usage, as described in *Chapter
    7*, *Developing Reactive Microservices* – refer to the *Adding a health API* section:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第 7 章 *开发响应式微服务* 中所述配置 Spring Boot Actuator 以用于开发，请参阅 *添加健康 API* 部分：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Configure log levels so that we can see log messages from interesting parts
    of the internal processing in Spring Cloud Gateway, for example, how it decides
    where to route incoming requests to:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置日志级别，以便我们可以看到 Spring Cloud Gateway 内部处理中有趣部分的日志消息，例如，它如何决定将传入的请求路由到何处：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the full source code, refer to the configuration file, `src/main/resources/application.yml`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的源代码，请参阅配置文件 `src/main/resources/application.yml`。
- en: Routing rules
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由规则
- en: 'Setting up routing rules can be done in two ways: programmatically, using a
    Java DSL, or by configuration. Using a Java DSL to set up routing rules programmatically
    can be useful in cases where the rules are stored in external storage, such as
    a database, or are given at runtime, for example, via a RESTful API or a message
    sent to the gateway. In more static use cases, I find it more convenient to declare
    the routes in the configuration file, `src/main/resources/application.yml`. Separating
    the routing rules from the Java code makes it possible to update the routing rules
    without having to deploy a new version of the microservice.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置路由规则可以通过两种方式完成：程序化地使用 Java DSL，或通过配置。在规则存储在外部存储（如数据库）或运行时提供（例如，通过 RESTful
    API 或发送到网关的消息）的情况下，使用 Java DSL 程序化设置路由规则可能很有用。在更静态的使用场景中，我发现将路由声明在配置文件 `src/main/resources/application.yml`
    中更为方便。将路由规则与 Java 代码分离，使得无需部署微服务的新版本即可更新路由规则。
- en: 'A **route** is defined by the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 路由由以下定义：
- en: '**Predicates**, which select a route based on information in the incoming HTTP
    request'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**，根据传入的 HTTP 请求中的信息选择路由'
- en: '**Filters**, which can modify both the request and/or the response'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**，可以修改请求和/或响应'
- en: A **destination URI**, which describes where to send a request
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **目标 URI**，它描述了请求应发送到何处
- en: An **ID**, that is, the name of the route
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **ID**，即路由的名称
- en: 'For a full list of available predicates and filters, refer to the reference
    documentation: [https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可用的断言和过滤器的完整列表，请参阅参考文档：[https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html)。
- en: In the following subsections, we will first learn how to route requests to the
    `product-composite` service and the Eureka server. After that, we will see how
    predicates and filters can be used, even though they are not used in this book
    elsewhere.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将首先学习如何将请求路由到 `product-composite` 服 务和 Eureka 服 务器。之后，我们将看到如何使用谓词和过滤器，尽管它们在此书中其他地方没有使用。
- en: Routing requests to the product-composite API
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由请求到 product-composite API
- en: 'If we, for example, want to route incoming requests where the URL path starts
    with `/product-composite/` to our `product-composite` service, we can specify
    a routing rule like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将 URL 路径以 `/product-composite/` 开头的传入请求路由到我们的 `product-composite` 服
    务，我们可以指定一个如下的路由规则：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some points to note from the preceding code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中需要注意的一些点：
- en: '`id: product-composite`: The name of the route is `product-composite`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id: product-composite`：路由的名称是 `product-composite`。'
- en: '`uri: lb://product-composite`: If the route is selected by its predicates,
    the request will be routed to the service that is named `product-composite` in
    the discovery service, Netflix Eureka. The protocol `lb://` is used to direct
    Spring Cloud Gateway to use the client-side load balancer to look up the destination
    in the discovery service.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri: lb://product-composite`：如果路由被其谓词选中，请求将被路由到在发现服务 Netflix Eureka 中命名为 `product-composite`
    的服务。协议 `lb://` 用于指示 Spring Cloud Gateway 使用客户端负载均衡器在发现服务中查找目标。'
- en: '`predicates: - Path=/product-composite/**` is used to specify what requests
    this route should match. `**` matches zero or more elements in the path.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predicates: - Path=/product-composite/**` 用于指定此路由应匹配哪些请求。`**` 匹配路径中的零个或多个元素。'
- en: 'To be able to route requests to the **Swagger UI** set up in *Chapter 5*, *Adding
    an API Description Using OpenAPI*, an extra route to the `product-composite` service
    is added:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将请求路由到第 5 章“使用 OpenAPI 添加 API 描述”中设置的 **Swagger UI**，向 `product-composite`
    服 务添加了额外的路由：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Requests sent to the edge server with a URI starting with `/openapi/` will be
    directed to the `product-composite` service.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `/openapi/` 开头的 URI 开始发送到边缘服务器的请求将被路由到 `product-composite` 服 务。
- en: 'When the Swagger UI is presented behind an edge server, it must be able to
    present an OpenAPI Specification of the API that contains the correct server URL
    – the URL of the edge server instead of the URL of the `product-composite` service
    itself. To enable the `product-composite` service to produce a correct server
    URL in the OpenAPI specification, the following configuration has been added to
    the `product-composite` service:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Swagger UI 在边缘服务器后面呈现时，它必须能够呈现包含正确服务器 URL 的 API 的 OpenAPI 规范 – 即边缘服务器的 URL
    而不是 `product-composite` 服务的 URL。为了使 `product-composite` 服 务能够在 OpenAPI 规范中生成正确的服务器
    URL，已经向 `product-composite` 服 务添加了以下配置：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more details, see [https://springdoc.org/index.html#how-can-i-deploy-springdoc-openapi-ui-behind-a-reverse-proxy](https://springdoc.org/index.html#how-can-i-deploy-springdoc-openapi-ui-behind-a-reverse-proxy).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请参阅 [https://springdoc.org/index.html#how-can-i-deploy-springdoc-openapi-ui-behind-a-reverse-proxy](https://springdoc.org/index.html#how-can-i-deploy-springdoc-openapi-ui-behind-a-reverse-proxy)。
- en: 'To verify that the correct server URL is set in the OpenAPI specification,
    the following test has been added to the test script, `test-em-all.bash`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 OpenAPI 规范中已设置正确的服务器 URL，已在测试脚本 `test-em-all.bash` 中添加了以下测试：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Routing requests to the Eureka server’s API and web page
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由请求到 Eureka 服务器 API 和网页
- en: 'Eureka exposes both an API and a web page for its clients. To provide a clean
    separation between the API and the web page in Eureka, we will set up routes as
    follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka 向其客户端公开了 API 和网页。为了在 Eureka 中提供 API 和网页之间的清晰分离，我们将设置如下路由：
- en: Requests sent to the edge server with the path starting with `/eureka/api/`
    should be handled as a call to the Eureka API.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `/eureka/api/` 开头的路径发送到边缘服务器的请求应被视为对 Eureka API 的调用。
- en: Requests sent to the edge server with the path starting with `/eureka/web/`
    should be handled as a call to the Eureka web page.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `/eureka/web/` 开头的路径发送到边缘服务器的请求应被视为对 Eureka 网页的调用。
- en: 'API requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    routing rule for the Eureka API looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: API 请求将被路由到 `http://${app.eureka-server}:8761/eureka`。Eureka API 的路由规则看起来像这样：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `{segment}` part in the `Path` value matches zero or more elements in the
    path and will be used to replace the `{segment}` part in the `SetPath` value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 值中的 `{segment}` 部分与路径中的零个或多个元素匹配，并将用于替换 `SetPath` 值中的 `{segment}` 部分。'
- en: 'Web page requests will be routed to `http://${app.eureka-server}:8761`. The
    web page will load several web resources, such as `.js`, `.css`, and `.png` files.
    These requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    routing rules for the Eureka web page look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 网页请求将被路由到 `http://${app.eureka-server}:8761`。网页将加载多个网络资源，例如 `.js`、`.css` 和 `.png`
    文件。这些请求将被路由到 `http://${app.eureka-server}:8761/eureka`。Eureka 网页的路由规则如下：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the preceding configuration, we can take the following notes. The `${app.eureka-server}`
    property is resolved by Spring’s property mechanism, depending on what Spring
    profile is activated:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的配置中，我们可以得出以下结论。`${app.eureka-server}` 属性通过 Spring 的属性机制解析，取决于激活了哪个 Spring
    配置文件：
- en: When running the services on the same host without using Docker, for example,
    for debugging purposes, the property will be translated to `localhost` using the
    `default` profile.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在不使用 Docker 的情况下在同一主机上运行服务，例如，出于调试目的时，该属性将使用 `default` 配置文件转换为 `localhost`。
- en: When running the services as Docker containers, the Netflix Eureka server will
    run in a container with the DNS name `eureka`. Therefore, the property will be
    translated into `eureka` using the `docker` profile.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当以 Docker 容器运行服务时，Netflix Eureka 服务器将在一个名为 `eureka` 的容器中运行。因此，该属性将使用 `docker`
    配置文件转换为 `eureka`。
- en: 'The relevant parts in the `application.yml` file that define this translation
    look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定义此翻译的 `application.yml` 文件中的相关部分如下：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this, we have seen how to route requests to both the `product-composite`
    and the Eureka server. As a final step, let’s see how predicates and filters can
    be used in Spring Cloud Gateway.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经看到了如何将请求路由到 `product-composite` 和 Eureka 服务器。作为最后一步，让我们看看如何在 Spring
    Cloud Gateway 中使用谓词和过滤器。
- en: Routing requests with predicates and filters
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用谓词和过滤器路由请求
- en: 'To learn a bit more about the routing capabilities in Spring Cloud Gateway,
    we will try out **host-based routing**, where Spring Cloud Gateway uses the hostname
    of the incoming request to determine where to route the request. We will use one
    of my favorite websites for testing HTTP codes: [http://httpstat.us/](http://httpstat.us/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Spring Cloud Gateway 中路由功能的一些更多信息，我们将尝试 **基于主机的路由**，其中 Spring Cloud Gateway
    使用传入请求的主机名来确定请求的路由位置。我们将使用我最喜欢的网站来测试 HTTP 状态码：[http://httpstat.us/](http://httpstat.us/)。
- en: 'A call to `http://httpstat.us/${CODE}` simply returns a response with the `${CODE}`
    HTTP code and a response body, also containing the HTTP code, and a corresponding
    descriptive text. For example, see the following `curl` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `http://httpstat.us/${CODE}` 的调用简单地返回一个包含 `${CODE}` HTTP 状态码和响应体的响应，响应体中也包含
    HTTP 状态码和相应的描述性文本。例如，请参阅以下 `curl` 命令：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will return the HTTP code `200`, and a response body with the text `200
    OK`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 HTTP 状态码 `200`，以及包含文本 `200 OK` 的响应体。
- en: 'Let’s assume that we want to route calls to `http://${hostname}:8080/headerrouting`
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将 `http://${hostname}:8080/headerrouting` 的调用路由如下：
- en: Calls to the `i.feel.lucky` host should return `200 OK`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `i.feel.lucky` 主机的调用应返回 `200 OK`
- en: Calls to the `im.a.teapot` host should return `418 I'm a teapot`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `im.a.teapot` 主机的调用应返回 `418 I'm a teapot`
- en: Calls to all other hostnames should return `501 Not Implemented`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有其他主机名的调用应返回 `501 Not Implemented`
- en: 'To implement these routing rules in Spring Cloud Gateway, we can use the `Host`
    route predicate to select requests with specific hostnames, and the `SetPath`
    filter to set the desired HTTP code in the request path. This can be done as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Spring Cloud Gateway 中实现这些路由规则，我们可以使用 `Host` 路由谓词来选择具有特定主机名的请求，并使用 `SetPath`
    过滤器在请求路径中设置所需的 HTTP 状态码。可以按照以下方式完成：
- en: 'To make calls to `http://i.feel.lucky:8080/headerrouting` return `200 OK`,
    we can set up the following route:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使对 `http://i.feel.lucky:8080/headerrouting` 的调用返回 `200 OK`，我们可以设置以下路由：
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To make calls to `http://im.a.teapot:8080/headerrouting` return `418 I''m a
    teapot`, we can set up the following route:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使对 `http://im.a.teapot:8080/headerrouting` 的调用返回 `418 I'm a teapot`，我们可以设置以下路由：
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, to make calls to all other hostnames return `501 Not Implemented`,
    we can set up the following route:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使对所有其他主机名的调用返回 `501 Not Implemented`，我们可以设置以下路由：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Okay, that was quite a bit of configuration, so let’s now try it out!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这需要相当多的配置，所以现在让我们来试一试！
- en: Trying out the edge server
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试边缘服务器
- en: 'To try out the edge server, we perform the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试边缘服务器，我们执行以下步骤：
- en: 'First, build the Docker images with the following commands:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建 Docker 镜像：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Docker中启动系统景观并使用以下命令运行常规测试：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Expect output similar to what we have seen in previous chapters:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期输出类似于我们在前面的章节中看到的：
- en: '![Text  Description automatically generated](img/B19825_10_02.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_10_02.png)'
- en: 'Figure 10.2: Output from test-em-all.bash'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：test-em-all.bash的输出
- en: From the log output, note the second to last test result, `http://localhost:8080`.
    That is the output from the test that verifies that the server URL in Swagger
    UI’s OpenAPI specification is correctly rewritten as the URL of the edge server.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从日志输出中，注意倒数第二个测试结果，`http://localhost:8080`。这是验证Swagger UI的OpenAPI规范中服务器URL是否正确重写为边缘服务器URL的测试输出。
- en: 'With the system landscape, including the edge server, up and running, let’s
    explore the following topics:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统景观，包括边缘服务器，启动并运行时，让我们探索以下主题：
- en: Examining what is exposed by the edge server outside of the system landscape
    running in the Docker engine.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查边缘服务器在Docker引擎中运行的系统景观之外暴露的内容。
- en: 'Trying out some of the most frequently used routing rules as follows:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试以下最常用的路由规则：
- en: Using URL-based routing to call our APIs through the edge server
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于URL的路由来通过边缘服务器调用我们的API
- en: Using URL-based routing to call the Swagger UI through the edge server
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于URL的路由来通过边缘服务器调用Swagger UI
- en: Using URL-based routing to call Netflix Eureka through the edge server, both
    using its API and web-based UI
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于URL的路由来通过边缘服务器调用Netflix Eureka，同时使用其API和基于Web的UI
- en: Using header-based routing to see how we can route requests based on the hostname
    in the request
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于头的路由来查看我们如何根据请求中的主机名来路由请求
- en: Examining what is exposed outside the Docker engine
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查Docker引擎外部暴露的内容
- en: 'To understand what the edge server exposes to the outside of the system landscape,
    perform the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解边缘服务器向系统景观外部暴露了什么，请执行以下步骤：
- en: 'Use the `docker-compose ps` command to see which ports are exposed by our services:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker-compose ps`命令查看我们的服务暴露了哪些端口：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see in the following output, only the edge server (named `gateway`)
    exposes its port (`8080`) outside the Docker engine:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下输出所示，只有边缘服务器（命名为`gateway`）在其Docker引擎外部暴露了其端口（`8080`）：
- en: '![Timeline  Description automatically generated with medium confidence](img/B19825_10_03.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![时间线描述自动生成，中等置信度](img/B19825_10_03.png)'
- en: 'Figure 10.3: Output from docker-compose ps'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：docker-compose ps的输出
- en: 'If we want to see what routes the edge server has set up, we can use the `/actuator/gateway/routes`
    API. The response from this API is rather verbose. To limit the response to information
    we are interested in, we can apply a `jq` filter. In the following example, the
    `id` of the route and the `uri` that the request will be routed to are selected:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想查看边缘服务器设置了哪些路由，可以使用`/actuator/gateway/routes` API。这个API的响应相当冗长。为了限制响应只包含我们感兴趣的信息，我们可以应用一个`jq`过滤器。在以下示例中，选择了路由的`id`和请求将被路由到的`uri`：
- en: '[PRE21]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command will respond with the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令将响应如下：
- en: '![Text  Description automatically generated](img/B19825_10_04.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_10_04.png)'
- en: 'Figure 10.4: Spring Cloud Gateway routing rules'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：Spring Cloud Gateway路由规则
- en: This gives us a good overview of the actual routes configured in the edge server.
    Now, let’s try out the routes!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了边缘服务器中实际配置的路由的良好概述。现在，让我们尝试这些路由！
- en: Trying out the routing rules
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试路由规则
- en: In this section, we will try out the edge server and the routes it exposes to
    the outside of the system landscape. Let’s start by calling the `product-composite`
    API and its Swagger UI. Then, we’ll call the Eureka API and visit its web page.
    Finally, we’ll conclude by testing the routes that are based on hostnames.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试边缘服务器及其向系统景观外部暴露的路由。让我们首先调用`product-composite` API及其Swagger UI。然后，我们将调用Eureka
    API并访问其网页。最后，我们将通过测试基于主机名的路由来结束。
- en: Calling the product composite API through the edge server
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过边缘服务器调用产品组合API
- en: 'Let’s perform the following steps to call the product composite API through
    the edge server:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来通过边缘服务器调用产品组合API：
- en: 'To be able to see what is going on in the edge server, we can follow its log
    output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够看到边缘服务器中正在发生的事情，我们可以跟随其日志输出：
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, in a separate terminal window, make the call to the `product-composite`
    API through the edge server:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在另一个终端窗口中，通过边缘服务器调用`product-composite` API：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Expect the normal type of response from the `product-composite` API:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期从`product-composite` API获得正常类型的响应：
- en: '![Graphical user interface  Description automatically generated](img/B19825_10_05.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B19825_10_05.png)'
- en: 'Figure 10.5: Output from retrieving the composite product with Product ID 1'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：检索产品ID为1的复合产品的输出
- en: 'We should be able to find the following information in the log output:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在日志输出中找到以下信息：
- en: '![Text  Description automatically generated](img/B19825_10_06.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B19825_10_06.png)'
- en: 'Figure 10.6: Log output from the edge server'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：边缘服务器的日志输出
- en: From the log output, we can see the pattern matching based on the predicate
    we specified in the configuration, and we can see which microservice instance
    the edge server selected from the available instances in the discovery server
    – in this case, it forwards the request to `http://b8013440aea0:8080/product-composite/1`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从日志输出中，我们可以看到基于我们在配置中指定的断言的模式匹配，并且我们可以看到边缘服务器从发现服务器中的可用实例中选择了哪个微服务实例——在这种情况下，它将请求转发到`http://b8013440aea0:8080/product-composite/1`。
- en: Calling the Swagger UI through the edge server
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过边缘服务器调用Swagger UI
- en: 'To verify that we can reach the Swagger UI introduced in *Chapter 5*, *Adding
    an API Description Using OpenAPI*, through the edge server, open the URL `http://localhost:8080/openapi/swagger-ui.html`
    in a web browser. The resulting Swagger UI page should look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证我们是否可以通过边缘服务器访问到第5章中介绍的Swagger UI，即使用OpenAPI添加API描述，请在网络浏览器中打开URL `http://localhost:8080/openapi/swagger-ui.html`。生成的Swagger
    UI页面应如下所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_10_07.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_10_07.png)'
- en: 'Figure 10.7: The Swagger UI through the edge server, gateway'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：通过边缘服务器，网关的Swagger UI
- en: 'Note the server URL: `http://localhost:8080`; this means that the `product-composite`
    API’s own URL, `http://product-service:8080/`, has been replaced in the OpenAPI
    specification returned by the Swagger UI.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意服务器URL：`http://localhost:8080`；这意味着Swagger UI返回的OpenAPI规范中已经替换了`product-composite`
    API自己的URL，即`http://product-service:8080/`。
- en: If you want to, you can proceed and actually try out the `product-composite`
    API in the Swagger UI, as we did back in *Chapter 5*, *Adding an API Description
    Using OpenAPI*!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想的话，你可以在Swagger UI中实际尝试`product-composite` API，就像我们在第5章中做的那样，即使用OpenAPI添加API描述！
- en: Calling Eureka through the edge server
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过边缘服务器调用Eureka
- en: 'To call Eureka through an edge server, perform the following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过边缘服务器调用Eureka，请执行以下步骤：
- en: 'First, call the Eureka API through the edge server to see what instances are
    currently registered in the discovery server:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过边缘服务器调用Eureka API，以查看当前在发现服务器中注册的实例：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Expect a response along the lines of the following:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期响应将与以下类似：
- en: '![Text  Description automatically generated](img/B19825_10_08.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B19825_10_08.png)'
- en: 'Figure 10.8: Eureka listing the edge server, gateway, in the REST call'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：Eureka在REST调用中列出边缘服务器，网关
- en: Note that the edge server (named `gateway`) is also present in the response.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，边缘服务器（命名为`gateway`）也存在于响应中。
- en: 'Next, open the Eureka web page in a web browser using the URL `http://localhost:8080/eureka/web`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用URL `http://localhost:8080/eureka/web`在网页浏览器中打开Eureka网页：
- en: '![Graphical user interface, website  Description automatically generated](img/B19825_10_09.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站  自动生成的描述](img/B19825_10_09.png)'
- en: 'Figure 10.9: Eureka listing the edge server, gateway, in the web UI'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：Eureka在Web UI中列出边缘服务器，网关
- en: From the preceding screenshot, we can see the Eureka web page reporting the
    same available instances as the API response in the previous step.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图，我们可以看到Eureka网页报告了与上一步API响应中相同的可用实例。
- en: Routing based on the host header
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主机头的路由
- en: Let’s wrap up by testing the route configuration based on the hostname used
    in the requests to see predicates and filters in use!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过测试基于请求中使用的主机名配置的路由来结束，以查看正在使用的断言和过滤器！
- en: 'Normally, the hostname in the request is set automatically in the `Host` header
    by the HTTP client. When testing the edge server locally, the hostname will be
    `localhost` – that is not so useful when testing hostname-based routing. However,
    we can cheat by specifying another hostname in the `Host` header in the call to
    the API. Let’s see how this can be done:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，请求中的主机名会由 HTTP 客户端自动设置在 `Host` 头部。当在本地测试边缘服务器时，主机名将是 `localhost` – 这在测试基于主机名的路由时并不那么有用。然而，我们可以在调用
    API 时通过指定 `Host` 头部中的另一个主机名来作弊。让我们看看如何做到这一点：
- en: 'To call for the `i.feel.lucky` hostname, use this code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调用 `i.feel.lucky` 主机名，请使用以下代码：
- en: '[PRE25]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Expect the response `200 OK`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期响应 `200 OK`。
- en: 'For the hostname `im.a.teapot`, use the following command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于主机名 `im.a.teapot`，请使用以下命令：
- en: '[PRE26]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Expect the response `418 I'm a teapot`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期响应 `418 I'm a teapot`。
- en: 'Finally, if not specifying any `Host` header, use `localhost` as the `Host`
    header:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果不指定任何 `Host` 头部，请使用 `localhost` 作为 `Host` 头部：
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Expect the response `501 Not Implemented`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期响应 `501 Not Implemented`。
- en: 'We can also use `i.feel.lucky` and `im.a.teapot` as real hostnames in the requests
    if we add them to the file `/etc/hosts`, specifying that they should be translated
    into the same IP address as `localhost`, that is, `127.0.0.1`. To do so, perform
    the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `i.feel.lucky` 和 `im.a.teapot` 添加到 `/etc/hosts` 文件中，并指定它们应转换为与 `localhost`
    相同的 IP 地址，即 `127.0.0.1`，我们也可以将它们用作请求中的真实主机名。为此，请执行以下步骤：
- en: 'Run the following command to add a row to the `/etc/hosts` file with the required
    information:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令向 `/etc/hosts` 文件添加一行包含所需信息：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now perform the same routing based on the hostname, but without specifying
    the `Host` header. Try it out by running the following commands:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以根据主机名执行相同的路由，但无需指定 `Host` 头部。通过运行以下命令来尝试：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Expect the same responses as previously, `200 OK` and `418 I'm a teapot`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期与之前相同的响应，`200 OK` 和 `418 I'm a teapot`。
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令关闭系统景观来结束测试：
- en: '[PRE30]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Clean up the `/etc/hosts` file from the DNS name translation we added for the
    hostnames, `i.feel.lucky` and `im.a.teapot`. Edit the `/etc/hosts` file and remove
    the line we added:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理 `/etc/hosts` 文件中为主机名 `i.feel.lucky` 和 `im.a.teapot` 添加的 DNS 名称转换。编辑 `/etc/hosts`
    文件并删除我们添加的行：
- en: '[PRE31]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These tests of the routing capabilities in the edge server end the chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对边缘服务器路由能力的测试结束了本章。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how Spring Cloud Gateway can be used as an edge
    server to control what services are allowed to be called from outside of the system
    landscape. Based on predicates, filters, and destination URIs, we can define routing
    rules in a very flexible way. If we want to, we can configure Spring Cloud Gateway
    to use a discovery service such as Netflix Eureka to look up the target microservice
    instances.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 Spring Cloud Gateway 作为边缘服务器来控制哪些服务可以从系统景观外部调用。基于断言、过滤器以及目标 URI，我们可以非常灵活地定义路由规则。如果我们想的话，我们可以配置
    Spring Cloud Gateway 使用发现服务，如 Netflix Eureka 来查找目标微服务实例。
- en: An important topic we still need address is how we prevent unauthorized access
    to the APIs exposed by the edge server, and how we can prevent third parties from
    intercepting traffic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍需要解决的一个重要问题是，我们如何防止对边缘服务器暴露的 API 的未授权访问，以及我们如何防止第三方拦截流量。
- en: In the next chapter, we will see how we can secure access to the edge server
    using standard security mechanisms, such as HTTPS, OAuth, and OpenID Connect.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用标准安全机制，如 HTTPS、OAuth 和 OpenID Connect 来保护边缘服务器的访问。
- en: Questions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the elements used to build a routing rule in Spring Cloud Gateway called?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于构建 Spring Cloud Gateway 路由规则中的元素被称为什么？
- en: What are the aforementioned elements used for?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些上述元素用于什么？
- en: How can we instruct Spring Cloud Gateway to locate microservice instances through
    a discovery service such as Netflix Eureka?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何指导 Spring Cloud Gateway 通过发现服务，如 Netflix Eureka 来定位微服务实例？
- en: In a Docker environment, how can we ensure that external HTTP requests to the
    Docker engine can only reach the edge server?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Docker 环境中，我们如何确保外部 HTTP 请求只能到达边缘服务器？
- en: How do we change the routing rules so that the edge server accepts calls to
    the `product-composite` service on the `http://$HOST:$PORT/api/product` URL instead
    of the currently used `http://$HOST:$PORT/product-composite`?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何更改路由规则，以便边缘服务器接受对 `http://$HOST:$PORT/api/product` URL 上的 `product-composite`
    服务的调用，而不是当前使用的 `http://$HOST:$PORT/product-composite`？
- en: Join our community on Discord
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
- en: '![](img/QR_Code1849216352344398875.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1849216352344398875.png)'
