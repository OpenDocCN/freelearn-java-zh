- en: '*Chapter 17*: Best Practices for Writing High-Quality Code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 17 章*：编写高质量代码的最佳实践'
- en: When programmers talk to each other, they often use jargon that cannot be understood
    by non-programmers, or is vaguely understood by the programmers of different programming
    languages. But those who use the same programming language understand each other
    just fine. Sometimes, it may also depend on how knowledgeable a programmer is.
    A novice may not understand what an experienced programmer is talking about, while
    a seasoned colleague nods and responds in kind. This chapter is designed to fill
    this gap and improve the understanding between programmers of different levels.
    In this chapter, we will discuss some Java programming jargon – the Java idioms
    that describe certain features, functionality, design solutions, and so on. You
    will also learn about the most popular and useful practices for designing and
    writing application code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员之间交流时，他们经常使用非程序员无法理解或不同编程语言程序员模糊理解的术语。但使用相同编程语言的人可以很好地理解彼此。有时，这也可能取决于程序员的了解程度。新手可能无法理解经验丰富的程序员在谈论什么，而经验丰富的同事则会点头并相应地回应。本章旨在填补这一差距，提高不同水平程序员之间的理解。在本章中，我们将讨论一些
    Java 编程术语——描述某些特性、功能、设计解决方案等的 Java 习惯用法。你还将了解设计和编写应用程序代码最流行和最有用的实践。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Java idioms, their implementation, and their usage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 习惯用法、它们的实现和它们的用法
- en: The `equals()`, `hashCode()`, `compareTo()`, and `clone()` methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`, `hashCode()`, `compareTo()`, 和 `clone()` 方法'
- en: The `StringBuffer` and `StringBuilder` classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringBuffer` 和 `StringBuilder` 类'
- en: The `try`, `catch`, and `finally` clauses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`、`catch` 和 `finally` 子句'
- en: Best design practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳设计实践
- en: Code is written for people
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写的代码是为了给人看
- en: Use well-established frameworks and libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用经过良好建立的框架和库
- en: Testing is the shortest path to quality code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是通往高质量代码的最短路径
- en: By the end of this chapter, you will have a solid understanding of what other
    Java programmers are talking about while discussing their design decisions and
    the functionality they use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深刻理解其他 Java 程序员在讨论他们的设计决策和使用的功能时所谈论的内容。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To execute the code examples provided in this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章提供的代码示例，你需要以下内容：
- en: A computer with either Microsoft Windows, Apple macOS, or Linux
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有 Microsoft Windows、Apple macOS 或 Linux 的计算机
- en: Java SE version 17 or later
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 版本 17 或更高版本
- en: An IDE or code editor of your choice
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你选择的 IDE 或代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015)*,* *Getting Started with
    Java 17*. The files containing the code examples for this chapter are available
    on GitHub at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the examples/src/main/java/com/packt/learnjava/ch17_bestpractices folder and
    in the `spring` and `reactive` folders.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置 Java SE 和 IntelliJ IDEA 编辑器的说明已在 [*第 1 章*](B18388_01_ePub.xhtml#_idTextAnchor015)*,*
    *开始使用 Java 17* 中提供。本章的代码示例文件可在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)，位于
    examples/src/main/java/com/packt/learnjava/ch17_bestpractices 文件夹以及 `spring` 和
    `reactive` 文件夹中。
- en: Java idioms, their implementation, and their usage
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 习惯用法、它们的实现和它们的用法
- en: In addition to serving as a means of communication among professionals, programming
    idioms are also proven programming solutions and common practices not directly
    derived from the language specification but born out of the programming experience.
    In this section, we are going to discuss the ones that are used most often. You
    can find and study the full list of idioms in the official Java documentation
    ([https://docs.oracle.com/javase/tutorial](https://docs.oracle.com/javase/tutorial)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为专业人士之间交流的手段外，编程习惯用法也是经过证明的编程解决方案和常见实践，这些解决方案并非直接来自语言规范，而是源于编程经验。在本节中，我们将讨论最常用的那些。你可以在官方
    Java 文档中找到并研究完整的习惯用法列表（[https://docs.oracle.com/javase/tutorial](https://docs.oracle.com/javase/tutorial)）。
- en: The equals() and hashCode() methods
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`equals()` 和 `hashCode()` 方法'
- en: 'The default implementation of the `equals()` and `hashCode()` methods in the
    `java.lang.Object` class looks as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Object` 类中 `equals()` 和 `hashCode()` 方法的默认实现如下：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the default implementation of the `equals()` method only compares
    memory references that point to the addresses where the objects are stored. Similarly,
    as you can see from the comments (quoted from the source code), the `hashCode()`
    method returns the same integer for the same object and a different integer for
    different objects. Let’s demonstrate this using the `Person` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`equals()`方法的默认实现仅比较指向存储对象地址的内存引用。同样，正如您从注释（从源代码中引用）中看到的那样，`hashCode()`方法为相同的对象返回相同的整数，而为不同的对象返回不同的整数。让我们使用`Person`类来演示这一点：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is an example of how the default `equals()` and `hashCode()` methods behave:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个默认的`equals()`和`hashCode()`方法行为的例子：
- en: '[PRE24]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output in your system might be slightly different.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您的系统中的输出可能会有所不同。
- en: The `person1` and `person2` references and their hash codes are equal because
    they point to the same object (the same area of memory and the same address),
    while the `person3` reference points to another object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`person1`和`person2`引用及其哈希码相等，因为它们指向同一个对象（相同的内存区域和相同的地址），而`person3`引用指向另一个对象。'
- en: 'In practice, though, as we described in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*, we would like the equality
    of the object to be based on the value of all or some of the object properties.
    So, here is a typical implementation of the `equals()` and `hashCode()` methods:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，正如我们在[*第6章*](B18388_06_ePub.xhtml#_idTextAnchor141)，*数据结构、泛型和常用工具*中所描述的，我们希望对象的相等性基于对象的所有属性或某些属性值。因此，下面是`equals()`和`hashCode()`方法的典型实现：
- en: '[PRE35]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It used to be more involved, but using `java.util.Objects` utilities makes it
    much easier, especially if you notice that the `Objects.equals()` method handles
    `null` too.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 过去这更为复杂，但使用`java.util.Objects`实用工具使得它变得容易得多，尤其是如果您注意到`Objects.equals()`方法也处理`null`。
- en: 'Here, we have added the described implementation of the `equals()` and `hashCode()`
    methods to the `Person1` class and executed the same comparisons:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将描述的`equals()`和`hashCode()`方法的实现添加到`Person1`类中，并执行了相同的比较：
- en: '[PRE49]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, the change we have made not only makes the same objects equal
    but makes two different objects with the same values of the properties equal too.
    Furthermore, the hash code value is now based on the values of the same properties
    as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们所做的更改不仅使相同的对象相等，而且使具有相同属性值的两个不同对象也相等。此外，哈希码值现在也基于相同的属性值。
- en: In [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures, Generics,
    and Popular Utilities*, we explained why it is important to implement the `hasCode()`
    method while implementing the `equals()` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18388_06_ePub.xhtml#_idTextAnchor141)，*数据结构、泛型和常用工具*中，我们解释了为什么在实现`equals()`方法的同时实现`hashCode()`方法很重要。
- en: The same set of properties must be used for establishing equality in the `equals()`
    method and for the hash calculation in the `hashCode()` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`equals()`方法中建立相等性和在`hashCode()`方法中进行哈希计算时必须使用相同的一组属性。
- en: Having the `@Override` annotation in front of these methods assures that they
    override the default implementation in the `Object` class. Otherwise, a typo in
    the method’s name may create the illusion that the new implementation is being
    used when it isn’t. Debugging such cases has proved much more difficult and costly
    than just adding the `@Override` annotation, which generates an error if the method
    does not override anything.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法前加上`@Override`注解可以确保它们覆盖了`Object`类中的默认实现。否则，方法名称中的错误可能会造成一种假象，即新实现正在被使用，而实际上并没有。调试此类情况比仅仅添加`@Override`注解要困难得多，而且成本也更高，因为如果方法没有覆盖任何内容，`@Override`注解会生成一个错误。
- en: The compareTo() method
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`compareTo()`方法'
- en: In [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures, Generics,
    and Popular Utilities*, we used the `compareTo()` method (the only method of the
    `Comparable` interface) extensively and pointed out that the order that is established
    based on this method (its implementation by the elements of a collection) is called
    a **natural order**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18388_06_ePub.xhtml#_idTextAnchor141)，*数据结构、泛型和常用工具*中，我们广泛使用了`compareTo()`方法（`Comparable`接口的唯一方法），并指出基于此方法（集合元素的实现）建立的组织顺序被称为**自然顺序**。
- en: 'To demonstrate this, we created the `Person2` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们创建了`Person2`类：
- en: '[PRE60]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Then, we composed a list of `Person2` objects and sorted it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们组成了一列`Person2`对象并对其进行排序：
- en: '[PRE92]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The result looks as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/B18388_Figure_17.1.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_17.1.jpg)'
- en: 'There are three things worth noting:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有三件事值得注意：
- en: According to the `Comparable` interface, the `compareTo()` method must return
    a negative integer, zero, or a positive integer if the object is less than, equal
    to, or greater than another object. In our implementation, we returned the result
    immediately if the values of the same property of two objects were different.
    We already know that this object is *bigger* or *smaller*, regardless of what
    the other properties are. But the sequence in which you compare the properties
    of two objects, affects the final result. It defines the precedence in which the
    property value affects the order.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 `Comparable` 接口，`compareTo()` 方法必须返回一个负整数、零或正整数，如果对象小于、等于或大于另一个对象。在我们的实现中，如果两个对象的相同属性值不同，我们立即返回结果。我们已经知道，无论其他属性如何，这个对象是
    *更大* 或 *更小* 的。但是，比较两个对象属性顺序的顺序会影响最终结果。它定义了属性值影响顺序的优先级。
- en: We have put the result of `List.of()` into a `new ArrayList()` object. We did
    so because, as we mentioned in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*, the collection that’s created
    by the `of()` factory method is unmodifiable. No elements can be added or removed
    from it and the order of the elements cannot be changed either, while we need
    to sort the created collection. We only used the `of()` method because it is more
    convenient and provides a shorter notation.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `List.of()` 的结果放入了一个 `new ArrayList()` 对象中。我们这样做是因为，如我们已在 [*第6章*](B18388_06_ePub.xhtml#_idTextAnchor141)
    中提到的，*数据结构、泛型和常用工具*，由 `of()` 工厂方法创建的集合是不可修改的。无法向其中添加或删除元素，也无法更改元素的顺序，而我们需要对创建的集合进行排序。我们只使用
    `of()` 方法，因为它更方便，提供了更短的表示法。
- en: Finally, using `java.util.Objects` for comparing properties makes the implementation
    much easier and more reliable than custom coding.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用 `java.util.Objects` 来比较属性，使得实现比自定义编码更容易、更可靠。
- en: 'While implementing the `compareTo()` method, it is important to make sure that
    the following rules are not violated:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `compareTo()` 方法时，重要的是要确保以下规则不被违反：
- en: '`obj1.compareTo(obj2)` returns the same value as `obj2.compareTo(obj1)`, but
    only when the returned value is `0`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj1.compareTo(obj2)` 返回与 `obj2.compareTo(obj1)` 相同的值，但只有当返回值是 `0` 时。'
- en: If the returned value is not `0`, `obj1.compareTo(obj2)` has the opposite sign
    of `obj2.compareTo(obj1)`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回值不是 `0`，则 `obj1.compareTo(obj2)` 的符号与 `obj2.compareTo(obj1)` 相反。
- en: If `obj1.compareTo(obj2) > 0` and `obj2.compareTo(obj3) > 0`, then `obj1.compareTo(obj3)
    > 0`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `obj1.compareTo(obj2) > 0` 且 `obj2.compareTo(obj3) > 0`，那么 `obj1.compareTo(obj3)
    > 0`。
- en: If `obj1.compareTo(obj2) < 0` and `obj2.compareTo(obj3) < 0`, then `obj1.compareTo(obj3)
    < 0`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `obj1.compareTo(obj2) < 0` 且 `obj2.compareTo(obj3) < 0`，那么 `obj1.compareTo(obj3)
    < 0`。
- en: If `obj1.compareTo(obj2) == 0`, then `obj2.compareTo(obj3)` and `obj1.compareTo(obj3)
    > 0` have the same sign.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `obj1.compareTo(obj2) == 0`，那么 `obj2.compareTo(obj3)` 和 `obj1.compareTo(obj3)`
    具有相同的符号。
- en: Both `obj1.compareTo(obj2)` and `obj2.compareTo(obj1)` throw the same exceptions,
    if any.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj1.compareTo(obj2)` 和 `obj2.compareTo(obj1)` 如果抛出异常，则抛出相同的异常。'
- en: It is also recommended, but not always required, that if `obj1.equals(obj2)`,
    then `obj1.compareTo(obj2) == 0` and, at the same time, if `obj1.compareTo(obj2)
    == 0`, then `obj1.equals(obj2)`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，建议（但不总是必需）如果 `obj1.equals(obj2)`，则 `obj1.compareTo(obj2) == 0`，并且同时，如果 `obj1.compareTo(obj2)
    == 0`，则 `obj1.equals(obj2)`。
- en: The clone() method
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`clone()` 方法'
- en: 'The `clone()` method’s implementation in the `java.lang.Object` class looks
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Object` 类中 `clone()` 方法的实现如下：'
- en: '[PRE102]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The comment shown in the preceding code states the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中显示的注释说明了以下内容：
- en: '[PRE104]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The default result of this method returns a copy of the object fields as-is,
    which is fine if the values are of primitive types. However, if an object property
    holds a reference to another object, only the reference itself will be copied,
    not the referred object. That is why such a copy is called a `clone()` method
    and clone each of the object properties that refers to an object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的默认结果返回对象字段的副本，如果值是原始类型，则这是可以接受的。然而，如果一个对象属性持有对另一个对象的引用，则只会复制引用本身，而不是被引用的对象。这就是为什么这样的复制被称为
    `clone()` 方法，并克隆每个引用对象的属性。
- en: In any case, to be able to clone an object, it must implement the `Cloneable`
    interface and make sure that all the objects along the inheritance tree (and the
    properties that are objects) implement the `Cloneable` interface too (except the
    `java.lang.Object` class). The `Cloneable` interface is just a marker interface
    that tells the compiler that the programmer made a conscious decision to allow
    this object to be cloned (whether it’s because the shallow copy was good enough
    or because the `clone()` method was overridden). An attempt to call `clone()`
    on an object that does not implement the `Cloneable` interface will result in
    a `CloneNotSupportedException`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，为了能够克隆一个对象，它必须实现`Cloneable`接口，并确保继承树上的所有对象（以及是对象的属性）也实现`Cloneable`接口（除了`java.lang.Object`类）。`Cloneable`接口只是一个标记接口，它告诉编译器程序员已经做出了有意识的决策，允许这个对象被克隆（无论是由于浅拷贝足够好，还是因为重写了`clone()`方法）。尝试在未实现`Cloneable`接口的对象上调用`clone()`将导致`CloneNotSupportedException`。
- en: 'It looks complex already, but in practice, there are even more pitfalls. For
    example, let’s say that the `Person` class has an `address` property of the `Address`
    type. The shallow copy, `p2`, of the `Person` object, `p1`, will refer to the
    same object of `Address` so that `p1.address == p2.address`. Here is an example.
    The `Address` class looks as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来已经很复杂了，但在实践中，还有更多的陷阱。例如，假设`Person`类有一个`address`属性，其类型为`Address`。`Person`对象`p1`的浅拷贝`p2`将引用相同的`Address`对象，因此`p1.address
    == p2.address`。以下是一个例子。`Address`类如下所示：
- en: '[PRE108]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `Person3` class uses it like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person3`类是这样使用的：'
- en: '[PRE119]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Notice that the `clone()` method does a shallow copy because it does not clone
    the `address` property. Here is the result of using such a `clone()` method implementation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`clone()`方法执行的是浅拷贝，因为它没有克隆`address`属性。以下是使用这种`clone()`方法实现的示例：
- en: '[PRE139]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: As you can see, after the cloning is complete, the change that was made to the
    `address` property of the source object is reflected in the same property of the
    clone. That isn’t very intuitive, is it? While cloning, we expected an independent
    copy, didn’t we?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在克隆完成后，对源对象`address`属性的更改反映在克隆对象的相同属性中。这并不直观，对吧？在克隆过程中，我们期望得到一个独立的副本，不是吗？
- en: 'To avoid sharing the `Address` object, you must clone it explicitly too. To
    do so, you must make the `Address` object cloneable, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免共享`Address`对象，您还必须显式地克隆它。为此，您必须使`Address`对象可克隆，如下所示：
- en: '[PRE155]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'With that implementation in place, we can now add the `address` property for
    cloning:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现到位后，我们现在可以为克隆添加`address`属性：
- en: '[PRE170]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Now, if we run the same test, the results are going to be as we expected them
    originally:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行相同的测试，结果将是我们最初预期的：
- en: '[PRE192]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: So, if the application expects all the properties to be deeply copied, all the
    objects involved must be cloneable. That is fine so long as none of the related
    objects, whether it’s a property in the current object or the parent class (and
    their properties and parents), do not acquire a new object property without making
    them cloneable and are cloned explicitly in the `clone()` method of the container
    object. This last statement is complex. The reason for its complexity is due to
    the underlying complexity of the cloning process. That is why programmers often
    stay away from making objects cloneable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果应用程序期望所有属性都进行深度复制，所有相关的对象都必须是可克隆的。只要相关的对象（无论是当前对象的属性还是父类及其属性和父类）在没有使它们可克隆的情况下不获取新的对象属性，并且在容器对象的`clone()`方法中显式克隆，那就没问题。这个最后的陈述很复杂。其复杂性的原因在于克隆过程的底层复杂性。这就是为什么程序员常常避免使对象可克隆。
- en: 'Instead, they prefer to clone the object manually, if need be, as shown in
    the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，他们更倾向于在必要时手动克隆对象，如下面的代码所示：
- en: '[PRE207]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: This approach still requires code changes if another property is added to any
    related object. However, it provides more control over the result and has less
    chance of unexpected consequences.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法仍然需要在任何相关对象中添加其他属性时进行代码更改。然而，它提供了对结果更多的控制，并且不太可能出现意外的后果。
- en: Fortunately, the `clone()` method is not used very often. You may never encounter
    a need to use it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`clone()`方法并不常用。您可能永远不会遇到需要使用它的需求。
- en: The StringBuffer and StringBuilder classes
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`StringBuffer`和`StringBuilder`类'
- en: We talked about the difference between the `StringBuffer` and `StringBuilder`
    classes in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures,
    Generics, and Popular Utilities*. We are not going to repeat this here. Instead,
    we will just mention that, in a single-threaded process (which is the vast majority
    of cases), the `StringBuilder` class is the preferred choice because it is faster.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第6章*](B18388_06_ePub.xhtml#_idTextAnchor141)，“数据结构、泛型和常用工具”中讨论了`StringBuffer`和`StringBuilder`类的区别。我们在这里不再重复。相反，我们只想提到，在单线程过程中（这是大多数情况），`StringBuilder`类是首选，因为它更快。
- en: The try, catch, and finally clauses
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try、catch和finally子句
- en: '[*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110), *Exception Handling*,
    is dedicated to using the `try`, `catch`, and `finally` clauses, so we are not
    going to repeat this here. We would like to repeat that using a `try-with-resources`
    statement is the preferred way to release resources (traditionally done in a `finally`
    block). Deferring the library makes the code simpler and more reliable.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第4章*](B18388_04_ePub.xhtml#_idTextAnchor110)，“异常处理”专门讨论了使用`try`、`catch`和`finally`子句，所以我们在这里不再重复。我们想重申，使用`try-with-resources`语句是释放资源（传统上在`finally`块中完成）的首选方式。推迟库使代码更简单、更可靠。'
- en: Best design practices
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳设计实践
- en: The term *best* is often subjective and context-dependent. That is why we would
    like to disclose that the following recommendations are based on the vast majority
    of cases in mainstream programming. However, they should not be followed blindly
    and unconditionally because there are cases when some of these practices, in some
    contexts, are useless or even wrong. Before following them, try to understand
    the motivation behind them and use it as a guide for your decisions. For example,
    size matters. If the application is not going to grow beyond a few thousand lines
    of code, a simple monolith with laundry-list-style code is good enough. But if
    there are complicated pockets of code and several people working on it, breaking
    the code into specialized pieces would be beneficial for code understanding, maintenance,
    and even scaling, if one particular code area requires more resources than others.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*最佳*通常是主观的和情境依赖的。这就是为什么我们想透露，以下建议是基于主流编程中绝大多数情况。然而，它们不应该盲目和无条件地遵循，因为有些情况下，这些实践中的某些，在某些情境下，可能是无用的，甚至是错误的。在遵循它们之前，试着理解它们背后的动机，并将其用作你决策的指南。例如，大小很重要。如果应用程序不会增长到几千行代码，一个简单的单体，具有清单式代码就足够了。但如果存在复杂的代码块，并且有几个人在处理它，将代码分解成专门的片段将有利于代码理解、维护，甚至如果某个特定的代码区域需要比其他区域更多的资源，还有助于扩展。
- en: We will start with higher-level design decisions in no particular order.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将无特定顺序地从更高层次的设计决策开始。
- en: Identifying loosely coupled functional areas
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别松散耦合的功能区域
- en: 'These design decisions can be made very early on, based just on the general
    understanding of the main parts of the future system, their functionality, and
    the data they produce and exchange. There are several benefits of doing this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计决策可以在非常早期就做出，仅基于对未来系统主要部分的总体理解，它们的功能，以及它们产生和交换的数据。这样做有几个好处：
- en: You can identify the structure of the future system, which has bearings on the
    further design steps and implementation
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以识别未来系统的结构，这对后续的设计步骤和实施有影响
- en: You can specialize in and analyze parts deeply
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以专门分析和深入研究部分
- en: You can develop parts in parallel
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以并行开发部分
- en: You can have a better understanding of the data flow
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以更好地理解数据流
- en: Breaking the functional area into traditional tiers
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将功能区域分解为传统的层级
- en: 'With each functional area in place, specializations based on the technical
    aspects and technologies can be used. The traditional separation of technical
    specialization is as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个功能区域就位后，可以根据技术方面和技术使用专门化。传统的技术专门化分离如下：
- en: The frontend (user graphic or web interface)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端（用户图形或网络界面）
- en: The middle tier with extensive business logic
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有广泛业务逻辑的中层
- en: The backend (data storage or data source)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端（数据存储或数据源）
- en: 'The benefits of doing this include the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的好处包括以下内容：
- en: You can deploy and scale by tiers
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以按层级部署和扩展
- en: You can gain programmer specialization based on your expertise
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以根据你的专业知识获得程序员的专业化
- en: You can develop parts in parallel
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以并行开发部分
- en: Coding to an interface
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向接口编码
- en: The specialized parts, based on the decisions described in the previous two
    subsections, must be described in an interface that hides the implementation details.
    The benefits of such a design lie in the foundations of **object-oriented programming**
    (**OOP**) and were described in detail in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*, so we are not going to repeat this here.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前两个小节中描述的决策，必须在一个隐藏实现细节的接口中描述专门的部分。这种设计的优势在于**面向对象编程**（**OOP**）的基础，这在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)《Java面向对象编程（OOP）》中已经详细描述，所以我们在这里不再重复。
- en: Using factories
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工厂
- en: We talked about this in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*, too. An interface, by definition, does
    not and cannot describe the constructor of a class that implements the interface.
    Using factories allows you to close this gap and expose just an interface to a
    client.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)《Java面向对象编程（OOP）》中也讨论了这一点。根据定义，接口不能也不能描述实现该接口的类的构造函数。使用工厂允许你关闭这个差距，并向客户端暴露一个接口。
- en: Preferring composition over inheritance
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先使用组合而非继承
- en: Originally, OOP focused on inheritance as a way to share the common functionality
    between objects. Inheritance is even one of the four OOP principles, as we have
    described in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented
    Programming (OOP)*. In practice, however, this method of functionality sharing
    creates too much dependency between classes included in the same inheritance line.
    The evolution of application functionality is often unpredictable, and some of
    the classes in the inheritance chain start to acquire functionality that’s unrelated
    to the original purpose of the class chain. We can argue that there are design
    solutions that allow us not to do this and keep the original classes intact. But,
    in practice, such things happen all the time, and the subclasses may suddenly
    change behavior just because they acquired new functionality through inheritance.
    We cannot choose our parents, can we? Besides, it breaks encapsulation this way,
    which is another foundational principle of OOP.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，OOP侧重于继承作为在对象之间共享公共功能的方法。继承甚至是我们描述在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)《Java面向对象编程（OOP）》中的四个OOP原则之一。然而，在实践中，这种功能共享方法在同一个继承线上的类之间产生了过多的依赖。应用程序功能的演变往往是不可预测的，继承链中的某些类开始获得与类链原始目的无关的功能。我们可以争论，有一些设计解决方案可以让我们不做这样的事情，并保持原始类不变。但是，在实践中，这样的事情经常发生，子类可能会突然改变行为，仅仅是因为它们通过继承获得了新的功能。我们无法选择我们的父母，对吧？此外，这样会破坏封装，这是OOP的另一个基础原则。
- en: Composition, on the other hand, allows us to choose and control which functionality
    of the class to use and which to ignore. It also allows the object to stay light
    and not be burdened by the inheritance. Such a design is more flexible, extensible,
    and predictable.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，组合允许我们选择和控制使用类的哪些功能以及忽略哪些功能。它还允许对象保持轻量级，不被继承所负担。这种设计更加灵活、可扩展和可预测。
- en: Using libraries
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用库
- en: Throughout this book, we have mentioned that using the **Java Class Library**
    (**JCL**) and external (to the **Java Development Kit** (**JDK**)) Java libraries
    makes programming much easier and produces code of higher quality. [*Chapter 7*](B18388_07_ePub.xhtml#_idTextAnchor169),
    *Java Standard and External Libraries*, contains an overview of the most popular
    Java libraries. People who create libraries invest a lot of time and effort, so
    you should take advantage of them any time you can.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们提到使用**Java类库**（**JCL**）和外部（相对于**Java开发工具包**（**JDK**））的Java库可以使编程更加容易，并产生更高质量的代码。[*第7章*](B18388_07_ePub.xhtml#_idTextAnchor169)《Java标准库和外部库》概述了最流行的Java库。创建库的人投入了大量的时间和精力，因此你应该在可能的情况下利用它们。
- en: In [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional Programming*,
    we described standard functional interfaces that reside in the `java.util.function`
    package of JCL. That is another way to take advantage of a library – by using
    its set of well-known and shared interfaces, instead of defining your own.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第13章*](B18388_13_ePub.xhtml#_idTextAnchor281)《函数式编程》中，我们描述了位于JCL的`java.util.function`包中的标准函数式接口。这是利用库的另一种方式——通过使用其一系列已知和共享的接口，而不是定义自己的接口。
- en: This last statement is a good segue to the next topic about writing code that
    can easily be understood by other people.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一点很好地过渡到下一个关于编写其他人容易理解的代码的主题。
- en: Code is written for people
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码是为人类编写的
- en: The first decades of programming required writing machine commands so that electronic
    devices could execute them. Not only was it a tedious and error-prone endeavor,
    but it also required you to write the instructions in a manner that yielded the
    best performance possible. This is because the computers were slow and did not
    do much code optimization, if at all.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的前几十年需要编写机器命令，以便电子设备能够执行它们。这不仅是一项繁琐且容易出错的任务，而且还需要你以产生最佳性能的方式编写指令。这是因为计算机速度慢，几乎没有进行代码优化。
- en: Since then, we have made a lot of progress in terms of both hardware and programming.
    The modern compiler went a long way toward making the submitted code work as fast
    as possible, even when a programmer did not think about it. We talked about this
    with specific examples in the previous chapter.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我们在硬件和编程方面都取得了很大的进步。现代编译器在很大程度上使提交的代码尽可能快地运行，即使程序员没有考虑这一点。我们在上一章中通过具体例子讨论了这一点。
- en: It allowed programmers to write more lines of code without thinking much about
    optimization. But tradition and many books about programming continued to call
    for it, and some programmers still worry about their code performance – more so
    than the results it produces. It is easier to follow tradition than to break away
    from it. That is why programmers tend to pay more attention to the way they write
    code than to the business they automate, although good code that implements incorrect
    business logic is useless.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得程序员可以写出更多的代码行，而不必过多考虑优化。但传统和许多关于编程的书籍仍然要求这样做，一些程序员仍然担心他们的代码性能——甚至比结果更重要。遵循传统比打破传统更容易。这就是为什么程序员往往更关注他们编写代码的方式，而不是他们自动化的业务，尽管实现错误业务逻辑的好代码是无用的。
- en: However, back to the topic. With modern JVM, the need for code optimization
    by a programmer is not as pressing as it used to be. Nowadays, a programmer must
    pay attention mostly to the big picture, to avoid structural mistakes that lead
    to poor code performance and to code that is used multiple times. The latter becomes
    less pressing as the JVM becomes more sophisticated, observing the code in real
    time, and just returning the results (without execution) when the same code block
    is called several times with the same input.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，回到主题。随着现代JVM的出现，程序员进行代码优化的需求不像以前那么迫切了。如今，程序员必须主要关注大局，避免导致代码性能不佳的结构性错误，以及多次使用的代码。随着JVM变得更加复杂，实时观察代码，并在相同的输入多次调用相同的代码块时仅返回结果（而不执行），后者变得不那么紧迫。
- en: That leaves us with the only conclusion possible – while writing code, you must
    make sure it is easy to read and understand for a human, not for a computer. Those
    who have worked in the industry for some time have been puzzled over code they
    wrote a few years prior. You can improve your code-writing style via clarity and
    the transparency of its intent.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这就让我们得出唯一可能的结论——在编写代码时，你必须确保代码对人类来说易于阅读和理解，而不是对计算机。那些在业界工作了一段时间的人可能会对几年前写的代码感到困惑。你可以通过清晰性和意图的透明度来改进你的代码编写风格。
- en: 'Now, let’s discuss the need for comments. We do not need comments that echo
    what the code does, as shown in the following example:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论注释的必要性。我们不需要注释来重复代码的功能，如下面的例子所示：
- en: '[PRE225]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'The comments that explain the intent are much more valuable:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 解释意图的注释更有价值：
- en: '[PRE227]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'The commented code can be very complex. Good comments explain the intent and
    provide guidance that helps us understand the code. Yet, programmers often do
    not bother to write comments. The argument against writing comments typically
    includes two statements:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注释的代码可能非常复杂。好的注释能够解释意图并提供帮助，使我们理解代码。然而，程序员往往懒得写注释。反对写注释的论点通常包括以下两点：
- en: Comments must be maintained and evolve along with the code; otherwise, they
    may become misleading. However, no tool can prompt the programmer to adjust the
    comments along with changing the code. Thus, comments are dangerous.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释必须与代码一起维护和更新；否则，它们可能会产生误导。然而，没有任何工具能够提示程序员在更改代码的同时调整注释。因此，注释是有风险的。
- en: The code itself must be written (including name selection for variables and
    methods) so that no extra explanation is needed.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码本身必须编写（包括变量和方法名称的选择）以便不需要额外的解释。
- en: Both statements are true, but it is also true that comments can be very helpful,
    especially those that capture the intent. Besides, such comments tend to require
    fewer adjustments because the code intent doesn’t change often, if ever.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个陈述都是正确的，但事实也是，注释可以非常有帮助，尤其是那些捕捉意图的注释。此外，这样的注释通常需要更少的调整，因为代码意图不经常改变，甚至从不改变。
- en: Use well-established frameworks and libraries
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用成熟的框架和库
- en: Programmers are not always given a chance to select the framework and libraries
    to develop the software. Often, the company prefers to stay with the set of software
    and development tools they have already used for other projects. But when you
    get such a possibility of choosing, the variety of available products may be overwhelming.
    It may also be tempting to select the latest new offer that is trending in the
    programming community. Nevertheless, experience proves time and again that the
    best course of action would be to select something well–established and proven
    to be production-strong. Besides, using solid software with a long history requires
    typically writing less boilerplate code.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员并不总是有机会选择框架和库来开发软件。通常，公司更愿意继续使用他们已经用于其他项目的软件和开发工具集。但是，当您有机会选择时，可用的产品种类可能会让人感到不知所措。选择编程社区中最新流行的产品也可能很有吸引力。然而，经验一次又一次地证明，最佳的行动方案是选择一些成熟且经过证明的生产级产品。此外，使用历史悠久且稳固的软件通常需要编写更少的样板代码。
- en: 'To demonstrate this point, we created two projects:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们创建了两个项目：
- en: Using the Spring Boot framework
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 框架
- en: Using the **Vert.x** toolkit
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Vert.x** 工具包
- en: We start with Spring Boot. It is an open source Java-based framework, developed
    by the Pivotal Team for building standalone production-strong applications. By
    default, it does not need an external web server, because it embeds a web server
    (Tomcat or Netty). As a result, the Spring Boot user does not need to write any
    non-business code. You don’t need even to create configuration, as in Spring.
    You just define which non-business features you need (such as health check, metrics,
    or swagger doc, for example) using the properties file and tune them using annotation.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Spring Boot 开始。它是一个开源的基于 Java 的框架，由 Pivotal 团队开发，用于构建独立的生产级应用程序。默认情况下，它不需要外部
    web 服务器，因为它内置了一个 web 服务器（Tomcat 或 Netty）。因此，Spring Boot 用户不需要编写任何非业务代码。您甚至不需要创建配置，就像在
    Spring 中那样。您只需定义您需要的非业务功能（例如健康检查、指标或 Swagger 文档等）使用属性文件，并通过注解进行调整。
- en: Naturally, because there is so much implemented behind the scenes, Spring Boot
    is very opinionated. But you would be hard-pressed to find a case when it cannot
    be used to produce a solid efficient application. Most probably, limitations of
    Spring Boot will manifest themselves in large-scale projects. The best approach
    for using Spring Boot is to embrace its way to do things, because by doing this
    you will save a lot of time and will get a robust and well-optimized solution.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，因为幕后有如此多的实现，Spring Boot 非常具有意见。但您很难找到一个不能用来生成稳固高效应用程序的案例。最有可能的是，Spring Boot
    的限制将在大型项目中显现出来。使用 Spring Boot 的最佳方法就是接受它的做事方式，因为这样做您可以节省大量时间，并获得一个健壮且经过优化的解决方案。
- en: To simplify dependency management, Spring Boot provides the required third-party
    dependencies for each type of application in the so-called `starter` JAR file.
    For example, spring-boot-starter-web brings into the project all the libraries
    necessary for Spring MVC (Model-View-Controller) and the Tomcat web server. Based
    on the selected starter package, Spring Boot automatically configures the application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化依赖管理，Spring Boot 提供了所谓的 `starter` JAR 文件中每个类型应用程序所需的第三方依赖项。例如，spring-boot-starter-web
    将所有必要的库引入到项目中，用于 Spring MVC（模型-视图-控制器）和 Tomcat web 服务器。基于所选的 `starter` 包，Spring
    Boot 自动配置应用程序。
- en: You can find comprehensive and well-written information for programmers of all
    levels – from beginners to experienced professionals – at [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot).
    If you plan to use Spring Boot in your line of work, we encourage you to read
    it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)
    找到针对所有级别程序员的全面且编写良好的信息——从初学者到经验丰富的专业人士。如果您计划在工作中使用 Spring Boot，我们鼓励您阅读它。
- en: To demonstrate Spring Boot capabilities and advantages, we created a project
    in the `spring` folder. To run this sample application, you need the database,
    created in [*Chapter 10*](B18388_10_ePub.xhtml#_idTextAnchor230), *Managing Data
    in a Database,* of this book, up and running. The sample application manages (creates,
    reads, updates, deletes) records of persons in the database. This functionality
    is accessible via the UI (HTML pages), which is human-oriented. In addition, we
    implemented access to the same functionality via RESTful services, which can be
    used by other applications.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Spring Boot 的功能和优势，我们在 `spring` 文件夹中创建了一个项目。要运行此示例应用程序，您需要运行此书第 *10* 章，*在数据库中管理数据*
    中创建的数据库。该示例应用程序管理（创建、读取、更新、删除）数据库中的人员记录。此功能可以通过用户界面（HTML 页面）访问，面向人类。此外，我们还实现了通过
    RESTful 服务访问相同功能，这些服务可以被其他应用程序使用。
- en: 'You can run the application from an IDE by executing the `Application` class.
    Alternatively, you can start the application from the command line. There are
    two command files in the `spring` folder: `mvnw` (for Unix/Linux/Mac systems)
    and `mvnw.cmd` (for Windows). They can be used to launch the application as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行 `Application` 类从 IDE 运行应用程序。或者，您可以从命令行启动应用程序。在 `spring` 文件夹中有两个命令文件：`mvnw`（用于
    Unix/Linux/Mac 系统）和 `mvnw.cmd`（用于 Windows）。它们可以用来启动应用程序，如下所示：
- en: 'For Unix/Linux/Mac systems:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Unix/Linux/Mac 系统：
- en: '[PRE233]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'For Windows:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Windows：
- en: '[PRE234]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'When you do it the first time, you may get an error:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次这样做时，可能会出错：
- en: '[PRE235]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'If that happens, install the Maven wrapper by executing the following command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，请通过执行以下命令安装 Maven 包装器：
- en: '[PRE236]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Alternatively, you can build the executable `.jar` file:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以构建可执行的 `.jar` 文件：
- en: 'For Unix/Linux/Mac systems:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Unix/Linux/Mac 系统：
- en: '[PRE237]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'For Windows:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Windows：
- en: '[PRE238]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Then you can put the created `.jar` file on any computer that has Java 17 installed
    and run it, using the following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将创建的 `.jar` 文件放在任何已安装 Java 17 的计算机上并运行它，使用以下命令：
- en: '[PRE239]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'After the application is running, execute the following command:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行后，执行以下命令：
- en: '[PRE240]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The `curl` command requires the application to create a new person record.
    The expected response looks as follows (the `id` value will be different every
    time you run this command):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` 命令需要应用程序创建一个新的个人记录。预期的响应如下（每次运行此命令时 `id` 值都会不同）：'
- en: '[PRE241]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: To see the HTTP code in the response, add the option `-v` to the command. The
    HTTP code 200 indicates successful processing of the request.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看响应中的 HTTP 状态码，请将选项 `-v` 添加到命令中。HTTP 状态码 200 表示请求处理成功。
- en: 'Now let’s execute the `update` command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行 `update` 命令：
- en: '[PRE242]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'The application responds to this command as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序会以以下方式响应此命令：
- en: '[PRE243]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Notice that not all fields in the payload have to be populated. Only the `id`
    value is required and has to match with one of the existing records. The application
    retrieves the current `Person` record by the provided `id` value and updates only
    those properties that are provided.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不是所有字段都必须在有效负载中填充。只需要 `id` 值，并且必须与现有记录之一匹配。应用程序通过提供的 `id` 值检索当前的 `Person`
    记录，并仅更新提供的属性。
- en: 'The `delete` endpoint is similarly constructed. The difference is that the
    data (the `Person` record identity number `id`) is passed as part of the URL.
    Now let’s execute the following command:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 端点构建方式类似。区别在于数据（`Person` 记录身份号码 `id`）作为 URL 的一部分传递。现在让我们执行以下命令：'
- en: '[PRE245]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'The application responds to this command with the following message:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序会以以下消息响应此命令：
- en: '[PRE246]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'The list of all the existing records can be retrieved with the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令检索所有现有记录的列表：
- en: '[PRE248]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: All the preceding functionalities can be accessed via the UI. Type in the browser
    the URL `http://localhost:8083/ui/list` and click the corresponding links.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先前功能都可以通过用户界面访问。在浏览器中输入 URL `http://localhost:8083/ui/list` 并点击相应的链接。
- en: 'You can also type `http://localhost:8083` in the browser URL and access the
    following page:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在浏览器 URL 中输入 `http://localhost:8083` 并访问以下页面：
- en: '![](img/B18388_Figure_17.2.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_17.2.jpg)'
- en: Then again, click any of the available links. The `Home` page presents information
    about the current application version and its heath. The `http://localhost:8083/swagger-ui.html`
    URL brings up the list of all the application endoints.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次点击任何可用的链接。`Home` 页面展示了当前应用程序版本及其健康状况。`http://localhost:8083/swagger-ui.html`
    URL 会显示所有应用程序端点列表。
- en: We highly encourage you to study the application code and read the Spring Boot
    documentation on the [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)
    website.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议你研究应用程序代码并阅读[https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)网站上的Spring
    Boot文档。
- en: Now let us look in the project in the `reactive` folder. It demonstrates the
    reactive methods of communication, using Vert.x, which is an event-driven non-blocking
    lightweight polyglot toolkit. It allows you to write components in Java, JavaScript,
    Groovy, Ruby, Scala, Kotlin, and Ceylon. It supports an asynchronous programming
    model and a distributed event bus that reaches into the JavaScript browser, thus
    allowing the creation of real-time web applications. However, because of the focus
    of this book, we are going to use Java only.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看`reactive`文件夹中的项目。它展示了使用Vert.x的响应式通信方法，Vert.x是一个事件驱动的非阻塞轻量级多语言工具包。它允许你使用Java、JavaScript、Groovy、Ruby、Scala、Kotlin和Ceylon编写组件。它支持异步编程模型和分布式事件总线，该总线延伸到JavaScript浏览器，从而允许创建实时Web应用程序。然而，由于本书的焦点，我们将只使用Java。
- en: To demonstrate how a reactive system of microservices may look if implemented
    using the **Vert**.x toolkit, we have created an HTTP server that can accept a
    REST-based request to the system, send an EventBus-based message to another *verticle*
    (the fundamental processing unit in the **Vert**.x toolkit that can be deployed),
    receive a reply, and send the response back to the original request.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如果使用**Vert**.x工具包实现微服务响应式系统可能看起来是什么样子，我们创建了一个可以接受基于REST的请求到系统的HTTP服务器，向另一个*verticle*（**Vert**.x工具包中的基本处理单元，可以被部署）发送基于EventBus的消息，接收回复，并将响应发送回原始请求。
- en: 'We created two verticles:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个verticles：
- en: '`HttpServerVert`, which acts as a server and receives HTTP messages, which
    then sends them to a particular address via the EventBus(a lightweight distributed
    messaging system)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpServerVert`，它作为一个服务器并接收HTTP消息，然后将这些消息通过EventBus（一个轻量级的分布式消息系统）发送到特定的地址'
- en: '`MessageRcvVert`, which listens messages on a particular event-bus address'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageRcvVert`，它监听特定的事件总线地址上的消息'
- en: 'Now we can deploy them as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下方式部署它们：
- en: '[PRE249]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'To execute this code, run the `ReactiveSystemDemo` class. The result is expected
    to be as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此代码，运行`ReactiveSystemDemo`类。预期的结果是如下所示：
- en: '![](img/B18388_Figure_17.3.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_17.3.jpg)'
- en: 'Let’s now start sending HTTP requests to our system. First, let’s send the
    same HTTP `GET` request three times:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始向我们的系统发送HTTP请求。首先，让我们发送三次相同的HTTP `GET`请求：
- en: '![](img/B18388_Figure_17.4.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_17.4.jpg)'
- en: 'If there are several verticles registered with the same address (as it is in
    our case: we have registered two verticles with the same `One` address), the system
    uses a round-robin algorithm to select the verticle that should receive the next
    message.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个verticles注册了相同的地址（正如我们的情况：我们注册了两个具有相同`One`地址的verticles），系统将使用轮询算法选择应该接收下一个消息的verticle。
- en: The first request went to the receiver with `ID="1"`, the second request went
    to the receiver with `ID="2"`, and the third request went to the receiver with
    `ID="1"` again.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次请求发送到了`ID="1"`的接收者，第二次请求发送到了`ID="2"`的接收者，第三次请求又发送到了`ID="1"`的接收者。
- en: 'We get the same results using the HTTP `POST` request for the `/some/path/send`
    path:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP `POST`请求对`/some/path/send`路径，我们得到相同的结果：
- en: '![](img/B18388_Figure_17.5.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_17.5.jpg)'
- en: Again, the receiver of the message is rotated using the round-robin algorithm.
    Now, let’s publish a message to our system twice.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，消息的接收者使用轮询算法进行轮换。现在，让我们向我们的系统发布两次消息。
- en: 'Since the receiver’s reply cannot propagate back to the system user, we need
    to take a look at the messages that are logged on the backend:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收者的回复不能传播回系统用户，我们需要查看后端记录的消息：
- en: '![](img/B18388_Figure_17.6.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_17.6.jpg)'
- en: As you can see, the `publish()` method sends the message to all verticles that
    are registered to the specified address. And note that the verticle with `ID="3"`
    (registered with the `Two` address) never received a message.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`publish()`方法将消息发送到注册到指定地址的所有verticles。请注意，具有`ID="3"`（在`Two`地址上注册）的verticle从未收到任何消息。
- en: Before we wrap up this reactive system demonstration, it is worth mentioning
    that the **Vert.x** toolkit allows you to easily cluster verticles. You can read
    about this feature in the **Vert.x** documentation at [https://vertx.io/docs/vertx-core/java](https://vertx.io/docs/vertx-core/java).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这个反应式系统演示之前，值得提一下，**Vert.x**工具包允许你轻松地集群verticles。你可以在[https://vertx.io/docs/vertx-core/java](https://vertx.io/docs/vertx-core/java)的**Vert.x**文档中了解更多关于这个功能的信息。
- en: These two examples demonstrated how little code you have to write in order to
    create a complete web application if you use a well-established framework. It
    does not mean that you cannot explore the latest and greatest of frameworks. By
    any means, you can and should do it to stay abreast with progress in your industry.
    Just keep in mind that it takes some time for a new product to mature and become
    reliable and helpful enough for creating a production-strong software solution.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子展示了如果你使用一个成熟的框架，创建一个完整的网络应用所需的代码量是多么少。这并不意味着你不能探索最新和最好的框架。无论如何，你应该这样做，以跟上你所在行业的进步。只需记住，一个新产品要成熟并变得足够可靠和有用，以创建一个强大的生产级软件解决方案，需要一些时间。
- en: Testing is the shortest path to quality code
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试是通往高质量代码的捷径
- en: 'The last best practice we will discuss is this statement: *testing is not an
    overhead or a burden; it is the programmer’s guide to success*. The only question
    is when to write the test.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一条最佳实践是这一声明：*测试不是额外的负担；它是程序员成功的指南*。唯一的问题是何时编写测试。
- en: There is a compelling argument that requires writing a test before any line
    of code is written. If you can do it, that is great. We are not going to try and
    talk you out of it. But if you do not do it, try to start writing a test after
    you have written one, or all, the lines of code you have been tasked to write.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个强有力的论点要求在编写任何代码行之前编写测试。如果你能这样做，那很好。我们不会试图说服你放弃。但如果你不这样做，在你编写了一行或所有分配给你的代码之后，尝试开始编写测试。
- en: In practice, many experienced programmers find it helpful to start writing testing
    code after some of the new functionality is implemented. This is because that
    is when the programmer understands better how the new code fits into the existing
    context. They may even try and hardcode some values to see how well the new code
    is integrated with the code that calls the new method. After making sure the new
    code is well integrated, the programmer can continue implementing and tuning it,
    all while testing the new implementation against the requirements in the context
    of the calling code.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，许多经验丰富的程序员发现，在实现一些新功能之后开始编写测试代码是有帮助的。这是因为这时程序员能更好地理解新代码如何融入现有环境。他们甚至可能尝试硬编码一些值，以查看新代码与调用新方法的代码的集成情况。在确保新代码良好集成后，程序员可以继续实现和调整它，同时测试新实现与调用代码上下文中的要求。
- en: One important qualification must be added – while writing the test, it is better
    if the input data and the test criteria are set not by you, but by the person
    who assigned you the task or the tester. Setting the test according to the results
    the code produces is a well-known programmer’s trap. Objective self-assessment
    is not easy, if at all possible.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 必须添加一个重要条件——在编写测试时，最好由分配任务给你的人或测试员来设置输入数据和测试标准。根据代码产生的结果来设置测试是一个众所周知的程序员陷阱。客观的自我评估并不容易，如果可能的话。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the Java idioms that a mainstream programmer encounters
    daily. We also discussed the best design practices and related recommendations,
    including code-writing styles and testing.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了主流程序员在日常工作中遇到的Java惯用法。我们还讨论了最佳设计实践和相关建议，包括代码编写风格和测试。
- en: You also learned about the most popular Java idioms related to certain features,
    functionalities, and design solutions. These idioms were demonstrated with practical
    examples, where you learned how to incorporate them into your code and the professional
    language that’s used to communicate with other programmers.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解了一些与特定功能、功能性和设计解决方案相关的最流行的Java惯用法。这些惯用法通过实际示例进行了演示，你学习了如何将它们融入你的代码和与程序员交流的专业语言。
- en: This chapter concludes this book about Java 17 and its usage for writing effective
    application code. If you have read all of it, then you should have a very good
    overview of this topic and acquired valuable programming knowledge and skills
    you can immediately apply professionally. If you found this material valuable,
    then it makes us happy to know that we have achieved our goal. Thank you for reading.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了关于Java 17及其在编写有效应用程序代码中使用的书籍。如果你已经阅读了全部内容，那么你应该对这个主题有一个很好的概述，并获得了可以立即应用于专业领域的宝贵编程知识和技能。如果你觉得这些材料很有价值，那么让我们知道我们已经实现了我们的目标。感谢阅读。
- en: Quiz
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小测验
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的了解：
- en: 'Select all the correct statements:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Idioms can be used to communicate the code’s intent.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 习语可以用来传达代码的意图。
- en: Idioms can be used to explain what the code does.
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 习语可以用来解释代码的功能。
- en: Idioms can be misused and obscure the topic of conversation.
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 习语可能会被误用，从而模糊谈话的主题。
- en: Idioms should be avoided to express the idea clearly.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰地表达思想，应避免使用习语。
- en: Is it necessary to implement `hasCode()` every time `equals()` is implemented?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次实现`equals()`时是否必须实现`hasCode()`？
- en: If `obj1.compareTo(obj2)` returns a negative value, what does this mean?
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`obj1.compareTo(obj2)`返回负值，这意味着什么？
- en: Does the deep copy notion apply to a primitive value during cloning?
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 深拷贝的概念在克隆原始值时适用吗？
- en: Which is faster, `StringBuffer` or `StringBuilder`?
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StringBuffer`和`StringBuilder`哪个更快？'
- en: What are the benefits of coding to an interface?
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循接口编码有哪些好处？
- en: What are the benefits of using composition versus inheritance?
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用组合与继承相比有哪些好处？
- en: What is the advantage of using libraries versus writing your own code?
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用库与编写自己的代码相比有什么优势？
- en: Who is the target audience of your code?
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码的目标受众是谁？
- en: Is testing required?
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否需要测试？
