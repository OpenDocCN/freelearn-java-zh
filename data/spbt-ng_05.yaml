- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Building APIs with Spring
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 构建API
- en: In the previous chapter, you learned about the concepts and advantages of PostgreSQL
    and set it up on your local machine using the installer or the Docker container.
    You know how to configure **Spring Data Java Persistence API** (**Spring Data
    JPA**) on our project and use its provided repositories to perform **Create, Read,
    Update**, and **Delete** (**CRUD**) operations on our database with less boilerplate
    code. Lastly, you have also learned to connect your application with PostgreSQL
    using the **Java Database Connectivity** (**JDBC**) driver and Spring Data JPA.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了 PostgreSQL 的概念和优势，并使用安装程序或 Docker 容器在你的本地机器上设置了它。你知道如何在我们的项目中配置 **Spring
    Data Java 持久性 API**（**Spring Data JPA**），并使用其提供的存储库以更少的样板代码在我们的数据库上执行 **创建、读取、更新**
    和 **删除**（**CRUD**）操作。最后，你还学会了如何使用 **Java 数据库连接**（**JDBC**）驱动程序和 Spring Data JPA
    将你的应用程序与 PostgreSQL 连接。
- en: This chapter will create your Spring Boot **application programming interface**
    (**API**) project; we will focus on coding, making our models, and adding controllers
    and services to develop our endpoints. We will also add **Remote Dictionary Server**
    (**Redis**) for caching to help improve our application performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将创建你的 Spring Boot **应用程序编程接口**（**API**）项目；我们将专注于编码，创建我们的模型，并添加控制器和服务来开发我们的端点。我们还将添加
    **远程字典服务器**（**Redis**）进行缓存，以帮助提高我们的应用程序性能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Starting the server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动服务器
- en: Adding models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加模型
- en: Writing services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写服务
- en: Adding controllers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加控制器
- en: Adding Redis for caching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 Redis 进行缓存
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no technical requirements for this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有技术要求。
- en: 'The link to the finished version of this chapter can be found here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成版本的链接可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-05/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-05/superheroes)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-05/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-05/superheroes)'
- en: Starting the server
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'In this section, we will now attempt to run our Spring Boot application on
    our server but first, let’s have a recap of the previous chapter: we learned how
    to configure Spring Data JPA and connect our application to our PostgreSQL database,
    and—most importantly—we have installed all of the needed dependencies in our application.
    These are all prerequisites before running the Spring Boot application.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试在我们的服务器上运行我们的 Spring Boot 应用程序，但首先，让我们回顾一下上一章：我们学习了如何配置 Spring Data
    JPA 并将我们的应用程序连接到我们的 PostgreSQL 数据库，并且——最重要的是——我们已经在我们的应用程序中安装了所有需要的依赖项。在运行 Spring
    Boot 应用程序之前，这些都是先决条件。
- en: 'In the following examples, we will be using an application named `spring-boot-superheroes`.
    We will generate a new Spring Boot application using **Spring Initializr** with
    the same dependencies. Throughout developing our application, we will also show
    you several ways to write the different parts of your API, such as how to write
    models, services, and controllers. These are the most common ways used now in
    the industry. Still, first things first: let’s proceed with running our Spring
    Boot application.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用一个名为 `spring-boot-superheroes` 的应用程序。我们将使用 **Spring Initializr**
    生成一个新的 Spring Boot 应用程序，并带有相同的依赖项。在整个开发我们的应用程序的过程中，我们还将向你展示编写 API 不同部分的几种方法，例如如何编写模型、服务和控制器。这些是目前在行业中使用的最常见方法。但首先，让我们继续运行我们的
    Spring Boot 应用程序。
- en: 'We assume that you have already generated your Spring Boot application with
    the needed dependencies. However, if you have missed this part or are unsure whether
    all dependencies are included on your generated project, let’s list again all
    the dependencies we installed in the previous chapter, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经生成了带有所需依赖项的 Spring Boot 应用程序。然而，如果你错过了这一部分或者不确定是否在你的生成项目中包含了所有依赖项，那么让我们再次列出我们在上一章中安装的所有依赖项，如下所示：
- en: '**Spring Data JPA**: Dependency for adding Spring Data JPA used for built-in
    data store-related implementation.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Data JPA**：用于内置数据存储相关实现的 Spring Data JPA 依赖项。'
- en: '**PostgreSQL Driver**: A JDBC and **Reactive Relational Database Connectivity**
    (**R2DBC**) driver that will allow the connection of Java applications to the
    PostgreSQL database.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL 驱动程序**：一个 JDBC 和 **响应式关系型数据库连接**（**R2DBC**）驱动程序，它将允许 Java 应用程序连接到
    PostgreSQL 数据库。'
- en: '**H2 Database**: An in-memory database that supports JDBC API and R2DBC access;
    this is commonly used for unit testing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H2 数据库**：一个支持 JDBC API 和 R2DBC 访问的内存数据库；这通常用于单元测试。'
- en: 'If you have successfully initialized your application with the listed dependencies,
    open your project in your preferred **integrated development environment** (**IDE**);
    we will be using IntelliJ for Spring Boot in the following examples. Then, proceed
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已成功初始化应用程序并添加了列出的依赖项，请打开你首选的 **集成开发环境**（**IDE**）；在下面的示例中，我们将使用 IntelliJ 进行
    Spring Boot。然后，按照以下步骤操作：
- en: 'Expand the project folder; we will see several folders inside, as indicated
    in the following screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开项目文件夹；我们将看到里面有几个文件夹，如下面的截图所示：
- en: "![Figure 5.1 – Project structure of \uFEFFthe Spring Boot application](img/B18159_05_01.jpg)"
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Spring Boot 应用程序的项目结构](img/B18159_05_01.jpg)'
- en: Figure 5.1 – Project structure of the Spring Boot application
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Spring Boot 应用程序的项目结构
- en: We can see the files and folders in our Spring Boot application in the preceding
    screenshot. We can find our main class, named `SuperHeroesApplication`, under
    `src/main/java`. This main class will be used in running our application on the
    server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到我们的 Spring Boot 应用程序中的文件和文件夹。我们可以在 `src/main/java` 下找到名为 `SuperHeroesApplication`
    的主类。这个主类将用于在服务器上运行我们的应用程序。
- en: '`application.properties` is also an important file that we need to configure,
    as this is where all the properties are placed that are necessary for connecting
    to our database.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.properties` 也是一个重要的文件，我们需要对其进行配置，因为这个文件放置了所有连接到我们数据库所必需的属性。'
- en: 'Open the `application.properties` file, and we should set the following configuration:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `application.properties` 文件，我们应该设置以下配置：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This configuration will allow us to connect to our **PostgreSQL database** on
    our local machine. Remember that the database should exist on our PostgreSQL servers;
    otherwise, our application will not run successfully. If you haven’t created your
    database, open **pgAdmin** and enter your master password; on the left panel,
    expand the **Servers** section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将允许我们连接到我们本地机器上的 **PostgreSQL 数据库**。请记住，数据库应该存在于我们的 PostgreSQL 服务器上；否则，我们的应用程序将无法成功运行。如果你还没有创建你的数据库，打开
    **pgAdmin** 并输入你的主密码；在左侧面板中，展开 **服务器** 部分。
- en: 'You will see the PostgreSQL instance on your local machine. Right-click on
    the instance, select `postgres` user. This will now access the databases on our
    server, as illustrated in the following screenshot:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到你本地机器上的 PostgreSQL 实例。右键单击实例，选择 `postgres` 用户。这将现在访问我们服务器上的数据库，如下面的截图所示：
- en: '![Figure 5.2 – Accessing PostgreSQL server using pgAdmin](img/B18159_05_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 使用 pgAdmin 访问 PostgreSQL 服务器](img/B18159_05_02.jpg)'
- en: Figure 5.2 – Accessing PostgreSQL server using pgAdmin
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 使用 pgAdmin 访问 PostgreSQL 服务器
- en: 'After successfully accessing the server, right-click on **Database**, select
    **Create**, and click on **Database**; this will open the following modal:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功访问服务器后，右键单击 **数据库**，选择 **创建**，然后点击 **数据库**；这将打开以下模态：
- en: '![Figure 5.3 – Creating a database](img/B18159_05_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 创建数据库](img/B18159_05_03.jpg)'
- en: Figure 5.3 – Creating a database
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 创建数据库
- en: In the preceding screenshot, we named our database `SpringDevDB` and set the
    `postgres` user value in the **Owner** field. Click **Save**, and our database
    is all set in our server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们已将数据库命名为 `SpringDevDB` 并在 **所有者** 字段中设置了 `postgres` 用户值。点击 **保存**，我们的数据库现在已在服务器上设置好。
- en: 'Our Spring Boot application is now ready to run on our server; in your IntelliJ
    IDE, click on **Add Configuration**, found on the upper-right side of the panel.
    This will open the modal where we will configure our entry point to run our application,
    as illustrated in the following screenshot:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们 Spring Boot 应用程序现在已准备好在服务器上运行；在你的 IntelliJ IDE 中，点击面板右上角的 **添加配置**。这将打开一个模态，我们将在此配置我们的入口点以运行应用程序，如下面的截图所示：
- en: '![Figure 5.4 – Adding configuration for Spring Boot](img/B18159_05_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 为 Spring Boot 添加配置](img/B18159_05_04.jpg)'
- en: Figure 5.4 – Adding configuration for Spring Boot
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 为 Spring Boot 添加配置
- en: 'Click on `SuperheroesApplication`, and this will automatically fill the program
    arguments with the correct fully qualified name of the class, as illustrated in
    the following screenshot:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `SuperheroesApplication`，这将自动填充程序参数为类的正确完全限定名称，如下面的截图所示：
- en: '![Figure 5.5 – Configuration for application](img/B18159_05_05.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 应用程序的配置](img/B18159_05_05.jpg)'
- en: Figure 5.5 – Configuration for application
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 应用程序的配置
- en: Click on **Apply** and then click **OK** to save the configuration changes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **应用**，然后点击 **确定**以保存配置更改。
- en: 'In the upper-right panel of the IDE, select the created configuration and run
    the project by clicking on the green play icon. The application will run on the
    installed Tomcat server on the default port `8080`; we can also use the terminal
    to check whether the Spring Boot project has successfully started on the server.
    You can see the process running in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IDE 的右上角面板中选择创建的配置，通过点击绿色的播放图标来运行项目。应用程序将在默认端口 `8080` 上安装的 Tomcat 服务器上运行；我们也可以使用终端来检查
    Spring Boot 项目是否已成功在服务器上启动。您可以在以下屏幕截图中看到正在运行的过程：
- en: '![Figure 5.6 – Spring Boot logs](img/B18159_05_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – Spring Boot 日志](img/B18159_05_06.jpg)'
- en: Figure 5.6 – Spring Boot logs
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – Spring Boot 日志
- en: In the preceding screenshot, we can see that our application has started successfully;
    we are also connected to our PostgreSQL database, and we can now start writing
    our code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我们的应用程序已成功启动；我们已连接到我们的 PostgreSQL 数据库，现在我们可以开始编写我们的代码。
- en: We will now try to create our application models in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节尝试创建我们的应用程序模型。
- en: Adding models
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型
- en: In this section, we will now write code for our application, and the first thing
    we will create is models. In simple terms, models are the object of our application;
    the models will serve as our entities and will define our tables in the database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们现在将编写我们的应用程序代码，我们将首先创建的是模型。简单来说，模型是应用程序的对象；模型将充当我们的实体，并定义数据库中的表。
- en: Once we create models and run the application, this will also generate tables
    in our database automatically with the help of annotations, which will also be
    discussed throughout this example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了模型并运行了应用程序，这将自动在数据库中生成表，这有助于注解，这一点将在整个示例中讨论。
- en: Creating models with DTOs and Lombok
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 DTOs 和 Lombok 创建模型
- en: We will first show you how to write models using Lombok and **data transfer
    objects** (**DTOs**). First, we will discuss DTOs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向您展示如何使用 Lombok 和 **数据传输对象**（**DTOs**）编写模型。首先，我们将讨论 DTOs。
- en: DTOs
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DTOs
- en: DTOs are responsible for carrying data between processes to reduce the number
    of method calls. DTOs are **plain old Java objects** (**POJOs**) that commonly
    consist of data accessors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs 负责在进程之间传输数据以减少方法调用的数量。DTOs 是 **普通的 Java 对象**（**POJOs**），通常由数据访问器组成。
- en: 'DTOs are very useful for creating representations of our entities to have views
    for clients without affecting the pattern and design. Let’s have an example use
    case for DTOs. You can see this here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs 对于创建我们实体的表示非常有用，以便为客户端提供视图，同时不影响模式和设计。让我们来看一个 DTOs 的用例示例。您可以看到如下：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we have created an example domain model that will represent
    entities in our database. There are instances where we would not want to include
    some information on sending data to the client, which is where DTOs would enter
    the scene. We will create two DTOs for the blog model used for getting and creating
    data, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个示例领域模型，它将代表我们数据库中的实体。有些情况下，我们可能不希望在发送数据到客户端时包含某些信息，这就是 DTOs 发挥作用的地方。我们将为用于获取和创建数据的博客模型创建两个
    DTOs，如下所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding example DTO, we have created a `BlogDTO` class that will be
    used for retrieving data; our objective is to hide the author’s name, thus not
    including it as a field in the DTO. The code is illustrated in the following snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例 DTO 中，我们创建了一个 `BlogDTO` 类，它将用于检索数据；我们的目标是隐藏作者的名字，因此不将其作为字段包含在 DTO 中。代码如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The next DTO we have created is `BlogCreationDTO`, which will create a new blog.
    We can see that all fields necessary to create a new blog are included.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的下一个 DTO 是 `BlogCreationDTO`，它将创建一个新的博客。我们可以看到创建新博客所需的所有字段都已包含。
- en: The created DTOs will be used for our controllers in the following sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的 DTOs 将在以下章节中用于我们的控制器。
- en: Lombok
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lombok
- en: '**Lombok** is a third-party library used to reduce boilerplate code using annotations.
    Lombok allows us to avoid repetitive code, especially in creating models such
    as getter and setter methods.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lombok** 是一个第三方库，用于通过注解减少样板代码。Lombok 允许我们避免重复的代码，尤其是在创建模型，如获取和设置方法时。'
- en: 'Let’s have a comparison between a model without Lombok and a model using Lombok,
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下没有使用 Lombok 的模型和使用 Lombok 的模型，如下所示：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code example, we have created a blog model without using Lombok;
    we can see that we have created a getter and setter method for each field, and
    we have also created constructors with and without arguments. The code in this
    example is still manageable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们没有使用Lombok创建了一个博客模型；我们可以看到我们已经为每个字段创建了一个getter和setter方法，我们还创建了带有和不带有参数的构造函数。这个例子中的代码仍然是可管理的。
- en: Still, if our model is required to contain more fields, we need to create setters
    and getters for the new fields, creating more boilerplate code inside our model
    and sacrificing the maintainability of our code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果我们的模型需要包含更多字段，我们需要为新的字段创建setter和getter，在我们的模型内部创建更多样板代码，从而牺牲我们代码的可维护性。
- en: 'The class and annotations should be as shown in the following code block:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类和注解应该如下所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding screenshot, we have used Lombok to create our blog model, and
    we can see that a considerable amount of code has been omitted from the model.
    The `@Data` annotation generates setter and getter methods, a `toString()` method,
    and a constructor with required arguments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们使用了Lombok创建我们的博客模型，我们可以看到模型中已经省略了相当多的代码。`@Data`注解生成了setter和getter方法、`toString()`方法和带有必需参数的构造函数。
- en: '`@AllArgsConstructor` and `@NoArgsConstructor` are accountable for the constructor
    with all and no arguments.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AllArgsConstructor`和`@NoArgsConstructor`负责生成带有所有和没有参数的构造函数。'
- en: The advantage of using Lombok is evident in the previous examples; it makes
    code easier to read and less error-prone, promotes easy cleanup and maintainability,
    and gives effortless logging and debugging.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lombok的优势在之前的示例中已经很明显；它使代码更容易阅读和更少出错，促进了轻松的清理和维护，并提供了无力的日志记录和调试。
- en: Model application
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型应用
- en: Now that we have learned about the importance of DTO and Lombok, let’s go back
    to our Spring Boot application. Under the `java` folder, right-click on the package
    and select **Package**. This will display a small window that will allow you to
    enter a new package.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了DTO和Lombok的重要性，让我们回到我们的Spring Boot应用程序。在`java`文件夹下，右键单击包并选择**包**。这将显示一个小窗口，允许您输入一个新包。
- en: 'In this example, we will create a new package named `antiHero`. After completing
    the new package, we will create two new packages under `antiHero`, calling them
    `dto` and `entity`. You can see the packages in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个名为`antiHero`的新包。在完成新包后，我们将在`antiHero`下创建两个新的包，分别命名为`dto`和`entity`。您可以在下面的屏幕截图中看到这些包：
- en: '![Figure 5.7 – Project structure after the creation of packages](img/B18159_05_07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 创建包后的项目结构](img/B18159_05_07.jpg)'
- en: Figure 5.7 – Project structure after the creation of packages
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 创建包后的项目结构
- en: 'Our project structure should now look just as it is presented in the preceding
    screenshot. Let’s first create our entity; right-click on the entity package we
    have created, and then click on `AntiHeroEntity` and click on the **OK** button.
    The process is illustrated in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目结构现在应该看起来就像前面屏幕截图中所展示的那样。让我们首先创建我们的实体；右键单击我们创建的实体包，然后单击`AntiHeroEntity`并单击**确定**按钮。该过程在下面的屏幕截图中进行了说明：
- en: '![Figure 5.8 – Creating an entity](img/B18159_05_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 创建实体](img/B18159_05_08.jpg)'
- en: Figure 5.8 – Creating an entity
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 创建实体
- en: 'We will see a newly generated class under the `entity` package, and it will
    have the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`entity`包下看到一个新生成的类，它将具有以下代码：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An entity was automatically generated with the `@Entity` and `@Table` annotations
    that will be used to identify this model as an object in the database. The current
    code will have some issues, stating that the entity does not have a **primary
    key** (**PK**); in this case, we will add the following to our model:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Entity`和`@Table`注解自动生成了一个实体，这些注解将用于将此模型识别为数据库中的对象。当前的代码将有一些问题，指出实体没有**主键**（**PK**）；在这种情况下，我们将向我们的模型添加以下内容：
- en: '`@Data`: Lombok annotations that will set the getter and setter methods, the
    `toString()` method, and `@RequiredArgsConstructor`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Data`：Lombok注解，将设置getter和setter方法、`toString()`方法和`@RequiredArgsConstructor`。'
- en: '`@AllArgsConstructor`: Lombok annotations for generating a constructor for
    the model with all fields as arguments.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AllArgsConstructor`：用于生成具有所有字段作为参数的模型构造函数的Lombok注解。'
- en: '`@NoArgsConstructor`: Lombok annotations for generating a constructor for the
    model with no arguments.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NoArgsConstructor`：用于生成没有参数的模型构造函数的Lombok注解。'
- en: '`@Id`: Found under `javax.persistence.*`, this will determine the model’s PK.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id`：位于`javax.persistence.*`下，这将确定模型的PK。'
- en: '`@GeneratedValue`: Used on the PK to determine which generation type will be
    used.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GeneratedValue`：用于主键，以确定将使用哪种生成类型。'
- en: '`@NotNull`: Found under `javax.validation.constraints` and validates that a
    specific field cannot be null.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：位于`javax.validation.constraints`下，用于验证特定字段不能为null。'
- en: 'The dependency should be installed by adding the following code to `pom.xml`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 应该通过将以下代码添加到`pom.xml`中来安装依赖项：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After adding the dependency to `pom.xml`, right-click on your project and select
    **Maven** | **Reload project** to install the new dependency.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在将依赖项添加到`pom.xml`后，右键单击您的项目并选择**Maven** | **Reload project**以安装新的依赖项。
- en: 'After successfully adding the Lombok annotations, PK, validations, and fields
    to our model, we will have the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功添加Lombok注解、PK、验证和字段到我们的模型后，我们将得到以下代码：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After adding all the preceding packages, we can now start writing our class
    and the annotations, like so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加所有前面的包之后，我们现在可以开始编写我们的类和注解，如下所示：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code block, we can see that we have added a PK of the `UUID`
    type; this will be automatically generated once we insert new anti-hero data into
    our database. The type is defined using the `@GeneratedValue` annotation, where
    we have also indicated that the strategy will be using an auto generator. We have
    also added several fields that will be used to store the anti-hero information.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们可以看到我们添加了一个`UUID`类型的PK；一旦我们将新的反英雄数据插入到我们的数据库中，它将自动生成。类型是通过`@GeneratedValue`注解定义的，其中我们还指明了策略将使用自动生成器。我们还添加了几个将用于存储反英雄信息的字段。
- en: 'We have successfully created our entity; now, we will create a DTO for the
    anti-hero entity. Right-click on the `dto` package, select `AntiHeroDto`. After
    successfully creating the DTO, we will place the following code into it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了我们的实体；现在，我们将为反英雄实体创建一个DTO。右键单击`dto`包，选择`AntiHeroDto`。在成功创建DTO后，我们将以下代码放入其中：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code example, we have added fields that we only want to display
    as we send the anti-hero data to the client; in this case, we have removed the
    `createdAt` field in our DTO. We have also added `@Getter` and `@Setter` annotations
    to generate getter and setter methods for our DTO, and lastly, we have also added
    `@NotNull` validation to match our constraint with the entity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们添加了只希望在将反英雄数据发送到客户端时显示的字段；在这种情况下，我们在我们的DTO中移除了`createdAt`字段。我们还添加了`@Getter`和`@Setter`注解来生成我们的DTO的getter和setter方法，最后，我们还添加了`@NotNull`验证来匹配我们的约束与实体。
- en: We have successfully created our DTO and models with Lombok in our application.
    In the next section, we will make our services responsible for the CRUD functionalities
    of our Spring Boot application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用Lombok在我们的应用程序中成功创建了DTO和模型。在下一节中，我们将使我们的服务负责Spring Boot应用程序的CRUD功能。
- en: Writing services
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写服务
- en: In this section, we will now write the services for our application, but first,
    let’s discuss the primary purpose of services in Spring Boot. Services are classes
    where we place all of our business logic; this is where we will write our CRUD
    functionalities with the help of JPA repositories. In this case, we will not only
    make our service class but will also create our JPA repository.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们现在将编写我们的应用程序服务，但首先，让我们讨论Spring Boot中服务的主要目的。服务是我们放置所有业务逻辑的类；这是我们将在JPA仓库的帮助下编写我们的CRUD功能的地方。在这种情况下，我们不仅将创建我们的服务类，还将创建我们的JPA仓库。
- en: JPA repository
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPA仓库
- en: As discussed in [*Chapter 4*](B18159_04.xhtml#_idTextAnchor079), *Setting Up
    the Database and Spring Data JPA*, the JPA repository is a widely used specification
    for managing relational data in Java applications. It helps develop Spring by
    reducing boilerplate code by not implementing read and write operations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第4章*](B18159_04.xhtml#_idTextAnchor079)中所述，*设置数据库和Spring Data JPA*，JPA仓库是管理Java应用程序中关系数据的广泛使用的规范。它通过不实现读写操作来减少样板代码，从而帮助开发Spring。
- en: 'It is simple to create a JPA repository in Spring Boot; having said that, the
    JPA library provides classes such as `CrudRepository` that we can use to extend
    our classes. Let’s make one in our Spring Boot application example. Proceed as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot中创建JPA仓库非常简单；话虽如此，JPA库提供了如`CrudRepository`之类的类，我们可以用来扩展我们的类。让我们在我们的Spring
    Boot应用程序示例中创建一个。按照以下步骤进行：
- en: Right-click on our `antiHero` package, select **New**, and click on the **Package**
    option.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击我们的 `antiHero` 包，选择 **New**，然后点击 **Package** 选项。
- en: Create a new package named `repository`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `repository` 的新包。
- en: After creating the new package, right-click on the `repository` package, select
    **New**, and click on the **Class** option.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新包后，右键点击 `repository` 包，选择 **New**，然后点击 **Class** 选项。
- en: 'As the small modal pops up, switch to the `AntiHeroRepository`. The following
    code will be generated:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当小模态弹出时，切换到 `AntiHeroRepository`。以下代码将被生成：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have created our interface, but this is just a simple interface. We will
    extend our interface with the `CrudRepository` class to convert it to a JPA repository,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的接口，但这只是一个简单的接口。我们将通过 `CrudRepository` 类扩展我们的接口，将其转换为 JPA 仓库，如下所示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`AntiHeroRepository`, as we have already extended it with `CrudRepository<Type,
    ID>`, will have methods that have the following functionalities:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`AntiHeroRepository`，因为我们已经通过 `CrudRepository<Type, ID>` 扩展了它，将具有以下功能的方法：'
- en: Persisting, updating, and deleting one of the blog entities
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化、更新和删除博客实体之一。
- en: Finding one or multiple blogs by their PKs
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过主键（PK）查找一个或多个博客。
- en: Counting all blogs
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计所有博客的数量。
- en: Validating whether a single blog exists
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证单个博客是否存在。
- en: 'We have successfully created our JPA repository; our next step is to do our
    service. Our goal is to create a service that will have the capability to get
    an entire list, get a single database in a PK, insert new data, update selected
    data, and delete data. We can achieve this through the following methods provided
    by the JPA repository:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功创建我们的 JPA 仓库；我们的下一步是进行服务。我们的目标是创建一个服务，该服务将能够获取整个列表，通过主键（PK）获取单个数据库，插入新数据，更新选定数据，以及删除数据。我们可以通过以下由
    JPA 仓库提供的方法来实现这一点：
- en: '`findAll()`: Gets all the existing data in a specific entity'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findAll()`: 获取特定实体中的所有现有数据。'
- en: '`findById(Id)`: Finds a particular database by PK'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findById(Id)`: 通过主键（PK）查找特定的数据库。'
- en: '`save()`: Inserts new data in the table'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save()`: 在表中插入新数据。'
- en: '`save(data)`: Updates existing data in the table'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save(data)`: 更新表中的现有数据。'
- en: '`deleteById(id)`: Deletes specific data in the table by PK'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteById(id)`: 通过主键（PK）删除表中的特定数据。'
- en: 'Now that we have successfully identified the methods we need for our service,
    let’s next create our service. Right-click on the `antiHero` package and create
    a new package named `service`; after creating the new package, create a new class
    under the `service` package called `AntiHeroService`, and we will place the following
    methods inside the service:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功识别出我们服务所需的方法，接下来创建我们的服务。右键点击 `antiHero` 包并创建一个名为 `service` 的新包；在创建新包后，在
    `service` 包下创建一个名为 `AntiHeroService` 的新类，并将以下方法放在服务中：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s discuss the preceding code; we have added several methods to our service,
    and these are explained in more detail here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论前面的代码；我们已向我们的服务添加了几个方法，这些方法在此处有更详细的解释：
- en: '`Iterable<AntiHeroEntity> findAllAntiHeroes()`: This method calls `findAll()`
    from `AntiHeroRepository`, which returns an `Iterable` instance of `AntiHeroEntity`.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable<AntiHeroEntity> findAllAntiHeroes()`: 此方法从 `AntiHeroRepository` 调用
    `findAll()`，返回 `AntiHeroEntity` 的 `Iterable` 实例。'
- en: '`AntiHeroEntity findAntiHeroById(UUID id)`: This method calls `findById(id)`
    from `AntiHeroRepository`, which returns a single `AntiHeroEntity` instance based
    on the `Id` value.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AntiHeroEntity findAntiHeroById(UUID id)`: 此方法从 `AntiHeroRepository` 调用 `findById(id)`，根据
    `Id` 值返回单个 `AntiHeroEntity` 实例。'
- en: '`removeAntiHeroById(UUID id)`: This method calls `deleteById(id)` from `AntiHeroRepository`,
    which deletes a single `AntiHeroEntity` instance based on the `Id` value.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeAntiHeroById(UUID id)`: 此方法从 `AntiHeroRepository` 调用 `deleteById(id)`，根据
    `Id` 值删除单个 `AntiHeroEntity` 实例。'
- en: '`void AntiHeroEntity addAntiHero(AntiHeroEntity antiHero)`: This method calls
    `save()` from `AntiHeroRepository` and inserts a new `AntiHeroEntity` instance
    in the database.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void AntiHeroEntity addAntiHero(AntiHeroEntity antiHero)`: 此方法从 `AntiHeroRepository`
    调用 `save()` 并在数据库中插入新的 `AntiHeroEntity` 实例。'
- en: '`void updateAntiHero(UUID id, AntiHeroEntity antiHero)`: This method calls
    `save(antiHero)` from `AntiHeroRepository`, which updates a specific `AntiHeroEntity`
    instance in the database.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void updateAntiHero(UUID id, AntiHeroEntity antiHero)`: 此方法从 `AntiHeroRepository`
    调用 `save(antiHero)`，在数据库中更新特定的 `AntiHeroEntity` 实例。'
- en: 'After successfully adding the method for our service, we will add `@AllArgsConstructor`
    and `@Service` annotations to `AntiHeroService`. `@AllArgsConstructor` is an annotation
    from Lombok that will generate a constructor that requires one argument of each
    field; in our example, this will produce the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功添加我们的服务的方法之后，我们将向`AntiHeroService`添加`@AllArgsConstructor`和`@Service`注解。`@AllArgsConstructor`是Lombok的一个注解，它将生成一个需要每个字段一个参数的构造函数；在我们的例子中，这将生成以下代码：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will now allow the wiring of our `AntiHeroRepository` dependency on our
    service.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将允许我们将`AntiHeroRepository`依赖项连接到我们的服务上。
- en: The `@Service` annotation, on the other hand, is functional when we want Spring
    Context to autodetect classes based on their classification.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们希望Spring上下文根据其分类自动检测类时，`@Service`注解是功能性的。
- en: We have now successfully created our service with CRUD methods, but what if
    something went wrong as we call our service? For example, the **identifier** (**ID**)
    of the anti-hero we have passed may not exist. We would want to catch the error
    and return an understandable message to the user. Now, we will create runtime
    exception handling for our service.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功创建了具有CRUD方法的服务，但如果在调用服务时出了问题怎么办？例如，我们传递的反英雄的**标识符**（**ID**）可能不存在。我们希望捕获错误并向用户返回一个可理解的消息。现在，我们将为我们的服务创建运行时异常处理。
- en: Runtime exceptions
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '**Runtime exceptions** are also known as unchecked exceptions. These are programming
    errors and will happen upon the current execution of our application. This should
    be prevented directly by the developers.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时异常**也被称为未检查异常。这些是编程错误，将在我们应用程序的当前执行中发生。这应该直接由开发者来预防。'
- en: 'Some known runtime exceptions are listed here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些已知的运行时异常：
- en: '`IndexOutOfBoundsException`: This exception occurs when we access an index
    of an array string or an iterable that is out of range, as illustrated in the
    following code snippet:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexOutOfBoundsException`：当我们访问一个数组字符串或可迭代的索引超出范围时，会发生此异常，如下面的代码片段所示：'
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`IllegalArgumentException`: This exception occurs when a method has been passed
    by an illegal argument, as illustrated in the following code snippet:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IllegalArgumentException`：当方法被传递了一个非法参数时，会发生此异常，如下面的代码片段所示：'
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`NullPointerException`: This exception occurs when a variable is accessed that
    does not point to any object or is simply null, as illustrated in the following
    code snippet:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullPointerException`：当访问一个不指向任何对象或简单地为null的变量时，会发生此异常，如下面的代码片段所示：'
- en: '[PRE44]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'These are just common runtime exceptions that we use in our application; we
    can also create runtime exceptions using the `RunTimeException` class. In this
    example, let’s create a `NotFoundException` runtime exception that we will use
    to get a non-existent ID. Proceed as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们在应用程序中使用的常见运行时异常；我们也可以使用`RunTimeException`类来创建运行时异常。在这个例子中，让我们创建一个`NotFoundException`运行时异常，我们将使用它来获取一个不存在的ID。按照以下步骤进行：
- en: 'Under the `main` package, create a new package named `exception`; after successfully
    creating the package, create a class named `NotFoundException`. We will extend
    our created class with the `RunTimeException` class and will add the following
    code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`包下，创建一个名为`exception`的新包；在成功创建包之后，创建一个名为`NotFoundException`的类。我们将使用`RunTimeException`类扩展我们创建的类，并将添加以下代码：
- en: '[PRE50]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding code snippet, we have declared several methods with `NotFoundException`
    with different arguments; having successfully created our custom exception, we
    can now use it on our service.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们已声明了几个带有不同参数的`NotFoundException`方法；在成功创建我们的自定义异常后，我们现在可以在我们的服务中使用它。
- en: 'Go back to `AntiHeroService`, and we will add the following method:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`AntiHeroService`，我们将添加以下方法：
- en: '[PRE62]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the preceding code example, we have created a new method named `findOrThrow()`;
    this is also calling the `findById()` method. The only difference is that it checks
    whether the given ID exists on the database; otherwise, it will throw something
    based on our code. In this case, we would want to throw a `NotFoundException`
    runtime exception.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个名为`findOrThrow()`的新方法；这同样是在调用`findById()`方法。唯一的区别是它检查给定的ID是否存在于数据库中；否则，它将根据我们的代码抛出某些内容。在这种情况下，我们希望抛出一个`NotFoundException`运行时异常。
- en: 'After this, we can use it now on `findAntiHeroById()` by replacing `findById()`
    with the `findOrThrow()` method and also add it to the `updateAntiHero()` and
    `deleteAntiHero()` methods to check whether the data exists before updating or
    deleting it. The code to accomplish this is illustrated here:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们可以在`findAntiHeroById()`中使用它，通过将`findById()`替换为`findOrThrow()`方法，并将其添加到`updateAntiHero()`和`deleteAntiHero()`方法中，以在更新或删除之前检查数据是否存在。完成此操作的代码如下所示：
- en: '[PRE70]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We have now successfully created our service for our application. The next section
    will discuss how to make controllers and define endpoints in our code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功创建了我们的应用程序服务。下一节将讨论如何在我们的代码中创建控制器和定义端点。
- en: Adding controllers
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加控制器
- en: This section will now discuss the use of controllers and how to create them
    in our application. **Controllers** are responsible for intercepting incoming
    requests and converting the payload of the request for the internal structure
    of the data; this is also where we will define our endpoint paths that will be
    available for access for our frontend applications.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论控制器在应用程序中的使用以及如何创建它们。**控制器**负责拦截传入的请求并将请求的有效负载转换为数据的内部结构；这也是我们将定义前端应用程序可访问的端点路径的地方。
- en: 'In creating controllers, we will use several annotations, as described here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建控制器时，我们将使用几个注解，如下所述：
- en: '`@RestController`: This is a specialized form of the `@Controller` annotation;
    compared to using the `@Controller` annotation, it already includes both the `@Controller`
    and `@ResponseBody` annotation, not needing to specify the `@ResponseBody` annotation
    on each method.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RestController`：这是`@Controller`注解的专用形式；与使用`@Controller`注解相比，它已经包含了`@Controller`和`@ResponseBody`注解，不需要在每个方法上指定`@ResponseBody`注解。'
- en: '`@RequestMapping`: This is an annotation used to map **HyperText Transfer Protocol**
    (**HTTP**) requests to the methods of **REpresentational State Transfer** (**REST**)
    controllers. It is also where we define a base path for the controller.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping`：这是一个用于将**超文本传输协议**（**HTTP**）请求映射到**表现层状态转移**（**REST**）控制器方法上的注解。它也是我们定义控制器基本路径的地方。'
- en: '`@GetMapping`: This maps HTTP `GET` requests on a method; the annotation is
    a shortcut for `@RequestMapping(method =` `RequestMethod.GET)`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GetMapping`：这个注解将HTTP `GET`请求映射到方法上；该注解是`@RequestMapping(method = RequestMethod.GET)`的快捷方式。'
- en: '`@PutMapping`: This maps HTTP `PUT` requests on a method; the annotation is
    a shortcut for `@RequestMapping(method =` `RequestMethod.PUT)`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PutMapping`：这个注解将HTTP `PUT`请求映射到方法上；该注解是`@RequestMapping(method = RequestMethod.PUT)`的快捷方式。'
- en: '`@PostMapping`: This maps HTTP `POST` requests on a method; the annotation
    is a shortcut for `@RequestMapping(method =` `RequestMethod.POST`).'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PostMapping`：这个注解将HTTP `POST`请求映射到方法上；该注解是`@RequestMapping(method = RequestMethod.POST)`的快捷方式。'
- en: '`@DeleteMapping`: This maps HTTP `DELETE` requests on a method; the annotation
    is a shortcut for `@RequestMapping(method =` `RequestMethod.DELETE)`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DeleteMapping`：这个注解将HTTP `DELETE`请求映射到方法上；该注解是`@RequestMapping(method = RequestMethod.DELETE)`的快捷方式。'
- en: '`@PathVariable`: This annotation is used to get the value of endpoint parameters.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PathVariable`：这个注解用于获取端点参数的值。'
- en: '`@Valid`: This annotation is used to check the validity of an object; it is
    commonly used on the request body to check whether a passed request is a valid
    object.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Valid`：这个注解用于检查对象的合法性；它通常用于请求体上，以检查传递的请求是否是有效的对象。'
- en: We have successfully identified the annotations we will use for our controller.
    We can now create our controller. Under the `antiHero` package, create a new package
    named `controller`, and after completing the `controller` package, create a new
    class called `AntiHeroController`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功确定了我们将用于我们控制器的注释。现在我们可以创建我们的控制器了。在`antiHero`包下，创建一个名为`controller`的新包，完成`controller`包后，创建一个名为`AntiHeroController`的新类。
- en: 'In the `AntiHeroController` class, we will use the `@AllArgsConstructor`, `@RestController`,
    and `@RequestMapping` annotations, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AntiHeroController`类中，我们将使用`@AllArgsConstructor`、`@RestController`和`@RequestMapping`注释，如下所示：
- en: '[PRE78]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Our controller is now configured; the next step is to place our dependencies
    inside our controller. We have used the `@AllArgsContructor` annotation. We don’t
    need to create a constructor method with the parameters; we only need to define
    dependencies.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器的配置现在已经完成；下一步是将我们的依赖项放入我们的控制器中。我们使用了`@AllArgsContructor`注解。我们不需要创建带有参数的构造方法；我们只需要定义依赖项。
- en: First, we will determine the `AntiHeroService` class where all our CRUD logic
    is baked. The next one is `ModelMapper`; this is important, seeing as we need
    to convert our entity into a DTO when we use it as a response, and vice versa
    if we want to read an object from a request body. `ModelMapper` will easily map
    the values of an entity to a DTO object with the same property.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将确定包含所有CRUD逻辑的`AntiHeroService`类。下一个是`ModelMapper`；这很重要，因为我们需要在将实体用作响应时将其转换为DTO，反之亦然，如果我们想从请求体中读取对象。`ModelMapper`将轻松地将实体的值映射到具有相同属性的DTO对象。
- en: 'To install the dependency, we just need to add the following code to our `pom.xml`
    file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装依赖项，我们只需将以下代码添加到我们的`pom.xml`文件中：
- en: '[PRE79]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'After successfully adding the `ModelMapper` dependency, we need to define our
    `ModelMapper` dependency as a Bean in our configuration to use it on our application.
    To achieve this, we will create a new package named `config` under the `main`
    package, and we will create a new class called `ModelMapperConfig`. After creating
    a new class, we will add a new method annotated with `@Bean` and return a new
    instance of `ModelMapper`. The code is illustrated in the following snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功添加`ModelMapper`依赖项后，我们需要在配置中将我们的`ModelMapper`依赖项定义为Bean，以便在应用程序中使用。为此，我们将在`main`包下创建一个新的名为`config`的包，并创建一个名为`ModelMapperConfig`的新类。创建新类后，我们将添加一个带有`@Bean`注解的新方法，并返回一个`ModelMapper`的新实例。代码如下所示：
- en: '[PRE80]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Our configuration is all done, and now, we can add `AntiHeroService` and `ModelMapper`
    to our controller, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有配置都已经完成，现在，我们可以将`AntiHeroService`和`ModelMapper`添加到我们的控制器中，如下所示：
- en: '[PRE81]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We now have our controllers with the needed dependencies. Now, let’s create
    two functions that will convert our entity into a DTO, or vice versa. As mentioned
    a while ago, we will be using the `ModelMapper` dependency to make these methods,
    and in this case, we will add the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了带有所需依赖项的控制器。现在，让我们创建两个函数，将我们的实体转换为DTO，或者反过来。正如之前提到的，我们将使用`ModelMapper`依赖项来创建这些方法，在这种情况下，我们将添加以下代码：
- en: '[PRE82]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We have created two functions in the preceding code example. First, we created
    the `convertToDto()` method, which will convert the given `AntiHeroEntity` instance
    into an `AntiHeroDto` instance, for which we have used the `map()` method from
    `ModelMapper` to map the entity’s values. The second function is the `convertToEntity()`
    method, which converts the DTO into an entity.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的代码示例中创建了两个函数。首先，我们创建了`convertToDto()`方法，它将给定的`AntiHeroEntity`实例转换为`AntiHeroDto`实例，我们使用了`ModelMapper`的`map()`方法来映射实体的值。第二个函数是`convertToEntity()`方法，它将DTO转换为实体。
- en: Now, we can create mappings for our CRUD methods. Let’s first start a method
    that will return a specific entity base on the `id` value; we will use the `@GetMapping`
    annotation to identify that this will use a `GET` request, and we will add `/{id}`
    as a parameter to indicate that we can pass the entity ID as a dynamic parameter
    in the endpoint.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的CRUD方法创建映射。让我们首先创建一个方法，该方法将根据`id`值返回一个特定的实体；我们将使用`@GetMapping`注解来标识这将使用`GET`请求，并将`/{id}`作为参数添加，表示我们可以将实体ID作为动态参数传递到端点中。
- en: 'In creating the method, we will use the `@PathVariable` annotation to get the
    value of `/{id}` in the endpoint and define it as a `UUID` type. Lastly, we will
    call the `service.findAntiHeroById()` function under `AntiHeroService` and pass
    the retrieved ID to get the entity in the database, and we will use the `convertToDto()`
    function to convert it to a DTO. The code is illustrated in the following snippet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建方法时，我们将使用`@PathVariable`注解来获取端点中`/{id}`的值，并将其定义为`UUID`类型。最后，我们将在`AntiHeroService`下调用`service.findAntiHeroById()`函数，并将检索到的ID传递给数据库中的实体，我们将使用`convertToDto()`函数将其转换为DTO。代码如下所示：
- en: '[PRE83]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now, to create the `create` mapping, we will use the `@PostMapping` annotation
    to identify that this will use a `POST` request, we will use the `@RequestBody`
    annotation to get the object on the request body, and we can also use the `@Valid`
    annotation to check whether the object is a valid entity.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建`create`映射，我们将使用`@PostMapping`注解来标识这将使用`POST`请求，我们将使用`@RequestBody`注解来获取请求体中的对象，我们还可以使用`@Valid`注解来检查该对象是否是一个有效的实体。
- en: 'In creating the function, we will call the `convertToEntity()` method to convert
    the object into an entity, and we will call the `service.addAntiHero()` method
    to insert the converted entity into the database. The code is illustrated in the
    following snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数时，我们将调用`convertToEntity()`方法将对象转换为实体，并将调用`service.addAntiHero()`方法将转换后的实体插入到数据库中。代码如下所示：
- en: '[PRE84]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The next thing we need to create is the `PUT` mapping. We will use the `@PutMapping`
    annotation to identify that this will use a `PUT` request, the same as how we
    created the `GET` mapping. We will add `/{id}` as a parameter, and we will also
    use the `@RequestBody` annotation to get the object on the request body and the
    `@PathVariable` annotation to get the value of `id` in the parameter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要创建的是`PUT`映射。我们将使用`@PutMapping`注解来标识这将使用`PUT`请求，这与我们创建`GET`映射的方式相同。我们将添加`/{id}`作为参数，并且我们还将使用`@RequestBody`注解来获取请求体中的对象，以及使用`@PathVariable`注解来获取参数中`id`的值。
- en: 'In implementing the function, we will also call the `convertToEntity()` method
    and call the `service.updateAntiHero(id, entity)` method to update the specific
    entity with the DTO values. The code is illustrated in the following snippet:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现函数时，我们还将调用`convertToEntity()`方法，并调用`service.updateAntiHero(id, entity)`方法来使用DTO值更新特定实体。代码如下所示：
- en: '[PRE85]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Next, we’ll create `DELETE` mapping. We will use the `@DeleteMapping` annotation
    to identify that this will use a `DELETE` request. We will also add `/{id}` as
    a parameter to receive the ID of the entity we need to delete, and we will add
    the `@PathVariable` annotation to get the value of `id`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`DELETE`映射。我们将使用`@DeleteMapping`注解来标识这将使用`DELETE`请求。我们还将添加`/{id}`作为参数来接收需要删除的实体的ID，并添加`@PathVariable`注解来获取`id`的值。
- en: 'To implement the method, we simply call the `service.removeAntiHeroById()`
    method to delete the specific entity in the database, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现该方法，我们只需调用`service.removeAntiHeroById()`方法来删除数据库中的特定实体，如下所示：
- en: '[PRE86]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And lastly, we need to create a method that will return all the entities in
    the database. One way we can implement this is using `StreamSupport` to convert
    our retrieved list into a stream and convert each object into a DTO, but first,
    we will create a method that returns a type of `List<AntiHeroDto>` with the `@GetMapping`
    annotation. After completing the method, we will now call the `service.findAllAntiHeroes()`
    method to get the entities in the database. Since this returns to an `Iterable`
    instance, we will convert it into a stream and transform it into a list using
    `Collectors.toList()`. The code is illustrated in the following snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个方法，该方法将返回数据库中的所有实体。我们可以实现这一点的其中一种方法是通过使用`StreamSupport`将检索到的列表转换为流，并将每个对象转换为DTO，但首先，我们将创建一个带有`@GetMapping`注解的返回`List<AntiHeroDto>`类型的方法。完成方法后，我们现在将调用`service.findAllAntiHeroes()`方法来获取数据库中的实体。由于这返回一个`Iterable`实例，我们将将其转换为流，并使用`Collectors.toList()`将其转换为列表。代码如下所示：
- en: '[PRE87]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'After successfully retrieving and converting the data into a list, we want
    each object converted into a DTO. We can achieve this by converting the list into
    a stream. Call the `convertToDto()` method and convert it to a list again, as
    follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功检索并将数据转换为列表后，我们希望将每个对象转换为DTO。我们可以通过将列表转换为流来实现这一点。调用`convertToDto()`方法并将其再次转换为列表，如下所示：
- en: '[PRE88]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We will return the converted list in response, and our method will now look
    like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在响应中返回转换后的列表，现在我们的方法将如下所示：
- en: '[PRE89]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We have successfully created mappings on our controller, and our code should
    look like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在控制器上成功创建了映射，我们的代码应该看起来像这样：
- en: '[PRE90]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We have completed our Spring Boot application, we have created our models and
    DTO that defines the structure of our object, we have built services that are
    responsible for the business logic, and we have created controllers that map the
    HTTP requests in our applications, so our endpoint will work as expected.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的Spring Boot应用程序，我们创建了我们的模型和DTO，它定义了我们的对象结构，我们构建了负责业务逻辑的服务，我们还创建了映射我们应用程序中HTTP请求的控制器，因此我们的端点将按预期工作。
- en: Still, we can improve our backend in terms of performance, and we can do this
    with caching mechanisms. In the next section, we will discuss the concepts and
    application of Redis.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以在性能方面改进我们的后端，我们可以通过缓存机制来实现这一点。在下一节中，我们将讨论Redis的概念和应用。
- en: Adding Redis for caching
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Redis进行缓存
- en: In this section, we will now discuss Redis, which can improve the performance
    of our REST applications. Redis is an open source, in-memory, key-value data store
    that allows data to reside in memory to enable low latency and faster data access.
    Compared to traditional databases, Redis doesn’t require disk access, having all
    data cached in the memory, which gives a quicker response.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们现在将讨论 Redis，它可以提高我们 REST 应用程序的性能。Redis 是一个开源的内存键值数据存储，允许数据驻留在内存中以实现低延迟和更快的数据访问。与传统数据库相比，Redis
    不需要磁盘访问，所有数据都缓存在内存中，这提供了更快的响应。
- en: It is now widely used, especially for large applications that receive millions
    of requests. It is compatible with different data structures such as strings,
    lists, sets, hashes, bitmaps, and geospatial and is compatible with **Publish/Subscribe**
    (**Pub/Sub**), used for real-time chat applications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它被广泛使用，尤其是在接收数百万请求的大型应用程序中。它与不同的数据结构兼容，如字符串、列表、集合、散列、位图和地理空间，并且与 **发布/订阅**（**Pub/Sub**）兼容，用于实时聊天应用程序。
- en: Installing the Redis server
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Redis 服务器
- en: Before using Redis on our Spring Boot application, we will need to install the
    Redis server in our terminal. Let’s discuss how to install Redis on different
    operating systems.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Spring Boot 应用程序中使用 Redis 之前，我们需要在我们的终端中安装 Redis 服务器。让我们讨论如何在不同的操作系统上安装
    Redis。
- en: macOS
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: macOS
- en: 'Redis is simple to install in a macOS system; we can use Homebrew to install
    Redis and execute the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 系统中安装 Redis 非常简单；我们可以使用 Homebrew 来安装 Redis 并执行以下命令：
- en: '[PRE91]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'After successful installation, we can set the Redis server to start automatically
    with the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装后，我们可以使用以下命令设置 Redis 服务器自动启动：
- en: '[PRE92]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: And we have successfully installed and run our Redis server on macOS.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 macOS 上成功安装并运行了我们的 Redis 服务器。
- en: Ubuntu Linux
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ubuntu Linux
- en: 'For installing Redis on Ubuntu OS, we will execute the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 Ubuntu OS 上安装 Redis，我们将执行以下命令：
- en: '[PRE93]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This will automatically install and start the Redis server on port `6739`, and
    we have successfully installed and run our Redis server on Linux.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动在端口 `6739` 上安装并启动 Redis 服务器，并且我们已经成功在 Linux 上安装并运行了我们的 Redis 服务器。
- en: Windows
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'For installing Redis on Windows, we can install the different versions from
    the following link: [https://github.com/microsoftarchive/redis/releases](https://github.com/microsoftarchive/redis/releases),
    download the `.zip` or `.msi` file, and extract to your chosen directory. Run
    the `Redis-server.exe` file to start the Redis server on port `6739`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 Windows 上安装 Redis，我们可以从以下链接安装不同版本：[https://github.com/microsoftarchive/redis/releases](https://github.com/microsoftarchive/redis/releases)，下载
    `.zip` 或 `.msi` 文件，并将其解压到您选择的目录。运行 `Redis-server.exe` 文件以在端口 `6739` 上启动 Redis
    服务器。
- en: Thus, we have successfully installed and run our Redis server on Windows. We
    can now use Redis on our Spring Boot application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经成功在 Windows 上安装并运行了我们的 Redis 服务器。我们现在可以在我们的 Spring Boot 应用程序中使用 Redis。
- en: Configuring Redis on Spring Boot
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Spring Boot 上配置 Redis
- en: 'We have successfully configured and started the Redis server on our local machine;
    our next step is to use Redis in our developed Spring Boot project. We’ll now
    follow these steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本地机器上成功配置并启动了 Redis 服务器；我们的下一步是将在开发的 Spring Boot 项目中使用 Redis。我们现在将遵循以下步骤：
- en: 'The first thing we need to do is include the Redis dependency; to achieve this,
    we need to add the following code to our `pom.xml` file:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是包含 Redis 依赖项；为了实现这一点，我们需要将以下代码添加到我们的 `pom.xml` 文件中：
- en: '[PRE94]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: After successfully adding the Redis dependency, we will add our `config` package.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功添加 Redis 依赖项后，我们将添加我们的 `config` 包。
- en: 'Create a class named `RedisConfig`. We will use the `@Configuration` annotation
    to identify whether this class has Bean definition methods that will be bootstrapped
    on the execution of the application. We will also add the following method to
    our class:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `RedisConfig` 的类。我们将使用 `@Configuration` 注解来标识这个类是否有 Bean 定义方法，这些方法将在应用程序执行时启动。我们还将向我们的类添加以下方法：
- en: '[PRE106]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '`jedisConnectionFactory()` is the method used to identify the connection properties
    for our Redis server; this uses default values since we have not specified connection
    properties.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`jedisConnectionFactory()` 是用于识别 Redis 服务器连接属性的函数；由于我们没有指定连接属性，它使用默认值。'
- en: 'Still, if our Redis server is hosted on a different server, hosted on a different
    port, or has a username and password, we can use the following methods:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果我们的 Redis 服务器托管在不同的服务器上，在不同的端口上，或者有用户名和密码，我们可以使用以下方法：
- en: '`redisStandaloneConfiguration.setHostName("host")`: This sets the host **Uniform
    Resource Locator** (**URL**) where the Redis server is running.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redisStandaloneConfiguration.setHostName("host")`：这设置了Redis服务器运行的**统一资源定位符**（**URL**）的主机。'
- en: '`redisStandaloneConfiguration.setPort("port")`: This sets the port where the
    application will connect.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redisStandaloneConfiguration.setPort("port")`：这设置了应用程序将连接的端口。'
- en: '`redisStandaloneConfiguration.setUsername("username")`: This sets the username
    for the Redis server.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redisStandaloneConfiguration.setUsername("username")`：这设置了Redis服务器的用户名。'
- en: '`redisStandaloneConfiguration.setPassword("password")`: This sets the password
    for the Redis server.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redisStandaloneConfiguration.setPassword("password")`：这设置了Redis服务器的密码。'
- en: The next step is to use the connection factory to create a Redis template; this
    is used for Redis data interactions. It allows the automatic serialization and
    deserialization between objects and binary data stored in the Redis server.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用连接工厂创建一个Redis模板；这用于Redis数据交互。它允许在Redis服务器中存储的对象和二进制数据之间自动序列化和反序列化。
- en: 'We will create a method that will also use the `@Bean` annotation; we will
    create a new Redis template and set the connection factory with the following
    code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个方法，它也将使用`@Bean`注解；我们将创建一个新的Redis模板，并使用以下代码设置连接工厂：
- en: '[PRE114]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: After successfully creating the template instance with the connection factory,
    we can also define serializers depending on the data structures. If we want to
    use the default serializer, which is `JdkSerializationRedisSerializer`, we will
    just return a template instance.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建连接工厂的模板实例后，我们还可以根据数据结构定义序列化器。如果我们想使用默认的序列化器，即`JdkSerializationRedisSerializer`，我们只需返回一个模板实例。
- en: 'In the following code snippet, we have used different serializers for different
    data structures:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们为不同的数据结构使用了不同的序列化器：
- en: '[PRE116]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The last thing we need to do is add the `@RedishHash` annotation to our entity.
    This serves as a mark for objects as an aggregate root to be stored on the Redis
    hash; in our example, we will use it on `AntiHeroEntity`, as follows:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将`@RedishHash`注解添加到我们的实体上。这作为标记对象作为一个聚合根存储在Redis哈希中；在我们的例子中，我们将它在`AntiHeroEntity`上使用，如下所示：
- en: '[PRE135]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: And this will successfully use the Redis server to cache data on our Spring
    Boot application as operations are executed.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以成功地在Spring Boot应用程序上使用Redis服务器来缓存数据，随着操作的执行。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned. You have learned how to start the Spring Boot
    application on a Tomcat server using IntelliJ. You have also known how to create
    a complete Spring Boot application step by step by creating entities, using Lombok
    and DTOs, writing services with CRUD logic with the help of JPA repositories,
    and creating controllers using HTTP annotations and `ModelMapper` for converting
    entities to DTO, and vice versa.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经到达了本章的结尾。让我们回顾一下你学到的宝贵知识。你学会了如何使用IntelliJ在Tomcat服务器上启动Spring Boot应用程序。你还知道了如何通过创建实体、使用Lombok和DTO、编写带有CRUD逻辑的服务以及使用JPA仓库、创建控制器（使用HTTP注解和`ModelMapper`将实体转换为DTO，反之亦然）来逐步创建一个完整的Spring
    Boot应用程序。
- en: Lastly, you have also learned how to configure a Redis server and use it on
    a Spring Boot application.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也学会了如何配置Redis服务器并在Spring Boot应用程序中使用它。
- en: The skills you have learned here will make your code readable and concise because
    of the Lombok and JPA repositories.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里学到的技能将使你的代码因为Lombok和JPA仓库而易于阅读和简洁。
- en: In the next chapter, we will be learning how to create documentation for our
    APIs using `springdoc-openapi` and Swagger UI.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用`springdoc-openapi`和Swagger UI为我们的API创建文档。
