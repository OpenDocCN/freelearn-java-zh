- en: Be Lazy; Cache Your Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰；缓存你的数据
- en: In the previous chapter, we saw how to parallelize the processing of our requests
    and reduce our response time using our processor more accurately.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何通过我们的处理器并行处理我们的请求并更准确地减少我们的响应时间。
- en: However, the best way to be efficient and fast is, obviously, not doing anything.
    This is what caching tries to do, allowing you to use the memory to keep track
    of the already processed results and read them fast when needed later on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，显然最有效率和快速的方式显然是不做任何事情。这正是缓存试图做到的，它允许你使用内存来跟踪已经处理过的结果，并在需要时快速读取它们。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What caching is, how it works, and when it is interesting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存是什么，它是如何工作的，以及它在什么情况下是有趣的
- en: 'Which kind of cache to use: local versus remote caching'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用哪种类型的缓存：本地缓存与远程缓存
- en: JCache – a standard API for Java EE
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JCache - Java EE的标准API
- en: Caching challenges
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存挑战
- en: 'To ensure that we keep in mind the pattern we target when we put caching in
    place, let''s use a simple example taken from our quote manager application. Our
    goal will be to make our *find by symbol* endpoint go faster. The current logic
    looks like this pseudo code snippet:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们在实施缓存时记住我们针对的模式，让我们用一个简单的例子来说明，这个例子来自我们的引用管理应用程序。我们的目标将是使我们的 *按符号查找* 端点更快。当前的逻辑看起来像以下伪代码片段：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We only have two operations in this code snippet (find it in the database and
    convert the database model into a JSON model). Wonder what you''re caching: the
    database lookup result, the JSON conversion, or both?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中我们只有两个操作（在数据库中查找并将数据库模型转换为JSON模型）。你好奇你在缓存什么：数据库查找结果、JSON转换，还是两者都缓存？
- en: 'We will come back to this part later, but to keep it simple, here, we will
    just cache the database lookup. Therefore, our new pseudo code can look like the
    following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到这部分，但为了简单起见，这里我们只缓存数据库查找。因此，我们新的伪代码可能看起来像以下这样：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is pretty much the same logic as before, except that we try to read the
    data from the cache before reaching the database, and if we reach the database
    and find the record, then we'll add it to the cache.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上和之前的逻辑一样，只是我们尝试在到达数据库之前从缓存中读取数据，如果我们到达数据库并找到记录，然后我们会将其添加到缓存中。
- en: Indeed, you can also cache if you did not find the quote in the database, in
    order to avoid issuing a query to the database which will not return anything.
    It depends on your application whether it encounters these kind of requests often
    or not.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你在数据库中没有找到引用，你也可以进行缓存，以避免发出一个不会返回任何结果的数据库查询。这取决于你的应用程序是否经常遇到这类请求。
- en: 'So, we now have a cache layer with the data from our database to consider in
    our application. We can visualize this structural change with the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在在我们的应用程序中需要考虑一个包含我们数据库数据的缓存层。我们可以用以下图表来可视化这种结构变化：
- en: '![](img/b011d741-4d12-494e-af15-ce531fd0c867.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b011d741-4d12-494e-af15-ce531fd0c867.jpg)'
- en: This image represents the fact that the **Application** goes through the **Cache**
    and **Database**. The fact that the connection (the arrow) to the **Cache** is
    bolder than the one to the **Database** represents our assumption that **Cache**
    access is faster than **Database** access. Therefore, it is cheaper to access
    the **Cache** than the **Database**. This implies that we want to go more often
    to the **Cache** than to the **Database** to find our quotes. Finally, this picture
    represents the **Cache** and the **Database** in the same *layer*, since with
    this kind of solution—and even if the **Cache**, access should be very fast—you
    now have two data sources.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表示了 **应用程序** 通过 **缓存** 和 **数据库**。连接（箭头）到 **缓存** 的线比到 **数据库** 的线更粗，这代表我们的假设是
    **缓存** 访问比 **数据库** 访问更快。因此，访问 **缓存** 比访问 **数据库** 更便宜。这意味着我们想要比访问 **数据库** 更频繁地访问
    **缓存** 来找到我们的引用。最后，这张图表示了 **缓存** 和 **数据库** 在同一个 *层* 中，因为有了这种解决方案——即使 **缓存** 访问应该非常快——你现在有两个数据源。
- en: How does the cache work?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存是如何工作的？
- en: What is cache? The word *cache* is actually very generic and hides a lot of
    different flavors, which don't target the same needs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是缓存？单词 *缓存* 实际上非常通用，隐藏了许多不同的风味，它们并不针对相同的需求。
- en: 'However, all cache implementations share a common basis in terms of principles:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有缓存实现都在原则上有一个共同的基础。
- en: The data is accessible by key
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以通过键访问
- en: The cache provides some eviction mechanisms representing the validity of the
    stored values
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存提供了一些表示存储值有效性的驱逐机制
- en: The cache relies on memory storage *first*
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存依赖于内存存储*首先*。
- en: The cache key
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存键。
- en: Most cache APIs are very close to a map in terms of their behavior—you can put
    some data with `put(key, value)` and retrieve it back with the same key through
    a `get(key)` invocation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数缓存API在行为上非常接近映射——你可以使用`put(key, value)`来存储一些数据，并通过`get(key)`调用使用相同的键检索它。
- en: 'This means that a poor man''s cache can be implemented with `ConcurrentMap`
    of the JRE:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可以使用JRE的`ConcurrentMap`实现一个穷人的缓存。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this implementation, we wrapped the database access in a concurrent map access,
    which triggers the database access only if the data is not already in the cache.
    Note that we cached `Optional`, which also represents the fact that we do not
    have the data in the database. Thus, we will bypass the SQL query, even if the
    data is absent.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们将数据库访问封装在并发映射访问中，只有当数据不在缓存中时才会触发数据库访问。请注意，我们缓存了`Optional`，这也表示我们没有在数据库中拥有数据。因此，即使数据不存在，我们也会绕过SQL查询。
- en: This kind of implementation works, but as it doesn't have any eviction policy,
    you will keep the same data during the application's lifespan, which means that
    updates in the database are completely bypassed. Don't use it in production if
    your data is not constant.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的实现是可行的，但它没有任何驱逐策略，这意味着你将在应用程序的生命周期内保持相同的数据，这意味着数据库中的更新将被完全绕过。如果你的数据不是常量，请不要在生产环境中使用它。
- en: The important part of the usage of such structures (let's call them *maps*)
    is the choice of the key. Cache implementations will try to limit the locking
    as much as possible. They can even be lock-free, depending on the implementation.
    So, you can assume that caches will scale by themselves, but the key is yours
    and you need to ensure that it is well implemented.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这类结构（让我们称它们为*映射*）使用的重要部分是键的选择。缓存实现会尽可能减少锁定。它们甚至可以是无锁的，这取决于实现方式。因此，你可以假设缓存会自行扩展，但关键是你的，你需要确保它得到良好的实现。
- en: 'The usage of key by the cache generally has multiple strategies, but the most
    known and used are the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存使用键通常有多种策略，但最知名和常用的如下：
- en: '**By reference**: The equality is tested using a reference equality, which
    means that you need to use the same key instance to find the value. It is, by
    design, limited to local caches.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按引用**：通过引用相等性来测试相等性，这意味着你需要使用相同的键实例来查找值。按照设计，它仅限于本地缓存。'
- en: '**By contract**: This uses `equals` and `hashCode` of the key.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按合同**：这使用键的`equals`和`hashCode`方法。'
- en: '**By value**: This is the same as *by contract*, but it also copies the key
    when putting it into the cache. It ensures that if the key is mutable and has
    somehow been mutated after having put the data into the cache, it doesn''t affect
    the cache, which will potentially be corrupted by a wrong `hashCode` affectation.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按值**：这与*按合同*相同，但在将其放入缓存时也会复制键。它确保如果键是可变的，并且在将数据放入缓存后以某种方式发生了变化，它不会影响缓存，这可能会因为错误的`hashCode`赋值而损坏。'
- en: The `hashCode` usage is generally needed to affect the key/value pair of a cell
    in the cache storing structure. It enables the distribution of data in a structure,
    which will then be faster to access. If the key's `hashCode` changes after the
    key has been affected to a cell, then the data won't be found, even if `equals`
    is correctly implemented.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashCode`的使用通常需要影响缓存存储结构中单元格的键/值对。它使得数据在结构中的分布，这将使得访问更快。如果键的`hashCode`在键被分配到单元格后发生变化，那么即使`equals`实现正确，数据也无法找到。'
- en: Most of the time, you will use the *by contract* solution (or *by value*, depending
    on the implementation), since the *by reference* rarely works in web applications
    because the key's reference is often bound to the request and changes with each
    request. This implies that you must define what the key of your data is and that
    you must implement `equals` and `hashCode`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你会使用*按合同*解决方案（或*按值*，取决于实现），因为*按引用*在Web应用程序中很少工作，因为键的引用通常绑定到请求，并且随着每个请求而变化。这意味着你必须定义你的数据键是什么，你必须实现`equals`和`hashCode`。
- en: 'With such a constraint, you need to take care of two very important consequences:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种约束下，你需要注意两个非常重要的后果：
- en: These methods must be fast to execute
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些方法必须执行得快。
- en: These methods must be constant once the data is put into the cache
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些方法一旦数据放入缓存后就必须是常量。
- en: 'To understand what this means, let''s put a computing result in our cache,
    based on our `Quote` entity, as a natural key of the computation (we cache some
    news related to the quote, for instance). As a reminder, here is our entity structure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这意味着什么，让我们基于我们的`Quote`实体，将其计算结果放入我们的缓存中，作为计算的天然键（例如，我们缓存一些与报价相关的新闻）。作为提醒，以下是我们的实体结构：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you use your IDE to generate the `equals` and `hashCode` methods, you will
    probably get something like the following implementation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用你的IDE生成`equals`和`hashCode`方法，你可能会得到以下实现：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is a very common implementation, but it takes all the fields into account.
    For a JPA entity, it is a disaster because of the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的实现，但它考虑了所有字段。对于一个JPA实体来说，由于以下原因，这是一个灾难：
- en: What happens if the identifier is not affected? If the entity is persisted after
    the entity is put into the cache, you will lose the cache benefit or cache it
    again (with another hash value).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果标识符没有受到影响会发生什么？如果实体在实体被放入缓存之后持久化，你将失去缓存的好处或者再次缓存（使用另一个哈希值）。
- en: What happens when `customers` is accessed? This is a lazy relationship, so if
    not touched before the `hashCode` or `equals`, then it will load the relationship,
    which is surely something we do not want.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问`customers`时会发生什么？这是一个懒加载的关系，所以如果在`hashCode`或`equals`之前没有被触及，那么它将加载这个关系，这肯定不是我们想要的。
- en: What happens if `value`—any state of the entity unrelated to the identifier—changes?
    The cache usage will also be missed.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`value`——与标识符无关的实体任何状态——发生变化会发生什么？缓存的使用也将被错过。
- en: 'JPA is a case where the identifier is really important, even without caching.
    But with caching, it is more obvious. All these observations lead to the fact
    that each key of the cache must be based on a natural identifier, which should
    be immutable, or you must ensure that you evict the cache entry if you receive
    an event mutating the key hypothesis. In the case of JPA, the natural identifier
    is the JPA identifier (`id` for `Quote`), but it must also be affected from the
    first usage. This is why, most of the time, good technical identifiers are based
    on UUID algorithms and affected when a newly created entity is instantiated. Corrected,
    our `equals` and `hashCode` methods will look as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JPA是一个标识符真正重要的案例，即使没有缓存。但是有了缓存，这一点更加明显。所有这些观察都导致了一个事实，即缓存中的每个键都必须基于一个自然标识符，这个标识符应该是不可变的，或者如果你收到一个修改键假设的事件，你必须确保你清除缓存条目。在JPA的情况下，自然标识符是JPA标识符（`Quote`的`id`），但它也必须从第一次使用时受到影响。这就是为什么，在大多数情况下，好的技术标识符是基于UUID算法，并在新创建的实体实例化时受到影响。修正后，我们的`equals`和`hashCode`方法将如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These implementations take into account the `id` value only, and assuming that
    it is affected early, it is safe to use as the key in a cache.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现只考虑`id`值，并假设它早期受到影响，因此可以作为缓存中的键安全使用。
- en: Several databases rely on the key/value paradigm to ensure good performance
    and efficient storage. However, the main difference from a cache will be the volatility
    of the data that a cache is not intended to store, whereas a database will ensure
    the persistence of the data, even if it is an eventually consistent database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 几种数据库依赖于键/值范式来确保良好的性能和高效的存储。然而，与缓存的主要区别将是缓存中数据的易变性，缓存不是为了存储数据而设计的，而数据库将确保数据的持久性，即使它是一个最终一致性的数据库。
- en: Eviction policy
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除策略
- en: The eviction policy is what makes the cache different from a database or `Map`.
    It enables you to define how the data is automatically removed from the cache
    storage. This is very important because if you cache some reference data taken
    from a database, then the database storage can be bigger than the memory storage
    you have available on the machine and, thus, without any eviction, you will end
    up filling the memory and getting `OutOfMemoryException` instead of the performance
    boost you were expecting from the cache addition.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 清除策略是使缓存与数据库或`Map`不同的地方。它使你能够定义数据如何自动从缓存存储中删除。这非常重要，因为如果你缓存从数据库中取出的某些参考数据，那么数据库存储可能比机器上可用的内存存储更大，因此，如果没有清除，你最终会填满内存，并得到`OutOfMemoryException`，而不是你期望从缓存添加中获得的性能提升。
- en: 'There are several kinds of eviction policies, but there are few mainstream
    categories:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种清除策略，但主流的分类却很少：
- en: '**Least Recently Used** (**LRU**)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最近最少使用**（**LRU**）'
- en: '**First In First Out** (**FIFO**)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先进先出**（**FIFO**）'
- en: Random
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机
- en: '**Least Frequently Used** (**LFU**)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最少使用**（**LFU**）'
- en: Only LRU, FIFO, and *Expire* are really mainstream; the other ones highly depend
    on your provider capabilities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只有LRU、FIFO和*过期*是真正的主流；其他的一些高度依赖于你的提供商能力。
- en: Least Recently Used (LRU)
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最少最近使用（LRU）
- en: The LRU strategy is based on the usage of cache elements. Some statistics are
    maintained to be able to *sort* elements by the last usage date, and when eviction
    is needed, the cache just goes through the elements in order and evicts them in
    the same order.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: LRU策略基于缓存元素的使用情况。一些统计数据被维护以能够根据最后使用日期对元素进行*排序*，当需要淘汰时，缓存只需按顺序遍历元素，并按相同的顺序淘汰它们。
- en: 'You can imagine it as the cache maintaining a map of data (storage) and a list
    of the usage of the data (or keys). Here is a sequence to help you visualize it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其想象为缓存维护一个数据（存储）的映射和一个数据（或键）使用列表。以下是一个序列，帮助你可视化它：
- en: '| **Action** | **Cache storage (unsorted)** | **Eviction list (sorted)** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **缓存存储（未排序）** | **淘汰列表（已排序）** |'
- en: '| - | [] | [] |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| - | [] | [] |'
- en: '| add key/value E1 | [E1] | [E1] |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 添加键/值E1 | [E1] | [E1] |'
- en: '| add key/value E2 | [E1, E2] | [E1, E2] |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 添加键/值E2 | [E1, E2] | [E1, E2] |'
- en: '| add key/value E3 | [E1, E2, E3] | [E1, E2, E3] |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 添加键/值E3 | [E1, E2, E3] | [E1, E2, E3] |'
- en: '| read E2 | [E1, E2, E3] | [E1, E3, E2] |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 读取E2 | [E1, E2, E3] | [E1, E3, E2] |'
- en: What is important to notice here is that each usage (*put*, *get*, and so on)
    will first put the element in the eviction list. This means that when the eviction
    is executed, it will remove this element last. In terms of behavior, LRU leads
    to keeping the most used elements in the cache for the longest possible time,
    which is exactly when a cache is the most efficient. However, this also means
    that the cache has to maintain an eviction list state that can be done in several
    manners (through a list, sorting at eviction time, dynamic matrix, and so on).
    Since it has additional work to do, it will impact the performance or memory usage,
    which will no longer be here for the application/cache.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要一点是，每次使用（*put*、*get*等）都会首先将元素放入淘汰列表。这意味着当执行淘汰操作时，它将最后移除这个元素。从行为上来说，LRU会导致在缓存中保留最常使用的元素尽可能长时间，这正是缓存效率最高的时候。然而，这也意味着缓存必须维护一个淘汰列表状态，这可以通过多种方式完成（通过列表、淘汰时排序、动态矩阵等）。由于它需要额外的工作，这会影响性能或内存使用，这将对应用程序/缓存不再适用。
- en: First In First Out (FIFO)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先进先出（FIFO）
- en: The FIFO algorithm is a simplistic flavor of the LRU algorithm aiming to avoid
    the drawback of the LRU algorithm at the cost of a little less accurate behavior.
    Concretely, it will bypass the statistics on the usage and just rely on the time
    of entry into the cache—a bit like when you are waiting in a supermarket line.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO算法是LRU算法的一个简单版本，旨在通过牺牲一点准确性来避免LRU算法的缺点。具体来说，它将绕过使用统计，仅依赖于进入缓存的时间——有点像你在超市排队等待时的情况。
- en: 'Here is an illustration similar to the one we used to depict the LRU algorithm:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个类似于我们用来描述LRU算法的插图：
- en: '| **Action** | **Cache storage (unsorted)** | **Eviction list (sorted)** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **缓存存储（未排序）** | **淘汰列表（已排序）** |'
- en: '| - | [] | [] |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| - | [] | [] |'
- en: '| add key/value E1 | [E1] | [E1] |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 添加键/值E1 | [E1] | [E1] |'
- en: '| add key/value E2 | [E1, E2] | [E1, E2] |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 添加键/值E2 | [E1, E2] | [E1, E2] |'
- en: '| add key/value E3 | [E1, E2, E3] | [E1, E2, E3] |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 添加键/值E3 | [E1, E2, E3] | [E1, E2, E3] |'
- en: '| read E2 | [E1, E2, E3] | [E1, E2, E3] |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 读取E2 | [E1, E2, E3] | [E1, E3, E2] |'
- en: The main difference here is the last entry, which doesn't impact the eviction
    order between E2 and E3\. You can see it as *updates don't change the eviction
    time*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里主要的区别是最后一个条目，它不会影响E2和E3之间的淘汰顺序。你可以将其视为*更新不会改变淘汰时间*。
- en: Random
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机
- en: As you can guess from its name, this eviction policy randomly selects entries
    to remove. It looks inefficient because there's a higher probability of removing
    most used entries and thereby decreasing the cache efficiency. However, there
    are a few cases where it can be a good choice. The main advantage of this strategy
    is that it doesn't rely on any eviction order maintenance and is, thus, fast to
    execute.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这种淘汰策略会随机选择条目进行删除。它看起来效率不高，因为删除最常使用条目的概率更高，从而降低缓存效率。然而，在某些情况下，它可能是一个不错的选择。这种策略的主要优点是它不依赖于任何淘汰顺序维护，因此执行速度快。
- en: 'Before using it, make sure that it is really less efficient than the others:
    almost 20% less efficient than LRU, experimentally.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用它之前，请确保它确实比其他方法效率低：几乎比LRU低20%，这是通过实验得出的。
- en: Least Frequently Used (LFU)
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最少使用频率（LFU）
- en: The last common algorithm you can meet in caches is the LFU algorithm. Like
    the LRU algorithm, this flavor also maintains statistics on the cache access.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你在缓存中能遇到的最后一个常见算法是LFU算法。和LRU算法一样，这个版本也维护了缓存访问的统计信息。
- en: The main difference with LRU is that, instead of using a time-based statistic,
    it uses a frequency statistic. It means that if E1 is accessed 10 times and E2
    is accessed 5 times, then E2 will be evicted before E1.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与LRU的主要区别是，它使用频率统计而不是基于时间的统计。这意味着如果E1被访问了10次而E2被访问了5次，那么E2将在E1之前被删除。
- en: The issue with this algorithm is that if you have a fast access rate during
    a small period of time, then you may evict a more regularly used element than
    the one often used during a very short period of time. So, the final cache distribution
    may not be that optimal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的问题是，如果你在短时间内有快速的访问率，那么你可能会删除比在非常短的时间内经常使用的元素更频繁使用的元素。因此，最终的缓存分布可能不是那么理想。
- en: Cache eviction trigger
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存删除触发器
- en: 'The previous algorithms define how to select the items to evict when the eviction
    is triggered. It means that if the eviction is not triggered, they are pointless.
    Eviction triggers can be of multiple types, but the main ones are the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的算法定义了在触发删除时如何选择要删除的项目。这意味着如果未触发删除，它们就毫无意义。删除触发器可以是多种类型，但主要的是以下几种：
- en: '**Size**: The *size* of the cache can be of several types, such as the actual
    number of objects of the cache or the memory size (in bits or bytes).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：缓存的大小可以是几种类型，例如缓存的实际对象数量或内存大小（以位或字节为单位）。'
- en: '**Expiration**: With each element, you can associate an *end of life*. When
    the *end of life* is reached, then the element should be evicted (removed) from
    the cache. Note that this parameter is not strict, and the element can stay in
    memory and be removed during access if the cache doesn''t use a background thread
    to evict the element fast enough. However, you shouldn''t notice it as a client
    (cache user).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期**：你可以与每个元素关联一个*生命周期*。当*生命周期*到达时，该元素应该从缓存中删除（移除）。请注意，此参数不是严格的，如果缓存没有使用足够快的后台线程来快速删除元素，则元素可以留在内存中并在访问期间被移除。然而，作为客户端（缓存用户），你不应该注意到这一点。'
- en: This is the high-level configuration. However, every cache implementation has
    a lot of different flavors, mixing a bit of everything. For instance, you can
    configure a cache to support keeping 1 million objects in memory with a cache
    memory of the maximum size of 10 MB, and if the objects don't fit in memory, then
    you can use 1 GB of disk space (overflow on disk strategy). This kind of advanced
    configuration may affect a different *end of life* to each element, and the cache
    can thus remove elements from the cache when this *end of life* is reached. Finally,
    you can associate this *per-element end of life* with a global maximum *end of
    life* policy of 10 minutes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是高级配置。然而，每个缓存实现都有很多不同的版本，混合了各种元素。例如，你可以配置一个缓存以支持在内存中保持100万个对象，缓存内存的最大大小为10
    MB，如果对象不适合内存，则可以使用1 GB的磁盘空间（溢出到磁盘策略）。这种高级配置可能会影响每个元素的不同*生命周期*，因此缓存可以在达到这个*生命周期*时从缓存中删除元素。最后，你可以将这个*每个元素的生命周期*与10分钟的全球最大*生命周期*策略相关联。
- en: If you browse your cache implementation provider, you will identify a lot of
    configuration options, and what is important is to not try to copy-paste a cache
    configuration from an existing application without ensuring you are in a similar
    scenario.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览你的缓存实现提供商，你会识别出很多配置选项，重要的是不要尝试复制粘贴现有应用程序中的缓存配置，除非你确保你处于类似的场景中。
- en: The idea is to start simple and complicate the configuration if your application
    requires it, or if you get a performance benefit from it. For instance, activating
    the disk overflow of the data can decrease your performance compared with going
    to your backend, especially if your backend connection is pretty fast and the
    disk is highly used already.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是从简单开始，如果应用程序需要或者从中获得性能提升，再复杂化配置。例如，激活数据的磁盘溢出可能会降低与访问后端相比的性能，特别是如果后端连接相当快且磁盘已经高度使用。
- en: Starting from a simple LRU strategy with a max memory size or object size is
    generally the most pragmatic choice.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个简单的LRU策略开始，具有最大内存大小或对象大小通常是最高效的选择。
- en: Cache storage – memory or not
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存存储 – 是内存还是不是
- en: 'The idea of caching is to keep the instances in order to serve them faster
    than rebuilding them or fetching them from a *slow* backend. The first-citizen
    storage is the heap because it is a fast-access solution. However, several cache
    vendors allow other strategies. Most of the time, it will allow to be pluggable
    through a **Service Provider Interface** (**SPI**), so you will often see a lot
    of implementations. Here is a small list of the ones you can find:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的想法是保留实例以便更快地提供服务，而不是重建它们或从*慢速*后端获取它们。首选的存储是堆，因为它是一种快速访问解决方案。然而，许多缓存供应商允许其他策略。大多数时候，它将通过**服务提供者接口**（**SPI**）来实现可插拔，因此你经常会看到很多实现。以下是你可能找到的一些小列表：
- en: Hard disk
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬盘
- en: RDBMS database (MySQL, Oracle, and so on)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统（RDBMS）数据库（MySQL、Oracle等）
- en: NoSQL database (MongoDB, Cassandra, a specific cache server kind of storage,
    *network cache*, and so on)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库（MongoDB、Cassandra、一种特定的缓存服务器存储类型、*网络缓存*等）
- en: Before discussing the usage of these extensions, don't forget that it is generally
    a cache-specific way to use backends. For example, it is not rare for hard-disk
    implementation to keep keys in memory, store the values on the disk to keep a
    fast lookup of the data, and ensure that memory usage is respectful of the configuration.
    This means that you will not always be able to use these *overflow* strategies
    to persist cached data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这些扩展的使用之前，不要忘记这通常是一种针对缓存的特定方式来使用后端。例如，硬盘实现中在内存中保持键、在磁盘上存储值以保持数据的快速查找，并确保内存使用符合配置的情况并不少见。这意味着你并不总是能够使用这些*溢出*策略来持久化缓存数据。
- en: The question is that if the overflow leads to using yet another backend, why
    is it useful and not more efficient to just go to the main backend, where the
    data is? This has several answers and they become more and more accurate with
    the microservices trend that we see nowadays.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，如果溢出导致使用另一个后端，为什么直接去数据所在的主后端会更有用且更高效呢？这有几个答案，并且随着我们现在看到的微服务趋势，这些答案变得越来越准确。
- en: 'The two main reasons for going through this kind of caching are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种缓存方式的主要两个原因如下：
- en: Provide a more reliable access to the data, even if the main backend is not
    reliable (and owned by another application you don't control).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供更可靠的访问数据的方式，即使主要的后端不可靠（且由你无法控制的另一个应用程序拥有）。
- en: Work around an access limitation (like a rate limit) without having to entirely
    rewrite the application to take it into account. For example, if you access the
    GitHub API, you will not be able to do more than 30 requests per minute on some
    endpoints, so if your application requires to do 1,500 accesses per minute, you
    will need to store the corresponding data on your side. Here, a cache can be fancy
    because it allows to put an eviction adapted to the rate limit, time unit, and
    your own application through output.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无需完全重写应用程序以考虑访问限制（如速率限制）的情况下，解决访问限制问题。例如，如果你访问GitHub API，你将无法在某个端点上每分钟进行超过30次请求，所以如果你的应用程序需要每分钟进行1,500次访问，你需要在你的端存储相应的数据。在这里，缓存可以很巧妙，因为它允许根据速率限制、时间单位和你的应用程序通过输出来放置适应的驱逐策略。
- en: Using a distributed solution (such as a centralized RDBMS or distributed database
    such as NoSQL) will allow you to share the data between nodes and avoid doing
    as many queries on the main backend as you have nodes. For instance, if you have
    100 nodes of your application in your cluster and you cache the key, *myid*, then
    you will request the backend 100 times for the *myid* data by using in-memory
    storage. Whereas, using a distributed storage, you will cache it once from one
    node, then just read it from this distributed storage, which is still faster than
    the main backend.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式解决方案（如集中式RDBMS或分布式数据库如NoSQL）将允许你在节点之间共享数据，并避免在主后端上进行与节点数量一样多的查询。例如，如果你的集群中有100个你的应用程序节点，并且你缓存了键，*myid*，那么你将通过内存存储请求后端100次以获取*myid*数据。而使用分布式存储，你只需从其中一个节点缓存一次，然后只需从这个分布式存储中读取，这仍然比主后端快。
- en: Even though using the overflow can be very tempting, don't forget that it is
    generally slower than in-memory caching (we often say that in-memory access time
    is one, disk access time is 10, and network access time is 100). There are alternative
    strategies that allow you to push data eagerly in memory instead of relying on
    overflow (lazy) reads, which may pay off if your cluster load balancing doesn't
    use any affinity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用溢出可能非常有吸引力，但不要忘记它通常比内存缓存慢（我们常说内存访问时间是1，磁盘访问时间是10，网络访问时间是100）。有一些替代策略允许你积极地将数据推入内存，而不是依赖于溢出（懒加载）读取，如果你的集群负载均衡没有使用任何亲和性，这可能是有益的。
- en: Consistency of the data
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据一致性
- en: 'We can now set up our caching on all our cluster nodes; the question, however,
    is whether our application is still working. To answer this, we will take a very
    simple case where two requests are executed in parallel:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在所有集群节点上设置我们的缓存；然而，问题是我们的应用程序是否仍然可以工作。为了回答这个问题，我们将考虑一个非常简单的案例，其中两个请求是并行执行的：
- en: '| **Node 1** | **Node 2** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **节点1** | **节点2** |'
- en: '| put data1 in cache at time t1 | - |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 在时间t1将数据1放入缓存 | - |'
- en: '|  | put data1 in cache at time t1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  | 在时间t1将数据1放入缓存 |'
- en: '| access data1 at time t3 | access data1 at time t3 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 在时间t3访问数据1 | 在时间t3访问数据1 |'
- en: With this simple timeline, we can immediately see that using a local in-memory
    cache can lead to inconsistencies, since nodes will likely not cache the data
    at the same time (cache is generally lazy, so the cache is populated at the first
    request or when the machine starts, if eager, which may lead to potentially inconsistent
    data in both cases).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的时间线，我们可以立即看出，使用本地内存缓存可能导致不一致，因为节点可能不会同时缓存数据（缓存通常是懒加载的，所以缓存是在第一次请求或机器启动时填充的，如果是积极加载的，这可能导致两种情况下都可能存在潜在的不一致数据）。
- en: 'If the data is cached, it generally means it is okay to not have the most up-to-date
    data. Is it really an issue?—It can be. In fact, if you load balance without affinity
    (randomly in terms of business logic, which is the case with a *by load* or *round-robin* load
    balancer), then you can fall into such a situation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据被缓存，通常意味着不需要最新的数据。这真的是一个问题吗？——是的，可能是一个问题。事实上，如果你在没有亲和性的负载均衡（从业务逻辑的角度看是随机的，这是*按负载*或*轮询*负载均衡器的情况），那么你可能会陷入这样的情况：
- en: '| **Node 1** | **Node 2** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **节点1** | **节点2** |'
- en: '| put data1 in cache at time t1 |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 在时间t1将数据1放入缓存 |  |'
- en: '|  | update data1 at time t2 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | 在时间t2更新数据1 |'
- en: '|  | put data1 in cache at time t3 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  | 在时间t3将数据1放入缓存 |'
- en: '| get and put data2 in cache at time t4 |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 在时间t4获取并将数据2放入缓存 |  |'
- en: '|  | put data2 in cache at time t5 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  | 在时间t5将数据2放入缓存 |'
- en: '| access data1 at time t6 | access data1 at time t6 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 在时间t6访问数据1 | 在时间t6访问数据1 |'
- en: '| access data2 at time t7 | access data2 at time t7 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 在时间t7访问数据2 | 在时间t7访问数据2 |'
- en: We are exactly in the same case as the previous one, but we can now use two
    kinds data (data1 and data2) in our business logic and cache both. Then, to identify
    the issue, we must consider that data1 and data2 are *logically* linked (for instance,
    data1 is an invoice and data2 is a contract with a price). In this situation,
    if you validate the data (data1 and data2), the processing may fail because the
    data is cached at different times and in different nodes, which would give more
    guarantees on the data consistency (since a single node will access a single cache
    and, therefore, be consistent with its current state).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于与之前相同的情况，但现在我们可以在业务逻辑中使用两种数据（数据1和数据2），并缓存两者。然后，为了识别问题，我们必须考虑数据1和数据2是*逻辑上*相关的（例如，数据1是一张发票，数据2是一份包含价格的合同）。在这种情况下，如果你验证数据（数据1和数据2），处理可能会失败，因为数据在不同的时间和不同的节点上被缓存，这会提供更多的数据一致性保证（因为单个节点将访问单个缓存，因此与其当前状态保持一致）。
- en: In other words, it is very important to cache the data in a way that guarantees
    whether your application still works even with the server's concurrency. The direct
    implication of this statement is to resist putting the cache everywhere during
    benchmarks, and adding it only when proven useful, while avoiding breaking the
    application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，以保证即使在服务器并发的情况下应用程序仍然可以工作的方式缓存数据非常重要。这个陈述的直接含义是在基准测试期间不要到处放置缓存，只有在证明其有用时才添加，同时避免破坏应用程序。
- en: The same thing exists in a worse manner with an overflow storage, since the
    overflow can be local to a node (hard disk, for instance), leading you to use
    three sources of truth for your data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在溢出存储中，这种情况更糟，因为溢出可以局限于节点（例如硬盘），这导致你使用三个数据来源。
- en: Generally, *reference data* is the first type of data we cache. It is the data
    that rarely changes, like a contract that is not supposed to change every day.
    This helps the application to go faster, since part of the data will have fast
    access. However, it will not break the application, since the *dynamic* data is
    still looked up from the main source (a database, for instance). Globally, you
    will end up with a hybrid lookup setup, where part of your data is read from the
    cache and the other part is read from the main backend.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*参考数据*是我们首先缓存的数据类型。这是很少变化的数据，比如不应该每天更改的合同。这有助于应用程序运行得更快，因为部分数据将具有快速访问。然而，它不会破坏应用程序，因为*动态*数据仍然从主要来源（例如数据库）中查找。总体而言，您将最终拥有一个混合查找设置，其中部分数据从缓存中读取，另一部分从主要后端读取。
- en: HTTP and caching
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP和缓存
- en: Implementing an HTTP server is one of the main purposes of Java EE. Using the
    Servlet API, JAX-RS, or even JAX-WS, you can easily expose data over HTTP without
    caring for the transport.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实现HTTP服务器是Java EE的主要目的之一。使用Servlet API、JAX-RS或甚至JAX-WS，您可以轻松地在HTTP上公开数据，而不必关心传输。
- en: However, HTTP defines a caching mechanism that is interesting to take into account
    in order to optimize the client's behavior.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，HTTP定义了一种缓存机制，这在优化客户端行为时值得考虑。
- en: 'The common communication with your server will look as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器的常见通信将如下所示：
- en: '![](img/137c99fd-c76e-4587-83b0-7e1e0d623329.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/137c99fd-c76e-4587-83b0-7e1e0d623329.jpg)'
- en: The server makes a request and the client sends back some data in headers and
    a payload (which can be huge). On the previous schema, it is a JSON payload, but
    don't forget that your web applications will probably also serve images and other
    sorts of resources, which get big very quickly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发起请求，客户端在头部和有效载荷（可能非常大）中发送一些数据（上一个架构中是JSON有效载荷）。但不要忘记，您的Web应用程序可能还会提供图像和其他类型的资源，这些资源很快就会变得很大。
- en: To avoid having to do it each and every time, even when nothing is changed (a
    picture will not change very often in general), the HTTP specification defines
    a set of headers that help identify the resource that didn't change. Thus, the
    client doesn't need to read the payload, but can just reuse the one it already
    has.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次都需要这样做，即使没有任何变化（通常图片不会经常变化），HTTP规范定义了一组头部，有助于识别未更改的资源。因此，客户端不需要读取有效载荷，只需重新使用它已经拥有的即可。
- en: Even if this way of caching the data is mainly intended to be used with resources
    and browsers, nothing prevents you from reusing these same mechanisms in a JAX-RS
    client to avoid fetching the data you access frequently, to ensure you are always
    up-to-date.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种缓存数据的方式主要是为了与资源和浏览器一起使用，也没有什么阻止你在JAX-RS客户端中重用这些相同的机制，以避免获取频繁访问的数据，确保你总是最新的。
- en: Cache-Control
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cache-Control
- en: '`Cache-Control` is a header that helps to deal with the cache. It defines the
    policy to use for the request/response. Used on a response, it defines how the
    client should cache the data; on a request, it defines what the server can send
    back in terms of policy.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cache-Control`是一个头部，有助于处理缓存。它定义了请求/响应应使用的策略。在响应中使用时，它定义了客户端应该如何缓存数据；在请求中使用时，它定义了服务器在策略方面可以发送回什么。'
- en: 'This header supports multiple values, which can be concatenated when compatible,
    separated by a comma. Here are the values you can use to define the way data is
    cached on the client:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此头部支持多个值，当兼容时可以连接，用逗号分隔。以下是您可以使用来定义客户端上数据缓存方式的值：
- en: '| **Value** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **描述** |'
- en: '| public/private | This defines whether the cache is public or private. A private
    cache is dedicated to a single client whereas a public cache is shared by several
    clients. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| public/private | 这定义了缓存是公共的还是私有的。私有缓存是专门为单个客户端设计的，而公共缓存是由多个客户端共享的。 |'
- en: '| no-cache | This defines the cached entry as outdated and enforces the loading
    of data once again from the server. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| no-cache | 这将缓存的条目定义为过时的，并强制从服务器再次加载数据。 |'
- en: '| no-store | This prevents the not volatile storage—no disk or persistent storage.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| no-store | 这防止了非易失性存储——没有磁盘或持久存储。 |'
- en: '| no-transform | This requests additional network layers, such as proxies,
    to keep the payload *as it is* . |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| no-transform | 这要求额外的网络层，如代理，以保持有效载荷*原样*。 |'
- en: '| max-age=<duration in seconds> | This defines how long the data can be cached
    (0 meaning never), for example, `max-age=600` for a 10-minute cache. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| max-age=<duration in seconds> | 这定义了数据可以缓存多长时间（0表示永不），例如，`max-age=600`表示10分钟的缓存。
    |'
- en: '| max-stale=<duration in seconds> | This notifies the server that an outdated
    response is acceptable while in this range. For instance, `max-stale=600` allows
    the server to serve data from 9 minutes ago, even if the server policy is 5 minutes.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| max-stale=<持续时间（秒）> | 这通知服务器，在此范围内，过时的响应是可以接受的。例如，`max-stale=600` 允许服务器从9分钟前提供数据，即使服务器的策略是5分钟。
    |'
- en: '| min-fresh=<duration in seconds> | This requests a response that will be valid
    during N seconds. Note that this is not always possible. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| min-fresh=<持续时间（秒）> | 这请求一个在N秒内有效的响应。请注意，这并不总是可能的。 |'
- en: '| min-vers=<value> | This specifies the HTTP protocol version to consider for
    caching. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| min-vers=<值> | 这指定了用于缓存的HTTP协议版本。 |'
- en: '| must-revalidate | The cached data will contact the server back (associated
    with an `If-Modified-Since` header) to validate the cached data. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| must-revalidate | 缓存的数据将联系服务器（与一个 `If-Modified-Since` 头相关联）以验证缓存的数据。 |'
- en: '| proxy-revalidate | This is same as `must-revalidate` but is used for proxies/gateways.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| proxy-revalidate | 这与 `must-revalidate` 相同，但用于代理/网关。 |'
- en: 'Here is an example of the header value you can use to not cache the data:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个你可以使用的头值示例，用于不缓存数据：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the type of configuration you can use for sensitive data to avoid keeping
    them and reuse them transparently. A *login* endpoint often does it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以用于敏感数据以避免保留和透明地重用它们的配置类型。一个 *登录* 端点通常会这样做。
- en: ETag
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ETag
- en: The `ETag` header presence is important for this header more than its value,
    which is not supposed to be read by the browser. However, its value is often `W/<content
    length>-<last modified>`, where `content length` is the size of the resource and
    `last modified` is its last modified timestamp. This is mainly because it is easy
    to generate and stateless for the server, but it can be anything, including a
    random string.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`ETag` 头的存在对于这个头比其值更重要，其值不应该被浏览器读取。然而，其值通常是 `W/<内容长度>-<最后修改时间>`，其中 `内容长度` 是资源的大小，`最后修改时间`
    是其最后修改的时间戳。这主要是因为它对服务器来说很容易生成且是无状态的，但它可以是任何东西，包括一个随机字符串。'
- en: This header value can be used as a strong validator. The presence of `W/` at
    the beginning marks it as a weak validator, which means multiple resources can
    have the same value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头值可以用作强验证器。开头有 `W/` 标记它为一个弱验证器，这意味着多个资源可以具有相同的值。
- en: 'The value is used with other headers as an identifier, for instance, `Other-Header:
    <etag>`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '该值与其他头一起用作标识符，例如，`Other-Header: <etag>`。'
- en: Used with `If-None-Match`, the header takes a list of `Etag` values, potentially
    `*` for uploads as well, in a comma-separated fashion. If the server doesn't match
    any resource (or already uploaded payload for *PUT*/*POST*), then the request
    will be processed; otherwise, it will return an HTTP 304 response for the read
    methods (*GET*, *HEAD*) and 412 (precondition failed) for others.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `If-None-Match` 一起使用时，该头以逗号分隔的形式接受一个 `Etag` 值列表，对于上传也可以是 `*`。如果服务器没有匹配任何资源（或已上传的
    *PUT*/*POST* 有效负载），则请求将被处理；否则，它将为读取方法（*GET*，*HEAD*）返回 HTTP 304 响应，对于其他方法返回 412（预条件失败）。
- en: An interesting header linked to this kind of logic is `If-Modified-Since`. It
    will allow you to do almost the same, but based on a date if you don't have `Etag`
    for the resource. It is often associated with the `Last-Modified` value sent back
    by the server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与这种逻辑相关的有趣头是 `If-Modified-Since`。它将允许你做几乎相同的事情，但基于日期，如果你没有资源的 `Etag`。它通常与服务器返回的
    `Last-Modified` 值相关联。
- en: Vary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vary
- en: The `Vary` header defines how to decide whether a cached response can be used
    or not. It contains a comma-separated list of headers, which must not change,
    in order to decide whether the cache can be used.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vary` 头定义了如何决定是否可以使用缓存的响应。它包含一个逗号分隔的头列表，这些头必须不变，以便决定是否可以使用缓存。'
- en: 'Let''s take these two HTTP responses, for example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以这两个HTTP响应为例：
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Both the responses are the same, except the `App-Target` header. If you add
    caching, a desktop or mobile request will lead to the same payload being served
    if cached.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 两个响应都是相同的，除了 `App-Target` 头。如果你添加缓存，桌面或移动请求将导致提供相同的有效负载，如果已缓存。
- en: 'Now, if the responses are modified, like in the following snippets, to add
    the `Vary` header, each kind of `App-Target` will not reuse the cache of the other
    one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果响应被修改，如下面的片段所示，添加 `Vary` 头，每种 `App-Target` 都不会重用其他一种的缓存：
- en: '|'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This way, both *desktop* and *mobile* experiences can use different resources.
    For instance, the server can use a different folder depending on the `App-Target`
    value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，桌面和移动体验都可以使用不同的资源。例如，服务器可以根据`App-Target`值使用不同的文件夹。
- en: HTTP caching and the Java EE API
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP缓存和Java EE API
- en: Java EE doesn't define a dedicated API (or specification) for HTTP caching,
    but it provides a few helpers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE没有为HTTP缓存定义一个专门的API（或规范），但它提供了一些辅助工具。
- en: 'The more direct (and low level) way to configure it is by using the Servlet
    specification, which abstracts the HTTP layer:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 配置它的更直接（和低级）方式是使用Servlet规范，它抽象了HTTP层：
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this filter, the `Cache-Control` value will prevent the cached data from
    being persistently stored. To activate it, just add it in your `web.xml` or in
    the server if you don''t want to modify your application:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个过滤器，`Cache-Control`值将防止缓存数据被持久存储。要激活它，只需将其添加到你的`web.xml`中或在服务器中（如果你不想修改你的应用程序）：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using this XML declaration, and not the `@WebFilter` one, allows you to reuse
    the same filter on different mappings (URLs) without having to redeclare it or
    modify the code. The previous declaration put this filter on all the web applications.
    It can be good for an application that has secured only web services, for instance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个XML声明，而不是`@WebFilter`，允许你在不同的映射（URL）上重用相同的过滤器，而无需重新声明或修改代码。之前的声明将此过滤器放在所有Web应用程序上。对于仅保护Web服务的应用程序来说，这可能是个好主意。
- en: 'If you want a bit higher level API, you can use the JAX-RS API, which provides
    a `CacheControl` API. But for some particular headers, you will still go to a
    lower level, even while using JAX-RS `Response` instead of `HttpServletResponse`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个更高级的API，你可以使用JAX-RS API，它提供了一个`CacheControl` API。但对于某些特定的头信息，即使在使用JAX-RS
    `Response`而不是`HttpServletResponse`时，你仍然需要降低到更低的级别：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This JAX-RS filter will do the same as the previous Servlet filter, but in
    a JAX-RS way. Now, if you return a `Response` in your endpoint, you can directly
    use the `CacheControl` API:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JAX-RS过滤器将与之前的Servlet过滤器做相同的事情，但以JAX-RS的方式。现在，如果你在你的端点返回一个`Response`，你可以直接使用`CacheControl`
    API：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code associates a cache control strategy with the response, which will
    be converted to headers in the actual HTTP response.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将一个缓存控制策略与响应关联，这将转换为实际的HTTP响应中的头信息。
- en: HTTP 2 promise
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 2承诺
- en: 'Servlet 4.0 specification brings HTTP/2 support, which is new for Java EE and
    for a lot of applications. The idea is to be able to eagerly push some resources
    to the client. Here is a basic example to give you a high-level picture in mind:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 4.0规范引入了HTTP/2支持，这对于Java EE和许多应用程序来说都是新的。其想法是能够积极地将一些资源推送到客户端。以下是一个基本示例，以给你一个高层次的概念：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This Servlet will start pushing the resource `images/packt.png` upfront. This
    will enable the browser to rely on it in the response it serves after (likely
    an HTML page), without having the client to load the image later on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Servlet将提前开始推送资源`images/packt.png`。这将使浏览器能够在它提供的响应中依赖它（可能是HTML页面），而无需客户端稍后加载图像。
- en: This will enable the applications to be more reactive since it is all done in
    a single connection. Thus, it is faster than opening multiple connections to get
    multiple resources, but it doesn't mean you don't need caching. As you can see
    in the preceding code snippet, the headers are supported per resource, so you
    can still use what we previously saw per resource to make the resources load faster,
    even on HTTP/2.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使应用程序能够更加反应灵敏，因为所有操作都在单个连接中完成。因此，它比打开多个连接以获取多个资源要快，但这并不意味着你不需要缓存。正如你可以在前面的代码片段中看到的那样，头信息是按资源支持的，所以你仍然可以使用我们之前看到的按资源的方法来使资源加载更快，即使在HTTP/2上也是如此。
- en: JCache – the standard cache of Java EE
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JCache – Java EE的标准缓存
- en: 'JCache was added to Java EE to enable the application and libraries to interact
    in a standard manner with the caching. Therefore, it has two types of APIs and
    features:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: JCache被添加到Java EE中，以使应用程序和库能够以标准方式与缓存交互。因此，它有两种类型的API和功能：
- en: A programmatic Cache API to write/read data
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于读写数据的程序化缓存API
- en: A CDI integration to automatically put data in the cache
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CDI集成，可以自动将数据放入缓存
- en: Setting up JCache
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置JCache
- en: 'To use JCache, you may need to add it to your application—or to your server,
    depending on how you want to deploy it—since not all servers add it in their distribution(s).
    To do it with maven, you can add this dependency:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JCache，你可能需要将其添加到你的应用程序中——或者根据你如何部署它，添加到你的服务器中——因为并非所有服务器都在它们的分发中包含它。使用Maven，你可以添加这个依赖项：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then the only thing you will need to do is select an implementation and add
    it as well. The most common ones are the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你唯一需要做的就是选择一个实现并将其添加进去。最常见的是以下这些：
- en: Apache Ignite
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Ignite
- en: JBoss Infinispan
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JBoss Infinispan
- en: Apache JCS
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache JCS
- en: Ehcache
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ehcache
- en: Oracle Coherence
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Coherence
- en: Hazelcast
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hazelcast
- en: 'As often, the choice of the provider is a multicriteria choice and you will
    probably want to take the following into account:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，选择提供商是一个多标准选择，你可能需要考虑以下因素：
- en: The performances
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: The dependency stack the provider enforces you to adopt (it can conflict with
    your other libraries for the biggest ones)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供商强制你采用的依赖堆栈（它可能与你最大的其他库冲突）
- en: The extensions the provider has (some of them don't even support CDI)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供商拥有的扩展（其中一些甚至不支持CDI）
- en: The community and support you can get from it
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从它那里获得的社区和支持
- en: However, using the JCache API, the provider implementation should not impact
    your code. So, it doesn't impact you and you can start setting up JCache and change
    the provider later.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用JCache API，提供商实现不应影响你的代码。所以，它不会影响你，你可以开始设置JCache并在以后更改提供商。
- en: If the provider you choose doesn't support CDI, JCS provides a *cdi* module,
    which allows you to add CDI integration without using the JCS cache implementation,
    but using the one you provide.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择的提供商不支持CDI，JCS提供了一个*cdi*模块，它允许你添加CDI集成，而无需使用JCS缓存实现，而是使用你提供的实现。
- en: Programmatic API
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程API
- en: 'A JCache cache can be very quickly accessed using the `Caching` factory:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Caching`工厂非常快速地访问JCache缓存：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `getCache` method directly gives you back a `Cache` instance, which allows
    you to write/read data. The API is then close to a plain `Map` semantic. However,
    this only works if the cache already exists; otherwise, the `getCache` call will
    fail.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCache`方法直接返回一个`Cache`实例，允许你写入/读取数据。API随后接近于普通的`Map`语义。然而，这仅在缓存已存在时才有效；否则，`getCache`调用将失败。'
- en: 'To understand how JCache works, we need to look at how the instances are managed.
    This design is pretty common in Java EE and is quite efficient in general:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解JCache是如何工作的，我们需要看看实例是如何管理的。这种设计在Java EE中相当常见，通常效率很高：
- en: A factory method gives you a provider instance (a link between the API and implementation)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工厂方法为你提供一个提供商实例（API和实现之间的链接）
- en: The provider gives you a manager, which stores instances and avoids creating
    them for every request
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供商给你一个管理器，它存储实例并避免为每个请求创建它们
- en: The manager allows you to create and get cache instances
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理器允许你创建和获取缓存实例
- en: 'Here is what it looks like in terms of code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码中的样子：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The caching factory will give a provider on line 2, but we passed a classloader
    as a parameter to load the provider for potential future uses. We could use `Caching.getDefaultClassLoader()`,
    but depending on the environment, you can get a classloader other than the one
    in your application. So, it is generally saner to manually pass your own application's
    classloader. Then, we'll create `CacheManager` from the provider we just retrieved.
    The `getCacheManager` method takes three parameters, which are mainly about how
    to configure the cache. The URI can default to the provider default value using
    the provider `getDefaultURI()` method. It is the path (URI, actually) to the vendor-specific
    configuration file. The loader is the classloader to use for the manager/caches
    usages and the property is a list of key/values used to configure the cache in
    a vendor-specific manner. Then, once we have a manager, `createCache()` allows
    you to define a cache name and its configuration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存工厂将在第2行提供一个提供商，但我们传递了一个类加载器作为参数来加载提供商以供未来潜在使用。我们可以使用`Caching.getDefaultClassLoader()`，但根据环境，你可能得到一个不同于你应用程序的类加载器。因此，通常更明智的做法是手动传递你自己的应用程序类加载器。然后，我们将从我们刚刚检索到的提供商创建`CacheManager`。`getCacheManager`方法接受三个参数，主要关于如何配置缓存。URI可以使用提供商的`getDefaultURI()`方法默认为提供商的默认值。这是指向供应商特定配置文件的路径（URI）。加载器是用于管理/缓存使用的类加载器，属性是用于以供应商特定方式配置缓存的键/值列表。然后，一旦我们有一个管理器，`createCache()`允许你定义缓存名称及其配置。
- en: 'Note that we have two types of configurations here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有两种配置类型：
- en: The implementation-specific configuration passed through the URI and properties
    to the manager
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过URI和属性传递给管理器的特定实现配置
- en: The JCache configuration passed through the `createCache()` method
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`createCache()`方法传递的JCache配置
- en: JCache configuration
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JCache配置
- en: 'The JCache configuration implements `javax.cache.configuration.Configuration`
    or, more often, `javax.cache.configuration.CompleteConfiguration`. This specification
    provides the `MutableConfiguration` implementation, which provides a fluent DSL
    to configure the configuration. Here are the main entry points:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: JCache 配置实现了 `javax.cache.configuration.Configuration` 或更常见的是 `javax.cache.configuration.CompleteConfiguration`。此规范提供了
    `MutableConfiguration` 实现，它提供了一个流畅的 DSL 来配置配置。以下是主要入口点：
- en: '| **Configuration** | **Description** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **配置** | **描述** |'
- en: '| key type/value type | Allows to enforce the keys/values to respect a typing.
    If a key or value doesn''t respect the configuration type then it will be rejected
    (the `put` will fail). |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 键类型/值类型 | 允许强制键/值遵守类型。如果键或值不遵守配置类型，则会被拒绝（`put` 将失败）。 |'
- en: '| store by value | If true, it will copy the values to prevent them from being
    mutable (which is the case in store by reference mode). It is faster to store
    by reference, but in such a case, it is recommended to ensure the key/value pair
    is immutable in your application. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 值存储 | 如果为真，它将复制值以防止它们可变（这是在按引用存储模式中的情况）。按引用存储更快，但在这种情况下，建议确保键/值对在您的应用程序中是不可变的。
    |'
- en: '| cache entry configuration listeners | JCache provides several listeners for
    all cache events (entry created, updated, deleted, expired) and registering a
    configuration listener allows to register such a listener and define its behavior—which
    entry to trigger the event for (the listener event filter), is the listener synchronous,
    and should the listener provide the old value of the data if it exists. This last
    parameter intends to avoid triggering a network communication if not needed for
    distributed caches. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 缓存条目配置监听器 | JCache 为所有缓存事件（条目创建、更新、删除、过期）提供了一些监听器，并注册配置监听器允许注册此类监听器并定义其行为——触发事件的条目（监听器事件过滤器），监听器是否同步，以及如果存在，监听器是否应提供数据的旧值。最后一个参数旨在避免在不需要时触发网络通信（对于分布式缓存）。
    |'
- en: '| cache loader/writer factory | JCache provides loader and writer mechanism.
    The goal is to be able to populate the cache from an external source (like a database)
    if the data is not in the cache yet, and to synchronize the cache with the same
    - or another - external storage. In your application, it means you only access
    the cache, but your data can be persisted. This is a paradigm change in terms
    of code where the cache is the source of truth for your data. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 缓存加载器/写入器工厂 | JCache 提供了加载器和写入器机制。目标是能够在数据尚未在缓存中时，从外部源（如数据库）填充缓存，并且与相同或另一个外部存储同步。在您的应用程序中，这意味着您只访问缓存，但您的数据可以持久化。这在代码方面是一个范式转变，其中缓存是您数据的真相来源。
    |'
- en: '| management enabled | Registers a JMX MBean for each cache exposing the cache
    configuration. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 管理启用 | 为每个缓存注册一个 JMX MBean，以公开缓存配置。 |'
- en: '| statistics enabled | Registers a JMX MBean for each cache exposing the cache
    statistics (hits, misses, removals, and so on) and allows to reset the statistics.
    This is very helpful to validate your cache is useful (if you only get misses
    then the cache just adds an overhead and is never used as intended). |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 统计启用 | 为每个缓存注册一个 JMX MBean，以公开缓存统计信息（命中、未命中、删除等），并允许重置统计信息。这非常有帮助，以验证您的缓存是否有用（如果您只得到未命中，则缓存只是增加了开销，并且从未按预期使用）。
    |'
- en: '| read/write through | Activates the reader/writer if configured. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 读写通过 | 如果配置了，则激活读取器/写入器。 |'
- en: CDI integration
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI 集成
- en: The JCache specification (and, therefore, complete implementations) comes with
    a CDI integration. The idea is to enable you to cache your data without having
    to deal with all the glue of `Cache`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: JCache 规范（以及因此完整的实现）包含 CDI 集成。其想法是让您能够缓存数据，而无需处理 `Cache` 的所有粘合剂。
- en: 'The CDI integration provides four operations usable with CDI:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 集成提供了四个与 CDI 一起使用的操作：
- en: '`@CacheResult`: This is probably the most useful feature that will cache a
    method result and serve it from the cache for later invocations.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheResult`: 这可能是最有用的功能，它将缓存方法结果，并在后续调用中从缓存中提供服务。'
- en: '`@CacheRemove`: This removes data from the cache.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheRemove`: 这将从缓存中删除数据。'
- en: '`@CacheRemoveAll`: This removes all the data of the referenced cache.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheRemoveAll`: 这将删除引用缓存中的所有数据。'
- en: '`@CachePut`: This adds data to the cache. It relies on `@CacheValue`, which
    marks a parameter to identify the value to cache.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CachePut`: 这会将数据添加到缓存中。它依赖于 `@CacheValue`，它标记一个参数以标识要缓存的价值。'
- en: 'If we want to cache our quotes in our service, we can just decorate our finder
    method with `@CacheResult`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在我们的服务中缓存我们的报价，我们只需用`@CacheResult`装饰我们的查找方法：
- en: '[PRE19]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding the `@CacheResult` annotation will allow you to use the cache from the
    second invocation of this method and bypass the JPA lookup we used to do.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`@CacheResult`注解将允许您从该方法的第二次调用中使用缓存，并绕过我们之前使用的JPA查找。
- en: Note that here we are not caching an optional, as it was our original signature,
    which will work but is not serializable. Being part of the JDK, we could have
    trouble making it serializable if our cache needs that constraint to distribute
    the values into the cache cluster. In practice, try not to cache optionals, and
    never cache streams that are lazily evaluated and not reusable.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们不是缓存一个可选值，正如我们的原始签名那样，这将工作但不可序列化。作为JDK的一部分，如果我们需要该约束将值分布到缓存集群，我们可能会遇到麻烦。在实践中，尽量不缓存可选值，并且永远不要缓存那些被延迟评估且不可重用的流。
- en: Cache configuration
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存配置
- en: All these annotations share the same type of configuration where you can define
    if the corresponding action is done before/after the method execution, how the
    cache behaves in case of an exception (is the cache operation skipped?), what
    the cache name is and how to resolve the cache and key to use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些注解都共享相同类型的配置，您可以在其中定义是否在方法执行前后执行相应的操作，在发生异常时缓存的行为（是否跳过缓存操作？），缓存名称以及如何解析要使用的缓存和键。
- en: While the first set of parameters is simple to understand, let's focus on the
    cache resolution, which is a bit peculiar with CDI, as you don't bootstrap the
    cache yourself but simply reference it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一组参数很容易理解，但让我们关注缓存解析，这在CDI中有点特别，因为您不是自己启动缓存，而是简单地引用它。
- en: In the programmatic approach, we saw that the cache configuration is done through
    a `CompleteConfiguration` instance. How do you provide it in a CDI context?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序化方法中，我们看到了缓存配置是通过一个`CompleteConfiguration`实例完成的。如何在CDI上下文中提供它？
- en: 'All these annotations take two important parameters:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些注解都接受两个重要参数：
- en: '`cacheName`: This represents the cache name to use for the operation. Note
    that by default it is based on the qualified name of the method if not explicitly
    set.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheName`：这表示用于操作的缓存名称。请注意，如果没有明确设置，默认情况下它基于方法的限定名。'
- en: '`cacheResolverFactory`: This is the way a cache instance will be retrieved.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheResolverFactory`：这是检索缓存实例的方式。'
- en: A cache resolver factory provides access from the method metadata to the cache
    resolver to do the operation associated with the annotation, or a cache resolver
    for the exception if an exception is thrown and the configuration of the annotation
    requires to cache it if `CacheResult#exceptionCacheName` is set.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存解析器工厂提供从方法元数据到缓存解析器的访问，以执行与注解相关的操作，或者在抛出异常且注解配置要求在`CacheResult#exceptionCacheName`设置的情况下缓存异常的缓存解析器。
- en: 'The cache resolver is just a contextual factory of cache. Here is a simplistic
    implementation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存解析器只是缓存的一个上下文工厂。以下是一个简化的实现：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This implementation is a CDI bean that allows you to reuse the CDI power and
    tries to retrieve the existing cache from the contextual cache name; if it doesn't
    exist, it creates a new instance. This is done in this order to avoid passing
    in the catch block at runtime—it will happen only once.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现是一个CDI bean，允许您重用CDI功能，并尝试从上下文缓存名称检索现有缓存；如果不存在，则创建一个新实例。这样做是为了避免在运行时传递catch块——它只会发生一次。
- en: 'Indeed, to make this implementation work, you need to produce the cache manager
    somewhere:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，为了使此实现工作，您需要在某处生成缓存管理器：
- en: '[PRE21]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a plain CDI producer and the associated code can reuse the code we saw
    in the programmatic API part.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通的CDI生产者，相关的代码可以重用我们在程序化API部分看到的代码。
- en: 'The interesting thing using CDI and extracting the resolver is that you can
    easily integrate with any configuration. For instance, to read a configuration
    from `${app.home}/conf/quote-manager-cache.properties`, you can use this implementation
    of the cache resolver factory:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDI和提取解析器有趣的地方在于，您可以轻松地与任何配置集成。例如，要从`${app.home}/conf/quote-manager-cache.properties`读取配置，您可以使用此缓存解析器工厂的实现：
- en: '[PRE22]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this skeleton, we can see that the cache resolver factory getting injections
    as any CDI bean, that it read the configuration in a `@PostConstruct` method to
    avoid reading it each time (but this is not mandatory, it just shows that it really
    can leverage CDI features), and that when a cache needs to be provided, it is
    created using the strategy we saw previously (see the simplistic implementation).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个框架，我们可以看到缓存解析器工厂像任何CDI豆一样接收注入，它在一个`@PostConstruct`方法中读取配置以避免每次都读取（但这不是强制性的，只是表明它确实可以利用CDI功能），当需要提供缓存时，它使用我们之前看到的策略创建（参见简单实现）。
- en: 'To be complete, we need to see how we read the configuration. It can be as
    simple as reading a `properties` file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整，我们需要看看我们是如何读取配置的。它可以像读取`properties`文件一样简单：
- en: '[PRE23]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code is not very complicated and quite common, but the trick is to convert
    `Properties` into `Map`, which avoids being synchronized at runtime and would
    potentially slow down the runtime a little bit while different caches are getting
    created for no reason.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并不复杂，相当常见，但技巧在于将`Properties`转换为`Map`，这避免了在运行时同步，可能会在创建不同缓存时无理由地稍微减慢运行时速度。
- en: 'The last missing thing for having a functional implementation is how to create
    the cache configuration. It is mainly just a matter of converting the configuration
    into a cache configuration instance. Here is a potential implementation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个功能性的实现，最后缺少的东西是如何创建缓存配置。这主要是将配置转换为缓存配置实例的问题。以下是一个潜在的实现：
- en: '[PRE24]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To create the cache configuration, we rely on `MutableConfiguration` and just
    read the values from the properties we loaded. The trick is to get instances like
    the reader or writer. This can be done using CDI `Instance<Object>`, which can
    be seen as a generic CDI lookup; you can also use `BeanManager` directly if you
    prefer. In this implementation, we look up the reader/writer from their CDI name,
    so we need to provide the `@Named("...")` literal. Since CDI 2.0, you can use
    the `NamedLiteral` API, which will create the corresponding annotation instance
    for you. Finally, readers/writers need to be passed to the JCache runtime through
    a factory, but JCache provides a singleton factory implementation, preventing
    you from creating your own.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建缓存配置时，我们依赖于`MutableConfiguration`并直接从已加载的属性中读取值。技巧在于获取像读取器或写入器这样的实例。这可以通过CDI的`Instance<Object>`实现，这可以看作是一个通用的CDI查找；如果您愿意，也可以直接使用`BeanManager`。在这个实现中，我们从CDI名称查找读取器/写入器，因此我们需要提供`@Named("...")`字面量。自从CDI
    2.0以来，您可以使用`NamedLiteral` API，这将为您创建相应的注解实例。最后，读取器/写入器需要通过一个工厂传递给JCache运行时，但JCache提供了一个单例工厂实现，防止您创建自己的。
- en: '@CacheDefaults'
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@CacheDefaults'
- en: '`@CacheDefaults` allows you to define at the cache level, the cache name, the
    resolver factory, and the key generator to use. It prevents having to do it on
    all the methods if they all share the same setup:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`@CacheDefaults`允许您在缓存级别定义缓存名称、解析器工厂和要使用的键生成器。它防止了在所有方法上都需要执行此操作，如果它们都共享相同的设置：'
- en: '[PRE25]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This class, which delegates the logic to a dedicated service, has two methods
    using JCache CDI integration. Both are using the same shared configuration relying
    on the `@CacheDefaults` setup done at the class-level. It prevents having to code
    it this way:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将逻辑委托给一个专门的服务，有两个方法使用JCache CDI集成。这两个方法都使用在类级别上完成的相同共享配置，依赖于`@CacheDefaults`设置。它防止了必须以这种方式编写代码：
- en: '[PRE26]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a more simplistic flavor, cache configuration was duplicated by method, which
    is less readable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在更简单的版本中，缓存配置是通过方法复制的，这降低了可读性。
- en: Cache key
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存键
- en: 'Now, we are able to control our cache and activate our cache operations on
    our methods; what did we miss?—A way to control the key used for the cache. For
    instance, let''s take the following method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够控制我们的缓存并激活我们的缓存操作在方法上；我们错过了什么？——控制用于缓存的键的方式。例如，让我们看看以下方法：
- en: '[PRE27]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, the natural key is the symbol, so it would be nice if JCache could do
    it automatically, right? It is the cache, but the rule is a bit more complicated
    because if you apply the same reasoning for a `create` method, then it doesn''t
    work:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，自然键是符号，所以如果JCache能自动完成这个任务，那就太好了，对吧？它是缓存，但规则稍微复杂一些，因为如果您为`create`方法应用相同的推理，那么它就不起作用了：
- en: '[PRE28]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we want the result to be cached, but if `findQuote()` must match the `create()`
    method, then we must have a way to ask JCache to use only `symbol` in the key.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望结果被缓存，但如果`findQuote()`必须匹配`create()`方法，那么我们必须有一种方法来请求JCache只使用`symbol`作为键。
- en: 'To do so, JCache relies on the `@CacheKey` API. The following are the rules:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，JCache依赖于`@CacheKey` API。以下是一些规则：
- en: If there is no `@CacheKey`, then use all parameters
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有`@CacheKey`，则使用所有参数
- en: If there is `@CacheValue` used on some parameter but no `@CacheKey`, then use
    all the parameters except the one decorated with `@CacheValue`
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某个参数使用了`@CacheValue`但没有`@CacheKey`，则使用所有参数，除了装饰了`@CacheValue`的那个
- en: If some parameters (*>= 1*) are decorated with `@CacheKey`, then use them
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某些参数（*>= 1*）装饰了`@CacheKey`，则使用它们
- en: 'In other words, our `create` method should look like the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们的`create`方法应该看起来像以下这样：
- en: '[PRE29]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This way, and due to the previous rules, the `findQuote` and `create` methods
    use the same key, based on the symbol—*based* because the key of the cache is
    not directly the value you pass as the parameter. This is mainly because it can
    be a key composed of multiple parameters, so you need to wrap them in a single
    object. The actual key type is `GeneratedCacheKey`, which just enforces the implementation
    to be serializable and to implement `equals` and `hashCode` for the reason we
    mentioned at the beginning of the chapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，由于之前的规则，`findQuote`和`create`方法使用相同的键，基于符号—*基于*，因为缓存的键不是直接作为参数传递的值。这主要是因为它可能是由多个参数组成的键，所以你需要将它们包装在单个对象中。实际的关键类型是`GeneratedCacheKey`，它只是强制实现序列化，并实现`equals`和`hashCode`，正如我们在本章开头提到的理由。
- en: 'The JCache implementation will, by default, provide an implementation respecting
    these rules, but in some cases, you can optimize or want to customize the key.
    In our case, a plain string key, we can optimize `GeneratedCacheKey` to fully
    rely on the String specifics, which allows to cache `hashCode`. Here is the implementation:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: JCache实现将默认提供一个遵守这些规则的实现，但在某些情况下，您可以优化或希望自定义键。在我们的例子中，一个普通的字符串键，我们可以优化`GeneratedCacheKey`以完全依赖于字符串的特定功能，这允许缓存`hashCode`。以下是实现：
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since a cache access is an access to a storage cell through the hash index,
    optimizing the hash can be worthy if the delegate parameters' hash code computing
    is long or needs to go through a complex graph. The same kind of logic can apply
    to `equals`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓存访问是通过哈希索引访问存储单元，如果代理参数的哈希码计算时间较长或需要通过复杂的图进行，那么优化哈希可能是值得的。同样的逻辑也适用于`equals`。
- en: 'Now, we have an *optimized* flavor of our key; we need to enable it. This is
    done through the cache annotation (`@CacheDefaults`) and the `cacheKeyGenerator()`
    member. It allows us to reference a *key generator*. Here, again, it can be a
    CDI bean, and it gives you the contextual information of the method, so you can
    instantiate the key:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了我们键的*优化*版本；我们需要启用它。这是通过缓存注解（`@CacheDefaults`）和`cacheKeyGenerator()`成员来完成的。它允许我们引用一个*键生成器*。在这里，同样，它可以是CDI
    bean，它提供了方法的环境信息，因此你可以实例化键：
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This a very simple implementation; directly extract the (assumed) single key
    parameter of the method and cast it to a string to instantiate our optimized generated
    cache key. Then, to use it, we just reference this class in the cache annotation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的实现；直接提取方法（假设的）单个键参数并将其转换为字符串以实例化我们优化的生成缓存键。然后，为了使用它，我们只需在缓存注解中引用这个类：
- en: '[PRE32]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is very important to ensure that the generator implementation matches the
    method signature. Typically, in this last snippet, if we change our `name` parameter
    to `long`, then we need to change the key generator; otherwise, it will fail.
    However, it is not rare to have generators assuming the type of key parameters,
    since it is generally coupled to optimize their usage.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确保生成器实现与方法签名匹配非常重要。通常，在这个最后的片段中，如果我们把`name`参数改为`long`，那么我们需要更改键生成器；否则，它将失败。然而，生成器假设键参数类型的情况并不少见，因为它通常与优化它们的用法相关联。
- en: Cache once
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存一次
- en: 'If we look back at our quote manager application, we have the following layers
    through which a request goes:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回顾我们的报价管理应用，一个请求会经过以下层次：
- en: Servlet
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet
- en: JAX-RS
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS
- en: Service layer (`@Transactional`)
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层（`@Transactional`）
- en: JPA
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA
- en: You can add some caching (such as JCache, not HTTP, which is more a client data
    management solution) to all the layers. On the Servlet side, you can cache the
    responses using the requests as key. In JAX-RS, you can do the same, but in a
    more business-oriented manner. In the service layer, you can use CDI JCache integration.
    And in JPA, you can use level 2 caching, which can be implemented with JCache
    or a provider-specific implementation—this generally just requires configuration
    to be set up so that the API is not very crucial.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在所有层添加一些缓存（例如JCache，而不是HTTP，后者更像是客户端数据管理解决方案）。在Servlet层面，你可以使用请求作为键来缓存响应。在JAX-RS中，你可以以更面向业务的方式做同样的事情。在服务层，你可以使用CDI
    JCache集成。而在JPA中，你可以使用第2级缓存，这可以通过JCache或特定提供者的实现来实现——这通常只需要配置设置，这样API就不是非常关键。
- en: However, if you configure the caching on all layers, it is likely that a part
    of the cache will be useless, and since all the layers will not have access to
    the same information, you will duplicate the caches for a poor gain or for nothing.
    To use an extreme example, if you cache the response from the request in the Servlet
    layer, the JAX-RS/service/JPA layer will never be called once the data is in the
    cache and, therefore, setting up caching in these layers is useless. It doesn't
    mean that the caching in these layers should be avoided because using some caching
    in the service layer can benefit some background tasks as well (such as a batch
    developed with JBatch using some reference data).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在所有层配置缓存，很可能会有一部分缓存是无用的，并且由于所有层无法访问相同的信息，你将为了微小的收益或没有任何收益而重复缓存。用一个极端的例子来说，如果你在Servlet层缓存请求的响应，一旦数据进入缓存，JAX-RS/service/JPA层就永远不会被调用，因此在这些层设置缓存是无用的。这并不意味着在这些层应该避免缓存，因为服务层使用一些缓存也可以使一些后台任务受益（例如，使用JBatch开发的批处理任务使用一些参考数据）。
- en: Nonetheless, caching the closest of the outbound of your application will give
    you the best performance boost, as it will bypass more layers. For instance, caching
    the response in the Servlet layer will bypass JAX-RS and, thereby, JAX-RS routing
    and serialization steps, where caching the same data in the service layer will
    keep executing these steps through the JAX-RS layer.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，缓存你应用程序最外层的输出将给你带来最佳的性能提升，因为它将绕过更多层。例如，在Servlet层缓存响应将绕过JAX-RS，从而绕过JAX-RS的路由和序列化步骤，而在服务层缓存相同的数据将保持通过JAX-RS层执行这些步骤。
- en: There is no general rule here, since it is a trade-off between the memory it
    takes (closer to the data you are). The less memory you use in general, the simpler
    the key handling will be (since you don't accumulate other data such as HTTP headers
    in Servlet layer). The best you should do is to think about your application and
    how it uses data and then validate the cache setup by a comparative benchmark.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有普遍的规则，因为这是在内存占用（接近你的数据）之间的权衡。你通常使用的内存越少，键处理就会越简单（因为你不会在Servlet层累积其他数据，如HTTP头）。你最好做的事情是考虑你的应用程序以及它如何使用数据，然后通过比较基准来验证缓存设置。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At the end of this chapter, you have all the keys you need to enhance your application
    performance. We saw how to send the right data to a browser to not have to load
    cached data, how to set up a cache using Java EE API (JCache), and the caching
    challenges you need to think about to not decrease the performance.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将拥有增强应用程序性能所需的所有关键。我们看到了如何将正确的数据发送到浏览器，以便不必加载缓存数据，如何使用Java EE API（JCache）设置缓存，以及你需要考虑的缓存挑战，以避免降低性能。
- en: Being able to cache data in a distributed system is important, since any network
    call is very impacting on performances. Now that we know how to cache, we can
    go to the next level about distributed systems and see how to control the performance
    in a wider system. This is what our next chapter will be about—how to be fault-tolerant
    and avoid impacting all the applications of a system when one is starting to fail
    or running slower than usual.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中能够缓存数据非常重要，因为任何网络调用都会对性能产生很大影响。现在我们知道了如何缓存，我们可以进入分布式系统的下一个层次，看看如何在一个更广泛的系统中控制性能。这正是我们下一章要讲的内容——如何在系统开始失败或运行速度比平时慢时，使系统能够容错并避免影响所有应用程序。
