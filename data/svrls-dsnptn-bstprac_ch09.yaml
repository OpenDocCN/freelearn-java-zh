- en: Deployment and CI/CD Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和 CI/CD 模式
- en: One of the big advantages of serverless architectures is the ease, speed, and
    agility with which you can develop and deploy your application. While the various
    serverless frameworks out there give you tools to manage your application's lifecycle,
    there are still many questions to answer when it comes to managing deployments
    and environments. Additionally, the question of unit tests is sometimes more difficult
    to answer since serverless architectures often use managed services such as databases,
    queues, and the like.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构的一个主要优势是开发、部署应用程序的简便性、速度和敏捷性。虽然现有的各种无服务器框架为你提供了管理应用程序生命周期的工具，但在管理部署和环境方面仍然有许多问题需要回答。此外，单元测试的问题有时也难以回答，因为无服务器架构通常使用数据库、队列等托管服务。
- en: In this chapter, you will learn deployment tooling, techniques, and considerations.
    We will also discuss **continuous integration** (**CI**) and **continuous delivery**
    (**CD**) systems and how they hook into unit testing and automated deployments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习部署工具、技术和考虑因素。我们还将讨论**持续集成**（**CI**）和**持续交付**（**CD**）系统以及它们如何与单元测试和自动化部署挂钩。
- en: 'By the end of this chapter, you will have learned the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学习以下内容：
- en: Deployment options and techniques for serverless applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器应用程序的部署选项和技术
- en: The landscape of CI/CD systems and how they work with serverless applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD 系统的格局以及它们如何与无服务器应用程序协同工作
- en: General best practices in setting up serverless application code for unit testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置无服务器应用程序代码进行单元测试的一般最佳实践
- en: How to set up unit tests for a serverless Python REST application using Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Docker 为无服务器 Python REST 应用程序设置单元测试
- en: How to set up CI with CircleCI to run unit tests and report test coverage on
    each commit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 CircleCI 设置 CI 来运行单元测试并在每次提交时报告测试覆盖率
- en: How to set up CI with CircleCI to deploy our production application for every
    commit to the `production` branch when tests pass
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 CircleCI 设置 CI，以便在测试通过时将我们的生产应用程序部署到 `production` 分支的每次提交
- en: Introduction to CI/CD
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD 简介
- en: CI and CD are often grouped in discussions around software development life
    cycles or software engineering best practices. However, CI and CD are distinct
    concepts with their own sets of best practices, challenges, and goals. This section
    will not attempt to cover the broad subject of CI and CD, but it is essential
    to talk about a few concepts and ideas to have a discussion that applies to serverless
    architectures and systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CI 和 CD 经常在软件开发生命周期或软件工程最佳实践的讨论中被归为一类。然而，CI 和 CD 是两个不同的概念，它们各自有一套最佳实践、挑战和目标。本节不会试图涵盖
    CI 和 CD 的广泛主题，但讨论一些概念和想法对于应用在无服务器架构和系统中进行讨论是至关重要的。
- en: Most of these ideas were born out of the Agile and **Extreme Programming** (**XP**)
    communities. While these are not hard rules that every team needs to follow, they
    do come from groups of people who were looking to solve real-world problems. Adopting
    these practices can help any team and any project, whether the project is serverless
    or not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些想法都源于敏捷和**极限编程**（**XP**）社区。虽然这些并不是每个团队都必须遵循的硬性规则，但它们确实来自那些寻求解决现实世界问题的群体。采用这些实践可以帮助任何团队和任何项目，无论项目是否为无服务器。
- en: CI
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI
- en: 'CI is the process of merging code changes into a mainline branch (for example,
    often a `master` branch if using Git) early and often. Before a merge from a development
    branch to a master branch, some preconditions should be met:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是将代码更改合并到主线分支（例如，如果使用 Git，通常是 `master` 分支）的早期和频繁的过程。在从开发分支合并到主分支之前，应满足一些先决条件：
- en: Unit tests must be run and pass
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试必须运行并通过
- en: New tests must cover the newly added code
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新测试必须覆盖新添加的代码
- en: Another team member must do a code review or be the result of a pair programming
    session
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一位团队成员必须进行代码审查或成为结对编程会话的结果
- en: In a serverless system, there aren't many special considerations when talking
    about CI. Pair programming, unit testing, and test coverage are ideas that are
    not unique to any particular architecture. However, there are a few tricks to
    setting up serverless application code that make testing easier and even fun.
    I'll discuss some specific scenarios and tips in the *Setting up unit tests* section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器系统中，讨论 CI 时没有太多特殊考虑。结对编程、单元测试和测试覆盖率是并非特定于任何特定架构的想法。然而，有一些设置无服务器应用程序代码的技巧可以使测试更容易甚至更有趣。我将在“设置单元测试”部分讨论一些具体的场景和技巧。
- en: CD
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CD
- en: While CI is usually easily understood, I feel that CD is often conflated with
    continuous deployment. Traditional CD is the process of building, testing and
    releasing software rapidly. Since *testing* is wrapped up in this definition,
    there is, of course, a natural relationship with CI. I view CD more on the spectrum
    of setting up automated systems so that the process of fixing a bug and deploying
    that fix safely and reliably to production is as fast and easy to hand off as
    possible.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CI（持续集成）通常容易理解，但我感觉CD（持续交付）经常与持续部署混淆。传统的CD是快速构建、测试和发布软件的过程。由于*测试*包含在这个定义中，因此它与CI（持续集成）当然存在自然关系。我认为CD更多地体现在设置自动化系统上，以便修复错误并将修复安全可靠地部署到生产环境的过程尽可能快、尽可能容易。
- en: Continuous deployment is a particular feature wrapped up within CD, that is,
    every merge to the production branch results in a deployment to the production
    system. A good CD pipeline enables continuous deployments, but it's up to the
    team behind the software whether or not to enable or use continuous deployment.
    More specifically, continuous deployment requires CD, but just because a good
    CD system is in place does not mean that the team is utilizing continuous deployment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署是CD（持续交付）中封装的一个特定功能，即每次将代码合并到生产分支时，都会导致对生产系统的部署。一个好的CD管道可以启用持续部署，但软件背后的团队是否启用或使用持续部署则取决于他们。
- en: 'A good CD system may look like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的CD系统可能如下所示：
- en: Teammates pair program to implement a feature on a branch named `feature/xyx`
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队成员结对编程，在名为`feature/xyx`的分支上实现一个功能
- en: The code is checked in, and CI system runs unit tests and code coverage
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码被提交，CI系统运行单元测试和代码覆盖率
- en: The team is notified of test results and given code coverage results
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队会收到测试结果通知，并获得代码覆盖率结果
- en: Team merges `feature/xyz` branch to `master` branch
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队将`feature/xyz`分支合并到`master`分支
- en: Tests are rerun on the `master` branch
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`master`分支上重新运行测试
- en: The team is informed of test results on the `master` branch
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队会收到`master`分支上的测试结果
- en: '`master` branch code is automatically deployed to production'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`master`分支的代码会自动部署到生产环境'
- en: Again, it's up to the team whether the final step of automatic deployment occurs
    or not. However, the entire CD pipeline should be set up so that it's *possible*.
    When you set up a CD pipeline to *enable* continuous deployments, you'll have
    solved most of the hard problems, which makes your software development life cycle
    that much faster and more efficient.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，是否执行自动部署的最后一步取决于团队。然而，整个CD管道应该设置得使其*可能*进行。当你设置一个CD管道来*启用*持续部署时，你就解决了大多数难题，这使得你的软件开发生命周期更快、更高效。
- en: Like CI, serverless systems look mostly the same as traditional software systems
    when it comes to CD. One nice thing here is that the serverless frameworks give
    us tooling to perform deployments. In non-serverless systems, deployment scripts
    are often left as exercises for teams to undertake using a myriad of tooling,
    the choices of which are vast and not always obvious. In the serverless landscape,
    deployment options are usually limited by your framework of choice.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就CD（持续交付）而言，与传统的软件系统相比，无服务器系统看起来大致相同。这里的一个优点是，无服务器框架为我们提供了执行部署的工具。在非无服务器系统中，部署脚本通常被留给团队去使用各种工具执行，这些工具的选择众多且不一定明显。在无服务器领域，部署选项通常受你选择的框架限制。
- en: Setting up unit tests
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置单元测试
- en: As I mentioned in the prior section, there are a few tricks and tips in setting
    up unit tests with a serverless system. The most important thing you can do is
    completely isolate your application code from the fact that it is running in a
    serverless context or within a given cloud provider. This strategy will lend other
    significant benefits other than making our tests easier to run, and I'll discuss
    those advantages in the course of this discussion on testing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在前一个部分提到的，在设置无服务器系统中的单元测试有一些技巧和提示。你可以做的最重要的事情是完全隔离你的应用程序代码，使其不受它运行在无服务器环境或特定云提供商中的事实的影响。这种策略除了使我们的测试更容易运行外，还会带来其他显著的好处，我将在本讨论中讨论这些优势。
- en: Code organization
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织
- en: 'What does our code layout look like when we attempt to isolate application
    code from cloud provider-specific code? Let''s take a look at the following diagram
    that shows the high-level structure of our REST or GraphQL API from [Chapter 2](svrls-dsnptn-bstprac_ch02.html),
    *A* *Three-Tier Web Application Using REST*, and [Chapter 3](svrls-dsnptn-bstprac_ch03.html),
    *A Three-Tier Web Application Pattern with GraphQL*, respectively:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将应用程序代码与云服务提供商特定代码隔离时，我们的代码布局是什么样的？让我们看看以下图，它展示了我们 REST 或 GraphQL API 的高级结构，分别来自
    [第 2 章](svrls-dsnptn-bstprac_ch02.html)，“使用 REST 的三层 Web 应用程序”，和 [第 3 章](svrls-dsnptn-bstprac_ch03.html)，“具有
    GraphQL 的三层 Web 应用程序模式”。
- en: '![](img/75276d11-2217-4e86-9dcc-9b148456d914.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75276d11-2217-4e86-9dcc-9b148456d914.jpg)'
- en: Our example application was authored in Python, but this diagram shows how this
    general code organization can work for Node, Python, or any other language. In
    addition to being language-agnostic, this should be both framework- and cloud
    provider-agnostic. The primary goal of this layout is to isolate your application
    code from any vendor, framework, or other third-party systems.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序是用 Python 编写的，但这个图展示了这种通用的代码组织如何适用于 Node、Python 或任何其他语言。除了语言无关性，这还应该是框架和云服务提供商无关的。这种布局的主要目标是使你的应用程序代码与任何供应商、框架或其他第三方系统隔离。
- en: 'The main ideas behind this code organization are the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码组织背后的主要思想如下：
- en: The primary handler or entry point that is invoked by the cloud provider contains
    any cloud-specific code and bootstraps the rest of the code (for instance, managing
    paths if necessary).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由云服务提供商调用的主要处理程序或入口点包含任何云特定代码，并引导其余代码（例如，如果需要，管理路径）。
- en: Any additional libraries are wrapped up alongside the handler file.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何额外的库都与处理程序文件一起打包。
- en: Tests are isolated in a `tests` directory. Only testing-related code goes in
    here, including mocks or factories.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试被隔离在 `tests` 目录中。只有与测试相关的代码放在这里，包括模拟或工厂。
- en: All application logic is namespaced within a separate directory (`cupping`,
    in this example).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有应用程序逻辑都在一个单独的目录（在这个例子中是 `cupping`）中命名空间化。
- en: 'With this setup, there are several advantages and no obvious disadvantages:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，有几个优点，没有明显的缺点：
- en: If you ever decide to change cloud providers, no application code changes are
    necessary. The only changes needed would be in the `handler` file.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你决定更改云服务提供商，不需要更改任何应用程序代码。唯一需要更改的是 `handler` 文件。
- en: Tests are wholly isolated from application code and are not deployed with application
    code.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试完全与应用程序代码隔离，并且不会与应用程序代码一起部署。
- en: The structure is very trim and easy to navigate and understand for other developers.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种结构非常简洁，易于其他开发者导航和理解。
- en: If any path manipulation is needed to find packages (as is the case with Python)
    you only need to add a single directory to the runtime path.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要任何路径操作来查找包（例如 Python 的情况），你只需要将一个目录添加到运行时路径中。
- en: It is trivial to point any test runner at the single `tests` directory to run
    unit tests.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任何测试运行器指向单个 `tests` 目录以运行单元测试是极其简单的。
- en: Anyone writing serverless functions with Node shouldn't need to deal with system
    paths explicitly, as is necessary for Python. Node.js will automatically resolve
    `node_modules` as you'd expect. Some of these tips are therefore applicable only
    to Python developers or those using other supported languages that don't resolve
    libraries via convention.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 编写无服务器函数的人不需要显式处理系统路径，这与 Python 所需的情况不同。Node.js 会自动解析 `node_modules`，正如你所期望的那样。因此，这些技巧仅适用于
    Python 开发者或使用其他受支持语言的人，这些语言不通过惯例解析库。
- en: Setting up unit tests
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置单元测试
- en: 'With `py.test`, a single file named `conftest.py` controls testing setup and
    configuration. If you can remember back to our discussion on setting up the runtime
    in `handler.py`, we had a few lines of code that added `lib` to our system path,
    which is shown in the following code. The next code block is taken directly from
    our `handler.py` function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `py.test`，一个名为 `conftest.py` 的单个文件控制测试设置和配置。如果你还记得我们之前在 `handler.py` 中设置运行时的讨论，我们有一些代码行将
    `lib` 添加到我们的系统路径中，如下所示。下一个代码块直接来自我们的 `handler.py` 函数：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we run our tests using `py.test`, the main entry point will be our test
    code rather than `handler.py`. As such, any bootstrapping of our code needs to
    take place in a different location since `handler.py` will not always be imported
    before every test. In a testing context, `conftest.py` is the new entry point
    where any system bootstrapping and configuration will occur. In addition to managing
    our system path, which will now be relative to the `tests/` directory, our `conftest.py`
    file will also be responsible for setting up environment variables that were previously
    managed by our serverless framework stack. The following code from `conftest.py` shows
    the path manipulation and environment variable setup so that our tests can import
    application code and execute successfully during a test run:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `py.test` 运行测试时，主要入口点将是我们的测试代码而不是 `handler.py`。因此，我们的代码的任何引导都需要在不同的位置进行，因为
    `handler.py` 并非在每次测试之前都会被导入。在测试环境中，`conftest.py` 是新的入口点，其中将发生任何系统引导和配置。除了管理现在相对于
    `tests/` 目录的相对系统路径外，我们的 `conftest.py` 文件还将负责设置之前由我们的无服务器框架堆栈管理的环境变量。以下来自 `conftest.py`
    的代码显示了路径操作和环境变量设置，以便我们的测试可以在测试运行期间导入应用程序代码并成功执行：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our test code will need to import two different types of code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试代码需要导入两种不同类型的代码：
- en: Our application code
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序代码
- en: Third-party packages
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方包
- en: With this being the case, we need to add two directories to our system path.
    The first path we add to the system path (`code_dir`) corresponds to the location
    of our application code. The second path we add to the system path (`lib_dir`)
    corresponds to the directory for third-party libraries. In the previous code block,
    you can view how that path manipulation is being handled manually.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要向我们的系统路径中添加两个目录。我们添加到系统路径中的第一个路径（`code_dir`）对应于我们的应用程序代码的位置。我们添加到系统路径中的第二个路径（`lib_dir`）对应于第三方库的目录。在先前的代码块中，您可以查看如何手动处理路径操作。
- en: Next, we'll need to manage environment variables. In this project, there aren't
    many to contend with. All of the above environment variables deal with our PostgreSQL
    database, which happens to be running as a linked Docker container. You'll notice
    in the final `if` statement there is a check for an environment variable named
    `CIRCLECI`. If that is present, this setup code will change the host variable
    for our PostgreSQL database. I'll review this in more detail in the following
    section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要管理环境变量。在这个项目中，要处理的环境变量并不多。上述所有环境变量都涉及我们的 PostgreSQL 数据库，它恰好作为一个链接的 Docker
    容器运行。您会在最后的 `if` 语句中注意到有一个检查名为 `CIRCLECI` 的环境变量。如果存在，此设置代码将更改我们的 PostgreSQL 数据库的主机变量。我将在下一节中更详细地审查这一点。
- en: Setting up CI with CircleCI
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CircleCI 设置 CI
- en: There is a reasonably extensive landscape when it comes to hosted CI systems.
    If you add in self-hosted systems, the list grows even longer. Tools such as Jenkins
    have been around for many years, initially as self-hosted systems. Inevitably,
    hosted versions of tools such as Jenkins have emerged from various companies.
    In this section, we'll walk through the steps of setting up CircleCI ([https://circleci.com](https://circleci.com))
    to run our unit tests and produce a code coverage report on every code commit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管 CI 系统方面，有一个相当广泛的领域。如果您再加上自托管系统，列表会更长。像 Jenkins 这样的工具已经存在很多年了，最初是作为自托管系统。不可避免地，来自不同公司的
    Jenkins 等工具的托管版本已经出现。在本节中，我们将逐步介绍设置 CircleCI ([https://circleci.com](https://circleci.com))
    的步骤，以便在每次代码提交时运行我们的单元测试并生成代码覆盖率报告。
- en: Since this is a book about serverless patterns, I'll encourage you to pick whatever
    tool works for your purposes with a very strong lean towards hosted CI/CD system.
    Using a hosted CI/CD systems means that you can focus more on your application
    code rather than the CI/CD system, which is just a tool we need to get our jobs
    done.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于无服务器模式的书籍，我将鼓励您选择任何适合您目的的工具，并且强烈倾向于使用托管 CI/CD 系统。使用托管 CI/CD 系统意味着您可以更多地关注您的应用程序代码，而不是
    CI/CD 系统，这只是我们完成工作所需的一个工具。
- en: Setting up a brand new project with CircleCI is quite simple, and it has easy
    integration with both GitHub and Bitbucket. The first thing you'll need to do
    to set up a new project is log in with one of those two services. From there,
    you can go to the Projects item in the left-hand-side navigation menu and click
    on the Add Project button in the upper-right of the screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CircleCI 上设置一个全新的项目非常简单，并且与 GitHub 和 Bitbucket 都有易于集成的功能。设置新项目的第一步是使用其中之一的服务登录。从那里，你可以点击左侧导航菜单中的“项目”项，然后在屏幕右上角点击“添加项目”按钮。
- en: 'The following screenshot shows this navigation; however, I''ve already set
    up this example project, which is the reason it shows up in the list:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此导航；然而，我已经设置了此示例项目，这是它出现在列表中的原因：
- en: '![](img/0057c99a-d861-4a6e-9bf9-3bc67bb4e37d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/0057c99a-d861-4a6e-9bf9-3bc67bb4e37d.png)'
- en: You can see that I also have my blog set up in CircleCI. CI can be used for
    any repository where you'd like to perform some automated set of steps when code
    is committed, or branches are merged. In the case of my blog, a script will deploy
    any new posts or changes out once they are checked in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我还在 CircleCI 上设置了我的博客。CI 可以用于任何你希望在代码提交或分支合并时执行一些自动化步骤的仓库。在我的博客案例中，一旦检查入，一个脚本就会部署任何新的帖子或更改。
- en: Configuring CircleCI builds
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 CircleCI 构建
- en: There is a plethora of options and controls that you can configure within CircleCI.
    There are only a few settings we'll need to control from within the CircleCI web
    interface. Everything else will be controlled via a `config.yml` configuration
    file, which we will add to the repository.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CircleCI 中，你可以配置大量选项和控制。我们只需要在 CircleCI 网页界面中控制几个设置。其他所有内容将通过 `config.yml`
    配置文件进行控制，我们将将其添加到仓库中。
- en: 'Our first step is putting together a `.circleci/config.yml` file. The `.circleci/`
    directory lives in the root of our repository. The following code block shows
    the configuration to run unit tests in for our REST API, which is located in the
    `ch2/` directory of the repository:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建一个 `.circleci/config.yml` 文件。`.circleci/` 目录位于我们仓库的根目录下。以下代码块展示了在仓库的
    `ch2/` 目录中运行单元测试的配置，该目录包含我们的 REST API：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is some extra work involved in this setup since our application code lives
    in the `ch2/` directory but commands always start from the root directory. In
    a regular repository where the code isn't contained in a subdirectory, dealing
    with the `working_directory` would be unnecessary.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序代码位于 `ch2/` 目录中，但命令总是从根目录开始，因此在这个设置中涉及一些额外的工作。在一个常规仓库中，代码不包含在子目录中，处理
    `working_directory` 就是不必要的。
- en: CircleCI 2.0 uses Docker containers for their builds. What this means for us
    is that it's quite easy to pull in any additional resources our application code
    may need to run tests. In this case, we'll pull in the official `postgres` Docker
    image. Another benefit of this is that I use a Docker container for building libraries,
    running tests, and doing deployments. Since all of this functionality is possible
    using the `verypossible/serverless` images, which I built, we can just use the
    same image to run these tests and do deployments as we did during development.
    The first image listed under the `docker` key previously will be the primary container
    where the code will be checked out, and any commands will run.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI 2.0 使用 Docker 容器进行构建。这意味着对我们来说，很容易引入应用程序代码运行测试可能需要的任何额外资源。在这种情况下，我们将引入官方的
    `postgres` Docker 镜像。这个好处是，我使用 Docker 容器来构建库、运行测试和进行部署。由于所有这些功能都可以使用我构建的 `verypossible/serverless`
    镜像实现，因此我们可以使用相同的镜像来运行这些测试和进行部署，就像我们在开发期间做的那样。在 `docker` 键下列出的第一个镜像将是主要的容器，代码将从中检出，任何命令都将在此容器中运行。
- en: 'The Docker image and Makefile that I''m using here are set up to use a variable
    named `ENV`. I''ll set the `ENV` variable in this configuration file. After the
    environment section begins, a list of steps that run in sequence and make up the
    actual test run. The steps to set up and run the tests consist of:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用的 Docker 镜像和 Makefile 设置为使用名为 `ENV` 的变量。我将在配置文件中设置 `ENV` 变量。在环境部分开始之后，将按顺序运行一系列步骤，这些步骤构成了实际的测试运行。设置和运行测试的步骤包括：
- en: Check out code
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出代码
- en: Restore cache, so that the supporting packages are only downloaded when there
    is a change
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复缓存，以便仅在发生更改时下载支持包
- en: Install supporting packages, in case they are not cached
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装支持包，以防它们未被缓存
- en: Save cache
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存缓存
- en: Run unit tests with the `make tests` command
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `make tests` 命令运行单元测试
- en: Store test coverage results, so they are viewable on CircleCI
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储测试覆盖率结果，以便在 CircleCI 上可查看
- en: A few different commands deal with saving and restoring the cache. These cache
    controls are specific to CircleCI, and I encourage you to read about it in detail
    in the CircleCI docs. At a high level, these steps are saving some CPU cycles
    by caching any installed libraries from previous runs rather than doing package
    downloads and installs for every test run.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 几个不同的命令处理保存和恢复缓存。这些缓存控制是 CircleCI 特有的，我鼓励您在 CircleCI 文档中详细了解。从高层次来看，这些步骤通过缓存之前运行中安装的任何库来节省一些
    CPU 周期，而不是在每次测试运行时都进行包下载和安装。
- en: There are two `run` directives, which perform the bulk of the work. Both `Install
    Python requirements` and `py.test` steps use `make` targets to do their work.
    We've already set up the actual logic of what those commands do, which you can
    review by inspecting the Makefile. Neither of these commands is incredibly complex
    (installing packages and running test). Since we've already done this work of
    wrapping up the details in the Makefile, we can take advantage of these and other make
    shortcuts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 `run` 指令，它们执行了大部分工作。`安装 Python 依赖项` 和 `py.test` 步骤都使用 `make` 目标来完成工作。我们已经设置了这些命令的实际逻辑，您可以通过检查
    Makefile 来查看。这两个命令都不算特别复杂（安装包和运行测试）。由于我们已经完成了将细节封装在 Makefile 中的工作，我们可以利用这些和其他
    make 快捷方式。
- en: Finally, after tests are run, I'll set up CircleCI to upload the test coverage
    output files to the build's artifacts. Build artifacts are another CircleCI-specific
    task, although I know other CI systems have something similar. After the HTML
    coverage output is uploaded as a CircleCI artifact, we'll be able to view the
    results via the CircleCI website.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在运行测试之后，我将设置 CircleCI 以将测试覆盖率输出文件上传到构建的工件中。构建工件是 CircleCI 特定的任务，尽管我知道其他 CI
    系统也有类似的功能。在将 HTML 覆盖率输出作为 CircleCI 工件上传后，我们就能通过 CircleCI 网站查看结果。
- en: 'The following screenshot shows all of the `coverage` output files listed in
    the Artifacts tab for each build:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了每个构建的工件选项卡中列出的所有 `coverage` 输出文件：
- en: '![](img/eab05a9e-798f-4192-8f0b-017118c53857.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eab05a9e-798f-4192-8f0b-017118c53857.png)'
- en: 'Since the coverage report is created in HTML format, I can click on the `index.html`
    file to see the complete test results. The following screenshot shows the test
    coverage report after I clicked on `index.html`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于覆盖率报告是以 HTML 格式创建的，我可以点击 `index.html` 文件来查看完整的测试结果。以下截图显示了点击 `index.html`
    后的测试覆盖率报告：
- en: '![](img/8154614d-fd83-4ea8-8bab-725da7dd3c71.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8154614d-fd83-4ea8-8bab-725da7dd3c71.png)'
- en: Setting up environment variables
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: Earlier in this chapter, you'll remember that there were some environment variables
    that we needed to take care of in our tests. Additionally, there was a small switch
    in our `conftest.py` file that set the PostgreSQL host based on the presence of
    a particular environment variable. CircleCI is kind enough to inject a couple
    of environment variables during a build, one of which is named `CIRCLECI`. Using
    this variable, we'll update the database host during test runs, which happens
    to be `localhost`. When we're testing our code locally with Docker containers
    that we manage, the hostname will be that of our linked PostgreSQL container.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，您可能会记得我们需要在我们的测试中处理一些环境变量。此外，我们的 `conftest.py` 文件中有一个小开关，根据特定环境变量的存在来设置
    PostgreSQL 主机。CircleCI 很好地注入了几个环境变量，其中一个名为 `CIRCLECI`。使用这个变量，我们将在测试运行期间更新数据库主机，它恰好是
    `localhost`。当我们使用我们管理的 Docker 容器本地测试我们的代码时，主机名将是链接的 PostgreSQL 容器的名称。
- en: In addition to handling specific environment variables differently when running
    within a CircleCI build, we'll also need to manage any sensitive variables in
    preparation for deployments. Because those variables relate to the deployment
    of our stack, I'll cover this in the next section about continuous deployment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 CircleCI 构建中运行时对特定环境变量进行不同的处理外，我们还需要管理任何敏感变量，以备部署之需。因为这些变量与我们的堆栈部署相关，我将在下一节关于持续部署的部分中介绍这一点。
- en: Setting up CD and deployments with CircleCI
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CircleCI 设置 CD 和部署
- en: 'As I mentioned in the introductory section of this chapter, the **D** in **CD**
    stands for **Delivery**. In this section, we''ll walk through the details of setting
    up both delivery and deployment of our application via CircleCI. I will admit,
    the boundaries here between delivery and deployment are a bit blurred, and any
    such discussions can become difficult due to disagreements in terminology and
    details. For our purposes, our CD pipeline will focus on the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在本章引言部分所述，**CD**中的**D**代表**Delivery**。在本节中，我们将详细介绍通过CircleCI设置应用程序的交付和部署的细节。我必须承认，这里的交付和部署之间的界限有些模糊，并且由于术语和细节上的分歧，此类讨论可能会变得困难。就我们的目的而言，我们的CD管道将专注于以下方面：
- en: Visibility
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性
- en: Feedback
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反馈
- en: Ease of automated deployments
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动部署的便捷性
- en: For visibility and feedback, we'll use Slack and GitHub badges. Our existing
    deployment script from the Makefile and the serverless framework will be hooked
    into CircleCI to make production deployments fast, simple, and reliable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可见性和反馈，我们将使用Slack和GitHub徽章。我们现有的从Makefile和serverless框架部署的脚本将被集成到CircleCI中，以使生产部署快速、简单且可靠。
- en: Setting up Slack notifications
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Slack通知
- en: CircleCI has several integrations with various chat systems. Setting up test
    results to be posted to Slack (or your messaging platform of choice) is a straightforward
    and effective way to disseminate test results among team members.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI与各种聊天系统有多个集成。设置测试结果发布到Slack（或你选择的任何消息平台）是向团队成员传播测试结果的一种简单而有效的方法。
- en: In CircleCI, navigate to the Chat Notifications menu item and click on the link
    in the Slack section. From there, you'll be guided through the setup process for
    you Slack group. Ultimately, you'll get a webhook URL from Slack, which you will
    need to enter into CircleCI. Notification will be sent to this Slack webhook,
    which will post to a particular channel.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在CircleCI中，导航到“聊天通知”菜单项，点击Slack部分中的链接。从那里，你将完成Slack群组的设置过程。最终，你将获得一个Slack webhook
    URL，你需要将其输入到CircleCI中。通知将被发送到这个Slack webhook，它将发布到特定的频道。
- en: 'The following screenshot shows project settings for this repository within
    CircleCI and the page where you configure chat notifications:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了CircleCI中此存储库的项目设置以及配置聊天通知的页面：
- en: '![](img/262832fb-0e9d-4766-b5d3-0adaf9198a2c.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/262832fb-0e9d-4766-b5d3-0adaf9198a2c.png)'
- en: 'After tests run, you''ll see the results show up in Slack. The following two
    screenshots show success and failure messages in Slack, delivered by CircleCI:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行后，你会在Slack中看到结果。以下两个截图显示了CircleCI通过Slack发送的成功和失败消息：
- en: '![](img/b709706f-41fc-42c2-bb75-d7ca6c9f2775.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b709706f-41fc-42c2-bb75-d7ca6c9f2775.png)'
- en: 'If tests fail, the message will look slightly different. The following shows
    the message when tests fail from another project I work on:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，消息将略有不同。以下是从我工作的另一个项目中测试失败时的消息：
- en: '![](img/35568fe0-e410-4012-9f02-46f70e7a96a3.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35568fe0-e410-4012-9f02-46f70e7a96a3.png)'
- en: Setting up a CircleCI badge
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置CircleCI徽章
- en: Current test results can also be displayed in markdown files. This badge is
    especially useful in GitHub or Bitbucket `README` files. In the Notifications | Status
    Badges section of CircleCI, you can find a markdown (or another format) snippet,
    which you can copy and put into your `README.md` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当前测试结果也可以在Markdown文件中显示。这个徽章在GitHub或Bitbucket的`README`文件中特别有用。在CircleCI的“通知
    | 状态徽章”部分，你可以找到一个Markdown（或另一种格式）片段，你可以将其复制并放入你的`README.md`文件中。
- en: 'After putting that CircleCI-generated markdown snippet into the `README.md`
    file, GitHub will display the current status of the last build, as shown in the
    following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将CircleCI生成的Markdown片段放入`README.md`文件后，GitHub将显示最后一次构建的当前状态，如下截图所示：
- en: '![](img/8d1d3232-708f-464d-aa4b-933d86aba3fd.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d1d3232-708f-464d-aa4b-933d86aba3fd.png)'
- en: Setting up deployments
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置部署
- en: We now have our tests running automatically, as well as notifications about
    test results being pushed to Slack. Now, we can work on getting CircleCI to deploy
    our code to AWS for us automatically. I'll be working through the steps to enable
    automated deployments. You may not want to do automated deployments for each of
    your projects. However, you should work toward being *able* to perform continuous
    deployments. Even if you choose not to release production code like this, working
    toward continuous deployment as an end goal means that you will have automated
    the majority of your build pipeline.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的测试正在自动运行，以及关于测试结果的通知被推送到Slack。现在，我们可以着手让CircleCI自动将我们的代码部署到AWS。我将逐步完成启用自动化部署的步骤。你可能不希望为你的每个项目都进行自动化部署。然而，你应该朝着能够执行持续部署的目标努力。即使你选择不发布像这样的生产代码，将持续部署作为最终目标意味着你将自动化大部分的构建管道。
- en: Setting up AWS credentials
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置AWS凭证
- en: Using AWS credentials is such a common task that CircleCI has a special section
    for it in each project's configuration. If you navigate to Permissions | AWS Permissions,
    you'll find two fields for your AWS Access Key ID and AWS Secret Key. Setting
    these here ensures you'll never need to check them into source control and that
    any AWS libraries you use (noted in the following screenshot) will automatically
    pick up the values as environment variables.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS凭证是一项如此常见的任务，以至于CircleCI在每个项目的配置中都有一个专门的区域。如果你导航到权限 | AWS权限，你会找到两个字段用于你的AWS访问密钥ID和AWS秘密密钥。在这里设置这些确保你永远不需要将它们检查到源控制中，并且你使用的任何AWS库（如以下屏幕截图所示）将自动获取这些值作为环境变量。
- en: 'Setting these credentials in this section works as we would expect for the
    Serverless framework, allowing any `serverless` command to execute successfully
    provided the keys we attach have the correct IAM permissions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中设置这些凭证与无服务器框架的预期行为一致，允许任何`serverless`命令在附加的密钥具有正确的IAM权限的情况下成功执行：
- en: '![](img/d1869cea-290d-4273-9489-a167700fe922.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d1869cea-290d-4273-9489-a167700fe922.png)'
- en: Setting up environment variables
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: Some of the non-critical variables, such as the test database host and username,
    are easy to deal with in code or configuration files that are tracked in version
    control (such as `.circleci/config.yml`). When we turn our attention to deployments,
    however, there are inevitably variables that you would prefer to keep secret and
    never check into version control.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些非关键变量，例如测试数据库的主机和用户名，在代码或配置文件中处理起来很容易，这些文件被版本控制跟踪（如`.circleci/config.yml`）。然而，当我们转向部署时，不可避免地会有一些你希望保持秘密且永远不会提交到版本控制的变量。
- en: 'In cases like this, we can add variables via CircleCI from the Build Settings | Environment
    Variables section. In the following screenshot, you can see how I''m setting the
    database password for the PostgreSQL RDS instance:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过CircleCI的构建设置 | 环境变量部分添加变量。在下面的屏幕截图中，你可以看到我是如何设置PostgreSQL RDS实例的数据库密码的：
- en: '![](img/2afea326-5e1a-4e3c-89a3-406667f82e8a.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/2afea326-5e1a-4e3c-89a3-406667f82e8a.png)'
- en: 'As a quick review of how this entire system works, variables from the environment
    are picked up by the Serverless framework. In the case of some of the RDS variables,
    we inject the values into our Lambda functions via serverless and use the variables
    when creating and setting up an RDS instance. The related snippets of `serverless.yml`
    are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这个整个系统如何工作的快速回顾，环境变量由无服务器框架拾取。在RDS的一些变量情况下，我们通过无服务器将值注入到我们的Lambda函数中，并在创建和设置RDS实例时使用这些变量。相关的`serverless.yml`片段如下：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Any value we set in CircleCI for the `CUPPING_DB_PASSWORD` will be available
    during any `serverless` commands we execute from within CircleCI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在CircleCI中为`CUPPING_DB_PASSWORD`设置的任何值，在执行CircleCI内的任何`serverless`命令时都将可用。
- en: Executing deployments
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行部署
- en: With all of the setup out of the way, we can update our CircleCI configuration
    to deploy code on our behalf. During the CI tasks, we utilized our various `make`
    targets to perform work that we were already doing manually. For deployments,
    we'll reuse another pre-existing `make` target that is already set up, `make deploy`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有设置后，我们可以更新我们的CircleCI配置以代表我们部署代码。在CI任务期间，我们利用了各种`make`目标来执行我们已经在手动执行的工作。对于部署，我们将重用另一个已经设置好的预存在的`make`目标，即`make
    deploy`。
- en: Under the `jobs` key, we'll add another step named `deploy`, which comes after
    our build step. This new deploy job has the same configuration options available
    as the previous build step. Our goal in this deploy step is actually to perform
    the deployment out to our production environment. For that to work, there are
    different configuration options that we'll need to set up, the details of which
    you can see in the following YAML snippet from `.circleci/config.yml`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jobs`键下，我们将添加另一个名为`deploy`的步骤，它位于我们的构建步骤之后。这个新的部署作业具有与之前的构建步骤相同的配置选项。我们在这个部署步骤中的目标是实际上在我们的生产环境中执行部署。为了使其工作，我们需要设置不同的配置选项，其详细信息您可以在以下来自`.circleci/config.yml`的YAML片段中看到。
- en: With CircleCI, each section under the jobs keys is a standalone body of work,
    which you may define and configure on its own. These steps can work together or
    in parallel, as we'll see shortly. In this case, we already have a `build/test`
    section, and we're now adding a `deploy` section. These two jobs will work together,
    so our code is deployed only after tests are run and pass.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在CircleCI中，每个`jobs`键下的部分都是一个独立的工作体，您可以单独定义和配置它。这些步骤可以一起工作或并行工作，正如我们很快就会看到的。在这种情况下，我们已经有了一个`build/test`部分，我们现在正在添加一个`deploy`部分。这两个作业将一起工作，所以我们的代码只有在测试运行并通过后才会部署。
- en: 'We''ll be using the same Docker image to perform our deployments, which you
    can see in the image section. For our deployments to work, some environment variables
    need to exist, as I mentioned earlier in this chapter. Here, we can set up those
    variables in our configuration file. The RDS password is missing from this list
    on purpose since it will be injected into our deployment phase by CircleCI because
    we defined it from the CircleCI web application. Finally, the steps for deploying
    our Serverless project are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的Docker镜像来执行我们的部署，您可以在图片部分看到它。为了我们的部署能够工作，一些环境变量需要存在，正如我在本章前面提到的。在这里，我们可以在我们的配置文件中设置这些变量。RDS密码故意没有包含在这个列表中，因为它将由CircleCI在部署阶段注入，因为我们是在CircleCI网络应用程序中定义的。最后，部署我们的无服务器项目的步骤如下：
- en: Check out code
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出代码
- en: Run `make libs` from the `ch2` directory
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ch2`目录运行`make libs`
- en: Run `make deploy` from the `ch2` directory
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ch2`目录运行`make deploy`
- en: 'The following code block shows the `deploy` step of `.circleci/config.yml`
    as well as the workflows, that chains together tests and deployments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了`.circleci/config.yml`中的`deploy`步骤以及工作流程，它将测试和部署链接在一起：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These job keys can be named anything you like and make sense to you. I happened
    to name them `build` and `deploy`. However, I could have called them `test` and
    `deploy`, or `build-test` and `rollout`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些作业键可以命名为您喜欢的任何名称，只要对您有意义。我碰巧将它们命名为`build`和`deploy`。然而，我也可以将它们命名为`test`和`deploy`，或者`build-test`和`rollout`。
- en: With our deploy steps defined, we can instruct CircleCI to do our deployment
    under certain conditions via their workflows feature. The full capabilities of
    this feature are vast, but in our case the goal is simple; we want to do the deployment
    only when we are on the `production` branch and when tests have passed. You can
    see all of this logic in the `workflows` section in the previous configuration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了部署步骤后，我们可以通过CircleCI的工作流程功能在特定条件下执行我们的部署。这个功能的全部能力非常广泛，但在这个案例中，我们的目标很简单；我们只想在`production`分支上并且测试通过时进行部署。您可以在之前配置中的`workflows`部分看到所有这些逻辑。
- en: 'To see this in action, I performed the following steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个动作的实际效果，我执行了以下步骤：
- en: Checked in some changes to the `feature/circleci` branch
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一些更改提交到`feature/circleci`分支
- en: Created a GitHub pull request against the `production` branch
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`production`分支上创建了一个GitHub拉取请求
- en: Merged the pull request
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并了拉取请求
- en: Very often a deployment flow such as this will work off the `master` branch.
    Here, I've chosen to use a branch named `production`. This change in naming convention
    is because this book's repository may have several commits for the various chapters
    and I don't want every commit to `master` to trigger a CircleCI `build-deploy`
    workflow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见，这样的部署流程将基于`master`分支。在这里，我选择使用名为`production`的分支。这种命名约定上的变化是因为这本书的存储库可能有几个章节的提交，我不想每个提交到`master`的提交都触发CircleCI的`build-deploy`工作流程。
- en: '![](img/afbbc5ed-ffa4-4fdf-9579-e40f395c9801.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afbbc5ed-ffa4-4fdf-9579-e40f395c9801.png)'
- en: The previous screenshot shows the pull request details. With CircleCI set up,
    any pull request will show the details of the test run. Here, we can see our tests
    have successfully run. I also received a Slack notification of the successful
    tests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了拉取请求的详细信息。在设置了 CircleCI 之后，任何拉取请求都会显示测试运行的详细信息。在这里，我们可以看到我们的测试已经成功运行。我还收到了关于测试成功的
    Slack 通知。
- en: 'Once I click Merge pull request, another CircleCI build begins. In the following
    screenshot you can see that, because the `production` branch was updated, our
    `build-deploy` workflow is running:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我点击合并拉取请求，另一个 CircleCI 构建就会开始。在下面的截图里，你可以看到，由于`production`分支已被更新，我们的`build-deploy`工作流程正在运行：
- en: '![](img/0331668d-1885-43a7-87da-5239f3b1ec8d.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/0331668d-1885-43a7-87da-5239f3b1ec8d.png)'
- en: 'After the build job runs and tests pass, the deploy step will commence. We
    can see this in CircleCI with their workflows visualization, shown in the following
    screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建作业运行并通过测试后，部署步骤将开始。我们可以在 CircleCI 的工作流程可视化中看到这一点，如下面的截图所示：
- en: '![](img/a77a2113-b08a-4a9c-b4c0-3417a108fe00.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a77a2113-b08a-4a9c-b4c0-3417a108fe00.png)'
- en: 'By clicking on the deploy box, we can watch or see the details of the `deploy`
    phase:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击部署框，我们可以查看或看到部署阶段的详细信息：
- en: '![](img/013489ab-7648-4f9a-9176-2c6346df9d36.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/013489ab-7648-4f9a-9176-2c6346df9d36.png)'
- en: Success! Since our `make deploy` command works for creating a brand new stack
    or updating an existing one, there is nothing more we need to do from here on.
    Any merges or commits to our `production` branch will trigger this flow, and we
    now have continuous deployment working.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！由于我们的`make deploy`命令可以用于创建全新的栈或更新现有的栈，因此从现在开始我们不需要做更多的事情。对我们`production`分支的任何合并或提交都将触发此流程，我们现在已经实现了持续部署。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the meaning and high-level details of CI and CD.
    I also discussed some best practices on how to organize application code in serverless
    projects to help set up and run unit tests. From there, I covered how to set up
    our unit tests to run on every commit using CircleCI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 CI 和 CD 的意义和高级细节。我还讨论了一些最佳实践，关于如何在无服务器项目中组织应用程序代码，以帮助设置和运行单元测试。从那里，我介绍了如何使用
    CircleCI 来设置单元测试，使其在每次提交时运行。
- en: Finally, we worked through the entire process of setting up CircleCI to perform
    automated deployments triggered by changes to the `production` branch. You learned
    some of the nuances of controlling CI execution via environment variables and
    where to configure sensitive settings such as database passwords and AWS keys.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了设置 CircleCI 以执行由`production`分支更改触发的自动化部署的整个流程。你了解了一些通过环境变量控制 CI 执行的细微差别，以及在哪里配置敏感设置，例如数据库密码和
    AWS 密钥。
