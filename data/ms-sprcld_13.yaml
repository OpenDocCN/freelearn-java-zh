- en: Testing Java Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Java微服务
- en: While developing a new application, we should never forget about automated tests.
    These are especially important if we are thinking about microservices-based architecture.
    Testing microservices requires a different approach than the tests created for
    monolithic applications. As far as monoliths are concerned, the main focus is
    on unit testing and  integration tests, together with the database layer. In the
    case of microservices, the most important thing is to provide coverage for each
    of the communications at the finest possible granularity. Although each microservice
    is independently developed and released, a change in one of them can affect all
    of the others that are interacting with that service. The communication between
    them is realized through messages. Usually, these are messages that are sent via
    REST or AMQP protocols.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发新应用程序时，我们永远不要忘记自动化测试。如果考虑基于微服务的架构，这些尤其重要。测试微服务需要与为单体应用程序创建的测试不同的方法。就单体而言，主要关注的是单元测试和集成测试，以及数据库层。在微服务的情况下，最重要的事情是以尽可能细粒度的覆盖每个通信。尽管每个微服务都是独立开发和发布的，但其中一个服务的更改可能会影响所有与之交互的其他服务。它们之间的通信是通过消息实现的。通常，这些消息是通过REST或AMQP协议发送的。
- en: 'Topics we will cover in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将覆盖以下主题：
- en: Spring support for automated testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring对自动化测试的支持
- en: Differences between a component and integration testing for Spring Boot microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot微服务中组件测试与集成测试的区别
- en: Implementing contract tests using Pact
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pact实施合同测试
- en: Implementing contract tests using Spring Cloud Contract
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Contract实施合同测试
- en: Implementing performance tests using Gatling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gatling实施性能测试
- en: Testing strategies
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试策略
- en: 'There are five different microservices testing strategies. The first three
    of them are the same as for monolithic applications:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种不同的微服务测试策略。其中前三种与单体应用相同：
- en: '**Unit tests**: With unit tests, we test the smallest pieces of code, for example,
    a single method or component, and mock every call of other methods and components.
    There are many popular frameworks that support unit tests in Java, such as JUnit,
    TestNG, and Mockito (for mocking). The main task of this type of testing is to
    confirm that the implementation meets requirements. Unit testing can be a powerful
    tool, especially when combined with test-driven development.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试中，我们测试代码的最小单元，例如，一个单独的方法或组件，并模拟其他方法和组件的每次调用。有许多流行的Java框架支持单元测试，如JUnit、TestNG和Mockito（用于模拟）。这类测试的主要任务是确认实现符合需求。单元测试尤其是一个强大的工具，尤其是在与测试驱动开发结合使用时。'
- en: '**Integration tests**: Using only unit testing doesn''t guarantee that you
    will verify the behavior of the whole system. Integration tests take the modules
    and try to test them together. This approach gives you an opportunity to exercise
    communication paths within the subsystem. We are testing the interaction and communication
    between components based on their interfaces with external services mocked-up.
    In a microservices-based system, integration tests can be used in order to include
    other microservices, data sources, or caches.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：仅使用单元测试并不能保证您将验证整个系统的行为。集成测试取模块并尝试将它们一起测试。这种方法为您提供了在子系统中锻炼通信路径的机会。我们根据模拟的外部服务接口测试组件之间的交互和通信。在基于微服务的系统中，集成测试可以用于包括其他微服务、数据源或缓存。'
- en: '**End-to-end tests**: End-to-end tests are also known as **functional tests**.
    The main goal of these tests is to verify whether the system meets the external
    requirements. It means that we should design test scenarios that test all the
    microservices taking part in that process. The design of a good end-to-end test
    is not a trivial task. Since we need to test the whole system, it is very important
    to place a particular emphasis on the test''s scenario design.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：端到端测试也称为**功能测试**。这些测试的主要目标是验证系统是否符合外部要求。这意味着我们应该设计测试场景，以测试参与该过程的所有微服务。设计一个好的端到端测试并不是一件简单的事。由于我们需要测试整个系统，因此特别重视测试场景的设计非常重要。'
- en: '**Contract tests**: Contract tests are used to ensure that the explicit and
    implicit contract of a microservice work as expected. A contract is always formed
    when a consumer integrates with the interface of a component in order to use it.
    Usually, in microservice-based systems, there are many consumers of a single component.
    Each of them usually requires a different contract that meets its demands. Following
    these assumptions, every consumer is responsible for a source component''s interface
    behavior.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**契约测试**：契约测试用于确保微服务的显式和隐式契约如预期般工作。当消费者集成并使用组件的接口时，总是形成契约。在微服务系统中，通常有一个组件被多个消费者使用。每个消费者通常需要一个满足其需求的不同的契约。基于这些假设，每个消费者都负责源组件接口的行为。'
- en: '**Component tests**: After we have completed unit testing of all the objects
    and methods within a microservice, we should test the whole microservice in isolation.
    In order to run the tests in isolation, we need to mock or stub the calls of the
    other microservices. An external data store should be replaced with an equivalent
    in-memory data store, which also provides significant test performance improvements.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件测试**：在我们完成了微服务中所有对象和方法的单元测试之后，我们应该孤立地测试整个微服务。为了在孤立环境中运行测试，我们需要模拟或替换其他微服务的调用。外部数据存储应被等效的内存数据存储所替代，这也显著提高了测试性能。'
- en: 'The differences between contract and component tests are obvious. The following
    diagram illustrates those differences in our sample `order-service` microservice:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 契约测试与组件测试的区别是显而易见的。以下图表在我们的示例`order-service`微服务中说明了这些差异：
- en: '![](img/ce6b981a-9c68-4f29-926f-f51f4ca22502.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce6b981a-9c68-4f29-926f-f51f4ca22502.png)'
- en: Now, there is a question of whether we really need two additional strategies
    for testing a microservices-based system. Through the proper unit and integration
    tests, we may be confident in the correctness of the implementation of the individual
    components that form part of the microservice. However, without more specific
    test strategies for microservices, we cannot be sure how they work together in
    order to meet our business requirements. Therefore, component and contract tests
    have been added. This is a really important change in order to help us understand
    the differences between component, contract, and integration tests. Since component
    tests are performed in isolation from the outside world, integration tests are
    responsible for verifying interactions with that world. That's why we should provide
    stubs for an integration test in contrast with a components test. Contract tests,
    much like integration tests, emphasize interactions between microservices, but
    they treat them as a black box and verify only the format of the responses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个问题是我们是否真的需要为基于微服务的系统测试添加两个额外的策略。通过适当的单元和集成测试，我们可能对构成微服务的一部分的单个组件的实现的正确性有信心。然而，如果没有为微服务制定更具体的测试策略，我们不能确定它们如何共同工作以满足我们的业务需求。因此，增加了组件和契约测试。这是帮助我们理解组件、契约和集成测试之间差异的一个非常重要的变化。因为组件测试是在与外界隔离的情况下进行的，所以集成测试负责验证与那个世界的交互。这就是为什么我们应该为集成测试提供存根，而不是为组件测试。契约测试与集成测试类似，强调微服务之间的交互，但它们将它们视为黑盒，仅验证响应的格式。
- en: 'Once you provide functional tests for your microservices, you should also think
    about performance testing. We can distinguish the following strategies of performance
    testing:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为你的微服务提供了功能测试，你也应该考虑性能测试。我们可以区分出以下性能测试策略：
- en: '**Load tests**: These are used to determine a system''s behavior under the
    normal and anticipated load conditions. The main idea here is to identify some
    weaknesses, such as response time latencies, aberrant outages, or too many retries
    if network timeouts are not set properly.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：这些测试用于确定系统在正常和预期负载条件下的行为。这里的主要想法是识别一些弱点，例如响应时间延迟、异常中断或如果网络超时设置不正确则尝试次数过多。'
- en: '**Stress tests**: These check the upper limits of your system to examine how
    it behaves under an extremely heavy load. In addition to load testing, it also
    checks out memory leaks, security issues, and data corruption. It may be using
    the same tools as for load testing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**：这些测试检查系统的上限，以观察在极端重载下系统的表现。除了负载测试之外，它还检查内存泄漏、安全问题以及数据损坏。它可能使用与负载测试相同的工具。'
- en: 'The following diagram illustrates the logical order of performing all of the
    test strategies on your system. We are starting from the simplest unit testing,
    which verifies small pieces of software, and going through the next stages to
    finally finish with stress testing that pushes the whole system to the limit:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了在您的系统上执行所有测试策略的逻辑顺序。我们从最简单的单元测试开始，该测试验证小块软件，然后继续下一阶段，最后完成压力测试，将整个系统推向极限：
- en: '![](img/79c6864e-6185-4be3-8573-fe3fdcd8330e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79c6864e-6185-4be3-8573-fe3fdcd8330e.png)'
- en: Testing Spring Boot applications
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Spring Boot 应用程序
- en: 'As you might have read in the previous section, there are some different strategies
    and approaches to the tests in your application. I have briefly mentioned all
    of them, so now we may proceed to the practical aspects. Spring Boot provides
    a set of utilities that help in the implementation of automated tests. In order
    to enable these features in the project, you have to include the `spring-boot-starter-test`
    starter to the dependencies. It imports not only the `spring-test` and `spring-boot-test`
    artifacts, but also some other useful test libraries, such as JUnit, Mockito,
    and AssertJ:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一节可能已经读到的，您的应用程序中有不同的测试策略和方法。我简要提到了它们的所有内容，所以现在我们可以继续实践方面的问题。Spring Boot
    提供了一系列工具，有助于实现自动化测试。为了在项目中启用这些特性，您必须将 `spring-boot-starter-test` 启动器添加到依赖项中。它不仅导入了
    `spring-test` 和 `spring-boot-test` 工件，还导入了其他一些有用的测试库，如 JUnit、Mockito 和 AssertJ：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Building the sample application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建示例应用程序
- en: 'Before we start to work on automated tests, we need to prepare a sample business
    logic for testing purposes. We may use the same example system from the previous
    chapters, but it has to be modified a little. Until now, we have never used an
    external data source for storing and collecting test data. In this chapter, it
    would be helpful to do this in order to illustrate how the different strategies
    approach the issue of persistence testing. Now, each service has its own database
    although, generally, it doesn''t really matter which database is chosen. There
    is a large choice of solutions supported by Spring Boot, including both relational
    and NoSQL databases. I have decided to use Mongo. Let us remind ourselves of the
    architecture of the sample system. The current model shown in the following diagram
    takes into account the assumptions described previously regarding dedicated databases
    per service:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始自动化测试之前，我们需要为测试目的准备一个示例业务逻辑。我们可以使用前几章中的同一个示例系统，但它必须稍作修改。到目前为止，我们从未使用过外部数据源来存储和收集测试数据。在本章中，为了说明不同的策略如何处理持久性测试问题，这样做将很有帮助。现在，每个服务都有自己的数据库尽管，通常，选择哪个数据库并不重要。Spring
    Boot 支持大量解决方案，包括关系型和 NoSQL 数据库。我决定使用 Mongo。让我们回顾一下示例系统的架构。以下图表所示的当前模型考虑了关于每个服务专用数据库的先前描述的假设：
- en: '![](img/2b538768-b0e9-4e90-bc9e-df506778371a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b538768-b0e9-4e90-bc9e-df506778371a.png)'
- en: Integration with the database
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库集成
- en: 'In order to enable Mongo support for our Spring Boot application, include the
    `spring-boot-starter-data-mongo` starter to the dependencies. This project provides
    some interesting features to simplify integration with MongoDB. Among these features,
    it is worth mentioning particular rich object mapping, `MongoTemplate`, and of
    course support for the repository writing style, well-known from other Spring
    Data projects. Here''s the required dependency declaration in `pom.xml`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Spring Boot 应用程序中启用 Mongo 支持，请在依赖项中包含 `spring-boot-starter-data-mongo` 启动器。这个项目提供了一些有趣的特性来简化与
    MongoDB 的集成。在这些特性中，特别值得一提的是丰富的对象映射、`MongoTemplate`，当然还有对仓库编写风格的支持，这是其他 Spring
    Data 项目所熟知的。以下是 `pom.xml` 中所需的依赖声明：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The instance of MongoDB may be easily started using its Docker image. Run the
    following command to launch the Docker container that exposes the Mongo database
    on port `27017`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 MongoDB 的 Docker 镜像轻松启动 MongoDB 的实例。运行以下命令以启动一个容器，该容器在端口 `27017` 上暴露 Mongo
    数据库：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to connect the application with a previously started data source,
    we should override some `auto-configured` settings in `application.yml`. This
    can be achieved with the `spring.data.mongodb.*` properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将应用程序与之前启动的数据源连接，我们应该覆盖 `application.yml` 中的 `auto-configured` 设置。这可以通过 `spring.data.mongodb.*`
    属性来实现：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I have already mentioned the object mapping feature. Spring Data Mongo provides
    some annotations that may be used for this. Every object stored in the database
    should be annotated with `@Document`. The primary key of the target collection
    is a 12 byte string, which should be indicated in every mapped class with Spring
    Data `@Id`. Here''s the fragment of `Account` object implementation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了对象映射功能。Spring Data Mongo提供了一些可用于此的注解。存储在数据库中的每个对象都应该用`@Document`注解。目标集合的主键是一个12字节的字符串，应该在Spring
    Data的`@Id`中每个映射类中指示。以下是`Account`对象实现的片段：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unit tests
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: I have taken a lot of time to describe integration with MongoDB. However, testing
    persistence is one of the key points of automated tests, so it is very important
    to configure it properly. Now, we may proceed to the test's implementation. Spring
    Test provides support for the most typical testing scenarios, such as integration
    with other services through a REST client or integration with databases. We have
    a set of libraries available that allows us to easily mock interactions with external
    services, which is especially important for unit tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了很长时间描述与MongoDB的集成。然而，测试持久性是自动化测试的关键点之一，所以正确配置它非常重要。现在，我们可以进行测试的实现。Spring
    Test为最典型的测试场景提供支持，例如通过REST客户端与其他服务集成或与数据库集成。我们有一套库可供我们轻松模拟与外部服务的交互，这对于单元测试尤为重要。
- en: 'The following test class is a typical unit test implementation for a Spring
    Boot application. We have used the JUnit framework, which is the de facto standard
    for Java. The Mockito library is used here for replacing the real repository and
    controller with their stubs. Such an approach allows us to easily verify the correctness
    of every method implemented by the `@Controller` class. The test is performed
    in isolation from the external components, which is the main assumption of unit
    testing:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试类是一个典型的Spring Boot应用程序的单元测试实现。我们使用了JUnit框架，这是Java事实上的标准。在这里，我们使用Mockito库用它们的存根替换真实的仓库和控制器。这种方法允许我们轻松验证`@Controller`类实现的每个方法的正确性。测试在与外部组件隔离的环境中进行，这是单元测试的主要假设：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The good news, especially within the context of microservices, is that we may
    easily mock Feign client communication. The following example test class verifies
    the endpoint from `order-service` used for withdrawing money by calling the endpoint
    exposed by `account-service`. As you have probably noticed, that endpoint has
    in turn been tested by the previously introduced test class. Here''s the class
    with unit test implementation for `order-service`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在微服务的背景下，我们可以很容易地模拟Feign客户端通信。下面的例子测试类验证了`order-service`中用于提款的端点，通过调用`account-service`暴露的端点。正如你可能已经注意到的，那个端点已经被之前介绍的测试类测试过了。这是`order-service`的带有单元测试实现的类：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Component tests
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试
- en: If you have provided the unit tests for all the key classes and interfaces in
    the application, you may proceed to the component tests. The main idea of component
    tests is to instantiate the full microservice in memory using in-memory test doubles
    and data stores. This allows us to skip the network connections. While for unit
    tests we were mocking all the database or HTTP clients, here we do not mock anything.
    We provide an in-memory data source for the database client and we simulate HTTP
    responses for the REST client.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为应用程序中的所有关键类和接口提供了单元测试，你可以继续进行组件测试。组件测试的主要思想是使用内存中的测试替身和数据存储实例化完整的微服务。这允许我们跳过网络连接。而在单元测试中，我们模拟了所有的数据库或HTTP客户端，在这里我们不模拟任何东西。我们为数据库客户端提供内存中的数据源，并为REST客户端模拟HTTP响应。
- en: Running tests with an in-memory database
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存数据库运行测试
- en: 'One of the reasons I chose MongoDB is that it can be easily embedded with a
    Spring Boot application for testing purposes. To enable an embedded MongoDB for
    your project, include the following dependency in Maven `pom.xml`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择MongoDB的一个原因是因为它很容易与Spring Boot应用程序集成以用于测试目的。为了为你的项目启用嵌入式MongoDB，请在Maven的`pom.xml`中包含以下依赖项：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Spring Boot provides auto-configuration for an embedded MongoDB, so we don''t
    need to do anything else other than setting the local address and port in `application.yml`.
    Because, by default, we use Mongo running on Docker container, we should declare
    such a configuration in an additional Spring profile. This specific profile is
    activated during test case execution by annotating the test class with `@ActiveProfiles`.
    Here''s a fragment of `application.yml`, where we defined two profiles, `dev`
    and `test`, with different MongoDB connection settings:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为内嵌MongoDB提供了自动配置，所以我们除了在`application.yml`中设置本地地址和端口外，不需要做任何事情。因为默认情况下，我们使用运行在Docker容器上的Mongo，所以我们应该在一个额外的Spring配置文件中声明这样的配置。这个特定的配置文件在测试用例执行期间通过在测试类上使用`@ActiveProfiles`注解来激活。下面是`application.yml`文件的一个片段，我们定义了两个配置文件`dev`和`test`，它们具有不同的MongoDB连接设置：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you use databases other than MongoDB, for example, MySQL or Postgres, you
    may easily replace them with alternative, in-memory, embedded, relational databases,
    such as H2 or Derby. Spring Boot supports them and provides auto-configuration
    for the tests that may be activated with `@DataJpaTest`. Instead of using `@SpringBootTest`,
    you can also use the `@DataMongoTest` annotation for embedded MongoDB. As well
    as an in-memory, embedded MongoDB, this will configure a `MongoTemplate`, scan
    for `@Document` classes, and configure Spring Data MongoDB repositories.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是除MongoDB之外的数据库，例如MySQL或Postgres，你可以很容易地将它们替换为替代的、基于内存的、内嵌的关系型数据库，如H2或Derby。Spring
    Boot支持它们，并为可能通过`@DataJpaTest`激活的测试提供自动配置。除了使用`@SpringBootTest`之外，你还可以使用`@DataMongoTest`注解来进行内嵌MongoDB的测试。这不仅会配置一个基于内存的内嵌MongoDB，还会配置一个`MongoTemplate`，扫描带有`@Document`注解的类，并配置Spring
    Data MongoDB仓库。
- en: Handling HTTP clients and service discovery
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理HTTP客户端和服务发现
- en: The issue regarding testing persistence with an in-memory database is resolved.
    However, we still need to consider some other aspects of the test, such as simulating
    HTTP responses from other services or integration with a service discovery. When
    you implement some tests for microservices, you may choose between two typical
    approaches to a service discovery. The first of these is to embed the discovery
    server to the application during the test case execution, and the second is just
    to disable discovery on the client side. The second option is relatively easy
    to configure with Spring Cloud. For the Eureka Server, it can be disabled using
    the `eureka.client.enabled=false` property.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用内嵌数据库测试持久化的 issue 已经解决。然而，我们仍然需要考虑测试的其他方面，例如模拟来自其他服务的HTTP响应或与服务发现集成。当你为微服务实现一些测试时，你可以选择服务发现的两种典型方法。第一种是在测试用例执行期间将发现服务器嵌入到应用程序中，第二种只是禁用在客户端上的发现。第二种选项通过Spring
    Cloud相对容易地进行配置。对于Eureka Server，可以通过设置`eureka.client.enabled=false`属性来禁用它。
- en: 'This is only the first part of the exercise. We should also disable discovery
    for the Ribbon client, which is responsible for load balancing in an interservice
    communication. If there is more than one target service, we have to label every
    client with the service name. The value of the last property in the following
    configuration, `listOfServers`, is strictly related to the framework used for
    automated test implementation. I''m going to show you the sample based on the
    Hoverfly Java library, which has already been introduced in [Chapter 7](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml),
    *Advanced Load Balancing and Circuit Breakers*. It was used then for simulating
    delays in calling target services in order to present how the Ribbon client and
    Hystrix deal with network timeouts. Here, we will just use it to return prepared
    responses to make our component tests to touch the network communications. Here''s
    a fragment of the configuration file with the profile responsible for disabling
    Eureka''s discovery and setting the test properties of the Ribbon client. That
    profile should also be activated for the test class by annotating it with `@ActiveProfiles`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是练习的第一部分。我们还应该禁用Ribbon客户端的服务发现功能，它负责服务间通信的负载均衡。如果有多个目标服务，我们必须给每个客户端打上服务名称的标签。下面配置文件中最后一个属性的值`listOfServers`与用于自动化测试实现的框架密切相关。我将向你展示一个基于Hoverfly
    Java库的示例，该库在第[7章](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml)《高级负载均衡和断路器》中已经介绍过，用于模拟调用目标服务时的延迟，以展示Ribbon客户端和Hystrix如何处理网络超时。在这里，我们只是使用它来返回预制的响应，使我们的组件测试涉及到网络通信。下面是配置文件的一个片段，其中包含负责禁用Eureka发现和设置Ribbon客户端测试属性的配置文件。该配置文件还应通过用`@ActiveProfiles`注解来激活测试类：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I wouldn''t like to go into the details of Hoverfly usage because it has already
    been discussed in [Chapter 7](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml), *Advanced
    Load Balancing and Circuit Breakers*. As you probably remember, Hoverfly can be
    activated for the JUnit test by declaring `@ClassRule` with `HoverflyRule`, defining
    the list of services and endpoints that should be simulated. The name of each
    service has to be the same as its address defined with the `listOfServers` property.
    Here''s a definition of the Hoverfly test rule that simulates responses from three
    different services:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想深入讲解Hoverfly的使用细节，因为这在第[7章](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml)《高级负载均衡和断路器》中已经讨论过了，*理查德·费曼*。正如你可能记得的，Hoverfly可以通过声明`@ClassRule`和`HoverflyRule`来为JUnit测试激活，通过定义需要模拟的服务和端点的列表来实现。每个服务的名称必须与其在`listOfServers`属性中定义的地址相同。下面是一个定义Hoverfly测试规则的示例，该规则模拟来自三个不同服务的响应：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementing sample tests
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现示例测试
- en: 'To conclude everything that has been said in the last two sections, we will
    now prepare component tests using an in-memory, embedded MongoDB, Hoverfly (to
    simulate HTTP responses), and disabled service discovery. The correct configuration
    settings prepared especially for our testing purposes are available under profiles
    `test` and `no-discovery`. Every component test is initialized by the `TestRestTemplate`,
    which calls `order-service` HTTP endpoints. The test result verification may be
    performed based on the HTTP response or data stored in the embedded MongoDB. Here''s
    a sample implementation of component tests for `order-service`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结前两节所讲的内容，我们现在将准备一个使用内存内嵌入的MongoDB、Hoverfly（用于模拟HTTP响应）和服务发现禁用的组件测试。专门为我们测试目的准备的正确配置设置位于`test`和`no-discovery`配置文件中。每个组件测试都是通过`TestRestTemplate`初始化的，它调用`order-service`的HTTP端点。测试结果的验证可以基于HTTP响应或存储在嵌入式MongoDB中的数据。下面是针对`order-service`的组件测试的一个示例实现：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Integration tests
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: After creating unit and component tests, we have verified all the functionalities
    inside the microservices. However, we still need to test the interaction with
    other services, external data stores, and caches. In microservices-based architecture
    integration, tests are treated differently than they are in monolithic applications.
    Because all the relationships between internal modules have been tested through
    the component tests, we have tested only those modules that interact with external
    components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建单元和组件测试之后，我们已经验证了微服务中的所有功能。然而，我们仍然需要测试与其他服务、外部数据存储和缓存的交互。在基于微服务的架构集成测试中，测试的处理方式与单体应用程序中的处理方式不同。因为所有内部模块之间的关系都通过组件测试进行了测试，所以我们只测试了与外部组件交互的模块。
- en: Categorizing tests
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类测试
- en: 'It also makes sense to separate integration tests in the CI pipeline so that
    external outages don''t block or break the build of the project. You should consider
    categorizing your tests by annotating them with `@Category`. You may create the
    interface especially for integration tests, for example, `IntegrationTest`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 把集成测试分离到CI管道中也是有意义的，这样外部故障就不会阻塞或破坏项目的构建。你应该通过用`@Category`注解标记它们来分类你的测试。你可以为集成测试创建一个特别的接口，例如`IntegrationTest`：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, you can mark your test with that interface using the `@Category` annotation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`@Category`注解标记你的测试：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, you can configure Maven to run only the selected type of tests, for
    example, with `maven-failsafe-plugin`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以配置Maven只运行选定的测试类型，例如，使用`maven-failsafe-plugin`：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Capturing HTTP traffic
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获HTTP流量
- en: Categorization is one of the ways of dealing with problems in communication
    with external microservices during automated tests. Another popular approach to
    that issue involves recording outgoing requests and incoming responses in order
    to use them in the future without establishing a connection to the external services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 分类是处理自动化测试期间与外部微服务通信问题的方法之一。另一种流行的方法涉及记录外出请求和进入响应，以便在未来不建立与外部服务的连接的情况下使用它们。
- en: In the previous examples, we have only used Hoverfly in simulation mode. However,
    it can also be run in capture mode, which means that requests will be made to
    the real service as normal, but they will be intercepted, recorded, and stored
    in the file by Hoverfly. The file that stores the captured traffic in JSON format
    may then be used in simulation mode. You can create a Hoverfly Rule in your JUnit
    test class, which is started in capture mode if the simulation file does not exist
    and in simulate mode if it does exist. It is always stored inside the `src/test/resources/hoverfly`
    directory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们只是使用了Hoverfly的模拟模式。然而，它也可以以捕获模式运行，这意味着请求将像往常一样发送到真实服务，但它们将被Hoverfly拦截、记录并存储在文件中。存储在JSON格式的捕获流量文件随后可以在模拟模式下使用。你可以在你的JUnit测试类中创建一个Hoverfly规则，如果模拟文件不存在，它将以捕获模式启动，如果存在，则以模拟模式启动。它总是存储在`src/test/resources/hoverfly`目录中。
- en: This is a simple way of breaking dependencies to the external service. For example,
    if you know that there were no changes there, it is not necessary to interact
    with the real service. If such a service were to be modified, you can remove the
    JSON simulation file and thereby switch to capture mode. If your test fails, it
    means that the modification affected your service and you have to perform some
    fixes before moving back to capture mode.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的方法，用于打破对外部服务的依赖。例如，如果你知道那里没有发生变化，那么与真实服务交互就不是必要的。如果这样的服务被修改了，你可以删除JSON模拟文件，从而切换到捕获模式。如果你的测试失败了，这意味着修改影响到了你的服务，你需要在回到捕获模式之前进行一些修复。
- en: 'Here''s a sample integration test located inside `order-service`. It adds a
    new account and then calls a method for withdrawing money from that account. Thanks
    to using the `inCaptureOrSimulationMode` method, the real service is invoked only
    if the `account.json` file does not exist or you change the input data passed
    to the services in the test:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个位于`order-service`内的集成测试示例。它添加了一个新账户，然后调用从该账户取款的的方法。由于使用了`inCaptureOrSimulationMode`方法，只有在`account.json`文件不存在或你更改了传递给服务的输入数据时，才会调用真实服务：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Contract tests
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同测试
- en: There are some interesting tools especially dedicated to contract testing. We
    will discuss this concept by looking at two of the most popular tools—Pact and
    Spring Cloud Contract.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有趣的工具专门用于合同测试。我们将通过查看最受欢迎的两个工具——Pact和Spring Cloud Contract——来讨论这个概念。
- en: Using Pact
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pact
- en: 'As we have already mentioned, the main concept around contract tests is to
    define a contract between the consumer and provider, and then verify it independently
    for each service. Since the responsibility for creating and maintaining a contract
    lies mainly on the consumer side, this type of test is usually referred to as
    a consumer-driven test. The division into a consumer and provider side is clearly
    visible in Pact JVM. It provides two separated libraries, the first prefixed by
    `pact-jvm-consumer` and the second prefixed by `pact-jvm-provider`. Of course,
    the contract is created by the consumer in agreement with the provider, which
    has been illustrated in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经在前面提到的，合同测试的主要概念是定义消费者和提供者之间的合同，然后独立地为每个服务验证它。由于创建和维护合同的责任主要在消费者端，这种类型的测试通常被称为消费者驱动的测试。在Pact
    JVM中，消费者和提供者端的分界是非常明显的。它提供了两个分离的库，第一个以`pact-jvm-consumer`为前缀，第二个以`pact-jvm-provider`为前缀。当然，合同是由消费者与提供商共同创建和维护的，这在下面的图表中已经说明：
- en: '![](img/f33b5f96-1fa5-40cf-a968-da07cb4ad39e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f33b5f96-1fa5-40cf-a968-da07cb4ad39e.png)'
- en: 'Pact is, in fact, a collection of frameworks that provide support for consumer-driven
    contract testing. These implementations are available for different languages
    and frameworks. Fortunately, Pact may be used together with JUnit and Spring Boot.
    Let''s consider one of the integrations implemented in our sample system, namely
    the one between `customer-service` and `account-service`. The microservice named
    `customer-service` uses the Feign client for communication with `account-service`.
    The Feign client definition on the consumer side de facto represents our contract:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Pact实际上是一组提供支持消费者驱动合同测试的框架集合。这些实现适用于不同的语言和框架。幸运的是，Pact可以与JUnit和Spring Boot一起使用。考虑我们在示例系统中实现的一个集成，即`customer-service`和`account-service`之间的集成。名为`customer-service`的微服务使用Feign客户端与`account-service`进行通信。消费者端的Feign客户端定义实际上代表我们的合同：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Consumer side
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费者端
- en: 'To enable Pact with JUnit support on the consumer side, include the following
    dependency to your project:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在消费者端启用带有JUnit支持的Pact，请将以下依赖项包含在你的项目中：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now the only thing we have to do is to create the JUnit test class. We may
    implement it as a standard Spring Boot test by annotating it with `@SpringBootTest`
    and running it using Spring Runner. To perform the created test successfully,
    we first need to disable the discovery client and ensure that the Ribbon client
    will communicate with the stub of the `account-service` represented by `@Rule`
    `PactProviderRuleMk2`. The key point of the test is the `callAccountClient` method,
    which is annotated with `@Pact` and returns a `RequestResponsePact`. It defines
    the format of the request and the content of the response. During the test case
    execution, Pact automatically generates the JSON representation of that definition,
    which is available in the `target/pacts/addressClient-customerServiceProvider.json`
    file. Finally, the method implemented in the Feign client is invoked and the response
    returned by Pact `@Rule` is verified in the test method annotated with `@PactVerification`.
    Here''s a sample implementation of a consumer-side contract test for `customer-service`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要创建一个JUnit测试类。我们可以通过用`@SpringBootTest`注解它并使用Spring Runner运行它来实现一个标准的Spring
    Boot测试。为了成功执行创建的测试，我们首先需要禁用发现客户端，并确保Ribbon客户端将使用`@Rule` `PactProviderRuleMk2`与`account-service`的存根进行通信。测试的关键点是`callAccountClient`方法，它用`@Pact`注解并返回一个`RequestResponsePact`。它定义了请求的格式和响应的内容。在测试用例执行期间，Pact会自动生成该定义的JSON表示，该表示位于`target/pacts/addressClient-customerServiceProvider.json`文件中。最后，在用`@PactVerification`注解的测试方法中调用Feign客户端实现的方法，并验证Pact
    `@Rule`返回的响应。下面是针对`customer-service`的消费者端合同测试的一个示例实现：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The JSON test result file generated in the `target/pacts` directory has to
    be available on the provider side. The simplest possible solution assumes that
    it can just access the generated file using the `@PactFolder` annotation. Of course,
    it requires the provider to have access to the `target/pacts` directory. Although
    it would work for our sample since its source code is stored in the same Git repository,
    it is not our target solution. Fortunately, we may publish the Pact test result
    in the network using Pact Broker. Pact Broker is a repository server that provides
    an HTTP API for publication and consumption of Pact files. We may start Pact Broker
    locally using its Docker image. It requires a Postgres database as a backend store,
    so we also start the container with Postgres. Here are the required Docker commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`target/pacts`目录中生成的JSON测试结果文件必须在提供者一侧可用。最简单的解决方案假设它可以通过使用`@PactFolder`注解来访问生成的文件。当然，这需要提供者能够访问`target/pacts`目录。尽管这对我们的示例有效，因为其源代码存储在同一个Git仓库中，但这不是我们的目标解决方案。幸运的是，我们可以使用Pact
    Broker在网络上发布Pact测试结果。Pact Broker是一个提供HTTP API用于发布和消费Pact文件的存储库服务器。我们可以使用其Docker镜像启动Pact
    Broker。它需要一个Postgres数据库作为后端存储，所以我们还需要启动带有Postgres的容器。以下是所需的Docker命令：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After running Pact Broker on Docker, we have to publish our test report there.
    We may easily perform this using the Maven plugin `pact-jvm-provider-maven_2.12`.
    If you run the `mvn clean install pack:publish` command, all the files placed
    in the `/target/pacts` directory will be sent to the broker''s HTTP API:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker上运行Pact Broker后，我们必须在那里发布我们的测试报告。我们可以使用`pact-jvm-provider-maven_2.12`插件轻松地执行此操作。如果您运行`mvn
    clean install pack:publish`命令，所有放置在`/target/pacts`目录中的文件都将发送到代理的HTTP API：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The full list of published Pacts can be displayed using the web console available
    at `http://192.168.99.100:9080`. It also provides the information about the last
    verification date and the details of every Pact in the list, as shown in the following
    screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 已发布Pact的完整列表可以通过在`http://192.168.99.100:9080`上可用的web控制台显示。它还提供了列表中每个Pact的最后验证日期和详细信息，如下面的屏幕截图所示：
- en: '![](img/55c94e0d-75da-45aa-a98f-2d8af546530e.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55c94e0d-75da-45aa-a98f-2d8af546530e.png)'
- en: Producer side
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者一侧
- en: 'Assuming the consumer has created a Pact and published it on the broker, we
    may proceed to implement a verification test on the provider side. To enable Pact
    with JUnit support on the provider side, include the `pact-jvm-provider-junit`
    dependency to your project. There is also another framework available, `pact-jvm-provider-spring`.
    This library allows you to run contract tests against a provider using Spring
    and JUnit. The list of required dependencies is visible on the following fragment
    of Maven `pom.xml`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设消费者已经在代理上创建了一个Pact并发布了它，我们可以在提供者一侧继续实现验证测试。要在提供者一侧启用支持Pact的JUnit，请在项目中包含`pact-jvm-provider-junit`依赖项。还有一个可用的框架，`pact-jvm-provider-spring`。这个库允许您使用Spring和JUnit对提供者运行合同测试。所需依赖项如下面的Maven
    `pom.xml`片段所示：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Thanks to the dedicated library for Spring, we may use `SpringRestPactRunner`
    instead of the default `PactRunner`. This, in turn, allows you to use the Spring
    test annotations, such as `@MockBean`. In the following JUnit test, we mock the
    `AccountRepository` bean. It returns three objects expected by the test on the
    consumer side. The test automatically starts the Spring Boot application and calls
    the `/customer/{customerId}` endpoint. There are also two other important things.
    By using the `@Provider` and `@State` annotations, we need to set the same names
    as were set for the test on the consumer side inside the `@Pact` annotation. Finally,
    by declaring `@PactBroker` on the test class, we provide the connection settings
    to the Pact''s repository. Here''s sample test using Pact, that verifies contract
    published by `customer-service`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有专门针对Spring的库，我们可以使用`SpringRestPactRunner`而不是默认的`PactRunner`。这反过来又允许您使用Spring测试注解，如`@MockBean`。在下面的JUnit测试中，我们模拟了`AccountRepository`bean。它返回测试消费者一侧期望的三个对象。测试自动启动Spring
    Boot应用程序并调用`/customer/{customerId}`端点。还有另外两个重要的事情。通过使用`@Provider`和`@State`注解，我们需要在`@Pact`注解中设置与消费者一侧测试相同的名称。最后，通过在测试类上声明`@PactBroker`，我们提供了连接到Pact存储库的设置。以下是使用Pact的示例测试，验证由`customer-service`发布的合同：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using Spring Cloud Contract
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Contract
- en: 'Spring Cloud Contract presents a slightly different approach to contract testing
    than Pack. While in Pack the consumer is responsible for publishing the contract,
    in Spring Cloud Contract the initiator of this action is the provider. The contracts
    are stored in a Maven repository as JARs, containing the stubs automatically generated
    based on the contract definition file. These definitions may be created using
    the Groovy DSL syntax. Each of them consists of two main parts: the request and
    the response specification. On the basis of these files, Spring Cloud Contract
    generates JSON stub definitions, which are used by WireMock for integration testing
    on the client side. In contrast to Pact, which is used as the tool supporting
    consumer-driven contracts testing for REST APIs, it has been designed especially
    for testing JVM-based microservices. It consists of three subprojects:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '-   Spring Cloud Contract在合同测试方面提出了与Pack略有不同的方法。在Pack中，消费者负责发布合同，而在Spring Cloud
    Contract中，这一行动的发起者是提供者。合同作为JAR存储在Maven仓库中，其中包含基于合同定义文件自动生成的存根。这些定义可以使用Groovy DSL语法创建。每个定义都包含两部分：请求和响应规格。基于这些文件，Spring
    Cloud Contract生成JSON存根定义，这些定义由WireMock用于客户端方面的集成测试。与用作支持REST API的消费者驱动合同测试工具的Pact相比，它特别设计用于测试基于JVM的微服务。它包含三个子项目：'
- en: Spring Cloud Contract Verifier
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   Spring Cloud Contract Verifier'
- en: Spring Cloud Contract Stub Runner
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Contract Stub Runner
- en: Spring Cloud Contract WireMock
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   Spring Cloud Contract WireMock'
- en: Let's analyze how they should be used in our contract tests based on the same
    example that was previously described in the section about the Pact framework.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '-   让我们分析如何根据之前在Pact框架部分描述的相同示例来使用它们进行合同测试。'
- en: WireMock is a simulator for HTTP-based APIs. Some might consider it a service
    virtualization tool or a mock server. It is able to get up and running quickly
    by capturing traffic to and from an existing API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '-   WireMock是一个基于HTTP的API模拟器。有些人可能认为它是一个服务虚拟化工具或模拟服务器。它可以通过捕获现有API的流量快速启动。'
- en: Defining contracts and generating stubs
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   定义合同并生成存根'
- en: 'As I have already mentioned in contrast to Pact, in Spring Cloud Contract,
    the provider (server side) is responsible for publishing the contract specification.
    Therefore, we will begin the implementation from `account-service`, which serves
    the endpoint invoked by `customer-service`. But before proceeding to the implementation,
    take a look at the following diagram. It illustrates the main components taking
    part in our testing process. The source code of the sample application is available
    in the same GitHub repository as the previous samples, but on a different branch
    contract:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '-   正如我已经在前面提到的，与Pact相比，在Spring Cloud Contract中，提供者（服务器端）负责发布合同规格。因此，我们将从`account-service`开始实现，该服务是`customer-service`调用的端点。但在继续实现之前，看看下面的图表。它描述了在我们测试过程中参与的主要组件。示例应用程序的源代码可在GitHub仓库中的上一个示例的不同分支contract中找到：'
- en: '![](img/03bc1e16-89eb-4c5a-bc68-a00382569392.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](img/03bc1e16-89eb-4c5a-bc68-a00382569392.png)'
- en: 'To enable Spring Cloud Contract functionalities for the provider-side application,
    first you have to include Spring Cloud Contract Verifier to your project dependencies:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '-   为了在提供者端应用程序中启用Spring Cloud Contract的功能，首先你必须将Spring Cloud Contract Verifier添加到你的项目依赖中：'
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to add the Spring Cloud Contract Verifier Maven plugin, which
    generates and runs your contract tests. It also produces and installs stubs in
    the local Maven repository. The only parameter you have to define for it is the
    package where the base classes extended by the generated test classes are located:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '-   下一步是添加Spring Cloud Contract Verifier Maven插件，该插件生成并运行你的合同测试。它还会生成并安装存根到本地Maven仓库中。你必须为它定义的唯一参数是生成的测试类所扩展的基本类所在的包：'
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we have to create a base class for the contract tests. It should be placed
    within the `pl.piomin.services.account` package. In the following base class,
    we set up a Spring Boot application with `@SpringBootTest` and then mock away
    the `AccountRepository`. We also use `RestAssured` to mock Spring MVC and send
    requests only to our controller. Thanks to all these mocks, the test does not
    interact with any external components, such as a database or an HTTP endpoint,
    and tests only the contract:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须为合同测试创建一个基类。它应该放在`pl.piomin.services.account`包内。在下面的基类中，我们用`@SpringBootTest`设置了Spring
    Boot应用程序，然后模拟了`AccountRepository`。我们还使用`RestAssured`来模拟Spring MVC，只向我们的控制器发送请求。由于所有的模拟，测试不与任何外部组件（如数据库或HTTP端点）交互，只测试合同：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have provided all the configuration and base classes needed for running tests
    with Spring Cloud Contract. Therefore, we may proceed to the most important part,
    defining the contract using the Spring Cloud Contract Groovy DSL. All the specifications
    of the contracts should be located in the `/src/test/resources/contracts` directory.
    The specific location under this directory, which contains stub definitions, is
    treated as a base test class name. Each stub definition represents a single contract
    test. Based on this rule, `spring-cloud-contract-maven-plugin` automatically finds
    the contract and assigns it to the base test class. In the example we are currently
    discussing, I have placed my stub definition in the `/src/test/resources/contracts/accountService`
    directory. So the generated test class name is `AccountServiceTest`, and it also
    extends the `AccountServiceBase` class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了所有运行与Spring Cloud Contract一起的测试所需的配置和基类。因此，我们可以进行最重要的部分，使用Spring Cloud
    Contract Groovy DSL定义合同。所有合同的规格都应该位于`/src/test/resources/contracts`目录下。这个目录下具体的位置，包含存根定义，被视为基测试类名。每个存根定义代表一个单独的合同测试。根据这个规则，`spring-cloud-contract-maven-plugin`会自动找到合同并将其分配给基测试类。在我们当前讨论的示例中，我把我的存根定义放在了`/src/test/resources/contracts/accountService`目录下。因此生成的测试类名是`AccountServiceTest`，并且它也继承了`AccountServiceBase`类。
- en: 'Here''s the sample contract specification that returns a list of accounts belonging
    to the customer. This contract is not very trivial, so some things need to be
    explained. You can use regular expressions to write your requests in Contract
    DSL. You can also provide different values for every property depending on the
    communication side (consumer or producer). Contract DSL also gives you the ability
    to reference a request in your response by using the `fromRequest` method. The
    following contract returns a list of three accounts, taking the `customerId` field
    from the request path and the `id` field, consisting of five digits:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是返回属于客户账户列表的示例合同规格。这个合同并不简单，所以有些东西需要解释。你可以使用正则表达式来编写你的请求 Contract DSL。你还可以为每个属性提供不同的值，这取决于通信方（消费者或生产者）。Contract
    DSL还允许你通过使用`fromRequest`方法来引用请求。下面的合同返回了三个账户列表，从请求路径中获取`customerId`字段和由五位数字组成的`id`字段：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Test classes are generated under the `target/generated-test-sources` directory
    during the test phase of the Maven build. Here''s the class generated from the
    contract specification described earlier:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类在Maven构建的测试阶段会在`target/generated-test-sources`目录下生成。下面是早先描述的合同规格生成的类：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Verifying a contract on the consumer side
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在消费者侧验证合同
- en: 'Assuming we have successfully built and run tests on the provider side, the
    stubs will have been generated and then published in our local Maven repository.
    To be able to use them during the consumer application test, we should include
    Spring Cloud Contract Stub Runner to the project dependencies:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经成功在提供者侧构建并运行了测试，存根将会被生成，然后发布在我们的本地Maven仓库中。为了能够在消费者应用程序测试时使用它们，我们应该将Spring
    Cloud Contract Stub Runner添加到项目依赖中：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then we should annotate our test class with `@AutoConfigureStubRunner`. It takes
    two input parameters—`ids` and `workOffline`. The `Ids` field is a concatenation
    of the `artifactId`, `groupId`, version number, `stubs` qualifier, and port number,
    and generally points out to the JAR which stubs are published by the provider.
    The `workOffline` flag indicates where the repository with the stubs is located.
    By default, the consumer tries to download artifacts automatically from Nexus
    or Artifactory. If you would like to force Spring Cloud Contract Stub Runner to
    download stubs only from the local Maven repository, you can switch the value
    of the `workOffline` parameter to `true`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该用`@AutoConfigureStubRunner`注解我们的测试类。它接受两个输入参数—`ids`和`workOffline`。`Ids`字段是`artifactId`、`groupId`、版本号、`stubs`限定符和端口号的组合，通常指出提供者发布的存根的JAR。`workOffline`标志指示存根仓库的位置。默认情况下，消费者尝试自动从Nexus或Artifactory下载工件。如果你想要强制Spring
    Cloud Contract Stub Runner只从本地Maven仓库下载存根，可以将`workOffline`参数的值切换为`true`。
- en: 'Here''s a JUnit test class that uses the Feign client to invoke the endpoint
    from the stub published by the provider side. Spring Cloud Contract looks for
    the newest version of the `pl.piomin.services:account-service` artifact. It has
    been indicated by passing the `+` sign as a version of the stub inside the `@AutoConfigureStubRunner`
    annotation. If you would like to use the concrete version of that artifact, you
    may set the current version from your `pom.xml` file instead of `+`, for example,
    `@AutoConfigureStubRunner(ids = {"pl.piomin.services:account-service:1.0-SNAPSHOT:stubs:8091"})`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Feign客户端调用由提供方发布的存根的端点的JUnit测试类。Spring Cloud Contract查找`pl.piomin.services:account-service`工件的最新版本。这通过在`@AutoConfigureStubRunner`注解中传递`+`作为存根的版本来指示。如果你想要使用该工件的具体版本，你可以在`pom.xml`文件中设置当前版本而不是`+`，例如，`@AutoConfigureStubRunner(ids
    = {"pl.piomin.services:account-service:1.0-SNAPSHOT:stubs:8091"})`：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only thing left is to build the whole project using the `mvn clean install`
    command in order to verify that tests are running successfully. However, we should
    remember that the tests created before cover only integration between `customer-service`
    and `account-service`. In our sample system, there are some other integrations
    between microservices that should be verified. I'll show you one more example,
    which tests the whole system. It tests methods exposed `order-service`, which
    communicates with all the other microservices. For this, we are going to use another
    interesting feature of Spring Cloud Contract scenarios.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要做的就是使用`mvn clean install`命令来构建整个项目，以验证测试是否成功运行。然而，我们应该记住，之前创建的测试只覆盖了`customer-service`和`account-service`之间的集成。在我们的示例系统中，还有其他一些微服务之间的集成应该被验证。我会再给你一个例子，它测试了整个系统。它测试了`order-service`中暴露的方法，该服务与其他所有微服务进行通信。为此，我们将使用Spring
    Cloud Contract场景的另一个有趣特性。
- en: Scenarios
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景
- en: 'Defining scenarios with Spring Cloud Contract is not difficult. The only thing
    you have to do is to provide the proper naming convention while creating a contract.
    This convention assumes that every contract''s name that is a part of the scenario
    is prefixed by an order number and an underscore. All the contracts included in
    a single scenario have to be located in the same directory. Spring Cloud Contract
    scenarios are based on WireMock''s scenarios. Here''s a directory structure with
    contracts defined for the needs of scenario that creates and accepts an order:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Contract定义场景并不困难。你只需要在做合同创建时提供合适的命名约定。这个约定假设每个场景中的合同名称都由一个序号和一个下划线前缀。一个场景中包含的所有合同必须位于同一个目录中。Spring
    Cloud Contract场景基于WireMock的场景。以下是一个包含为创建和接受订单需求定义的合同的目录结构：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the test''s source code generated for this scenario:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为此场景生成的测试源代码：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s imagine that we have a lot of microservices, and most of them communicate
    with one or more other microservices. So, even if you test a single contract,
    you can''t be sure that all other contracts during interservice communication
    work as expected. However, with Spring Cloud Contract, you may easily include
    all required stubs to your test class. That gives you the ability to verify all
    the contracts in the defined scenarios. This is required to include both `spring-cloud-starter-contract-verifier`
    and `spring-cloud-starter-contract-stub-runner` dependencies to the project. The
    following class definition acts as a base for the Spring Cloud Contract test class
    and includes stubs generated by other microservices. The stub generated for `order-service`
    endpoints may be used by any other external service that needs to verify the contract
    with `order-service`. A test such as the following code will verify not only the
    contract between this service and `order-service`, but also the contract between
    `order-service` and other services used by that service:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下我们有很多微服务，其中大多数都与其他一个或多个微服务进行通信。所以，即使你测试了一个单一的合约，你也不能确保所有其他在服务间通信过程中的合约都能如预期般工作。然而，借助Spring
    Cloud Contract，你完全可以轻松地将所有必需的存根（stubs）包含到你的测试类中。这赋予了你验证所有合约在定义场景中的能力。为此，你必须将`spring-cloud-starter-contract-verifier`和`spring-cloud-starter-contract-stub-runner`这两个依赖项包含到项目中。下面的类定义作为Spring
    Cloud Contract测试类的基类，并包含了由其他微服务生成的存根。为`order-service`端点生成的存根可以被任何其他需要与`order-service`验证合约的外部服务使用。如下面的测试代码不仅会验证本服务与`order-service`之间的合约，还会验证`order-service`与其他被该服务使用的服务之间的合约：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Performance testing
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: We still have one last type of automated test to discuss. It has already been
    mentioned at the beginning of the chapter. I am, of course, talking about performance
    tests. There are some really interesting tools and frameworks that help you to
    create and run this kind of test. There is a large choice of instruments, especially
    if we are talking about HTTP API tests. I wouldn't like to discuss all of them,
    but I will talk about one framework that might be helpful. It's Gatling. Let's
    take a closer look at it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要讨论一种自动化测试的最后类型。在本章的开头已经提到了它。我当然是在谈论性能测试。有一些非常有趣的工具和框架可以帮助你创建和运行这类测试。如果我们谈论的是HTTP
    API测试，特别是在仪器选择上有很多选择。我不想讨论它们全部，但我将讨论一个可能会有帮助的框架。它就是Gatling。让我们更仔细地看看它。
- en: Gatling
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gatling
- en: Gatling is an open source performance testing tool written in Scala. It allows
    you to develop the tests in an easily readable and writable **domain-specific
    language** (**DSL**). It stands out from the competition by generating comprehensive,
    graphical load reports illustrating all the metrics collected during a test case.
    There are plugins available for integrating Gatling with Gradle, Maven, and Jenkins.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Gatling是一个用Scala编写的开源性能测试工具。它允许你使用一种易于阅读和编写的**领域特定语言**（**DSL**）来开发测试。它通过生成详尽、图表化的负载报告，展示了测试过程中收集的所有指标，从而区别于其他竞争对手。还有插件可用于将Gatling与Gradle、Maven和Jenkins集成。
- en: Enabling Gatling
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用Gatling
- en: To enable the Gatling framework for a project, we should include the `io.gatling.highcharts:gatling-charts-highcharts`
    artifact in the dependencies.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使项目启用Gatling框架，我们应该在依赖项中包含`io.gatling.highcharts:gatling-charts-highcharts`这个构件。
- en: Defining the test scenario
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义测试场景
- en: Every Gatling test suite should extend the `Simulation` class. In every test
    class, we may declare a list of scenarios using the Gatling Scala DSL. We usually
    declare the number of simultaneous threads that can call HTTP endpoints and the
    whole number of requests sent per single thread. In the Gatling nomenclature,
    the number of threads is determined by the number of users set using the `atOnceUsers`
    method. The test class should be placed in the `src/test/scala` directory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Gatling测试套件都应该扩展`Simulation`类。在每一个测试类中，我们可以使用Gatling Scala DSL声明一系列场景。我们通常会声明可以同时调用HTTP端点的线程数以及每个线程发送的请求总数。在Gatling的术语中，线程数是由使用`atOnceUsers`方法设置的用户数决定的。测试类应该放在`src/test/scala`目录中。
- en: Assuming that we would like to test two endpoints that are exposed by `order-service`
    running 20 clients, where each of them sends 500 requests sequentially, we would
    have 20,000 requests sent in total. By sending them all in a short period of time,
    we would be able to test the performance of our application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试由`order-service`暴露的两个端点，在该服务上运行20个客户端，每个客户端按顺序发送500个请求，总共将发送20,000个请求。通过在短时间内发送它们全部，我们能够测试我们应用程序的性能。
- en: 'The following test scenario is written in Scala. Let''s take a closer look
    at it. Before running this test, I created some accounts and products by calling
    the HTTP API, exposed by `account-service` and `product-service`. Because they
    are connected to an external database, IDs are automatically generated. In order
    to provide some test data, I have copied them into the test class. Both the lists
    with the account and product IDs are passed to the test scenario as feeds. Then,
    during every iteration, the required values are randomly picked from the lists.
    Our test scenario is named `AddAndConfirmOrder`. It consists of two `exec` methods.
    The first of them creates a new order by calling the `POST /order` HTTP method.
    The order''s ID is automatically generated by the service, so it should be saved
    as an attribute. Then it can be used in the next `exec` method, which confirms
    the order by calling the `PUT /order/{id}` endpoint. The only thing that is validated
    after the test is the HTTP status:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试场景是用Scala编写的。让我们仔细看看。在运行这个测试之前，我通过调用`account-service`和`product-service`暴露的HTTP
    API创建了一些账户和产品。因为它们连接到一个外部数据库，所以ID是自动生成的。为了提供一些测试数据，我将它们复制到了测试类中。账户和产品ID的列表都被传递到测试场景作为数据源。然后，在每次迭代中，都会从列表中随机选择所需值。我们的测试场景名为`AddAndConfirmOrder`。它由两个`exec`方法组成。第一个方法通过调用`POST
    /order`HTTP方法创建一个新订单。订单ID由服务自动生成，因此应该作为属性保存。然后，它可以用在下一个`exec`方法中，通过调用`PUT /order/{id}`端点确认订单。测试后验证的唯一事情是HTTP状态：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Running a test scenario
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行一个测试场景
- en: 'There are a few different ways of running a Gatling performance test on your
    machine. One of them is through one of the available through Gradle plugins, which
    provide support for running tests during the building of a project. You may also
    use Maven plugins or just try to run it from your IDE. If you build your project
    with Gradle, you can also define simple tasks that just run tests by launching
    the `io.gatling.app.Gatling` main class. Here''s a definition of such a task in
    the `gradle.build` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以在你的机器上运行Gatling性能测试。其中一种是通过可用的Gradle插件之一，它提供在项目构建过程中运行测试的支持。你也可以使用Maven插件，或者尝试从你的IDE中运行它。如果你用Gradle构建你的项目，你还可以定义简单的任务，只需通过启动`io.gatling.app.Gatling`主类来运行测试。下面是在`gradle.build`文件中此类任务的定义：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now you can run that task just by calling the `gradle loadTest` command. Of
    course, you need to have all the sample microservices, MongoDB, and `discovery-service`
    started before running those tests. By default, Gatling will print all the requests
    sent, the received responses, and the final test result, with time statistics
    and the number of success and failure API calls. If you need more detailed information,
    you should refer to the files generated after the test, which are available under
    the `build/gatling-results` directory. You might find that the HTML files there
    provide visualization in the form of diagrams and graphs. The first of them (shown
    in the following diagram) shows a summary with the total number of generated requests
    and the maximum response time broken down by percentiles. For example, you may
    see that the maximum response time in 95% of responses for the `AddOrder` API
    is 835 ms:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过调用`gradle loadTest`命令来运行该任务。当然，在运行这些测试之前，你需要启动所有示例微服务、MongoDB和`discovery-service`。默认情况下，Gatling会打印发送的所有请求、收到的响应以及最终的测试结果，包括时间统计和成功与失败的API调用次数。如果你需要更详细的信息，你应该参考测试后生成的文件，这些文件可以在`build/gatling-results`目录下找到。你可能会发现那里的HTML文件以图表和图形的形式提供了可视化。其中的第一个（如图所示）显示了生成的请求总数以及按百分位数划分的最大响应时间。例如，你可能看到`AddOrder`
    API的95%响应中的最大响应时间是835毫秒：
- en: '![](img/b0a26700-2d21-4154-a8c2-59a74a404800.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0a26700-2d21-4154-a8c2-59a74a404800.png)'
- en: 'There are also some other interesting statistics visualized. Let''s pay particular
    attention to the following two reports. The first of them shows a graph displaying
    the percentage of requests grouped by the average response time, while the second
    shows the timeline with the average response time by percentile:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他有趣的统计数据进行了可视化。让我们特别关注以下两个报告。第一个报告显示了一个图表，显示按平均响应时间分组的请求百分比，而第二个报告则显示了按百分位数显示的平均响应时间的时间线：
- en: '![](img/94bc93b4-1e8f-465f-9ff6-ba27c5f7f418.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94bc93b4-1e8f-465f-9ff6-ba27c5f7f418.png)'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I have introduced some frameworks that can help you effectively
    test your REST-based applications written in Java. Each of these solutions has
    been assigned to a particular type of test. I focused on tests strictly related
    to microservices, such as contract and component tests. The main goal of this
    chapter was to compare the two most popular frameworks used for contract testing,
    namely Pact and Spring Cloud Contract. Despite appearances, there are some significant
    differences between them. I tried to show you the most important similarities
    and differences based on the same sample applications that we looked at in previous
    chapters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了一些框架，这些框架可以帮助您有效地测试用Java编写的基于REST的应用程序。每个解决方案都被分配到一种特定的测试类型。我专注于与微服务直接相关的测试，例如契约测试和组件测试。本章的主要目标是比较两种最流行的用于契约测试的框架，即Pact和Spring
    Cloud Contract。尽管它们看起来很相似，但实际上它们之间有一些显著的区别。我试图向您展示基于我们在前几章中查看的相同示例应用程序的最重要相似之处和差异。
- en: Microservices are strictly related to automation. Remember that migration from
    monolith to microservices gives you an opportunity to refactor your code, and,
    moreover, to improve the quality and code coverage of your automated tests. Frameworks
    such as Mockito, Spring Test, Spring Cloud Contract, and Pact, when used together,
    give you a really powerful solution to develop tests for REST-based Java microservices.
    Automated tests are a significant part of the CI/CD process, which will be discussed
    in the next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务与自动化密切相关。请记住，从单体迁移到微服务为您提供了一个机会来重构您的代码，而且更重要的是，提高自动化测试的质量和代码覆盖率。当一起使用时，如Mockito、Spring
    Test、Spring Cloud Contract和Pact这样的框架为您提供了一个非常强大的解决方案，用于开发基于REST的Java微服务的测试。自动化测试是CI/CD过程的一个重要组成部分，下一章将讨论这一点。
