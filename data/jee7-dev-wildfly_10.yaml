- en: Chapter 10. Securing WildFly Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。保护WildFly应用程序
- en: In the previous chapter, we described how to manage your application server.
    The next stop in our journey will be learning about security, which is a key element
    of any Enterprise application. You must be able to control and restrict who is
    permitted to access your applications and what operations users may perform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们描述了如何管理您的应用服务器。我们旅程的下一个目的地将是学习安全，这是任何企业应用程序的关键元素。您必须能够控制并限制谁被允许访问您的应用程序以及用户可以执行的操作。
- en: The Java Enterprise Edition specification defines a simple role-based security
    model for Enterprise JavaBeans and web components. The implementation of WildFly
    security is delivered by the **Picketbox** framework (formerly known as JBoss
    Security), which is part of the application server and provides the authentication,
    authorization, auditing, and mapping capabilities for Java applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java企业版规范为Enterprise JavaBeans和Web组件定义了一个简单的基于角色的安全模型。WildFly安全的实现由**Picketbox**框架（以前称为JBoss
    Security）提供，它是应用服务器的一部分，并为Java应用程序提供认证、授权、审计和映射功能。
- en: 'Here is the list of topics we will cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题列表：
- en: A short introduction to the Java security API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java安全API简介
- en: The foundation of the WildFly security subsystem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WildFly安全子系统的基石
- en: Defining and applying login modules to secure Java EE applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义并应用登录模块以保护Java EE应用程序
- en: Using the **Secure Sockets Layer** (**SSL**) protocol to encrypt the traffic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**安全套接字层**（**SSL**）协议加密流量
- en: Approaching the Java security API
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近Java安全API
- en: 'Java EE security services provide a robust and easily configurable security
    mechanism to authenticate users and authorize access to application functions
    and the associated data. To better understand the topics related to security,
    we should first lay out some basic definitions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE安全服务提供了一种强大且易于配置的安全机制，用于认证用户并授权访问应用程序功能和相关数据。为了更好地理解与安全相关的主题，我们首先应该列出一些基本定义：
- en: '**Authentication**: This is the process by which you can verify who is currently
    executing an application, regardless of whether it is an EJB or a servlet (and
    so on). Authentication is usually performed by means of a `Login` module contained
    in a web/standalone application. The Java EE specification provides only general
    requirements that must be met by all compliant containers. This means that every
    application server provides its own authentication mechanisms, which is a problem
    when it comes to portability of applications and their configuration.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：这是验证当前执行应用程序的用户身份的过程，无论它是EJB还是servlet（等等）。认证通常通过包含在Web/独立应用程序中的`Login`模块来完成。Java
    EE规范仅提供了所有兼容容器必须满足的一般要求。这意味着每个应用服务器都提供自己的认证机制，这在应用程序的可移植性和配置方面会带来问题。'
- en: '**Authorization**: This is the process by which you can verify if a user has
    the right (permission) to access system resources or invoke certain operations.
    Authorization, therefore, presupposes that authentication has occurred; it would
    be impossible to grant any access control if you don''t know who the user is first.
    Java EE specification provides means to authorize a user''s actions. The authorization
    declarations are usually portable between different application servers. The difference
    between authentication and authorization is depicted in the following diagram:![Approaching
    the Java security API](img/00079.jpeg)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：这是验证用户是否有权（权限）访问系统资源或调用某些操作的过程。因此，授权假设认证已经发生；如果你不知道用户是谁，就无法授予任何访问控制。Java
    EE规范提供了授权用户操作的手段。授权声明通常在不同应用服务器之间是可移植的。认证和授权之间的区别在以下图中展示：![接近Java安全API](img/00079.jpeg)'
- en: 'In Java EE, the containers are responsible for providing application security.
    A container basically provides two types of security: declarative and programmatic.
    Let''s take a look at both of them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE中，容器负责提供应用程序安全。容器基本上提供两种类型的安全：声明性和程序性。让我们来看看这两种类型：
- en: '**Declarative security**: This expresses an application component''s security
    requirements by means of deployment descriptors. Because deployment descriptor
    information is contained in an external file, it can be changed without the need
    to modify the source code.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式安全**：通过部署描述符表达应用程序组件的安全需求。因为部署描述符信息包含在外部文件中，所以可以在不修改源代码的情况下进行更改。'
- en: For example, Enterprise JavaBeans components use an EJB deployment descriptor,
    which must be named `ejb-jar.xml` and placed in the `META-INF` folder of the EJB
    JAR file.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，企业 JavaBeans 组件使用 EJB 部署描述符，其名称必须是 `ejb-jar.xml`，并放置在 EJB JAR 文件的 `META-INF`
    文件夹中。
- en: Web components use a web application deployment descriptor named `web.xml`,
    which is located in the `WEB-INF` directory.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Web 组件使用名为 `web.xml` 的 Web 应用程序部署描述符，位于 `WEB-INF` 目录中。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since the release of Java EE 5, you can apply declarative security by means
    of annotations just like we have for other key APIs (EJB, web services, and so
    on). Annotations are specified within a class file, and when the application is
    deployed, the application server translates this information internally.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自 Java EE 5 发布以来，你可以通过注解的方式应用声明式安全，就像我们对其他关键 API（EJB、Web 服务等）所做的那样。注解在类文件中指定，当应用程序部署时，应用程序服务器会内部转换这些信息。
- en: '**Programmatic security**: This is embedded in an application and used to make
    security decisions. It can be used when declarative security alone is not sufficient
    to express the security model of an application. The Java EE security API allows
    the developer to test whether or not the current user has access to a specific
    role, using the following calls:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序性安全**：嵌入在应用程序中，用于做出安全决策。当仅使用声明式安全不足以表达应用程序的安全模型时，可以使用它。Java EE 安全 API 允许开发者使用以下调用测试当前用户是否有权访问特定角色：'
- en: '`isUserInRole()` for servlets and JSPs (adopted in `javax.servlet.http.HttpServletRequest`)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isUserInRole()` 用于 servlets 和 JSPs（在 `javax.servlet.http.HttpServletRequest`
    中采用）'
- en: '`isCallerInRole()` for EJBs (adopted in `javax.ejb.SessionContext`)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCallerInRole()` 用于 EJBs（在 `javax.ejb.SessionContext` 中采用）'
- en: 'Additionally, there are other API calls that provide access to the user''s
    identity, which are as follows:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，还有其他 API 调用可以提供对用户身份的访问，如下所示：
- en: '`getUserPrincipal()` for servlets and JSPs (adopted in `javax.servlet.http.HttpServletRequest`)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUserPrincipal()` 用于 servlets 和 JSPs（在 `javax.servlet.http.HttpServletRequest`
    中采用）'
- en: '`getCallerPrincipal()` for EJBs (adopted in `javax.ejb.SessionContext`)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCallerPrincipal()` 用于 EJBs（在 `javax.ejb.SessionContext` 中采用）'
- en: Using these APIs, you can develop arbitrarily complex authorization models.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这些 API，你可以开发任意复杂的授权模型。
- en: The WildFly security subsystem
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WildFly 安全子系统
- en: 'WildFly security qualifies as an extension to the application server and is
    included, by default, both in standalone and domain servers using the following
    code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 安全性作为应用程序服务器的扩展，默认情况下包含在独立服务器和域服务器中，以下代码所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'WildFly defines security policies using two terms: security realms and security
    domains. Security realms are configuration sets mapped to external connectors
    (for example, EJB remoting and management interface). They allow every connection
    type to have its own appropriate authentication and authorization properties defined.
    For instance, both management and application realms define two separate files,
    which store the allowed usernames. Additionally, the application realm contains
    a reference to a file that defines user role.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 使用两个术语定义安全策略：安全领域和安全域。安全领域是映射到外部连接器的配置集（例如，EJB 远程和管理接口）。它们允许每种连接类型都有其适当的身份验证和授权属性定义。例如，管理和应用程序领域定义了两个单独的文件，存储允许的用户名。此外，应用程序领域包含一个指向定义用户角色的文件的引用。
- en: The configuration defined in the security realm is then passed to a security
    domain requested by the deployed application. The security domain defines a set
    of login modules that are responsible for checking the user's credentials and
    creating a security principal representing the client (along with a set of roles
    for the requester).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将安全域中定义的配置传递给已部署应用程序请求的安全域。安全域定义了一组负责检查用户凭据并创建代表客户端的安全主体（以及请求者的角色集）的登录模块。
- en: 'The following is an extract from the default security subsystem contained in
    the server configuration file, which contains the `RealmDirect` login that will
    be used in the next section to secure the Ticket example application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从服务器配置文件中提取的默认安全子系统，其中包含将在下一节中用于保护Ticket示例应用程序的`RealmDirect`登录：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Configuration files are defined in the security realm using the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码在安全域中定义配置文件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the configuration is pretty short as it relies largely on default
    values, especially for high-level structures such as the security management area.
    By defining your own security management options, you could, for example, override
    the default authentication/authorization managers with your implementations. Since
    it is likely that you will not need to override these interfaces, we will rather
    concentrate on the `security-domain` element, which is the core aspect of WildFly
    security.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，配置相当简短，因为它在很大程度上依赖于默认值，特别是对于像安全管理区域这样的高级结构。通过定义自己的安全管理选项，例如，您可以覆盖默认的认证/授权管理器，使用您的实现。由于您可能不需要覆盖这些接口，我们将更关注`security-domain`元素，这是WildFly安全的核心方面。
- en: A security domain can be thought of as a Customs Office for foreigners. Before
    the request crosses WildFly borders, the security domain performs all the required
    authentication and authorization checks and eventually notifies if he/she can
    proceed or not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安全域可以被视为外国人的海关办公室。在请求越过WildFly边界之前，安全域会执行所有必要的身份验证和授权检查，并最终通知他/她是否可以继续。
- en: Security domains are generally configured at server startup and subsequently
    bound into the JNDI tree under the key `java:/jaas/`. Within the security domain,
    you can configure login authentication modules so that you can easily change your
    authentication provider by simply changing its `login-module` element.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安全域通常在服务器启动时配置，并随后绑定到`java:/jaas/`键下的JNDI树中。在安全域内，您可以配置登录认证模块，以便您可以简单地通过更改其`login-module`元素来轻松更改您的认证提供者。
- en: 'There are several implementations of login modules available out of the box;
    there is obviously not enough room here to describe in detail the features of
    each module, though we will offer a comprehensive description of some popular
    options, such as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，提供了几个登录模块的实现；显然，这里没有足够的空间来详细描述每个模块的功能，尽管我们将提供一些流行选项的全面描述，例如：
- en: The `RealmDirect` login module, which can be used for basic file-based authentication
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RealmDirect`登录模块，可用于基于基本文件的身份验证'
- en: The `Database` login module, which checks user credentials against a relational
    database
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Database`登录模块，该模块将用户凭据与关系数据库进行核对'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Should you need further information about login modules, check out the WildFly
    documentation at:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要有关登录模块的更多信息，请查看WildFly文档：
- en: '[https://docs.jboss.org/author/display/WFLY8/Security+subsystem+configuration](https://docs.jboss.org/author/display/WFLY8/Security+subsystem+configuration)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.jboss.org/author/display/WFLY8/Security+subsystem+configuration](https://docs.jboss.org/author/display/WFLY8/Security+subsystem+configuration)'
- en: '[https://docs.jboss.org/author/display/WFLY8/Security+Realms](https://docs.jboss.org/author/display/WFLY8/Security+Realms)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.jboss.org/author/display/WFLY8/Security+Realms](https://docs.jboss.org/author/display/WFLY8/Security+Realms)'
- en: Setting up your first login module
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置您的第一个登录模块
- en: 'In the following section, we will demonstrate how to secure an application
    using the `RealmDirect` security domain, which was introduced earlier. The `RealmDirect`
    login module is based on the following two files:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将演示如何使用之前介绍的`RealmDirect`安全域来保护应用程序。`RealmDirect`登录模块基于以下两个文件：
- en: '`application-users.properties`: This contains the list of usernames and passwords'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application-users.properties`：此文件包含用户名和密码列表'
- en: '`application-roles.properties`: This contains the mapping between the users
    and their roles'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application-roles.properties`：此文件包含用户与其角色之间的映射'
- en: 'These files are located in the application server configuration folder and
    they are updated each time you add a new user via the `add-user.sh/add-user.cmd`
    script. For our purpose, we will create a new application user named `demouser`,
    which belongs to the role `Manager`, as shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件位于应用程序服务器配置文件夹中，每次您通过`add-user.sh/add-user.cmd`脚本添加新用户时，它们都会被更新。为了我们的目的，我们将创建一个名为`demouser`的新应用程序用户，该用户属于`Manager`角色，如下面的截图所示：
- en: '![Setting up your first login module](img/00080.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![设置您的第一个登录模块](img/00080.jpeg)'
- en: 'Once the user is added, the `application-users.properties` file will contain
    the username and the MD5 encoding of the password, shown as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户添加后，`application-users.properties` 文件将包含用户名和密码的 MD5 编码，如下所示：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Conversely, the `application-roles.properties` file will contain the roles
    granted to the `demouser` username once logged in:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`application-roles.properties` 文件将包含登录后授予 `demouser` 用户名的角色：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the login module in the Ticket web application
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Ticket 网络应用程序中使用登录模块
- en: We can now apply the `RoleDirect` login module in the Ticket web application
    described in [Chapter 4](part0028_split_000.html#page "Chapter 4. Learning Context
    and Dependency Injection"), *Learning Context and Dependency Injection* (you could
    pick the version from another chapter if you like). We will first show how to
    provide a BASIC web authentication, and then we will show a slightly more complex
    example using FORM-based authentication.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 [第 4 章](part0028_split_000.html#page "Chapter 4. 学习上下文和依赖注入") 中描述的 Ticket
    网络应用程序中应用 `RoleDirect` 登录模块，*学习上下文和依赖注入*（如果你喜欢，也可以从其他章节选择版本）。我们首先将展示如何提供基本的 Web
    身份验证，然后我们将展示一个使用基于表单的身份验证的稍微复杂一些的例子。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: BASIC-access authentication is the simplest way to provide a username and password
    when making a request through a browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: BASIC 访问身份验证是在通过浏览器进行请求时提供用户名和密码的最简单方式。
- en: It works by sending an encoded string containing the user credentials. This
    Base64-encoded string is transmitted and decoded by the receiver, resulting in
    colon-separated username and password strings. When it comes to safety, BASIC
    authentication is usually not the best solution. The password can be stolen during
    the transmission, so SSL is a must in order to protect it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过发送包含用户凭据的编码字符串来工作。这个 Base64 编码的字符串被传输并解码，结果是冒号分隔的用户名和密码字符串。当涉及到安全性时，基本身份验证通常不是最佳解决方案。密码可能在传输过程中被盗，因此
    SSL 是必须的，以保护它。
- en: 'Turning on web authentication requires the `security-constraints` element to
    be defined in the web application configuration file (`web.xml`), as shown in
    the following code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Web 身份验证需要在 Web 应用程序配置文件（`web.xml`）中定义 `security-constraints` 元素，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This configuration will add a security constraint on any JSP/servlet of the
    web application that will restrict access to users authenticated with the role
    `Manager`. All login modules shown in the earlier section define this role, so
    you can just use the login module that suits your needs best.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将在 Web 应用程序中的任何 JSP/servlet 上添加一个安全约束，将限制对具有 `Manager` 角色的已验证用户的访问。前面部分中显示的所有登录模块都定义了此角色，因此你可以使用最适合你需求的登录模块。
- en: 'From Java EE 7, there are two more methods to express your security constraints.
    Firstly, you can use a new container provided role: `**`. It indicates that you
    are referring to any authenticated user, without taking its roles into account.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java EE 7 开始，有另外两种方法来表示你的安全约束。首先，你可以使用一个新的容器提供的角色：`**`。这表示你正在引用任何已认证的用户，不考虑其角色。
- en: The second one is the `deny-http-uncovered-methods` tag, which can be used in
    a `web.xml` file to forbid access to every HTTP method that is not covered by
    a separate security constraint.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是 `deny-http-uncovered-methods` 标签，可以在 `web.xml` 文件中使用，以禁止访问未由单独安全约束覆盖的任何
    HTTP 方法。
- en: 'The next configuration tweak needs to be performed on the JBoss web deployment''s
    descriptor, `WEB-INF/jboss-web.xml`. You need to declare the security domain here,
    which will be used to authenticate the users. Since we are using `RealmDirect`,
    which is part of the other built-in login module, we will need to include the
    `java:/jaas/other` context information:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配置调整需要在 JBoss 网络部署的描述符 `WEB-INF/jboss-web.xml` 上执行。你需要在这里声明安全域，它将被用来验证用户。由于我们使用的是
    `RealmDirect`，它是其他内置登录模块的一部分，因此我们需要包含 `java:/jaas/other` 上下文信息：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following diagram illustrates the whole configuration sequence applied
    to a `Database` login module:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了应用于 `Database` 登录模块的整个配置序列：
- en: '![Using the login module in the Ticket web application](img/00081.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![在 Ticket 网络应用程序中使用登录模块](img/00081.jpeg)'
- en: Once you have deployed your application, the outcome should be a blocking pop
    up requesting user authentication. The window will look a little different on
    every browser and its appearance cannot be changed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署了你的应用程序，结果应该是一个阻塞的弹出窗口，要求用户进行身份验证。在不同的浏览器上，窗口的外观可能会有所不同，其外观无法更改。
- en: Logging in with `demouser` username and the valid password will grant access
    to the application with the `Manager` role.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `demouser` 用户名和有效的密码登录将授予 `Manager` 角色的应用程序访问权限。
- en: Switching to FORM-based security
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换到基于 FORM 的安全
- en: 'FORM-based authentication lets developers customize the authentication user
    interface, adapting it, for example, to your company''s standards. Configuring
    it in your application requires you to basically modify just the `login-config`
    stanza of the security section of your `web.xml` file. Within it, we will define
    a login landing page (`login.xhtml`) and an error page (`error.xhtml`), in case
    the login fails. The code snippet for it is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 FORM 的身份验证允许开发者自定义身份验证用户界面，例如，适应贵公司的标准。在您的应用程序中配置它需要您基本上只修改 `web.xml` 文件安全部分的
    `login-config` 段。在其中，我们将定义一个登录着陆页（`login.xhtml`）和一个错误页（`error.xhtml`），以防登录失败。相应的代码片段如下：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The login form must contain fields to enter a username and password. These
    fields must be named `j_username` and `j_password`, respectively. The authentication
    form should post these values to the `j_security_check` logical name. All these
    names beginning with `j_` are standardized by the Java Servlet specification—we
    just need to follow the convention in order to let the automatic mechanisms work.
    Here''s a simple `login.xhtml` page, which can be used to pass the required values
    to the security system:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 登录表单必须包含用于输入用户名和密码的字段。这些字段分别命名为 `j_username` 和 `j_password`。认证表单应将这些值提交到 `j_security_check`
    逻辑名称。所有以 `j_` 开头的名称都由 Java Servlet 规范标准化——我们只需遵循约定，以便让自动机制工作。以下是一个简单的 `login.xhtml`
    页面，可以用来将所需值传递给安全系统：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the sake of brevity, we won't include the error page, which will simply
    alert that the user entered an incorrect combination of username and password.
    The expected outcome is the following login screen, which will intercept all user
    access to your application and grant access to the default home page if the `username`
    and `password` credentials are correct.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们不会包括错误页，它将简单地提醒用户输入了错误的用户名和密码组合。预期的结果是以下登录屏幕，它将拦截所有用户对您的应用程序的访问，如果
    `username` 和 `password` 凭据正确，则授予对默认主页的访问权限。
- en: Creating a Database login module
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库登录模块
- en: 'The `UserRoles` login module is a good starting point to learn how to put together
    all the pieces required to secure a web application. In real-world cases, there
    are better alternatives to protect your applications, such as the `Database` login
    module. A database security domain follows the same logic exposed in the earlier
    example; it just stores the credentials within the database. In order to run this
    example, we will refer to a data source defined in [Chapter 5](part0030_split_000.html#page
    "Chapter 5. Combining Persistence with CDI"), *Combining Persistence with CDI*
    (bound at the JNDI name `java:jboss/datasources/wflydevelopment`), which needs
    to be deployed on the application server:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRoles` 登录模块是学习如何组合所有用于保护 Web 应用程序所需的组件的好起点。在实际情况下，有更好的替代方案来保护您的应用程序，例如
    `Database` 登录模块。数据库安全域遵循之前示例中公开的逻辑；它只是在数据库中存储凭据。为了运行此示例，我们将参考在 [第 5 章](part0030_split_000.html#page
    "第 5 章。将持久性与 CDI 结合") 中定义的数据源，*将持久性与 CDI 结合*（绑定在 JNDI 名称 `java:jboss/datasources/wflydevelopment`），需要在应用程序服务器上部署： '
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to get this configuration working, you have to first create the required
    tables and insert some sample data in it using the following queries:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此配置生效，您必须首先创建所需的表，并使用以下查询在表中插入一些示例数据：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `admin` user will map again to the `Manager` role. One caveat
    of this configuration is that it uses clear text passwords in the database; so
    before rolling this module into production, you should consider adding additional
    security to your login module. Let's see how to do this in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`admin` 用户将再次映射到 `Manager` 角色。此配置的一个注意事项是它使用数据库中的明文密码；因此，在将此模块投入生产之前，您应该考虑在登录模块中添加额外的安全性。让我们在下一节中看看如何做。
- en: Encrypting passwords
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密密码
- en: Storing passwords in the database as a clear text string is not considered a
    good practice; as a matter of fact, a database has even more potential security
    holes than a regular filesystem. Imagine, for example, that a DBA added a public
    synonym for some tables, forgetting that one of those tables held sensitive information
    such as application passwords, as shown in the following screenshot! You then
    need to be sure that no potential attackers will ever be able to deliver the following
    query.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将密码以明文字符串的形式存储在数据库中不被认为是良好的做法；事实上，数据库甚至比常规文件系统有更多的潜在安全漏洞。例如，想象一下，如果数据库管理员为某些表添加了一个公共同义词，忘记了其中一张表包含了敏感信息，如应用程序密码，如下面的截图所示！您随后需要确保没有任何潜在的攻击者能够执行以下查询。
- en: '![Encrypting passwords](img/00082.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![加密密码](img/00082.jpeg)'
- en: 'Fortunately, securing application passwords is relatively easy; you can add
    a few extra options to your login module, specifying that the stored passwords
    are encrypted using a message digest algorithm. For example, in the `Database`
    login module, you should add the following highlighted options at the bottom:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，保护应用程序密码相对简单；您可以在登录模块中添加一些额外的选项，指定存储的密码使用消息摘要算法进行加密。例如，在`Database`登录模块中，您应该在底部添加以下突出显示的选项：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we specified that the password will be hashed against an SHA hash algorithm;
    alternatively, you can use any other algorithm allowed by your JCA provider.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定密码将与SHA哈希算法进行散列；或者，您可以使用JCA提供程序允许的任何其他算法。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an excellent introduction to hashing algorithms, refer to [http://www.unixwiz.net/techtips/iguide-crypto-hashes.html](http://www.unixwiz.net/techtips/iguide-crypto-hashes.html).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对哈希算法的优秀介绍，请参阅[http://www.unixwiz.net/techtips/iguide-crypto-hashes.html](http://www.unixwiz.net/techtips/iguide-crypto-hashes.html)。
- en: 'For the sake of completeness, we include a small application as follows, which
    generates the Base64 hashed password that is to be inserted in `Database`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们包括以下小应用程序，它生成要插入到`Database`中的Base64散列密码：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the main program with `admin` as the argument will generate the hash
    `jGl25bVBBBW96Qi9Te4V37Fnqchz/Eu4qB9vKrRIqRg=`. This hash will be your updated
    password, which needs to be updated in your database, as shown in the following
    screenshot. Update the password using the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`admin`作为参数运行主程序将生成哈希`jGl25bVBBBW96Qi9Te4V37Fnqchz/Eu4qB9vKrRIqRg=`。这个哈希将是您的更新后的密码，您需要将其更新到您的数据库中，如下面的截图所示。使用以下代码更新密码：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can update it with any SQL client of your choice.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您选择的任何SQL客户端来更新它。
- en: '![Encrypting passwords](img/00083.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![加密密码](img/00083.jpeg)'
- en: Using the Database login module in your application
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用Database登录模块
- en: 'Once you are done with the login module configuration, don''t forget to reference
    it through the JBoss web deployment''s descriptor, `WEB-INF/jboss-web.xml`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完成登录模块配置后，不要忘记通过JBoss web部署的描述符`WEB-INF/jboss-web.xml`引用它：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Securing EJBs
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护EJBs
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful! There is more than one `SecurityDomain` API available. You have
    to include `org.jboss.ejb3.annotation.SecurityDomain`. The `@RolesAllowed` annotation,
    on the other hand, needs to import `javax.annotation.security.RolesAllowed`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意！有多个`SecurityDomain` API可用。您必须包含`org.jboss.ejb3.annotation.SecurityDomain`。另一方面，`@RolesAllowed`注解需要导入`javax.annotation.security.RolesAllowed`。
- en: 'The JBoss-specific annotations can be found in the following maven dependency:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss特定的注解可以在以下maven依赖项中找到：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Annotations can also be applied at the method level; for example, if we want
    to secure just the `bookSeat` object of the `TheatreBookerBean` class, we will
    tag the `bookSeat` method as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注解也可以应用于方法级别；例如，如果我们只想保护`TheatreBookerBean`类的`bookSeat`对象，我们将如下标记`bookSeat`方法：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What if you don''t want to use annotations to establish security roles? For
    example, if you have a security role that is used crosswise by all your EJB applications,
    perhaps it is simpler to use a plain old XML configuration instead of tagging
    all EJBs with annotations. In this scenario, you have to declare the security
    constraints first in the generic `META-INF/ejb-jar.xml` file, shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用注解来建立安全角色怎么办？例如，如果您有一个被所有EJB应用程序跨域使用的安全角色，可能使用普通的旧XML配置而不是给所有EJB添加注解会更简单。在这种情况下，您必须在通用的`META-INF/ejb-jar.xml`文件中首先声明安全约束，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, inside the `META-INF/jboss-ejb3.xml` configuration file, just add a reference
    to your security domain:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`META-INF/jboss-ejb3.xml`配置文件中，只需添加对您的安全域的引用：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s a snapshot illustrating the role configuration of the EJB file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个展示 EJB 文件角色配置的快照：
- en: '![Securing EJBs](img/00084.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![保护 EJB](img/00084.jpeg)'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to use a login module via EJB remoting, you must configure your
    security realm accordingly using the JAAS entry, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想通过 EJB 远程使用登录模块，您必须使用以下代码中的 JAAS 条目相应地配置您的安全领域：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Additionally, you should place the following entries in `jbossyourjboss-ejb-client-properties`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该在 `jbossyourjboss-ejb-client-properties` 中放置以下条目：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These entries will ensure (besides passing the credentials), that the transmitted
    password will not be additionally hashed by the remoting mechanism.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条目将确保（除了传递凭证之外），传输的密码不会被远程机制额外散列。
- en: Securing web services
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护网络服务
- en: 'Web service authorization can basically be carried out in two ways, depending
    on whether we are dealing with a POJO-based web service or an EJB-based web service.     Security changes to POJO web services are identical to those we introduced for
    servlets/JSP, consistent in defining the `security-constraints` element in `web.xml`
    and the login modules in `jboss-web.xml`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们是否处理基于 POJO 的网络服务或基于 EJB 的网络服务，基本可以通过两种方式执行 Web 服务授权。安全更改与我们对 servlets/JSP
    介绍的安全更改相同，一致地定义 `web.xml` 中的 `security-constraints` 元素和 `jboss-web.xml` 中的登录模块。
- en: 'If you are using a web client to access your web service, it is all you need
    to get authenticated. If you are using a standalone client, you will need to specify
    the credentials in the JAX-WS Factory. The following is an example of how to access
    the secured `CalculatePowerService` instance, which was described in [Chapter
    7](part0038_split_000.html#page "Chapter 7. Adding Web Services to Your Applications"),
    *Adding Web Services to Your Applications*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Web 客户端来访问您的网络服务，这将是您需要的一切以进行认证。如果您使用的是独立客户端，您需要在 JAX-WS 工厂中指定凭证。以下是如何访问在
    [第 7 章](part0038_split_000.html#page "第 7 章。将 Web 服务添加到您的应用程序") 中描述的受保护 `CalculatePowerService`
    实例的示例，该实例在 *将 Web 服务添加到您的应用程序* 中进行了描述：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What about EJB-based web services? The configuration is slightly different;
    since the security domain is not specified in web descriptors, we have to provide
    it by means of annotations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那么基于 EJB 的网络服务呢？配置略有不同；由于在 Web 描述符中没有指定安全域，我们必须通过注解来提供它：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the `@org.jboss.ws.api.annotation.Webcontext` annotation basically
    reflects the same configuration options as that of POJO-based web services, with
    BASIC authentication and unrestricted WSDL access.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`@org.jboss.ws.api.annotation.Webcontext` 注解基本上反映了与基于 POJO 的网络服务相同的配置选项，包括基本身份验证和无限制的
    WSDL 访问。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `@WebContext` annotation can be found in the following dependency:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebContext` 注解可以在以下依赖项中找到：'
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `@org.jboss.ejb3.annotation.SecurityDomain` annotation should be familiar
    to you since we introduced it to illustrate how to secure an EJB. As you can see,
    it's a replacement for the information contained in the `jboss-web.xml` file,
    except that the security domain is referenced directly by `dbdomain` (instead
    of `java:/jaas/dbdomain`).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`@org.jboss.ejb3.annotation.SecurityDomain` 注解应该对你来说很熟悉，因为我们曾用它来演示如何保护 EJB。正如你所见，它是
    `jboss-web.xml` 文件中包含信息的替代品，除了安全域是直接通过 `dbdomain`（而不是 `java:/jaas/dbdomain`）引用的。'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The previous security configuration can also be specified by means of the `META-INF/ejb-jar.xml`
    and `META-INF/jboss-ejb3.xml` file in case you prefer using standard configuration
    files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用标准配置文件，之前的网络安全配置也可以通过 `META-INF/ejb-jar.xml` 和 `META-INF/jboss-ejb3.xml`
    文件来指定。
- en: 'To pass your login credentials to the web service, you can use the `RequestContext`
    object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的登录凭证传递给网络服务，您可以使用 `RequestContext` 对象：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The username and password values will be passed to the login module defined
    in the security domain, just like in every other authentication method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名和密码值将被传递到安全域中定义的登录模块，就像在其他任何认证方法中一样。
- en: Securing the transport layer
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护传输层
- en: If you were to create a mission-critical application with just the bare concepts
    you learned until now, you would be exposed to all sorts of security threats.
    For example, if you need to design a payment gateway, where the credit card information
    is transmitted by means of an EJB or servlet, using just the authorization and
    authentication stack is really not enough, as the sensitive information is still
    sent across a network and it could be disclosed by a hacker.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仅凭至今所学的基础概念来创建一个关键任务应用，你将面临各种安全威胁。例如，如果你需要设计一个支付网关，其中信用卡信息通过EJB或servlet传输，仅使用授权和认证栈是远远不够的，因为敏感信息仍然通过网络传输，可能被黑客泄露。
- en: In order to prevent disclosure of critical information to unauthorized individuals
    or systems, you have to use a protocol that provides encryption of the information.
    Encryption is the conversion of data into a form that cannot be understood by
    unauthorized people. Conversely, decryption is the process of converting encrypted
    data back into its original form so that it can be understood.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止关键信息被未经授权的个人或系统泄露，你必须使用一种提供信息加密的协议。加密是将数据转换成未经授权的人无法理解的形式的过程。相反，解密是将加密数据转换回原始形式以便理解的过程。
- en: The protocols used to secure the communication are SSL and TLS, the latter being
    considered a replacement for the older SSL.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 用于保护通信的协议是SSL和TLS，后者被认为是较老SSL的替代品。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The differences between the two protocols are minor and very technical. In
    short, TLS uses stronger encryption algorithms and has the ability to work on
    different ports. For the rest of this chapter, we will refer to SSL for both protocols.
    Check out Wikipedia for more information on it: [http://en.wikipedia.org/wiki/Transport_Layer_Security](http://en.wikipedia.org/wiki/Transport_Layer_Security).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种协议之间的差异很小，且非常技术性。简而言之，TLS使用更强的加密算法，并且能够在不同的端口上工作。在本章的其余部分，我们将对这两种协议都使用SSL。有关更多信息，请查看维基百科：[http://en.wikipedia.org/wiki/Transport_Layer_Security](http://en.wikipedia.org/wiki/Transport_Layer_Security)。
- en: 'There are two basic techniques to encrypt information: symmetric encryption
    (also called secret-key encryption) and asymmetric encryption (also called public-key
    encryption).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 加密信息有两种基本技术：对称加密（也称为密钥加密）和非对称加密（也称为公钥加密）。
- en: Symmetric encryption is the oldest and best-known technique. It is based on
    a secret key, which is applied to the text of a message to change the content
    in a particular way. As long as both the sender and recipient know the secret
    key, they can encrypt and decrypt all messages that use this key. These encryption
    algorithms typically work fast and are well suited to encrypt blocks of messages
    at once.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密是最古老且最广为人知的技巧。它基于一个密钥，该密钥应用于消息文本以改变内容。只要发送者和接收者都知道这个密钥，他们就可以加密和解密使用此密钥的所有消息。这些加密算法通常运行速度快，非常适合一次性加密大量消息。
- en: One significant issue with symmetric algorithms is the requirement of a safe
    administrative organization to distribute keys to users. This generally results
    in increased overhead from the administrative aspect while the keys remain vulnerable
    to unauthorized disclosure and potential abuse.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对称算法的一个显著问题是需要安全的行政组织来向用户分发密钥。这通常会导致行政方面的开销增加，同时密钥仍然容易受到未经授权的泄露和潜在滥用的威胁。
- en: For this reason, a mission-critical enterprise system usually relies on the
    asymmetric encryption algorithms, which tend to be easier to employ, manage, and
    are ultimately more secure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关键任务的企业系统通常依赖于非对称加密算法，这些算法通常更容易部署、管理和使用，最终也更加安全。
- en: 'Asymmetric cryptography, also known as **public-key cryptography**, is based
    on the concept that the key used to encrypt is not the same as the key that is
    used to decrypt the message. In practice, each user holds a couple of keys: the
    public key that is distributed to other parties and the private key that is kept
    as a secret. Each message is encrypted with the recipient''s public key and can
    only be decrypted (by the recipient) with his private key, as shown in the following
    diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称密码学，也称为**公钥密码学**，基于这样一个概念：用于加密的密钥与用于解密消息的密钥不同。在实践中，每个用户都持有几对密钥：分发给其他方的公钥和作为秘密保留的私钥。每条消息都使用接收者的公钥进行加密，并且只能用接收者的私钥（如以下图所示）进行解密：
- en: '![Securing the transport layer](img/00085.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![保护传输层](img/00085.jpeg)'
- en: Using asymmetric encryption, you can be sure that your message cannot be disclosed
    to a third party. However, there is still one vulnerability.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非对称加密，你可以确信你的消息不会被泄露给第三方。然而，仍然存在一个漏洞。
- en: Suppose you want to exchange some valuable information with a business partner
    and to that end are requesting his public key by telephone or email. A fraudulent
    user intercepts your e-mail or simply listens to your conversation and quickly
    sends you a fake mail with his public key. Now, even if your data transmission
    is secured, it will be directed to the wrong person!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想与一个商业伙伴交换一些有价值的信息，为此你通过电话或电子邮件请求他的公钥。一个欺诈用户拦截了你的电子邮件或简单地监听你的对话，并迅速发送给你一封带有他公钥的伪造邮件。现在，即使你的数据传输是加密的，它也会被错误地发送给错误的人！
- en: In order to solve this issue, we need a document to verify that the public key
    belongs to a particular individual. This document is called a **digital certificate**
    or public-key certificate. A digital certificate consists of a formatted block
    of data that contains the name of the certificate holder (which may be either
    a user or system name) and the holder's public key, along with the digital signature
    of a **Certification Authority** (**CA**) for authentication. The CA attests that
    the sender's name is the one associated with the public key in the document.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要一份文件来验证公钥属于特定的个人。这份文件被称为**数字证书**或公钥证书。数字证书由一个格式化的数据块组成，其中包含证书持有者的名称（可能是用户名或系统名）和持有者的公钥，以及**认证机构**（**CA**）的数字签名以进行认证。CA证实发送者的名称与文件中公钥关联。
- en: '![Securing the transport layer](img/00086.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![保护传输层](img/00086.jpeg)'
- en: Public key certificates are commonly used to secure the interaction with websites.
    By default, the web browser ships with a set of predefined CAs; they are used
    to verify that the public certificate served to a browser when you enter a secure
    site has actually been issued by the owner of the website. In short, if you connect
    your browser to `https://www.abc.com` and your browser doesn't give any certificate
    warning, you can safely interact with the entity in charge of the site, that is,
    unless the site or your browser has been hacked. However, this is another story.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥证书通常用于确保与网站的交互安全。默认情况下，网络浏览器附带一组预定义的CA；它们用于验证当你输入一个安全网站时，提供给浏览器的公钥证书确实是由网站所有者签发的。简而言之，如果你将浏览器连接到`https://www.abc.com`，并且你的浏览器没有给出任何证书警告，你可以安全地与负责该网站的实体进行交互，除非该网站或你的浏览器已被黑客攻击。然而，这又是另一个故事。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Simple authentication and client authentication**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单认证和客户端认证**'
- en: In the previous example, we depicted a simple authentication, (also called server
    authentication). In this scenario, the only party that needs to prove its identity
    is the server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们描述了一个简单的认证（也称为服务器认证）。在这个场景中，唯一需要证明其身份的方是服务器。
- en: SSL, however, is able to perform mutual authentication (also called client or
    two-way authentication); here too, the server requests a client certificate during
    the SSL handshake over the network.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SSL能够执行相互认证（也称为客户端或双向认证）；在这里，服务器在网络SSL握手期间也会请求客户端证书。
- en: Client authentication requires a client certificate in the x.509 format from
    a CA. The x.509 format is an industry-standard format for SSL certificates. In
    the next section, we will explore which tools are available to generate digital
    certificates, and how to get your certificates signed by a CA.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端认证需要从CA获取的x.509格式的客户端证书。x.509格式是SSL证书的行业标准格式。在下一节中，我们将探讨哪些工具可用于生成数字证书，以及如何让你的证书由CA签名。
- en: Enabling the Secure Socket Layer on WildFly
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在WildFly上启用安全套接字层
- en: WildFly uses the **Java Secure Socket Extension** (**JSSE**), which is bundled
    in the Java SE to leverage the SSL/TLS communication.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly使用**Java安全套接字扩展**（**JSSE**），它是Java SE的一部分，用于利用SSL/TLS通信。
- en: 'An Enterprise application can be secured at two different locations: the HTTP
    level for web applications, and the RMI level for applications using EJB. HTTP
    communication is handled by the web subsystem within the `standalone.xml`/`domain.xml`
    file. Securing the RMI transport is, on the other hand, not always a compelling
    requirement of your applications. Actually, in most production environments, WildFly
    is placed behind a firewall.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序可以在两个不同的位置进行安全设置：Web应用的HTTP级别，以及使用EJB的应用程序的RMI级别。HTTP通信由`standalone.xml`/`domain.xml`文件中的Web子系统处理。另一方面，保护RMI传输并不是您应用程序的强制要求。实际上，在大多数生产环境中，WildFly都放置在防火墙后面。
- en: 'As you can see from the following diagram, this implies that your EJBs are
    not directly exposed to untrusted networks, which usually connect through the
    web server placed in a demilitarized zone:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下图中可以看出，这意味着您的EJBs不是直接暴露在不信任的网络中，这些网络通常通过放置在非军事区的Web服务器连接：
- en: '![Enabling the Secure Socket Layer on WildFly](img/00087.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![在WildFly上启用安全套接字层](img/00087.jpeg)'
- en: In order to get started with WildFly and SSL, we need a tool that generates
    a public/private key pair in the form of an x.509 certificate for use by the SSL
    server sockets. This is covered in the next section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用WildFly和SSL，我们需要一个工具来生成用于SSL服务器套接字的公钥/私钥对，形式为x.509证书。这将在下一节中介绍。
- en: Certificate management tools
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 证书管理工具
- en: One tool that can be used to set up a digital certificate is **keytool**, a
    key and certificate management utility that ships with the Java SE. It enables
    users to administer their own public/private key pairs and associated certificates
    for use in self-authentication (where the user authenticates himself or herself
    to other users or services) or data integrity and authentication services, using
    digital signatures. It also allows users to cache the public keys (in the form
    of certificates) of their communicating peers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来设置数字证书的一个工具是**keytool**，这是一个Java SE附带的关键和证书管理实用程序。它使用户能够管理自己的公钥/私钥对及其相关证书，用于自我认证（用户向其他用户或服务进行身份验证）或数据完整性和认证服务，使用数字签名。它还允许用户缓存其通信对等方的公钥（以证书的形式）。
- en: 'The keytool stores the keys and certificates in a file termed keystore, a repository
    of certificates used to identify a client or server. Typically, a keystore contains
    a client or server''s identity, which is protected by a password. Let''s see an
    example of the keystore generation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: keytool将密钥和证书存储在称为密钥库的文件中，这是一个用于识别客户端或服务器的证书存储库。通常，密钥库包含客户端或服务器的身份，由密码保护。让我们看看密钥库生成的示例：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command creates the keystore named `wildfly.keystore` in the working directory,
    and assigns it the password `mypassword`. It generates a public/private key pair
    for the entity whose unique name has the common name `John Smith`, organization
    `PacktPub`, and two-letter country code `GB`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在当前工作目录中创建名为`wildfly.keystore`的密钥库，并为其分配密码`mypassword`。它为具有通用名`John Smith`、组织`PacktPub`和两位字母国家代码`GB`的唯一名称的实体生成公钥/私钥对。
- en: The result of this action will be a self-signed certificate (using the RSA signature
    algorithm), which includes the public key and the unique name. This certificate
    will be valid for 180 days, and is associated with the private key in a keystore
    entry referred to by the alias `wflyalias`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的输出将是一个自签名证书（使用RSA签名算法），它包括公钥和唯一名称。此证书将有效期为180天，并与密钥库条目中引用的别名`wflyalias`关联的私钥相关联。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A self-signed certificate is a certificate that has not been verified by a CA
    and thus, leaves you vulnerable to the classic man-in-the-middle attack. A self-signed
    certificate is only suitable for in-house use or for testing while you wait for
    your real certificate to arrive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书是一个未经CA验证的证书，因此，您容易受到经典的中间人攻击。自签名证书仅适用于内部使用或测试，直到您真正的证书到达。
- en: Securing the HTTP communication with a self-signed certificate
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自签名证书保护HTTP通信
- en: Now let's see how you can use this keystore file to secure your WildFly web
    channel. Open your server configuration file and locate the web subsystem.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用此密钥库文件来保护您的WildFly Web通道。打开您的服务器配置文件，定位Web子系统。
- en: 'Within the web subsystem, you have to first change the default `http-listener`
    and `socket-binding` to `https-listener` and `"https"`, and add the `security-realm`
    element to it. Next, you have to insert an `ssl` stanza within it, which contains
    the details of your `keystore` object (in our example, we dropped the file `jboss.keystore`
    into the server configuration directory):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 子系统中，您必须首先更改默认的 `http-listener` 和 `socket-binding` 为 `https-listener`
    和 `"https"`，并将 `security-realm` 元素添加到其中。接下来，您必须在其中插入一个 `ssl` 子句，其中包含您的 `keystore`
    对象的详细信息（在我们的示例中，我们将文件 `jboss.keystore` 放入服务器配置目录中）：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we referenced `EJBRealm` in the configuration, but we still
    need to define it. We will do this in the next sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在配置中引用了 `EJBRealm`，但我们仍然需要定义它。我们将在下一节中这样做。
- en: Generating the server and client certificates
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成服务器和客户端证书
- en: Start by generating a public/private key pair for the entity whose unique name
    has the common name `John Smith`, organization `PacktPub`, and two-letter country
    code `GB`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为具有通用名 `John Smith`、组织 `PacktPub` 和两字母国家代码 `GB` 的实体的公私钥对进行生成。
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, export the server's public key into a certificate named `sslPublicKey.cer`
    that uses the password `mypassword`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将服务器的公钥导出到一个名为 `sslPublicKey.cer` 的证书中，该证书使用密码 `mypassword`。
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have finished configuring the server, we will generate a key pair
    for the client too. We will do this by using the alias `ejbclientalias` and the
    same properties as we did for the server''s `keystore` object:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了服务器的配置，我们也将为客户端生成一个密钥对。我们将通过使用别名 `ejbclientalias` 和与服务器 `keystore`
    对象相同的属性来完成此操作：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The client public key will also be exported to a certificate named `clientPublicKey.cer`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端公钥也将导出到一个名为 `clientPublicKey.cer` 的证书中。
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, in order to complete the SSL handshake successfully, we need to first
    import the client''s public key into the server''s `truststore` object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了成功完成 SSL 握手，我们首先需要将客户端的公钥导入服务器的 `truststore` 对象中：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The server certificate also needs to be trusted by the client. You have two
    available options to solve this issue, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器证书也需要被客户端信任。您有两个可用的选项来解决此问题，如下所示：
- en: Import the server certificate into the client's JDK bundle of certificates
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务器证书导入客户端的 JDK 证书包中
- en: Create a new repository of certificates trusted by the client (`truststore`)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个客户端信任的证书新存储库（`truststore`）
- en: Importing the server certificate into the client JDK means executing a certificate
    import into the client's certified authorities.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务器证书导入客户端 JDK 意味着执行一个证书导入到客户端的认证机构中。
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We just have to replace the path we used with our actual JDK path and use the
    client store's password in order to complete this operation (the default value
    is `changeit`).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将我们使用的路径替换为实际的 JDK 路径，并使用客户端存储库的密码（默认值为 `changeit`）来完成此操作。
- en: Otherwise, if you want to import the certificate into a newly created `truststore`
    object, just substitute the `cacerts` destination with your client's `truststore`
    object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果您想将证书导入到一个新创建的 `truststore` 对象中，只需将 `cacerts` 目标替换为您的客户端 `truststore` 对象。
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you choose the latter option, you need to add the following properties to
    your client''s JDK arguments, which will override the default JDK''s `truststore`
    object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择后者，您需要将以下属性添加到您的客户端 JDK 参数中，这将覆盖默认 JDK 的 `truststore` 对象：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating an SSL-aware security realm
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个支持 SSL 的安全域
- en: Within WildFly, security realms are used to secure access to the management
    interfaces, HTTP interface, and remote JNDI and EJB access. Within a security
    realm, it is also possible to define an identity for the server; this identity
    can be used for both inbound connections to the server and outbound connections
    being established by the server.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WildFly 中，安全域用于保护对管理接口、HTTP 接口和远程 JNDI 及 EJB 访问的访问。在安全域内，还可以为服务器定义一个身份；此身份可以用于服务器的外部连接和服务器正在建立的内部连接。
- en: 'Therefore, in order to enable SSL communication for our EJB communication and
    HTTP, we will define a security realm (named `EJBRealm`) that is bound to a server
    identity, which references the server''s `keystore` object, shown as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了启用我们的 EJB 通信和 HTTP 的 SSL 通信，我们将定义一个名为 `EJBRealm` 的安全域，该域绑定到一个服务器身份，该身份引用服务器的
    `keystore` 对象，如下所示：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Besides containing the location where SSL certificates are stored, this security
    realm also contains the authentication policy used by your EJBs, which is defined
    by the JAAS's security domain, named `ejb-security-domain`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含存储SSL证书的位置外，这个安全域还包含你的EJB使用的身份验证策略，该策略由名为`ejb-security-domain`的JAAS安全域定义。
- en: 'The following is a security domain definition, which is a simple file-based
    security domain containing the user credentials and roles in the files `ejb-users.properties`
    and `ejb-roles.properties`, respectively:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个安全域定义，它是一个简单的基于文件的包含用户凭据和角色的安全域，分别在`ejb-users.properties`和`ejb-roles.properties`文件中：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can imagine, you need to create the two property files, each with some
    values in them. For example, here''s the `ejb-user.properties` file to be placed
    in the server configuration''s folder:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，你需要创建两个属性文件，每个文件中都有一些值。例如，以下是将放置在服务器配置文件夹中的`ejb-user.properties`文件：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is the corresponding `ejb-roles.properties` file that grants
    the role `ejbRole` to the `adminUser` role:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`ejb-roles.properties`文件，它将`ejbRole`角色授予`adminUser`角色：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last configuration effort would be to specify it in the `security-realm`
    attribute of your `remoting` connector''s element:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的配置工作是在你的`remoting`连接器的`security-realm`属性中指定它：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's check the outcome of our work. First, we will try out the HTTPS connection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的工作成果。首先，我们将尝试HTTPS连接。
- en: 'You have to restart WildFly to activate the changes. You should see the following
    log at the bottom of your console, which informs you about the new HTTPS channel
    running on port 8443:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须重新启动WildFly以激活更改。你应该在你的控制台底部看到以下日志，它通知你新的HTTPS通道正在端口8443上运行：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following screen is what will be displayed by the Internet Explorer (don''t
    try this at home) browser (the same kind of error message, with a different format,
    will be displayed by other browsers such as Firefox and Google Chrome) if you
    try to access the Ticket example using the secured channel (for example, `https://localhost:8443/ticket-agency-cdi`):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用安全通道（例如，`https://localhost:8443/ticket-agency-cdi`）访问Ticket示例，以下屏幕将是Internet
    Explorer（不要在家尝试）浏览器将显示的内容（其他浏览器如Firefox和Google Chrome将以不同格式显示相同类型的错误消息）：
- en: '![Creating an SSL-aware security realm](img/00088.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个支持SSL的安全域](img/00088.jpeg)'
- en: What happened? Once you establish a secure connection with the web server, the
    server certificate is sent to the browser. Since the certificate has not been
    signed by any recognized CA, the browser security sandbox warns the user about
    the potential security threat.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？一旦你与Web服务器建立了安全连接，服务器证书将被发送到浏览器。由于证书没有被任何已识别的CA签发，浏览器安全沙盒会警告用户潜在的威胁。
- en: This is an in-house test so we can safely proceed by choosing **Continue to
    this website**. That's all you need to do in order to activate the Secure Socket
    Layer with a self-signed certificate.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内部测试，因此我们可以通过选择**继续访问此网站**来安全地进行。这就是你为了使用自签名证书激活安全套接字层所需做的全部事情。
- en: Securing HTTP communication with a certificate signed by a CA
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用由CA签名的证书保护HTTP通信
- en: Having your certificate signed requires a **certificate-signing request** (**CSR**)
    to be issued to a CA, which will return a signed certificate to be installed on
    your server. This implies a cost for your organization, which depends on how many
    certificates you request, the encryption strength, and other factors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的证书被签发需要向CA发出一个**证书签名请求**（**CSR**），CA将返回一个已签名的证书以安装到你的服务器上。这表明你的组织将产生一定的成本，这取决于你请求的证书数量、加密强度和其他因素。
- en: 'Firstly, generate a CSR using the newly created `keystore` and keyentry:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用新创建的`keystore`和密钥条目生成CSR：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will create a new certificate request named `certreq.csr`, bearing the
    following format:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`certreq.csr`的新证书请求，具有以下格式：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The previous certificate needs to be transmitted to the CA. At the end of the
    enrollment phase, the CA will return a signed certificate, which needs to be imported
    into your keychain. The following code assumes you saved your CA certificate in
    a file named `signed_ca.txt`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将之前的证书传输给CA。在注册阶段结束时，CA将返回一个已签名的证书，需要将其导入到你的密钥链中。以下代码假设你将CA证书保存在名为`signed_ca.txt`的文件中：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, your web browser will recognize your new certificate as being signed by
    a CA, so it won't complain about not being able to validate the certificate.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的网络浏览器将识别你的新证书是由CA签发的，因此它不会因为无法验证证书而抱怨。
- en: Securing EJB communication
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护 EJB 通信
- en: EJB clients interact with the Enterprise EJB tier using the RMI-IIOP protocol.
    The RMI-IIOP protocol has been developed by Sun to combine the RMI programming
    model with the IIOP underlying transport.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 客户端使用 RMI-IIOP 协议与企业 EJB 层交互。RMI-IIOP 协议是由 Sun 开发的，旨在将 RMI 编程模型与 IIOP 基础传输相结合。
- en: 'Securing the EJB transport is required for applications that have strict secure
    policies, which cannot be carried out using clear text transmission. In order
    to do this, we need to be sure to complete the following steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有严格安全策略的应用程序，需要保护 EJB 传输，这些策略不能使用明文传输执行。为了做到这一点，我们需要确保完成以下步骤：
- en: First, generate the SSL certificates and then store the client's public key
    in the server's `keystore` object and the server's public key on the client's
    `truststore;` we've already done this in order to prepare our HTTPS connector.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，生成 SSL 证书，然后将客户端的公钥存储在服务器的 `keystore` 对象中，并将服务器的公钥存储在客户端的 `truststore` 中；我们已经为此准备了
    HTTPS 连接器。
- en: Next, we need to create an SSL-aware security realm, which will be used by the
    `remoting` transport. We can use the one created for the HTTPS communication.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个支持 SSL 的安全域，该域将被 `remoting` 传输使用。我们可以使用为 HTTPS 通信创建的那个。
- en: Finally, we need to apply some changes to our EJB application so that it actually
    uses the SSL secure channel. We will cover this in the next subsection.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要对我们的 EJB 应用程序进行一些更改，以便它实际上使用 SSL 安全通道。我们将在下一小节中介绍这一点。
- en: Connecting to an SSL-aware security realm
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到支持 SSL 的安全域
- en: 'As you saw in [Chapter 3](part0023_split_000.html#page "Chapter 3. Introducing
    Java EE 7 – EJBs"), *Introducing Java EE 7 – EJBs*, the RMI-IIOP connection properties
    are specified in the `jboss-ejb-client.properties` file, which needs to be tweaked
    a bit to enable SSL connections:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 3 章](part0023_split_000.html#page "第 3 章。介绍 Java EE 7 – EJBs")中看到的，*介绍
    Java EE 7 – EJBs*，RMI-IIOP 连接属性在 `jboss-ejb-client.properties` 文件中指定，需要稍作调整以启用
    SSL 连接：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `SSL_ENABLED` option, when set to `true`, enables the `remoting` connector's
    SSL communication.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `SSL_ENABLED` 选项设置为 `true` 时，启用 `remoting` 连接器的 SSL 通信。
- en: The `STARTTLS` option specifies whether to use the **Tunneled Transport Layer
    Security** (**TTLS**) mode at startup or when needed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`STARTTLS` 选项指定在启动时或需要时是否使用 **Tunneled Transport Layer Security**（**TTLS**）模式。'
- en: The `SASL_POLICY_NOANONYMOUS` option specifies whether **Simple Authentication
    and Security Layer** (**SASL**) mechanisms, which accept anonymous logins, are
    permitted.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`SASL_POLICY_NOANONYMOUS` 选项指定是否允许 **Simple Authentication and Security Layer**（**SASL**）机制，这些机制接受匿名登录。'
- en: 'Finally, since our security realm also includes an authentication security
    domain, we can choose to restrict access to some methods by specifying a `@RolesAllowed`
    annotation, which requires the role `ejbRole`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们的安全域还包括一个身份验证安全域，我们可以选择通过指定一个 `@RolesAllowed` 注解来限制对某些方法的访问，该注解需要 `ejbRole`
    角色：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In order to activate the security domain on your EJBs, we need to mention it
    in the assembly descriptor of your `jboss-ejb3.xml` file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的 EJB 上激活安全域，我们需要在 `jboss-ejb3.xml` 文件的组装描述符中提及它：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, redeploy the Ticket EJB example application, following the directions contained
    in [Chapter 3](part0023_split_000.html#page "Chapter 3. Introducing Java EE 7
    – EJBs"), *Introducing Java EE 7 – EJBs*, and execute the client.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照 [第 3 章](part0023_split_000.html#page "第 3 章。介绍 Java EE 7 – EJBs")中包含的说明重新部署
    Ticket EJB 示例应用程序，并执行客户端。
- en: If the connection is successful, then you have configured a fully working and
    secured remoting connection.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接成功，那么你已经配置了一个完全工作且安全的远程连接。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by discussing the basic concepts of security and the
    difference between authentication and authorization.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时讨论了安全的基本概念以及身份验证和授权之间的区别。
- en: WildFly uses the PicketBox framework sitting on top of the **Java Authentication
    and Authorization Service** (**JAAS**), which secures all the Java EE technologies
    running in the application. The core section of the security subsystem is contained
    in the security-domain element that performs all the required **authorization**
    and **authentication** checks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 使用位于 **Java Authentication and Authorization Service**（**JAAS**）之上的
    PicketBox 框架，该框架保护应用程序中运行的所有 Java EE 技术。安全子系统的核心部分包含在执行所有必需的 **授权** 和 **身份验证**检查的
    security-domain 元素中。
- en: Then, we took a much closer look at the login modules, which are used to store
    the user credentials and their associated roles. In particular, you learned how
    to apply the file-based `UserRoles` login module and the `Database` login module.
    Each login module can be used by Enterprise applications in either a programmatic
    or declarative way. While programmatic security can provide a fine-grained security
    model, you should consider using declarative security, which allows a clean separation
    between the business layer and the security policies.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更仔细地研究了登录模块，这些模块用于存储用户凭据及其相关角色。特别是，你学习了如何应用基于文件的`UserRoles`登录模块和`Database`登录模块。每个登录模块都可以由企业应用程序以编程方式或声明方式使用。虽然编程安全可以提供细粒度的安全模型，但你应考虑使用声明式安全，这允许业务层和安全策略之间有一个清晰的分离。
- en: Finally, in the last section of this chapter, we covered how to encrypt the
    communication channel using the Secure Socket Layer and the certificates produced
    by the `keytool` Java utility.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章的最后部分，我们介绍了如何使用安全套接字层和由`keytool` Java实用程序生成的证书来加密通信通道。
- en: In the next chapter, we are going to discuss clustering, which is the environment
    where critical applications are deployed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论集群，这是关键应用程序部署的环境。
