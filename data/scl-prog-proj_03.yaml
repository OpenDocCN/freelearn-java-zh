- en: Handling Errors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: In this chapter, we will continue working on the retirement calculator that
    we implemented in [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*. Our calculator worked correctly as long as we passed
    the right arguments, but would fail badly with a horrible stack trace if any of
    the parameters were wrong. Our program only worked for what we call the *happy
    path*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续在 [第 2 章](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml) 中实现的退休计算器上进行工作，即
    *开发退休计算器*。只要我们传递了正确的参数，我们的计算器就能正常工作，但如果任何参数错误，它将产生糟糕的堆栈跟踪并严重失败。我们的程序只适用于我们所说的
    *快乐路径*。
- en: The reality of writing production software is that all kinds of error scenarios
    can occur. Some of them are recoverable, some of them must be presented to the
    user in an attractive way, and, for some hardware-related errors, we might need
    to let the program crash.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编写生产软件的现实是，可能会出现各种错误场景。其中一些是可恢复的，一些必须以吸引人的方式呈现给用户，而对于一些与硬件相关的错误，我们可能需要让程序崩溃。
- en: In this chapter, we will introduce exception handling, explain what referential
    transparency is, and try to convince you that exceptions are not the best way
    to deal with errors. Then, we will explain how to use functional programming constructs
    to effectively handle the possibility of an error.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍异常处理，解释引用透明性是什么，并试图说服您异常不是处理错误的最佳方式。然后，我们将解释如何使用函数式编程结构有效地处理错误的可能性。
- en: In each section, we will briefly introduce a new concept, and then use it in
    a Scala worksheet to get a sense of how to use it. After that, we will apply this
    new knowledge to improve the retirement calculator.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个部分中，我们将简要介绍一个新概念，然后在 Scala 工作表中使用它，以了解如何使用它。之后，我们将应用这些新知识来改进退休计算器。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Using exceptions when necessary
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在必要时使用异常
- en: Understanding referential transparency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解引用透明性
- en: Using `Option` to represent optional values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Option` 表示可选值
- en: Using `Either` to handle errors sequentially
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Either` 顺序处理错误
- en: Using `Validated` to handle errors in parallel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Validated` 并行处理错误
- en: Setup
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: If you have not completed [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*, then you can check out the retirement calculator project
    at GitHub. If you are not already familiar with Git, I would advise that you read
    the documents at [https://guides.github.com/introduction/git-handbook/](https://guides.github.com/introduction/git-handbook/) first.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未完成 [第 2 章](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml)，*开发退休计算器*，那么您可以在
    GitHub 上查看退休计算器项目。如果您还不熟悉 Git，我建议您首先阅读 [https://guides.github.com/introduction/git-handbook/](https://guides.github.com/introduction/git-handbook/)
    中的文档。
- en: 'To begin the setup, go through the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始设置，请按照以下步骤操作：
- en: Create an account at [https://github.com/](https://github.com/) if you do not
    have one already.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有账户，请在 [https://github.com/](https://github.com/) 上创建一个账户。
- en: Go to the retirement calculator project at [https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects).
    Click on Fork in the top-right corner to fork the project into your account.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往退休计算器项目 [https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects)。点击右上角的
    Fork 将项目分叉到您的账户中。
- en: Once the project is forked, click on Clone or download, and copy the URL into
    the clipboard.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目被分叉，点击 Clone 或下载，并将 URL 复制到剪贴板。
- en: 'In IntelliJ, go to File | New | Project from Version Control | GitHub and make
    the following edits:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 中，转到 File | New | Project from Version Control | GitHub 并进行以下编辑：
- en: Git repository URL**:** Paste the URL of your forked repository
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 仓库 URL**:** 粘贴您分叉仓库的 URL
- en: Parent directory**:** Choose a location
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父目录**:** 选择一个位置
- en: Directory name**:** Keep `retirement_calculator`
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录名称**:** 保持 `retirement_calculator`
- en: Click on Clone
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击 Clone
- en: 'The project should be imported in IntelliJ. Click on git: master in the bottom-right
    of the screen and select Remote branches | origin/chapter2 | Checkout as new local
    branch. Name the new branch `chapter3_yourusername` to distinguish it from the
    final solution, which is in the `origin/chapter3` branch.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '项目应该在 IntelliJ 中导入。点击屏幕右下角的 git: master，然后选择 Remote branches | origin/chapter2
    | Checkout as new local branch。将新分支命名为 `chapter3_yourusername` 以区分最终的解决方案，该解决方案位于
    `origin/chapter3` 分支中。'
- en: Build the project with *Ctrl* + *F9*. Everything should compile.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *F9* 构建 project。一切都应该编译成功。
- en: Using exceptions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异常
- en: 'Exceptions are one of the mechanisms that we can use in Scala to handle error
    scenarios. It consists of two statements:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是我们可以在Scala中使用的用于处理错误场景的机制之一。它由两个语句组成：
- en: The `throw exceptionObject` statement stops the current function and passes
    the exception up to the caller.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw exceptionObject`语句停止当前函数并将异常传递给调用者。'
- en: 'The `try { myFunc() } catch { case pattern1 => recoverExpr1 }` statement catches
    any exception thrown by `myFunc()` if the exception matches one of the patterns
    inside the `catch` block:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try { myFunc() } catch { case pattern1 => recoverExpr1 }`语句会捕获`myFunc()`抛出的任何异常，如果该异常与`catch`块内部的某个模式匹配：'
- en: If an exception is thrown by `myFunc`, but no pattern matches the exception,
    the function stops, and the exception is passed up to the caller again. If there
    is no `try...catch` block in the call chain that can catch the exception, the
    whole program stops.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`myFunc`抛出异常，但没有模式与该异常匹配，则函数停止，并将异常再次传递给调用者。如果没有`try...catch`块可以在调用链中捕获该异常，则整个程序停止。
- en: If an exception is thrown by `myFunc`, and the `pattern1` pattern matches the
    exception, the `try...catch` block will return the `recoverExpr1` expression at
    the right of the arrow.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`myFunc`抛出异常，并且`pattern1`模式与该异常匹配，则`try...catch`块将返回箭头右侧的`recoverExpr1`表达式。
- en: If no exception is thrown, the `try...catch` block returns the result returned
    by `myFunc()`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有抛出异常，则`try...catch`块返回`myFunc()`返回的结果。
- en: This mechanism comes from Java, and since the Scala SDK sits on top of the Java
    SDK, many function calls to the SDK can throw exceptions. If you are familiar
    with Java, the Scala exception mechanism differs slightly. Exceptions in Scala
    are always *unchecked*, which means that the compiler will never force you to
    catch an exception or declare that a function can throw an exception.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制来自Java，由于Scala SDK位于Java SDK之上，许多对SDK的函数调用可能会抛出异常。如果你熟悉Java，Scala的异常机制略有不同。Scala中的异常总是*未检查的*，这意味着编译器永远不会强制你捕获异常或声明一个函数可以抛出异常。
- en: Throwing exceptions
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'The following is a code snippet that demonstrates how exceptions can be thrown.
    You can paste it in the Scala console or in a Scala worksheet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段演示了如何抛出异常。你可以将其粘贴到Scala控制台或Scala工作表中：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `createPerson` function creates the `Person` object if the string passed
    in an argument is correct, but throws different types of exceptions if it is not.
    In the preceding code, we also implemented our own `AgeNegativeException` isntance,
    which is thrown if the age passed in the string is negative, as shown in the following
    code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`createPerson`函数如果传入的字符串参数正确，则创建`Person`对象，如果不正确，则抛出不同类型的异常。在前面的代码中，我们还实现了自己的`AgeNegativeException`实例，如果字符串中传递的年龄是负数，则会抛出，如下面的代码所示：'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the exceptions are not caught by any `try...catch` block, the Scala console
    shows a **stack trace**. The stack trace shows all the nested function calls that
    led to the point where the exception was thrown. In the last example, the `val
    age = split(1).toInt` line in `createPerson` called `scala.collection.immutable.StringOps.toInt`,
    which called `scala.collection.immutable.StringLike.toInt$`, and so on, until
    finally the `java.lang.Integer.parseInt` function threw the exception at line
    580 in `Integer.java`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异常没有被任何`try...catch`块捕获，Scala控制台显示了**堆栈跟踪**。堆栈跟踪显示了导致异常抛出的所有嵌套函数调用。在最后一个例子中，`createPerson`中的`val
    age = split(1).toInt`行调用了`scala.collection.immutable.StringOps.toInt`，它又调用了`scala.collection.immutable.StringLike.toInt$`，等等，直到最终在`Integer.java`的第580行`java.lang.Integer.parseInt`函数抛出了异常。
- en: Catching exceptions
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获异常
- en: 'In order to illustrate how exceptions bubble up the call stack, we are going
    to create a new `averageAge `function, which calculates the average age of a list
    of `Person `instances, using their string descriptions, as shown in the following
    code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明异常如何在调用栈中向上冒泡，我们将创建一个新的`averageAge`函数，该函数使用字符串描述计算`Person`实例列表的平均年龄，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function calls our previously implemented `createPerson `function, and
    therefore will throw any exception that is thrown by `createPerson` because there
    is no `try...catch` block in `averageAge`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用我们之前实现的`createPerson`函数，因此会抛出`createPerson`抛出的任何异常，因为在`averageAge`中没有`try...catch`块。
- en: 'Now, we can implement another function on top that will parse an input containing
    several `Person` descriptions and return a summary in a string. It will print
    an error message in case the input cannot be parsed, as shown in the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在上面实现另一个函数，该函数将解析包含多个`Person`描述的输入，并以字符串形式返回摘要。如果输入无法解析，它将打印错误信息，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this function, we declare an `avg` value, which will get the return value
    of `averageAge` if no exception is thrown. If one of the descriptions contains
    a negative age, our catch block will print an error message, and `avg` will be
    assigned the value of `0`. If another type of exception is thrown, and this exception
    is `NonFatal`, then we print another message and `avg` will also be assigned the
    value of `0`. A fatal exception is an exception that cannot be recovered, such
    as `OutOfMemoryException`. You can look at the implementation of `scala.util.control.NonFatal`
    for more details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们声明了一个`avg`值，如果没有抛出异常，它将获取`averageAge`的返回值。如果其中一个描述包含负年龄，我们的捕获块将打印错误信息，并将`avg`赋值为`0`。如果抛出了另一种类型的异常，并且这个异常是`NonFatal`，那么我们将打印另一条信息，并将`avg`也赋值为`0`。致命异常是无法恢复的异常，例如`OutOfMemoryException`。你可以查看`scala.util.control.NonFatal`的实现以获取更多详细信息。
- en: 'The following code shows a few sample calls to `personsSummary`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`personsSummary`的一些示例调用：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, as soon as any of the descriptions cannot be parsed, an error
    is printed and the average age is set to `0`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，一旦任何描述无法解析，就会打印错误信息，并将平均年龄设置为`0`。
- en: Using the finally block
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用finally块
- en: A `try...catch` block can optionally be followed by a `finally {}` block. The
    code inside the `finally` block is always executed, even if an exception is not
    matched by any pattern in the `catch` block. The `finally` block is typically
    used to close any resource that is accessed inside the `try` block, such as a
    file or a network connection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`try...catch`块可以可选地跟一个`finally {}`块。`finally`块中的代码总是被执行，即使`catch`块中没有匹配任何模式。`finally`块通常用于关闭在`try`块中访问的任何资源，例如文件或网络连接。'
- en: 'The following code shows how to use a URL to read a web page into a string:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用URL将网页读入字符串：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `finally` block allows us to close `InputStream`, whether the reading of
    the page succeeded or not. This way, we will not leave a dangling open connection
    in case there is a network issue or a thread interruption.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块允许我们在页面读取成功与否的情况下关闭`InputStream`。这样，如果存在网络问题或线程中断，我们不会留下悬挂的打开连接。'
- en: 'Note that the preceding code is for illustrative purposes only. In a real project,
    you should use the following code format:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码仅用于说明目的。在实际项目中，你应该使用以下代码格式：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you know how to use exceptions, we are going to define the concept
    of referential transparency and show how catching exceptions can break it. We
    will then explore better data structures that will let us manage errors without
    breaking referential transparency.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用异常，我们将定义引用透明的概念，并展示如何捕获异常可以破坏它。然后我们将探索更好的数据结构，这将使我们能够在不破坏引用透明性的情况下管理错误。
- en: Ensuring referential transparency
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保引用透明性
- en: We say that an expression is **referentially transparent** when it can be replaced
    by its value without changing the program's behavior, in any context. When an
    expression is a function call, it means that we can always substitute this function
    call with the return value of the function. A function that guarantees this in
    any context is called a **pure function**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式可以被其值替换而不改变程序的行为时，我们称其为**引用透明**。当一个表达式是一个函数调用时，这意味着我们可以总是用函数的返回值替换这个函数调用。在任何上下文中都能保证这一点的函数被称为**纯函数**。
- en: A pure function is like a mathematical function—the return value depends only
    on the arguments passed to the function. You do not have to consider anything
    else about the context in which it is called.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数就像数学函数一样——返回值只依赖于传递给函数的参数。你不需要考虑任何其他关于它被调用的上下文。
- en: Defining pure functions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义纯函数
- en: 'In the following code,  the `pureSquare` function is pure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`pureSquare`函数是纯函数：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The functions called `pureSquare(4)` and `pureSquare(3)` are referentially transparent—when
    we replace them with the return value of the function, the program's behavior
    does not change.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的函数`pureSquare(4)`和`pureSquare(3)`是引用透明的——当我们用函数的返回值替换它们时，程序的行为不会改变。
- en: 'On the other hand, the following function is impure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下函数是不纯的：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We cannot replace the call to `impure(3)` with its return value because the
    return value changes depending on the context. In fact, any function that has
    **side effects** is impure. A side effect can be any of the following constructs:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能用 `impure(3)` 的返回值来替换其调用，因为返回值会根据上下文而变化。实际上，任何具有**副作用**的函数都是不纯的。副作用可以是以下任何一种结构：
- en: Mutating a global variable
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改全局变量
- en: Printing to the console
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向控制台打印
- en: Opening a network connection
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开网络连接
- en: Reading/writing data to/from a file
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件读取/写入数据
- en: Reading/writing data to/from a database
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库读取/写入数据
- en: More generally, any interaction with the outside world
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更普遍地，任何与外部世界的交互
- en: 'The following is another example of an impure function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个不纯函数的例子：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You cannot substitute the result of `impureRand()` with its value because the
    value changes for every call. If you do so, the program's behavior changes. The
    call to `impureRand()` is not referentially transparent, and hence `impureRand`
    is impure. In fact, the `random()` function mutates a global variable to generate
    a new random number for every call. We can also say that this function is **nondeterministic**—we
    cannot predict its return value just by observing its arguments.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 `impureRand()` 的结果替换为其值，因为每次调用时值都会变化。如果你这样做，程序的行为会改变。`impureRand()` 的调用不是引用透明的，因此
    `impureRand` 是不纯的。实际上，`random()` 函数每次调用都会修改一个全局变量以生成一个新的随机数。我们也可以说这个函数是**非确定性的**——我们仅通过观察其参数无法预测其返回值。
- en: 'We can rewrite our impure function to make it pure, as shown in the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写我们的不纯函数，使其成为纯函数，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can substitute the call to `pureRand(seed)` with its value; the function
    will always return the same value given the same seed. The call to `pureRand`
    is referentially transparent, and `pureRand` is a pure function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `pureRand(seed)` 的值替换其调用；给定相同的种子，该函数总是会返回相同的值。`pureRand` 的调用是引用透明的，因此 `pureRand`
    是一个纯函数。
- en: 'The following is another example of an impure function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个不纯函数的例子：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the second example, the return value of `impurePrint` is of the `Unit `type.
    There is only one value of this type in the Scala SDK: the `()`value. If we replace
    the call to `impurePrint()` with `()`, then the program''s behavior changes—in
    the first case, something will be printed on the console, but not in the second
    case.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，`impurePrint` 函数的返回值是 `Unit` 类型。在 Scala SDK 中，这种类型的值只有一个：`()` 值。如果我们用
    `()` 替换对 `impurePrint()` 的调用，那么程序的行为会改变——在第一种情况下，会在控制台上打印一些内容，但在第二种情况下则不会。
- en: Best practices
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Referential transparency is a key concept in functional programming. If most
    of your program uses pure functions, then it becomes much easier to do the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性是函数式编程中的一个关键概念。如果你的程序大部分使用纯函数，那么以下操作会变得容易得多：
- en: '**Understand what a program is doing:** You know that the function''s return
    value only depends on its arguments. You do not have to think about what the state
    of this or that variable is in this or that context. You just have to look at
    the arguments.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解程序在做什么**：你知道函数的返回值只依赖于其参数。你不必考虑在这个或那个上下文中这个或那个变量的状态。你只需看看参数。'
- en: '**Test your functions:** I will restate this point—the function''s return value
    only depends on its argument. Testing it is very simple; you can try different
    argument values and confirm that the return value is what you expect.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试你的函数**：我将重申这一点——函数的返回值只依赖于其参数。测试它非常简单；你可以尝试不同的参数值，并确认返回值是你预期的。'
- en: '**Write multithreaded programs:** Since a pure function''s behavior does not
    depend on a global state, you can execute it in parallel on multiple threads or
    even on different machines. The return values will not change. As our CPUs are
    built with more and more cores these days, this will help you write faster programs.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写多线程程序**：由于纯函数的行为不依赖于全局状态，你可以在多个线程甚至不同的机器上并行执行它。返回值不会改变。随着我们今天构建的 CPU 越来越多核心，这将帮助你编写更快的程序。'
- en: However, it is not possible to only have pure functions in a program because,
    in essence, a program must interact with the outside world. It has to print something,
    read some user input, or save some state in a database. In functional programming,
    the best practice is to use pure functions in the majority of the code base and
    to push the impure side-effecting functions to the boundaries of the program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在程序中只使用纯函数是不可能的，因为本质上，程序必须与外界交互。它必须打印某些内容，读取一些用户输入，或将某些状态保存到数据库中。在函数式编程中，最佳实践是在大多数代码库中使用纯函数，并将不纯的副作用函数推到程序的边界。
- en: For instance, in [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*, we implemented a retirement calculator that mostly uses
    pure functions. One side-effecting function was the `println` call in the `SimulatePlanApp`
    object, which was at the boundaries of the program. There were other side effects
    in `EquityData.fromFile` and `InflationData.fromFile`; these functions are for
    reading files. However, the resource files can never change for the duration of
    the program. For a given filename, we would always get the same file content,
    and we could substitute the return value of `fromFile` in all calls without changing
    the program's behavior. In this case, the side effect of reading a file is not
    observable, and we can consider theses file-reading functions as being pure. Another
    side-effecting function was `strMain` because it could throw exceptions. In the
    rest of this chapter, we will see why throwing exceptions break referential transparency,
    and we will learn how to replace it with better functional programming structures.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第2章](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml)，“开发退休计算器”，我们实现了一个主要使用纯函数的退休计算器。其中一个副作用函数是`SimulatePlanApp`对象中的`println`调用，它在程序的边界上。`EquityData.fromFile`和`InflationData.fromFile`中也有其他副作用；这些函数用于读取文件。然而，资源文件在程序运行期间永远不会改变。对于给定的文件名，我们总是会得到相同的内容，并且我们可以替换所有调用中的`fromFile`的返回值，而不改变程序的行为。在这种情况下，读取文件的副作用是不可观察的，我们可以将这些文件读取函数视为纯函数。另一个副作用函数是`strMain`，因为它可以抛出异常。在本章的其余部分，我们将看到为什么抛出异常会破坏引用透明性，我们将学习如何用更好的函数式编程结构来替换它。
- en: 'An impure function fulfills the following two criteria:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不纯函数满足以下两个标准：
- en: It returns `Unit`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回`单位`。
- en: It does not take any arguments but returns a type. Since it returns something
    that cannot be obtained by using its arguments, it must be using a global state.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不接受任何参数，但返回一个类型。由于它返回的内容无法通过其参数获得，它必须使用全局状态。
- en: 'Note that a pure function can use mutable variables or side effects inside
    the body of the function. As long as these effects are *not observable* by the
    caller, we consider the function pure. In the Scala SDK, many pure functions are
    implemented using mutable variables to improve performance. Look, for the instance,
    at the following implementation of `TraversableOnce.foldLeft`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，纯函数可以在函数体内使用可变变量或副作用。只要这些效果对调用者来说是*不可观察的*，我们就认为该函数是纯的。在Scala SDK中，许多纯函数都是使用可变变量实现的，以提高性能。看看以下`TraversableOnce.foldLeft`的实现：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Showing how exceptions break referential transparency
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示异常如何破坏引用透明性
- en: 'This might not seem obvious, but when a function throws an exception, it breaks
    referential transparency. In this section, I am going to show you why. First,
    create a new Scala worksheet and type the following definitions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不明显，但当函数抛出异常时，它会破坏引用透明性。在本节中，我将向您展示原因。首先，创建一个新的Scala工作表，并输入以下定义：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we will call `area` with the following arguments:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下参数调用`area`：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We get `total: Double = 14.0`. In the preceding code, the `area1` and `area2` expressions
    are referentially transparent. We can indeed *substitute* them with their value
    without changing the program''s behavior. In IntelliJ, select the `area1` variable inside
    the `try` block and hit *Ctrl* + *Alt* + *N* (inline variable), as shown in the
    following code. Do the same for `area2`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '我们得到`total: Double = 14.0`。在上面的代码中，`area1`和`area2`表达式是引用透明的。我们确实可以*替换*它们而不改变程序的行为。在IntelliJ中，选择`try`块内的`area1`变量，然后按*Ctrl*
    + *Alt* + *N*（内联变量），如下所示。对`area2`也做同样的操作：'
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `total` is the same as before. The program''s behavior did not change,
    hence `area1` and `area2` are referentially transparent. However, let''s see what
    happens if we define `area1` in the following way:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`total`与之前相同。程序的行为没有改变，因此`area1`和`area2`是引用透明的。然而，让我们看看如果我们以以下方式定义`area1`会发生什么：'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, we get `java.lang.IllegalArgumentException: too big`, because
    our `area(...)` function throws an exception when the width is greater than five.
    Now let''s see what happens if we inline `area1` and `area2` as before, as shown
    in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们会得到`java.lang.IllegalArgumentException: too big`，因为我们的`area(...)`函数在宽度大于五时抛出异常。现在让我们看看如果我们像之前一样内联`area1`和`area2`会发生什么，如下面的代码所示：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case, we get `total: Double = 0.0`. The program''s behavior changed
    when substituting `area1` with its value, hence `area1` is *not* referentially
    transparent.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们得到`total: Double = 0.0`。当用其值替换`area1`时，程序的行为发生了变化，因此`area1`不是引用透明的。'
- en: We demonstrated that exception handling breaks referential transparency, and
    hence functions that throw exceptions are impure. It makes a program more difficult
    to understand because you have to take into account *where* a variable is defined
    to understand how the program will behave. The behavior will change depending
    on whether a variable is defined inside or outside a `try` block. This might not
    seem to be a big deal in a trivial example, but when there are multiple chained
    function calls with `try` blocks along the line, matching different types of exceptions,
    it can become daunting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明了异常处理会破坏引用透明性，因此抛出异常的函数是不纯的。这使得程序更难以理解，因为你必须考虑变量在哪里定义来了解程序将如何运行。行为将根据变量是在`try`块内还是外定义而改变。这在一个简单的例子中可能不是什么大问题，但当存在多个带有`try`块的链式函数调用，并匹配不同类型的异常时，可能会变得令人望而生畏。
- en: 'Another disadvantage when you use exceptions is that the *signature* of the
    function does not indicate that it can throw an exception. When you call a function
    that can throw exceptions, you have to look at its implementation to figure out
    what type of exception it can throw, and under what circumstances. If the function
    calls other functions, it compounds the problem. You can accommodate this by adding
    comments or an `@throws` annotation to indicate what exception types can be thrown,
    but these can become outdated when the code is refactored. When we call a function,
    we should only have to consider its signature. A signature is a bit like a contract—given
    these arguments, I will return you a result. If you have to look at the implementation
    to know what exceptions are thrown, it means that the contract is not completed:
    some information is hidden.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用异常时，另一个缺点是函数的*签名*并没有表明它可以抛出异常。当你调用一个可能抛出异常的函数时，你必须查看其实现来了解它可以抛出什么类型的异常，以及在什么情况下。如果函数调用了其他函数，问题会变得更加复杂。你可以通过添加注释或`@throws`注解来指明可能抛出的异常类型，但这些在代码重构时可能会过时。当我们调用一个函数时，我们只需要考虑其签名。签名有点像一份合同——给定这些参数，我会返回一个结果。如果你必须查看实现来了解抛出了哪些异常，这意味着合同尚未完成：有些信息被隐藏了。
- en: 'We now know how to throw and catch exceptions, and why we should use them with
    caution. The best practice is to do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何抛出和捕获异常，以及为什么我们应该谨慎使用它们。最佳实践是执行以下操作：
- en: Catch recoverable exceptions as early as possible, and indicate the possibility
    of failure with a specific return type.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽早捕获可恢复的异常，并使用特定的返回类型来指示失败的可能性。
- en: Not catch exceptions that cannot be recovered, such as disk full, out of memory,
    or some other catastrophic failure. This will make your program crash whenever
    such exceptions happen, and you should then have a manual or automatic recovery
    process outside the program.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要捕获无法恢复的异常，例如磁盘空间不足、内存不足或其他灾难性故障。这样，每当发生此类异常时，你的程序都会崩溃，你应该在程序外部有一个手动或自动的恢复过程。
- en: In the rest of this chapter, I will show you how to use the `Option`, `Either`,
    and `Validated` classes to model the possibility of a failure.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将向你展示如何使用`Option`、`Either`和`Validated`类来模拟失败的可能性。
- en: Using Option
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Option
- en: The Scala `Option` type is an **algebraic data type** (**ADT**) that represents
    an optional value. It can also be viewed as `List` that can contain either one
    or no elements. It is a safe replacement for a `null` reference that you might
    have used if you have programmed in Java, C++, or C#.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的 `Option` 类型是一个 **代数数据类型**（**ADT**），它表示一个可选值。它也可以被视为可以包含一个或零个元素的 `List`。它是您在
    Java、C++ 或 C# 编程时可能使用的 `null` 引用的安全替代品。
- en: Manipulating instances of Option
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作 `Option` 实例
- en: 'The following is a simplified definition of the `Option` ADT:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `Option` ADT 的简化定义：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Scala SDK provides a more refined implementation; the preceding definition
    is just for illustrative purpose. This definition implies that `Option` can be
    either of the following two types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Scala SDK 提供了一个更精细的实现；前面的定义只是为了说明目的。这个定义意味着 `Option` 可以是以下两种类型之一：
- en: '`Some(value)`, which represents an optional value where the value is present'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some(value)`，表示一个可选值，其中值存在'
- en: '`None`, which represents an optional value where the value is not present.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`，表示一个可选值，其中值不存在。'
- en: The `+` sign in front of the `A` type parameter in the `Option[+A]` declaration
    means that `Option` is covariant in `A`. We will explore contravariance in more
    details in [Chapter 4](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml), *Advanced
    Features*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Option[+A]` 声明中 `A` 类型参数前面的 `+` 符号表示 `Option` 在 `A` 上是协变的。我们将在第 4 章 [高级特性](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml)中更详细地探讨逆变。
- en: For now, you just have to know that if `B` is a subtype of `A`, then `Option[B]`
    is a subtype of `Option[A]`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您只需知道如果 `B` 是 `A` 的子类型，那么 `Option[B]` 就是 `Option[A]` 的子类型。
- en: Furthermore, you might notice that `None` actually extends `Option[Nothing]`
    and not `Option[A]`. This is because a case object cannot accept a type parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能会注意到 `None` 实际上扩展了 `Option[Nothing]` 而不是 `Option[A]`。这是因为一个案例对象不能接受类型参数。
- en: In Scala, `Nothing` is the bottom type, which means that it is a subtype of
    any other type.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，`Nothing` 是最低类型，这意味着它是任何其他类型的子类型。
- en: This implies that `None` is a subtype of `Option[A]` for any `A`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于任何 `A`，`None` 都是 `Option[A]` 的子类型。
- en: 'The following are some examples of the usage of the different types of `Option`
    that you can paste in a Scala worksheet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用不同类型 `Option` 的示例，您可以将它们粘贴到 Scala 工作表中：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Explanation of the preceding code is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的解释如下：
- en: The first two examples show how we can define an `Option` type that can optionally
    contain `Int`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个示例展示了我们如何定义一个可选包含 `Int` 的 `Option` 类型。
- en: The following examples use the `headOption` and `lastOption` methods in `List`
    to show that many safe functions of the SDK return `Option`. If `List` is empty,
    these functions always return `None`. Note that the SDK also provides *unsafe*
    equivalent `head` and `last `methods. The unsafe methods throw an exception if
    we call them with an empty `List`, which might crash our program if we do not
    catch the exception.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下示例使用 `List` 中的 `headOption` 和 `lastOption` 方法来展示 SDK 的许多安全函数返回 `Option`。如果
    `List` 为空，这些函数总是返回 `None`。请注意，SDK 还提供了等效的 *危险* `head` 和 `last` 方法。如果用空 `List`
    调用这些危险方法，它们会抛出异常，如果我们没有捕获异常，这可能会使我们的程序崩溃。
- en: Many functions of the SDK provide equivalent safe (which return `Option`) and
    unsafe functions (which throw an exception). It is a best practice to always use
    the safe alternative.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 的许多函数提供了等效的安全（返回 `Option`）和危险（抛出异常）函数。始终使用安全替代方案是一种最佳实践。
- en: 'Since `Option` is an ADT, we can use pattern matching to test whether `Option`
    is `None` or `Some`, as shown in the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Option` 是一个 ADT，我们可以使用模式匹配来测试 `Option` 是 `None` 还是 `Some`，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `get(key)`method in `Map` returns `Option`, containing the value associated
    with the key. If the key does not exist in `Map`, it returns `None`. When you
    start using `Option`, pattern matching is the most natural way of triggering different
    behaviors depending on the content of `Option`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 中的 `get(key)` 方法返回 `Option`，包含与键关联的值。如果键不在 `Map` 中，它返回 `None`。当您开始使用
    `Option` 时，模式匹配是根据 `Option` 的内容触发不同行为的最自然方式。'
- en: 'Another way is to use `map` and `getOrElse`, as shown in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `map` 和 `getOrElse`，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We saw earlier how to transform the elements of a vector using `map`. This works
    exactly the same for `Option`—we pass an anonymous function that will be called
    with the option's value if `Option` is not empty. Since our anonymous function
    returns a string, we obtain `Option[String]`. We then call `getOrElse`, which
    provides a value in case `Option` is `None`. The `getOrElse `phrase is a good
    way to safely extract the content of `Option`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到如何使用`map`转换向量的元素。这对于`Option`也是完全相同的——我们传递一个匿名函数，如果`Option`不为空，它将被调用。由于我们的匿名函数返回一个字符串，我们得到`Option[String]`。然后我们调用`getOrElse`，它提供了一个值，以防`Option`是`None`。`getOrElse`短语是一种安全提取`Option`内容的好方法。
- en: Never use the `.get` method on `Option`—always use `.getOrElse`. The `.get`
    method throws an exception if `Option` is `None`, and hence is not safe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在`Option`上使用`.get`方法——始终使用`.getOrElse`。如果`Option`是`None`，`.get`方法会抛出异常，因此它是不安全的。
- en: Composing transformations with for... yield
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用for...yield组合转换
- en: 'Using the same `db: Map[String, Int]` phrase, containing the ages of different
    people, the following code is a naive implementation of a function that returns
    the average age of two people:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '使用相同的`db: Map[String, Int]`短语，包含不同人的年龄，以下代码是一个返回两个人平均年龄的函数的简单实现：'
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function returns `Option[Double]`. If `name1` or `name2` cannot be found
    in the `db` map, `averageAge` returns `None`. If both names are found, it returns
    `Some(value)`. The implementation uses `map` to transform the value contained
    in the option. We end up with a nested `Option[Option[Double]]`, but our function
    must return `Option[Double]`. Fortunately, we can use `flatten` to remove one
    level of nesting.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回`Option[Double]`。如果`name1`或`name2`在`db`映射中找不到，`averageAge`返回`None`。如果两个名字都找到了，它返回`Some(value)`。实现使用`map`来转换选项中包含的值。我们最终得到一个嵌套的`Option[Option[Double]]`，但我们的函数必须返回`Option[Double]`。幸运的是，我们可以使用`flatten`来移除一层嵌套。
- en: 'We managed to implement `averageAge`, but we can improve it using `flatMap`,
    as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功实现了`averageAge`，但我们可以使用`flatMap`来改进它，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As its name suggests, `flatMap` is equivalent to composing `flatten` and `map`.
    In our function, we replaced `map(...).flatten` with `flatMap(...)`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`flatMap`相当于组合`flatten`和`map`。在我们的函数中，我们将`map(...).flatten`替换为`flatMap(...)`。
- en: 'So far, so good, but what if we want to get the average age of three or four
    people? We would have to nest several instances of `flatMap`, which would not
    be very pretty or readable. Fortunately, Scala provides a syntactic sugar that
    allows us to simplify our function further, called the `for` comprehension, as
    shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但如果我们想得到三或四人的平均年龄怎么办？我们就必须嵌套多个`flatMap`实例，这不会很漂亮或易于阅读。幸运的是，Scala提供了一个语法糖，允许我们进一步简化我们的函数，称为`for`推导式，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you compile a `for` comprehension, such as `for { ... } yield { ... }`,
    the Scala compiler transforms it into a composition of `flatMap`/`map` operations.
    Here is how it works:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译一个`for`推导式，例如`for { ... } yield { ... }`时，Scala编译器将其转换为`flatMap`/`map`操作的组合。以下是它是如何工作的：
- en: Inside the `for` block, there can be one or many expressions phrased as `variable
    <- context`, which is called a **generator**. The left side of the arrow is the
    name of a variable that is bound to the content of the **context** on the right
    of the arrow.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`for`块内部，可以有一个或多个表达式以`variable <- context`的形式表达，这被称为**生成器**。箭头的左侧是绑定到箭头右侧**上下文**内容的变量的名称。
- en: Every generator except the last one is transformed into a `flatMap` expression.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了最后一个生成器之外，每个生成器都被转换为一个`flatMap`表达式。
- en: The last generator is transformed into a `map` expression.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个生成器被转换为一个`map`表达式。
- en: All context expressions (the right side of the arrow) must have the same context
    type.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有上下文表达式（箭头的右侧）必须具有相同的上下文类型。
- en: 'In the preceding example, we used `Option` for the context type, but `for yield`
    can also be used with any class that has a `flatMap` and `map` operation. For
    instance, we can use `for..yield` with `Vector` to run nested loops, as shown
    in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`Option`作为上下文类型，但`for yield`也可以与任何具有`flatMap`和`map`操作的类一起使用。例如，我们可以使用`for..yield`与`Vector`一起运行嵌套循环，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Syntactic sugar** is syntax within a programming language that makes it easier
    to read or write. It makes it sweeter for the programmer.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法糖**是编程语言中的语法，它使得阅读或编写更容易。它让程序员感到更甜蜜。'
- en: Refactoring the retirement calculator to use Option
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将退休计算器重构为使用Option
- en: Now that we know what `Option` can do for us, we are going to refactor one of
    the functions of the retirement calculator that we developed in [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*, to improve the handling of some edge-case scenarios.
    If you have not done it yet, please follow the instructions at the beginning of
    the [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing a Retirement
    Calculator*, to set up the project.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`Option`能为我们做什么，我们将重构我们在[第2章](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml)，“开发退休计算器”中开发的退休计算器的一个函数，以改进对一些边缘情况的处理。如果你还没有做，请按照[第2章](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml)，“开发退休计算器”开头的说明来设置项目。
- en: In `RetCalc.scala`, we are going to change the return type of `nbMonthsSaving`.
    In [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing a Retirement
    Calculator*, we returned `Int.MaxValue` if `netIncome <= currentExpense` to avoid
    looping infinitely. This was not very robust, as this infinite result could then
    be used in another computation, which would lead to bogus results. It would be
    better to return `Option[Int]` to indicate that the function might not be computable
    and let the caller decide what to do. We would return `None` if it was not computable
    or `Some(returnValue)` if it was computable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RetCalc.scala`中，我们将更改`nbMonthsSaving`的返回类型。在[第2章](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml)，“开发退休计算器”中，如果`netIncome
    <= currentExpense`，我们返回`Int.MaxValue`以避免无限循环。这并不十分健壮，因为这个无限的结果可能会被用于另一个计算，从而导致错误的结果。最好是返回`Option[Int]`来表示该函数可能不可计算，并让调用者决定如何处理。如果不可计算，我们将返回`None`，如果可计算，则返回`Some(returnValue)`。
- en: 'The following code is the new implementation for `nbMonthsSaving`, with the
    changed portions highlighted in bold:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`nbMonthsSaving`的新实现，其中更改的部分以粗体突出显示：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now try to compile the project. This change breaks many parts of our project,
    but the Scala compiler is a terrific assistant. It will help us identify the portions
    of the code we need to change to make our code more robust.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试编译项目。这个更改破坏了我们项目的许多部分，但Scala编译器是一个出色的助手。它将帮助我们识别需要更改的代码部分，以使我们的代码更加健壮。
- en: 'The first error is in `RetCalcSpec.scala`, as shown in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误在`RetCalcSpec.scala`中，如下所示：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This error means that the types in the `actual should === (expected)` expression
    do not match: `actual` is of the `Option[Int]0` type, whereas `expected` is of
    the `Int` type. We need to change the assertion, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误意味着在`actual should === (expected)`表达式中，类型不匹配：`actual`是`Option[Int]0`类型，而`expected`是`Int`类型。我们需要更改断言，如下所示：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can apply the same fix for the second unit test. For the last unit test,
    we want to assert that `None` is returned instead of `Int.MaxValue`, as shown
    in the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将相同的修复应用于第二个单元测试。对于最后一个单元测试，我们希望断言返回`None`而不是`Int.MaxValue`，如下所示：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can now compile and run the test. It should pass.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以编译并运行测试。它应该通过。
- en: You are now able to model an optional value safely. However, sometimes it is
    not always obvious to know what `None` actually means. Why did this function return `None`?
    Was it because the arguments that were passed were wrong? Which argument was wrong?
    And what value would be correct? It would indeed be nice to have some explanation
    that comes along with the `None` in order to understand *why* there was no value.
    In the next section, we are going to use the `Either` type for this purpose.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你能够安全地模拟一个可选值。然而，有时并不总是很明显知道`None`实际上意味着什么。为什么这个函数返回`None`？是因为传递的参数错误吗？哪个参数错误？什么值才是正确的？确实很希望有一些解释与`None`一起出现，以便理解*为什么*没有值。在下一节中，我们将使用`Either`类型来实现这个目的。
- en: Using Either
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Either`
- en: 'The `Either` type is an ADT that represents a value of either a `Left` type
    or a `Right` type. A simplified definition of `Either` would be the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`类型是一个ADT，表示一个`Left`类型或`Right`类型的值。`Either`的一个简化定义如下：'
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you instantiate a `Right` type, you need to provide a value of a `B` type,
    and when you instantiate a `Left` type, you need to provide a value of an `A` type.
    Therefore, `Either[A, B]` can either hold a value of type `A` or a value of type
    `B`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化一个`Right`类型时，你需要提供一个`B`类型的值，当你实例化一个`Left`类型时，你需要提供一个`A`类型的值。因此，`Either[A,
    B]`可以持有`A`类型的值或`B`类型的值。
- en: 'The following code shows an example of such a usage that you can type in a
    new Scala worksheet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了你可以在一个新的Scala工作表中输入的此类用法示例：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `divide` function returns either a string or a double:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`divide`函数返回字符串或双精度浮点数：'
- en: If the function cannot compute a value, it returns an error `String` wrapped
    in a `Left` type
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数无法计算值，它将返回一个被`Left`类型包裹的`String`错误。
- en: If the function can compute a correct value, it returns the `Double` value wrapped
    in a `Right` type
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数可以计算正确的值，它将返回被`Right`类型包裹的`Double`值。
- en: By convention, we use `Right` to represent the correct or right value, and we
    use `Left` to represent an error.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们使用`Right`来表示正确或右侧的值，而使用`Left`来表示错误。
- en: Manipulating Either
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作`Either`
- en: Since `Either` is an ADT, we can use pattern matching to decide what to do when
    we get a `Left` or `Right` type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Either`是一个ADT，我们可以使用模式匹配来决定在得到`Left`或`Right`类型时该做什么。
- en: 'The following is a modified version of the `personDescription` function that
    we showed earlier in the *Using Option* section:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是我们在*使用Option*部分中展示的`personDescription`函数的修改版本：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first `getPersonAge `function produces `Right(age)` if the `name `argument is
    present in `db`. If `name` is not present in `db`, it returns an error message
    wrapped in a `Left` type. For this purpose, we use the `Option.toRight `method.
    I encourage you to have a look at the documentation and implementation of this
    method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`getPersonAge`函数如果`name`参数在`db`中存在，则产生`Right(age)`。如果`name`不在`db`中，它将返回一个被`Left`类型包裹的错误信息。为此，我们使用`Option.toRight`方法。我鼓励你查看该方法的文档和实现。
- en: The implementation of `personDescription` is straightforward—we pattern match
    using the result of `getPersonAge` and return an appropriate `String` depending
    on whether the result is a `Left` or `Right` type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`personDescription`的实现很简单——我们使用`getPersonAge`的结果进行模式匹配，并根据结果是否为`Left`或`Right`类型返回适当的`String`。'
- en: 'As with `Option`, we can also use `map` and `flatMap` to combine several instances
    of `Either`, as shown in the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Option`一样，我们也可以使用`map`和`flatMap`来组合多个`Either`实例，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note how the body of the function is almost the same as `Option`. This is because
    `Either` is **right biased**, meaning that `map` and `flatMap` transform the right
    side of `Either`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数体几乎与`Option`相同。这是因为`Either`是**右偏的**，意味着`map`和`flatMap`将`Either`的右侧进行转换。
- en: 'If you want to transform the `Left` side of `Either`, you need to call the
    `Either.left `method, as shown in the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要转换`Either`的`Left`侧，你需要调用`Either.left`方法，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since `Either` implements `map` and `flatMap`, we can refactor `averageAge`
    to use a `for` comprehension, as shown in the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Either`实现了`map`和`flatMap`，我们可以重构`averageAge`以使用`for`推导式，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, the code looks the same as it did with `Option`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，代码看起来和用`Option`时一样。
- en: Refactoring the retirement calculator to use Either
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构退休计算器以使用`Either`
- en: Now that we have a good understanding of how to manipulate `Either`, we are
    going to refactor our retirement calculator to take advantage of it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了如何操作`Either`，我们将重构我们的退休计算器以利用它。
- en: Refactoring nbOfMonthsSavings
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构`nbOfMonthsSavings`
- en: In the previous section, we changed the return type of `nbOfMonthsSavings` to
    return `Option[Int]`. The function returned `None` if the `expenses` arguments were greater
    than `income`. We are now going to change it to return an error message wrapped
    in `Left`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们将`nbOfMonthsSavings`的返回类型更改为返回`Option[Int]`。如果`expenses`参数大于`income`，函数返回`None`。我们现在将其更改为返回被`Left`包裹的错误信息。
- en: 'We could use a simple string for our error message, but the best practice when
    using `Either` is to create an ADT for all of the possible error messages. Create
    a new Scala class in `src/main/scala/retcalc` called `RetCalcError`, as shown
    in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的字符串作为错误信息，但使用`Either`时的最佳实践是为所有可能的错误信息创建一个ADT。在`src/main/scala/retcalc`中创建一个新的Scala类`RetCalcError`，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We define a `RetCalcError` trait that has only one `message `method. This method
    will produce the error message whenever we need to return it to the user. Inside
    the `RetCalcError `object, we define one case class per type of error message.
    We will then change the functions that need to return an error to return `Either[RetCalcError,
    A]`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个只有`message`方法的`RetCalcError`特质。此方法将在我们需要将错误信息返回给用户时产生错误信息。在`RetCalcError`对象内部，我们为每种错误信息类型定义一个case类。然后我们将需要返回错误的函数更改为返回`Either[RetCalcError,
    A]`。
- en: 'This pattern has many advantages over just using `String`, as shown in the
    following list:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅使用`String`相比，这种模式具有许多优点，如下面的列表所示：
- en: All of the error messages are located in one place. It allows you to immediately
    know what are all the possible error messages that can be returned to the user.
    You could also add different translations if your application uses multiple languages.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的错误消息都位于一个地方。这允许你立即知道所有可能的错误消息，这些错误消息可以返回给用户。如果你的应用程序使用多种语言，你也可以添加不同的翻译。
- en: Since `RetCalcError` is an ADT, you can use pattern matching to recover from
    a specific error and take action.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`RetCalcError`是一个ADT（抽象数据类型），你可以使用模式匹配从特定错误中恢复并采取行动。
- en: It simplifies testing. You can test whether a function returns a specific type
    of error without having to assert on the error message itself. This way, you can
    change your error messages without having to change any test.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它简化了测试。你可以测试一个函数是否返回特定类型的错误，而无需断言错误消息本身。这样，你可以在不更改任何测试的情况下更改错误消息。
- en: 'Now we can refactor our `RetCalc.nbOfMonthsSavings `function to return `Either[RetCalcError,
    Int]`, as shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新整理我们的`RetCalc.nbOfMonthsSavings`函数，使其返回`Either[RetCalcError, Int]`，如下所示：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also have to change the corresponding unit tests. ScalaTest provides convenient
    extensions to perform assertions on the `Either` type. To bring them in scope,
    extend `EitherValues` in `RetCalcSpec.scala`, as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须更改相应的单元测试。ScalaTest提供了对`Either`类型进行断言的便利扩展。为了将它们引入作用域，在`RetCalcSpec.scala`中扩展`EitherValues`，如下所示：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you have a `myEither `variable of the `Either[A, B]` type in your test,
    then `EitherValues` will let us use the following methods:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个`myEither`变量，其类型为`Either[A, B]`，那么`EitherValues`将允许我们使用以下方法：
- en: '`myEither.left.value` returns the left value of type `A` or fails the test
    if `myEither` is `Right`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myEither.left.value`返回类型为`A`的左值，或者如果`myEither`是`Right`则测试失败'
- en: '`myEither.right.value` returns the right value of type `B` or fails the test
    if `myEither` is `Left`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myEither.right.value`返回类型为`B`的右值，或者如果`myEither`是`Left`则测试失败'
- en: 'We can now change our unit tests on `nbOfMonthsSaving` as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更改`nbOfMonthsSaving`的单元测试，如下所示：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the unit test. It should pass.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行单元测试。它应该通过。
- en: Refactoring monthlyRate
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新整理monthlyRate
- en: 'In [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing a Retirement
    Calculator*, we implemented a `Returns.monthlyRate(returns: Returns, month: Int):
    Double` function that returned the monthly return rate for a given month. When
    we called it with a month exceeding the size of an instance of `VariableReturns`,
    we rolled over to the first month using a modulo operation.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '在[第2章](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml)，“开发退休计算器”中，我们实现了一个`Returns.monthlyRate(returns:
    Returns, month: Int): Double`函数，它返回给定月份的月收益率。当我们用超过`VariableReturns`实例大小的月份调用它时，我们使用模运算滚动到第一个月份。'
- en: This was not completely satisfying, as it could compute unrealistic simulations.
    Say that your `VariableReturns` instance contains data for 1950 to 2017\. When
    you ask the monthly returns for 2018, `monthlyRate` would give you the returns
    that we had in 1950\. The economic outlook of the fifties was very different compared
    to the current one, and it is unlikely that the returns in 2018 will mirror those
    in 1950.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全令人满意，因为它可以计算不切实际的模拟。假设你的`VariableReturns`实例包含从1950年到2017年的数据。当你要求2018年的月收益率时，`monthlyRate`会给你1950年的收益率。与当前的经济前景相比，五十年代的经济前景非常不同，而且2018年的收益率不太可能反映1950年的收益率。
- en: 'Therefore, we are going to change `monthlyRate` to return an error if the `month`
    argument is outside the bounds of `VariableReturn`. First, open `RetCalcError.scala` and
    add the following error type:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将更改`monthlyRate`，使其在`month`参数超出`VariableReturn`的范围时返回错误。首先，打开`RetCalcError.scala`并添加以下错误类型：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we are going to change the unit tests to specify the function that we
    expect it to return. Open `ReturnsSpec.scala` and change the tests as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改单元测试以指定我们期望它返回的函数。打开`ReturnsSpec.scala`并按以下方式更改测试：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, open `Returns.scala` and change `monthlyRate` As follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`Returns.scala`并按以下方式更改`monthlyRate`：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Try to compile the project now. Since `monthlyRate` is called by other functions,
    we will get some compilation errors, which is actually a good thing. We just have
    to fix the compilation errors to make our code deal with the possibility of an
    error. Every fix requires some thinking about what to do with that possibility.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试编译项目。由于`monthlyRate`被其他函数调用，我们将得到一些编译错误，这实际上是一件好事。我们只需修复编译错误，使我们的代码能够处理错误的可能性。每个修复都需要思考如何处理这种可能性。
- en: On the other hand, if we had thrown an exception instead of returning `Either`,
    everything would have compiled, but the program would have crashed whenever the
    month was out of bounds. It would have been more difficult to achieve the desired
    behavior because the compiler would not have helped us.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们抛出异常而不是返回`Either`，那么一切都会编译，但每当月份超出范围时程序都会崩溃。要实现所需的行为会更困难，因为编译器不会帮助我们。
- en: 'The first compilation error is in `RetCalc.scala` in `futureCapital`, as shown
    in the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个编译错误在`RetCalc.scala`中的`futureCapital`，如下所示代码：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This means that we cannot call the `+` method on `Either[RetCalcError, Double]`.
    If `monthlyRate` returns `Left`, we cannot calculate the accumulated capital.
    The best course of action would be to stop here and return the error. For this,
    we need to change the return type of `futureCapital` to `Either[RetCalcError,
    Double]` as well.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不能在`Either[RetCalcError, Double]`上调用`+`方法。如果`monthlyRate`返回`Left`，我们无法计算累积资本。最好的做法是在这里停止并返回错误。为此，我们需要将`futureCapital`的返回类型也改为`Either[RetCalcError,
    Double]`。
- en: 'The following is the corrected version of the function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该函数的修正版本：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the second line, we changed the initial element passed to `foldLeft`. We
    are now accumulating `Either[RetCalcError, Double]`. Note that we have to explicitly
    specify the type parameter for `foldLeft`. In the previous version of the function,
    when we were using `Double`, that type was inferred automatically.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们更改了传递给`foldLeft`的初始元素。我们现在正在累积`Either[RetCalcError, Double]`。请注意，我们必须显式指定`foldLeft`的类型参数。在函数的先前版本中，当我们使用`Double`时，该类型是自动推断的。
- en: If we do not specify the type parameter, the compiler will infer it to be of
    the type of the initial element. In our case, `Right(initialCapital)` is of the
    `Right[Nothing, Double] `type, which is a subclass of `Either[RetCalcError, Double]`.
    The problem is that, inside the anonymous function, we return `Either[RetCalcError,
    Double]`, not `Right[Nothing, Double]`. The compiler would complain that the types
    do not match.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不指定类型参数，编译器将推断它为初始元素的类型。在我们的情况下，`Right(initialCapital)`是`Right[Nothing,
    Double]`类型，它是`Either[RetCalcError, Double]`的子类。问题在于，在匿名函数内部，我们返回`Either[RetCalcError,
    Double]`，而不是`Right[Nothing, Double]`。编译器会抱怨类型不匹配。
- en: 'Inside the anonymous function passed to `foldLeft`, we use a `for` comprehension
    to do the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递给`foldLeft`的匿名函数内部，我们使用一个`for`循环来完成以下操作：
- en: Return the accumulated result in `Right` if both `acc` and `monthlyRate` are `Right`
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`acc`和`monthlyRate`都是`Right`，则在`Right`中返回累积的结果
- en: Return `Left` if `acc` or `monthlyRate` is `Left`
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`acc`或`monthlyRate`是`Left`，则返回`Left`
- en: Note that our implementation does not stop as soon as `monthlyRate` returns `Left`,
    which is a bit inefficient. There is no point in iterating through the other months
    when we get an error because this function should always return the first error
    it encounters. In [Chapter 4](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml), *Advanced
    Features*, we will see how we can use lazy evaluation with `foldr` to stop the
    iteration early.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的实现不会在`monthlyRate`返回`Left`时立即停止，这有点低效。当我们得到错误时，没有必要遍历其他月份，因为这个函数应该始终返回它遇到的第一个错误。在[第4章](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml)，*高级特性*中，我们将看到如何使用`foldr`进行懒计算以提前停止迭代。
- en: Compile the project again. Now we need to fix a compilation error in `simulatePlan`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译项目。现在我们需要修复`simulatePlan`中的编译错误。
- en: Refactoring simulatePlan
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构`simulatePlan`
- en: 'Since `simulatePlan` calls `futureCapital`, we need to change its implementation
    to take into account the new return type, as shown in the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`simulatePlan`调用了`futureCapital`，我们需要更改其实现以考虑新的返回类型，如下所示代码：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We moved the two calls to `futureCapital` inside a `for` comprehension. This
    way, if any of these calls return an error, `simulatePlan` will return it. If
    both calls succeed, `simulatePlan` will return the two double values in a tuple.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个对`futureCapital`的调用移到了一个`for`循环中。这样，如果这些调用中的任何一个返回错误，`simulatePlan`将返回它。如果两个调用都成功，`simulatePlan`将返回一个包含两个双精度值的元组。
- en: 'Compile the project. Now we need to fix a compilation error in `nbOfMonthsSaving`,
    which uses `simulatePlan`. The following code is the fixed version:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编译项目。现在我们需要修复`nbOfMonthsSaving`中的编译错误，它使用了`simulatePlan`。以下代码是修复后的版本：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We had to change our recursive `loop` function to return `Either[RetCalcError,
    Int]`. The loop will stop as soon as we get an error or `if (capitalAfterDeath
    > 0.0)`. You might wonder why we did not use `flatMap` instead of using pattern
    matching. It would indeed have been more concise, but the `loop` function would
    not be tail recursive anymore, because the recursive call to loop would be inside
    an anonymous function. As an exercise, I encourage you to try changing the code
    so that it uses `flatMap` and observe the tail recursion compilation error.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不将我们的递归 `loop` 函数更改为返回 `Either[RetCalcError, Int]`。循环将在我们得到错误或 `if (capitalAfterDeath
    > 0.0)` 时停止。你可能想知道为什么我们没有使用 `flatMap` 而不是使用模式匹配。这确实会更简洁，但 `loop` 函数将不再尾递归，因为对循环的递归调用将位于匿名函数内部。作为一个练习，我鼓励你尝试更改代码以使用
    `flatMap` 并观察尾递归编译错误。
- en: Compile the project. The last compilation error in the production code is in
    `SimulatePlanApp.scala`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编译项目。生产代码中的最后一个编译错误在 `SimulatePlanApp.scala`。
- en: Refactoring SimulatePlanApp
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构 SimulatePlanApp
- en: The entry point of our `SimulatePlanApp `application calls `simulatePlan`. We
    need to change it to return the text of any error that could occur.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `SimulatePlanApp` 应用程序的入口点调用 `simulatePlan`。我们需要将其更改为返回可能发生的任何错误的文本。
- en: 'First, we need to change the integration test to add a new test case. Open 
    `SimulatePlanIT.scala` and add the following test:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改集成测试以添加一个新的测试用例。打开 `SimulatePlanIT.scala` 并添加以下测试用例：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, open `SimulatePlanApp.scala` and change the implementation of `SimulatePlanApp `as
    follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开 `SimulatePlanApp.scala` 并按如下方式更改 `SimulatePlanApp` 的实现：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We just have to pattern match on the result of `simulatePlan`, and return a
    string explaining the result of the computation if it is a `Right` value, or return
    the error message if it is a `Left` value.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需对 `simulatePlan` 的结果进行模式匹配，如果结果是 `Right` 值，则返回解释计算结果的字符串；如果是 `Left` 值，则返回错误信息。
- en: Compile the project. Now all the production code should compile, but there are
    still several compilation errors in the unit tests. As an exercise, I encourage
    you to try to fix them. In most cases, you have to make the test extend `EitherValues`,
    and call `.right.value` on an `Either` class to get its right value. Once you
    have fixed the remaining errors, compile and run all the tests of the project.
    They should all pass.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 编译项目。现在所有生产代码都应该可以编译，但在单元测试中仍然有几个编译错误。作为一个练习，我鼓励您尝试修复它们。在大多数情况下，您必须使测试扩展 `EitherValues`，并在
    `Either` 类上调用 `.right.value` 以获取其右侧值。一旦修复了剩余的错误，编译并运行项目的所有测试。它们都应该通过。
- en: Now your code should look like the `Chapter03` branch in the Scala fundamentals
    GitHub project, apart from the `SimulatePlanApp` class, which we will improve
    in the next section. See [https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects) for
    more details.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的代码应该看起来像 Scala 基础 GitHub 项目中的 `Chapter03` 分支，除了我们将改进的 `SimulatePlanApp`
    类。有关更多详细信息，请参阅 [https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects)。
- en: Using ValidatedNel
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ValidatedNel
- en: In this chapter, we have seen how we can model the possibility of an optional
    value with `Option` and the possibility of an error with `Either`. We demonstrated
    how these types can replace exceptions while guaranteeing referential transparency.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 `Option` 模型可选值的可能性，以及使用 `Either` 模型错误的可能性。我们展示了这些类型如何替换异常，同时保证引用透明性。
- en: 'We also saw how we can combine several `Option` or `Either` types using `flatMap`.
    This works well when we have to check for optional values or errors *sequentially*—call
    `function1`; if there is no error, call `function2`; if there is no error, call
    `function3`. If any of these functions return an error, we return that error and
    stop the call chain, as shown in the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用 `flatMap` 组合几个 `Option` 或 `Either` 类型。当我们需要按顺序检查可选值或错误时，这效果很好——调用
    `function1`；如果没有错误，则调用 `function2`；如果没有错误，则调用 `function3`。如果这些函数中的任何一个返回错误，我们将返回该错误并停止调用链，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, in some situations, we would want to call several functions in parallel
    and return all the errors that might have occurred. For instance, when you enter
    some personal details to purchase a product from an online shop, you expect the
    website to highlight all the mistakes in all the fields after you submit the details.
    It would be a bad user experience to have the website tell you that the last name
    is mandatory after submitting the details, and subsequently that your password
    is too short after submitting the details again. All the fields must be validated
    simultaneously and all errors must be returned to the user in one go.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们可能希望并行调用多个函数并返回可能发生的所有错误。例如，当你输入一些个人详细信息以从在线商店购买产品时，你期望网站在你提交详细信息后突出显示所有字段的错误。在提交详细信息后告诉你说姓氏是必填项，然后在你再次提交详细信息后说你的密码太短，这将是一个糟糕的用户体验。所有字段必须同时验证，并且所有错误必须一次性返回给用户。
- en: The data structure that can help us address this use case is `Validated`. Unfortunately,
    it is not part of the Scala SDK, and we have to use an external library called
    `cats` to bring it into our project.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可以帮助我们解决此用例的数据结构是 `Validated`。不幸的是，它不是 Scala SDK 的一部分，我们必须使用一个名为 `cats` 的外部库将其引入我们的项目中。
- en: Adding the cats dependency
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 cats 依赖项
- en: The `cats` library provides abstractions for functional programming. Its name
    comes from the shortening of the phrase *category theory*. It is also a reference
    to the famous joke that managing developers is like herding cats—the truth is
    that you don't really have control—cats do whatever they want.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`cats` 库提供了函数式编程的抽象。其名称来自短语 *category theory* 的缩写。它也是对著名笑话的引用，即管理开发者就像放养猫——事实是，你实际上并没有控制权——猫做它们想做的事情。'
- en: In this chapter, we are going to focus only on `Validated` and `NonEmptyList`,
    but `cats` offers many more powerful abstractions that we will explore later in
    this book.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将只关注 `Validated` 和 `NonEmptyList`，但 `cats` 提供了许多更强大的抽象，我们将在本书的后续部分中探讨。
- en: 'First, edit `built.sbt` and add the following lines:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编辑 `built.sbt` 并添加以下行：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This brings the `cats` dependency to our project and also enables a compiler
    flag (`partial unification`) that is required by the library to infer types correctly.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `cats` 依赖项引入我们的项目，并启用了一个库所需的编译器标志（`partial unification`），以便正确推断类型。
- en: Save the project with *Ctrl* + *S*. IntelliJ should offer to update the project
    to reflect the changes in the `build` file. Click on Refresh Project on top of
    `built.sbt`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *S* 保存项目。IntelliJ 应该会提供更新项目以反映 `build` 文件中更改的选项。在 `built.sbt` 顶部单击刷新项目。
- en: Introducing NonEmptyList
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 NonEmptyList
- en: 'As its name implies, the `cats.data.NonEmptyList` type represents a `List` instance
    that has at least one element. In other words, it is a `List` instance that cannot
    be empty. The following are some examples of this usage that you can retype in
    a new Scala worksheet:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`cats.data.NonEmptyList` 类型代表一个至少包含一个元素的 `List` 实例。换句话说，它是一个不能为空的 `List`
    实例。以下是一些你可以在新 Scala 工作表中重新输入的此用法示例：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can construct `NonEmptyList` with the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式构造 `NonEmptyList`：
- en: '`apply[A]`: You can pass a `head` element and a `List` as a tail.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply[A]`：你可以传递一个 `head` 元素和一个作为尾部的 `List`。'
- en: '`fromList[A]`: You can pass `List`. You get back `Option[NonEmptyList[A]]`
    that will be `None` if the `List` argument is empty.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromList[A]`：你可以传递一个 `List`。你将得到一个 `Option[NonEmptyList[A]]`，如果 `List` 参数为空，则它将是
    `None`。'
- en: '`of[A]`: You can pass a `head` element and variable length `List `argument for
    the tail. This is is the most convenient way of building `NonEmptyList` when you
    know its constituents.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of[A]`：你可以传递一个 `head` 元素和一个可变长度的 `List` 参数作为尾部。这是当你知道其组成部分时构建 `NonEmptyList`
    最方便的方式。'
- en: 'Since `NonEmptyList` always contains at least one element, we can always call
    the `head` method without risking getting an exception. As a consequence, there
    is no `headOption` method. You can manipulate `NonEmptyList` with all the usual
    methods that you would use on `List`: `map`, `tail`, `flatMap`, `filter`, and
    `foldLeft`, to name a few.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `NonEmptyList` 总是包含至少一个元素，因此我们可以始终调用 `head` 方法而不会冒着抛出异常的风险。因此，没有 `headOption`
    方法。你可以使用所有在 `List` 上使用的常规方法来操作 `NonEmptyList`：`map`、`tail`、`flatMap`、`filter`
    和 `foldLeft` 等。
- en: Introducing Validated
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Validated
- en: 'The `cats.data.Validated[E, A]`type is very similar to `Either[E, A]`. It is
    an ADT that represents a value of either an `Invalid` type or a `Valid` type.
    A simplified definition would be the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`cats.data.Validated[E, A]`类型与`Either[E, A]`非常相似。它是一个ADT，表示一个`Invalid`类型或`Valid`类型的值。简化的定义如下：'
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We will see what the `+` sign in front of a type parameter means in the section
    on covariance and contravariance in [Chapter 4](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml), *Advanced
    Features*. For now, though, do not worry about it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml)的协变和逆变部分看到类型参数前面`+`符号的含义，*高级特性*。不过，现在不必担心它。
- en: Similarly to the definition of `Option`, the definitions use contravariance
    and `Nothing`. This way, `Valid[A]` is a subtype of `Validated[E, A]` for any
    `E`; and `Invalid[E]` is a subtype of `Validated[E, A]` for any `A`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Option`的定义类似，定义使用了逆变和`Nothing`。这样，对于任何`E`，`Valid[A]`是`Validated[E, A]`的子类型；对于任何`A`，`Invalid[E]`是`Validated[E,
    A]`的子类型。
- en: 'The main difference with `Either` is that we can accumulate the errors produced
    by several `Validated` instances. Here are some examples that you can retype in
    a new Scala worksheet. I advise you to uncheck the Type-aware highlighting box
    in the bottom-right corner of IntelliJ; otherwise, IntelliJ will underline some
    expressions in red, even though they compile fine:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Either`的主要区别是我们可以累积由多个`Validated`实例产生的错误。以下是一些你可以在新Scala工作表中重新输入的示例。我建议你取消勾选IntelliJ右下角的“类型感知高亮”框；否则，IntelliJ会用红色下划线标记一些表达式，尽管它们可以正常编译：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We first define a `Valid` value of `1`, with a `Valid` type `Int` parameter,
    and an `Invalid` type `NonEmptyList[String]` parameter. Each error will be of
    a `String` type, and the `NonEmptyList` instance will force us to have at least
    one error when we produce an `Invalid` value. This usage is so common that `cats`
    provide a type alias called `ValidatedNel` in the `cats.data `package, as shown
    in the following code :'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个值为`1`的`Valid`值，具有`Int`类型的`Valid`参数和`NonEmptyList[String]`类型的`Invalid`参数。每个错误都将是一个`String`类型，`NonEmptyList`实例将强制我们在产生`Invalid`值时至少有一个错误。这种用法非常常见，因此`cats`在`cats.data`包中提供了一个类型别名`ValidatedNel`，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Going back to our example, in the second line, we define a `Valid` value of `2`
    using a handy `cats` method called `.validNel`. When calling `validNel`, we have
    to pass the type of error, because in this case, the compiler does not have any
    information to infer it. In our case, the error type is `String`. The resulting
    type of `valid2` is `ValidatedNel[String, Int]`, which is an alias for `Validated[NonEmptyList[String],
    Int]`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，在第二行，我们使用一个方便的`cats`方法`.validNel`定义了一个值为`2`的`Valid`值。在调用`validNel`时，我们必须传递错误类型，因为在这种情况下，编译器没有任何信息可以推断它。在我们的情况下，错误类型是`String`。`valid2`的结果类型是`ValidatedNel[String,
    Int]`，它是`Validated[NonEmptyList[String], Int]`的别名。
- en: In the third line, we *compose* the two valid values by putting them in a tuple
    and call `mapN`. The `mapN` phrase accepts an `f `function that takes as many
    arguments as there are elements in the tuple. If *all* of the elements of the
    tuple are `Valid` values, `f` is called and its result will be wrapped in a `Valid`
    value. If *any* of the elements inside the tuple are `Invalid` values, then all
    the `Invalid` values are *combined* together and wrapped in an `Invalid` value.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们通过将两个有效值放入一个元组中并调用`mapN`来**组合**这两个有效值。`mapN`短语接受一个`f`函数，该函数接受与元组中元素数量相同的参数。如果元组的**所有**元素都是`Valid`值，则调用`f`，其结果将被包裹在一个`Valid`值中。如果元组内部的**任何**元素是`Invalid`值，则所有`Invalid`值将被**合并**在一起并包裹在一个`Invalid`值中。
- en: We can observe that, when we compose `valid1` and `valid2`, which are all `Valid`,
    `mapN` returns a `Valid` value. When we compose `valid1`, `valid2`, `invalid3`,
    and `invalid4`, `mapN` returns an `Invalid` value. This `Invalid` value wraps
    a `NonEmptyList` that contains the errors of `invalid3` and `invalid4`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，当我们组合`valid1`和`valid2`（它们都是`Valid`）时，`mapN`返回一个`Valid`值。当我们组合`valid1`、`valid2`、`invalid3`和`invalid4`时，`mapN`返回一个`Invalid`值。这个`Invalid`值包裹了一个包含`invalid3`和`invalid4`错误的`NonEmptyList`。
- en: 'We now know two mechanisms to represent the possibility of a failure:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了两种表示失败可能性的机制：
- en: '`Either` with `for...yield` can be used to validate *sequentially*,stopping
    at the first error encountered'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for...yield`的`Either`可以用于**顺序**验证，在遇到第一个错误时停止。
- en: '`Validated` with `mapN` can be used to validate in parallel, accumulating all
    the errors in `NonEmptyList`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Validated`与`mapN`可以用于**并行**验证，将所有错误累积在`NonEmptyList`中。'
- en: Refactoring the retirement calculator to use ValidatedNel
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构退休计算器以使用ValidatedNel
- en: With this new knowledge, we are well equipped to improve our retirement calculator
    further. We are going to improve `SimulatePlanApp` to give the users more information
    if one or many arguments passed to the program are wrong.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些新知识，我们已准备好进一步改进我们的退休计算器。我们将改进`SimulatePlanApp`，以便在程序传递给用户的参数中有一个或多个错误时提供更多信息。
- en: When many arguments are wrong, for instance, if the user passes some random
    text instead of a parsable number, we want to report one error for every bad argument.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多参数错误时，例如，如果用户传递了一些随机文本而不是可解析的数字，我们希望为每个错误参数报告一个错误。
- en: Adding unit tests
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加单元测试
- en: 'Firstly, we need to change the test associated with `SimulatePlanApp`. Open
    `SimulatePlanAppIT.scala` and change the content as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改与`SimulatePlanApp`相关的测试。打开`SimulatePlanAppIT.scala`并按照以下内容更改内容：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s have a look at the preceding code in detail:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看前面的代码：
- en: The first two tests do not change much—we just changed the expectations to be `Valid(expectedResult)`.
    We are going to change the return type of `SimulatePlanApp.strMain`—instead of
    returning a string, we are going to change it to return `Validated[String, String]`.
    We expect `strMain` to return a `Valid` value containing the result if all arguments
    are correct. If some arguments are incorrect, it should return an `Invalid` value
    containing `String` explaining what the incorrect arguments are.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个测试变化不大——我们只是将期望更改为`Valid(expectedResult)`。我们将改变`SimulatePlanApp.strMain`的返回类型——而不是返回一个字符串，我们将将其更改为返回`Validated[String,
    String]`。我们期望`strMain`在所有参数正确的情况下返回一个包含结果的`Valid`值。如果某些参数不正确，它应该返回一个包含`String`的`Invalid`值，解释哪些参数不正确。
- en: The third test is a new test. If we do not pass the right number of arguments,
    we expect `strMain` to return an `Invalid` value containing a usage example.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个测试是一个新测试。如果我们没有传递正确的参数数量，我们期望`strMain`返回一个包含使用示例的`Invalid`值。
- en: The fourth test checks that one error for every bad argument is reported.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个测试检查每个错误参数都会报告一个错误。
- en: Implementing parsing functions
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现解析函数
- en: 'The next step is to add new types of errors that will be returned in `ValidateNel`
    when some arguments are wrong. We need to change `RetCalcError.scala` as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加新的错误类型，当某些参数错误时，这些错误将在`ValidateNel`中返回。我们需要按照以下方式更改`RetCalcError.scala`：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we introduced an `InvalidNumber` error that will be returned when a string
    cannot be parsed into a number. The other error, `InvalidArgument`, will be returned
    when an argument is wrong. We will use it when the `from` and `until` parameters
    are wrong (see the preceding unit test). Also, as we are going to use many types
    of `ValidatedNel[RetCalcError, A]` form, we created a type alias, `RetCalcResult`.
    It will also help IntelliJ to autocomplete the functions of the `cats` library.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了一个`InvalidNumber`错误，当字符串无法解析为数字时将返回。另一个错误`InvalidArgument`将在参数错误时返回。我们将使用它来处理`from`和`until`参数错误（参见前面的单元测试）。此外，由于我们将使用许多类型的`ValidatedNel[RetCalcError,
    A]`形式，我们创建了一个类型别名`RetCalcResult`。它还将帮助IntelliJ自动完成`cats`库的函数。
- en: After that, we need to change `SimulatePlanApp.strMain` to validate the arguments.
    For this, we start by writing a small function that parses one string argument
    to produce `Validated Int`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要更改`SimulatePlanApp.strMain`以验证参数。为此，我们首先编写一个小的函数，该函数解析一个字符串参数以生成`Validated
    Int`。
- en: Ideally, all the following parsing functions should be unit tested. We do have
    indirect test coverage for them in `SimulatePlanAppIT`, but it is not sufficient.
    In test-driven development, whenever you need to write a new function, you should
    just define its signature and then write a test before implementing it. Unfortunately,
    we do not have enough space in this book to show all of the unit tests that you
    would expect to have in a production application. However, as an exercise, I encourage
    you to write them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，以下所有解析函数都应该进行单元测试。我们确实在`SimulatePlanAppIT`中为它们提供了间接的测试覆盖率，但这并不充分。在测试驱动开发中，每次你需要编写一个新函数时，你应该先定义其签名，然后在其实现之前编写一个测试。不幸的是，这本书中没有足够的空间来展示你期望在生产应用程序中拥有的所有单元测试。然而，作为一个练习，我鼓励你编写它们。
- en: 'We call this function `parseInt`. It takes the name of an argument and its
    value, and returns `Validated Int`, as shown in the following code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个函数为`parseInt`。它接受一个参数的名称和其值，并返回`Validated Int`，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We first call the `Validated.catchOnly` method, which executes a block of code
    (in our case, `value.toInt`) and catches a specific type of exception. If the
    block does not throw any exception, `catchOnly` returns a `Valid` value with the
    result. If the block throws the exception type passed as an argument (in our case, `NumberFormatException`),
    then `catchOnly` returns an `Invalid` value containing the caught exception. The
    resulting expression type is `Validated[NumberFormatException, Int]`. However,
    our `parseInt` function must return `RetCalcResut[Int]`, which is an alias for
    `ValidatedNel[RetCalcError, Int]`. In order to transform the error or left type,
    we call the `Validated.leftMap` method to produce `NonEmptyList[RetCalcError]`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 `Validated.catchOnly` 方法，该方法执行一个代码块（在我们的情况下，`value.toInt`）并捕获特定类型的异常。如果代码块没有抛出任何异常，`catchOnly`
    返回一个包含结果的 `Valid` 值。如果代码块抛出了作为参数传递的异常类型（在我们的情况下，`NumberFormatException`），则 `catchOnly`
    返回一个包含捕获的异常的 `Invalid` 值。结果表达式类型为 `Validated[NumberFormatException, Int]`。然而，我们的
    `parseInt` 函数必须返回 `RetCalcResut[Int]`，它是 `ValidatedNel[RetCalcError, Int]` 的别名。为了转换错误或左类型，我们调用
    `Validated.leftMap` 方法来生成 `NonEmptyList[RetCalcError]`。
- en: 'Then, we write another function, `parseFromUntil`—that is in charge of parsing
    the `from` and `until `arguments. These two arguments are separated by a comma,
    as shown in the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写另一个函数 `parseFromUntil`——该函数负责解析 `from` 和 `until` 参数。这两个参数由逗号分隔，如下所示：
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We create an `Array[String]` with the `String.split `method. If the array does
    not have exactly two elements, we return an `Invalid` value containing an `InvalidArgument`
    error. If the array has two elements, then we return them in a tuple inside a
    `Valid` value.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `String.split` 方法创建一个 `Array[String]`。如果数组不恰好有两个元素，我们返回一个包含 `InvalidArgument`
    错误的 `Invalid` 值。如果数组有两个元素，则将它们作为 `Valid` 值中的元组返回。
- en: 'Finally, we write a `parseParams `function that accepts an array of arguments
    and produces `RetCalcResult[RetCalcParams]`. The `RetCalcParams` argument is one
    of the arguments required by `RetCalc.simulatePlan`, as shown in the following
    code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编写一个 `parseParams` 函数，该函数接受一个参数数组并生成 `RetCalcResult[RetCalcParams]`。`RetCalcParams`
    参数是 `RetCalc.simulatePlan` 所需的参数之一，如下所示：
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The function assumes that the `args` array has at least six elements. We create
    a tuple of four elements, each element being the result of `parseInt`, and hence,
    it has the `RetCalcResult[Int]` type. Then, we call the `mapN` method on our `Tuple4`,
    which will accumulate any error produced by the calls to `parseInt`. If all of
    the `parseInt` calls return a `Valid` value, the anonymous function passed to
    `mapN` is called. It takes `Tuple4 (Int, Int, Int, Int)` and returns a `RetCalcParams`
    instance.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数假设 `args` 数组至少有六个元素。我们创建一个包含四个元素的元组，每个元素都是 `parseInt` 的结果，因此它具有 `RetCalcResult[Int]`
    类型。然后，我们在 `Tuple4` 上调用 `mapN` 方法，这将累积由 `parseInt` 调用产生的任何错误。如果所有的 `parseInt` 调用都返回一个
    `Valid` 值，则调用传递给 `mapN` 的匿名函数。它接受 `Tuple4 (Int, Int, Int, Int)` 并返回一个 `RetCalcParams`
    实例。
- en: Implementing SimulatePlanApp.strSimulatePlan
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 SimulatePlanApp.strSimulatePlan
- en: 'In order to keep `SimulatePlanApp.strMain` small and readable, we are going
    to extract the code that is in charge of calling `RetCalc.simulatePlan` and return a
    human-readable string detailing the result of the simulation. We call this new
    function `strSimulatePlan`, and use it as shown in the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持 `SimulatePlanApp.strMain` 代码小且易于阅读，我们打算提取负责调用 `RetCalc.simulatePlan` 并返回一个详细描述模拟结果的易读字符串的代码。我们称这个新函数为
    `strSimulatePlan`，并在以下代码中展示其用法：
- en: '[PRE60]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The function takes the parsed arguments, calls `simulatePlan`, and transforms
    its result into a string. In order to keep the same type as our parsing functions,
    we declare the return type of the function to be `RetCalcResult[String]`. This
    is an alias for `ValidatedNel[RetCalcError, String]`, but `simulatePlan` returns `Either[RetCalcError,
    String]`. Fortunately, `cats` provide `.toValidatedNel` method to easily convert
    `Either` to `ValidatedNel`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受解析后的参数，调用 `simulatePlan`，并将结果转换为字符串。为了保持与我们的解析函数相同的类型，我们声明函数的返回类型为 `RetCalcResult[String]`。这是
    `ValidatedNel[RetCalcError, String]` 的别名，但 `simulatePlan` 返回 `Either[RetCalcError,
    String]`。幸运的是，`cats` 提供了 `.toValidatedNel` 方法，可以轻松地将 `Either` 转换为 `ValidatedNel`。
- en: Refactoring SimulatePlanApp.strMain
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构 SimulatePlanApp.strMain
- en: 'We have implemented some building blocks for parsing the whole arguments array.
    It is now time to refactor `SimulatePlanApp.strMain` to call them. First, we need
    to check that the arguments array has the right size, as shown in the following
    code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一些用于解析整个参数数组的构建块。现在是时候重构 `SimulatePlanApp.strMain` 以调用它们了。首先，我们需要检查参数数组的大小是否正确，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In order to match the assertions we made in the `SimulatePlanAppIT `integration
    test, we change the signature to return `Validated[String, String]`. If the arguments
    array is of the wrong size, we return an `Invalid` value, with a string explaining
    the correct usage for our program. Otherwise, when the arguments array is of the
    right size, we first declare the `allReturns` variable as before.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配我们在 `SimulatePlanAppIT` 集成测试中提出的断言，我们将签名更改为返回 `Validated[String, String]`。如果参数数组的大小不正确，我们返回一个
    `Invalid` 值，其中包含解释我们程序正确用法的字符串。否则，当参数数组的大小正确时，我们首先声明 `allReturns` 变量，就像之前一样。
- en: Then, we call the three parsing functions that we implemented earlier and assign
    them to `vFromUntil`, `vNbOfYearsSaving`, and `vParams`. Their types are `RetCalcResult[(String,
    String)]`, `RetCalcResult[Int]`, and `RetCalcResult[RetCalcParams]` respectively.
    After that, we put these three values in `Tuple3`, and call the `cats` `tupled`
    function, which combines the three elements of the tuple to produce `RetCalcResult[((String,
    String), Int, RetCalcParams)]`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用我们之前实现的三个解析函数，并将它们分配给 `vFromUntil`、`vNbOfYearsSaving` 和 `vParams`。它们的类型分别是
    `RetCalcResult[(String, String)]`、`RetCalcResult[Int]` 和 `RetCalcResult[RetCalcParams]`。之后，我们将这三个值放入
    `Tuple3` 中，并调用 `cats` 的 `tupled` 函数，该函数将元组的三个元素组合起来产生 `RetCalcResult[((String,
    String), Int, RetCalcParams)]`。
- en: At this point, we have a `ValidatedNel` instance containing all the required
    parameters to call the `strSimulatePlan` function that we implemented earlier.
    In this case, we need to check errors sequentially—first, we validate all the
    arguments, *and then* we call `strSimulatePlan`. If we had used `Either` instead
    of `ValidatedNel`, we would have used `flatMap` to do this. Fortunately, `ValidatedNel`
    provides an equivalent method in the form of `andThen`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个 `ValidatedNel` 实例，它包含调用我们之前实现的 `strSimulatePlan` 函数所需的所有参数。在这种情况下，我们需要按顺序检查错误——首先，我们验证所有参数，*然后*
    调用 `strSimulatePlan`。如果我们使用了 `Either` 而不是 `ValidatedNel`，我们会使用 `flatMap` 来做这件事。幸运的是，`ValidatedNel`
    提供了一个等效的方法，形式为 `andThen`。
- en: Unlike `Option` and `Either`, instances of `ValidatedNel` do not have a `flatMap`
    method because it is not a monad, it is an applicative functor. We will explain what
    these terms mean in [Chapter 4,](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml) *Advanced
    Features*. If you want to run validations in sequence, you need to use `andThen` or
    convert in to `Either` and use `flatMap`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Option` 和 `Either` 不同，`ValidatedNel` 的实例没有 `flatMap` 方法，因为它不是一个 monad，而是一个
    applicative functor。我们将在 [第 4 章](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml)，*高级特性*
    中解释这些术语的含义。如果你想按顺序运行验证，你需要使用 `andThen` 或将其转换为 `Either` 并使用 `flatMap`。
- en: Before the call to `.leftMap`, we have an expression of the `RetCaclResult[String] `type,
    which is an alias for `Validated[NonEmptyList[RetCalcError], String]`. However,
    our function must return `Validated[String, String]`. Therefore, we transform
    the left `NonEmptyList[RetCalcError]`type to a string using the anonymous function
    passed to `.leftMap`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `.leftMap` 之前，我们有一个 `RetCaclResult[String]` 类型的表达式，它是 `Validated[NonEmptyList[RetCalcError],
    String]` 的别名。然而，我们的函数必须返回 `Validated[String, String]`。因此，我们使用传递给 `.leftMap` 的匿名函数将左边的
    `NonEmptyList[RetCalcError]` 类型转换为字符串。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how we can handle optional values and how to handle
    errors in a purely functional way. You are now better equipped to write safer
    programs that do not throw exceptions and crash unexpectedly.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何处理可选值以及如何以纯函数方式处理错误。你现在更有能力编写更安全的程序，这些程序不会抛出异常并意外崩溃。
- en: If you use Java libraries or some non-purely-functional Scala libraries, you
    will notice that they can throw exceptions. If you do not want your program to
    crash when exceptions are raised, I advise you to wrap them as early as possible
    inside `Either` or `Validated`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Java 库或某些非纯函数式 Scala 库，你会注意到它们可以抛出异常。如果你不希望程序在抛出异常时崩溃，我建议你尽早将它们包装在 `Either`
    或 `Validated` 中。
- en: We saw how `Either` can be used to handle errors sequentially, and how `Validated`
    can handle errors in parallel. As these two types are very similar, I would advise
    you to use `Validated` most of the time. Instances of `Validated` can indeed handle
    errors in parallel using `mapN`, but they can also perform sequential validation
    using `andThen`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用`Either`来按顺序处理错误，以及如何使用`Validated`来并行处理错误。由于这两个类型非常相似，我建议你大多数时候使用`Validated`。`Validated`的实例确实可以使用`mapN`并行处理错误，但它们也可以使用`andThen`进行顺序验证。
- en: 'This chapter went a bit further in the way of writing programs in a functional
    way. In the next chapter we will explore other features of the language that you
    will necessarily encounter in typical Scala projects: laziness, covariance and
    contravariance, and implicit.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在以函数式方式编写程序方面又前进了一步。在下一章中，我们将探索你将在典型的Scala项目中必然会遇到的其他语言特性：惰性、协变和逆变，以及隐式。
- en: Questions
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are some questions to test your knowledge:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题来测试你的知识：
- en: What type can you use to represent an optional value?
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用哪种类型来表示可选值？
- en: What type(s) can you use to represent the possibility of an error?
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用哪些类型来表示错误的可能性？
- en: What is referential transparency?
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是引用透明性？
- en: Is it good practice to throw exceptions?
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常是良好的实践吗？
- en: 'Here are some exercises:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习：
- en: Write unit tests for `SimulatePlanApp`
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`SimulatePlanApp`编写单元测试
- en: Use `RetCalcResult` instead of `Either[RetCalcError, X]` in `RetCalc.scala`
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`RetCalc.scala`中使用`RetCalcResult`代替`Either[RetCalcError, X]`
- en: Change `VariableReturns.fromUntil` to return an error if `monthIdFrom` or `monthIdUntil`
    cannot be found in the returns `Vector`
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`VariableReturns.fromUntil`修改为在`monthIdFrom`或`monthIdUntil`在返回的`Vector`中找不到时返回错误
- en: Further reading
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The `cats` documentation on `Either` and `Validated` at the following links
    provides other usage examples, as well as more details on their respective topics:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中，`cats`文档关于`Either`和`Validated`提供了其他使用示例，以及它们各自主题的更多详细信息：
- en: '[https://typelevel.org/cats/datatypes/either.html](https://typelevel.org/cats/datatypes/either.html)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://typelevel.org/cats/datatypes/either.html](https://typelevel.org/cats/datatypes/either.html)'
- en: '[https://typelevel.org/cats/datatypes/validated.html](https://typelevel.org/cats/datatypes/validated.html)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://typelevel.org/cats/datatypes/validated.html](https://typelevel.org/cats/datatypes/validated.html)'
