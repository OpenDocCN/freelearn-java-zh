- en: Chapter 5. Conversations and Journeys
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 对话和旅程
- en: '|   | *"Success is liking yourself, liking what you do, and liking how you
    do it."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"成功就是喜欢自己，喜欢你所做的事情，以及喜欢你做事的方式。"|'
- en: '|   | --*Maya Angelou* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*玛雅·安吉洛*|'
- en: In this chapter, we devote our attention to the JSF conversation scope. This
    scope defines the lifecycle of a managed backing bean that spans between the request
    and the session scope. This allows the data in the form to survive in a lifespan
    that sits between the request-scope and the session-scope. The conversation scope
    is also said to be contextual. This term is appropriated from the **Context and
    Dependency Injection** (**CDI**) specification, and it means that the life span
    of the beans marked with a conversation scope are treated as being part of a context.
    You can think of this as a dotted marker that the CDI container draws around the
    object instances to define them as a private group, which denotes a lifecycle.
    The CDI container does this job of gathering the object instances together as
    it associates one object bean with a dependency on another.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于JSF对话作用域。此作用域定义了跨越请求和会话作用域的管理后端Bean的生命周期。这使得表单中的数据能够在请求作用域和会话作用域之间的生命周期中存活。对话作用域也被认为是上下文相关的。这个术语是从**上下文和依赖注入**（**CDI**）规范中借用的，它的意思是被标记为对话作用域的Bean的生命周期被视为上下文的一部分。你可以将这视为CDI容器在对象实例周围绘制的点状标记，以将它们定义为私有组，这表示一个生命周期。CDI容器通过将一个对象Bean与对另一个Bean的依赖关联起来来完成这项将对象实例聚集在一起的工作。
- en: In CDI, Context represents the CDI container's ability to bind a group of object
    instances that are stateful components into well-defined and extendible lifecycles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在CDI中，上下文表示CDI容器将一组具有状态的组件对象实例绑定到定义良好且可扩展的生命周期中的能力。
- en: In CDI, Dependency Injection represents the CDI container's capability to inject
    components into an application with type safety in mind. The CDI container chooses,
    at runtime, the implementation of the Java interface that is to be injected.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在CDI中，依赖注入表示CDI容器将组件注入到应用程序中的能力，同时考虑到类型安全。CDI容器在运行时选择要注入的Java接口的实现。
- en: JavaServer Faces integrates into the standard CDI scope, including the conversational
    scope. Examples of conversation include several types of contemporary digital
    customer journeys. You probably have seen this yourself whilst applying for a
    new job online, going through the shipping and delivery flow of an e-commerce
    website, or setting up a government resource or function like a tax assessment
    or return. In this chapter, we are going look at one example customer journey,
    where the developer or user is applying for an instant secured loan. You may have
    already seen these or actually have been fortunate, or unfortunate, to peruse
    a payday loan facility.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JavaServer Faces集成到标准CDI作用域中，包括对话作用域。对话的例子包括多种当代数字客户旅程。你可能自己在在线申请新工作时见过，或者在电子商务网站的发货和配送流程中，或者在设置政府资源或功能（如税务评估或退税）时见过。在本章中，我们将探讨一个客户旅程的例子，其中开发人员或用户正在申请即时安全贷款。你可能已经见过这些，或者实际上已经幸运地或不幸地浏览过现金贷款设施。
- en: The conversation scope maintains a state with a client. The controller or POJO,
    which is demarcated with the conversation scope, and its component instances become
    part of its state.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对话作用域与客户端保持状态。标记为对话作用域的控制器或POJO及其组件实例成为其状态的一部分。
- en: 'The following diagram outlines the conversation scope around the managed bean
    controller that we will be studying in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下图概述了我们将在本章中研究的受管理Bean控制器周围的对话作用域：
- en: '![Conversations and Journeys](img/image00396.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![对话和旅程](img/image00396.jpeg)'
- en: An illustration of the several bean instances with different CDI scopes
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 几个具有不同CDI作用域的Bean实例的插图
- en: The preceding diagram shows two different customers, which are logged into the
    enterprise application. Starting from left to right, we have the **UserProfile**
    instances that capture the login information of the customer, which are stored
    in the CDI session scope. These beans are shared with only the particular customer
    associated with the `javax.servlet.http.HttpSession` object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图展示了两个不同的客户，他们已经登录到企业应用程序中。从左到右，我们有**UserProfile**实例，它们捕获客户的登录信息，并存储在CDI会话作用域中。这些豆子只与特定的客户共享，该客户与`javax.servlet.http.HttpSession`对象相关联。
- en: Moving over to the right, we have an object graph of bean instances, the **LendingController**,
    **ContactDetail**, and **BankDetails**, which are stored in the conversation scope.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 向右移动，我们有一个豆实例的对象图，**LendingController**、**ContactDetail**和**BankDetails**，它们存储在对话范围内。
- en: At the bottom of the diagram, inside the application scope, we have the bean
    instances, **Utility** and **DataHelperController**. All web application users
    share the beans. The conversation beans are able to access the shared information
    in the current session scope and also in the application scope.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在图例底部，在应用范围内，我们有豆实例，**Utility**和**DataHelperController**。所有Web应用用户共享这些豆。对话豆能够访问当前会话范围和应用程序范围内的共享信息。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information on CDI, please read the sister book, *Java EE 7 Developer
    Handbook*, *Packt Publishing*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于CDI的信息，请阅读姊妹书籍，*Java EE 7 开发者手册*，*Packt Publishing*。
- en: Digital e-commerce applications
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字电子商务应用
- en: Java EE applications are well-suited to digital sites that maintain state. If
    the site maintains any sort state with the user in their customer journey, then
    the users are usually involved with conversations. UX testing has shown that,
    for many enterprise sites where lots of interactions occur, there are several
    conversations. To paraphrase, a fellow Java Champion, Antonio Gonclaves, who was
    a member of the Java EE 7 expert group, if your intention is to build digital
    web applications, then it must be able to handle complex flow management.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE应用非常适合维护状态的数字站点。如果网站在用户的客户旅程中维护任何与用户相关的状态，那么用户通常都会参与对话。用户体验测试表明，对于许多发生大量交互的企业网站，存在多个对话。换句话说，Java
    Champion，Java EE 7专家组成员Antonio Gonclaves曾经说过，如果你的目的是构建数字Web应用，那么它必须能够处理复杂的流程管理。
- en: An instant loan is not quite in the same league of the products that fast start-ups
    and entrepreneurs effectively provided as an end-state solution to the global
    economic credit crunch. With the rise in competition from these new agile upstarts,
    many domestic household banks in several of the developed nations have had to
    quickly assemble an instant loan facility product. In this chapter, we will develop
    an instant secure loan facility. Our product is not a full solution, but it shows
    the way to deliver the initial prototype for a digital customer. We do not integrate
    with the financial services, whereas a commercial solution would need management
    information reporting as well as integration with the commercial banking infrastructure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬时贷款并不完全属于快速启动公司和企业家为解决全球经济信用危机提供的最终解决方案的产品行列。随着这些新敏捷初创企业的竞争加剧，许多发达国家的国内家庭银行不得不迅速组建一个瞬时贷款设施产品。在本章中，我们将开发一个瞬时安全贷款设施。我们的产品不是一个完整的解决方案，但它展示了为数字客户交付初始原型的途径。我们不会与金融服务集成，而商业解决方案则需要管理信息报告以及与商业银行基础设施的集成。
- en: Let's move on to the conversational scope more extensively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨对话范围。
- en: Conversational scope
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话范围
- en: Conversational scope is defined by a lifecycle that spans many HTTP requests
    to the server. The developer determines when the scope begins and ends, and most
    importantly, it is associated with a user. The key annotation is defined by a
    CDI specification called `@javax.enterprise.context.ConversationScoped`. When
    you apply this annotation to a controller or POJO, remember to ensure that you
    implement the marker interface, `java.io.Serializable`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对话范围由跨越多个对服务器HTTP请求的生命周期定义。开发者决定范围何时开始和结束，最重要的是，它与用户相关联。关键注解由一个名为`@javax.enterprise.context.ConversationScoped`的CDI规范定义。当你将此注解应用于控制器或POJO时，请记住确保你实现了标记接口，`java.io.Serializable`。
- en: 'CDI also defines an interface, `javax.enterprise.context.Conversation` that
    represents the conversation interface. A conversation can be two distinct states
    of existence: transient and long-running. The transient state means that the conversation
    is a temporary state. When you annotate a bean with `@ConversationScoped`, it
    will be in the transient state by default.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CDI还定义了一个接口，`javax.enterprise.context.Conversation`，它代表对话接口。对话可以存在两种不同的状态：短暂的和长期运行的。短暂状态意味着对话是一个临时状态。当你用`@ConversationScoped`注解一个豆时，它将默认处于短暂状态。
- en: The developer controls when the conversation switches from the transient to
    the long-running state. The conversation, then, becomes active and it maintains
    the holds state of the HTTP user connection, which is usually associated with
    a particular web browser tab. Essentially, a conversation is a unit of work. A
    conversation is started and, eventually, ends.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者控制会话何时从瞬态状态切换到长时间运行状态。然后，会话变得活跃，并保持 HTTP 用户连接的持有状态，这通常与特定的网络浏览器标签相关联。本质上，会话是一个工作单元。会话被启动，最终结束。
- en: 'The following is the definition of `javax.enterprise.context.Conversation`
    interface:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `javax.enterprise.context.Conversation` 接口的定义：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The methods, `begin()` initiate a conversation. A conversational scope POJO
    is marked for long running storage by the CDI container. A conversation has an
    identifier; the other method `begin(String id)` allows the developer to provide
    an explicit one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `begin()` 启动一个会话。CDI 容器通过标记会话作用域 POJO 以便进行长时间运行存储。会话有一个标识符；另一个方法 `begin(String
    id)` 允许开发者提供一个显式的标识符。
- en: The method `end()` terminates a conversation, the CDI container effectively
    discards the contextual information associated with the POJO, and the state returns
    to transient. In order to find out if a conversation is transient, the call `isTransient()`
    is used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `end()` 终止会话，CDI 容器有效地丢弃与 POJO 相关的上下文信息，状态返回瞬态。为了找出会话是否为瞬态，使用 `isTransient()`
    调用。
- en: 'The following diagram illustrates the lifecycle of a CDI conversation scope
    bean:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 CDI 会话作用域 Bean 的生命周期：
- en: '![Conversational scope](img/image00397.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![会话作用域](img/image00397.jpeg)'
- en: Conversation timeout and serialization
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话超时和序列化
- en: As we discussed earlier, the lifespan of a conversation scope is beyond the
    request scope, but cannot survive beyond the session scope. The CDI container
    can timeout a conversation scope and terminate the contextual information in order
    to preserve or recover a resource. This is partially the reason that an annotated
    bean with `@ConversationScoped` must be `Serializable`. A smart CDI container
    and servlet container may transfer a conversation to disk or even to another running
    JVM instance, but it could never attempt this without serialization.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，会话作用域的生命周期超出了请求作用域，但不能在会话作用域之外存活。CDI 容器可以超时会话作用域并终止上下文信息，以保留或恢复资源。这也是为什么带有
    `@ConversationScoped` 注解的 Bean 必须是 `Serializable` 的部分原因。一个智能的 CDI 容器和 Servlet
    容器可能会将一个会话转移到磁盘，甚至转移到另一个正在运行的 JVM 实例，但如果没有序列化，它们永远不会尝试这样做。
- en: The application developer can retrieve the timeout and set it with the methods,
    `getTimeout()` and `setTimeout()`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者可以通过 `getTimeout()` 和 `setTimeout()` 方法检索和设置超时时间。
- en: So now we know what are `@ConversationScoped` and `Conversation`. Let's put
    them to good use in our instant secure lending application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道了 `@ConversationScoped` 和 `Conversation` 是什么。让我们在我们的即时安全贷款应用程序中好好利用它们。
- en: The conversation scope controller
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话作用域控制器
- en: The heart of our digital customer journey is a managed bean called `LendingController`.
    We will break it down gently into easier sections as we go through this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数字客户旅程的核心是一个名为 `LendingController` 的管理 Bean。随着我们通过本章的进展，我们将将其分解成更易于理解的几个部分。
- en: 'The initial implementation looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 初始实现看起来是这样的：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This might appear a complicated controller on the first observation, however,
    there are two important items here. First, we annotate the `LendingController`
    with `@ConversationScoped` and second, we ask the CDI to inject a `Conversation`
    instance into this bean. We also implement the `Serializable` marker interface
    to allow the servlet container to have the freedom to persist and reload beans
    on the fly, if it so chooses and if the implementation supports this feature.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 初看这可能是一个复杂的控制器，然而，这里有两个重要的事项。首先，我们使用 `@ConversationScoped` 注解 `LendingController`，其次，我们要求
    CDI 将 `Conversation` 实例注入到这个 Bean 中。我们还实现了 `Serializable` 标记接口，以便让 Servlet 容器有自由选择在需要时以及在实现支持此功能的情况下，即时持久化和重新加载
    Bean。
- en: Pay particular attention to the helper methods, `checkAndStart()` and `checkAndEnd()`.
    The `checkAndStart()` method starts a new long-running conversation if the current
    state is transient. The `checkAndEnd()` method terminates a long-running conversation
    provided that the current Conversational instance is in the running state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意辅助方法 `checkAndStart()` 和 `checkAndEnd()`。`checkAndStart()` 方法在当前状态为瞬时时启动一个新的长时间运行会话。`checkAndEnd()`
    方法在当前会话实例处于运行状态时终止长时间运行会话。
- en: You can see that some elements of the previous contact detail application have
    made it into our instant lending application. This is by deliberate design.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，前一个联系详情应用程序的一些元素已经进入了我们的即时贷款应用程序。这是经过深思熟虑的设计。
- en: The `LendingController` bean contains an instance member of `Applicant`, which
    is the domain master detail record. It is a JPA entity bean that stores the applicant's
    data. You have already seen the date-of-birth fields. The controller also has
    members related to the monthly payment amount and the total payable amount of
    the loan. It also contains the lower and upper limits for the loan amount and
    the rate, which are exposed as getters and setters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`LendingController`豆包含一个`Applicant`实例成员，这是领域主详细记录。它是一个JPA实体豆，用于存储申请人的数据。你已经看到了出生日期字段。控制器还包括与月供金额和贷款总额相关的成员。它还包含贷款金额和利率的下限和上限，这些作为getter和setter公开。'
- en: Finally, the CDI injects a utility instance into `LendingController`. This is
    an application scoped POJO, which neatly lets us avoid writing a static singleton.
    We shall see the details of the utility class later, but first we must side step
    into a design pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CDI将一个实用实例注入到`LendingController`中。这是一个应用程序范围的POJO，它让我们可以避免编写静态单例。我们将在稍后看到实用类的细节，但首先我们必须绕到一个设计模式。
- en: The Entity-Control-Boundary design pattern
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体-控制-边界设计模式
- en: This instant lending application takes advantage of a particular design pattern
    called Entity-Control-Boundary. This is a pattern that separates the concerns
    and responsibilities for a group of objects in an application. The clue is in
    the imported package names for `LendingController`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个即时贷款应用程序利用了一种特定的设计模式，称为实体-控制-边界。这是一个将应用程序中一组对象的责任和关注点分离的模式。线索在于导入的`LendingController`包名。
- en: To explain very briefly, the notion of entities represents the data model in
    a software application. The control elements are the components in the software
    application that manage the flow of information. The boundary elements belong
    to the application system, but lie on the periphery of the system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，实体的概念代表软件应用中的数据模型。控制元素是管理信息流的软件应用组件。边界元素属于应用程序系统，但位于系统的外围。
- en: You are quite correct in your assumption that this pattern resembles the Model-View-Controller,
    except that the ECB is applicable to the entire software system and the control
    element is more responsible than the controller and user interfaces.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你在假设这个模式类似于模型-视图-控制器时是正确的，除了ECB适用于整个软件系统，控制元素比控制器和用户界面更有责任。
- en: In this application, I placed `LendingController` in the control package, because
    the source code shows that it contains the majority of the business logic. Perhaps,
    for a proper production application, we could delegate our logic into another
    CDI bean or EJB. As a consultant once said to his client, *it depends on the situation*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我将`LendingController`放在控制包中，因为源代码显示它包含大部分业务逻辑。也许，对于一个合适的生产应用程序，我们可以将我们的逻辑委托给另一个CDI豆或EJB。正如一位顾问曾经对他的客户说的那样，*这取决于情况*。
- en: Inside the entity package, there is no controversy; I added the `Applicant`,
    `ContactDetail`, and `Address` classes. These are persistence capable objects.
    You have already seen the `ContactDetail` entity bean in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. JSF Validation and AJAX"), *JSF Validation and AJAX*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体包内部，没有争议；我添加了`Applicant`、`ContactDetail`和`Address`类。这些是持久化对象。你已经看到了在[第4章](part0043.xhtml#aid-190861
    "第4章。JSF验证和AJAX")中的`ContactDetail`实体豆，*JSF验证和AJAX*。
- en: I put the `ApplicantService` EJB in the boundary package, because it lies on
    the periphery and it is responsible for data access.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`ApplicantService` EJB放在边界包中，因为它位于外围，并且负责数据访问。
- en: The customer journey
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户旅程
- en: Let's delve back into `LendingController` and reveal our customer journey. We
    assume that we have sat with creative designers and the UX team and come up with
    a design. The application is based on a series of linear web pages organized into
    a wizard. For the sake of this basic example, we only allow the consumer to progress
    to the next page when they successfully enter valid information for the current
    page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次深入探讨`LendingController`并揭示我们的客户旅程。我们假设我们已经与创意设计师和用户体验团队会面，并提出了一个设计方案。该应用程序基于一系列线性网页，组织成一个向导。为了这个基本示例，我们只允许消费者在成功输入当前页面的有效信息后，才能进入下一页。
- en: 'The following are the topographical titles for each page:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为每个页面设定的标题：
- en: '| Step | Page | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 页面 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Getting started | Provide the customers with information about the eligibility
    criteria |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 开始 | 向客户提供关于资格标准的详细信息 |'
- en: '| 2 | Your details | The customers enter their personal contact detail and
    date of birth |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 您的详细信息 | 客户输入他们的个人联系详情和出生日期 |'
- en: '| 3 | Your rate | The customers selects their loan amount and term |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 您的利率 | 客户选择贷款金额和期限 |'
- en: '| 4 | Your address | The customers enters their full home address and telephone
    numbers |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 您的地址 | 客户输入他们的完整家庭地址和电话号码 |'
- en: '| 5 | Confirm | The consumers agree to the legal terms of service and view
    the summary |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 确认 | 消费者同意服务条款并查看摘要 |'
- en: '| 6 | Completion | The consumers see an acknowledgement of their application
    form submission |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 完成 | 消费者看到他们申请表提交的确认 |'
- en: 'This is now quite simple to implement in the controller with the following
    extract:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在在控制器中实现起来相当简单，以下是一个示例：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `LendingController` bean has several action methods that correspond to the
    user requirements, namely `doGettingStarted()`, `doYourDetails()`, `doYourRate()`,
    `doYourAddress()`, `doConfirm()`, and `doCompletion()`. These action methods progress
    the customer to the next page view by simply returning the name. For most of these
    methods, apart from `doCompletion()`, we ensure that the conversation is in a
    long-running state by calling `checkAndStart()`. In the `doCompletion()` and `cancel()`
    methods, we invoke `checkAndEnd()` to ensure that the conversation reverts to
    the transient state. The method `doCompletion()` utilizes `ApplicationService`
    to save the data, the `Applicant` entity instance, to the underlying database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`LendingController` 面豆有多个与用户需求相对应的操作方法，即 `doGettingStarted()`、`doYourDetails()`、`doYourRate()`、`doYourAddress()`、`doConfirm()`
    和 `doCompletion()`。这些操作方法通过简单地返回名称来推进客户到下一个页面视图。对于这些方法中的大多数，除了 `doCompletion()`
    之外，我们通过调用 `checkAndStart()` 确保会话处于长时间运行状态。在 `doCompletion()` 和 `cancel()` 方法中，我们调用
    `checkAndEnd()` 确保会话回到短暂状态。`doCompletion()` 方法利用 `ApplicationService` 将数据、`Applicant`
    实例保存到底层数据库。'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the example code, we are cheating slightly by applying `checkAndStart()`
    at the beginning of each action method. For production code, we should usually
    ensure that it is an error or a redirection if the user jumps into a bookmarkable
    URL that is supposed to have a conversation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，我们在每个操作方法的开头应用 `checkAndStart()` 是一种欺骗行为。对于生产代码，我们通常应该确保如果用户跳转到应该有会话的标记URL，那么它将是一个错误或重定向。
- en: Let's examine the entities and fill in more of the blanks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查实体并填写更多的空白。
- en: Entity classes
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体类
- en: The entity `Applicant` is a master detail record. This is known as the core
    domain object. It stores the data for the customer's application for the instant
    secured loan. We capture the customer's loan information such as the contact details
    (`ContactDetail`), the address (`Address`), the telephone numbers (home, work,
    and mobile), and, most importantly, the financial details.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实体 `Applicant` 是一个主从记录。这被称为核心域对象。它存储了客户对即时保障贷款的申请数据。我们捕获客户的贷款信息，例如联系详情（`ContactDetail`）、地址（`Address`）、电话号码（家庭、工作和手机），最重要的是，财务详情。
- en: 'The `Applicant` entity would be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicant` 实体如下所示：'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Applicant` entity stores the loan amount, rate, term, and also a submission
    date. It also contains the home, work, and mobile telephone numbers. An applicant
    has a one-to-one unidirectional relationship with both, the `ContactDetail` and
    `Address` entities.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicant` 实体存储贷款金额、利率、期限，以及提交日期。它还包含家庭、工作和手机电话号码。申请人与 `ContactDetail` 和 `Address`
    实体都存在一对一的单向关系。'
- en: For the financial properties such as `loanRate` and `loanAmount`, please note
    that we prefer to use `BigDecimal` rather than the primitive floating-point type
    for monetary accuracy during calculations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 `loanRate` 和 `loanAmount` 这样的财务属性，请注意，我们更喜欢在计算时使用 `BigDecimal` 而不是原始的浮点类型，以确保货币计算的准确性。
- en: 'The way to explain a domain object to the stakeholder would be: a customer
    has a loan rate, a loan term, and must agree electronically to the legal conditions.
    With this information, the system can compute the loan and how much the customer
    pays back each month, and displays it at the time of applying for the loan.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 向利益相关者解释领域对象的方式是：客户有一个贷款利率，一个贷款期限，并且必须电子方式同意法律条件。有了这些信息，系统可以计算贷款以及客户每月需要偿还的金额，并在申请贷款时显示出来。
- en: 'You have already seen the `ContactDetail` entity. It is exactly the same as
    before and only the package name has been refactored to entity. The following
    is the extract code of the `Address` entity bean:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了`ContactDetail`实体。它与之前完全相同，只是包名已被重构为实体。以下是`Address`实体bean的提取代码：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The entity `Address` represents the applicant's correspondence and legal personal
    address. There is nothing special to see here. It is a bog standard entity bean
    that you will see in e-commerce applications.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实体`Address`代表申请人的通信和法律个人地址。这里没有什么特别之处。它是一个标准的实体bean，你将在电子商务应用程序中看到。
- en: May I remind you that the source code for the examples are online and are a
    part of this book for your reference.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请允许我提醒您，示例的源代码是在线的，并且是本书的一部分，供您参考。
- en: Data service
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据服务
- en: How do we save the customer's input into persistence storage? Our application
    utilizes a stateful session EJB, and it provides methods to save and retrieve
    the `Applicant` entity records.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将客户的输入保存到持久存储中？我们的应用程序使用有状态的会话EJB，并提供保存和检索`Applicant`实体记录的方法。
- en: 'The class `ApplicantService` is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicantService`类如下：'
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `add()` method inserts a new applicant into the database. The `findAll()`
    and `findById()` are not used in the instant loan example. These query methods
    are there for illustrative purposes only. Presumably, one requires access to the
    applicant data in another part of the full application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`方法将新申请人插入到数据库中。`findAll()`和`findById()`在即时贷款示例中未使用。这些查询方法仅用于说明目的。假设，在完整应用程序的另一个部分需要访问申请人数据。'
- en: We have covered the entity, control, and boundary of our application. It is
    time to examine the page views.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了应用程序的实体、控制和边界。现在是时候检查页面视图了。
- en: Page views
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面视图
- en: The flow of control for the view is defined by the customer journey. Each page
    view represents a particular requirement that the business stakeholder wants to
    see. The index page view is a requirement, because the lender wants the customer
    to see a landing page. It is also a legal duty of compliance required by national
    government authorities. You will also notice that the customer journey maps to
    a linear flow, but not for all journeys.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的控件流程由客户旅程定义。每个页面视图代表业务利益相关者希望看到的特定要求。索引页面视图是一个要求，因为贷款人希望客户看到着陆页。它也是国家政府当局要求的合规法律义务。您还会注意到客户旅程映射为线性流程，但并非所有旅程都是如此。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Payday loan scheme must follow compliance requirements. Refer to the websites
    of the UK Financial Conduct Authority ([https://goo.gl/NfbFbK](https://goo.gl/NfbFbK))
    and the US Consumer Financial Protection Bureau ([http://goo.gl/3V9fxk](http://goo.gl/3V9fxk)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 短期贷款方案必须遵循合规要求。请参阅英国金融服务管理局（[https://goo.gl/NfbFbK](https://goo.gl/NfbFbK)）和美国消费者金融保护局（[http://goo.gl/3V9fxk](http://goo.gl/3V9fxk)）的网站。
- en: 'The following table outlines the relationship between the controller actions
    and the view pages:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格概述了控制器操作与视图页面之间的关系：
- en: '| View source | View target | Action method |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 查看源代码 | 查看目标 | 操作方法 |'
- en: '| --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `index` | `getting-started` | `jumpGettingStarted()` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `index` | `getting-started` | `jumpGettingStarted()` |'
- en: '| `getting-started` | `your-detail` | `doGettingStarted()` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `getting-started` | `your-detail` | `doGettingStarted()` |'
- en: '| `your-details` | `your-rate` | `doYourDetails()` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `your-details` | `your-rate` | `doYourDetails()` |'
- en: '| `your-rate` | `your-address` | `doYourRate()` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `your-rate` | `your-address` | `doYourRate()` |'
- en: '| `your-address` | `confirm` | `doYourAddress()` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `your-address` | `confirm` | `doYourAddress()` |'
- en: '| `confirm` | `completion` | `doConfirm()` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `confirm` | `completion` | `doConfirm()` |'
- en: '| `completion` | `index` | `doCompletion()` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `completion` | `index` | `doCompletion()` |'
- en: All the view pages are suffixed with the extension `xthml` in the preceding
    table. It is quite clear there is a linear flow of work happening in the conversation.
    The conversation scope ideally begins when the customer enters the getting-started
    view through the `jumpGettingStarted()` action method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，所有视图页面都带有扩展名 `xthml`。很明显，在对话中正在发生线性工作流程。对话范围理想地开始于客户通过 `jumpGettingStarted()`
    动作方法进入开始视图时。
- en: An initial page view
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个初始页面视图
- en: 'Let''s look at the initial `index.xhtml` page view. This is the landing page
    of the loan application. The following is a screenshot of our loan application
    and the landing page:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看初始的 `index.xhtml` 页面视图。这是贷款申请的着陆页。以下是我们贷款申请和着陆页的截图：
- en: '![An initial page view](img/image00398.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![一个初始页面视图](img/image00398.jpeg)'
- en: 'The view for this page `index.xhtml` is very straightforward. It features a
    basic link button component and features a Bootstrap carousel:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面的视图 `index.xhtml` 非常简单直接。它包含一个基本的链接按钮组件，并使用 Bootstrap 滚动图：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `<h:link>` element is the most important feature of this view. The outcome
    of this custom tag references the `jumpGettingStarted()` method in the controller,
    which begins a long-running conversation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:link>` 元素是这个视图最重要的功能。这个自定义标签的输出引用了控制器中的 `jumpGettingStarted()` 方法，这开始了一个长时间运行的对话。'
- en: Even at this stage, before a conversation begins, we can deliver information
    to the customer. So, in a further section of the page view, we tell the customer
    about the minimum and maximum loan amounts and the rates using expression language.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个阶段，在对话开始之前，我们也可以向客户传递信息。因此，在页面视图的进一步部分，我们使用表达式语言告诉客户最低和最高贷款金额以及利率。
- en: 'The following is the code, which is also a part of the page view `index.xhtml`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码，也是页面视图 `index.xhtml` 的一部分：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This page makes use of the JSF core tag `<f:convertNumber>` to format the floating
    numbers into monetary formats. The HTML entity character `&#37;` represents the
    percent character (`%`). Remember, the view technology is strictly Facelets and
    not HTML5.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面使用了 JSF 核心标签 `<f:convertNumber>` 将浮点数格式化为货币格式。HTML 实体字符 `&#37;` 代表百分号字符
    (`%`)。记住，视图技术是严格使用 Facelets 而不是 HTML5。
- en: Getting started page view
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始页面视图
- en: The getting started view is even simpler. We present the customer with information
    regarding their eligibility to apply for a loan. The customer must be 18 years
    or over; we repeat how much they borrow and for how long.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 开始视图甚至更简单。我们向客户展示他们申请贷款的资格信息。客户必须年满18岁；我们重复说明他们可以借多少钱以及借款期限。
- en: 'The view is called `getting-started.xhtml` and looks like the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图被命名为 `getting-started.xhtml`，如下截图所示：
- en: '![Getting started page view](img/image00399.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![开始页面视图](img/image00399.jpeg)'
- en: 'There is a single JSF form with a button to move the customer to the next page
    view, `your-details.xhtml`. There is no need to see the full source code for this
    view, because it is mainly mark-up HTML. However, we have another command link:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个单独的 JSF 表单，有一个按钮可以将客户移动到下一个页面视图 `your-details.xhtml`。没有必要查看这个视图的完整源代码，因为它主要是标记
    HTML。然而，我们还有一个命令链接：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Contact details page view
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联系详情页面视图
- en: The next view is the familiar contact details screen. We've subsumed it from
    the previous chapters into the instant secure loan example. We've also repurposed
    the JSF expression language to reference the controller and the nested properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个视图是熟悉的联系详情屏幕。我们将它从前面的章节中纳入即时安全贷款示例。我们还重新使用了 JSF 表达式语言来引用控制器和嵌套属性。
- en: 'The page-authoring code for the first name field is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首名字段页面编写代码如下：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The EL `#{lendingController.applicant.contactDetail.firstName}` refers to the
    relevant nested entity bean property. We also retain the AJAX JSF validation features
    from [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation and AJAX"),
    *JSF Validation and AJAX* to provide a rich customer journey.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: EL `#{lendingController.applicant.contactDetail.firstName}` 引用了相关的嵌套实体属性。我们还保留了来自
    [第4章](part0043.xhtml#aid-190861 "第4章。JSF 验证和 AJAX") 的 AJAX JSF 验证功能，*JSF 验证和 AJAX*，以提供丰富的客户旅程。
- en: 'For this view, we use a JSF command button to submit the form:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个视图，我们使用 JSF 命令按钮提交表单：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We also have the obligatory cancel operation just in case the customer no longer
    wants to apply for the loan that day.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了必要的取消操作，以防客户当天不再想申请贷款。
- en: 'The following is a screenshot of the `your-details.xhtml` view, which allows
    the customer to enter their contact details:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `your-details.xhtml` 视图的截图，允许客户输入他们的联系信息：
- en: '![Contact details page view](img/image00400.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![联系信息页面视图](img/image00400.jpeg)'
- en: Now it is time for something new. How about adding in some HTML5 goodness to
    the good old JavaServer Faces?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候做一些新的事情了。何不向老牌的 JavaServer Faces 中添加一些 HTML5 的好处？
- en: Your rate page view
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的评分页面视图
- en: The loan amount and rate page view relies on the HTML5 range control element,
    which, on most standard compliant browsers, is rendered as a horizontal slider.
    JSF has no built-in support for a range control; so for this view, we make use
    of the JSF HTML5 friendly support capability. The JSF specification allows us
    to write a markup that looks like a standard HTML component, but if we supply
    a special attribute, JSF treats it as a UI component. The pass-through ability
    works only with the markup that resembles the existing JSF core controls.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 贷款金额和利率页面视图依赖于 HTML5 范围控件元素，在大多数符合标准浏览器中，它被渲染为一个水平滑块。JSF 没有内置对范围控件的支持；因此，对于此视图，我们利用了
    JSF HTML5 友好支持功能。JSF 规范允许我们编写看起来像标准 HTML 组件的标记，但如果我们提供一个特殊属性，JSF 就将其视为 UI 组件。透传功能仅适用于类似于现有
    JSF 核心控件标记。
- en: 'A picture is worth a thousand words, so let''s take a look at the following
    screenshot of `your-rate.xhtml`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一图胜千言，让我们看看以下 `your-rate.xhtml` 的截图：
- en: '![Your rate page view](img/image00401.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![您的评分页面视图](img/image00401.jpeg)'
- en: 'The view uses AJAX partial updates and the HTML5 friendly markup facility.
    Let me show you the code for the form:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该视图使用 AJAX 部分更新和 HTML5 友好的标记功能。让我向您展示表单的代码：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As with all JSF forms, we first declare a form called `yourRateForm` and style
    it using Bootstrap CSS. Concentrating on the control element, you will notice
    that it is written as `<input>` as not `<h:inputText>`. This is because the JSF
    `<h:inputText>` does not support the new HTML5 Range element. Ordinarily, the
    lack of access to a richer UI component would have been an issue for the instant
    secure lending.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有 JSF 表单一样，我们首先声明一个名为 `yourRateForm` 的表单，并使用 Bootstrap CSS 进行样式设计。专注于控件元素，您会注意到它被编写为
    `<input>` 而不是 `<h:inputText>`。这是因为 JSF 的 `<h:inputText>` 不支持新的 HTML5 范围元素。通常，无法访问更丰富的
    UI 组件会对即时安全贷款造成问题。
- en: The HTML5 Range Input element accepts a minimum, a maximum, and the current
    value. It also accepts a step size.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 范围输入元素接受最小值、最大值和当前值。它还接受步长大小。
- en: HTML5 friendly support
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML5 友好支持
- en: JSF 2.2 allows HTML5 friendly components with a new tag library URI for an XML
    namespace of ``. With the attributes `jsf:id`, `jsf:label`, and `jsf:attribute`,
    HTML5 tags have a visibility within the JSF framework.``
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 允许使用新的标签库 URI 和 XML 命名空间 ``. 通过属性 `jsf:id`、`jsf:label` 和 `jsf:attribute`，HTML5
    标签在 JSF 框架中具有可见性。`
- en: '``The full XML namespace for `your-rate.xhtml` looks as follows:``'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '```your-rate.xhtml` 的完整 XML 命名空间如下所示：`'
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`We will discuss composite components later in the chapter. The HTML5 friendly
    tag library exposes a standard HTML input component to the JSF lifecycle. It is
    also easier for the creatives, not experienced in JSF or Java, to understand a
    page view. We do not have to worry any longer about the special name mangling
    that JSF applies to the view IDs; this means that component IDs are useful for
    both, HTML and JavaScript.`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`我们将在本章后面讨论组合组件。HTML5 友好的标签库向 JSF 生命周期公开了标准的 HTML 输入组件。对于不熟悉 JSF 或 Java 的创意人员来说，理解页面视图也更简单。我们不再需要担心
    JSF 对视图 ID 应用特殊名称混淆的问题；这意味着组件 ID 对 HTML 和 JavaScript 都是有用的。`'
- en: '`Using AJAX for a partial update`'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`使用 AJAX 进行部分更新`'
- en: '``In [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation and AJAX"),
    *JSF Validation and AJAX*, we learnt how to validate the form properties using
    Ajax. JSF allows the developers to perform a partial page update using the `<f:ajax>`
    custom tag.``'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '``在 [第 4 章](part0043.xhtml#aid-190861 "第 4 章。JSF 验证和 AJAX") 中，我们学习了如何使用 Ajax
    验证表单属性。JSF 允许开发者使用 `<f:ajax>` 自定义标签执行部分页面更新。```'
- en: '`To enable a rich user example, whenever the customer changes the loan amount
    slider, we invoke the server side to recalculate the monthly payment amount. We
    achieve this by attaching an event listener to the change in value. The code for
    this would be as follows:`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`为了启用丰富的用户示例，每当客户更改贷款金额滑块时，我们都会调用服务器端来重新计算月付款金额。我们通过附加一个事件监听器来跟踪值的变化来实现这一点。相应的代码如下：`'
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`A new addition to the code is the render attribute, which specifies the unique
    ID of the JSF UI components that will be re-rendered on an AJAX response. In other
    words, we declaratively specify the components to be re-rendered on the completion
    of an AJAX behavior to JSF, and thus, obtain a partial update.`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`代码的新增功能是渲染属性，它指定了在AJAX响应中将被重新渲染的JSF UI组件的唯一ID。换句话说，我们声明性地指定了在AJAX行为完成时JSF上要重新渲染的组件，从而获得部分更新。`'
- en: '`Binding components`'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`绑定组件`'
- en: '`Let''s see the other components that the HTML5 Range element, the loan amount
    in this case, binds with.`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`让我们看看HTML5 Range元素（在本例中为贷款金额）与之绑定的其他组件。`'
- en: '`Take a look at the following code:`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`看看下面的代码：`'
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '``The progress markup is directly copied from the Bootstrap CSS component examples.
    We plugged in the value expressions to pull information from the `LendingController`
    and the `Applicant` instances.``'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`进度标记直接复制自Bootstrap CSS组件示例。我们插入了值表达式，从`LendingController`和`Applicant`实例中提取信息。`'
- en: '``Right at the top of the preceding code extract, we set the initial value
    of the progress bar with the JSTL core tag `<c:set>`.``'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`在前面代码摘录的顶部，我们使用JSTL核心标签`<c:set>`设置了进度条的初始值。`'
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '``This demonstrates that the unified expression language in EL 3.0 has the
    ability to retrieve the late bounded values in JSF to compute a result. The result
    is set in a page scope variable called `loanAmountWide`. This variable is accessed
    later with `$(loanAmountWidth)` and it sets the initial position value of the
    Bootstrap CSS progress bar component..``'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`这表明EL 3.0中的统一表达式语言具有检索JSF中后期绑定的值以计算结果的能力。结果被设置在名为`loanAmountWide`的页面作用域变量中。稍后，使用`$(loanAmountWidth)`访问该变量，并设置Bootstrap
    CSS进度条组件的初始位置值。`'
- en: '`The HTML5 standard has no built-in support for displaying the value of an
    HTML5 Range element that works across all the top web browsers. At the time of
    writing, this feature was missing, and the W3C or WHATWG may tighten up this weakness
    in the HTML5 specification in the near future. Until then, we will use jQuery
    and JavaScript to fill the void.`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTML5标准没有内置支持来显示HTML5 Range元素在所有顶级浏览器中的值。在撰写本文时，这个特性缺失，W3C或WHATWG可能在不久的将来加强HTML5规范中的这一弱点。在此之前，我们将使用jQuery和JavaScript来填补这一空白。`'
- en: '``If you noticed, the text is identified with `loanAmountText` and the progress
    component is denoted by `loanAmountProgress` in the preceding code. It is trivial
    to write the jQuery for binding the HTML5 Range elements to these fields.``'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`如果你注意到了，前面的代码中，文本被标识为`loanAmountText`，进度组件被表示为`loanAmountProgress`。将HTML5
    Range元素绑定到这些字段上的jQuery代码是微不足道的。`'
- en: '``We need a JavaScript module to achieve the binding. The complete code to
    `/resources/app/main.js` is given as follows:``'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`我们需要一个JavaScript模块来实现绑定。完整的代码位于`/resources/app/main.js`中，如下所示：`'
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '``The module `instantLending.Main` defines a binding of an HTML Range element
    to two other components: a progress bar and a label text area. For a quick revision
    of the JavaScript module, refer to [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Digital
    Java EE 7"), *Digital Java EE 7*.``'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`模块`instantLending.Main`定义了一个HTML Range元素与两个其他组件的绑定：一个进度条和一个标签文本区域。为了快速复习JavaScript模块，请参阅[第1章](part0015.xhtml#aid-E9OE1
    "第1章. 数字Java EE 7")，*数字Java EE 7*。`'
- en: '``The module has an `init()` function that sets up the binding using the jQuery
    document loading mechanism. It calls a function called `associateRangeToText()`,
    which computes the percentage travelled for the progress bar and writes that value
    into the text element area. The function accepts the document ID for the relevant
    components: the range, progress, and text label components. It attaches an anonymous
    function to the range element; when the user changes the component, it updates
    the associated component.``'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`该模块有一个`init()`函数，它使用jQuery文档加载机制设置绑定。它调用一个名为`associateRangeToText()`的函数，该函数计算进度条的百分比并将其值写入文本元素区域。该函数接受相关组件的文档ID：范围、进度和文本标签组件。它将一个匿名函数附加到范围元素上；当用户更改组件时，它更新相关组件。`'
- en: '``The module `main.js` also defines a helpful prototype method added to the
    JavaScript number type. The following code shows how it works:``'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`模块`main.js`还定义了一个添加到JavaScript数字类型中的有用原型方法。以下代码显示了它是如何工作的：`'
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '``The method `formatMoney()` formats a floating-point value type to the monetary
    output as a String. This code has been contributed by Patrick Desjardins to Stack
    Overflow. The following code illustrates how to invoke this function:``'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '```formatMoney()`方法将浮点数值类型格式化为货币输出作为字符串。此代码由Patrick Desjardins贡献给Stack Overflow。以下代码说明了如何调用此函数：`'
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`The first parameter is the fixed fraction size, the second parameter determines
    the decimal symbol, and the third specifies the thousand-unit character.`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`第一个参数是固定分数大小，第二个参数确定小数符号，第三个指定千位字符。`'
- en: '`With this module, we bound the HTML5 Range element to other elements in the
    page, thus demonstrating the HTML5 friendly support within JSF.`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`使用此模块，我们将HTML5 Range元素绑定到页面上的其他元素，从而展示了JSF对HTML5的友好支持。`'
- en: '`Updating areas with AJAX partial updates`'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`使用AJAX局部更新更新区域`'
- en: '``How does JSF update an area of the page with an AJAX response? The developer
    specifies the UI components that are updated with the render attribute of the
    `<f:ajax>` tag. In modern web design, which component can be treated as an HTML
    Layer element `<div>` inside the standard JSF rendering kit? The answer for this
    is to use the `<h:panelGroup>` JSF custom tag. We can supply this UI component
    with a unique identifier, and when the AJAX behavior completes, JSF renders this
    component.``'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '``JSF如何使用AJAX响应更新页面上的区域？开发者指定了由`<f:ajax>`标签的render属性更新的UI组件。在现代网页设计中，哪个组件可以被视为标准JSF渲染套件内的HTML层元素`<div>`？这个答案是通过使用`<h:panelGroup>`
    JSF自定义标签。我们可以为这个UI组件提供一个唯一标识符，当AJAX行为完成时，JSF渲染此组件。`'
- en: '``The following is the code extract for the instant loan rate where the div
    element is identified by `loanRateOutput`:``'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '``以下是为即时贷款利率的代码摘录，其中div元素通过`loanRateOutput`标识：`'
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '``The `<h:panelGroup>` renders a div layer by default and thus contains the
    progress bar component and the text output content. The div is rendered after
    an invocation to the method `recalculatePMT()` in `LendingController`. Refer to
    the preceding sections for a reminder of this code.``'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '```<h:panelGroup>`默认渲染一个div层，因此包含进度条组件和文本输出内容。该div在`LendingController`中调用`recalculatePMT()`方法之后渲染。请参考前面的章节以提醒此代码。`'
- en: '``The functions `recalclulatePMT()` and `recalculateLoanRate()` look as follows:``'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '``函数`recalclulatePMT()`和`recalculateLoanRate()`如下所示：`'
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '``The function `recalculatePMT()` uses the classic mathematical formula to
    evaluate the monthly payment amount for the loan based on the principal amount,
    length of the term and, of course, the rate.``'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '``函数`recalculatePMT()`使用经典的数学公式根据本金金额、期限长度以及当然的利率来评估贷款的月付款金额。`'
- en: '``The function `recalculateLoanRate()` uses a utility, an application-scoped
    CDI bean, to work out the rate according to a table of rate limits that vary according
    to the loan account.``'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '``函数`recalculateLoanRate()`使用一个实用工具，一个应用范围的CDI豆，根据贷款账户的利率限制表来计算利率。`'
- en: '``So let''s recap. The JavaScript module `instantLending::Main` updates on
    the client side. When the customer changes the loan amount then this module changes
    the progress bar component and the text content. Simultaneously, JSF invokes an
    AJAX request to the server side and invokes the action event listener, `recalculatePMT()`.
    The framework eventually receives the AJAX response and then re-renders the loan
    rate, term control, and the summary area.``'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '``让我们回顾一下。JavaScript模块`instantLending::Main`在客户端更新。当客户更改贷款金额时，此模块会更改进度条组件和文本内容。同时，JSF向服务器端发起AJAX请求并调用动作事件监听器`recalculatePMT()`。框架最终接收到AJAX响应，然后重新渲染贷款利率、期限控件和摘要区域。`'
- en: '``To complete the XHTML, let''s inspect the remaining content on this page
    view, your-`rate.xhtml`. The following is the content for the loan term, which
    is a drop-down component:``'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '``为了完成XHTML，让我们检查这个页面视图上剩余的内容，你的`rate.xhtml`。以下是为贷款期限的内容，它是一个下拉组件：`'
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '``The component also features a `<f:ajax>` custom tag that invokes the recalculation
    event listener. Therefore, if the customer selects a different term for the loan,
    `loanRateOutput` and `paymentMonthlyOutput` also change along with the summary
    due to a partial AJAX update.``'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '``该组件还包含一个`<f:ajax>`自定义标签，用于调用重新计算事件监听器。因此，如果客户选择不同的贷款期限，由于AJAX局部更新，`loanRateOutput`和`paymentMonthlyOutput`也会随着摘要一起改变。`'
- en: '`Finally, let''s see the content for the summary area:`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`最后，让我们看看摘要区域的内容：`'
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '``In the preceding code extract, we use `<h:outputText>` instead of `<h:panelGroup>`
    to update only certain parts of the content using partial AJAX updates. A JSF
    output text element is a JSF UI component, so it works by asking for the AJAX
    behavior to be re-rendered.``'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '``在先前的代码摘录中，我们使用`<h:outputText>`而不是`<h:panelGroup>`来仅使用部分AJAX更新更新内容的一部分。JSF输出文本元素是一个JSF
    UI组件，它通过请求AJAX行为重新渲染来工作。``'
- en: '`The address page view`'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`地址页面视图`'
- en: '`The address page view captures the customer''s primary home address. This
    page also features an AJAX validation on the client side.`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`地址页面视图捕获客户的住宅主要地址。这个页面还具备客户端的AJAX验证。`'
- en: '``This code is so similar to the contact details form that we will leave out
    the code extract and the trees here. I will only show the first `houseOrFlatNumber`
    fields in the following code:``'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '``这段代码与联系详情表单如此相似，所以我们在这里省略代码摘录和树形结构。我将在下面的代码中只展示第一个`houseOrFlatNumber`字段：``'
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '``The following is a screenshot of the `your-address.xhtml` pageview.``'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '``以下是对`your-address.xhtml`页面视图的截图。``'
- en: '`![The address page view](img/image00402.jpeg)`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`![地址页面视图](img/image00402.jpeg)`'
- en: '`The confirmation page view`'
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`确认页面视图`'
- en: '``The confirmation page view is where the customer sees all the details about
    their instant loan. In this view, they have a chance to read the terms and conditions
    of the contract. The customer must either select the checkbox to accept the agreement,
    or they can hit the cancel button to terminate the conversation. The cancel button
    invokes the `cancel()` method in `LendingController`, which, in turn, invokes
    `checkAndEnd()`.``'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '``确认页面视图是客户看到他们即时贷款所有详情的地方。在这个视图中，他们有机会阅读合同的条款和条件。客户必须选择复选框以接受协议，或者他们可以点击取消按钮来终止对话。取消按钮会在`LendingController`中调用`cancel()`方法，然后反过来调用`checkAndEnd()`。``'
- en: '`The only relevant code here is for the terms of agreement checkbox. The code
    extract is as follows:`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`这里唯一相关的代码是关于协议复选框的。代码摘录如下：`'
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '``We use `<h:selectBooleanCheckBox>` with immediate AJAX validation on the
    blur event. This ensures that the Boolean property is set to true on the server
    side. However, we must still verify on form submission, as we see in the action
    controller method:``'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '``我们使用`<h:selectBooleanCheckBox>`在blur事件上执行即时AJAX验证。这确保了布尔属性在服务器端被设置为true。然而，我们仍然必须在表单提交时进行验证，正如我们在动作控制器方法中看到的那样：``'
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '``Inside the `doConfirm()` method, we recalculate the monthly payment term
    just to be sure. We check that the the applicant''s data values have not changed,
    set the date of submission, and then we invoke the `ApplicationService` to insert
    a new record into the database. After this method, the customer is said to have
    applied successfully.``'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '``在`doConfirm()`方法内部，我们重新计算月供期限以确保无误。我们检查申请人的数据值是否没有改变，设置提交日期，然后调用`ApplicationService`将一条新记录插入到数据库中。在这个方法之后，客户被认为是成功申请了。``'
- en: '``We include a manual check on `isTermsAgreed()`, because it is a legal requirement
    in the contract for the customer to accept the terms and conditions. It is probably
    controversial to raise an application error `IllegalStateException` here. More
    likely, the developer would print a message to an error log, and also raise an
    exception. The servlet specification allows different exceptions to be trapped
    and sent to a certain error page. Therefore, if we created a custom runtime exception
    such as `LegalTermsAgreementException`, we could responsibly handle such conditions.``'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '``我们在`isTermsAgreed()`上包含了一个手动检查，因为这是合同中客户接受条款和条件的法律要求。在这里引发一个应用程序错误`IllegalStateException`可能是有争议的。更有可能的是，开发者会向错误日志打印一条消息，并引发异常。Servlet规范允许捕获不同的异常并将它们发送到特定的错误页面。因此，如果我们创建了一个自定义运行时异常，例如`LegalTermsAgreementException`，我们就可以负责任地处理这些情况。``'
- en: '`In a production system, the end of this sequence would probably trigger an
    additional business process. For instance, the work message might be sent to another
    case working area using a messaging bus, JMS. In a modern digital application,
    the customer should expect an e-mail to be sent with the confirmation and the
    loan contract details. Of course, this is an additional exercise for the reader
    to deliver this requirement.`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`在生产系统中，这个序列的结束可能会触发一个额外的业务流程。例如，工作消息可能会通过消息总线JMS发送到另一个工作区域。在现代数字应用中，客户应该期待收到带有确认和贷款合同详情的电子邮件。当然，这是读者需要额外完成的任务。`'
- en: '``The following is a screenshot for the confirmation view, `confirm.xhtml`:``'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '``以下是对确认视图的截图，`confirm.xhtml`：``'
- en: '`![The confirmation page view](img/image00403.jpeg)`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`![确认页面视图](img/image00403.jpeg)`'
- en: '`Let''s move to the final page view of completion.`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`让我们转到完成的最终页面视图。`'''''
- en: '`The completion page view`'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`完成页面视图`'
- en: '``The complete stage is straightforward. The customer has submitted his application,
    so we only need to inform him or her about this and then the conversation ends.
    The following is the full code for the `doCompletion()` method in `LendingController`:``'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '``完成阶段很简单。客户已提交申请，所以我们只需通知他或她这一点，然后对话结束。以下是`LendingController`中`doCompletion()`方法的完整代码：`'''''
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`This method simply ends the conversation scope, because the user''s digital
    customer journey is finished by then.`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '``此方法仅结束对话范围，因为到那时用户的数字客户旅程已经完成。`'''''
- en: '`Now we have a complete flow, a digital customer journey. What is missing?
    We should add the steps to accept a valid bank account, a bank sorting code, IBAN
    number, and an integration into the national bank infrastructure! Of course, we
    would also need a certain level of financial capital, enough money to satisfy
    the regulators; in the United Kingdom, this would be the Financial Conduct Authority
    ([http://www.fca.org.uk/](http://www.fca.org.uk/)).`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '``现在我们有一个完整的流程，一个数字客户旅程。还缺少什么？我们应该添加接受有效银行账户、银行分类代码、IBAN号码以及与国家银行基础设施集成的步骤！当然，我们还需要一定水平的金融资本，足够的资金来满足监管机构；在英国，这将是由金融行为管理局([http://www.fca.org.uk/](http://www.fca.org.uk/))。`'''''
- en: '``A screenshot of this page view, `completion.xhtml`, is as follows:``'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '``本页面的截图，`completion.xhtml`，如下所示：`'''''
- en: '`![The completion page view](img/image00404.jpeg)`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`![完成页面视图](img/image00404.jpeg)`'
- en: '`Utility classes`'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`实用类`'
- en: '``Often in applications, we refactor common methods and properties into a separate
    utility class, which has features so common that they do not make sense in any
    particular package domain. We often place these concepts inside static methods
    in a singleton. With Java EE, we can do much better than that. Since CDI supports
    application scope, we can simply move our commons methods into a POJO and make
    CDI inject the bean into dependent objects. It is the smart way to handle the
    data, the time and monthly payment term calculation in the `LendingController`
    example.``'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '``通常在应用程序中，我们将常见的方法和属性重构到单独的实用类中，这些功能如此普遍，以至于它们在任何特定的包域中都没有意义。我们通常将这些概念放在单例的静态方法中。使用Java
    EE，我们可以做得更好。由于CDI支持应用范围，我们可以简单地将我们的公共方法移动到一个POJO中，并让CDI将Bean注入到依赖对象中。这是处理数据、时间和月付款期限计算的`LendingController`示例中的智能方式。`'''''
- en: '``The application scope bean `DateTimeController` acts as a helper for the
    page author views:``'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '``应用范围Bean `DateTimeController`充当页面作者视图的辅助工具：`'''''
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '``The `DateHelperController` method is used in `your-details.view`, and it
    generates the data for the drop-down day and month of the date-of-birth fields.
    This code was originally a part of the `ContactDetailsController` method in [Chapter
    4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation and AJAX"), *JSF Validation
    and AJAX*. It has been refactored for reuse.``'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '```DateHelperController`方法用于`your-details.view`，并为出生日期字段的下拉日和月生成数据。此代码最初是[第4章](part0043.xhtml#aid-190861
    "第4章。JSF验证和AJAX")中`ContactDetailsController`方法的组成部分，*JSF验证和AJAX*。它已被重构以供重用。`'''''
- en: '`There is an other POJO with an application scope and it is called Utility.`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`存在另一个具有应用范围的POJO，它被称为Utility。`'''''
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '``In the preceding code, the method `calculateMonthlyPayment()` calculates
    the monthly payment amount. The arguments are `pv` (that specifies the principal
    value), `apr` (that specifies the annual percentage rate), and the `np`, which
    stands for the notice period measured in months.``'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '``在上述代码中，方法`calculateMonthlyPayment()`计算月付款金额。参数是`pv`（指定本金值）、`apr`（指定年百分比率）和`np`，代表以月为单位的提前通知期。`'''''
- en: '``The method `getTaxRate()` looks up the appropriate tax rate given the principal
    value, that is, the loan amount that the customer wants. The class `LoanRateBounds`
    is a simple POJO, as shown in the following code:``'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '``方法`getTaxRate()`根据本金值查找适当的税率，即客户想要的贷款金额。`LoanRateBounds`类是一个简单的POJO，如下面的代码所示：`'''''
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '``This `LoanRateBounds` POJO is an immutable object and is thread-safe.``'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '``这个`LoanRateBounds` POJO是一个不可变对象，并且是线程安全的。'''''
- en: "[PRE30] package uk.co.xenonique.digital.instant.control; import javax.faces.component.*;\
    \ import javax.faces.context.FacesContext; import java.io.IOException;  @FacesComponent(\"\
    workerBannerComponent\") public class WorkerBannerComponent extends UINamingContainer\
    \ {   private String gettingStartedActive;   private String yourDetailsActive;\
    \   private String yourRateActive;   private String yourAddressActive;   private\
    \ String confirmActive;   private String completedActive;    @Override   public\
    \ void encodeAll(FacesContext context) throws IOException {     if (context ==\
    \ null) {         throw new NullPointerException(\"no faces context supplied\"\
    );     }     String sectionName = (String)getAttributes().get(\"sectionName\"\
    );     gettingStartedActive = yourDetailsActive = yourRateActive = yourAddressActive\
    \ = confirmActive = completedActive = \"\";      if ( \"gettingStarted\".equalsIgnoreCase(sectionName))\
    \ {         gettingStartedActive = \"active\";     }     else if ( \"yourDetails\"\
    .equalsIgnoreCase(sectionName)) {         yourDetailsActive = \"active\";    \
    \ }     else if ( \"yourRate\".equalsIgnoreCase(sectionName)) {         yourRateActive\
    \ = \"active\";     }     else if ( \"yourAddress\".equalsIgnoreCase(sectionName))\
    \ {         yourAddressActive = \"active\";     }     else if ( \"confirm\".equalsIgnoreCase(sectionName))\
    \ {         confirmActive = \"active\";     }     else if ( \"completed\".equalsIgnoreCase(sectionName))\
    \ {         completedActive = \"active\";     }     super.encodeAll(context);\
    \   }    // Getters and setters omitted } [PRE31] <!DOCTYPE html> <html      \
    \                 >   <cc:interface componentType=\"workerBannerComponent\"> \
    \    <cc:attribute name=\"sectionName\" required=\"true\"/>   </cc:interface>\
    \    <cc:implementation>     <div class=\"workflow-wrapper\">       <div class=\"\
    workflow-column\">         <div class=\"workflow-title  #{cc.gettingStartedActive}\
    \ pull-left\" >             Getting Started         </div>         <div class=\"\
    workflow-arrow-right #{cc.gettingStartedActive}  pull-left\"></div>       </div>\
    \        <div class=\"workflow-column\">         <div class=\"workflow-title \
    \ #{cc.yourDetailsActive} pull-left\" >             Your Details         </div>\
    \         <div class=\"workflow-arrow-right  #{cc.yourDetailsActive} pull-left\"\
    ></div>       </div>        <div class=\"workflow-column\">         <div class=\"\
    workflow-title  #{cc.yourRateActive} pull-left\" >             Your Rate     \
    \    </div>         <div class=\"workflow-arrow-right  #{cc.yourRateActive} pull-left\"\
    ></div>       </div>        <div class=\"workflow-column\">         <div class=\"\
    workflow-title  #{cc.yourAddressActive} pull-left\" >             Your Address\
    \         </div>         <div class=\"workflow-arrow-right  #{cc.yourAddressActive}\
    \ pull-left\"></div>       </div>        ...        </div>     </div>   </cc:implementation>\
    \ </html> [PRE32] <html                                    >    <ui:composition\
    \ template=\"/basic_layout.xhtml\">     <ui:define name=\"mainContent\">     \
    \  <xen:workflow-banner sectionName=\"yourRate\"/>       ...                 </html>\
    \ [PRE33] <!DOCTYPE html> <html        >    <cc:interface/>\P      <cc:implementation>\
    \     <div class=\"alert alert-info\">       <h:outputText value=\"Own ID: #{component.id},\
    \ parent composite ID: #{cc.id}\" />       <br/>       <h:outputText value=\"\
    Own ID: #{component.id}, parent composite ID: #{cc.id}\" />       <br/>      \
    \ <h:outputText value=\"Own ID: #{component.id}, parent composite ID: #{cc.id}\"\
    \ />     </div>   </cc:implementation> </html> [PRE34] <!DOCTYPE html> <html \
    \            >    <ui:composition template=\"/basic_layout.xhtml\">     <ui:define\
    \ name=\"mainContent\">       <h1> Custom Composite Demonstations</h1>       \
    \ <xen:workflow-banner sectionName=\"gettingStarted\"/>       <pro:infoSec message=\"\
    The definition of digital transformation\" />       <xen:component-report/>  \
    \      <a class=\"btn btn-primary btn-lg\"         href=\"#{request.contextPath}/index.xhtml\"\
    > Home </a>      </ui:define> <!--name=\"mainContent\" -->   </ui:composition>\
    \ </html> [PRE35] package uk.co.xenonique.digital.instant.control; import javax.faces.component.FacesComponent;\
    \ import javax.faces.component.UINamingContainer; import javax.faces.context.FacesContext;\
    \ import javax.faces.context.ResponseWriter; import java.io.IOException; import\
    \ java.security.Principal;  @FacesComponent(   value=\"informationSecurity\",\
    \   namespace = \"http:/www.xenonique.co.uk/jsf/instant/lending\",   tagName =\
    \ \"infoSec\", createTag = true) public class InfoSecurityComponent extends UINamingContainer\
    \ {   private String message;    @Override   public String getFamily() {     return\
    \ \"instant.lending.custom.component\";   }    @Override   public Object saveState(FacesContext\
    \ context) {     Object values[] = new Object[2];     values[0] = super.saveState(context);\
    \     values[1] = message;     return ((Object) (values));   }    @Override  \
    \ public void restoreState(FacesContext context, Object state) {     Object values[]\
    \ = (Object[]) state;     super.restoreState(context, values[0]);     message\
    \ = (String) values[1];   }    public void encodeBegin(FacesContext context) \
    \        throws IOException {     ResponseWriter writer = context.getResponseWriter();\
    \     writer.startElement(\"div\", this);     writer.writeAttribute(\"role\",\
    \ \"alert\", null );     Principal principal = FacesContext.getCurrentInstance()\
    \         .getExternalContext().getUserPrincipal();     String name;     if (\
    \ principal !=null ) {       writer.writeAttribute(\"class\",\"alert  alert-success\"\
    ,null);       name = principal.getName();     }     else {       writer.writeAttribute(\"\
    class\",\"alert  alert-danger\",null);       name = \"unknown\";     }     writer.write(\
    \       String.format(\"[USER: <strong>%s</strong>] - %s\",       name, message));\
    \   }    public void encodeEnd(FacesContext context)           throws IOException\
    \ {     ResponseWriter writer = context.getResponseWriter();     writer.endElement(\"\
    div\");     writer.flush();   }   // Getter and setter omitted } [PRE36] <html\
    \      ...          >  ...     <pro:infoSec message=\"Hello world component\"\
    \ /> [PRE37] <div class=\"alert alert-success\" role=\"alert\">   [USER: <strong>unknown</strong>]\
    \ - Hello world component </div> [PRE38]`"
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: "[PRE30] 包含 uk.co.xenonique.digital.instant.control; 导入 javax.faces.component.*;\
    \ 导入 javax.faces.context.FacesContext; 导入 java.io.IOException;  @FacesComponent(\"\
    workerBannerComponent\") public class WorkerBannerComponent extends UINamingContainer\
    \ {   private String gettingStartedActive;   private String yourDetailsActive;\
    \   private String yourRateActive;   private String yourAddressActive;   private\
    \ String confirmActive;   private String completedActive;    @Override   public\
    \ void encodeAll(FacesContext context) throws IOException {     if (context ==\
    \ null) {         throw new NullPointerException(\"no faces context supplied\"\
    );     }     String sectionName = (String)getAttributes().get(\"sectionName\"\
    );     gettingStartedActive = yourDetailsActive = yourRateActive = yourAddressActive\
    \ = confirmActive = completedActive = \"\";      if ( \"gettingStarted\".equalsIgnoreCase(sectionName))\
    \ {         gettingStartedActive = \"active\";     }     else if ( \"yourDetails\"\
    .equalsIgnoreCase(sectionName)) {         yourDetailsActive = \"active\";    \
    \ }     else if ( \"yourRate\".equalsIgnoreCase(sectionName)) {         yourRateActive\
    \ = \"active\";     }     else if ( \"yourAddress\".equalsIgnoreCase(sectionName))\
    \ {         yourAddressActive = \"active\";     }     else if ( \"confirm\".equalsIgnoreCase(sectionName))\
    \ {         confirmActive = \"active\";     }     else if ( \"completed\".equalsIgnoreCase(sectionName))\
    \ {         completedActive = \"active\";     }     super.encodeAll(context);\
    \   }    // Getters and setters omitted } [PRE31] <!DOCTYPE html> <html      \
    \                 >   <cc:interface componentType=\"workerBannerComponent\"> \
    \    <cc:attribute name=\"sectionName\" required=\"true\"/>   </cc:interface>\
    \    <cc:implementation>     <div class=\"workflow-wrapper\">       <div class=\"\
    workflow-column\">         <div class=\"workflow-title  #{cc.gettingStartedActive}\
    \ pull-left\" >             Getting Started         </div>         <div class=\"\
    workflow-arrow-right #{cc.gettingStartedActive}  pull-left\"></div>       </div>\
    \        <div class=\"workflow-column\">         <div class=\"workflow-title \
    \ #{cc.yourDetailsActive} pull-left\" >             Your Details         </div>\
    \         <div class=\"workflow-arrow-right  #{cc.yourDetailsActive} pull-left\"\
    ></div>       </div>        <div class=\"workflow-column\">         <div class=\"\
    workflow-title  #{cc.yourRateActive} pull-left\" >             Your Rate     \
    \    </div>         <div class=\"workflow-arrow-right  #{cc.yourRateActive} pull-left\"\
    ></div>       </div>        <div class=\"workflow-column\">         <div class=\"\
    workflow-title  #{cc.yourAddressActive} pull-left\" >             Your Address\
    \         </div>         <div class=\"workflow-arrow-right  #{cc.yourAddressActive}\
    \ pull-left\"></div>       </div>        ...        </div>     </div>   </cc:implementation>\
    \ </html> [PRE32] <html                                    >    <ui:composition\
    \ template=\"/basic_layout.xhtml\">     <ui:define name=\"mainContent\">     \
    \  <xen:workflow-banner sectionName=\"yourRate\"/>       ...                 </html>\
    \ [PRE33] <!DOCTYPE html> <html        >    <cc:interface/>\P      <cc:implementation>\
    \     <div class=\"alert alert-info\">       <h:outputText value=\"Own ID: #{component.id},\
    \ parent composite ID: #{cc.id}\" />       <br/>       <h:outputText value=\"\
    Own ID: #{component.id}, parent composite ID: #{cc.id}\" />       <br/>      \
    \ <h:outputText value=\"Own ID: #{component.id}, parent composite ID: #{cc.id}\"\
    \ />     </div>   </cc:implementation> </html> [PRE34] <!DOCTYPE html> <html \
    \            >    <ui:composition template=\"/basic_layout.xhtml\">     <ui:define\
    \ name=\"mainContent\">       <h1> Custom Composite Demonstations</h1>       \
    \ <xen:workflow-banner sectionName=\"gettingStarted\"/>       <pro:infoSec message=\"\
    The definition of digital transformation\" />       <xen:component-report/>  \
    \      <a class=\"btn btn-primary btn-lg\"         href=\"#{request.contextPath}/index.xhtml\"\
    > Home </a>      </ui:define> <!--name=\"mainContent\" -->   </ui:composition>\
    \ </html> [PRE35] 包含 uk.co.xenonique.digital.instant.control; 导入 javax.faces.component.FacesComponent;\
    \ 导入 javax.faces.component.UINamingContainer; 导入 javax.faces.context.FacesContext;\
    \ 导入 javax.faces.context.ResponseWriter; 导入 java.io.IOException; 导入 java.security.Principal;\
    \  @FacesComponent(   value=\"informationSecurity\",   namespace = \"http:/www.xenonique.co.uk/jsf/instant/lending\"\
    ,   tagName = \"infoSec\", createTag = true) public class InfoSecurityComponent\
    \ extends UINamingContainer {   private String message;    @Override   public\
    \ String getFamily() {     return \"instant.lending.custom.component\";   }  \
    \  @Override   public Object saveState(FacesContext context) {     Object values[]\
    \ = new Object[2];     values[0] = super.saveState(context);     values[1] = message;\
    \     return ((Object) (values));   }    @Override   public void restoreState(FacesContext\
    \ context, Object state) {     Object values[] = (Object[]) state;     super.restoreState(context,\
    \ values[0]);     message = (String) values[1];   }    public void encodeBegin(FacesContext\
    \ context)         throws IOException {     ResponseWriter writer = context.getResponseWriter();\
    \     writer.startElement(\"div\", this);     writer.writeAttribute(\"role\",\
    \ \"alert\", null );     Principal principal = FacesContext.getCurrentInstance()\
    \         .getExternalContext().getUserPrincipal();     String name;     if (\
    \ principal !=null ) {       writer.writeAttribute(\"class\",\"alert  alert-success\"\
    ,null);       name = principal.getName();     }     else {       writer.writeAttribute(\"\
    class\",\"alert  alert-danger\",null);       name = \"unknown\";     }     writer.write(\
    \       String.format(\"[USER: <strong>%s</strong>] - %s\",       name, message));\
    \   }    public void encodeEnd(FacesContext context)           throws IOException\
    \ {     ResponseWriter writer = context.getResponseWriter();     writer.endElement(\"\
    div\");     writer.flush();   }   // Getter and setter omitted } [PRE36] <html\
    \      ...          >  ...     <pro:infoSec message=\"Hello world component\"\
    \ /> [PRE37] <div class=\"alert alert-success\" role=\"alert\">   [USER: <strong>unknown</strong>]\
    \ - Hello world component </div> [PRE38]"
