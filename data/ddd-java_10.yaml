- en: '*Chapter 8*: Implementing Long-Running Workflows'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：实现长期运行的工作流程'
- en: In the long run, the pessimist may be proven right, but the optimist has a better
    time on the trip.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，悲观者可能会被证明是对的，但乐观者在旅途中会有更好的时光。
- en: — Daniel Reardon
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: — 丹尼尔·雷诺德
- en: In the previous chapters, we looked at handling commands and queries within
    the context of a single aggregate. All the scenarios we have looked at thus far
    have been limited to a single interaction. However, not all capabilities can be
    implemented in the form of a simple request-response interaction, requiring coordination
    across multiple external systems or human-centric operations, or both. In other
    cases, there may be a need to react to triggers that are non-deterministic (occur
    conditionally or not at all) and/or are time-bound (based on a deadline). This
    may require managing business transactions across multiple bounded contexts that
    may run over a long duration of time while continuing to maintain consistency
    (**saga**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了在单个聚合体上下文中处理命令和查询。迄今为止，我们所考虑的所有场景都局限于单一交互。然而，并非所有功能都可以以简单的请求-响应交互的形式实现，需要跨多个外部系统或以人为中心的操作进行协调，或者两者都需要。在其他情况下，可能需要响应非确定性的触发器（条件发生或不发生）和/或时间限制的触发器（基于截止日期）。这可能需要管理跨越多个边界上下文的业务事务，这些事务可能需要很长时间才能运行，同时继续维护一致性（**叙事**）。
- en: 'There are at least two common patterns to implement the saga pattern:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两种常见的模式来实现叙事模式：
- en: '**Explicit orchestration**: A designated component acts as a centralized coordinator—where
    the system relies on the coordinator to react to domain events to manage the flow.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式编排**：一个指定的组件作为中央协调器——系统依赖于协调器对领域事件做出反应以管理流程。'
- en: '**Implicit choreography**: No single component is required to act as a centralized
    coordinator—where the components simply react to domain events in other components
    to manage the flow.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式协奏**：不需要单个组件作为中央协调器——组件简单地对其他组件中的领域事件做出反应以管理流程。'
- en: 'We’ll cover the following main topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Implementing sagas
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现叙事
- en: Deciding between orchestration and choreography
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编排和协奏之间做出决定
- en: Handling deadlines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理截止日期
- en: By the end of this chapter, you will have learned how to implement sagas using
    both techniques. You will also have learned how to work with deadlines when no
    explicit events occur within the system. You will finally be able to appreciate
    when/whether to choose an explicit orchestrator or simply stick to implicit choreography
    without resorting to the use of potentially expensive distributed transactions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何使用这两种技术实现叙事。你还将学会在没有系统内发生明确事件时如何处理截止日期。你最终将能够理解何时/是否选择显式编排器，或者简单地坚持隐式协奏，而不必求助于可能昂贵的分布式事务。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples in this chapter, you will need access to the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的示例，你需要访问以下内容：
- en: JDK 1.8+ (we have used Java 17 to compile sample sources)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+（我们使用 Java 17 编译示例源代码）
- en: Spring Boot 2.4.x
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 2.4.x
- en: Axon Framework 4.5.3
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Axon Framework 4.5.3
- en: JUnit 5.7.x (included with Spring Boot)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5.7.x（包含在 Spring Boot 中）
- en: Project Lombok (to reduce verbosity)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 Lombok（以减少冗余）
- en: Maven 3.x
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 3.x
- en: Please refer to the `Chapter08` directory of the book’s accompanying source
    code repository for complete working examples on GitHub at [https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter08).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本书配套源代码仓库中的 `Chapter08` 目录，GitHub 上的完整工作示例位于 [https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/Domain-Driven-Design-with-Java-A-Practitioner-s-Guide/tree/master/Chapter08)。
- en: Continuing our design journey
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: 'In [*Chapter 4*](B16716_04_Final_NM_ePub.xhtml#_idTextAnchor065), *Domain Analysis
    and Modeling*, we discussed eventstorming as a lightweight method to clarify business
    flows. As a reminder, this is the output produced from our eventstorming session:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B16716_04_Final_NM_ePub.xhtml#_idTextAnchor065) *领域分析和建模* 中，我们讨论了事件风暴作为一种轻量级方法来阐明业务流程。作为提醒，这是我们事件风暴会议的输出：
- en: '![Figure 8.1 – Recap of the eventstorming session'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 事件风暴会议回顾'
- en: '](img/B16716_Figure_8.1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_8.1.jpg)'
- en: Figure 8.1 – Recap of the eventstorming session
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 事件风暴会议回顾
- en: 'As depicted in the preceding diagram, some aspects of **Letter of Credit**
    (**LC**) application processing happen outside our current bounded context, before
    the trade finance manager makes a decision to either approve or decline the application,
    as listed here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**信用证**（**LC**）申请处理的一些方面发生在我们的当前边界上下文之外，在贸易融资经理决定批准或拒绝申请之前，如下列所示：
- en: Product value is validated.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品价值得到验证。
- en: Product legality is validated.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品合法性得到验证。
- en: Applicant’s creditworthiness is validated.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 申请人的信用度得到验证。
- en: Currently, the final approval is a manual process. It is pertinent to note that
    the product value and legality checks happen as part of the work done by the product
    analysis department, whereas applicant creditworthiness checks happen in the credit
    analysis department. Both departments make use of their own systems to perform
    these functions and notify us through the respective events. An LC application
    is **not ready** to be either approved or declined until **each** of these checks
    is completed. Each of these processes happens mostly independently of the others
    and may take a non-deterministic amount of time (typically in the order of a few
    days). After these checks have happened, the trade finance manager manually reviews
    the application and makes the final decision.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，最终批准是一个手动过程。值得注意的是，产品价值和合法性检查是产品分析部门工作的一部分，而申请人信用度检查发生在信贷分析部门。这两个部门都使用自己的系统来执行这些功能，并通过相应的事件通知我们。只有当**每个**这些检查都完成时，LC申请才**不准备**被批准或拒绝。这些过程中的每一个主要都是独立于其他过程的，可能需要非确定性的时间（通常在几天左右）。在这些检查发生后，贸易融资经理手动审查申请并做出最终决定。
- en: Given the growing volumes of LC applications received, the bank is looking to
    introduce a process optimization to automatically approve applications with an
    amount below a certain threshold (*USD 10,000* at this time). The business has
    deemed that the three preceding checks are sufficient and that no further human
    intervention is required when approving such applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于收到的LC申请数量不断增加，银行正在寻求引入一个流程优化，以自动批准金额低于一定阈值（目前为*USD 10,000*）的申请。业务认为前三个检查是足够的，并且在批准此类申请时不需要进一步的人工干预。
- en: From an overall system perspective, it is pertinent to note that the product
    analyst system notifies us through `ProductValueValidatedEvent` and `ProductLegalityValidatedEvent`,
    whereas the credit analyst system does the same through the `ApplicantCreditValidatedEvent`
    event. Each of these events can, and indeed do, happen independently of the others.
    For us to be able to auto-approve applications, our solution needs to wait for
    all of these events to occur. Once these events have occurred, we need to examine
    the outcome of each of these events to finally make a decision.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从整体系统角度来看，值得注意的是，产品分析师系统通过`ProductValueValidatedEvent`和`ProductLegalityValidatedEvent`事件通知我们，而信贷分析师系统则通过`ApplicantCreditValidatedEvent`事件进行同样的操作。这些事件中的每一个都可以，实际上也确实可以独立于其他事件发生。为了能够自动批准申请，我们的解决方案需要等待所有这些事件的发生。一旦这些事件发生，我们需要检查每个事件的输出结果，最终做出决定。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this context, we are using the term long-running to denote a complex business
    process that takes several steps to complete. As these steps occur, the process
    transitions from one state to another. In other words, we are referring to a state
    machine. This is not to be confused with a long-running software process (for
    example, a complex SQL query or an image-processing routine) that is computationally
    intensive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，我们使用“长运行”一词来表示需要多个步骤才能完成的复杂业务流程。随着这些步骤的发生，流程从一个状态转换到另一个状态。换句话说，我们指的是一个状态机。这不应与计算密集型的长运行软件过程（例如，复杂的SQL查询或图像处理例程）混淆。
- en: As is evident from the preceding diagram, the LC auto-approval functionality
    is an example of a long-running business process where *something* in our system
    needs to keep track of the fact that these independent events have occurred before
    proceeding further. Such functionality can be implemented using the saga pattern.
    Let’s look at how we can do this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，LC自动批准功能是一个长运行业务流程的例子，其中我们的系统中需要跟踪这些独立事件发生的事实才能继续进行。这种功能可以使用saga模式实现。让我们看看我们如何做到这一点。
- en: Implementing sagas
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现sagas
- en: 'Before we delve into how we can implement this auto-approval functionality,
    let’s take a look at how this works from a logical perspective, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何实现此自动审批功能之前，让我们看看从逻辑角度来看它是如何工作的，如图所示：
- en: '![Figure 8.2 – Auto-approval process—logical view'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.2 – Auto-approval process—logical view'
- en: '](img/B16716_Figure_8.2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_8.2.jpg](img/B16716_Figure_8.2.jpg)'
- en: Figure 8.2 – Auto-approval process—logical view
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 自动审批流程—逻辑视图
- en: 'As depicted in the preceding diagram, there are three bounded contexts in play:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，有三个有界上下文在起作用：
- en: '**LC Application** (the bounded context we have been implementing thus far)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LC 应用**（我们迄今为止一直在实施的有界上下文）'
- en: The **Applicant** bounded context
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**申请人**有界上下文'
- en: The **Product** bounded context
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品**有界上下文'
- en: 'The flow gets triggered when the LC application is submitted. This in turn
    sets in motion three independent functions that establish the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当 LC 申请提交时，流程被触发。这反过来又启动了三个独立的功能，以建立以下内容：
- en: Value of the product being transacted
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易产品的价值
- en: Legality of the product being transacted
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易产品的合法性
- en: Creditworthiness of the applicant
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 申请人的信用度
- en: LC approval can proceed only after **all** of these functions have been completed.
    Furthermore, to **auto-approve**, all of these checks have to complete **favorably**
    and, as mentioned earlier, the LC amount has to be less than the *USD 10,000*
    threshold.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在**所有**这些功能都完成后，LC 批准才能进行。此外，为了**自动批准**，所有这些检查都必须**顺利通过**，并且如前所述，LC 金额必须低于
    *USD 10,000* 阈值。
- en: 'As shown in the eventstorming artifact, the `LC Application` aggregate is able
    to handle `ApproveLCApplicationCommand`, which results in `LCApplicationApprovedEvent`.
    To auto-approve, this command needs to be invoked automatically when all the conditions
    mentioned earlier are satisfied. We are building an event-driven system, and we
    can see that each of these validations produces events when their respective actions
    are complete. There are at least two ways to implement this functionality:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如事件风暴工件所示，`LC Application` 聚合能够处理 `ApproveLCApplicationCommand`，这导致 `LCApplicationApprovedEvent`。为了自动批准，当所有提到的条件都满足时，此命令需要自动调用。我们正在构建一个事件驱动系统，我们可以看到，每当相应的动作完成时，这些验证都会产生事件。实现此功能至少有两种方法：
- en: '**Orchestration**: Where a single component in the system coordinates the state
    of the flow and triggers subsequent actions as necessary'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排**：在系统中，单个组件协调流程的状态并在必要时触发后续操作'
- en: '**Choreography**: Where actions in the flow are triggered without requiring
    an explicit coordinating component'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**舞蹈编排**：在流程中，动作被触发，而不需要显式的协调组件'
- en: Let’s examine these methods in more detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查这些方法。
- en: Orchestration
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编排
- en: 'When implementing sagas using an orchestrating component, the system looks
    similar to the one depicted here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用编排组件实现 sagas 时，系统看起来类似于以下图所示：
- en: '![Figure 8.3 – Saga implementation using an orchestrator'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.3 – Saga implementation using an orchestrator'
- en: '](img/B16716_Figure_8.3.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_8.3.jpg](img/B16716_Figure_8.3.jpg)'
- en: Figure 8.3 – Saga implementation using an orchestrator
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 使用编排器的 saga 实现
- en: 'The orchestrator starts tracking the flow when the LC application is submitted.
    It will then need to wait for each of the `ProductValueValidatedEvent`, `ProductLegalityValidatedEvent`,
    and `ApplicantCreditValidatedEvent` events to occur and decide whether it is appropriate
    to trigger `ApproveLCApplicationCommand`. Finally, the saga life cycle ends unconditionally
    when the LC application is approved. There are other conditions that may cause
    the saga to end abruptly. We will examine those scenarios in detail later. It
    is pertinent to note that there will be a **distinct** auto-approval saga instance
    for each LC application that gets submitted. Let’s look at how to implement this
    functionality using the Axon Framework. As usual, let’s test-drive this functionality
    that a new auto-approval saga instance is created when an LC application is submitted:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当 LC 申请提交时，编排器开始跟踪流程。然后它需要等待每个 `ProductValueValidatedEvent`、`ProductLegalityValidatedEvent`
    和 `ApplicantCreditValidatedEvent` 事件发生，并决定是否触发 `ApproveLCApplicationCommand`。最后，当
    LC 申请被批准时，saga 生命周期无条件结束。还有其他可能导致 saga 突然结束的条件。我们将在稍后详细检查这些场景。值得注意的是，对于每个提交的 LC
    申请，将有一个**独立的**自动审批 saga 实例。让我们看看如何使用 Axon 框架实现此功能。像往常一样，让我们通过测试驱动来验证当 LC 申请提交时，会创建一个新的自动审批
    saga 实例：
- en: '![](img/ch8-1.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![img/ch8-1.jpg](img/ch8-1.jpg)'
- en: We make use of the Axon-provided `FixtureConfiguration` and `SagaTestFixture`,
    which allow us to test saga functionality.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Axon提供的`FixtureConfiguration`和`SagaTestFixture`，这允许我们测试编排功能。
- en: Given no prior activity has occurred (from the perspective of the saga).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假定在此之前没有发生任何活动（从编排的角度来看）。
- en: When `LCApplicationSubmittedEvent` is published.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发布`LCApplicationSubmittedEvent`时。
- en: We expect one active saga to exist.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望存在一个活动编排。
- en: 'The implementation to make this test pass looks as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使此测试通过的实现如下：
- en: '![](img/ch8-2.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-2.jpg)'
- en: When working with Axon and Spring, the orchestrator is annotated with the `@Saga`
    annotation to mark it as a Spring bean. In order to track each submitted LC application,
    the `@Saga` annotation is prototype-scoped (as opposed to singleton-scoped), to
    allow the creation of multiple saga instances. Please refer to the Axon and Spring
    documentation for more information.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当与Axon和Spring一起工作时，编排器被`@Saga`注解标记为Spring bean。为了跟踪每个提交的LC申请，`@Saga`注解是原型作用域的（与单例作用域相对），以允许创建多个编排实例。请参阅Axon和Spring文档以获取更多信息。
- en: The saga listens to `LCApplicationSubmittedEvent` to keep track of the flow
    (as denoted by the `@SagaEventHandler` annotation). Conceptually, the `@SagaEventHandler`
    annotation is very similar to the `@EventHandler` annotation that we discussed
    in the previous chapter. However, the `@SagaEventHandler` annotation is used specifically
    for event listeners within a saga. The `associationProperty` attribute on the
    `@SagaEventHandler` annotation causes this event handler method to get invoked
    only for the saga with a matching value of the `lcApplicationId` attribute in
    the event payload. Also, `@SagaEventHandler` is a transaction boundary. Every
    time such a method completes successfully, the Axon Framework commits a transaction,
    thereby allowing it to keep track of the state stored in the saga. We will look
    at this in more detail shortly.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编排监听`LCApplicationSubmittedEvent`以跟踪流程（如`@SagaEventHandler`注解所示）。从概念上讲，`@SagaEventHandler`注解与我们之前章节中讨论的`@EventHandler`注解非常相似。然而，`@SagaEventHandler`注解专门用于编排内部的事件监听器。`@SagaEventHandler`注解上的`associationProperty`属性使得此事件处理方法仅在事件负载中`lcApplicationId`属性具有匹配值的编排上被调用。此外，`@SagaEventHandler`是一个事务边界。每次此类方法成功完成时，Axon框架都会提交一个事务，从而允许它跟踪存储在编排中的状态。我们将在稍后更详细地探讨这一点。
- en: Every saga needs to have at least one `@SagaEventHandler` method that is also
    annotated with the `@StartSaga` annotation to denote the beginning of the saga.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个编排至少需要有一个同时被`@StartSaga`注解标注的`@SagaEventHandler`方法，以表示编排的开始。
- en: 'We have a requirement that an LC cannot be auto-approved if its amount exceeds
    the threshold (*USD 10,000* in our case). The test for this scenario looks like
    this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个要求，如果信用证的金额超过阈值（在我们的情况下为*USD 10,000*），则不能自动批准信用证。对此场景的测试看起来是这样的：
- en: '![](img/ch8-3.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-3.jpg)'
- en: When the LC amount exceeds the auto-approval threshold amount.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当信用证（LC）金额超过自动批准阈值时。
- en: We expect no active sagas to exist for that LC.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望该LC不存在任何活动编排。
- en: 'The implementation to satisfy this condition looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 满足此条件实现的代码如下：
- en: '![](img/ch8-4.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-4.jpg)'
- en: We check for the condition of the LC amount being greater than the threshold
    amount.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查LC金额是否大于阈值金额的条件。
- en: If so, we end the saga using the framework-provided `SagaLifecycle.end()` method.
    Here, we end the saga programmatically. It is also possible to declaratively end
    the saga as well using the `@EndSaga` annotation when `LCApplicationApprovedEvent`
    occurs. Please refer to the full code examples included in this chapter’s repository
    for more information.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，我们将使用框架提供的`SagaLifecycle.end()`方法结束编排。在这里，我们以编程方式结束编排。当`LCApplicationApprovedEvent`发生时，也可以使用`@EndSaga`注解声明性地结束编排。有关更多信息，请参阅本章存储库中包含的完整代码示例。
- en: 'We need to auto-approve the saga if `ApplicantCreditValidatedEvent`, `ProductLegalityValidatedEvent`,
    and `ProductValueValidatedEvent` have all occurred successfully. The test to verify
    this functionality is shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ApplicantCreditValidatedEvent`、`ProductLegalityValidatedEvent`和`ProductValueValidatedEvent`都成功发生，我们需要自动批准编排。验证此功能的测试如下所示：
- en: '![](img/ch8-5.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-5.jpg)'
- en: Given that the LC application has been submitted and `ProductValueValidatedEvent`
    and `ProductLegalityValidatedEvent` have occurred successfully.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假定LC申请已经提交，并且`ProductValueValidatedEvent`和`ProductLegalityValidatedEvent`已经成功发生。
- en: When `ApplicantCreditValidatedEvent` is published.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发布`ApplicantCreditValidatedEvent`时。
- en: We expect one active saga instance and the following.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望有一个活跃的saga实例和以下内容。
- en: We expect `ApproveLCApplicationCommand` to be dispatched for that LC.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望为该LC派发`ApproveLCApplicationCommand`。
- en: 'The implementation for this looks as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的看起来如下：
- en: '![](img/ch8-6.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch8-6.jpg)'
- en: As mentioned previously, sagas can maintain state. In this case, we are maintaining
    three Boolean variables, each to denote the occurrence of the respective event.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，sagas可以维护状态。在这种情况下，我们维护了三个布尔变量，每个变量表示相应事件的触发。
- en: We have declared the Axon `CommandGateway` as a transient member because we
    need it to dispatch commands, but not be persisted along with other saga states.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已将Axon的`CommandGateway`声明为瞬态成员，因为我们需要用它来派发命令，但不需要与其他saga状态一起持久化。
- en: This event handler intercepts `ApplicantCreditValidatedEvent` for the specific
    LC application (as denoted by `associationProperty` in the `@SagaEventHandler`
    annotation).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此事件处理器拦截特定LC申请的`ApplicantCreditValidatedEvent`（如`@SagaEventHandler`注解中的`associationProperty`所示）。
- en: If the decision from `ApplicantCreditValidatedEvent` is rejected, we end the
    saga immediately.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`ApplicantCreditValidatedEvent`的决策被拒绝，我们将立即结束saga。
- en: Otherwise, we remember the fact that the applicant’s credit has been validated.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们记住申请人的信用已经得到验证。
- en: We then check to see whether the product’s value and legality have already been
    validated.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着检查产品的价值和合法性是否已经被验证。
- en: If so, we issue the command to auto-approve the LC.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，我们将发布自动批准LC的命令。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The logic in `ProductValueValidatedEvent` and `ProductLegalityValidatedEvent`
    is very similar to that in the saga event handler for `ApplicantCreditValidatedEvent`.
    We have omitted it here for brevity. Please refer to the source code for this
    chapter for the full example along with the tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductValueValidatedEvent`和`ProductLegalityValidatedEvent`中的逻辑与`saga`事件处理器中的`ApplicantCreditValidatedEvent`非常相似。为了简洁，这里省略了它。请参阅本章源代码以获取完整的示例以及测试。'
- en: 'Finally, we can end the saga when we receive `LCApplicationApprovedEvent` for
    this application:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们收到此应用的`LCApplicationApprovedEvent`时，我们可以结束saga：
- en: '![](img/ch8-7.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch8-7.jpg)'
- en: Given that the LC has been submitted and all the validations have been completed
    successfully.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于LC已经提交并且所有验证都已完成成功。
- en: When `LCApplicationApprovedEvent` is published.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发布`LCApplicationApprovedEvent`时。
- en: We expect zero active sagas to be running.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望没有活跃的saga正在运行。
- en: We also expect to not dispatch any commands.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也期望不会派发任何命令。
- en: Now that we have looked at how to implement sagas using an orchestrator, let’s
    examine some design decisions that we may need to consider when working with them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用协调器实现sagas，让我们来探讨一些在设计时可能需要考虑的设计决策。
- en: 'Here are the pros of orchestration:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是编排的优点：
- en: '**Complex workflows**: Having an explicit orchestrator can be very helpful
    when dealing with flows that involve multiple participants and have a lot of conditionals
    because the orchestrator can keep track of the overall progress in a fine-grained
    manner.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的工作流**：在处理涉及多个参与者和许多条件的工作流时，拥有一个显式的协调器非常有帮助，因为协调器可以以细粒度的方式跟踪整体进度。'
- en: '**Testing**: As we have seen in the preceding implementation, testing flow
    logic in isolation is relatively straightforward.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：正如我们在前面的实现中看到的，在隔离状态下测试流程逻辑相对简单。'
- en: '**Debugging**: Given that we have a single coordinator, debugging the current
    state of the flow can be relatively easier.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：鉴于我们有一个单一的协调器，调试流程的当前状态可以相对容易。'
- en: '**Handling exceptions**: Given that the orchestrator has fine-grained control
    of the flow, recovering gracefully from exceptions can be easier.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理异常**：鉴于协调器对流程有细粒度的控制，从异常中优雅地恢复可以更容易。'
- en: '**System knowledge**: Components in different bounded contexts do not need
    to have knowledge of each other’s internals (for example, commands and events)
    to progress the flow.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统知识**：不同边界上下文中的组件不需要了解彼此的内部（例如，命令和事件）以推进流程。'
- en: '**Cyclic dependencies**: Having a central coordinator allows avoiding accidental
    cyclic dependencies between components.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环依赖**：拥有一个中央协调器可以避免组件之间意外产生循环依赖。'
- en: 'Here are the cons of orchestration:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是编排的缺点：
- en: '**Single point of failure**: From an operational perspective, orchestrators
    can become single points of failure because they are the only ones that have knowledge
    of the flow. This means that these components need to exhibit higher-resilience
    characteristics as compared to other components.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点故障**：从操作角度来看，编排器可能成为单点故障，因为它们是唯一了解流程的组件。这意味着与其他组件相比，这些组件需要表现出更高的弹性特征。'
- en: '**Leaking of domain logic**: In an ideal world, the aggregate will remain the
    custodian of all domain logic. Given that the orchestrator is also stateful, business
    logic may inadvertently shift to the orchestrator. Care should be taken to ensure
    that the orchestrator only has flow control logic while business invariants remain
    within the confines of the aggregate.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域逻辑泄露**：在一个理想的世界里，聚合将始终是所有领域逻辑的保管者。鉴于编排器也是有状态的，业务逻辑可能会无意中转移到编排器。应小心确保编排器只具有流程控制逻辑，而业务不变量仍然保持在聚合的范围内。'
- en: The preceding implementation should give you a good idea of how to implement
    a saga orchestrator. Now let’s look at how we can do this without the use of an
    explicit orchestrator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现应该能让你对如何实现Saga编排器有一个很好的了解。现在让我们看看在不使用显式编排器的情况下如何实现这一点。
- en: Choreography
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编排
- en: 'Saga orchestrators keep track of the current state of the flow, usually making
    use of some kind of data store. Another way to implement this functionality is
    without using any stateful component. Logically, this looks like the setup shown
    in the diagram here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Saga编排器跟踪流程的当前状态，通常使用某种类型的数据存储。实现此功能的另一种方式是不使用任何有状态的组件。从逻辑上看，这就像这里图中所示的设置：
- en: '![Figure 8.4 – Saga implementation using choreography'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.4 – Saga implementation using choreography'
- en: '](img/B16716_Figure_8.4.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_8.4.jpg]'
- en: Figure 8.4 – Saga implementation using choreography
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 使用编排的Saga实现
- en: 'As you can see, there is no single component that tracks the saga life cycle.
    However, to make the auto-approval decision, each of these stateless event handlers
    needs to have knowledge of the same three events occurring:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有单个组件跟踪Saga的生命周期。然而，为了做出自动批准的决定，每个这些无状态的事件处理器都需要了解相同的三种事件发生：
- en: Product value is validated.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证产品价值。
- en: Product legality is validated.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证产品合法性。
- en: Applicant’s creditworthiness is validated.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证申请人的信用度。
- en: 'Given that the event listeners themselves are stateless, there are at least
    three ways to provide this information to them:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件监听器本身是无状态的，至少有三种方式可以向它们提供此信息：
- en: Each of the events carries this information in their respective payloads.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个事件都在它们各自的负载中携带这些信息。
- en: The event listeners query the source systems (in this case, the product- and
    applicant-bounded contexts, respectively).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件监听器查询源系统（在这种情况下，分别是产品和申请人边界上下文）。
- en: The LC application-bounded context maintains a query model to keep track of
    these events occurring.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LC应用边界上下文维护一个查询模型以跟踪这些事件的发生。
- en: Just like in the orchestrator example, when all events have occurred and the
    LC amount is below the specified threshold, these event listeners can issue `ApproveLCApplicationCommand`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在编排器示例中一样，当所有事件都已发生且LC金额低于指定阈值时，这些事件监听器可以发出`ApproveLCApplicationCommand`。
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will skip covering code examples for the choreography implementation because
    this is no different from the material we have covered previously in this and
    prior chapters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过介绍编排实现中的代码示例，因为这与我们在本章和前几章中介绍的内容没有不同。
- en: Now that we have looked at how to implement both styles of sagas, let’s examine
    some design decisions that we may need to consider when working with them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何实现两种风格的Saga，让我们来探讨一些在设计时可能需要考虑的设计决策。
- en: 'The pros of the choreography implementation are listed here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编排实现的优点如下：
- en: '**Simple workflows**: For simple flows, the choreography approach can be relatively
    straightforward because it does not require the overhead of an additional coordinating
    component.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单的流程**：对于简单的流程，编排方法可以相对直接，因为它不需要额外协调组件的开销。'
- en: '**No single points of failure**: From an operational perspective, there is
    one less high-resilience component to worry about.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无单点故障**：从操作角度来看，不再需要担心一个高弹性组件。'
- en: 'These are the cons of the choreography implementation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编排实现的缺点：
- en: '**Workflow tracking**: Especially with complex workflows that involve numerous
    steps and conditionals, tracking and debugging the current state of the flow may
    become challenging.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流程跟踪**：特别是对于涉及许多步骤和条件的复杂工作流程，跟踪和调试流程的当前状态可能变得具有挑战性。'
- en: '**Cyclic dependencies**: It is possible to inadvertently introduce cyclic dependencies
    among components when workflows become gnarly.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环依赖**：当工作流程变得复杂时，可能会意外地在组件之间引入循环依赖。'
- en: Sagas enable applications to maintain data and transactional consistency when
    more than one bounded context is required to complete the business functionality
    without having to resort to using *distributed transactions*. However, it does
    introduce a level of complexity to the programming model, especially when it comes
    to handling failures. We will look at exception handling in a lot more detail
    when we discuss working with distributed systems in upcoming chapters. Let’s look
    at how to progress flows when there are no explicit stimuli by looking at how
    deadlines work.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Sagas允许应用程序在需要多个有界上下文来完成业务功能而不必求助于使用*分布式事务*的情况下维护数据和事务一致性。然而，它确实给编程模型引入了一定的复杂性，尤其是在处理失败时。当我们在即将到来的章节中讨论与分布式系统一起工作时，我们将更详细地探讨异常处理。让我们通过查看截止日期的工作方式来了解在没有明确刺激的情况下如何推进流程。
- en: Handling deadlines
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理截止日期
- en: Thus far, we have looked at events that are caused by human (for example, the
    applicant submitting an LC application) or system (for example, the auto-approval
    of an LC application) action. However, in an event-driven system, not all events
    occur due to an explicit human or system stimulus. Events may need to be emitted
    either due to inactivity over a period of time or on a recurring schedule based
    on prevailing conditions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了由人类（例如，申请人提交LC申请）或系统（例如，LC申请的自动批准）行为引起的事件。然而，在事件驱动系统中，并非所有事件都是由于明确的人类或系统刺激而发生的。事件可能需要根据一段时间内的不活动或基于现有条件的重复调度来发出。
- en: For example, let’s examine the case where the bank needs *submitted LC applications*
    to be decided on as quickly as possible. When applications are not acted upon
    by the trade finance managers within 10 calendar days, the system should send
    them reminders.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考察银行需要尽快决定*已提交的LC申请*的情况。当贸易融资经理在10个日历日内未对申请采取行动时，系统应发送提醒。
- en: 'To deal with such inactivity, we need a means by which to trigger system actions
    (read: emit events) based on the passage of time—in other words, perform actions
    when a *deadline* expires. In a happy path scenario, we expect either the user
    or the system to take a certain action. In such cases, we will also need to account
    for cases where we will need to cancel the trigger scheduled to occur on deadline
    expiry. Let’s look at how to test-drive this functionality:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种不活动，我们需要一种方法来触发基于时间流逝的系统行为（即：在截止日期到期时执行操作）。在理想情况下，我们期望用户或系统采取某些行动。在这种情况下，我们还需要考虑在截止日期到期时需要取消已安排触发的情况。让我们看看如何测试驱动这个功能：
- en: '![](img/ch8-8.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-8.jpg)'
- en: When the LC application is submitted.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当LC申请提交时。
- en: We expect a deadline for the reminder to be scheduled.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望安排一个提醒的截止日期。
- en: 'The implementation for this is fairly straightforward:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的步骤相当直接：
- en: '![](img/ch8-9.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-9.jpg)'
- en: To allow working with deadlines, the Axon Framework provides a `DeadlineManager`
    that allows working with deadlines. This is injected into the command handler
    method.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许与截止日期一起工作，Axon框架提供了一个`DeadlineManager`，允许与截止日期一起工作。这个管理器被注入到命令处理方法中。
- en: We use `deadlineManager` to schedule a named deadline (`"LC_APPROVAL_REMINDER"`
    in this case) that will expire in 10 days.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`deadlineManager`来安排一个名为的截止日期（在这种情况下为`"LC_APPROVAL_REMINDER"`），它将在10天后到期。
- en: When the deadline is met, it will result in `LCApprovalPendingNotification`,
    which can be handled just like a command. Except, in this case, the behavior is
    triggered by the passage of time.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当截止日期满足时，它将导致`LCApprovalPendingNotification`，这可以像命令一样处理。但是，在这种情况下，行为是由时间的流逝触发的。
- en: 'If no action is taken for 10 days, this is what we expect:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果10天内没有采取任何行动，这是我们期望的情况：
- en: '![](img/ch8-10.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-10.jpg)'
- en: Given that the LC application is submitted.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设LC申请已经提交。
- en: When the period of 10 days elapses.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当10天的周期结束时。
- en: The deadline should be met.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该满足截止日期。
- en: '`LCApprovalPendingEvent` should be emitted.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该发出`LCApprovalPendingEvent`。
- en: 'Let’s look at how to implement this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这一点：
- en: '![](img/ch8-11.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-11.jpg)'
- en: Deadlines are handled by annotating handler methods with the `@DeadlineHandler`
    annotation. Note that the same deadline name used previously is being referenced
    here.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 截止日期通过使用`@DeadlineHandler`注解来处理。请注意，这里引用的是之前使用的相同截止日期名称。
- en: This is the deadline handler method and uses the same payload that was passed
    along when it was scheduled.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是截止日期处理方法，并使用在调度时传递的相同有效载荷。
- en: We emit `LCApprovalPendingEvent` when the deadline expires.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当截止日期到期时，我们发出`LCApprovalPendingEvent`。
- en: 'The deadline handling logic should only be triggered if no action is taken.
    However, if the LC is either approved or rejected within a duration of 10 days,
    none of this behavior should be triggered:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 截止日期处理逻辑只有在没有采取任何行动的情况下才会被触发。然而，如果在10天的时间内LC（贷款承诺）被批准或拒绝，则不应触发以下任何行为：
- en: '![](img/ch8-12.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-12.jpg)'
- en: Given that the LC application is submitted.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设LC申请已提交。
- en: When it is approved within a duration of 10 days (in this case, almost immediately).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它在10天（在这种情况下，几乎是立即）内被批准。
- en: We expect no scheduled deadlines.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们预期没有计划中的截止日期。
- en: 'The implementation for this looks as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现的示例如下：
- en: '![](img/ch8-13.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch8-13.jpg)'
- en: We cancel all the deadlines with the name `LC_APPROVAL_REMINDER` (in this case,
    we only have one deadline with that name) within the scope of this aggregate.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此聚合的作用域内，我们取消所有名为`LC_APPROVAL_REMINDER`（在这种情况下，我们只有一个具有该名称的截止日期）的截止日期。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined how to work with long-running workflows using sagas
    and the different styles we can use to implement them. We also looked at the implications
    of using explicit orchestration versus implicit choreography. We finally looked
    at how we can handle deadlines when there are no user-initiated actions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用sagas和不同的实现风格来处理长时间运行的流程。我们还探讨了使用显式编排与隐式编舞的后果。最后，我们探讨了在没有用户发起的操作时如何处理截止日期。
- en: You have learned how sagas can act as a first-class citizen in addition to aggregates
    when designing a system that makes use of domain-driven design principles.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何在设计利用领域驱动设计原则的系统时，sagas可以作为除了聚合之外的一等公民。
- en: In the next chapter, we will look at how we can interact with external systems
    while respecting bounded context boundaries between core and peripheral systems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在尊重核心系统和外围系统之间的边界上下文中与外部系统进行交互。
- en: Further reading
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '![](img/B16716_08_Table_01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16716_08_Table_01.jpg)'
