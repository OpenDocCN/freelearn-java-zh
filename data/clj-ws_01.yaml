- en: 1\. Hello REPL!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. Hello REPL！
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explain the basics of creating Clojure programs. We start
    by getting you familiar with the **Read Eval Print Loop** (**REPL**), where most
    of the experimentation happens when writing code. The REPL also allows you to
    explore code and documentation by yourself, so it is an excellent place to start.
    After the quick dive in the REPL, we describe in more detail how to read and understand
    simple Lisp and Clojure code, which syntax can sometimes appear unsettling. We
    then explore fundamental operators and functions in Clojure, which enable you
    to write and run simple Clojure programs or scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们解释了创建 Clojure 程序的基础。我们首先让你熟悉 **读取求值打印循环**（**REPL**），在编写代码时，大部分实验都是在 REPL
    中进行的。REPL 还允许你自己探索代码和文档，因此它是一个极佳的起点。在快速了解 REPL 之后，我们将更详细地描述如何阅读和理解简单的 Lisp 和 Clojure
    代码，其语法有时可能显得令人不安。然后，我们探索 Clojure 中的基本运算符和函数，这些运算符和函数使你能够编写和运行简单的 Clojure 程序或脚本。
- en: By the end of this chapter, you will be able to use the REPL and work with functions
    in Clojure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够使用 REPL 并在 Clojure 中处理函数。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Have you ever ended up entangled in the "spaghetti code" of an object-oriented
    application? Many experienced programmers would say yes, and at some point in
    their journey or career would reconsider the foundation of their programs. They
    might look for a simpler, better alternative to object-oriented programming, and
    Clojure is an appealing choice. It is a functional, concise, and elegant language
    of the Lisp family. Its core is small, and its syntax minimal. It shines because
    of its simplicity, which takes a trained eye to notice and ultimately understand.
    Employing Clojure's more sophisticated building blocks will allow you to design
    and build sturdier applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经陷入面向对象应用程序的“意大利面代码”中？许多经验丰富的程序员会说是的，在他们的人生旅程或职业生涯的某个时刻，他们可能会重新考虑他们程序的基础。他们可能会寻找一个更简单、更好的面向对象编程的替代方案，而
    Clojure 就是一个吸引人的选择。它是 Lisp 家族中的一种功能性强、简洁优雅的语言。它的核心很小，语法也很简单。它因其简单性而闪耀，这种简单性需要经过训练的眼睛才能注意到，最终才能理解。使用
    Clojure 更为复杂的构建块将允许你设计和构建更坚固的应用程序。
- en: Whether you are a seasoned programmer or a novice, hobbyist or professional,
    C# wizard or Haskell ninja, learning a new programming language is challenging.
    It is, however, a highly rewarding experience that will make you an overall better
    programmer. In this book, you will learn by doing and will ramp up your skills
    quickly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你是经验丰富的程序员还是新手，爱好者还是专业人士，C# 大师还是 Haskell 高手，学习一门新的编程语言都是一项挑战。然而，这却是一种高度有益的经历，它将使你成为一个更好的程序员。在这本书中，你将通过实践来学习，并且能够快速提升你的技能。
- en: 'Clojure is an excellent choice of programming language to learn today. It will
    allow you to work efficiently using a technology built to last. Clojure can be
    used to program pretty much anything: from full-blown client-server applications
    to simple scripts or big data processing jobs. By the end of this book, you will
    have written a modern web application using Clojure and ClojureScript and will
    have all the cards in your hand to start writing your own!'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是今天学习编程语言的一个极佳选择。它将允许你使用一种旨在持久的技术来高效工作。Clojure 可以用来编写几乎任何东西：从完整的客户端-服务器应用程序到简单的脚本或大数据处理任务。到这本书结束时，你将使用
    Clojure 和 ClojureScript 编写了一个现代网络应用程序，并将拥有所有启动你自己的应用程序所需的牌面！
- en: REPL Basics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL 基础
- en: Welcome to the Clojure **Read Eval Print Loop** (**REPL**), a command-line interface
    that we can use to interact with a running Clojure program. REPL, in the sense
    that it **reads** the user's input (where the user is you, the programmer), **evaluates**
    the input by instantly compiling and executing the code, and **prints** (that
    is, displays) the result to the user. The read-eval-print three-step process repeats
    over and over again (**loop**) until you exit the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 Clojure 的 **读取求值打印循环**（**REPL**），这是一个命令行界面，我们可以用它与运行的 Clojure 程序进行交互。REPL
    在这个意义上是 **读取**用户的输入（用户就是你，程序员），通过即时编译和执行代码来**评估**输入，并将结果**打印**（即显示）给用户。读取-评估-打印的三步过程会不断重复（**循环**），直到你退出程序。
- en: 'The dynamism provided by the REPL allows you to discover and experiment with
    a tight feedback loop: your code is evaluated instantly, and you can adjust it
    until you get it right. Many other programming languages provide interactive shells
    (notably, other dynamic languages such as Ruby or Python), but in Clojure, the
    REPL plays an exceptional and essential role in the life of the developer. It
    is often integrated with the code editor and the line between editing, browsing,
    and executing code blurs toward a malleable development environment similar to
    Smalltalk. But let''s start with the basics.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 提供的动态性允许你发现和实验一个紧密的反馈循环：你的代码被即时评估，你可以调整它直到正确为止。许多其他编程语言提供了交互式外壳（特别是其他动态语言，如
    Ruby 或 Python），但在 Clojure 中，REPL 在开发者的生活中扮演着非凡和至关重要的角色。它通常与代码编辑器集成，编辑、浏览和执行代码之间的界限模糊，类似于
    Smalltalk 的可塑开发环境。但让我们从基础知识开始。
- en: Throughout these exercises, you may notice some mentions of Java (for example,
    in the stack trace in the second exercise). This is because Clojure is implemented
    in Java and runs in the **Java Virtual Machine** (**JVM**). Clojure can, therefore,
    benefit from a mature ecosystem (a battle-tested, widely deployed execution platform
    and a plethora of libraries) while still being a cutting-edge technology. Clojure
    is designed to be a hosted language, and another implementation, called ClojureScript,
    allows you to execute Clojure code on any JavaScript runtime (for example, a web
    browser or Node.js). This hosted-language implementation choice allows for a smaller
    community of functional programmers to strive in an industry dominated by Java,
    .NET Core, and JavaScript technologies. Welcome to the Clojure party, where we're
    all having our cake and eating it too.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些练习中，你可能会注意到一些关于 Java 的提及（例如，在第二个练习的堆栈跟踪中）。这是因为 Clojure 是用 Java 实现的，并在 **Java
    虚拟机**（**JVM**）上运行。因此，Clojure 可以从成熟的生态系统（经过实战检验、广泛部署的执行平台和大量的库）中受益，同时仍然是一个前沿技术。Clojure
    被设计为托管语言，另一个名为 ClojureScript 的实现允许你在任何 JavaScript 运行时（例如，网页浏览器或 Node.js）上执行 Clojure
    代码。这种托管语言实现的选择允许较小的函数式程序员社区在由 Java、.NET Core 和 JavaScript 技术主导的行业中努力。欢迎来到 Clojure
    舞会，在这里我们都在享受我们的蛋糕并吃掉它。
- en: 'Exercise 1.01: Your First Dance'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.01：你的第一次舞蹈
- en: 'In this exercise, we will perform some basic operations in the REPL. Let''s
    get started:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在 REPL 中执行一些基本操作。让我们开始吧：
- en: 'Open Terminal and type `clj`. This will start a Clojure REPL:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入 `clj`。这将启动一个 Clojure REPL：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line is your version of Clojure, which in this example is `1.10.1`.
    Don't worry if your version is different—the exercises we will go through together
    should be compatible with any version of Clojure.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行是 Clojure 的版本，在这个例子中是 `1.10.1`。如果你的版本不同，请不要担心——我们将一起进行的练习应该与任何版本的 Clojure
    兼容。
- en: The second line displays the namespace we are currently in (`user`) and prompts
    for your input. A namespace is a group of things (such as functions) that belong
    together. Everything you create here will be in the `user` namespace by default.
    The `user` namespace can be considered your playground.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二行显示了当前所在的命名空间（`user`）并提示输入。命名空间是一组属于一起的事物（例如函数）。在这里创建的任何内容都将默认位于 `user` 命名空间中。`user`
    命名空间可以被视为你的游乐场。
- en: Your REPL is ready to **read**.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的 REPL 已经准备好**读取**。
- en: 'Let''s try to evaluate an expression:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试评估一个表达式：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Clojure, *literal* strings are created with double quotes, `""`. A literal
    is a notation for representing a fixed value in source code.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Clojure 中，*字面量*字符串使用双引号创建，`""`。字面量是在源代码中表示固定值的一种表示法。
- en: 'Let''s see what happens if we type in multiple strings:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如果我们输入多个字符串会发生什么：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have just evaluated two expressions sequentially, and each result is printed
    onto separate lines.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经连续评估了两个表达式，并且每个结果都打印到了单独的行上。
- en: 'Now, let''s try a bit of arithmetic, for example, `1 + 2`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一些算术运算，例如 `1 + 2`：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output is not exactly what we expected. Clojure evaluated the three components,
    that is, `1`, `+`, and `2`, *separately*. Evaluating `+` looks strange because
    the `+` symbol is bound to a function.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出并不完全符合我们的预期。Clojure 对三个组件进行了评估，即 `1`、`+` 和 `2`，*分别* 进行评估。评估 `+` 看起来很奇怪，因为
    `+` 符号绑定了一个函数。
- en: Note
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A function is a unit of code that performs a specific task. We don't need to
    know more for now except that functions can be called (or invoked) and can take
    some parameters. A function's argument is a term that's used to design the value
    of a parameter, but those terms are often used interchangeably.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数是执行特定任务的代码单元。我们现在不需要了解更多，除了函数可以被调用（或调用）并且可以接受一些参数。函数的参数是一个术语，用于设计参数的值，但这些术语通常可以互换使用。
- en: To add those numbers, we need to call the `+` function with the arguments `1`
    and `2`.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要添加这些数字，我们需要调用`+`函数，并传入参数`1`和`2`。
- en: 'Call the `+` function with the arguments `1` and `2` as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式调用`+`函数，并传入参数`1`和`2`：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will soon discover that many basic operations that are usually part of a
    programming language syntax, such as addition, multiplication, comparison, and
    so on, are just simple functions in Clojure.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你很快就会发现，许多通常是编程语言语法一部分的基本操作，比如加法、乘法、比较等，在Clojure中只是简单的函数。
- en: 'Let''s try a few more examples of basic arithmetic. You can even try to pass
    more than two arguments to the following functions, so adding 1 + 2 + 3 together
    would look like `(+ 1 2 3)`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试更多基本算术的示例。你甚至可以尝试向以下函数传递超过两个参数，所以将1 + 2 + 3相加将看起来像`(+ 1 2 3)`：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The other basic arithmetic operators are used in a similar way. Try and type
    the following expressions:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他基本算术运算符的使用方式类似。尝试输入以下表达式：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After typing in the preceding examples, you should try a few more by yourself
    – the REPL is here to be experimented with.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输入前面的示例之后，你应该尝试更多自己输入的内容——REPL就是为了实验而存在的。
- en: 'You should now be familiar enough with the REPL to ask the following question:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该足够熟悉REPL，可以提出以下问题：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Don't take it personally – `nil` was the value that was returned by the `println`
    function. The text that was printed by the function was merely a *side effect*
    of this function.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要个人化——`nil`是`println`函数返回的值。该函数打印的文本仅仅是这个函数的*副作用*。
- en: '`nil` is the Clojure equivalent of "null," or "nothing"; that is, the absence
    of meaningful value. `print` (without a new line) and `println` (with a new line)
    are used to print objects to the standard output, and they return `nil` once they
    are done.'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`nil`是Clojure中“null”或“nothing”的等价物；也就是说，没有有意义的价值。`print`（不带换行符）和`println`（带换行符）用于将对象打印到标准输出，并在完成后返回`nil`。'
- en: 'Now, we can combine those operations and print the result of a simple addition:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以组合这些操作并打印简单加法的结果：
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A value of `3` was printed and the value of `nil` was returned by this expression.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该表达式打印了一个值为`3`，并返回了`nil`值。
- en: 'Notice how we have nested those *forms* (or *expressions*). This is how we
    chain functions in Clojure:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何嵌套那些*形式*（或*表达式*）。这就是我们在Clojure中链式调用函数的方式：
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Exit the REPL by pressing *Ctrl* + *D*. The function to exit is `System/exit`,
    which takes the exit code as a parameter. Therefore, you can also type the following:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *D*退出REPL。退出函数是`System/exit`，它接受退出码作为参数。因此，你也可以输入以下内容：
- en: '[PRE15]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this exercise, we discovered the REPL and called Clojure functions to print
    and perform basic arithmetic operations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们发现了REPL并调用了Clojure函数来打印和执行基本的算术操作。
- en: 'Exercise 1.02: Getting around in the REPL'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.02：在REPL中导航
- en: 'In this exercise, we will introduce a few navigational key bindings and commands
    to help you use and survive the REPL. Let''s get started:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍一些导航快捷键和命令，帮助你使用并生存于REPL中。让我们开始吧：
- en: Start by opening the REPL again.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先再次打开REPL。
- en: Notice how you can navigate the history of what was typed earlier and in previous
    sessions by pressing *Ctrl* + *P* (or the *UP* arrow) and *Ctrl* + *N* (or the
    *DOWN* arrow).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意你可以通过按*Ctrl* + *P*（或*UP*箭头）和*Ctrl* + *N*（或*DOWN*箭头）来导航之前输入的内容和之前的会话历史。
- en: 'You can also search (case-sensitive) through the history of the commands you
    have entered: press *Ctrl* + *R* and then `Hello`, which should bring back the
    `Hello` `Again` expression we typed earlier. If you press *Ctrl* + *R* a second
    time, it will cycle through the matches of the search and bring back the very
    first command: `Hello REPL!`. If you press *Enter*, it will bring the expression
    back to the current prompt. Press *Enter* again and it will evaluate it.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以搜索（区分大小写）你输入的命令历史：按 *Ctrl* + *R* 然后输入 `Hello`，这应该会带回到我们之前输入的 `Hello Again`
    表达式。如果你再次按 *Ctrl* + *R*，它将遍历搜索的匹配项并带回到第一个命令：`Hello REPL!`。如果你按 *Enter*，它将表达式带回到当前提示符。再次按
    *Enter* 将评估它。
- en: 'Now, evaluate the following expression, which *increments* (adds 1 to) the
    number 10:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，评估以下表达式，该表达式将数字 10 *增加*（加 1）：
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The returned value is 11, which is indeed 10 + 1.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回的值是 11，这确实是 10 + 1。
- en: '`*1` is a special variable that is bound to the result of the last expression
    that was evaluated in the REPL. You can evaluate its value by simply typing it
    like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*1` 是一个特殊变量，它绑定到在 REPL 中评估的最后表达式的结果。你可以通过简单地像这样输入它来评估它的值：'
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly, `*2` and `*3` are variables bound to the second and third most recent
    values of that REPL session, respectively.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，`*2` 和 `*3` 分别绑定到该 REPL 会话中第二和第三最近的价值。
- en: 'You can also reuse those special variable values within other expressions.
    See if you can follow and type this sequence of commands:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以在其他表达式中重用这些特殊的变量值。看看你是否能跟随并输入以下命令序列：
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the values of `*1` and `*2` change as new expressions are evaluated.
    When the REPL is crowded with text, press *Ctrl* + *L* to clear the screen.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `*1` 和 `*2` 的值是如何随着新表达式的评估而变化的。当 REPL 中文本很多时，按 *Ctrl* + *L* 清屏。
- en: 'Another useful variable that''s available in the REPL is `*e`, which contains
    the result of the last exception. At the moment, it should be `nil` unless you
    generated an error earlier. Let''s trigger an exception voluntarily by dividing
    by zero:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REPL 中还可用的一个有用变量是 `*e`，它包含最后一个异常的结果。目前，它应该是 `nil`，除非你之前生成了错误。让我们通过除以零来自愿触发一个异常：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Evaluating `*e` should contain details about the exception, including the stack
    trace:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 评估 `*e` 应该包含有关异常的详细信息，包括堆栈跟踪：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'Different Clojure implementations may have a slightly different behavior. For
    example, if you tried to divide by 0 in a ClojureScript REPL, it will not throw
    an exception and instead return the "infinity value":'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同的 Clojure 实现可能会有略微不同的行为。例如，如果你在一个 ClojureScript REPL 中尝试除以 0，它不会抛出异常，而是返回“无穷大”值：
- en: '`cljs.user=> (/ 1 0)`'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cljs.user=> (/ 1 0)`'
- en: '`##Inf`'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`##Inf`'
- en: 'This is to stay consistent with the host platform: the literal number 0 is
    implemented as an integer in Java (and Clojure) but as a floating-point number
    in JavaScript (and ClojureScript). The IEEE Standard for Floating-Point Arithmetic
    (IEEE 754) specifies that division by 0 should return +/- infinity.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是为了保持与主机平台的一致性：字面数字 0 在 Java（和 Clojure）中实现为整数，但在 JavaScript（和 ClojureScript）中实现为浮点数。IEEE
    浮点算术标准（IEEE 754）指定除以 0 应该返回 +/- 无穷大。
- en: 'The `doc`, `find-doc`, and `apropos` functions are essential REPL tools for
    browsing through documentation. Given that you know the name of the function you
    want to use, you can read its documentation with `doc`. Let''s see how it works
    in practice. Start by typing `(doc str)` to read more about the `str` function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doc`、`find-doc` 和 `apropos` 函数是浏览文档的必要 REPL 工具。既然你知道你想使用的函数的名称，你可以使用 `doc`
    来阅读它的文档。让我们看看它在实际中的应用。首先，输入 `(doc str)` 来了解更多关于 `str` 函数的信息：'
- en: '[PRE21]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`doc` prints the fully qualified name of the function (including the namespace)
    on the first line, the possible sets of parameters (or "arities") on the next
    line, and finally the description.'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`doc` 在第一行打印函数的完全限定名称（包括命名空间），在下一行打印可能的参数集（或“arity”），最后是描述。'
- en: This function's fully qualified name is `clojure.core/str`, which means that
    it is in the `clojure.core` namespace. Things defined in `clojure.core` are available
    to your current namespace by default, without you explicitly having to require
    them. This is because they are fundamental components for building your programs,
    and it would be tedious to have to use their full name every time.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数的完全限定名称是 `clojure.core/str`，这意味着它在 `clojure.core` 命名空间中。在 `clojure.core`
    中定义的东西默认情况下就可用在你的当前命名空间中，无需你显式地导入它们。这是因为它们是构建程序的基本组件，每次都使用它们的完整名称将会很繁琐。
- en: 'Let''s try to use the `str` function. As the documentation explains, we can
    pass it multiple arguments:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用 `str` 函数。正如文档所解释的，我们可以传递多个参数：
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s inspect the documentation of the `doc` function:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查 `doc` 函数的文档：
- en: '[PRE23]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function is in the `clojure.repl` namespace, which is also available by
    default in your REPL environment.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数位于 `clojure.repl` 命名空间中，它也在你的 REPL 环境中默认可用。
- en: 'You can also look at the documentation of a namespace. As its documentation
    suggests, your final program would typically not use the helpers in the `clojure.repl`
    namespace (for instance, `doc`, `find-doc`, and `apropos`):'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以查看命名空间的文档。正如其文档所建议的，你的最终程序通常不会使用 `clojure.repl` 命名空间中的辅助工具（例如，`doc`、`find-doc`
    和 `apropos`）：
- en: '[PRE24]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you don''t know the name of the function, but you have an idea of what
    the description or name may contain, you can search for it with the `find-doc`
    helper. Let''s try and search for the `modulus` operator:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你不知道函数的名称，但你对描述或名称可能包含的内容有一个想法时，你可以使用 `find-doc` 辅助工具来搜索它。让我们尝试搜索 `modulus`
    运算符：
- en: '[PRE25]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'No luck, but there''s a catch: `find-doc` is case-sensitive, but the good news
    is that we can use a regular expression with the `i` modifier to ignore the case:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有成功，但有一个转折：`find-doc` 是区分大小写的，但好消息是我们可以使用带有 `i` 修饰符的正则表达式来忽略大小写：
- en: '[PRE26]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You don't need to know more about regular expressions for now – you don't even
    have to use them, but it can be useful to ignore the case when searching for a
    function. You can write them with the `#"(?i)text"` syntax, where `text` is anything
    you want to search for.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前你不需要了解更多关于正则表达式的知识——你甚至不需要使用它们，但忽略大小写来搜索函数可能很有用。你可以用 `#"(?i)text"` 语法来写它们，其中
    `text` 是你想要搜索的任何内容。
- en: The function we were looking for was `clojure.core/mod`.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们要找的函数是 `clojure.core/mod`。
- en: 'Let''s make sure it works according to its documentation:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们确保它按照其文档工作：
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use the `apropos` function to search for functions by name, thereby yielding
    a more succinct output. Say we were looking for a function that transforms the
    case of a given string of characters:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `apropos` 函数通过名称搜索函数，从而产生更简洁的输出。比如说，我们正在寻找一个转换给定字符字符串的案例的函数：
- en: '[PRE28]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Please note that this function is in the `clojure.string` namespace, which is
    not referred to by default. You will need to use its full name until we learn
    how to import and refer symbols from other namespaces.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，此函数位于 `clojure.string` 命名空间中，默认情况下并未引用。在我们学习如何从其他命名空间导入和引用符号之前，您需要使用其全名。
- en: 'Activity 1.01: Performing Basic Operations'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.01：执行基本操作
- en: In this activity, we will print messages and perform some basic arithmetic operations
    in the Clojure REPL.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将在 Clojure REPL 中打印消息并执行一些基本的算术运算。
- en: 'These steps will help you complete this activity:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成此活动：
- en: Open the REPL.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 REPL。
- en: Print the message "`I am not afraid of parentheses`" to motivate yourself.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印消息 "`我不怕括号`" 来激励自己。
- en: 'Add 1, 2, and 3 and multiply the result by 10 minus 3, which corresponds to
    the following `infix` notation: (1 + 2 + 3) * (10 - 3). You should obtain the
    following result:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 1、2 和 3 相加，然后将结果乘以 10 减 3，这对应于以下 `中缀` 表示法：(1 + 2 + 3) * (10 - 3)。你应该得到以下结果：
- en: '[PRE29]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Print the message "`Well done`!" to congratulate yourself.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印消息 "`做得好`!" 来祝贺自己。
- en: Exit the REPL.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 REPL。
- en: Note
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: The solution to this activity can be found on page 678.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 678 页找到。
- en: Evaluation of Clojure Code
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 代码的评估
- en: Clojure is a dialect of Lisp, a high-level programming language that was designed
    by John McCarthy and first appeared in 1958\. One of the most distinctive features
    of Lisp and its derivatives, or "dialects," is the use of data structures to write
    the source code of programs. The unusual number of parentheses in our Clojure
    programs is a manifestation of this as parentheses are used to create lists.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是 Lisp 的一种方言，一种由 John McCarthy 设计的高级编程语言，首次出现在 1958 年。Lisp 及其衍生品或“方言”的最显著特征之一是使用数据结构来编写程序的源代码。我们
    Clojure 程序中不寻常的括号数量就是这种特征的体现，因为括号用于创建列表。
- en: Here, we will focus on the building blocks of Clojure programs, that is, *forms
    and expressions,* and briefly look at how expressions are evaluated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将关注 Clojure 程序的构建块，即 *形式和表达式*，并简要地看看表达式是如何被评估的。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'The terms "expression" and "form" are often used interchangeably; however,
    according to the Clojure documentation, an expression is a form type: *"Every
    form not handled specially by a special form or macro is considered by the compiler
    to be an expression, which is evaluated to yield a value."*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “表达式”和“形式”这两个术语经常可以互换使用；然而，根据 Clojure 文档，表达式是一种形式类型：“每个没有被特殊形式或宏特别处理的表单都被编译器视为表达式，它被评估以产生一个值。”
- en: 'We have seen how literals are valid syntax and evaluate to themselves, for
    example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到字面量是有效的语法，并且评估为自身，例如：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have also learned how to invoke functions by using parentheses:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何通过使用括号来调用函数：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is worth noting at this point that comments can be written with "`;`" at
    the beginning of a line. Any line starting with "`;`" will not be evaluated:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在此点，可以在一行的开头使用 "`;`" 来编写注释。任何以 "`;`" 开头的行将不会被评估：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Functions are invoked according to the following structure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的调用遵循以下结构：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Take note of the following from the preceding example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下来自前一个示例的内容：
- en: The list, denoted by opening and closing parenthesis, `()`, is evaluated to
    a function call (or invocation).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表，由开括号和闭括号 `()` 表示，被评估为函数调用（或调用）。
- en: When evaluated, the `*` symbol resolves to the function that implements the
    multiplication.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进行评估时，`*` 符号解析为执行乘法的函数。
- en: '`2`, `3`, and `4` are evaluated to themselves and passed as arguments to the
    function.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`、`3` 和 `4` 被评估为自身，并将作为参数传递给函数。'
- en: 'Consider the expression you wrote in *Activity 1.01*, *Performing Basic Operations*:
    `(* (+ 1 2 3) (- 10 3))`. It can also help to visualize the expression as a tree:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你在 *活动 1.01* 中编写的表达式，*执行基本操作*：`(* (+ 1 2 3) (- 10 3))`。将其视为树形结构也有助于可视化该表达式：
- en: '![Figure 1.1: Tree representation of the expression, (* (+ 1 2 3) (- 10 3))'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1：表达式 (* (+ 1 2 3) (- 10 3)) 的树形表示]'
- en: '](img/B14502_01_01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_01_01.jpg)'
- en: 'Figure 1.1: Tree representation of the expression, (* (+ 1 2 3) (- 10 3))'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：表达式 (* (+ 1 2 3) (- 10 3)) 的树形表示
- en: 'Evaluating this expression consists of reducing the tree, starting with the
    offshoots (the innermost lists): `(* (+ 1 2 3) (- 10 3))` becomes `(* 6 7)`, which
    becomes `42`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 评估这个表达式包括减少树，从分支（最内层的列表）开始：`(* (+ 1 2 3) (- 10 3))` 变为 `(* 6 7)`，然后变为 `42`。
- en: The term **s-expression** (or symbolic expression) is often used to designate
    those types of expressions. You may come across it again, so it is good to know
    that an s-expression is a data notation for writing data structures and code with
    lists, as we demonstrated previously.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **s-expression**（或符号表达式）常用来指代这类表达式。你可能会再次遇到它，所以了解 s-expression 是一个使用列表编写数据结构和代码的数据表示法，正如我们之前所展示的那样。
- en: 'So far, we have only used literal scalar types as operands to our operators,
    which hold one value, such as numbers, strings, Booleans, and so on. We''ve only
    used lists to invoke functions and not to represent data. Let''s try to create
    a list that represents data but not "code":'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用字面量标量类型作为运算符的操作数，这些类型只包含一个值，例如数字、字符串、布尔值等。我们只使用列表来调用函数，而不是表示数据。让我们尝试创建一个表示数据但不表示“代码”的列表：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: An exception was thrown because the first item of the list (the operator) was
    not a function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出了一个异常，因为列表的第一个元素（运算符）不是一个函数。
- en: 'There is a special syntax to prevent the list from being considered as the
    invocation of a function: the quote. Creating a literal list is done by adding
    a quotation `''`, in front of it, so let''s try again:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的语法可以防止列表被视为函数的调用：引用。创建字面量列表是通过在其前面添加引用 `'` 来完成的，所以让我们再试一次：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Great! By preventing the evaluation of the form, we can now write a literal
    representation of lists.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！通过防止表单的评估，我们现在可以编写列表的字面量表示。
- en: This concept will help us get ready for what we are going to cover next. It
    is, however, fascinating to notice at this point that Clojure code is made up
    of data structures, and our programs can generate those same data structures.
    "Code is data" is a famous saying in the Lisp world, and a powerful concept that
    allows your program to generate code (known as **meta-programming**). If you are
    new to this concept, it is worth pausing for a minute to think and admire the
    sheer beauty of it. We will explain meta-programming techniques in detail later
    when explaining *macros* in *Chapter 11*, *Macros*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念将帮助我们为接下来要介绍的内容做好准备。然而，在这个时候注意到 Clojure 代码由数据结构组成，我们的程序可以生成那些相同的数据结构，这是非常迷人的。"代码是数据"
    是 Lisp 世界中的一句名言，这是一个强大的概念，允许你的程序生成代码（称为 **元编程**）。如果你对这个概念还不熟悉，那么花一分钟时间思考和欣赏它的纯粹之美是值得的。我们将在解释
    *第 11 章* 中的 *宏* 时详细解释元编程技术。
- en: Basic Special Forms
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本特殊形式
- en: So far, we have been writing code that complies with the simplest rules of evaluating
    Clojure code, but there are some behaviors that cannot simply be encoded with
    normal functions. For example, arguments that have been passed to a function will
    always be resolved or evaluated, but what if we do not want to evaluate all the
    operands of an operator? That is when special forms come into play. They can have
    different evaluation rules for functions when the source code is read by Clojure.
    For example, the special form `if`, may not evaluate one of its arguments, depending
    on the result of the first argument.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在编写符合 Clojure 代码最简单规则的代码，但有一些行为不能简单地用正常函数来编码。例如，传递给函数的参数将始终被解析或评估，但如果我们不想评估运算符的所有操作数呢？这就是特殊形式发挥作用的时候。它们可以在
    Clojure 读取源代码时为函数提供不同的评估规则。例如，特殊形式 `if` 可能不会评估其参数之一，这取决于第一个参数的结果。
- en: 'There are a few other special forms that we will go through in this section:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将介绍几个其他特殊形式：
- en: '`when`, which can be used when we are only interested in the case of a condition
    being *truthy* (a value is *truthy* when considered true in the context of a Boolean
    expression).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when` 可以在只对条件为 *真值*（在布尔表达式的上下文中，值被认为是 *真值*）的情况感兴趣时使用。'
- en: '`do`, which can be used to execute a series of expressions and return the value
    of the last expression.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do` 可以用来执行一系列表达式并返回最后一个表达式的值。'
- en: '`def` and `let`, which are special forms that are used to create global and
    local bindings.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def` 和 `let`，这些是用于创建全局和局部绑定的特殊形式。'
- en: '`fn` and `defn`, which are special forms that are used to create functions.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn` 和 `defn`，这些是用于创建函数的特殊形式。'
- en: All these special forms have special evaluation rules, all of which we will
    discover by working through the following three exercises.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特殊形式都有特殊的评估规则，所有这些规则我们都会通过以下三个练习来发现。
- en: 'Exercise 1.03: Working with if, do, and when'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.03：使用 if、do 和 when
- en: 'In this exercise, we will evaluate expressions using the `if`, `do`, and `when`
    forms. Let''s get started:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `if`、`do` 和 `when` 形式来评估表达式。让我们开始吧：
- en: 'Start your REPL and type in the following expression:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 REPL 并输入以下表达式：
- en: '[PRE36]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The special form `if`, evaluates its first argument. If its value is truthful,
    it will evaluate argument `2`, otherwise (`else`), it will evaluate argument 3\.
    It will never evaluate both arguments 2 and 3.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊形式 `if`，评估其第一个参数。如果其值为真，它将评估参数 2，否则（`else`），它将评估参数 3。它永远不会同时评估参数 2 和 3。
- en: 'We can nest expressions and start doing more interesting things:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以嵌套表达式，并开始做一些更有趣的事情：
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, the computation of `(+ 3 4)` will not be executed, and only a
    random number (between 0 and 1) will be returned by the `rand` function.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，计算 `(+ 3 4)` 将不会执行，`rand` 函数只会返回一个随机数（介于 0 和 1 之间）。
- en: 'But what if we wanted to do more than one thing in our branch of the condition?
    We could wrap our operation with `do`. Let''s see how `do` works:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但如果我们想在条件的分支中做更多的事情呢？我们可以用 `do` 来包裹我们的操作。让我们看看 `do` 是如何工作的：
- en: '[PRE38]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To use the special form, `do` type the following expression:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用特殊形式，请输入以下表达式：
- en: '[PRE39]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All the expressions before the final `(+ 1 1)` expression were evaluated, but
    only the value of the last one is returned. This does not look very useful with
    expressions that don't alter the state of the world, and so it would typically
    be used for side effects such as logging or any other kind of I/O (filesystem
    access, database query, network request, and so on).
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后的`(+ 1 1)`表达式之前的所有表达式都被评估了，但只有最后一个表达式的值被返回。对于不改变世界状态的表达式来说，这看起来并不很有用，因此它通常用于副作用，如日志记录或任何其他类型的I/O（文件系统访问、数据库查询、网络请求等）。
- en: 'You don''t have to take my word for it, so let''s experiment with the side
    effect of printing to the Terminal:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不必相信我的话，所以让我们通过在终端打印副作用来实验：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we can combine the use of `if` and `do` to execute multiple operations
    in a conditional branching:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以结合使用`if`和`do`来在条件分支中执行多个操作：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Technically, you could also omit the third argument. Bring back the previous
    expression in the REPL and remove the last expression, that is, `(+ 1 2)`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术上，你也可以省略第三个参数。在REPL中恢复之前的表达式，并移除最后一个表达式，即`(+ 1 2)`：
- en: '[PRE42]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have a better construct available for this case: the `when` operator. Instead
    of combining `if` and `do`, when you are only interested in doing work in one
    branch of the conditional execution, use `when`.'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这种情况，我们有更好的构造：`when`运算符。当你只对条件执行的一个分支中的工作感兴趣时，使用`when`而不是组合`if`和`do`：
- en: 'Type the following expression to use `when` instead of a combination of `if`
    and `do`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下表达式来使用`when`而不是`if`和`do`的组合：
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By completing this exercise, we have demonstrated the usage of the special forms
    known as `if`, `do`, and `when`. We can now write expressions that contain multiple
    statements, as well as conditional expressions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们已经展示了特殊形式`if`、`do`和`when`的用法。现在我们可以编写包含多个语句以及条件表达式的表达式。
- en: Bindings
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: In Clojure, we use the term *bindings* rather than *variables* and *assignments*
    because we tend to bind a value to a symbol only once. Under the hood, Clojure
    creates *variables* and so you may encounter this term, but it would be preferable
    if you don't think of them as classic *variables* or values that can change. We
    won't use the term variable anymore in this chapter as it can be confusing. You
    can use `def` to define global bindings and `let` for local bindings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，我们使用术语*绑定*而不是*变量*和*赋值*，因为我们倾向于只将一个值绑定到一个符号上。在底层，Clojure创建*变量*，因此你可能会遇到这个术语，但如果你不把它们视为经典的*变量*或可以改变的值，那就更好了。在本章中，我们不再使用术语变量，因为它可能会造成混淆。你可以使用`def`来定义全局绑定，使用`let`来定义局部绑定。
- en: 'Exercise 1.04: Using def and let'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.04：使用def和let
- en: 'In this exercise, we will demonstrate the usage of the `def` and `let` keywords,
    which are used to create bindings. Let''s get started:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将展示`def`和`let`关键字的使用，这些关键字用于创建绑定。让我们开始吧：
- en: 'The special form `def` allows you to bind a value to a symbol. In the REPL,
    type the following expression to bind the value `10` to the `x` symbol:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊形式`def`允许你将值绑定到符号。在REPL中，输入以下表达式将值`10`绑定到`x`符号：
- en: '[PRE44]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When the REPL returns `#'user/x`, it is returning a reference to the var you
    have just created. The user part indicates the namespace where the var is defined.
    The `#'` prefix is a way of quoting the var so that we see the symbol and not
    the value of the symbol.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当REPL返回`#'user/x`时，它正在返回你刚刚创建的变量的引用。`user`部分表示变量定义的命名空间。`#'`前缀是一种引用变量的方式，这样我们就能看到符号而不是符号的值。
- en: 'Evaluate the expression, `x`, which will resolve the `x` symbol to its value:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估表达式`x`，这将解析`x`符号到其值：
- en: '[PRE45]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Technically, you can change the binding, which is fine when experimenting in
    the REPL:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术上，你可以更改绑定，这在REPL中实验时是可行的：
- en: '[PRE46]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It is, however, not recommended in your programs because it can make it hard
    to read and complicate its maintenance. For now, it would be better if you just
    consider such a binding as a *constant.*
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在你的程序中并不推荐这样做，因为它可能会使代码难以阅读并复杂化其维护。现在，最好是将这样的绑定视为一个*常量*。
- en: 'You can use the `x` symbol within another expression:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在另一个表达式中使用`x`符号：
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Wherever `def` is invoked, it will bind the value to the symbol in the current
    namespace. We could try to define a local binding in a `do` block and see what
    happens:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论`def`在哪里被调用，它都会将值绑定到当前命名空间中的符号。我们可以在`do`块中尝试定义一个局部绑定，看看会发生什么：
- en: '[PRE48]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The bindings that are created by `def` have an indefinite scope (or dynamic
    scope) and can be considered as "global." They are automatically namespaced, which
    is a useful trait to avoid clashing with existing names.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由 `def` 创建的绑定具有不确定的作用域（或动态作用域），可以视为“全局”。它们会自动命名空间，这是一个有用的特性，可以避免与现有名称冲突。
- en: 'If we want to have a binding available only to a local scope or lexical scope,
    we can use the special form `let`. Type the following expression to create a lexical
    binding of the `y` symbol:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只想让绑定在局部作用域或词法作用域内可用，我们可以使用特殊形式 `let`。输入以下表达式以创建 `y` 符号的词法绑定：
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`let` takes a "vector" as a parameter to create the local bindings, and then
    a series of expressions that will be evaluated like they are in a `do` block.'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let` 以一个“向量”作为参数来创建局部绑定，然后是一系列表达式，这些表达式将被评估，就像它们在一个 `do` 块中一样。'
- en: Note
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A vector is similar to a list, in the sense that they both are a sequential
    collection of values. Their underlying data structure is different, and we will
    shed light on this in *Chapter 2*, *Data Types and Immutability*. For now, you
    just need to know that vectors can be created with square brackets, for example,
    `[1 2 3 4]`.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向量与列表类似，因为它们都是值的顺序集合。它们的底层数据结构不同，我们将在*第2章*，*数据类型和不可变性*中详细说明。现在，你只需要知道向量可以用方括号创建，例如，`[1
    2 3 4]`。
- en: 'Evaluate the `y` symbol:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估 `y` 符号：
- en: '[PRE50]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'An error is thrown, that is, `Unable to resolve symbol: y in this context`,
    because we are now outside of the `let` block.'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 会抛出一个错误，即“无法在当前上下文中解析符号：y”，因为我们现在处于 `let` 块之外。
- en: 'Type the following expression to create a lexical binding of `x` to the value
    `3`, and see how it affects the indefinite (global) binding of `x` that we created
    in *step 4*:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下表达式以创建 `x` 到值 `3` 的词法绑定，并看看它如何影响我们在*步骤4*中创建的不确定（全局）绑定 `x`：
- en: '[PRE51]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Printing `x` yields the value `3`, which means that the "global" `x` symbol
    was temporarily overridden or "shadowed" by the lexical context in which `println`
    was invoked.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印 `x` 得到值 `3`，这意味着“全局”的 `x` 符号被在 `println` 调用时的词法上下文临时覆盖或“阴影”。
- en: 'You can create multiple local bindings at once with `let` by passing an even
    number of items in the vector. Type the following expression to bind `x` to `10`
    and `y` to `20`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `let` 一次创建多个局部绑定，通过在向量中传递偶数个项。输入以下表达式以将 `x` 绑定到 `10`，将 `y` 绑定到 `20`：
- en: '[PRE52]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Combine the concepts of this section and write the following expressions:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合本节的概念，编写以下表达式：
- en: '[PRE53]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The expression spans over multiple lines to improve readability.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式跨越多行以提高可读性。
- en: 'Exercise 1.05: Creating Simple Functions with fn and defn'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.05：使用fn和defn创建简单函数
- en: 'The special form that''s used to define functions is `fn`. Let''s jump right
    into it by creating our first function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数的特殊形式是 `fn`。让我们直接进入正题，通过创建我们的第一个函数来开始：
- en: 'Type the following expression in your REPL:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的REPL中输入以下表达式：
- en: '[PRE54]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We have just created the simplest anonymous function, which takes no parameters
    and does nothing, and we returned an object, which is our function with no name.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚创建了最简单的匿名函数，它不接受任何参数也不做任何事情，并返回了一个对象，即我们的无名称函数。
- en: 'Create a function that takes a parameter named `x` and return its square value
    (multiply it by itself):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接受名为 `x` 的参数并返回其平方值的函数（乘以自身）：
- en: '[PRE55]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Remember that, in Clojure, the first item of an expression will be invoked,
    so we can call our anonymous function by wrapping it with parentheses and providing
    an argument as the second item of the expression:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，在Clojure中，表达式的第一个项将被调用，因此我们可以通过将匿名函数用括号括起来并提供作为表达式第二个项的参数来调用我们的匿名函数：
- en: '[PRE56]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now this is great, but not very convenient. If we wanted our function to be
    reusable or testable, it would be better for it to have a name. We can create
    a symbol in the namespace and bind it to the function.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在这是很好的，但不是很方便。如果我们想让函数可重用或可测试，给它一个名字会更好。我们可以在命名空间中创建一个符号并将其绑定到函数上。
- en: 'Use `def` to bind the function returned by the special form, `fn`, to the `square`
    symbol:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `def` 将特殊形式 `fn` 返回的函数绑定到 `square` 符号：
- en: '[PRE57]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Invoke your newly created function to make sure that it works:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用你新创建的函数以确保它正常工作：
- en: '[PRE58]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This pattern of combining `def` and `fn` is so common that a built-in *macro*
    was born out of necessity: `defn`. Recreate the square function with `defn` instead
    of `def` and `fn`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种将 `def` 和 `fn` 结合的模式非常常见，以至于出于必要性产生了内置的 *宏*：`defn`。用 `defn` 而不是 `def` 和 `fn`
    重新创建平方函数：
- en: '[PRE59]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Did you notice that the `x` argument was passed in a vector? We have already
    learned that vectors are collections, and so we can add more than one symbol to
    the argument's vector. The values that are passed when calling the function will
    be bound to the symbols provided in the vector during the function's definition.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你注意到`x`参数是以向量形式传递的吗？我们已经了解到向量是集合，因此我们可以将多个符号添加到参数的向量中。在调用函数时传递的值将在函数定义期间绑定到向量中提供的符号。
- en: 'Functions can take multiple arguments, and their bodies can be composed of
    multiple expressions (such as an implicit `do` block). Create a function with
    the name `meditate` that takes two arguments: a string, `s`, and a Boolean, `calm`.
    The function will print an introductory message and return a transformation of
    `s` based on `calm`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以接受多个参数，它们的主体可以由多个表达式组成（如隐式`do`块）。创建一个名为`meditate`的函数，它接受两个参数：一个字符串`s`和一个布尔值`calm`。该函数将打印一个介绍性消息并根据`calm`返回`s`的转换：
- en: '[PRE60]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Editing multiline expressions in the REPL can be cumbersome. As we start creating
    lengthier functions and expressions that span multiple lines, it would be preferable
    to have a window of your favorite editor open next to your REPL window. Keep those
    windows side by side, edit the code in your editor, copy it to your clipboard,
    and paste it into your REPL.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在REPL中编辑多行表达式可能会很麻烦。当我们开始创建更长的函数和跨越多行的表达式时，最好在REPL窗口旁边打开你最喜欢的编辑器窗口。保持这些窗口并排打开，在编辑器中编辑代码，将其复制到剪贴板，然后将其粘贴到REPL中。
- en: The function body contains two main expressions, the first of which is a side
    effect with `println` and the second of which is the `if` block, which will determine
    the return value. If `calm` is `true`, it will politely return the string capitalized
    (with the first character converted into uppercase), otherwise it will shout and
    return the string with all its characters to uppercase, ending with an exclamation
    mark.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数体包含两个主要表达式，第一个是一个带有`println`的副作用，第二个是一个`if`块，它将确定返回值。如果`calm`为`true`，它将礼貌地返回大写字母开头的字符串（第一个字符转换为大写），否则它将大声喊叫并返回所有字符都大写的字符串，并以感叹号结尾。
- en: 'Let''s try and make sure that our function works as intended:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试确保我们的函数按预期工作：
- en: '[PRE61]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we call the function with only the first parameter, it will throw an exception.
    This is because the parameters that we have defined are required:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只使用第一个参数调用函数，它将抛出异常。这是因为我们定义的参数是必需的：
- en: '[PRE62]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: One last thing to end our initial tour of these functions is the `doc-string`
    parameter. When provided to `defn`, it will allow you to add a description of
    your function.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在结束对这些函数的初步浏览之前，我们再来谈谈`doc-string`参数。当提供给`defn`时，它将允许你添加函数的描述。
- en: 'Add documentation to your `square` function by adding a doc-string just before
    the function arguments:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在函数参数之前添加文档字符串来为你的`square`函数添加文档：
- en: '[PRE63]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The doc-string is not only useful when browsing a project's source code – it
    also makes it available to the `doc` function.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文档字符串不仅在使用项目源代码时很有用——它还使`doc`函数能够访问它。
- en: 'Look up the documentation of your `square` function with `doc`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`doc`查找你的`square`函数的文档：
- en: '[PRE64]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It is important to remember that the doc-string needs to come before the function
    arguments. If it comes after, the string will be evaluated sequentially as part
    of the function body and won't throw an error. It is valid syntax, but it will
    not be available in the `doc` helper and other development tools.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要记住，文档字符串需要放在函数参数之前。如果它放在后面，字符串将被逐行评估作为函数体的一部分，而不会抛出错误。这是一个有效的语法，但它将无法在`doc`辅助程序和其他开发工具中使用。
- en: It is good practice to document the arguments with backticks, `` ` ``, like
    we did with `` `x` ``, so that development tools (such as the IDE) can recognize
    them.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用反引号` `` ` ` ``记录参数是一个好习惯，就像我们用` `` `x` ` ``做的那样，这样开发工具（如IDE）就可以识别它们。
- en: We will take a deeper dive into functions in *Chapter 3*, *Functions in Depth*,
    but these few basic principles will get you a long way in terms of writing functions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第3章“深入函数”中更深入地探讨函数，但这几个基本原理将使你在编写函数方面走得很远。
- en: 'Activity 1.02: Predicting the Atmospheric Carbon Dioxide Level'
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.02：预测大气二氧化碳水平
- en: 'Carbon dioxide (CO2) is an important heat-trapping (greenhouse) gas, currently
    rising and threatening life as we know it on our planet. We would like to predict
    future levels of CO2 in the atmosphere based on historical data provided by **National
    Oceanic and Atmospheric Administration** (**NOAA**):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 二氧化碳（CO2）是一种重要的温室气体，目前正在上升，威胁着我们星球上我们所知的生活。我们希望根据**国家海洋和大气管理局**（**NOAA**）提供的历史数据预测大气中未来CO2的水平：
- en: '![Figure 1.2: CO2 parts per million (ppm) over the years'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：过去年份的CO2百万分之一（ppm）]'
- en: '](img/B14502_01_02.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_01_02.jpg)'
- en: 'Figure 1.2: CO2 parts per million (ppm) over the years'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：过去年份的CO2百万分之一（ppm）
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding chart was taken from [https://packt.live/35kUI7L](https://packt.live/35kUI7L)
    and the data was taken from NOAA.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表是从[https://packt.live/35kUI7L](https://packt.live/35kUI7L)获取的，数据来自NOAA。
- en: We will use the year 2006 as a starting point with a CO2 level of 382 ppm and
    calculate the estimate using a simplified (and optimistic) linear function, as follows: *Estimate
    = 382 + ((Year - 2006) * 2)*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以2006年为起点，CO2水平为382 ppm，使用简化的（且乐观的）线性函数来计算估计值，如下所示：*估计值 = 382 + ((年份 - 2006)
    * 2)*。
- en: Create a function called `co2-estimate` that takes one integer parameter called
    `year` and returns the estimated level of CO2 ppm for that year.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`co2-estimate`的函数，它接受一个名为`year`的整数参数，并返回该年份的估计CO2 ppm水平。
- en: 'These steps will help you complete this activity:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成这项活动：
- en: Open your favorite editor and a REPL window next to it.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你最喜欢的编辑器和旁边的REPL窗口。
- en: In your editor, define two constants, `base-co2` and `base-year`, with the values
    382 and 2006, respectively.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中，定义两个常量，`base-co2`和`base-year`，分别赋值为382和2006。
- en: In your editor, write the code to define the `co2-estimate` function without
    forgetting to document it with the doc-string parameter.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中，编写代码来定义`co2-estimate`函数，不要忘记使用doc-string参数对其进行文档化。
- en: You may be tempted to write the function body in a single line but nesting a
    lot of function calls decreases the readability of the code. It is also easier
    to reason about each step of the process by decomposing them in a `let` block.
    Write the body of the function using `let` to define the local binding `year-diff`,
    which is the subtraction of 2006 from the `year` parameter.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会想将函数体写在一行中，但嵌套过多的函数调用会降低代码的可读性。通过在`let`块中分解它们，也更容易推理过程的每一步。使用`let`来定义局部绑定`year-diff`，它是从`year`参数中减去2006的结果，来编写函数体。
- en: Test your function by evaluating `(co2-estimate 2050)`. You should get `470`
    as the result.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过评估`(co2-estimate 2050)`测试你的函数。你应该得到`470`作为结果。
- en: Look up the documentation of your function with `doc` and make sure that it
    has been defined correctly.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`doc`查找你函数的文档，并确保它已被正确定义。
- en: 'The following is the expected output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 679.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第679页找到。
- en: Truthiness, nil, and equality
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实感、空值和相等性
- en: Up until now, we have been using conditional expressions intuitively, possibly
    on the basis of how they usually work with other programming languages. In this
    final section, we will review and explain Boolean expressions and the related
    comparison functions in detail, starting with `nil` and truthiness in Clojure.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在直观地使用条件表达式，可能基于它们在其他编程语言中通常的工作方式。在本节的最后，我们将详细回顾和解释布尔表达式以及相关的比较函数，从Clojure中的`nil`和真值开始。
- en: '`nil` is a value that represents the absence of value. It is also often called
    `NULL` in other programming languages. Representing the absence of value is useful
    because it means that something is missing.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`nil`是一个表示值缺失的值。在其他编程语言中，它也常被称为`NULL`。表示值的缺失是有用的，因为它意味着某些东西缺失了。'
- en: In Clojure, `nil` is "falsey," which means that `nil` behaves like `false` when
    evaluated in a Boolean expression.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，`nil`是“假值”，这意味着在布尔表达式中评估时，`nil`的行为就像`false`。
- en: '`false` and `nil` are the only values that are treated as *falsey* in Clojure;
    everything else is truthy. This simple rule is a blessing (especially if you are
    coming from a language such as JavaScript) and makes our code more readable and
    less error-prone. Perhaps it''s just that Clojure was not out yet when Oscar Wilde
    wrote, "The truth is rarely pure and never simple."'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`和`nil`是Clojure中唯一被视为*假值*的值；其他所有值都是真值。这个简单的规则是一种祝福（尤其是如果你来自像JavaScript这样的语言），它使我们的代码更易于阅读且更少出错。也许这只是因为当奥斯卡·王尔德写下“真理很少是纯粹的，也永远不会简单”时，Clojure还没有出现。'
- en: 'Exercise 1.06: The Truth Is Simple'
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.06：真理很简单
- en: 'In this exercise, we will demonstrate how to work with Boolean values in conditional
    expressions. We will also see how to play around with the logical operators in
    conditional expressions. Let''s get started:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将演示如何在条件表达式中处理布尔值。我们还将看到如何在条件表达式中玩转逻辑运算符。让我们开始吧：
- en: 'Let''s start by verifying that `nil` and `false` are indeed `falsey`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先验证`nil`和`false`确实是*假值*：
- en: '[PRE66]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In other programming languages, it is common for more values to resolve to
    `false` in Boolean expressions. But in Clojure, remember that only `nil` and `false`
    are *falsey*. Let''s try a few examples:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他编程语言中，在布尔表达式中，更多的值解析为`false`是常见的。但在Clojure中，请记住，只有`nil`和`false`是*假值*。让我们尝试几个例子：
- en: '[PRE67]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we want to know whether something is exactly `true` or `false`, and not
    just `truthy` or `falsey`, we can use the `true?` and `false?` functions:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想知道某物是否确实是`true`或`false`，而不仅仅是`真值`或`假值`，我们可以使用`true?`和`false?`函数：
- en: '[PRE68]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `?` character has no special behavior – it is just a naming convention for
    functions that return a Boolean value.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`?`字符没有特殊的行为——它只是为返回布尔值的函数命名的一种约定。'
- en: 'Similarly, if we want to know that something is `nil` and not just `falsey`,
    we can use the `nil?` function:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，如果我们想知道某物是`nil`而不是仅仅是*假值*，我们可以使用`nil?`函数：
- en: '[PRE69]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Remember that `println` returns `nil`, and so the last piece of output in the
    preceding code is `true`.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住`println`返回`nil`，因此前述代码中的最后一行输出是`true`。
- en: Boolean expressions become interesting when they are composed together. Clojure
    provides the usual suspects, that is, `and` and `or`. At this point, we are only
    interested in *logical* `and` and *logical* `or`. If you are looking to play around
    with `bitwise` operators, you can easily find them with the `(find-doc "bit-")`
    command.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当布尔表达式组合在一起时，它们变得有趣。Clojure提供了常用的运算符，即`and`和`or`。在这个阶段，我们只对*逻辑*`and`和*逻辑*`or`感兴趣。如果你想要玩转位运算符，你可以通过`(find-doc
    "bit-")`命令轻松找到它们。
- en: '`and` returns the first *falsey* value that it encounters (from left to right)
    and will not evaluate the rest of the expression when that is the case. When all
    the values passed to `and` are *truthy*, `and` will return the last value.'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`and`返回它遇到的第一个*假值*（从左到右），并且当这种情况发生时，它不会评估表达式的其余部分。当传递给`and`的所有值都是*真值*时，`and`将返回最后一个值。'
- en: 'Experiment with the `and` function by passing a mix of *truthy* and *falsey*
    values to observe the return value that''s been generated:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递*真值*和*假值*的混合值来实验`and`函数，观察生成的返回值：
- en: '[PRE70]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s use `println` and make sure that not all the expressions are evaluated:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`println`并确保不是所有的表达式都被评估：
- en: '[PRE71]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`and` evaluated the first expression, which printed `Hello` and returned `nil`,
    which is *falsey*. Therefore, the second expression was not evaluated, and `Goodbye`
    was not printed.'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`and`评估了第一个表达式，它打印了`Hello`并返回`nil`，这是*假值*。因此，第二个表达式没有被评估，`Goodbye`没有被打印。'
- en: '`or` works in a similar fashion: it will return the first *truthy* value that
    it comes across and it will not evaluate the rest of the expression when that
    is the case. When all the values that are passed to `or` are *falsey*, `or` will
    return the last value.'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`or`的工作方式类似：它会返回遇到的第一个*真值*，并且当这种情况发生时，它不会评估表达式的其余部分。当传递给`or`的所有值都是*假值*时，`or`将返回最后一个值。'
- en: 'Experiment with the `or` function by passing a mix of *truthy* and *falsey*
    values to observe the return value that''s generated:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递*真值*和*假值*的混合值来实验`or`函数，观察生成的返回值：
- en: '[PRE72]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once again, we can use `println` to make sure that the expressions are not
    all evaluated:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`println`来确保表达式没有被全部评估：
- en: '[PRE73]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`or` evaluated the first expression `true` and returned it. Therefore, the
    second expression was not evaluated, and `Hello` was not printed.'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`or`评估了第一个表达式`true`并返回它。因此，第二个表达式没有被评估，`Hello`没有被打印。'
- en: Equality and Comparisons
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等和比较
- en: In most imperative programming languages, the `=` symbol is used for variable
    assignments. As we've seen already, in Clojure, we have `def` and `let` to bind
    names with values. The `=` symbol is a function for equality and will return `true`
    if all its arguments are equal. As you may have guessed by now, the other common
    comparison functions are implemented as functions. `>`, `>=`, `<`, `<=`, and `=`
    are not special syntax and you may have developed the intuition for using them
    already.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数命令式编程语言中，`=` 符号用于变量赋值。正如我们之前看到的，在 Clojure 中，我们有 `def` 和 `let` 来绑定名称和值。`=`
    符号是一个用于相等的函数，如果所有参数都相等，它将返回 `true`。正如你现在可能已经猜到的，其他常见的比较函数也是作为函数实现的。`>`, `>=`,
    `<`, `<=`, 和 `=` 不是特殊语法，你可能已经对这些用法有了直觉。
- en: 'Exercise 1.07: Comparing Values'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.07：比较值
- en: 'In this final exercise, we will go through the different ways of comparing
    values in Clojure. Let''s get started:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的练习中，我们将探讨在 Clojure 中比较值的不同方法。让我们开始吧：
- en: First, start your REPL if it is not running yet.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果你的 REPL 还没有运行，请启动它。
- en: 'Type the following expressions to compare two numbers:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下表达式来比较两个数字：
- en: '[PRE74]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can pass multiple arguments to the `=` operator:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以向 `=` 操作符传递多个参数：
- en: '[PRE75]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In that case, even though the first three arguments are equal, the last one
    isn't, so the `=` function returns `false`.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在那种情况下，即使前三个参数相等，最后一个参数不相等，所以 `=` 函数返回 `false`。
- en: 'The `=` operator is not only used to compare numbers, but other types as well.
    Evaluate some of the following expressions:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`=` 操作符不仅用于比较数字，还用于比较其他类型。评估以下一些表达式：'
- en: '[PRE76]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In Java or other object-oriented programming languages, comparing things usually
    checks whether they are the exact same instance of an object stored in memory,
    that is, their identity. However, comparisons in Clojure are made by equality
    rather than identity. Comparing values is generally more useful, and Clojure makes
    it convenient, but if you ever wanted to compare identities, you could do so by
    using the `identical?` function.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Java 或其他面向对象的编程语言中，比较事物通常检查它们是否是存储在内存中的对象的相同实例，即它们的**身份**。然而，Clojure 中的比较是通过相等性而不是身份来进行的。比较值通常更有用，Clojure
    也使其变得方便，但如果你想要比较身份，你可以通过使用 `identical?` 函数来实现。
- en: 'Maybe more surprisingly, but sequences of different types can be considered
    equal as well:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更令人惊讶的是，不同类型的序列也可以被认为是相等的：
- en: '[PRE77]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The list `1` `2` `3` is equivalent to the vector `1` `2` `3` . Collections and
    sequences are powerful Clojure abstractions that will be presented in *Chapter
    2*, *Data Types and Immutability*.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表 `1` `2` `3` 等价于向量 `1` `2` `3`。集合和序列是 Clojure 的强大抽象，将在**第 2 章**，**数据类型和不可变性**中介绍。
- en: 'It is worth mentioning that the `=` function can also take one argument, in
    which case it will always return `true`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得注意的是，`=` 函数也可以接受一个参数，在这种情况下，它将始终返回 `true`：
- en: '[PRE78]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The other comparison operators, that is, `>`, `>=`, `<`, and `<=`, can only
    be used with numbers. Let's start with `<` and `>`.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他比较运算符，即 `>`, `>=`, `<`, 和 `<=`，只能用于数字。让我们从 `<` 和 `>` 开始。
- en: '`<` returns `true` if all its arguments are in a strictly increasing order.
    Try to evaluate the following expressions:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<` 如果所有参数都是严格递增的，则返回 `true`。尝试评估以下表达式：'
- en: '[PRE79]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Notice that `10` followed by `10` is not strictly increasing.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`10` 后面跟着 `10` 并不是严格递增的。
- en: '`<=` is similar, but adjacent arguments can be equal:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<=` 类似，但相邻参数可以相等：'
- en: '[PRE80]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`>` and `>=` have a similar behavior and return `true` when their arguments
    are in a decreasing order. `>=` allows adjacent arguments to be equal:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`>` 和 `>=` 有类似的行为，当它们的参数按递减顺序排列时返回 `true`。`>=` 允许相邻参数相等：'
- en: '[PRE81]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, the `not` operator is a useful function that returns `true` when its
    argument is *falsey* (`nil` or `false`), and `false` otherwise. Let''s try an
    example:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`not` 操作符是一个有用的函数，当其参数是**假值**（`nil` 或 `false`）时返回 `true`，否则返回 `false`。让我们试一个例子：
- en: '[PRE82]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To put things together, let''s consider the following JavaScript code:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了将这些内容综合起来，让我们考虑以下 JavaScript 代码：
- en: '[PRE83]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This code snippet prints `Valid` when a number, `x`, is included between 1 and
    100 or if `x` is a multiple of 100\. Otherwise, it prints `Invalid`.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码片段当数字 `x` 在 1 到 100 之间或 `x` 是 100 的倍数时打印 `Valid`，否则打印 `Invalid`。
- en: 'If we wanted to translate this to Clojure code, we would write the following:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们要将此转换为 Clojure 代码，我们会写出以下内容：
- en: '[PRE84]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We may have a few more parentheses in the Clojure code, but you could argue
    that Clojure is more readable than the imperative JavaScript code. It contains
    less specific syntax, and we don't need to think about operator precedence.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Clojure代码中可能有一些额外的括号，但你可以争论Clojure比命令式JavaScript代码更易读。它包含更少的特定语法，我们不需要考虑运算符优先级。
- en: 'If we wanted to transform the JavaScript code using an "inline if," we would
    introduce new syntax with `?` and `:`, as follows:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想使用“内联if”转换JavaScript代码，我们会引入带有`?`和`:`的新语法，如下所示：
- en: '[PRE85]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The Clojure code would become the following:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Clojure代码将变成以下样子：
- en: '[PRE86]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Notice that there is no new syntax, and nothing new to learn. You already know
    how to read lists, and that is all you will (almost) ever need.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有新的语法，也没有什么新的东西要学习。你已经知道如何读取列表，而且几乎永远不需要做其他的事情。
- en: 'This simple example demonstrates the great flexibility of `lists`: the building
    blocks of Clojure and other Lisp languages.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了`lists`（列表）的巨大灵活性：Clojure和其他Lisp语言的基本构建块。
- en: 'Activity 1.03: The meditate Function v2.0'
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.03：meditate函数v2.0
- en: 'In this activity, we will improve the `meditate` function we wrote in *Exercise
    1.05*, *Creating Simple Functions with fn and defn*, by replacing the `calm` Boolean
    argument with `calmness-level`. The function will print a transformation of the
    string passed as a second argument based on the calmness level. The specifications
    of the function are as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将通过用`calmness-level`替换`calm`布尔参数来改进我们在*练习1.05*，*使用fn和defn创建简单函数*中编写的`meditate`函数。该函数将根据平静度打印作为第二个参数传递的字符串的转换。函数的规范如下：
- en: '`calmness-level` is a number between `1` and `10`, but we will not check the
    input for errors.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calmness-level`是一个介于`1`和`10`之间的数字，但我们将不会检查输入错误。'
- en: If the calmness level is strictly inferior to `5`, we consider the user to be
    angry. The function should return the `s` string transformed to uppercase concatenated
    with the string "`, I TELL YA!`".
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果平静度严格小于`5`，我们认为用户很生气。函数应该将`s`字符串转换为大写并连接字符串"`, I TELL YA!`"。
- en: If the calmness level is between `5` and `9`, we consider the user to be calm
    and relaxed. The function should return the `s` string with only its first letter
    capitalized.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果平静度在`5`和`9`之间，我们认为用户处于平静和放松的状态。函数应该只将`s`字符串的第一个字母大写后返回。
- en: If the calmness level is `10`, the user has reached nirvana, and is being possessed
    by the Clojure gods. In its trance, the user channels the incomprehensible language
    of those divine entities. The function should return the `s` string in reverse.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果平静度是`10`，用户已经达到了涅槃，被Clojure神灵附体。在它的迷幻状态中，用户传达了那些神圣实体的难以理解的语言。函数应该返回反转的`s`字符串。
- en: Hint
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Use the `str` function to concatenate a string and `clojure.string/reverse`
    to reverse a string. If you are not sure how to use them, you can look up their
    documentation with `doc` (for example, `(doc clojure.string/reverse)`).
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`str`函数连接字符串和`clojure.string/reverse`来反转字符串。如果你不确定如何使用它们，可以使用`doc`（例如，`(doc
    clojure.string/reverse)`）查找它们的文档。
- en: 'These steps will help you complete this activity:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成这个活动：
- en: Open your favorite editor and a REPL window next to it.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你最喜欢的编辑器和旁边的REPL窗口。
- en: In your editor, define a function with the name `meditate`, taking two arguments,
    `calmness-level` and `s`, without forgetting to write its documentation.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中，定义一个名为`meditate`的函数，它接受两个参数`calmness-level`和`s`，不要忘记编写它的文档。
- en: In the function body, start by writing an expression that prints the string,
    `Clojure Meditate v2.0`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数体中，首先编写一个打印字符串`Clojure Meditate v2.0`的表达式。
- en: Following the specification, write the first condition to test whether the calmness
    level is strictly inferior to `5`. Write the first branch of the conditional expression
    (the `then`).
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照规范，编写第一个条件来测试平静度是否严格小于`5`。编写条件表达式的第一个分支（即`then`）。
- en: Write the second condition, which should be nested in the second branch of the
    first condition (the `else`).
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写第二个条件，它应该嵌套在第一个条件的第二个分支（即`else`）中。
- en: Write the third condition, which should be nested in the second branch of the
    second condition. It will check that `calmness-level` is exactly `10` and return
    the reverse of the `s` string when that is the case.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写第三个条件，它应该嵌套在第二个条件的第二个分支中。它将检查`calmness-level`是否正好是`10`，并在这种情况下返回`s`字符串的反转。
- en: 'Test your function by passing a string with different levels of calmness. The
    output should be similar to the following:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递具有不同平静程度的字符串来测试你的函数。输出应该类似于以下内容：
- en: '[PRE87]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If you have been using the `and` operator to find whether a number was between
    two other numbers, rewrite your function to remove it and only use the `<=` operator.
    Remember that `<=` can take more than two arguments.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你一直使用 `and` 操作符来查找一个数字是否介于两个其他数字之间，请将你的函数重写，移除它并仅使用 `<=` 操作符。记住，`<=` 可以接受超过两个参数。
- en: Look up the `cond` operator in the documentation and rewrite your function to
    replace the nested conditions with `cond`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档中查找 `cond` 操作符，并将你的函数重写，用 `cond` 替换嵌套条件。
- en: Note
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 680.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第 680 页找到。
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered how to use the REPL and its helpers. You are
    now able to search and discover new functions and look up their documentation
    interactively in the REPL. We learned how Clojure code is evaluated, as well as
    how to use and create functions, bindings, conditionals, and comparisons. These
    allow you to create simple programs and scripts.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了如何使用 REPL 及其辅助工具。你现在能够搜索和发现新的函数，并在 REPL 中交互式地查找它们的文档。我们学习了 Clojure
    代码是如何评估的，以及如何使用和创建函数、绑定、条件和比较。这些允许你创建简单的程序和脚本。
- en: In the next chapter, we will look at data types, including collections, and
    the concept of immutability.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据类型，包括集合，以及不可变性的概念。
