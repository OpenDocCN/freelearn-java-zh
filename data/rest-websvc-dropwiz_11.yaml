- en: Appendix A. Testing a Dropwizard Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 测试 Dropwizard 应用程序
- en: Our application is ready. However, if we respect its stability, we have to make
    sure that we at least have its most important aspects covered by unit tests. You
    are probably familiar with unit testing and JUnit, but Dropwizard takes this a
    little bit further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经准备好了。然而，如果我们尊重其稳定性，我们必须确保我们至少用单元测试覆盖了其最重要的方面。您可能熟悉单元测试和 JUnit，但 Dropwizard
    在这方面走得更远。
- en: The `dropwizard-testing` module includes everything you need, such as JUnit
    and FEST assertions, in order to create tests for your application, right from
    small unit tests to bigger, full-fledged tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropwizard-testing` 模块包含了您创建应用程序测试所需的一切，例如 JUnit 和 FEST 断言，从小的单元测试到更大的、完整的测试。'
- en: Creating a complete test for the application
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序创建完整的测试
- en: Let's create a complete, fully automated integration test for our application.
    This test should start our application as we would normally do for a manual test,
    and perform some HTTP requests to the application's services which check how the
    application is responding.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的应用程序创建一个完整、完全自动化的集成测试。这个测试应该像手动测试一样启动我们的应用程序，并对应用程序的服务执行一些 HTTP 请求，以检查应用程序的响应。
- en: Getting ready
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'When we first created our project using Maven in [Chapter 2](ch02.html "Chapter 2. Creating
    a Dropwizard Application"), *Creating a Dropwizard Application*, a JUnit dependency
    had been automatically added in our `pom.xml` file. We will replace it with Dropwizard''s
    testing module, so let''s remove it. Locate and delete the following dependency
    from the `pom.xml` file:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次使用 Maven 在[第 2 章](ch02.html "第 2 章。创建 Dropwizard 应用程序")中创建我们的项目时，*创建 Dropwizard
    应用程序*，JUnit 依赖项已自动添加到我们的 `pom.xml` 文件中。我们将用 Dropwizard 的测试模块替换它，所以让我们将其删除。在 `pom.xml`
    文件中定位并删除以下依赖项：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will need the `dropwizard-testing` and `hamcrest-all` modules, so include
    them both in your `pom.xml` file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 `dropwizard-testing` 和 `hamcrest-all` 模块，所以将它们两个都包含在您的 `pom.xml` 文件中：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it…
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Your project already has a test folder. During the generation of the default
    artifact, Maven created both `src/main/java` (where our application''s source
    code lies) and `src/test/java` as a placeholder for our unit tests. Let''s see
    what we need to place there in order to build our tests:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目已经有一个测试文件夹。在生成默认工件期间，Maven 创建了 `src/main/java`（我们的应用程序源代码所在的位置）和 `src/test/java`
    作为单元测试的占位符。让我们看看我们需要放置什么来构建我们的测试：
- en: 'Create a new test class, `ApplicationTest`, within the `src/test/java/com/dwbook/phonebook`
    folder, extending the `ResourceTest` base class. This class needs to have two
    methods; `#setUp()`, in which we will prepare our mocked objects and add the required
    resources and providers to the memory inJersey server, and `#createAndRetrieveContact()`,
    where we will perform the actual test:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/test/java/com/dwbook/phonebook` 文件夹中创建一个新的测试类，`ApplicationTest`，继承自 `ResourceTest`
    基类。这个类需要有两个方法；`#setUp()`，在其中我们将准备我们的模拟对象并添加所需的资源和服务提供者到内存中的 Jersey 服务器，以及 `#createAndRetrieveContact()`，在其中我们将执行实际的测试：
- en: '[PRE2]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our tests will run every time we issue the `mvn` package command, but they
    can also be executed on demand with the `test` command of `mvn`. For now, let''s
    run the test on a clean application environment by issuing the following command:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的测试将在我们发出 `mvn` 打包命令时运行，但它们也可以通过 `mvn` 的 `test` 命令按需执行。现在，让我们通过发出以下命令在干净的应用程序环境中运行测试：
- en: '[PRE3]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will see that Maven will clean our target directory, start the application,
    and then run our tests successfully.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到 Maven 会清理我们的目标目录，启动应用程序，然后成功运行我们的测试。
- en: '![How to do it…](img/9530OS_App.A_01.jpg)'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/9530OS_App.A_01.jpg)'
- en: How it works…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Firstly, we defined our test data; that is, a `Contact` instance that we intend
    to create.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了我们的测试数据；即我们打算创建的 `Contact` 实例。
- en: We initialized a `DropwizardAppRule<PhonebookConfiguration>` instance, which
    is described as a JUnit rule for starting and stopping your application at the
    start and end of a test class, allowing the test framework to start the application
    as you would normally do in order to perform a manual test. For this, we need
    to specify not only the main class of our application, but also the configuration
    file to be used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了一个 `DropwizardAppRule<PhonebookConfiguration>` 实例，该实例被描述为在测试类开始和结束时启动和停止应用程序的
    JUnit 规则，允许测试框架以您通常进行手动测试的方式启动应用程序。为此，我们不仅需要指定我们应用程序的主类，还需要指定要使用的配置文件。
- en: Within the `#setUp()` method, we instantiated a REST client to help us with
    the HTTP requests to our application and also applied the necessary HTTP basic
    authentication filter since our web services require authentication.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#setUp()`方法中，我们实例化了一个REST客户端来帮助我们向应用程序发送HTTP请求，并且由于我们的网络服务需要认证，我们还应用了必要的HTTP基本认证过滤器。
- en: 'The `#createAndRetrieveContact()` method wraps the actual test. Using the REST
    client, we are performing an HTTP POST request in order to create a new contact.
    After such a request, we expect an HTTP response with the `code 201 – Created`
    response. We test whether the response code is the one we expected with the `assertThat()`
    and `isEqual()` helper methods, which are provided by the **Fixtures for Easy
    Software Testing** (**FEST**) libraries. As stated on the home page of the FEST
    project ([http://code.google.com/p/fest/](http://code.google.com/     p/fest/)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`#createAndRetrieveContact()`方法封装了实际的测试。使用REST客户端，我们执行一个HTTP POST请求来创建一个新的联系人。在这样一个请求之后，我们期望得到一个带有`code
    201 – Created`响应的HTTP响应。我们使用由**Fixtures for Easy Software Testing**（**FEST**）库提供的`assertThat()`和`isEqual()`辅助方法来测试响应代码是否是我们期望的。正如FEST项目主页上所述（[http://code.google.com/p/fest/](http://code.google.com/p/fest/))）：'
- en: '"FEST is a collection of libraries, released under the Apache 2.0 license,
    whose mission is to simplify software testing. It is composed of various modules,
    which can be used with TestNG or JUnit."'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"FEST是一组库，在Apache 2.0许可下发布，其使命是简化软件测试。它由各种模块组成，可以与TestNG或JUnit一起使用。"'
- en: There's more…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We just showcased the use of the Dropwizard testing module in order to perform
    an integration test by booting an actual server that is connected to an actual
    database. This module is not limited to integration testing though. It is backed
    by JUnit, and you are able to use it for smaller (but critical) to larger unit
    tests and also for testing the correct serialization/deserialization of entities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示了如何使用Dropwizard测试模块通过启动一个连接到实际数据库的实际服务器来执行集成测试。尽管这个模块不仅限于集成测试。它由JUnit支持，你可以用它来进行较小的（但关键的）到较大的单元测试，也可以用于测试实体的正确序列化和反序列化。
- en: Adding health checks
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加健康检查
- en: A health check is a runtime test for our application. We are going to create
    a health check that tests the creation of new contacts using the Jersey client.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是我们应用程序的运行时测试。我们将创建一个使用Jersey客户端测试创建新联系人的健康检查。
- en: The health check results are accessible through the admin port of our application,
    which by default is 8081.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查结果可以通过我们应用程序的管理端口访问，默认端口为8081。
- en: How to do it…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To add a health check perform the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加健康检查，请执行以下步骤：
- en: 'Create a new package called `com.dwbook.phonebook.health` and a class named
    `NewContactHealthCheck` in it:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`com.dwbook.phonebook.health`的新包，并在其中创建一个名为`NewContactHealthCheck`的类：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Register the health check with the Dropwizard environment by using the `HealthCheckRegistry#register()`
    method within the `#run()` method of the `App` class. You will first need to import
    `com.dwbook.phonebook.health.NewContactHealthCheck`. The `HealthCheckRegistry`
    can be accessed using the `Environment#healthChecks()` method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`App`类的`#run()`方法中使用`HealthCheckRegistry#register()`方法将健康检查注册到Dropwizard环境中。你首先需要导入`com.dwbook.phonebook.health.NewContactHealthCheck`。可以通过`Environment#healthChecks()`方法访问`HealthCheckRegistry`：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After building and starting your application, navigate with your browser to
    `http://localhost:8081/healthcheck`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建并启动你的应用程序后，使用浏览器导航到`http://localhost:8081/healthcheck`：
- en: '![How to do it…](img/9530OS_App.A_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/9530OS_App.A_02.jpg)'
- en: 'The results of the defined health checks are presented in the JSON format.
    In case the custom health check we just created or any other health check fails,
    it will be flagged as `"healthy": false`, letting you know that your application
    faces runtime problems.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '定义的健康检查的结果以JSON格式呈现。如果刚刚创建的自定义健康检查或其他任何健康检查失败，它将被标记为`"healthy": false`，让你知道你的应用程序面临运行时问题。'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We used exactly the same code used by our `client` class in order to create
    a health check; that is, a runtime test that confirms that the new contacts can
    be created by performing HTTP POST requests to the appropriate endpoint of the
    `ContactResource` class. This health check gives us the required confidence that
    our web service is functional.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与我们的`client`类完全相同的代码来创建一个健康检查；也就是说，这是一个运行时测试，通过向`ContactResource`类的适当端点执行HTTP
    POST请求来确认可以创建新的联系人。这个健康检查让我们对我们的网络服务功能有了所需的信心。
- en: All we need for the creation of a health check is a class that extends `HealthCheck`
    and implements the `#check()` method. In the class's constructor, we call the
    parent class's constructor specifying the name of our check—the one that will
    be used to identify our health check.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个健康检查所需的一切就是一个扩展`HealthCheck`类并实现`#check()`方法的类。在类的构造函数中，我们调用父类的构造函数，指定我们的检查名称——即用于识别我们的健康检查的那个名称。
- en: In the `#check()` method, we literally implement a check. We check that everything
    is as it should be. If so, we return `Result.healthy()`, else we return `Result.unhealthy()`,
    indicating that something is going wrong.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#check()`方法中，我们实际上执行了一个检查。我们检查一切是否如预期那样。如果是这样，我们返回`Result.healthy()`，否则我们返回`Result.unhealthy()`，表示有问题发生。
