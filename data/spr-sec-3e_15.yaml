- en: Additional Spring Security Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的 Spring Security 特性
- en: 'In this chapter, we will explore several additional Spring Security features
    that we have not covered so far in this book, including the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨一些到目前为止本书中尚未涵盖的 Spring Security 特性，包括以下主题：
- en: '**Cross-Site Scripting** (**XSS**)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击**（**XSS**）'
- en: '**Cross-Site Request Forgery** (**CSRF**)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）'
- en: Synchronizer tokens
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步器令牌
- en: '**Clickjacking**'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点击劫持**'
- en: 'We will understand how to include various HTTP headers to protect against common
    security vulnerabilities, using the following methods:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何使用以下方法包含各种HTTP头以保护常见安全漏洞：
- en: '`Cache-Control`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cache-Control`'
- en: '`Content-Type Options`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type Options`'
- en: '**HTTP Strict Transport Security** (**HSTS**)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP 严格传输安全**（**HSTS**）'
- en: '`X-Frame-Options`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Frame-Options`'
- en: '`X-XSS-Protection`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-XSS-Protection`'
- en: Before you read this chapter, you should already have an understanding of how
    Spring Security works. This means you should already be able to set up authentication
    and authorization in a simple web application. If you are unable to do this, you
    will want to ensure you have read up to [Chapter 3](03.html), *Custom Authentication*,
    before proceeding with this chapter. If you keep the basic concepts of Spring
    Security in mind and you understand the framework you are integrating with, then
    integrating with other frameworks is fairly straightforward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这一章之前，你应该已经对 Spring Security 的工作原理有了了解。这意味着你应该已经能够在一个简单的web应用程序中设置身份验证和授权。如果你还不能做到这一点，你需要在继续学习这一章之前确保你已经阅读了
    [第3章](03.html)，*自定义身份验证*。如果你牢记Spring Security的基本概念并且理解你正在集成的框架，那么集成其他框架就相对简单了。
- en: Security vulnerabilities
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全漏洞
- en: In the age of the internet, there is a multitude of possible vulnerabilities
    that can be exploited. A great resource to learn more about web-based vulnerabilities
    is **The Open Web Application Security Project** (**OWASP**), which is located
    at [https://www.owasp.org](https://www.owasp.org/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网时代，有很多可能被利用的漏洞。要了解更多关于基于web的漏洞，一个很好的资源是**开放网络应用安全项目**（**OWASP**），它的网址是 [https://www.owasp.org](https://www.owasp.org/).
- en: In addition to being a great resource to understand various vulnerabilities,
    OWASP categorizes the top 10 vulnerabilities based on industry trends.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是一个了解各种漏洞的伟大资源外，OWASP还根据行业趋势对最10个漏洞进行了分类。
- en: Cross-Site Scripting
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: XSS attacks involve malicious scripts that have been injected into a trusted
    site.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击涉及已经被注入到信任网站的恶意脚本。
- en: XSS attacks occur when an attacker exploits a given web application that is
    allowing unventilated input to be sent into the site generally in the form of
    browser-based scripts, which are then executed by a different user of the website.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 攻击发生在一个攻击者利用一个允许未经审查的输入发送到网站的给定web应用程序时，通常以基于浏览器的脚本的形式，然后由网站的不同用户执行。
- en: There are many forms that attackers can exploit, based on validated or unencoded
    information provided to websites.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基于向网站提供验证过的或未编码的信息，攻击者可以利用很多形式。
- en: At the core of this issue is expecting a user to trust the site's information
    that is being sent. The end user's browser has no way to know that the script
    should not be trusted because there has been an implicit trust of the website
    they're browsing. Because it thinks the script came from a trusted source, the
    malicious script can access any cookies, session tokens, or other sensitive information
    retained by the browser and used with that website.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题核心在于期望用户信任网站发送的信息。最终用户的浏览器没有办法知道这个脚本不应该被信任，因为它来自一个它们正在浏览的网站。因为它认为脚本来自一个信任的来源，恶意脚本就可以访问浏览器中保留的与该网站一起使用的任何cookie、会话令牌或其他敏感信息。
- en: 'XSS can be described by the following sequence diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 攻击可以通过以下序列图来描述：
- en: '![](img/da789fd6-805c-4ab2-bcc8-ec95e763c00a.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da789fd6-805c-4ab2-bcc8-ec95e763c00a.png)'
- en: Cross-Site Request Forgery
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: CSRF is an attack that tricks the victim into submitting a malicious request.
    This type of attack inherits or hijacks the identity and privileges of the victim
    and performs unauthorized functions and access on the victim's behalf.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 攻击通过诱骗受害者提交恶意请求来攻击受害者。这种攻击继承或劫持受害者的身份和特权，并在受害者的名义上执行未经授权的功能和访问。
- en: For web applications, most browsers automatically include credentials associated
    with the site, which includes a user session, cookie, IP address, Windows domain
    credentials, and so forth.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络应用程序，大多数浏览器会自动包含与该网站关联的凭据，这包括用户会话、Cookie、IP地址、Windows域凭据等等。
- en: So, if a user is currently authenticated on a site, that given site will have
    no way to distinguish between the forged request sent by the victim and a legitimate
    court request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个用户当前在一个网站上已认证，那么该网站将无法区分由受害者发送的伪造请求和合法的法院请求。
- en: CSRF attacks target functionality that causes a state change on the server,
    such as changing the victim's email address or password, or engaging in a financial
    transaction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF攻击针对的是在服务器上引起状态变化的功能，比如更改受害者的电子邮件地址或密码，或者进行金融交易。
- en: This forces the victim to retrieve data that doesn't benefit an attacker because
    the attacker does not receive the response; the victim does. Thus, CSRF attacks
    target state-changing requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使受害者获取对攻击者不利的数据，因为攻击者不会收到响应；受害者会。因此，CSRF攻击针对的是状态更改请求。
- en: 'The following sequence diagram details how a CSRF attack would occur:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下序列图详细说明了CSRF攻击是如何发生的：
- en: '![](img/c0a2cc8f-d6c0-4d2e-85cc-55c6ee3fcb83.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0a2cc8f-d6c0-4d2e-85cc-55c6ee3fcb83.png)'
- en: There are several different design measures that may be taken to attempt to
    prevent CSRF, however, measures such as secret cookies, HTTP POST requests, multistep
    transactions, URL rewriting, and HTTPS, in no way prevent this type of attack.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试防止CSRF，可以采取几种不同的设计措施，然而，诸如秘密Cookie、HTTP POST请求、多步骤交易、URL重写和HTTPS等措施，绝不可能防止此类攻击。
- en: OWASP's top 10 security vulnerabilities list details CSRF as the eighth most
    common attack at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP的前10大安全漏洞列表详细介绍了CSRF，作为第八常见的攻击，详情请见[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。
- en: Synchronizer tokens
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步器令牌
- en: A solution to this is to use the synchronizer token pattern. This solution is
    to ensure that each request requires, in addition to our session cookie, a randomly
    generated token as an HTTP parameter. When a request is submitted, the server
    must look up the expected value for the parameter and compare it to the actual
    value in the request. If the values do not match, the request should fail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是使用同步器令牌模式。这个解决方案要求每个请求除了我们的会话Cookie外，还需要一个作为HTTP参数的随机生成的令牌。当提交一个请求时，服务器必须查找参数的预期值并将其与请求中的实际值进行比较。如果值不匹配，请求应该失败。
- en: 'The *Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet* recommends the
    synchronizer token pattern as a viable solution for CSRF attacks: [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 《跨站请求伪造（CSRF）预防速查表》建议使用同步器令牌模式作为防止CSRF攻击的可行解决方案：[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)
- en: Relaxing the expectation is to only require the token for each HTTP request
    that updates state. This can be safely done since the same origin policy ensures
    the evil site cannot read the response. Additionally, we do not want to include
    the random token in HTTP `GET`, as this can cause the tokens to be leaked.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 放宽期望值意味着只要求每个更新状态的HTTP请求中包含令牌。由于同源策略可以确保恶意网站无法读取响应，因此这样做是安全的。另外，我们不希望在每个HTTP
    `GET`请求中包含随机令牌，因为这可能导致令牌泄露。
- en: 'Let''s take a look at how our example would change. Assume the randomly generated
    token is present in an HTTP parameter `named _csrf`. For example, the request
    to transfer money would look like as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看例子会如何改变。假设生成的随机令牌以HTTP参数`named _csrf`的形式存在。例如，转账请求如下所示：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will notice that we added the `_csrf` parameter with a random value. Now,
    the malicious website will not be able to guess the correct value for the `_csrf`
    parameter (which must be explicitly provided on the malicious website) and the
    transfer will fail when the server compares the actual token to the expected token.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们添加了带有随机值的`_csrf`参数。现在，恶意网站将无法猜测`_csrf`参数的正确值（必须在恶意网站上显式提供）并且在服务器将实际令牌与预期令牌比较时，传输将会失败。
- en: 'The following diagram shows a standard use case for a synchronizer token pattern:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了同步令牌模式的标准用例：
- en: '![](img/a55eec39-0e93-4503-82d8-af9c17f44ce6.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a55eec39-0e93-4503-82d8-af9c17f44ce6.png)'
- en: Synchronizer token support in Spring Security
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Security中的同步器令牌支持
- en: 'Spring Security provides synchronizer token support that is turned on by default.
    You might have noticed from the previous chapters that in our `SecurityConfig.java`
    file, we have disabled CSRF protection, as shown in the following code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了默认启用的同步器令牌支持。您可能在前几章中注意到，在我们的`SecurityConfig.java`文件中，我们禁用了CSRF保护，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Up to this point in the book, we have disabled synchronizer token protection
    so we could focus on other security concerns.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经禁用了同步器令牌保护，以便我们可以专注于其他安全问题。
- en: If we start the application at this point, we can run through the security and
    there will be no synchronizer token support added to any of the pages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个时候启动应用程序，我们可以走过安全流程，但不会有任何页面的同步器令牌支持被添加。
- en: You should start with the code from `chapter16.00-calendar`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter16.00-calendar`的代码开始。
- en: When to use CSRF protection
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用CSRF保护
- en: It is recommended you use CSRF protection for any request that could be processed
    by a browser or by normal users. If you are only creating a service that is used
    by non-browser clients, you will most likely want to disable CSRF protection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您对任何可以由浏览器或普通用户处理的请求使用CSRF保护。如果您只是创建一个被非浏览器客户端使用的服务，您很可能会想要禁用CSRF保护。
- en: CSRF protection and JSON
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF保护与JSON
- en: 'A common question is: do I need to protect JSON requests made by JavaScript?
    The short answer is, it depends. However, you must be very careful, as there are
    CSRF exploits that can impact JSON requests. For example, a malicious user can
    create a CSRF with JSON using the following form:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是：我需要为JavaScript发出的JSON请求提供保护吗？简短的答案是，视情况而定。然而，您必须非常小心，因为存在可以影响JSON请求的CSRF利用方式。例如，恶意用户可以使用以下表单创建一个CSRF攻击：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If an application were not validating the Content-Type method, then it would
    be exposed to this exploit. Depending on the setup, a Spring MVC application that
    validates the Content-Type method could still be exploited by updating the URL
    suffix to end with `.json`, as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序没有验证Content-Type方法，那么它将受到这种利用的影响。根据设置，一个验证Content-Type方法的Spring MVC应用程序仍然可以通过将URL后缀更新为以`.json`结尾来被利用，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: CSRF and stateless browser applications
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF与无状态浏览器应用程序
- en: What if your application is stateless? That doesn't necessarily mean you are
    protected. In fact, if a user does not need to perform any actions in the web
    browser for a given request, they are likely still vulnerable to CSRF attacks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序是无状态的，那并不意味着您就受到了保护。实际上，如果用户不需要在网页浏览器中为特定请求执行任何操作，他们仍然可能受到CSRF攻击的威胁。
- en: For example, consider an application using a custom cookie that contains all
    of the states within it for authentication instead of the `JSESSIONID` cookie.
    When the CSRF attack happens, the custom cookie will be sent with the request
    in the same manner that the `JSESSIONID` cookie was sent in our previous example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个使用自定义cookie的应用程序，它包含所有认证状态，而不是`JSESSIONID`cookie。当发生CSRF攻击时，自定义cookie将按照我们之前例子中`JSESSIONID`cookie的方式随请求发送。
- en: Users using basic authentication are also vulnerable to CSRF attacks, since
    the browser will automatically include the username and password in any requests,
    in the same manner, that the `JSESSIONID` cookie was sent in our previous example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本认证的用户也容易受到CSRF攻击，因为浏览器将自动在所有请求中包含用户名和密码，就像我们在之前的例子中`JSESSIONID` cookie一样发送。
- en: Using Spring Security CSRF protection
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security CSRF保护
- en: 'So, what are the steps necessary to use Spring Security to protect our site
    against CSRF attacks? The steps for using Spring Security''s CSRF protection are
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用Spring Security保护我们的网站免受CSRF攻击需要哪些步骤呢？使用Spring Security的CSRF保护的步骤如下：
- en: Use proper HTTP verbs.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的HTTP动词。
- en: Configure CSRF protection.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置CSRF保护。
- en: Include the CSRF token.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含CSRF令牌。
- en: Using proper HTTP verbs
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正确的HTTP动词
- en: The first step to protecting against CSRF attacks is to ensure your website
    uses proper HTTP verbs. Specifically, before Spring Security's CSRF support can
    be of use, you need to be certain that your application is using `PATCH`, `POST`,
    `PUT`, and/or `DELETE` for anything that modifies state.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 防止CSRF攻击的第一步是确保你的网站使用正确的HTTP动词。特别是，在Spring Security的CSRF支持可以发挥作用之前，你需要确信你的应用程序正在使用`PATCH`、`POST`、`PUT`和/或`DELETE`来处理任何改变状态的操作。
- en: This is not a limitation of Spring Security's support, but instead a general
    requirement for proper CSRF prevention. The reason is that including private information
    in an HTTP `GET` method can cause the information to be leaked.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是Spring Security支持的限制，而是防止CSRF攻击的一般要求。原因是将私有信息包含在HTTP `GET`方法中可能会导致信息泄露。
- en: Refer to *RFC 2616*, *Section 15.1.3*, *Encoding Sensitive Information in URI's*
    for general guidance on using `POST` instead of `GET` for sensitive information
    ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 参考*RFC 2616*，*第15.1.3节*，*在URI中编码敏感信息*，以了解如何使用`POST`而不是`GET`来处理敏感信息的一般指导原则（[https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3)）。
- en: Configuring CSRF protection
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置CSRF保护
- en: The next step is to include Spring Security's CSRF protection within your application.
    Some frameworks handle invalid CSRF tokens by invaliding the user's session, but
    this causes its own problems. Instead, by default, Spring Security's CSRF protection
    will produce HTTP 403 access denied. This can be customized by configuring `AccessDeniedHandler`
    to process `InvalidCsrfTokenException` differently.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在你的应用程序中包含Spring Security的CSRF保护。一些框架通过使用户会话无效来处理无效的CSRF令牌，但这会带来它自己的问题。相反，默认情况下，Spring
    Security的CSRF保护将产生HTTP 403禁止访问。这可以通过配置`AccessDeniedHandler`以不同的方式处理`InvalidCsrfTokenException`来自定义。
- en: For passivity reasons, if you are using the XML configuration, CSRF protection
    must be explicitly enabled using the `<csrf>` element. Refer to the `<csrf>` element's
    documentation for additional customizations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 出于被动原因，如果你使用XML配置，必须使用`<csrf>`元素显式启用CSRF保护。查阅`<csrf>`元素的文档以获取其他自定义设置。
- en: SEC-2347 is logged to ensure Spring Security 4.x's XML namespace configuration
    will enable CSRF protection by default ([https://github.com/spring-projects/spring-security/issues/2574](https://github.com/spring-projects/spring-security/issues/2574)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SEC-2347被记录下来，以确保Spring Security 4.x的XML命名空间配置将默认启用CSRF保护（[https://github.com/spring-projects/spring-security/issues/2574](https://github.com/spring-projects/spring-security/issues/2574)）。
- en: Default CSRF support
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认的CSRF支持
- en: CSRF protection is enabled by default with Java configuration. Refer to the
    Javadoc of `csrf()` for additional customizations regarding how CSRF protection
    is configured.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java配置时，CSRF保护默认启用。查阅`csrf()`的Javadoc以获取有关如何配置CSRF保护的其他自定义设置。
- en: 'Just to be verbose in this configuration, we are going to add the CSRS method
    to our `SecurityConfig.java` file as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这个配置中详细说明，我们将在`SecurityConfig.java`文件中添加CSRS方法，如下所示：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Including the CSRF token in the <Form> submissions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在<Form>提交中包含CSRF令牌
- en: 'The last step is to ensure that you include the CSRF token in all `PATCH`,
    `POST`, `PUT`, and `DELETE` methods. One way to approach this is to use the `_csrf`
    request attribute to obtain the current `CsrfToken` token. An example of doing
    this with a JSP is shown as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是确保你在所有的`PATCH`、`POST`、`PUT`和`DELETE`方法中包含CSRF令牌。一种实现方法是使用`_csrf`请求属性来获取当前的`CsrfToken`令牌。以下是在JSP中这样做的一个例子：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Including the CSRF token using the Spring Security JSP tag library
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security JSP标签库包含CSRF令牌
- en: If CSRF protection is enabled, this tag inserts a hidden form field with the
    correct name and value for the CSRF protection token. If CSRF protection is not
    enabled, this tag has no output.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了CSRF保护，此标记将插入一个带有正确名称和值的秘密表单字段，以供CSRF保护令牌使用。如果未启用CSRF保护，此标记将不输出任何内容。
- en: Normally, Spring Security automatically inserts a CSRF form field for any `<form:form>`
    tags you use, but if for some reason you cannot use `<form:form>`, `csrfInput`
    is a handy replacement.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Spring Security会自动为任何使用的`<form:form>`标签插入CSRF表单字段，但如果出于某种原因不能使用`<form:form>`，`csrfInput`是一个方便的替代品。
- en: 'You should place this tag within an HTML `<form></form>` block, where you would
    normally place other input fields. Do not place this tag within a Spring `<form:form></form:form>`
    block. Spring Security handles Spring forms automatically as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在HTML `<form></form>`块中放置这个标签，你通常会在其他输入字段中放置其他输入字段。不要在这个标签中放置Spring `<form:form></form:form>`块。Spring
    Security会自动处理Spring表单，如下所示：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Default CSRF token support
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认的CSRF令牌支持
- en: If you are using the Spring MVC `<form:form>` tag, or Thymeleaf 2.1+, and you
    replace `@EnableWebSecurity` with `@EnableWebMvcSecurity`, the `CsrfToken` token
    is automatically included for you (using the `CsrfRequestDataValue` token we have
    been processing).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Spring MVC `<form:form>`标签，或者Thymeleaf 2.1+，并且你用`@EnableWebMvcSecurity`替换`@EnableWebSecurity`，`CsrfToken`令牌会自动包含在内（我们一直在处理`CsrfRequestDataValue`令牌）。
- en: So, for this book, we have been using Thymeleaf for all of our web pages. Thymeleaf
    has CSRF support enabled by default if we enable CSRF support in Spring Security.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这本书中，我们已经使用Thymeleaf为所有的网页页面。如果我们启用Spring Security中的CSRF支持，Thymeleaf默认具有CSRF支持。
- en: You should start with the code from `chapter16.01-calendar`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter16.01-calendar`的代码开始。
- en: 'If we start up the JBCP calendar application and navigate to the login page
    at `https://localhost:8443/login.html`, we can view the generated source for the
    `login.html` page, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动JBCP日历应用程序并导航到登录页面`https://localhost:8443/login.html`，我们可以查看生成的`login.html`页面的源代码，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ajax and JSON requests
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax和JSON请求
- en: 'If you are using JSON, then it is not possible to submit the CSRF token within
    an HTTP parameter. Instead, you can submit the token within a HTTP header. A typical
    pattern would be to include the CSRF token within your `<meta>` HTML tags. An
    example with a JSP is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用JSON，那么不可能在HTTP参数中提交CSRF令牌。相反，你可以在HTTP头中提交令牌。一个典型的模式是将CSRF令牌包括在你的`<meta>`HTML标签中。一个在JSP中的示例如下：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of manually creating the meta tags, you can use the simpler `csrfMetaTags`
    tag from the Spring Security JSP tag library.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: instead of manually creating the meta tags, you can use the simpler `csrfMetaTags`
    tag from the Spring Security JSP tag library.
- en: The csrfMetaTags tag
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`csrfMetaTags`标签'
- en: If CSRF protection is enabled, this tag inserts meta tags containing the CSRF
    protection token form field, header names, and CSRF protection token value. These
    meta tags are useful for employing CSRF protection within JavaScript in your applications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了CSRF保护，这个标签将插入包含CSRF保护令牌表单字段、头部名称和CSRF保护令牌值的元标签。这些元标签对于在应用程序中的JavaScript中使用CSRF保护非常有用。
- en: 'You should place the `csrfMetaTags` tag within an HTML `<head></head>` block,
    where you would normally place other meta tags. Once you use this tag, you can
    access the form field name, header name, and token value easily using JavaScript,
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在HTML `<head></head>`块中放置`csrfMetaTags`标签，你通常会在其他元标签中放置其他元标签。一旦使用这个标签，你可以轻松地使用JavaScript访问表单字段名、头部名称和令牌值，如下所示：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If CSRF protection is not enabled, `csrfMetaTags` outputs nothing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未启用CSRF保护，`csrfMetaTags`不会输出任何内容。
- en: jQuery usage
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery使用
- en: 'You can then include the token within all of your Ajax requests. If you were
    using jQuery, this could be done with the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'You can then include the token within all of your Ajax requests. If you were
    using jQuery, this could be done with the following code snippet:'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the cujoJS's rest.js module
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cujoJS的rest.js模块
- en: 'As an alternative to jQuery, we recommend using the `rest.js` module of cujoJS.
    The `rest.js` module provides advanced support for working with HTTP requests
    and responses in RESTful ways. A core capability is the ability to contextualize
    the HTTP client, adding behavior as needed by chaining interceptors onto the client,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为jQuery的替代品，我们建议使用cujoJS的`rest.js`模块。`rest.js`模块提供了高级支持，用于以RESTful方式处理HTTP请求和响应。其核心功能是能够对HTTP客户端进行上下文化处理，通过将拦截器链接到客户端来添加所需的行为，如下所示：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The configured client can be shared with any component of the application that
    needs to make a request to the CSRF protected resource. One significant difference
    between `rest.js` and jQuery is that the only requests made with the configured
    client will contain the CSRF token, versus in jQuery, where all requests will
    include the token. The ability to determine which requests receive the token helps
    guard against leaking the CSRF token to a third-party.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的客户端可以与应用程序中需要对CSRF受保护资源进行请求的任何组件共享。`rest.js`与jQuery之间的一个重要区别是，仅使用配置的客户端发出的请求将包含CSRF令牌，而在jQuery中，所有请求都将包含令牌。能够确定哪些请求接收到令牌有助于防止泄露CSRF令牌给第三方。
- en: Please refer to the `rest.js` reference documentation for more information on
    `rest.js`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`rest.js`的更多信息，请参考`rest.js`参考文档。
- en: '[(](https://github.com/cujojs/rest/tree/master/docs)[https://github.com/cujojs/rest/tree/master/docs](https://github.com/cujojs/rest/tree/master/docs)[).](https://github.com/cujojs/rest/tree/master/docs)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[(](https://github.com/cujojs/rest/tree/master/docs)[https://github.com/cujojs/rest/tree/master/docs](https://github.com/cujojs/rest/tree/master/docs)[).](https://github.com/cujojs/rest/tree/master/docs)'
- en: CSRF caveats
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF注意事项
- en: There are a few caveats when implementing CSRF in Spring Security that you need
    to be aware of.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security中实现CSRF时，有几个注意事项你需要知道。
- en: Timeouts
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: One issue is that the expected CSRF token is stored in the `HttpSession` method,
    so as soon as the `HttpSession` method expires, your configured `AccessDeniedHandler`
    handler will receive `InvalidCsrfTokenException`. If you are using the default
    `AccessDeniedHandler` handler, the browser will get an HTTP 403 and display a
    poor error message.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是在`HttpSession`方法中存储了预期的CSRF令牌，所以一旦`HttpSession`方法过期，您配置的`AccessDeniedHandler`处理器将会接收到`InvalidCsrfTokenException`。如果您正在使用默认的`AccessDeniedHandler`处理器，浏览器将得到一个HTTP
    403，并显示一个糟糕的错误信息。
- en: You might ask why the expected `CsrfToken` token isn't stored in a cookie. This
    is because there are known exploits in which headers (specifying the cookies)
    can be set by another domain.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么预期的`CsrfToken`令牌不是存储在cookie中。这是因为已知存在一些利用方式，其中头部（指定cookie）可以由另一个域设置。
- en: This is the same reason Ruby on Rails no longer skips CSRF checks when the header
    X-Requested-With is present ([http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/](http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同样的原因，Ruby on Rails不再在存在X-Requested-With头时跳过CSRF检查 ([http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/](http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/)).
- en: The *Web Application Security Consortium* ([http://www.webappsec.org](http://www.webappsec.org/))
    has a detailed thread on using CSRF and an HTTP 307 redirect to perform exploit
    CSRF cookies.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用安全委员会(*Web Application Security Consortium*) ([http://www.webappsec.org](http://www.webappsec.org/))有一个详细的线程，讨论使用CSRF和HTTP
    307重定向来执行CSRF cookie利用。
- en: See this [www.webappsec.org](http://www.webappsec.org/) thread for details on
    how to perform the exploit at [http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html](http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何执行利用的具体细节，请参阅这个[www.webappsec.org](http://www.webappsec.org/)线程：[http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html](http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html)。
- en: Another disadvantage is that by removing the state (the timeout), you lose the
    ability to forcibly terminate the token if something is compromised.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，通过移除状态（超时），您失去了在某些东西被泄露时强制终止令牌的能力。
- en: A simple way to mitigate an active user experiencing a timeout is to have some
    JavaScript that lets the user know their session is about to expire. The user
    can click a button to continue and refresh the session.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 减轻活动用户遇到超时的一种简单方法是有一些JavaScript，让用户知道他们的会话即将过期。用户可以点击一个按钮来继续并刷新会话。
- en: 'Alternatively, specifying a custom `AccessDeniedHandler` handler allows you
    to process `InvalidCsrfTokenException` any way you like, as we can see in the
    following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，指定一个自定义的`AccessDeniedHandler`处理器可以让您以任何喜欢的方式处理`InvalidCsrfTokenException`，正如我们接下来代码中所看到的：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Logging in
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: In order to protect against forged login requests, the login form should be
    protected against CSRF attacks, too. Since the `CsrfToken` token is stored in
    `HttpSession`, this means an `HttpSession` mehthod will be created as soon as
    the `CsrfToken` attribute is accessed. While this sounds bad in a RESTful/stateless
    architecture, the reality is that the state is necessary to implement practical
    security. Without the state, we have nothing we can do if a token is compromised.
    Practically speaking, the CSRF token is quite small in size and should have a
    negligible impact on our architecture.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止伪造登录请求，登录表单也应该受到CSRF攻击的保护。由于`CsrfToken`令牌存储在`HttpSession`中，这意味着一旦访问`CsrfToken`属性，就会立即创建一个`HttpSession`方法。虽然这在RESTful/无状态架构中听起来很糟糕，但现实是状态是实现实际安全所必需的。如果没有状态，如果令牌被泄露，我们无能为力。实际上，CSRF令牌的大小相当小，对架构的影响应该可以忽略不计。
- en: An attacker may forge a request to log the victim into a target website using
    the attacker's credentials; this is known as login CSRF ([https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能会伪造一个请求，使用攻击者的凭据将受害者登录到目标网站，这被称为登录CSRF([https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests))。
- en: Logging out
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出
- en: Adding CSRF will update the `LogoutFilter` filter to only use HTTP `POST`. This
    ensures that logging out requires a CSRF token and that a malicious user cannot
    forcibly log out your users.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 添加CSRF将更新`LogoutFilter`过滤器，使其只使用HTTP`POST`。这确保了登出需要CSRF令牌，并且恶意用户不能强制登出您的用户。
- en: One approach is to use a `<form>` tag for logout. If you want an HTML link,
    you can use JavaScript to have the link perform an HTTP `POST` (which can be in
    a hidden form). For browsers with JavaScript disabled, you can optionally have
    the link take the user to a logout confirmation page that will perform the HTTP
    `POST`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用`<form>`标签进行登出。如果你想要一个HTML链接，你可以使用JavaScript让链接执行HTTP`POST`（可以是一个隐藏的表单）。对于禁用JavaScript的浏览器，你可以选择让链接带用户到执行HTTP`POST`的登出确认页面。
- en: 'If you want to use HTTP `GET` with logout, you can do so, but remember, this
    is generally not recommended. For example, the following Java configuration will
    perform logout when the logout URL pattern is requested with any HTTP method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用HTTP`GET`进行登出，你可以这样做，但请记住，这通常不推荐。例如，以下Java配置将在任何HTTP方法请求登出URL模式时执行登出：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Security HTTP response headers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全HTTP响应头
- en: The following sections discuss Spring Security's support for adding various
    security headers to the response.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分讨论了Spring Security为将各种安全头添加到响应中提供的支持。
- en: Default security headers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认安全头
- en: 'Spring Security allows users to easily inject default security headers to assist
    in protecting their application. The following is a list of the current default
    security headers provided by Spring Security:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security允许用户轻松地注入默认的安全头，以帮助保护他们的应用程序。以下是由Spring Security提供的当前默认安全头的列表：
- en: '`Cache-Control`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cache-Control`'
- en: '`Content-Type Options`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type Options`'
- en: HTTP Strict Transport Security
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP严格传输安全
- en: '`X-Frame-Options`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Frame-Options`'
- en: '`X-XSS-Protection`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-XSS-Protection`'
- en: While each of these headers is considered best practice, it should be noted
    that not all clients utilize these headers, so additional testing is encouraged.
    For passivity reasons, if you are using Spring Security's XML namespace support,
    you must explicitly enable the security headers. All of the default headers can
    be easily added using the `<headers>` element with no child elements.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个头都被认为是最佳实践，但应注意的是，并非所有客户端都使用这些头，因此鼓励进行额外测试。出于被动原因，如果你使用Spring Security的XML命名空间支持，你必须显式启用安全头。所有默认头都可以通过没有子元素的`<headers>`元素轻松添加。
- en: '*SEC-2348* is logged to ensure Spring Security 4.x''s XML namespace configuration
    will enable Security headers by default ([https://github.com/spring-projects/spring-security/issues/2575](https://github.com/spring-projects/spring-security/issues/2575)).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*SEC-2348*被记录下来，以确保Spring Security 4.x的XML命名空间配置将默认启用安全头([https://github.com/spring-projects/spring-security/issues/2575](https://github.com/spring-projects/spring-security/issues/2575))。'
- en: 'If you are using Spring Security''s Java configuration, all of the default
    security headers are added by default. They can be disabled using Java configuration,
    as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Spring Security的Java配置，所有的默认安全头都会被默认添加。它们可以通过Java配置禁用，如下所示：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code adds the security headers to the response. This is activated
    by default when using the default constructor of `WebSecurityConfigurerAdapter`.
    Accepting the default provided by `WebSecurityConfigurerAdapter`, or only invoking
    the `headers()` method without invoking additional methods, is the equivalent
    of the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码将安全头添加到响应中。当使用`WebSecurityConfigurerAdapter`的默认构造函数时，这是默认激活的。接受`WebSecurityConfigurerAdapter`提供的默认值，或者只调用`headers()`方法而不调用其他方法，等效于以下代码片段：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As soon as you specify any headers that should be included, then only those
    headers will be included. For example, the following configuration will include
    support for X-Frame-Options only:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你指定了任何应该包括的头，那么只有这些头会被包括。例如，以下配置仅包括对X-Frame-Options的支持：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Cache-Control
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cache-Control
- en: In the past, Spring Security required you to provide your own `Cache-Control`
    method for your web application. This seemed reasonable at the time, but browser
    caches have evolved to include caches for secure connections as well. This means
    that a user may view an authenticated page, log out, and then a malicious user
    can use the browser history to view the cached page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，Spring Security 要求你必须为你的网络应用程序提供自己的 `Cache-Control` 方法。当时这看起来是合理的，但是浏览器缓存已经发展到包括对安全连接的缓存。这意味着一个用户可能查看一个认证过的页面，登出后，恶意用户就可以利用浏览器历史记录来查看缓存的页面。
- en: 'To help mitigate this, Spring Security has added `Cache-Control` support, which
    will insert the following headers into your response:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助减轻这个问题，Spring Security 增加了对 `Cache-Control` 的支持，它将以下头部信息插入到你的响应中：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Simply adding the `headers()` method with no child elements will automatically
    add `Cache-Control` and quite a few other protection options. However, if you
    only want `Cache-Control`, you can enable this feature using Spring Security''s
    Java Configuration with the `cacheControl()` method, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅添加 `headers()` 方法而没有子元素将会自动添加 `Cache-Control` 和其他很多保护选项。然而，如果你只想要 `Cache-Control`，你可以使用
    Spring Security 的 Java 配置方法，如下所示：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you want to cache specific responses, your application can selectively invoke
    `HttpServletResponse.setHeader(String,String)` to override the header set by Spring
    Security. This is useful to ensure things such as CSS, JavaScript, and images
    are properly cached.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要缓存特定的响应，你的应用程序可以选择性地调用 `HttpServletResponse.setHeader(String,String)` 来覆盖
    Spring Security 设置的头部。这对于确保诸如 CSS、JavaScript 和图片等被正确缓存很有用。
- en: 'When using Spring Web MVC, this is typically done within your configuration.
    For example, the following configuration will ensure that the cache headers are
    set for all of your resources:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Spring Web MVC 时，这通常是在你的配置中完成的。例如，以下配置将确保为你的所有资源设置缓存头部：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Content-Type Options
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Content-Type 选项
- en: Historically, browsers, including Internet Explorer, would try to guess the
    content type of a request using content sniffing. This allowed browsers to improve
    the user experience by guessing the content type of resources that had not specified
    the content type. For example, if a browser encountered a JavaScript file that
    did not have the content type specified, it would be able to guess the content
    type and then execute it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，包括 Internet Explorer 在内的浏览器会尝试使用内容嗅探来猜测请求的内容类型。这允许浏览器通过猜测未指定内容类型的资源的內容类型来改进用户体验。例如，如果浏览器遇到一个没有指定内容类型的
    JavaScript 文件，它将能够猜测内容类型并执行它。
- en: There are many additional things one should do, such as only displaying the
    document in a distinct domain, ensuring the Content-Type header is set, sanitizing
    the document, and so on, when allowing content to be uploaded. However, these
    measures are out of the scope of what Spring Security provides. It is also important
    to point out that when disabling content sniffing, you must specify the content
    type in order for things to work properly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的事情需要做，比如只在一个独特的域中显示文档，确保设置 Content-Type 头部，对文档进行清理等等，当允许内容上传时。然而，这些措施超出了
    Spring Security 提供的范围。重要的是指出，在禁用内容嗅探时，你必须指定内容类型，以便一切正常工作。
- en: The problem with content sniffing is that this allows malicious users to use
    polyglots (a file that is valid as multiple content types) to execute XSS attacks.
    For example, some sites may allow users to submit a valid postscript document
    to a website and view it. A malicious user might create a postscript document
    that is also a valid JavaScript file and execute an XSS attack with it ([http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf](http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 内容嗅探的问题在于，这允许恶意用户使用多语言（一个可以作为多种内容类型有效的文件）来执行 XSS 攻击。例如，一些网站可能允许用户向网站提交一个有效的
    PostScript 文档并查看它。恶意用户可能会创建一个同时是有效的 JavaScript 文件的 PostScript 文档，并利用它执行 XSS 攻击（[http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf](http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf)）。
- en: 'Content sniffing can be disabled by adding the following header to our response:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过向我们的响应中添加以下头部来禁用内容嗅探：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Just as with the `Cache-Control` element, the `nosniff` directive is added
    by default when using the `headers()` method with no child elements. The X-Content-Type-Options
    header is added by default within the Spring Security Java configuration. If you
    want more control over the headers, you can explicitly specify the content type
    options with the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Cache-Control`元素一样，`nosniff`指令在没有子元素的情况下使用`headers()`方法时默认添加。在Spring Security
    Java配置中，`X-Content-Type-Options`头默认添加。如果您想对头部有更精细的控制，您可以显式指定内容类型选项，如下代码所示：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: HTTP Strict Transport Security
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP严格传输安全
- en: When you type in your bank's website, do you enter `mybank.example.com`, or
    do you enter `https://mybank.example.com`? If you omit the HTTPS protocol, you
    are potentially vulnerable to man in the middle attacks. Even if the website performs
    a redirect to `https://**my**bank.example.com`, a malicious user could intercept
    the initial HTTP request and manipulate the response (redirect to `https://**mi**bank.example.com`
    and steal their credentials).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入您的银行网站时，您是输入`mybank.example.com`，还是输入`https://mybank.example.com`？如果您省略了HTTPS协议，您可能会受到中间人攻击的潜在威胁。即使网站执行重定向到`https://**my**bank.example.com`，恶意用户仍然可以拦截最初的HTTP请求并操纵响应（重定向到`https://**mi**bank.example.com`并窃取他们的凭据）。
- en: Many users omit the HTTPS protocol, and this is why HSTS was created.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户省略了HTTPS协议，这就是为什么创建了HSTS。
- en: In accordance with *RFC6797*, the HSTS header is only injected into HTTPS responses.
    In order for the browser to acknowledge the header, the browser must first trust
    the CA that signed the SSL certificate used to make the connection, not just the
    SSL certificate ([https://tools.ietf.org/html/rfc6797](https://tools.ietf.org/html/rfc6797)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*RFC6797*，HSTS头部仅注入到HTTPS响应中。为了使浏览器认可该头部，浏览器必须首先信任签署用于建立连接的SSL证书的CA，而不仅仅是SSL证书（[https://tools.ietf.org/html/rfc6797](https://tools.ietf.org/html/rfc6797)）。
- en: Once `mybank.example.com` is added as an HSTS host, a browser can know beforehand
    that any request to `mybank.example.com` should be interpreted as `https://mybank.example.com`.
    This greatly reduces the possibility of a man in the middle attack occurring.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`mybank.example.com`被添加为HSTS主机，浏览器就可以提前知道任何对`mybank.example.com`的请求都应该被解释为`https://mybank.example.com`。这大大减少了发生中间人攻击的可能性。
- en: 'One way for a site to be marked as an HSTS host is to have the host preloaded
    into the browser. Another is to add the `Strict-Transport-Security` header to
    the response. For example, the following would instruct the browser to treat the
    domain as an HSTS host for a year (there are approximately `31,536,000` seconds
    in a year):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网站被标记为HSTS主机的途径之一是将主机预加载到浏览器中。另一个途径是在响应中添加`Strict-Transport-Security`头部。例如，下面的内容将指导浏览器将域名视为HSTS主机一年（一年大约有`31,536,000`秒）：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The optional `includeSubDomains` directive instructs Spring Security that subdomains
    (such as `secure.mybank.example.com`) should also be treated as an HSTS domain.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`includeSubDomains`指令告知Spring Security，子域名（如`secure.mybank.example.com`）也应该被视为一个HSTS域名。
- en: 'As with the other headers, Spring Security adds the previous header to the
    response when the `headers()` method is specified with no child elements, but
    it is automatically added when you are using Java configuration. You can also
    only use HSTS headers with the `hsts()` method, as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与其它头部一样，当在`headers()`方法中没有子元素指定时，Spring Security将前一个头部添加到响应中，但当你使用Java配置时，它会自动添加。您还可以仅使用HSTS头部与`hsts()`方法一起使用，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: X-Frame-Options
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: X-Frame-Options
- en: Allowing your website to be added to a frame can be a security issue. For example,
    using clever CSS styling, users could be tricked into clicking on something that
    they did not intend to.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您的网站被添加到框架中可能是一个安全问题。例如，通过巧妙的CSS样式，用户可能会被诱骗点击他们本不想点击的东西。
- en: View a Clickjacking video demo here at [https://www.youtube.com/watch?v=3mk0RySeNsU](https://www.youtube.com/watch?v=3mk0RySeNsU).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://www.youtube.com/watch?v=3mk0RySeNsU](https://www.youtube.com/watch?v=3mk0RySeNsU)观看Clickjacking视频演示。
- en: For example, a user that is logged in to their bank might click a button that
    grants access to other users. This sort of attack is known as Clickjacking.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个已登录其银行的用户的可能会点击一个授予其他用户访问权限的按钮。这种攻击称为Clickjacking。
- en: Read more about Clickjacking at [https://www.owasp.org/index.php/Clickjacking](https://www.owasp.org/index.php/Clickjacking).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://www.owasp.org/index.php/Clickjacking](https://www.owasp.org/index.php/Clickjacking)阅读更多关于Clickjacking的信息。
- en: Another modern approach to dealing with Clickjacking is using a content security
    policy. Spring Security does not provide support for this as the specification
    has not been released, and it is quite a bit more complicated. However, you could
    use the static headers feature to implement this. To stay up to date on this issue
    and to see how you can implement it with Spring Security, refer to *SEC-2117*
    at [https://github.com/spring-projects/spring-security/issues/2342](https://github.com/spring-projects/spring-security/issues/2342).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Clickjacking的另一种现代方法是使用内容安全策略。Spring Security不提供对此的支持，因为该规范尚未发布，而且相当复杂。然而，你可以使用静态头功能来实现这一点。要了解此问题的最新动态以及如何使用Spring
    Security实现它，请参阅*SEC-2117*在[https://github.com/spring-projects/spring-security/issues/2342](https://github.com/spring-projects/spring-security/issues/2342)。
- en: There are a number of ways to mitigate Clickjacking attacks. For example, to
    protect legacy browsers from Clickjacking attacks, you can use frame-breaking
    code. While not perfect, a frame-breaking code is the best you can do for legacy
    browsers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以缓解Clickjacking攻击。例如，为了保护老式浏览器不受Clickjacking攻击，你可以使用破帧代码。虽然不是完美的，但破帧代码对于老式浏览器来说是最好的做法。
- en: 'A more modern approach to address Clickjacking is to use the X-Frame-Options
    header, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 解决Clickjacking的更现代方法是使用`X-Frame-Options`头，如下所示：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `X-Frame-Options` response header instructs the browser to prevent any
    site with this header in the response from being rendered within a frame. As with
    the other response headers, this is automatically included when the `headers()`
    method is specified with no child elements. You can also explicitly specify the
    frame-options element to control which headers are added to the response, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-Frame-Options`响应头指示浏览器防止任何在响应中包含此头的站点被渲染在框架内。与其他响应头一样，当没有子元素的`headers()`方法被指定时，此头会自动包含。你还可以明确指定frame-options元素以控制要添加到响应中的哪些头，如下所示：'
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you want to change the value for the X-Frame-Options header, then you can
    use a `XFrameOptionsHeaderWriter instance`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改`X-Frame-Options`头的值，那么你可以使用一个`XFrameOptionsHeaderWriter`实例。
- en: Some browsers have built-in support for filtering out reflected XSS attacks.
    This is by no means foolproof, but it does assist with XSS protection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器内置了对过滤掉反射型XSS攻击的支持。这绝不是万无一失的，但它确实有助于XSS保护。
- en: 'Filtering is typically enabled by default, so adding the header just ensures
    it is enabled and instructs the browser as to what to do when an XSS attack is
    detected. For example, the filter might try to change the content in the least
    invasive way to still render everything. At times, this type of replacement can
    become an XSS vulnerability in itself. Instead, it is best to block the content,
    rather than attempt to fix it. To do this, we can add the following header:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤通常默认启用，因此添加头 just 确保它已启用，并指示浏览器在检测到XSS攻击时应该做什么。例如，过滤器可能会尝试以最不具侵入性的方式更改内容以仍然呈现一切。有时，这种类型的替换本身可能成为一个XSS漏洞。相反，最好阻止内容，而不是尝试修复它。为此，我们可以添加以下头：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This header is included by default when the `headers()` method is specified
    with no child elements. We can explicitly state it using the `xssProtection` element,
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`headers()`方法且没有子元素时，默认包含此标题。我们可以使用`xssProtection`元素明确地声明，如下所示：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Custom Headers
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义头
- en: Spring Security has mechanisms to make it convenient to add more common security
    headers to your application. However, it also provides hooks to enable the adding
    of custom headers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security具有机制，使其方便地向你的应用程序添加更多常见的 security headers。然而，它还提供了挂载点，以启用添加自定义头。
- en: Static headers
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态头
- en: 'There may be times you wish to inject custom security headers into your application
    that are not supported out of the box. For example, perhaps you wish to have early
    support for a content security policy in order to ensure that resources are only
    loaded from the same origin. Since support for a content security policy has not
    been finalized, browsers use one of two common extension headers to implement
    the feature. This means we will need to inject the policy twice. An example of
    the headers can be seen in the following code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望向你的应用程序中注入自定义的安全头，但这些头并不是开箱即用的。例如，也许你希望提前支持内容安全策略，以确保资源只从同一来源加载。由于内容安全策略的支持尚未最终确定，浏览器使用两个常见的扩展头之一来实现此功能。这意味着我们将需要注入策略两次。以下代码段显示了头部的示例：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When using Java configuration, these headers can be added to the response using
    the `header()` method, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Java配置时，这些头可以使用`header()`方法添加到响应中，如下所示：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The HeadersWriter instance
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`HeadersWriter`实例'
- en: When the namespace or Java configuration does not support the headers you want,
    you can create a custom `HeadersWriter` instance or even provide a custom implementation
    of `HeadersWriter`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当命名空间或Java配置不支持您想要的头时，您可以创建一个自定义`HeadersWriter`实例，甚至提供`HeadersWriter`的自定义实现。
- en: 'Let''s take a look at an example of using a custom instance of `XFrameOptionsHeaderWriter`.
    Perhaps you want to allow the framing of content for the same origin. This is
    easily supported by setting the policy attribute to `SAMEORIGIN`, but let''s take
    a look at a more explicit example using the `ref` attribute, as shown in the following
    code snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用自定义实例`XFrameOptionsHeaderWriter`的例子。也许你想允许相同源的内容框架。这可以通过将策略属性设置为`SAMEORIGIN`轻松支持，但让我们来看一个更明确的例子，使用`ref`属性，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The DelegatingRequestMatcherHeaderWriter class
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`DelegatingRequestMatcherHeaderWriter`类'
- en: 'At times, you may want to only write a header for certain requests. For example,
    perhaps you want to only protect your login page from being framed. You could
    use the `DelegatingRequestMatcherHeaderWriter` class to do so. When using Java
    configuration, this can be done with the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能只想为某些请求写入头。例如，也许您只想保护登录页面不被框架。您可以使用`DelegatingRequestMatcherHeaderWriter`类来实现。当使用Java配置时，可以用以下代码完成：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered several security vulnerabilities, as well employing
    Spring Security to circumvent those vulnerabilities. After reading this chapter,
    you should understand the threat of CSRF and use of the synchronizer tokens to
    prevent CSRF.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了几种安全漏洞，并使用了Spring Security来规避这些漏洞。阅读本章后，你应该理解CSRF的威胁以及使用同步令牌来预防CSRF。
- en: You should also know how to include various HTTP headers to protect against
    common security vulnerabilities using the `Cache-Control`, `Content-Type Options`,
    HSTS, `X-Frame-Options`, and `X-XSS-Protection` methods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该知道如何使用`Cache-Control`、`Content-Type Options`、HSTS、`X-Frame-Options`和`X-XSS-Protection`方法，将各种HTTP头包含在内，以保护免受常见安全漏洞的侵害。
- en: In the next chapter, we will discuss how to migrate from Spring Security 3.x
    to Spring Security 4.2.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何从Spring Security 3.x迁移到Spring Security 4.2。
