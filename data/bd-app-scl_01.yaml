- en: Chapter 1. Introduction to FP, Reactive, and Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。FP、响应式和Scala简介
- en: 'In our first chapter, we will learn the basic concepts of **Functional Programing**
    (**FP**), reactive programming, and the Scala language. These concepts are listed
    as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一章中，我们将学习函数式编程（**FP**）、响应式编程和Scala语言的基本概念。这些概念如下所示：
- en: Setting up a Scala development environment with Eclipse Scala IDE.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse Scala IDE设置Scala开发环境。
- en: Basic constructs of the language like var, val, for, if, switch, and operator
    overload.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言的基本结构，如var、val、for、if、switch和操作符重载。
- en: The difference between FP and object-oriented programming.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程与面向对象编程之间的区别。
- en: 'Principles of pure FP: immutability, no side effects, state discipline, composition,
    and higher order functions.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数式编程（FP）的原则：不可变性、无副作用、状态纪律、组合和高级函数。
- en: Concepts of FP such as lambda, recursion, for comprehensions, partial functions,
    Monads, currying, and functions.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP的概念，如lambda、递归、for推导、部分函数、Monads、柯里化和函数。
- en: Pattern Matcher, recursion, reflection, package objects, and concurrency.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配、递归、反射、包对象和并发。
- en: Let's get going!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Functional programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'FP is not new at all. The very first implementation of FP is Lisp and is dated
    from the 1950s. Currently, we are living in a post-functional programming era,
    where we have the strong math principles and ideas from the 50s mixed with the
    most modern and beautiful piece of engineering, also know as the **Java Virtual
    Machine** (**JVM**). Scala is a post-functional programming language built on
    top of the JVM. Being on top of the JVM gives us a lot of benefits such as the
    following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: FP根本不新。FP的第一个实现是Lisp，始于20世纪50年代。目前，我们正处于一个后函数式编程时代，那时我们拥有50年代强大的数学原理和思想，与现代最美丽和先进的工程技术相结合，也称为**Java虚拟机**（**JVM**）。Scala是一种基于JVM的后函数式编程语言。位于JVM之上为我们带来了许多好处，如下所示：
- en: 'Scala is a post-functional programming language built on top of the JVM. Being
    on top of the JVM gives us a lot of benefits such as the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种基于JVM的函数式编程语言。位于JVM之上为我们带来了许多好处，如下所示：
- en: '**Reliability and performance**: Java is used by 10 out of 10 top websites
    we have currently, like Netflix, Apple, Uber, Twitter, Yahoo, eBay, Yelp, LinkedIn,
    Google, Amazon, and many others. JVM is the best solution at scale and is battle-tested
    by these web-scale companies.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性和性能**：Java被我们目前排名前10的网站中的10个使用，如Netflix、Apple、Uber、Twitter、Yahoo、eBay、Yelp、LinkedIn、Google、Amazon等。JVM是规模化的最佳解决方案，并且已经由这些网站规模公司进行了实战测试。'
- en: '**Native JVM eco-system**: Full access to all of the Java ecosystem including
    frameworks, libraries, servers, and tools.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生JVM生态系统**：完全访问包括框架、库、服务器和工具在内的所有Java生态系统。'
- en: '**Operations leverage**: Your operation team can run Scala in the same way
    they run Java.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作利用**：您的操作团队可以像运行Java一样运行Scala。'
- en: '**Legacy code leverage**: Scala allows you to easily integrate Scala code with
    Java code. This feature is great because it enables Java legacy system integration
    inside the box.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗留代码利用**：Scala允许您轻松地将Scala代码与Java代码集成。这个特性非常棒，因为它使得Java遗留系统集成变得容易。'
- en: '**Java interoperability**: A code written in Scala can be accessed in Java.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java互操作性**：用Scala编写的代码可以在Java中访问。'
- en: Scala was created in 2001 at EPFL by Martin Odersky. Scala is a strong static-typed
    language, and was inspired by another functional language called **Haskell**.
    Scala addresses several criticisms of the Java language, and delivers a better
    developer experience through less code and more concise programs, without losing
    performance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是由Martin Odersky于2001年在EPFL创建的。Scala是一种强静态类型语言，并受到了另一种名为**Haskell**的函数式语言的启发。Scala解决了Java语言的几个批评，并通过更少的代码和更简洁的程序，在不损失性能的情况下提供了更好的开发者体验。
- en: Scala and Java share the same infrastructure as the JVM, but in terms of design,
    Scala is a different language in comparison with Java. Java is an imperative object-oriented
    language and Scala is a post-functional, multiparadigm programing language. FP
    works with different principles than **object-oriented programing** (**OOP**).
    OOP got very popular and well established in enterprise thanks to languages like
    Java, C#, Ruby, and Python. However, languages like Scala, Clojure, F#, and Swift
    are gaining a huge momentum, and FP has grown a lot in the last 10 years. Most
    of the new languages are pure functional, post-functional, or hybrid (like Java
    8). In this book, you will see Scala code compared with Java code so you can see
    by yourself how Scala is way more compact, objective, and direct than Java and
    imperative OOP languages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 和 Java 与 JVM 具有相同的底层结构，但在设计上，Scala 与 Java 相比是不同的语言。Java 是一种命令式面向对象的语言，而
    Scala 是一种后函数式、多范式的编程语言。FP 与 **面向对象编程**（**OOP**）的工作原理不同。OOP 由于 Java、C#、Ruby 和 Python
    等语言而变得非常流行和稳固。然而，Scala、Clojure、F# 和 Swift 等语言正在获得巨大的动力，FP 在过去 10 年中得到了很大的发展。大多数新的语言都是纯函数式、后函数式或混合（如
    Java 8）。在这本书中，你将看到 Scala 代码与 Java 代码的比较，这样你可以亲自看到 Scala 相比 Java 和命令式 OOP 语言要紧凑、客观和直接得多。
- en: FP started at academia and spread to the world; FP is everywhere. Big Data and
    Stream processing solutions like Hadoop and Spark (built on top of Scala and Akka)
    are built on top of FP ideas and principles. FP spread to UI with **RxJavaScript **-
    you can even find FP in a database with Datomic (Clojure). Languages like Clojure
    and Scala made FP more practical and attractive to enterprise and professional
    developers. In this book, we will be exploring both principles and practical aspects
    of the Scala language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: FP 从学术界开始，传播到全世界；FP 到处都是。像 Hadoop 和 Spark 这样的大数据和流处理解决方案（建立在 Scala 和 Akka 之上）都是建立在
    FP 思想和原则之上的。FP 传播到 UI，有了 **RxJavaScript** - 你甚至可以在 Datomic（Clojure）数据库中找到 FP。像
    Clojure 和 Scala 这样的语言使 FP 对企业和专业开发者更加实用和有吸引力。在这本书中，我们将探讨 Scala 语言的原理和实践方面。
- en: Principles of functional programming
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程原理
- en: FP is a way of thinking, a specific style of constructing and building programs.
    Having an FP language helps a lot in terms of syntax, but at the end of the day,
    it's all about ideas and developer mindset. FP favors disciplined state management
    and immutability in a declarative programming way rather than the imperative programming
    mostly used by OOP languages such as Java, Python, and Ruby.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: FP 是一种思考方式，一种构建和构建程序的具体风格。拥有 FP 语言在语法方面有很大帮助，但最终，一切都关于思想和开发者心态。FP 倾向于以声明式编程方式管理纪律状态和不可变性，而不是像
    Java、Python 和 Ruby 这样的 OOP 语言主要使用的命令式编程。
- en: FP has roots in math back to **Lambda calculus **- a formal system developed
    in the 1930s. Lambda calculus is a mathematical abstraction and not a programming
    language, but it is easy to see its concepts in programming languages nowadays.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: FP 的根源可以追溯到数学中的 **Lambda 演算** - 20 世纪 30 年代开发的一种形式系统。Lambda 演算是一种数学抽象，不是编程语言，但如今在编程语言中很容易看到其概念。
- en: Imperative programming uses statements to change the program state. In other
    words, this means you give commands to the program to perform actions. This way
    of thinking describes a sequence of steps on how the program needs to operate.
    What you need to keep in mind is the kind of style focus on how FP works in a
    different way, focusing on what the program should accomplish without telling
    the program how to do it. When you are coding in FP, you tend to use fewer variables,
    for loops, and IFS, and write more functions and make function composition.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程使用语句来改变程序状态。换句话说，这意味着你向程序下达命令以执行操作。这种方式描述了程序需要操作的步骤序列。你需要记住的是，FP 的工作方式关注于程序应该完成什么，而不是告诉程序如何去做。当你用
    FP 编码时，你倾向于使用更少的变量、循环和条件语句，并编写更多的函数和函数组合。
- en: 'The following are the CORE principles of FP:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 FP 的核心原理：
- en: Immutability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Disciplined state
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纪律状态
- en: Pure functions and no side effects/disciplined states
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数和无副作用/纪律状态
- en: First class functions and high order functions
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首类函数和高阶函数
- en: Type systems
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统
- en: Referential transparency
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性
- en: Let's understand these principles in detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解这些原理。
- en: Immutability
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: The concept of immutability is the CORE of FP, and it means that once you assign
    a value to something, that value won't change. This is very important, because
    it eliminates side effects (anything outside of the local function scope), for
    instance, changing other variables outside the function. Immutability makes it
    easier to read code, because you know the function that you are using is a pure
    function. Since your function has a disciplined state and does not change other
    variables outside of the function, you don't need to look at the code outside
    the function definition. This sounds like you're not working with state at all,
    so how would it be possible to write professional applications this way? Well,
    you will change state but in a very disciplined way. You will create another instance
    or another pointer to that instance, but you won't change that variable's value.
    Having immutability is the key to having better, faster, and more correct programs,
    because you don't need to use locks and your code is parallel by nature.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性概念是FP的核心，这意味着一旦你给某个东西赋值，该值就不会改变。这非常重要，因为它消除了副作用（任何在局部函数作用域之外的东西），例如，在函数外部更改其他变量。不可变性使得代码更容易阅读，因为你知道你正在使用的函数是一个纯函数。由于你的函数具有规范的状态且不更改函数外部的其他变量，因此你不需要查看函数定义外的代码。这听起来像你根本不处理状态，那么你怎么可能以这种方式编写专业应用程序呢？好吧，你会改变状态，但以一种非常规范的方式。你会创建另一个实例或指向该实例的另一个指针，但你不会改变该变量的值。拥有不可变性是拥有更好、更快、更正确程序的关键，因为你不需要使用锁，而且你的代码天生就是并行的。
- en: Disciplined state
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范的状态
- en: 'Shared mutable state is evil, because it is much harder to scale and to run
    it concurrently. What is shared mutable state? A simple way to see it is as a
    global variable that all your functions have access to. Why is this bad? First
    of all, because it is hard to keep this state correct since there are many functions
    that have direct access to this state. Second, if you are performing refactoring,
    this kind of code is often the hardest to refactor as well. It''s also hard to
    read this code. This is because you can never trust the local method, since your
    local method is just one part of the program. And with mutable state, you need
    to look up for all the functions that use that variable, in order to understand
    the logic. It''s hard to debug for the very same reason. When you are coding with
    FP principles in mind, you avoid, as much as possible, having a shared mutable
    state. Of course you can have state, but you should keep it local, which means
    inside your function. This is the state discipline: you use state, but in a very
    disciplined way. This is simple, but it could be hard especially if you are a
    professional developer, because this aspect is now usual to see in enterprise
    languages such as Java, .NET, Ruby, and Python.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 共享可变状态是邪恶的，因为它很难扩展和并发运行。什么是共享可变状态？一个简单的方式来理解它就是将其视为一个所有函数都可以访问的全局变量。为什么这很糟糕？首先，因为很难保持这个状态正确，因为有许多函数可以直接访问这个状态。其次，如果你正在进行重构，这种代码通常也是最难重构的。阅读这种代码也很困难。这是因为你永远不能信任局部方法，因为你的局部方法只是程序的一部分。并且带有可变状态，你需要查找所有使用该变量的函数，以便理解逻辑。调试也是如此困难。当你带着FP原则进行编码时，你应尽可能避免共享可变状态。当然，你可以有状态，但你应该将其保持为局部状态，这意味着在函数内部。这就是状态纪律：你使用状态，但以一种非常规范的方式。这很简单，但如果你是一名专业开发者，这可能很难，因为这种方面现在在Java、.NET、Ruby和Python等企业语言中很常见。
- en: Pure functions and no side effects
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数和无副作用
- en: Pure functions are the ones with no side effects. Side effects are bad, because
    they are unpredictable and make your software hard to test. Let's say you have
    a method that receives no parameters and returns nothing--this is one of the worst
    things we could have, because how do you test it? How can you reuse this code?
    This is not what we call a pure function. What are the possible side effects?
    Database call, global variables, IO call, and so on. This makes sense, but you
    cannot have a program with just pure functions, because it won't be practical.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是没有副作用的函数。副作用很糟糕，因为它们是不可预测的，并使你的软件难以测试。假设你有一个没有参数接收且不返回任何内容的方法——这是我们可能遇到的最糟糕的事情之一，因为你怎么测试它？你怎么重用这段代码？这并不是我们所说的纯函数。可能有哪些副作用？数据库调用、全局变量、IO调用等等。这很有道理，但你不能只使用纯函数，因为这样不实用。
- en: First-class functions and higher-order functions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一等函数和高级函数
- en: First-class means that the language treats functions as first-class citizens.
    In other words, it means having language support to pass functions as arguments
    to other functions and to return values as functions. First-class function also
    implies that the language allows you to store functions as variables or any other
    data structure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首类意味着语言将函数视为一等公民。换句话说，这意味着语言支持将函数作为参数传递给其他函数，并将值作为函数返回。首类函数还意味着语言允许你将函数存储为变量或任何其他数据结构。
- en: Higher-order functions are related to First-class functions, but they are not
    the same thing. Higher-order functions often means language support for partial
    functional application and Currying. Higher-order functions are a mathematical
    concept where functions operate with other functions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数与首类函数相关，但它们不是同一回事。高阶函数通常意味着语言支持部分函数应用和柯里化。高阶函数是一个数学概念，其中函数与其他函数一起操作。
- en: Partial functions are when you can fix a value (argument) to a particular function,
    which you may or may not change later on. This is great for function composition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数是指你可以将一个值（参数）固定到特定的函数上，你以后可能改变也可能不改变。这对于函数组合来说很棒。
- en: Currying is a technique to transform a function with multiple parameters in
    a sequence of functions with each function having a single argument. Scala language
    does not force currying, however, languages like ML and Haskell almost always
    use this kind of technique.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是一种将具有多个参数的函数转换为一系列函数的技术，每个函数只有一个参数。Scala语言并不强制使用柯里化，然而，像ML和Haskell这样的语言几乎总是使用这种技术。
- en: Type systems
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型系统
- en: 'Type system is all about the compiler. The idea is simple: you create a type
    system, and by doing so, you leverage the compiler to avoid all kinds of mistakes
    and errors. This is because the compiler helps in making sure that you only have
    the right types as arguments, turn statements, function composition, and so on.
    The compiler will not allow you do make any basic mistakes. Scala and Haskell
    are examples of languages that are Strong-type. Meanwhile, Common Lisp, Scheme,
    and Clojure are dynamic languages that may accept wrong values during compilation
    time. One of the biggest benefits of the strong type system is that you have to
    write fewer tests, because the compiler will take care of several issues for you.
    For instance, if you have a function that receives a string, it could be dangerous,
    because you can pass pretty much anything in a string. However, if you have a
    function that receives a type called salesman, then you don''t write a validation
    to check if it is a salesman. All this may sound silly, but in a real application,
    this saves lots of lines of code and makes you program better. Another great benefit
    of strong typing is that you have better documentation, as your code becomes your
    documentation, and it''s way more clear what you can or can''t do.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统完全关乎编译器。其理念很简单：你创建一个类型系统，通过这样做，你可以利用编译器来避免各种错误和错误。这是因为编译器有助于确保你只有正确的类型作为参数、转换语句、函数组合等等。编译器不会允许你犯任何基本错误。Scala和Haskell是强类型语言的例子。与此同时，Common
    Lisp、Scheme和Clojure是动态语言，它们可能在编译时接受错误值。强类型系统最大的好处之一是你必须编写的测试更少，因为编译器会为你处理几个问题。例如，如果你有一个接收字符串的函数，这可能很危险，因为你可以几乎在字符串中传递任何东西。然而，如果你有一个接收名为salesman类型的函数，那么你不需要编写验证来检查它是否是salesman。所有这些可能听起来很愚蠢，但在实际应用中，这可以节省大量的代码并使你的程序编写得更好。强类型的另一个巨大好处是，你将拥有更好的文档，因为你的代码成为你的文档，而且可以更清楚地了解你可以或不能做什么。
- en: Referential transparency
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指称透明性
- en: Referential transparency is a concept which works close with pure functions
    and immutability since your program has fewer assignment statements, and often
    when you have it, you tend to never change that value. This is great because you
    eliminate side effects with this technique. During program execution, any variable
    can be replaced since there are no side effects, and the program becomes referentially
    transparent. Scala language makes this concept very clear the moment you declare
    a variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 指称透明性是一个与纯函数和不可变性紧密相关的概念，因为你的程序有较少的赋值语句，并且当你有它时，你往往永远不会改变那个值。这很好，因为你可以用这种技术消除副作用。在程序执行期间，由于没有副作用，任何变量都可以被替换，程序变得指称透明。Scala语言在声明变量时使这个概念非常清晰。
- en: Installing Java 8 and Scala 2.11
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Java 8和Scala 2.11
- en: Scala requires JVM to work, so we need get the JDK 8 before installing Scala.
    Go to the Oracle website, and download and install JDK 8 from [http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html](http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 需要 JVM 才能运行，因此我们在安装 Scala 之前需要获取 JDK 8。访问 Oracle 网站，并从 [http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html](http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html)
    下载并安装 JDK 8。
- en: 'Once you''ve downloaded Java, we need to add Java to the `PATH` variable; otherwise,
    you can use the terminal. We do this as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 Java 后，我们需要将 Java 添加到 `PATH` 变量中；否则，你可以使用终端。我们这样做如下：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next step is to create the environment variable called `JAVA_HOME`, and
    to put the Java 8 binaries in the `PATH` variable. In Linux, we need to edit the
    `~/.bashrc` file, and export the variables we need, like in the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个名为 `JAVA_HOME` 的环境变量，并将 Java 8 二进制文件放入 `PATH` 变量中。在 Linux 中，我们需要编辑 `~/.bashrc`
    文件，并导出所需的变量，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the file, and then on the same terminal we need to source the file via
    `$ source ~/.bashrc`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，在同一终端中，我们需要通过 `$ source ~/.bashrc` 命令来源文件。
- en: 'Now we can test our Java 8 installation. Just type in `$ java -version`. You
    should see something like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们的 Java 8 安装。只需输入 `$ java -version`。你应该会看到如下类似的内容：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's get started. We will be using the latest Scala version 2.11.8\. However,
    the code inside this book should work with any Scala 2.11.x version. First of
    all, let's download Scala from [http://www.scala-lang.org/](http://www.scala-lang.org/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们将使用最新的 Scala 版本 2.11.8。然而，这本书中的代码应该与任何 Scala 2.11.x 版本兼容。首先，让我们从 [http://www.scala-lang.org/](http://www.scala-lang.org/)
    下载 Scala。
- en: Scala works on Windows, Mac, and Linux. For this book, I will show how to use
    Scala on Ubuntu Linux(Debian-based). Open your browser and go to [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 在 Windows、Mac 和 Linux 上都能运行。对于这本书，我将展示如何在基于 Debian 的 Ubuntu Linux 上使用
    Scala。打开你的浏览器并访问 [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/)。
- en: 'Download `scala 2.11.8`: it will be a TGZ file. Extract it and add it to your
    path; otherwise, you can use the terminal. Do this as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 `scala 2.11.8`：它将是一个 TGZ 文件。解压它并将其添加到你的路径中；否则，你可以使用终端。这样做如下：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next step is to create the environment variable called `SCALA_HOME`, and
    to put the Scala binaries in the `PATH` variable. In Linux, we need to edit the
    `~/.bashrc` file and export the variables we need, like in the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个名为 `SCALA_HOME` 的环境变量，并将 Scala 二进制文件放入 `PATH` 变量中。在 Linux 中，我们需要编辑 `~/.bashrc`
    文件并导出所需的变量，如下所示：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save the file, and then, on the same terminal, we need to source the file via
    `$ source ~/.bashrc`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，在同一终端中，我们需要通过 `$ source ~/.bashrc` 命令来源文件。
- en: 'Now we can test our Scala installation. Just type in `$ scala -version`. You
    should see something like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们的 Scala 安装。只需输入 `$ scala -version`。你应该会看到如下类似的内容：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You have successfully installed Java 8 and Scala 2.11\. Now we are ready to
    start learning the FP principles in Scala. For this, we will be using the Scala
    REPL in the beginning. Scala REPL is bundled with the default Scala installation,
    and you just need to type `$ scala` in your terminal as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功安装了 Java 8 和 Scala 2.11。现在我们准备好开始学习 Scala 中的 FP 原则了。为此，我们将在开始时使用 Scala
    REPL。Scala REPL 是默认 Scala 安装的一部分，你只需在终端中输入 `$ scala`，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Congratulations! You have installed Java 8 and Scala 2.11 successfully.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功安装了 Java 8 和 Scala 2.11。
- en: Read Eval Print and Loop - REPL
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取、评估、打印和循环 - REPL
- en: '**Read Eval Print and Loop** (**REPL**) is also know as a language shell. Many
    other languages have shells, like Lisp, Python, and Ruby for instance. The REPL
    is a simple environment to experiment the language in. It''s possible to write
    very complex programs using REPL, but this is not the REPL goal. Using REPL does
    not invalidate the usage of an IDE like Eclipse or IntelliJ IDEA. REPL is ideal
    for testing simple commands and programs without having to spend much time configuring
    projects like you do with an IDE. The Scala REPL allows you to create a variable,
    functions, classes, and complex functions as well. There is a history of every
    command you perform; there is some level of autocomplete too. As a REPL user,
    you can print variable values and call functions.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取评估打印循环**（**REPL**）也被称为语言外壳。许多其他语言都有外壳，例如 Lisp、Python 和 Ruby 等。REPL 是一个简单的环境，可以用来实验语言。使用
    REPL 可以编写非常复杂的程序，但这不是 REPL 的目标。使用 REPL 并不影响像 Eclipse 或 IntelliJ IDEA 这样的 IDE 的使用。REPL
    是测试简单命令和程序的理想选择，无需像使用 IDE 那样花费大量时间配置项目。Scala REPL 允许你创建变量、函数、类以及复杂的函数。每个命令都有一个历史记录；也有一定程度的自动完成。作为一个
    REPL 用户，你可以打印变量值并调用函数。'
- en: Scala Hello World using the REPL
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REPL 的 Scala Hello World
- en: 'Let''s get started. Go ahead, open your terminal, and type `$ scala` in order
    to open the Scala REPL. Once the REPL is open, you can just type `"Hello World"`.
    By doing this, you perform two operations: eval and print. The Scala REPL will
    create a variable called `res0`, and store your String there. Then it will print
    the content of the `res0` variable.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。打开你的终端，输入 `$ scala` 以打开 Scala REPL。一旦 REPL 打开，你只需输入 `"Hello World"`。通过这样做，你执行了两个操作：评估和打印。Scala
    REPL 将创建一个名为 `res0` 的变量，并将你的字符串存储在那里。然后它将打印 `res0` 变量的内容。
- en: Scala REPL Hello World program
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL Hello World 程序
- en: 'We will see how to create Hello World program in Scala REPL as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在 Scala REPL 中创建 Hello World 程序，如下所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Scala is a hybrid language, which means it is object-oriented and functional
    as well. You can create classes and objects in Scala. Next we will create a complete
    Hello World application using classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是一种混合语言，这意味着它既是面向对象的，也是函数式的。你可以在 Scala 中创建类和对象。接下来我们将使用类创建一个完整的 Hello
    World 应用程序。
- en: Scala object-oriented HelloWorld program
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 面向对象的 Hello World 程序
- en: 'We will see how to create object-oriented HelloWorld program in Scala REPL
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在 Scala REPL 中创建面向对象的 Hello World 程序，如下所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing you need to realize is that we use the word object instead of
    class. The Scala language has different constructs compared to Java. Object is
    a singleton in Scala. It's the same as coding the singleton pattern in Java.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先你需要意识到，我们使用的是 object 而不是 class。与 Java 相比，Scala 语言有不同的结构。在 Scala 中，Object 是一个单例。这与在
    Java 中编写单例模式相同。
- en: 'Next we see the word `def` that is used in Scala to create functions. In the
    preceding program, we create the main function similar to the way we do it in
    Java, and we call the built-in function `println` in order to print the String
    Hello World. Scala imports some Java objects and packages by default. Coding in
    Scala does not require you to type, for instance, `System.out.println("Hello World")`,
    but you can if you want. Let''s take a look at it in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看到 Scala 中用于创建函数的 `def` 关键字。在前面的程序中，我们创建了一个类似于 Java 中创建的方式的 main 函数，并调用内置函数
    `println` 来打印字符串 Hello World。Scala 默认导入了一些 Java 对象和包。在 Scala 中编码不需要你输入，例如，`System.out.println("Hello
    World")`，但如果你愿意，你也可以这样做。让我们在下面的代码中看看它：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can and we will do better. Scala has some abstractions for a console application,
    so we can write this code with a lesser number of lines of code. To accomplish
    this goal, we need to extend the Scala class App. When we extend from App, we
    perform inheritance and we don't need to define the main function. We can just
    put all the code in the body of the class, which is very convenient and makes
    the code clean and simple to read.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以，我们也将做得更好。Scala 为控制台应用程序提供了一些抽象，因此我们可以用更少的代码行数来编写这个代码。为了实现这个目标，我们需要扩展 Scala
    类 App。当我们从 App 继承时，我们执行了继承，我们不需要定义 main 函数。我们只需将所有代码放入类的主体中，这非常方便，使得代码整洁且易于阅读。
- en: Scala HelloWorld App in the Scala REPL
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的 Scala HelloWorld App
- en: 'We will see how to create Scala HelloWorld App in Scala REPL as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在 Scala REPL 中创建 Scala HelloWorld App，如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After coding the HelloWorld object in the Scala REPL we can ask the REPL what
    HelloWorld is, and as you might realize, the REPL will answer that HelloWorld
    is an object. This is a very convenient Scala way to code console applications,
    because we can have a Hello World application with just three lines of code. Sadly,
    to have the same program in Java, it required way more code. Java is a great language
    for performance, but it is a verbose language compared with Scala, for instance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala REPL中编码了HelloWorld对象之后，我们可以询问REPL HelloWorld是什么，正如你可能意识到的，REPL会回答HelloWorld是一个对象。这是Scala编写控制台应用程序的一种非常方便的方法，因为我们只需三行代码就可以有一个Hello
    World应用程序。遗憾的是，要在Java中实现相同的程序，需要更多的代码。Java是一种性能出色的语言，但与Scala相比，它是一种冗长的语言。
- en: Java HelloWorld application
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java HelloWorld应用程序
- en: 'We will see how to create Java HelloWorld application as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何创建Java HelloWorld应用程序如下：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Java app required six lines of code, while in Scala, we were able to do
    the same with 50% less code (three lines of code). This is a very simple application.
    When we are coding complex applications, this difference gets bigger, as a Scala
    application ends up with way less code than Java.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序需要六行代码，而在Scala中，我们能够用50%的代码（三行代码）完成同样的工作。这是一个非常简单的应用程序。当我们编写复杂的应用程序时，这种差异会更大，因为Scala应用程序的代码量远少于Java。
- en: 'Remember, we use an object in Scala in order to have a Singleton (Design Pattern
    that makes sure you have just one instance of a class), and if we want the same
    in Java, the code would be something like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在Scala中使用对象是为了有一个单例（确保只有一个类实例的设计模式），如果我们想在Java中实现相同的功能，代码可能如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's not just about the size of the code, but also about consistency and the
    language providing more abstractions for you. If you write less code, you will
    have fewer bugs in your software at the end of the day.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅关乎代码的大小，还关乎一致性和语言为你提供更多的抽象。如果你编写的代码更少，最终你的软件中出现的错误也会更少。
- en: Scala language - the basics
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala语言 - 基础知识
- en: Scala is a statically typed language with a very expressive type system which
    enforces abstractions in a safe yet coherent manner. All values in Scala are Java
    objects (primitives which are unboxed at runtime), because at the end of the day,
    Scala runs on the Java JVM. Scala enforces immutability as a core FP principle.
    This enforcement happens in multiple aspects of the Scala language, for instance,
    when you create a variable, you do it in an immutable way, when you use an collection,
    you will use a immutable collection. Scala also lets you use mutable variables
    and mutable structures, but by design, it favors immutable ones.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种静态类型语言，具有非常表达性的类型系统，以安全且连贯的方式强制执行抽象。Scala中的所有值都是Java对象（在运行时未装箱的原生类型），因为最终，Scala是在Java
    JVM上运行的。Scala强制执行不可变性作为核心的FP原则。这种强制执行在Scala语言的多个方面发生，例如，当你创建一个变量时，你以不可变的方式创建它，当你使用集合时，你会使用不可变集合。Scala还允许你使用可变变量和可变结构，但按照设计，它更倾向于不可变结构。
- en: Scala variables - var and val
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala变量 - var和val
- en: When you are coding in Scala, you create variables using the operator `var`,
    or you can use the operator `val`. The operator `var` allows you to create a mutable
    state, which is fine as long as you make it local, follow the CORE-FP principles
    and avoid a mutable shared state.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Scala中编码时，你使用运算符`var`创建变量，或者你可以使用运算符`val`。`var`运算符允许你创建可变状态，只要你将其本地化，遵循CORE-FP原则，并避免可变共享状态，这是可以的。
- en: Scala REPL var usage
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的var使用
- en: 'We will see how to use var in Scala REPL as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用var如下：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, Scala has a more interesting construct called `val`. Using the `val`
    operator makes your variables immutable, and this means you can't change the value
    once you've set it. If you try to change the value of the `val` variable in Scala,
    the compiler will give you an error. As a Scala developer, you should use the
    variable `val` as much as possible, because that's a good FP mindset, and it will
    make your programs better. In Scala, everything is an object; there are no primitives
    -- the `var` and `val` rules apply for everything it could but an `Int` or `String`
    or even a class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Scala有一个更有趣的结构叫做`val`。使用`val`运算符使你的变量不可变，这意味着一旦设置了值，就不能更改它。如果你尝试更改Scala中`val`变量的值，编译器会给你一个错误。作为一个Scala开发者，你应该尽可能多地使用`val`变量，因为这是一种良好的FP思维模式，并且会使你的程序更好。在Scala中，一切都是对象；没有原生类型
    -- `var`和`val`规则适用于所有可能的对象，除了`Int`或`String`甚至是一个类。
- en: Scala val usage at the Scala REPL
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala在Scala REPL中的val使用
- en: 'We will see how to use val in Scala REPL as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用`val`，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating immutable variables
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建不可变变量
- en: Right now, let's see how we define the most common types in Scala such as `Int`,
    `Double`, `Boolean`, and `String`. Remember, you can create these variables using
    `val` or `var` depending on your needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Scala中定义最常见的数据类型，如`Int`、`Double`、`Boolean`和`String`。记住，你可以根据需要使用`val`或`var`创建这些变量。
- en: Scala variable type in the Scala REPL
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的Scala变量类型
- en: 'We will see Scala variable type in Scala REPL as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中查看Scala变量类型，如下所示：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the variables in the preceding code, we did not define the type. Scala language
    figures it out for us. However, it is possible to specify the type if you want.
    In Scala, the type comes after the name of the variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们没有定义变量的类型。Scala语言会为我们解决这个问题。然而，如果你想指定类型，也是可能的。在Scala中，类型位于变量名称之后。
- en: Scala variables with explicit typing at the Scala REPL
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的具有显式类型的Scala变量
- en: 'We will see Scala variables with explicit typing at Scala REPL as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Scala REPL中看到具有显式类型的Scala变量，如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Scala conditional and loops statements
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala的条件和循环语句
- en: Like any other language, Scala has support for conditional statements like `if`
    and `else`. While Java has a switch statement, Scala has a more powerful and functional
    structure called Pattern Matcher, which we will cover later in this chapter. Scala
    allows you to use `if` statements during variable assignments, which is very practical
    as well as useful.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他语言一样，Scala支持`if`和`else`这样的条件语句。虽然Java有`switch`语句，但Scala有一个更强大且功能性的结构，称为模式匹配器（Pattern
    Matcher），我们将在本章后面介绍。Scala允许你在变量赋值时使用`if`语句，这既实用又有用。
- en: If statements in Scala REPL
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Scala REPL中的if语句
- en: 'We will see how to use `if` statements in Scala REPL as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用`if`语句，如下所示：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, you can see that we set the variable `y` based on an
    `if` condition. Scala `if` conditions are very powerful, and they also can be
    used in return statements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到我们根据`if`条件设置了变量`y`。Scala的`if`条件非常强大，并且也可以用于返回语句。
- en: If statements in return statements in Scala REPL
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Scala REPL中的返回语句中的if语句
- en: 'We will see how to use `if` statements in return statements in Scala REPL as
    follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中的返回语句中使用`if`语句，如下所示：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Scala supports `else` statements too, and you also can use them in variables
    and return statements as wellas follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Scala也支持`else`语句，你还可以在变量和返回语句中使用它们，如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now you will learn how to use for loops in Scala. For loops are very powerful
    in Scala. We will start with the basics and later we will move on to functional
    loops used for comprehensions, also know as `List` comprehensions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将学习如何在Scala中使用for循环。在Scala中，for循环非常强大。我们将从基础知识开始，稍后我们将继续介绍用于列表推导的函数式循环，也称为`List`推导。
- en: In Scala, for loops work with ranges, which is another Scala data structure
    that represents numbers from a starting point to an end point. The range is created
    using the left arrow operator(`<-`). Scala allows you to have multiple ranges
    in the same for loop as long as you use the semicolon(`;`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，for循环与范围（range）一起工作，范围是Scala的另一种数据结构，表示从起点到终点的数字。范围是通过左箭头运算符（`<-`）创建的。只要你在同一个for循环中使用分号（`;`），Scala就允许你在同一个for循环中有多个范围。
- en: You also can use `if` statements in order to filter data inside for loops, and
    work smoothly with `List` structures. Scala allows you to create variables inside
    a for loop as well. Right now, let's see some code which illustrates the various
    for loop usages in Scala language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在for循环中使用`if`语句来过滤数据，并顺畅地与`List`结构一起工作。Scala允许你在for循环中创建变量。现在，让我们看看一些代码，这些代码展示了Scala语言中各种for循环的使用。
- en: Basic for loop in Scala REPL
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的基本for循环
- en: 'We will see how to use basic for loop in Scala REPL as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用基本for循环，如下所示：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Right now, we will create a for loop using a Scala data structure called `List`.
    This is very useful, because in the first line of code, you can define a `List`
    as well as set its values in the same line. Since we are using the `List` structure,
    you don't need to pass any other argument besides the `List` itself.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用名为`List`的Scala数据结构创建一个for循环。这非常有用，因为在代码的第一行，你可以定义一个`List`以及设置其值。由于我们使用的是`List`结构，因此除了`List`本身之外，你不需要传递任何其他参数。
- en: For with List in Scala REPL
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Scala REPL中使用带有List的for循环
- en: 'We will see how to `use` for with `List` in Scala REPL as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Scala REPL中使用`for`与`List`，如下所示：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we can use for loops with `if` statements in order to apply some filtering.
    Later in this book, we will approach a more functional way to approach filtering
    using functions. For this code, let's say we want to get just the even numbers
    on the list and print them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用带有 `if` 语句的 for 循环来实现一些过滤操作。在本书的后续部分，我们将探讨使用函数的更函数式的方法来处理过滤。对于这段代码，假设我们只想获取列表中的偶数并打印它们。
- en: For with if statements for filtering - Scala REPL
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的带有 if 语句的 for 推导式 - Scala REPL
- en: 'We will see how to use `for` with `if` statements in Scala REPL as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何在 Scala REPL 中使用 `for` 与 `if` 语句，如下所示：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Java code for filtering even numbers
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 代码过滤偶数
- en: 'In Scala language, we just need two lines of code to perform this filtering,
    whereas in Java it would have required at least eleven lines of code as you see
    in the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 语言中，我们只需要两行代码就可以完成这个过滤操作，而在 Java 中，这至少需要十一行代码，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For comprehensions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于推导式
- en: 'Also known as list or sequence comprehensions, for comprehensions are one of
    the FP ways to perform loops. This is a language support to create `List` structure
    or collections based on other collections. This task is performed in a `SetBuilder`
    notation. Another way to accomplish the same goal would be by using the `Map`
    and `filter` functions, which we will cover later in this chapter. For comprehensions
    can be used in a generator form, which would introduce new variables and values,
    or in a reductionist way, which would filter values resulting into a new collection
    or sequence. The syntax is: `for (expt) yield e`, where the `yield` operator will
    add new values to a new collection/sequence that will be created from the original
    sequence.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为列表或序列推导式，for 推导式是函数式编程中执行循环的一种方式。这是语言支持，用于根据其他集合创建 `List` 结构或集合。这项任务在 `SetBuilder`
    语法中执行。另一种实现相同目标的方法是使用 `Map` 和 `filter` 函数，我们将在本章后面介绍。for 推导式可以用生成器形式使用，这将引入新的变量和值，或者以归约方式使用，这将过滤值，生成一个新的集合或序列。语法是：`for
    (expt) yield e`，其中 `yield` 操作符将新值添加到从原始序列创建的新集合/序列中。
- en: For comprehension in Scala REPL
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的推导式
- en: 'We will see how to use `for` comprehension in Scala REPL as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何在 Scala REPL 中使用 `for` 推导式，如下所示：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we create a set of names. As you can see, Scala, by default,
    prefers immutable data structures and uses `immutable.Set`. When we apply the
    `for` loop, we are simply filtering only the `names` which contain a specific
    substring, and then, using the `yield` operator, we are creating a new `Set` structure.
    The `yield` operator will keep the structure you are using. For instance, if we
    use `List` structure, it would create a `List` instead of a `Set structure`, the
    `yield` operator will always keep the same data collection you have on the variable.
    Another interesting aspect of the preceding code is the fact that we are holding
    the result of the `for` comprehension in a variable called Brazilians. Java does
    not have `for` comprehensions, but we could use similar code although it would
    require way more lines of code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名字的集合。正如你所见，Scala 默认偏好不可变数据结构，并使用 `immutable.Set`。当我们应用 `for`
    循环时，我们只是在过滤包含特定子字符串的 `names`，然后，使用 `yield` 操作符，我们创建了一个新的 `Set` 结构。`yield` 操作符将保持你正在使用的结构。例如，如果我们使用
    `List` 结构，它将创建一个 `List` 而不是 `Set` 结构，`yield` 操作符将始终保持变量上的相同数据集合。前面代码的另一个有趣之处在于，我们将
    `for` 推导式的结果保存在一个名为 Brazilians 的变量中。Java 没有for 推导式，但我们可以使用类似的代码，尽管这将需要更多的行数。
- en: Java code for performing filtering with collections
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合进行过滤的 Java 代码
- en: 'We will see how to use Java code for performing filtering with collections as
    follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用 Java 代码进行集合过滤，如下所示：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Scala collections
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 集合
- en: 'In the previous section, we saw how to create the `List` and `Set` structures
    in Scala in an immutable way. Now we will learn to work with the `List` and `Set`
    structures in a mutable way, and also with other collections such as sequences,
    tuples, and Maps. Let''s take a look at the Scala collections hierarchy tree,
    as shown in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何在 Scala 中以不可变的方式创建 `List` 和 `Set` 结构。现在我们将学习如何以可变的方式处理 `List` 和
    `Set` 结构，以及其他集合，如序列、元组和 Maps。让我们看看 Scala 集合层次结构的树状图，如下面的图所示：
- en: '![Scala collections](img/image00231.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Scala 集合](img/image00231.jpeg)'
- en: Now let's take a look at the Scala Seq class hierarchy. As you can see, Seq
    is traversable as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 Scala 的 Seq 类层次结构。正如你所见，Seq 也是可遍历的。
- en: '![Scala collections](img/image00232.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Scala 集合](img/image00232.jpeg)'
- en: Scala collections extend from traversable, which is the main trait of all collection's
    descends. `List` structures, for instance, extend from Seq class hierarchy, which
    means sequence - `List` is a kind of sequence. All these trees are immutable or
    mutable depending on the Scala package you end up using.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 集合扩展自可遍历，这是所有集合派生的主要特质。例如，`List` 结构扩展自 `Seq` 类层次结构，这意味着序列 - `List` 是一种序列。所有这些树都是不可变或可变的，具体取决于您最终使用的
    Scala 包。
- en: 'Let''s see how to perform basic mutable operations with `List` structures in
    Scala. In order to have filter and removal operations, we need use a `Buffer` sequence as
    follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Scala 中使用 `List` 结构执行基本可变操作。为了进行过滤和删除操作，我们需要使用以下 `Buffer` 序列：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's see the next set of code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一组代码。
- en: Creating, removing, and getting an item from a mutable list in Scala REPL
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Scala REPL 中创建、删除和获取可变列表中的项
- en: 'We will see how to create, remove, and get an item from a mutable list in Scala
    REPL as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在 Scala REPL 中创建、删除和获取可变列表中的项如下：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Have you ever wanted to return multiple values in a method? Well, in Java you
    have to create a class, but in Scala, there is a more convenient way to perform
    this task, and you won't need to create new classes each time. Tuples allow you
    to return or simply hold multiple values in methods without having to create a
    specific type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾想在方法中返回多个值？嗯，在 Java 中您必须创建一个类，但在 Scala 中，有一个更方便的方式来执行此任务，而且您不需要每次都创建新类。元组允许您在方法中返回或简单地持有多个值，而无需创建特定类型。
- en: Scala tuples
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 元组
- en: 'We will see Scala tuples as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到 Scala 元组如下：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Scala has special methods called `_1` and `_2` which you can use to retrieve
    a tuple's values. The only thing you have to keep in mind is the fact that values
    are kept in the order of insertion in the tuple.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 有特殊的方法称为 `_1` 和 `_2`，您可以使用它们来检索元组的值。您需要记住的唯一一点是值在元组中按照插入顺序存储。
- en: Scala has a very practical and useful collection library. A Map, for instance,
    is a key/value pair that can be retrieved based on the key, which is unique. However,
    Map values do not need to be unique. Like other Scala collections, you have mutable
    and immutable Map collections. Keep in mind that Scala favors immutable collections
    over mutable ones.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 拥有一个非常实用且有用的集合库。例如，Map 是一个键/值对，可以根据键检索，键是唯一的。然而，Map 的值不需要是唯一的。像其他 Scala
    集合一样，您有可变和不可变 Map 集合。请记住，Scala 更倾向于不可变集合而不是可变集合。
- en: Scala immutable Map in Scala REPL
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的 Scala 不变 Map
- en: 'We will see Scala immutable Map in Scala REPL as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Scala REPL 中看到 Scala 不变 Map 的用法如下：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, Scala uses `scala.collection.immutable.Map` when you create
    a Map using `Map()`. Both keys and values are iterable, and you can have access
    to all the keys with the `keys` method or to all the values using the `values`
    method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当您使用 `Map()` 创建 Map 时，Scala 使用 `scala.collection.immutable.Map`。键和值都是可迭代的，您可以使用
    `keys` 方法访问所有键，或使用 `values` 方法访问所有值。
- en: Scala mutable Maps at Scala REPL
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的 Scala 可变 Maps
- en: 'We will see Scala mutable Map in Scala REPL as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Scala REPL 中看到 Scala 可变 Map 的用法如下：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you are dealing with mutable state, you have to be explicit and this is great
    in Scala, because it increases developers' awareness and avoids mutable shared
    state by default. So, in order to have a mutable Map, we need to explicitly create
    the Map with `scala.collection.mutable.HashMap`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理可变状态，您必须明确指定，这在 Scala 中是很好的，因为它增加了开发者的意识，并默认避免了可变共享状态。因此，为了有一个可变 Map，我们需要明确使用
    `scala.collection.mutable.HashMap` 创建 Map。
- en: Monads
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摩纳哥
- en: Monads are combinable parametrized container types which have support for higher-order
    functions. Remember higher-order functions are functions which receive functions
    as parameters and return functions as results. One of the most used functions
    in FP is Map. Map takes a function, applies it to each element in the container,
    and returns a new container.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 摩纳哥是可组合的参数化容器类型，它支持高阶函数。记住，高阶函数是接收函数作为参数并返回函数作为结果的函数。在函数式编程中最常用的函数之一是 Map。Map
    接收一个函数，将其应用于容器中的每个元素，并返回一个新的容器。
- en: Scala Map function in Scala REPL
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的 Scala Map 函数
- en: 'We will see Map function in Scala REPL as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Scala REPL 中看到 Map 函数的用法如下：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we created a list of numbers containing 1,2,3,4,5, and
    6\. We also defined a Scala function called `doubleIt`, which receives an integer
    and multiplies it by `2.0` resulting in a double number. The `map` function calls
    `doubleIt` for each element in the `List (1,2,3,4,5,6)`, and the result is a new
    container, a brand new `List` instance containing the new values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个包含数字1,2,3,4,5和6的数字列表。我们还定义了一个名为`doubleIt`的Scala函数，它接收一个整数并将其乘以`2.0`，得到一个双精度浮点数。`map`函数对`List
    (1,2,3,4,5,6)`中的每个元素调用`doubleIt`，结果是新的容器，一个新的`List`实例，包含新的值。
- en: Scala has some syntactical sugar which helps us to be more productive. For instance,
    you may realize that in the previous code, we also did - `2.0 * _`. The underscore
    is a special operator for this specific case -- it means the current value is
    being iterated into the collection. Scala will create a function from this expression
    for us.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Scala有一些语法糖可以帮助我们更高效。例如，你可能会意识到在之前的代码中，我们也做了`2.0 * _`。下划线是一个特殊操作符，用于这个特定情况——它表示当前值正在被迭代到集合中。Scala会为我们从这个表达式创建一个函数。
- en: 'As you might have realized, `map` functions are pretty useful for lots of reasons:
    one reason is that you can do complex computations without using the `for` loop
    explicitly, and this makes your code functional. Secondly, we can use a `map`
    function to convert element types from one type to another. That''s what we did
    in the previous code: we transformed a list of integers into a list of doubles. Look
    at the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经意识到的，`map`函数有很多用途：一个原因是你可以不显式使用`for`循环来做复杂的计算，这使得你的代码更函数式。其次，我们可以使用`map`函数将元素类型从一种类型转换为另一种类型。这就是我们在之前的代码中所做的：我们将整数列表转换为双精度浮点数列表。看看下面的：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `map` function operates over several data structures and not only collections,
    as you can see in the previous code. You can use the `map` function on pretty
    much everything in Scala language.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数在多个数据结构上操作，而不仅仅是集合，正如你在之前的代码中看到的。你几乎可以在Scala语言中的任何地方使用`map`函数。'
- en: The `map` function is great, but you can end up with nested structures. That's
    why, when we are working with Monads, we use a slightly different version of the
    `map` function called `flatMap`, which works in a very similar way to the `map`
    function, but returns the values in a flat form instead of nested values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数很棒，但你可能会得到嵌套的结构。这就是为什么，当我们与Monads一起工作时，我们使用一个稍微不同的`map`函数版本，称为`flatMap`，它的工作方式与`map`函数非常相似，但以扁平形式返回值而不是嵌套值。'
- en: In order to have a monad, you need to have a method called `flatMap`. Other
    function languages such as Haskell call `flatMap` as `bind`, and use the operator
    `>>=`. The syntax changes with the language, but the concept is the same.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个monad，你需要有一个名为`flatMap`的方法。其他函数语言，如Haskell，将`flatMap`称为`bind`，并使用操作符`>>=`。语法随着语言的变化而变化，但概念是相同的。
- en: Monads can be built in different ways. In Scala, we need a single argument constructor
    which will work as a monad factory. Basically, the constructor receives one type,
    `A`, and returns `Monad[A]` or just `M[A]`. For instance, `unit(A)` for a `List`
    will be `== List[A]` and `unit(A)`, where a is an Option `== Option[A]`. In Scala,
    you don't need to have unit; this is optional. To have a monad in Scala, you need
    to have map and `flatMap` implemented.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Monads可以以不同的方式构建。在Scala中，我们需要一个单参数构造函数，它将作为monad工厂工作。基本上，构造函数接收一个类型`A`，并返回`Monad[A]`或简称为`M[A]`。例如，对于`List`的`unit(A)`将是`==
    List[A]`和`unit(A)`，其中`a`是一个Option `== Option[A]`。在Scala中，你不需要有unit；这是可选的。要在Scala中有一个monad，你需要实现map和`flatMap`。
- en: 'Working with Monads will make you write a little bit more code than before.
    However, you will get a way better API, which will be easier to reuse and your
    potential complexity will be managed, because you won''t need to write a complex
    code full of `if` and for loops. The possibilities are expressed through the types,
    and the compiler can check it for you. Let us see a simple monad example in Scala
    language:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与Monads一起工作会使你写的代码比以前稍微多一点。然而，你将获得一个更好的API，这将更容易重用，并且你的潜在复杂性将被管理，因为你不需要写一个充满`if`和for循环的复杂代码。可能性通过类型表达，编译器会为你检查。让我们看看Scala语言中的一个简单的monad示例：
- en: Option Monad in Scala
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala中的Option Monad
- en: 'We will see option Monad in Scala as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如下看到Scala中的Option Monad：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In Haskell, this also known as the Maybe monad. Option means optional value,
    because we are not 100% sure if the value will be present. In order to express
    a value, we use the `Some` type, and in order to express the lack of value, we
    use none. Option Monads are great, they make your code more explicit, because
    a method might receive or return an option, which means you are explicitly saying
    this could be null. However, this technique is not only more expressive but also
    safer, since you won't get a null pointer, because you have a container around
    the value. Although, if you call the method `get` in `Option` and it is none,
    you will get a `NoSuchelementException`. In order to fix this, you can use the
    method `getOrElse`, and you can supply a fallback value which will be used in
    the case of none. Alright, but you might be wondering where the `flatMap` method
    is. Don't worry, Scala implements this method for us into the `Option` abstraction,
    so you can  use it with no issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，这被称为 Maybe monad。Option 表示可选值，因为我们不能100%确定值是否存在。为了表达一个值，我们使用 `Some`
    类型，为了表达值的缺失，我们使用 none。Option Monads 非常好，它们使你的代码更加明确，因为一个方法可能会接收或返回一个 option，这意味着你明确地表示这可能是
    null。然而，这种技术不仅更加明确，而且更加安全，因为你不会得到一个 null 指针，因为你有一个容器包围着值。尽管如此，如果你在 `Option` 中调用
    `get` 方法，并且它是 none，你将得到一个 `NoSuchelementException`。为了解决这个问题，你可以使用 `getOrElse`
    方法，并且你可以提供一个回退值，在 none 的情况下将被使用。好吧，但你可能想知道 `flatMap` 方法在哪里。别担心，Scala 为我们实现了这个方法到
    `Option` 抽象中，所以你可以无问题地使用它。
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The Scala REPL can perform autocomplete for you. If you type **C** + **Tab**,
    you will see all the available methods for the `Some` class. The `map` function
    is available for you to use, and as I said before, there is no unit function in
    Scala whatsoever. However, it is not wrong if you add in your APIs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Scala REPL 可以为你执行自动补全。如果你输入 **C** + **Tab**，你会看到 `Some` 类的所有可用方法。`map` 函数可供你使用，正如我之前所说的，Scala
    中根本没有任何单元函数。然而，如果你在自己的 API 中添加它，这并不错误。
- en: A list of all methods using the Scala REPL
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Scala REPL 的所有方法列表
- en: 'Following are the list of all methods using the Scala REPL:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Scala REPL 的所有方法列表：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Scala class, traits, and OO programming
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 类、特性和面向对象编程
- en: As a hybrid post-functional language, Scala allows you to write OO code and
    create classes as well. Right now we will learn how to create classes and functions
    inside classes, and also how to work with traits, which are similar to Java interfaces
    in concept but way more powerful in practice.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种混合函数式语言，Scala 允许你编写面向对象的代码并创建类。现在我们将学习如何创建类和类内的函数，以及如何处理特性，特性在概念上类似于 Java
    接口，但在实践中要强大得多。
- en: A simple Scala class in Scala REPL
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的简单 Scala 类
- en: 'We will see a simple Scala class in Scala REPL as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Scala REPL 中看到以下简单的 Scala 类：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At first glance, the preceding code looks like Java. But let's add constructors,
    getters, and setters, and then you can see how much we can accomplish with just
    a few lines of code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，前面的代码看起来像 Java。但让我们添加构造函数、获取器和设置器，然后你就可以看到我们只需几行代码就能完成多少工作。
- en: Scala plain old Java object in Scala REPL
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的 Scala 简单 Java 对象
- en: 'Following is a Scala plain old Java object in Scala REPL:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Scala REPL 中展示的 Scala 简单 Java 对象：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Constructors in Scala are just lines of code. You might realize that we get
    the `name` variable, and apply a function to change the given name to upper case
    in the preceding example. If you want, you can put as many lines as you want,
    and you can perform as many computations as you wish.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的构造函数只是代码行。你可能意识到，我们在前面的例子中得到了 `name` 变量，并应用了一个函数将给定的名字转换为大写。如果你想，你可以放任意多的行，并且可以执行你想要的任何计算。
- en: On this same code, we perform method overriding as well, because we override
    the `toString` method. In Scala, in order to do an override, you need to use the
    `override` operator in front of the function definition.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的代码上，我们还执行了方法重写，因为我们重写了 `toString` 方法。在 Scala 中，为了进行重写，你需要在函数定义前使用 `override`
    操作符。
- en: We just wrote a **Plain Old Java Object** (**POJO**) with very few lines of
    code in Scala. Scala has a special annotation called `@scala.beans.BeanProperty`,
    which generates the getter and setter method for you. This is very useful, and
    saves lots of lines of code. However, the target needs to be public; you can't
    a apply `BeanProperty` annotation on top of a private `var` or `val` object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是用 Scala 写了一个只有几行代码的 **纯 Java 对象**（**POJO**）。Scala 有一个特殊的注解叫做 `@scala.beans.BeanProperty`，它可以为你生成
    getter 和 setter 方法。这非常有用，可以节省很多代码。然而，目标必须是公共的；你不能在私有 `var` 或 `val` 对象上应用 `BeanProperty`
    注解。
- en: Person class in Java
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 中的 Person 类
- en: 'Following is a Person class in Java:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Java 中的 Person 类：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Traits and inheritance
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质和继承
- en: It's possible to do inheritance in Scala as well. For such a task, you use the
    operator `extend` after the class definition. Scala just allows you to extend
    one class, just like Java. Java does not allow multiple inheritance like C++.
    However, Scala allows it by using the Mixing technique with traits. Scala traits
    are like Java interface, but you can also add concrete code, and you are allowed
    to have as many traits as you want in your code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中也可以进行继承。对于这样的任务，你在类定义之后使用 `extend` 操作符。Scala 只允许你扩展一个类，就像 Java 一样。Java
    不像 C++ 那样允许多重继承。然而，Scala 通过使用特质的混合技术允许这样做。Scala 特质类似于 Java 接口，但你也可以添加具体代码，并且你可以在代码中拥有任意数量的特质。
- en: Scala inheritance code in Scala REPL
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 继承代码在 Scala REPL
- en: 'Following is a Scala inheritance code in Scala REPL:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Scala REPL 中的 Scala 继承代码：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Scala does not make constructors inheritance like Java. So you need to rewrite
    the constructors and pass the values through a super class. All code inside the
    class will be the secondary constructor. All code inside parentheses `()` in the
    class definition will be the primary constructor. It's possible to have multiple
    constructors using the `this` operator. For this particular implementation, we
    changed the default behavior and added new constructor code in order to make the
    given name lower case, instead of the default uppercase defined by the `Person`
    superclass.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 不像 Java 那样支持构造函数的继承。因此，你需要重写构造函数并通过超类传递值。类内的所有代码都将作为次要构造函数。类定义中括号 `()`
    内的所有代码都将作为主要构造函数。可以使用 `this` 操作符来拥有多个构造函数。对于这个特定的实现，我们改变了默认行为，并添加了新的构造函数代码，以便将给定的名称转换为小写，而不是
    `Person` 超类定义的默认大写。
- en: Scala traits sample code in Scala REPL
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 特质示例代码在 Scala REPL
- en: 'Following is a Scala traits sample code in Scala REPL:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Scala REPL 中的 Scala 特质示例代码：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, we created multiple traits. One is called Car, which
    is the mother trait. Traits support inheritance as well, and we have it with the
    `SportCar` trait which extends from the `Car` trait. The `SportCar` trait demands
    a variable called brand, and defines a concrete implementation of the function
    run. Finally, we have a class called `BMW` which extends from multiple traits
    -- this technique is called **mixing.**
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了多个特质。其中一个叫做 Car，是母特质。特质也支持继承，我们通过 `SportCar` 特质从 `Car` 特质扩展了它。`SportCar`
    特质要求一个名为 brand 的变量，并定义了 run 函数的具体实现。最后，我们有一个名为 `BMW` 的类，它从多个特质扩展而来——这种技术称为 **混合**。
- en: Scala traits using variable mixing technique at Scala REPL
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Scala REPL 中使用变量混合技术的 Scala 特质
- en: 'Following is a Scala traits using variable mixing technique at Scala REPL:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Scala REPL 中使用变量混合技术的 Scala 特质示例：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Scala is a very powerful language indeed. It's possible to add traits to a variable
    at runtime. When you define a variable, you can use the `with` operator after
    the assignment. This is a very useful feature, because it makes it easier to make
    function composition. You can have multiple specialized traits and just add them
    in your variables as you need them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 确实是一个非常强大的语言。你可以在运行时向变量添加特质。当你定义一个变量时，你可以在赋值之后使用 `with` 操作符。这是一个非常有用的特性，因为它使得函数组合更容易。你可以拥有多个专门的特质，并且可以根据需要将它们添加到你的变量中。
- en: Scala allows you to create the `type` alias as well, this is a very simple technique
    which will increase the readability of your code. It's just a simple alias.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 允许你创建 `类型别名`，这是一个非常简单的技术，可以提高你代码的可读性。它只是一个简单的别名。
- en: Scala type alias sample in Scala REPL
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Scala REPL 中的 Scala 类型别名示例
- en: 'Following is a Scala type alias sample in Scala REPL:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Scala REPL 中的 Scala 类型别名示例：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When you are coding with Scala, it is highly recommended that you use the `type`
    alias and traits for everything, because that way you will get more advantages
    with your compiler, and you will avoid writing unnecessary code and unnecessary
    unit tests.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用 Scala 编码时，强烈建议你为一切使用 `type` 别名和特质，因为这样你将获得编译器的更多优势，并且可以避免编写不必要的代码和单元测试。
- en: Case classes
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例类
- en: 'We are not done yet in terms of the OO features in Scala; there is another
    very interesting way to work with classes in Scala: the so-called case classes.
    Case classes are great because you can have a class with way less number of lines
    of code and case classes can be part of a Pattern Matcher.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 的面向对象特性方面，我们还没有完成；还有另一种非常有趣的方式来处理 Scala 中的类：所谓的案例类。案例类很棒，因为你可以拥有一个代码行数远少于常规类的类，并且案例类可以是模式匹配器的一部分。
- en: Scala case classes feature in Scala REPL
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的案例类特性
- en: 'Following is a Scala case classes feature in Scala REPL:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Scala REPL 中的案例类特性：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is the Scala way to work with classes. Because this is so much easier and
    compact, you pretty much create a class with one line of code, and you can have
    the `equals` and `hashcode` methods for free.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Scala 处理类的方式。因为这样既简单又紧凑，你几乎可以用一行代码创建一个类，并且可以免费获得 `equals` 和 `hashCode` 方法。
- en: Pattern Matcher
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配器
- en: When you code in Java, you can use a Switch statement. However, in Scala, we
    have a more powerful feature called Pattern Matcher, which is a kind of switch
    but on steroids.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Java 中编码时，你可以使用 Switch 语句。然而，在 Scala 中，我们有一个更强大的特性，称为模式匹配，它是一种增强版的 switch。
- en: Simple Pattern Matcher in Scala
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 中的简单模式匹配器
- en: 'Following is a Simple Pattern Matcher in Scala:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 Scala 中的简单模式匹配器：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Scala uses Pattern Matcher for error handling. Java does not have Pattern Matcher
    like Scala. It's similar to a switch statement; however, Pattern Matcher can be
    used in a method return statement as you can see in the preceding code. Scala
    developers can specify a special operator called `_` (Underscore), which allows
    you to specify anything in the Pattern Matcher scope. This behavior is similar
    to `else` in an `if` conditional. However, in Scala, you can use `_` in several
    places, and not only as the otherwise clause, like in Java switch.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 使用模式匹配进行错误处理。Java 没有像 Scala 那样的模式匹配。它类似于 switch 语句；然而，模式匹配可以在方法返回语句中使用，就像前面代码中看到的那样。Scala
    开发者可以指定一个特殊的操作符 `_`（下划线），它允许你在模式匹配器范围内指定任何内容。这种行为类似于 `if` 条件中的 `else`。然而，在 Scala
    中，你可以在多个地方使用 `_`，而不仅仅是作为 Java switch 中的其他分支。
- en: Error handling in Scala is similar to error handling in Java. We use try...catch
    blocks. The main difference is that you have to use Pattern Matcher in Scala,
    which is great because it adds more flexibility to your code. Pattern Matcher
    in Scala can operate against many data structures like case classes, collections,
    integers, and strings.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的错误处理类似于 Java 中的错误处理。我们使用 try...catch 块。主要区别在于你必须在 Scala 中使用模式匹配，这很棒，因为它为你的代码增加了更多的灵活性。Scala
    中的模式匹配可以对许多数据结构进行操作，如案例类、集合、整数和字符串。
- en: The preceding code is pretty simple and straightforward. Next we will see a
    more complex and advanced code using the Scala Pattern Matcher feature.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码相当简单直接。接下来，我们将看到使用 Scala 模式匹配器特性的更复杂和高级的代码。
- en: Advanced pattern matcher in Scala REPL
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的高级模式匹配器
- en: 'Following is an Advanced Pattern Matcher using Scala REPL:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Scala REPL 中使用的高级模式匹配器：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Pattern Matcher can be used in a very functional way. For instance, in the preceding
    code, we use the Pattern Matcher for recursion. There is no need to create a variable
    to store the result, we can put the Pattern Matcher straight to the function return,
    which is very convenient and saves lots of lines of code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配可以非常函数式地使用。例如，在前面代码中，我们使用模式匹配进行递归。不需要创建变量来存储结果，我们可以直接将模式匹配放入函数返回，这非常方便，并且可以节省大量的代码行数。
- en: Advanced complex pattern matcher in Scala REPL
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的高级复杂模式匹配器
- en: 'Following is an Advanced complex Pattern Matcher using Scala REPL:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Scala REPL 中使用的高级复杂模式匹配器：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Scala Pattern Matcher is really amazing. We just used an `if` statement
    in the middle of the Pattern Matcher, and also `_` to specify a match for any
    kind of red value. We also used case classes in the middle of the Pattern Matcher
    expressions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的模式匹配器非常神奇。我们只是在模式匹配器的中间使用了 `if` 语句，还使用了 `_` 来指定对任何红色值的匹配。我们还在模式匹配器表达式中使用了案例类。
- en: Partial functions
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分函数
- en: Partial functions are great for function composition. They can operate with
    case statements as we just learned from Pattern Matcher. Partial functions are
    great in the sense of function composition. They allow us to define a function
    in steps. Scala frameworks and libraries use this feature a lot to create abstractions
    and callback mechanisms. It's also possible to check if a partial function is
    being supplied or not.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数非常适合函数组合。正如我们从模式匹配器中学到的那样，它们可以使用情况语句进行操作。在函数组合方面，部分函数非常出色。它们允许我们分步骤定义一个函数。Scala框架和库大量使用这个特性来创建抽象和回调机制。还可以检查是否提供了部分函数。
- en: Partial functions are predictable, because the caller can check beforehand if
    the value will be applied to the partial function or not. Partial function can
    be coded with or without case-like statements.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数是可预测的，因为调用者可以在之前检查值是否将被应用到部分函数中。部分函数可以带有或没有类似情况语句的代码。
- en: Simple Partial function in Scala REPL
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的简单部分函数
- en: 'Following is a simple Partial function using Scala REPL:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用Scala REPL的简单部分函数示例：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Partial functions are Scala classes. They have some methods you need to provide,
    for instance, `apply` and `isDefinedAt`. The function `isDefinedAt` is used by
    the caller to check if the `PartialFunction` will accept and operate with the
    value supplied. The `apply` function will do the work when the `PartialFunction`
    is executed by Scala.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数是Scala类。它们有一些您需要提供的方法，例如`apply`和`isDefinedAt`。`isDefinedAt`函数由调用者使用，以检查`PartialFunction`是否会接受并操作提供的值。当`PartialFunction`由Scala执行时，`apply`函数将执行工作。
- en: Scala PartialFunction without OO using case statements in Scala REPL
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Scala REPL中使用情况语句的Scala部分函数
- en: 'Following is a Scala PartialFunction without OO using case statements in Scala
    REPL:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在Scala REPL中使用情况语句的Scala部分函数示例：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Scala was a more fluent way to work with `PartialFunction` using the `case`
    statements. When you use the `case` statements, you don't need to supply the `apply`
    and `isDefinedAt` functions, since the Pattern Matcher takes care of that.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用情况语句，Scala在处理`PartialFunction`时更加流畅。当您使用情况语句时，您不需要提供`apply`和`isDefinedAt`函数，因为模式匹配器会处理这些。
- en: PartialFunction composition in Scala REPL
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的部分函数组合
- en: 'Following is a PartialFunction composition in Scala REPL:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Scala REPL中的部分函数组合示例：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Scala allows us to compose as many `PartialFunctions` as we want. `PartialFunction`
    composition happens with the `orElse` function. In the preceding code, we defined
    an immutable variable called `even`, which verifies even numbers. Secondly, we
    created a second immutable variable called `odd`, which checks for odd numbers.
    Then we did the composition, and created a third `PartialFunction` called `evenOrOdd`
    with compose even and odd using the `orElse` operator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Scala允许我们组合任意多的`PartialFunctions`。`PartialFunction`的组合是通过`orElse`函数实现的。在前面的代码中，我们定义了一个不可变的变量`even`，用于验证偶数。其次，我们创建了一个名为`odd`的第二个不可变变量，用于检查奇数。然后我们进行了组合，并使用`orElse`运算符创建了一个名为`evenOrOdd`的第三个`PartialFunction`，它通过组合偶数和奇数。
- en: Package objects
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包对象
- en: Scala has packages like Java. However, Scala packages are also objects, and
    you can have code inside a package. Java does not have the same power as Scala
    in terms of packages. If you add code to a package, it will be available to all
    classes and functions within that package.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Scala有像Java一样的包。然而，Scala的包也是对象，您可以在包内编写代码。在包方面，Java没有Scala那样的能力。如果您向包中添加代码，它将对该包内的所有类和函数都可用。
- en: package.scala
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: package.scala
- en: Your `package.scala` file should contain the following code
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `package.scala` 文件应包含以下代码
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is the Scala package object. There is this special token called `package`
    object which you use to define common code to all classes, objects, and functions
    that are defined inside this package or sub-package. For this case, we define
    a value of PI as a constant and also one object holder containing the String values
    for `Odd` and `Even`. There are also three helper functions, which can and will
    be used by the classes inside this package.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Scala包对象。这里有一个特殊的标记，称为`package`对象，您可以使用它来定义所有在包或子包内部定义的类、对象和函数的公共代码。在这种情况下，我们定义PI的值作为一个常量，还有一个包含`Odd`和`Even`字符串值的对象持有者。还有三个辅助函数，这些函数将被包内的类使用。
- en: MainApp.scala
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MainApp.scala
- en: Your `MainApp.scala` file should contain the following code
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `MainApp.scala` 文件应包含以下代码
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see in the preceding code, this new object is placed in the package:
    `com.packait.scala.book.commons`. Another interesting thing is the fact that we
    don''t have any import statement here because of the `package` object feature.
    When you compile and run this program, you will see the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，这个新对象被放置在包中：`com.packait.scala.book.commons`。另一个有趣的事实是，由于`package`对象特性，我们在这里没有任何导入语句。当您编译并运行此程序时，您将看到以下输出：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Scala uses the `Package` object a great deal providing lots of shortcuts and
    convenience for all Scala developers. The following is the Scala `package` object
    definition:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Scala大量使用`Package`对象，为所有Scala开发者提供了许多快捷方式和便利。以下是Scala `package`对象定义：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Functions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Like any great FP language, Scala has lots of built-in functions. These functions
    make our code more fluent and functional; now it''s time to learn some of these
    functions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何伟大的函数式编程语言一样，Scala有很多内置函数。这些函数使我们的代码更加流畅和函数式；现在是时候学习一些这些函数了：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Partial application
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: In Scala, the underscore(`_`) means different things in different contexts.
    The underscore can be used to partially apply a function. It means a value will
    be supplied later. This feature is useful for function composition and allows
    you to reuse functions. Let's see some code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，下划线（`_`）在不同的上下文中意味着不同的事情。下划线可以用来部分应用一个函数。这意味着稍后将会提供值。这个特性对于函数组合很有用，并允许您重用函数。让我们看看一些代码。
- en: Partial function in Scala REPL
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的部分函数
- en: 'Following is an example using Partial function in Scala REPL:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用部分函数的Scala REPL示例：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, first, we define a function called `sum`, which takes
    two `Int` parameters and calculates a sum of these two parameters. Later, we define
    a function and hold it as a variable called `add6`. For the `add6` function definition,
    we just call the sum function passing `6` and `_`. Scala will get the parameter
    passed through `add6`, and pass it through the `sum` function.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们定义了一个名为`sum`的函数，它接受两个`Int`参数并计算这两个参数的和。稍后，我们定义了一个函数并将其存储在一个名为`add6`的变量中。对于`add6`函数的定义，我们只是调用sum函数，传递`6`和`_`。Scala将获取通过`add6`传递的参数，并将其传递给`sum`函数。
- en: Curried functions
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化函数
- en: This feature is very popular in function languages like Haskell. Curried functions
    are similar to partial applications, because they allow some arguments to pass now
    and others later. However, they are a little bit different.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在像Haskell这样的函数语言中非常流行。柯里化函数与部分应用类似，因为它们允许一些参数现在传递，其他参数稍后传递。然而，它们有一些不同之处。
- en: Curried functions - Scala REPL
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化函数 - Scala REPL
- en: 'Following is an example using curried function in Scala REPL:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用柯里化函数的Scala REPL示例：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For the preceding code, we create a curried function in the function definition.
    Scala allows us to transform regular/normal functions into curried functions.
    The following code shows the usage of the `curried` function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的代码，我们在函数定义中创建了一个柯里化函数。Scala允许我们将常规/普通函数转换为柯里化函数。以下代码显示了`curried`函数的用法。
- en: Curried transformation in Scala REPL
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的柯里化转换
- en: 'Following is an example using curried transformation in Scala REPL:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用柯里化转换的Scala REPL示例：
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Operator overloading
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Like C++, Scala permits operator overload. This feature is great for creating
    custom **Domain Specific Languages** (**DSL**), which can be useful to create
    better software abstractions or even internal or external APIs for developers,
    or for business people. You should use this feature with wisdom -- imagine if all
    frameworks decide to overload the same operators with implicits! You might run
    into trouble. Scala is a very flexible language compared to Java. However, you
    need to be careful, otherwise you could create code that's hard to maintain or
    even incompatible with other Scala applications, libraries, or functions.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++类似，Scala允许运算符重载。这个特性对于创建自定义**领域特定语言**（**DSL**）非常有用，这对于创建更好的软件抽象或为开发人员或商业人士创建内部或外部API非常有用。您应该明智地使用这个特性——想象一下，如果所有框架都决定使用隐式参数重载相同的运算符！您可能会遇到麻烦。与Java相比，Scala是一个非常灵活的语言。然而，您需要小心，否则您可能会创建难以维护或甚至与其他Scala应用程序、库或函数不兼容的代码。
- en: Scala operator overloading in Scala REPL
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL中的Scala运算符重载
- en: 'Following is an example using Scala operator overloading in Scala REPL:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Scala运算符重载的Scala REPL示例：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, we have two functions called `+`. One of this functions receives
    a `MyNumber` case class, and the other receives a `Int` value. You can use OO
    in Scala with regular classes and functions as well if you wish. We're also favoring
    immutability here because we always create a new instance of `MyNumber` when the
    operation `+` happens.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有两个名为 `+` 的函数。其中一个函数接收一个 `MyNumber` 案例类，另一个接收一个 `Int` 值。如果您愿意，您也可以在 Scala
    中使用面向对象编程（OO）和常规类及函数。我们在这里也倾向于使用不可变性，因为我们总是在操作 `+` 发生时创建一个新的 `MyNumber` 实例。
- en: Implicits
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式参数
- en: Implicits allow you to do magic in Scala. With great power comes great responsibility.
    Implicits allow to you create very powerful DSL, but they also allow you to get
    crazy, so do it with wisdom. You are allowed to have implicit functions, classes,
    and objects. The Scala language and other core frameworks from the Scala ecosystem
    like Akka and PlayFramework use implicits many times.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数允许您在 Scala 中施展魔法。权力越大，责任越大。隐式参数允许您创建非常强大的 DSL，但它们也允许您变得疯狂，所以请明智地使用。您可以使用隐式函数、类和对象。Scala
    语言以及 Scala 生态系统中的其他核心框架，如 Akka 和 PlayFramework，都多次使用了隐式参数。
- en: Scala Implicits in SCALA REPL
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SCALA REPL 中的 Scala 隐式参数
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: To use implicits, you need to use the keyword `implicit` before a function.
    Scala will implicitly call that function when it is appropriate. For this case,
    it will call to convert the `String` type to `Int` type as we can see.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用隐式参数，您需要在函数前使用关键字 `implicit`。Scala 将在适当的时候隐式调用该函数。对于这个例子，它将调用将 `String` 类型转换为
    `Int` 类型的转换。
- en: Implicit Parameter at Scala REPL
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的隐式参数
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For this other case, given in the last code, we use an implicit parameter in
    the function `sum`. We also used a curried function here. We defined the `implicit`
    function first, and then called the `sum` function. This technique is good for
    externalized functions configuration and values you would let it hard code. It
    also saves lines of code, because you don't need to pass a parameter to all functions
    all the time, so it's quite handy.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后给出的代码中的另一个情况，我们在 `sum` 函数中使用了隐式参数。我们在这里还使用了一个柯里化函数。我们首先定义了 `implicit` 函数，然后调用了
    `sum` 函数。这种技术对于外部化函数配置和您希望避免硬编码的值很有用。它还节省了代码行数，因为您不必总是传递参数给所有函数，所以它非常方便。
- en: Futures
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Futures
- en: Futures enable an efficient way to write parallel operations in a nonblocking
    IO fashion. Futures are placeholder objects for values that might not exist yet.
    Futures are composable, and they work with callbacks instead of traditional blocking
    code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Futures 提供了一种高效的方式来以非阻塞 I/O 风格编写并行操作。Futures 是可能尚未存在的值的占位符对象。Futures 是可组合的，并且它们使用回调而不是传统的阻塞代码。
- en: Simple Future code in Scala REPL
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala REPL 中的简单 Future 代码
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In order to work with futures in Scala, we have to import `concurrent.Future`.
    We also need an executor, which is a way to work with threads. Scala has a default
    set of execution services. You can tweak it if you like, however, for now we can
    just use the defaults; to do that, we just import `concurrent.ExecutionContext.Implicits.global`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Scala 中使用 futures，我们必须导入 `concurrent.Future`。我们还需要一个执行器，这是一种处理线程的方式。Scala
    有一个默认的执行服务集合。如果您喜欢，可以对其进行调整，但就目前而言，我们可以直接使用默认设置；为此，我们只需导入 `concurrent.ExecutionContext.Implicits.global`。
- en: It's possible to retrieve the `Future` value. Scala has a very explicit API,
    which makes the developer's life easier, and also gives good samples for how we
    should code our own APIs. Future has a method called `value`, which returns `Option[scala.util.Try[A]]`
    where `A` is the generic type you are using for the future; for our case, it's
    a String `A`. `Try` is a different way to do a try...catch, and this is safer,
    because the caller knows beforehand that the code they are calling may fail. `Try[Optional]`
    means that Scala will try to run some code and the code may fail -- even if it
    does not fail, you might receive `None` or `Some`. This type of system makes everybody's
    lives better, because you can have `Some` or `None` as the Option return. Futures
    are a kind of callback. For our previous sample code, the result was obtained
    quite quickly, however, we often use futures to call external APIs, REST services,
    Microservices, SOAP Webservices, or any code that takes time to run and might
    not get completed. Futures also work with Pattern Matcher. Let's see another sample
    code.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检索 `Future` 的值。Scala 有一个非常明确的 API，这使得开发者的生活更加轻松，同时也为我们提供了如何编写我们自己的 API 的良好示例。Future
    有一个名为 `value` 的方法，它返回 `Option[scala.util.Try[A]]`，其中 `A` 是你为 future 使用的通用类型；在我们的例子中，它是一个
    String `A`。`Try` 是执行 try...catch 的另一种方式，这更安全，因为调用者事先知道他们调用的代码可能会失败。`Try[Optional]`
    表示 Scala 将尝试运行一些代码，这些代码可能会失败——即使它们没有失败，你也可能会收到 `None` 或 `Some`。这种类型的系统使每个人的生活都变得更好，因为你可以有
    `Some` 或 `None` 作为 Option 返回值。Futures 是一种回调。在我们的前一个示例代码中，结果获得得相当快，然而，我们经常使用 futures
    来调用外部 API、REST 服务、微服务、SOAP Web服务或任何需要时间运行且可能无法完成的代码。Futures 还与模式匹配器一起工作。让我们看看另一个示例代码。
- en: A complete Future sample at Scala REPL
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Scala REPL 中完整的 Future 示例
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is a function called `createFuture`, which creates `Future[Int]` each
    time you call it. In the preceding code, we use `scala.util.Random` to generate
    random numbers between 0 and 99\. If the number is even, we return a `0`, which
    means success. However, if the number is odd, we return a `RuntimeException`,
    which will mean a failure.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `createFuture` 的函数，每次调用它都会创建一个 `Future[Int]`。在上面的代码中，我们使用 `scala.util.Random`
    生成介于 0 和 99 之间的随机数。如果数字是偶数，我们返回一个 `0`，表示成功。然而，如果数字是奇数，我们返回一个 `RuntimeException`，这表示失败。
- en: 'There is a second function called `evaluateFuture`, which receives any Future.
    We allow a result of any kind of generic parameterized type of function, because
    we used the magic underscore `_`. Then we apply Pattern Matcher with two case
    classes: `Success` and `Failure`. In both the cases, we just print on `stdin`.
    We also use another interesting and handy Scala feature called String interpolation.
    We need to we start the String with `s` before `""`. This allows us to use expressions
    with `$` and `${}` to evaluate any variable in the context. This is a different
    approach for String concatenation from what we have done so far. Later, we made
    `6` calls for the `evaluteFuture` function, passing a new Future each time, created
    by the function `createFuture`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `evaluateFuture` 的第二个函数，它接收任何 Future。我们允许函数的结果是任何类型的通用参数化类型，因为我们使用了魔法下划线
    `_`。然后我们使用两个案例类 `Success` 和 `Failure` 进行模式匹配。在两种情况下，我们只是在 `stdin` 上打印。我们还使用了另一个有趣且实用的
    Scala 功能，称为字符串插值。我们需要在 `""` 前以 `s` 开头字符串。这允许我们使用 `$` 和 `${}` 来评估上下文中的任何变量。这是与我们迄今为止所做不同的字符串连接方法。稍后，我们为
    `evaluteFuture` 函数调用了 `6` 次，每次传递由 `createFuture` 函数创建的新 Future。
- en: Reactive Programing and RxScala
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程和 RxScala
- en: Reactive programming is better, scalable, and a faster way to build applications.
    Reactive Programing can be done with OO languages, however, they make a lot of
    sense with FP languages. When FP is married to Reactive Programing, we get something
    called **Functional Reactive Programing** (**FRP**). Scala FRP can be used for
    many purposes like GUI, Robotics, and Music, because it gives you a better model
    to model time. Reactive programming is a new technique, which works with Streams(also
    known as Data Flows). Streams is a way to think and code applications in a way
    which can express data transformations and flow. The main idea is to propagate
    changes through a circuit or flow. Yes, we are talking about a new way to do async
    programming.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程更好、可扩展，是构建应用程序的更快方式。响应式编程可以用面向对象的语言实现，然而，它们与函数式编程语言结合时更有意义。当函数式编程与响应式编程结合时，我们得到一个称为**函数式响应式编程**（**FRP**）的东西。Scala
    FRP可用于许多目的，如GUI、机器人技术和音乐，因为它为你提供了一个更好的模型来模拟时间。响应式编程是一种新技术，它与流（也称为数据流）一起工作。流是一种以能够表达数据转换和流动的方式思考和编写应用程序的方法。主要思想是通过电路或流传播变化。是的，我们正在谈论一种新的异步编程方式。
- en: The main library for Reactive Programing is called **Reactive Extensions** (**Rx**)
    - [http://reactivex.io/](http://reactivex.io/)), originally built for .NET by
    Eric Meijer. It combines the best ideas from the Observer and Iterator Patterns,
    and FP. Rx has implementations for many languages like Scala, Java, Python, .NET,
    PHP, and others ([https://github.com/ReactiveX](https://github.com/ReactiveX)).
    Coding with Rx is easy, and you can create Streams, combine with query-like operators,
    and also listen (subscribe) to any observable Streams to perform data transformations.
    Rx is used by many successful companies today like Netflix, GitHub, Microsoft,
    SoundCloud, Couchbase, Airbnb, Trello, and several others. In this book, we will
    use RxScala, which is the Scala implementation of the Reactive Streams.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 用于响应式编程的主要库称为**响应式扩展**（**Rx**） - [http://reactivex.io/](http://reactivex.io/)，最初由Eric
    Meijer为.NET构建。它结合了观察者模式和迭代器模式以及函数式编程的最佳思想。Rx为许多语言提供了实现，如Scala、Java、Python、.NET、PHP等（[https://github.com/ReactiveX](https://github.com/ReactiveX)）。使用Rx进行编码很简单，你可以创建流，使用类似查询的运算符进行组合，还可以订阅任何可观测流以执行数据转换。Rx被许多成功的公司使用，如Netflix、GitHub、Microsoft、SoundCloud、Couchbase、Airbnb、Trello等。在这本书中，我们将使用RxScala，它是响应式流的Scala实现。
- en: The following table shows the main class/concepts you need to know in order
    to work with Rx.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了您需要了解的主要类/概念，以便与Rx一起工作。
- en: '| **Term / Class** | **Concept** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **术语/类** | **概念** |'
- en: '| Observable | Create async composable Streams from sources. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 可观测对象 | 从源创建异步可组合的流。|'
- en: '| Observer | A callback function type. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 观察者 | 一种回调函数类型。|'
- en: '| Subscription | The bound between the Subscriber and the Observable. Receives
    notifications from Observables. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 订阅 | 订阅者和可观测对象之间的绑定。接收来自可观测对象的通告。|'
- en: Reactive Streams is also the name of a common specification trying to consolidate
    and standardize the reactive stream processing, There are several implementations
    such as RxJava/RxScala, Reactor, Akka, Slick, and Vert.x. You can find more at
    [https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式流也是试图统一和标准化响应式流处理的通用规范名称。有几个实现，如RxJava/RxScala、Reactor、Akka、Slick和Vert.x。更多信息请参阅[https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm)。
- en: Back to the Observables -- we can perform all kinds of operations with observables.
    For instance, we can filter, select, aggregate, compose, perform time-based operations,
    and apply backpressure. There are two big wins with Observables instead of callbacks.
    First of all, Observables are not opinionated about how low-level I/O and threading
    happens, and secondly, when you are doing complex code, callbacks tend to be nested,
    and that is when things get ugly and hard to read. Observables have a simple way
    to do composition thanks to FP.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 回到可观测对象 -- 我们可以对可观测对象执行各种操作。例如，我们可以过滤、选择、聚合、组合、执行基于时间的操作，并应用背压。与回调相比，使用可观测对象有两个显著的优点。首先，可观测对象对底层I/O和线程的处理方式没有偏见，其次，当你编写复杂代码时，回调往往会嵌套，这时事情会变得丑陋且难以阅读。由于函数式编程（FP），可观测对象有简单的方法来进行组合。
- en: Observables push values to consumers whenever values are available, which is
    great because then the values can arrive in sync or async fashion. Rx provides
    a series of collection operators to do all sorts of data transformations you may need.
    Let's see some code now. We will use RxScala version 0.26.1, which is compatible
    with RxJava version 1.1.1+. RxScala is just a wrapper for RxJava (Created by Netflix).
    Why not use RxJava straight? Because the syntax won't be pleasant; with RxScala,
    we can have a fluent Scala experience. RxJava is great, however, Java syntax for
    this is not pleasant - as Scala is, in fact, pretty ugly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Observables在值可用时将值推送到消费者，这很好，因为这样值可以以同步或异步的方式到达。Rx提供了一系列集合操作符，可以执行各种你可能需要的数据转换。现在让我们看看一些代码。我们将使用RxScala版本0.26.1，它与RxJava版本1.1.1+兼容。RxScala只是RxJava的一个包装器（由Netflix创建）。为什么不直接使用RxJava呢？因为语法不会很愉快；使用RxScala，我们可以获得流畅的Scala体验。RxJava很棒，然而，Java语法对于这个来说并不愉快——实际上，Scala的语法相当糟糕。
- en: Simple Observables Scala with RxScala
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的RxScala Scala
- en: '[PRE63]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you run this preceding Scala program, you will see the following output:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的Scala程序，你将看到以下输出：
- en: Simple Observables Scala with RxScala - Execution in the console
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的RxScala Scala - 在控制台中的执行
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you try to run this code in the Scala REPL, it will fail, because we need
    the RxScala and RxJava dependencies. For this, we will need SBT and dependency
    management. Do not worry, we will cover how to work with SBT in our Scala application
    in the next chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在Scala REPL中运行此代码，它将会失败，因为我们需要RxScala和RxJava依赖项。为此，我们需要SBT和依赖项管理。不要担心，我们将在下一章中介绍如何在Scala应用程序中使用SBT。
- en: 'Going back to the observables, we need to import the Scala Observable. Make
    sure you get it from the Scala package, because if you get the Java one, you will
    have issues: in the very first part of the code, we will get numbers starting
    from 0 each 100 milliseconds, and this code would run forever. To avoid this,
    we use the take function to put a limit into the collection, so we will get the
    first five values. Then, later, we subscribe to the observer, and when data is
    ready, our code will run. For the first sample, it''s pretty easy, we are just
    printing the values we have got. There is a thread sleep in this program, otherwise,
    the program would terminate, and you would not see any value on the console.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Observables，我们需要导入Scala Observable。确保你从Scala包中获取它，因为如果你获取Java版本，你将会遇到问题：在代码的第一个部分，我们将从0开始每100毫秒获取一个数字，这段代码将会无限期地运行。为了避免这种情况，我们使用take函数将限制放入集合中，这样我们就会得到前五个值。然后，稍后，我们订阅观察者，当数据准备好时，我们的代码将会运行。对于第一个示例，它非常简单，我们只是打印出我们得到的值。在这个程序中有一个线程休眠，否则程序将会终止，你将看不到控制台上的任何值。
- en: The second part of the code does something more interesting. First of all, it
    creates an Observable from a static list of values, which are 1,2,3, and 4\. We
    apply a reduce function into the elements, which will sum all the elements with
    each other, and then we subscribe and print the result.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二部分做了更有趣的事情。首先，它从一个静态值列表中创建了一个Observable，这些值是1、2、3和4。我们将一个reduce函数应用到这些元素上，它会将所有元素相加，然后我们订阅并打印结果。
- en: Complex Scala with RxScala Observables
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂的Scala与RxScala Observables
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding first part of the code creates an Observable with numbers from
    1 to 10, and then applies a `filter` function, which will get only the even numbers.
    It then reduces them, calculates their sum, and lastly, prints the solution. You
    can visualize it as depicted in the following image:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前一部分创建了一个从1到10的数字Observable，然后应用了一个`filter`函数，它只会获取偶数。然后它将它们相加，计算它们的总和，最后打印出解决方案。你可以将其可视化如下面的图像所示：
- en: '![Complex Scala with RxScala Observables](img/image00233.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![复杂的Scala与RxScala Observables](img/image00233.jpeg)'
- en: For the second part of the code, we create two different observables. The first
    one is with even numbers and the second one is with odd numbers. These two observables
    are decoupled from each other; you can control as many observables you want. Later
    on, the code uses a merge function to join these two observables into a third
    and new observable containing the content of the first and second observables.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码的第二部分，我们创建了两个不同的Observable。第一个是偶数，第二个是奇数。这两个Observable彼此解耦；你可以控制你想要的任意多个Observable。稍后，代码使用merge函数将这两个Observable合并成一个第三和新的Observable，它包含第一个和第二个Observable的内容。
- en: '![Complex Scala with RxScala Observables](img/image00234.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![复杂的Scala与RxScala Observables](img/image00234.jpeg)'
- en: Merging 2 Observables
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 合并2个Observables
- en: There are many functions and options, and you can see the whole list at [http://rxmarbles.com/](http://rxmarbles.com/)
    and [https://github.com/ReactiveX/RxScala](https://github.com/ReactiveX/RxScala).
    For the sake of simplicity, for now, we are just working with numbers. Later,
    we will use this to do more advance compositions including database calls and
    external web services calls.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多功能和选项，您可以在[http://rxmarbles.com/](http://rxmarbles.com/)和[https://github.com/ReactiveX/RxScala](https://github.com/ReactiveX/RxScala)查看完整列表。为了简化，目前我们只使用数字。稍后，我们将使用这些知识进行更高级的合成，包括数据库调用和外部Web服务调用。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basic concepts of FP, Reactive Programing, and
    the Scala language. We learned about the basic constructs of the Scala language
    and Functional Programming, functions, collections, and OO in Scala, and concurrent
    programming with Futures.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了FP（函数式编程）、响应式编程和Scala语言的基本概念。我们了解了Scala语言和函数式编程的基本结构，包括函数、集合、Scala中的面向对象编程，以及使用Futures的并发编程。
- en: Next, we will see how to use SBT to build Scala projects. We will learn how
    to compile and run Scala applications using SBT.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何使用SBT构建Scala项目。我们将学习如何使用SBT编译和运行Scala应用程序。
