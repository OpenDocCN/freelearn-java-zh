- en: Chapter 11. Clustering WildFly Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。WildFly 应用程序集群
- en: In the previous chapters, we went through the most interesting aspects of developing
    Java Enterprise applications. Once you are ready to roll out your applications,
    it is important that you guarantee your customers a responsive and fault-tolerant
    environment. This requirement can be achieved through application server clustering.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了开发 Java 企业应用程序最有趣的方面。一旦您准备好推出您的应用程序，确保您的客户获得响应迅速且容错的环境是非常重要的。这一需求可以通过应用服务器集群来实现。
- en: WildFly clustering is not the product of a single library or specification,
    but rather a blend of technologies. In this chapter, we will first introduce some
    of the basics of clustered programming. Then, we will quickly move on to the cluster
    configuration and its setup, which will be required to deploy some clustered applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 集群不是单一库或规范的产物，而是一系列技术的融合。在本章中，我们将首先介绍一些集群编程的基本知识。然后，我们将快速进入集群配置及其设置，这是部署一些集群应用程序所必需的。
- en: 'The following list is a preview of the topics that will be covered in this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是本章将要涵盖的主题预览：
- en: What clustering is and how WildFly implements it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群是什么以及 WildFly 如何实现它
- en: Setting up clusters in the standalone and domain mode
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在独立和域模式下设置集群
- en: Developing clustered Java EE 7 applications in order to achieve load balancing
    and high availability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发集群 Java EE 7 应用以实现负载均衡和高可用性
- en: Clustering basics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群基础知识
- en: A cluster of application servers consists of multiple server instances (cluster
    nodes) running simultaneously and working together to provide increased scalability
    and reliability. The nodes that make up a cluster can be located either on the
    same machine or different machines. From the client's point of view, this is irrelevant
    because the cluster appears as a single server instance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器集群由多个同时运行并协同工作以提供增强的可扩展性和可靠性的服务器实例（集群节点）组成。构成集群的节点可以位于同一台机器或不同的机器上。从客户端的角度来看，这并不重要，因为集群看起来就像一个单独的服务器实例。
- en: 'Introducing clustering in your applications will produce the following benefits:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中引入集群将产生以下好处：
- en: '**Horizontal scalability (scaling out)**: Adding a new node to a cluster should
    allow the overall system to service a higher client load than that provided by
    a simple basic configuration. Ideally, it should be possible to service any given
    load simply by adding the appropriate number of servers or machines.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平扩展（向外扩展）**：向集群中添加一个新节点应该允许整个系统服务比简单基本配置提供的更高的客户端负载。理想情况下，只需通过添加适当数量的服务器或机器就可以服务任何给定的负载。'
- en: '**Load balancing**: In a clustered environment, the individual nodes that compose
    the cluster should each process a fair share of the overall client load. This
    can be achieved by distributing client requests across multiple servers, which
    is also known as load balancing.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：在集群环境中，构成集群的各个节点应该各自处理整体客户端负载的公平份额。这可以通过在多个服务器之间分配客户端请求来实现，这也被称为负载均衡。'
- en: '**High availability**: Applications running in a cluster can continue to do
    so when a server instance fails. This is achieved because applications are deployed
    on multiple nodes of the cluster, and so if a server instance fails, another server
    instance on which that component is deployed can continue with application processing.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：当服务器实例失败时，运行在集群中的应用程序可以继续运行。这是通过将应用程序部署在集群的多个节点上实现的，因此如果服务器实例失败，另一个部署了该组件的服务器实例可以继续进行应用程序处理。'
- en: WildFly clustering
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WildFly 集群
- en: Clustering is available in WildFly out of the box. There is no all-in-one library
    that deals with clustering, but rather a set of libraries that cover different
    kinds of aspects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 中自带集群功能。没有处理集群的单一库，而是一组覆盖不同方面的库。
- en: 'The following diagram shows the basic clustering architecture adopted by WildFly:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了 WildFly 采纳的基本集群架构：
- en: '![WildFly clustering](img/00089.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![WildFly 集群](img/00089.jpeg)'
- en: The backbone of JBoss clustering is the **JGroups** library, which provides
    communication between members of the cluster using a multicast transmission.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss 集群的骨干是 **JGroups** 库，它通过多播传输在集群成员之间提供通信。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Multicast** is a protocol where data is transmitted simultaneously to a group
    of hosts that have joined the appropriate multicast group. You can think about
    multicast as a radio or television streaming where only those tuned to a particular
    frequency receive the streaming.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播**是一种协议，数据同时传输到已加入适当多播组的多个主机。你可以将多播想象成一种广播或电视流，只有调谐到特定频率的接收者才能接收到流。'
- en: The next building block is **Infinispan**, which handles the consistency of
    your application across the cluster by means of a replicated and transactional
    JSR-107-compatible cache.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个构建块是**Infinispan**，它通过一个复制和事务性的JSR-107兼容缓存来处理应用程序在集群中的一致性。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**JSR-107** specifies the API and semantics for temporary in-memory caching
    of Java objects, including object creation, shared access, spooling, invalidation,
    and consistency across JVMs.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSR-107**指定了Java对象临时内存缓存的API和语义，包括对象创建、共享访问、排队、失效和跨JVM的一致性。'
- en: 'Before diving into some cluster examples, we will first need to describe how
    to set up a cluster of WildFly nodes using the two available nodes: **standalone
    cluster** and **domain cluster**. If you don''t remember the difference between
    the **standalone** and **domain** mode or what core **domain** elements are, you
    can revise the material from [Chapter 2](part0017_split_000.html#page "Chapter 2. Your
    First Java EE Application on WildFly"), *Your First Java EE Application on WildFly*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨一些集群示例之前，我们首先需要描述如何使用两个可用的节点设置一个WildFly节点的集群：**独立集群**和**域集群**。如果你不记得**独立**和**域**模式之间的区别，或者核心**域**元素是什么，你可以复习[第2章](part0017_split_000.html#page
    "第2章。在WildFly上创建你的第一个Java EE应用程序")的内容，*在WildFly上创建你的第一个Java EE应用程序*。
- en: Starting a cluster of standalone nodes
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动独立节点集群
- en: 'A standalone server starts as a single JVM process; therefore, we need to start
    each server using the `standalone.bat/standalone.sh` command, passing all the
    required parameters. In the following example, we are starting a cluster of two
    server nodes on two different boxes that are bound to the IP addresses `192.168.1.10`
    and `192.168.1.11`, respectively:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 独立服务器以单个JVM进程启动；因此，我们需要使用`standalone.bat/standalone.sh`命令启动每个服务器，传递所有必需的参数。在以下示例中，我们正在启动两个不同机器上的两个服务器节点集群，分别绑定到IP地址`192.168.1.10`和`192.168.1.11`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `-c` parameter specifies the server configuration to be used; out of the
    box, the application server includes two standalone clustering configurations:
    `standalone-ha.xml` and `standalone-full-ha.xml`. The latter one also includes
    the messaging subsystem and other elements of the Java EE full profile; therefore,
    it has been named the *full* configuration.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c`参数指定要使用的服务器配置；默认情况下，应用程序服务器包括两个独立的集群配置：`standalone-ha.xml`和`standalone-full-ha.xml`。后者还包括Java
    EE完整配置的消息子系统和其他元素；因此，它被称为**完整**配置。'
- en: The other parameter (`-b`) should sound familiar to older JBoss users, as it's
    still used to specify the server-binding address, which needs to be unique in
    order to avoid port conflicts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个参数（`-b`）应该对老版本的JBoss用户来说很熟悉，因为它仍然用于指定服务器绑定地址，该地址需要是唯一的，以避免端口冲突。
- en: 'In this other example, we are starting another cluster of two nodes on the
    same box using some additional parameters in order to avoid port conflicts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个其他示例中，我们正在同一台机器上启动另一个由两个节点组成的集群，使用一些额外的参数以避免端口冲突：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we had to specify two additional parameters: `jboss.node.name`
    in order to assign a unique server name to each node and a socket-binding port,
    which uses an offset of `200`. So, for example, the second node would respond
    to the HTTP channel on port `8280` instead of port `8080`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不得不指定两个额外的参数：`jboss.node.name`，以便为每个节点分配一个唯一的服务器名称，以及一个套接字绑定端口，它使用`200`的偏移量。例如，第二个节点将响应HTTP通道上的端口`8280`而不是端口`8080`。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't be surprised if you don't see any message about clustering on your server
    console. Clustering modules are activated on demand, so first you need to deploy
    an application that is cluster-aware. In a few minutes, we will show you how.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在服务器控制台上没有看到任何关于集群的消息，请不要感到惊讶。集群模块是按需激活的，所以首先你需要部署一个集群感知的应用程序。在几分钟内，我们将向你展示如何做。
- en: Starting a cluster of domain nodes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动域节点集群
- en: In order to configure a cluster running on a domain of server nodes, you need
    to configure the main `domain.xml` file for your domain controller. Then, for
    every WildFly host that is a part of the cluster, you need to provide a `host.xml`
    configuration file, which describes the configuration of a single-server distribution.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置在服务器节点域上运行的集群，您需要配置域控制器的`domain.xml`主文件。然后，对于集群中的每个WildFly主机，您需要提供一个`host.xml`配置文件，该文件描述了单个服务器分布的配置。
- en: The domain controller configuration
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 域控制器配置
- en: 'The `domain.xml` file is located at `JBOSS_HOME/domain/configuration/`. It
    includes the main domain configuration, which is shared by all server instances.
    In the `domain.xml` file, we will define the server group configurations specifying
    a profile that is compatible with clustering. Out of the box, a WildFly domain
    ships with four different profiles:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`domain.xml`文件位于`JBOSS_HOME/domain/configuration/`。它包括主域配置，该配置由所有服务器实例共享。在`domain.xml`文件中，我们将定义服务器组配置，指定一个与集群兼容的配置文件。默认情况下，WildFly域附带四个不同的配置文件：'
- en: '`default`: This profile has the support of Java EE Web Profile and some extensions,
    such as RESTful web services, or support for **Enterprise JavaBeans** (**EJB**)
    3 remote invocations'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：此配置文件支持Java EE Web Profile和一些扩展，例如RESTful Web服务，或支持**企业JavaBeans**（**EJB**）3远程调用'
- en: '`full`: This profile supports all the default subsystems contained in the default
    profile and the messaging subsystem'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full`：此配置文件支持默认配置文件中包含的所有默认子系统以及消息子系统'
- en: '`ha`: This profile corresponds to the `default` profile extended with clustering
    capabilities'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ha`：此配置文件对应于扩展了集群功能的`default`配置文件'
- en: '`full-ha`: This is the `full` profile with clustering capabilities'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full-ha`：这是具有集群功能的`full`配置文件'
- en: 'So, first specify a cluster-aware profile for your server groups in your `domain.xml`
    file. In our example, we have adopted the `full-ha` profile for both the server
    groups so that you can run the full Java EE stack on all your domain servers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先在您的`domain.xml`文件中为您的服务器组指定一个集群感知配置文件。在我们的示例中，我们为服务器组采用了`full-ha`配置文件，这样您就可以在所有域服务器上运行完整的Java
    EE堆栈：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When using a `full-ha` profile, you need to configure HornetQ clustering security.
    You can just disable it, or you need to additionally set a completely random user
    credential for a JMS cluster. Find the profile settings in `domain.xml`, and add
    the following code to the messaging subsystem:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`full-ha`配置文件时，您需要配置HornetQ集群安全性。您可以简单地禁用它，或者您还需要为JMS集群设置一个完全随机的用户凭据。在`domain.xml`中找到配置设置，并将以下代码添加到消息子系统：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition to the `domain.xml` file, you need to check whether your domain
    controller''s `host.xml` file contains a reference to the local host, as shown
    in the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`domain.xml`文件外，您还需要检查您的域控制器的`host.xml`文件是否包含对本地主机的引用，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `local` stanza means that this host controller will take the role of a domain
    controller. For all other hosts controllers, you must specify the remote domain
    controller host and its port (in this example, we added some variables as placeholders).
    We will cover them in the next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`local`部分表示该主机控制器将扮演域控制器的角色。对于所有其他主机控制器，您必须指定远程域控制器的主机和端口（在本例中，我们添加了一些变量作为占位符）。我们将在下一节中介绍它们。'
- en: 'Finally, you need to create a management user that will be used to establish
    a connection between the slave nodes and the domain controller. For this purpose,
    launch the `add-user.sh/add-user.cmd` script, which is located in the `JBOSS_HOME/bin`
    directory of your distribution:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要创建一个管理用户，该用户将用于在从节点和域控制器之间建立连接。为此，启动位于您分发`JBOSS_HOME/bin`目录中的`add-user.sh/add-user.cmd`脚本：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from the preceding listing, you have to create a management user
    by specifying a username and password for it. You should answer the previous question
    with either `yes` or `y` to indicate that the user will be used to connect to
    the domain controller from the host controller. The generated secret value is
    the Base64-encoded password of the newly created user.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您必须通过指定用户名和密码来创建一个管理用户。您应该用`yes`或`y`回答前面的问题，以表示该用户将用于从主机控制器连接到域控制器。生成的密钥值是新创建用户的Base64编码密码。
- en: 'Now we can start the domain controller by specifying the address that will
    be used for public and management interfaces (in our example, `192.168.1.10`)
    with the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过指定用于公共和管理接口的地址（在我们的示例中为`192.168.1.10`）来启动域控制器，以下命令：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have set the bind address of the physical network to the host configuration
    with the `jboss.bind.address.management` property. The management interface must
    be reachable for all the hosts in the domain in order to establish a connection
    with the domain controller.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将物理网络的绑定地址设置为具有`jboss.bind.address.management`属性的宿主配置。管理接口必须对所有域中的主机可访问，以便与域控制器建立连接。
- en: Host configurations
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主机配置
- en: After the domain controller is configured and started, the next step is to set
    up the other hosts that will connect to the domain controller. On each host, we
    also need an installation of WildFly, where we will configure the `host.xml` file.
    (As an alternative, you can name the host file as you like and start the domain
    with the `-host-config` parameter, for example, `./domain.sh -host-config=host-slave.xml`.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置并启动域控制器之后，下一步是设置将连接到域控制器的其他主机。在每个主机上，我们还需要安装WildFly，我们将配置`host.xml`文件。（作为替代，您可以根据需要命名主机文件，并通过`-host-config`参数启动域，例如，`./domain.sh
    -host-config=host-slave.xml`。）
- en: The first thing is to choose a unique name for each host in our domain in order
    to avoid name conflicts. Otherwise, the default is the hostname of the server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是为我们域中的每个主机选择一个唯一名称，以避免名称冲突。否则，默认为服务器的主机名。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Also, you have to choose a unique name for the other host:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还必须为另一个主机选择一个唯一名称：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we need to specify that the host controller will connect to a remote domain
    controller. We will not specify the actual IP address of the domain controller
    but leave it as a property named `jboss.domain.master.address`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定主机控制器将连接到远程域控制器。我们不会指定域控制器的实际IP地址，而是将其留为名为`jboss.domain.master.address`的属性。
- en: 'Additionally, we need to specify the username that will be used to connect
    to the domain controller. So let''s add the user `admin1234`, which we created
    on the domain controller machine:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要指定用于连接域控制器的用户名。因此，让我们添加在域控制器机器上创建的用户`admin1234`：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we need to specify the Base64 password for the server identity that
    we included in the `remote` element:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要指定包含在`remote`元素中的服务器身份的Base64密码：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The final step is to configure the server nodes inside the `host.xml` file
    on both the hosts. So, on the first host, we will configure `server-one` and `server-two`
    to add them to `main-server-group`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在两个主机上的`host.xml`文件中配置服务器节点。因此，在第一个主机上，我们将配置`server-one`和`server-two`以将它们添加到`main-server-group`：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the second host, we will configure `server-three` and `server-four` to add
    them to `other-server-group`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个主机上，我们将配置`server-three`和`server-four`以将它们添加到`other-server-group`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that the `auto-start` flag value indicates that the server instances
    will not be started automatically if the host controller is started.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`auto-start`标志的值表示如果主机控制器启动，服务器实例将不会自动启动。
- en: 'For `server-two` and `server-four`, a `port-offset` value of `150` is configured
    to avoid port conflicts. Okay, now we are done with our configuration. Assuming
    that the first host has an IP address of `192.168.1.10`, we can start the first
    host with the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`server-two`和`server-four`，已配置`port-offset`值为`150`以避免端口冲突。好吧，现在我们已经完成了我们的配置。假设第一个主机的IP地址为`192.168.1.10`，我们可以使用以下代码片段启动第一个主机：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second host (`192.168.1.11`) can be started with the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主机（`192.168.1.11`）可以使用以下代码片段启动：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Deploying clustered applications
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署集群应用程序
- en: 'If you have tried starting your standalone or domain set of cluster nodes,
    you will be surprised that there is no information at all about clustering in
    your server logging. Believe me, it is not a bug but a feature! One of the key
    features of WildFly is that only a minimal set of services is started; therefore,
    in order to see a cluster''s live demonstration, you need to deploy a cluster-aware
    application. In order to trigger clustering libraries in your application, you
    can follow two approaches:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试启动您的独立或域集的集群节点，您可能会惊讶地发现您的服务器日志中完全没有关于集群的信息。相信我，这不是一个错误，而是一个特性！WildFly的一个关键特性是只启动最小的一组服务；因此，为了看到集群的实时演示，您需要部署一个集群感知的应用程序。为了在您的应用程序中触发集群库，您可以遵循两种方法：
- en: If your application uses Enterprise JavaBeans, you don't have to do anything
    more. This area brings some important changes in WildFly. Now, by default, the
    data of all stateful session beans is replicated in HA profiles, and all stateless
    beans are clustered. If your application is deployed on a container started with
    the `standalone-ha.xml` configuration, all remote **Stateless Session Bean** (**SLSB**)
    support failover capabilities by default.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的应用程序使用企业JavaBeans，您不需要做任何事情。这个区域带来了WildFly的一些重要变化。现在，默认情况下，所有状态会话Bean的数据都在HA配置文件中进行复制，所有无状态Bean都是集群化的。如果您的应用程序部署在以`standalone-ha.xml`配置启动的容器上，所有远程**无状态会话Bean**（**SLSB**）默认支持故障转移功能。
- en: If your application includes a web application archive, you can use the portable
    `<distributable />` element in your `web.xml` file.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的应用程序包含一个Web应用程序存档，您可以在`web.xml`文件中使用可移植的`<distributable />`元素。
- en: Let's have a look at both the approaches, starting from clustering EJBs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看两种方法，从集群EJB开始。
- en: Creating HA Stateful Session Beans
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建高可用性（HA）状态会话Bean
- en: Clustered **Stateful Session Beans** (**SFSB**) have built-in failover capabilities.
    This means that the state of `@Stateful` EJBs is replicated across the cluster
    nodes so that if one of the nodes in the cluster goes down, some other node will
    be able to take over the invocations addressed to it. It is possible to disable
    this feature for specific beans using the `@Stateful(passivationCapable=false)`
    annotation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 集群**状态会话Bean**（**SFSB**）具有内置的故障转移能力。这意味着`@Stateful` EJB的状态在集群节点之间进行复制，以便如果集群中的某个节点发生故障，其他节点将能够接管指向它的调用。可以通过使用`@Stateful(passivationCapable=false)`注解来为特定Bean禁用此功能。
- en: 'The following diagram depicts a typical exchange of information between the
    EJB client application and the remote EJB component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了EJB客户端应用程序和远程EJB组件之间典型的信息交换：
- en: '![Creating HA Stateful Session Beans](img/00090.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![创建高可用性状态会话Bean](img/00090.jpeg)'
- en: As you can see, after a successful lookup of an SFSB via **Java Naming and Directory
    Interface** (**JNDI**), a proxy is returned to the client for subsequent method
    invocations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过**Java命名和目录接口**（**JNDI**）成功查找SFSB后，会返回一个代理给客户端用于后续的方法调用。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the EJB is clustered, it will return a session ID and along with it the
    *affinity* of that session, that is, the name of the cluster to which the stateful
    bean belongs to on the server side. This affinity will later help the EJB client
    to route the invocations on the proxy appropriately to a specific node in the
    cluster.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于EJB是集群化的，它将返回一个会话ID，以及与它一起的会话的*亲和力*，即状态会话Bean在服务器端所属的集群名称。这种亲和力将有助于EJB客户端将代理上的调用适当地路由到集群中的特定节点。
- en: While this session creation request is going on, **NodeA** will also send back
    an asynchronous message that contains the cluster topology. The JBoss **EJB Client**
    implementation will take note of this topology information and will later use
    it to create connections to the nodes within the cluster and route invocations
    to those nodes, whenever necessary.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此会话创建请求进行的同时，**NodeA**也会发送一个包含集群拓扑结构的异步消息。JBoss **EJB客户端**实现将注意这个拓扑信息，并在以后使用它来创建与集群内节点的连接，并在必要时将调用路由到这些节点。
- en: 'Now let''s assume that **NodeA** goes down and the client application subsequently
    invokes on the proxy. At this stage, the **JBoss EJB Client** implementation will
    be aware of the cluster topology; therefore, it knows that the cluster has two
    nodes: **NodeA** and **NodeB**. Now when the invocation arrives, it detects that
    **NodeA** is down, so it uses a selector to fetch a suitable node from among the
    cluster nodes. This exchange is shown in the following diagram:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假设**NodeA**发生故障，客户端应用程序随后在代理上调用。在这个阶段，**JBoss EJB客户端**实现将了解集群拓扑；因此，它知道集群有两个节点：**NodeA**和**NodeB**。现在当调用到达时，它检测到**NodeA**已关闭，因此它使用选择器从集群节点中获取一个合适的节点。此交换在以下图中显示：
- en: '![Creating HA Stateful Session Beans](img/00091.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![创建高可用性状态会话Bean](img/00091.jpeg)'
- en: If a suitable node is found, the **JBoss EJB Client** implementation creates
    a connection to that node (in our case **NodeB**) and creates an EJB receiver
    out of it. At the end of this process, the invocation has now been effectively
    failed over to a different node within the cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到合适的节点，**JBoss EJB客户端**实现将创建到该节点的连接（在我们的案例中是**NodeB**），并从中创建一个EJB接收器。在此过程结束时，调用现在已被有效地故障转移到集群内的另一个节点。
- en: Clustering the Ticket example
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集群票务示例
- en: 'In [Chapter 3](part0023_split_000.html#page "Chapter 3. Introducing Java EE
    7 – EJBs"), *Introducing Java EE 7 – EJBs*, we discussed our ticket system example,
    which was built around the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0023_split_000.html#page "第3章。介绍Java EE 7 – EJBs")，*介绍Java EE 7 –
    EJBs*中，我们讨论了我们的票务系统示例，该示例围绕以下内容构建：
- en: A stateful EJB to hold the session data
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储会话数据的具有状态的EJB
- en: A singleton EJB to store the cache of data
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储数据缓存的单例EJB
- en: A stateless EJB to perform some business methods
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于执行一些业务方法的无状态EJB
- en: Let's see how to apply the necessary changes to start our application in a cluster
    context.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何应用必要的更改以在集群上下文中启动我们的应用程序。
- en: The stateless and stateful beans are ready to be clustered—no additional code
    is required; however, there's a pitfall. As a matter of fact, the singleton EJB
    that is used to hold the cache of a seat will be instantiated once in each JVM
    of the cluster. This means that if there's a server failure, the data in the cache
    will be lost and new data (inconsistent) will be used.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态和有状态的Bean已准备好进行集群化——不需要额外的代码；然而，存在一个陷阱。实际上，用于存储座位缓存的单例EJB将在集群中的每个JVM中实例化一次。这意味着如果服务器发生故障，缓存中的数据将会丢失，并且将使用新的数据（不一致的数据）。
- en: 'There are several alternatives to set up a cache in a clustered environment:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群环境中设置缓存有几种替代方案：
- en: Use a JBoss proprietary solution that deploys a clustered version of `SingletonService`,
    which exposes an HA singleton of `org.jboss.msc.service.Service` (an example of
    this approach is contained in the WildFly quickstart demo at [https://github.com/wildfly/quickstart/tree/master/cluster-ha-singleton](https://github.com/wildfly/quickstart/tree/master/cluster-ha-singleton))
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JBoss专有解决方案，该解决方案部署了`SingletonService`的集群版本，该版本公开了`org.jboss.msc.service.Service`的HA单例（此方法的示例包含在WildFly快速入门演示中，[https://github.com/wildfly/quickstart/tree/master/cluster-ha-singleton](https://github.com/wildfly/quickstart/tree/master/cluster-ha-singleton)）
- en: Move your cache to a persistent storage, which means using JPA to store and
    read data from the cache (see [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining
    Persistence with CDI"), *Combining Persistence with CDI*, which includes a JPA-based
    example of our application)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的缓存移动到持久存储，这意味着使用JPA从缓存中存储和读取数据（参见[第5章](part0030_split_000.html#page "第5章。将持久性与CDI结合"，*将持久性与CDI结合*，其中包含我们应用程序基于JPA的示例）
- en: Use a distributed data cache such as Infinispan to store data, providing a failover
    and data consistency to your cache
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分布式数据缓存，如Infinispan来存储数据，为您的缓存提供故障转移和数据一致性
- en: Showing all the possible solution implementations would, however, make this
    section excessively long; therefore, we will illustrate how to use the last option,
    which can provide a good architectural pattern with the least amount of effort.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，展示所有可能的解决方案实现会使本节内容过长；因此，我们将说明如何使用最后一种选项，它可以以最少的努力提供良好的架构模式。
- en: Turning your cache into a distributed cache
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将您的缓存转换为分布式缓存
- en: Infinispan is a distributed data grid platform that exposes a JSR-107-compatible
    cache interface in which you can store data and enhance it by providing additional
    APIs and features (such as transactional cache, data eviction and expiration,
    asynchronous operations on the cache, and more). Its primary interface is `javax.cache.Cache`,
    which is similar to the `java.util.ConcurrentMap` Java SE, with some modifications
    for distributed environments. In particular, it adds the ability to register,
    deregister, and list event listeners. Also, it defines a `CacheLoader` interface
    to load/store cached data. Cache instances can be retrieved using an appropriate
    `CacheManager` interface, which represents a collection of caches.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Infinispan是一个分布式数据网格平台，它提供了一个JSR-107兼容的缓存接口，您可以在其中存储数据，并通过提供额外的API和功能（如事务性缓存、数据驱逐和过期、缓存上的异步操作等）来增强它。它的主要接口是`javax.cache.Cache`，类似于Java
    SE中的`java.util.ConcurrentMap`，但在分布式环境中进行了一些修改。特别是，它增加了注册、注销和列出事件监听器的功能。此外，它定义了一个`CacheLoader`接口来加载/存储缓存数据。可以使用适当的`CacheManager`接口检索缓存实例，它代表了一组缓存。
- en: 'So here''s our singleton `TheatreBox` class rewritten using the Infinispan
    API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是使用Infinispan API重写的我们的单例`TheatreBox`类：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing we want to stress on is the `@Resource` annotation, which injects
    an `EmbeddedCacheManager` instance. When the WildFly deployer encounters this
    annotation, your application will include a dependency on the requested cache
    container. Consequently, the cache container will automatically start during deployment
    and stop (including all caches) during undeployment of your application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想强调的是`@Resource`注解，它注入一个`EmbeddedCacheManager`实例。当WildFly部署器遇到这个注解时，您的应用程序将包含对请求的缓存容器的依赖。因此，缓存容器将在部署期间自动启动，并在您的应用程序卸载期间停止（包括所有缓存）。
- en: Subsequently, when the EJB is instantiated (see the method `start`, which is
    annotated as `@PostConstruct`), `org.infinispan.Cache` is created using `EmbeddedCacheManager`
    as a factory. This cache will be used to store our highly available set of data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，当EJB被实例化时（请参阅标记为`@PostConstruct`的`start`方法），使用`EmbeddedCacheManager`作为工厂创建`org.infinispan.Cache`。这个缓存将用于存储我们高度可用的数据集。
- en: 'The operations performed against the distributed cache are quite intuitive:
    the `put` method is used to store instances of the `Seat` object in the cache
    and the corresponding `get` method is used to retrieve elements from it, just
    what you would do using an ordinary hashmap. The only difference is that in our
    clustered cache, every entry must be serializable. Be sure to mark `Seat` as `Serializable`
    and create a default constructor for it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对分布式缓存执行的操作相当直观：`put`方法用于将`Seat`对象的实例存储在缓存中，相应的`get`方法用于从中检索元素，这正是您使用普通hashmap所做的事情。唯一的区别是，在我们的集群缓存中，每个条目都必须是可序列化的。请确保将`Seat`标记为`Serializable`并为它创建一个默认构造函数。
- en: 'As far as application deployment is concerned, you need to state a dependency
    to the Infinispan API explicitly, which is not included as an implicit dependency
    in WildFly''s class-loading policy. This is most easily done by adding the following
    line to your application''s `META-INF/MANIFEST.MF`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用部署方面，您需要明确声明对Infinispan API的依赖，因为在WildFly的类加载策略中，它并未作为隐式依赖项包含。这可以通过将以下行添加到您的应用程序的`META-INF/MANIFEST.MF`文件中来实现：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We additionally need to add the new cache container to the appropriate profile
    in our `domain.xml` file (in the Infinispan subsystem):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将新的缓存容器添加到我们的`domain.xml`文件中适当的配置文件（在Infinispan子系统内）：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In our sample, we are using the `seats.values()` call to get all the elements
    from our distributed map, which is in fact an instance of `org.infinispan.Cache`.
    This operation is normally discouraged in distributed caches (not replicated)
    and has its own limitations. Check out the Javadoc for this method at [https://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/Cache.html#values()](https://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/Cache.html#values())
    for more information. This is however, no longer the case for the newest version
    of Infinispan: [http://infinispan.org/infinispan-7.0/](http://infinispan.org/infinispan-7.0/).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`seats.values()`调用从我们的分布式映射（实际上是`org.infinispan.Cache`的一个实例）中获取所有元素。这种操作在分布式缓存（非复制）中通常是不推荐的，并且有其自身的限制。有关此方法的更多信息，请查看[https://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/Cache.html#values()](https://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/Cache.html#values())的Javadoc。然而，对于Infinispan的最新版本来说，情况已经不再是这样了：[http://infinispan.org/infinispan-7.0/](http://infinispan.org/infinispan-7.0/)。
- en: Coding the cluster-aware remote client
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写集群感知的远程客户端
- en: The remote EJB client will not need any particular change in order to be able
    to achieve high availability.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 远程EJB客户端不需要进行任何特定的更改，以便能够实现高可用性。
- en: 'We will only need to prepare a `jboss-ejb-client.properties` file, which will
    contain the list of servers that will be initially contacted (via remoting) by
    our client application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要准备一个`jboss-ejb-client.properties`文件，该文件将包含我们的客户端应用程序最初将通过远程通信联系到的服务器列表：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see from this file, we assume that you are running a two-node cluster
    on the `localhost` address: the first one running the default port settings and
    the second one using an offset of `200` (just as shown in the second paragraph
    of the *Starting a cluster of standalone nodes* section).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本文件中可以看到，我们假设您正在使用`localhost`地址运行一个双节点集群：第一个节点使用默认端口设置，第二个节点使用偏移量`200`（正如在“启动独立节点集群”部分的第二段中所示）。
- en: Replace the `remote.connection.nodeX.host` variable's value with the actual
    IP or host if you are running your server nodes on different machines from your
    client.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的服务器节点和客户端在不同的机器上运行，请将`remote.connection.nodeX.host`变量的值替换为实际的IP或主机。
- en: Deploying and testing high availability
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署和测试高可用性
- en: Deploying an application to a cluster can be achieved in several ways; if you
    prefer automation instead of manually copying each archive into the `deployments`
    folder, you can reuse the CLI deployment script contained in the previous chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到集群可以通过几种方式实现；如果您更喜欢自动化而不是手动将每个存档复制到 `deployments` 文件夹，您可以重用前一章中包含的 CLI
    部署脚本。
- en: 'Alternatively, if you are using the WildFly Maven plugin to deploy, you can
    parameterize its configuration, including the hostname and the port as variables,
    which will be passed to the command line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您正在使用 WildFly Maven 插件进行部署，您可以参数化其配置，包括主机名和端口号作为变量，这些变量将被传递到命令行：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Therefore, you will use the following shell to compile the package and deploy
    the application on the first node:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将使用以下 shell 编译包并在第一个节点上部署应用程序：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the second node, you will use the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个节点，您将使用以下内容：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Deploying the application in the domain node works the same as mentioned in
    the preceding example, except that you need to add the `domain` tag to your configuration
    and need to specify at least one server group. Visit [https://docs.jboss.org/wildfly/plugins/maven/latest/examples/deployment-example.html](https://docs.jboss.org/wildfly/plugins/maven/latest/examples/deployment-example.html)
    for more information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在域节点上部署应用程序与前面示例中提到的相同，除了您需要将 `domain` 标签添加到您的配置中，并且需要指定至少一个服务器组。有关更多信息，请访问
    [https://docs.jboss.org/wildfly/plugins/maven/latest/examples/deployment-example.html](https://docs.jboss.org/wildfly/plugins/maven/latest/examples/deployment-example.html)。
- en: 'Once you have deployed both the applications on your server node, you should
    be able to see the cluster view in the server console logs and also see that the
    Infinispan cache has been started and has discovered other nodes in the cluster.
    You should see something similar to the following on one of the nodes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在服务器节点上部署了这两个应用程序，您应该能够在服务器控制台日志中看到集群视图，并且可以看到 Infinispan 缓存已启动并已发现集群中的其他节点。您应该在其中一个节点上看到以下类似内容：
- en: '![Deploying and testing high availability](img/00092.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![部署和测试高可用性](img/00092.jpeg)'
- en: 'Before you launch your application, update Maven''s `exec` plugin information,
    which should now reference our remote EJB client application as shown in the highlighted
    section of the following code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在您启动应用程序之前，更新 Maven 的 `exec` 插件信息，现在它应该引用以下代码片段中突出显示部分所示我们的远程 EJB 客户端应用程序。
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can run it using the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行它：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first part of the client will show the evidence that we have successfully
    completed the first transaction. On the client console, you will see the return
    value of the booking transaction and the `Seat` list, as shown in the following
    screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的第一部分将显示我们已经成功完成第一笔交易的证据。在客户端控制台，您将看到预订交易的返回值和 `Seat` 列表，如下面的屏幕截图所示：
- en: '![Deploying and testing high availability](img/00093.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![部署和测试高可用性](img/00093.jpeg)'
- en: 'The following screenshot shows the server node where our EJB client landed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了我们的 EJB 客户端到达的服务器节点：
- en: '![Deploying and testing high availability](img/00094.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![部署和测试高可用性](img/00094.jpeg)'
- en: Now shut down the preceding server node (*Ctrl* + *C* would suffice if you are
    starting it as a foreground process) and press *Enter* (or *Return* on a Mac)
    on the client application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关闭前面的服务器节点（如果您以前台进程启动，则按 *Ctrl* + *C* 即可）并在客户端应用程序上按 *Enter*（或在 Mac 上按 *Return*）。
- en: As you can see from the following screenshot, you should see that the session
    continues to run on the survivor node and correctly displays the session values
    (the money left). Your client window should also display the updated cache information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下屏幕截图中所见，您应该看到会话在幸存节点上继续运行并正确显示会话值（剩余金额）。您的客户端窗口也应显示更新的缓存信息。
- en: '![Deploying and testing high availability](img/00095.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![部署和测试高可用性](img/00095.jpeg)'
- en: Web application clustering
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 应用程序集群
- en: 'Web application clustering involves two aspects: setting up an HTTP load balancer
    and telling WildFly to make the application''s user sessions as HA. How to do
    the former depends on what load balancer you would choose (`mod_cluster` is our
    suggested choice—it is preconfigured and integrates with WildFly out of the box);
    the latter could not be simpler—just add the `<distributable/>`tag to your application''s
    `web.xml` file. Whenever a node fails, the user''s HTTP session will be handled
    by another one. If everything goes well, the end user will not know that there
    was a failure—everything will be handled behind the scenes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用集群涉及两个方面：设置HTTP负载均衡器和告诉WildFly使应用程序的用户会话具有高可用性。如何做前者取决于你选择的负载均衡器（我们建议选择`mod_cluster`——它是预配置的，并且与WildFly无缝集成）；后者非常简单——只需将`<distributable/>`标签添加到你的应用程序的`web.xml`文件中。每当一个节点失败时，用户的HTTP会话将由另一个节点处理。如果一切顺利，最终用户将不知道发生了故障——所有的事情都会在幕后处理。
- en: Let's see how to action both these steps in concrete terms.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体看看如何执行这两个步骤。
- en: Load balancing your web applications
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载均衡您的Web应用
- en: 'You have several choices available in order to achieve load balancing of your
    HTTP requests. You can opt for a hardware load balancer that sits in front of
    your cluster of servers or you can choose from the many available software solutions
    for WildFly, which include the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种选择可以实现HTTP请求的负载均衡。你可以选择一个硬件负载均衡器，它位于你的服务器集群之前，或者你可以从许多可用的WildFly软件解决方案中选择，包括以下内容：
- en: Use Apache Tomcat's `mod_jk` module to route your requests to your nodes
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Tomcat的`mod_jk`模块将你的请求路由到你的节点
- en: Use Apache `mod_proxy` that configures Apache to act as a proxy server and forwards
    requests to WildFly nodes
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache `mod_proxy`配置Apache作为代理服务器并将请求转发到WildFly节点
- en: Use WildFly's built-in solution `mod_cluster` to achieve dynamic load balancing
    of your requests
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WildFly的内置解决方案`mod_cluster`来实现请求的动态负载均衡
- en: 'Here, we will illustrate how to get started with `mod_cluster`—a module for
    the Apache HTTP server. The advantage of using `mod_cluster` against other options
    can be summarized in the following key points:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将说明如何开始使用`mod_cluster`——Apache HTTP服务器的模块。使用`mod_cluster`相对于其他选项的优势可以总结如下要点：
- en: Dynamic clustering configuration
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态集群配置
- en: Server-side pluggable load metrics
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端可插拔负载度量
- en: Life cycle notifications of the application status
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序状态的生命周期通知
- en: As a matter of fact, when using a standard load balancer such as `mod_jk`, you
    have to provide a static list of nodes that is used to spread the load. This is
    a very limiting factor, especially if you have to deliver upgrades to your configuration
    by adding or removing nodes; alternatively, you simply need to upgrade software
    used by single nodes. Besides this, using a flat cluster configuration can be
    tedious and it is prone to errors, especially if the number of cluster nodes is
    high.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当使用标准负载均衡器如`mod_jk`时，你必须提供一个静态节点列表，该列表用于分配负载。这是一个非常限制性的因素，特别是如果你需要通过添加或删除节点来升级你的配置；或者，你可能只需要升级单个节点使用的软件。除此之外，使用平面集群配置可能会很繁琐，并且容易出错，尤其是当集群节点数量很多时。
- en: When using `mod_cluster`, you can dynamically add or remove nodes from your
    cluster because cluster nodes are discovered through an advertising mechanism.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`mod_cluster`时，你可以动态地向你的集群中添加或删除节点，因为集群节点是通过广告机制发现的。
- en: In practice, the `mod_cluster` libraries on the HTTP side send UDP messages
    on a multicast group, which is subscribed by WildFly nodes. This allows WildFly
    nodes to automatically discover HTTP proxies when application life cycle notifications
    are sent.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，HTTP侧的`mod_cluster`库在多播组上发送UDP消息，该组由WildFly节点订阅。这允许当发送应用程序生命周期通知时，WildFly节点自动发现HTTP代理。
- en: 'The next diagram illustrates this concept better:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表更好地说明了这个概念：
- en: '![Load balancing your web applications](img/00096.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![负载均衡您的Web应用](img/00096.jpeg)'
- en: Installing mod_cluster
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装mod_cluster
- en: The `mod_cluster` module is implemented as a core WildFly module, which is a
    part of the distribution. On the HTTP side, it is available as a set of libraries
    installed on the Apache web server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod_cluster`模块作为WildFly的核心模块实现，它是分发的一部分。在HTTP方面，它作为一组安装在Apache Web服务器上的库提供。'
- en: 'On the WildFly side, you can find the `mod_cluster` module''s subsystem already
    bundled as part of the clustered configuration file. You can locate it in either
    the `standalone-ha.xml` file or the `standalone-full-ha.xml` (and of course in
    the `domain.xml` file) configuration file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在WildFly方面，您可以在集群配置文件中找到已捆绑的`mod_cluster`模块的子系统。您可以在`standalone-ha.xml`文件或`standalone-full-ha.xml`（当然在`domain.xml`文件）配置文件中找到它：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The subsystem contains just a bare-bones configuration that references its
    socket binding through the `advertise-socket` element:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 子系统仅包含一个裸骨配置，通过`advertise-socket`元素引用其套接字绑定：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On the Apache web server side, we have to install the core libraries that are
    used to interact with `mod_cluster`. This is a very simple procedure; just point
    the browser to the latest `mod_cluster` release at [http://www.jboss.org/mod_cluster/downloads](http://www.jboss.org/mod_cluster/downloads).
    Be sure to choose a version that suits your operating system and architecture
    (x86 or x64).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apache网络服务器方面，我们必须安装用于与`mod_cluster`交互的核心库。这是一个非常简单的步骤；只需将浏览器指向最新的`mod_cluster`发布版，在[http://www.jboss.org/mod_cluster/downloads](http://www.jboss.org/mod_cluster/downloads)。请确保选择适合您的操作系统和架构（x86或x64）的版本。
- en: Once the binaries are downloaded, extract the archive to a folder; then, navigate
    to the extracted folder. The `mod_cluster` binaries essentially consist of a bundled
    Apache web server with all the required libraries installed. To preconfigure your
    installation, be sure to run the `\httpd-2.2\bin\installconf.bat` file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载了二进制文件，将存档提取到一个文件夹中；然后，导航到提取的文件夹。`mod_cluster`的二进制文件基本上是一个捆绑了所有必需库的Apache网络服务器。为了预配置您的安装，请确保运行`\httpd-2.2\bin\installconf.bat`文件。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to use your own Apache web server 2.2 installation; just pick
    up the modules from the `mod_cluster` bundle and copy them to the `modules` folder
    of your Apache web server.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用自己的Apache web服务器2.2安装；只需从`mod_cluster`捆绑中提取模块并将它们复制到您的Apache网络服务器的`modules`文件夹中。
- en: 'If you choose to use your own Apache web server over the bundled one, you have
    to load the following libraries into your `httpd.conf` file (the same set is used
    in the bundled Apache HTTP):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择使用自己的Apache网络服务器而不是捆绑的版本，您必须将以下库加载到您的`httpd.conf`文件中（与捆绑的Apache HTTP使用相同的集合）：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each of these modules covers an important aspect of load balancing, listed
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块中的每一个都涵盖了负载均衡的重要方面，如下所示：
- en: '`mod_proxy`, `mod_proxy_http`, and `mod_proxy_ajp`: These are the core modules
    that forward requests to cluster nodes using either the HTTP/HTTPS or AJP protocol'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod_proxy`、`mod_proxy_http`和`mod_proxy_ajp`：这些是核心模块，它们使用HTTP/HTTPS或AJP协议将请求转发到集群节点'
- en: '`mod_manager`: This module reads the information from AS 7 and updates the
    shared memory information in conjunction with `mod_slotmem`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod_manager`：此模块从AS 7读取信息，并与`mod_slotmem`一起更新共享内存信息'
- en: '`mod_proxy_cluster`: This module contains the balancer for `mod_proxy`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod_proxy_cluster`：此模块包含`mod_proxy`的均衡器'
- en: '`mod_advertise`: This is an additional module that allows HTTP to advertise
    via multicast packets—the IP and port—where the `mod_cluster` module is listening'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod_advertise`：这是一个附加模块，允许HTTP通过多播数据包（IP和端口）进行广告，其中`mod_cluster`模块正在监听'
- en: 'The next part of the configuration that we need to add is the core load balancing
    configuration:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的配置的下一部分是核心负载均衡配置：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Basically, you have to replace the `192.168.10.1` IP address with the one that
    your Apache web server listens for requests and the port value of `8888` with
    the one you want to use to communicate with WildFly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，您必须将`192.168.10.1` IP地址替换为您Apache网络服务器监听请求的地址，将`8888`端口号替换为您想要与WildFly通信的端口号。
- en: As it is, the Apache virtual host allows you to have incoming requests from
    the subnetwork `192.168.10`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，Apache虚拟主机允许您从子网络`192.168.10`接收传入请求。
- en: The `KeepAliveTimeout` directive allows you to reuse the same connection within
    60 seconds. The number of requests per connection is unlimited since we are setting
    `MaxKeepAliveRequests` to `0`. The `ManagerBalancerName` directive provides the
    balancer name for your cluster (defaults to `mycluster`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeepAliveTimeout`指令允许您在60秒内重用相同的连接。由于我们将`MaxKeepAliveRequests`设置为`0`，因此每个连接的请求数量是无限制的。`ManagerBalancerName`指令提供了您集群的均衡器名称（默认为`mycluster`）。'
- en: What's most important for us is the `ServerAdvertise` directive that is set
    to `On` and uses the advertise mechanism to tell WildFly whom it should send the
    cluster information to.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说最重要的是设置为 `On` 的 `ServerAdvertise` 指令，它使用广告机制来告诉 WildFly 它应该将集群信息发送给谁。
- en: This option is disabled in the bundled server by default. Be sure to uncomment
    the `ServerAdvertise` directive in its `httpd.conf` file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此选项在捆绑的服务器中已禁用。请确保在 `httpd.conf` 文件中取消注释 `ServerAdvertise` 指令。
- en: Now, restart the Apache web server and the single application server nodes.
    If you have correctly configured the mode cluster on the HTTP side, you will see
    that each WildFly node will start receiving UDP multicast messages from `mod_cluster`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动 Apache Web 服务器和单个应用程序服务器节点。如果您已正确配置 HTTP 侧的模式集群，您将看到每个 WildFly 节点将开始从
    `mod_cluster` 接收 UDP 多播消息。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are running on a Windows machine, be sure to run your web server as an
    administrator.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在 Windows 机器上运行，请确保以管理员身份运行您的 Web 服务器。
- en: 'If everything goes well, you can visit `http://127.0.0.1:6666/mod_cluster_manager`
    to see the status of your load balancer and the interconnected nodes. Be sure
    to not use Google Chrome for this because it considers the `6666` port as an unsecure
    one (it is an IRC port by default). You should see the following information on
    the simple webpage:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您可以通过访问 `http://127.0.0.1:6666/mod_cluster_manager` 来查看您的负载均衡器和互联节点的情况。请确保不要使用
    Google Chrome，因为它将 `6666` 端口视为不安全（默认情况下，它是一个 IRC 端口）。您应该在简单的网页上看到以下信息：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**If you don''t have a running WildFly instance** now, be sure to start it
    with one of the full-HA configuration files. Refresh Apache''s configuration web
    page after the server is up.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您现在没有运行的 WildFly 实例**，请确保使用其中一个全高可用性配置文件启动它。在服务器启动后，刷新 Apache 的配置网页。'
- en: Clustering your web applications
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集群化您的 Web 应用程序
- en: 'Clustering web applications requires the least amount of effort to be put in
    by the developer. As we have just discussed, all you need to do to switch on clustering
    in a web application is to add the following directive to the `web.xml` descriptor:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 集群化 Web 应用程序需要开发者投入最少的努力。正如我们刚才讨论的，要在 Web 应用程序中启用集群，您只需将以下指令添加到 `web.xml` 描述符中：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once your application ships with the distributable stanza in it, the cluster
    will start, and provided you have correctly designed your session layer, it will
    be load balanced and fault tolerant as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用程序包含可分发的配置段落，集群将启动，并且只要您正确设计了会话层，它也将是负载均衡和容错的。
- en: You could check it out by pointing the browser to your HTTP proxy. For the default
    setup, it would be `http://localhost:6666/your_web_application/`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将浏览器指向您的 HTTP 代理来检查它。对于默认设置，它将是 `http://localhost:6666/your_web_application/`。
- en: Programming considerations to achieve HA
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现高可用性的编程注意事项
- en: In order to support in-memory replication of HTTP session states, all servlets
    and JSP session data must be serializable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 HTTP 会话状态的内存复制，所有 servlet 和 JSP 会话数据都必须是可序列化的。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Serialization** is the conversion of an object to a series of bytes so that
    the object can be easily saved to a persistent storage or streamed across a communication
    link. The byte stream can then be deserialized, converting the stream into a replica
    of the original object.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**是将对象转换为一系列字节的过程，以便对象可以轻松地保存到持久存储或通过通信链路传输。然后，该字节流可以被反序列化，将流转换为原始对象的副本。'
- en: Additionally, in an HTTP servlet that implements `javax.servlet.http.HttpSession`,
    you need to use the `setAttribute` method to change the attributes in a session
    object. If you set the attributes in a session object with `setAttribute`, by
    default the object and its attributes are replicated using the Infinispan API.
    Every time a change is made to an object that is in the session, `setAttribute`
    should be called to update that object across the cluster.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在实现 `javax.servlet.http.HttpSession` 的 HTTP servlet 中，您需要使用 `setAttribute`
    方法来更改会话对象中的属性。如果您使用 `setAttribute` 在会话对象中设置属性，则默认情况下，对象及其属性将使用 Infinispan API
    进行复制。每次对会话中的对象进行更改时，都应该调用 `setAttribute` 来更新集群中的该对象。
- en: Likewise, you need to use `removeAttribute` to remove an attribute from a session
    object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您需要使用 `removeAttribute` 来从会话对象中删除属性。
- en: Achieving HA in JSF applications
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 JSF 应用程序中实现高可用性（HA）
- en: In the applications included in this book, we have used JSF and the CDI API
    to manage the web session. In this case, we transparently replicate the other
    server nodes to the beans, which are marked as `@SessionScoped`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书包含的应用程序中，我们使用了JSF和CDI API来管理Web会话。在这种情况下，我们透明地将其他服务器节点复制到标记为`@SessionScoped`的Bean。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Clustering JSF-based applications requires special attention if you are dealing
    with both HTTP and EJB sessions created by SFSB. In the earlier servlet-centric
    frameworks, the usual approach was to store references of Stateful Session Beans
    in `javax.servlet.http.HttpSession`. When dealing with high-level JSF and CDI
    Beans, it is vital to provide a `@SessionScoped` controller to your application,
    which gets injected in the SFSB reference; otherwise, you will end up creating
    a new Stateful Session Beans upon each request.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理由SFSB创建的HTTP和EJB会话，则对基于JSF的应用程序进行集群需要特别注意。在早期的以servlet为中心的框架中，通常的方法是将状态会话Bean的引用存储在`javax.servlet.http.HttpSession`中。当处理高级JSF和CDI
    Bean时，向您的应用程序提供一个`@SessionScoped`控制器至关重要，该控制器被注入到SFSB引用中；否则，您将在每次请求时创建一个新的状态会话Bean。
- en: 'The following is an example of how to adapt your Ticket CDI application (described
    in [Chapter 4](part0028_split_000.html#page "Chapter 4. Learning Context and Dependency
    Injection"), *Learning Context and Dependency Injection*) to a clustered environment.
    At first, as we said, we need to include the distributable stanza in your `web.xml`
    file to trigger clustering modules:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将您的Ticket CDI应用程序（在第4章中描述，*学习上下文和依赖注入*）适配到集群环境的一个示例。起初，正如我们所说的，我们需要在您的`web.xml`文件中包含可分发段以触发集群模块：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, apply the same changes to the `TheatreBox` singleton that we described
    in the *Turning your cache into a distributed cache* section:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将我们在*将您的缓存转换为分布式缓存*部分中描述的相同更改应用到`TheatreBox`单例：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since our controller component is bound to a `@SessionScoped` state, you don''t
    need to apply any changes in order to propagate your session across server nodes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的控制器组件绑定到`@SessionScoped`状态，您不需要进行任何更改即可在服务器节点之间传播您的会话：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, remember to include the Infinispan dependency in your `META-INF/MANIFEST.MF`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住在您的`META-INF/MANIFEST.MF`中包含Infinispan依赖项：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once your application is deployed on both the nodes of your cluster, you can
    test it by hitting the Apache web server (`http://localhost:6666/ticket-agency-cluster`
    in our example) and start booking tickets:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用程序部署在集群的节点上，您可以通过访问Apache web服务器（在我们的示例中为`http://localhost:6666/ticket-agency-cluster`）来测试它并开始预订票务：
- en: '![Achieving HA in JSF applications](img/00097.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![在JSF应用程序中实现高可用性](img/00097.jpeg)'
- en: Since the `mod_cluster` subsystem is configured to use **sticky web sessions**
    by default, all subsequent requests from the same client will be redirected to
    the same server node. Therefore, by shutting down the sticky server node, you
    will get evidence that a new cluster view has been created and you can continue
    shopping on the other server node.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`mod_cluster`子系统默认配置为使用**粘性Web会话**，因此来自同一客户端的所有后续请求都将被重定向到同一服务器节点。因此，通过关闭粘性服务器节点，你可以获得已创建新的集群视图的证据，并且可以在其他服务器节点上继续购物。
- en: '![Achieving HA in JSF applications](img/00098.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![在JSF应用程序中实现高可用性](img/00098.jpeg)'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about the world of clustered applications. Here, we took
    you through the robust clustering features of WildFly and applied them to some
    of the examples discussed in this book.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于集群应用程序的世界。在这里，我们向您介绍了WildFly的强大集群功能，并将其应用于本书中讨论的一些示例。
- en: The number of topics related to clustering might be expanded to cover a full
    book of its own; however, we decided to stress only on some features. In particular,
    we learned how to cluster EJBs and achieve fault tolerance in case there is a
    change in the server topology.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与集群相关的主题数量可能需要扩展以涵盖一本完整的书籍；然而，我们决定只强调一些功能。特别是，我们学习了如何集群EJB并实现服务器拓扑变化时的容错。
- en: Next, we discussed clustering web applications and the integration with load
    balancing solutions such as the Apache web server and `mod_cluster`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了集群Web应用程序以及与负载均衡解决方案（如Apache web服务器和`mod_cluster`）的集成。
- en: 'In the next chapter, we will focus on some new topics added to Java EE 7 related
    to long-term task execution: batch processing and concurrency utilities'' usage.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注Java EE 7中添加的一些与长期任务执行相关的新主题：批处理和并发实用工具的使用。
