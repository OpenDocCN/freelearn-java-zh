- en: Dependency Injection in Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9中的依赖注入
- en: In the previous chapter, we got acquainted with the Dependency Injection Principle,
    IOC with different scenarios, and different types of Dependency Injection by writing
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过编写代码了解了依赖注入原则、不同场景下的IOC以及不同类型的依赖注入。
- en: In this chapter, we will learn about the new features offered in Java 9\. Specifically,
    we will learn about modularity in Java 9, modularity framework, types of modules
    offered in Java 9, and we will see Dependency Injection using modules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解Java 9提供的新特性。具体来说，我们将学习Java 9中的模块化，模块化框架，Java 9提供的模块类型，以及我们将看到使用模块的依赖注入。
- en: 'This chapter will mainly cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将主要涵盖以下主题：
- en: Java 9 introduction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9简介
- en: Modular Framework in Java 9
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9中的模块化框架
- en: Dependency Injection using Java 9 Modular Framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java 9模块化框架进行依赖注入
- en: Java 9 introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9简介
- en: Before learning what's new in Java 9, we need to know one of the important components
    of Java, which is **Java Development Kit** (**JDK**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习Java 9的新特性之前，我们需要了解Java的一个重要组成部分，那就是**Java开发工具包**（**JDK**）。
- en: JDK is a collection of **Java Standard Edition** (**Java SE**), **Java Enterprise
    Edition** (**Java EE**), **Java Micro Edition** platforms (**Java ME**), and different
    tools such as javac, Java console, JAR, JShell, Jlink, and it provides all the
    libraries for developing, debugging, and monitoring for building Java-based applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JDK是一个包含**Java标准版**（**Java SE**）、**Java企业版**（**Java EE**）、**Java微型版**（**Java
    ME**）平台以及不同的工具（如javac、Java控制台、JAR、JShell、Jlink）的集合，它为开发、调试和监控基于Java的应用程序提供了所有库。
- en: Java 9 has come up with almost over 100 new features and enhancements in different
    categories of JDK, such as tools, security, deployment, performance tuning, API
    changes of core libraries, and javadoc.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9在JDK的不同类别中推出了近100个新特性和增强，如工具、安全、部署、性能调整、核心库API更改和javadoc。
- en: Key features
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键特性
- en: 'Let''s look at some of the key features of Java 9 in brief, which will change
    Java software development:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看Java 9的一些关键特性，这些特性将改变Java软件开发：
- en: '**Java Platform Module System** (**JPMS**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java平台模块系统**（**JPMS**）'
- en: JShell (REPL)—The Java Shell
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JShell（REPL）——Java Shell
- en: JLink—Module Linker
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JLink——模块链接器
- en: Multi-Release JAR Files
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多版本JAR文件
- en: Stream API enhancements
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stream API增强
- en: Stack—Walking API
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈跟踪API
- en: Immutable collections with convenient factory methods
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有便捷工厂方法的不可变集合
- en: Support of HTTP 2.0
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HTTP 2.0
- en: Java Platform Module System
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java平台模块系统
- en: The introduction of **Java Platform Module System** (**JPMS**) is key and a
    game changer feature of Java 9 and JPMS developed under the shed of project Jigsaw.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java平台模块系统**（**JPMS**）的引入是Java 9和JPMS的一个关键特性，也是游戏规则改变者，JPMS是在Jigsaw项目下开发的。'
- en: 'The main objectives of project Jigsaw are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 项目Jigsaw的主要目标如下：
- en: 'Scalable JDK: Until Java 8, engineering of JDK is solid and contains a number
    of components, which make it troublesome to maintain and develop. JDK 9 is partitioned
    into sets of independent modules, which permits custom runtime capability to incorporate
    only required modules in our application, which offers assistance to diminish
    runtime size.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩的JDK：直到Java 8，JDK的工程是稳固的，包含了许多组件，这使得维护和开发变得麻烦。JDK 9被划分为一系列独立的模块，这允许我们的应用程序只包含所需的模块，从而有助于减少运行时大小。
- en: 'Robust encapsulation and security: Bundles from the module can be expressly
    exposed if required by other modules. On the other hand, another module has to
    explicitly define which particular bundles are required from modules. This way,
    modules can encapsulate particular bundles for security purposes.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强健的封装和安全：如果需要，模块可以从模块中明确地暴露出来。另一方面，另一个模块必须明确定义需要从模块中获取哪些特定的包。这样，模块可以为了安全目的封装特定的包。
- en: 'Dependency: Modern module frameworks permit us to define unequivocal dependency
    between modules and all required subset modules dependency can be distinguished
    at compile time.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系：现代模块框架允许我们定义模块之间以及所有所需子模块之间的明确依赖关系，所有所需的子模块依赖关系都可以在编译时区分。
- en: Modern rebuild permits us to incorporate runtime images of modules, which gives
    superior performance of JDK. It moreover evacuates `tools.jar` and `rt.jar` from
    runtime images.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代重建允许我们包含模块的运行时镜像，这为JDK提供了更好的性能。它还从运行时镜像中移除了`tools.jar`和`rt.jar`。
- en: To secure the internal structure of runtime images, an unused URI conspire is
    utilized for naming modules, resources, and classes.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保护运行时图像的内部结构，使用了一个未使用的 URI 策略来命名模块、资源和类。
- en: We will discuss JPMS in detail in the *Modular Framework in Java 9* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *Java 9 的模块化框架* 部分详细讨论 JPMS。
- en: JShell (REPL) – The Java Shell
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JShell (REPL) – Java Shell
- en: In earlier JDK, we did not have the luxury of running code using a command line
    interface. For learning new functions such as the matches function of regular
    expression API and many more, we had to write a necessary skeleton of Java, `public
    static void main(String[] args)`, and go through the compilation and execution
    phase.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 JDK 中，我们没有使用命令行界面的便利来运行代码。为了学习新的功能，例如正则表达式 API 的 matches 函数等，我们必须编写必要的
    Java 骨架，`public static void main(String[] args)`，并经历编译和执行阶段。
- en: Java 9 introduced JShell, a command line tool. It uses the **Read-Eval-Print
    Loop** (**REPL**) principle to provide a command line interface to interact with
    the Java platform and provide an interactive way of running a program without
    writing necessary skeletons.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 引入了 JShell，这是一个命令行工具。它使用 **读取-评估-打印循环**（**REPL**）原则提供命令行界面与 Java 平台交互，并提供一种无需编写必要骨架的交互式运行程序的方式。
- en: JShell came up with a parser that parses submitted code and identifies different
    types such as a variable, a declared method, loop, and many more, and put them
    all together in a dummy skeleton to make a complete Java program to pass it to
    the compiler. Based on the inputs compiler, it converts it into byte code. During
    this process, a file is not created, so it will all be saved in memory. At the
    end, the generated byte code is used by JVM to load and execute.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 提出了一个解析器，它可以解析提交的代码并识别不同类型，如变量、声明的方法、循环等，并将它们全部组合在一个虚拟骨架中，形成一个完整的 Java
    程序以传递给编译器。基于输入的编译器，它将其转换为字节码。在这个过程中，不会创建文件，所以所有内容都将保存在内存中。最后，生成的字节码被 JVM 用于加载和执行。
- en: 'JShell is located in the `bin` directory of shipped JDK 9\. Using a command
    interface, traverse to the `bin` directory and type command `JShell` to start
    the tool:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 位于发货 JDK 9 的 `bin` 目录中。使用命令界面，进入 `bin` 目录并输入命令 `JShell` 以启动工具：
- en: '![](img/00013.gif)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00013.gif)'
- en: 'Let’s consider a program that we used to write in IDE. Here is a simple program
    to print a string message into uppercase:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个我们通常在 IDE 中编写的程序。这是一个简单的程序，用于将字符串消息打印为大写：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we can get quick output of the preceding string message by directly writing
    a statement in the JShell tool, declaring variables and `println` statements is
    not required. JShell provides various command features that make a developer's
    life easy when writing quick code snippets.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过直接在 JShell 工具中编写语句来快速输出前面的字符串消息，声明变量和 `println` 语句是不必要的。JShell 提供了各种命令功能，使得开发者编写快速代码片段时生活更加轻松。
- en: '![](img/00014.gif)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00014.gif)'
- en: JLink – Module Linker
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JLink – 模块链接器
- en: When we are talking about modular systems, then immediately one question comes,
    how dependencies  of modules will organize and what will be impact on final deployment?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论模块化系统时，一个立即的问题就是模块的依赖关系将如何组织，以及它将对最终部署产生什么影响？
- en: The JLink tool is designed to provide optional phases between compile time and
    runtime, called link time, which links a set of modules and its transitive dependencies
    to create runtime images. JLink makes deployment simpler and also reduces the
    size of an application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JLink 工具旨在在编译时间和运行时间之间提供可选阶段，称为链接时间，它将一组模块及其传递依赖项链接到创建运行时图像。JLink 使部署更加简单，并减少了应用程序的大小。
- en: 'The invocation syntax of `jLink` is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`jLink` 的调用语法如下：'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Multi-release JAR files
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多版本 JAR 文件
- en: We have seen many third-party libraries, support for several Java versions with
    backward compatibility. Because of this, they don't use the latest API features
    introduced in new releases of JDK. Since Java 8, there is no facility to define
    condition-based platform dependencies for using new features.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多第三方库，支持多个 Java 版本并具有向后兼容性。正因为如此，它们不使用 JDK 新版本中引入的最新 API 功能。自从 Java
    8 以来，没有设施来定义基于条件的平台依赖来使用新功能。
- en: Java 9 introduced a multi-release jar concept. It allows developers to create
    alternative versions of each class, which are only used when running on specific
    Java versions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 引入了多版本 JAR 概念。它允许开发者为每个类创建替代版本，这些版本仅在运行特定 Java 版本时使用。
- en: '![](img/00015.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00015.jpeg)'
- en: The preceding diagram shows the structure of a multi-release jar. It contain
    resources and classes along with the Meta-INF directory for metadata. This metadata
    file contains version-specific details to encode jar files to provide a compatible
    method for multiple versions of libraries that run on a target Java platform.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示展示了多版本 jar 的结构。它包含资源、类以及用于元数据的 Meta-INF 目录。这个元数据文件包含特定版本的详细信息，用于将 jar 文件编码，以提供在目标
    Java 平台上运行的多版本库的兼容方法。
- en: To continue on with the preceding example, we can see that the **javaMutipleJar**
    library has three classes, **Class1.class**, **Class2.class**, and **Class3.class**,
    at root level build with Java 8\. If we deploy this jar in JDK, which does not
    support MARJAR, then only the root level classes will be visible and later platform
    classes will be ignored.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续前面的例子，我们可以看到 `javaMutipleJar` 库在根级别有三个类，**Class1.class**、**Class2.class**
    和 **Class3.class**，使用 Java 8 构建。如果我们在这个不支持 MARJAR 的 JDK 中部署这个 jar，那么只有根级别的类将是可见的，后续平台类将被忽略。
- en: Moreover, **Class1.class** and **Class2.class** want to use Java 9 features,
    so then only those classes will bundle with Java 9 compilation. When Java 10 comes
    and **Class1.class** wants to use Java 10 features, then, as mentioned in the
    diagram, because of MARJAR concepts, it will bundle with the Java 10 platform.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**Class1.class** 和 **Class2.class** 想要使用 Java 9 特性，因此只有这些类会与 Java 9 编译捆绑。当
    Java 10 来临时，如果 **Class1.class** 想要使用 Java 10 特性，那么，如图中所述，由于 MARJAR 概念，它将与 Java
    10 平台捆绑。
- en: Ultimately, multi-release jar concepts help third-party library and framework
    developers to easily separate the use of new APIs for specific JDK for supporting
    migration as well as continuing to support older versions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，多版本 jar 概念帮助第三方库和框架开发者轻松地分离特定 JDK 的新 API 使用，以支持迁移，同时继续支持旧版本。
- en: Stream API enhancements
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stream API 的增强
- en: Stream is a pipeline that contains elements in sequential form to support aggregation
    operations on collections of data. Stream API is a major feature of Java 8, which
    provides sequential and parallel execution with filtering based on criteria, all
    this together is known as internal iteration of Stream.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Stream 是一个包含元素以顺序形式存在的管道，用于支持对数据集合的聚合操作。Stream API 是 Java 8 的一个主要特性，它提供了基于标准的过滤和顺序或并行执行，所有这些统称为
    Stream 的内部迭代。
- en: Java 9 added four new methods to make the Stream API better for iterating operations.
    `dropWhile` and `takeWhile  `methods are default methods and `iterate` and `ofNullable` are
    static methods in the `java.util.stream` interface. Let's discuss the `takeWhile`
    method use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 增加了四个新方法，以使 Stream API 在迭代操作方面更加完善。`dropWhile` 和 `takeWhile` 方法是默认方法，而
    `iterate` 和 `ofNullable` 是 `java.util.stream` 接口中的静态方法。让我们来讨论 `takeWhile` 方法的用法。
- en: 'Stream API Syntax:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Stream API 语法：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/00016.gif)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.gif)'
- en: The `takeWhile()` method returns the longest prefix, which matches the predicate
    for the ordered stream. As from the preceding code, `takeWhile` returns the first
    three elements because of matching with the predicate.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeWhile()` 方法返回与有序流中谓词匹配的最长前缀。从前面的代码中可以看出，`takeWhile` 返回前三个元素，因为它们与谓词匹配。'
- en: For unordered streams, the `takeWhile()` method returns a prefixed element until
    the predicate condition is true. It stops iteration if the predicate condition
    returns false and returns a list of elements that predicate evaluated until the
    condition fails for the first time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无序流，`takeWhile()` 方法返回一个前缀元素，直到谓词条件为真。如果谓词条件返回假，则停止迭代，并返回一个元素列表，这些元素在谓词评估直到条件首次失败。
- en: Stack-walking API
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈跟踪 API
- en: To debug exceptions, we look at the root cause of exception by traversing the
    stack trace. Prior to Java 9, we all used `Thread.getStackTrace()` to get `StackTraceElement`
    objects in the form of arrays.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试异常，我们通过遍历堆栈跟踪来查看异常的根本原因。在 Java 9 之前，我们都使用 `Thread.getStackTrace()` 来获取以数组形式存在的
    `StackTraceElement` 对象。
- en: '**StackTraceElement**: Each element of `StackTraceElement` is a single `StackFrame`,
    which provides details about classname, method name, filename, and line number
    where the exception was generated. Except for the first `StackFrame`, all the
    other elements represent the method invocation call from the starting point of
    the application to the point where the exception generated. This is helpful when
    we want auditing of generated error logs.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**StackTraceElement**: `StackTraceElement` 的每个元素都是一个单独的 `StackFrame`，它提供了关于类名、方法名、文件名和异常生成的行号等详细信息。除了第一个
    `StackFrame` 之外，所有其他元素都代表从应用程序的起点到异常生成的点的调用方法。这在我们需要审计生成的错误日志时非常有用。'
- en: Java 9 StackWalker API provides several features such as filtering, asserting,
    and skipping certain classes in the stack trace. We can get either a full stack
    trace or  short stack trace for a current thread at any point.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 StackWalker API 提供了过滤、断言和跳过堆栈跟踪中某些类等几个功能。我们可以在任何时刻获取当前线程的完整堆栈跟踪或简短堆栈跟踪。
- en: 'StackWalker provides various methods for capturing information about stacks,
    such as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: StackWalker 提供了各种用于捕获有关堆栈信息的方法，例如：
- en: '**forEach**: For the current thread it returns each StackFrame stream to perform
    actions'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**forEach**: 对于当前线程，它返回每个 StackFrame 流以执行操作'
- en: '**getInstance()**: This returns the current instance of StackWalker'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getInstance()**: 这将返回 StackWalker 的当前实例'
- en: '**walk()**: This is used to open a sequential stream for each StackFrame for
    the current thread, where we can apply functions such as limit, skip, and filter'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**walk()**: 这用于为当前线程的每个 StackFrame 打开一个顺序流，其中我们可以应用如限制、跳过和过滤等函数'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Immutable collections with convenient factory methods
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有便利工厂方法的不可变集合
- en: Many times we directly add or remove elements from a collection, which is returned
    from the `factory` method. This collection is immutable and adding items into
    these collection gives us an exception called `UnSupportedOperationException`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候我们直接从 `factory` 方法返回的集合中添加或删除元素。这个集合是不可变的，将这些项目添加到这些集合中会引发一个名为 `UnSupportedOperationException`
    的异常。
- en: 'To avoid such situations, we create immutable collection objects by using the `collections.unmodifiableXXX()`
    method. These methods are also tedious, such as writing multiple statements for
    adding individual items and then adding into it immutable `List` or `Set` or `Map`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免此类情况，我们通过使用 `collections.unmodifiableXXX()` 方法创建不可变集合对象。这些方法也很繁琐，例如，需要编写多个语句来添加单个项目，然后将它们添加到不可变的
    `List`、`Set` 或 `Map` 中：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Java 9 provides convenient immutable factory methods such as `List.of(), Set.of()
    and Map.of()` to solve the previously mentioned issue:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 提供了便利的不可变工厂方法，如 `List.of(), Set.of() 和 Map.of()`，以解决之前提到的问题：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: HTTP/2.0 support
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2.0 支持
- en: We used to connect servers using `HttpURLConnection`, which works in a single
    request/response cycle, and this eventually increases web page loading time and
    latency.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过去使用 `HttpURLConnection` 连接服务器，它在单个请求/响应周期中工作，这最终增加了网页加载时间和延迟。
- en: 'Moreover, the difference between HTTP/1.1 of older JDK and HTTP/2 of JAVA 9
    is that data is framed when transporting between clients and servers. HTTP/2 uses
    the `HttpClient` API to push data by using the server push feature, with this
    it allows us to prioritize and send required data for loading the web page first.
    The following example shows HTTP interaction for the `GET` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，较旧 JDK 的 HTTP/1.1 与 JAVA 9 的 HTTP/2 之间的区别在于，在客户端和服务器之间传输数据时数据被分帧。HTTP/2 使用
    `HttpClient` API 通过服务器推送功能推送数据，这使得我们可以优先发送加载网页所需的数据。以下示例显示了 `GET` 方法的 HTTP 交互：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Modular Framework in Java 9
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9 的模块框架
- en: In the previous section, we discussed several Java 9 features in brief. Now,
    in this section, we will learn about the Modular Framework and how it is used
    in Java 9.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们简要讨论了几个 Java 9 的特性。现在，在本节中，我们将学习模块框架及其在 Java 9 中的使用方法。
- en: What is modularity?
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模块化？
- en: Before we move to Java Platform Module System, let's understand the meaning
    of modularity in the real world.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向 Java 平台模块系统之前，让我们了解现实世界中模块化的含义。
- en: Modularity is a design that divides systems into smaller parts called a module.
    Nowadays, modular kitchens are installed in homes. These types of kitchen include
    several units or modules such as wall cabinets, cupboards, sinks, and many more
    and all these different parts are built in factories. If at any time there is
    damage in any unit, then only that module needs to be replaced or repaired.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化是一种将系统划分为称为模块的较小部分的设计。如今，家庭中安装了模块化厨房。这类厨房包括多个单元或模块，如壁柜、橱柜、水槽等，所有这些不同的部件都是在工厂中制造的。如果任何单元在任何时候出现损坏，那么只需要更换或修理该模块。
- en: Another familiar modular system is electric outlets in walls, which allow you
    to plug in different types of electrical gadgets such as microwaves, mixer grinders,
    refrigerators, televisions, and they are all designed to work on defined tasks.
    These devices work in any outlet without caring whether it is in our home or a
    neighbor's home, they just do their task and function when they are plugged in.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个熟悉的模块化系统是墙上的电源插座，它允许你插入不同类型的电器，如微波炉、搅拌机、冰箱、电视等，它们都是设计来完成特定任务的。这些设备在任何插座上都能工作，无论它是在我们的家中还是邻居的家中，它们只是在插入时执行任务和功能。
- en: In terms of computer systems, modularity is a concept of combination and linking
    of multiple independent modules in a single system. It increases usability and
    removes duplication of code and also makes a system loosely coupled. Similar to
    the electric outlet concept, modules should do their task without caring where
    they are plugged into an application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机系统方面，模块化是多个独立模块在一个单一系统中组合和链接的概念。它增加了可用性，消除了代码的重复，并使系统松散耦合。类似于电源插座的概念，模块应该在不关心它们被插入到应用程序中的位置的情况下执行任务。
- en: '![](img/00017.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00017.jpeg)'
- en: Java Platform Module System
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java平台模块系统
- en: '**Java Platform Module System** (**JPMS**) is also known as JSR 376 and is
    implemented under project Jigsaw. We have to understand why we need module systems
    in Java and what the changes in current JDK are.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java平台模块系统**（**JPMS**）也称为JSR 376，是在Jigsaw项目下实现的。我们必须了解为什么我们需要Java中的模块化系统以及当前JDK中的变化。'
- en: The need for a Java modular system
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要Java模块化系统
- en: To run a small or big application, a runtime environment up to Java 8 is required
    because JDK is built to support monolithic design. All libraries are tightly coupled
    with each other and for deployment full JDK is required.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行小型或大型应用程序都需要一个最高支持Java 8的运行环境，因为JDK是构建来支持单体设计的。所有库都紧密耦合在一起，并且部署时需要完整的JDK。
- en: '**Maintainability**: We all want an application to be loosely coupled, highly
    united, readable, and understandable. So we are using classes and packages. Day
    by day Java is growing exponentially in terms of size and packages to provide
    better features, but dependencies between packages is compromised. So we need
    something new that is better than packages for maintaining our code base.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**可维护性**：我们都希望应用程序能够松散耦合、高度统一、易于阅读和理解。因此，我们使用类和包。随着Java在规模和包方面的指数级增长，每天都在提供更好的功能，但包之间的依赖性却受到了影响。因此，我们需要一些新的东西，它比包更好地维护我们的代码库。'
- en: '**JAR Hell**: Before Java 9,  The JVM does not have thought that how JAR on
    the class path depends on another Jar. It essentially loads a bunch of JARs, but
    it does not validate their dependencies. The JVM breaks the execution at runtime
    when a JAR is missing. The JARs don''t characterize accessibility constraints
    such as open or private. The whole substance of all JARs on the class path is
    totally visible to all the other JARs from the class path. There is no way to
    declare that a few classes in a JAR are private. All classes and methods are open
    related to the class path. Sometimes, we have jar files that contain multiple
    versions of a single class. The Java ClassLoader loads only one version of this
    class, and it does not determined which one. This creates uncertainty about how
    our program is  going to work. This issue is known as **JAR Hell**. The Module
    Path concept presented in Java 9 tends to illuminate issues caused by the class
    path.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**JAR地狱**：在Java 9之前，JVM没有考虑到类路径上的JAR是如何依赖于另一个JAR的。它本质上加载了一堆JAR文件，但不会验证它们的依赖关系。当缺少JAR时，JVM在运行时中断执行。JAR文件没有定义可访问性约束，如公开或私有。类路径上所有JAR文件的全部内容对类路径上的其他JAR文件都是完全可见的。无法声明JAR中的某些类是私有的。所有类和方法都与类路径公开相关。有时，我们有一些包含单个类多个版本的JAR文件。Java
    ClassLoader只加载这个类的单个版本，并且它不决定哪个版本。这导致我们程序的工作方式存在不确定性。这个问题被称为**JAR地狱**。Java 9中提出的模块路径概念倾向于阐明由类路径引起的问题。'
- en: '**Implicit Dependency**: We have all seen the `NoClassDefFoundError` error
    a few times. It comes when JVM is not able to discover a class on which code it
    is executing. Finding depending code and lost dependency is simple, but dependency
    that is not in classLoader is troublesome to recognize, since there are chances
    that the same class is stacked by numerous class loaders. The current JAR framework
    is not able to express which other JAR file is dependent, so that JVM understands
    and resolves dependency.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式依赖**：我们都见过几次`NoClassDefFoundError`错误。它发生在JVM无法发现它正在执行的代码所依赖的类时。找到依赖代码和丢失的依赖关系很简单，但不在classLoader中的依赖关系很难识别，因为同一个类可能被多个class
    loaders堆叠。当前的JAR框架无法表达哪个JAR文件是依赖的，以便JVM理解和解决依赖关系。'
- en: '**Lack of strong encapsulation**: Java''s visibility modifier provides strong
    encapsulation between classes of the same packages. Current Java encapsulation
    works with ClassPath where every public class is visible to other classes because
    several critical JDK API classes are open for other classes.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺乏强封装**：Java的可视性修饰符为同一包中的类提供了强大的封装。当前的Java封装与ClassPath一起工作，其中每个公开类对其他类都是可见的，因为几个关键的JDK
    API类对其他类是公开的。'
- en: All preceding issues are fixed with Java 9 module concepts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述问题都通过Java 9的模块概念得到了解决。
- en: Modular JDK
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化JDK
- en: 'JDK 9 folder structure has changed compared to Java 8; JDK 9 does not have
    JRE, it is separately installed into a distinct folder. In JDK 9, we can see a
    new folder called jmod, which contains all the Java platform modules. Java 9 on
    wards `rt.jar` and `tool.jar` is not available in JDK:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java 8相比，JDK 9的文件夹结构已经改变；JDK 9没有JRE，它是单独安装到一个不同的文件夹中。在JDK 9中，我们可以看到一个名为jmod的新文件夹，其中包含所有Java平台模块。从Java
    9开始，`rt.jar`和`tool.jar`在JDK中不可用：
- en: '![](img/00018.gif)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.gif)'
- en: 'All Java modules, `src` are available from the `..\jdk-9.0.1\lib\src` folder,
    and each module includes `module-info.java`. The following is a diagram that shows
    how JDK looks with all modules:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Java模块，`src`，都可在`..\jdk-9.0.1\lib\src`文件夹中找到，每个模块都包含`module-info.java`。以下是一个显示JDK如何包含所有模块的图表：
- en: '![](img/00019.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: Every other module implicitly or explicitly depends on the `java.base` module.
    It follows a directed acyclic graph dependency, which means no circular dependency
    is allowed between modules.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个其他模块都隐式或显式地依赖于`java.base`模块。它遵循有向无环图依赖关系，这意味着模块之间不允许存在循环依赖。
- en: All modules in JDK 9 are by default dependent on the base module, known as the `java.base` module.
    It includes the `java.lang` package.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 9中的所有模块默认都依赖于基础模块，称为`java.base`模块。它包括`java.lang`包。
- en: We can list all modules of Java 9 using the  command `-- list-modules`. Each
    module name is followed by a version number with string `-@9`, to indicate that
    the module belongs to Java 9\. A JDK 9 specific module is prefix with keyword ***jdk*** such
    as                                                            `jdk.compiler` and
    JAVA SE specific modules start with the ***java*** *keyword*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令`-- list-modules`列出Java 9的所有模块。每个模块名称后面跟着一个版本号，格式为`-@9`，以指示该模块属于Java
    9。JDK 9特定的模块以关键字**jdk**为前缀，例如`jdk.compiler`，而JAVA SE特定的模块以**java**关键字开头。
- en: What is a module?
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模块？
- en: When we discuss modular systems, immediately you might ask what is a module?
    A module is a collection of code, data, and resources with self-descriptive properties.
    It contains a set of packages and types such as classes, abstract classes, interfaces,
    and so on, and also, most importantly, every module contains a `module-info.java`
    file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论模块化系统时，你可能会立即问什么是模块？模块是一组具有自描述属性的代码、数据和资源。它包含一系列包和类型，如类、抽象类、接口等，最重要的是，每个模块都包含一个`module-info.java`文件。
- en: A module can explicitly declare which package needs to export for other modules
    and what is required from other modules in order to compile and run. This will
    also help us to identify which module is missing when we get an error.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以显式声明需要导出到其他模块的包，以及为了编译和运行需要从其他模块获取的内容。这也有助于我们在出错时识别缺少的模块。
- en: Structure of a module
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的架构
- en: 'Modules are the main building block of JPMS. Modules are similar to JARs, but
    have additional characteristics, such as:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是JPMS的主要构建块。模块类似于JAR文件，但具有额外的特性，例如：
- en: '**Module Name**: A unique name to identify globally; a name can be defined
    by using inverse-URL naming convention'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块名称**: 一个用于全局识别的唯一名称；可以使用反向URL命名约定来定义名称'
- en: Declare dependencies for other modules
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明对其他模块的依赖
- en: Declaration of API that needs to export as packages
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要导出为包的API声明
- en: '![](img/00020.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00020.jpeg)'
- en: Module Descriptor (module-info.java)
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块描述符（module-info.java）
- en: '`module-info.java` is an important file in the modular system, and it contains
    modular metadata which describes the behavior module. It is a Java file, but it
    is not like a traditional Java file. It has its own syntax and it''s compiled
    into the `module-info.class` file.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`module-info.java`是模块化系统中的一个重要文件，它包含描述模块行为的模块元数据。它是一个Java文件，但它与传统Java文件不同。它有自己的语法，并且编译成`module-info.class`文件。'
- en: 'The following is the syntax that we have to follow when creating `module-info.java`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们创建`module-info.java`时必须遵循的语法：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is an example of the `module-info.java` file, where each module
    contains a unique ID and optional module descriptor details:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`module-info.java`文件的示例，其中每个模块包含一个唯一的ID和可选的模块描述符详细信息：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s understand different module descriptors, mentioned here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这里提到的不同模块描述符：
- en: '**requires <module>**: This descriptor specifies that a module depends on another
    module to run this module, this type of relationship is called a *module dependency*.
    At runtime, modules only see modules that are required, and this is called Readability.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**requires <module>**: 此描述符指定一个模块依赖于另一个模块以运行此模块，这种关系称为*模块依赖关系*。在运行时，模块只能看到所需的模块，这称为可读性。'
- en: '**requires transitive <module>**: This means to indicate a dependency on another
    module and, moreover, to guarantee that other modules perusing your module read
    that dependency—known as implied readability.  For example, module A reads module
    B and module B reads module C, then module B needs to declare requires transitive,
    otherwise module A will not compile unless they read module C explicitly.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**requires transitive <module>**: 这意味着表示对另一个模块的依赖，并且还要保证其他模块在读取你的模块时读取该依赖——称为隐式可读性。例如，模块A读取模块B，模块B读取模块C，那么模块B需要声明requires
    transitive，否则模块A将无法编译，除非它们显式地读取模块C。'
- en: '**requires static <module>**: By using a static keyword, dependency will be
    validated at compile time and it will be optional at runtime.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**requires static <module>**: 通过使用静态关键字，依赖关系将在编译时进行验证，在运行时是可选的。'
- en: '**exports <package-name>**: This descriptor is used to export own packages
    to other modules.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exports <package-name>**: 此描述符用于将自身的包导出到其他模块。'
- en: '**exports <package-name> to <module-name>**: By using such descriptor statements,
    we export packages to specific modules, not to all modules. It''s called qualified
    export.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exports <package-name> to <module-name>**: 通过使用此类描述符语句，我们将包导出到特定的模块，而不是所有模块。这被称为有条件导出。'
- en: '**opens <package-name>**: Opens descriptor used to define, only public types
    of packages are accessible to code in other modules at runtime only using reflection.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**opens <包名>**：用于定义的打开描述符，只有公共类型的包在运行时才能通过反射访问其他模块中的代码。'
- en: '**opens <package-name> to <module-name>**: A qualified open. This opens only
    a specific module that can access public type packages at runtime only through
    reflection.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**opens <包名> to <模块名>**：一个有资格的打开。这仅打开一个特定的模块，该模块可以在运行时仅通过反射访问公共类型包。'
- en: '**uses <service-interface>**: A module directive defined service used for this
    module. It makes a module as a service consumer. Service implementation can be
    in the same module or on another module.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uses <服务接口>**：为该模块定义的模块指令定义了服务。这使得模块成为服务消费者。服务实现可以位于同一模块或另一个模块中。'
- en: '**provide <service-interface> with <class1>,<class2>** :  Specifies that a
    module contains service implementation of an interface defined in a modules''s
    uses descriptor. This makes a module a service provider.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**provide <服务接口> with <class1>，<class2>**：指定模块包含在模块的 `uses` 描述符中定义的接口的服务实现。这使得模块成为服务提供者。'
- en: 'The following are important points that we need to understand when creating
    a module descriptor:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模块描述符时，我们需要理解以下重要要点：
- en: A module-info can have only a module name; means exports or requires clause
    are not mandatory.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module-info` 只能有一个模块名称；这意味着导出或需求子句不是必需的。'
- en: If a module descriptor has only exports then it means it is only exporting declared
    packages to other modules and it is not dependent on any other module. We can
    call them independent modules. For example, the `java.base` module.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模块描述符只有导出，那么这意味着它只向其他模块导出声明的包，并且它不依赖于任何其他模块。我们可以称它们为独立模块。例如，`java.base` 模块。
- en: Opposite to the previous point, module descriptors might contain export and
    requires clauses, which means the module is exporting packages to other modules
    and is also dependent on other modules for its own compilation.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与前一点相反，模块描述符可能包含导出和需求子句，这意味着该模块正在向其他模块导出包，并且它也依赖于其他模块进行自己的编译。
- en: There might be zero or more export or requires clauses in the module descriptor.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块描述符中可能有零个或多个导出或需求子句。
- en: When we create a project, JDK 8 adds a JDK jar into our project ClassPath. But
    when we create a Java 9 module project, then JDK modules are added into ModulePath.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建项目时，JDK 8 将一个 JDK jar 文件添加到我们的项目类路径中。但是，当我们创建 Java 9 模块项目时，JDK 模块将被添加到模块路径中。
- en: Module types
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块类型
- en: 'There are different types of modules:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模块有多种类型：
- en: '**Named application modules**: This is a simple module that we can all create.
    Any third-party libraries can be application modules.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名应用程序模块**：这是一个我们可以创建的简单模块。任何第三方库都可以是应用程序模块。'
- en: '**Platform modules**: As we have seen, JDK 9 itself migrated to modular architecture.
    All the existing features will be provided as different modules, such as `java.sql`,
    `java. desktop`, `java.transaction`. These are called Platform Modules. All modules
    are implicitly dependent on the `java.base` module.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台模块**：正如我们所见，JDK 9 本身迁移到了模块化架构。所有现有功能都将作为不同的模块提供，例如 `java.sql`、`java.desktop`、`java.transaction`。这些被称为平台模块。所有模块都隐式依赖于
    `java.base` 模块。'
- en: '**Automatic modules**:  A pre-Java 9 JAR, which is not migrated to modules,
    can be placed in a module path without module descriptors. These are called automated
    modules. This JAR implicitly exports all their packages for other modules and
    also reads other modules along with unnamed modules. Because there is no unique
    name for an automatic module, JDK generates depending on the JAR filename by removing
    the version number and extension. For example, the file `postgresql-42.1.4.jar` as
    a module will be `postgresql`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动模块**：一个预 Java 9 的 JAR 文件，未迁移到模块，可以放置在模块路径中而不需要模块描述符。这些被称为自动模块。这些 JAR 文件隐式导出所有包供其他模块使用，并读取其他模块以及未命名的模块。因为自动模块没有唯一的名称，JDK
    根据文件名生成依赖项，通过删除版本号和扩展名。例如，文件 `postgresql-42.1.4.jar` 作为模块将是 `postgresql`。'
- en: '**Unnamed modules**: JDK 9 does not remove classpaths. So all the JARs and
    classes placed on the class path are called Unnamed Modules. These modules can
    read all the modules and export all the packages, as they do not have a name.
    This module cannot be read or required by named application modules.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**未命名的模块**：JDK 9 并不删除类路径。因此，放置在类路径上的所有 JAR 文件和类都被称为未命名的模块。这些模块可以读取所有模块并导出所有包，因为它们没有名称。这个模块不能被命名应用程序模块读取或要求。'
- en: In JDK 9, we have two module paths and class paths. Now we might ask which JAR
    goes where? So, the answer is, a modular jar with an application module goes into
    `--module-path`,  and a modular jar with an unnamed module can be placed into
    `--class-path`. Similarly, a non-modular jar can be migrated into an automatic
    module and goes into `--module-path`. If a jar contains an unnamed module, then
    it resides in `--class-path`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 9 中，我们有两条模块路径和类路径。现在我们可能会问哪个 JAR 放在哪里？所以，答案是，一个包含应用程序模块的模块化 JAR 放入 `--module-path`，一个包含未命名模块的模块化
    JAR 可以放入 `--class-path`。同样，一个非模块化 JAR 可以迁移到一个自动模块中，并放入 `--module-path`。如果一个 JAR
    包含一个未命名的模块，那么它位于 `--class-path`。
- en: Dependency Injection using the Java 9 Modular Framework
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java 9 模块框架进行依赖注入
- en: The last topic we will learn about is molecularity and basics of  Java 9 modules.
    Now, we will learn how to write modules and how Dependency Injection is handled
    in modules.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要学习的最后一个主题是分子性和 Java 9 模块的基础。现在，我们将学习如何编写模块以及如何在模块中处理依赖注入。
- en: Java 9 has the concept of Service Loader, which is related to IoC and Dependency
    Injection. New module systems do not provide Dependency Injection, but the same
    can be achieved by Service Loader and SPI (Service Provider Interface) Pattern.
    We will now see how this will work with Java 9.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 引入了服务加载器的概念，这与 IoC 和依赖注入相关。新的模块系统不提供依赖注入，但可以通过服务加载器和 SPI（服务提供者接口）模式实现相同的功能。现在我们将看看这如何在
    Java 9 中工作。
- en: Modules with Service Loader
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有服务加载器的模块
- en: A service is a bunch of interfaces and classes collectively named a library,
    which delivers a specific functionality. Simply, we can say API. There are multiple
    usages for a service and they are called service providers (say implementations)
    . The client utilizing this service will not have any contact with the implementations.
    This can be accomplished by utilizing the underneath concept.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是一组接口和类，统称为库，它提供特定的功能。简单来说，我们可以称之为 API。服务有多种用途，它们被称为服务提供者（或者说实现）。利用这个服务的客户端将不会与实现有任何接触。这可以通过利用底层概念来实现。
- en: Java has `ClassLoader`, which simply loads the classes and creates instances
    of classes on runtime. Compared to Java 9 modules, `java.util.ServiceLoader` is
    capable of finding and loading all the service providers at a runtime for a service
    interface. The `ServiceLoader` class permits decoupling between the API and client
    app. The service loader will instantiate all the service providers that are implementing
    the service and makes it accessible to the client to utilize.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有 `ClassLoader`，它简单地加载类并在运行时创建类的实例。与 Java 9 模块相比，`java.util.ServiceLoader`
    能够在运行时找到一个服务的所有服务提供者。`ServiceLoader` 类允许 API 和客户端应用程序解耦。服务加载器将实例化所有实现服务的服务提供者，并使其可供客户端使用。
- en: Let's take an example of Notification Application containing API and a different
    implementation of API. We will create three modules, the first one with a service
    (API) module, the second one will be a provider (Implementation) module, and the
    last one will be a client module for the accessing service.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个包含 API 和 API 的不同实现的 Notification 应用程序为例。我们将创建三个模块，第一个是一个包含服务的（API）模块，第二个将是一个提供者（实现）模块，最后一个将是一个用于访问服务的客户端模块。
- en: Service (API) module
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务（API）模块
- en: 'The created API module with the name `com.packt.service.api`  contains a `NotificationService`
    interface to send notification and load service providers. To make this interface
    a service provider interface (SPI), we have to mention the `''use''` clause in
    `module-info.java`. Our module code will be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的名为 `com.packt.service.api` 的 API 模块包含一个 `NotificationService` 接口，用于发送通知和加载服务提供者。为了使这个接口成为一个服务提供者接口（SPI），我们必须在
    `module-info.java` 中提到 `'use'` 子句。我们的模块代码如下：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`module-info.java` will be as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`module-info.java` 将如下所示：'
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following  are the command line steps that need to be followed for the `com.packt.service.api`
    module jar. Assume that there will be an out directory in the `com.packt.service.api`
    module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要遵循的命令行步骤，用于 `com.packt.service.api` 模块 JAR。假设在 `com.packt.service.api`
    模块中会有一个输出目录：
- en: '![](img/00021.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: Service provider (Implementation) module
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务提供者（实现）模块
- en: 'Now, create a service provider module `com.packt.service.impl` to implement
    `NotificationService` service API, and for that we should define a "*provides
    ... with*" clause in the `module-info.java` file. The ***provides*** keyword is
    used to mention the service interface name and the ***with*** keyword is used
    to mention which implementation we want to load. In the event that the module
    doesn’t have the provides statement in the module descriptor file, the service
    loader will not load that module. The syntax of the ''*provides...with''* statement
    is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `com.packt.service.impl` 的服务提供者模块来实现 `NotificationService` 服务 API，为此我们应在
    `module-info.java` 文件中定义一个 "*provides ... with*" 子句。***provides*** 关键字用来提及服务接口名称，而
    ***with*** 关键字用来提及我们想要加载的实现。如果模块在模块描述符文件中没有提供语句，服务加载器将不会加载该模块。'*provides...with*'
    语句的语法如下：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To send an SMS message to a recipient we are creating two implementation classes, `SMSServiceImpl.java ` and
    `EmailServiceImpl`, by implementing  `NotificationService`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向收件人发送短信，我们创建了两个实现类，`SMSServiceImpl.java` 和 `EmailServiceImpl`，通过实现 `NotificationService`：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The module descriptor for this provider module will be as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此提供者模块的模块描述符如下所示：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To generate a jar file of the `com.packt.service.impl` module, we have to copy
    `notification-api.jar` of the service API module into the lib folder for compile
    time dependency resolution. The outcome of the following commands will be `sms-service.jar`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 `com.packt.service.impl` 模块的 jar 文件，我们必须将服务 API 模块的 `notification-api.jar`
    复制到 lib 文件夹中，以便在编译时解决依赖关系。以下命令的输出将是 `sms-service.jar`：
- en: '![](img/00022.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: 'Service Provider Rules:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供者规则：
- en: It always has a no-argument constructor. This constructor is used by the `ServiceLoader`
    class to instantiate the service provider using reflection.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它总是有一个无参构造函数。这个构造函数被 `ServiceLoader` 类用来通过反射实例化服务提供者。
- en: The provider must be a public concrete class. It should not be an abstract class
    or inner class.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者必须是一个公共的具体类。它不应该是一个抽象类或内部类。
- en: An occurrence of the implementation class must be consistent with the service
    interface.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现类的出现必须与服务接口一致。
- en: Service client application
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务客户端应用程序
- en: 'Now, create a client application named `com.packt.client`, which lists all
    implementation of `NotificationService` by calling the `getInstances()` method.
    A client application only *requires* the `com.packt.service.api` module as dependency
    in `module-info.java`. But we have to copy `notification-api.jar` and `sms-service.jar`
    into the lib folder to resolve compile time dependency of the service API and
    service provider module. Our `ClientApplication.java` and `module-info.java` will
    look as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `com.packt.client` 的客户端应用程序，通过调用 `getInstances()` 方法列出所有 `NotificationService`
    的实现。客户端应用程序在 `module-info.java` 中只需要 *requires* `com.packt.service.api` 模块作为依赖项。但我们必须将
    `notification-api.jar` 和 `sms-service.jar` 复制到 lib 文件夹中，以解决服务 API 和服务提供者模块的编译时依赖关系。我们的
    `ClientApplication.java` 和 `module-info.java` 将如下所示：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For our client application, we have to only mention the *requires* clause for
    `com.packt.service.api` in the `module-info.java` file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的客户端应用程序，我们只需要在 `module-info.java` 文件中提及 `com.packt.service.api` 的 *requires*
    子句：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are commands that need to run in order to run our client application.
    In the output we will get a message from `SMSServiceImpl.java`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要运行以运行我们的客户端应用程序的命令。在输出中，我们将从 `SMSServiceImpl.java` 获得一条消息：
- en: '![](img/00023.gif)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00023.gif)'
- en: Writing modular code using a command-line interface
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行界面编写模块化代码
- en: As a tradition, let's create a simple module called `helloApp`, which will have
    a simple message and will be required by another module called `helloClient`.
    Here, we will use a command line interface to create and run the module.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种传统，让我们创建一个简单的模块，命名为 `helloApp`，它将包含一个简单的消息，并且将被另一个名为 `helloClient` 的模块所需要。在这里，我们将使用命令行界面来创建和运行该模块。
- en: 'Create a `helloApp` module folder named `com.packt.helloapp` and a package
    folder named `com\packt\helloapp`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `com.packt.helloapp` 的 `helloApp` 模块文件夹和一个名为 `com\packt\helloapp` 的包文件夹：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, create a `HelloApp.java` component class under the package name `com.packt.helloapp\com\packt\helloapp`
    and a `modue-info.java` file at root folder `com.packt.helloapp`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在包名 `com.packt.helloapp\com\packt\helloapp` 下创建一个 `HelloApp.java` 组件类，并在根文件夹
    `com.packt.helloapp` 中创建一个 `modue-info.java` 文件：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we will create another module called `helloClient`. Create a `helloClient`
    module with the folder name `com.packt.hello.client` and a package with the folder
    name `com\packt\hello\client`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建另一个名为`helloClient`的模块。创建一个名为`com.packt.hello.client`的`helloClient`模块，并使用名为`com\packt\hello\client`的包：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s create another component class called `HelloClient.java` under the `com.packt.hello.client\com\packt\hello\client`
    package and create a `module-info.java` file at root folder `com.packt.hello.client`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`com.packt.hello.client\com\packt\hello\client`包下创建另一个名为`HelloClient.java`的组件类，并在根目录`com.packt.hello.client`下创建一个`module-info.java`文件：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both modules are independent modules so are not dependent on each other. But
    if we want to use a method called `sayHelloJava()` in the `HelloClient` class,
    then we have to import the module, otherwise it will give a compile time error
    `package com.packt.helloapp is not visible`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模块都是独立模块，因此它们之间没有依赖关系。但是，如果我们想在`HelloClient`类中使用名为`sayHelloJava()`的方法，那么我们必须导入该模块，否则将会在编译时出现错误`package
    com.packt.helloapp is not visible`。
- en: Defining dependency between modules
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模块之间的依赖关系
- en: 'To use `HelloApp`, we need to export the package `com.packt.helloapp` from
    the `helloApp`  module and include the `helloApp` module in the `helloClient`
    module:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`HelloApp`，我们需要从`helloApp`模块导出包`com.packt.helloapp`，并将`helloApp`模块包含在`helloClient`模块中：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From the preceding code, the first module descriptor, the `exports` keyword,
    indicates that packages are available to export to other modules. If a package
    is explicitly exported, then it is only accessible by other modules. If in a same
    module some packages are not exported, then it cannot be accessed by other modules.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，第一个模块描述符中的`exports`关键字表示包可供其他模块导出。如果一个包被显式导出，那么它只能被其他模块访问。如果在同一个模块中某些包没有被导出，那么它们就不能被其他模块访问。
- en: The second module descriptor uses the `requires` keyword to indicate that the
    module is dependent on the `com.packt.helloapp` module,  and this is called Dependency
    Injection in Java 9 Module.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模块描述符使用`requires`关键字来指示该模块依赖于`com.packt.helloapp`模块，这被称为Java 9模块的依赖注入。
- en: 'Finally, the `HelloClient` class will be as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`HelloClient`类将如下所示：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After creating two modules, the following will be the final tree structure:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了两个模块后，最终的树结构如下：
- en: '![](img/00024.gif)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.gif)'
- en: But wait, we only wrote the code and have not compiled and run it yet. Let's
    do that in the next section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，我们只写了代码，还没有编译和运行它。让我们在下一节中完成这个操作。
- en: Compiling and running modules
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行模块
- en: 'Let''s first compile the `HelloApp` module and then the `HelloClient` module.
    Before running the command, make sure that the Java 9 ClassPath is set. To compile
    module code, the following command needs to run:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先编译`HelloApp`模块，然后编译`HelloClient`模块。在运行命令之前，请确保Java 9 ClassPath已设置。要编译模块代码，需要运行以下命令：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On successful compilation it will generate `HelloApp.class` and `module-info.class`
    into the output directory.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成功后，它将在输出目录中生成`HelloApp.class`和`module-info.class`。
- en: 'As our `HelloApp` module is required by the `HelloClient` module, we should
    generate the `com.packt.helloapp` module jar to include it in the `HelloClient`
    module. To create a jar in the `mlib` folder, run the following jar command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`HelloApp`模块被`HelloClient`模块所依赖，我们应该生成`com.packt.helloapp`模块jar并将其包含在`HelloClient`模块中。要在`mlib`文件夹中创建jar，请运行以下jar命令：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, remove the output directory by running the following command and again
    make an output directory for the second module:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令删除输出目录，然后为第二个模块再次创建输出目录：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to compile the `HelloClient` module, we need to provide a reference
    of `com.packt.hellpapp.jar`  and `javac` commands and provide a way to pass `module-path` to
    refer to other modules. Here we pass the `mlib` directory as a module path. Without
    `module-path`, compilation of the `com.packt.hello.client ` module is not possible:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译`HelloClient`模块，我们需要提供一个`com.packt.hellpapp.jar`的引用和`javac`命令，并提供一种方法来传递`module-path`以引用其他模块。在这里，我们将`mlib`目录作为模块路径传递。没有`module-path`，`com.packt.hello.client`模块的编译将无法进行：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s run the module with the help of the following command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令运行模块：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output will be as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/00025.gif)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.gif)'
- en: 'At the end of the preceding example, we learned how to create a module and
    define Dependency Injection in Java modules. The following diagram shows how one
    module is dependent on another:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例结束时，我们学习了如何创建模块并在Java模块中定义依赖注入。以下图表显示了模块之间的依赖关系：
- en: '![](img/00026.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Here, the journey ends for Dependency Injection in Java 9\. Let's summarize
    what we learned from this chapter. Firstly, we learned key features introduced
    in Java 9, such as Java Platform Module System, JShell, JLink tool, multi-release
    of JAR, Enhanced Stream API, Stack-Walking PI, Immutable collection methods, and
    HTTP 2.0.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Java 9 中的依赖注入之旅就此结束。让我们总结一下本章所学的内容。首先，我们学习了 Java 9 中引入的关键特性，例如 Java 平台模块系统、JShell、JLink
    工具、JAR 的多版本发布、增强的流 API、堆栈跟踪 PI、不可变集合方法以及 HTTP 2.0。
- en: Secondly, in Modular Frameworks in Java 9 section,  we learned the meaning of
    modularity and the need of modular design in Java applications. We also learned
    how JPMS changes the earlier JDK into Modular JDK in detail.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在 Java 9 的模块化框架部分，我们学习了模块化的含义以及模块化设计在 Java 应用中的必要性。我们还详细了解了 JPMS 如何将早期的 JDK
    转变为模块化 JDK。
- en: After that we learned about an important element of modular systems, which is
    modules. We saw how module structure is defined with the help of different module
    descriptors and module types.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们了解了一个模块化系统的重要元素，即模块。我们看到了如何通过不同的模块描述符和模块类型来定义模块结构。
- en: And lastly, we learned how to write simple modules using commands to understand
    how Dependency Injection works in Java 9 between modules.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用命令编写简单的模块，以了解 Java 9 中模块间的依赖注入是如何工作的。
- en: In the next chapter, we will discuss concepts of Dependency Injection in Spring
    Framework in detail.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细讨论 Spring 框架中依赖注入的概念。
