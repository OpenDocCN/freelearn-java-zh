- en: Implementing Server-Side Components with Internationalization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用国际化实现服务器端组件
- en: Having a login form is arguably one of the most common requirements in web applications.
    In this chapter, you will learn how to implement a reusable and extensible login
    form that supports multiple languages, and see the advantages of favoring *composition*
    over *extension* when implementing UI components. Through examples, we'll discuss
    why *extension* is not always the best approach, and we'll explore several alternatives
    for implementing custom server-side UI components with Vaadin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，拥有一个登录表单可以说是最常见的需求之一。在本章中，你将学习如何实现一个可重用且可扩展的登录表单，它支持多种语言，并看到在实现UI组件时优先考虑*组合*而非*扩展*的优势。通过示例，我们将讨论为什么*扩展*并不总是最佳方法，并探讨使用Vaadin实现自定义服务器端UI组件的几种替代方案。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Extending layout components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展布局组件
- en: Using the `Composite` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Composite`类
- en: Externalization of Java Strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部化Java字符串
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要拥有Java SE开发工具包和Java EE SDK版本8或更高版本。你还需要Maven版本3或更高版本。建议使用具有Maven支持的Java IDE，如IntelliJ
    IDEA、Eclipse或NetBeans。最后，为了使用本书的Git仓库，你需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-03](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-03)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-03](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-03)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[https://goo.gl/fu8W3W](https://goo.gl/fu8W3W)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/fu8W3W](https://goo.gl/fu8W3W)'
- en: Using extensions to develop a UI component
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展来开发UI组件
- en: Let's explore how to implement a login form component. The first idea that comes
    to mind when starting to develop a UI component is to extend, in the Java sense,
    an existing component. Most of the time, the natural choice is to extend a layout
    component such as `VerticalLayout` or `HorizontalLayout`. For example, a login
    form usually includes at least a username field, a password field, a login button,
    and a remember me checkbox, with all of them aligned vertically. So, let's start
    by directly extending `VerticalLayout`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何实现一个登录表单组件。在开始开发UI组件时，脑海中首先浮现的想法是在Java意义上扩展现有组件。大多数情况下，自然的选择是扩展布局组件，如`VerticalLayout`或`HorizontalLayout`。例如，登录表单通常至少包括用户名字段、密码字段、登录按钮和一个记住我复选框，所有这些都垂直对齐。因此，让我们首先直接扩展`VerticalLayout`。
- en: Extending VerticalLayout
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展VerticalLayout
- en: 'The following snippet of code shows a typical way of extending `VerticalLayout`
    to implement a UI component, in this case, the login form:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了扩展`VerticalLayout`以实现UI组件的典型方式，在这种情况下，是登录表单：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The logic to handle events and additional UI configuration that might be required
    is omitted in the previous example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中省略了处理事件和可能需要的额外UI配置的逻辑。
- en: The full implementation of the `LoginFormLayout` class is located in the `Data-centric-Applications-with-Vaadin-8/chapter-03`
    Maven project of the source code that accompanies this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginFormLayout`类的完整实现位于本书附带源代码的`Data-centric-Applications-with-Vaadin-8/chapter-03`
    Maven项目中。'
- en: Why avoid extension?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么避免扩展？
- en: What is wrong with the previous implementation? Well, there's nothing inherently
    wrong with it. However, it can be highly improved. The `LoginFormLayout` class
    violates encapsulation! Clients of the class know that a `VerticalLayout` is used.
    All public methods of `VerticalLayout` are exposed to clients of `LoginFormLayout`.
    If, for some reason, the implementation needs to change to a different layout
    (a `FormLayout`, `CssLayout`, or even a `Panel`, for instance), clients calling
    any method in `VerticalLayout` that are not in the new base layout class would
    break.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个实现有什么问题？嗯，它本身并没有什么固有的问题。然而，它可以得到极大的改进。《LoginFormLayout》类违反了封装性！该类的客户端知道使用了`VerticalLayout`。`VerticalLayout`的所有公共方法都暴露给了`LoginFormLayout`的客户端。如果出于某种原因，实现需要更改为不同的布局（例如`FormLayout`、`CssLayout`，甚至是`Panel`），调用`VerticalLayout`中任何不在新基类中的方法的客户端将会出错。
- en: To the outside world, `LoginFormLayout` is a `Layout`. The purpose of a login
    form is not to serve as a layout (to position other components), but to show the
    fields that are required to authenticate users with the application. So, let's
    try to get more encapsulation into the design!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外界来说，`LoginFormLayout` 是一个 `Layout`。登录表单的目的不是作为布局（定位其他组件），而是显示用于验证用户与应用程序交互所需的字段。所以，让我们尝试在设计中获得更多的封装性！
- en: Using composition to develop custom components
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合来开发自定义组件
- en: 'If extending `VerticalLayout` is a problem, a possible solution is to not extend
    any class at all. However, in that case, we wouldn''t get a `Component`, but a
    class of which instances cannot be added to the components tree. What about extending
    a more suitable component in the hierarchy? Let''s start with interfaces. The
    following figure shows some of the top interfaces in the hierarchy:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果扩展 `VerticalLayout` 是一个问题，一个可能的解决方案是完全不扩展任何类。然而，在这种情况下，我们不会得到一个 `Component`，而是一个其实例不能添加到组件树中的类。那么扩展层次结构中更合适的组件怎么样？让我们从接口开始。以下图显示了层次结构中的一些顶级接口：
- en: '![](img/8fadb91a-9c91-4591-b36a-3ad65a8595e9.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fadb91a-9c91-4591-b36a-3ad65a8595e9.jpg)'
- en: 'Going up the hierarchy, we find the `Component` interface which has more than
    20 methods that would require an implementation. The other interfaces inherit
    these 20+ methods and add some more. Fortunately, Vaadin provides abstract implementations
    for these interfaces. The following figure shows some of the equivalent implementations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构中向上，我们找到了 `Component` 接口，它有超过 20 个需要实现的方法。其他接口继承这些 20 多个方法并添加一些。幸运的是，Vaadin
    为这些接口提供了抽象实现。以下图显示了其中的一些等效实现：
- en: '![](img/50d0b746-91f7-4bba-9f98-57031e8165df.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50d0b746-91f7-4bba-9f98-57031e8165df.jpg)'
- en: '`AbstractComponent` is the default implementation of `Component`. Many Vaadin
    components directly extend this class. It''s not a convenient class for the login
    form, though, since it''s too general and doesn''t offer methods to add other
    components to it. `AbstractField` and `AbstractListing` can be discarded as well
    because the login form is not just a field showing a value or a list of values,
    respectively.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractComponent` 是 `Component` 的默认实现。许多 Vaadin 组件直接扩展了这个类。然而，对于登录表单来说，它并不是一个方便的类，因为它太通用，并且不提供添加其他组件的方法。`AbstractField`
    和 `AbstractListing` 也可以被丢弃，因为登录表单不仅仅是一个显示值或值列表的字段。'
- en: The next candidates are the `AbstractSingleComponentContainer`, `AbstractComponentContainer`,
    and `AbstractLayout` classes. These classes help with the implementation of layouts,
    but as we discussed previously, a login form shouldn't look like a layout to the
    external world.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个候选类是 `AbstractSingleComponentContainer`、`AbstractComponentContainer` 和 `AbstractLayout`。这些类有助于布局的实现，但正如我们之前讨论的，登录表单不应该在对外界看来像布局一样。
- en: Implementing a factory
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现工厂
- en: 'How about a factory of components? The following is an implementation of a
    factory with a method that returns a `Component`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么组件工厂怎么样？以下是一个包含返回 `Component` 方法的工厂实现：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This hides the implementation details but also makes it more difficult and complex
    to offer functionality to the clients. For example, how would clients of the class
    get the username or password values introduced by the user in the form? One option
    is to implement getters in the factory class, but that would require some more
    adjustments in the `LoginFormFactory` class. At the end of the day, this kind
    of implementation would require you to implement (and maintain) two highly coupled
    classes for a single custom component. Not a very good idea.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这隐藏了实现细节，但也使得向客户端提供功能变得更加困难和复杂。例如，类客户端如何获取用户在表单中输入的用户名或密码值？一个选项是在工厂类中实现获取器，但这将需要在
    `LoginFormFactory` 类中进行一些调整。最终，这种实现将需要你为单个自定义组件实现（并维护）两个高度耦合的类。这不是一个好主意。
- en: Using the Composite class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用复合类
- en: 'If you have some experience with Vaadin, chances are that you already know
    the `CustomComponent` class. The `Composite` class works in the same way as the
    `CustomComponent` class, but it''s more lightweight since it only adds a simple
    `<div>` element to the DOM in the browser. The `Composite` class eases the development
    of compositions of components by eliminating some of the problems previously described.
    `Composite` directly extends `AbstractComponent`, which means that any class extending
    `Composite` is a `Component` itself that can be added to any Vaadin layout. A
    `Composite` can specify a composition root that serves as the root of the components
    tree (usually a layout), for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些Vaadin的经验，那么你很可能已经知道`CustomComponent`类。`Composite`类以与`CustomComponent`类相同的方式工作，但它更轻量，因为它只在浏览器DOM中添加一个简单的`<div>`元素。`Composite`类通过消除之前描述的一些问题来简化组件组合的开发。`Composite`直接扩展了`AbstractComponent`，这意味着任何扩展`Composite`的类本身就是一个`Component`，可以添加到任何Vaadin布局中。`Composite`可以指定一个组合根，作为组件树（通常是布局）的根，例如：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the LoginForm class
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`LoginForm`类
- en: 'Vaadin comes with a `LoginForm` class that, by default, renders a username
    and a password field. It also adds *auto-completion* and *auto-fill* in the browser.
    The `LoginForm` class is a good candidate for extension (and you have to extend
    it if you want to override its defaults). For example, the following snippet of
    code creates a `loginForm` and a listener that is invoked when the user clicks
    the login button:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Vaadin自带一个`LoginForm`类，默认情况下，它会渲染用户名和密码字段。它还在浏览器中添加了*自动完成*和*自动填充*功能。`LoginForm`类是一个很好的扩展候选（如果你想要覆盖其默认设置，你必须扩展它）。例如，以下代码片段创建了一个`loginForm`和一个监听器，当用户点击登录按钮时会被调用：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To add more fields to the form, override the `createContent` method. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要向表单中添加更多字段，请覆盖`createContent`方法。例如：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Despite its design for extension, it''s always a good idea to hide implementation
    details by extending `Composite` and abstracting away the underlying `LoginForm`
    class. The following snippet of code shows a first iteration of the new `LoginFormComponent`
    class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其设计是为了扩展，但总是通过扩展`Composite`并抽象出底层的`LoginForm`类来隐藏实现细节是一个好主意。以下代码片段展示了新`LoginFormComponent`类的一个初始迭代：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `createContent` method is called internally by the `LoginForm` class. Notice
    how the `username` and `password` variables are assigned to references in the
    `LoginFormComponent` class. These references can be used later to retrieve the
    values in the fields.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`createContent`方法由`LoginForm`类内部调用。注意`username`和`password`变量是如何在`LoginFormComponent`类中被分配给引用的。这些引用可以在以后用来检索字段中的值。'
- en: 'Allowing clients of the `LoginFormComponent` class to be notified when the
    user clicks the login button can be implemented with a custom `LoginListener`
    interface:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 允许`LoginFormComponent`类的客户端在用户点击登录按钮时被通知可以通过自定义`LoginListener`接口来实现：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `LoginListener` interface defines one method that accepts a `LoginFormComponent`.
    Now, it''s easy to define getters to allow clients to obtain the values in the
    fields:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginListener`接口定义了一个接受`LoginFormComponent`的方法。现在，定义getter以允许客户端获取字段中的值变得很容易：'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If a new component is added to the login form in future, it's possible to add
    a getter to return the value in the added field without breaking existing clients
    of the class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来在登录表单中添加了新的组件，可以添加一个getter来返回添加的字段中的值，而不会破坏现有客户端的类。
- en: The final version of the `LoginFormComponent` class can be found in the `Data-centric-Applications-with-Vaadin-8\chapter-03`
    Maven project of the source code that accompanies this book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginFormComponent`类的最终版本可以在本书所附源代码的`Data-centric-Applications-with-Vaadin-8\chapter-03`
    Maven项目中找到。'
- en: Using internationalization for Multiple Language Support
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用国际化支持多语言
- en: '**Internationalization** is the process of making an application ready to support
    several languages and data formats. An internationalized application can be adapted
    for a particular language and region, a process known as *localization*, which
    consists of adding a specific set of resources (usually text, images, and data
    formats) to an internationalized application. Ideally, localization should not
    require rebuilding the application, but only adding the localized resources and,
    at most, restarting the web container.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**国际化**是指使一个应用程序准备好支持多种语言和数据格式的过程。一个国际化的应用程序可以被适应特定的语言和地区，这个过程称为**本地化**，它包括向国际化的应用程序添加一组特定的资源（通常是文本、图像和数据格式）。理想情况下，本地化不应该需要重新构建应用程序，而只需添加本地化资源，最多只需要重新启动Web容器。'
- en: Addressing internationalization early in a software development project and
    knowing the audience makes the process much easier. Internationalization is orthogonal
    to all the application layers, and the process of localizing can involve translating
    and defining several resources such as texts, images, videos, audio files, number
    formats, date formats, currency symbols, and even colors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发项目的早期阶段处理国际化，并了解受众，可以使这个过程变得容易得多。国际化与所有应用程序层都是正交的，本地化的过程可能涉及翻译和定义多个资源，如文本、图像、视频、音频文件、数字格式、日期格式、货币符号，甚至颜色。
- en: Removing hardcoded strings
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除硬编码的字符串
- en: 'Custom reusable UI components should not depend on the mechanism used to handle
    internationalization. The `LoginFormComponent`, for instance, should include setters
    (or alternatively, parameters in the constructor) to configure the captions of
    the inner UI components. The following implementation shows how to use setters
    to configure captions in the login form:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义可重用UI组件不应依赖于处理国际化的机制。例如，`LoginFormComponent`应该包含设置器（或者也可以在构造函数中提供参数）来配置内部UI组件的标题。以下实现展示了如何使用设置器在登录表单中配置标题：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It's a good idea to provide defaults and a method to set all the captions in
    one call. The implementation in the example application includes such features.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提供默认值并提供一种方法，在一次调用中设置所有标题，这是一个好主意。示例应用程序中的实现包括这些功能。
- en: Getting localized strings
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取本地化字符串
- en: At this point, the `LoginFormComponent` can be internationalized. The next step
    is to pass the strings containing the captions in the correct language. Usually,
    the `Locale` and `ResourceBundle` standard Java classes are good enough to externalize
    localized messages. However, it is also a good idea to isolate string externalization
    logic into a separate class that allows clients to add resource bundles and get
    localized strings by name. Encapsulating this logic into a separate class allows
    you to change the underlying mechanism (for example, to read the messages from
    a database) and add features such as caching without affecting the rest of the
    application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`LoginFormComponent`可以进行国际化。下一步是传递包含正确语言标题的字符串。通常，`Locale`和`ResourceBundle`标准Java类足够用于外部化本地化消息。然而，将字符串外部化逻辑隔离到单独的类中也是一个好主意，这样客户端可以通过名称添加资源包并获取本地化字符串。将此逻辑封装到单独的类中允许你更改底层机制（例如，从数据库中读取消息）并添加诸如缓存等特性，而不会影响应用程序的其他部分。
- en: 'The following is an implementation of the `Messages` utility class used to
    encapsulate string externalization logic:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`Messages`实用类实现的示例，用于封装字符串外部化逻辑：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This class can be used to register a *base name* used internally by the standard
    `ResourceBundle` class. This base name should match the name of the properties
    files with the translations. For example, to add English and Spanish messages,
    you have to create two files, `messages_en.properties` and `messages_es.properties`.
    The `messages` part in the name of these files corresponds to the *base name*.
    You can load these resource bundles by calling `Messages.addBundle("messages")`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以用来注册标准`ResourceBundle`类内部使用的**基本名称**。这个基本名称应该与包含翻译的属性文件名称匹配。例如，为了添加英语和西班牙语消息，你必须创建两个文件，`messages_en.properties`和`messages_es.properties`。这些文件名称中的`messages`部分对应于**基本名称**。你可以通过调用`Messages.addBundle("messages")`来加载这些资源包。
- en: The `Messages` class is located in the `Data-centric-Applications-with-Vaadin-8\chapter-03`
    Maven project of the source code that accompanies this book. The class includes
    a method to get all the available languages that you can use to allow end users
    to change the language from the UI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Messages` 类位于与本书配套的源代码的 `Data-centric-Applications-with-Vaadin-8\chapter-03`
    Maven 项目中。该类包含一个获取所有可用语言的方法，以便允许最终用户从 UI 中更改语言。'
- en: 'Supporting a new language is as easy (or complicated) as adding a new `.properties`
    file (in the `resources` directory) containing the translated properties. For
    example, a `messages_en.properties` file could define the following properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 支持新语言与添加新的 `.properties` 文件（在 `resources` 目录中）一样简单（或复杂），该文件包含翻译后的属性。例如，`messages_en.properties`
    文件可以定义以下属性：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To support Spanish, for example, you would have to add a `messages_es.properties`
    file with the following content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持西班牙语，例如，您需要添加一个包含以下内容的 `messages_es.properties` 文件：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that you have to use *unicode scape* *syntax* if you want to include special
    characters (like the Spanish *n* with a *tilde* in the example).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您想包含特殊字符（如示例中的西班牙语 *n* 带有 *波浪号*），则必须使用 *Unicode 转义* 语法。
- en: 'You can get a message in the language of the browser by calling `Messages.get("property")`.
    For example, the following snippet of code sets the correct labels for the components
    in the `LoginFormComponent`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用 `Messages.get("property")` 来获取浏览器语言的短信。例如，以下代码片段为 `LoginFormComponent`
    中的组件设置了正确的标签：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting and setting the locale
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和设置区域设置
- en: 'Vaadin automatically sets the `Locale` reported by the browser. You can get
    this `Locale` by calling the `UI::getLocale()` method and the `UI::setLocale(Locale)`
    method to set the `Locale` for the current user. The example application in this
    chapter uses the locale reported by the browser. There''s no need do anything
    else except add the resource bundle using the helper `Messages` class. The example
    application does this in a static block in the `UI` implementation (the `VaadinUI`
    class):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Vaadin 会自动设置浏览器报告的 `Locale`。您可以通过调用 `UI::getLocale()` 方法来获取此 `Locale`，并通过调用
    `UI::setLocale(Locale)` 方法来设置当前用户的 `Locale`。本章的示例应用程序使用浏览器报告的 `Locale`。除了使用辅助
    `Messages` 类添加资源包外，无需做其他任何事情。示例应用程序在 `UI` 实现的静态块中这样做（`VaadinUI` 类）：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In more complex scenarios, you should use an event listener such as `ServletContextListener`
    to add the resource bundle when the context starts, for example.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的场景中，您应该使用事件监听器，如 `ServletContextListener`，在上下文启动时添加资源包，例如。
- en: You can configure your browser in a different language to test this functionality.
    How to configure this may depend on your browser and operating system vendor.
    In Chrome, however, you can use the Language settings. Just move the language
    that you wish to test to the top of the list. You have to restart Chrome for this
    change to take effect.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置浏览器以不同的语言来测试此功能。如何配置可能取决于您的浏览器和操作系统供应商。然而，在 Chrome 中，您可以使用语言设置。只需将您要测试的语言移动到列表的顶部。您必须重新启动
    Chrome 以使此更改生效。
- en: 'The following is a screenshot of the `LoginFormComponent` using the Spanish
    locale:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是使用西班牙语区域设置的 `LoginFormComponent` 的截图：
- en: '![](img/3f35b3de-cc5e-43d0-af68-5d8a7fe59631.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f35b3de-cc5e-43d0-af68-5d8a7fe59631.png)'
- en: Internationalization requires a constant effort throughout the development of
    UIs. Try to catch yourself *hard-coding* strings and immediately fix them by creating
    an entry in the appropriate properties file. Incorporate this practice into your
    coding routine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化需要在 UI 开发的整个过程中持续努力。尝试捕捉自己 *硬编码* 字符串，并立即通过在适当的属性文件中创建条目来修复它们。将此实践纳入您的编码常规中。
- en: When implementing truly internationalized applications, you should have a well-defined
    and simple process that allows translators to create all the localizations (translations)
    for new resources. A way of doing this is by using well-defined directories or
    files that translators can take and complete (by translating the strings, for
    example) before a new production-ready artifact is constructed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现真正国际化的应用程序时，您应该有一个定义良好且简单的流程，允许翻译者创建所有新资源的所有本地化（翻译）。这样做的一种方法是通过使用定义良好的目录或文件，翻译者可以在构建新的生产就绪工件之前取走并完成（例如，通过翻译字符串）。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to design UI components with the help of object-oriented
    techniques by considering several approaches such as extending layout components,
    extending a specialized component, and using composition with the help of the
    `Composite` class. We developed a `LoginForm` class that uses the browser's language
    to show captions in the appropriate language.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过考虑几种方法，如扩展布局组件、扩展专用组件以及使用`Composite`类进行组合，学习了如何在面向对象技术的帮助下设计UI组件。我们开发了一个`LoginForm`类，该类使用浏览器的语言来显示适当的语言字幕。
- en: In the next chapter, you will learn how to make the login form functional by
    adding authentication and authorization capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过添加身份验证和授权功能来使登录表单变得可用。
