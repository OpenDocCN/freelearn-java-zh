- en: Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: We are constantly looking for new ways to create software systems that cater
    for both happy customers who have applications that support their business needs
    and developers who are challenged by cutting-edge technologies. The balance of
    satisfying these two types of target user is important; it allows us to achieve
    our business goals and avoid losing skilled developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断寻找新的方法来创建软件系统，以满足既支持他们业务需求的应用程序的满意客户，又受到尖端技术挑战的开发人员。满足这两种目标用户的平衡很重要；这使我们能够实现业务目标，避免失去技术娴熟的开发人员。
- en: On the other hand, as developers, we are also trying to create modules and specialized
    libraries that address specific technical or business needs. Later, we will reuse
    these modules and libraries across different projects to comply with the **don't
    repeat yourself** (**DRY**) principle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，作为开发人员，我们也在努力创建模块和专门的库，以满足特定的技术或业务需求。稍后，我们将在不同的项目中重用这些模块和库，以符合“不要重复自己”（DRY）原则。
- en: 'Using this introduction as a point of departure, we are going to review how
    microservices architectures can address these concerns and more. In this chapter,
    we are going to look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个介绍作为出发点，我们将回顾微服务架构如何解决这些问题以及更多内容。在本章中，我们将讨论以下主题：
- en: Principles of microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务原则
- en: Modeling microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模微服务
- en: 'How to implement microservices using Spring Cloud:'
  id: totrans-6
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Spring Cloud实现微服务：
- en: Supporting dynamic configuration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持动态配置
- en: Enabling service discovery and registration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用服务发现和注册
- en: Edge services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务
- en: The circuit breaker pattern and Hystrix
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器模式和Hystrix
- en: Principles of microservices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务原则
- en: 'There are a lot of definitions of microservices that are available on the web.
    One that comes up frequently is the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上有很多微服务的定义。经常出现的一个是以下内容：
- en: '"Microservices are small and autonomous services that work well together."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “微服务是小型且自主的服务，能够良好地协同工作。”
- en: Let's start looking at this definition and what it means in a little more detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个定义开始，更详细地了解它的含义。
- en: Size
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小
- en: 'The fact that the word microservices contains the word *micro* leads us to
    think that the service''s size must be really small. However, it''s almost impossible
    to define what the right size of the services should be using metrics such as
    how many lines of code or files there are, or the size of a particular deployable
    artifact. Instead, it''s much simpler to use the following idea:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务一词中包含“微”这个词，让我们认为服务的大小必须非常小。然而，几乎不可能使用诸如代码行数、文件数量或特定可部署工件的大小等指标来定义服务的正确大小。相反，使用以下想法要简单得多：
- en: '"A service should be focused on doing one thing well."'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “一个服务应专注于做好一件事。”
- en: '- Sam Newman'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '- Sam Newman'
- en: 'That *one thing* can be thought of as one business domain. If you''re building
    systems for an online store, for example, they might cover the following **business
    domains**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那“一件事”可以被视为一个业务领域。例如，如果您正在为在线商店构建系统，它们可能涵盖以下业务领域：
- en: Customer management
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户管理
- en: Product catalog
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品目录
- en: Shopping cart
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: Orders
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: The idea is to build one service that is able to address all the demands of
    a particular business domain. Eventually, you might also end up breaking a service
    into other microservices when the business domain becomes too big to be handled
    as just one microservice.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是构建一个能够满足特定业务领域所有需求的服务。最终，当业务领域变得太大，无法仅作为一个微服务处理时，您可能还会将一个服务拆分为其他微服务。
- en: Autonomous
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主的
- en: Autonomy is really important when we are talking about microservices. A microservice
    should have the ability to change and evolve independently to the rest of the
    services around it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自主性在谈论微服务时非常重要。微服务应该有能力独立于其周围的其他服务进行更改和演变。
- en: The best way to verify whether a microservice is autonomous enough is by applying
    a change to it and deploying the new version of the service. The deployment process
    should not require you to modify anything other than the service itself. If you
    need to restart other services or anything else during the deployment process,
    you should consider ways of removing those additional steps. On the other hand,
    the autonomy of a service is also related to the organization of the team that
    is building it. We will discuss this in detail later on in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 验证微服务是否足够自主的最佳方法是对其进行更改并部署服务的新版本。部署过程不应要求您修改除服务本身之外的任何内容。如果在部署过程中需要重新启动其他服务或其他任何内容，您应考虑消除这些额外步骤的方法。另一方面，服务的自主性也与构建它的团队的组织有关。我们将在本章后面详细讨论这一点。
- en: Working well together
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好协同工作
- en: It is not possible to build systems in isolation that don't interact with one
    another. Even though we are building separate services to address the requirements
    of different business domains, we eventually need to make them interact as a whole
    in order to meet the demands of the business. This interaction is carried out
    by using **application programming interfaces** (**API**).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在孤立地构建不相互交互的系统是不可能的。即使我们正在构建不同业务领域需求的独立服务，最终我们也需要使它们作为一个整体进行交互，以满足业务需求。这种交互是通过使用应用程序编程接口（API）来实现的。
- en: '"An API is a set of commands, functions, protocols, and objects that programmers
    can use to create software or interact with an external system. It provides developers
    with standard commands for performing common operations so they do not have to
    write the code from scratch."'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “API是程序员可以用来创建软件或与外部系统交互的一组命令、函数、协议和对象。它为开发人员提供了执行常见操作的标准命令，因此他们不必从头编写代码。”
- en: '- API definition from https://techterms.com/definition/api'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '- API定义来自https://techterms.com/definition/api'
- en: Monolithic applications tend to carry out database integration. This is something
    that should be avoided at all costs; any required interaction between services
    should only be done using the provided service APIs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单片应用程序往往进行数据库集成。这是应该尽量避免的事情；任何所需的服务之间的交互应该只使用提供的服务API来完成。
- en: Advantages
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: 'Microservices offer many advantages that are worth knowing to understand how
    a company might benefit. The most common advantages are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务提供了许多值得了解的优势，以了解公司可能如何受益。最常见的优势如下：
- en: Alignment to the single responsibility principle
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符合单一责任原则
- en: Continuous releases
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续发布
- en: Independent scalability
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立可伸缩性
- en: Increased adoption of new technology
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加对新技术的采用
- en: Alignment to the single responsibility principle
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符合单一责任原则
- en: Using microservices involves creating separate components. Every component is
    designed to address a specific business domain model. Consequently, this domain
    model defines the service's single responsibility. The service should not violate
    its limits and it should request any information that falls outside of them using
    the provided APIs of other microservices. Each microservice should expose an API
    with all the required functionality to allow other microservices to obtain information
    from it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务涉及创建单独的组件。每个组件都设计为解决特定的业务领域模型。因此，该领域模型定义了服务的单一责任。服务不应违反其限制，并且应该使用其他微服务提供的API请求任何超出其范围的信息。每个微服务应该暴露一个API，其中包含所有必需的功能，以允许其他微服务从中获取信息。
- en: Continuous releases
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续发布
- en: Since large, monolithic applications handle many business domain models, they
    are comprised of a huge amount of source code and configuration files. This produces
    large artifacts that take a considerable amount of time to be deployed. Furthermore,
    large monolithic applications often involve large teams that are distributed around
    the world, which makes communication difficult. This becomes a problem when working
    on new features or fixing bugs in the application. Microservices are able to tackle
    this problem easily because one team will be in charge of one or more services,
    and a service is rarely written by more than one team. This means that new releases
    can be planned within the team, which allows them to roll out new versions faster
    and more frequently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大型的单片应用程序处理许多业务领域模型，它们由大量的源代码和配置文件组成。这会产生需要大量时间才能部署的大型构件。此外，大型单片应用程序通常涉及分布在世界各地的大型团队，这使得沟通困难。在开发新功能或修复应用程序中的错误时，这会成为一个问题。微服务能够轻松解决这个问题，因为一个团队将负责一个或多个服务，并且一个服务很少由多个团队编写。这意味着新版本可以在团队内计划，这使得他们能够更快更频繁地推出新版本。
- en: Additionally, even the smallest change in the code involves a new deployment
    of the large artifact, which makes the entire application unavailable during the
    deployment process. For microservices, however, only the service that has the
    patch for the bug or the new feature should be deployed. The deployment is fast
    and doesn't affect other services.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使代码中的最小更改也需要部署大型构件，这使得整个应用程序在部署过程中不可用。然而，对于微服务，只需部署具有漏洞修补程序或新功能的服务。部署速度快，不会影响其他服务。
- en: Independent scalability
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立可伸缩性
- en: If we need to scale a monolithic application, the entire system should be deployed
    on different servers. The servers should be really powerful to allow the application
    to perform well. Not all of the features have the same traffic, but since all
    the code is bundled as a single artifact, there is no way to scale only the desired
    features. With microservices, we have the freedom to scale only what we need.
    It's common to find cloud providers offering the chance to scale an application
    by provisioning more servers on demand or adding more resources automatically
    when they are needed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要扩展一个单片应用程序，整个系统应该部署在不同的服务器上。服务器应该非常强大，以使应用程序能够良好运行。并非所有功能都具有相同的流量，但由于所有代码都打包为单个构件，因此无法仅扩展所需的功能。使用微服务，我们有自由只扩展我们需要的部分。通常可以找到云提供商提供通过按需提供更多服务器或在需要时自动添加更多资源来扩展应用程序的机会。
- en: Increased adoption of new technologies
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新技术的增加采用
- en: 'Not all business domain models are equals, which is why different sets of technologies
    are needed. Since one microservice should only address the demands of one domain
    model, different services can adopt different technologies easily. It''s common
    to find companies using different programming languages, frameworks, cloud providers,
    and databases to code their microservices. Furthermore, we have the ability to
    experiment with new technologies for small applications, which can then be used
    elsewhere. As a consequence of embracing new technologies, companies end up with
    heterogeneous applications, as shown in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有业务领域模型都是相等的，这就是为什么需要不同的技术集。由于一个微服务只应处理一个领域模型的需求，因此不同的服务可以轻松采用不同的技术。通常可以找到公司使用不同的编程语言、框架、云提供商和数据库来编写他们的微服务。此外，我们有能力为小型应用程序尝试新技术，然后可以在其他地方使用。由于采用新技术，公司最终会拥有异构应用程序，如下图所示：
- en: '![](img/442ed02e-81a5-4135-999c-05b281bb3aba.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/442ed02e-81a5-4135-999c-05b281bb3aba.png)'
- en: Heterogeneous applications allow us to create specialized systems to solve specific
    business demands using the right set of technologies. As a result of this, we
    end up having small artifacts that are easy to deploy and scale in isolation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 异构应用程序使我们能够使用正确的技术集创建专门的系统来解决特定的业务需求。因此，我们最终会拥有易于部署和独立扩展的小构件。
- en: Drawbacks
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'Even though microservices have all the benefits that we listed earlier, it''s
    important to understand that they do have a few downsides as well. Let''s review
    these and consider how they can be dealt with:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微服务具有我们之前列出的所有优点，但重要的是要理解它们也有一些缺点。让我们回顾一下这些，并考虑如何处理它们：
- en: Too many options
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择太多
- en: Slow at the beginning
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一开始慢
- en: Monitoring
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: Transactions and eventual consistency
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务和最终一致性
- en: Too many options
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择太多
- en: Since you have the opportunity to choose which technology you want to build
    a microservice with, you might feel overwhelmed because of the wide variety of
    options available. This can be solved by using just a few new technologies instead
    of trying to fit them all in at once.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您有机会选择要使用哪种技术构建微服务，您可能会因为可用选项的广泛多样而感到不知所措。这可以通过仅使用少量新技术而不是一次性尝试将它们全部整合来解决。
- en: Slow at the beginning
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一开始慢
- en: When you're in the process of adopting microservices, you have to build the
    entire ecosystem in order to make them work. You need to look for new ways to
    connect the distributed systems, secure them, and make them work as a whole. Writing
    just one application to do all this is easier. However, after a few months, the
    other microservices will reuse all the work that you put in at the beginning,
    meaning the process speeds up significantly. To take full advantage of this way
    of creating systems, it is important to try out new ways of deploying applications,
    making them scale on demand, monitoring them, and logging them. It's also important
    to review the functionality of microservices that handle the core of the business.
    These systems sometimes end up being semi-monoliths that should be split up in
    order to make them easier to manage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用微服务的过程中，您必须构建整个生态系统以使它们运行。您需要寻找连接分布式系统、保护它们并使它们作为一个整体运行的新方法。编写一个应用程序来完成所有这些工作更容易。然而，几个月后，其他微服务将重复使用您一开始投入的所有工作，这意味着流程速度显著加快。要充分利用这种创建系统的方式，重要的是尝试新的部署应用程序的方式，使其按需扩展，监控和记录它们。还重要的是审查处理业务核心的微服务的功能。这些系统有时最终成为半单体应用，应该拆分以便更容易管理。
- en: Monitoring
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: Monitoring a single application is easier than monitoring many instances of
    different services. It's important to create dashboards and automated tools that
    provide metrics in order to make this task easier to accomplish. When a new error
    occurs, it can be hard to figure out where the problem is. A good log-tracing
    mechanism should be used to identify which service of the application is not working
    as expected. This means that you don't have to analyze all the services.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 监控单个应用比监控许多不同服务的实例更容易。重要的是创建仪表板和自动化工具，提供指标以使这项任务更容易完成。当出现新错误时，很难弄清楚问题出在哪里。应该使用良好的日志跟踪机制来确定应用的哪个服务未按预期工作。这意味着您不必分析所有服务。
- en: Transactions and eventual consistency
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务和最终一致性
- en: While large monoliths have their transaction boundaries well-defined, and because
    we often use techniques such as two-phase commits when we are writing microservices,
    we have to approach these requirements in another way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大型单体应用有着明确定义的事务边界，而且我们在编写微服务时经常使用两阶段提交等技术，但我们必须以另一种方式来满足这些要求。
- en: We should remember that each microservice is the owner of its own data storage,
    and we should access their data using only their APIs. It is important to keep
    your data up to date and use compensating transactions when an operation doesn't
    work as expected. When we write monolithic applications, many operations are executed
    as a single transaction. For microservices, we need to rethink the operations
    and transactions to make them fit within each microservice boundary.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记住，每个微服务都拥有自己的数据存储，并且我们应该仅使用它们的API来访问它们的数据。保持数据最新并在操作不符合预期时使用补偿事务是很重要的。当我们编写单体应用时，许多操作作为单个事务执行。对于微服务，我们需要重新思考操作和事务，使它们适应每个微服务的边界。
- en: Modeling microservices
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模微服务
- en: 'As developers, we always try to create reusable components to interact with
    systems or services in order to avoid writing code more than once. Most monolithic
    applications that we have built so far have followed a three-tier architectural
    pattern, as shown in the following diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们总是试图创建可重用的组件来与系统或服务交互，以避免重复编写代码。到目前为止，我们构建的大多数单体应用都遵循了三层架构模式，如下图所示：
- en: '![](img/01da1f47-1a59-4f7a-b61b-761ce7deb621.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01da1f47-1a59-4f7a-b61b-761ce7deb621.png)'
- en: Three-tier architecture
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 三层架构
- en: When a change is required in an application that is built using this model,
    you often need to modify all three layers. Depending on how the application is
    created, you might need many deployments. Furthermore, since large monolithic
    applications share a lot of functionality, it's common to find more than one team
    working on them, which makes it even harder for them to evolve quickly. Sometimes,
    specialized teams work on particular layers because these layers are comprised
    of many components. In this way, changes are applied horizontally to make the
    application grow and evolve.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要对使用此模型构建的应用进行更改时，通常需要修改所有三层。根据应用程序的创建方式，可能需要进行多次部署。此外，由于大型单体应用共享许多功能，通常会发现有多个团队在其上工作，这使得它们更难快速发展。有时，专门的团队会在特定层上工作，因为这些层由许多组件组成。通过这种方式，可以水平应用更改以使应用程序增长和发展。
- en: 'With microservices, applications evolve vertically because they are modeled
    around a specific business domain. The following diagram shows a few microservices
    for an online store application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务，应用程序在特定业务领域周围建模，因此应用程序在垂直方向上发展。以下图表显示了在线商店应用程序的一些微服务：
- en: '![](img/6e0cad3b-c090-41a7-bcdc-7a268937aeab.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e0cad3b-c090-41a7-bcdc-7a268937aeab.png)'
- en: Microservices diagram
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务图表
- en: The names by themselves explain the intention and the collection of capabilities
    associated with the microservices. Just by reading the names, anyone can understand
    what they do; how the tasks are carried out and how they are implemented is irrelevant
    at this point. Since these services are built around a well-defined business domain,
    only one service should be modified when a new change is required. Since no more
    than one team should work on a microservice, making them evolve is easier in comparison
    to large monoliths. The team in charge of the service has a deep understanding
    of how that particular service works and how to make it evolve.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称本身就解释了微服务的意图和相关功能集合。仅通过阅读名称，任何人都可以理解它们的功能；如何执行任务以及它们如何实现在这一点上是无关紧要的。由于这些服务围绕着一个明确定义的业务领域构建，当需要进行新更改时，只有一个服务应该被修改。由于不止一个团队应该在一个微服务上工作，与大型单体相比，使它们发展变得更容易。负责服务的团队深刻了解特定服务的工作方式以及如何使其发展。
- en: The team in charge of a microservice is composed of experts in that service's
    business domain, but not in the technology of the other services around it. After
    all, technology choices consist of details; the principle motivation of the service
    is the business domain.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 负责微服务的团队由该服务业务领域的专家组成，但不擅长其周围其他服务的技术。毕竟，技术选择包括细节；服务的主要动机是业务领域。
- en: Speeding up
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速
- en: We mentioned earlier in this chapter that developing an application based on
    microservices is a time-consuming process at the beginning because you are literally
    starting from scratch. Whether you're starting a new project or splitting an existing
    legacy application into separate microservices, you have to work on all the necessary steps to
    bring an application from development to production.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面提到，基于微服务开发应用程序在开始阶段是一个耗时的过程，因为您从头开始。无论您是开始一个新项目还是将现有的遗留应用程序拆分为单独的微服务，您都必须完成将应用程序从开发到生产的所有必要步骤。
- en: Accelerating the development process
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速开发过程
- en: 'Let''s start at the development stage. When you''re working on old applications,
    you usually have to go through the following steps before writing the first line
    of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开发阶段开始。当您在旧应用程序上工作时，通常在编写第一行代码之前，您必须经历以下步骤：
- en: Install the required tools in your local machine.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地机器上安装所需的工具。
- en: Set up all the required dependencies.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置所有必需的依赖项。
- en: Create one or more configuration files.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个或多个配置文件。
- en: Discover all the missing parts that were not listed as part of the documentation.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现所有未列入文档的缺失部分。
- en: Load the test data.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载测试数据。
- en: Run the application.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。
- en: Now, let's say you're working as part of a team that owns many microservices
    that are written in different programming languages and that use different database
    technologies. Can you imagine the effort required before writing your first line
    of code?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您是作为一个团队的一部分，拥有用不同编程语言编写并使用不同数据库技术的许多微服务。您能想象在编写第一行代码之前需要多少努力吗？
- en: Using microservices is supposed to be able to provide you with faster solutions,
    but all the setup required makes it slower initially. For a large monolithic application,
    you only have to set up one environment, but for heterogeneous applications, you'll
    have to set up many different environments. In order to approach this problem
    effectively, you need to embrace a culture of automation. Instead of executing
    all the aforementioned steps manually, you can run a script to do that for you.
    In this way, every time you want to work on a different project, you only need
    to execute the script instead of repeating all the steps listed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务应该能够为您提供更快的解决方案，但所需的所有设置使其在最初变得更慢。对于大型单片应用程序，您只需要设置一个环境，但对于异构应用程序，您将需要设置许多不同的环境。为了有效地解决这个问题，您需要拥抱自动化文化。您可以运行脚本来代替手动执行所有上述步骤。这样，每当您想要在不同的项目上工作时，您只需要执行脚本，而不是重复列出的所有步骤。
- en: There are some really cool tools available on the market, such as Nanobox ([https://nanobox.io](https://nanobox.io)),
    Docker Compose ([https://docs.docker.com/compose/](https://docs.docker.com/compose/)),
    and Vagrant ([https://www.vagrantup.com](https://www.vagrantup.com)) . These can
    help you by providing an environment similar to the production environment by
    running a single command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有一些非常酷的工具，比如Nanobox（https://nanobox.io）、Docker Compose（https://docs.docker.com/compose/）和Vagrant（https://www.vagrantup.com）。这些工具可以通过运行单个命令提供类似于生产环境的环境，从而帮助您。
- en: Adopting tools such as the ones mentioned in the preceding tip will have a great
    impact on the productivity of the development team. You don't want developers
    wasting their time by providing their own environments; instead, you want them
    writing code to add new features to your product.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 采用前面提到的工具将对开发团队的生产力产生巨大影响。您不希望开发人员浪费时间提供自己的环境；相反，您希望他们编写代码为产品添加新功能。
- en: Embracing tests
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥抱测试
- en: Let's talk about the code-writing process. When we are working on large monoliths,
    many people need to be notified every time that a new feature or bug fix is released.
    In extreme cases, the QA team needs to check the entire environment themselves
    to ensure that the new changes didn't affect the application's existing functionality.
    Imagine how time-consuming it would be to repeat this task for every release with
    multiple microservices. For this reason, you need to adopt testing as an essential
    part of your development process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈编写代码的过程。当我们在大型单体上工作时，每次发布新功能或错误修复时都需要通知许多人。在极端情况下，QA团队需要自行检查整个环境，以确保新更改不会影响应用程序的现有功能。想象一下为多个微服务的每次发布重复执行此任务会耗费多少时间。因此，您需要将测试作为开发过程的必要部分。
- en: 'There are many different levels of testing. Let''s take a look at the pyramid
    test introduced by Jason Huggins in 2005, which is shown in the following diagram:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同级别的测试。让我们来看一下Jason Huggins在2005年引入的金字塔测试，如下图所示：
- en: '![](img/6c7dbaa5-4d0c-4e3d-a378-6efdaf5a0fcb.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c7dbaa5-4d0c-4e3d-a378-6efdaf5a0fcb.png)'
- en: Pyramid test
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔测试
- en: The tests that are part of the pyramid's base are easy and quick to write and
    execute. Running unit tests only takes a few minutes, and is useful to validate
    that isolated pieces of code work as expected. Integration tests, on the other
    hand, are useful to validate that the code works when it's interacting with external
    services, such as databases, third-party applications, or other microservices.
    These tests will take a few tens of minutes to run. Finally, **end-to-end** (**e2e**)
    tests help you to validate that the code works as expected from an end user perspective.
    If you're writing a REST API, the e2e tests will validate the HTTP response codes
    from your API using different data. These tests are usually slow, and they change
    all the time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔底部的测试很容易且快速编写和执行。运行单元测试只需要几分钟，对验证隔离的代码片段是否按预期工作很有用。另一方面，集成测试对验证代码在与数据库、第三方应用程序或其他微服务交互时是否正常工作很有用。这些测试需要几十分钟才能运行。最后，端到端（e2e）测试帮助您验证代码是否符合最终用户的预期。如果你正在编写一个REST
    API，e2e测试将使用不同的数据验证API的HTTP响应代码。这些测试通常很慢，而且它们一直在变化。
- en: Ideally, all of your new features should go through all of these tests to verify
    that your code is working as expected before going into production. The more tests
    you write, the more confidence you will gain. After all, if you've covered all
    the possible scenarios, what could go wrong? To add to this, Michael Bryzek introduced
    the idea of testing in production (see [https://www.infoq.com/podcasts/Michael-Bryzek-testing-in-production](https://www.infoq.com/podcasts/Michael-Bryzek-testing-in-production) for
    more information). This helps you to assess whether your services are working
    by executing automated tasks or bots regularly to exercise the key parts of your
    systems in production.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，所有新功能都应该经过所有这些测试，以验证您的代码在进入生产之前是否按预期工作。你写的测试越多，你就会获得越多的信心。毕竟，如果你覆盖了所有可能的情况，还会出什么问题呢？此外，Michael
    Bryzek提出了在生产中进行测试的想法（有关更多信息，请参见[https://www.infoq.com/podcasts/Michael-Bryzek-testing-in-production](https://www.infoq.com/podcasts/Michael-Bryzek-testing-in-production)）。这有助于您通过定期执行自动化任务或机器人来评估您的服务是否正常运行，以在生产中运行系统的关键部分。
- en: Going to production
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投入生产
- en: You have to automate the production environment in the same way that you automate
    the development environment. Today, it is common to find companies using cloud
    providers to deploy their systems and API-driven tools to provide servers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须以与自动化开发环境相同的方式自动化生产环境。如今，公司普遍使用云提供商部署其系统，并使用API驱动工具提供服务器。
- en: Installing an OS and adding the dependencies needed to make an application work
    is something that must be automated. If you want to provide many servers, you
    just have to execute the same script several times. Technologies such as Docker,
    Puppet, and Chef can help you to do this. An indirect benefit of using code to
    provide environments is that you'll have the perfect documentation for all the
    required dependencies to make an application work. Over time, these scripts can
    be improved. They are stored in version control systems, which makes it easy to
    track every single change made to them. We will look at this further in [Chapter
    11](81e880b2-2345-4231-b7d5-d558f3c55955.xhtml), *DevOps and Release Management*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 安装操作系统并添加所需的依赖项以使应用程序工作必须自动化。如果要提供多台服务器，只需多次执行相同的脚本。Docker、Puppet和Chef等技术可以帮助你做到这一点。使用代码提供环境的间接好处是，你将拥有使应用程序工作所需的所有依赖项的完美文档。随着时间的推移，这些脚本可以得到改进。它们存储在版本控制系统中，这样就很容易跟踪对它们所做的每一次更改。我们将在[第11章](81e880b2-2345-4231-b7d5-d558f3c55955.xhtml)
    *DevOps和发布管理*中进一步讨论这一点。
- en: Implementing microservices
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施微服务
- en: Now that we have a good understanding of what microservices are and what they
    are intended for, we are going to start looking at how to implement a microservice
    architecture using Spring Framework. Over the next few sections, we are going
    to look at some of the important concepts that we haven't covered so far. It's
    better to approach these from a practical viewpoint to make them easier to understand.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对微服务的定义和用途有了很好的理解，我们将开始学习如何使用Spring Framework实施微服务架构。在接下来的几节中，我们将看一些到目前为止还没有涉及的重要概念。最好从实际角度来接触这些概念，以便更容易理解。
- en: Dynamic configuration
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态配置
- en: We have all worked on applications that use different configuration files or
    associated metadata to allow you to specify configuration parameters that make
    an application work. When we are talking about microservices, we need to approach
    this configuration process in a different way. We should avoid configuration files
    and instead adopt the twelve-fact app configuration style (as outlined at [https://12factor.net](https://12factor.net)),
    proposed by Heroku. When we are using this configuration style, we want to externalize
    all the properties that are different in each environment and make them easy and convenient to
    create and change.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都曾经在使用不同配置文件或相关元数据的应用程序上工作，以允许你指定使应用程序工作的配置参数。当我们谈论微服务时，我们需要以不同的方式来处理这个配置过程。我们应该避免配置文件，而是采用由Heroku提出的十二要素应用程序配置风格（在[https://12factor.net](https://12factor.net)中概述）。当我们使用这种配置风格时，我们希望将每个环境中不同的属性外部化，并使其易于创建和更改。
- en: By default, Spring Boot applications can work using command-line arguments,
    JNDI names, or environment variables. Spring Boot also provides the ability to
    use a `.properties` or `.yaml` configuration file. In order to work with configuration
    variables in a safe way, Spring Boot has introduced the `@ConfigurationProperties`
    annotation, which allows you to map properties to **plain old Java objects** (**POJOs**).
    When the application is starting, it checks that all the configurations are provided,
    have the right format, and comply with the requirements demanded by the `@Valid`
    annotation. Let's take a look at how this mapping works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot应用程序可以使用命令行参数、JNDI名称或环境变量工作。Spring Boot还提供了使用`.properties`或`.yaml`配置文件的能力。为了以安全的方式处理配置变量，Spring
    Boot引入了`@ConfigurationProperties`注释，它允许您将属性映射到**普通的Java对象**（**POJOs**）。应用程序启动时，它会检查所有配置是否已提供、格式是否正确，并符合`@Valid`注释要求的需求。让我们看看这个映射是如何工作的。
- en: 'Let''s say that you have the following `application.yaml` file as part of your
    application:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序中有以下`application.yaml`文件：
- en: '[PRE0]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s map these variables to two different POJOs using the `@ConfigurationProperties`
    annotation. Let''s start with the middleware configuration that is given:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`@ConfigurationProperties`注释将这些变量映射到两个不同的POJO中。让我们从给定的中间件配置开始：
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following code snippet represents the class needed for the `eventBus` configuration
    section:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段代表了`eventBus`配置部分所需的类：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `@Data` annotation from lombok has been used to avoid writing standard
    accessors methods. You can now print the `.toString()` result of these classes,
    and you will see the following output in your console:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lombok的`@Data`注释来避免编写标准访问器方法。现在，您可以打印这些类的`.toString()`结果，并且您将在控制台中看到以下输出：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It can be useful to have all of these configuration variables hardcoded. This
    means that when you want to deploy the application in another environment, you
    can simply override them by providing additional parameters, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些配置变量硬编码可能很有用。这意味着当您想要在另一个环境中部署应用程序时，您可以通过提供额外的参数来简单地覆盖它们，如下所示：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we are overriding one of the configuration variables before running the
    `.jar` file, so the output that you will get is shown as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`.jar`文件之前，我们在文件中覆盖了一个配置变量，因此您将得到如下所示的输出：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though this configuration is easy to achieve, it is not good enough for
    microservices, or any modern application in general. First of all, after applying
    any change, you need to restart the application, which is not desirable. The worst
    part is that you can't keep track of the changes that you have applied. This means
    that if an environment variable is provided, there is no way to know who provided
    it. In order to tackle this problem, Spring provides a way to centralize all of
    the configurations using the Spring Cloud Configuration server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种配置很容易实现，但对于微服务或一般的现代应用程序来说还不够好。首先，在应用任何更改后，您需要重新启动应用程序，这是不可取的。最糟糕的是，您无法跟踪您所应用的更改。这意味着如果提供了环境变量，就无法知道是谁提供的。为了解决这个问题，Spring提供了一种集中所有配置的方法，使用Spring
    Cloud配置服务器。
- en: The server provides a centralized, journaled, and secure way to store the configuration
    values. Since it stores all the configuration values in a Git repository that
    can be local or remote, you'll have all the benefits associated with a version-control
    system for free.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务器提供了一种集中、记录和安全的方式来存储配置值。由于它将所有配置值存储在可以是本地或远程的Git存储库中，因此您将免费获得与版本控制系统相关的所有好处。
- en: Implementing a configuration server
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施配置服务器
- en: 'A Spring Cloud configuration server is built on the top of a regular Spring
    Boot application. All you need to do is add the following additional dependency:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud配置服务器是建立在常规Spring Boot应用程序之上的。您只需要添加以下附加依赖项：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the dependency has been added, you need to activate the configuration
    server using an additional annotation in the application, as shown in the following
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 添加依赖项后，您需要使用应用程序中的附加注释来激活配置服务器，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, you need to provide the Git repository URL, which stores the configuration
    for your microservices in the `application.yaml` file, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要提供存储微服务配置的Git存储库URL，存储在`application.yaml`文件中，如下所示：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding Git repository has separate configuration files to manage the
    configuration for each microservice. For example, the `configuration-demo.properties` file is
    used to manage the configuration for the configuration demo microservice.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Git存储库有单独的配置文件来管理每个微服务的配置。例如，`configuration-demo.properties`文件用于管理配置演示微服务的配置。
- en: Implementing a configuration client
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施配置客户端
- en: 'Configuration clients are regular Spring Boot applications. All you need to
    do is provide the server configuration URI to read the centralized configuration,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 配置客户端是常规的Spring Boot应用程序。您只需要提供服务器配置URI以读取集中配置，如下所示：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code snippet shows a REST endpoint reading a centralized configuration
    and serving the read value as its own response:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个REST端点，读取集中配置并将读取的值作为自己的响应提供：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the configuration file stored in the Git repository:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了存储在Git存储库中的配置文件：
- en: '![](img/f41e5b6e-ec7e-45fb-b14b-8461c1d5e3e4.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f41e5b6e-ec7e-45fb-b14b-8461c1d5e3e4.png)'
- en: Configuration file stored in a Git repository
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在Git存储库中的配置文件
- en: 'Once you execute a request against the preceding endpoint, it will produce
    the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对前面的端点执行请求，它将产生以下输出：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Change the value of the configuration variable in the file stored in Git, as
    shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更改存储在Git中的文件中的配置变量的值，如下面的屏幕截图所示：
- en: '![](img/92a82e19-3a7a-44fc-98ef-4ec55933662c.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92a82e19-3a7a-44fc-98ef-4ec55933662c.png)'
- en: The configuration file with the change applied
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更改后的配置文件
- en: 'If you hit the endpoint, you will retrieve the same output as before. In order
    to reload the configuration, you will need to reload the configuration variables
    by hitting the `/refresh` endpoint by using a `POST` request, as shown in the
    following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问端点，将检索到与之前相同的输出。为了重新加载配置，您需要通过使用`POST`请求命中`/refresh`端点来重新加载配置变量，如下代码所示：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After reloading the configuration, the endpoint will serve a response using
    the new provided value, as you can see in the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载配置后，端点将使用新提供的值提供响应，如下输出所示：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Service discovery and registration
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现和注册
- en: 'In the past, our applications lived on a single physical server where we had
    a 1:1 relation between the application and the backend implementing it. In this
    case, looking for a service is really simple: you only need to know the server
    IP address or the associated DNS name.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，我们的应用程序存在于单个物理服务器上，应用程序与实施它的后端之间存在1:1的关系。在这种情况下，查找服务非常简单：您只需要知道服务器的IP地址或相关的DNS名称。
- en: Later on, applications were distributed, which means that they lived on many
    physical servers to provide high availability. In this case, we have a 1:*N* relationship
    between a service and the backend servers, where *N* can represent more than one.
    Incoming requests are managed using a load balancer to route the requests among
    the available servers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，应用程序被分布，这意味着它们存在于许多物理服务器上以提供高可用性。在这种情况下，服务与后端服务器之间存在1:*N*的关系，其中*N*可以表示多个。传入请求使用负载均衡器进行管理，以在可用服务器之间路由请求。
- en: The same approach is used when the physical servers are replaced by virtual
    machines. Load balancers need some configuration to register the new servers available
    and route the requests properly. This task used to be executed by the operations
    team.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理服务器被虚拟机替换时，使用相同的方法。负载均衡器需要一些配置来注册新的可用服务器并正确路由请求。这项任务过去由运维团队执行。
- en: Today, it's common to find applications deployed within containers, which we
    will discuss further in [Chapter 10](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml),
    *Containerizing your Applications*. Containers are constantly being provided and
    destroyed every millisecond, so registering new servers manually is an impossible
    task and must be automated. For this purpose, Netflix created a project named
    the Eureka project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，常见的是在容器中部署应用程序，我们将在[第10章](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml)中进一步讨论，*容器化您的应用程序*。容器每毫秒都在不断提供和销毁，因此手动注册新服务器是不可能的任务，必须自动化。为此，Netflix创建了一个名为Eureka的项目。
- en: Introducing Eureka
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Eureka
- en: 'Eureka is a tool that allows you to discover and register servers automatically.
    You can think about it as a phone directory where all the services are registered.
    It helps to avoid establishing direct communications among servers. For example,
    let''s say you have three services and all of them are interacting with each other.
    The only way to make them work as a whole is by specifying the IP addresses and
    ports for the servers or their load balancers, as shown in the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka是一个允许您自动发现和注册服务器的工具。您可以将其视为一个电话目录，其中所有服务都注册了。它有助于避免在服务器之间建立直接通信。例如，假设您有三个服务，它们都相互交互。使它们作为一个整体工作的唯一方法是指定服务器或其负载均衡器的IP地址和端口，如下图所示：
- en: '![](img/e1c9b79a-b9e3-4659-8b69-8ba590c91a23.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1c9b79a-b9e3-4659-8b69-8ba590c91a23.png)'
- en: Services interacting with each other
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 服务相互交互
- en: 'As you can see in the preceding image, the interaction occurs directly between
    the servers or their load balancers. When a new server is added, it should be
    registered in the load balancer either manually or with an existing automated
    mechanism. Additionally, using Eureka, you can establish a communication using
    the service names registered on it. The following diagram shows how the same interactions
    would work with Eureka:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，交互直接发生在服务器或它们的负载均衡器之间。当添加新服务器时，应手动或使用现有的自动化机制在负载均衡器中注册它。此外，使用Eureka，您可以使用在其上注册的服务名称建立通信。以下图表显示了相同的交互如何与Eureka一起工作：
- en: '![](img/ae639f43-2562-4a8d-ad5c-c629b24571a1.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae639f43-2562-4a8d-ad5c-c629b24571a1.png)'
- en: Services registered using Eureka
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eureka注册的服务
- en: This means that when you need to establish a communication among services, you
    only need to provide the name instead of the IP address and port. Eureka will
    also work as a load balancer when more than one instance of a service is available.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当您需要在服务之间建立通信时，您只需要提供名称而不是IP地址和端口。当一个服务有多个实例可用时，Eureka也将作为负载均衡器工作。
- en: Implementing a Netflix Eureka service registry
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Netflix Eureka服务注册表
- en: 'Since Eureka was created to allow a smooth integration with Spring Boot, a
    service registry can be implemented simply by adding the following dependency:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Eureka是为了允许与Spring Boot平稳集成而创建的，因此可以通过添加以下依赖项来简单实现服务注册表：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `application` class should be modified as well to indicate that the application
    will work as a Eureka server, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`application`类也应该被修改，以指示应用程序将作为Eureka服务器工作，如下所示：'
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After running the application, you can see the web console at `http://localhost:8901/`,
    as shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序后，您可以在`http://localhost:8901/`看到Web控制台，如下截图所示：
- en: '![](img/5ea2fea4-1bdc-4882-bfc1-e16b8f311f2e.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ea2fea4-1bdc-4882-bfc1-e16b8f311f2e.png)'
- en: Eureka web console
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka Web控制台
- en: Implementing a service registry client
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务注册表客户端
- en: Previously, we mentioned that a load balancer used to be used to offer high
    scalability by using more than one server as a backend. Eureka works in the same
    way, but the main benefit is that you won't need to add any configuration in the
    service registry when more instances of a server are provisioned. Instead, every
    instance should let Eureka know that it wants to be registered.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到过负载均衡器曾经用于通过使用多个服务器作为后端来提供高可伸缩性。Eureka以相同的方式工作，但主要好处是当服务器的更多实例被提供时，您不需要在服务注册表中添加任何配置。相反，每个实例都应让Eureka知道它想要注册。
- en: 'Registering a new service is quite simple. You just need to include the following
    dependency:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注册新服务非常简单。您只需要包含以下依赖项：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The service application class should include an additional annotation that
    will be discovered, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应用程序类应包括一个附加的注解，如下所示：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To finish up, you will need to specify the Eureka server URI as part of the
    `application.properties` file, as shown in the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在`application.properties`文件中指定Eureka服务器URI，如下所示：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After running this Spring Boot application, it will be automatically registered
    in Eureka. You can verify this by refreshing the Eureka web console. You will
    see that the service is registered, as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此Spring Boot应用程序后，它将自动在Eureka中注册。您可以通过刷新Eureka Web控制台来验证这一点。您将看到服务已注册，如下截图所示：
- en: '![](img/784bdd55-5354-4bc4-9e78-1b3e24bfc6fc.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/784bdd55-5354-4bc4-9e78-1b3e24bfc6fc.png)'
- en: Registered instances in Eureka
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka中注册的实例
- en: Once the services are registered, you will want to consume them. One of the
    easiest ways to consume services is by using Netflix Ribbon.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务注册，您将希望消费它们。使用Netflix Ribbon是消费服务的最简单方式之一。
- en: Netflix Ribbon
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix Ribbon
- en: Ribbon is a client-side, load balancing solution that has a smooth integration
    with the Spring Cloud ecosystem. It can consume a service that is exposed using
    Eureka simply by specifying the service name. Since all the server instances are
    registered in Eureka, it will choose one of them to execute the request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon是一个客户端负载均衡解决方案，与Spring Cloud生态系统无缝集成。它可以通过指定服务名称来消费使用Eureka暴露的服务。由于所有服务器实例都在Eureka中注册，它将选择其中一个来执行请求。
- en: Let's say we have another service named `cinema-service`. Say that this service
    has an endpoint that can be used to query a cinema by its ID. As part of the cinema
    payload, we want to include all the movies that are available in the `movies-service`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有另一个名为`cinema-service`的服务。假设该服务有一个端点，可以用来按ID查询电影院。作为电影院负载的一部分，我们希望包括`movies-service`中所有可用的电影。
- en: 'First of all, we need to add the following dependency:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加以下依赖项：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, as part of the `application` class, we need to create a new `RestTemplate`
    bean that will be injected in order to consume the services available in Eureka:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，作为`application`类的一部分，我们需要创建一个新的`RestTemplate` bean，以便注入以消费Eureka中可用的服务：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `RestTemplate` phrase is a client that is used to consume RESTful web services.
    It can execute a request against the `movies-service` as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestTemplate`短语是用于消费RESTful web服务的客户端。它可以执行对`movies-service`的请求如下：'
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note how the service name is specified, and we don't have to provide any other
    information, such as the IP address or the port. This is good because it would
    be impossible to determine this information when new servers are being created
    and destroyed on demand.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意服务名称的指定方式，我们不必提供任何其他信息，如IP地址或端口。这很好，因为在新服务器按需创建和销毁时，确定这些信息将是不可能的。
- en: Edge services
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务
- en: 'An edge service is an intermediary component that is exposed to both the outside
    world and the downstream services. It works as a gateway that allows for interaction
    between all the services around it. The following diagram shows how an edge service
    is used:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务是一个中间组件，对外部世界和下游服务都是可见的。它作为一个网关，允许周围所有服务之间的交互。以下图表显示了边缘服务的使用方式：
- en: '![](img/a6d4231e-c5b5-4c63-9916-65351fb64aab.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6d4231e-c5b5-4c63-9916-65351fb64aab.png)'
- en: An edge service
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务
- en: Note that all the incoming requests are pointing directly to the edge service,
    which will later look for the right service to redirect the request properly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有传入请求都直接指向边缘服务，后者将稍后查找正确的服务以正确重定向请求。
- en: 'Edge services are used in different ways to add additional behavior or functionalities
    according to the services around them. The most common example is a cross-origin
    resource sharing (CORS) ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS))
    filter. You can add a CORS filter to an edge service, and this would mean that
    the downstream services won''t need to implement anything. Say that we only want
    to allow incoming requests from the domain **abc.com**. We can implement this
    logic as part of the edge service, as shown in the following diagram:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务以不同的方式使用，根据周围的服务添加额外的行为或功能。最常见的例子是跨域资源共享（CORS）([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS))过滤器。您可以向边缘服务添加CORS过滤器，这意味着下游服务不需要实现任何内容。假设我们**只**想允许来自域**abc.com**的传入请求。我们可以将此逻辑作为边缘服务的一部分实现，如下图所示：
- en: '![](img/44c5a40f-277c-4153-9fc7-4f8b786940f9.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44c5a40f-277c-4153-9fc7-4f8b786940f9.png)'
- en: A CORS filter using an edge service
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边缘服务的CORS过滤器
- en: Here, we can see that all the logic is added in one place only, and that the
    downstream services don't have to implement anything to manage the required behavior.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有逻辑只添加在一个地方，下游服务不必实现任何内容来管理所需的行为。
- en: Edge services are also used for many other requirements that we will discuss
    in the next section. Different implementations of edge services are available
    on the market. In the next section, we are going to talk about Netflix's Zuul,
    because it provides a smooth integration with Spring Cloud.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务还用于许多其他需求，我们将在下一节讨论。市场上有许多不同的边缘服务实现。在下一节中，我们将讨论Netflix的Zuul，因为它与Spring Cloud集成得很顺畅。
- en: Introducing Zuul
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Zuul
- en: Zuul is an edge service created by Netflix that bases its functionality around
    filters. Zuul filters follow the interceptor filter pattern (as described at [http://www.oracle.com/technetwork/java/interceptingfilter-142169.html](http://www.oracle.com/technetwork/java/interceptingfilter-142169.html)).
    Using filters, you can perform a set of actions on HTTP requests and responses
    during their routing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul是Netflix创建的边缘服务，其功能基于过滤器。Zuul过滤器遵循拦截器过滤器模式（如[http://www.oracle.com/technetwork/java/interceptingfilter-142169.html](http://www.oracle.com/technetwork/java/interceptingfilter-142169.html)中所述）。使用过滤器，您可以在路由过程中对HTTP请求和响应执行一系列操作。
- en: Zuul is the name of a gatekeeper that is taken from a movie (see [http://ghostbusters.wikia.com/wiki/Zuul](http://ghostbusters.wikia.com/wiki/Zuul) for
    more details), and represents exactly the functionality that this project has,
    namely that of a gatekeeper.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul是一个来自电影的门卫的名字（请参阅[http://ghostbusters.wikia.com/wiki/Zuul](http://ghostbusters.wikia.com/wiki/Zuul)了解更多详情），它确切地代表了这个项目的功能，即门卫的功能。
- en: 'You can apply the filter during four phases, as shown in the following diagram:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在四个阶段应用过滤器，如下图所示：
- en: '![](img/17767e7f-7cd0-417a-933f-62bed7f88750.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17767e7f-7cd0-417a-933f-62bed7f88750.png)'
- en: Zuul filters
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul过滤器
- en: 'Let''s review each one of these phases:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这些阶段：
- en: '**pre**: Before the request is processed'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pre**：在请求被处理之前'
- en: '**route**: During the routing of the request to the service'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**route**：在将请求路由到服务时'
- en: '**post**: After the request has been processed'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**post**：在请求被处理后'
- en: '**error**: When an error occurs during the request'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**error**：当请求发生错误时'
- en: 'Using these phases, you can write your own filter to handle different requirements.
    Some common uses for filters during the `pre` phase are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些阶段，您可以编写自己的过滤器来处理不同的需求。`pre`阶段的一些常见用途如下：
- en: Authentication
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Authorization
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: Rate limits
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Translation and transformation operations in the request body
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求正文中的翻译和转换操作
- en: Custom headers injection
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义标头注入
- en: Adapters
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: 'Some common uses of filters in the `route` phase are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`route`阶段的一些常见过滤器用途如下：'
- en: Canary releases
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: Proxying
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: 'Once a request has been processed by the microservice, you have two scenarios:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个请求被微服务处理，就会有两种情况：
- en: Succesful processing
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理成功
- en: Error during the processing of the request
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求处理过程中发生错误
- en: 'If the request was successful, all the filters associated with the `post` phase
    will be executed. Some common uses of filters that are executed during this phase
    are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求成功，将执行与`post`阶段相关的所有过滤器。在此阶段执行的一些常见过滤器用途如下：
- en: Translation and transformation operations in the response payload
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应有效负载中的翻译和转换操作
- en: Storing of metrics associated with the business itself
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储与业务本身相关的度量标准
- en: 'On the other hand, when errors occur during the processing of the requests,
    then all the `error` filters will be executed. Some common uses of filters in
    this phase are as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当请求处理过程中发生错误时，所有`error`过滤器都将被执行。此阶段过滤器的一些常见用途如下：
- en: Saving the associated metadata of requests
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存请求的相关元数据
- en: Removing technical details from the response for security reasons
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出于安全原因，从响应中删除技术细节
- en: The preceding points are just a few common uses of filters during each phase.
    Think about your own business when writing filters that target your needs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述观点只是每个阶段过滤器的一些常见用途。在编写针对您需求的过滤器时，请考虑您自己的业务。
- en: 'In order to write a Zuul filter, the `ZuulFilter` class should be extended.
    This class has the following four abstract methods that needed to be implemented:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个Zuul过滤器，应该扩展`ZuulFilter`类。这个类有以下四个需要实现的抽象方法：
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The two methods shown in bold are not directly declared in the `ZuulFilter`
    class, but are instead inherited from the `IZuulFilter` interface that is implemented
    by this class.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体显示的两个方法并不是直接在`ZuulFilter`类中声明的，而是从`IZuulFilter`接口继承而来，这个接口是由这个类实现的。
- en: Let's review each one of these methods to understand how a Zuul filter works.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这些方法，以了解Zuul过滤器的工作原理。
- en: 'First, you have the `filterType` method, where you need to specify the phase
    in which you want to execute the current filter. The valid values of this method
    are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您有`filterType`方法，需要在其中指定要执行当前过滤器的阶段。该方法的有效值如下：
- en: '`pre`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre`'
- en: '`post`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`'
- en: '`route`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`'
- en: '`error`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`'
- en: 'You can write the preceding values by yourself, but it is better to use the
    `FilterConstant` class, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己编写上述值，但最好使用`FilterConstant`类，如下所示：
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All the phases are listed in the class that we mentioned previously:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所有阶段都列在我们之前提到的类中：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `filterOrder` method is used to define the order in which the filter will
    be executed. It's common to have more than one filter in each phase, so by using
    this method, you can configure the desired order for each filter. The highest
    value represents a low order of execution.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterOrder`方法用于定义将执行过滤器的顺序。每个阶段通常有多个过滤器，因此通过使用该方法，可以为每个过滤器配置所需的顺序。最高值表示执行顺序较低。'
- en: 'It is easy to configure the execution order by using the `org.springframework.core.Ordered`
    interface, which has two values that can be used as references:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`org.springframework.core.Ordered`接口，可以轻松配置执行顺序，该接口有两个值可用作参考：
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `shouldFilter` method is used to determine whether the filter logic should
    be executed or not. In this method, you can access the request information using
    the `RequestContext` class, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldFilter`方法用于确定是否应执行过滤逻辑。在这个方法中，你可以使用`RequestContext`类来访问请求信息，如下所示：'
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method should return a boolean value that indicates whether the `run` method
    should be executed or not.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法应该返回一个布尔值，指示是否应执行`run`方法。
- en: Finally, the `run` method contains the logic that's applied in the filter. In
    this method, you can also use the `RequestContext` class to perform the desired
    logic.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`run`方法包含在过滤器中应用的逻辑。在这个方法中，你也可以使用`RequestContext`类来执行所需的逻辑。
- en: 'For example, let''s use the endpoint implemented previously to query the movies
    screened by a cinema:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用之前实现的端点来查询电影院放映的电影：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is a simple implementation to print the requested method and
    URL:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的实现，用于打印请求的方法和URL：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the request has been processed, you will have the following output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求被处理，你将得到以下输出：
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: CAP theorem
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAP定理
- en: 'In 2000, during the **Symposium on Principles of Distributed Computing** (**SPDC**),
    Eric Brewer presented the following theory:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年的**分布式计算原理研讨会**（**SPDC**）上，Eric Brewer提出了以下理论：
- en: '"It is impossible for a shared-data system to simultaneously provide more than
    two of the three properties (consistency, high-availability and partition tolerance)
    at the same time."'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: “一个共享数据系统不可能同时提供这三个属性中的两个以上（一致性、高可用性和分区容错）。”
- en: '- Eric Brewer'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '- Eric Brewer'
- en: Let's review these three properties.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下这三个属性。
- en: Consistency
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性
- en: A consistent system is able to report its current state in every subsequent
    operation until the state is explicitly changed by an external agent. In other
    words, every `read` operation should retrieve the data that was last written.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一致的系统能够在每次后续操作中报告其当前状态，直到状态被外部代理显式更改。换句话说，每个`read`操作应该检索到上次写入的数据。
- en: High availability
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高可用性
- en: High availability refers to the system's ability to always provide a valid response
    when it retrieves any request from an external agent. In a perfect world, the
    system should always be able to handle incoming requests and never produce errors.
    It should at least handle them in a way that is not perceptible to the user.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 高可用性指的是系统在从外部代理检索任何请求时始终能够提供有效的响应能力。在理想的情况下，系统应该始终能够处理传入的请求，从不产生错误。至少应该以对用户不可感知的方式处理它们。
- en: Partition tolerance
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区容错
- en: A partition tolerant distributed system should always keep operating, even when
    communication with one of its nodes cannot be established.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分区容错的分布式系统应该始终保持运行，即使与其节点之一的通信无法建立。
- en: Brewer's theory can be applied to any distributed system in general. Since microservices
    architectures are based on the concepts of distributed computing, this means that
    this theory applies to them as well.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Brewer的理论可以应用于任何分布式系统。由于微服务架构是基于分布式计算概念的，这意味着这个理论也适用于它们。
- en: Even though the theory states that a system won't be able to accomplish all
    three properties at the same time, we should build systems that are able to handle
    failures gracefully. This is where the circuit breaker pattern can be applied.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管理论表明系统无法同时实现所有三个属性，我们应该构建能够优雅处理故障的系统。这就是断路器模式可以应用的地方。
- en: Circuit breaker
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器
- en: 'The circuit breaker pattern is intended to handle failures that are created
    when a system interacts with other systems that are running in different processes
    using remote calls. The main idea behind this pattern is to wrap the call with
    an object that is able to monitor failures and produce successful responses, as
    shown in the following diagram:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式旨在处理系统与其他运行在不同进程中的系统进行远程调用时产生的故障。该模式的主要思想是用一个能够监视故障并产生成功响应的对象来包装调用，如下图所示：
- en: '![](img/084f7ab6-ed84-41c0-871d-1d552f66326f.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/084f7ab6-ed84-41c0-871d-1d552f66326f.png)'
- en: Circuit breaker pattern
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式
- en: Note that the circuit breaker pattern provides an alternate response once a
    connection can't be established with the targeted service. Let's look at how to
    implement this pattern and make it part of our application using Hystrix.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，断路器模式在无法与目标服务建立连接时提供替代响应。让我们看看如何使用Hystrix来实现这种模式并将其纳入我们的应用程序。
- en: Hystrix
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hystrix
- en: 'Hystrix is a library that was created by Netflix in 2011\. It was created to
    deal with latency and connection problems when interactions with external services
    are executed. The main aim of Hystrix was to provide an alternate method to be
    executed when a communication problem occurs. It can be implemented as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix是Netflix于2011年创建的一个库。它是为了处理与外部服务交互时的延迟和连接问题而创建的。Hystrix的主要目的是在通信问题发生时提供一种替代方法来执行。它可以这样实现：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note how the `getMovies` method tries to interact with another service to get
    a list of movies. The method is annotated with `@HystrixCommand(fallbackMethod
    = "emptyMoviesArray")`. The `fallbackMethod` value indicates the alternate method
    to be used as an alternative if an error occurs during communication with other
    services. In this case, the alternate method provides an array with a hard-coded
    movie. In this way, you can avoid cascade failures when interactions with external
    services are needed. This provides a better experience to end users by handling
    failures gracefully.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`getMovies`方法如何尝试与另一个服务交互以获取电影列表。该方法用`@HystrixCommand(fallbackMethod = "emptyMoviesArray")`进行了注释。`fallbackMethod`值指示在与其他服务通信期间发生错误时要使用的替代方法。在这种情况下，替代方法提供了一个硬编码的电影数组。这样，你可以在需要与外部服务交互时避免级联故障。通过优雅地处理故障，这为最终用户提供了更好的体验。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the principles of microservices and their advantages
    and drawbacks. After that, we learned how to model microservices and discussed
    some important concepts regarding distributed computing that are inherent to this
    architectural style. Finally, we reviewed the CAP theorem and how to handle failures gracefully during
    interaction with other services. In the next chapter, we are going to look at
    the serverless architectural style, which can also be integrated as part of your
    microservices environment.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了微服务的原则、优势和缺点。之后，我们学习了如何对微服务进行建模，并讨论了一些与分布式计算相关的重要概念，这些概念是这种架构风格固有的。最后，我们回顾了CAP定理以及如何在与其他服务交互时优雅地处理故障。在下一章中，我们将探讨无服务器架构风格，这也可以作为您的微服务环境的一部分进行集成。
