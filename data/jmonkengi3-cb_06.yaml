- en: Chapter 6. GUI with Nifty GUI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用Nifty GUI的GUI
- en: First of all, what is **Nifty GUI**? It's not the only GUI available in jMonkeyEngine,
    but it is the one that is officially supported. It is not developed by the jMonkeyEngine
    team but is an independent open source effort that has implementations in other
    engines as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是**Nifty GUI**？它不是jMonkeyEngine中可用的唯一GUI，但它是官方支持的。它不是由jMonkeyEngine团队开发的，而是一个独立的开源项目，在其他引擎中也有实现。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Initializing Nifty and managing an options menu
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化Nifty和管理选项菜单
- en: Loading the screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载屏幕
- en: Creating an RPG dialog screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个RPG对话框屏幕
- en: Implementing a game console
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个游戏控制台
- en: Handling a game message queue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理游戏消息队列
- en: Creating an inventory screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个库存屏幕
- en: Customizing the input and settings page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义输入和设置页面
- en: Using offscreen rendering for a minimap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用离屏渲染实现小地图
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Nifty GUI is operated using screens. A screen could be, for example, an in-game
    (**HUD)** **heads-up display** or the same game's main menu. Screens are built
    using XML and Nifty's own set of tags. On each screen, there can be layers that
    are drawn on top of each other according to their order.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Nifty GUI是通过屏幕操作的。屏幕可以是，例如，游戏中的(**HUD**) **抬头显示**或同一游戏的主菜单。屏幕是用XML和Nifty自己的标签集构建的。在每一个屏幕上，可以有层叠的层，这些层根据它们的顺序绘制。
- en: 'On a screen, objects cascade similarly as on a web page, that is, from top
    to bottom or left to right, depending on the settings. The following code is an
    example of what a simple screen might look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，对象像网页上一样级联，即从上到下或从左到右，具体取决于设置。以下代码是一个简单屏幕可能看起来像的示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each screen has a `Controller` class tied to it. This is the link between the
    XML and Java that allows Nifty to control functions in the code and the other
    way around.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个屏幕都与一个`Controller`类相关联。这是XML和Java之间的链接，允许Nifty控制代码中的功能，反之亦然。
- en: Another important concept is `Controls` (not to be confused with `Controller`
    classes or jMonkeyEngine's Control interface). Using `Controls` is a very convenient
    way to make screen files smaller and create reusable components. Anyone familiar
    with, for example, components in JSF will see the similarities. It's highly recommended
    that you become accustomed to using these early on, or screen files will quickly
    become unmanageable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是`Controls`（不要与`Controller`类或jMonkeyEngine的Control接口混淆）。使用`Controls`是一种非常方便的方法来使屏幕文件更小并创建可重用组件。任何熟悉，例如，JSF组件的人都会看到相似之处。强烈建议您尽早熟悉使用这些，否则屏幕文件将很快变得难以管理。
- en: A UI's implementation is often very specific to the game in question. This chapter
    will try to show and explain the different functions and effects available in
    Nifty GUI. Even if the title of a recipe does not appeal to you, it could still
    be worth to glance through the content to see whether it covers some features
    that could be suitable for your project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个UI的实现通常非常特定于所讨论的游戏。本章将尝试展示和解释Nifty GUI中可用的不同功能和效果。即使配方标题对你没有吸引力，仍然值得浏览内容，看看它是否涵盖了适合你项目的某些功能。
- en: Initializing Nifty and managing an options menu
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Nifty和管理选项菜单
- en: To start things off, let's begin with a simple recipe that will provide us with
    the basics of setting up the application to use Nifty GUI and tell us how to manage
    the options menu. An options menu is usually found in games; it acts as a link
    between different screens. For this reason, it's suitable to create it using the
    control pattern so it can be easily handled across screens.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一个简单的配方开始，这个配方将为我们提供设置应用程序使用Nifty GUI的基本知识，并告诉我们如何管理选项菜单。选项菜单通常在游戏中找到；它充当不同屏幕之间的链接。因此，使用控制模式创建它是合适的，这样就可以轻松地在屏幕之间处理。
- en: We'll initialize Nifty GUI inside `AppState` to offset it from the main application
    code and then access the application from Nifty and control Nifty through code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`AppState`内部初始化Nifty GUI，以将其与主应用程序代码隔离开来，然后从Nifty访问应用程序并通过代码控制Nifty。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's look at how to initialize Nifty in an application. We start off by defining
    a new `AppState` to handle our Nifty functions. We can call it `NiftyAppState`
    and have it extend `AbstractAppState`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在应用程序中初始化Nifty。我们首先定义一个新的`AppState`来处理我们的Nifty功能。我们可以称它为`NiftyAppState`，并让它扩展`AbstractAppState`。
- en: 'In the `initialize` method, we need to create the Nifty display with the following
    line of code, giving Nifty access to various functionalities within the application
    and telling it to render `o` in the GUI view:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initialize` 方法中，我们需要使用以下代码创建 Nifty 显示，给 Nifty 访问应用程序中的各种功能，并告诉它在 GUI 视图中渲染
    `o`：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We should also store the Nifty instance in the class for use later, using `niftyDisplay.getNifty()`.
    With this done, we need to add `niftyDisplay` as a processor to the same view
    we just specified, using the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该使用 `niftyDisplay.getNifty()` 将 Nifty 实例存储在类中，以便以后使用。完成此操作后，我们需要将 `niftyDisplay`
    添加为我们刚才指定的视图的处理器，使用以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last thing that needs to be done before Nifty could show anything is to
    tell it what to draw. We do this with `nifty.fromXml` and pass the XML file to
    be used as well as the name of the screen (if several screens are stored in the
    same XML).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Nifty 能够显示任何内容之前，我们需要做的最后一件事是告诉它要绘制什么。我们通过 `nifty.fromXml` 来完成这个操作，并传递要使用的
    XML 文件以及屏幕的名称（如果多个屏幕存储在同一个 XML 中）。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We start by defining the XML files for our options menu and the screen that
    will contain it. Perform the following steps to do this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的选项菜单和包含它的屏幕的 XML 文件。执行以下步骤来完成此操作：
- en: First of all, we should create a new file called `optionsMenu.xml`. It should
    reside in the `Interface`/`Controls` folder.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该创建一个名为 `optionsMenu.xml` 的新文件。它应该位于 `Interface/Controls` 文件夹中。
- en: The first tag we need to have is a `<nifty-controls>` tag to let Nifty know
    that the elements inside should be parsed as controls.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要拥有的第一个标签是 `<nifty-controls>` 标签，以便让 Nifty 知道内部元素应该被解析为控件。
- en: Then, we add `<controlDefinition name="options">`, which is the actual options
    menu instance.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加 `<controlDefinition name="options">`，这是实际的选项菜单实例。
- en: 'This is where the actual layout starts, and it does so with a `<panel>` element,
    as shown in the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际布局从这里开始，它通过一个 `<panel>` 元素开始，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At the top, we'll have `<panel>` that will include `<control name="label"> element
    with text="Options"`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部，我们将有一个包含 `<control name="label">` 元素且文本为 "Options" 的 `<panel>`。
- en: 'To the right of this panel, there should be a small button with the familiar
    **x** to close the menu and an interact element to call a method in the `Controller`
    class, as shown in the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此面板的右侧，应该有一个带有熟悉的 **x** 图标的按钮来关闭菜单，以及一个交互元素来调用 `Controller` 类中的方法，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After this, we can have as many `<control name="button">` elements we want for
    our options menu to work. There should at least be one that calls `quit()` in
    the `Controller` class to stop the application.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们可以根据需要添加任意多的 `<control name="button">` 元素，以便我们的选项菜单能够正常工作。至少应该有一个在 `Controller`
    类中调用 `quit()` 的元素来停止应用程序。
- en: Now, we can define a screen to contain our options menu. If we right-click on
    the **Projects** window and select **New/Empty Nifty GUI file**, we will get a
    basic setup for a screen.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个屏幕来包含我们的选项菜单。如果我们右键单击 **Projects** 窗口并选择 **New/Empty Nifty GUI file**，我们将得到一个基本的屏幕设置。
- en: Clean out everything between the `<layer>` tags, and change the controller of
    the `<screen>` element to `gui.controls.NiftyController`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除 `<layer>` 标签之间的所有内容，并将 `<screen>` 元素的控制器更改为 `gui.controls.NiftyController`。
- en: Next, we need to define what styles to include using the `<useStyles>` tag,
    which should appear before the `<screen>` element.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 `<useStyles>` 标签定义要包含的样式，该标签应该出现在 `<screen>` 元素之前。
- en: We add `<useControls filename="nifty-default-controls.xml" />` to include access
    to basic nifty controls such as buttons, and we should add another `<useControls>`
    tag for our options menu. These should also be added before the `<screen>` element.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加 `<useControls filename="nifty-default-controls.xml" />` 以包含对基本 nifty 控件的访问，例如按钮，并且我们应该为我们的选项菜单添加另一个
    `<useControls>` 标签。这些也应该添加在 `<screen>` 元素之前。
- en: 'Now, we can start looking at the `Controller` code for this. Perform the following
    five steps to do this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始查看这个 `Controller` 代码。执行以下五个步骤来完成此操作：
- en: We should define a class that implements the `ScreenController` interface, which
    will become the link between the GUI and the code. We can make it abstract and
    call it `NiftyController`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该定义一个实现 `ScreenController` 接口的类，它将成为 GUI 和代码之间的链接。我们可以将其设为抽象类，并命名为 `NiftyController`。
- en: It should have two protected fields, namely, `Nifty nifty` and `Screen screen`,
    which will be set from the values provided in the `bind` method.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该有两个受保护的字段，即 `Nifty nifty` 和 `Screen screen`，这些字段将在 `bind` 方法中设置。
- en: We also need a Boolean field called `optionsMenuVisible`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个名为 `optionsMenuVisible` 的布尔字段。
- en: 'We need to add methods for each of the methods specified in the `optionsMenu.xml`
    file, and `toggleOptionsMenu()` should either show or hide the menu depending
    on whether `optionsMenuVisible` is true or not. A handy way to get hold of an
    element is by using the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为`optionsMenu.xml`文件中指定的每个方法添加方法，并且`toggleOptionsMenu()`应该根据`optionsMenuVisible`是否为真来显示或隐藏菜单。获取元素的一个方便方法是使用以下代码：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, we can call either `hide()` or `show()` on the element to control visibility.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在元素上调用`hide()`或`show()`来控制其可见性。
- en: 'Normally, the application is shut down when *Esc* is pressed. Let''s make the
    options menu handle this instead; this consists of the following four steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当按下*Esc*键时，应用程序会关闭。让我们让选项菜单来处理这个操作；这包括以下四个步骤：
- en: 'Start by deleting the related mapping by adding the following line to the `NiftyAppState`
    initialization method:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在`NiftyAppState`初始化方法中添加以下行来删除相关的映射：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we need to add our own mapping for the Esc key, as shown in the following
    code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加自己的Esc键映射，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `NiftyAppState` method also needs to implement `ActionListener` and handle
    the key press:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NiftyAppState`方法还需要实现`ActionListener`并处理按键：'
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the normal shut down routine removed, we need to add functionality inside
    `NiftyController` to handle this instead. Since this class will be shared by the
    screens, we provide the application with static access and a setter method. The
    `quit` method just has to call `app.stop()` to shut it down.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除正常关闭程序后，我们需要在`NiftyController`内部添加功能来处理这种情况。由于此类将由屏幕共享，我们为应用程序提供了静态访问和设置方法。`quit`方法只需调用`app.stop()`来关闭它。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Nifty was initialized inside `AppState` to offset the code from the main application
    and make it more modular. This also made it easier to add some more general functionalities
    related to controlling the GUI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Nifty是在`AppState`内部初始化的，这样可以将代码从主应用程序中分离出来，使其更加模块化。这也使得添加一些与控制GUI相关的更通用的功能变得更加容易。
- en: Every nifty `Controller` class must implement the `ScreenController` interface
    for Nifty to be able to find it. Since some functions will be shared across the
    screens, we created an abstract class called `NiftyController` to avoid duplicating
    the code. Apart from handling the generic Options menu, it was also given access
    to the application itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个nifty `Controller`类都必须实现`ScreenController`接口，以便Nifty能够找到它。由于一些功能将在屏幕之间共享，我们创建了一个名为`NiftyController`的抽象类来避免代码重复。除了处理通用的选项菜单外，它还被赋予了访问应用程序本身的权限。
- en: The link between the XML file and the `Controller` class doesn't need to be
    specified beyond providing the qualified name of the controller in the screen.
    Likewise, Nifty will find methods automatically using the name provided in the
    `interact` tag of `ButtonControl`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: XML文件和`Controller`类之间的链接不需要指定，只需在屏幕中提供控制器的限定名称。同样，Nifty会自动使用`ButtonControl`的`interact`标签中提供的名称来查找方法。
- en: The `<panel>` elements are versatile objects that can be used for many parts
    of the layout and can contain most other types of layout items.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`<panel>`元素是多功能对象，可以用于布局的许多部分，并且可以包含大多数其他类型的布局项。'
- en: It's OK to contain several `<controlDefinition>` elements within a `<nifty-controls>`
    tag.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<nifty-controls>`标签内包含多个`<controlDefinition>`元素是可以的。
- en: There's more…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'It''s very easy to use a `properties` file to back a Nifty file for localization
    purposes, as given in the following points:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性文件作为Nifty文件的后备以进行本地化非常容易，如下所述：
- en: 'First of all, the following tag needs to be present to link the properties
    file:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，需要存在以下标签来链接属性文件：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It can be called, for example, from a `label` control:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以从`label`控件中调用，例如：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Loading the screen
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载屏幕
- en: In this recipe, we'll develop a loading screen along with a controller for the
    game. It'll cover the most important aspects of the loading screen, such as showing
    a text and image for what it's loading and an indicator that shows the system
    is working.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将开发一个加载屏幕以及游戏控制器。它将涵盖加载屏幕的最重要方面，例如显示正在加载的文本和图像以及显示系统正在工作的指示器。
- en: Before starting this, it's recommended that you have a basic understanding of
    how to set up Nifty in an application and how to create screens and controllers.
    Have a look at the previous recipe, *Initializing Nifty managing an options menu*,
    if you are unsure about this.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，建议您对如何在应用程序中设置Nifty以及如何创建屏幕和控制器有一个基本的了解。如果您对此不确定，请查看之前的配方，*初始化Nifty管理选项菜单*。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We begin by creating the XML for the loading screen. Perform the following
    nine steps to do this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建加载屏幕的XML。执行以下九个步骤来完成此操作：
- en: Create a new file called `loadingScreen.xml` and load `Nifty-default-styles`
    and `Nifty-default-controls`. Optionally, we can also include `optionsMenu` from
    the previous recipe.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`loadingScreen.xml`的新文件，并加载`Nifty-default-styles`和`Nifty-default-controls`。可选地，我们还可以包括之前配方中的`optionsMenu`。
- en: 'The first element we need is a `<screen>` element:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的第一个元素是一个`<screen>`元素：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside this, we define a `<layer>` element:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此内部，我们定义一个`<layer>`元素：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside this `<layer>` element, we define `<panel>` that will contain our layout.
    Note that we set `visible` to `false`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此`<layer>`元素内部，我们定义了`<panel>`，它将包含我们的布局。请注意，我们将`visible`设置为`false`：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since we want a smooth transition to the screen, we''ll add a fade effect to
    this panel:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望屏幕有一个平滑的过渡效果，我们将为此面板添加一个淡入效果：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To add a movie-style and non-interactive feel to it, we will have three `<panel>`
    elements inside this file. At the top and bottom, there will be two black bars
    captioning the loading image, which will appear in the central panel.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给它添加电影风格和非交互式的感受，我们将在文件中放置三个`<panel>`元素。在顶部和底部，将有两个黑色条带，用于标注加载图像，这些图像将出现在中央面板中。
- en: Inside the `topPanel` element, we define `<control name="label">` that will
    contain the name of the scene that is being loaded.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`topPanel`元素内部，我们定义`<control name="label">`，它将包含正在加载的场景的名称。
- en: 'The `bottomPanel` element will have an animated indicator that will show the
    system hasn''t frozen. We will define another panel inside this, aligned to the
    right of the screen. We will use an `imageSizePulsate` effect to animate this
    and have it fade in as well, as shown in the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bottomPanel`元素将有一个动画指示器，它会显示系统没有冻结。我们将在其中定义另一个面板，与屏幕的右侧对齐。我们将使用`imageSizePulsate`效果来动画化这个面板，并使其淡入，如下面的代码所示：'
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Optionally, we can also add another `<layer>` tag beside the previous one that
    will contain the `options` control from the previous recipe.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们还可以在之前的`<layer>`标签旁边添加另一个`<layer>`标签，其中包含之前配方中的`options`控件。
- en: 'Now, we have a complete XML. Let''s have a look at the controller for this.
    We will create it by performing the following seven steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个完整的XML。让我们看看这个控制器的样子。我们将通过以下七个步骤来创建它：
- en: We begin by creating a new class called `LoadingScreenController` that extends
    the `NiftyController` class we created in the previous recipe.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`LoadingScreenController`的新类，该类扩展了我们之前配方中创建的`NiftyController`类。
- en: We define two strings, `loadingText` and `loadingScreen`, and setters for these
    as well.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个字符串`loadingText`和`loadingScreen`，以及这些字符串的设置器。
- en: 'Next, we override the `onStartScreen()` method and add the following three
    lines to it:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重写`onStartScreen()`方法，并向其中添加以下三行：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The controller is now done. However, there are some more things we need to do
    before we can look at it.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器现在已经完成。然而，在我们能够查看它之前，还有一些其他的事情需要做。
- en: 'First, we need to add the screen to Nifty. If we have the `NiftyAppState` method
    from the previous recipe, we should add the following line just after the `nifty.fromXml`
    call:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将屏幕添加到Nifty中。如果我们有之前的配方中的`NiftyAppState`方法，我们应该在`nifty.fromXml`调用之后立即添加以下行：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can also add a `convenience` class to access `nifty.gotoScreen()`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以添加一个`convenience`类来访问`nifty.gotoScreen()`。
- en: 'Now, before calling `gotoScreen("loadingScreen")` from our main class, we can
    add the following lines to set `lodingText` and `loadingImage`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在从我们的主类调用`gotoScreen("loadingScreen")`之前，我们可以添加以下行来设置`lodingText`和`loadingImage`：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most of the work in this recipe consists of getting the XML layout right. It's
    a good idea to sketch it on paper first and visualize the flow of the elements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的大部分工作都集中在正确获取XML布局上。在纸上先画出来并可视化元素的流程是个好主意。
- en: The reason the fade effect is shorter is because by the time it fades out, the
    game is ready to be played and the player doesn't need to wait longer than necessary.
    When the loading screen is first shown, the player has to wait for the game to
    load.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 淡入效果较短的原因是因为当它淡出时，游戏已经准备好可以玩，玩家不需要等待比必要的更长的时间。当加载屏幕首次显示时，玩家必须等待游戏加载。
- en: There is a reason why we set `loadingPanel` to `visible="false"` at the beginning
    and used `onShow` rather than `onScreenStart` effects. The `onStartScreen` method
    in the controller is called after the screen has been started and `onScreenStart`
    effects have been fired (and completed). This means that any fading will occur
    before we set the images, and they would pop into existence after some time has
    passed. Since the `onShow` effects are called once the element becomes visible,
    we get around that problem this way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以在开始时将 `loadingPanel` 设置为 `visible="false"` 并使用 `onShow` 而不是 `onScreenStart`
    效果，是有原因的。控制器中的 `onStartScreen` 方法在屏幕启动后和 `onScreenStart` 效果被触发（并完成）后被调用。这意味着任何淡入效果都会在我们设置图像之前发生，并且它们会在一段时间后突然出现。由于
    `onShow` 效果是在元素变为可见后调用的，我们通过这种方式解决了这个问题。
- en: Another possible gotcha here, especially if we use a test case to show the screen,
    is that we can't call `nifty.gotoScreen` just after initializing `NiftyAppState`.
    Since the `AppState` initialization method is called in a thread-safe way, it
    doesn't run until the next update cycle. This means that if we try to change the
    screens on the next line, we will get `NullPointerException`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个可能的陷阱，特别是如果我们使用测试用例来显示屏幕，那就是我们无法在初始化 `NiftyAppState` 后立即调用 `nifty.gotoScreen`。由于
    `AppState` 初始化方法是以线程安全的方式调用的，它不会运行直到下一个更新周期。这意味着如果我们尝试在下一条语句中更改屏幕，我们将得到 `NullPointerException`。
- en: Creating an RPG dialog screen
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个RPG对话框屏幕
- en: As the title implies, we'll explore a method to create a dialog screen, similar
    to those found in many RPGs. It'll display an image of the character being talked
    to, but this could be replaced by using some clever camera work to zoom in on
    a character instead.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如标题所暗示的，我们将探讨创建一个对话框屏幕的方法，类似于许多角色扮演游戏（RPG）中找到的。它将显示正在交谈的角色的图像，但可以使用一些巧妙的摄像机工作来放大角色的图像来代替。
- en: It will use a Nifty `ListBox` to display the player's available dialog options
    and a listener to find out the result of the player's choice.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使用 Nifty `ListBox` 来显示玩家的可用对话选项，并使用监听器来获取玩家选择的结果。
- en: There most likely has to be some dialog tree system that backs the implementation.
    For this example, we'll use a template class called `DialogNode`. This will have
    information about a character's name, image, and what it says. It also contains
    the player's options as a string array, as shown in the following screenshot.
    What's missing from it is the callbacks for each option. It will, however, be
    possible to call it from the controller's listener method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能需要一个支持实现的对话树系统。在这个例子中，我们将使用一个名为 `DialogNode` 的模板类。它将包含有关角色名称、图像和所说内容的信息。它还包含玩家选项的字符串数组，如以下截图所示。它缺少的是每个选项的回调。然而，将可以从控制器的监听器方法中调用它。
- en: '![Creating an RPG dialog screen](img/6478OS_06_01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个RPG对话框屏幕](img/6478OS_06_01.jpg)'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Before we work on the screen, we should define a new reusable Nifty control
    to contain the character information of the character the player is talking to;
    perform the following steps to do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理屏幕之前，我们应该定义一个新的可重用 Nifty 控制来包含玩家正在交谈的角色的信息；执行以下步骤来完成此操作：
- en: Create a new file called `characterDialogControls.xml` with the `<nifty-controls>`
    tag, and inside it, create a new `<controlDefinition name="characterControl">`
    class.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `characterDialogControls.xml` 的新文件，并在其中创建一个带有 `<nifty-controls>` 标签的新
    `<controlDefinition name="characterControl">` 类。
- en: The layout for this is fairly simple; it needs one `<panel>` element that contains
    another `<panel>` for the character image and a `<control name="label">` element
    for the name.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个布局相当简单；它需要一个包含另一个 `<panel>` 元素以显示角色图像和 `<control name="label">` 元素以显示名称的 `<panel>`
    元素。
- en: 'Now, let''s build the dialog screen. We do this by performing the following
    nine steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建对话框屏幕。我们通过执行以下九个步骤来完成此操作：
- en: Create a new file called `dialogScreen.xml` and load `nifty-default-styles`
    and `nifty-default-controls`. It should also load the `characterDialogControls.xml`
    file. We can also include `optionsMenu` from the previous recipe.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `dialogScreen.xml` 的新文件，并加载 `nifty-default-styles` 和 `nifty-default-controls`。它还应加载
    `characterDialogControls.xml` 文件。我们还可以包括之前配方中的 `optionsMenu`。
- en: 'The first element we need is a `<screen>` element:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的第一个元素是一个 `<screen>` 元素：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside this, we define a `<layer>` element:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个 `<layer>` 元素：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside the `<layer>` element, we define `<panel>`, which will contain the rest
    of our layout:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<layer>` 元素内部，我们定义 `<panel>`，它将包含我们布局的其余部分：
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll add a short fade effect to this panel as well:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为此面板添加一个简短的淡入效果：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The dialog panel will have four `<panel>` elements inside it. At the top and
    bottom, we should add two thin panels with black background to give it a cinematic
    feel.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话框面板将包含四个 `<panel>` 元素。在顶部和底部，我们应该添加两个带有黑色背景的细面板，以使其具有电影感。
- en: 'The upper part of the two central panels will contain the `characterControl`
    we just created:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个中央面板的上部将包含我们刚刚创建的 `characterControl`：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The lower one will have a listbox that contains the player''s dialog options:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个将有一个包含玩家对话框选项的列表框：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we also want support for the options menu, it should go in a separate layer
    to make it show on top of the rest of the GUI.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还想支持选项菜单，它应该放在一个单独的层中，以便在其余 GUI 之上显示。
- en: 'The controller code for it can be created by performing the following 12 steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为此可以创建控制器代码，通过执行以下 12 个步骤：
- en: Begin by defining a new class called `DialogScreenController` that extends `NiftyController`
    or implements `ScreenController` if an abstract `Controller` class is not available.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义一个新的类 `DialogScreenController`，它扩展 `NiftyController` 或实现 `ScreenController`（如果不可用抽象
    `Controller` 类）。
- en: 'Next, we add two fields: one for the current `DialogNode`, `dialogNode`, and
    a reference to `ListBox` in the XML called `dialogOptions`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加两个字段：一个用于当前的 `DialogNode`，`dialogNode`，以及在 XML 中对 `ListBox` 的引用 `dialogOptions`。
- en: 'The `onStartScreen()` method should be overridden; here, it should set `dialogOptions`
    by calling `screen.findNiftyControl`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该重写 `onStartScreen()` 方法；在这里，它应该通过调用 `screen.findNiftyControl` 来设置 `dialogOptions`：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, `onStartScreen` should also call `onDialogNodeChanged()` if `dialogNode`
    is set.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果设置了 `dialogNode`，`onStartScreen` 应该也调用 `onDialogNodeChanged()`。
- en: Now, we need to define the method called `onDialogNodeChanged` that will apply
    the dialog information to the layout.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个名为 `onDialogNodeChanged` 的方法，它将应用对话框信息到布局中。
- en: 'We should begin this by setting the name of the character; again, we will use
    `screen.findNiftyControl` to do this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该从设置角色的名称开始；再次，我们将使用 `screen.findNiftyControl` 来完成这项工作：
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Likewise, the dialog text is set in the same manner.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，对话框文本也是以相同的方式设置的。
- en: 'To set the image, we need to create `NiftyImage` and pass it on to `ImageRenderer`
    of an element using the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置图像，我们需要创建 `NiftyImage` 并将其传递给元素的 `ImageRenderer`，以下代码：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we clear `dialogOptions` and use `dialogOptions.addItem` to apply the
    values available in `DialogNode`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们清除 `dialogOptions` 并使用 `dialogOptions.addItem` 应用 `DialogNode` 中可用的值。
- en: Finally, we call `dialogOptions.refresh()` and `screen.layoutLayers()` and set
    the `dialogPanel` element to be visible.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用 `dialogOptions.refresh()` 和 `screen.layoutLayers()` 并将 `dialogPanel`
    元素设置为可见。
- en: 'To find out which item is pressed in `dialogOptions`, we add a listener method
    to the class:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出 `dialogOptions` 中按下的项目，我们向类中添加一个监听方法：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we add an annotation to let it know which element to listen to:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个注释来告知它要监听哪个元素：
- en: '[PRE29]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `event.getSelectionIndices()`, we can find out which item the player has
    pressed.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `event.getSelectionIndices()`，我们可以找出玩家按下了哪个项目。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Getting the layout exactly as we want can be tricky sometimes, but in general,
    it's important to know that Nifty really likes the width and height to be defined.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，要得到我们想要的布局可能很棘手，但一般来说，重要的是要知道 Nifty 真的喜欢定义宽度和高度。
- en: Using the ListBox here gives us a lot for free since it handles a dynamic number
    of options, and callbacks to the code are easily handled with the `listener` method.
    By default, it has scrollbars and handles multiple selection, which is why we
    explicitly defined it to be `selection="Single"` and used `vertical="off"` and
    `horizontal="off"` to turn off the scrollbars. It also supports item selection
    by using the up, down, and *Enter* keys.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用 ListBox 可以免费获得很多功能，因为它可以处理动态数量的选项，并且使用 `listener` 方法可以轻松处理回调到代码。默认情况下，它具有滚动条并支持多选，这就是为什么我们明确将其定义为
    `selection="Single"` 并使用 `vertical="off"` 和 `horizontal="off"` 来关闭滚动条。它还支持使用上、下和
    *Enter* 键进行项目选择。
- en: The listener method in the controller can be referred to as anything; what Nifty
    looks for is the annotation and the method's parameters. From here, we can call
    the next `DialogNode` or other code based on the player's choices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器中的监听方法可以命名为任何名称；Nifty寻找的是注解和方法参数。从这里，我们可以根据玩家的选择调用下一个`DialogNode`或其他代码。
- en: Implementing a game console
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏控制台
- en: A console can be a very powerful tool that allows a player to have control over
    game functions that might either not have a functional UI yet, or where setting
    up a UI is simply not be feasible due to its complexity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台可以是一个非常强大的工具，允许玩家控制可能还没有功能UI或由于复杂性而无法设置UI的游戏功能。
- en: This recipe will implement a console in the main screen from the first recipe
    in this chapter and also use the `Move` effect to slide it in and out of view.
    Moreover, it will describe how to use console commands to let the player control
    the game functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将在本章的第一个菜谱中实现控制台，并使用`Move`效果将其滑动到视图中或从视图中滑出。此外，它还将描述如何使用控制台命令让玩家控制游戏功能。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Just as before, we begin by defining a control that will host the console.
    It can be done by performing the following four steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们首先定义一个将托管控制台的控制。这可以通过执行以下四个步骤来完成：
- en: Inside the `<nifty-controls>` tags, we add a new `<controlDefinition name="consoleControl">`
    class.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<nifty-controls>`标签内，我们添加一个新的`<controlDefinition name="consoleControl">`类。
- en: 'Then, we add a small console, aligning it with the bottom of the screen:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个小控制台，将其与屏幕底部对齐：
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To spice up the simple console, we give it a `Move` effect when it''s being
    shown or hidden:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使简单的控制台更加生动，我们在显示或隐藏时给它添加一个`Move`效果：
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `mainScreen.xml`, we add `controlDefinition` inside a new layer:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mainScreen.xml`中，我们在一个新层内添加`controlDefinition`：
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That''s it for XML hacking. Now, we can turn our attention to the `NiftyController`
    class from the *Initializing Nifty and managing an options menu* recipe and add
    a console to handle to it. This can be done by performing the following 10 steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是XML黑客的结束。现在，我们可以将注意力转向从*初始化Nifty和管理选项菜单*菜谱中的`NiftyController`类，并添加一个控制台来处理它。这可以通过执行以下10个步骤来完成：
- en: 'We need to add a new field, `Console console`, and bind it using the following
    code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加一个新的字段`Console console`，并使用以下代码进行绑定：
- en: '[PRE33]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we add a method about the output text to the console from external sources.
    We call it `outputToConsole`, and it takes a string as an input. It then calls
    `console.output` to display the message.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个关于从外部来源输出文本到控制台的方法。我们称它为`outputToConsole`，它接受一个字符串作为输入。然后它调用`console.output`来显示消息。
- en: Another new method is `toggleConsole()`. It should check whether `console.getElement()`
    is visible or not and then hide or show it accordingly.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个新方法是`toggleConsole()`。它应该检查`console.getElement()`是否可见，然后相应地隐藏或显示它。
- en: 'Then, we add a `subscriber` method that will receive anything entered in the
    console. It needs the `@NiftyEventSubscriber` annotation with the console as its
    ID. It also needs a method declaration that looks like the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`subscriber`方法，它将接收控制台中输入的任何内容。它需要带有控制台ID的`@NiftyEventSubscriber`注解。它还需要一个方法声明，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Define a new class called `HideCommand` that implements `ConsoleCommand`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的类`HideCommand`，它实现了`ConsoleCommand`。
- en: Add a field `NiftyController` controller together with a setter method to the
    `HideCommand` class.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HideCommand`类中添加一个字段`NiftyController`控制器以及一个设置方法。
- en: In the implemented `execute` method, we call `controller.toggleConsole()`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现的`execute`方法中，我们调用`controller.toggleConsole()`。
- en: Going back to `NiftyController`, we instantiate a new `HideCommand` method and
    set the controller.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`NiftyController`，我们实例化一个新的`HideCommand`方法并设置控制器。
- en: We then create a new `ConsoleCommands` instance and call `registerCommand`;
    thereafter, we supply/hide the instance and call `commandText`, and `HideCommand`
    as `ConsoleCommand`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个新的`ConsoleCommands`实例并调用`registerCommand`；之后，我们提供/隐藏实例并调用`commandText`，以及`HideCommand`作为`ConsoleCommand`。
- en: Finally, we call `enableCommandCompletion(true)` in the `ConsoleCommands` instance.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`ConsoleCommands`实例中调用`enableCommandCompletion(true)`。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we implemented two ways of handling the input in the console.
    The most straightforward way is the `onConsoleCommand` method where we get the
    raw input and can do whatever we want with it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了两种处理控制台输入的方法。最直接的方法是`onConsoleCommand`方法，其中我们获取原始输入并可以对其进行任何操作。
- en: The more intricate way of doing this is using `ConsoleCommands`. With this,
    we get a nice layered pattern to handle the input. Once the console is shown or
    hidden, it will quickly slide in or out of the screen with the move effect. It
    will move the `offsetY` distance, and based on the mode, it will either move to
    that offset or from it. The `inherit="true"` value ensures that child elements
    move together with the component in question.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的方法是使用`ConsoleCommands`。使用它，我们得到一个很好的分层模式来处理输入。一旦控制台显示或隐藏，它将快速滑动进入或退出屏幕，并带有移动效果。它将移动`offsetY`距离，并根据模式，它将移动到该偏移量或从该偏移量移动。`inherit="true"`值确保子元素与相关组件一起移动。
- en: Handling a game message queue
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理游戏消息队列
- en: It is possible to relay most game-related information to the player using a
    console. However, it's a very basic form of communication. Modern players often
    expect more graphical ways of receiving information. In this recipe, we'll explore
    one way of doing this using Nifty. We'll create a dynamic message queue with messages
    moving in from the right of the screen and fading out once clicked.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台可以将大多数游戏相关信息传达给玩家。然而，这仅仅是一种非常基础的通信形式。现代玩家通常期望有更多图形化的信息接收方式。在这个菜谱中，我们将探讨使用Nifty实现这一点的其中一种方法。我们将创建一个动态的消息队列，消息从屏幕右侧移动进来，点击后淡出。
- en: It actually doesn't require that many lines of code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并不需要那么多代码行。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The XML for this recipe can be completed by performing the following five steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此菜谱的XML可以通过以下五个步骤完成：
- en: We start by defining a new `<controlDefinition name="gameMessage">`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的`<controlDefinition name="gameMessage">`。
- en: Inside this, we should add a `panel` element, and inside this `panel` element,
    add two `<control name="label">` elements with the ID `#title` and other contents.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们应该添加一个`panel`元素，并在该`panel`元素内部添加两个带有ID `#title`和其他内容的`<control name="label">`元素。
- en: 'The panel should also have two effects, one `onShow` trigger and one `onHide`
    trigger with move and fade effects respectively, as shown in the following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该面板还应具有两个效果，一个`onShow`触发器和另一个`onHide`触发器，分别具有移动和淡出效果，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In addition to the `gameMessage` control, we can define another control to be
    our `messageQueue` element. It just needs a horizontally aligned panel, spanning
    the whole screen.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`gameMessage`控制之外，我们还可以定义另一个控制作为我们的`messageQueue`元素。它只需要一个水平对齐的面板，覆盖整个屏幕。
- en: To make them align with each other, the `messageQueue` control is added to the
    `mainScreen.xml` file inside the same layer as the console.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它们对齐，`messageQueue`控制被添加到与控制台相同的层中的`mainScreen.xml`文件内。
- en: 'Inside `MainScreenController`, we need to do the following changes:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`MainScreenController`内部，我们需要进行以下更改：
- en: First, add a new `int` field called `messageIndex`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加一个新的`int`字段，称为`messageIndex`。
- en: Then, we need two methods. One of these is called `addMessage` that should take
    a string as an input.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要两个方法。其中一个是名为`addMessage`的方法，它应该接受一个字符串作为输入。
- en: 'Inside the `addMessage` method, we define a `ControlBuilder` method called
    `messageBuilder`. This will create `gameMessage` controls:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`addMessage`方法内部，我们定义一个名为`messageBuilder`的`ControlBuilder`方法。这将创建`gameMessage`控制：
- en: '[PRE36]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After calling the `build` method on this and supplying the `messageQueue` element
    as the parent, we can call `element.findNiftyControl` to set the title and the
    text on the labels inside the `gameMessage` control.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个对象上调用`build`方法，并传入`messageQueue`元素作为父元素后，我们可以调用`element.findNiftyControl`来设置`gameMessage`控制内部标签的标题和文本。
- en: Then, we call `element.show()` and increase `messageIndex` for the next message.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用`element.show()`并增加`messageIndex`以供下一条消息使用。
- en: The second method we create is `removeMessage`. It takes a string called `id`
    as the input.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的第二个方法是`removeMessage`。它接受一个名为`id`的字符串作为输入。
- en: Inside this, we use `screen.findElementByName` to find the message, and call
    `hide`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用`screen.findElementByName`来查找消息，并调用`hide`。
- en: While doing this, we supply a new `EndNotify` object, which in its `perform`
    message should call `markForRemoval()` on the message and also `layoutElements()`
    on the parent `messageQueue` control.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行此操作时，我们提供一个新的`EndNotify`对象，在其`perform`消息中应调用消息上的`markForRemoval()`，并调用父`messageQueue`控制上的`layoutElements()`。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the `addMessage` method is called in the `Controller` class, `ControlBuilder`
    creates a new `gameMessage` instance. The `interactOnClick` element tells `gameMessage`
    to call `removeMessage` when clicked, supplying its index as `id`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在`Controller`类中调用`addMessage`方法，`ControlBuilder`将创建一个新的`gameMessage`实例。`interactOnClick`元素告诉`gameMessage`在点击时调用`removeMessage`，并提供其索引作为`id`。
- en: After its built and added to `messageQueue`, we populate the title and content
    elements of the message. Using `#` in the ID of these elements is preferred by
    Nifty for non-unique IDs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在其构建并添加到`messageQueue`后，我们填充消息的标题和内容元素。Nifty更喜欢使用`#`作为这些元素的ID，以表示非唯一ID。
- en: The `gameMessage` instance is not visible upon creation, and we call `show()`
    to make it play the `onShow` effect we defined.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameMessage`实例在创建时不可见，我们调用`show()`来使其播放我们定义的`onShow`效果。'
- en: The `Move` effect is set up to have `offsetX`, which is outside of the screen.
    If it's too low, there will be a pop effect as it comes into existence. It's set
    to reach the target position in 100 ms. Messages will stack up nicely without
    any additional work when they are added.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move`效果被设置为具有`offsetX`，它位于屏幕之外。如果它太低，当它出现时会有一个弹出效果。它被设置为在100毫秒内达到目标位置。当它们被添加时，消息会很好地堆叠起来，无需任何额外的工作。'
- en: The messages are set to disappear when clicked, as defined in the builder, through
    the `interactOnClick` method. Instead of just removing them, we want to play a
    short fade effect to make the transition smoother. Simply hiding them won't be
    enough in this case either. Since they still occupy a position in the `messageQueue`
    panel, the remaining messages won't align properly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 消息被设置为在点击时消失，如构建器中定义的，通过`interactOnClick`方法。我们不仅想要移除它们，还想要播放一个简短的淡入淡出效果，以使过渡更加平滑。在这种情况下，简单地隐藏它们也不够。因为它们仍然占据`messageQueue`面板中的一个位置，剩余的消息不会正确对齐。
- en: Hence, we want to call `markForRemoval` on the `gameMessage` element. Doing
    this instantly, however, would remove it before our hide effect is played. This
    why we supply an `EndNotify` object that is handled once the hide effect is done
    with playing; then, we add the `markForRemoval` call in here instead.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望在`gameMessage`元素上调用`markForRemoval`。然而，这样做会立即将其移除，在我们播放隐藏效果之前。这就是为什么我们提供一个`EndNotify`对象，它在隐藏效果播放完成后被处理；然后，我们在这里添加`markForRemoval`调用。
- en: There's more…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Let's say we would like to be able to show messages in a window, either when
    clicking the message in the queue, or any time. In that case, we can use Nifty's
    window control.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望能够在窗口中显示消息，无论是点击队列中的消息，还是任何时间。在这种情况下，我们可以使用Nifty的窗口控制。
- en: We can define a new `controlDefinition` in our `gameMessageControls.xml` file
    and call it `messageWindow`. Inside this, we'll add `<control name="window">`,
    inside which we can add any content we'd like. For now, we can settle with `<control
    name="label">` for text content and a short fade effect when showing or hiding
    the window.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`gameMessageControls.xml`文件中定义一个新的`controlDefinition`，并命名为`messageWindow`。在这个内部，我们将添加`<control
    name="window">`，在其中我们可以添加任何我们想要的内容。目前，我们可以用`<control name="label">`来处理文本内容，并在显示或隐藏窗口时添加一个简短的淡入淡出效果。
- en: Then, we can copy the `addMessage` method to `MainScreenController`, and instead
    of having `ControlBuilder` make `gameMessage`, we can tell it to build a `messageWindow`
    window instead.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`addMessage`方法复制到`MainScreenController`中，而不是让`ControlBuilder`创建`gameMessage`，我们可以告诉它构建一个`messageWindow`窗口。
- en: 'We don''t need an `interactOnClick` element, as the window can be closed by
    default. Instead, we can use it to set the title of the window:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要`interactOnClick`元素，因为窗口默认可以关闭。相反，我们可以用它来设置窗口的标题：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Windows are also draggable by default, but the parent element must have `childLayout="absolute"`
    for it to work, as it lets the element decide its position itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口默认也是可拖动的，但父元素必须具有`childLayout="absolute"`才能使其工作，因为它让元素自己决定其位置。
- en: Creating an inventory screen
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建库存屏幕
- en: In this recipe, we'll create an inventory screen, which is very common, mostly
    in RPGs. To do this, we'll use the `Droppable` and `Draggable` components in Nifty
    and create an `InventoryItem` class to help us differentiate different the types
    of items (and hence, where they can be attached). This time, we'll use both XML
    to create the static components and the Java Builder interface to build the inventory
    (or backpack) slots. The reason is that in many games, the amount of inventory
    a character has varies.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个库存屏幕，这在RPG游戏中非常常见。为此，我们将使用Nifty中的`Droppable`和`Draggable`组件，并创建一个`InventoryItem`类来帮助我们区分不同类型的物品（因此，它们可以附加的位置）。这次，我们将使用XML来创建静态组件，并使用Java
    Builder接口来构建库存（或背包）槽位。原因是许多游戏中，角色的库存量是变化的。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We begin by creating the controls, which are the key components of this method.
    This can be done by performing the following four steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建控制组件，这是此方法的关键组成部分。这可以通过以下四个步骤来完成：
- en: First, we create a new controls file, `inventoryControls.xml`, with the `<nifty-controls>`
    tag.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的控制文件，`inventoryControls.xml`，并使用 `<nifty-controls>` 标签。
- en: 'Inside this, we first define `<controlDefinition name="itemSlot">` with the
    following content:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此内部，我们首先定义 `<controlDefinition name="itemSlot">` 并包含以下内容：
- en: '[PRE38]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then similarly, we create a draggable control to be the item, and name it `<controlDefinition
    name="item" >`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，类似地，我们创建一个可拖动的控件作为项目，并命名为 `<controlDefinition name="item" >`。
- en: 'This item contains both the draggable component and a label with the item''s
    name:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此项目包含可拖动的组件以及带有项目名称的标签：
- en: '[PRE39]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we can turn our attention to the screen itself. It can be created by
    performing the following five steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将注意力转向屏幕本身。可以通过以下五个步骤创建屏幕：
- en: First, we make sure that the styles we want to use are loaded, and add our `inventoryControls.xml`
    file is loaded with `<useControls>`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们确保要使用的样式已加载，并将我们的 `inventoryControls.xml` 文件通过 `<useControls>` 加载：
- en: 'Then, we add a `<screen>` element with a link to our controller file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个带有指向控制器文件链接的 `<screen>` 元素：
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside this, we need a `<layer>` element:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此内部，我们需要一个 `<layer>` 元素：
- en: '[PRE41]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Inside the `<layer>` element, we need a `<panel>` element that will contain
    the rest of our layout:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<layer>` 元素内部，我们需要一个 `<panel>` 元素来包含其余布局：
- en: '[PRE42]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next element is a panel that will keep our dynamically created `itemSlots`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个元素是一个面板，用于保持动态创建的 `itemSlots`：
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following screenshot shows us the dynamically created item slots:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了动态创建的项目槽位：
- en: '![How to do it...](img/6478OS_06_02.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/6478OS_06_02.jpg)'
- en: After this, we create a simple representation of a humanoid with two hands and
    feet, using the `itemSlot` control. We use `align` and `childLayout` to make the
    components appear where we want them to.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们使用 `itemSlot` 控制创建一个简单的人形表示，具有两只手和脚。我们使用 `align` 和 `childLayout` 来使组件出现在我们想要的位置。
- en: 'First, add a panel to contain the components:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加一个面板来包含组件：
- en: '[PRE44]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, add the head using the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令添加头部：
- en: '[PRE45]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add one left and right hand using the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令添加一只左手和一只右手：
- en: '[PRE46]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we have one `itemSlot` for the legs/feet:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为腿部/脚部设置了一个 `itemSlot`：
- en: '[PRE47]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the XML elements done, we can turn to the Java code. The following nine
    steps are necessary:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 XML 元素后，我们可以转向 Java 代码。以下九个步骤是必要的：
- en: 'We create a class called `InventoryItem`. This has an enum (enumeration) for
    different body parts: head, hand, foot, and a name.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个名为 `InventoryItem` 的类。这个类有一个枚举（枚举）用于不同的身体部位：头部、手、脚和名称。
- en: Next, we'll create the `Controller` class, `InventoryScreenController`, and
    have it extend `NiftyController`; also, implement `DroppableDropFilter`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `Controller` 类，`InventoryScreenController`，并使其扩展 `NiftyController`；同时实现
    `DroppableDropFilter`。
- en: We need to add a map to contain our `InventoryItems`, with the name as the key.
    It can be called `itemMap`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加一个映射来包含我们的 `InventoryItems`，名称作为键。它可以被称为 `itemMap`。
- en: 'The `bind` method should be overridden, and in here, we should find different
    `DropControls` in the `InventoryScreen` and add this class as a filter using the
    following code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bind` 方法应该被覆盖，在这里，我们应该在 `InventoryScreen` 中找到不同的 `DropControls` 并将此类作为过滤器使用以下代码：'
- en: '[PRE48]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, we can generate the item slots in the inventory in a 5 x 5 grid.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在库存中以 5 x 5 网格生成项目槽位。
- en: 'We define two builders: `ControlBuilder` for the itemSlot controls and `PanelBuilder`
    to make columns that will contain five itemSlots each.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义两个构建器：`ControlBuilder` 用于 itemSlot 控件和 `PanelBuilder` 用于创建包含五个 itemSlots
    的列。
- en: 'We can use a `for` loop to iterate five times over the following block:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `for` 循环迭代以下块五次：
- en: '[PRE49]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'While still inside this `for` loop, we run another `for` loop, generating the
    five item slots for that column:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此 `for` 循环内部，我们运行另一个 `for` 循环，为该列生成五个项目槽位：
- en: '[PRE50]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For each of the item slots, we also need to add the following class as a DropFilter:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个项目槽位，我们还需要添加以下类作为 DropFilter：
- en: '[PRE51]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The implemented method that is accepted needs some logic. Once an item has
    been dropped on an `itemSlot`, we should check whether it''s allowed, and we can
    do it with the following lines of code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现的方法需要一些逻辑。一旦项目被投放到 `itemSlot` 上，我们应该检查它是否允许，我们可以通过以下代码行来完成：
- en: '[PRE52]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With the item slots done, we can generate some items for testing.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在完成项目槽位后，我们可以生成一些项目进行测试。
- en: First we use a `for` loop to create 10 `InventoryItems` with different types
    and names.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `for` 循环创建 10 个具有不同类型和名称的 `InventoryItems`。
- en: 'For each of these, we create a Nifty control using `ControlBuilder` and the
    item control we defined earlier, as shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这些，我们使用`ControlBuilder`和之前定义的项目控件创建Nifty控件，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Then, we put each of the inventory items in the itemMap with the ID of the control
    as the key. This ensures we can easily find out the link to the inventory item
    where a nifty item has been dragged or dropped.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将每个库存项目放入itemMap中，以控件的ID作为键。这确保我们可以轻松地找到拖动或放下巧妙物品的库存项目的链接。
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Java Builder interface we use to create item slots takes a while to get
    used to, but it's a really powerful tool when we have the need to create nifty
    elements dynamically. In this case, we still use a predefined control. This saves
    us a couple of lines of code and allows someone else than a coder to edit the
    layout and style of the component since it's exposed in the XML file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建物品槽的Java Builder界面需要一段时间才能习惯，但当我们需要动态创建巧妙元素时，它是一个非常强大的工具。在这种情况下，我们仍然使用预定义的控制。这为我们节省了几行代码，并允许非编码人员编辑组件的布局和样式，因为它们在XML文件中是公开的。
- en: By default, a `Droppable` control will always accept the `Draggable` control
    that is being dropped. The `accept` method in `DroppableDropFilter` enables us
    to define what should be accepted or not. It's illustrated in this recipe by only
    accepting `InventoryItems` of a certain type. The method parameters for the accept
    method can be described, as the first `Droppable` is the control that the `draggable`
    control is being picked up from. The `Draggable` control is the item that is being
    moved. The second `Droppable` control is the target where `Draggable` has been
    dropped.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Droppable`控件将始终接受被丢弃的`Draggable`控件。`DroppableDropFilter`中的`accept`方法使我们能够定义应该接受什么或不接受什么。在本配方中，它通过仅接受特定类型的`InventoryItems`来展示。`accept`方法的方法参数可以描述，第一个`Droppable`是`draggable`控件被拾起的地方的控件。`Draggable`控件是被移动的项目。第二个`Droppable`控件是`Draggable`被丢弃的目标。
- en: Tip
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At the time of writing this, the first `Droppable` control tends to be null
    the first time a `Draggable` control is being moved.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，第一次移动`Draggable`控件时，第一个`Droppable`控件往往会是null。
- en: Customizing the input and settings page
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义输入和设置页面
- en: Just about every modern game lets the player customize the input according to
    their own preferences. This recipe will rely on jMonkeyEngine to do the work for
    us, and we will use Nifty GUI as a visual aid. We'll use `RawInputListener` to
    work out which keys have been pressed and divide them between key codes and characters
    using the `Keyboard` class.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代游戏都允许玩家根据自己的喜好自定义输入。这个配方将依赖于jMonkeyEngine为我们完成工作，我们将使用Nifty GUI作为视觉辅助工具。我们将使用`RawInputListener`来确定哪些键被按下，并使用`Keyboard`类将它们分为键码和字符。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The recipe will depend on there being some bindings in `InputManager`. If you
    already have a game, this would not be a problem. If not, it will describe how
    to add a couple of bindings for the example to work.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将取决于`InputManager`中是否存在一些绑定。如果你已经有了游戏，这不会是问题。如果没有，它将描述如何为示例添加一些绑定。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Following the pattern from previous recipes, we''ll start defining the controls,
    then move on to the screen, and finally work on the controller. Adding the controls
    and screen will consist of the following eight steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的配方模式，我们将开始定义控件，然后转到屏幕，最后处理控制器。添加控件和屏幕将包括以下八个步骤：
- en: Inside a `<nifty-control>` tag, we define a new `<controlDefinition name="keyBindingControl">`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<nifty-control>`标签内部，我们定义一个新的`<controlDefinition name="keyBindingControl">`。
- en: 'Here, we''ll add a horizontal spanning panel with some margin to the edges
    of its container and enough height to contain text:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将向容器边缘添加一个带有一些边距的水平扩展面板，以及足够的高度来容纳文本：
- en: '[PRE54]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This panel will have three elements. The first is a label control that contains
    the text for the key binding, as shown in the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个面板将包含三个元素。第一个是一个包含键绑定文本的标签控件，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, it will have a button to change the binding, displaying the current key:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将有一个按钮来更改绑定，显示当前键：
- en: '[PRE56]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In between them, it will have a simple panel with `width="*"`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在它们之间，它将有一个简单的面板，`width="*"`。
- en: Now, we can define another `<controlDefinition name="settingsControl">` that
    will contain a number of our `keyBindingControls`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义另一个`<controlDefinition name="settingsControl">`，它将包含我们的`keyBindingControls`。
- en: 'This will contain a panel, and inside this, four `keyBindingControls` for each
    moving direction. The IDs of these controls should be representative of the direction
    and end with a key as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将包含一个面板，在这个面板内部，为每个移动方向添加四个`keyBindingControls`。这些控制的ID应该代表方向，并以一个键结尾，如下所示：
- en: '[PRE57]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following points are needed for the screen:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕需要以下点：
- en: The ID should be settings, and controller should be `gui.controller.SettingsController`
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID应该是settings，控制器应该是`gui.controller.SettingsController`
- en: The `settingsControl` class we just created should be added inside a layer element
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们刚刚创建的`settingsControl`类应该添加到层元素内部
- en: 'That''s all with regards to XML. To create the `Controller` class, perform
    the following steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 关于XML的内容就到这里。要创建`Controller`类，请执行以下步骤：
- en: As usual, we create a new class that extends `NiftyController`. We call it `SettingsController`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，我们创建一个新的类，该类扩展了`NiftyController`。我们将其命名为`SettingsController`。
- en: We'll have `Element` fields for each of the key bindings we would like to track
    and one `Element` field for the current `selectedElement`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为每个要跟踪的键绑定定义一个`Element`字段，并为当前的`selectedElement`定义一个`Element`字段。
- en: In addition, we should add `Map<Integer, String>` called `mappings` where we
    can keep the relations between key inputs and input bindings.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还应该添加一个名为`mappings`的`Map<Integer, String>`，我们可以在这里保存键输入和输入绑定之间的关系。
- en: From here, we should call a `bindElements` method, which we'll define as well.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，我们应该调用一个`bindElements`方法，我们也将定义它。
- en: Inside this, we'll add the current key bindings to the `mappings` map using
    the key code as key and the actual binding as the value. This can usually be found
    in the class that handles the input.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将使用键码作为键，将实际的绑定作为值添加到`mappings`映射中。这通常可以在处理输入的类中找到。
- en: 'Next, for each of the keys we would like to handle, we find the reference in
    the settings screen and populate their values accordingly. For example, for the
    forward key use the following code:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，对于我们要处理的每个键，我们在设置屏幕中找到其引用，并相应地填充它们的值。例如，对于前进键，使用以下代码：
- en: '[PRE58]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we define a new inner class called `KeyEventListener` that implements
    `RawInputListener`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个新的内部类`KeyEventListener`，该类实现了`RawInputListener`。
- en: In `onKeyEvent`, add an `if` statement for if the incoming `KeyInputEvent` is
    pressed and `selectedElement` is not null.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onKeyEvent`中，添加一个`if`语句，用于检查传入的`KeyInputEvent`是否被按下，并且`selectedElement`不为null。
- en: 'Here, we add a reference to the yet-to-be-created `changeMapping` method and
    add the following line:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们添加对尚未创建的`changeMapping`方法的引用，并添加以下行：
- en: '[PRE59]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, we should set `selectedElement` to `null`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应该将`selectedElement`设置为`null`。
- en: Now, we can turn our attention to the `changeMapping` method.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以将注意力转向`changeMapping`方法。
- en: This method has the pressed key code as an input parameter, and we use this
    to see whether we already have a binding in our `mappings` map. If `inputManager`
    of the application also has this, we should delete the old binding.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法有一个输入参数，即按下的键码，我们使用这个参数来查看我们是否已经在`mappings`映射中有一个绑定。如果应用程序的`inputManager`也有这个，我们应该删除旧的绑定。
- en: Next, we need to iterate through all the values in our `mappings` map and check
    whether any of the bindings match the one that the selected element is handling.
    If you find a match, it should be deleted.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要遍历`mappings`映射中的所有值，并检查是否有任何绑定与所选元素正在处理的绑定匹配。如果找到匹配项，应该将其删除。
- en: Finally, we create a new `KeyTrigger` class using `keyCode` and add it to `inputManager`
    using `addMapping`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`keyCode`创建一个新的`KeyTrigger`类，并使用`addMapping`将其添加到`inputManager`。
- en: The last thing we need to do in this class is add an event subscriber to the
    buttons in `keyBindingControls`.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个类中，我们最后需要做的是向`keyBindingControls`中的按钮添加事件订阅者。
- en: 'We define a new method, `keyClicked(String id, ButtonClickedEvent event)`,
    and give it the following annotation:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个新的方法`keyClicked(String id, ButtonClickedEvent event)`，并给它以下注解：
- en: '[PRE60]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When the button is clicked, the corresponding element should be selected, so
    we use `event.getButton().getElement().getParent()` to find out which one that
    is.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，相应的元素应该被选中，因此我们使用`event.getButton().getElement().getParent()`来找出是哪一个。
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe explains that when a button that represents a key binding is clicked,
    the corresponding element is selected. By using a pattern in the annotation for
    the `keyClicked` method, rather than an ID, we can capture all the keys using
    the wildcard`.*`. This is also why the naming of the elements is important.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱解释了当点击代表按键绑定的按钮时，会选中相应的元素。通过在`keyClicked`方法的注释中使用模式，而不是ID，我们可以使用通配符`.*`捕获所有按键。这也是为什么元素命名很重要。
- en: Once an element is selected, `KeyEventListener` will start to listen for a key
    to be pressed on the keyboard. We set the text of the button to be the text representation
    of the key. In many cases, we can use the `getKeyChar` method of `KeyInputEvent`
    for this; however, not all the methods have a character like representation, hence
    the use of the `Keyboard` class and `getKeyName` method instead. This method tends
    to output a string representation instead.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选中一个元素，`KeyEventListener`将开始监听键盘上的按键。我们将按钮的文本设置为按键的文本表示。在许多情况下，我们可以使用`KeyInputEvent`的`getKeyChar`方法来做这件事；然而，并非所有方法都有字符表示，因此我们使用`Keyboard`类和`getKeyName`方法。这种方法通常输出一个字符串表示。
- en: The `changeMapping` method first sees whether there is a current binding for
    the key pressed and deletes it if that is the case. This is not enough, however,
    since we also need to delete any previous bindings for that input. This is why
    we also iterate over the current mappings to see whether any of them match the
    binding that this key press was for; if yes, it deletes them too.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeMapping`方法首先检查是否有当前按键的绑定，如果有，则删除它。然而，这还不够，因为我们还需要删除该输入的任何先前绑定。这就是为什么我们还要遍历当前映射，看看是否有任何与这次按键绑定的匹配；如果有，也会删除它们。'
- en: There's more...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe uses a static representation of the different input bindings. This
    would most likely be fine for many games, but modern first person shooters for
    example, can have 20 and more key bindings; adding all of these manually to the
    XML can be cumbersome and not good from a maintenance perspective. In this case,
    it might be better to use the Java Builder interface described in the *Creating
    an inventory screen* recipe to let Java do the repetitious work.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用不同输入绑定的静态表示。这很可能对许多游戏来说都很好，但例如现代第一人称射击游戏可能有20个以上的按键绑定；将这些全部手动添加到XML中可能会很繁琐，而且从维护的角度来看也不太好。在这种情况下，可能最好使用在*创建库存屏幕*菜谱中描述的Java
    Builder接口，让Java做重复性的工作。
- en: Using offscreen rendering for a minimap
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用离屏渲染创建最小图
- en: There are generally two ways of creating minimaps. One way is to let an artist
    draw a representation of the map, as shown in the following screenshot. This usually
    ends up beautifully as it gives considerable freedom to the artist when it comes
    to style. The method is not that viable during development when scenes might be
    changing a lot, or for games with procedural content where the end result is not
    known beforehand.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种创建最小图的方法。一种方法是让艺术家绘制地图的表示，如下面的截图所示。这通常非常漂亮，因为它在风格上给了艺术家相当大的自由度。当场景可能变化很多时，或者对于内容是程序生成的游戏，这种方法在开发期间可能不太可行。
- en: '![Using offscreen rendering for a minimap](img/6478OS_06_03.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![使用离屏渲染创建最小图](img/6478OS_06_03.jpg)'
- en: Minimap with unit marker
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 带有单位标记的最小图
- en: In those cases, taking a snapshot of the actual scene can be very helpful. The
    resulting image can then be run through various filters (or shaders during rendering)
    to get a less raw look.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，拍摄实际场景的快照可能非常有帮助。然后可以将生成的图像通过各种过滤器（或渲染期间的着色器）进行处理，以获得更不原始的外观。
- en: In this recipe, we'll achieve this by creating a new `ViewPort` port, and `FrameBuffer`
    to store a snapshot of a camera. Finally, we'll create `NiftyImage` out of it
    and display it as a GUI element.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过创建一个新的`ViewPort`端口和`FrameBuffer`来存储摄像头的快照来实现这一点。最后，我们将从它创建`NiftyImage`并将其作为GUI元素显示。
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''re going to start by creating a `Util` class to handle the rendering of
    our minimap. This will consist of the following 15 steps:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`Util`类来处理我们最小图的渲染。这将由以下15个步骤组成：
- en: Define a new class called `MinimapUtil`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的类，称为`MinimapUtil`。
- en: 'It will only have one static method, `createMiniMap`, with the following declaration:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将只有一个静态方法，`createMiniMap`，具有以下声明：
- en: '[PRE61]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first thing we do is create a new camera called `offScreenCamera` with the
    same width and height that were supplied to the method.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的摄像头，称为`offScreenCamera`，其宽度和高度与方法提供的相同。
- en: 'The camera should have the parallel projection set to true, and a frustrum
    that spans between `1` and `1000` in depth, `-width` to `width`, and `-height`
    to `height`, as shown in the following code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摄像机应该将平行投影设置为`true`，并且一个深度范围为`1`到`1000`，宽度从`-width`到`width`，高度从`-height`到`height`的视锥体，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It should be located at some distance above the scene and rotated downwards,
    as shown in the following code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该位于场景上方一定距离处，并向下旋转，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we create a new `ViewPort` by calling the application''s `RenderManager`
    and its `createPreView` method using `offScreenCamera`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用应用程序的`RenderManager`及其`createPreView`方法，并使用`offScreenCamera`来创建一个新的`ViewPort`：
- en: '[PRE64]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we need a `Texture2D` class to store the data in, so we create a class
    called `offScreenTexture` with the same width and height as before and set `MinFilter`
    to `Trilinear`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个`Texture2D`类来存储数据，因此我们创建一个名为`offScreenTexture`的类，其宽度和高度与之前相同，并将`MinFilter`设置为`Trilinear`：
- en: '[PRE65]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A `FrameBuffer` class is needed as a medium for the data, so we create one
    with the same width and height, and `1` sample, as shown in the following code:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一个`FrameBuffer`类作为数据的中介，所以我们创建一个具有相同宽度和高度，以及`1`个样本的类，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We set `DepthBuffer` to be `Image.Format.Depth` and `offScreenTexture` to be
    `ColorTexture`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`DepthBuffer`设置为`Image.Format.Depth`，将`offScreenTexture`设置为`ColorTexture`：
- en: '[PRE67]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we set `outPutFrameBuffer` of `offScreenView` to be `offScreenBuffer`:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`offScreenView`的`outPutFrameBuffer`设置为`offScreenBuffer`：
- en: '[PRE68]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Unless the scene we supplied already has some lights, we should add at least
    one `Light` class to it.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非我们提供的场景已经有一些灯光，否则我们应该至少添加一个`Light`类到其中。
- en: 'Then, we attach the scene to `offScreenView`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将场景附加到`offScreenView`：
- en: '[PRE69]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To store the texture, we can add it to `AssetManager` with the following line:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了存储纹理，我们可以使用以下行将其添加到`AssetManager`中：
- en: '[PRE70]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we can do the actual rendering by calling the application''s `renderManager`
    and `renderViewPort` methods:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用应用程序的`renderManager`和`renderViewPort`方法来进行实际的渲染：
- en: '[PRE71]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After this, we''re done and can call `removePreview` to discard `offScreeenView`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们完成工作并可以调用`removePreview`来丢弃`offScreeenView`：
- en: '[PRE72]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With the `Util` class done, we can create a screen `Controller` class. Perform
    the following additional six steps to do this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`Util`类之后，我们可以创建一个屏幕`Controller`类。为此，请执行以下六个附加步骤：
- en: Create a new class called `GameScreenController` that extends `NiftyController`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类`GameScreenController`，它扩展了`NiftyController`。
- en: For now, it only needs one public method called `createMinimap` that takes a
    scene as the input.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，它只需要一个名为`createMinimap`的公共方法，该方法接受一个场景作为输入。
- en: The first thing the `createMinimap` method should do is call `MiniMapUtil.createMinimap`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createMinimap`方法应该做的第一件事是调用`MiniMapUtil.createMinimap`。'
- en: With the scene rendered, we can create `NiftyImage` with the `nifty.createImage`
    method.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景渲染完成后，我们可以使用`nifty.createImage`方法创建`NiftyImage`。
- en: 'Then, we can apply the image to our minimap element in the Nifty screen with
    the following line:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下行将图像应用到Nifty屏幕中的缩略图元素：
- en: '[PRE73]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, all we need to do is add a panel element called `minimap` to a screen that
    uses `GameScreenController` as the controller.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要将一个名为`minimap`的面板元素添加到一个使用`GameScreenController`作为控制器的屏幕上。
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Offscreen rendering is just what it sounds like. We render something in a view
    that is not related to the main view that the player sees. To do this, we set
    up a new viewport and camera. It's not possible to render something directly to
    a texture, which is why `FrameBuffer` is used as the medium.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 后台渲染正如其名。我们在与玩家看到的主视图无关的视图中渲染某些内容。为此，我们设置一个新的视口和摄像机。由于无法直接将内容渲染到纹理中，因此使用`FrameBuffer`作为中介。
- en: Once the texture object is created and added to the asset manager, it's possible
    to keep changing it if we would like to at a later stage. It's even possible to
    have a live view of the scene in the minimap, although this would probably cost
    unnecessary resources. In this case, we remove the view as soon as we've rendered
    it once.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建并添加到资产管理器中的纹理对象，我们就可以在以后阶段对其进行更改。甚至可以在缩略图中实时查看场景，尽管这可能会消耗不必要的资源。在这种情况下，我们一旦渲染一次就移除视图。
- en: The example is limited in some sense, like it expects that there is a correlation
    between the size of the scene and the size of the minimap.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在某种程度上是有限的，比如它期望场景的大小和缩略图的大小之间存在关联。
- en: Nifty uses its own image format, `NiftyImage`, so we need to convert the image
    we saved; however, Nifty's `createImage` will automatically find the texture in
    the asset manager based on the name (key).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Nifty 使用它自己的图像格式，`NiftyImage`，因此我们需要将保存的图像进行转换；然而，Nifty 的 `createImage` 将会根据名称（键）自动在资源管理器中找到纹理。
- en: There's more…
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Usually, on a minimap, players will want some kind of indication about their
    (and others) whereabouts. Let''s implement that in the minimap we just created:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在缩略图中，玩家会想要某种关于他们（和其他人）位置的信息。让我们在我们刚刚创建的缩略图中实现这一点：
- en: First of all, we need to change the `minimap` element in our screen a bit. We
    set `childLayout` to `absolute` and add another panel inside it called `playerIcon`
    with a small width and height.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要对我们的屏幕中的 `minimap` 元素进行一些修改。我们将 `childLayout` 设置为 `absolute`，并在其中添加一个名为
    `playerIcon` 的面板，它具有较小的宽度和高度。
- en: Next, we add a new `Element` field called `playerIcon` to the `GameScreenController`
    and use `findElementByName` in the `bind` method to set it.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在 `GameScreenController` 中添加一个新的 `Element` 字段名为 `playerIcon`，并在 `bind`
    方法中使用 `findElementByName` 来设置它。
- en: Then, we add another method called `updatePlayerPosition` with two integers,
    `x` and `y`, as the input.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加另一个名为 `updatePlayerPosition` 的方法，它接受两个整数，`x` 和 `y` 作为输入。
- en: This method should use `setConstraintX` and `setConstraintY` on the `playerIcon`
    element to set the position. Those methods take `SizeValue` as the input, and
    we supply the `x` and `y` values with the `"px"` definition.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法应该在 `playerIcon` 元素上使用 `setConstraintX` 和 `setConstraintY` 来设置位置。这些方法接受 `SizeValue`
    作为输入，我们使用 `"px"` 定义提供 `x` 和 `y` 值。
- en: Finally, in the same method, we need to call `layoutElements()` on the `minimap`
    element to make it update its child elements.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在相同的方法中，我们需要在 `minimap` 元素上调用 `layoutElements()` 来使其更新其子元素。
- en: For other things, such as visible enemies, we can use the builder interface
    to create them as and when we need them and then use `markForRemoval` to remove
    them when they're not needed anymore. An example of this process can be seen in
    the *Handling a game message queue* recipe.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他事物，例如可见的敌人，我们可以根据需要使用构建器接口创建它们，然后使用 `markForRemoval` 在不再需要时移除它们。这个过程的一个例子可以在
    *处理游戏消息队列* 菜谱中看到。
