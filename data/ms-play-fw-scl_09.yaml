- en: Chapter 9. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。测试
- en: 'Testing is the process of cross-checking the implementation of an application/process.
    It brings its shortcomings out into the open. It can be extremely handy when you
    are upgrading/downgrading one or more dependencies. Tests can be classified into
    various categories based on different programming practices, but in this chapter,
    we will only discuss two types of tests:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是交叉检查应用程序/流程实现的过程。它将缺点暴露出来。当你升级/降级一个或多个依赖项时，它可能非常有用。根据不同的编程实践，测试可以划分为各种类别，但在这章中，我们只将讨论两种类型的测试：
- en: '**Unit tests**: These are tests that check the functionality of a specific
    section of code'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些是检查特定代码部分功能的测试'
- en: '**Functional tests**: These are tests that check a specific action, mostly
    written to verify working code with regard to a use case or scenario'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：这些是检查特定操作的测试，通常编写来验证与用例或场景相关的代码是否正常工作'
- en: In the following sections, we will see the different ways in which we can test
    a Play application using **Specs2** and **ScalaTest**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将看到我们可以使用 **Specs2** 和 **ScalaTest** 测试 Play 应用的不同方式。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The tests using either of the Specs2 and ScalaTest libraries are similar. The
    major difference is in the keywords, syntax, and style. Since different developers
    can have different preferences, in this chapter, tests are defined using both
    libraries and for convenience. Most of the tests written using Specs2 have names
    ending with `'Spec'`, while those using ScalaTest end with `'Test'`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Specs2 和 ScalaTest 任意一个库编写的测试是相似的。主要区别在于关键字、语法和风格。由于不同的开发者可能有不同的偏好，在本章中，使用这两个库定义测试，以方便起见。大多数使用
    Specs2 编写的测试以 `'Spec'` 结尾，而使用 ScalaTest 编写的测试以 `'Test'` 结尾。
- en: The setup for writing tests
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试的设置
- en: Play is packaged with `Specs2`, since this is the library used internally for
    testing it. It provides support to test applications using Specs2 by default,
    that is, no additional library dependency is required.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Play 随 `Specs2` 打包，因为这是内部用于测试的库。它默认提供对使用 Specs2 测试应用程序的支持，即不需要额外的库依赖项。
- en: 'Using `ScalaTest` earlier was difficult but now, Play also provides helpers
    for using ScalaTest. Although it is picked up from transitive dependencies, we
    need to add a library dependency to use the helper methods:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期使用 `ScalaTest` 是困难的，但现在，Play 也提供了使用 ScalaTest 的辅助方法。尽管它来自传递依赖，但我们需要添加一个库依赖项来使用这些辅助方法：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The 1.1.0 version of `org.scalatestplus.play` is compatible with Play 2.3.x.
    It is better to check the compatibility when working with another version of Play
    at [http://www.scalatest.org/plus/play/versions](http://www.scalatest.org/plus/play/versions).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.scalatestplus.play` 的 1.1.0 版本与 Play 2.3.x 兼容。当与 Play 的其他版本一起工作时，最好在 [http://www.scalatest.org/plus/play/versions](http://www.scalatest.org/plus/play/versions)
    检查兼容性。'
- en: Unit testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Unit tests can be written as in any Scala project. For example, suppose we
    have a utility method `isNumberInRange` that takes a string and checks if it''s
    a number in the range [0,3600]. It is defined as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以像任何 Scala 项目一样编写。例如，假设我们有一个实用方法 `isNumberInRange`，它接受一个字符串并检查它是否在范围 [0,3600]
    内。它被定义为以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s write a unit test to check this function using `Specs2`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `Specs2` 编写一个单元测试来检查这个函数：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These scenarios can also be written using `ScalaTest` with slight modifications:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景也可以使用 `ScalaTest` 通过轻微修改来编写：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unit tests that need to rely on external dependencies and data service layers
    should be defined using **mocks**. Mocking is the process of simulating actual
    behavior. **Mockito**, **ScalaMock**, **EasyMock**, and **jMock** are some of
    the libraries that facilitate mocking.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 需要依赖外部依赖和数据服务层的单元测试应该使用 **模拟** 来定义。模拟是模拟实际行为的过程。**Mockito**、**ScalaMock**、**EasyMock**
    和 **jMock** 是一些便于模拟的库。
- en: Dissecting PlaySpecification
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆解 PlaySpecification
- en: 'The tests written using Specs2 can also be written as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Specs2 编写的测试也可以按照以下方式编写：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`PlaySpecification` is a trait that provides the required helper methods to
    test a Play application using Specs2\. It is defined as:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaySpecification` 是一个特质，它提供了使用 Specs2 测试 Play 应用程序所需的辅助方法。它被定义为：'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s scan through the API exposed by each of these traits to understand its
    significance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扫描这些特质暴露的 API，以了解其重要性：
- en: '`Specification` and `NoTimeConversions` are traits of Specs2\. `NoTimeConversions`
    can be used to deactivate the time conversions.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Specification` 和 `NoTimeConversions` 是 Specs2 的特质。`NoTimeConversions` 可以用来禁用时间转换。'
- en: '`PlayRunners` provides helper methods to execute a block of code in a running
    application or server with or without specifying the browser.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayRunners` 提供了在运行中的应用程序或服务器中执行代码块的帮助方法，可以指定或不指定浏览器。'
- en: '`HeaderNames` and `Status` define constants for all the standard HTTP headers
    and HTTP status codes, respectively, with their relevant names, as shown here:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HeaderNames` 和 `Status` 分别定义了所有标准 HTTP 头和 HTTP 状态码的常量，以及它们的相关名称，如下所示：'
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`HttpProtocol` defines the constants related to the HTTP protocol:'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpProtocol` 定义了与 HTTP 协议相关的常量：'
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`ResultExtractors` provides methods to extract data from the HTTP response,
    which is of the `Future[Result]` type. These methods are as follows:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultExtractors` 提供了从 HTTP 响应中提取数据的帮助方法，这些方法的数据类型为 `Future[Result]`。这些方法如下：'
- en: '`charset(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charset(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
- en: '`contentAsBytes(of: Future[Result])(implicit timeout: Timeout): Array[Byte]`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentAsBytes(of: Future[Result])(implicit timeout: Timeout): Array[Byte]`'
- en: '`contentAsJson(of: Future[Result])(implicit timeout: Timeout): JsValue`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentAsJson(of: Future[Result])(implicit timeout: Timeout): JsValue`'
- en: '`contentAsString(of: Future[Result])(implicit timeout: Timeout): String`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentAsString(of: Future[Result])(implicit timeout: Timeout): String`'
- en: '`contentType(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentType(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
- en: '`cookies(of: Future[Result])(implicit timeout: Timeout): Cookies`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookies(of: Future[Result])(implicit timeout: Timeout): Cookies`'
- en: '`flash(of: Future[Result])(implicit timeout: Timeout): Flash`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash(of: Future[Result])(implicit timeout: Timeout): Flash`'
- en: '`header(header: String, of: Future[Result])(implicit timeout: Timeout): Option[String]`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header(header: String, of: Future[Result])(implicit timeout: Timeout): Option[String]`'
- en: '`headers(of: Future[Result])(implicit timeout: Timeout): Map[String, String]`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers(of: Future[Result])(implicit timeout: Timeout): Map[String, String]`'
- en: '`redirectLocation(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectLocation(of: Future[Result])(implicit timeout: Timeout): Option[String]`'
- en: '`session(of: Future[Result])(implicit timeout: Timeout): Session`'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session(of: Future[Result])(implicit timeout: Timeout): Session`'
- en: '`status(of: Future[Result])(implicit timeout: Timeout): Int`'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status(of: Future[Result])(implicit timeout: Timeout): Int`'
- en: The `implicit Timeout` in these method calls is provided by the `DefaultAwaitTimeout`
    trait and the default timeout is set to 20 seconds. This can be overridden by
    providing an implicit timeout in the scope of the scenario.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法调用中的 `implicit Timeout` 由 `DefaultAwaitTimeout` 特质提供，默认超时设置为 20 秒。这可以通过在场景作用域内提供隐式超时来覆盖。
- en: '`RouteInvokers` provides the methods to call a corresponding `Action` for a
    given request using `Router`. These methods are as follows:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouteInvokers` 提供了使用 `Router` 调用给定请求的相应 `Action` 的方法。这些方法如下：'
- en: '`route[T](app: Application, req: Request[T])(implicit w: Writeable[T]): Option[Future[Result]]`'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route[T](app: Application, req: Request[T])(implicit w: Writeable[T]): Option[Future[Result]]`'
- en: '`route[T](app: Application, rh: RequestHeader, body: T)(implicit w: Writeable[T]):
    Option[Future[Result]]`'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route[T](app: Application, rh: RequestHeader, body: T)(implicit w: Writeable[T]):
    Option[Future[Result]]`'
- en: '`route[T](req: Request[T])(implicit w: Writeable[T]): Option[Future[Result]]`'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route[T](req: Request[T])(implicit w: Writeable[T]): Option[Future[Result]]`'
- en: '`route[T](rh: RequestHeader, body: T)(implicit w: Writeable[T]): Option[Future[Result]]`'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route[T](rh: RequestHeader, body: T)(implicit w: Writeable[T]): Option[Future[Result]]`'
- en: '`call[T](action: EssentialAction, rh: RequestHeader, body: T)(implicit w: Writeable[T]):
    Future[Result]`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call[T](action: EssentialAction, rh: RequestHeader, body: T)(implicit w: Writeable[T]):
    Future[Result]`'
- en: '`call[T](action: EssentialAction, req: FakeRequest[T])(implicit w: Writeable[T]):
    Future[Result]`'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call[T](action: EssentialAction, req: FakeRequest[T])(implicit w: Writeable[T]):
    Future[Result]`'
- en: The `implicit Writable` in these method calls is provided by the `Writeables`
    trait. The `call` methods are inherited from `EssentialActionCaller`.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法调用中的 `implicit Writable` 由 `Writeables` 特质提供。`call` 方法是从 `EssentialActionCaller`
    继承的。
- en: The `FutureAwaits` trait provides methods to wait on a request with or without
    specifying the waiting time.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FutureAwaits` 特质提供了在指定或不指定等待时间的情况下等待请求的方法。'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although the library that supports ScalaTest for a Play application has an
    `PlaySpec` abstract class, there is no equivalent to `PlaySpecification` for ScalaTest.
    Instead, there''s a helper object, which is defined as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然支持 Play 应用的 ScalaTest 库有一个 `PlaySpec` 抽象类，但没有 `PlaySpecification` 的等效物。取而代之的是，有一个帮助对象，定义如下：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`PlaySpec` is defined as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaySpec` 定义如下：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Hence, importing `play.api.test.Helpers` is also sufficient to use only the
    helper methods.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，导入 `play.api.test.Helpers` 也足以使用仅有的帮助方法。
- en: For the following sections, with regard to tests using Specs2, we will extend
    PlaySpecification, and for ScalaTest, we will assume that `play.api.test.Helpers`
    is imported and the test extends to `PlaySpec`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下部分，关于使用 Specs2 的测试，我们将扩展 PlaySpecification，而对于 ScalaTest，我们假设已经导入了 `play.api.test.Helpers`，并且测试扩展到
    `PlaySpec`。
- en: Unit testing a controller
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试控制器
- en: 'We might have a simple project with a `User` model and `UserRepo`, defined
    as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个简单的项目，其中包含 `User` 模型和 `UserRepo`，定义如下：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this project, we need to test a `getUser` method of `UserController`—a controller
    that is defined to access user details, which are handled by the user model, where
    `UserController` is defined as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们需要测试 `UserController` 的 `getUser` 方法——这是一个定义用来访问用户详情的控制器，这些详情由用户模型处理，其中
    `UserController` 定义如下：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`AnormUserRepo` is an implementation of `UserRepo`, which uses Anorm for DB
    transactions. The methods in `UserController` are mapped in the routes file as
    follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnormUserRepo` 是 `UserRepo` 的一个实现，它使用 Anorm 进行数据库事务。`UserController` 中的方法在路由文件中映射如下：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since mocking Scala objects for tests is not yet fully supported by a testing
    library, there are different approaches to unit test a controller. These are as
    follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试库尚未完全支持模拟 Scala 对象，因此有几种不同的方法可以单元测试控制器。这些方法如下：
- en: Defining all the controller's methods in a trait and then this trait can be
    extended by an object, while the trait is tested for functionality
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在特质中定义控制器的所有方法，然后这个特质可以被一个对象扩展，同时特质的功能被测试
- en: Defining controllers as classes and wiring up other required services using
    dependency injection
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控制器定义为类，并使用依赖注入连接其他所需服务
- en: Both these approaches require us to modify our application code. We can choose
    the one that suits our coding practices the best. Let's see what these changes
    are and how to write the corresponding tests in the following sections.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都需要我们修改我们的应用程序代码。我们可以选择最适合我们编码实践的一种。让我们看看这些更改是什么，以及如何在以下部分中编写相应的测试。
- en: Using traits for controllers
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特质定义控制器
- en: 'In this approach, we define all the controller''s methods in a trait and define
    the controller by extending this trait. For example, `UserController` should be
    defined as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们定义了控制器中的所有方法在一个特质中，并通过扩展这个特质来定义控制器。例如，`UserController` 应该定义为如下所示：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can write tests for the `BaseUserController` trait—`UserControllerSpec`
    using Specs2 as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 Specs2 编写 `BaseUserController` 特质的测试——`UserControllerSpec`，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`FakeRequest` is a helper that generates fake HTTP requests while testing.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`FakeRequest` 是一个在测试中生成伪造 HTTP 请求的辅助工具。'
- en: Here, we mock `UserRepo` and use this mock to generate a new instance of `TestController`.
    ScalaTest provides integration with Mockito via its `MockitoSugar` trait, so there
    will be small changes in the code for mocking.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们模拟 `UserRepo` 并使用这个模拟生成 `TestController` 的新实例。ScalaTest 通过其 `MockitoSugar`
    特质提供了与 Mockito 的集成，因此模拟代码将有一些小的变化。
- en: 'Using ScalaTest, the `UserControllerTest` test will be as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ScalaTest，`UserControllerTest` 测试将如下所示：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using dependency injection
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用依赖注入
- en: We can make our controller depend on specific services, and all of this is configurable
    through the global object's `getControllerInstance` method by using a dependency
    injection library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使我们的控制器依赖于特定的服务，并且所有这些都可以通过使用依赖注入库通过全局对象的 `getControllerInstance` 方法进行配置。
- en: 'In this example, we have used **Guice** by adding it as a dependency for our
    project:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过将其添加为项目依赖项来使用 **Guice**：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s update the `getControllerInstance` method in the `Global` object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新 `Global` 对象中的 `getControllerInstance` 方法：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We now define `UserController` as a singleton that extends `play.api.mvc.Controller`
    and uses `UserRepo`, which is injected:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将 `UserController` 定义为一个单例，它扩展了 `play.api.mvc.Controller` 并使用 `UserRepo`，该库是通过依赖注入实现的：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will also need to modify the routes file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改路由文件：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `@` symbol at the beginning of the method call indicates that the global
    object's `getControllerInstance` method should be used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用开头处的 `@` 符号表示应该使用全局对象的 `getControllerInstance` 方法。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we do not add the `@` suffix to the method name, it will search for an object
    with the `UserController` name and throw errors during compilation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不添加方法名称的 `@` 后缀，它将搜索具有 `UserController` 名称的对象，并在编译期间抛出错误：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can write a unit test using Specs2 as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 Specs2 编写单元测试，如下所示：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we mock `AnormUserRepo` and use this mock to generate a new instance of
    `UserController`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们模拟 `AnormUserRepo` 并使用这个模拟生成 `UserController` 的新实例。
- en: 'The same test using ScalaTest will be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ScalaTest的相同测试如下：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following table summarizes the key differences in both these approaches,
    so that it''s easier to decide which one suits your requirement in the best way:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了这两种方法的关键区别，以便更容易决定哪一种最适合您的需求：
- en: '| Using traits for controllers | Using dependency injection |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 使用特质进行控制器 | 使用依赖注入 |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| It requires defining and not just declaring all the methods to be supported
    by a controller in a trait. | It requires a controller to be defined as a singleton
    class and provides implementations for the global object''s `getControllerInstance`
    method. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 需要在特质中定义和声明所有要由控制器支持的的方法。 | 需要将控制器定义为单例类，并为全局对象的`getControllerInstance`方法提供实现。
    |'
- en: '| It does not require additional libraries. | It requires using a dependency
    injection library and provides flexibility to plug-in different classes in different
    application modes. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 不需要额外的库。 | 需要使用依赖注入库，并提供在不同应用模式中插入不同类的灵活性。 |'
- en: '| It requires defining an additional class for a controller, which extends
    a trait for testing. | It does not require any additional class definitions to
    test a controller, since a new instance can be instantiated from a singleton.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 需要定义一个额外的类来扩展测试的控制器特质。 | 不需要定义任何额外的类来测试控制器，因为可以从单例中实例化一个新的实例。 |'
- en: For more examples on dependency injection, refer to [https://www.playframework.com/documentation/2.3.x/ScalaDependencyInjection](https://www.playframework.com/documentation/2.3.x/ScalaDependencyInjection).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于依赖注入的示例，请参阅[https://www.playframework.com/documentation/2.3.x/ScalaDependencyInjection](https://www.playframework.com/documentation/2.3.x/ScalaDependencyInjection)。
- en: Functional testing
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: 'Let''s look at some of Play''s test cases to see how to use the helper methods.
    For example, consider the `DevErrorPageSpec` test, which is defined as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Play的一些测试用例，看看如何使用辅助方法。例如，考虑定义如下`DevErrorPageSpec`测试：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This test starts `FakeApplication` with the Prod mode and checks the response
    when `FakeRequest` encounters an exception.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试以生产模式启动`FakeApplication`，并检查当`FakeRequest`遇到异常时的响应。
- en: '`FakeApplication` extends an application and is defined as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`FakeApplication`扩展了应用程序，并定义如下：'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The method that is running is part of PlayRunners and executes a block of code
    in the context of a given application. It is defined as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行的方法是PlayRunners的一部分，在给定应用程序的上下文中执行代码块。它定义如下：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'PlayRunners has a few more definitions of how to run, these are:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: PlayRunners有更多关于如何运行的定义，如下所示：
- en: '`running[T](testServer: TestServer)(block: => T)``: T`: This can be used to
    execute a block of code in a running server.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`running[T](testServer: TestServer)(block: => T): T`：这可以用来在一个运行的服务器中执行一段代码块。'
- en: '`running[T](testServer: TestServer, webDriver: WebDriver)(block: TestBrowser
    => T): T`: This can be used to execute a block of code in a running server with
    a test browser.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`running[T](testServer: TestServer, webDriver: WebDriver)(block: TestBrowser
    => T): T`：这可以用来在一个运行的服务器中执行一段代码块，并使用测试浏览器。'
- en: '`running[T, WEBDRIVER <: WebDriver](testServer: TestServer, webDriver: Class[WEBDRIVER])(block:
    TestBrowser => T): T`: This can also be used to execute a block of code in a running
    server with a test browser using Selenium WebDriver. This method uses the previous
    method internally.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`running[T, WEBDRIVER <: WebDriver](testServer: TestServer, webDriver: Class[WEBDRIVER])(block:
    TestBrowser => T): T`：这也可以用来在一个运行的服务器中使用Selenium WebDriver执行带有测试浏览器的代码块。此方法内部使用之前的方法。'
- en: Instead of using the `running` method directly, as an alternative, we could
    define our tests using the wrapper classes, which make use of the running. There
    are different helpers for Specs2 and ScalaTest.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代替直接使用`running`方法，我们可以定义测试使用包装类，这些类利用了`running`。对于Specs2和ScalaTest有不同的辅助类。
- en: Using Specs2
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Specs2
- en: 'First, let''s look at the ones available when using Specs2\. They are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看使用Specs2时可用的一些。它们如下所示：
- en: '`WithApplication`: It is used to execute a test within the context of a running
    application. For example, consider a situation where we want to write functional
    tests for `CountController`, which is responsible for getting a count of distinct
    data grouped by a perspective. We can write the test as follows:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithApplication`：它用于在运行的应用程序上下文中执行测试。例如，考虑我们想要为`CountController`编写功能测试的情况，该控制器负责按视角分组获取不同数据的计数。我们可以编写如下测试：'
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, assume that `TestHelper` is a helper object specifically defined for simplifying
    the code of test cases (extracting common processes as methods).
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，假设 `TestHelper` 是一个专门为简化测试用例代码（将常见过程作为方法提取）而定义的辅助对象。
- en: 'If we need to specify `FakeApplication`, we can do so by passing it as an argument
    to the `WithApplication` constructor:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们需要指定 `FakeApplication`，我们可以通过将其作为参数传递给 `WithApplication` 构造函数来实现：
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This comes in handy when we want to change the default application configurations,
    GlobalSettings, and so on for the tests.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们想要为测试更改默认应用程序配置、GlobalSettings 等，这会很有用。
- en: '`WithServer`: It is used to execute tests within the context of a running application
    on a new `TestServer`. This is quite useful when we need to start our `FakeApplication`
    on a new `TestServer` at a specific port. After slightly modifying the previous
    example:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithServer`: 它用于在新的 `TestServer` 上执行运行中的应用程序上下文中的测试。当我们需要在特定端口上启动新的 `FakeApplication`
    时，这非常有用。在稍微修改之前的示例后：'
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`WithBrowser`: It is used to test an application''s functionality by performing
    certain actions in browsers. For example, consider a dummy application where the
    page title changes on the click of a button. We can test it as follows:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithBrowser`: 它通过在浏览器中执行某些操作来测试应用程序的功能。例如，考虑一个模拟应用程序，其中按钮点击时页面标题会改变。我们可以这样测试它：'
- en: '[PRE29]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are assuming `TestRoute` is a partial function that maps to some of the routes
    which can then be used in tests.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们假设 `TestRoute` 是一个部分函数，它映射到一些路由，然后可以在测试中使用。
- en: Using ScalaTest
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ScalaTest
- en: 'Now, lets see what **ScalaTestPlus-Play**, the library with helper methods
    that are used for testing with the help of ScalaTest, has to offer. In this section,
    we will see examples from `ScalatestPlus-Play` wherever applicable. The helpers
    for ScalaTest are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 **ScalaTestPlus-Play**，这个库提供了用于通过 ScalaTest 进行测试的辅助方法，它有什么可以提供的。在本节中，我们将根据适用性展示
    `ScalatestPlus-Play` 的示例。ScalaTest 的辅助方法如下：
- en: '`OneAppPerSuite`: It starts `FakeApplication` using `Play.start` before running
    any tests in a suite and then stops it once they are completed. The application
    is exposed through the variable app and can be overridden if required. From `ExampleSpec.scala`:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneAppPerSuite`: 在套件中运行任何测试之前，它使用 `Play.start` 启动 `FakeApplication`，然后在测试完成后停止它。应用程序通过变量
    `app` 公开，如果需要可以重写。从 `ExampleSpec.scala`：'
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we wish to use the same application for all or multiple suites, we can define
    a nested suite. For such an example, we can refer to `NestedExampleSpec.scala`
    from the library.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们希望为所有或多个套件使用相同的应用程序，我们可以定义一个嵌套套件。对于此类示例，我们可以参考库中的 `NestedExampleSpec.scala`。
- en: '`OneAppPerTest`: It starts a new `FakeApplication` for each test defined in
    the suite. The application is exposed through the `newAppForTest` method and can
    be overridden if required. For example, consider the `OneAppTest` test, where
    each test uses a different `FakeApplication` obtained through `newAppForTest`:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneAppPerTest`: 它为套件中定义的每个测试启动一个新的 `FakeApplication`。应用程序通过 `newAppForTest`
    方法公开，如果需要可以重写。例如，考虑 `OneAppTest` 测试，其中每个测试都使用通过 `newAppForTest` 获取的不同 `FakeApplication`：'
- en: '[PRE31]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`OneServerPerSuite`: It starts a new `FakeApplication` and a new `TestServer`
    for the suite. The application is exposed through the variable app and can be
    overridden if required. The server''s port is set from the variable port and can
    be changed/modified if required. This has been demonstrated in the example for
    `OneServerPerSuite` (`ExampleSpec2.scala`):'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneServerPerSuite`: 它为套件启动一个新的 `FakeApplication` 和一个新的 `TestServer`。应用程序通过变量
    `app` 公开，如果需要可以重写。服务器端口由变量 `port` 设置，如果需要可以更改/修改。这已在 `OneServerPerSuite` 的示例（`ExampleSpec2.scala`）中演示：'
- en: '[PRE32]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we require multiple suites to use the same FakeApplication and TestServer,
    we can define tests using a nested suite similar to `NestedExampleSpec2.scala`.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们需要多个套件使用相同的 FakeApplication 和 TestServer 时，我们可以定义类似于 `NestedExampleSpec2.scala`
    的嵌套套件测试。
- en: '`OneServerPerTest`: It starts a new `FakeApplication` and `TestServer` for
    each test defined in the suite. The application is exposed through the `newAppForTest`
    method and can be overridden if required. For example, consider the `DiffServerTest`
    test, where each test uses a different `FakeApplication` obtained through `newAppForTest`
    and the `TestServer` port is overridden:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneServerPerTest`: 它为套件中定义的每个测试启动一个新的 `FakeApplication` 和 `TestServer`。应用程序通过
    `newAppForTest` 方法公开，如果需要可以重写。例如，考虑 `DiffServerTest` 测试，其中每个测试都使用通过 `newAppForTest`
    获取的不同 `FakeApplication`，并且 `TestServer` 端口被重写：'
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`OneBrowserPerSuite`: It provides a new Selenium WebDriver instance per suite.
    For example, assume that we wish to test the clicking of a button by opening the
    application in Firefox, the test can be written in the same way as `ExampleSpec3.scala`:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneBrowserPerSuite`: 它为每个测试套件提供一个新的 Selenium WebDriver 实例。例如，假设我们希望通过在 Firefox
    中打开应用程序来测试按钮的点击，测试可以像 `ExampleSpec3.scala` 一样编写：'
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are assuming `TestRoute` is a partial function that maps to some of the routes,
    which can then be used in tests.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们假设 `TestRoute` 是一个部分函数，它映射到一些路由，然后可以在测试中使用。
- en: 'The same trait can be used to test the application within multiple browsers,
    as demonstrated in `MultiBrowserExampleSpec.scala`. To execute tests in all the
    browsers, we should use `AllBrowsersPerSuite`, as follows:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样的特质可以用来在多个浏览器中测试应用程序，如 `MultiBrowserExampleSpec.scala` 中所示。要执行所有浏览器的测试，我们应该使用
    `AllBrowsersPerSuite`，如下所示：
- en: '[PRE35]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The trait `OneBrowserPerSuite` can also be used with nested tests. Refer to
    `NestedExampleSpec3.scala`.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OneBrowserPerSuite` 特质也可以与嵌套测试一起使用。请参阅 `NestedExampleSpec3.scala`。'
- en: '`OneBrowserPerTest`: It starts a new browser session for each test in the suite.
    This can be noticed by running the `ExampleSpec4.scala` test. It''s similar to
    `ExampleSpec3.scala`, but `OneServerPerSuite` and `OneBrowserPerSuite` have been
    replaced with `OneServerPerTest` and `OneBrowserPerTest`, respectively, as shown
    here:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneBrowserPerTest`: 它为套件中的每个测试启动一个新的浏览器会话。这可以通过运行 `ExampleSpec4.scala` 测试来注意到。它与
    `ExampleSpec3.scala` 类似，但 `OneServerPerSuite` 和 `OneBrowserPerSuite` 分别被替换为 `OneServerPerTest`
    和 `OneBrowserPerTest`，如下所示：'
- en: '[PRE36]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've also replaced the overridden app variable with the `newAppForTest` overridden
    method. Try writing a test that uses the `AllBrowsersPerTest` trait.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还用 `newAppForTest` 重写方法替换了重写的 `app` 变量。尝试编写一个使用 `AllBrowsersPerTest` 特质的测试。
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can run into an InvalidActorNameException when running multiple functional
    tests simultaneously on an application, which defines custom actors. We can avoid
    this by defining a nested test where multiple tests use the same `FakeApplication`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当在定义自定义演员的应用程序上同时运行多个功能测试时，可能会遇到 InvalidActorNameException。我们可以通过定义一个嵌套测试来避免这种情况，其中多个测试使用相同的
    `FakeApplication`。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how a Play application can be tested using Specs2 or
    ScalaTest. We have also come across the different helper methods available to
    simplify testing a Play application. In the unit testing section, we discussed
    the different approaches that can be taken while designing models and controller
    based on the preferred testing process using traits with defined methods or dependency
    injection. We also discussed the functional testing of a Play application within
    the context of an application with a test server and within a browser using Selenium
    WebDrivers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 Specs2 或 ScalaTest 测试 Play 应用程序。我们还遇到了简化 Play 应用程序测试的不同辅助方法。在单元测试部分，我们讨论了在设计模型和控制器时可以采取的不同方法，这些方法基于首选的测试过程，使用具有定义方法的特质或依赖注入。我们还讨论了在具有测试服务器和浏览器使用
    Selenium WebDriver 的上下文中对 Play 应用程序的功能测试。
- en: In the next chapter, we will discuss debugging and logging in to your Play application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Play 应用程序的调试和日志记录。
