- en: Modular Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化编程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using jdeps to find dependencies in a Java application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jdeps在Java应用程序中查找依赖项
- en: Creating a simple modular application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的模块化应用程序
- en: Creating a modular JAR
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模块化JAR文件
- en: Using a module JAR with pre-JDK 9 applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在预JDK 9应用程序中使用模块JAR文件
- en: Bottom-up migration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自底向上的迁移
- en: Top-down migration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自顶向下的迁移
- en: Using services to create loose coupling between consumer and provider modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务在消费者模块和提供者模块之间创建松耦合
- en: Creating a custom modular runtime image using jlink
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jlink创建自定义模块化运行时映像
- en: Compiling for older platform versions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为旧平台版本编译
- en: Creating multirelease JARs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多版本JAR文件
- en: Using Maven to develop a modular application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven开发模块化应用程序
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Modular programming enables one to organize code into independent, cohesive
    modules, which can be combined together to achieve the desired functionality.
    This allows in creating code that is:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程使人们能够将代码组织成独立的、凝聚的模块，这些模块可以组合在一起以实现所需的功能。这允许创建以下代码：
- en: More cohesive because the modules are built with a specific purpose, so the
    code that resides there tends to cater to that specific purpose.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更具凝聚力，因为模块是针对特定目的构建的，所以驻留在那里的代码往往是为了满足那个特定目的。
- en: Encapsulated because modules can interact with only those APIs that have been
    made available by the other modules.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装的，因为模块只能与那些由其他模块提供的API交互。
- en: Reliable because the discoverability is based on the modules and not on the
    individual types. This means that if a module is not present, then the dependent
    module cannot be executed until it is discoverable by the dependent module. This
    helps in preventing runtime errors.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠的，因为可发现性是基于模块而不是基于单个类型。这意味着如果某个模块不存在，那么依赖模块将无法执行，直到它被依赖模块发现。这有助于防止运行时错误。
- en: Loosely coupled. If you use service interfaces, then the module interface and
    the service interface implementation can be loosely coupled.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松耦合。如果你使用服务接口，那么模块接口和服务接口实现可以松耦合。
- en: So, the thought process in designing and organizing the code will now involve
    identifying the modules, code, and configuration files, which go into the module
    and the packages in which the code is organized within the module. After that,
    we have to decide the public APIs of the module, thereby making them available
    for use by dependent modules.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设计和组织代码时的思维过程现在将涉及识别模块、代码和配置文件，这些文件将进入模块，以及代码在模块内组织的包。之后，我们必须决定模块的公共API，从而使它们可供依赖模块使用。
- en: 'Coming to the development of the Java Platform Module System, it is being governed
    by **Java Specification Request** (**JSR**) 376 ([https://www.jcp.org/en/jsr/detail?id=376](https://www.jcp.org/en/jsr/detail?id=376)).
    The JSR mentions the need for a module system is to address the following fundamental
    issues:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 说到Java平台模块系统的开发，它正由**Java规范请求**（**JSR**）376（[https://www.jcp.org/en/jsr/detail?id=376](https://www.jcp.org/en/jsr/detail?id=376)）管理。JSR提到模块系统的需求是为了解决以下基本问题：
- en: '**Reliable configuration**: Developers have long suffered from the brittle,
    error-prone classpath mechanism for configuring program components. The classpath
    cannot express relationships between components, so if a necessary component is
    missing, then that will not be discovered until an attempt is made to use it.
    The classpath also allows classes in the same package to be loaded from different
    components, leading to unpredictable behavior and difficult-to-diagnose errors.
    The proposed specification will allow a component to declare that it depends upon
    other components as other components depend upon it.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠的配置**：开发者长期以来一直遭受脆弱、易出错的类路径机制来配置程序组件。类路径不能表达组件之间的关系，因此如果必要的组件缺失，那么它将不会被发现，直到尝试使用它。类路径还允许从不同的组件中加载同一包中的类，导致不可预测的行为和难以诊断的错误。所提出的规范将允许一个组件声明它依赖于其他组件，就像其他组件依赖于它一样。'
- en: '**Strong encapsulation**: The access-control mechanism of the Java programming
    language and the JVM provides no way for a component to prevent other components
    from accessing its internal packages. The proposed specification will allow a
    component to declare its packages that are accessible by other components and
    those that are not.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强封装**：Java编程语言和JVM的访问控制机制没有提供任何方法来阻止一个组件防止其他组件访问其内部包。所提出的规范将允许一个组件声明其可以被其他组件访问的包以及那些不可以被访问的包。'
- en: 'The JSR further goes to list the advantages that result from addressing the
    preceding issues, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JSR 还进一步列出了解决上述问题所带来的优势，如下所示：
- en: '**A scalable platform**: The ever-increasing size of the Java SE platform has
    made it increasingly difficult to use in small devices, despite the fact that
    many such devices are capable of running an SE-class JVM. The compact profiles
    introduced in Java SE 8 (JSR 337) help in this regard, but they are not nearly
    flexible enough. The proposed specification will allow the Java SE platform and
    its implementations to be decomposed into a set of components that can be assembled
    by developers into custom configurations that contain only the functionality actually
    required by an application.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展的平台**：Java SE 平台的大小不断增加，使得在小型设备上使用变得越来越困难，尽管许多此类设备能够运行 SE 类 JVM。Java SE
    8（JSR 337）中引入的紧凑配置有助于解决这个问题，但它们远不够灵活。拟议的规范将允许 Java SE 平台及其实现被分解成一组组件，开发者可以将这些组件组装成自定义配置，其中只包含应用程序实际需要的功能。'
- en: '**Greater platform integrity**: Casual use of APIs that are internal to Java
    SE platform implementations is both a security risk and a maintenance burden.
    The strong encapsulation provided by the proposed specification will allow components
    that implement the Java SE platform to prevent access to their internal APIs.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的平台完整性**：对 Java SE 平台实现内部 API 的随意使用既是安全风险也是维护负担。拟议的规范提供的强大封装将允许实现 Java
    SE 平台的组件防止对其内部 API 的访问。'
- en: '**Improved performance**: Many ahead-of-time, whole-program optimization techniques
    can be more effective when it is known that a class can refer only to classes
    in a few other specific components rather than to any class loaded at runtime.
    Performance is especially enhanced when the components of an application can be
    optimized in conjunction with the components that implement the Java SE platform.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的性能**：当知道一个类只能引用几个其他特定组件中的类，而不是运行时加载的任何类时，许多提前时间、整个程序优化技术可以更有效。当应用程序的组件可以与实现
    Java SE 平台的组件一起优化时，性能尤其得到提升。'
- en: In this chapter, we will look at few important recipes that will help you get
    started with modular programming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些重要的食谱，这些食谱将帮助您开始模块化编程。
- en: Using jdeps to find dependencies in a Java application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jdeps 在 Java 应用程序中查找依赖项
- en: The first step in modularizing your application is to identify its dependencies.
    A static analysis tool called `jdeps` was introduced in JDK 8 to enable developers
    to find the dependencies of their applications. There are multiple options supported
    in the command, which enables developers to check for dependencies to the JDK
    internal APIs, show the dependencies at the package level, show the dependencies
    at the class level, and filter the dependencies, among other options.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的应用程序模块化的第一步是确定其依赖项。在 JDK 8 中引入了一个名为 `jdeps` 的静态分析工具，以使开发者能够找到其应用程序的依赖项。命令支持多个选项，这使开发者能够检查对
    JDK 内部 API 的依赖，显示包级别的依赖，显示类级别的依赖，以及过滤依赖，等等。
- en: In this recipe, we will look at how to make use of the `jdeps` tool by exploring
    its functionality and using the multiple command-line options it supports.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探讨如何通过探索其功能和使用它支持的多个命令行选项来利用 `jdeps` 工具。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need a sample application, which we can run against the `jdeps` command
    to find its dependencies. So, we thought of creating a very simple application
    that uses the Jackson API to consume JSON from the REST API: [http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个示例应用程序，我们可以运行 `jdeps` 命令来找到其依赖项。因此，我们想到了创建一个非常简单的应用程序，该应用程序使用 Jackson
    API 从 REST API 消费 JSON：[http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users)。
- en: In the sample code, we also added a call to the deprecated JDK internal API,
    called `sun.reflect.Reflection.getCallerClass()`. This way, we can see how `jdeps`
    helps in finding dependencies to the JDK internal APIs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，我们还添加了对已弃用的 JDK 内部 API 的调用，该 API 被称为 `sun.reflect.Reflection.getCallerClass()`。这样，我们可以看到
    `jdeps` 如何帮助找到对 JDK 内部 API 的依赖。
- en: 'The following steps will help you to set up the prerequisites for this recipe:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您设置本食谱的先决条件：
- en: You can get the complete code for the sample from the location, `chp3/1_json-jackson-sample`.
    We have built this code against Java 9 and it compiles well. So, you need not
    install something other than Java 9 to compile it.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从位置 `chp3/1_json-jackson-sample` 获取示例的完整代码。我们针对 Java 9 构建了此代码，并且它可以很好地编译。因此，您不需要安装除
    Java 9 以外的任何东西来编译它。
- en: 'Once you have the code, compile it by using the following:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有代码，就可以使用以下命令编译它：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will see a warning for the use of an internal API, which you can safely
    ignore. We added this with a purpose to demonstrate the capability of `jdeps`.
    Now, you should have your compiled class files in the classes directory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个关于使用内部 API 的警告，你可以安全地忽略它。我们添加这个是为了演示 `jdeps` 的能力。现在，你应该已经在 classes 目录中有编译好的类文件。
- en: 'You can run the sample program by using the following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令运行示例程序：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have provided the `run.bat` and `run.sh` scripts at `chp3/1_json-jackson-sample`.
    You can compile and run using these scripts as well.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `chp3/1_json-jackson-sample` 提供了 `run.bat` 和 `run.sh` 脚本。您也可以使用这些脚本进行编译和运行。
- en: 'Let''s also create a JAR file for this sample so that we can run `jdeps` on
    the JAR file as well:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也为这个示例创建一个 JAR 文件，这样我们就可以在 JAR 文件上运行 `jdeps`：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A `sample.jar` file gets created in the current directory. You can also run
    the JAR by issuing this command: `java -jar sample.jar`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录下创建了一个 `sample.jar` 文件。您也可以通过以下命令运行 JAR：`java -jar sample.jar`。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The simplest way to use `jdeps` is as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `jdeps` 的最简单方法是如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding command is equivalent to the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令等同于以下命令：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/b28ed050-3259-48b4-9335-39711bd29a8d.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b28ed050-3259-48b4-9335-39711bd29a8d.png)'
- en: In the preceding command, we use `jdeps` to list the dependencies for the class
    file, `Sample.class`, at the package level. We have to provide `jdeps` with the
    path to search for the dependencies of the code being analyzed. This can be done
    by setting the `-classpath`, `-cp`, or `--class-path` option of the `jdeps` command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用 `jdeps` 列出类文件 `Sample.class` 在包级别的依赖关系。我们必须为 `jdeps` 提供搜索正在分析的代码依赖关系的路径。这可以通过设置
    `jdeps` 命令的 `-classpath`、`-cp` 或 `--class-path` 选项来完成。
- en: The `-verbose:package` option lists the dependencies at the package level.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`-verbose:package` 选项列出包级别的依赖关系。'
- en: 'Let''s list the dependencies at the class level:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出类级别的依赖关系：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下：
- en: '![](img/c0bab155-4237-4b6f-ab35-4e24fdbc749d.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0bab155-4237-4b6f-ab35-4e24fdbc749d.png)'
- en: In this case, we make use of the `-verbose:class` option to list the dependencies
    at the class level, which is why you can see that the `com.packt.Sample` class
    depends on `com.packt.model.Company`, `java.lang.Exception`, `com.fasterxml.jackson.core.type.TypeReference`,
    and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了 `-verbose:class` 选项来列出类级别的依赖关系，这就是为什么你可以看到 `com.packt.Sample` 类依赖于
    `com.packt.model.Company`、`java.lang.Exception`、`com.fasterxml.jackson.core.type.TypeReference`
    等原因。
- en: 'Let''s get the summary of the dependencies:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取依赖关系的摘要：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/96d306f0-8b73-49b2-8e09-abb1bee38ace.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96d306f0-8b73-49b2-8e09-abb1bee38ace.png)'
- en: 'Let''s check for the dependency on the JDK internal API:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查对 JDK 内部 API 的依赖性：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is the output of the preceding command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下：
- en: '![](img/a4248c94-c0d2-4812-b7db-6b580e43f99a.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4248c94-c0d2-4812-b7db-6b580e43f99a.png)'
- en: The StackWalker API is the new API for traversing the call stack, introduced
    in Java 9\. This is the replacement for the `sun.reflect.Reflection.getCallerClass()`
    method. We will discuss this API in [Chapter 12](01ba0219-7bd3-4ad9-a856-ac2f81e98057.xhtml), *Memory
    Management and Debugging*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: StackWalker API 是 Java 9 中引入的用于遍历调用栈的新 API。这是 `sun.reflect.Reflection.getCallerClass()`
    方法的替代品。我们将在第 12 章，*内存管理和调试*中讨论这个 API。
- en: 'Let''s run the `jdeps` on the JAR file, `sample.jar`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 JAR 文件 `sample.jar` 上运行 `jdeps`：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output we get is the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如下：
- en: '![](img/b60e2fc2-67c7-4bcf-8d66-a89bada43ac1.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b60e2fc2-67c7-4bcf-8d66-a89bada43ac1.png)'
- en: The preceding information obtained after investigating the `sample.jar` using
    `jdeps` is quite useful. It clearly states the dependencies of our JAR files and
    is very useful when we try to migrate this application to a modular application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `jdeps` 检查 `sample.jar` 后得到的信息非常有用。它清楚地说明了我们的 JAR 文件的依赖关系，当我们尝试将此应用程序迁移到模块化应用程序时非常有用。
- en: 'Let''s find if there are any dependencies to a given package name:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查找是否有对给定包名的依赖关系：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/447a9356-a643-4601-bd92-8a274416237a.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/447a9356-a643-4601-bd92-8a274416237a.png)'
- en: 'The `-p` option is used to find dependencies on the given package name. So,
    we get to know that our code depends on the `java.util` package. Let''s try with
    some other package name:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`选项用于查找给定包名的依赖。因此，我们得知我们的代码依赖于`java.util`包。让我们尝试使用其他包名：'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is no output, which means that our code doesn't depend on the `java.util.concurrent`
    package.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输出，这意味着我们的代码不依赖于`java.util.concurrent`包。
- en: 'We would want to run the dependency check only for our code. Yes, this is possible.
    Suppose we run `jdeps -cp lib/* sample.jar`, you will see even the library JARs
    being analyzed. We wouldn''t want that, right? Let''s just include the classes
    of the `com.packt` package:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只想为我们的代码运行依赖性检查。是的，这是可能的。假设我们运行`jdeps -cp lib/* sample.jar`，你会看到甚至库JAR文件也被分析了。我们不想这样，对吧？让我们只包含`com.packt`包的类：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c8431335-f5b2-41ea-b850-f08cdd1e2994.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8431335-f5b2-41ea-b850-f08cdd1e2994.png)'
- en: 'Let''s check whether our code is dependent on a specific package:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查我们的代码是否依赖于特定的包：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/6c967f34-94fb-4550-b88f-8576d8d48846.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c967f34-94fb-4550-b88f-8576d8d48846.png)'
- en: 'We can use `jdeps` on analyzing the JDK modules. Let''s pick the `java.httpclient`
    module for analysis:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`jdeps`来分析JDK模块。让我们选择`java.httpclient`模块进行分析：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '![](img/1cc0e943-a761-4690-befb-24426ef45fb6.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cc0e943-a761-4690-befb-24426ef45fb6.png)'
- en: 'We can also find whether a given module is dependent on another module by using
    the `--require` option, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`--require`选项来查找给定模块是否依赖于另一个模块，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '![](img/a8a641e8-d651-4838-9303-c697f5e10bcd.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8a641e8-d651-4838-9303-c697f5e10bcd.png)'
- en: In the preceding command, we tried to find out whether the `java.sql` module
    is dependent on the `java.logging` module. The output we get is the dependency
    summary of the `java.sql` module and the packages in the `java.sql` module, which
    make use of the code from the `java.logging` module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们试图找出`java.sql`模块是否依赖于`java.logging`模块。我们得到的输出是`java.sql`模块及其使用`java.logging`模块代码的包的依赖摘要。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `jdeps` command is a static class dependency analyzer and is used to analyze
    the static dependencies of the application and its libraries. The `jdeps` command by
    default shows the package-level dependencies of the input files, which can be
    `.class` files, a directory, or a JAR file. This is configurable and can be changed
    to show class-level dependencies. There are multiple options available to filter
    out the dependencies and to specify the class files to be analyzed. We have seen
    a regular use of the `-cp` command-line option. This option is used to provide
    the locations to search for the analyzed code's dependencies.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdeps`命令是一个静态类依赖分析器，用于分析应用程序及其库的静态依赖。默认情况下，`jdeps`命令显示输入文件的包级别依赖，这些可以是`.class`文件、目录或JAR文件。这是可配置的，可以更改以显示类级别依赖。有多个选项可用于过滤依赖并指定要分析的类文件。我们已经看到了`-cp`命令行选项的常规使用。此选项用于提供搜索分析代码依赖的位置。'
- en: 'We have analyzed the class file, JAR files, and the JDK modules, and we also
    tried out different options of the `jdeps` command. There are a few options, such
    as `-e`, `-regex`, `--regex`, `-f`, `--filter`, and `-include`, which accept a
    regular expression (regex). It''s important to understand the output of the `jdeps`
    command. There are two parts of information for every class/JAR file being analyzed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分析了类文件、JAR文件和JDK模块，我们还尝试了`jdeps`命令的不同选项。有几个选项，如`-e`、`-regex`、`--regex`、`-f`、`--filter`和`-include`，它们接受正则表达式（regex）。理解`jdeps`命令的输出是很重要的。对于每个正在分析的类/JAR文件，有两部分信息：
- en: 'The summary of the dependency for the analyzed file (JAR or class file). This
    consists of the name of the class or the JAR file on the left and the name of
    the dependent entity on the right. The dependent entity can be a directory, a
    JAR file, or a JDK module, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析文件的依赖摘要（JAR或类文件）。这包括左侧的类或JAR文件名称和右侧的依赖实体名称。依赖实体可以是目录、JAR文件或JDK模块，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A more verbose dependency information of the contents of the analyzed file
    at the package or class level ( depending on the command-line options). This consists
    of three columns: column 1 contains the name of the package/class, column 2 contains
    the name of the dependent package, and column 3 contains the name of the module/JAR
    where the dependency is found. A sample output looks like the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包或类级别（根据命令行选项）上，对分析文件内容的更详细依赖信息（取决于命令行选项）。这由三列组成：第1列包含包/类的名称，第2列包含依赖包的名称，第3列包含找到依赖项的模块/JAR的名称。一个示例输出如下：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We have seen quite a few options of the `jdeps` command. There are a few more
    related to filtering the dependencies and filtering the classes to be analyzed.
    Apart from that, there are a few options that deal with module paths.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`jdeps`命令的许多选项。还有一些与过滤依赖项和过滤要分析的类相关的选项。除此之外，还有一些与模块路径相关的选项。
- en: 'The following are the options that can be tried out:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以尝试的选项：
- en: '`-e`, `-regex`, `--regex`: These find dependencies matching the given pattern.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`, `-regex`, `--regex`：这些查找与给定模式匹配的依赖项。'
- en: '`-f`, `-filter`: These exclude dependencies matching the given pattern.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`, `-filter`：这些排除与给定模式匹配的依赖项。'
- en: '`-filter:none`: This allows no filtering applied via `filter:package` or `filter:archive`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-filter:none`：这允许不通过`filter:package`或`filter:archive`应用过滤。'
- en: '`-filter:package`: This excludes dependencies within the same package. This
    is the default option. For example, if we added `-filter:none` to `jdeps sample.jar`,
    it would print the dependency of the package to itself.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-filter:package`：这排除同一包内的依赖项。这是默认选项。例如，如果我们向`jdeps sample.jar`添加了`-filter:none`，它将打印出包对自己的依赖项。'
- en: '`-filter:archive`: This excludes dependencies within the same archive.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-filter:archive`：这排除同一存档内的依赖项。'
- en: '`-filter:module`: This excludes dependencies in the same module.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-filter:module`：这排除同一模块中的依赖项。'
- en: '`-P`, `-profile`: This is used to show the profile of the package, whether
    it is in compact1, compact2, compact3, or Full JRE.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P`, `-profile`：这用于显示包的配置文件，无论是compact1、compact2、compact3还是Full JRE。'
- en: '`-R`, `-recursive`: These recursively traverse all the runtime dependencies;
    they are equivalent to the `-filter:none` option.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-R`, `-recursive`：这些递归遍历所有运行时依赖项；它们与`-filter:none`选项等价。'
- en: Creating a simple modular application
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的模块化应用程序
- en: You should be wondering what this modularity is all about and how to create
    a modular application in Java. In this recipe, we will try to clear the mystery
    around creating modular applications in Java by walking you through a simple example.
    Our goal is to show you how to create a modular application; hence, we picked
    a simple example so as to focus on our goal.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想这个模块化是什么意思，以及如何在Java中创建一个模块化应用程序。在这个菜谱中，我们将通过一个简单的示例来帮助你解开在Java中创建模块化应用程序的神秘面纱。我们的目标是向你展示如何创建一个模块化应用程序；因此，我们选择了一个简单的例子，以便专注于我们的目标。
- en: Our example is a simple advanced calculator, which checks whether a number is
    prime, calculates the sum of prime numbers, checks whether a number is even, and
    calculates the sum of even and odd numbers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子是一个简单的先进计算器，它可以检查一个数字是否为素数，计算素数的和，检查一个数字是否为偶数，并计算偶数和奇数的和。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will divide our application into two modules:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的应用程序分为两个模块：
- en: The `math.util` module, which contains the APIs for performing the mathematical
    calculations
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math.util`模块，它包含执行数学计算的API'
- en: The `calculator` module, which launches an advanced calculator
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculator`模块，它启动一个高级计算器'
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s implement the APIs in the `com.packt.math.MathUtil` class, starting
    with the `isPrime(Integer number)` API:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`com.packt.math.MathUtil`类中实现API，从`isPrime(Integer number)` API开始：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to implement the `sumOfFirstNPrimes(Integer count)` API:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现`sumOfFirstNPrimes(Integer count)` API：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s write a function to check whether the number is even:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来检查数字是否为偶数：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The negation of `isEven` tells us whether the number is odd. We can have functions
    to find the sum of the first *N* even numbers and the first *N* odd numbers, as
    shown here:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isEven`函数的否定告诉我们数字是否为奇数。我们可以有函数来找到前*N*个偶数和前*N*个奇数的和，如下所示：'
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can see in the preceding APIs that the following operations are repeated:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在先前的API中看到以下操作是重复的：
- en: An infinite sequence of numbers starting from 1
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从1开始的无限数字序列
- en: Filtering the numbers based on some condition
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据某些条件过滤数字
- en: Limiting the stream of numbers to a given count
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制数字流到给定的数量
- en: Finding the sum of numbers thus obtained
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求得这些数字的总和
- en: 'Based on our observation, we can refactor the preceding APIs and extract these
    operations into a method, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的观察，我们可以重构前面的 API 并将这些操作提取到一个方法中，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `count` is the limit of numbers we need to find the sum of and `filter`
    is the condition for picking the numbers for summing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`count` 是我们需要找到总和的数字的限制，而 `filter` 是选择要相加的数字的条件。
- en: 'Let''s rewrite the APIs based on the refactoring we just did:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据我们刚刚做的重构重写 API：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You must be wondering about the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道以下内容：
- en: The `IntStream` class and the related chaining of the methods
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream` 类和相关的方法链'
- en: The use of `->` in the code base
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库中 `->` 的使用
- en: The use of the `IntPredicate` class
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntPredicate` 类的使用'
- en: If you are indeed wondering, then you need not worry, as we will cover these
    things in [Chapter](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml) 4, *Going Functional*
    and [Chapter](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml) 5, *Stream Operations
    and Pipelines*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实在疑惑，那么你不必担心，因为我们在第 4 章 *功能化* 和第 5 章 *流操作和管道* 中将涵盖这些内容。[Chapter](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml) 4,
    *功能化* 和 [Chapter](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml) 5, *流操作和管道*。
- en: So far, we have seen a few APIs around mathematical computations. These APIs
    are part of our `com.packt.math.MathUtil` class. The complete code for this class
    can be found at the location, `chp3/2_simple-modular-math-util/math.util/com/packt/math`,
    in the code base downloaded for this book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些数学计算的 API。这些 API 是我们 `com.packt.math.MathUtil` 类的一部分。这个类的完整代码可以在代码库中找到，位置是
    `chp3/2_simple-modular-math-util/math.util/com/packt/math`，这是为这本书下载的代码库。
- en: 'Let''s make this small utility class part of a module named `math.util`. The
    following are some conventions we use to create a module:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个小实用类模块化为一个名为 `math.util` 的模块。以下是我们创建模块时使用的某些约定：
- en: Place all the code related to the module under a directory named `math.util`
    and treat this as our module root directory.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与模块相关的所有代码放置在一个名为 `math.util` 的目录下，并将其视为我们的模块根目录。
- en: In the root folder, place a file by the name `module-info.java`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根文件夹中，放置一个名为 `module-info.java` 的文件。
- en: We then place the packages and the code files under the root directory.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将包和代码文件放置在根目录下。
- en: What does `module-info.java` contain?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`module-info.java` 包含什么内容？'
- en: The name of the module
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的名字
- en: The packages it exports, that is, makes available for other modules to use
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导出的包，即，使其可供其他模块使用
- en: The modules it depends on
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它依赖的模块
- en: The services it uses
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用的服务
- en: The service for which it provides implementation
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供的实现服务
- en: As mentioned in [Chapter 1](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml), *Installation
    and a Sneak Peek into Java 9*, the JDK comes bundled with a lot of modules, that
    is, the existing Java SDK has been modularized! One of those modules is a module
    named `java.base`. All the user-defined modules implicitly depend (or require)
    the `java.base` module (think of every class implicitly extending the `Object`
    class ).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 1 章 [Chapter 1](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml) *安装和Java 9 漫游*
    中所述，JDK 随带了许多模块，也就是说，现有的 Java SDK 已经模块化了！其中之一是一个名为 `java.base` 的模块。所有用户定义的模块都隐式依赖于（或要求）`java.base`
    模块（想想每个类都隐式扩展了 `Object` 类）。
- en: 'Our `math.util` module doesn''t depend on any other module (except, of course,
    on the `java.base` module). However, it makes its API available for other modules
    (if not, then this module''s existence is questionable). Let''s go ahead and put
    this statement into code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `math.util` 模块不依赖于任何其他模块（当然，除了 `java.base` 模块）。然而，它使它的 API 可供其他模块使用（如果不是，那么这个模块的存在就值得怀疑）。让我们继续将这个声明放入代码中：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are telling the Java compiler and runtime that our `math.util` module is
    *exporting* the code in the `com.packt.math` package to any module that depends
    on `math.util`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在告诉 Java 编译器和运行时，我们的 `math.util` 模块正在 *导出* `com.packt.math` 包中的代码到任何依赖于 `math.util`
    的模块。
- en: The code for this module can be found at the location, `chp3/2_simple-modular-math-util/math.util`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块的代码可以在位置 `chp3/2_simple-modular-math-util/math.util` 找到。
- en: 'Now, let''s create another module calculator that uses the `math.util` module.
    This module has a `Calculator` class whose work is to accept the user''s choice
    for which mathematical operation to execute and then the inputs required to execute
    the operation. The user can choose from five available mathematical operations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个名为 `calculator` 的模块，它使用 `math.util` 模块。这个模块有一个 `Calculator` 类，其工作是为用户接受要执行哪种数学运算的选择，然后接受执行该运算所需的输入。用户可以从五种可用的数学运算中选择：
- en: Prime number check
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 素数检查
- en: Even number check
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 偶数检查
- en: Sum of *N* primes
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*N* 个素数的和'
- en: Sum of *N* evens
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*N* 个偶数的和'
- en: Sum of *N* odds
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*N* 个奇数的和'
- en: 'Let''s see this in code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码示例：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, for each of the choice, we accept the required inputs and invoke the
    corresponding `MathUtil` API, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个选择，我们接受所需的输入并调用相应的 `MathUtil` API，如下所示：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The complete code for the `Calculator` class can be found at `chp3/2_simple-modular-math-util/calculator/com/packt/calculator/Calculator.java`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calculator` 类的完整代码可以在 `chp3/2_simple-modular-math-util/calculator/com/packt/calculator/Calculator.java`
    找到。'
- en: 'Let''s create the module definition for our `calculator` module in the same
    way we created for the `math.util` module:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建 `math.util` 模块相同的方式创建我们的 `calculator` 模块的模块定义：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding module definition, we mention that the `calculator` module
    depends on the `math.util` module by using the keyword, `required`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模块定义中，我们提到 `calculator` 模块通过使用关键字 `required` 依赖于 `math.util` 模块。
- en: The code for this module can be found at `chp3/2_simple-modular-math-util/calculator`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的代码可以在 `chp3/2_simple-modular-math-util/calculator` 找到。
- en: 'Let''s now compile the code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编译代码：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding command has to be executed from `chp3/2_simple-modular-math-util`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在 `chp3/2_simple-modular-math-util` 目录下执行前面的命令。
- en: Also, you should have the compiled code from across both the modules, `math.util`
    and `calculator` in the `mods` directory. Was it not quite simple? Just a single
    command and everything including the dependency between the modules is taken care
    of by the compiler. We didn't require build tools such as `ant` to manage the
    compilation of modules.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该在 `mods` 目录中拥有来自两个模块的编译代码，即 `math.util` 和 `calculator`。这难道不是很简单吗？只需一个命令，包括模块之间的依赖关系，编译器就全部处理了。我们不需要像
    `ant` 这样的构建工具来管理模块的编译。
- en: The `--module-source-path` command is the new command-line option to `javac`,
    specifying the location of our module source code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`--module-source-path` 命令是 `javac` 的新命令行选项，用于指定我们的模块源代码的位置。'
- en: 'Let''s now execute the preceding code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行前面的代码：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `--module-path` command, similar to `--classpath`, is the new command-line
    option to `java`, specifying the location of the compiled modules.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`--module-path` 命令，类似于 `--classpath`，是 `java` 的新命令行选项，用于指定编译模块的位置。'
- en: 'After running the preceding command, you will see the calculator in action:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，您将看到计算器正在运行：
- en: '![](img/e5375502-61aa-4aa0-9674-3da9489d9171.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5375502-61aa-4aa0-9674-3da9489d9171.png)'
- en: Congratulations! With this, we have a simple modular application up and running.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！有了这个，我们有一个简单的模块化应用程序正在运行。
- en: We have provided scripts to test out the code on both Windows and Linux platforms.
    Please use `run.bat` for Windows and `run.sh` for Linux.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了在 Windows 和 Linux 平台上测试代码的脚本。请使用 `run.bat` 用于 Windows 和 `run.sh` 用于 Linux。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now that you have been through the example, we will look at how to generalize
    it so that we can apply the same pattern in all our modules. We followed a particular
    convention to create the modules:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经通过了这个例子，我们将看看如何将其推广，以便我们可以在所有模块中应用相同的模式。我们遵循了特定的约定来创建模块：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We place the module-specific code within its folders with a corresponding `module-info.java`
    at the root of the folder. This way, the code is organized well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特定模块的代码放在其文件夹中，并在文件夹根目录下放置相应的 `module-info.java` 文件。这样，代码组织得很好。
- en: 'Let''s look into what `module-info.java` can contain. From the Java language
    specification ([http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html](http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html)),
    a module declaration is of the following form:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `module-info.java` 可以包含什么。根据 Java 语言规范 ([http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html](http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html))，模块声明具有以下形式：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s the syntax, explained:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是语法说明：
- en: '`{Annotation}`: This is any annotation of the form `@Annotation(2)`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{注释}`: 这是指任何形式的注释 `@注释(2)`。'
- en: '`open`: This keyword is optional. An open module makes all its components accessible
    at runtime via reflection. However, at compile time and runtime, only those components
    that are explicitly exported are accessible.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`: 这个关键字是可选的。一个开放的模块使其所有组件在运行时通过反射可访问。然而，在编译时和运行时，只有那些明确导出的组件是可访问的。'
- en: '`module`: This is keyword used to declare a module.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`: 这是用于声明模块的关键字。'
- en: '`ModuleName`: This is the name of the module that is a valid Java identifier
    with a permissible dot (`.`) between the identifier names--similar to `math.util`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleName`: 这是模块的名称，它是一个有效的Java标识符，标识符名称之间可以有允许的点（`.`）--类似于 `math.util`。'
- en: '`{ModuleStatement}`: This is a collection of the permissible statements within
    a module definition. Let''s expand this next.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ModuleStatement}`: 这是一个模块定义中允许的语句集合。让我们接下来扩展这个概念。'
- en: 'A module statement is of the following form:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模块语句的形式如下：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The module statement is decoded here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 模块语句在这里被解码：
- en: '`requires`: This is used to declare a dependency on a module. `{RequiresModifier}`
    can be **transitive**, **static**, or both. Transitive means that any module that
    depends on the given module also implicitly depends on the module that is required
    by the given module transitively. Static means that the module dependence is mandatory
    at compile time, but optional at runtime. Some examples are `requires math.util`,
    `requires transitive math.util`, and `requires static math.util`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires`: 这用于声明对模块的依赖。`{RequiresModifier}` 可以是 **transitive**、**static**
    或两者都是。传递性意味着任何依赖于给定模块的模块也隐式地依赖于给定模块所要求的模块。静态意味着模块依赖在编译时是强制性的，但在运行时是可选的。一些例子是 `requires
    math.util`、`requires transitive math.util` 和 `requires static math.util`。'
- en: '`exports`: This is used to make the given packages accessible to the dependent
    modules. Optionally, we can force the package accessibility to specific modules
    by specifying the module name, such as `exports com.package.math to claculator`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`: 这用于使给定的包对依赖模块可访问。可选地，我们可以通过指定模块名称来强制包的可访问性到特定的模块，例如 `exports com.package.math
    to claculator`。'
- en: '`opens`: This is used to open a specific package. We saw earlier that we can
    open a module by specifying the `open` keyword with the module declaration. But
    this can be less restrictive. So, to make it more restrictive, we can open a specific
    package for reflective access at runtime by using the `opens` keyword: `opens
    com.packt.math`.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opens`: 这用于打开一个特定的包。我们之前看到，我们可以通过在模块声明中使用 `open` 关键字来打开一个模块。但这可能不够严格。因此，为了使其更加严格，我们可以通过使用
    `opens` 关键字在运行时通过反射访问特定包：`opens com.packt.math`。'
- en: '`uses`: This is used to declare a dependency on a service interface that is
    accessible via `java.util.ServiceLoader`. The service interface can be in the
    current module or in any module that the current module depends on.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uses`: 这用于声明对通过 `java.util.ServiceLoader` 可访问的服务接口的依赖。服务接口可以在当前模块中，也可以在任何当前模块依赖的模块中。'
- en: '`provides`: This is used to declare a service interface and provide it with
    at least one implementation. The service interface can be declared in the current
    module or in any other dependent module. However, the service implementation must
    be provided in the same module; otherwise, a compile-time error would occur.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provides`: 这用于声明一个服务接口并提供至少一个实现。服务接口可以在当前模块中声明，也可以在任何其他依赖模块中声明。然而，服务实现必须在同一模块中提供；否则，将发生编译时错误。'
- en: We will look at the `uses` and `provides` clauses in more detail in our recipe,
    *Using services to create loose coupling between consumer and provider modules*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的配方中更详细地查看 `uses` 和 `provides` 子句，*使用服务在消费者模块和提供者模块之间创建松耦合*。
- en: The module source of all modules can be compiled at once using the `--module-source-path`
    command-line option. This way, all the modules will be compiled and placed in
    their corresponding directories under the directory provided by the `-d` option.
    For example, `javac -d mods --module-source-path . $(find . -name "*.java")`  compiles
    the code in the current directory into a `mods` directory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模块的模块源可以一次使用 `--module-source-path` 命令行选项编译。这样，所有模块都将被编译并放置在由 `-d` 选项提供的目录下的相应目录中。例如， `javac
    -d mods --module-source-path . $(find . -name "*.java")`  将当前目录中的代码编译到 `mods`
    目录中。
- en: Running the code is equally simple. We specify the path where all our modules
    are compiled into, using the command-line option, `--module-path`. Then, we mention
    the module name along with the fully qualified main class name using the command-line
    option, `-m`, for example, `java --module-path mods -m calculator/com.packt.calculator.Calculator`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码同样简单。我们使用命令行选项指定所有模块编译到的路径，即`--module-path`。然后，我们使用命令行选项`-m`提及模块名称以及完全限定主类名称，例如`java
    --module-path mods -m calculator/com.packt.calculator.Calculator`。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考信息
- en: Look at the recipe, *Compiling and running a Java application* from [Chapter
    1](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml), *Installation and a Sneak Peek
    into Java 9*, where we try out another modular application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅配方，*编译和运行Java应用程序*，来自[第1章](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml)，*安装和Java
    9的预览*，其中我们尝试运行另一个模块化应用程序。
- en: Creating a modular JAR
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块化JAR文件
- en: Compiling modules into a class is good, but it is not suitable for sharing binaries
    and deployment. JARs are better formats for sharing and deployment. We can package
    the compiled module into JARs, and the JARs that contain `module-info.class` at
    its top level are called **modular JARs**. In this recipe, we will look at how
    to create modular JARs, and we'll also look at how to execute the application,
    which is composed of multiple modular JARs
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块编译成类是好的，但并不适合共享二进制文件和部署。JAR文件是更好的共享和部署格式。我们可以将编译好的模块打包成JAR文件，其中包含顶层`module-info.class`的JAR文件被称为**模块化JAR文件**。在本配方中，我们将探讨如何创建模块化JAR文件，同时也会探讨如何执行由多个模块化JAR文件组成的应用程序。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have seen and created a simple modular application in the recipe, *Creating
    a simpler modular application*. In order to build a modular JAR, we will make
    use of the sample code available at `chp3/3_modular_jar`. This sample code contains
    two modules: `math.util` and `calculator`. We will create modular JARs for both
    the modules.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配方中看到了并创建了一个简单的模块化应用程序，*创建一个更简单的模块化应用程序*。为了构建模块化JAR文件，我们将利用在`chp3/3_modular_jar`可用的示例代码。这个示例代码包含两个模块：`math.util`和`calculator`。我们将为这两个模块创建模块化JAR文件。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Compile the code and place the compiled classes in a directory, say `mods`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并将编译后的类放置在目录中，例如`mods`：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Build a modular JAR for the `math.util` module:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`math.util`模块构建一个模块化JAR文件：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Do not forget the dot (`.`) in the end in the preceding code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在前面代码的末尾加上点（`.`）。
- en: 'Build a modular JAR for the `calculator` module, specifying the main class
    to make the JAR executable:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`calculator`模块构建一个模块化JAR文件，指定主类以使JAR文件可执行：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The critical piece in the preceding command is the `--main-class` option. This
    enables us to execute the JAR without providing the main class information during
    execution.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令中的关键部分是`--main-class`选项。这使我们能够在执行时无需提供主类信息即可执行JAR文件。
- en: 'Now we have two JARs in the `mlib` directory: `math.util@1.0.jar` and `calculator@1.0.jar`.
    These JARs are called modular JARs. If you want to run the example, you can use
    the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在`mlib`目录中有两个JAR文件：`math.util@1.0.jar`和`calculator@1.0.jar`。这些JAR文件被称为模块化JAR文件。如果您想运行示例，可以使用以下命令：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A new command-line option for the JAR command has been introduced in Java 9,
    called `-d` or  `--describe-module`. This prints the information about the module
    that the modular JAR contains:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中引入了JAR命令的新命令行选项，称为`-d`或`--describe-module`。这会打印出模块化JAR文件包含的模块信息：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of `jar -d` for `calculator@1.0.jar` is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`jar -d`对`calculator@1.0.jar`的输出如下：'
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of `jar -d` for `math.util@1.0.jar` is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`jar -d`对`math.util@1.0.jar`的输出如下：'
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have provided the following scripts to try out the recipe code on Windows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了以下脚本，以便在Windows上尝试运行配方代码：
- en: '`compile-math.bat`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile-math.bat`'
- en: '`compile-calculator.bat`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile-calculator.bat`'
- en: '`jar-math.bat`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar-math.bat`'
- en: '`jar-calculator.bat`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar-calculator.bat`'
- en: '`run.bat`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.bat`'
- en: 'We have provided the following scripts to try out the recipe code on Linux:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了以下脚本，以便在Linux上尝试运行配方代码：
- en: '`compile.sh`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile.sh`'
- en: '`jar-math.sh`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar-math.sh`'
- en: '`jar-calculator.sh`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar-calculator.sh`'
- en: '`run.sh`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.sh`'
- en: You have to run the scripts in the order they have been listed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须按照列出的顺序运行脚本。
- en: Using a module JAR with pre-JDK 9 applications
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JDK 9之前的应用程序中使用模块化JAR文件
- en: It would be amazing if our modular JARs could be run with pre-JDK 9 applications.
    This way, we will not be concerned with writing another version of our API for
    pre-JDK 9 applications. The good news is that we can use our modular JARs just
    as if they were ordinary JARs, that is, JARs without `module-info.class` at its
    root. We will see how to do so in this recipe.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的模块化 JAR 可以与 JDK 9 之前的应用程序一起运行，那将非常神奇。这样，我们就无需再为 JDK 9 之前的应用程序编写另一个版本的 API。好消息是，我们可以像使用普通
    JAR 一样使用我们的模块化 JAR，也就是说，根目录下没有 `module-info.class` 的 JAR。我们将在本食谱中看到如何做到这一点。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need a modular jar and a non-modular application.
    Our modular code can be found at `chp3/4_modular_jar_with_pre_java9/math.util` (this
    is the same `math.util` module that we created in our recipe, *Creating a simple
    modular application*). Let''s compile this modular code and create a modular JAR
    by using the following commands:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要一个模块化 JAR 和一个非模块化应用程序。我们的模块化代码可以在 `chp3/4_modular_jar_with_pre_java9/math.util`
    找到（这是我们在食谱 *创建一个简单的模块化应用程序* 中创建的同一个 `math.util` 模块）。让我们使用以下命令编译这个模块化代码并创建一个模块化
    JAR：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have also provided a `jar-math.bat` script at `chp3/4_modular_jar_with_pre_java9`,
    which can be used to create modular JARs on Windows. We have our modular JAR.
    Let''s verify by using the `-d` option of the `jar` command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `chp3/4_modular_jar_with_pre_java9` 提供了一个 `jar-math.bat` 脚本，可用于在 Windows
    上创建模块化 JAR。我们已经有了模块化 JAR。让我们使用 `jar` 命令的 `-d` 选项进行验证：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let's now create a simple application, which is non-modular. Our application
    will consist of one class named `NonModularCalculator`, which borrows its code
    from the class, `Calculator`, in the recipe *Creating a simple modular application*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的应用程序，它不是模块化的。我们的应用程序将包含一个名为 `NonModularCalculator` 的类，它从食谱 *创建一个简单的模块化应用程序*
    中的 `Calculator` 类借用代码。
- en: You can find the `NonModularCalculator` class definition in the `com.packt.calculator`
    package under the directory, `chp3/4_modular_jar_with_pre_java9/calculator`. As
    it is non-modular, it doesn't need a `module-info.java` file. This application
    makes use of our modular JAR `math.util.jar` to execute some mathematical calculations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `chp3/4_modular_jar_with_pre_java9/calculator` 目录下的 `com.packt.calculator`
    包中找到 `NonModularCalculator` 类的定义。由于它不是模块化的，它不需要 `module-info.java` 文件。此应用程序使用我们的模块化
    JAR `math.util.jar` 执行一些数学计算。
- en: 'At this point, you should have the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该有以下内容：
- en: A modular JAR named `math.util@1.0.jar`
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `math.util@1.0.jar` 的模块化 JAR
- en: A non-modular application consisting of the `NonModularCalculator` package
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `NonModularCalculator` 包组成的非模块化应用程序
- en: 'Now we need to compile our `NonModularCalculator` class:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编译我们的 `NonModularCalculator` 类：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After running the previous command, you will see a list of errors saying that
    the `com.packt.math` package doesn''t exist, the `MathUtil` symbol cannot be found, and
    so on. You guessed it right; we missed providing the location of our modular JAR
    for the compiler. Let''s add the modular jar location using the `--class-path`
    option:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上一个命令后，您将看到一系列错误，表示 `com.packt.math` 包不存在，找不到 `MathUtil` 符号等。您猜对了；我们遗漏了为编译器提供模块化
    JAR 位置。让我们使用 `--class-path` 选项添加模块化 JAR 位置：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we have successfully compiled our non-modular code, which was dependent
    on the modular JAR. Let''s run the compiled code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功编译了依赖于模块化 JAR 的非模块化代码。让我们运行编译后的代码：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Congratulations! You have successfully used your modular JAR with a non-modular
    application. Amazing, right!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经成功使用模块化 JAR 与非模块化应用程序一起使用。太神奇了，对吧！
- en: 'We have provided the following scripts at `chp3/4_modular_jar_with_pre_java9` 
    to run the code on the Windows platform:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `chp3/4_modular_jar_with_pre_java9` 提供了以下脚本，用于在 Windows 平台上运行代码：
- en: '`compile-calculator.bat`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile-calculator.bat`'
- en: '`run.bat`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.bat`'
- en: See also
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'We recommend you to try out the following recipes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您尝试以下食谱：
- en: Creating a simple modular application
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的模块化应用程序
- en: Creating a modular JAR
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模块化 JAR
- en: Bottom-up migration
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自下而上的迁移
- en: 'Now that Java 9 is out of the door, the much-awaited modularity feature is
    now available to be adopted by developers. At some point or the other, you will
    be involved in migrating your application to Java 9 and, hence, trying to modularize
    it. A change of such magnitude, which involves third-party libraries and rethinking
    of the code structure, would require proper planning and implementation. The Java
    team has suggested two migration approaches:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Java 9已经发布，备受期待的模块化特性现在可供开发者采用。在某个时候，你将参与将你的应用程序迁移到Java 9，因此尝试将其模块化。这种涉及第三方库和代码结构重新思考的重大变化需要适当的规划和实施。Java团队建议了两种迁移方法：
- en: Bottom-up migration
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自底向上迁移
- en: Top-down migration
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自顶向下迁移
- en: Before going into learning about bottom-up migration, it's important to understand
    what unnamed module and automatic module are. Suppose you are accessing a type
    not available in any of the modules; in such a case, the module system will search
    for the type on the classpath, and if found, the type becomes part of an unnamed
    module. This is similar to the classes we write that do not belong to any package,
    but Java adds them to an unnamed package so as to simplify the creation of new
    classes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习自底向上迁移之前，了解未命名模块和自动模块是什么非常重要。假设你正在访问任何模块中不可用的类型；在这种情况下，模块系统将在类路径上搜索该类型，如果找到，该类型就成为了未命名模块的一部分。这类似于我们编写的不属于任何包的类，但Java将它们添加到一个未命名的包中，以便简化新类的创建。
- en: So, an unnamed module is a catch-all module without a name, which contains all
    those types that are not part of any modules, but are found in the classpath.
    An unnamed module can access all the exported types of all the named modules (user-defined
    modules) and built-in modules (Java platform modules). On the other hand, a named
    module (user-defined module) will not be able to access the types in the unnamed
    module. In other words, a named module cannot declare dependency on an unnamed
    module. If at all you want to declare dependency, how would you do that? An unnamed
    module doesn't have a name!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，未命名模块是一个没有名称的通用模块，它包含所有不属于任何模块但在类路径中找到的类型。未命名模块可以访问所有命名模块（用户定义模块）和内置模块（Java平台模块）导出的类型。另一方面，命名模块（用户定义模块）将无法访问未命名模块中的类型。换句话说，命名模块不能声明对未命名模块的依赖。如果你确实想声明依赖关系，你将如何做？未命名模块没有名称！
- en: With the concept of unnamed modules, you can take your Java 8 application as
    is and run it on Java 9 (except for any deprecated internal APIs, which might
    not be available for user code in Java 9).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未命名模块的概念，你可以直接将你的Java 8应用程序运行在Java 9上（除了任何已弃用的内部API，这些API在Java 9中可能对用户代码不可用）。
- en: You may have seen this if you have tried out the *Using jdeps to find dependencies
    in a Java application* recipe, where we had a non-modular application and were
    able to run it on Java 9\. However, running as is on Java 9 would defeat the purpose
    of introducing the modular system.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试过*使用jdeps在Java应用程序中查找依赖关系*的配方，你可能见过这种情况，其中我们有一个非模块化应用程序，并且能够在Java 9上运行它。然而，直接在Java
    9上运行将违背引入模块化系统的目的。
- en: If a package is defined in both named and unnamed modules, the one in the named
    module would be given preference over the one in the unnamed module. This helps
    in preventing conflict of packages when they come from both named and unnamed
    modules.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包在命名和未命名模块中都有定义，那么在命名模块中的包将优先于在未命名模块中的包。这有助于防止来自命名和未命名模块的包之间的冲突。
- en: Automatic modules are those that are automatically created by the JVM. These
    modules are created when we introduce the classes packaged in JARs in the module
    path instead of the classpath. The name of this module will be derived from the
    name of the JAR without the `.jar` extension and, hence, is different from unnamed
    modules. Alternatively, one can provide the name for these automatic modules by
    providing the module name against `Automatic-Module-Name` in the JAR manifest
    file. These automatic modules export all the packages present in it and also depend
    on all the automatic and named (user/JDK) modules.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 自动模块是由JVM自动创建的。这些模块是在我们引入模块路径中打包在JAR文件中的类时创建的，而不是在类路径中。这个模块的名称将派生自没有`.jar`扩展名的JAR文件名，因此与未命名模块不同。或者，可以通过在JAR清单文件中提供`Automatic-Module-Name`来为这些自动模块提供名称。这些自动模块导出其包含的所有包，并且依赖于所有自动和命名的（用户/JDK）模块。
- en: 'Based on this explanation, modules can be classified into the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个解释，模块可以分为以下几类：
- en: '**Unnamed modules**: The code available on classpath and not available on the
    module path is placed in an unnamed module'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未命名模块**：位于类路径上但不在模块路径上的代码被放置在未命名模块中'
- en: '**Named modules**: all those modules which have a name associated with it -
    this can be user defined modules and JDK modules.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名模块**：所有与名称相关联的模块——这可以是用户定义的模块和JDK模块。'
- en: '**Automatic modules**: all those modules which are implicitly created by JVM
    based on the jar files present in the module path'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动模块**：所有由JVM根据模块路径中存在的jar文件隐式创建的模块'
- en: '**Implicit modules**: modules which are implicitly created. They are same as
    automatic modules'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式模块**：隐式创建的模块。它们与自动模块相同'
- en: '**Explicit modules**: all modules which are created explicitly by user or JDK.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式模块**：所有由用户或JDK显式创建的模块。'
- en: But the unnamed module and automatic module are a good first step to start your
    migration. So let's get started!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 但未命名模块和自动模块是开始迁移的良好第一步。所以让我们开始吧！
- en: Getting ready
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need a non-modular application which we will eventually modularize. We have
    already created a simple application whose source code is available at the location
    `chp3/6_bottom_up_migration_before`. This simple application has 3 parts to it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个非模块化应用程序，我们最终将对其进行模块化。我们已创建了一个简单的应用程序，其源代码位于位置`chp3/6_bottom_up_migration_before`。这个简单应用程序有3个部分：
- en: 'A math utility library which contains our favorite mathematical APIs namely:
    prime checker, even number checker, sum of primes, sum of evens and sum of odds.
    The code for this is available at the location `chp3/6_bottom_up_migration_before/math_util`.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含我们最喜欢的数学API的数学实用程序库，即：素数检查器、偶数检查器、素数之和、偶数之和和奇数之和。此代码位于位置`chp3/6_bottom_up_migration_before/math_util`。
- en: A banking utility library which contains API to compute simple interest and
    compound interest. The code for this is available at the location `chp3/6_bottom_up_migration_before/banking_util`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含计算简单利息和复利API的银行实用程序库。此代码位于位置`chp3/6_bottom_up_migration_before/banking_util`。
- en: Our calculator app which helps us with our mathematical and banking calculations.
    To make this more interesting we will output the results in JSON and for this,
    we will make use of Jackson JSON API. The code for this is available at the location `chp3/6_bottom_up_migration_before/calculator`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的计算器应用程序，它帮助我们进行数学和银行计算。为了使它更有趣，我们将结果输出为JSON，为此，我们将使用Jackson JSON API。此代码位于位置`chp3/6_bottom_up_migration_before/calculator`。
- en: 'After you have copied or downloaded the code, we will compile and build respective
    jars. So use the following commands to compile and build jars:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在您复制或下载代码后，我们将编译和构建相应的jar文件。因此，请使用以下命令编译和构建jar文件：
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let's also create a JAR for this (we make use of the JAR to build the dependency
    graph but not for running the app)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也为这个创建一个JAR（我们使用JAR来构建依赖图，但不是为了运行应用程序）
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Please note that our Jackson JARs are in the calculator/lib so you need not
    worry about downloading them. Let''s run our calculator using the command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的Jackson JAR位于`calculator/lib`中，因此您无需担心下载它们。让我们使用以下命令运行我们的计算器：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You will see a menu asking for the choice of operation and then you can play
    around with different operations. Let's now modularize this application!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个菜单，询问操作选择，然后您可以尝试不同的操作。现在让我们对这个应用程序进行模块化！
- en: We have provided `package-*.bat` and run.bat to package and run the application
    on Windows. And `package-*.sh` and `run.sh` to package and run the application
    on Linux.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已提供`package-*.bat`和run.bat在Windows上打包和运行应用程序。以及`package-*.sh`和`run.sh`在Linux上打包和运行应用程序。
- en: How to do it...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first step in modularizing your application is to understand its dependency
    graph. Let''s create a dependency graph for our application. And for that, we
    make use of `jdeps` tool. If you are wondering what `jdeps` tool is, stop right
    away and read the recipe: *Using jdeps to find dependencies in a Java application*.
    OK so let''s run the `jdeps` tool:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的应用程序模块化的第一步是理解其依赖图。让我们为我们的应用程序创建一个依赖图。为此，我们使用`jdeps`工具。如果您想知道`jdeps`工具是什么，请立即停止并阅读配方：*使用jdeps在Java应用程序中查找依赖关系*。好的，那么让我们运行`jdeps`工具：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We are asking `jdeps` to give us a summary of the dependencies of our `calculator.jar`
    and then do this recursively for each dependency of `calculator.jar`. And the
    output we get is:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求`jdeps`为我们提供`calculator.jar`的依赖关系摘要，然后对`calculator.jar`的每个依赖项递归地执行此操作。我们得到的结果是：
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding output is not clear, hence we have put the same diagrammatically
    as shown which is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出不是很清晰，因此我们以图示的形式再次展示，如下所示：
- en: '![](img/1b8dc10e-8e36-4770-9d4d-d19a518440f3.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b8dc10e-8e36-4770-9d4d-d19a518440f3.png)'
- en: In bottom-up migration, we start with modularizing the leaf nodes. In our graph
    the leaf nodes namely `java.xml`, `java.sql`, `java.base` and `java.logging` are
    already modularized. Let's pick to modularize `banking.util.jar`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在自下而上的迁移中，我们从模块化叶节点开始。在我们的图中，叶节点`java.xml`、`java.sql`、`java.base`和`java.logging`已经进行了模块化。让我们选择模块化`banking.util.jar`。
- en: All the code for this recipe is available at the location `chp3/6_bottom_up_migration_after`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的所有代码都可在位置`chp3/6_bottom_up_migration_after`找到。
- en: Modularizing banking.util.jar
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化`banking.util.jar`
- en: 'Copy `BankUtil.java` from `chp3/6_bottom_up_migration_before/banking_util/src/com/packt/banking`
    to the location `chp3/6_bottom_up_migration_after/src/banking.util/com/packt/banking`.
    Two things to take a note of:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BankUtil.java`从`chp3/6_bottom_up_migration_before/banking_util/src/com/packt/banking`复制到位置`chp3/6_bottom_up_migration_after/src/banking.util/com/packt/banking`。请注意以下两点：
- en: We have renamed the folder from `banking_util` to `banking.util`. This is to
    follow the convention of placing module related code under the folder bearing
    module name.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已将文件夹从`banking_util`重命名为`banking.util`。这是为了遵循将模块相关代码放置在以模块名称命名的文件夹下的约定。
- en: We have placed the package directly under the `banking.util` folder and not
    under `src`, again this is to follow the convention. And we would be placing all
    our modules under the `src` folder.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将包直接放置在`banking.util`文件夹下，而不是在`src`文件夹下，这再次是为了遵循约定。我们还将把所有模块放置在`src`文件夹下。
- en: 'Create the module definition file `module-info.java` under `chp3/6_bottom_up_migration_after/src/banking.util` with
    the following definition:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chp3/6_bottom_up_migration_after/src/banking.util`下创建模块定义文件`module-info.java`，内容如下：
- en: '[PRE49]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'From within the folder `6_bottom_up_migration_after`, compile the java code
    of the modules by running the command:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`6_bottom_up_migration_after`文件夹内，通过运行以下命令编译模块的Java代码：
- en: '[PRE50]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You will see that the java code in the module `banking.util` is compiled into
    the mods directory.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到模块`banking.util`中的Java代码被编译到mods目录中。
- en: 'Let''s create a modular JAR for this module:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个模块创建一个模块化的JAR：
- en: '[PRE51]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you are wondering what a modular JAR is, feel free to read through the recipe,
    *Creating a modular JAR*in this chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道什么是模块化JAR，请随意阅读本章的食谱，*创建模块化JAR*。
- en: Now that we have modularized `banking.util.jar`, let's use this modular jar
    in place of the non-modular JAR used in *Getting ready* section earlier. You should
    execute the following from the `6_bottom_up_migration_before` folder because we
    haven't yet completely modularized the app.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经模块化了`banking.util.jar`，让我们使用这个模块化JAR替换之前在*准备就绪*部分使用的非模块化JAR。你应该从`6_bottom_up_migration_before`文件夹中执行以下操作，因为我们还没有完全模块化应用程序。
- en: '[PRE52]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`--add-modules` option tells the Java runtime to include the modules either
    by module name or by predefined constants namely: `ALL-MODULE-PATH`, `ALL-DEFAULT`,
    `ALL-SYSTEM`. We made use of `ALL-MODULE-PATH` to add module which is available
    on our module path'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`--add-modules`选项告诉Java运行时通过模块名称或预定义常量（例如：`ALL-MODULE-PATH`、`ALL-DEFAULT`、`ALL-SYSTEM`）来包含模块。我们使用了`ALL-MODULE-PATH`来添加位于我们的模块路径上的模块。'
- en: '`--module-path`  option tells the Java runtime the location of our modules.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`--module-path`选项告诉Java运行时我们的模块位置。'
- en: 'You will see that our calculator is running as usual. Try out simple interest
    calculation, compound interest calculation to check if the `BankUtil` class is
    found. So our dependency graph now looks like:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们的计算器仍然正常运行。尝试进行简单利息计算和复利计算，以检查是否找到了`BankUtil`类。因此，我们的依赖关系图现在看起来如下：
- en: '![](img/a6e33359-f3ec-4f7d-b1bd-cff778e74833.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6e33359-f3ec-4f7d-b1bd-cff778e74833.png)'
- en: Modularizing math.util.jar
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化`math.util.jar`
- en: Copy `MathUtil.java` from `chp3/6_bottom_up_migration_before/math_util/src/com/packt/math`
    to the location `chp3/6_bottom_up_migration_after/src/math.util/com/packt/math`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MathUtil.java`从`chp3/6_bottom_up_migration_before/math_util/src/com/packt/math`复制到位置`chp3/6_bottom_up_migration_after/src/math.util/com/packt/math`。
- en: 'Create the module definition file `module-info.java` under `chp3/6_bottom_up_migration_after/src/math.util` with
    the following definition:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chp3/6_bottom_up_migration_after/src/math.util`下创建模块定义文件`module-info.java`，内容如下：
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'From within the folder `6_bottom_up_migration_after`, compile the Java code
    of the modules by running the command:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `6_bottom_up_migration_after` 文件夹内，通过运行以下命令编译模块的Java代码：
- en: '[PRE54]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You will see that the Java code in the module `math.util` and `banking.util`
    is compiled into the `mods` directory.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到模块 `math.util` 和 `banking.util` 中的Java代码被编译到了 `mods` 目录。
- en: 'Let''s create a modular JAR for this module:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个模块创建一个模块化JAR：
- en: '[PRE55]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you are wondering what a modular jar is, feel free to read through the recipe,
    *Creating a modular JAR* in this chapter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道什么是模块化JAR，请随意阅读本章中的配方，*创建一个模块化JAR*。
- en: 'Now that we have modularized `math.util.jar`, let''s use this modular jar in
    place of the non-modular jar used in *Getting ready* section earlier. You should
    execute the below from the `6_bottom_up_migration_before` folder because we haven''t
    yet completely modularized the app:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经模块化了 `math.util.jar`，让我们使用这个模块化JAR替换之前在 *准备就绪* 部分中使用的非模块化JAR。你应该从 `6_bottom_up_migration_before`
    文件夹中执行以下操作，因为我们还没有完全模块化应用程序：
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This time as well our app is running fine. And the dependency graph looks like:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们的应用程序运行良好。依赖关系图看起来像：
- en: '![](img/171013b6-8812-4c30-b072-dfa719db87e4.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/171013b6-8812-4c30-b072-dfa719db87e4.png)'
- en: We cannot modularize calculator.jar because it depends on one another non-modular
    code jackson-databind. And we cannot modularize `jackson-databind` as it is not
    maintained by us. So we cannot achieve 100% modularity for our application. We
    introduced you to Unnamed modules at the beginning of this recipe. All our non-modular
    code in the classpath are grouped in unnamed modules which means all jackson related
    code can still remain in the unnamed module and we can try to modularize `calculator.jar`. But we
    cannot do so because `calculator.jar` cannot declare dependency on `jackson-databind-2.8.4.jar`
    (because it is an unnamed module and named modules cannot declare dependency on
    unnamed modules).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能模块化 calculator.jar，因为它依赖于彼此的非模块化代码 jackson-databind。而且我们不能模块化 `jackson-databind`，因为它不是由我们维护的。因此，我们无法实现应用程序的100%模块化。我们在本配方开头介绍了未命名的模块。所有我们的非模块化代码都在类路径中的未命名模块中分组，这意味着所有与jackson相关的代码仍然可以保留在未命名模块中，我们可以尝试模块化
    `calculator.jar`。但是，我们不能这样做，因为 `calculator.jar` 不能声明对 `jackson-databind-2.8.4.jar`
    的依赖（因为它是一个未命名的模块，而命名模块不能声明对未命名模块的依赖）。
- en: 'A way to get around this is to make the jackson related code as automatic modules.
    We can do this by moving the jars related to jackson namely:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将与jackson相关的代码作为自动模块。我们可以通过移动与jackson相关的JAR文件来实现，即：
- en: '`jackson-databind-2.8.4.jar`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jackson-databind-2.8.4.jar`'
- en: '`jackson-annotations-2.8.4.jar`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jackson-annotations-2.8.4.jar`'
- en: '`jackson-core-2.8.4.jar`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jackson-core-2.8.4.jar`'
- en: 'To our mods folder under the folder `6_bottom_up_migration_after` using the
    following commands:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将其移动到 `6_bottom_up_migration_after` 文件夹下的 `mods` 文件夹，使用以下命令：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The reason for renaming the jars is that the name of the module has to be a
    valid identifier (should not be only numeric, should not contain `-` and other
    rules) separated with `.` and as the names are derived from the name of the JAR
    files, we had to rename the JAR files to conform to Java identifier rules.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名JAR的原因是模块的名称必须是一个有效的标识符（不应仅由数字组成，不应包含 `-` 和其他规则），并且用 `.` 分隔，由于名称是从JAR文件名派生的，因此我们必须重命名JAR文件以符合Java标识符规则。
- en: Create a new `mlib` directory if it is not present under `6_bottom_up_migration_after`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `6_bottom_up_migration_after` 下不存在，创建一个新的 `mlib` 目录。
- en: 'Let''s now run our calculator program again using the command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次使用命令运行我们的计算器程序：
- en: '[PRE58]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The application will run as usual. You will notice that our `-cp` option value
    is getting smaller as all the dependent libraries have been moved as modules in
    the module path. The dependency graph now looks like:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将像往常一样运行。你会注意到我们的 `-cp` 选项值正在变小，因为所有依赖库都已作为模块移动到模块路径。依赖关系图现在看起来像：
- en: '![](img/ea7cc038-75e9-4a7e-b9c4-8c44c61a4367.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea7cc038-75e9-4a7e-b9c4-8c44c61a4367.png)'
- en: Modularizing calculator.jar
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化 calculator.jar
- en: 'The last step in the migration is to modularize `calculator.jar`. Follow the
    below steps to modularize it:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的最后一步是模块化 `calculator.jar`。按照以下步骤进行模块化：
- en: Copy the folder `com` from `chp3/6_bottom_up_migration_before/calculator/src`
    to the location `chp3/6_bottom_up_migration_after/src/calculator`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `chp3/6_bottom_up_migration_before/calculator/src` 下的 `com` 文件夹复制到 `chp3/6_bottom_up_migration_after/src/calculator`
    位置。
- en: 'Create the module definition file `module-info.java` under `chp3/6_bottom_up_migration_after/src/calculator` with
    the following definition:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `chp3/6_bottom_up_migration_after/src/calculator` 下创建模块定义文件 `module-info.java`，内容如下：
- en: '[PRE59]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'From within the folder `6_bottom_up_migration_after`, compile the Java code
    of the modules by running the command:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹`6_bottom_up_migration_after`内部，通过运行以下命令编译模块的Java代码：
- en: '[PRE60]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You will see that the Java code in all our modules is compiled into the mods
    directory. Please note that you should have the automatic modules (that is, jackson
    related JARs) already placed  in `mlib` directory.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到我们所有模块的Java代码都被编译到了`mods`目录中。请注意，您应该已经将自动模块（即与jackson相关的JAR文件）放置在`mlib`目录中。
- en: 'Let''s create a modular JAR for this module and also mention which is the `main`
    class:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个模块创建一个模块化JAR，并说明哪个是`main`类：
- en: '[PRE61]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we have a modular JAR for our calculator module which is our main module
    as it contains the `main` class. With this, we have also modularized our complete
    application. Let''s run the following command from the folder: `6_bottom_up_migration_after`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为我们的计算器模块创建了一个模块化JAR，这是我们的主模块，因为它包含了`main`类。有了这个，我们也已经模块化了我们的完整应用程序。让我们从文件夹`6_bottom_up_migration_after`中运行以下命令：
- en: '[PRE62]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So we have seen how we modularized a non-modular application using a bottom-up
    migration approach. The final dependency graph looks something like:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何使用自下而上的迁移方法对非模块化应用程序进行模块化。最终的依赖图看起来大致如下：
- en: '![](img/d2bbb80a-6a7b-477f-aa43-0a7dc543480d.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2bbb80a-6a7b-477f-aa43-0a7dc543480d.png)'
- en: The final code for this modular application can be found in the location: `chp3/6_bottom_up_migration_after`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块化应用程序的最终代码可以在以下位置找到：`chp3/6_bottom_up_migration_after`。
- en: We could have done modification in line that is, modularize the code in the
    same directory `6_bottom_up_migration_before`. But we prefer to do it separately
    in a different directory `6_bottom_up_migration_after` so as to keep it clean
    and not disturb the existing code base.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在同一目录`6_bottom_up_migration_before`中对代码进行修改，即模块化该目录中的代码。但我们更倾向于在不同的目录`6_bottom_up_migration_after`中单独进行，以保持其整洁，并避免干扰现有的代码库。
- en: How it works...
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The concept of unnamed modules helped us to run our non-modular application
    on Java 9\. The use of both module path and classpath helped us to run the partly
    modular application while we were doing the migration. We started with modularizing
    those code base which were not dependent on any non-modular code. And any code
    base which we couldn't modularize, we converted them into automatic modules. And
    thereby enabling us to modularize the code which was dependent on such code base.
    Eventually, we ended up with a completely modular application.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名模块的概念帮助我们能够在Java 9上运行我们的非模块化应用程序。同时使用模块路径和类路径帮助我们迁移时运行部分模块化应用程序。我们首先对那些不依赖于任何非模块化代码的代码库进行模块化。而对于我们无法模块化的代码库，我们将它们转换为自动模块。从而使得我们能够模块化依赖于这些代码库的代码。最终，我们得到了一个完全模块化的应用程序。
- en: Top-down migration
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自上而下迁移
- en: The other technique for migration is the top-down migration. In this approach,
    we start with the root JAR in the dependency graph of the JARs.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的另一种技术是自上而下的迁移。在这种方法中，我们从依赖图中JAR文件的根JAR开始。
- en: JARs indicate a code base. We have assumed that the code base is available in
    the form of JARs and hence the dependency graph which we get has nodes which are
    JARs.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: JAR表示一个代码库。我们假设代码库以JAR文件的形式提供，因此我们得到的依赖图具有节点，这些节点是JAR文件。
- en: 'Modularizing the root of the dependency graph would mean that all other JARs
    on which this root depends have to be modular. Otherwise, this modular root cannot
    declare a dependency on unnamed modules. Let''s consider the example non-modular
    application we introduced in our previous recipe. The dependency graph looks something
    like:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖图根部的模块化意味着所有依赖于这个根部的其他JAR文件也必须进行模块化。否则，这个模块化根无法声明对未命名的模块的依赖。让我们考虑我们在之前的菜谱中引入的示例非模块化应用程序。依赖图看起来大致如下：
- en: '![](img/27abb22e-5ff1-4ecb-b9ad-5320522b7106.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27abb22e-5ff1-4ecb-b9ad-5320522b7106.png)'
- en: We extensively make use of automatic modules in top-down migration. Automatic
    modules are those modules which are implicitly created by the JVM. These are created
    based on the non-modular JARs available in the module path.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在自上而下的迁移中，我们广泛地使用了自动模块。自动模块是JVM隐式创建的模块。这些模块基于模块路径中可用的非模块化JAR文件创建。
- en: Getting ready
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will make use of the calculator example which we introduced in the previous
    recipe *Bottom-up migration*. Go ahead and copy the non-modular code from the
    location: `chp3/7_top_down_migration_before`. Use the following commands if you
    wish to run it and see if it''s working:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前在*自下而上迁移*菜谱中介绍的计算器示例。请继续复制来自以下位置的代码：`chp3/7_top_down_migration_before`。如果您想运行它并查看是否正常工作，请使用以下命令：
- en: '[PRE63]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We have provided `package-*.bat` and `run.bat` to package and run the code on
    Windows. And `package-*.sh` and `run.sh` to package and run the code on Linux.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了`package-*.bat`和`run.bat`来在Windows上打包和运行代码。以及`package-*.sh`和`run.sh`来在Linux上打包和运行代码。
- en: How to do it...
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will be modularizing the application under the directory `chp3/7_top_down_migration_after`.
    Create two directories `src` and `mlib` under `chp3/7_top_down_migration_after`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`chp3/7_top_down_migration_after`目录下对应用程序进行模块化。在`chp3/7_top_down_migration_after`下创建两个目录`src`和`mlib`。
- en: Modularizing the calculator
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化计算器：
- en: 'We cannot modularize the calculator until we have modularized all its dependencies.
    But modularizing its dependencies might be easier at times and not so at other
    times especially in cases where the dependency is from a third party. In such
    scenarios, we make use of automatic modules. We copy the non-modular JARs under
    the folder `mlib` and ensuring the name of the JAR is of the form `<identifier>(.<identifier>)*`
    where `<identifier>` is a valid Java identifier:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们没有对计算器的所有依赖项进行模块化之前，我们无法对计算器进行模块化。但有时对依赖项进行模块化可能更容易，有时则不然，尤其是在依赖项来自第三方的情况下。在这种情况下，我们使用自动模块。我们将非模块化JAR文件复制到`mlib`文件夹下，并确保JAR文件名为`<identifier>(.<identifier>)*`的形式，其中`<identifier>`是一个有效的Java标识符：
- en: '[PRE64]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have provided script `copy-non-mod-jar.bat` and `copy-non-mod-jar.sh` to
    copy the jars easily.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了脚本`copy-non-mod-jar.bat`和`copy-non-mod-jar.sh`，以便轻松复制JAR文件。
- en: 'Let''s see what all we copied into `mlib`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们复制到`mlib`中的所有内容：
- en: '[PRE65]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `banking.util.jar` and `math.util.jar` will exist only if you have compiled
    and JAR'd the code in the `chp3/7_top_down_migration_before/banking_util` and
    `chp3/7_top_down_migration_before/math_util` directories. We did this in the *Getting
    ready*section earlier.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您已经编译并将`chp3/7_top_down_migration_before/banking_util`和`chp3/7_top_down_migration_before/math_util`目录中的代码打包成JAR文件后，`banking.util.jar`和`math.util.jar`才会存在。我们之前在*准备就绪*部分已经这样做过了。
- en: Create a new folder `calculator` under `src`. This will contain the code for
    the `calculator` module.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`目录下创建一个新的文件夹`calculator`。这个文件夹将包含`calculator`模块的代码。
- en: Create `module-info.java` under the `chp3/7_top_down_migration_after/src/calculator`
    directory that contains the following**:**
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chp3/7_top_down_migration_after/src/calculator`目录下创建`module-info.java`文件，其中包含以下内容**：
- en: '[PRE66]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Copy the directory `chp3/7_top_down_migration_before/calculator/src/com` and
    all the code under it to `chp3/7_top_down_migration_after/src/calculator`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chp3/7_top_down_migration_before/calculator/src/com`目录及其所有代码复制到`chp3/7_top_down_migration_after/src/calculator`。
- en: 'Compile the calculator module:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译计算器模块：
- en: '[PRE67]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the modular JAR for `calculator` module:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`calculator`模块创建模块化JAR文件：
- en: '[PRE68]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Run the `calculator` module :'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`calculator`模块：
- en: '[PRE69]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We will see that our calculator is executing correctly. You can try out different
    operations to verify if all of them are executing correctly.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到我们的计算器正在正确执行。您可以尝试不同的操作来验证是否所有操作都正确执行。
- en: Modularizing banking.util
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化`banking.util`：
- en: 'As this doesn''t depend on other non-module code we can directly convert this
    into a module by following the steps:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不依赖于其他非模块化代码，我们可以通过遵循以下步骤直接将其转换为模块：
- en: Create a new folder `banking.util` under `src`. This will contain the code for
    `banking.util` module.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`目录下创建一个新的文件夹`banking.util`。这个文件夹将包含`banking.util`模块的代码。
- en: Create `module-info.java` under the directory `chp3/7_top_down_migration_after/src/banking.util`which
    contains the following**:**
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chp3/7_top_down_migration_after/src/banking.util`目录下创建`module-info.java`文件，其中包含以下内容**：
- en: '[PRE70]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Copy the directory `chp3/7_top_down_migration_before/banking_util/src/com` and
    all the code under it to `chp3/7_top_down_migration_after/src/banking.util`.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chp3/7_top_down_migration_before/banking_util/src/com`目录及其所有代码复制到`chp3/7_top_down_migration_after/src/banking.util`。
- en: 'Compile the modules:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模块：
- en: '[PRE71]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create modular JAR for `banking.util` module. This will replace the non-modular
    `banking.util.jar` already present in `mlib`:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`banking.util`模块创建模块化JAR文件。这将替换`mlib`中已存在的非模块化`banking.util.jar`：
- en: '[PRE72]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run the `calculator` module to test if the `banking.util` modular JAR has been
    created successfully:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`calculator`模块以测试是否已成功创建`banking.util`模块化JAR文件：
- en: '[PRE73]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You should see the calculator getting executed. Play around with different operations
    to ensure there is no class not found issues.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到计算器正在执行。尝试不同的操作以确保没有找不到类的错误。
- en: Modularizing math.util
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化`math.util`
- en: Create a new folder `math.util` under `src`. This will contain the code for
    `math.util` module.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`下创建一个新的文件夹`math.util`。这将包含`math.util`模块的代码。
- en: Create `module-info.java` under the directory `chp3/7_top_down_migration_after/src/math.util`which
    contains the following**:**
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chp3/7_top_down_migration_after/src/math.util`目录下创建`module-info.java`，其中包含以下内容**：
- en: '[PRE74]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Copy the directory `chp3/7_top_down_migration_before/math_util/src/com` and
    all the code under it to `chp3/7_top_down_migration_after/src/math.util`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chp3/7_top_down_migration_before/math_util/src/com`目录及其下的所有代码复制到`chp3/7_top_down_migration_after/src/math.util`。
- en: 'Compile the modules:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模块：
- en: '[PRE75]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create modular JAR for `banking.util` module. This will replace the non-modular
    `banking.util.jar` already present in `mlib`:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`banking.util`模块创建模块化JAR。这将替换`mlib`中已经存在的非模块化`banking.util.jar`：
- en: '[PRE76]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Run the `calculator` module to test if the `math.util` modular JAR has been
    created successfully.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`calculator`模块以测试是否已成功创建`math.util`模块的模块化JAR。
- en: '[PRE77]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You should see the calculator getting executed. Play around with different operations
    to ensure there is no class not found issues.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到计算器正在执行。尝试不同的操作以确保没有找不到类的错误。
- en: With this, we have completely modularized the application baring the Jackson
    libraries which we have converted to automatic modules.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经完全模块化了应用程序，除了我们已将其转换为自动模块的Jackson库。
- en: We would prefer the top-down approach for migration. This is because we don't
    have to deal with classpath and module-path at the same time. We can make everything
    into automatic modules and then use the module-path as we keep migrating the non-modular
    JARs into modular JARs.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更倾向于自上而下的迁移方法。这是因为我们不必同时处理类路径和模块路径。我们可以将所有内容都变成自动模块，然后在我们继续将非模块化JAR迁移到模块化JAR时使用模块路径。
- en: Using services to create loose coupling between consumer and provider modules
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务在消费者模块和提供者模块之间创建松耦合
- en: Generally, in our applications, we have some interfaces and multiple implementations
    of those interfaces. Then at runtime depending on some condition, we make use
    of some specific implementation. This principle is called **Dependency Inversion**.
    This principle is used by the dependency injection frameworks like Spring to create
    objects of concrete implementations and assign (or inject) into the references
    of type abstract interface.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在我们的应用程序中，我们有一些接口和这些接口的多个实现。然后在运行时根据某些条件，我们使用某些特定的实现。这个原则被称为**依赖倒置**。这个原则被依赖注入框架如Spring用来创建具体实现的实例并将它们（或注入）到抽象接口的引用中。
- en: Java has for long (since Java 6) supported service-provider loading facility
    via the `java.util.ServiceLoader` class. Using Service Loader you can have a **service
    provider interface** (**SPI**) and multiple implementations of the SPI simply
    called service provider. These service providers are located in the classpath
    and loaded at run time. When these service providers are located within modules
    and as we no longer depend on the classpath scanning to load the service provider,
    we need a mechanism to tell our modules about the service provider and the SPI
    for which it is providing. In this recipe, we will look at that mechanism using
    a simple example.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Java长期以来（自Java 6以来）通过`java.util.ServiceLoader`类支持服务提供者加载功能。使用服务加载器，你可以有一个**服务提供者接口**（**SPI**）和该SPI的多个实现，这些实现简单地称为服务提供者。这些服务提供者位于类路径中，并在运行时加载。当这些服务提供者位于模块内，并且我们不再依赖于类路径扫描来加载服务提供者时，我们需要一个机制来告诉我们的模块关于服务提供者和它所提供的服务SPI。在这个菜谱中，我们将通过一个简单的示例来查看这个机制。
- en: Getting ready
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: There is nothing specific we need to set up for this recipe. In this recipe,
    we will take a simple example. We have one `BookService` abstract class which
    supports CRUD operations. Now, these CRUD operations can work on a SQL DB or on
    MongoDB or on file system and so on. This flexibility can be provided by using
    service provider interface and `ServiceLoader` class to load the required service
    provider implementation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们不需要设置任何特定内容。在这个菜谱中，我们将使用一个简单的示例。我们有一个支持CRUD操作的`BookService`抽象类。现在，这些CRUD操作可以在SQL数据库、MongoDB或文件系统上工作等等。这种灵活性可以通过使用服务提供者接口和`ServiceLoader`类来加载所需的服务提供者实现来提供。
- en: How to do it...
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We have four modules in this recipe:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们有四个模块：
- en: '`book.service`: This is the module which contains our service provider interface
    that is, the service'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`book.service`: 这是一个包含我们的服务提供者接口的模块，即服务'
- en: '`mongodb.book.service`: This is one of the service provider module'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mongodb.book.service`: 这是服务提供者模块之一'
- en: '`sqldb.book.service`: This is the other service provider module'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqldb.book.service`: 这是另一个服务提供者模块'
- en: '`book.manage`: This is the service consumer module'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`book.manage`: 这是一个服务消费者模块'
- en: 'The following steps demonstrate how to make use of `ServiceLoader` to achieve
    loose coupling:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何使用`ServiceLoader`实现松耦合：
- en: Create a folder `book.service` under the directory `chp3/8_services/src`. All
    our code for `book.service` module will be under this folder.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chp3/8_services/src`目录下创建一个名为`book.service`的文件夹。我们所有关于`book.service`模块的代码都将位于这个文件夹下。
- en: 'Create a new package `com.packt.model` and a new class `Book` under the new
    package. This is our model class which contains the following properties:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新包`com.packt.model`下创建一个新类`Book`。这是我们包含以下属性的模型类：
- en: '[PRE78]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a new package `com.packt.service` and a new class `BookService` under
    the new package. This is our main service interface and the service providers
    will provide an implementation for this service. Apart from the abstract methods
    for CRUD operations, one method worth mentioning is the `getInstance()`. This
    method uses the `ServiceLoader` class to load any one service provider (the last one
    to be specific) and then use that service provider to get an implementation of
    the `BookService`. Let''s see the following code:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新包`com.packt.service`下创建一个新类`BookService`。这是我们主要的服务接口，服务提供者将为这个接口提供实现。除了CRUD操作的抽象方法外，还有一个值得注意的方法是`getInstance()`。该方法使用`ServiceLoader`类加载任何一个服务提供者（具体来说是最后一个），然后使用该服务提供者来获取`BookService`的实现。让我们看看下面的代码：
- en: '[PRE79]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The first `while` loop is just for the demonstration that the `ServiceLoader`
    loads all the service providers and we pick one of the service providers. You
    can conditionally return the service provider as well, but that all depends on
    the requirements.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`while`循环只是为了演示`ServiceLoader`加载了所有的服务提供者，我们选择了一个服务提供者。你也可以有条件地返回服务提供者，但这完全取决于需求。
- en: The other important part is the actual service provider interface. The responsibility
    of this is to return an appropriate instance of the service implementation. In
    our recipe, `BookServiceProvider` in the package `com.packt.spi` is a service
    provider interface.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个重要的部分是实际的服务提供者接口。其责任是返回适当的服务实现实例。在我们的方案中，`com.packt.spi`包中的`BookServiceProvider`是一个服务提供者接口。
- en: '[PRE80]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next is the main part which is module definition. We create `module-info.java`
    under the directory `chp3/8_services/src/book.service` which contains:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是主要部分，即模块定义。我们在`chp3/8_services/src/book.service`目录下创建`module-info.java`，它包含以下内容：
- en: '[PRE81]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `uses` statement in the preceding module definition specifies the service
    interface which the module discovers using the `ServiceLoader`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模块定义中的`uses`语句指定了模块使用`ServiceLoader`发现的服务的接口。
- en: Let's now create a service provider module called `mongodb.book.service`. This
    will provide an implementation for our `BookService` and `BookServiceProvider`
    interface in `book.service` module. Our idea is that this service provider will
    implement the CRUD operations using MongoDB datastore.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为`mongodb.book.service`的服务提供者模块。这将为我们`BookService`和`book.service`模块中的`BookServiceProvider`接口提供实现。我们的想法是，这个服务提供者将使用MongoDB数据存储实现CRUD操作。
- en: Create a folder `mongodb.book.service` under the directory `chp3/8_services/src`.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chp3/8_services/src`目录下创建一个名为`mongodb.book.service`的文件夹。
- en: Create a class `MongoDbBookService` in the package `com.packt.mongodb.service` which
    extends `BookService` abstract class and provides an implementation for our abstract
    CRUD operation methods.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.mongodb.service`包中创建一个名为`MongoDbBookService`的类，它扩展了`BookService`抽象类，并为我们的抽象CRUD操作方法提供了实现。
- en: '[PRE82]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create a class `MongoDbBookServiceProvider` in the package `com.packt.mongodb`
    which implements the `BookServiceProvider` interface. This is our service discovery,
    class. Basically, it returns a relevant instance of `BookService` implementation.
    It overrides the method in `BookServiceProvider` interface as follows:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.mongodb`包中创建一个名为`MongoDbBookServiceProvider`的类，它实现了`BookServiceProvider`接口。这是我们服务发现类。基本上，它返回一个相关的`BookService`实现实例。它覆盖了`BookServiceProvider`接口中的方法如下：
- en: '[PRE83]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The module definition is quite interesting. We have to declare in the module
    definition that this module is a service provider for the interface `BookServiceProvider`
    and that can be done as follows:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块定义非常有趣。我们必须在模块定义中声明这个模块是 `BookServiceProvider` 接口的服务提供者，并且可以如下进行：
- en: '[PRE84]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`provides .. with ..` statement is used to specify the service interface and
    one of the service provider.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `provides .. with ..` 语句来指定服务接口和其中一个服务提供者。
- en: Let's now create a service consumer module called `book.manage`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为 `book.manage` 的服务消费者模块。
- en: Create a new folder `book.manage` under `chp3/8_services/src` which will contain
    the code for the module.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `chp3/8_services/src` 下创建一个新的文件夹 `book.manage`，它将包含模块的代码。
- en: 'Create a new class called `BookManager` in package `com.packt.manage`. The
    main aim of this class is to get an instance of `BookService` and then execute
    its CRUD operations. The instance returned is decided by the service providers
    loaded by the `ServiceLoader`. The `BookManager` class looks something like:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.packt.manage` 包中创建一个新的类 `BookManager`。这个类的主要目的是获取 `BookService` 的一个实例，然后执行其
    CRUD 操作。返回的实例由 `ServiceLoader` 加载的服务提供者决定。`BookManager` 类看起来像这样：
- en: '[PRE85]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s now compile and run our main module by using the following commands:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用以下命令编译并运行我们的主模块：
- en: '[PRE86]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the preceding output, the first line says the service providers available
    and the second line says which `BookService` implementation we are using.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，第一行说明了可用的服务提供者，第二行说明了我们正在使用的 `BookService` 实现。
- en: 'With one service provider, it looks simple. Let''s go ahead and add another
    module `sqldb.book.service` whose module definition would be:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个服务提供者时看起来很简单。让我们继续添加另一个模块 `sqldb.book.service`，其模块定义如下：
- en: '[PRE87]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `SqlDbBookServiceProvider` class in the `com.packt.sqldb` package is an
    implementation of the interface `BookServiceProvider` as follows:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`com.packt.sqldb` 包中的 `SqlDbBookServiceProvider` 类是实现 `BookServiceProvider`
    接口的一个实现，如下所示：'
- en: '[PRE88]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The implementation of CRUD operations is done by the class `SqlDbBookService`
    in the package `com.packt.sqldb.service`.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRUD操作的实现由 `com.packt.sqldb.service` 包中的 `SqlDbBookService` 类完成。
- en: 'Let''s compile and run the main module, this time with two service providers:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行主模块，这次使用两个服务提供者：
- en: '[PRE89]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The first two lines print the class names of the available service providers
    and the third line prints which `BookService` implementation we are using.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行打印可用的服务提供者的类名，第三行打印我们正在使用的 `BookService` 实现。
- en: Creating a custom modular runtime image using jlink
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jlink 创建自定义模块化运行时镜像
- en: 'Java comes in two flavors:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两种风味：
- en: Java runtime only also called as JRE - this supports execution of Java applications
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 运行时，也称为 JRE - 支持Java应用程序的执行
- en: Java development kit with Java run time also called as JDK - this supports development
    and execution of Java applications.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 开发工具包，也称为 JDK - 支持Java应用程序的开发和执行。
- en: Apart from this, there were 3 compact profiles introduced in Java 8 with the
    aim of providing runtimes with a smaller footprint in order to run on embedded
    and smaller devices.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，Java 8 中还引入了 3 个紧凑配置文件，目的是为了提供具有更小内存占用量的运行时，以便在嵌入式和较小的设备上运行。
- en: '![](img/1157ca16-9696-454f-93f2-1a7f43cd9264.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1157ca16-9696-454f-93f2-1a7f43cd9264.png)'
- en: The preceding image shows the different profiles and the features supported
    by them.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了不同的配置文件及其支持的功能。
- en: A new tool called `jLink` is introduced in Java 9 which enables the creation
    of modular run time images. These run time images are nothing but a collection
    of a set of modules and their dependencies. There is a Java enhancement proposal,
    JEP 220, governing the structure of this run time image.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中引入了一个名为 `jLink` 的新工具，它使得创建模块化运行时镜像成为可能。这些运行时镜像实际上是一组模块及其依赖项的集合。有一个名为
    JEP 220 的 Java 增强提案，它规定了该运行时镜像的结构。
- en: In this recipe, we will use `jLink` to create a run time image consisting of
    our modules `math.util`, `banking.util`, and `calculator` along with the Jackson
    automatic modules.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 `jLink` 创建一个运行时镜像，该镜像包含我们的模块 `math.util`、`banking.util` 和 `calculator`
    以及 Jackson 自动模块。
- en: Getting ready
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the recipe *Creating a simple modular application* we created a simple modular
    application consisting of the following modules:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在《创建一个简单的模块化应用程序》的食谱中，我们创建了一个简单的模块化应用程序，它由以下模块组成：
- en: '`math.util`'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math.util`'
- en: '`calculator` - consists of the main class'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculator` - 包含主类'
- en: We will reuse the same set of modules and code to demonstrate the use of jLink
    tool. For the convenience of our readers the code can be found at the location: `chp3/9_jlink_modular_run_time_image`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用同一组模块和代码来演示 jLink 工具的使用。为了方便读者，代码可以在以下位置找到：`chp3/9_jlink_modular_run_time_image`。
- en: How to do it...
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s compile the modules:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译这些模块：
- en: '[PRE90]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let''s create the modular JAR for all the modules:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为所有模块创建模块化 JAR：
- en: '[PRE91]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s use `jlink` to create a run time image consisting of the modules: `calculator`,
    `math.util` and its dependencies:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `jlink` 创建包含以下模块的运行时镜像：`calculator`、`math.util` 及其依赖项：
- en: '[PRE92]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The run time image gets created at the location specified with `--output` command
    line option.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时镜像在 `--output` 命令行选项指定的位置创建。
- en: 'The run time image created under the directory image contains `bin` directory
    among other directories. This `bin` directory consists of a shell script by name
    `calculator`. This can be used to launch our application:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 image 的目录下创建的运行时镜像包含 `bin` 目录以及其他目录。这个 `bin` 目录包含一个名为 `calculator` 的 shell
    脚本。这可以用来启动我们的应用程序：
- en: '[PRE93]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We cannot create run time image of modules which contain automatic modules.
    jLink gives an error if the JAR files are not modular or if there is no `module-info.class`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能创建包含自动模块的模块的运行时镜像。如果 JAR 文件不是模块化的或没有 `module-info.class`，jLink 会报错。
- en: Compiling for older platform versions
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为旧平台版本编译
- en: We have at some point used options `-source` and `-target` to create a java
    build. The `-source` option is used to indicate the version of java language accepted
    by the compiler and the `-target` option is used to indicate the version supported
    by the class files. Often we forget to use `-source` option and by default, `javac`
    compiles against the latest available Java version and due to this there are chances
    of newer APIs being used and as a result, the resultant build doesn't run as expected
    on the target version.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在某个时候使用了 `-source` 和 `-target` 选项来创建一个 java 构建。`-source` 选项用于指示编译器接受的 java
    语言版本，而 `-target` 选项用于指示类文件支持的版本。我们经常忘记使用 `-source` 选项，并且默认情况下，`javac` 会编译最新的可用
    Java 版本，因此有可能会使用新的 API，结果导致生成的构建在目标版本上无法按预期运行。
- en: So as to overcome the confusion of providing two different command line options,
    a new command line option `--release` is introduced in Java 9\. This acts as a
    substitute to `-source`, `-target` and `-bootclasspath` options. The `-bootclasspath`
    is used to provide the location of the bootstrap class files for a given version
    *N*.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服提供两个不同命令行选项的混淆，Java 9 中引入了一个新的命令行选项 `--release`。这个选项作为 `-source`、`-target`
    和 `-bootclasspath` 选项的替代。`-bootclasspath` 选项用于提供给定版本 *N* 的引导类文件的位置。
- en: Getting ready
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'We have created a simple module called demo which contains a very simple class
    called `CollectionsDemo` which just puts a few values in the map and iterate over
    them as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 demo 的简单模块，其中包含一个非常简单的类 `CollectionsDemo`，它只是将一些值放入映射中并遍历它们，如下所示：
- en: '[PRE94]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Let''s compile and run it to see its output:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行它以查看其输出：
- en: '[PRE95]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output we get is:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出是：
- en: '[PRE96]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Let's now compile this to run on Java 8 and then run it on Java 8.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编译它以在 Java 8 上运行，然后运行它。
- en: How to do it...
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As the older version of Java that is, Java 8 and before don''t support modules,
    we would have to get rid of the `module-info.java` while compiling on an older
    version. So what we did was to not include `module-info.java` during our compilation.
    So we compiled using the following code:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于较老的 Java 版本，即 Java 8 及之前版本不支持模块，我们不得不在较老版本编译时去除 `module-info.java`。所以我们所做的是在编译过程中不包含
    `module-info.java`。因此，我们使用以下代码进行编译：
- en: '[PRE97]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You can see that we are using the `--release` option targeting Java 8 and not
    compiling the `module-info.java`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们正在使用 `--release` 选项针对 Java 8，并且没有编译 `module-info.java`。
- en: 'Let''s create a JAR file because it becomes easier to transport the java build
    instead of copying all the class files:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 JAR 文件，因为与复制所有类文件相比，它更容易传输 java 构建文件：
- en: '[PRE98]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Let''s run the preceding JAR in Java 9:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 Java 9 上运行前面的 JAR：
- en: '[PRE99]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s run the JAR in Java 8 :'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 Java 8 上运行这个 JAR：
- en: '[PRE100]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: What if we did not use the `-release` option while building on Java 9? Let's
    try that as well.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Java 9 构建时没有使用 `-release` 选项会怎样？让我们也试试这个。
- en: 'Compile without using `--release` option and create a JAR out of the resulting
    class files:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不使用 `--release` 选项进行编译，并将生成的类文件创建成 JAR：
- en: '[PRE101]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Let''s run the JAR on Java 9:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 Java 9 上运行这个 JAR：
- en: '[PRE102]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Works as expected
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 按预期工作
- en: 'Let''s run the JAR on Java 8:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 Java 8 上运行这个 JAR：
- en: '[PRE103]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output is:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE104]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: It is clearly stating that there is a mismatch in the version of the class file.
    As it was compiled for Java 9 (version 53.0), it doesn't run on Java 8 (version
    52.0)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 它明确指出类文件版本不匹配。因为它是为 Java 9（版本 53.0）编译的，所以它不能在 Java 8（版本 52.0）上运行
- en: How it works...
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The data required for compiling to a target older version is stored in the `$JDK_ROOT/lib/ct.sym`
    file. This information is used by the `--release` option to locate the `bootclasspath`. The
    `ct.sym` file is a ZIP file containing stripped-down class files corresponding
    to class files from the target platform versions (taken verbatim from [http://openjdk.java.net/jeps/247](http://openjdk.java.net/jeps/247)).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 编译到目标旧版本所需的数据存储在 `$JDK_ROOT/lib/ct.sym` 文件中。此信息由 `--release` 选项用于定位 `bootclasspath`。`ct.sym`
    文件是一个 ZIP 文件，包含与目标平台版本对应的简化后的类文件（直接引用自 [http://openjdk.java.net/jeps/247](http://openjdk.java.net/jeps/247)）。
- en: Creating multirelease JARs
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多版本 JAR
- en: Prior to Java 9, it was hard for the developers of a library to adopt the new
    features introduced in the language without releasing a new library version. But
    in Java 9 multirelease JARs provide such a functionality where you can bundle
    certain class files to run when a higher version of Java is being used.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，库的开发者很难在不发布新库版本的情况下采用语言中引入的新功能。但在 Java 9 中，多版本 JAR 提供了这样的功能，您可以将某些类文件捆绑在一起，以便在使用更高版本的
    Java 时运行。
- en: In this recipe, we will show you how to create such a multirelease JAR.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向您展示如何创建这样的多版本 JAR。
- en: How to do it...
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the required Java code for Java 8 platform. We will add two classes
    `CollectionUtil.java` and `FactoryDemo.java` in the directory `src\8\com\packt`:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Java 8 平台创建所需的 Java 代码。我们将在 `src\8\com\packt` 目录中添加两个类 `CollectionUtil.java`
    和 `FactoryDemo.java`：
- en: '[PRE105]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We wish to make use of the `Collection` factory methods introduced in Java
    9\. So what we can do is create another sub directory under `src` to place our
    Java 9 related code: `src\9\com\packt` where we will add another `CollectionUtil`
    class:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望使用 Java 9 中引入的 `Collection` 工厂方法。所以我们可以创建 `src` 下的另一个子目录来放置我们的 Java 9 相关代码：`src\9\com\packt`，我们将添加另一个
    `CollectionUtil` 类：
- en: '[PRE106]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The preceding code uses the Java 9 collection factory methods. Compile the
    source code using the following commands:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码使用了 Java 9 集合工厂方法。使用以下命令编译源代码：
- en: '[PRE107]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Make a note of the `--release` option used to compile the code for different
    java versions.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 记下用于编译不同 Java 版本代码的 `--release` 选项。
- en: 'Let''s now create the multirelease JAR:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建多版本 JAR：
- en: '[PRE108]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: While creating the JAR we have also mentioned that when running on Java 9 make
    use of the Java 9 specific code.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 JAR 文件时，我们也提到当在 Java 9 上运行时，要使用 Java 9 特定的代码。
- en: 'We will run the `mr.jar` on Java 9:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 Java 9 上运行 `mr.jar`：
- en: '[PRE109]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We will run the `mr.jar` on Java 8:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 Java 8 上运行 `mr.jar`：
- en: '[PRE110]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How it works...
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s look at the layout of the content in `mr.jar`:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `mr.jar` 中内容的布局：
- en: '[PRE111]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The contents of the JAR is as shown in the following:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: JAR 的内容如下所示：
- en: '![](img/c8a24d55-58f0-41d8-a6d8-c4b0d1d61727.png)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8a24d55-58f0-41d8-a6d8-c4b0d1d61727.png)'
- en: 'The preceding layout we have `META-INF/versions/9` which contains the Java
    9 specific code. Another important thing to note is the contents of the `META-INF/MANIFEST.MF`
    file. Let''s extract the JAR and view its contents:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的布局中包含 `META-INF/versions/9`，其中包含 Java 9 特定的代码。另一个需要注意的重要事项是 `META-INF/MANIFEST.MF`
    文件的内容。让我们提取 JAR 并查看其内容：
- en: '[PRE112]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The new manifest attribute `Multi-Release` is used to indicate if the JAR is
    a multirelease JAR or not.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 新的清单属性 `Multi-Release` 用于指示 JAR 是否为多版本 JAR。
- en: Using Maven to develop a modular application
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven 开发模块化应用程序
- en: In this recipe, we will look at using Maven, most popular build tool in Java
    ecosystem, to develop a simple modular application. We will reuse the idea we
    had introduced in the Services recipe in this chapter.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨使用 Maven，Java 生态系统中最受欢迎的构建工具，来开发一个简单的模块化应用程序。我们将在这个章节中介绍的服务菜谱中重用我们之前介绍的想法。
- en: Getting ready
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have the following modules in our example:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中有以下模块：
- en: '`book.manage`: This is the main module which interacts with the data source'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book.manage`：这是与数据源交互的主要模块'
- en: '`book.service`: This is the module which contains the service provider interface'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book.service`：这是包含服务提供者接口的模块'
- en: '`mongodb.book.service`: This is the module which provides an implementation
    to the service provider interface'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongodb.book.service`：这是提供服务提供者接口实现的模块'
- en: '`sqldb.book.service`: This is the module which provides another implementation
    to the service provider interface'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqldb.book.service`：这是提供另一个服务提供者接口实现的模块'
- en: In the course of this recipe, we will create a maven project and include the
    preceding JDK modules as maven modules. So let's get started.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱的过程中，我们将创建一个 Maven 项目，并将前面的 JDK 模块包含为 Maven 模块。那么，让我们开始吧。
- en: How to do it...
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a folder to contain all the modules. We have called it `12_services_using_maven`
    with the following folder structure:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件夹来包含所有模块。我们将其命名为 `12_services_using_maven`，其文件夹结构如下：
- en: '[PRE113]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `pom.xml` for the parent is:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父项目的 `pom.xml` 如下：
- en: '[PRE114]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Let''s create the structure for the `book-service` Maven module:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为 `book-service` Maven 模块创建结构：
- en: '[PRE115]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The content of `pom.xml` for `book-service` Maven module is:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`book-service` Maven 模块的 `pom.xml` 内容如下：'
- en: '[PRE116]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The `module-info.java` is:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`module-info.java` 的内容是：'
- en: '[PRE117]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `Book.java` is:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Book.java` 的内容是：'
- en: '[PRE118]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `BookService.java` is:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BookService.java` 的内容是：'
- en: '[PRE119]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `BookServiceProvider.java` is:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BookServiceProvider.java` 的内容是：'
- en: '[PRE120]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: On similar lines, we define other three Maven modules namely `mongodb-book-service`,
    `sqldb-book-service` and `book-manager`. The code for this can be found at the
    location `chp3/12_services_using_maven`.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 按照类似的思路，我们定义了其他三个 Maven 模块，分别是 `mongodb-book-service`、`sqldb-book-service` 和
    `book-manager`。这段代码可以在位置 `chp3/12_services_using_maven` 找到。
- en: 'We can compile the classes and build the required JAR files using the command:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令编译类和构建所需的 JAR 文件：
- en: '[PRE121]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We have provided `run-with-mongo.*` to use the `mongodb-book-service` as the
    service provider implementation and `run-with-sqldb.*` to use the `sqldb-book-service`
    as the service provider implementation.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了 `run-with-mongo.*` 来使用 `mongodb-book-service` 作为服务提供者实现，以及 `run-with-sqldb.*`
    来使用 `sqldb-book-service` 作为服务提供者实现。
- en: The complete code for this recipe can be found at `chp3/12_services_using_maven`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的完整代码可以在 `chp3/12_services_using_maven` 找到。
