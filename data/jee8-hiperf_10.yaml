- en: Continuous Performance Evaluation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续性能评估
- en: We saw in the previous chapter that driving a benchmark requires work and is
    not a small operation. However, it doesn't solve all the needs of software development,
    since you only do it from time to time. Moreover, between two benchmarks, you
    can have huge performance regression not captured by the unit tests validating
    the features and behavior of your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章中看到，驱动基准测试需要工作，并且不是一个小的操作。然而，它并不能解决软件开发的所有需求，因为你只是偶尔进行它。此外，在两次基准测试之间，你可能会遇到巨大的性能回归，而这些回归没有被验证应用程序功能和行为的单元测试捕捉到。
- en: 'To solve that, it is a good idea to try to add dedicated tests for performance.
    This is what this chapter is about. Thus, we will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，尝试添加针对性能的专用测试是一个好主意。这正是本章的内容。因此，我们将学习：
- en: Which tools you can use to *test* the performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用哪些工具来*测试*性能
- en: How you can set up some continuous integration for performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何为性能设置一些持续集成
- en: How to write tests for the performance in such a context
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种背景下如何编写性能测试
- en: Writing performance tests – the pitfalls
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写性能测试——陷阱
- en: Performance tests have some challenges you need to take into account when you
    write your tests to avoid having a lot of false positive results (not passing
    tests where the performance is actually acceptable).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试有一些挑战，当你编写测试时需要考虑，以避免出现大量误报结果（实际性能可接受但测试未通过的情况）。
- en: 'The most common issues you will encounter are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你最常遇到的问题包括：
- en: 'How to manage the external systems: We know that external systems are very
    important in applications today, but it is not always trivial to have them during
    tests.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何管理外部系统：我们知道外部系统在当今的应用程序中非常重要，但在测试期间拥有它们并不总是微不足道的。
- en: 'How to be deterministic: Continuous integration/test platforms are often shared.
    How do you ensure you have the resources needed in order to have a deterministic
    execution time and to not be slown down, as another build is using all the available
    resources?'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保确定性：持续集成/测试平台通常是共享的。你如何确保你有必要的资源，以便有确定性的执行时间，并且不会被拖慢，因为另一个构建正在使用所有可用资源？
- en: 'How to handle the infrastructure: To do an end-to-end test, you need multiple
    injectors (clients) and probably multiple backend servers. How do you ensure you
    have them available without them being too expensive if you use cloud platforms
    such as **Amazon Web Services** (**AWS**)?'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理基础设施：为了进行端到端测试，你需要多个注入器（客户端）和可能多个后端服务器。如果你使用像**Amazon Web Services**（**AWS**）这样的云平台，你如何确保它们可用，同时又不至于过于昂贵？
- en: You can see the setup of performance tests as a benchmark preparation phase.
    The main difference will be that you should not rely on external consulting in
    the long-term, and you will ensure the benchmark iterations are almost completely
    automatic—*almost* because you will still need to take some actions if the tests
    fail, otherwise there is no point having a continuous system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将性能测试的设置看作是一个基准准备阶段。主要区别在于你不应长期依赖外部咨询，并且你将确保基准迭代几乎完全自动化——*几乎*因为如果测试失败，你仍然需要采取一些行动，否则拥有持续系统就没有意义了。
- en: Writing performance tests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写性能测试
- en: Performance tests are present at all stages in a Java EE application, and so,
    there are several ways to write a performance test. In this section, we will go
    through a few main ones, starting with the simplest one (algorithm validation).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试存在于Java EE应用的各个阶段，因此，编写性能测试有几种方法。在本节中，我们将探讨几种主要方法，从最简单的一个（算法验证）开始。
- en: JMH – the OpenJDK tool
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JMH – OpenJDK工具
- en: '**Java Microbenchmark Harness** (**JMH**) is a small library developed by the
    OpenJDK team—yes, the same one doing the JVM—which enables you to easily develop
    microbenchmarks.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Microbenchmark Harness**（**JMH**）是由OpenJDK团队开发的一个小型库——是的，就是那个做JVM的团队——它使你能够轻松地开发微基准测试。'
- en: A microbenchmark designs a benchmark on a very small part of an application.
    Most of the time, you can see it as a *unit benchmark*, using the analogy with
    unit tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试设计了一个基准测试，针对应用程序非常小的一部分。大多数情况下，你可以将其视为*单元基准测试*，与单元测试进行类比。
- en: Yet, it is something important when setting up performance tests as it will
    allow you to quickly identify a critical performance regression introduced by
    a recent change. The idea is to associate each benchmark with a small part of
    code, whereas a benchmark will include several layers. So, if the benchmark fails,
    you will spend a lot of time identifying why, instead of simply checking the related
    code part.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在设置性能测试时，这是一个重要的因素，因为它将允许您快速识别由最近更改引入的关键性能回归。想法是将每个基准测试与一小部分代码相关联，而基准测试将包含几个层次。因此，如果基准测试失败，您将花费大量时间来识别原因，而不是简单地检查相关的代码部分。
- en: Writing a benchmark with JMH
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMH编写基准测试
- en: Before being able to write code with JMH, you need to add it as a dependency
    of your project. We will use Maven syntax in the following example, but it has
    equivalents for Gradle, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够使用JMH编写代码之前，您需要将其添加为项目的依赖项。以下示例我们将使用Maven语法，但Gradle等其他构建工具也有相应的语法。
- en: 'The first thing to do is to add into your `pom.xml` the following dependencies;
    we will use the scope `test` since the dependencies are only needed for our performance
    tests and not the "main" code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是将以下依赖项添加到您的`pom.xml`文件中；我们将使用`test`范围，因为依赖项仅用于我们的性能测试，而不是“主”代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As of writing this book, the `jmh.version` property can take the `1.19` value.
    The `jmh-core` dependency will bring you JMH itself with its annotation-based
    API, and the `jmh-generator-annprocess` brings an annotation processor backbone—used
    when compiling the test classes/benchmarks—which will generate some sort of index
    file(s) used by the runtime to execute the benchmarks and the benchmark classes
    themselves.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 写这本书的时候，`jmh.version`属性可以取`1.19`的值。`jmh-core`依赖项将为您提供JMH本身及其基于注解的API，而`jmh-generator-annprocess`则提供了一个注解处理器框架——在编译测试类/基准测试时使用，它将生成一些索引文件，这些文件由运行时用于执行基准测试和基准测试类本身。
- en: The state
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: 'Once you have the right dependencies, you can develop your benchmarks. The
    API is quite straightforward. It uses the notion of a *state* and a state has
    a life cycle and (volatile) storage associated with the benchmark. The life cycle
    of a state is defined by marking methods with:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了正确的依赖项，您就可以开发您的基准测试。API非常直观。它使用*状态*的概念，状态与基准测试相关联，并具有生命周期和（易失性）存储。状态的生命周期是通过标记方法来定义的：
- en: '`@Setup` to execute an initialization task'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Setup`用于执行初始化任务'
- en: '`@Teardown` to release any created resource in the setup method'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Teardown`用于在设置方法中释放任何创建的资源'
- en: State classes can also contain fields decorated with `@Param` to make them contextualized
    and configurable (such as enabling them to get a different target URL depending
    on the execution for example).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 状态类也可以包含带有`@Param`装饰的字段，使它们具有上下文化和可配置性（例如，根据执行启用不同的目标URL等）。
- en: 'A state class is marked with `@State`, which takes, as parameter, the scope
    of the state instance for a benchmark:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 状态类用`@State`标记，它作为参数接受基准测试状态实例的作用域：
- en: '`Benchmark` means the state will be a singleton in the scope of the JVM.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Benchmark`意味着状态将在JVM的作用域内是一个单例。'
- en: '`Group` defines the state as a singleton per group. A group is a way to put
    multiple benchmark methods (scenarii) in the same thread bucket during the execution.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Group`定义了每个组的状态为一个单例。组是在执行期间将多个基准测试方法（场景）放入同一线程桶的方法。'
- en: '`Thread` defines the state as a singleton per thread (a bit like `@RequestScoped`
    for CDI).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread`定义了每个线程的状态为一个单例（有点类似于CDI中的`@RequestScoped`）。'
- en: 'Note that you can change how the life cycle is managed a bit by passing the
    runtime to `@Setup` and `@Teardown` to a different `Level`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以通过将运行时传递给`@Setup`和`@Teardown`以不同的`Level`来稍微改变生命周期管理方式：
- en: '`Trial`: This is the default, and as we just explained, the benchmark is seen
    as a whole'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trial`：这是默认的，正如我们刚才解释的，基准测试被视为一个整体'
- en: '`Iteration`: The life cycle is executed per iteration (warmup or measurement)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iteration`：生命周期在每次迭代（预热或测量）中执行'
- en: '`Invocation`: The life cycle of the state instance is executed per method;
    this is not recommended in practice to avoid some measurement errors'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invocation`：状态实例的生命周期在每次方法调用中执行；实际上不推荐这样做，以避免一些测量错误'
- en: 'So, once you have your state object, you define the class containing your benchmarks
    which are nothing other than methods marked with `@Benchmark`. Then, you have
    several annotations you can add to the method to customize the benchmark execution:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦您有了状态对象，您就定义包含基准测试的类，这些基准测试实际上就是标记了`@Benchmark`的方法。然后，您可以在方法上添加几个注解来自定义基准测试的执行：
- en: '`@Measurement`: To customize the number of iterations or the duration of the
    benchmark.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Measurement`：用于自定义基准的迭代次数或持续时间。'
- en: '`@Warmup` : The same as `@Measurement`, but for the warmup (which is a sort
    of pre-execution of the benchmark not taken into account for the measurement,
    the goal being to only measure metrics on a hot JVM).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Warmup`：与`@Measurement`相同，但用于预热（这是一种基准的预执行，不计入测量，目标是只测量热JVM上的指标）。'
- en: '`@OuputTimeUnit`: To customize the unit used for the metrics.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@OutputTimeUnit`：用于自定义用于指标的单元。'
- en: '`@Threads`: To customize the number of threads used for the benchmark. You
    can see it as the number of *users*.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Threads`：用于自定义用于基准的线程数。你可以将其视为用户数。'
- en: '`@Fork`: The benchmark will be executed in another JVM to avoid test side effects.
    This annotation allows you to add custom parameters to the forked JVM.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Fork`：基准将在另一个JVM中执行，以避免测试副作用。这个注解允许你向分叉的JVM添加自定义参数。'
- en: '`@OperationsPerInvocation`: If you have a loop in your benchmark method, this
    option (a number) will normalize the measurement. For instance, if you execute
    five times the same operation in your benchmark and set this value to five, then
    the execution time will be divided by five.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@OperationsPerInvocation`：如果你的基准方法中有一个循环，这个选项（一个数字）将标准化测量。例如，如果你在基准中执行了五次相同的操作，并将此值设置为五，那么执行时间将除以五。'
- en: '`@Timeout`: It lets you define a maximum duration for the benchmark execution.
    JMH will interrupt the threads if overpassed.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Timeout`：它允许你定义基准执行的最大持续时间。如果超过这个时间，JMH将中断线程。'
- en: '`@CompilerControl`: To customize the way the annotation processor generates
    the code. For our use case, you rarely need this option, but while tuning some
    code portions, it can be interesting to test it.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CompilerControl`：用于自定义注解处理器生成代码的方式。对于我们的用例，你很少需要这个选项，但在调整某些代码部分时，测试它可能很有趣。'
- en: Creating your first JMH benchmark
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个JMH基准
- en: 'After all that theory, here is a basic benchmark developed with JMH:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些理论之后，这里是一个使用JMH开发的基本基准：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, we have a single benchmark scenario called `compute`. It doesn't
    use any states and didn't customize any thread or fork count.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个名为`compute`的单个基准场景。它不使用任何状态，也没有自定义任何线程或分支计数。
- en: 'In practice, this will not be enough and you will often need a state to get
    a service. So, it will more look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这还不够，你通常会需要一个状态来获取服务。所以，它会更像这样：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we created a nested `QuoteState` instance which will be responsible for
    getting us a service, and we injected it to the benchmark method (`compute`) and
    used it to get our service instance. This avoids creating an instance per iteration,
    and thus, avoids taking into account the container startup duration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个嵌套的`QuoteState`实例，它将负责为我们获取服务，并将其注入到基准方法（`compute`）中，并使用它来获取我们的服务实例。这避免了每次迭代创建一个实例，因此避免了考虑容器启动持续时间。
- en: This sort of implementation works well until you need an actual container. But
    when you need a container, it will require some mocking which is absolutely something
    you should get rid of—even for unit testing—as it will not represent anything
    close to the real deployment until your code doesn't use Java EE at all (which
    also means you don't need to mock anything if that is the case).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方式在需要实际容器之前效果良好。但是，当你需要容器时，它将需要一些模拟，这绝对是你应该去除的东西——即使是对于单元测试——因为它不会在代码完全不使用Java
    EE的情况下（这也意味着在这种情况下你不需要模拟任何东西）代表接近真实部署的任何内容。
- en: 'If you use a CDI 2.0 implementation supporting standalone API—and your application
    doesn''t need more for what you want to test—then you can change the state to
    start/stop the CDI container and look up the services you need with the new CDI
    standalone API:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用支持独立API的CDI 2.0实现——并且你的应用程序不需要更多用于你想要测试的内容——那么你可以将状态更改为启动/停止CDI容器，并使用新的CDI独立API查找你需要的服务：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the setup starts the `container`—you can customize the classes to deploy
    before calling `initialize()`—and then looks up the `QuoteService` using the `container` instance
    API. The `tearDown` method just closes the container properly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，设置启动`container`——你可以在调用`initialize()`之前自定义要部署的类——然后使用`container`实例API查找`QuoteService`。`tearDown`方法只是正确关闭容器。
- en: 'Though, in GlassFish, you can''t use that new API. But there is the `EJBContainer`,
    coming from Java EE 6, allowing you to do the same thing combined with the `CDI`
    class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在GlassFish中，你不能使用那个新API。但是有一个来自Java EE 6的`EJBContainer`，它允许你结合`CDI`类做同样的事情：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This uses exactly the same logic as before, except the `container` is started
    based on the `EJBContainer` API. This looks great, but it will not always work
    with all containers. One pitfall is that if you don't have any EJB, some containers
    will just not even try to deploy the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前完全相同的逻辑，只是基于`EJBContainer` API启动`container`。这看起来很棒，但它并不总是与所有容器都兼容。一个陷阱是，如果你没有任何EJB，一些容器甚至不会尝试部署应用程序。
- en: You can find several workarounds, but the saner solution is to check if you
    really need the full container or just a subset—such as just CDI—and in this case,
    you just start this subset (Weld or OpenWebBeans only for a CDI using a previous
    state). If you really need a full container and your vendor doesn't support any
    of the two previous ways of starting a container, you can also use a vendor-specific
    API, mock the container (but take care, you will bypass some execution time *cost*),
    use another vendor if close enough to your final container, or implement it with
    a third-party container manager such as the `arquillian` container API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到几种解决方案，但更明智的解决方案是检查你是否真的需要完整的容器或只是子集——比如只是CDI——在这种情况下，你只需启动这个子集（Weld或OpenWebBeans仅用于CDI，使用之前的状态）。如果你真的需要一个完整的容器，并且你的供应商不支持上述两种启动容器的方法，你也可以使用供应商特定的API，模拟容器（但请注意，你将绕过一些执行时间*成本*），如果与你的最终容器足够接近，也可以使用另一个供应商，或者使用第三方容器管理器，如`arquillian`容器API。
- en: BlackHole to be a star
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑洞将成为一颗恒星
- en: 'JMH provides a particular class—`org.openjdk.jmh.infra.Blackhole`—that can
    seem weird as it mainly only allows you to `consume` an instance. It is retrieved
    by injecting it into the parameters of the benchmark:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JMH提供了一个特定的类——`org.openjdk.jmh.infra.Blackhole`——它可能看起来很奇怪，因为它主要只允许你`consume`一个实例。它是通过将其注入到基准的参数中检索的：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why consume the returned value of a method if we do nothing about it? Remember
    that the Oracle JVM has what is called the **just in time compilation** (**JIT**)
    which optimizes the code at runtime depending on the statistics of the code paths.
    If you don't call that `consume` method, you can end up not measuring the actual
    code you want, but some very optimized flavors of this code, since, most of the
    time, in your benchmark methods, you will ignore part of the returned values which
    can, hence, be optimized with the *dead-code elimination* rule.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不处理方法返回的值呢？记住，Oracle JVM有一个称为**即时编译**（**JIT**）的功能，它会根据代码路径的统计数据在运行时优化代码。如果你不调用那个`consume`方法，你可能会最终测量不到你想要的实际代码，而是这种代码的一些非常优化的版本，因为，在大多数情况下，在你的基准方法中，你会忽略部分返回值，因此可以被*死代码消除*规则优化。
- en: Running the benchmarks
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: 'JMH provides a main-friendly API to run the benchmarks. It is based on defining
    the execution options which are more or less the options you can associate with
    a benchmark method (the one we saw in previous section with annotations) and a
    list of includes/excludes to select the classes/methods to run. Then, you pass
    these options to a runner and call its `run()` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JMH提供了一个友好的API来运行基准测试。它基于定义执行选项，这些选项大致上是你可以与基准方法关联的选项（我们在上一节中通过注解看到的）和一个包含/排除列表，以选择要运行的类/方法。然后，你将这些选项传递给运行器并调用其`run()`方法：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we build a simple `Options` instance from the `OptionsBuilder` by including
    a benchmark class we want to include. Finally, we run it through the method with
    the same name as the runner, and collect the benchmark's results in a collection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过包含我们想要包含的基准类，从`OptionsBuilder`构建一个简单的`Options`实例。最后，我们通过具有与运行器相同名称的方法运行它，并将基准的结果收集到一个集合中。
- en: Integrating JMH with JUnit
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JMH与JUnit集成
- en: 'There is no official JUnit integration of JMH. In spite of that, it is not
    that hard to do it yourself. There are lots of possible designs, but in the context
    of this book we will do the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JMH没有官方的JUnit集成。尽管如此，自己实现它并不难。有许多可能的设计，但在这个书的背景下，我们将做以下事情：
- en: Our integration will go through a JUnit runner
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的集成将通过JUnit运行器进行
- en: The benchmark classes will be identified by extracting the nested classes of
    the test class which will avoid using any scanning to find the benchmark classes
    or explicit listing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准类将通过提取测试类的嵌套类来识别，这将避免使用任何扫描来查找基准类或显式列出
- en: We will introduce an `@ExpectedPerformances` annotation to be able to add assertions
    based on the execution
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将引入`@ExpectedPerformances`注解，以便能够根据执行添加断言
- en: 'Structurally, a microbenchmark test using this structure will look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结构上，使用这种结构的微基准测试将看起来像这样：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you have the overall test structure, you just need to add the benchmarks
    themselves in the right nested class. Concretely, a benchmark class can look like
    this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了整体测试结构，你只需要在正确的嵌套类中添加基准测试本身。具体来说，一个基准测试类可以看起来像这样：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this test class, we have two benchmark classes using a different state (a
    different service in our EE application) and each of them can have a different
    benchmark method counts. The execution is handled by the runner set with `@RunWith`,
    using the standard JUnit (4) API. We will note the `@ExpectedPerformances` usage
    on all benchmarks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试类中，我们有两个基准测试类，它们使用不同的状态（我们EE应用程序中的不同服务），并且每个类都可以有不同的基准测试方法数量。执行由使用`@RunWith`设置的运行器处理，使用标准的JUnit（4）API。我们将在所有基准测试上注意`@ExpectedPerformances`的使用。
- en: If you have already migrated to JUnit 5, or are using TestNG, the same sort
    of integration is possible but you will use extensions for JUnit 5 and probably
    an abstract class or a listener for TestNG.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经迁移到JUnit 5，或者正在使用TestNG，可以实现类似的集成，但你会使用JUnit 5的扩展，可能还会使用TestNG的抽象类或监听器。
- en: 'Before seeing how to implement that runner, we must have this `@ExpectedPerformances`
    annotation. It is the one allowing us to assert the performance of our benchmark.
    So, we at least need:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍如何实现该运行器之前，我们必须有这个`@ExpectedPerformances`注解。它是允许我们断言基准测试性能的注解。因此，我们至少需要：
- en: A score (duration but without specifying the unit, since JMH supports customizing
    the report unit)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分数（持续时间，但不指定单位，因为JMH支持自定义报告单位）
- en: A tolerance on the score as there is no way you get exactly the same score twice
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数上有一定的容差，因为你不可能两次得到完全相同的分数
- en: 'To do that, we can use this simple definition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以使用这个简单的定义：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we tell the user to define a score, but we use a default score
    tolerance of `0.1`. In our implementation, we will consider it as being a percentage
    (10%). This will avoid frequent failure if the machine load is not very stable
    when running your job. Don't hesitate to decrease that value or even make it configurable
    through a system property.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们告诉用户定义一个分数，但我们使用默认的分数容差`0.1`。在我们的实现中，我们将它视为百分比（10%）。这将避免在机器负载不稳定时运行作业时频繁失败。不要犹豫，降低这个值，甚至可以通过系统属性使其可配置。
- en: To make our previous snippet work, we need to implement a JUnit runner. This
    is a design choice, but you can also use a rule, exposing some programmatic API
    or not. To keep it simple, we will not do it here and just consider the whole
    benchmark setup as done through the annotations. However, for a real-life project,
    it can be handy to enable the environment (system properties) to customize the
    annotation values a bit. A common implementation is to use them as a template
    and multiple all numeric values by a configured ratio on the JVM to let the tests
    run on any machine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的上一个片段正常工作，我们需要实现一个JUnit运行器。这是一个设计选择，但你也可以使用规则，暴露一些程序性API或不暴露。为了保持简单，我们在这里不会这样做，而是将整个基准测试设置视为通过注解完成的。然而，对于实际项目来说，启用环境（系统属性）以自定义注解值可能很有用。一个常见的实现是使用它们作为模板，并在JVM中将所有数值乘以一个配置的比率，以便在任何机器上运行测试。
- en: 'Our runner will have these four roles:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行器将具有以下四个角色：
- en: Find the benchmark classes
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到基准测试类
- en: Validate the model of these classes—typically, validate that each benchmark
    has an `@ExpectedPerformances`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证这些类的模型——通常，验证每个基准测试都有一个`@ExpectedPerformances`
- en: Run each benchmark
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行每个基准测试
- en: Validate the expectations to make the test fail if we have a regression
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证期望，如果出现回归，使测试失败
- en: It is simpler for us to extend `ParentRunner<Class<?>>`. We could use `BlockJUnit4ClassRunner`,
    but it is based on methods and JMH only supports filtering the executions per
    class. So, let's stick to it for now. If you put a single benchmark per nested
    class, then you can simulate a run per method behavior.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，扩展`ParentRunner<Class<?>>`更简单。我们可以使用`BlockJUnit4ClassRunner`，但它基于方法，而JMH只支持按类过滤执行。所以，我们暂时坚持使用它。如果你在每个嵌套类中只放一个基准测试，那么你可以模拟按方法运行的运行行为。
- en: 'The first thing we need to do is to find our benchmark classes. With the JUnit
    runner API, you can access the test class with `getTestClass()`. To find our benchmark,
    we just need to check the nested classes of that class through `getClasses()`
    and make sure the class has at least one `@Benchmark` on a method to validate
    that it is a JMH class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是找到我们的基准测试类。使用JUnit运行器API，你可以通过`getTestClass()`访问测试类。要找到我们的基准测试，我们只需要通过`getClasses()`检查该类的嵌套类，并确保该类至少有一个方法上的`@Benchmark`来验证它是一个JMH类：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We go through all nested classes of the test class, then keep (or filter) only
    the ones with a benchmark method at the least. Note that we store the result as
    we will need multiple times in our runner.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历测试类的所有嵌套类，然后只保留（或过滤）至少有一个基准方法的那部分。请注意，我们存储结果，因为我们的跑步者需要多次使用这些结果。
- en: 'Then, the validation is as simple as going over these classes and their benchmark
    methods to validate they have the `@ExpectedPerformances` annotation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，验证过程就像遍历这些类及其基准方法，验证它们是否有`@ExpectedPerformances`注解：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, to list the errors of the JUnit validation, we add an exception per method
    annotated with `@Benchmark` but without an `@ExpectedPerformances`. We do it first
    by converting the classes to a stream of benchmark methods, then keeping only
    the ones without the `@ExpectedPerformances` annotation to keep the *set vision*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了列出JUnit验证的错误，我们为每个用`@Benchmark`注解但没有`@ExpectedPerformances`注解的方法添加一个异常。我们首先通过将类转换为基准方法的流来实现，然后只保留没有`@ExpectedPerformances`注解的方法以保持*集合视图*。
- en: 'Finally, the last key part of the runner code is to convert a class to an actual
    execution:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，跑步者代码的最后关键部分是将一个类转换为实际的执行：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, we execute the benchmark holder class and collect the results. Then,
    we iterate over the benchmark methods and for each of them, we extract the result
    (primary result label is the method name). Finally, we extract our `@ExpectedPerformances`
    constraint and compare it with the primary result of the test. The little trick
    here is to catch the `AssertionError` the assert can throw, and collect them all
    in a list to convert them in another `AssertionError`. You can just format the
    message the way you want, but doing it this way keeps standard JUnit formatting
    of the errors. The other tip here is to put the benchmark class and method in
    the error message to make sure you can identify which benchmark failed. The alternative
    way can be to introduce another annotation to use a custom name for each benchmark.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们执行基准持有类并收集结果。然后，我们遍历基准方法，并对每个方法，我们提取结果（主要结果标签是方法名）。最后，我们提取我们的`@ExpectedPerformances`约束并将其与测试的主要结果进行比较。这里的技巧是捕获断言可以抛出的`AssertionError`，并将它们全部收集到一个列表中，然后转换为另一个`AssertionError`。你可以按你想要的方式格式化消息，但这样做可以保持标准JUnit的错误格式。这里的另一个提示是将基准类和方法放入错误消息中，以确保你可以识别哪个基准失败了。另一种方式是引入另一个注解，为每个基准使用自定义名称。
- en: 'Now that we have looked at all the small technical points, let''s put it all
    together. To start, we will define that our runner will use `Class` children,
    which will represent each of our nested classes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审视了所有的技术细节，让我们将它们整合起来。首先，我们将定义我们的跑步者将使用`Class`子类，这些子类将代表我们嵌套的每个类：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the code executed by the parent constructor (`super(klass)`), JUnit will
    trigger a test validation where we compute the children we previously saw to be
    able to return them in `getChildren()` and to let JUnit handle all our nested
    classes. We implement `describeChild` to let JUnit associate a `Description` with
    each nested class and to have smoother integration with IDE (the goal is to show
    them in a tree when you run the tests). To compute the children and validate them,
    we can use this JUnit implementation of `collectInitializationErrors`—using this
    hook avoids computing it multiple times per test class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在父构造函数（`super(klass)`）执行的代码中，JUnit将触发一个测试验证，其中我们计算之前看到的子类，以便在`getChildren()`中返回它们，并让JUnit处理所有我们的嵌套类。我们实现`describeChild`以让JUnit将一个`Description`与每个嵌套类关联，并实现与IDE的更平滑集成（目标是当你运行测试时在树中显示它们）。为了计算子类并验证它们，我们可以使用这个JUnit的`collectInitializationErrors`实现——使用这个钩子可以避免在每个测试类中多次计算：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we need to ensure we can run our children (benchmarks) properly. To do
    that, we extend another JUnit hook which is designed to run each child. The only
    thing we take care of is mainly ensuring JUnit `@Ignored` is supported for our
    children:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要确保我们可以正确地运行我们的子类（基准）。为此，我们扩展了另一个JUnit钩子，该钩子旨在运行每个子类。我们主要关心的是确保JUnit的`@Ignored`注解支持我们的子类：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `runChild()`, we delegate the execution to the JUnit engine by adding, as
    an implementation of our test execution, the code we saw just before based on
    JMH runner but wrapped in a JUnit `Statement` to let it be integrated with JUnit
    notifiers. Now, we just need this execution implementation (`benchmarkStatement`).
    This is done by completing the class with the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `runChild()` 中，我们通过添加作为我们测试执行的代码（基于 JMH 运行器，但封装在 JUnit `Statement` 中以使其能够与
    JUnit 通知器集成）来委托给 JUnit 引擎执行。现在，我们只需要这个执行实现（`benchmarkStatement`）。这是通过以下代码来完成类的：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This reuses everything we previously saw; the `buildOptions` method will force
    the JMH runner to use the annotations on the benchmark for the execution configuration
    and we just include a single test at a time. Finally, we implement the `assertResults`
    method as we explained before:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这重用了我们之前看到的所有内容；`buildOptions` 方法将强制 JMH 运行器使用基准测试上的注解来配置执行，我们一次只包含一个测试。最后，我们像之前解释的那样实现了
    `assertResults` 方法：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, with this runner, you can execute the test in the main build with surefire
    or failsafe and ensure your build will not pass if you have huge performance regression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个运行器，你可以在主构建中使用 surefire 或 failsafe 执行测试，并确保如果你的性能回归很大，构建将不会通过。
- en: This is a simple implementation and you can enrich it in several ways, such
    as by simulating one child per benchmark to gain a nicer report in the IDE and
    surefire report (just run it the first time you encounter the enclosing class,
    then store the result and do the assertion per method). You can also assert more
    results, such as the secondary results or the iteration results (for example,
    no iteration is slower than X). Finally, you can implement some `living documentation` features,
    adding an @Documentation annotation which will be used by the runner to create
    a report file (in asciidoctor, for instance).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实现，你可以通过多种方式丰富它，例如通过模拟每个基准测试一个子项来在 IDE 和 surefire 报告中获得更好的报告（只需在第一次遇到封装类时运行它，然后存储结果并对每个方法进行断言）。你还可以断言更多结果，例如次要结果或迭代结果（例如，没有迭代比
    X 慢）。最后，你可以实现一些“活文档”功能，添加一个 @Documentation 注解，该注解将被运行器用于创建报告文件（例如，在 asciidoctor
    中）。
- en: ContiPerf
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ContiPerf
- en: 'An alternative to JMH, which is a bit less advanced but much easier to use,
    is ContiPerf. You can add it to your project with this dependency:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JMH 的一个替代方案是 ContiPerf，它稍微简单一些，但更容易使用。你可以通过以下依赖关系将其添加到你的项目中：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will not detail it completely in this book as we spent a lot of time on JMH
    already. But in a few words, it is based on a JUnit 4 rule. Thus, it can be combined
    with other rules and sorted thanks to the JUnit `RuleChain`, which makes it very
    powerful, with all light EE containers having a JUnit-based testing stack such
    as TomEE or Meecrowave, for instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经花费了大量时间在 JMH 上，我们不会在这本书中详细说明它。但简单来说，它基于 JUnit 4 规则。因此，它可以与其他规则结合并排序，这得益于
    JUnit `RuleChain`，这使得它非常强大，所有轻量级 EE 容器都拥有基于 JUnit 的测试堆栈，例如 TomEE 或 Meecrowave
    等。
- en: 'The very big advantage of ContiPerf is that it is aligned with the JUnit model:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ContiPerf 的一个很大的优势是它与 JUnit 模型对齐：
- en: It is based on the standard JUnit `@Test` method marker
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它基于标准的 JUnit `@Test` 方法标记
- en: You can reuse the JUnit standard life cycle (`@BeforeClass`, `@Before`, and
    so on)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以重用 JUnit 标准的生命周期（`@BeforeClass`、`@Before` 等等）
- en: You can combine it with other JUnit features (runners, rules, and so on)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将它与其他 JUnit 功能（运行器、规则等）结合使用
- en: 'Here is what a test can look like in terms of structure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构上来说，一个测试可以看起来是这样的：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We immediately identify a JUnit structure, with an `@BeforeClass` initializing
    the test (you can start a container here and close it in an `@AfterClass` if needed),
    and a `@Test` that is our benchmark/scenario. The only difference with a JUnit
    test is the `ContiPerfRule` and the `@Required` and `@PerfTest` annotations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即识别出 JUnit 结构，有一个 `@BeforeClass` 初始化测试（你可以在这里启动容器，如果需要的话，在 `@AfterClass`
    中关闭它），以及一个 `@Test`，它是我们的基准/场景。与 JUnit 测试的唯一区别是 `ContiPerfRule` 和 `@Required` 以及
    `@PerfTest` 注解。
- en: The `@PerfTest` describes the test environment—how many threads, how long, how
    many iterations, the duration for the warmup, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PerfTest` 描述了测试环境——多少线程、多长时间、多少迭代次数、预热持续时间等。'
- en: The `@Required`, on another side, describes the assertions (validations) to
    do. It is equivalent to our `@ExpectedPerformances` in our JMH integration. It
    supports most of the common validations such as the throughoutput, the average,
    the total time, and so on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`@Required` 描述了要进行的断言（验证）。它相当于我们 JMH 集成中的 `@ExpectedPerformances`。它支持大多数常见的验证，如吞吐量、平均时间、总时间等。
- en: Arquillian and ContiPerf – the diabolic pair
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arquillian 和 ContiPerf – 这对恶魔般的组合
- en: In the JMH section, we got the issue that starting a container was sometimes
    hard and really not straightforward. As ContiPerf is a rule, it is compatible
    with `Arquillian`, which can do all that work for you.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JMH 部分，我们遇到了启动容器有时很难且并不直接的问题。由于 ContiPerf 是一个规则，它与 `Arquillian` 兼容，可以为你完成所有这些工作。
- en: '`Arquillian` is a project created by JBoss (Red Hat, now) for abstracting the
    containers behind a **service provider interface** (**SPI**) and integrating it
    with JUnit or TestNG. The idea is to run a test from your IDE as usual, without
    having to care about needing a container.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arquillian` 是由 JBoss（现在是 Red Hat）创建的一个项目，用于抽象化容器背后的 **服务提供者接口**（**SPI**），并将其与
    JUnit 或 TestNG 集成。想法是像往常一样从你的 IDE 中运行测试，而不必担心需要容器。'
- en: 'At a high level, it requires you to define what you deploy into the container
    and to use the `Arquillian` runner with JUnit (or an abstract class with TestNG).
    Thanks to a mechanism of extensions and enrichers, you can inject most of what
    you need into the test class, such as CDI beans, which is really handy for writing
    tests. Here is a sample:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，它要求你定义要部署到容器中的内容，并使用与 JUnit（或 TestNG 的抽象类）一起使用的 `Arquillian` 运行器。多亏了扩展和增强器的机制，你可以将大多数你需要的内容注入到测试类中，例如
    CDI 容器，这对于编写测试来说非常方便。以下是一个示例：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This snippet illustrates `Arquillian` usage with its common characteristics:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段说明了 `Arquillian` 的使用及其常见特性：
- en: The `Arquillian` runner is in use; it is the magic that will start the container
    (once), deploy the application (per test class by default), execute the tests
    (inherited from JUnit default behavior), undeploy the application when all tests
    of the class were executed, and shut down the container once the tests have been
    executed.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在使用 `Arquillian` 运行器；这是启动容器（一次）、部署应用程序（默认情况下按测试类）、执行测试（继承自 JUnit 默认行为）、在执行完所有测试后卸载应用程序，并在测试执行后关闭容器的魔法。
- en: The static `@Deployment` method returns an `Archive<?>` describing what to deploy
    into the container (the application). You don't have to deploy the full application
    and you can change it per test if you want. For instance, in our sample, we didn't
    deploy our `DataSourceConfiguration`, which is pointing to MySQL, but instead,
    a `InMemoryDatabaseConfiguration`, which we can assume uses an embedded database
    such as derby or h2.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态的 `@Deployment` 方法返回一个 `Archive<?>`，描述了要部署到容器（应用程序）中的内容。你不需要部署完整的应用程序，如果你愿意，可以按测试更改它。例如，在我们的示例中，我们没有部署我们的
    `DataSourceConfiguration`，它指向 MySQL，而是部署了一个 `InMemoryDatabaseConfiguration`，我们可以假设它使用嵌入式数据库，如
    derby 或 h2。
- en: We have a CDI injected into the test directly, our `QuoteService`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们直接将 CDI 注入到测试中，我们的 `QuoteService`。
- en: The rest of the test is a standard JUnit test with its life cycle (`@Before`/`@After`)
    and its test methods (`@Test`).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的其余部分是一个标准的 JUnit 测试，具有其生命周期（`@Before`/`@After`）和测试方法（`@Test`）。
- en: 'If you find the construction of the archive too complicated, there are some
    projects such as the TomEE `ziplock` module that simplify it by reusing the *current* project
    metadata (such as the `pom.xml` and compiled classes), which allows you to create
    the archive with a single method invocation: `Mvn.war()`. Some containers, including
    TomEE, allow you to deploy each archive a single time. But if your container doesn''t
    support it, you can use the `Arquillian` suite extension to achieve almost the
    same result. The overall goal is to group your tests to deploy a single time your
    application and save precious minutes on your tests execution duration.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现构建存档过于复杂，有一些项目，例如 TomEE 的 `ziplock` 模块，通过重用 *当前* 项目元数据（例如 `pom.xml` 和编译后的类）来简化它，这允许你通过单次方法调用：`Mvn.war()`
    来创建存档。一些容器，包括 TomEE，允许你一次性部署每个存档。但如果你的容器不支持，你可以使用 `Arquillian` 套件扩展来实现几乎相同的结果。总体目标是将你的测试分组，一次性部署你的应用程序，并在测试执行持续时间上节省宝贵的时间。
- en: '`Arquillian` also allows us to go further and execute the test either from
    inside the container—as the previous example—or from a client perspective using
    the `@RunAsClient` annotation. In this case, your test is no longer executed inside
    the container but in JUnit JVM (which can be the same or not, depending on whether
    your container uses another JVM or not). In any case, coupling `Arquillian` with
    ContiPerf allows you to validate the performance without many headaches. You just
    have to add the ContiPerf rule and annotations on the methods you want to validate:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arquillian` 还允许我们更进一步，从容器内部（如前一个示例所示）或使用 `@RunAsClient` 注解从客户端角度执行测试。在这种情况下，你的测试不再在容器内部执行，而是在
    JUnit JVM（这可以相同或不同，取决于你的容器是否使用另一个 JVM）中执行。无论如何，将 `Arquillian` 与 ContiPerf 集成可以让你在没有太多烦恼的情况下验证性能。你只需在你想验证的方法上添加
    ContiPerf 规则和注解即可：'
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is almost the same test as before, but we added more data to ensure the
    dataset size doesn't affect our performance much in the `@Before` method used
    to initialize the database. To integrate the test with ContiPerf, we added the
    ContiPerf annotations to our method and the ContiPerf rule. The last trick you
    can see is a system property in the archive creation, able to switch databases
    depending on the JVM configuration. It can be used to test against several databases
    or environments and validates you are complicant with all your target platforms.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与之前的测试相同，但我们添加了更多数据以确保数据集大小不会在很大程度上影响初始化数据库时使用的 `@Before` 方法中的性能。为了将测试与 ContiPerf
    集成，我们在方法和 ContiPerf 规则上添加了 ContiPerf 注解。你最后可以看到的一个技巧是在归档创建中设置系统属性，可以根据 JVM 配置切换数据库。它可以用来测试多个数据库或环境，并验证你是否与所有目标平台兼容。
- en: 'To be able to run this example, you need to add these dependencies into your
    pom—considering that you will test it against GlassFish 5.0, you need to change
    the container dependency and `arquillian` container integration:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够运行此示例，你需要在你的 pom 中添加这些依赖项——考虑到你将针对 GlassFish 5.0 进行测试，你需要更改容器依赖项和 `arquillian`
    容器集成：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: JUnit is the test framework we use and we import its Arquillian integration
    (`arquillian-junit-container`). Then, we import our `arquillian` container integration
    (`arquillian-glassfish-embedded-3.1`) and Java EE container, as we use an embedded
    mode (`glassfish-embedded-all`). Don't forget to add a ContiPerf dependency too
    if you plan to use it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 是我们使用的测试框架，我们导入其 Arquillian 集成（`arquillian-junit-container`）。然后，我们导入我们的
    `arquillian` 容器集成（`arquillian-glassfish-embedded-3.1`）和 Java EE 容器，因为我们使用嵌入式模式（`glassfish-embedded-all`）。如果你计划使用它，别忘了添加
    ContiPerf 依赖项。
- en: JMeter and build integration
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JMeter 和构建集成
- en: We learned in a previous section that JMeter can be used to build scenarii you
    execute against your application. It can also be programmatically executed—it
    is Java-based, after all—or executed through some of its Maven integrations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们了解到 JMeter 可以用来构建针对你的应用程序执行的场景。它也可以通过编程方式执行——毕竟它是基于 Java 的——或者通过其
    Maven 集成之一执行。
- en: 'If you use its Maven plugin from lazerycode ([https://github.com/jmeter-maven-plugin/jmeter-maven-plugin](https://github.com/jmeter-maven-plugin/jmeter-maven-plugin)),
    you can even configure the remote mode to have real stress testing:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用其 Maven 插件来自 lazerycode ([https://github.com/jmeter-maven-plugin/jmeter-maven-plugin](https://github.com/jmeter-maven-plugin/jmeter-maven-plugin))，你甚至可以配置远程模式以进行真正的压力测试：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This snippet defines the `jmeter` plugin to use `jmeter1.company.com` and `jmeter2.company.com`
    for the load testing. Servers will be initialized and destroyed before/after running
    the plans.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段定义了 `jmeter` 插件使用 `jmeter1.company.com` 和 `jmeter2.company.com` 进行负载测试。服务器将在运行计划之前/之后初始化和销毁。
- en: Without entering into the deep details of the plugin—you can find them on the
    related GitHub wiki—the plugin uses configurations stored in the project in `src/test/jmeter`
    by default. This is where you can put your scenarii (`.jmx` files).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入插件的具体细节——你可以在相关的 GitHub wiki 上找到它们——该插件默认使用存储在项目中的 `src/test/jmeter` 中的配置。这就是你可以放置你的场景（`.jmx`
    文件）的地方。
- en: The challenge with this solution is to provide `jmeter[1,2].company.com` machines.
    Of course, you can create some machines and let them run, though, this is not
    a very good way to manage the AWS machines and it would be better to start them
    with the build  (allowing you to have concurrent builds, if needed, on multiple
    branches at the same time).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的挑战是提供 `jmeter[1,2].company.com` 机器。当然，你可以创建一些机器并让它们运行，尽管这样做并不是管理 AWS
    机器的好方法，而且最好是在构建过程中启动它们（允许你在多个分支上同时进行并发构建，如果需要的话）。
- en: There are several solutions for that need, but the simplest is probably to install
    on the CI platform an AWS client (or plugin) and launch it before/after the Maven
    builds the corresponding commands to provision the machine, set the machine hosts
    in a build property, and pass it to the Maven build. It requires you to variabilize
    the plugin configuration, but nothing fancy, as Maven supports placeholders and
    system property input. Nonetheless, running the tests from your machine can be
    hard as you will need to provision yourself with the machine you will use. Thus,
    this reduces the shareable side of the project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种需求，有几种解决方案，但最简单的方法可能是在一个 CI 平台上安装 AWS 客户端（或插件），并在 Maven 构建相应的命令来提供机器、设置机器主机为构建属性并将它传递给
    Maven 构建之前/之后启动它。这需要您对插件配置进行变量化，但不需要复杂，因为 Maven 支持占位符和系统属性输入。尽管如此，从您的机器上运行测试可能很困难，因为您需要为自己提供将要使用的机器。因此，这减少了项目的可共享性。
- en: Don't forget to ensure the task of shutting down the instance is always executed,
    even when the tests fail, or else you could leak some machines and have a billing
    surprise at the end of the month.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记确保关闭实例的任务始终被执行，即使测试失败，否则您可能会泄露一些机器，并在月底收到账单惊喜。
- en: 'Finally, as JMeter is a mainstream solution, you can easily find platforms
    supporting it natively and handling the infrastructure for you. The main ones
    are:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 JMeter 是一个主流解决方案，您可以轻松找到原生支持它并为您处理基础设施的平台。主要的有：
- en: BlazeMeter ([https://www.blazemeter.com/](https://www.blazemeter.com/))
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BlazeMeter ([https://www.blazemeter.com/](https://www.blazemeter.com/))
- en: Flood.IO ([https://flood.io/](https://flood.io/))
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flood.IO ([https://flood.io/](https://flood.io/))
- en: Redline.13 ([https://www.redline13.com/](https://www.redline13.com/))
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redline.13 ([https://www.redline13.com/](https://www.redline13.com/))
- en: Don't hesitate to have a look at their websites, their prices, and compare them
    to what you can build yourself directly with AWS if you don't have dedicated machines
    on your CI. This can allow you to solve the environment and infrastructure issues
    performance tests often encounter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 CI 上没有专用机器，不妨看看他们的网站、价格，并将它们与您直接使用 AWS 可以构建的内容进行比较。这可以帮助您解决性能测试经常遇到的环境和基础设施问题。
- en: Gatling and continuous integration
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gatling 和持续集成
- en: Like JMeter, Gatling has its own Maven plugin, but it also has some companion
    AWS integration ([https://github.com/electronicarts/gatling-aws-maven-plugin](https://github.com/electronicarts/gatling-aws-maven-plugin))
    natively integrated with Maven.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JMeter 类似，Gatling 有自己的 Maven 插件，但它还提供了一些 AWS 集成伴侣插件 ([https://github.com/electronicarts/gatling-aws-maven-plugin](https://github.com/electronicarts/gatling-aws-maven-plugin))，这些插件与
    Maven 本地集成。
- en: 'Here is what the official Gatling Maven plugin declaration can look like in
    your `pom.xml`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是官方 Gatling Maven 插件声明在您的 `pom.xml` 中的样子：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first plugin (1) defines how to run Gatling. The default configuration will
    look for simulations in `src/test/scala`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个插件（1）定义了如何运行 Gatling。默认配置将在 `src/test/scala` 中查找模拟。
- en: 'This setup will locally run your simulations. So, you will likely migrate to
    the non-official plugin, yet integrated with AWS, to be able to control the injectors.
    Here is what the declaration can look like:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置将在本地运行您的模拟。因此，您可能会迁移到非官方插件，但与 AWS 集成，以便能够控制注入器。以下是声明可能的样子：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This plugin will integrate Gatling on AWS. It requires some AWS configuration
    (like your keys), but you will generally configure them outside the `pom.xml` so
    as not to put your credentials in a public place—properties in a profile in your
    `settings.xml` is a good place to start. Here are the properties you will need
    to define:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件将在 AWS 上集成 Gatling。它需要一些 AWS 配置（如您的密钥），但您通常会在 `pom.xml` 之外配置它们，以免将凭证放在公共位置——在
    `settings.xml` 中的配置文件中的属性是一个好的开始。以下是您需要定义的属性：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Defining all these properties doesn't prevent you from changing the values through
    a system property. For instance, setting `-Dec2.instance.count=9` will allow you
    to change the number of injectors (nine instead of three). The first group of
    properties (ec2 ones) define how to create the AWS instances and how many to create.
    The second group (Gatling one) defines where Gatling is and how to run it. The
    third group defines the simulation to run. Finally, the last group (s3 one) defines
    where to upload the results of the test.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 定义所有这些属性并不能阻止你通过系统属性来更改它们的值。例如，设置 `-Dec2.instance.count=9` 将允许你更改注入器的数量（从三个变为九个）。第一组属性（ec2属性）定义了如何创建AWS实例以及创建多少个实例。第二组（Gatling属性）定义了Gatling的位置以及如何运行它。第三组定义了要运行的模拟。最后，最后一组（s3属性）定义了测试结果的上传位置。
- en: 'This configuration is not yet functional, as it is not yet self-sufficient:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置尚未启用，因为它尚未自给自足：
- en: It relies on Gatling distribution, which is not yet installed (`gatling.local.home`)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它依赖于尚未安装的Gatling发行版（`gatling.local.home`）
- en: It relies on a script we didn't create yet (`install-gatling.sh`)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它依赖于我们尚未创建的脚本（`install-gatling.sh`）
- en: 'To be able to not depend on a local Gatling installation, we can use Maven
    to download it. To do so, we just need the dependency plugin of Maven:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够不依赖于本地的Gatling安装，我们可以使用Maven来下载它。为此，我们只需要Maven的依赖插件：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This configuration will extract the Gatling distribution into the `target/gatling/gatling-charts-highcharts-bundle-2.2.4` folder
    and let the plugin use it when it runs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将Gatling发行版提取到`target/gatling/gatling-charts-highcharts-bundle-2.2.4`文件夹中，并在插件运行时使用它。
- en: 'For the script, you can use this one, which is for Fedora. However, it is easy
    to adapt to any distribution if you pick another image on EC2:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于脚本，你可以使用这个，它是为Fedora准备的。然而，如果你在EC2上选择另一个镜像，它很容易适应任何发行版：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This script does three main things:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本执行三个主要任务：
- en: Increases `ulimit` to make sure the injector can use enough file handlers and
    not be limited by the OS configuration
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加ulimit以确保注入器可以使用足够的文件处理器，而不会受到操作系统配置的限制
- en: Installs Java
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Java
- en: Downloads Gatling from Maven centra, extracts the archive (like we did with
    the previous Maven plugin), but on the injector machines which don't have to use
    Maven, and finally cleans up the extracted archive (removing sample simulations)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Maven中心下载Gatling，提取存档（就像我们使用之前的Maven插件所做的那样），但是在不需要使用Maven的注入器机器上，最后清理提取的存档（移除示例模拟）
- en: If you need any dependencies, you will need to create a shade (and use the default `jar-with-dependencies`
    as a classifier). You can do that using `maven-assembly-plugin` and the `single`
    goal.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要任何依赖项，你需要创建一个shade（并使用默认的`jar-with-dependencies`作为分类器）。你可以使用`maven-assembly-plugin`和`single`目标来实现这一点。
- en: Deploying your (benchmark) application
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署你的（基准）应用程序
- en: In the two previous sections, we learned how to handle the injectors, but you
    will also need to deploy the application to test, if possible, on a dedicated
    instance for the test. This doesn't mean you need to forget what we looked at
    in the previous chapter, such as ensuring the machine is used in production and
    other potentially impacting services are running. Instead, you must ensure the
    machine(s) does what you think it does and not something unexpected that will
    impact the figures/tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中，我们学习了如何处理注入器，但如果你可能的话，还需要将应用程序部署到测试专用的实例上进行测试。这并不意味着你需要忘记上一章中我们讨论的内容，例如确保机器在生产中使用，以及其他可能影响的服务正在运行。相反，你必须确保机器（们）做你所期望的事情，而不是一些意外的、会影响数据/测试的事情。
- en: Here, again, using cloud services to deploy your application can be the easiest
    solution. The simplest solution will likely rely on some cloud CLI (such as AWS
    CLI or `aws` command) or a small `main(String[])` you can write using the cloud
    provider client API or SDK.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，再次使用云服务来部署你的应用程序可能是最简单的解决方案。最简单的解决方案可能依赖于某些云CLI（例如AWS CLI或`aws`命令），或者你可以使用云提供商的客户端API或SDK编写的`main(String[])`。
- en: Depending on if you code the deployment yourself (or not), it will be more or
    less easy to integrate with the Maven (or Gradle) build. As part of your project,
    an `exec-maven-plugin` can enable you to integrate it exactly where you need to
    in the Maven life cycle. Most of the time, this will be done before the performance
    test but after test compilation, or even after packaging the application (if you
    keep the performance test in the same module, which is feasible).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您是否自己编写部署代码（或不是），与 Maven（或 Gradle）构建的集成将更容易或更难。作为您项目的一部分，`exec-maven-plugin`
    可以让您在 Maven 生命周期中精确地集成它。大多数情况下，这将在性能测试之前完成，但在测试编译之后，甚至在打包应用程序之后（如果您将性能测试保持在同一模块中，这是可行的）。
- en: 'If you don''t code the deployment yourself, you will need to define the stages
    of your performance build:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不自己编写部署代码，您将需要定义您的性能构建阶段：
- en: Compile/package the project and tests.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译/打包项目和测试。
- en: Deploy the application (and don't forget to reset the environment too if needed,
    including cleaning a database or JMS queue).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署应用程序（并且如果需要，别忘了重置环境，包括清理数据库或 JMS 队列）。
- en: Start the performance test.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始性能测试。
- en: Undeploy the application/shut down the created server (if relevant).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消部署应用程序/关闭创建的服务器（如果相关）。
- en: 'With Maven or Gradle, it is easy to skip some of the tasks, either with a flag
    or a profile, and consequently, you will end up with commands like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Maven 或 Gradle，很容易跳过一些任务，无论是通过标志还是配置文件，因此您最终可能会得到这样的命令：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first command, `(1)`, will build the full project but bypass the performance
    tests as we don't activate the `perf-tests` profile by default. The second command
    will deploy the application on the target environment using a custom implementation
    based on AWS SDK, for instance, potentially creating it from scratch. Don't forget
    to log what you do, even if you are waiting for something, or else you—or others
    —may think the process is hanging. Then, we run the performance test `(3)` and
    finally we undeploy the application with a command symmetric to `(2)`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令 `(1)` 将构建完整的项目，但绕过性能测试，因为我们默认没有激活 `perf-tests` 配置文件。第二个命令将使用基于 AWS SDK
    的自定义实现将应用程序部署到目标环境，例如，可能从头开始创建它。别忘了记录您所做的一切，即使您正在等待某事，否则您或其他人可能会认为进程挂起了。然后，我们运行性能测试
    `(3)`，最后我们使用与 `(2)` 对称的命令取消部署应用程序。
- en: With such a solution, you need to ensure `(4)` is executed as soon as `(2)`
    is executed. In general, you will enforce it to always be executed and handle
    a quick exit condition if the expected environment to destroy doesnt exist.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此类解决方案时，您需要确保 `(4)` 在 `(2)` 执行后立即执行。通常，您将强制执行它始终执行，并在预期环境不存在时处理快速退出条件。
- en: 'To orchestrate the steps, you can have a look at the Jenkins pipeline feature:
    it will give you a lot of flexibility to implement this type of logic in a straightforward
    manner.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要编排这些步骤，您可以查看 Jenkins 管道功能：它将为您提供很多灵活性，以直接方式实现此类逻辑。
- en: Going further overpasses the scope of this book, but to give you some pointers,
    the deployments can rely on Docker-based tools which makes it really easy to deploy
    on cloud platforms in general. Nevertheless, don't forget Docker is not a provisioning
    tool. And if your *recipe* (the steps for creating your instance) is not simple
    (installing software from the repository, copying/downloading your application,
    and starting it), then you can invest in a provisioning tool such as chef or puppet
    to be more flexible, powerful, and to avoid hacks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的内容超出了本书的范围，但为了给您一些提示，部署可以依赖于基于 Docker 的工具，这使得在云平台上部署变得非常容易。然而，别忘了 Docker
    不是一个配置工具。如果您的 *配方*（创建实例的步骤）不简单（从仓库安装软件、复制/下载您的应用程序并启动它），那么您可以考虑投资于 chef 或 puppet
    等配置工具，以获得更大的灵活性、更强的功能和避免黑客攻击。
- en: Continuous integration platform and performance
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成平台和性能
- en: Jenkins is the most commonly used continuous integration platform. There are
    alternatives, such as Travis, but the ecosystem of Jenkins and the easiness to
    extend it makes it the clear leader for Java and enterprises applications.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 是最常用的持续集成平台。虽然有一些替代品，如 Travis，但 Jenkins 的生态系统以及扩展的便捷性使其在 Java 和企业应用中成为明显的领导者。
- en: The first thing we want to solve on the build/test execution platform for performance
    is the isolation of the builds, the goal being obviously to ensure the obtained
    figures are not affected by other builds.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在性能构建/测试执行平台上想要解决的首要问题是构建的隔离，显然目标是确保获得的数字不受其他构建的影响。
- en: 'To do that, Jenkins provides several plugins:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，Jenkins 提供了几个插件：
- en: 'Amazon EC2 Container Service Plugin ([https://wiki.jenkins.io/display/JENKINS/Amazon+EC2+Container+Service+Plugin](https://wiki.jenkins.io/display/JENKINS/Amazon+EC2+Container+Service+Plugin)):
    Allows you to run the builds (tests) in a dedicated machine created based on a
    Docker image.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon EC2 容器服务插件 ([https://wiki.jenkins.io/display/JENKINS/Amazon+EC2+Container+Service+Plugin](https://wiki.jenkins.io/display/JENKINS/Amazon+EC2+Container+Service+Plugin)):
    允许您在基于 Docker 镜像创建的专用机器上运行构建（测试）。'
- en: 'Throttle Concurrent Build Plugin ([https://github.com/jenkinsci/throttle-concurrent-builds-plugin/blob/master/README.md](https://github.com/jenkinsci/throttle-concurrent-builds-plugin/blob/master/README.md)):
    Allows you to control how many concurrent builds can be executed per project.
    Concretely, for performance, we want to ensure it is one per project.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '限制并发构建插件 ([https://github.com/jenkinsci/throttle-concurrent-builds-plugin/blob/master/README.md](https://github.com/jenkinsci/throttle-concurrent-builds-plugin/blob/master/README.md)):
    允许您控制每个项目可以执行多少个并发构建。具体来说，为了性能，我们希望确保每个项目只有一个。'
- en: 'In terms of configuration, you will need to make sure the performance tests
    are executed with an accurate configuration:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置方面，您需要确保性能测试以准确的配置执行：
- en: Regularly, using Jenkins scheduling, but probably not each time there is a commit
    or a pull-request. Depending on the criticity, the stability of your project,
    and the duration of your performance tests, it can be once a day or once a week.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常使用 Jenkins 调度，但可能不是每次提交或拉取请求时都这样做。根据项目的关键性、稳定性和性能测试的持续时间，可能是每天一次或每周一次。
- en: The previous plugins—or equivalent—are in use and correctly configured.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前使用的插件或等效插件已正确配置。
- en: The build notifies the correct channels if they fail (mail, Slack, IRC, and
    so on).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果构建失败，它会通知正确的渠道（邮件、Slack、IRC 等）。
- en: 'It will also be important to ensure you store the history of the runs to be
    able to compare them, in particular if you don''t run the performance test with
    each commit, which would give you the exact commit, introducing a regression.
    To do that, you can use another Jenkins plugin which is exactly intended to store
    the history of common performance tools: the Performance Plugin ([https://wiki.jenkins.io/display/JENKINS/Performance+Plugin](https://wiki.jenkins.io/display/JENKINS/Performance+Plugin)).
    This plugin supports Gatling and JMeter, as well as a few other tools. It is a
    nice plugin, allowing you to visualize the reports directly from Jenkins, which
    is very handy when investigating some changes. What''s more, it is compatible
    with Jenkins pipeline scripts.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 确保存储运行历史记录以便进行比较也很重要，尤其是如果您不与每个提交一起运行性能测试，这将给出确切的提交，引入回归。为此，您可以使用另一个 Jenkins
    插件，该插件正是为了存储常见性能工具的历史记录：性能插件 ([https://wiki.jenkins.io/display/JENKINS/Performance+Plugin](https://wiki.jenkins.io/display/JENKINS/Performance+Plugin))。此插件支持
    Gatling 和 JMeter，以及一些其他工具。这是一个很好的插件，允许您直接从 Jenkins 可视化报告，这在调查某些更改时非常方便。更重要的是，它与
    Jenkins 管道脚本兼容。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through some common ways to ensure the performance
    of your application is under control and to limit the risk of getting unexpected
    bad surprises when you go into a benchmark phase, or worse, in production! Setting
    up simple tests or complete environments for a volatile (temporary) benchmark
    each week (or even each day) are very feasible steps, enabling a product to be
    delivered with a better quality level once the entry cost has been paid.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些确保您的应用程序性能处于控制之下并限制在进入基准测试阶段或更糟的生产阶段时遇到意外不良惊喜的风险的常见方法。每周（甚至每天）为波动（临时）基准测试设置简单的测试或完整的环境是非常可行的步骤，一旦支付了入门成本，就可以使产品以更高的质量水平交付。
- en: After having understood how Java EE instruments your application to let you
    focus on your business, how to monitor and instrument your application to optimize
    your application, and how to boost your application with some tuning or caching,
    we now know how to automatically control performance regressions to be able to
    fix them as soon as possible.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了如何使用 Java EE 仪器化您的应用程序以便您能专注于业务后，如何监控和仪器化您的应用程序以优化您的应用程序，以及如何通过一些调整或缓存来提升您的应用程序后，我们现在知道如何自动控制性能回归，以便能够尽快修复它们。
- en: As a result, you have now covered all the parts of product—or library—creation
    related to performance, and you are able to deliver highly performant software.
    You've got this!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您现在已经涵盖了与性能相关的所有产品或库创建部分，并且您能够交付高性能的软件。您做到了！
