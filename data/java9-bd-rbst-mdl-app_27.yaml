- en: Taking Notes with Monumentum
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Monumentum记笔记
- en: For our eighth project, we will again do something new--we'll build a web app.
    Whereas all of our other projects have been command lines, GUIs, or some combination
    thereof, this project will be a single module consisting of a REST API and a JavaScript
    frontend, all built with an eye toward the current microservice trend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第八个项目，我们又将做一些新的事情——我们将构建一个Web应用程序。与其他所有项目都是命令行、GUI或它们的某种组合不同，这个项目将是一个由一个REST
    API和一个JavaScript前端组成的单一模块，所有这些都是在关注当前的微服务趋势的情况下构建的。
- en: 'To build the application, you''ll learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建应用程序，你将学习以下主题：
- en: Some of the Java options to build microservice applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些用于构建微服务应用程序的Java选项
- en: Payara Micro and `microprofile.io`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Payara Micro和`microprofile.io`
- en: Java API for RESTful Web Services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java API for RESTful Web Services
- en: Document data stores and MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数据存储和MongoDB
- en: OAuth authentication (against Google, specifically)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth身份验证（针对Google，具体而言）
- en: '**JSON Web Tokens** (**JWT**)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON Web Tokens**（**JWT**）'
- en: As you can see, this will be, in many ways, a much different type of project
    than what we've looked at to this point.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这将是一个在很多方面与我们迄今为止所研究的项目截然不同的项目。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: Most of us have likely used some sort of note-taking application such as EverNote,
    OneNote, or Google Keep. They're an extremely handy way of jotting down notes
    and thoughts, and having them available from just about every environment imaginable--desktop,
    mobile, and web. In this chapter, we'll build a fairly basic clone of these industry
    giants in order to exercise a number of concepts. We will call this app Monumentum,
    which is Latin for a reminder or memorial, an apt name for this type of application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人可能都使用过某种笔记应用，如EverNote、OneNote或Google Keep。它们是记录笔记和想法的极其方便的方式，并且几乎可以在任何可想象的环境中访问——桌面、移动和网页。在本章中，我们将构建这些行业巨头的相当基础的克隆版，以便练习许多概念。我们将把这个应用命名为Monumentum，这是拉丁语中提醒或纪念的意思，对于这类应用来说是一个恰当的名字。
- en: 'Before we get into those, let''s take some time to list the requirements for
    our application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨这些之前，让我们花些时间列出我们应用程序的需求：
- en: Be able to create notes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建笔记
- en: Be able to list notes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够列出笔记
- en: Be able to edit notes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编辑笔记
- en: Be able to delete notes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够删除笔记
- en: Note bodies must be capable of storing/displaying rich text
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记内容必须能够存储/显示富文本
- en: Be able to create a user account
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建用户账户
- en: Must be able to log into the application using OAuth2 credentials against an
    existing system
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须能够使用OAuth2凭据登录到现有系统中的应用程序
- en: 'Our non-functional requirements are fairly modest:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的非功能性需求相当适度：
- en: Must have a RESTful API
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个RESTful API
- en: Must have an HTML 5/JavaScript frontend
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个HTML 5/JavaScript前端
- en: Must have a flexible, scalable data store
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个灵活、可扩展的数据存储
- en: Must be easily deployable on resource-constrained systems
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须能够在资源受限的系统上轻松部署
- en: Of course, this list of non-functional requirements was chosen in part because
    they reflect real-world requirements, but they also set us up very nicely to discuss
    some of the technologies I'd like to cover in this chapter. To cut to the chase,
    we'll create a web application that provides both a REST-based API and a JavaScript
    client. It will be backed by a document data store, and built using one of the
    many microservice libraries/frameworks available to the JVM.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个非功能性需求的列表部分是基于它们反映了现实世界的需求，但它们也为我们讨论我在本章中想涵盖的一些技术提供了很好的基础。直截了当地说，我们将创建一个提供基于REST的API和JavaScript客户端的Web应用程序。它将使用文档数据存储，并使用JVM上可用的许多微服务库/框架之一构建。
- en: So what does this stack look like? Let's take a quick survey of our options
    before we settle on a particular choice. Let's start with a look at the microservice
    frameworks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个堆栈看起来是什么样子呢？在我们确定一个特定的选择之前，让我们快速浏览一下我们的选项。让我们先看看微服务框架。
- en: Microservice frameworks on the JVM
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM上的微服务框架
- en: 'While I am reluctant to spend a great deal of time on what a microservice is
    given that most people are familiar with the topic at this point, I think it would
    be a remiss not to give at least a brief description in case you are not familiar
    with the idea. With that said, here is a nice, concise definition of microservice
    from SmartBear, a provider of software quality tools perhaps best known for their
    stewardship of the Swagger API and related libraries:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不愿意花太多时间在解释微服务是什么上，因为大多数人对此已经很熟悉了，但我认为如果不至少简要描述一下，可能会有些失职，以防你对这个概念不熟悉。话虽如此，以下是来自SmartBear（一个软件质量工具提供商，可能最出名的是他们维护Swagger
    API和相关库）的一个关于微服务的简洁定义：
- en: Essentially, microservice architecture is a method of developing software applications
    as a suite of independently deployable, small, modular services in which each
    service runs a unique process and communicates through a well-defined, lightweight
    mechanism to serve a business goal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，微服务架构是一种将软件应用程序作为一套独立可部署的、小型、模块化服务的方法，其中每个服务运行一个独特的进程，并通过一个定义良好、轻量级的机制进行通信，以实现业务目标。
- en: To put it another way, rather than the older, more established approach of bundling
    several related systems in one web application and deploying it to a large application
    server, such as GlassFish/Payara Server, Wildfly, WebLogic Server, or WebSphere,
    each of these systems would instead be run separately in their own JVM process.
    The benefits of this approach include easier, piecemeal upgrades, increased stability
    through process isolation, smaller resource requirements, greater machine utilization,
    and so on. The concept itself is not necessarily new, but it has certainly gained
    popularity in recent years, and continues to grow at a rapid pace.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，与将几个相关系统捆绑在一个Web应用程序中并部署到大型应用程序服务器（如GlassFish/Payara Server、Wildfly、WebLogic
    Server或WebSphere）的较旧、更成熟的方法相比，这些系统将分别在其自己的JVM进程中独立运行。这种方法的好处包括更容易的逐部分升级、通过进程隔离增加稳定性、更小的资源需求、更高的机器利用率等等。这个概念本身可能并不新颖，但它确实在近年来获得了流行，并且仍在以快速的速度增长。
- en: 'So what do our options look like on the JVM? We have several, including, in
    no particular order, the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在JVM上我们的选择有哪些呢？我们有很多选择，包括但不限于以下内容：
- en: '**Eclipse Vert.x**: This is officially *a tool-kit for building reactive applications
    on the JVM*. It provides an event-driven application framework that lends itself
    well to writing microservices. Vert.x can be used in a number of languages, including
    Java, Javascript, Kotlin, Ceylon, Scala, Groovy, and Ruby. More information can
    be found at [http://vertx.io/](http://vertx.io/).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse Vert.x**：这是一个官方的*在JVM上构建反应式应用程序的工具包*。它提供了一个事件驱动的应用程序框架，非常适合编写微服务。Vert.x可以使用多种语言，包括Java、JavaScript、Kotlin、Ceylon、Scala、Groovy和Ruby。更多信息可以在[http://vertx.io/](http://vertx.io/)找到。'
- en: '**Spring Boot**: This is a library to build stand alone Spring applications.
    Spring Boot applications have full access to the entire Spring ecosystem, and
    can be run using a single fat/uber JAR. Spring Boot lives at [https://projects.spring.io/spring-boot/](https://projects.spring.io/spring-boot/).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot**：这是一个用于构建独立Spring应用程序的库。Spring Boot应用程序可以完全访问整个Spring生态系统，并且可以使用单个fat/uber
    JAR运行。Spring Boot的网站是[https://projects.spring.io/spring-boot/](https://projects.spring.io/spring-boot/)。'
- en: '**Java EE MicroProfile**: This is a community and vendor-led effort to create
    a new profile for Java EE, specifically tailored to microservices. At the time
    of writing, the profile includes **Java API for RESTful Web Services** (**JAX-RS**),
    CDI, and JSON-P, and is sponsored by several companies including Tomitribe, Payara,
    Red Hat, Hazelcast, IBM, and Fujitsu, and user groups such as London Java Community
    and SouJava. The MicroProfile home page is [http://microprofile.io/](http://microprofile.io/).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java EE MicroProfile**：这是一个由社区和供应商领导的努力，旨在为Java EE创建一个新的配置文件，特别针对微服务。在撰写本文时，该配置文件包括**Java
    API for RESTful Web Services**（**JAX-RS**）、CDI和JSON-P，并由包括Tomitribe、Payara、Red
    Hat、Hazelcast、IBM和Fujitsu在内的多家公司以及如伦敦Java社区和SouJava等用户团体赞助。MicroProfile的主页是[http://microprofile.io/](http://microprofile.io/)。'
- en: '**Lagom**: This fairly new framework is a reactive microservices framework
    from Lightbend, the company behind Scala. It is described as an opinionated microservice
    framework, and is built using two of Lightbend''s more famous libraries--Akka
    and Play. Lagom applications can be written either in Java or Scala. More details
    can be found at [https://www.lightbend.com/platform/development/lagom-framework](https://www.lightbend.com/platform/development/lagom-framework).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lagom**：这是一个相对较新的框架，由Scala背后的公司Lightbend开发的响应式微服务框架。它被描述为一个有偏见的微服务框架，并使用Lightbend的两个更著名的库——Akka和Play构建。Lagom应用程序可以用Java或Scala编写。更多详细信息可以在[https://www.lightbend.com/platform/development/lagom-framework](https://www.lightbend.com/platform/development/lagom-framework)找到。'
- en: '**Dropwizard**: This is a Java framework to develop ops-friendly, high-performance,
    RESTful web services. It is a framework that offers Jetty for HTTP, Jersey for
    REST services, and Jackson for JSON. It also provides support for other libraries
    such as Guava, Hibernate Validator, Freemarker, and others. You can find Dropwizard
    at [http://www.dropwizard.io/](http://www.dropwizard.io/).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dropwizard**：这是一个用于开发操作友好、高性能、RESTful Web服务的Java框架。它提供了一个包含Jetty（用于HTTP）、Jersey（用于REST服务）和Jackson（用于JSON）的框架。它还支持其他库，如Guava、Hibernate
    Validator、Freemarker等。您可以在[http://www.dropwizard.io/](http://www.dropwizard.io/)找到Dropwizard。'
- en: There are a few other options, but it should be clear that, as JVM developers,
    we have a myriad of choices, which is almost always good. Since we can only build
    using one, I have chosen to use the MicroProfile. Specifically, we'll base our
    application on Payara Micro, Payara's implementation, which is based on the GlassFish
    sources (plus Payara's bug fixes, enhancements, and so on).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些选择，但应该很清楚，作为JVM开发者，我们有无数的选择，这几乎总是好的。由于我们只能使用一个，因此我选择了MicroProfile。具体来说，我们将基于Payara
    Micro，这是基于GlassFish源代码（加上Payara的bug修复、增强等）的实现。
- en: By choosing the MicroProfile and Payara Micro, we choose, implicitly, JAX-RS
    as the basis for our REST services. We are free, of course, to use whatever we
    want, but deviating from what the framework offers lessens the value of the framework
    itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择MicroProfile和Payara Micro，我们隐含地选择了JAX-RS作为我们REST服务的基石。当然，我们可以使用我们想要的任何东西，但偏离框架提供的功能会降低框架本身的价值。
- en: That leaves us with our choice of data store. One option we've already seen
    is the relational database. It is a tried and true choice that powers a wide swath
    of the industry. They are, however, not without their limitations and problems.
    While databases themselves can be complicated in terms of classifications and
    functionality, perhaps the most popular alternatives to relational databases are
    NoSQL databases. While these have existed for half a century, the idea had not
    gained any significant market traction until sometime in the last decade or so
    with the advent of **Web 2.0**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就让我们面临选择数据存储的问题。我们已经看到的一个选项是关系型数据库。这是一个经过考验且可靠的选项，为整个行业提供了广泛的支持。然而，它们并非没有局限性和问题。虽然数据库本身在分类和功能方面可能很复杂，但最流行的关系型数据库替代品可能是NoSQL数据库。尽管这些数据库已经存在了半个世纪，但直到大约十年前，随着**Web
    2.0**的出现，这一理念才在市场上获得了显著的影响力。
- en: While the term **NoSQL** is very broad, most examples of this type of database
    tend to be key-value, document, or graph data stores, each offering distinct performance
    and behavior characteristics. A full treatment of each type of NoSQL database
    and its various implementations is beyond the scope of this book, so, in the interest
    of time and space, we'll just get straight to our selection--MongoDB. Its scalability
    and flexibility, especially in regard to document schemas, meshes well with our
    target use case.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**NoSQL**这个术语非常广泛，但这类数据库的大多数例子往往是键值、文档或图数据存储，每种都提供独特的性能和行为特征。全面介绍每种NoSQL数据库及其各种实现超出了本书的范围，因此，为了节省时间和空间，我们将直接进入我们的选择——MongoDB。它在文档模式方面的可扩展性和灵活性非常适合我们的目标用例。
- en: Finally, on the client side, we have a myriad of options again. Among the most
    popular are ReactJS from Facebook and Angular from Google. There is a variety
    of other frameworks, including older options such as Knockout and Backbone, as
    well as newer ones such as Vue.js. It is this latter option that we'll use. Not
    only is it a very powerful and flexible option, it also presents the least amount
    of friction getting started. Since this book is focused on Java, I felt it prudent
    to select an option that will require the least amount of setup while meeting
    our needs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在客户端，我们又有许多选择。其中最受欢迎的是来自Facebook的ReactJS和来自Google的Angular。还有各种各样的其他框架，包括较老的选择，如Knockout和Backbone，以及较新的选择，如Vue.js。我们将使用后者。这不仅是一个非常强大和灵活的选择，而且它还提供了最少的启动摩擦。由于这本书专注于Java，我觉得选择一个在满足我们需求的同时设置最少的选项是明智的。
- en: Creating the application
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'To use Payara Micro, we create a Java web application like we normally would.
    In NetBeans, we will select File | New Project | Maven | Web Application and click
    on Next. For the project name, enter `monumentum`, select the appropriate Project
    Location, and fix up the Group ID and Package as desired:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Payara Micro，我们创建一个像平常一样的Java Web应用程序。在NetBeans中，我们将选择文件 | 新项目 | Maven |
    Web应用程序，然后点击下一步。对于项目名称，输入`monumentum`，选择适当的Project Location，并按需设置Group ID和Package：
- en: '![](img/c894fa8c-00bf-4de2-96ac-97152a4d040d.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c894fa8c-00bf-4de2-96ac-97152a4d040d.png)'
- en: 'The next window will ask us to choose a server, which we can leave blank, and
    a Java EE version, which we want to set to Java EE 7 Web:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个窗口将要求我们选择一个服务器，我们可以将其留空，并选择Java EE版本，我们希望将其设置为Java EE 7 Web：
- en: '![](img/3ec66cd8-47ee-46b0-926c-298c456cddf7.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ec66cd8-47ee-46b0-926c-298c456cddf7.png)'
- en: 'After a few moments, we should have our project created and ready to go. Since
    we created a Java EE 7 web application, NetBeans has already added the Java EE
    API dependency to the project. Before we jump into coding, let''s add Payara Micro
    to the build to get that part ready. To do that, we need to add a plugin to the
    build. That will look something like this (though we''ve only shown the highlights
    here):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们应该创建好项目并准备就绪。由于我们创建了一个Java EE 7 Web应用程序，NetBeans已经将Java EE API依赖项添加到了项目中。在我们开始编码之前，让我们将Payara
    Micro添加到构建中，以便准备好这部分。为此，我们需要向构建中添加一个插件。它看起来可能像这样（尽管我们在这里只展示了高亮部分）：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This sets up the Maven exec plugin, which is used to execute either an external
    application or, as we''ll do here, a Java application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了Maven exec插件，用于执行外部应用程序，或者像我们在这里要做的那样，执行Java应用程序：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we''re associating the execution of this plugin with Maven''s package
    phase. This means that when we run Maven to build our project, the plugin''s java
    goal will be run as Maven starts to package the project, allowing us to alter
    exactly what gets packaged in the JAR:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将此插件的执行与Maven的package阶段关联起来。这意味着当我们运行Maven来构建我们的项目时，插件的目标将在Maven开始打包项目时运行，这样我们就可以精确地改变JAR中包含的内容：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This last section configures the plugin. It will run the `PayaraMicro` class,
    passing the `--deploy <path> --outputUberJar ...` command. Effectively, we're
    telling Payara Micro how to run our application, but, rather than executing the
    package right now, we want it to create an uber JAR that will run the application
    later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后一部分配置了插件。它将运行`PayaraMicro`类，传递`--deploy <path> --outputUberJar ...`命令。实际上，我们正在告诉Payara
    Micro如何运行我们的应用程序，但我们不想立即执行包，而是希望它创建一个稍后运行的uber JAR。
- en: Typically, when you build your project, you get a jar file that contains only
    the classes and resources that are directly included in your project. Any external
    dependencies are left as something that the execution environment has to provide.
    With an uber JAR, all of the dependencies are included in our project's jar as
    well, which is then configured in such a way that the execution environment can
    find them as needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你构建你的项目时，你会得到一个只包含直接包含在你的项目中的类和资源的jar文件。任何外部依赖项都作为执行环境必须提供的东西留下。在uber JAR中，所有的依赖项都包含在我们的项目jar中，然后以这种方式配置，以便执行环境可以按需找到它们。
- en: 'The problem with the setup is that, left as is, when we build, we''ll get an
    uber JAR, but we won''t have any easy way to run the application from NetBeans.
    To fix that, we need a slightly different plugin configuration. Specifically,
    it needs these lines:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的问题在于，如果保持原样，当我们构建时，我们会得到一个uber JAR，但我们将没有简单的方法从NetBeans运行应用程序。为了解决这个问题，我们需要一个稍微不同的插件配置。具体来说，它需要这些行：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These replace the preceding `deploy` and `outputUberJar` options. To help speed
    up our builds, we also don''t want the uber JAR created until we ask for it, so
    we can separate these two plugin configurations into two separate profiles, as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项替换了先前的 `deploy` 和 `outputUberJar` 选项。为了加快我们的构建速度，我们也不希望在请求之前创建 uber JAR，因此我们可以将这些两个插件配置分别放入两个独立的配置文件中，如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we''re ready to build the deployment artifact, we activate the uber profile
    when we execute Maven, and we''ll get our executable jar:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备构建部署工件时，在执行 Maven 时激活 uber 配置文件，我们将得到可执行的 jar 文件：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `exploded-war` profile is the configuration that we''ll use from the IDE,
    which runs Payara Micro, pointing it at the exploded war in our build directory.
    To instruct NetBeans to use that, we need to modify a couple of action configurations.
    To do that, right-click on the project in NetBeans and select Properties from
    the bottom of the context menu. Under Actions, find Run Project and select it,
    then enter `exploded-war` under Activate Profiles:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`exploded-war` 配置文件是我们将在 IDE 中使用的配置，它运行 Payara Micro，指向我们构建目录中的展开的 war 文件。为了指导
    NetBeans 使用它，我们需要修改几个操作配置。为此，在 NetBeans 中右键单击项目，并从上下文菜单底部选择属性。在操作下，找到运行项目并选择它，然后在激活配置文件下输入
    `exploded-war`：'
- en: '![](img/6555e9a8-b1b4-4d90-aeaf-d5a687ea786a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6555e9a8-b1b4-4d90-aeaf-d5a687ea786a.png)'
- en: 'If we run the application now, NetBeans will complain because we haven''t selected
    a server. While this is a web application and those have typically needed a server,
    we''re using Payara Micro, so we don''t need an application server defined. Fortunately,
    NetBeans will let us tell it that, as demonstrated in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，NetBeans 会抱怨因为我们还没有选择服务器。虽然这是一个 Web 应用程序，通常需要服务器，但我们使用的是 Payara
    Micro，因此不需要定义应用程序服务器。幸运的是，NetBeans 会允许我们告诉它，如下面的截图所示：
- en: '![](img/8e5a2763-76d4-49ae-a724-cf30cd2fbb8e.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e5a2763-76d4-49ae-a724-cf30cd2fbb8e.png)'
- en: 'Select Ignore, I don''t want IDE managed deployment and click on OK, then watch
    the output window. You should see a fair amount of text scroll by, and after a
    few seconds, you should see text like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 选择忽略，我不想让 IDE 管理部署，然后点击确定，接着观察输出窗口。你应该会看到相当多的文本滚动过去，几秒钟后，你应该会看到类似这样的文本：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you see that, we're ready to test our application, such as it is at this
    point. In your browser, open `http://localhost:8080/monumentum-1.0-SNAPSHOT/index.html`
    and you should see a large and exciting *Hello World!* message on the page. If
    you see this, you have successfully bootstrapped a Payara Micro project. Take
    a moment to congratulate yourself, and then we'll make the application do something
    useful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦看到这一点，我们就准备好测试我们的应用程序，就像现在这样。在你的浏览器中打开 `http://localhost:8080/monumentum-1.0-SNAPSHOT/index.html`，你应该会在页面上看到一个大型且令人兴奋的
    *Hello World!* 消息。如果你看到这个，你就已经成功启动了一个 Payara Micro 项目。花点时间祝贺自己，然后我们将让应用程序做一些有用的事情。
- en: Creating REST Services
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 REST 服务
- en: This being basically a Java EE application, albeit one that it is packaged and
    deployed a bit differently, everything you may have learned about writing Java
    EE applications most likely still applies. Of course, you may not have ever written
    such an application, so we'll walk through the steps.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这基本上是一个 Java EE 应用程序，尽管它的打包和部署方式略有不同，但你可能学到的关于编写 Java EE 应用程序的大部分内容很可能仍然适用。当然，你可能从未编写过这样的应用程序，所以我们将一步步进行。
- en: 'REST applications in Java EE are written using JAX-RS, and our starting point
    for JAX-RS is an `Application`. The `Application` is a deployment-agnostic means
    for declaring root-level resources to the runtime. How the runtime finds the `Application`
    is, of course, dependent on the runtime itself. For a MicroProfile application
    like ours, we''ll be running in a Servlet 3.0 environment, so we need not do anything
    special, as Servlet 3.0 supports a descriptor-less deployment option. The runtime
    will scan for a class of type `Application` that is annotated with `@ApplicationPath`
    and uses that to configure the JAX-RS application, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 中编写的 REST 应用程序使用 JAX-RS，我们 JAX-RS 的起点是一个 `Application`。`Application`
    是一种与部署无关的声明根级资源给运行时的方法。运行时如何找到 `Application` 当然取决于运行时本身。对于像我们这样的 MicroProfile
    应用程序，我们将在 Servlet 3.0 环境中运行，所以我们不需要做任何特殊的事情，因为 Servlet 3.0 支持无描述符的部署选项。运行时将扫描带有
    `@ApplicationPath` 注解的 `Application` 类，并使用它来配置 JAX-RS 应用程序，如下所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the `@ApplicationPath` annotation, we specify the root URL of our application''s
    REST endpoints, which is, of course, relative to the web application''s root context
    itself. `Application` has three methods we can override, but we''re only interested
    in the one listed here: `getClasses()`. We''ll provide more details on this method
    shortly, but, for now, keep in mind that this is how we will describe to JAX-RS
    what our top-level resources are.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@ApplicationPath` 注解，我们指定应用程序 REST 端点的根 URL，这当然是相对于 Web 应用程序的根上下文。`Application`
    有三个我们可以覆盖的方法，但我们只对这里列出的一个感兴趣：`getClasses()`。我们将在稍后提供关于此方法的更多详细信息，但就目前而言，请记住这是我们向
    JAX-RS 描述顶级资源的方式。
- en: 'Monumentum will have a very simple API, with the primary endpoint being that
    to interact with notes. To create that endpoint, we create a simple Java class
    and mark it up with the appropriate JAX-RS annotations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Monumentum 将有一个非常简单的 API，主要端点是用于与笔记交互。为了创建这个端点，我们创建一个简单的 Java 类，并用适当的 JAX-RS
    注解标记它：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this class, we're describing an endpoint that will live at `/api/notes`
    and will produce JSON results. JAX-RS supports, for example, XML, but most REST
    developers are accustomed to JSON and are expecting nothing else, so we need not
    support anything other than JSON. The needs of your application may vary, of course,
    so you can adjust the list of supported media types as needed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类，我们正在描述一个将位于 `/api/notes` 的端点，并将产生 JSON 结果。JAX-RS 支持，例如，XML，但大多数 REST 开发者习惯于
    JSON，并期望没有其他内容，所以我们不需要支持除 JSON 之外的内容。当然，您应用程序的需求可能会有所不同，因此您可以根据需要调整支持的媒体类型列表。
- en: 'While this will compile and run, and JAX-RS will attempt to handle requests
    to our endpoint, we haven''t actually defined it yet. To do that, we need to add
    some methods to our endpoint that will define the inputs and outputs of the endpoint,
    as well as the HTTP verb/method we''ll use. Let''s start with the notes collection
    endpoint:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这将编译并运行，JAX-RS 将尝试处理对端点的请求，但我们还没有实际定义它。为了做到这一点，我们需要向端点添加一些方法来定义端点的输入和输出，以及我们将使用的
    HTTP 动词/方法。让我们从笔记集合端点开始：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have an endpoint that answers `GET` requests at `/api/notes` and returns
    a `List` of `Note` instances. There is some debate among REST developers on the
    proper return from methods like these. There are some who prefer to return the
    actual type the client will see, for example `List<Note>` in our case, as it makes
    it clear to developers reading the source, or documentation generated from it.
    Others prefer, as we've done here, to return a JAX-RS `Response` object, as that
    gives greater control over the response, including HTTP headers, status code,
    and more. I tend to prefer this second approach as we've done here. You, of course,
    are free to use either approach.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个端点，它回答 `/api/notes` 的 `GET` 请求，并返回 `Note` 实例的 `List`。在 REST 开发者中，关于这些方法的正确返回值有一些争议。有些人更喜欢返回客户端将看到的实际类型，例如我们案例中的
    `List<Note>`，因为它使阅读源代码的开发者或由此生成的文档更清楚。其他人，像我们在这里所做的那样，更喜欢返回 JAX-RS `Response`
    对象，因为它提供了对响应的更多控制，包括 HTTP 标头、状态码等。我倾向于更喜欢这种第二种方法，就像我们在这里所做的那样。当然，您当然可以自由选择使用任何一种方法。
- en: 'One last thing to note here is the way in which we build the response body:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是我们构建响应体的方式：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Typically, at runtime, the parameterized type of the List is lost due to type
    erasure. Using a `GenericEntity` like this allows us to capture the parameterized
    type, allowing the runtime to marshal the data. Using this allows us to avoid
    writing our own `MessageBodyWriter`. Less code is almost always a good thing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在运行时，由于类型擦除，List 的参数化类型会丢失。使用像这样的 `GenericEntity` 允许我们捕获参数化类型，从而使运行时能够序列化数据。使用这允许我们避免编写自己的
    `MessageBodyWriter`。代码越少几乎总是好事。
- en: 'If we run our application now, we''ll get the following response, albeit a
    very boring one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用程序，我们将得到以下响应，尽管它非常无聊：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's both satisfying, and it's not, but it does demonstrate that we're on
    the right track. Clearly, we want that endpoint to return data, but we have no
    way of adding a note, so let's fix that now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这既令人满意，又并非如此，但它确实表明我们正在正确的轨道上。显然，我们希望这个端点返回数据，但我们没有添加注释的方法，所以现在让我们解决这个问题。
- en: 'Creating a new entity via REST is accomplished by POSTing a new entity to its
    collection. That method looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 REST 创建新实体是通过将其 POST 到其集合来完成的。该方法看起来像这样：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@POST` annotation indicates the use of the HTTP POST verb. The method takes
    a `Note` instance, and returns a `Response` as we saw in the preceding code. Notice
    that we don't deal with JSON directly. By specifying a `Note` in the method signature,
    we can take advantage of one of JAX-RS's great features--POJO mapping. We've already
    seen a hint of it in the previous code with `GenericEntity`. JAX-RS will attempt
    to unmarshal--that is, convert from a serialized form to a model object--the JSON
    request body. If the client sends a JSON object in the correct format, we get
    a usable `Note` instance. If the client sends an improperly built object, it gets
    a response. This feature allows us to deal solely with our domain objects and
    not worry about JSON encoding and decoding, which can save considerable time and
    energy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`@POST`注解表示使用HTTP POST动词。该方法接受一个`Note`实例，并返回一个`Response`，正如我们在前面的代码中所看到的。注意，我们没有直接处理JSON。通过在方法签名中指定`Note`，我们可以利用JAX-RS的一个伟大特性--POJO映射。我们在之前的代码中已经看到了它的一个暗示，即`GenericEntity`。JAX-RS将尝试反序列化--即，将序列化形式转换为模型对象--JSON请求体。如果客户端发送了正确格式的JSON对象，我们将得到一个可用的`Note`实例。如果客户端发送了一个构建不当的对象，它将得到一个响应。这个特性允许我们只处理我们的领域对象，而不必担心JSON编码和解码，这可以节省大量的时间和精力。'
- en: Adding MongoDB
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加MongoDB
- en: 'In the body of the method, we get our first glimpse of the integration with
    MongoDB. To make this compile, we need to add a dependency on the MongoDB Java
    Driver:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法体中，我们首次看到了与MongoDB的集成。为了使这个编译成功，我们需要添加对MongoDB Java Driver的依赖：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'MongoDB deals with documents, so we need to convert our domain model to a `Document`,
    which we accomplish via a method on our model class. We haven''t looked at the
    details of the `Note` class, so let''s do that now:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB处理文档，因此我们需要将我们的领域模型转换为`Document`，这是通过我们的模型类上的一个方法来实现的。我们还没有查看`Note`类的细节，所以现在让我们看看：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is mostly just a normal POJO. We have added a constructor and an instance
    method to handle converting to and from MongoDB's `Document` type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上只是一个普通的POJO。我们添加了一个构造函数和一个实例方法来处理转换为和从MongoDB的`Document`类型。
- en: There are a couple of things to call out here. The first is how the ID of the
    MongoDB `Document` is handled. Every document stored in a MongoDB database gets
    `_id` assigned to it. In the Java API, this `_id` is represented as `ObjectId`.
    We don't want that detail exposed in our domain model, so we convert it to a `String`
    and back again.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。第一个是如何处理MongoDB `Document`的ID。存储在MongoDB数据库中的每个文档都会被分配一个`_id`。在Java
    API中，这个`_id`被表示为`ObjectId`。我们不希望这个细节暴露在我们的领域模型中，所以我们将其转换为`String`然后再转换回来。
- en: 'We also need to do some special handling for our date fields. We''ve chosen
    to represent the `created` and `modified` properties as `LocalDateTime` instances
    since the new date/time API is superior to the old `java.util.Date`. Unfortunately,
    the MongoDB Java Driver does not yet support Java 8, so we need to handle the
    conversion ourselves. We''ll store these dates as strings and convert them as
    needed. That conversion is handled via the `LocalDateTimeAdapter` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对我们日期字段进行一些特殊处理。我们选择将`created`和`modified`属性表示为`LocalDateTime`实例，因为新的日期/时间API比旧的`java.util.Date`更优越。不幸的是，MongoDB
    Java Driver目前还不支持Java 8，因此我们需要自己处理转换。我们将这些日期存储为字符串，并在需要时进行转换。这种转换是通过`LocalDateTimeAdapter`类来处理的：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is probably a bit more complicated than you might expect, and that's because
    it's doing more than we've discussed so far. The usage we're looking at now, that
    from our model class, is not this class' primary purpose, but we'll get to that
    in a moment. That aside, the class' behavior is pretty straightforward--take a
    `String`, determine which of the two supported formats it represents, and convert
    it to a `LocalDateTime`. It also goes the other way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比你预期的要复杂一些，这是因为它所做的不仅仅是我们在之前讨论过的。我们现在正在查看的使用，即从我们的模型类中，并不是这个类的首要目的，但我们会稍后讨论这一点。除了这一点，类的行为相当简单--接受一个`String`，确定它代表的是两种支持格式中的哪一种，并将其转换为`LocalDateTime`。它也可以反过来操作。
- en: This class' primary purpose is for JAX-RS' use. When we pass `Note` instances
    across the wire, `LocalDateTime` needs to be unmarshalled as well, and we can
    tell JAX-RS how to do this via an `XmlAdapter`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的主要目的是为了JAX-RS的使用。当我们通过线传递`Note`实例时，`LocalDateTime`也需要进行反序列化，我们可以通过一个`XmlAdapter`告诉JAX-RS如何进行这一操作。
- en: 'With the class defined, we need to tell JAX-RS about it. We can do that in
    a couple of different ways. We could use an annotation on each property in our
    model like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义好后，我们需要告诉 JAX-RS 关于它。我们可以通过几种不同的方式做到这一点。我们可以在模型中的每个属性上使用注解，如下所示：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While this works, it''s a fairly large annotation, as far as these kinds of
    things go, and you have to put this on every `LocalDateTime` property. If you
    have several models with fields of this type, you will have to touch each property.
    Fortunately, there''s a way to associate the type with the adapter once. We can
    do that in a special Java file called `package-info.java`. Most people have never
    heard of this file, and even fewer use it, but it is simply a place for package-level
    documentation and annotations. It is this latter use case that interests us. In
    the package for our model class, create `package-info.java` and put this in it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可行，但就这类事情而言，这是一个相当大的注解，你必须将它放在每个 `LocalDateTime` 属性上。如果你有多个具有此类字段的模型，你将不得不触摸每个属性。幸运的是，有一种方法可以将类型与适配器关联一次。我们可以在一个特殊的
    Java 文件 `package_info.java` 中做到这一点。大多数人从未听说过这个文件，甚至更少的人使用它，但它只是一个用于包级文档和注解的地方。正是这个后者的用例引起了我们的兴趣。在我们的模型类包中创建
    `package_info.java` 并将其放入其中：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have the same annotation we saw in the preceding code, but it's wrapped in
    `@XmlJavaTypeAdapters`. The JVM allows only annotation of a given type on an element,
    so this wrapper allows us to work around that limitation. We also need to specify
    the type parameter on the `@XmlJavaTypeAdapter` annotation since it is no longer
    on the target property. With this in place, every `LocalDateTime` property will
    be handled correctly without any additional work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有前面代码中看到的相同注解，但它被 `@XmlJavaTypeAdapters` 包装。JVM 只允许在元素上注解特定类型，因此这个包装器允许我们绕过这个限制。我们还需要在
    `@XmlJavaTypeAdapter` 注解上指定类型参数，因为它不再在目标属性上。有了这个，每个 `LocalDateTime` 属性都将被正确处理，而无需任何额外的工作。
- en: 'That''s quite a bit of setup, but we''re still not quite ready. We have everything
    set up on the REST side. We now need to get the MongoDB classes in place. To connect
    to a MongoDB instance, we start with a `MongoClient`. From the `MongoClient`,
    we then acquire a reference to a `MongoDatabase` from which we get a `MongoCollection`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要相当多的设置，但我们仍然还没有完全准备好。我们在 REST 侧已经设置了一切。现在我们需要将 MongoDB 类放在适当的位置。要连接到 MongoDB
    实例，我们从一个 `MongoClient` 开始。然后从 `MongoClient` 获取一个 `MongoDatabase` 的引用，从而得到一个 `MongoCollection`：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `@PostConstruct` method runs on the bean after the constructor has run.
    In this method, we initialize our various MongoDB classes and store them in instance
    variables. With these classes ready, we can revisit, for example, `getAll()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostConstruct` 方法在构造函数运行之后在 Bean 上运行。在这个方法中，我们初始化我们的各种 MongoDB 类并将它们存储在实例变量中。有了这些类就绪，我们可以重新访问，例如，`getAll()`：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now query the database for our notes, and with the implementation of
    `createNote()` shown in the preceding code, we can create the following notes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查询数据库中的笔记，并且根据前面代码中展示的 `createNote()` 实现，我们可以创建以下笔记：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For this to work on your machine, you'll need an instance of MongoDB running.
    You can download an installer appropriate for your operating system as well as
    find installation instructions on the MongoDB website ([https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的机器上使这可行，你需要一个正在运行的 MongoDB 实例。你可以下载适用于你的操作系统的安装程序，也可以在 MongoDB 网站上找到安装说明（[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)）。
- en: Before we move on to the other resource methods, let's take one last look at
    our MongoDB API instances. While instantiating the instances like we have works,
    it also puts a fair amount of work on the resource itself. Ideally, we should
    be able to move those concerns elsewhere and inject the instances. Hopefully,
    this sounds familiar to you, as this is exactly the type of concern that **dependency
    injection** (**DI**) or **inversion of control** (**IoC**) frameworks were created
    to solve.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续探讨其他资源方法之前，让我们最后再看看我们的 MongoDB API 实例。虽然像我们这样实例化实例是可行的，但它也给资源本身带来了一定的工作量。理想情况下，我们应该能够将这些关注点移至其他地方并注入实例。希望这对你来说很熟悉，因为这正是**依赖注入（DI**）或**控制反转（IoC**）框架被创建来解决的问题。
- en: Dependency injection with CDI
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CDI 进行依赖注入
- en: 'Java EE provides a framework such as CDI. With CDI, we can inject any container-controlled
    object into another with compile-time type safety. The problem, though, is the
    objects in question need to be container controlled, which our MongoDB API objects
    are not. Fortunately, CDI provides a means by which the container can create these
    instances, a facility known as producer methods. What might this look like? Let''s
    start with the injection point, as that is the simplest piece:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE提供了一个框架，如CDI。使用CDI，我们可以以编译时类型安全的方式将任何容器控制的对象注入到另一个对象中。然而，问题在于相关的对象需要是容器控制的，而我们的MongoDB
    API对象不是。幸运的是，CDI提供了一种方法，容器可以通过这种方法创建这些实例，这种设施被称为生产者方法。这会是什么样子呢？让我们从注入点开始，因为这是最简单的部分：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the CDI container sees `@Inject`, it inspects the element the annotation
    is on to determine the type. It will then attempt to look up an instance that
    will satisfy the injection request. If there is more than one, the injection would
    typically fail. Although, we have used a qualifier annotation to help CDI determine
    what to inject. That annotation is defined like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当CDI容器看到`@Inject`时，它会检查注解所在的元素以确定类型。然后它将尝试查找一个可以满足注入请求的实例。如果有多个，注入通常会失败。尽管我们使用了限定符注解来帮助CDI确定要注入的内容。这个注解的定义如下：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this annotation, we can pass hints to the container that will help it
    select an instance for injection. As we''ve mentioned, `MongoCollection` is not
    container-managed, so we need to fix that, which we do via the following producer
    method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个注解，我们可以向容器传递提示，帮助它选择注入的实例。正如我们提到的，`MongoCollection`不是容器管理的，因此我们需要修复这个问题，我们通过以下生产者方法来完成：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `@Produces` method tells CDI that this method will produce instances needed
    by the container. CDI determines the type of the injectable instance from the
    method signature. We also place the qualifier annotation on the method as an additional
    hint to the runtime as it tries to resolve our injection request.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Produces`方法告诉CDI此方法将产生容器需要的实例。CDI从方法签名中确定可注入实例的类型。我们还把限定符注解放在方法上，作为对运行时的额外提示，当它尝试解决我们的注入请求时。'
- en: In the method itself, we add `InjectionPoint` to the method signature. When
    CDI calls this method, it will provide an instance of this class, from which we
    can get information about each particular injection point as they are processed.
    From `InjectionPoint`, we get the `Collection` instance from which we can get
    the name of the MongoDB collection we're interested in. We are now ready to get
    the `MongoCollection` instance we saw earlier. The `MongoClient` and `MongoDatabase`
    instantiation is handled internally in the class and is not changed significantly
    from our earlier usage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法本身中，我们在方法签名中添加`InjectionPoint`。当CDI调用此方法时，它将提供一个此类实例，我们可以从中获取每个特定注入点的信息，在它们被处理时。从`InjectionPoint`，我们获取`Collection`实例，从中我们可以获取我们感兴趣的MongoDB集合的名称。我们现在已经准备好获取之前看到的`MongoCollection`实例。`MongoClient`和`MongoDatabase`的实例化是在类内部处理的，并且与我们之前的用法没有显著变化。
- en: There is one small setup step for CDI. In order to avoid potentially expensive
    classpath scanning by the CDI container, we need to tell the system that we want
    the CDI turned on, so to speak. To do that, we need a `beans.xml` file, which
    can either be full of CDI configuration elements, or completely empty, which is
    what we'll do. For Java EE web applications, `beans.xml` needs to be in the `WEB-INF`
    directory, so we create the file in `src/main/webapp/WEB-INF`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CDI有一个小的设置步骤。为了避免CDI容器进行可能昂贵的类路径扫描，我们需要告诉系统我们希望启用CDI，换句话说。为了做到这一点，我们需要一个`beans.xml`文件，它可以包含CDI配置元素，也可以完全为空，这就是我们将要做的。对于Java
    EE Web应用程序，`beans.xml`需要放在`WEB-INF`目录中，所以我们创建文件在`src/main/webapp/WEB-INF`。
- en: Make sure that the file is truly empty. If there's even a blank line, Weld,
    Payara's CDI implementation, will attempt to parse the file, giving you an XML
    parsing error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文件确实是空的。即使只有一行空白，Weld，Payara的CDI实现，也会尝试解析文件，导致XML解析错误。
- en: Finish the notes resource
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成笔记资源
- en: 'Before we can move on from the `Note` resource, we need to finish up a few
    operations, namely, read, update, and delete. Reading a single note is very straightforward:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以从`Note`资源继续前进之前，我们需要完成一些操作，即读取、更新和删除。读取单个笔记非常简单：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've specified the use of the HTTP verb `GET` as we've already seen, but we
    have an additional annotation on this method, `@Path`. Using this annotation,
    we tell JAX-RS that this endpoint has additional path segments that the request
    needs to be matched against. In this case, we specify one additional segment,
    but we've wrapped it in curly braces. Without those braces, the match would be
    a literal match, that is to say, "Does this URL have the string 'id' on the end?"
    With the braces, though, we're telling JAX-RS that we want to match the additional
    segment, but its contents can be anything, and we want to capture that value and
    give it the name `id`. In our method signature, we instruct JAX-RS to inject the
    value via the `@PathParam` annotation, giving us access to the user-specified
    `Note` ID in our method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了使用HTTP动词`GET`，正如我们之前看到的，但我们对这个方法有一个额外的注解，`@Path`。使用这个注解，我们告诉JAX-RS这个端点有额外的路径段，请求需要与之匹配。在这种情况下，我们指定了一个额外的段，但我们将其括在花括号中。如果没有这些括号，匹配将是字面匹配，也就是说，“这个URL的末尾是否有字符串'id'？”然而，通过使用花括号，我们告诉JAX-RS我们想要匹配额外的段，但它的内容可以是任何东西，我们想要捕获这个值并将其命名为`id`。在我们的方法签名中，我们指示JAX-RS通过`@PathParam`注解注入值，这样我们就可以在我们的方法中访问用户指定的`Note`
    ID。
- en: 'To retrieve the note from MongoDB, we get our first real glimpse of how one
    queries MongoDB:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从MongoDB检索笔记，我们第一次真正了解了如何查询MongoDB：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In a nutshell, pass `BasicDBObject` to the `find()` method on `collection`,
    which returns a `FindIterable<?>` object, on which we call `first()` to get what
    should be the only element returned (assuming there is one, of course). The interesting
    bits here are hidden in `buildQueryById()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，将`BasicDBObject`传递给`collection`上的`find()`方法，该方法返回一个`FindIterable<?>`对象，然后我们调用`first()`来获取应该返回的唯一元素（当然，假设有一个）。这里有趣的部分隐藏在`buildQueryById()`中：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our query filter is defined using this `BasicDBObject`, which we initialize
    with a key and value. In this case, we want to filter by the `_id` field in the
    document, so we use that as a key, but note that we pass `ObjectId` as the value,
    and not just `String`. If we want to filter by more fields, we would append more
    key/value pairs to the `BasicDBObject` variable, which we will see later.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的查询过滤器使用这个`BasicDBObject`定义，我们用键和值初始化它。在这种情况下，我们想要根据文档中的`_id`字段进行过滤，所以我们使用它作为键，但请注意，我们传递的是`ObjectId`作为值，而不是简单的`String`。如果我们想要根据更多字段进行过滤，我们将向`BasicDBObject`变量追加更多的键/值对，我们将在后面看到。
- en: Once we've queried the collection and gotten the document the user requested,
    we convert it from `Document` to `Note` using the helper method on `Note`, and
    return it with a status code of 200 or `OK`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们查询了集合并获取了用户请求的文档，我们就使用`Note`上的辅助方法将其从`Document`转换为`Note`，并以状态码200或`OK`返回它。
- en: 'Updating a document in the database is a bit more complicated, but not excessively
    so, as you can see here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中更新文档稍微复杂一些，但并不过分，如下所示：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first thing to notice is the HTTP method--`PUT`. There is some debate on
    what verb to use for updates. Some, such as Dropbox and Facebook, say `POST`,
    while others, such as Google (depending on which API you look at), say `PUT`.
    I would contend that the choice is largely up to you. Just be consistent in your
    choice. We will be completely replacing the entity on the server with what the
    client passes in, so the operation is idempotent. By choosing `PUT`, we can signal
    this fact to the client, making the API a bit more self-describing for clients.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是HTTP方法--`PUT`。关于更新应该使用什么动词有一些争议。有些人，如Dropbox和Facebook，说`POST`，而其他人，如Google（取决于你查看哪个API），说`PUT`。我会争辩说，选择在很大程度上取决于你。只要保持一致性。我们将完全用客户端传递的内容替换服务器上的实体，因此操作是幂等的。通过选择`PUT`，我们可以向客户端发出这个信号，使API对客户端来说更具自描述性。
- en: Inside the method, we start by setting the modified date to reflect the operation.
    Next, we call `Collection.updateOne()` to modify the document. The syntax is a
    little odd, but here's what's happening--we're querying the collection for the
    note we want to modify, then telling MongoDB to replace the loaded document with
    the new one we're providing. Finally, we query `UpdateResult` to see how many
    documents were updated. If none were, then the requested document doesn't exist,
    so we return `NOT_FOUND` (`404`). If it's non-zero, we return `OK` (`200`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们首先将修改日期设置为反映操作。接下来，我们调用`Collection.updateOne()`来修改文档。语法有点奇怪，但这是在发生的——我们在查询集合以获取我们想要修改的笔记，然后告诉MongoDB用我们提供的新的文档替换加载的文档。最后，我们查询`UpdateResult`以查看更新了多少个文档。如果没有，则表示请求的文档不存在，因此我们返回`NOT_FOUND`（`404`）。如果它是非零的，我们返回`OK`（`200`）。
- en: 'Finally, our delete method looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的删除方法看起来是这样的：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We tell MongoDB to filter the collection using the same query filter we've seen
    before, then delete one document, which should be all it finds, of course, given
    our filter, but `deleteOne()` is a sensible safeguard. We could do a check like
    we did above in `updateNote()` to see if something was actually deleted, but there's
    little point--whether the document was there at the start of the request or not,
    it's not there at the end and that's our goal, so there's little to be gained
    from returning an error response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉MongoDB使用我们之前看到的相同查询过滤器来过滤集合，然后删除一个文档，当然，考虑到我们的过滤器，它应该只找到这一个，但`deleteOne()`是一个合理的防护措施。我们可以在`updateNote()`中做像上面那样的检查，看看是否真的有东西被删除了，但几乎没有意义——无论文档在请求开始时是否存在，它最终都不存在，这就是我们的目标，所以返回错误响应几乎没有收获。
- en: We can now create, read, update, and delete notes, but the eagle-eyed among
    you may have noticed that anyone can read every note in the system. For a multi-user
    system, that's not a good thing, so let's fix that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建、读取、更新和删除笔记，但那些细心的你可能已经注意到，任何人都可以读取系统中的每一篇笔记。对于多用户系统来说，这并不是一个好事情，所以让我们来修复这个问题。
- en: Adding authentication
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加身份验证
- en: Authentication systems can easily get extremely complex. From homegrown systems,
    complete with custom user management screens, to sophisticated single sign-on
    solutions, we have a lot of options. One of the more popular options is OAuth2,
    and there are a number of options. For Monumentum, we'll implement sign in using
    Google. To do that, we need to create an application in Google's Developer Console,
    which can be found at [https://console.developers.google.com](https://console.developers.google.com).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证系统可以很容易地变得极其复杂。从自建系统，包括定制的用户管理屏幕，到复杂的单点登录解决方案，我们有大量的选择。其中更受欢迎的选项之一是OAuth2，有许多选择。对于Monumentum，我们将使用Google进行登录。为此，我们需要在Google开发者控制台中创建一个应用程序，该控制台位于[https://console.developers.google.com](https://console.developers.google.com)。
- en: 'Once you''ve logged in, click on the project dropdown at the top of page and
    click on Create Project, which should present this screen to you:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，点击页面顶部的项目下拉菜单，然后点击创建项目，这将显示此屏幕给你：
- en: '![](img/0b47b3bc-b9b4-459b-b9eb-89daf802242d.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b47b3bc-b9b4-459b-b9eb-89daf802242d.png)'
- en: 'Provide Project Name, make your choices for the next two questions, then click
    on CREATE. Once the project has been created, you should be redirected to the
    Library page. Click on the Credentials link on the left, then click on Create
    credentials and select OAuth Client ID. If needed, fill out the OAuth Consent
    screen as directed. Select Web Application for Application Type, enter Name, and
    provide Authorized redirect URIs as shown in this screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提供项目名称，然后为接下来的两个问题做出选择，然后点击创建。一旦项目创建完成，你应该会被重定向到库页面。点击左侧的凭据链接，然后点击创建凭据并选择OAuth客户端ID。如有需要，按照指示填写OAuth同意屏幕。选择Web应用程序作为应用程序类型，输入名称，并提供如截图所示的授权重定向URI：
- en: '![](img/dd5f9e8d-fedf-476c-bcf6-c0b60e913720.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd5f9e8d-fedf-476c-bcf6-c0b60e913720.png)'
- en: 'Before this is moved to production, we will need to add a production URI to
    this screen, but this configuration will work in development just fine. When you
    click on Save, you will be shown your new client ID and client secret. Make note
    of these:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此内容移至生产环境之前，我们需要向此屏幕添加一个生产URI，但此配置在开发环境中运行良好。当你点击保存时，你会看到你的新客户端ID和客户端密钥。请注意这些信息：
- en: '![](img/38a25359-1dc1-4c80-acfc-ccd9054bf5f9.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38a25359-1dc1-4c80-acfc-ccd9054bf5f9.png)'
- en: 'With this data (note that these are not my actual ID and secret, so you''ll
    have to generate your own), we are ready to start working on our authentication
    resource. We''ll start by defining the resource as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些数据（注意，这些不是我的实际ID和密钥，所以您需要生成自己的），我们就可以开始处理我们的认证资源了。我们将首先定义资源如下：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We need to register this in our `Application`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`Application`中注册此操作，如下所示：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To work with the Google OAuth provider, we''ll need to declare a few instance
    variables and instantiate a few Google API classes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Google OAuth提供者一起工作，我们需要声明一些实例变量并实例化一些Google API类：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The variables `clientId` and `clientSecret` will hold the values that Google
    just gave us. The other two classes are necessary for the process we''re about
    to walk through, and `SCOPES` holds the permissions we want from Google, which
    is just access to the user''s profile and email. The class constructor finishes
    the setup of these items:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`clientId`和`clientSecret`将保存Google刚刚给出的值。其他两个类对于我们将要执行的过程是必要的，而`SCOPES`保存了我们希望从Google获得的权限，即访问用户的个人资料和电子邮件。类构造函数完成这些项的设置：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first part of the authentication flow is to create an authentication URL,
    which is done like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 认证流程的第一部分是创建一个认证URL，其创建方式如下：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using the JAX-RS class, `UriInfo`, we create a `URI` that points to another
    endpoint in our application, `/api/auth/callback`. We then pass that to `GoogleAuthorizationCodeFlow`
    to finish building our login URL. When the user clicks on the link, the browser
    will be directed to a login dialog from Google. Upon successful authentication,
    the user will be redirected to our callback URL, which is handled by this method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JAX-RS类`UriInfo`，我们创建一个指向我们应用程序中另一个端点的`URI`，即`/api/auth/callback`。然后我们将它传递给`GoogleAuthorizationCodeFlow`以完成登录URL的构建。当用户点击链接时，浏览器将被导向Google的登录对话框。在成功认证后，用户将被重定向到我们的回调URL，该URL由此方法处理：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When Google redirects to our `callback` endpoint, it will provide a code that
    we can use to finish the authentication. We do that in the `getUserInfoJson()`
    method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当Google重定向到我们的`callback`端点时，它将提供一个代码，我们可以使用它来完成认证。我们在`getUserInfoJson()`方法中这样做：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using the authentication code we just got from Google, we send another request
    to Google, this time to get the user information. When the request returns, we
    take the JSON object in the response body and use it to build a `User` object,
    which we return.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们从Google刚刚获得的认证代码，我们向Google发送另一个请求，这次是为了获取用户信息。当请求返回时，我们取响应体中的JSON对象，并使用它来构建一个`User`对象，然后返回。
- en: 'Back in our REST endpoint method, we call this method to save the user to the
    database, if needed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的REST端点方法中，我们调用此方法以在需要时将用户保存到数据库中：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once we've gotten the user's information from Google, we no longer need the
    code as we do not need to interact with any other Google resources, so we do not
    persist it anywhere.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从Google获得了用户信息，我们就不再需要代码，因为我们不需要与任何其他Google资源交互，所以我们不会将其持久化。
- en: Finally, we want to return something to the client --some kind of token -- which
    can be used to prove the client's identity. To do that, we'll use a technology
    called a JSON Web Token, or JWT for short. JWT is *a JSON-based open standard
    (RFC 7519) for creating access tokens that assert some number of claims*. We'll
    create a JWT using the user's email address. We'll sign it with a key only the
    server uses, so we can safely pass it to the client, which will pass it back with
    each request. Since it must be encrypted/signed with the server key, untrustworthy
    clients will not be able to alter or forge the token successfully.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望向客户端返回一些东西——某种类型的令牌——可以用来证明客户端的身份。为此，我们将使用一种名为JSON Web Token（JWT）的技术，简称JWT。JWT是一种基于JSON的开放标准（RFC
    7519），用于创建断言一定数量声明的访问令牌。我们将使用用户的电子邮件地址创建一个JWT。我们将使用只有服务器使用的密钥对其进行签名，这样我们就可以安全地将它传递给客户端，客户端将在每次请求时将其传递回来。由于它必须使用服务器密钥进行加密/签名，不可信的客户端将无法成功修改或伪造令牌。
- en: 'To create JWTs, we need to add the library to our project as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建JWT，我们需要将库添加到我们的项目中，如下所示：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can then write this method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写此方法：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The subject of the token is the email address, our API''s base address is the
    issuer, the expiration date and time is 12 hours in the future, and the token
    is signed by a key we generate with a new class, `KeyGenerator`. When we call
    `compact()`, a URL-safe String is generated, which we return to the caller. We
    can use the JWT debugger at [http://jwt.io](http://jwt.io/) to look inside the
    token:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的主题是电子邮件地址，我们API的基本地址是发行者，过期日期和时间是未来的12小时，令牌由我们使用新类`KeyGenerator`生成的密钥签名。当我们调用`compact()`时，会生成一个URL安全的字符串，我们将其返回给调用者。我们可以使用[http://jwt.io](http://jwt.io/)上的JWT调试器来查看令牌内部：
- en: '![](img/2dbc46c7-26b5-4130-b8e1-3608c342acf1.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2dbc46c7-26b5-4130-b8e1-3608c342acf1.png)'
- en: Clearly, the claims in the token are readable, so don't store anything sensitive
    in them. What makes this secure is the use of a secret key when signing the token,
    making it impossible, in theory, to change its contents without detection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，令牌中的声明是可读的，所以不要在其中存储任何敏感信息。使这变得安全的是在签名令牌时使用秘密密钥，从理论上讲，没有检测到的情况下不可能更改其内容。
- en: 'The `KeyGenerator` class used to give us our signing key looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 用于给我们签名密钥的`KeyGenerator`类看起来像这样：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The class is annotated with `@Singleton`, so the container guarantees that one
    and only one instance of this bean will exist in the system. The `getKey()` method
    will use the system property `signing.key` as the key, allowing the user to specify
    a unique secret when starting the system. Of course, completely random keys are
    safer, but that adds some complexity should we ever try to scale this system out
    horizontally. We would need all instances to use the same signing key so that
    JWTs can be validated regardless of what server the client is directed to. A data
    grid solution, such as Hazelcast, would be an appropriate tool for those situations.
    As it is now, this is sufficient for our needs here.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该类被注解为`@Singleton`，因此容器保证系统中只存在一个此bean的实例。`getKey()`方法将使用系统属性`signing.key`作为密钥，允许用户在启动系统时指定一个唯一的秘密。当然，完全随机的密钥更安全，但如果我们试图水平扩展此系统，这会增加一些复杂性。我们需要所有实例使用相同的签名密钥，以便无论客户端被导向哪个服务器，JWT都可以被验证。在这种情况下，Hazelcast这样的数据网格解决方案将是一个合适的工具。就目前而言，这已经足够满足我们的需求了。
- en: Our authentication resource is now complete, but our system has not actually
    been secured yet. To do that, we need to tell JAX-RS how to authenticate requests,
    and we'll do that with a new annotation and `ContainerRequestFilter`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的认证资源现在已经完成，但我们的系统实际上还没有被保护。为了做到这一点，我们需要告诉JAX-RS如何认证请求，我们将使用一个新的注解和`ContainerRequestFilter`来实现。
- en: 'If we were to install a request filter with no additional information, it would
    apply to every resource, including our authentication resource. That would mean
    we''d have to authenticate in order to authenticate. Clearly that doesn''t make
    sense, so we need a way to discriminate between requests so that only requests
    for certain resources have this filter applied, and that means a new annotation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们安装一个没有额外信息的请求过滤器，它将应用于每个资源，包括我们的认证资源。这意味着我们必须先进行认证才能进行认证。显然，这没有意义，因此我们需要一种方法来区分请求，以便只有对某些资源的请求应用此过滤器，这意味着需要一个新注解：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ve defined an annotation that is semantically meaningful. The `@NameBinding`
    annotation tells JAX-RS to apply the annotation only to certain resources, which
    are bound by name (as opposed to dynamically bound at runtime). With the annotation
    defined, we need to define the other side of things, the request filter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个语义上有意义的注解。`@NameBinding`注解告诉JAX-RS只将注解应用于某些资源，这些资源通过名称绑定（而不是在运行时动态绑定）。注解定义后，我们需要定义事物的另一面，即请求过滤器：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We start by defining a class that implements the `ContainerRequestFilter` interface.
    We have to annotate it with `@Provider` so that JAX-RS will recognize and load
    the class. We apply the `@Secure` annotation to associate the filter with the
    annotation. We'll apply this to the resource in a moment. Finally, we apply the
    `@Priority` annotation to instruct the system that this filter should be applied
    earlier in the request cycle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个实现`ContainerRequestFilter`接口的类。我们必须用`@Provider`注解它，以便JAX-RS能够识别和加载该类。我们将`@Secure`注解应用于将过滤器与注解关联。我们将在稍后将其应用于资源。最后，我们应用`@Priority`注解来指示系统，此过滤器应在请求周期中较早应用。
- en: 'Inside the filter, we inject the same `KeyGenerator` we looked at earlier.
    Since this is a singleton, we are guaranteed that the key used here and in the
    authentication method are the same. The only method on the interface is `filter()`,
    and in this method, we get the Authorization header from the request, extract
    the Bearer token, which is the JWT, and validate it using the JWT API. If we can
    decode and validate the token, then we know the user has successfully authenticated
    against the system. To tell the system about this new filter, we need to modify
    our JAX-RS `Application` as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤器内部，我们注入了之前查看过的相同 `KeyGenerator`。由于这是一个单例，我们保证这里使用的密钥和认证方法中使用的密钥是相同的。接口上唯一的方法是
    `filter()`，在这个方法中，我们从请求中获取授权头，提取出 JWT 的 Bearer 令牌，并使用 JWT API 进行验证。如果我们能够解码并验证令牌，那么我们知道用户已经成功对系统进行了认证。为了告诉系统这个新的过滤器，我们需要修改我们的
    JAX-RS `Application` 如下：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The system knows about the filter now, but before it will do anything, we need
    to apply it to the resources that we want to secure. We do that by applying the
    `@Secure` annotation to the appropriate resources. It can either be applied at
    class level, which means that every endpoint in the class will be secured, or
    at the resource method level, which means that only those particular endpoints
    will be secured. In our case, we want every `Note` endpoint secured, so put the
    following annotation on the class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 系统现在知道了过滤器，但在它做任何事情之前，我们需要将其应用于我们想要保护的资源。我们通过将 `@Secure` 注解应用于适当的资源来实现这一点。它可以在类级别应用，这意味着类中的每个端点都将被保护，或者可以在资源方法级别应用，这意味着只有那些特定的端点将被保护。在我们的情况下，我们希望每个
    `Note` 端点都被保护，所以将以下注解放在类上：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Just a few more steps, and our application will be secured. We need to make
    some modifications to `NoteResource` so that it knows who is logged in, and so
    that notes are associated with the authenticated user. We will start by injecting
    `User`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 只需再走几步，我们的应用程序就会变得安全。我们需要对 `NoteResource` 进行一些修改，以便它知道谁登录了，并且使笔记与认证用户相关联。我们将从注入
    `User` 开始：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is obviously not a container-managed class, so we need to write another
    `Producer` method. There''s a small bit of work to do there, so we''ll wrap that
    in its own class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是一个容器管理的类，因此我们需要编写另一个 `Producer` 方法。那里有一些工作要做，所以我们将它封装在自己的类中：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We define this as a request-scoped CDI bean, and inject our `KeyGenerator`,
    the `HttpServletRequest`, and our users collection. The actual work is done in
    the `Producer` method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其定义为请求范围的 CDI 实例，并注入我们的 `KeyGenerator`、`HttpServletRequest` 和我们的用户集合。实际的工作是在
    `Producer` 方法中完成的：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using the Servlet request, we retrieve the `AUTHORIZATION` header. If it''s
    present and contains the `Bearer` string, we can process the token. If that condition
    is not true, we return null. To process the token, we extract the token value
    from the header, and then have `Jwts` parse the claims for us, which returns an
    object of type `Jws<Claims>`. We build the user in the `getUser()` method as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Servlet 请求，我们检索 `AUTHORIZATION` 头。如果它存在并且包含 `Bearer` 字符串，我们可以处理令牌。如果该条件不成立，我们返回
    null。要处理令牌，我们从头中提取令牌值，然后让 `Jwts` 为我们解析声明，它返回一个类型为 `Jws<Claims>` 的对象。我们在 `getUser()`
    方法中按照以下方式构建用户：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With the claims parsed, we can extract the subject and use it to query our `Users`
    collection, returning either the `User` if it is found, or `null` if not.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 解析了声明后，我们可以提取主题并使用它来查询我们的 `Users` 集合，如果找到则返回 `User`，如果没有找到则返回 `null`。
- en: 'Back in our `NoteResource`, we need to modify our resource methods to be `User-aware`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `NoteResource`，我们需要修改我们的资源方法以使其 `User-aware`：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We now have a complete and secured REST API. Other than a command-line tool
    like curl, we don't have any nice way to use it, so let's build a user interface.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完整且安全的 REST API。除了像 curl 这样的命令行工具外，我们没有其他很好的方式来使用它，所以让我们构建一个用户界面。
- en: Building the user interface
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: 'For a UI, we have a number of options. We''ve already looked at JavaFX and
    the NetBeans RCP in this book. While those are great options, we''ll do something
    a little different for this app and build a web-based interface. Even here, we
    have many, many options: JSF, Spring MVC, Google Web Toolkit, Vaadin, and more.
    Oftentimes, in real-world applications, while we may have a Java backend, we may
    have a JavaScript frontend, so that''s what we''ll do here, and that''s where
    your choices can get really dizzying.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UI，我们有多种选择。在这本书中，我们已经探讨了JavaFX和NetBeans RCP。虽然这些是很好的选择，但我们将为这个应用做一些不同的处理，并构建一个基于Web的界面。即使在这里，我们也有许多、许多选项：JSF、Spring
    MVC、Google Web Toolkit、Vaadin等等。在现实世界的应用中，虽然我们可能有Java后端，但我们可能有JavaScript前端，所以这就是我们将要做的，这也是你的选择变得非常令人眼花缭乱的地方。
- en: The two biggest players in that market at the time of the writing of this book
    are React from Facebook and Angular from Google. There are several smaller contenders,
    such as React API-compatible Preact, VueJS, Backbone, Ember, and so on. Which
    you choose will have a significant impact on the application, everything from
    architecture to the more mundane things such as building the project itself, or
    you could let architecture drive the framework if there's a compelling need for
    a specific architecture. As always, your particular environment will vary and
    should drive that decision more than what you read in a book or online.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书撰写时，该市场的两大主要玩家是来自Facebook的React和来自Google的Angular。还有一些较小的竞争者，例如与React API兼容的Preact、VueJS、Backbone、Ember等等。你的选择将对应用产生重大影响，从架构到更琐碎的事情，比如构建项目本身，或者如果你有强烈的特定架构需求，你也可以让架构驱动框架。一如既往，你的特定环境将有所不同，并且应该比你在书中或在线上读到的内容更能驱动这个决定。
- en: Since this is a Java book, and I'd like to avoid getting too far into the intimate
    details of JavaScript build systems and alternate **JavaScript VM** languages,
    transpiling, and so on, I've chosen to use Vue, as it is a fast, modern, and popular
    framework that meets our needs, yet still allows us to build a simple system without
    requiring complicated build configurations. If you have experience with, or a
    preference for, another framework, it should be fairly simple for you to build
    a comparable system using the framework of your choice.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本Java书，并且我想避免深入探讨JavaScript构建系统和替代**JavaScript虚拟机**语言、转译等亲密细节，我选择使用Vue，因为它是一个快速、现代且流行的框架，满足我们的需求，同时仍然允许我们构建一个简单的系统，无需复杂的构建配置。如果你有使用其他框架的经验或偏好，你应该能够相当简单地使用你选择的框架构建一个类似的系统。
- en: Note that I am *not* a JavaScript developer. The application we'll build in
    this part of the chapter should not be construed to be an example of best practices.
    It is merely an attempt to build a usable, albeit plain, JavaScript frontend to
    demonstrate a full stack application. Please consult the documentation for Vue
    or your framework of choice for details on how to build idiomatic applications
    with the tool.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我**不是**一个JavaScript开发者。在本章的这一部分，我们将构建的应用不应被视为最佳实践的例子。这仅仅是一个尝试构建一个可用、尽管简单的JavaScript前端，以展示全栈应用。请查阅Vue或你选择的框架的文档，了解如何使用该工具构建惯用应用的相关细节。
- en: 'Let''s start with the index page. In the project explorer window in NetBeans,
    expand the Other Sources node, right-click on the webapp node, and select New
    | Empty File, giving it the name `index.html`. The bare minimum we need in the
    file at this point is the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从索引页开始。在NetBeans的项目资源管理器窗口中，展开“其他源”节点，右键单击“webapp”节点，选择“新建 | 空文件”，将其命名为`index.html`。目前文件中我们需要的最基本内容如下：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will display a blank page at the moment, but it does import the source
    for Vue, as well as the JavaScript for our client app, `index.js`, which we need
    to create:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这会显示一个空白页，但它确实导入了Vue的源代码，以及我们客户端应用的JavaScript，即`index.js`，我们需要创建它：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we deploy those changes (HINT: If the app is already running, just press
    *F11* to tell NetBeans to build; that won''t make any Java changes take effect,
    but it will copy these static resources to the output directory) and refresh the
    page in the browser, we should now see *Hello, World!* on the page.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们部署这些更改（提示：如果应用已经运行，只需按*F11*键告诉NetBeans构建；这不会使任何Java更改生效，但它会将这些静态资源复制到输出目录），并在浏览器中刷新页面，我们现在应该能在页面上看到*Hello,
    World!*。
- en: 'Roughly put, what''s happening is that we''re creating a new `Vue` object,
    anchoring to the (`el`) element with the `app` ID. We''re also defining some state
    for this component (`data`), which includes the single property, `message`. On
    the page, anywhere inside the element `app`, we can access the component''s state
    using the Mustache syntax we see in the index page--`{{ message }}`. Let''s expand
    our component a bit:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，所发生的事情是我们正在创建一个新的 `Vue` 对象，将其锚定到具有 `app` ID 的 (`el`) 元素。我们还在定义此组件的一些状态（`data`），其中包括单个属性
    `message`。在页面上，`app` 元素内部的任何位置，我们可以使用我们在首页中看到的 Mustache 语法访问组件的状态--`{{ message
    }}`。让我们扩展一下我们的组件：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ve added three items here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了三项：
- en: We've introduced a global data store, aptly called `store`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们引入了一个全局数据存储，恰当地命名为 `store`
- en: We've added a new property called `isLoggedIn`, which gets its value from a
    method call
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `isLoggedIn` 的新属性，它从方法调用中获取其值
- en: We've added a lifecycle method, `created`, which will load `Note` from the server
    when the component is created on the page
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个生命周期方法 `created`，当组件在页面上创建时，将从服务器加载 `Note`
- en: 'Our data store is based on Vuex, a state-management pattern + library for `Vue.js`
    applications. It serves as a centralized store for all the components in an application,
    with rules ensuring that the state can only be mutated in a predictable fashion.
    ([https://vuex.vuejs.org](https://vuex.vuejs.org/)). To add it to our application,
    we need to add the following line of code to our page:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据存储基于 Vuex，这是一个为 `Vue.js` 应用程序提供状态管理模式和库。它作为应用程序中所有组件的集中存储，有规则确保状态只能以可预测的方式变异。([https://vuex.vuejs.org](https://vuex.vuejs.org/))。要将它添加到我们的应用程序中，我们需要在我们的页面中添加以下代码行：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then add a field called `store` to our component, which you can see in the
    preceding code. Most of the work so far takes place in the `NotesActions` object:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在组件中添加了一个名为 `store` 的字段，您可以在前面的代码中看到。到目前为止的大部分工作都在 `NotesActions` 对象中完成：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When the page loads, the application will immediately send a request to the
    backend for Notes, sending the bearer token, if there is one, in the `Authorization`
    header. When the response returns, we update the state of the `isLoggedIn` property
    in the store, and, if the request was successful, we update the list of `Notes`
    on the page. Note that we're using `fetch()`. That is the new, experimental API
    for sending XHR, or Ajax, requests in browsers. As of the writing of this book,
    it is supported in every major browser except Internet Explorer, so be careful
    using this in production apps if you can't dictate the client's browser.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，应用程序将立即向后端发送 Notes 的请求，如果有的话，在 `Authorization` 头部发送 bearer 令牌。当响应返回时，我们更新商店中
    `isLoggedIn` 属性的状态，如果请求成功，我们更新页面上的 `Notes` 列表。请注意，我们正在使用 `fetch()`。这是在浏览器中发送 XHR
    或 Ajax 请求的新实验性 API。截至本书编写时，它被所有主要浏览器支持，除了 Internet Explorer，所以如果您不能控制客户端的浏览器，请小心在生产应用程序中使用此功能。
- en: 'We''ve seen the store used a few times, so let''s take a look at it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到商店被使用了几次，所以让我们来看看它：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The store is of type `Vuex.Store`, and we specify the various state fields
    in its `state` property. Handled properly, any Vue component bound to one of these
    state fields is automatically updated for you. You don''t need to track and manage
    state, manually reflecting changes on the page as the application state changes.
    Vue and Vuex handle that for you. Mostly. There are some situations, such as array
    mutation (or replacement), that require some special handling. Vuex offers **mutations**
    to help with that. For example, `NotesAction.fetchNotes()`, upon a successful
    request, we will make this call:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该商店的类型为 `Vuex.Store`，我们在其 `state` 属性中指定了各种状态字段。如果处理得当，任何绑定到这些状态字段之一的 Vue 组件都会自动为您更新。您不需要跟踪和管理状态，手动在页面反映应用状态的变化。Vue
    和 Vuex 会为您处理这些。大多数情况下是这样的。有些情况，例如数组变异（或替换），需要一些特殊处理。Vuex 提供了 **mutations** 来帮助处理这种情况。例如，`NotesAction.fetchNotes()`
    在请求成功后，我们将执行以下调用：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code tells the store to `commit` a mutation called `setNotes`,
    with `notes` as the payload. We define mutations like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码告诉商店提交一个名为 `setNotes` 的变异，其中 `notes` 作为负载。我们像这样定义变异：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: What we are passing into this mutation (you can probably think of this as a
    function or a method with a peculiar invocation syntax if that helps) is a JSON
    array (hopefully, we show no type checking here), so we start by clearing out
    the current list of notes, then iterating over this array, creating and storing
    new objects, and reformatting some of the data as we do so. Strictly using only
    this mutation to replace the set of notes, we can guarantee that the user interface
    is kept in sync with the changing state of the application, all for free.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给这个突变的（如果你这样想有助于理解，可以将其视为具有奇特调用语法的函数或方法）是一个 JSON 数组（希望这里没有类型检查），所以我们首先清除当前的笔记列表，然后迭代这个数组，创建和存储新的对象，并在这样做的同时重新格式化一些数据。严格地仅使用这个突变来替换笔记集，我们可以保证用户界面与应用程序状态的变化保持同步，这一切都是免费的。
- en: 'So how are these notes displayed? To do that, we define a new Vue component
    and add it to the page, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些笔记是如何显示的呢？为了做到这一点，我们定义一个新的 Vue 组件并将其添加到页面上，如下所示：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we''ve referenced a new component called `note-list`. We''ve bound the
    template variable `notes` to the application variable of the same name, and specified
    that the component is only displayed if the user is logged. The actual component
    definition happens in JavaScript. Back in `index.js`, we have this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引用了一个名为 `note-list` 的新组件。我们将模板变量 `notes` 绑定到同名应用程序变量上，并指定只有当用户登录时才显示该组件。实际的组件定义发生在
    JavaScript 中。回到 `index.js`，我们有如下代码：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This component is named `note-list`; its template is found in an element with
    the `note-list-template` ID; it has two computed values: `notes` and `isLoggedIn`;
    and it provides two methods. In a typical Vue application, we would have a number
    of files, all ultimately compiled together using something like Grunt or Gulp,
    and one of these files would be our component''s template. Since we are trying
    to make this as simple as possible by avoiding the JS build processes, we have
    everything declared right on our page. In `index.html`, we can find the template
    for our component:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件被命名为 `note-list`；其模板位于具有 `note-list-template` ID 的元素中；它有两个计算值：`notes` 和
    `isLoggedIn`；并且提供了两个方法。在一个典型的 Vue 应用程序中，我们会有许多文件，所有这些文件最终都会使用类似 Grunt 或 Gulp 之类的工具一起编译，其中一个文件就是我们的组件模板。由于我们试图通过避免
    JS 构建过程来使这一切尽可能简单，所以我们直接在我们的页面上声明了一切。在 `index.html` 中，我们可以找到我们组件的模板：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using a `script` tag with with the `text/x-template` type, we can add the template
    to the DOM without it rendering on the page. Inside this template, the interesting
    part is the `div` tag with the `note-list` class. We have the `v-` attribute on
    it, which means the Vue template processor will iterate over the `notes` list
    using this `div` as a template for displaying each `note` in the array.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有 `text/x-template` 类型的 `script` 标签，我们可以在不将其渲染到页面上时将模板添加到 DOM 中。在这个模板中，有趣的部分是具有
    `note-list` 类的 `div` 标签。我们在这个标签上有一个 `v-` 属性，这意味着 Vue 模板处理器将使用这个 `div` 作为模板来迭代
    `notes` 列表，并显示数组中的每个 `note`。
- en: Each note will be rendered using the `span` tag. Using the template markup `:title`,
    we are able to create a value for the title tag using our application state (we
    can't say because string interpolation was deprecated in Vue 2.0). The sole child
    of the `span` tag is the `{{ note.title }}` expression, which renders the title
    of the `note` list as a string. When the user clicks on the note title on the
    page, we want to react to that, so we bind the `onClick` handler to the DOM element
    via `v-on:click`. The function referenced here is the `loadNote()` function that
    we defined in the `methods` block of our component definition.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个笔记都将使用 `span` 标签进行渲染。通过使用模板标记 `:title`，我们能够使用我们的应用程序状态创建一个标题标签的值（我们无法说因为字符串插值在
    Vue 2.0 中已被弃用）。`span` 标签的唯一子元素是 `{{ note.title }}` 表达式，它将 `note` 列表的标题作为字符串渲染。当用户在页面上点击笔记标题时，我们希望对此做出反应，因此我们将
    `onClick` 处理程序绑定到 DOM 元素上，通过 `v-on:click`。这里引用的函数是我们定义在组件定义的 `methods` 块中的 `loadNote()`
    函数。
- en: 'The `loadNote()` function calls a mutation we haven''t looked at yet:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadNote()` 函数调用了一个我们尚未查看的突变：'
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This mutation modifies the state to reflect the note that the user clicked
    on, then fires (or emits) an event called `note-clicked`. The event system is
    really quite simple. It is set up like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种突变修改了状态以反映用户点击的笔记，然后触发（或发出）一个名为 `note-clicked` 的事件。事件系统实际上非常简单。它被设置为如下：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That's literally it. This is just a bare bones, globally scoped Vue component.
    We fire events by calling `bus.$emit()` method, and register event listeners by
    calling the `bus.$on()` method. We'll see what that looks like in the note form.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这只是一个基础、全局范围的 Vue 组件。我们通过调用 `bus.$emit()` 方法来触发事件，并通过调用 `bus.$on()` 方法来注册事件监听器。我们将在笔记形式中看到它的样子。
- en: 'We will add the note form component to the page like we did the `note-list`
    component:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像添加 `note-list` 组件一样将笔记表单组件添加到页面：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And, again, the component is defined in `index.js` as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，组件是在 `index.js` 中定义的，如下所示：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The template is also in `index.html`, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 模板也位于 `index.html` 中，如下所示：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is mostly normal HTML form. The interesting bit is the v-model that ties
    the form element to the component's property. Changes made on the form are automatically
    reflected in the component, and changes made in the component (for example, via
    an event handler) are automatically reflected in the UI. We also attach an `onClick`
    handler via the now familiar `v-on:click` attribute.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一个正常的 HTML 表单。有趣的部分是 v-model 将表单元素绑定到组件的属性。在表单上所做的更改将自动反映在组件中，而在组件中（例如，通过事件处理器）所做的更改将自动反映在
    UI 中。我们还通过熟悉的 `v-on:click` 属性附加了一个 `onClick` 处理器。
- en: 'Did you notice the reference to `CKEDITOR` in our component definition? We''ll
    use the rich text editor `CKEditor` to provide a better experience. We could go
    to `CKEditor` and download the distribution bundle, but we have a better way--WebJars.
    The WebJars project takes popular client-side web libraries and packages them
    as JARs. This makes adding supported libraries to the project very simple:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了我们组件定义中关于 `CKEDITOR` 的引用吗？我们将使用富文本编辑器 `CKEditor` 来提供更好的体验。我们可以去 `CKEditor`
    下载发行版包，但我们有更好的方法--WebJars。WebJars 项目将流行的客户端 Web 库打包成 JAR 文件。这使得将支持的库添加到项目中变得非常简单：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When we package the application, this binary jar is added to the web archive.
    However, if it''s still archived, how do we access the resources? There are a
    number of options depending on the type of application you are building. We''ll
    make use of Servlet 3''s static resource handling (anything under `META-INF/resources`
    that''s packaged in the web application''s `lib` directory are automatically exposed).
    In `index.html`, we add `CKEditor` to the page with this simple line:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打包应用程序时，这个二进制 jar 文件会被添加到 Web 归档中。然而，如果它仍然被归档，我们如何访问资源呢？这取决于你正在构建的应用程序类型，有多种选择。我们将利用
    Servlet 3 的静态资源处理功能（任何打包在 Web 应用程序的 `lib` 目录下的 `META-INF/resources` 下的内容都会自动暴露）。在
    `index.html` 中，我们通过以下简单行将 `CKEditor` 添加到页面：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`CKEditor` is now ready to use.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`CKEditor` 现在已准备好使用。'
- en: 'One last major piece on the frontend is enabling the user to log in. To do
    that, we''ll create another component as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个主要的前端功能是允许用户登录。为此，我们将创建另一个组件，如下所示：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we will add the following component definition:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加以下组件定义：
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And, finally, we will add the template as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将按照以下方式添加模板：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When this component is **mounted** (or attached to the element in the DOM),
    we call the `getAuthUrl()` function that sends an Ajax request to the server for
    our Google login URL. Once that's fetched, the login anchor tag is updated to
    refer to the URL.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个组件被 **mounted**（或附加到 DOM 中的元素）时，我们调用 `getAuthUrl()` 函数，该函数向服务器发送 Ajax 请求以获取我们的
    Google 登录 URL。一旦获取到，登录锚标签将被更新以引用该 URL。
- en: There are a few more details in the JavaScript file we've not covered here explicitly,
    but interested parties can check out the source code in the repository and read
    through it for the remaining details. We do have a working JavaScript frontend
    for our note-taking app that supports listing, creating, updating, and deleting
    notes, as well as supporting multiple users. It's not a pretty application, but
    it works. Not bad for a Java guy!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 文件中还有一些我们没有在这里明确覆盖的细节，但有兴趣的人可以查看存储库中的源代码，并阅读剩余的细节。我们确实有一个用于笔记应用的运行中的
    JavaScript 前端，它支持列出、创建、更新和删除笔记，以及支持多用户。它不是一个很漂亮的应用程序，但它能工作。对于一个 Java 程序员来说，这已经很不错了！
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now we're back to the familiar refrain--our application is **finished**. What
    have we covered in the chapter? We've created a REST API using JAX-RS that doesn't
    require direct JSON manipulation. We've learned how to apply request filters to
    JAX-RS endpoints to restrict access to authenticated users, which we authenticate
    against their Google accounts using Google's OAuth2 workflow. We've packaged the
    application using Payara Micro, a great option to develop microservices, and we've
    integrated MongoDB into our application using the MongoDB Java API. Finally, we
    built a very basic JavaScript client using Vue.js to access our application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到了熟悉的旋律——我们的应用程序**完成了**。在这一章中我们涵盖了什么内容？我们使用JAX-RS创建了一个REST API，它不需要直接操作JSON。我们学习了如何将请求过滤器应用于JAX-RS端点，以限制对认证用户的访问，我们使用Google的OAuth2工作流程通过他们的Google账户进行认证。我们使用Payara
    Micro打包了应用程序，这是一个开发微服务的优秀选择，并且我们使用MongoDB Java API将MongoDB集成到我们的应用程序中。最后，我们使用Vue.js构建了一个非常基本的JavaScript客户端来访问我们的应用程序。
- en: There are a lot of new concepts and technologies interacting in this application,
    which makes it interesting from a technical perspective, but there's still more
    that could be done. The application could use a great deal of styling, and support
    for embedded images and videos would be nice, as would a mobile client. There
    is lots of room for improvements and enhancements with the app, but interested
    parties have a solid foundation to start from. Although, for us, it's time to
    turn to the next chapter and a new project, where we'll jump into the world of
    cloud computing with Functions as a Service.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，有很多新的概念和技术在相互作用，从技术角度来看，这使得它很有趣，但还有更多可以做的事情。应用程序需要大量的样式设计，并且支持嵌入图片和视频会很好，同样需要一个移动客户端。在应用程序中，有大量的改进和增强空间，但感兴趣的各方有一个坚实的基础可以从中开始。尽管如此，对我们来说，现在是时候转向下一章和新项目了，我们将跳入以服务为函数的云计算世界。
