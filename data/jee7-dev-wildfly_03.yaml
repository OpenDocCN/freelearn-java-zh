- en: Chapter 3. Introducing Java EE 7 – EJBs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 介绍Java EE 7 – EJBs
- en: In the previous chapter, you learned some basics about how to set up and deploy
    a Hello World application on WildFly. In this chapter, we will go a little deeper
    and learn how to create, deploy, and assemble Enterprise JavaBeans, which are
    at the heart of most Enterprise applications. Additionally, you will learn how
    to use Maven, a popular build tool, which can ease the packaging process of our
    beans.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何设置和部署Hello World应用程序在WildFly上的基础知识。在本章中，我们将更深入地学习如何创建、部署和组装企业JavaBeans，它们是大多数企业应用程序的核心。此外，你还将学习如何使用Maven，这是一个流行的构建工具，可以简化我们的Bean的打包过程。
- en: 'In more detail, here is what you will learn in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，以下是本章你将学习的内容：
- en: What changes are introduced by the new EJB 3.2 specification
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的EJB 3.2规范引入了哪些变化
- en: How to create a Java EE 7 Maven project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个Java EE 7 Maven项目
- en: How to develop a singleton EJB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何开发一个单例EJB
- en: How to create stateless and stateful Enterprise JavaBeans
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建无状态和有状态的Enterprise JavaBeans
- en: How to add and manage schedulers and timers to your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向你的应用程序添加和管理调度器和定时器
- en: How to make use of asynchronous APIs in an EJB project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在EJB项目中使用异步API
- en: EJB 3.2 – an overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB 3.2 – 概述
- en: Based on the **Enterprise JavaBeans** (**EJB**) specification, Enterprise JavaBeans
    are components that typically implement the business logic of Java Enterprise
    Edition applications (for Java EE, note that Oracle advises against using JEE
    as the acronym for Java Enterprise Edition; for more information about acronyms
    for Java-related technologies, visit [https://java.net/projects/javaee-spec/pages/JEE](https://java.net/projects/javaee-spec/pages/JEE)).
    Because of their transactional nature, EJBs are also commonly used for the construction
    of the data access layer in many applications. However, in the newest version
    of the specification, container-managed transactions are no longer exclusive for
    Enterprise JavaBeans and can be reused in other parts of the Java EE platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**企业JavaBeans**（**EJB**）规范，企业JavaBeans是通常实现Java企业版应用程序（对于Java EE，请注意，Oracle建议不要使用JEE作为Java企业版的缩写；有关Java相关技术缩写的更多信息，请访问[https://java.net/projects/javaee-spec/pages/JEE](https://java.net/projects/javaee-spec/pages/JEE)）。由于它们的事务性，EJBs也常用于许多应用程序的数据访问层构建。然而，在新版规范中，容器管理的交易不再是企业JavaBeans的专属，并且可以在Java
    EE平台的其它部分重用。
- en: 'There are basically three types of Enterprise JavaBeans:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Enterprise JavaBeans有三种类型：
- en: '**Session beans**: This is the most commonly used EJB type. The container manages
    multiple instances of every class that is defined as a session bean (with an exception
    for singletons, which have only one instance). When an operation implemented by
    EJB must be executed (for example, because a user has requested an update of an
    entity in the database), the container assigns a session bean instance for the
    specific user. This code is then executed on behalf of the calling client. The
    container is responsible for providing session beans with multiple system-level
    services, for example, security, transactions, or distribution of beans.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话Bean**：这是最常用的EJB类型。容器管理每个被定义为会话Bean的类的多个实例（单例除外，它只有一个实例）。当一个由EJB实现的操作必须执行时（例如，因为用户请求更新数据库中的实体），容器为特定用户分配一个会话Bean实例。然后，代表调用客户端执行此代码。容器负责为会话Bean提供多个系统级服务，例如安全、事务或Bean的分布。'
- en: '**Message-driven beans** (**MDB**): MDBs are Enterprise beans that can asynchronously
    process messages sent by any JMS producer. (We will discuss MDBs in [Chapter 6](part0035_split_000.html#page
    "Chapter 6. Developing Applications with JBoss JMS Provider"), *Developing Applications
    with JBoss JMS Provider*.)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动Bean**（**MDB**）：MDBs是能够异步处理任何JMS生产者发送的消息的企业Bean。（我们将在[第6章](part0035_split_000.html#page
    "第6章. 使用JBoss JMS提供程序开发应用程序")，*使用JBoss JMS提供程序开发应用程序*中讨论MDBs。）'
- en: '**Entity objects**: An EJB is used to represent entities in a database. The
    newest version of the specification made this type of Enterprise JavaBeans optional,
    so they may not be supported in all containers (their support has also been dropped
    in WildFly). Entity objects will be removed from the specification in Java EE
    8\. Currently, in Java EE 7, the main persistence technology is Java Persistence
    API. We will discuss JPA in [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining
    Persistence with CDI"), *Combining Persistence with CDI*.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体对象**：EJB用于在数据库中表示实体。最新版本的规范使这种类型的Enterprise JavaBeans成为可选的，因此它们可能不在所有容器中得到支持（在WildFly中也已取消支持）。实体对象将在Java
    EE 8中从规范中删除。目前，在Java EE 7中，主要的持久化技术是Java持久化API。我们将在[第5章](part0030_split_000.html#page
    "第5章。将持久化与CDI结合")，*将持久化与CDI结合*中讨论JPA。'
- en: Additionally, session beans can be divided into three subtypes based on their
    characteristics and usage scenarios.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，会话Bean可以根据其特性和使用场景分为三种子类型。
- en: '**Stateless session beans** (**SLSB**): These are objects whose instances have
    no conversational state with the client that has invoked an operation on them.
    This means that all these bean instances are equal when they are not servicing
    a client, and the container can prepare a pool for them to handle multiple requests
    in parallel. Because they do not store any state, their performance overhead is
    quite low. A common usage scenario for an SLSB would be a stateless service responsible
    for retrieving objects from a database.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态会话Bean**（**SLSB**）：这些对象的实例与调用它们操作的客户端没有对话状态。这意味着当它们不服务客户端时，所有这些Bean实例都是相同的，并且容器可以为它们准备一个池来并行处理多个请求。因为它们不存储任何状态，所以它们的性能开销相当低。无状态服务负责从数据库检索对象的场景是SLSB的一个常见用法。'
- en: '**Stateful session beans** (**SFSB**): SFSB supports conversational services
    with tightly coupled clients. A stateful session bean accomplishes a task for
    a particular client and it cannot be shared between multiple callers. It maintains
    the state for the duration of a client session. After session completion, the
    state is not retained. The container may decide to passivate (serialize and store
    for future usage) a stale SFSB. This is done to save resources of the application
    server or in some cases, to support SFSB failover mechanism in a domain of application
    servers (this is the case in JBoss AS 7 and WildFly). Starting from EJB 3.2, it
    is possible to disable passivation for a specific SFSB, although it may affect
    the server''s stability and failover capability. A shopping cart could serve as
    a simple use case for an SFSB.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态会话Bean**（**SFSB**）：SFSB支持与紧密耦合的客户端进行对话式服务。有状态会话Bean为特定客户端完成一项任务，并且不能在多个调用者之间共享。它在客户端会话期间维护状态。会话完成后，状态不会保留。容器可能会决定钝化（序列化并存储以供将来使用）一个过期的SFSB。这样做是为了节省应用服务器的资源，或者在某些情况下，为了在应用服务器域中支持SFSB故障转移机制（这是JBoss
    AS 7和WildFly的情况）。从EJB 3.2开始，可以禁用特定SFSB的钝化，尽管这可能会影响服务器的稳定性和故障转移能力。购物车可以作为SFSB的一个简单用例。'
- en: '**Singleton EJB**: This is essentially similar to a stateless session bean;
    however, it uses a single instance to serve client requests. So, you can guarantee
    the use of the same instance across invocations. Singletons can use a richer life
    cycle for a set of events, along with the possibility to control when a bean is
    initialized. Also, a more strict locking policy to control concurrent access to
    the instance can be enforced, so that the shared state of the singleton bean can
    be used by multiple clients. If the application is distributed on multiple nodes
    of a domain, then every running JVM will have its own instance of the singleton
    bean. We will discuss this a little further in [Chapter 11](part0057_split_000.html#page
    "Chapter 11. Clustering WildFly Applications"), *Clustering WildFly Applications*.
    Because of their special characteristics, singletons can be used to save the state
    of the application, cache, or initialize some resources during the application''s
    startup.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例EJB**：这本质上与无状态会话bean相似；然而，它使用单个实例来服务客户端请求。因此，你可以保证在调用之间使用相同的实例。单例可以使用更丰富的生命周期来处理一系列事件，以及控制bean初始化时间的可能性。此外，可以强制执行更严格的锁定策略来控制对实例的并发访问，以便多个客户端可以使用单例bean的共享状态。如果应用程序在域的多个节点上分布式部署，那么每个运行的JVM都将有自己的单例bean实例。我们将在[第11章](part0057_split_000.html#page
    "第11章。WildFly应用程序的集群")中进一步讨论这个问题，*WildFly应用程序的集群*。由于它们的特殊特性，单例可以用来保存应用程序的状态、缓存或在应用程序启动时初始化一些资源。'
- en: 'As we mentioned earlier, the container manages the instances of the beans,
    but the clients should call them through business interfaces. There are three
    types of a session bean''s views available:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，容器管理bean的实例，但客户端应该通过业务接口来调用它们。会话bean有三种类型的视图可用：
- en: '**Local business interface**: This session bean is used when the bean and its
    client are in the same container. It uses the pass-by-reference semantic, so the
    return values and method parameters are based on references and not copies of
    the objects.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地业务接口**：当bean及其客户端位于同一容器中时使用此会话bean。它使用按引用传递的语义，因此返回值和方法参数基于引用，而不是对象的副本。'
- en: '**Remote business interface**: In this session bean, the locations of the client
    and the bean are independent (the client may reside in another container or without
    a container at all, for example, as a standalone application). Every parameter
    and return value is serialized and copied.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程业务接口**：在这个会话bean中，客户端和bean的位置是独立的（客户端可能位于另一个容器中，或者根本不需要容器，例如作为一个独立的应用程序）。每个参数和返回值都被序列化和复制。'
- en: '**No-interface view**: This session bean is a variant of the local business
    view that does not require a separate interface, that is, all `public` methods
    of the bean class are automatically exposed to the caller.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无接口视图**：这个会话bean是本地业务视图的一个变体，它不需要单独的接口，也就是说，bean类的所有`public`方法都会自动暴露给调用者。'
- en: 'Since EJB 3.1, it is possible to use asynchronous methods. These are able to
    process client requests asynchronously, just like MDBs, except that they expose
    a typed interface and follow a more complex approach to process client requests.
    It is possible to use two approaches to achieve this kind of behavior:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自EJB 3.1以来，可以使用异步方法。这些方法能够异步处理客户端请求，就像消息驱动bean一样，除了它们提供了一个类型化的接口，并采用更复杂的方法来处理客户端请求。可以使用两种方法来实现这种行为：
- en: Fire-and-forget asynchronous void methods, which are invoked by the client
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端调用的异步void方法，即“fire-and-forget”异步方法
- en: Retrieve-result-later asynchronous methods, which have the `Future<?>` return
    type
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型为`Future<?>`的异步方法，即“检索结果稍后”方法
- en: 'What more should you know about EJBs before proceeding? When you develop an
    Enterprise JavaBean, you have to follow some general rules, which are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你还需要了解哪些关于EJB的知识？当你开发企业JavaBean时，你必须遵循一些通用规则，如下所示：
- en: Avoid using nonfinal static fields
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用非final静态字段
- en: Don't manually create threads (we will cover this topic more deeply in [Chapter
    12](part0062_split_000.html#page "Chapter 12. Long-term Tasks' Execution"), *Long-term
    Tasks' Execution*)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要手动创建线程（我们将在[第12章](part0062_split_000.html#page "第12章。长期任务执行")中更深入地讨论这个主题，*长期任务执行*）
- en: Don't use synchronization primitives (except in singletons with bean-managed
    concurrency)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用同步原语（除了在bean管理的并发中的单例）
- en: Manual file operations on the filesystem and listening on sockets are forbidden
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止在文件系统上手动执行文件操作和监听套接字
- en: Native libraries should not be loaded
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生库不应被加载
- en: Disobeying these rules could cause security and stability issues with the EJB
    container. A comprehensive list of disallowed activities can be found at [http://www.oracle.com/technetwork/java/restrictions-142267.html](http://www.oracle.com/technetwork/java/restrictions-142267.html)
    along with some explanations for specific points.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 违反这些规则可能会导致EJB容器出现安全和稳定性问题。可以在[http://www.oracle.com/technetwork/java/restrictions-142267.html](http://www.oracle.com/technetwork/java/restrictions-142267.html)找到不允许的活动列表，以及一些特定点的解释。
- en: Since it's easier to grasp the concepts with real examples, in the next section,
    we will provide a concrete application example that introduces some of the features
    that we described in this section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用实际例子更容易理解概念，在下一节中，我们将提供一个具体的应用程序示例，介绍本节中描述的一些特性。
- en: Developing singleton EJBs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发单例EJB
- en: As the name implies, `javax.ejb.Singleton` is a session bean that guarantees
    that there is at most one instance in the application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`javax.ejb.Singleton` 是一个会话Bean，它保证应用程序中最多只有一个实例。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Besides this, singleton EJBs fill a well-known gap in EJB applications, that
    is, the ability to have an EJB notified when the application starts and also when
    the application stops. So, you can do all sorts of things with an EJB that you
    previously (before EJB 3.1) could only do with a load-on-startup servlet. EJB
    also gives you a place to hold data that pertains to the entire application and
    all the users using it, without the need for static class fields.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单例EJB填补了EJB应用程序中的一个知名空白，即当应用程序启动和停止时能够通知EJB。因此，你可以用EJB做许多以前（在EJB 3.1之前）只能用启动时加载的servlet做的事情。EJB还为你提供了一个可以存放与整个应用程序及其所有用户相关数据的地方，而不需要静态类字段。
- en: In order to turn your EJB into a singleton, all that is needed is to apply the
    `@javax.ejb.Singleton` annotation on top of it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将你的EJB转换为单例，你只需要在它上面应用 `@javax.ejb.Singleton` 注解。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A singleton bean is similar to a stateful bean, in that, state information is
    maintained across method invocations. However, there is just one singleton bean
    for each server JVM, and it is shared by all of the EJBs and clients of an application.
    This type of bean provides a convenient means to maintain the overall state of
    an application. However, if the application is distributed on multiple machines
    (and therefore multiple JVMs), the singleton is unique on every one of them. Any
    application state must be synchronized between the nodes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单例Bean类似于有状态的Bean，因为状态信息在方法调用之间保持。然而，每个服务器JVM只有一个单例Bean，它被应用程序的所有EJB和客户端共享。这种类型的Bean提供了一种方便的方式来维护应用程序的整体状态。但是，如果应用程序分布在多个机器（因此多个JVM）上，那么每个机器上的单例都是唯一的。任何应用程序状态必须在节点之间同步。
- en: Another annotation that is worth learning is `@javax.ejb.Startup`, which causes
    the bean to be instantiated by the container when the application starts. This
    invokes the method decorated with the `@javax.annotation.PostConstruct` annotation
    if you have defined one in your EJB.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 值得学习的一个注释是 `@javax.ejb.Startup`，它会在应用程序启动时由容器实例化该Bean。如果你在EJB中定义了带有 `@javax.annotation.PostConstruct`
    注解的方法，它将调用该方法。
- en: We now have enough information to understand our first EJB example. There is
    more than one alternative to create a Java Enterprise project. In the earlier
    chapter, we illustrated how to start from a project based on Eclipse Java EE (a
    dynamic web project), binding it later to a WildFly runtime installation. This
    is obviously the simplest choice, and you can easily run the examples contained
    in this book using this pattern; however, when it comes to enterprise solutions,
    it's no surprise that almost every project now uses some kind of build automation
    tool. For this book, we will propose Apache Maven, as it is one of the most popular
    choices, but not the only one. Gradle is a similar project that uses the Groovy
    language to describe project structure, dependencies, and build workflow.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了足够的信息来理解我们的第一个EJB示例。创建Java Enterprise项目有多种选择。在早期章节中，我们展示了如何从一个基于Eclipse
    Java EE（一个动态Web项目）的项目开始，稍后将其绑定到WildFly运行时安装。这显然是最简单的选择，你可以很容易地使用这种模式运行本书中的示例；然而，当涉及到企业解决方案时，几乎每个项目现在都使用某种类型的构建自动化工具。对于本书，我们将提出Apache
    Maven，因为它是最受欢迎的选择之一，但并非唯一。Gradle是一个类似的项目，它使用Groovy语言来描述项目结构、依赖关系和构建工作流程。
- en: Some of the benefits that you will achieve when turning to Maven projects include
    a well-defined dependency structure, the conventions of a project build's best
    practices, and project modular design, just to mention a few. Additionally, when
    you have an automated build process, you can use continuous integration tools
    (such as Jenkins) to schedule automated tests and deployments of your applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你转向 Maven 项目时，你将获得的某些好处包括定义良好的依赖结构、项目构建最佳实践的传统，以及项目模块化设计，仅举几例。此外，当你有一个自动化的构建过程时，你可以使用持续集成工具（如
    Jenkins）来安排应用程序的自动化测试和部署。
- en: All major IDEs have built-in Maven support. This includes the Eclipse Java EE
    Luna release.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的 IDE 都有内置的 Maven 支持。这包括 Eclipse Java EE Luna 版本。
- en: 'So, let''s create our first Maven project directly from Eclipse. Navigate to
    **File** | **New** | **Other** | **Maven** | **Maven Project**. This is shown
    in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们直接从 Eclipse 创建我们的第一个 Maven 项目。导航到 **文件** | **新建** | **其他** | **Maven**
    | **Maven 项目**。这将在以下屏幕截图中显示：
- en: '![Developing singleton EJBs](img/00030.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![开发单例 EJB](img/00030.jpeg)'
- en: 'Click on **Next**; you will be taken to the following intermediary screen:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **下一步**；你将被带到以下中间屏幕：
- en: '![Developing singleton EJBs](img/00031.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![开发单例 EJB](img/00031.jpeg)'
- en: Maven allows the use of archetypes when creating a new project. They define
    a project's basic dependencies, resources, structure, and so on. For example,
    you can use a web application archetype in order to get an empty project skeleton,
    which you can just build and deploy. Unfortunately, archetypes are often outdated,
    and you still need to adjust them for your needs. In order to use some Java EE
    7 archetypes, you have to first define a repository and archetypes you would like
    to use, and then you can create a project. In real life, you will probably create
    every new project by just looking at your previous ones, without using any archetypes.
    So, here we will show how to create a project from scratch. You might also be
    interested in some additional Java EE-related tools such as JBoss Forge, whose
    description you will find in the [Appendix](part0067_split_000.html#page "Appendix A. Rapid
    Development Using JBoss Forge"), *Rapid Development Using JBoss Forge*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 允许在创建新项目时使用原型。它们定义了一个项目的基本依赖、资源、结构等等。例如，你可以使用一个网络应用程序原型来获取一个空的项目骨架，然后你可以直接构建和部署。不幸的是，原型通常过时，你仍然需要根据你的需求进行调整。为了使用一些
    Java EE 7 原型，你必须首先定义一个仓库和你想要使用的原型，然后你才能创建一个项目。在现实生活中，你可能只是通过查看你之前的那些项目来创建每一个新项目，而不使用任何原型。因此，这里我们将展示如何从头开始创建一个项目。你可能还对一些额外的
    Java EE 相关工具感兴趣，例如 JBoss Forge，你将在[附录](part0067_split_000.html#page "附录 A. Rapid
    Development Using JBoss Forge")中找到其描述，*Rapid Development Using JBoss Forge*。
- en: On the visible screen, check the **Create a simple project** checkbox. With
    this option, we will skip the archetype selection. You can click on **Next**.
    Now, you have to complete some basic project information. We are creating a server-side
    EJB application, which also has a standalone client. These two projects can share
    some common information, for example, about dependencies and their versions. Hence,
    we want to create a Maven multimodule project. In this first step, let's create
    a parent project that has a POM packaging. POM is a Maven convention used to describe
    the structure of a project and its modules. More information on this can be found
    in Sonatype free books that we mentioned in previous chapters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在可见的屏幕上，勾选 **创建一个简单项目** 复选框。使用此选项，我们将跳过原型选择。你可以点击 **下一步**。现在，你必须完成一些基本的项目信息。我们正在创建一个服务器端
    EJB 应用程序，它还有一个独立的客户端。这两个项目可以共享一些共同信息，例如关于依赖及其版本的信息。因此，我们想要创建一个 Maven 多模块项目。在这个第一步中，让我们创建一个具有
    POM 打包的父项目。POM 是 Maven 用来描述项目及其模块结构的一种约定。更多关于这个的信息可以在我们之前章节中提到的 Sonatype 免费书籍中找到。
- en: 'You can complete the wizard by entering some package-specific information,
    as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入一些包特定信息来完成向导，如下面的屏幕截图所示：
- en: '![Developing singleton EJBs](img/00032.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![开发单例 EJB](img/00032.jpeg)'
- en: For **Group ID** (an abstract identifier with a similar role as in Java packages),
    you can use `com.packtpub.wflydevelopment.chapter3`. For **Artifact ID** (a simplified
    name of our project), just use `ticket-agency`. Set the **Packaging** field to
    **pom**, and you can leave the default selection for the project's **Version**
    field. Click on **Finish** in order to complete the wizard.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **组 ID**（一个具有类似 Java 包角色的抽象标识符），您可以使用 `com.packtpub.wflydevelopment.chapter3`。对于
    **工件 ID**（我们项目的简化名称），只需使用 `ticket-agency`。将 **打包** 字段设置为 **pom**，并且可以保留项目 **版本**
    字段的默认选择。点击 **完成** 以完成向导。
- en: 'Take a look at our newly created project. At the moment, it contains only `pom.xml`,
    which will be the base for new modules. Navigate again to **File** | **New** |
    **Other** | **Maven** but now choose the **New Maven Module**. You can now see
    the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们新创建的项目。目前，它只包含 `pom.xml`，这将是新模块的基础。再次导航到 **文件** | **新建** | **其他** | **Maven**，但现在选择
    **新建 Maven 模块**。您现在可以看到以下截图：
- en: '![Developing singleton EJBs](img/00033.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![开发单例 EJB](img/00033.jpeg)'
- en: Again, we want to skip the archetype selection, so check the **Create a simple
    project** option. Under the **Parent Project**, click on **Browse** and select
    the parent we created a while ago. Under **Module Name**, enter `ticket-agency-ejb`.
    Click on **Next**. You will be presented with the following screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们想跳过存档选择，因此请检查 **创建简单项目** 选项。在 **父项目** 下，点击 **浏览** 并选择我们之前创建的父项目。在 **模块名称**
    下，输入 `ticket-agency-ejb`。点击 **下一步**。您将看到以下屏幕。
- en: '![Developing singleton EJBs](img/00034.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![开发单例 EJB](img/00034.jpeg)'
- en: 'Now, let''s discuss the packaging type. There are a few possible archive types
    for Java EE deployments:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论打包类型。Java EE 部署有几种可能的存档类型：
- en: '**The EJB module**: This module usually contains classes for EJBs, packed as
    a .`jar` file.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EJB 模块**：此模块通常包含 EJB 的类，打包为 `.jar` 文件。'
- en: '**The web module**: This archive can additionally contain web elements such
    as servlets, static web files, REST endpoints, and so on. It is packed as a `.war`
    file (web archive) file.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 模块**：此存档可以包含额外的 Web 元素，如 servlet、静态 Web 文件、REST 端点等。它打包为 `.war` 文件（Web
    存档）。'
- en: '**The resource adapter module**: This archive contains files related to JCA
    connectors (described in [Chapter 6](part0035_split_000.html#page "Chapter 6. Developing
    Applications with JBoss JMS Provider"), *Developing Applications with JBoss JMS
    Provider*). It is packed as a `.rar` file.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源适配器模块**：此存档包含与 JCA 连接器相关的文件（在第 6 章[开发使用 JBoss JMS 提供程序的应用程序](part0035_split_000.html#page
    "第 6 章。开发使用 JBoss JMS 提供程序的应用程序")中描述），打包为 `.rar` 文件。'
- en: '**The Enterprise archive**: This archive aggregates multiple Java EE modules
    (EJB, Web) with related descriptors. It is packed as a `.ear` file.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业存档**：此存档聚合了多个 Java EE 模块（EJB、Web）及其相关描述符。它打包为 `.ear` 文件。'
- en: Here, we want to deploy only EJBs without any web elements, so let's set the
    packaging to EJB (if it is not visible in the Eclipse drop-down menu, just manually
    type it) and click on **Finish**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只想部署 EJB 而不包含任何 Web 元素，因此将打包设置为 EJB（如果它在 Eclipse 下拉菜单中不可见，只需手动输入即可）并点击
    **完成**。
- en: Follow the same steps to add a second module with the name `ticket-agency-ejb-client`
    and JAR packaging . This will be a simple client for services exposed in `ticket-agency-ejb`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的步骤添加第二个模块，模块名为 `ticket-agency-ejb-client`，打包类型为 JAR。这将是一个简单的客户端，用于在 `ticket-agency-ejb`
    中公开的服务。
- en: 'Now, look at our parent project `pom.xml`. It should define two recently created
    modules, which are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看我们的父项目 `pom.xml`。它应该定义两个最近创建的模块，如下所示：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The expected outcome of these operations should match the following screenshot,
    which has been taken from the Project Explorer view:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的预期结果应与以下截图相匹配，该截图是从项目资源管理器视图获取的：
- en: '![Developing singleton EJBs](img/00035.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![开发单例 EJB](img/00035.jpeg)'
- en: 'As you can see, the **ticket-agency-ejb** and **ticket-agency-ejb-client**
    projects have been organized as a standard Maven project:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ticket-agency-ejb` 和 `ticket-agency-ejb-client` 项目已按标准 Maven 项目组织：
- en: '`src/main/java` will contain our source code'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/java` 将包含我们的源代码'
- en: '`src/main/resources` is meant for the configuration (containing a bare-bones
    `ejb-jar.xml` configuration file for the EJB project)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/resources` 用于配置（包含一个用于 EJB 项目的裸骨 `ejb-jar.xml` 配置文件）'
- en: '`src/test/java` is used to store the test classes'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/test/java` 用于存储测试类'
- en: At the moment, we will focus on the main file `pom.xml`, which needs to be aware
    of the Java EE dependencies.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将关注主文件 `pom.xml`，它需要知道 Java EE 依赖项。
- en: Configuring the EJB project object module (pom.xml)
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 EJB 项目对象模块（pom.xml）
- en: Before digging into the code, first you need to configure Maven's `pom.xml`
    configuration file further. This file is quite verbose, so we will illustrate
    just the core elements here that are required to understand our example, leaving
    the full listing to the code example package of this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究代码之前，首先你需要进一步配置 Maven 的 `pom.xml` 配置文件。这个文件相当冗长，所以我们在这里只展示理解我们的示例所必需的核心元素，完整的列表留到本书的代码示例包中。
- en: 'The first thing we are going to add just after the properties section is a
    reference to Java EE 7 API, which is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在属性部分之后添加对 Java EE 7 API 的引用，如下所示：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This dependency will add all Java EE 7.0 APIs' definitions. Scope is set to
    be provided, which means the dependency is available on the target environment
    (in our case, the application server), and does not need to be included in the
    built archive. This dependency is universal, and should work with all Application
    Servers that are compatible with Java EE 7.0, not only with WildFly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项将添加所有 Java EE 7.0 API 的定义。范围设置为 provided，这意味着依赖项在目标环境中（在我们的例子中，是应用程序服务器）可用，并且不需要包含在构建的存档中。这个依赖项是通用的，应该与所有兼容
    Java EE 7.0 的应用程序服务器一起工作，而不仅仅是与 WildFly。
- en: 'We also want to add a second dependency, which is the JBoss logging API. Place
    this definition in the same `<dependencies> </dependencies>` tags, for example,
    below `javaee-api`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望添加第二个依赖项，即 JBoss 日志 API。将此定义放在相同的 `<dependencies> </dependencies>` 标签中，例如在
    `javaee-api` 下方，如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The scope provided includes the enterprise dependencies and corresponds to
    adding a library to the compilation path. Therefore, it expects the JDK or a container
    to provide the dependency at runtime. Besides dependencies, we would like to configure
    the build process. The created project specifies the EJB packaging, but the build
    is performed with the JDK 1.5 compliance level and an old EJB version. This is
    why we want to add an additional block to `pom.xml`, which is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的范围包括企业依赖项，相当于将库添加到编译路径。因此，它期望 JDK 或容器在运行时提供依赖项。除了依赖项之外，我们还想配置构建过程。创建的项目指定了
    EJB 打包，但构建使用的是与 JDK 1.5 兼容的级别和一个旧的 EJB 版本。这就是为什么我们想在 `pom.xml` 中添加一个额外的代码块，如下所示：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This block does two things, which are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块执行以下两项操作：
- en: The `maven-compiler-plugin` configuration enforces the usage of Java 8
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maven-compiler-plugin` 配置强制使用 Java 8'
- en: The `maven-ejb-plugin` configuration defines that EJB 3.2 version was used,
    and enables generation of the EJB client (disabled by default) package for EJB
    client applications
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maven-ejb-plugin` 配置定义了使用 EJB 3.2 版本，并启用了为 EJB 客户端应用程序生成 EJB 客户端（默认禁用）包'
- en: 'Also, check the `src/main/resources/META-INF/ejb-jar.xml` file. It might contain
    the configuration from EJB 2.1\. Instead, use the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查 `src/main/resources/META-INF/ejb-jar.xml` 文件。它可能包含来自 EJB 2.1 的配置。相反，使用以下代码：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point, you will be able to compile your project; so, we will start adding
    classes, but we will return to the `pom.xml` file when it's time to deploy your
    artifact.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你将能够编译你的项目；因此，我们将开始添加类，但在部署你的工件时，我们将回到 `pom.xml` 文件。
- en: Coding our EJB application
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的 EJB 应用程序
- en: Creating EJB classes does not require getting mixed up with fancy wizards; all
    you need to do is add bare Java classes. Therefore, from the **File** menu, go
    to **New** | **Java Class**, and enter `TheatreBox` as the classname and `com.packtpub.wflydevelopment.chapter3.control`
    as the package name.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 EJB 类不需要与复杂的向导混淆；你只需要添加裸 Java 类。因此，从**文件**菜单，转到**新建** | **Java 类**，并将 `TheatreBox`
    作为类名，`com.packtpub.wflydevelopment.chapter3.control` 作为包名输入。
- en: 'We will add the following implementation to the class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在类中添加以下实现：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s see our application code in detail; the void method `setupTheatre` is
    invoked as soon as the application is deployed and takes care of assembling the
    theatre seats, creating a simple map of the `Seat` objects. Seat identifiers are
    key factors in this map. This happens right after deployment because our bean
    is annotated with `@Singleton` and `@Startup` that force the container to initialize
    the bean during startup. Each `Seat` object is constructed using a set of three
    field constructors, which includes the seat ID, its description, and the price
    (the booked field is initially set as false). This is given in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看我们的应用程序代码；void 方法 `setupTheatre` 在应用程序部署时被调用，负责组装剧院座位，创建一个简单的 `Seat`
    对象映射。座位标识符是这个映射的关键因素。这发生在部署之后，因为我们的 bean 被注解为 `@Singleton` 和 `@Startup`，这强制容器在启动时初始化
    bean。每个 `Seat` 对象都是使用一组三个字段构造函数构建的，包括座位 ID、其描述和价格（预订字段最初设置为 false）。这在下述代码中给出：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that our `Seat` object is an immutable one. After we create an instance,
    we will not be able to change its state (the value of the fields, all of them
    are final, and no setters are exposed). This means that when we return a `Seat`
    object to the client (local or remote), it will be only available for reading.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `Seat` 对象是不可变的。在创建实例后，我们将无法更改其状态（字段的值，所有字段都是最终的，并且没有暴露设置器）。这意味着当我们向客户端（本地或远程）返回一个
    `Seat` 对象时，它只能用于读取。
- en: Next, the singleton bean exposes four public methods; the `getSeats` method
    returns an unmodifiable collection of `Seat` objects, which will return the information
    regarding whether they have been reserved or not to the user. The collection must
    be unmodifiable because our Singleton exposes a no-interface view, which means
    that we are using the pass-by-reference semantic. If we will not protect the collection,
    then every change on an element of the returned collection will be done on our
    cache. What's more, the client can add or remove elements to our internal collection!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，单例 bean 公开了四个公共方法；`getSeats` 方法返回一个不可修改的 `Seat` 对象集合，它将返回有关它们是否已被预订的信息给用户。该集合必须是不可修改的，因为我们的
    Singleton 公开了一个无接口视图，这意味着我们正在使用引用传递语义。如果我们不保护集合，那么对返回集合中任何元素的更改都将在我们的缓存上完成。更重要的是，客户端可以向我们的内部集合添加或删除元素！
- en: The `getSeatPrice` method is an utility method, which will pick up the seat
    price and return it as `int`, so it can be used to verify whether the user can
    afford to buy the ticket.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSeatPrice` 方法是一个实用方法，它将获取座位价格并将其作为 `int` 返回，因此可以用来验证用户是否有能力购买门票。'
- en: The `getSeat` method returns an immutable `Seat` object for a given ID. Once
    more, we return an immutable `Seat` because we don't want the client to change
    the object without using the `TheatherBox` bean.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSeat` 方法返回一个给定 ID 的不可变 `Seat` 对象。再次强调，我们返回一个不可变的 `Seat` 对象，因为我们不希望客户端在不使用
    `TheatherBox` bean 的情况下更改对象。'
- en: Finally, the `buyTicket` method is the one that actually buys the ticket and,
    therefore, sets the ticket as booked. We cannot change the value of an immutable
    object, but we can replace it with a new one, which contains another value. The
    newly created object is placed in the hashmap instead of the old one.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`buyTicket` 方法是实际购买门票的方法，因此将门票设置为已预订。我们不能更改不可变对象的值，但我们可以用包含另一个值的新对象来替换它。新创建的对象被放置在
    hashmap 中，而不是旧的一个。
- en: Controlling bean concurrency
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制bean并发
- en: As you might have noticed, the bean includes a `@Lock` annotation on top of
    the methods managing our collection of `Seat` objects. This kind of annotation
    is used to control the concurrency of the singleton.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，bean 在管理我们的 `Seat` 对象集合的方法上包含了一个 `@Lock` 注解。这种类型的注解用于控制单例的并发。
- en: Concurrent access to a singleton EJB is, by default, controlled by the container.
    Read/write access to a singleton is limited to one client at a time. However,it
    is possible to provide a finer level of concurrency control through the use of
    annotations. This can be achieved using the `@Lock` annotation, whose arguments
    determine the type of concurrency access permitted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对单例 EJB 的并发访问由容器控制。对单例的读写访问一次仅限于一个客户端。然而，通过使用注解，可以提供更细粒度的并发控制。这可以通过使用
    `@Lock` 注解来实现，其参数决定了允许的并发访问类型。
- en: 'By using a `@Lock` annotation of type `javax.ejb.LockType.READ`, multithreaded
    access will be allowed to the bean. This is shown in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类型为 `javax.ejb.LockType.READ` 的 `@Lock` 注解，将对 bean 的多线程访问将允许。这在下述代码中显示：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the other hand, if we apply `javax.ejb.LockType.WRITE`, the single-threaded
    access policy is enforced, as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们应用`javax.ejb.LockType.WRITE`，将强制执行单线程访问策略，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The general idea is to use `READ` type locks on methods that just read values
    from the cache and `WRITE` type locks for methods that change the values of elements
    contained in the cache. Keep in mind that `WRITE` type locks block all methods
    with `READ` type locks. It is crucial that the singleton will have exclusive control
    of the modifications of its state. Lack of proper encapsulation mixed with the
    pass-by-reference semantic (used in local and no-interface views of EJBs) can
    lead to hard-to-find concurrency bugs. Using immutable objects as return values
    for singletons is a good strategy to solve these kind of problems. Another strategy
    would be to return only copies of our objects or switching to the pass-by-value
    semantic. The last strategy can be applied by switching to a remote business interface
    in the singleton.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通用思路是在只从缓存中读取值的`READ`类型锁方法上使用`READ`类型锁，对于更改缓存中元素值的`WRITE`类型锁方法使用`WRITE`类型锁。请记住，`WRITE`类型锁会阻塞所有带有`READ`类型锁的方法。确保单例对其状态的修改具有独占控制权至关重要。缺乏适当的封装与引用传递语义（在EJB的本地和无接口视图中使用）混合可能导致难以发现的并发错误。将不可变对象作为单例的返回值是一种解决这类问题的好策略。另一种策略是只返回我们对象的副本或切换到值传递语义。最后一种策略可以通过在单例中切换到远程业务接口来实现。
- en: In the `TheatreBox` code, you have probably noticed a `@AccessTimeout` annotation
    (with value `5` and unit `TimeUnit.MINUTES`). When you execute a query against
    a method with `@Lock (WRITE)`, and if some other thread is already accessing it,
    then after 5 seconds of waiting, you will get a timeout exception. In order to
    change this behavior (for example, by prolonging the allowed wait time), you can
    specify a `@javax.ejb.AccessTimout` annotation at the method or class level.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TheatreBox`代码中，你可能已经注意到了一个`@AccessTimeout`注解（值为`5`，单位为`TimeUnit.MINUTES`）。当你对一个带有`@Lock
    (WRITE)`的方法执行查询，并且如果有其他线程正在访问它，那么在等待5秒后，你会得到一个超时异常。为了改变这种行为（例如，通过延长允许的等待时间），你可以在方法或类级别指定一个`@javax.ejb.AccessTimout`注解。
- en: Using bean-managed concurrency
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用bean管理的并发
- en: The other possible option is to use a bean-managed concurrency strategy that
    can be pursued by applying the `@javax.ejb.ConcurrencyManagement` annotation with
    an argument of `ConcurrencyManagementType.BEAN`. This annotation will disable
    the effect of the `@Lock` annotation we have used so far, putting the responsibility
    of ensuring that the singleton cache does not get corrupted on the developer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的选择是使用由`@javax.ejb.ConcurrencyManagement`注解（带有参数`ConcurrencyManagementType.BEAN`）实现的bean管理的并发策略。这个注解将禁用我们之前使用的`@Lock`注解的效果，将确保单例缓存不被损坏的责任放在开发者身上。
- en: 'So, in order to ensure that our bookings are preserved, we will need to use
    a well-known synchronized keyword on top of the `buyTicket` method, which is as
    follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了确保我们的预订得到保留，我们将在`buyTicket`方法上使用一个众所周知的同步关键字，如下所示：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since concurrent access is restricted when a thread enters the synchronized
    block, no other methods are allowed to access the object while the current thread
    is in the block. Using a synchronized block is equivalent to having a container-managed
    concurrency with default locks of type `WRITE` on all methods. This is one of
    the few places in Java EE when the developer may use synchronization primitives
    without affecting the stability of the container.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程进入同步块时，并发访问被限制，因此在此期间不允许其他方法访问该对象。使用同步块相当于拥有容器管理的并发性，所有方法默认使用类型为`WRITE`的锁。这是Java
    EE中少数几个开发者可以使用同步原语而不影响容器稳定性的地方之一。
- en: Cooking session beans
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写会话Bean
- en: Our singleton EJB is equipped with the methods to handle our store of theatre
    seats. We will now add a couple of session beans to our project to manage the
    business logic, a stateless session bean that will provide a view of the theatre
    seats and stateful beans that will behave as a payment gateway to our system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单一EJB配备了处理我们的剧院座位库存的方法。现在我们将向我们的项目中添加几个会话Bean来管理业务逻辑，一个无状态会话Bean将提供剧院座位的视图，以及作为我们系统支付网关行为的会话Bean。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The choice of splitting our information system into two different beans is not
    part of a design pattern in particular, but serves a different purpose. That is,
    we would like to show how to look up both types of beans from a remote client.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的信息系统拆分为两个不同的Bean的选择并不属于特定的设计模式，而是服务于不同的目的。那就是，我们希望展示如何从远程客户端查找这两种类型的Bean。
- en: Adding a stateless bean
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加无状态的Bean
- en: 'So, the first bean we will create is `com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfo`,
    which barely contains the logic to look up the list of theatre seats. In practice,
    this bean acts as a facade for our singleton bean, as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将首先创建的Bean是`com.packtpub.wflydevelopment.chapter3.boundary.TheatreInfo`，它几乎只包含查找剧院座位列表的逻辑。实际上，这个Bean充当了我们单例Bean的代理，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we are planning to invoke this EJB from a remote client, we defined a
    remote interface for it with the `@Remote(TheatreInfoRemote.class)` annotation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们计划从远程客户端调用这个EJB，我们使用`@Remote(TheatreInfoRemote.class)`注解为其定义了一个远程接口。
- en: Next, take a look at the `@EJB TheatreBox` `box`, which can be used to safely
    inject an EJB into your class without the need of a manual JNDI lookup. This practice
    can be used to increase the portability of your application between different
    application servers, where different JNDI rules might exist.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看看`@EJB TheatreBox` `box`，它可以用来安全地将EJB注入到您的类中，而无需手动JNDI查找。这种做法可以提高应用程序在不同应用服务器之间的可移植性，在这些服务器中可能存在不同的JNDI规则。
- en: 'The remote interface of your bean will be as simple as the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Bean的远程接口将像以下代码一样简单：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are planning to expose your EJB to local clients only (for example, to
    a servlet), you can leave out the remote interface definition and simply annotate
    your bean with `@Stateless`. The application server will create a no-interface
    view of your session bean, which can safely be injected into your local clients
    such as servlets or other EJBs. Be mindful that this also changes the semantics
    of the methods parameters and return values. For remote views, they will be serialized
    and passed by value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划仅将您的EJB暴露给本地客户端（例如，给一个servlet），您可以省略远程接口定义，只需简单地用`@Stateless`注解您的Bean即可。应用服务器将创建一个无接口视图的会话Bean，它可以安全地注入到您的本地客户端，如servlet或其他EJB。请注意，这也改变了方法参数和返回值的语义。对于远程视图，它们将被序列化并通过值传递。
- en: Adding a stateful bean
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加有状态的Bean
- en: 'In order to keep track of how much money our customer has got in his pocket,
    we will need a session-aware component. Turning a Java class into a stateful session
    bean is just a matter of adding a `@Stateful` annotation on top of it, as in our
    example `com.packtpub.wflydevelopment.chapter3.boundary.TheatreBooker` class.
    This is shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪我们的客户口袋里有多少钱，我们需要一个会话感知组件。将一个Java类转换成一个有状态的会话Bean只需在其上添加一个`@Stateful`注解，就像我们示例中的`com.packtpub.wflydevelopment.chapter3.boundary.TheatreBooker`类一样。这在上面的代码中有所展示：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the previous bean bears a `@PostConstruct` annotation to initialize
    a session variable (money) that will be used to check whether the customer has
    enough money to buy the ticket. When using EJBs, we don't use `constructors` and
    `destructors` to perform actions on an object to create or destroy. The reason
    is that the point object might not have injected all objects it depends on. The
    method annotated with `@PostConstruct` is executed when object creation is already
    finished, that is, all objects are injected to it. There is a second annotation
    related to the EJB life cycle, `@PreDestroy`, which is executed before the object
    is destroyed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，之前的Bean带有`@PostConstruct`注解，用于初始化一个会话变量（money），该变量将用于检查客户是否有足够的钱购买票。在使用EJB时，我们不使用`构造器`和`析构器`来对一个对象执行动作以创建或销毁。原因是该对象可能还没有注入它所依赖的所有对象。带有`@PostConstruct`注解的方法是在对象创建完成后执行的，也就是说，所有对象都已经注入到它中。还有一个与EJB生命周期相关的第二个注解，`@PreDestroy`，它在对象销毁之前执行。
- en: Besides this, the ultimate purpose of our SFSB is to invoke the `buyTicket`
    method of our singleton after having performed some business checks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的SFSB的最终目的是在执行一些业务检查后调用我们的单例的`buyTicket`方法。
- en: 'If the business checks do not pass, the application will issue some exceptions.
    This is the case, for example, if the seat has already been booked or if the customer
    hasn''t got enough money to buy the ticket. In order to keep our conversation
    going, it''s important that our exception will be an extension of the generic
    `Exception` class. Refer to the following code for more information:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果业务检查未通过，应用程序将抛出一些异常。例如，如果座位已经被预订或者如果客户没有足够的钱购买票，就会出现这种情况。为了保持我们的对话进行，我们的异常必须是通用`Exception`类的扩展。有关更多信息，请参考以下代码：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we use a runtime exception (for example, `EJBException`), the bean instance
    will be discarded, and the communication between the remote client and server
    will be dropped. So, always take care to choose the appropriate type of exception
    when dealing with EJBs—choose to throw a runtime exception if you are dealing
    with an unrecoverable scenario (the connection with the enterprise information
    system is dropped). This kind of exception is called a System Exception. On the
    other hand, consider throwing a checked exception (or simply not throwing exceptions
    at all), if you are dealing with a business kind of exception; for example, if
    the booked seat is already engaged. Recoverable exceptions are called Application
    Exceptions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用运行时异常（例如，`EJBException`），则将丢弃bean实例，并且远程客户端与服务器之间的通信将被切断。因此，在处理EJB时，始终要小心选择适当的异常类型——如果您处理的是不可恢复的场景（与企业信息系统之间的连接被切断），则选择抛出运行时异常。这种异常被称为系统异常。另一方面，如果您处理的是业务类型的异常；例如，如果预订的座位已经被占用，则考虑抛出检查异常（或者简单地不抛出异常）。可恢复异常被称为应用程序异常。
- en: There is also a possibility to mark a runtime exception (which would normally
    be a System Exception) as a recoverable exception, using the `@ApplicationException`
    annotation. You may even decide if the current transaction should be rolled back
    (which is the default behavior for system exceptions) using `@ApplicationException`
    (with rollback `true`) on an exception class or the `EJBContext.setRollbackOnly`
    statement inside a business method. The decision to roll back a transaction is
    up to the developer, and in most cases, it depends on the business scenario.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@ApplicationException`注解，还可以将运行时异常（通常为系统异常）标记为可恢复异常。您甚至可以使用`@ApplicationException`（带有`rollback
    true`）在异常类上或业务方法内的`EJBContext.setRollbackOnly`语句中决定当前事务是否应该回滚（系统异常的默认行为）。是否回滚事务的决定权在开发者手中，在大多数情况下，这取决于业务场景。
- en: Deploying the EJB application
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署EJB应用程序
- en: 'As it is, you should be able to package your EJB project by issuing the following
    Maven goal and starting a command-line prompt from your project root:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 按照现状，您应该能够通过执行以下Maven目标并从项目根目录启动命令行提示符来打包您的EJB项目：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command will compile and package the application that needs to
    be copied into the `deployments` folder of your application server. This is fine;
    however, we can expect lots more from Maven by installing just a couple of plugins.
    In our case, we will configure our project to use Maven''s WildFly plugin by adding
    the following section:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将编译并打包需要复制到应用程序服务器`deployments`文件夹中的应用程序。这是可以的；然而，通过仅安装几个插件，我们可以期待Maven提供更多功能。在我们的例子中，我们将通过添加以下部分来配置我们的项目以使用Maven的WildFly插件：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first part of the XML fragment, we specified the project's `finalName`
    attribute, which will dictate the name of the packaged artifact (in our example,
    the project's name corresponds to our project's artifact ID, so it will be named
    `ticket-agency-ejb.jar`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML片段的第一部分，我们指定了项目的`finalName`属性，这将决定打包构件的名称（在我们的例子中，项目的名称与我们的项目构件ID相对应，因此它将被命名为`ticket-agency-ejb.jar`）。
- en: The artifact ID named `wildfly-maven-plugin` will actually trigger the WildFly
    Maven plugin that will be used to deploy our project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`wildfly-maven-plugin`的构件ID将实际触发用于部署我们项目的WildFly Maven插件。
- en: 'So, once you have configured the WildFly plugin, your application can be deployed
    automatically by entering from your project root. This can be done by typing the
    following command in the console:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦您配置了WildFly插件，您就可以通过从项目根目录进入来自动部署应用程序。这可以通过在控制台中键入以下命令来完成：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since deployment is a repetitive task for a developer, it would be convenient
    to execute this operation from within the Eclipse environment. All you need is
    to create a new **Run Configurations** setting from the upper menu by navigating
    to **Run** | **Run Configurations**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于部署对于开发者来说是一项重复性任务，因此从Eclipse环境中执行此操作将非常方便。您只需要从菜单中选择**运行** | **运行配置**来创建一个新的**运行配置**设置。
- en: 'Enter the project''s base directory (hint: the **Browse Workspace...** utility
    will help you pick up the project from your project list) and type your Maven
    goal into the **Goals** textbox, as shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 进入项目的基目录（提示：**浏览工作区...**实用程序可以帮助您从项目列表中选择项目）并在**目标**文本框中输入您的Maven目标，如下面的屏幕截图所示：
- en: '![Deploying the EJB application](img/00036.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![部署EJB应用程序](img/00036.jpeg)'
- en: Once this is done, please ensure that your WildFly instance is running. Click
    on **Apply** to save your configuration and then click on **Run** to execute the
    deployment of the application. The Maven plugin will activate and once it is verified
    that all classes are up to date, start deploying the applications to WildFly using
    the remote API. Note that you do not need to pass any username or password for
    the deployment. This is possible because you are deploying your application from
    the same machine that WildFly is installed on. A local user authentication is
    done under the hood so that programmers will not need to cover this on their development
    machines.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，请确保您的WildFly实例正在运行。单击**应用**以保存您的配置，然后单击**运行**以执行应用程序的部署。Maven插件将激活，一旦验证所有类都已更新，它将开始使用远程API将应用程序部署到WildFly。请注意，您不需要传递任何用户名或密码进行部署。这是因为您是从安装WildFly的同一台机器上部署应用程序的。在幕后进行本地用户身份验证，这样程序员就不需要在他们的开发机器上处理这个问题。
- en: 'After issuing the command, you should expect a success message on the Maven
    console, as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行命令后，你应该在Maven控制台上看到成功消息，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the other hand, on the WildFly console, you have quite a verbose output
    that points out some important EJB JNDI bindings (we will return to it in a minute)
    and informs us that the application has been deployed correctly. This is depicted
    in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在WildFly控制台上，您会看到相当冗长的输出，指出一些重要的EJB JNDI绑定（我们将在下一分钟回到它），并告知我们应用程序已正确部署。如下面的代码所示：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Despite the fact that we are working on WildFly, we can quite frequently see
    information from JBoss AS subsystems on the console. This is because WildFly is
    built straight on the JBoss AS 7 codebase, and should not be worried about.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们正在开发WildFly，但我们经常可以在控制台上看到来自JBoss AS子系统的信息。这是因为WildFly是直接基于JBoss AS 7代码库构建的，因此无需担心。
- en: Creating a remote EJB client
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建远程EJB客户端
- en: Creating a remote EJB client for the WildFly application server is very similar
    to AS7\. The big difference can be noticed between AS6 and newer releases.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为WildFly应用程序服务器创建远程EJB客户端与AS7非常相似。在AS6和较新版本之间可以明显看出差异。
- en: As a matter of fact, previous versions of WildFly (JBoss AS versions before
    7.x) used the JBoss naming project as the JNDI naming implementation, so developers
    are familiar with `jnp:// PROVIDER_URL` to communicate with the application server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，WildFly的早期版本（7.x之前的JBoss AS版本）使用JBoss命名项目作为JNDI命名实现，因此开发者熟悉使用`jnp:// PROVIDER_URL`与应用程序服务器通信。
- en: Starting with AS7, the JNP project is no longer used—neither on the server side
    nor on the client side. The client side of the JNP project has now been replaced
    by the jboss-remote-naming project. There were various reasons why the JNP client
    was replaced by the jboss-remote-naming project. One of them was that the JNP
    project did not allow fine-grained security configurations while communicating
    with the JNDI server. The jboss-remote-naming project is backed by the jboss-remoting
    project which allows much more and better control over security.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从AS7开始，JNP项目不再使用——无论是在服务器端还是客户端。JNP项目的客户端现在已被jboss-remote-naming项目取代。JNP客户端被jboss-remote-naming项目取代的原因有很多，其中之一是JNP项目在与JNDI服务器通信时不允许进行细粒度的安全配置。jboss-remote-naming项目由jboss-remoting项目支持，这允许对安全进行更多和更好的控制。
- en: Besides the new naming implementation in AS7 and WildFly, there is no longer
    any support to bind custom JNDI names to EJBs. So the beans are always bound to
    the spec's mandated `java:global`, `java:app`, and `java:module` namespaces. Therefore,
    setting the JNDI name for the session bean element via an annotation or configuration
    file is no longer supported.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了AS7和WildFly中的新命名实现外，不再支持将自定义JNDI名称绑定到EJB。因此，这些豆总是绑定到规范要求的`java:global`、`java:app`和`java:module`命名空间。因此，通过注解或配置文件设置会话豆元素的JNDI名称不再受支持。
- en: 'So, what will be the JNDI name used to invoke a stateless session bean? Here
    it is:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，将使用什么JNDI名称来调用无状态的会话豆？这里就是：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A bit verbose, isn''t it? However, the following table will help you get through
    it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点啰嗦，不是吗？然而，以下表格将帮助你理解：
- en: '| Element | Description |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `app-name` | This is the enterprise application name (without `ear`), if
    your EJB has been packed in an EAR |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `app-name` | 这是企业应用程序名称（不带`ear`），如果你的EJB被打包在一个EAR中 |'
- en: '| `module-name` | This is the module name (without `.jar` or `.war`), where
    your EJB has been packed |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `module-name` | 这是模块名称（不带`.jar`或`.war`），你的EJB已经被打包在这个模块中 |'
- en: '| `distinct-name` | Using this, you can optionally set a distinct name for
    each deployment unit |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `distinct-name` | 使用此选项，你可以为每个部署单元设置一个不同的名称 |'
- en: '| `bean-name` | This is the bean''s class name |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `bean-name` | 这是豆的类名 |'
- en: '| `fully-qualified-classname-of-the-remote-interface` | This is the fully qualified
    class name of the remote interface |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `fully-qualified-classname-of-the-remote-interface` | 这是远程接口的完全限定类名 |'
- en: 'So the corresponding JNDI binding for your `TheatreInfo EJB`, packaged into
    a file named `ticket-agency-ejb.jar`, will be:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的`TheatreInfo EJB`对应的JNDI绑定，打包在一个名为`ticket-agency-ejb.jar`的文件中，将是：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other hand, stateful EJBs will contain one more attribute, `?stateful`,
    at the bottom of the JNDI string; this will result in the following JNDI naming
    structure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有状态的EJB将在JNDI字符串底部包含一个额外的属性，`?stateful`；这将导致以下JNDI命名结构：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, here''s the corresponding binding for the `TheatreBooker` class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里还有`TheatreBooker`类的对应绑定：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you pay attention to the server logs, you will see that once your application
    is deployed, a set of JNDI bindings will be displayed on the server console. For
    example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意服务器日志，你将看到一旦你的应用程序部署，一组JNDI绑定将在服务器控制台上显示。例如：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Some of these bindings reflect the standard bindings as per Java EE specifications
    plus JBoss custom bindings (`java:/jboss`). This information, as it is, is not
    relevant for us but can be use to build our EJB client lookup string by replacing
    the Java EE (or JBoss-specific prefix) with `ejb:/`. For example, replace `java:/global`
    with `ejb:`, and you will save yourself the headache of referring to the EJB lookup
    string.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些绑定反映了Java EE规范的标准绑定以及JBoss自定义绑定（`java:/jboss`）。这些信息本身对我们来说并不相关，但可以通过用`ejb:/`替换Java
    EE（或JBoss特定前缀）来构建我们的EJB客户端查找字符串。例如，将`java:/global`替换为`ejb:`，这样你就可以避免引用EJB查找字符串的麻烦。
- en: Once we are done with decoding the JNDI binding string, we will code our EJB
    client. We have already created a separate subproject for it (`ticket-agency-ejb-client`)
    at the beginning of this chapter, but we must still complete its configuration
    before we dive into coding.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了JNDI绑定字符串的解码，我们就会编写我们的EJB客户端。我们已经在本章开头为它创建了一个单独的子项目（`ticket-agency-ejb-client`），但我们在开始编码之前必须完成其配置。
- en: Configuring the client's project object module
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置客户端的项目对象模块
- en: 'Configuring the client dependencies (in `pom.xml`) will basically require all
    the libraries that connect and transport data to the server, along with the required
    EJB client dependencies. The first thing we will add, just as we did for the server
    project, is the BOM for the EJB client dependencies, which is demonstrated in
    the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 配置客户端依赖项（在`pom.xml`中）基本上需要连接和传输数据到服务器的所有库，以及所需的EJB客户端依赖项。我们将添加的第一件事，就像我们为服务器项目所做的那样，是EJB客户端依赖项的BOM，如下代码片段所示：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we will add a set of dependencies that are needed to resolve the EJB
    interfaces (`ticket-agency-ejb artifact`), the JBoss'' transaction API (needed
    as EJBs are transaction-aware components), the `jboss-ejb-api` and `ejb-client`
    APIs, the `org.jboss.xnio` and `org.jboss.xnio` APIs (which provide a low-level
    input/output implementation), the `org.jboss.remoting3` API (the core transport
    protocol), which in turn requires `org.jboss.sasl` (to secure the transport),
    and finally, the `org.jboss.marshalling` API (to serialize the objects that are
    sent to and received from the server). This is shown in the following code snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一组必要的依赖项，用于解析 EJB 接口（`ticket-agency-ejb artifact`），JBoss 的交易 API（因为
    EJB 是具有交易感知能力的组件，所以需要），`jboss-ejb-api` 和 `ejb-client` API，`org.jboss.xnio` 和 `org.jboss.xnio`
    API（提供低级输入/输出实现），`org.jboss.remoting3` API（核心传输协议），它反过来又需要 `org.jboss.sasl`（以安全传输），最后是
    `org.jboss.marshalling` API（用于序列化发送到和从服务器接收的对象）。这在上面的代码片段中显示：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Many of these dependencies use the runtime scope. This means that classes that
    are provided by them are not used directly by our code; they are not needed to
    be bundled within our application package, but they are required at runtime.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些依赖项使用运行时作用域。这意味着它们提供的类不是直接由我们的代码使用；它们不需要包含在我们的应用程序包中，但在运行时是必需的。
- en: Coding the EJB client
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 EJB 客户端
- en: 'We are done with the configuration. We will finally proceed with adding a new
    Java class `com.packtpub.wflydevelopment.chapter3.client.TicketAgencyClient`,
    which will communicate with the ticket booking machine''s EJB application. This
    is shown in the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了配置。我们最终将添加一个新的 Java 类 `com.packtpub.wflydevelopment.chapter3.client.TicketAgencyClient`，它将与票务预订机的
    EJB 应用程序进行通信。这在上面的代码片段中显示：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Maven, the appropriate location for most of the resource files (like mentioned
    properties) is the `src/main/resources` directory.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Maven 中，大多数资源文件（如提到的属性）的适当位置是 `src/main/resources` 目录。
- en: 'The contents of the `jboss-ejb-client.properties` file are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`jboss-ejb-client.properties` 文件的内容如下：'
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is also a `remote.connectionprovider.create.options.org .xnio.Options.SSL_ENABLED`
    property, which enables the encryption of the XNIO connection; otherwise, plaintext
    will be used. (In [Chapter 10](part0054_split_000.html#page "Chapter 10. Securing
    WildFly Applications"), *Securing WildFly Applications*, we will discuss using
    SSL to secure the connection between the client and server.)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `remote.connectionprovider.create.options.org.xnio.Options.SSL_ENABLED`
    属性，它启用了 XNIO 连接的加密；否则，将使用明文。([第 10 章](part0054_split_000.html#page "第 10 章。保护
    WildFly 应用程序")，*保护 WildFly 应用程序*，我们将讨论使用 SSL 保护客户端和服务器之间的连接。)
- en: 'The `remote.connections` property can be set to define a list of logical names
    that will be used for connection purposes by the `remote.connection.[name].host`
    and `remote.connection.[name].port` attributes. If you define more than one connection,
    as in the following example, the connections will be split across various destinations,
    as shown in the following code snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `remote.connections` 属性设置为定义一组逻辑名称，这些名称将由 `remote.connection.[name].host`
    和 `remote.connection.[name].port` 属性用于连接目的。如果您定义了多个连接，如以下示例所示，连接将分布在各种目的地之间，如以下代码片段所示：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The default port used by the remoting framework is `8080`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 远程框架使用的默认端口是 `8080`。
- en: You may wonder how EJB remoting can work on the same port as the HTTP protocol.
    Starting from WildFly, remoting uses the HTTP protocol upgrade mechanism. The
    first connection is done on the `8080` port (via HTTP), then it is upgraded to
    EJB remoting, and switched to another port (chosen by WildFly).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道 EJB 远程如何在与 HTTP 协议相同的端口上工作。从 WildFly 开始，远程使用 HTTP 协议升级机制。第一个连接是在 `8080`
    端口（通过 HTTP）完成的，然后升级到 EJB 远程，并切换到另一个端口（由 WildFly 选择）。
- en: Running the client application
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行客户端应用程序
- en: 'In order to run your client application, the last requirement will be to add
    the required Maven plugins, which are needed to run the remote EJB client. This
    is given in the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行您的客户端应用程序，最后一个要求将是添加所需的 Maven 插件，这些插件是运行远程 EJB 客户端所必需的。这在上面的代码片段中给出：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once all the plugins are in place, you can compile and execute your project
    by issuing the following Maven goal:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有插件都到位，您可以通过以下 Maven 目标编译和执行您的项目：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding command can be executed either from a shell (positioned in the
    project''s `root` folder) or from your Eclipse runtime configuration, as shown
    in the following screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令可以从shell（位于项目的`root`文件夹中）或从您的Eclipse运行时配置中执行，如下面的截图所示：
- en: '![Running the client application](img/00037.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![运行客户端应用程序](img/00037.jpeg)'
- en: 'If executed from the Eclipse environment, you should be able to see the following
    GUI screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从Eclipse环境中执行，您应该能够看到以下GUI截图：
- en: '![Running the client application](img/00038.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![运行客户端应用程序](img/00038.jpeg)'
- en: 'At the moment, our application provides three functions: a book to book a seat,
    a list to list all the theatre seats, and money to retrieve the account balance.
    In the next sections, we will enrich our application by adding some more commands.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序提供了三个功能：一本书来预订座位，一个列表来列出所有剧院座位，以及金钱来检索账户余额。在下一节中，我们将通过添加更多命令来丰富我们的应用程序。
- en: Adding user authentication
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加用户身份验证
- en: If you are running this example from a client that is located on the same machine
    as the application server, the remoting framework will silently allow communication
    between the client and your EJB's classes. On the other hand, for a client located
    on a remote system, you will be required to provide authentication for your requests.
    In order to add an application user, launch the `add-user.sh` (or `add-user.bat`)
    script, which is located at `JBOSS_HOME/bin`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从位于应用程序服务器同一台机器上的客户端运行此示例，远程框架将静默允许客户端和您的EJB类之间的通信。另一方面，对于位于远程系统上的客户端，您将需要为您的请求提供身份验证。为了添加应用程序用户，启动位于`JBOSS_HOME/bin`的`add-user.sh`（或`add-user.bat`）脚本。
- en: 'Here''s a transcript of a user creation example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个用户创建示例的记录：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The defined user will be added for you in the `application-user.properties`
    file located in your `configuration` folder.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的用户将自动添加到位于您的`configuration`文件夹中的`application-user.properties`文件中。
- en: 'This file contains the default security realm named `ApplicationRealm`. This
    security realm uses the following format to store passwords:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含名为`ApplicationRealm`的默认安全域。此安全域使用以下格式存储密码：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the passwords you''ve just entered, the file will contain the following
    entry:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您刚刚输入的密码，文件将包含以下条目：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, insert the username and password information into `jboss-ejb-client.properties`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将用户名和密码信息插入到`jboss-ejb-client.properties`文件中：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, with all the previous information in the right place, you will be able
    to connect to your EJB application from a client that does not reside on the same
    machine as the server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有先前信息都已放置在正确的位置，您将能够从不在与服务器同一台机器上的客户端连接到您的EJB应用程序。
- en: 'You can also force the normal authentication process on your local machine,
    by adding the following line to the `jboss-ejb-client` properties:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在本地机器上添加以下行到`jboss-ejb-client`属性中，强制执行正常的身份验证过程：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using the EJB timer service
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EJB计时器服务
- en: Applications that model business workflows often rely on timed notifications.
    The timer service of the enterprise bean container enables you to schedule timed
    notifications for all types of enterprise beans, except for stateful session beans.
    You can schedule a timed notification to occur according to a calendar schedule
    either at a specific time, after the duration of a time period, or at timed intervals.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟业务工作流程的应用程序通常依赖于定时通知。企业Bean容器中的计时器服务允许您为所有类型的企业Bean（除了有状态的会话Bean）安排定时通知。您可以根据日历计划在特定时间、时间段的持续时间后或定时间隔发生定时通知。
- en: 'There can be two main types of EJB timers: programmatic timers and automatic
    timers. Programmatic timers are set by explicitly calling one of the timer creation
    methods of the `TimerService` interface. Automatic timers are created upon the
    successful deployment of an enterprise bean, which contains a method annotated
    with the `java.ejb.Schedule` or `java.ejb.Schedules` annotations. Let''s see both
    approaches in the following sections.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: EJB计时器主要有两种类型：编程式计时器和自动计时器。编程式计时器是通过显式调用`TimerService`接口的计时器创建方法来设置的。自动计时器是在企业Bean成功部署时创建的，该Bean包含带有`java.ejb.Schedule`或`java.ejb.Schedules`注解的方法。让我们在以下章节中查看这两种方法。
- en: Programmatic timer creation
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程式计时器创建
- en: To create a timer, the bean invokes one of the `create` methods of the `TimerService`
    interface. These methods allow for either single-action, interval, or calendar-based
    timers to be created.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个计时器，Bean将调用`TimerService`接口的`create`方法之一。这些方法允许创建单次动作、间隔或基于日历的计时器。
- en: 'The simplest way to get a `TimerService` instance is to use resource injection.
    For example, in the `TheatreBox` singleton EJB, we will use the `@Resource` annotation
    to inject a `TimerService` object, as shown in the following code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`TimerService`实例的最简单方法是使用资源注入。例如，在`TheatreBox`单例EJB中，我们将使用`@Resource`注解注入一个`TimerService`对象，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The duration specifies the time (in milliseconds) when the single timer is
    fired. The method that will fire the timer will use the `TimerService` instance
    to invoke `createSingleActionTimer`, passing the duration and an instance of the
    `TimerConfig` class as an argument, which may optionally contain some basic information
    (such as the description of the timer). This is shown in the following code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间指定了单次计时器触发的时间（以毫秒为单位）。将触发计时器的那个方法将使用`TimerService`实例来调用`createSingleActionTimer`方法，并将持续时间以及`TimerConfig`类的实例作为参数传递，该实例可以包含一些基本信息（例如计时器的描述）。这在上面的代码片段中有所展示：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will create a callback method named `timeout` and use the `@Timeout`
    annotation on top of the method. In the `timeout` method, we could, for example,
    reinitialize our singleton by invoking the `setupTheatre` method. Nothing fancy;
    however, this should give you an idea of how to get working with a single action
    timer. Refer to the following code for more information:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为`timeout`的回调方法，并在方法上方使用`@Timeout`注解。在`timeout`方法中，例如，我们可以通过调用`setupTheatre`方法来重新初始化我们的单例。没有什么花哨的；然而，这应该能给你一个如何使用单次动作计时器的想法。有关更多信息，请参考以下代码：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Scheduling timer events
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计划计时器事件
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first thing we should account for is the resource injection of the `Timer`
    object `[1]`, which will be used in the `cancelTimers` method `[4]` to cancel
    all the scheduling when the theatre is fully booked. Please note that the `timerService.getTimers()`
    method retrieves all active timers associated only with the current bean. In order
    to get all timers from your application module, you have to use the `timerService.getAllTimers()`
    method, which was added recently in EJB 3.2.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该考虑的是`Timer`对象的资源注入[1]，它将在`TheatreBox`单例的`cancelTimers`方法[4]中用于取消所有调度，当剧院完全订满时。请注意，`timerService.getTimers()`方法检索仅与当前Bean关联的所有活动计时器。为了从您的应用程序模块中获取所有计时器，您必须使用最近在EJB
    3.2中添加的`timerService.getAllTimers()`方法。
- en: Next, pay attention to the `Schedule` annotation `[2]` we are using, which will
    fire a non-persistent timer each minute.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意我们使用的`Schedule`注解[2]，它将每分钟触发一个非持久计时器。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Persistent timers (the default option) can survive application and server crashes.
    When the system recovers, any persistent timers will be recreated and missed callback
    events will be executed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 持久计时器（默认选项）可以在应用程序和服务器崩溃后存活。当系统恢复时，任何持久计时器都将被重新创建，并且丢失的回调事件将被执行。
- en: When a replay of missed timer events is not desired, a non-persistent timer
    should be used, as shown in the preceding example.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当不希望重放丢失的计时器事件时，应使用非持久计时器，如前例所示。
- en: When an action is fired, the `automaticCustomer` method starts scanning the
    theatre seats for an available seat. (Nothing too complex; `findSeat` starts looking
    from the first available seat.)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个动作被触发时，`automaticCustomer`方法开始扫描剧院座位以寻找一个可用的座位。（没有什么太复杂的；`findSeat`从第一个可用的座位开始查找。）
- en: Finally, if there are seats still available, the `buyTicket` method `[3]` of
    the `TheatreBox` singleton will be used to short circuit the purchase of the seat
    (obviously, we won't need to check the money for our automatic customer).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果还有座位可用，`TheatreBox`单例的`buyTicket`方法[3]将被用来短路购买座位（显然，我们不需要检查自动客户的金钱）。
- en: Adding asynchronous methods to our EJBs
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将异步方法添加到我们的EJB中
- en: Before the EJB 3.1 specification, the only way to provide asynchronous capabilities
    to enterprise applications was using message-driven bean recipes. This remains
    substantially a best practice, and we are going to discuss this in depth in [Chapter
    6](part0035_split_000.html#page "Chapter 6. Developing Applications with JBoss
    JMS Provider"), *Developing Applications with JBoss JMS Provider*; however, in
    some cases, it might be desirable (and easier) to use these asynchronous features
    from a component that follows the classical request-reply pattern.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在EJB 3.1规范之前，向企业应用提供异步功能的方法是使用消息驱动bean配方。这仍然是一个最佳实践，我们将在[第6章](part0035_split_000.html#page
    "第6章。使用JBoss JMS提供程序开发应用程序")中深入讨论，*使用JBoss JMS提供程序开发应用程序*；然而，在某些情况下，可能希望（并且更容易）从遵循经典请求-响应模式的组件中使用这些异步功能。
- en: You can make the EJB's method asynchronous by simply tagging it with the `@Asynchronous`
    annotation. Each time this method is invoked, it will immediately return, regardless
    of how long the method actually takes to complete.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单地使用`@Asynchronous`注解标记EJB的方法来使其异步。每次调用此方法时，它将立即返回，无论该方法实际上需要多长时间才能完成。
- en: 'This can be used in one of two ways:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种方式使用：
- en: The first technique is a fire-and-forget manner, where the request is made up
    of the EJB and the client is not concerned about the success or failure of the
    request.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种技术是一种“点火并忘记”的方式，其中请求由EJB发起，客户端不关心请求的成功或失败。
- en: The second modus operandi invokes the method but does not wait for the method
    to be completed. The method returns a `Future` object. This object is used later
    to determine the result of the request.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种操作方式调用方法但不等待方法完成。方法返回一个`Future`对象。该对象用于稍后确定请求的结果。
- en: Using fire-and-forget asynchronous calls
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用“点火并忘记”的异步调用
- en: 'If you don''t care about the async result, you can just have your `async` method
    return void. For this purpose, we will add a new method named `bookSeatAsync`
    to `TheatreBooker` and simply tag it as `@Asynchronous`. This is shown in the
    following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不关心异步结果，您的`async`方法可以简单地返回void。为此，我们将向`TheatreBooker`添加一个名为`bookSeatAsync`的新方法，并简单地将其标记为`@Asynchronous`。这在下述屏幕截图中显示：
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, this method does not return anything; it just executes our synchronous
    `bookSeet` method. We will need to use some other instruments to check whether
    the transaction was completed successfully. For example, we can check from the
    theatre list whether the seat has been booked successfully.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种方法不返回任何内容；它只是执行我们的同步`bookSeet`方法。我们需要使用其他工具来检查交易是否成功完成。例如，我们可以从剧院列表中检查座位是否已成功预订。
- en: Returning a Future object to the client
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向客户端返回Future对象
- en: 'The other available option consists of returning a `java.util.concurrent.Future`
    object, which can later be inspected by our clients so that they know the outcome
    of our transaction. This is shown in the following code snippet:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可用的选项是返回一个`java.util.concurrent.Future`对象，该对象可以稍后由我们的客户端检查，以便他们知道交易的结果。这在下述代码片段中显示：
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, calls to the asynchronous `bookSeatAsync` method simply results,
    behind the scenes, in a `Runnable` or `Callable Java` object being created, which
    wraps the method and parameters you provide. This `Runnable` (or callable) object
    is given to an `Executor` object, which is simply a work queue attached to a thread
    pool.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对异步`bookSeatAsync`方法的调用在幕后简单地导致创建一个`Runnable`或`Callable Java`对象，该对象封装了您提供的方法和参数。这个`Runnable`（或可调用）对象被交给一个`Executor`对象，它只是一个附加到线程池的工作队列。
- en: After adding the work to the queue, the proxy version of the method returns
    a Future implementation that is linked to `Runnable`, which is now waiting in
    the queue.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在将工作添加到队列后，方法的代理版本返回一个与`Runnable`相关联的Future实现，该`Runnable`现在正在队列中等待。
- en: When `Runnable` finally executes the `bookSeatAsync` method, it takes the return
    value and sets it to `Future`, making it available to the caller.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Runnable`最终执行`bookSeatAsync`方法时，它将返回值设置到`Future`中，使其对调用者可用。
- en: When dealing with `Future` objects, the client code needs to be adapted. As
    a matter of fact, in standard synchronous calls, we used exceptions to intercept
    some events such as when the customer does not have enough money to complete the
    transaction. When using `Future` calls, there's a change in this paradigm. The
    call to the asynchronous method is detached from the client; however, we have
    the option to check if the `Future` work has been completed with the `isDone`
    method issued on the Future return value.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理`Future`对象时，客户端代码需要做出调整。实际上，在标准的同步调用中，我们使用异常来拦截一些事件，例如当客户没有足够的钱来完成交易时。当使用`Future`调用时，这种范式发生了变化。对异步方法的调用与客户端分离；然而，我们有选项通过在Future返回值上发出`isDone`方法来检查`Future`工作是否已完成。
- en: 'For this purpose, let''s add a `bookasync` command to `TicketAgencyClient`,
    which will issue asynchronous booking and a mail command that will simulate the
    reading of the outcome by e-mail, as shown in the following code snippet:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，让我们向`TicketAgencyClient`添加一个`bookasync`命令，该命令将执行异步预订，并模拟通过电子邮件读取结果的邮件命令，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is a screenshot of our richer client application:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们更丰富的客户端应用程序的截图：
- en: '![Returning a Future object to the client](img/00039.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![返回给客户端的Future对象](img/00039.jpeg)'
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the EJB basics and changes in EJB 3.2 by following
    a simple lab example, which was enriched progressively. This example showed how
    the Maven project can be used from within the Eclipse environment to assist you
    in assembling the project with all the necessary dependencies.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过一个简单的实验室示例，逐步丰富了EJB基础知识以及EJB 3.2的变化。这个示例展示了如何在Eclipse环境中使用Maven项目来协助你组装包含所有必要依赖项的项目。
- en: Up to now, we have just coded a remote standalone client for our application.
    In the next chapter, we will see how to add a web frontend to our example using
    the context and dependency injections, to bridge the gap between the web tier
    and enterprise tier.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只为我们的应用程序编写了一个远程独立客户端。在下一章中，我们将看到如何使用上下文和依赖注入将Web前端添加到我们的示例中，以弥合Web层和企业层之间的差距。
