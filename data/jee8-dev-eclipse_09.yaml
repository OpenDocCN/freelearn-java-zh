- en: Asynchronous Programming with JMS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JMS 进行异步编程
- en: 'In the last chapter, we learned how to create web services in JEE. We learned
    to create both RESTful and SOAP-based web services. In this chapter, we will learn
    how to work with messaging systems in JEE. Thus far, we have seen examples of
    clients making requests to the JEE server and waiting till the server sends a
    response back. This is the synchronous model of programming. This model of programming
    may not be suitable when the server takes a long time to process requests. In
    such cases, a client might want to send a request to the server and return immediately
    without waiting for the response. The server would process the request and somehow
    make the result available to the client. Requests and responses in such scenarios
    are sent through messages. Furthermore, there is a message broker that makes sure
    that messages are sent to the appropriate recipients. This is also known as a
    **message-oriented architecture**. The following are some of the advantages of
    adopting a message-oriented architecture:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在 JEE 中创建 Web 服务。我们学习了如何创建基于 RESTful 和 SOAP 的 Web 服务。在本章中，我们将学习如何在
    JEE 中与消息系统一起工作。到目前为止，我们已经看到了客户端向 JEE 服务器发出请求并等待服务器发送响应的示例。这是编程的同步模型。当服务器处理请求需要很长时间时，这种编程模型可能不适用。在这种情况下，客户端可能希望向服务器发送请求并立即返回，而不必等待响应。服务器将处理请求，并以某种方式将结果提供给客户端。在这种情况下，请求和响应是通过消息发送的。此外，还有一个消息代理确保消息被发送到适当的接收者。这也被称为**面向消息的架构**。以下是采用面向消息的架构的一些优点：
- en: It can greatly improve the scalability of the application. Requests are put
    in a queue at one end, and at the other end there could be many handlers listening
    to the queue and processing the requests. As the load increases, more handlers
    can be added, and when the load reduces, some of the handlers can be taken off.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以极大地提高应用程序的可伸缩性。请求被放入一端的队列中，而在另一端可能有多个处理程序正在监听队列并处理请求。随着负载的增加，可以添加更多的处理程序，而当负载减少时，可以移除一些处理程序。
- en: Messaging systems can act as glue between disparate software applications. An
    application developed using PHP can put a JSON or XML message in a messaging system,
    which can be processed by a JEE application.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息系统可以作为不同软件应用程序之间的粘合剂。使用 PHP 开发的应用程序可以将 JSON 或 XML 消息放入消息系统中，该消息可以被 JEE 应用程序处理。
- en: It can be used to implement an event-driven program. Events can be put as messages
    in a messaging system, and any number of listeners can process events at the other
    end.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用来实现事件驱动的程序。事件可以作为消息放入消息系统中，并且任何数量的监听器都可以在另一端处理事件。
- en: It can reduce the impact of system outages in your application because messages
    are persisted till they are processed.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以减少应用程序中系统故障的影响，因为消息在处理之前是持久化的。
- en: There are many enterprise messaging systems, such as Apache ActiveMQ ([http://activemq.apache.org/](http://activemq.apache.org/)),
    RabbitMQ ([https://www.rabbitmq.com/](https://www.rabbitmq.com/)), and MSMQ ([https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx)).
    The **Java Messaging Service** (**JMS**) specification provides a uniform interface
    for working with many different messaging systems. JMS is also a part of the overall
    Java EE specifications. Refer to [https://javaee.github.io/tutorial/jms-concepts.html#BNCDQ](https://javaee.github.io/tutorial/jms-concepts.html#BNCDQ) for
    an overview of JMS APIs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 企业级消息系统有很多，例如 Apache ActiveMQ ([http://activemq.apache.org/](http://activemq.apache.org/))、RabbitMQ
    ([https://www.rabbitmq.com/](https://www.rabbitmq.com/)) 和 MSMQ ([https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx))。Java
    消息服务（**JMS**）规范为与许多不同的消息系统工作提供了一个统一的接口。JMS 也是整体 Java EE 规范的一部分。有关 JMS API 的概述，请参阅
    [https://javaee.github.io/tutorial/jms-concepts.html#BNCDQ](https://javaee.github.io/tutorial/jms-concepts.html#BNCDQ)。
- en: 'There are two types of message containers in any messaging system:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 任何消息系统都有两种类型的消息容器：
- en: '**Queue**: This is used for point-to-point messaging. One message producer
    puts a message in a queue, and only one message consumer receives the message.
    There can be multiple listeners for a queue, but only one listener receives the
    message. However, the same listener doesn''t necessarily get all the messages.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**：这是用于点对点消息的。一个消息生产者将消息放入队列，只有一个消息消费者接收该消息。可以为队列设置多个监听器，但只有一个监听器接收消息。然而，同一个监听器不一定能接收到所有消息。'
- en: '**Topic**: This is used in the publish-subscribe type of scenario. One message
    producer puts a message in a topic, and many subscribers receive the message.
    Topics are useful for broadcasting messages.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：这在发布-订阅类型的场景中使用。一个消息生产者将消息放入一个主题，许多订阅者接收该消息。主题对于广播消息很有用。'
- en: 'We will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Sending and receiving messages to and from queues and topics using JMS APIs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JMS API在队列和主题之间发送和接收消息
- en: Creating JMS applications using JSP, JSF, and CDI beans
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSP、JSF和CDI Bean创建JMS应用程序
- en: Consuming messages using MDBs (message-driven beans)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息驱动Bean（MDB）消费消息
- en: We will see examples of how to use queues and topics in this chapter. We will
    use a GlassFish Server, which has a built-in JMS provider. We will use JMS APIs
    to implement a use case in the *Course Management* application, the same application
    that we have been building in the other chapters of this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中看到如何使用队列和主题的示例。我们将使用具有内置JMS提供程序的GlassFish服务器。我们将使用JMS API在*课程管理*应用程序中实现一个用例，这是我们在这本书的其他章节中一直在构建的应用程序。
- en: Steps to send and receive messages using JMS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMS发送和接收消息的步骤
- en: 'However, before we start using JMS APIs, let''s take a look at the generic
    steps involved in using them. The following steps show how to send a message to
    a queue and receive it. Although the steps focus on queues, the steps for topics
    are similar, but with appropriate topic-related classes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始使用JMS API之前，让我们看看使用它们所涉及的通用步骤。以下步骤展示了如何向队列发送消息并接收它。尽管步骤集中在队列上，但主题的步骤类似，但需要使用适当的主题相关类：
- en: 'Look up `ConnectionFactory` using JNDI:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JNDI查找`ConnectionFactory`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a JMS connection and start it:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个JMS连接并启动它：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a JMS session:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个JMS会话：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Look up JMS `Queue`/`Topic`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找JMS `Queue`/`Topic`：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For sending messages, perform the following steps:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于发送消息，执行以下步骤：
- en: 'Create a sender:'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个发送者：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create the message. It can be of any of the following types: `TextMessage`/`ObjectMessage`/`MapMessage`/`BytesMessage`/`StreamMessage`:'
  id: totrans-28
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建消息。它可以以下列任何类型：`TextMessage`/`ObjectMessage`/`MapMessage`/`BytesMessage`/`StreamMessage`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Send the message:'
  id: totrans-30
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送消息：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Close the connection when no longer needed:'
  id: totrans-32
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当不再需要时关闭连接：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For receiving messages, perform the following steps:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于接收消息，执行以下步骤：
- en: 'Create a receiver:'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接收者：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Register a message listener or call the `receive` method:'
  id: totrans-37
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册消息监听器或调用`receive`方法：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, you can use any variation of the receive method:'
  id: totrans-39
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你可以使用接收方法的任何变体：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or you can use this:'
  id: totrans-41
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者你可以使用以下方法：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or you can use this:'
  id: totrans-43
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者你可以使用以下方法：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In a JEE application that uses EJB, it is recommended to use MDBs. We will see
    an example of MDBs later in this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用EJB的JEE应用程序中，建议使用MDB。我们将在本章后面看到MDB的示例。
- en: 'When done, close the connection. This stops message listeners too:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，关闭连接。这也会停止消息监听器：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some of the steps can be skipped when JMS annotations are used or when MDBs
    are used to receive messages. We will see examples later.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JMS注解或使用MDB接收消息时，可以跳过一些步骤。我们将在稍后看到示例。
- en: Now, let's create a working example of sending and receiving messages using
    JMS. Make sure that you have installed the GlassFish application server (refer
    to the *Installing the GlassFish Server* section in [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Introducing JEE and Eclipse*) and configured it in Eclipse JEE (refer to the
    *Configuring the GlassFish Server in Eclipse* section in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*). The use case that we will implement in
    this example is of adding a new course. Although this is not a strong use case
    for asynchronous processing, we will assume that this operation takes a long time
    and needs to be handled asynchronously.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个使用JMS发送和接收消息的工作示例。确保你已经安装了GlassFish应用程序服务器（参考第1章的*安装GlassFish服务器*部分，*介绍JEE和Eclipse*），并在Eclipse
    JEE中配置了它（参考第7章的*在Eclipse中配置GlassFish服务器*部分，*使用EJB创建JEE应用程序*）。在这个示例中，我们将实现添加新课程的使用案例。尽管这不是异步处理的一个强用例，但我们将假设这个操作需要很长时间，并且需要异步处理。
- en: Creating queues and topics in GlassFish
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GlassFish中创建队列和主题
- en: Let's create one queue and one topic in GlassFish. Make sure that the GlassFish
    Server is running. Open the GlassFish admin console. You can right-click the GlassFish
    Server instance configured in Eclipse (in the Servers view) and select GlassFish
    | View Admin Console. This opens the admin console in the built-in Eclipse browser.
    If you want to open it outside Eclipse, in a browser, then browse to `http://localhost:4848/`
    (assuming the default GlassFish installation).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在GlassFish中创建一个队列和一个主题。确保GlassFish服务器正在运行。打开GlassFish管理控制台。您可以在Eclipse（在“服务器视图”）中配置的GlassFish服务器实例上右键单击，并选择GlassFish
    | 查看管理控制台。这将在内置的Eclipse浏览器中打开管理控制台。如果您想在外部Eclipse中打开它，在浏览器中，则浏览到`http://localhost:4848/`（假设默认的GlassFish安装）。
- en: 'We will first create a JMS connection factory. In the admin console, go to the Resources
    | JMS Resources | Connection Factories page. Click the New button to create a
    new connection factory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将创建一个JMS连接工厂。在管理控制台中，转到“资源”|“JMS资源”|“连接工厂”页面。点击“新建”按钮来创建一个新的连接工厂：
- en: '![](img/00199.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00199.jpeg)'
- en: Figure 10.1: Create a JMS connection factory
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：创建JMS连接工厂
- en: Enter JNDI Name of the factory as `jms/CourseManagementCF` and select javax.jms.ConnectionFactory
    as the Resource Type. Leave the default values for Pool Settings. Click OK.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输入工厂的JNDI名称为`jms/CourseManagementCF`，并选择javax.jms.ConnectionFactory作为资源类型。保留池设置的默认值。点击“确定”。
- en: 'To create queues and topics, go to the Resources | JMS Resources | Destination
    Resources page. Click the New button:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建队列和主题，转到“资源”|“JMS资源”|“目的地资源”页面。点击“新建”按钮：
- en: '![](img/00200.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/00200.jpeg)'
- en: 'Figure 10.2: Create a JMS queue'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：创建JMS队列
- en: Enter the JNDI Name of the queue as `jms/courseManagementQueue`, Physical Destination
    Name as `CourseManagementQueue`, and select javax.jms.Queue as the Resource Type.
    Click OK to create the queue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输入队列的JNDI名称为`jms/courseManagementQueue`，物理目的地名称为`CourseManagementQueue`，并选择javax.jms.Queue作为资源类型。点击“确定”以创建队列。
- en: Similarly, create the topic by entering the JNDI Name as `jms/courseManagementTopic`, Physical
    Destination Name as `CourseManagementTopic`, and select javax.jms.Topic as the Resource
    Type.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，通过输入JNDI名称为`jms/courseManagementTopic`，物理目的地名称为`CourseManagementTopic`，并选择javax.jms.Topic作为资源类型来创建主题。
- en: 'You should now have one queue and one topic configured in the Destination Resources
    page:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经在目的地资源页面中配置了一个队列和一个主题：
- en: '![](img/00201.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00201.jpeg)'
- en: 'Figure 10.3: Queue and topic created in GlassFish'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：在GlassFish中创建的队列和主题
- en: Creating JEE project for a JMS application
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为JMS应用程序创建JEE项目
- en: We will see examples of using JMS APIs in three different ways.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到使用JMS API的三种不同方式的示例。
- en: In the first example, we will create a simple `addCourse.jsp` page, one JSP
    bean, and one `Service` class that actually performs JMS tasks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将创建一个简单的`addCourse.jsp`页面，一个JSP Bean和一个实际执行JMS任务的`Service`类。
- en: In the second example, we will use JSF and managed beans. We will use JMS APIs
    in the managed beans. We will also see how to use JMS annotations in JSF managed
    beans.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将使用JSF和托管Bean。我们将在托管Bean中使用JMS API。我们还将看到如何在JSF托管Bean中使用JMS注解。
- en: In the last example, we will use MDBs to consume JMS messages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们将使用MDB来消费JMS消息。
- en: 'Let''s start with the first example, which uses JSP, bean, and JMS APIs. Create
    a web project by selecting File | New | Dynamic Web Project or File | New | Other
    and then Web | Dynamic Web Project:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个示例开始，该示例使用JSP、Bean和JMS API。通过选择“文件”|“新建”|“动态Web项目”或“文件”|“新建”|“其他”然后“Web”|“动态Web项目”来创建一个Web项目：
- en: '![](img/00202.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/00202.jpeg)'
- en: 'Figure 10.4: Create a dynamic web project for a JMS app'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：为JMS应用程序创建动态Web项目
- en: Enter the Project name as `CourseManagementJMSWeb`. Make sure that Target runtime
    is GlassFish . Click Next, and accept all the default options. Click Finish to
    create the project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输入项目名称为`CourseManagementJMSWeb`。确保目标运行时为GlassFish。点击“下一步”，接受所有默认选项。点击“完成”以创建项目。
- en: Creating JMS application using JSP and JSP bean
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSP和JSP Bean创建JMS应用程序
- en: Let's first create a JSP that displays the form to enter course details. We
    will also create a JSP bean to process the form data. Right-click on the `WebContent`
    folder under the project in the Project Explorer view and select New | JSP File.
    Create the JSP file named `addCourse.jsp`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个JSP页面，用于显示输入课程详情的表单。我们还将创建一个JSP Bean来处理表单数据。在项目资源管理器视图下的项目中的“WebContent”文件夹上右键单击，选择“新建”|“JSP文件”。创建名为`addCourse.jsp`的JSP文件。
- en: 'We will now create `CourseDTO` and the JSP bean called `CourseJSPBean`. Create the `CourseDTO`
    class in the `packt.jee.eclipse.jms.dto` package. Add the `id`, `name`, and `credits`
    properties, and the getters and setters for them:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建`CourseDTO`和名为`CourseJSPBean`的JSP bean。在`packt.jee.eclipse.jms.dto`包中创建`CourseDTO`类。添加`id`、`name`和`credits`属性，以及它们的getter和setter方法：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create `CourseJSPBean` in the `packt.jee.eclipse.jms.jsp.beans` package:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`packt.jee.eclipse.jms.jsp.beans`包中创建`CourseJSPBean`：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will implement the code to send the `CourseDTO` object to the JMS queue
    later in the `addCourse` method. For now, add the following code to `addCourse.jsp`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`addCourse`方法中稍后实现发送`CourseDTO`对象的代码。现在，将以下代码添加到`addCourse.jsp`中：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At the top of the JSP file, we check whether the form is submitted. If yes,
    we then create an instance of `CourseJSPBean` and set its properties with values
    from the form submission. Then, we call the `addCourse` method of the bean.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSP文件的顶部，我们检查表单是否已提交。如果是，我们则创建一个`CourseJSPBean`实例，并使用表单提交的值设置其属性。然后，我们调用bean的`addCourse`方法。
- en: Executing addCourse.jsp
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行addCourse.jsp
- en: 'We still haven''t added any code to put the `Course` object in the JMS queue.
    However, if you want to test the JSP and bean, add the project to the GlassFish
    server configured in Eclipse. To do this, right-click on the configured server
    in the Servers view of Eclipse and select the Add and Remove... option. Select
    the web project that we created and click on Finish. Make sure that the server
    is started and the status is [Started, Synchronized]:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有添加任何代码将`Course`对象放入JMS队列。然而，如果你想测试JSP和bean，请将项目添加到Eclipse中配置的GlassFish服务器。为此，在Eclipse的“服务器视图”中右键单击配置的服务器，然后选择“添加和移除...”选项。选择我们创建的Web项目，然后单击“完成”。确保服务器已启动，状态为[已启动，同步]：
- en: '![](img/00203.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![img/00203.jpeg](img/00203.jpeg)'
- en: 'Figure 10.5: Status of GlassFish after adding web project'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：添加Web项目后GlassFish的状态
- en: If the status is Republish, then right-click on the server and select the Publish
    option. If the status is Restart, right-click on the server and select the Restart
    option. You may not have to do this immediately after adding the project, but
    later when we make changes to the code, you may have to republish or restart the
    server, or both. So, keep an eye on the server status before you execute the code
    in Eclipse.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态是重新发布，则右键单击服务器并选择“发布”选项。如果状态是重启，则右键单击服务器并选择“重启”选项。你可能不需要在添加项目后立即执行此操作，但在我们修改代码后，你可能需要重新发布或重启服务器，或者两者都要。所以，在你在Eclipse中执行代码之前，请密切关注服务器状态。
- en: To execute `addCourse.jsp`, right-click on the file in either Project Explorer
    or the editor, and select the Run As | Run on Server option. This will open the
    built-in Eclipse browser and open JSP in it. You should see the form for adding
    the course details. If you click the Submit button, you should see the message
    that we added in JSP when the form is submitted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`addCourse.jsp`，在项目资源管理器或编辑器中右键单击文件，然后选择“运行方式 | 在服务器上运行”选项。这将打开内置的Eclipse浏览器并在其中打开JSP。你应该看到添加课程详情的表单。如果你点击“提交”按钮，你应该看到我们在JSP中添加的消息，当表单提交时。
- en: Let's now add a class to send the course details to the JMS queue.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一个类来将课程详情发送到JMS队列。
- en: Implementing JMS queue sender class
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现JMS队列发送类
- en: 'Let''s create the `CourseQueueSender` class in the `packt.jee.eclipse.jms`
    package with the following content:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`packt.jee.eclipse.jms`包中创建名为`CourseQueueSender`的类，内容如下：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the constructor, we look up the JMS connection factory and create the connection.
    We then create a JMS session and lookup queue with the JNDI name that we used
    for creating the queue in a previous section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们查找JMS连接工厂并创建连接。然后我们创建一个JMS会话，并使用我们在前面的部分中创建队列时使用的JNDI名称查找队列。
- en: 'Note that we did not specify any configuration properties when constructing
    `InitialContext`. This is because the code is executed in the same instance of
    the GlassFish Server that hosts the JMS provider. If you are connecting to a JMS
    provider hosted in a different GlassFish Server, then you will have to specify
    the configuration properties, particularly for the remote host, for example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在构建`InitialContext`时没有指定任何配置属性。这是因为代码是在托管JMS提供者的GlassFish Server的同一实例中执行的。如果你正在连接到托管在另一个GlassFish
    Server中的JMS提供者，那么你将不得不指定配置属性，特别是对于远程主机，例如：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `CourseQueueSender.sendAddcourseMessage` method creates instances of `QueueSender` and
    `ObjectMessage`. Because the producer and the consumer of the message in this
    example are in Java, we use `ObjectMessage`. However, if you are to send a message
    to a messaging system where the message is going to be consumed by a non-Java
    consumer, then you could create JSON or XML from the Java object and send `TextMessage`.
    We have already seen how to serialize Java objects to JSON and XML using JAXB
    and JSON-B in [Chapter 9](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating Web Services*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseQueueSender.sendAddcourseMessage` 方法创建了 `QueueSender` 和 `ObjectMessage`
    的实例。由于本例中的消息生产者和消费者都是 Java，我们使用了 `ObjectMessage`。然而，如果你需要向一个消息系统发送消息，而该消息将由非 Java
    消费者消费，那么你可以从 Java 对象创建 JSON 或 XML，并发送 `TextMessage`。我们已经在 [第 9 章](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建
    Web 服务* 中看到了如何使用 JAXB 和 JSON-B 将 Java 对象序列化为 JSON 和 XML。'
- en: 'Now, let''s modify the `addCourse` method in `CourseJSPBean` to use the `CourseQueueSender`
    class to send JMS messages. Note that we could create an instance of `CourseQueueSender`
    in the bean class, `CouseJSPBean`, but the bean is created every time the page
    is requested. So, `CourseQueueSender` will be created frequently and the lookup
    for the JMS connection factory and the queue will also execute frequently, which
    is not necessary. Therefore, we will create an instance of `CourseQueueSender`
    and save it in the HTTP session. Then, we will modify the `addCourse` method to
    take `HttpServletRequest` as a parameter. We will also get the `HttpSession` object
    from the request:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改 `CourseJSPBean` 中的 `addCourse` 方法，以使用 `CourseQueueSender` 类发送 JMS 消息。请注意，我们可以在
    `CouseJSPBean` 的类中创建 `CourseQueueSender` 的实例，但每次请求页面时都会创建一个 bean。因此，`CourseQueueSender`
    将频繁创建，JMS 连接工厂和队列的查找也将频繁执行，这是不必要的。因此，我们将创建一个 `CourseQueueSender` 的实例并将其保存在 HTTP
    会话中。然后，我们将修改 `addCourse` 方法以接受 `HttpServletRequest` 作为参数。我们还将从请求中获取 `HttpSession`
    对象：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we don't find the `CourseQueueSender` object in the session, then we will
    create one and save it in the session.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在会话中找不到 `CourseQueueSender` 对象，那么我们将创建一个并将其保存在会话中。
- en: 'We need to modify the call to the `addCourse` method from `addcourse.jsp`.
    Currently, we do not pass any argument to the method. However, with the preceding
    changes to the `addCourse` method, we need to pass the `HttpServletRequest` object
    to it. JSP has a built-in property called `pageContext` that provides access to
    the `HttpServletRequest` object. So, modify the code in `addCourse.jsp` where
    `courseService.addCourse` is called as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改 `addcourse.jsp` 中对 `addCourse` 方法的调用。目前，我们没有向该方法传递任何参数。然而，随着对 `addCourse`
    方法的先前更改，我们需要向其中传递 `HttpServletRequest` 对象。JSP 有一个内置属性 `pageContext`，它提供了对 `HttpServletRequest`
    对象的访问。因此，修改 `addCourse.jsp` 中调用 `courseService.addCourse` 的代码如下：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can test our code at this point, but although messages are sent to the queue,
    we haven't implemented any consumer to receive them from the queue. So, let's
    implement a JMS queue consumer for our `Course` queue.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试我们的代码，尽管消息已发送到队列，但我们还没有实现任何消费者来从队列中接收它们。因此，让我们为我们的 `Course` 队列实现一个 JMS
    队列消费者。
- en: Implementing JMS queue receiver class
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 JMS 队列接收类
- en: 'Let''s create the `CourseQueueReceiver` class in the `packt.jee.eclipse.jms`
    package with the following content:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `packt.jee.eclipse.jms` 包中创建 `CourseQueueReceiver` 类，其内容如下：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code to look up the connection factory and the queue is similar to that
    in `CourseQueueSender`. Note that the constructor takes a `name` argument. We
    don't really need to use the JMS API, but we will use it as an identifier for
    instances of the `CourseQueueReceiver` class. We register a message listener in
    the constructor, and in the `onMessage` method of the listener class we get the `CourseDTO`
    object from the message and print the message to the console. This message will
    appear in the GlassFish console in Eclipse when we execute the code. To keep the
    example simple, we have not implemented the code to save the `Course` information
    to the database, but you can do so using the JDBC or JDO APIs we learned about
    in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 查找连接工厂和队列的代码与`CourseQueueSender`中的代码类似。注意构造函数接受一个`name`参数。我们实际上并不需要使用JMS API，但我们将使用它作为`CourseQueueReceiver`类实例的标识符。我们在构造函数中注册一个消息监听器，并在监听器类的`onMessage`方法中从消息中获取`CourseDTO`对象并将消息打印到控制台。当我们执行代码时，这个消息将出现在Eclipse中的GlassFish控制台中。为了使示例简单，我们没有实现将`Course`信息保存到数据库的代码，但你可以使用我们在[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“创建JEE数据库应用程序”中学到的JDBC或JDO
    API来实现。
- en: We need to instantiate the `CourseQueueReceiver` class at application startup,
    so that it will start listening for the messages. One way to implement this is
    in a servlet that loads on startup.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在应用程序启动时实例化`CourseQueueReceiver`类，以便它开始监听消息。实现这一种方法是在一个启动时加载的servlet中。
- en: 'Let''s create the `JMSReceiverInitServlet` class in the `packt.jee.eclipse.jms.servlet`
    package. We will mark this servlet to load at startup using annotations and instantiate
    `CourseQueueReceiver` in the `init` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`packt.jee.eclipse.jms.servlet`包中创建`JMSReceiverInitServlet`类。我们将使用注解标记这个servlet在启动时加载，并在`init`方法中实例化`CourseQueueReceiver`：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Publish the project again in the server and execute `addCourse.jsp` (see the *Executing
    addCourse.jsp* section of this chapter). Switch to the Console view in Eclipse.
    You should see the message that we printed in the `onMessage` method in `CourseQueueReceiver`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在服务器上发布项目并执行`addCourse.jsp`（参见本章的*执行addCourse.jsp*部分）。切换到Eclipse中的控制台视图。你应该会看到我们在`CourseQueueReceiver`中的`onMessage`方法中打印的消息：
- en: '![](img/00204.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00204.jpeg)'
- en: 'Figure 10.6: Example of a console message from the JMS receiver class'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：JMS接收器类的控制台消息示例
- en: Adding multiple queue listeners
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加多个队列监听器
- en: 'Queues are meant for point-to-point communication, but this does not mean that
    there can''t be more than one listener for a queue. However, only one listener
    gets the message. Furthermore, it is not guaranteed that the same listener will
    get the message every time. If you want to test this, add one more instance of
    `CourseQueueReceiver` in `JMSReceiverInitServlet`. Let''s add the second instance
    with a different name, say `Receiver2`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 队列用于点对点通信，但这并不意味着一个队列不能有多个监听器。然而，只有一个监听器会接收到消息。此外，也不能保证同一个监听器每次都会接收到消息。如果你想测试这一点，在`JMSReceiverInitServlet`中添加一个`CourseQueueReceiver`的更多实例。让我们添加第二个实例，并给它一个不同的名字，比如`Receiver2`：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Republish the project, execute `addCourse.jsp`, and add a few courses. Check
    the Console messages. You may see that some of the messages were received by `Receiver1`
    and the others by `Receiver2`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重新发布项目，执行`addCourse.jsp`，并添加一些课程。检查控制台消息。你可能看到一些消息被`Receiver1`接收，而其他则被`Receiver2`接收：
- en: '![](img/00205.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00205.jpeg)'
- en: 'Figure 10.7: Console output showing multiple JMS receivers listening to a JMS
    queue'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：控制台输出显示多个JMS接收器正在监听JMS队列
- en: Implementing JMS topic publisher
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现JMS主题发布者
- en: Let's say that we want to inform a bunch of applications when a new course is
    added. Such use cases can be best implemented by a **JMS topic**. A topic can
    have many subscribers. When a message is added to the topic, all subscribers are
    sent the same message. This is unlike a queue, where only one queue listener gets
    a message.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在添加新课程时通知一组应用程序。这样的用例最好通过一个**JMS主题**来实现。一个主题可以有多个订阅者。当消息添加到主题时，所有订阅者都会收到相同的消息。这与队列不同，在队列中只有一个队列监听器会收到消息。
- en: Steps to publish messages to a topic and subscribe for messages are very similar
    to those for a queue, except for the different classes, and in some cases, different
    method names.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 发布消息到主题和订阅消息的步骤与队列的步骤非常相似，只是类不同，在某些情况下，方法名也不同。
- en: Let's implement a topic publisher, which we will use when the message for adding
    a course is successfully handled in the `onMessage` method of the listener class
    implemented in `CourseQueueReceiver`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个主题发布者，当在`CourseQueueReceiver`类中实现的监听器的`onMessage`方法成功处理添加课程的消息时，我们将使用它。
- en: 'Create `CourseTopicPublisher` in the `packt.jee.eclipse.jms` package with the
    following content:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`packt.jee.eclipse.jms`包中创建名为`CourseTopicPublisher`的类，内容如下：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code is quite simple and self-explanatory. Let''s now modify the queue
    receiver class that we implemented, `CourseQueueReceiver`, to publish a message
    to the topic from the `onMessage` method, after the message from the queue is
    handled successfully:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单且易于理解。现在让我们修改我们实现的队列接收器类`CourseQueueReceiver`，在队列中的消息成功处理后，从`onMessage`方法向主题发布消息：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implementing JMS topic subscriber
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现JMS主题订阅者
- en: 'We will now implement a topic subscriber class to receive messages published
    to the topic we created earlier. Create a `CourseTopicSubscriber` class in the `packt.jee.eclipse.jms`
    package with the following content:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一个主题订阅者类来接收发布到我们之前创建的主题的消息。在`packt.jee.eclipse.jms`包中创建名为`CourseTopicSubscriber`的类，内容如下：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Again, the JMS APIs to subscribe to a topic are similar to those in `CourseQueueReceiver`,
    but with different class names and method names. We also identify subscribers
    with names so that we know which instance of the class receives the message.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，订阅主题的JMS API与`CourseQueueReceiver`中的类似，但类名和方法名不同。我们还通过名称标识订阅者，以便我们知道哪个类的实例接收了消息。
- en: In the preceding example, we created the topic subscriber by calling `TopicSession.createSubscriber`.
    In this case, the subscriber will receive messages from the topic as long as the
    subscriber is active. If the subscriber becomes inactive and then active again,
    it loses messages published by the topic during that period. If you want to make
    sure that the subscriber receives all the messages, you need to create a durable
    subscription using `TopicSession.createDurableSubscriber`. Along with the topic
    name, this method takes the subscriber name as the second argument. Refer to [https://javaee.github.io/javaee-spec/javadocs/javax/jms/TopicSession.html#createDurableSubscriber-javax.jms.Topic-java.lang.String-](https://javaee.github.io/javaee-spec/javadocs/javax/jms/TopicSession.html#createDurableSubscriber-javax.jms.Topic-java.lang.String-) for
    more information.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过调用`TopicSession.createSubscriber`创建了主题订阅者。在这种情况下，订阅者将接收主题的消息，只要订阅者处于活动状态。如果订阅者变得不活跃然后再次活跃，它将丢失在该期间发布的主题消息。如果您想确保订阅者接收所有消息，您需要使用`TopicSession.createDurableSubscriber`创建一个持久订阅。除了主题名称外，此方法还接受订阅者名称作为第二个参数。有关更多信息，请参阅[https://javaee.github.io/javaee-spec/javadocs/javax/jms/TopicSession.html#createDurableSubscriber-javax.jms.Topic-java.lang.String-](https://javaee.github.io/javaee-spec/javadocs/javax/jms/TopicSession.html#createDurableSubscriber-javax.jms.Topic-java.lang.String-)。
- en: 'We will create two instances of the `CourseTopicSubscriber` class (so there
    will be two topic subscribers) in `JMSReceiverInitServlet`. These two instances
    will start listening for messages on application startup (the servlet is loaded
    on startup):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`JMSReceiverInitServlet`中创建`CourseTopicSubscriber`类的两个实例（因此将有两个主题订阅者）。这两个实例将在应用程序启动时开始监听消息（servlet在启动时加载）：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now have two queue listeners and two topic listeners ready when the application
    starts. Republish the project, execute `addCourse.jsp`, and add a course. Check
    the messages in the Console view of Eclipse. You will see that the message published
    in the topic is received by all subscribers, but the same message published in
    the queue is received by only one receiver:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，我们现在有两个队列监听器和两个主题监听器就绪。重新发布项目，执行`addCourse.jsp`，并添加一门课程。检查Eclipse的控制台视图中的消息。您将看到发布在主题中的消息被所有订阅者接收，但发布在队列中的相同消息只被一个接收器接收：
- en: '![](img/00206.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00206.jpeg)'
- en: 'Figure 10.8: Console output showing multiple JMS receivers listening to JMS
    queue and topic'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：控制台输出显示多个JMS接收器正在监听JMS队列和主题
- en: Creating JMS application using JSF and CDI beans
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSF和CDI豆创建JMS应用程序
- en: In this section, we will see how to create a JMS application using JSF and **Component
    Dependency Injection** (**CDI**) beans. With CDI beans, we can reduce the code
    that we wrote using JMS APIs, because we can use annotations to inject objects
    such as the JMS connection factory, queue, and topic. Once we obtain references
    to these objects, the steps to send or receive data are the same as those discussed
    in the previous section. Therefore, our examples in this section do not list the
    entire code. For the complete source code, download the source code for this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用JSF和**组件依赖注入**（**CDI**）组件创建一个JMS应用程序。使用CDI组件，我们可以减少使用JMS API编写的代码，因为我们可以使用注解来注入诸如JMS连接工厂、队列和主题等对象。一旦我们获得了这些对象的引用，发送或接收数据的步骤与上一节中讨论的相同。因此，本节中的示例没有列出完整的代码。对于完整的源代码，请下载本章的源代码。
- en: 'To prepare our project for using JSF, we need to create `web.xml` and add the
    JSF servlet definition and mapping in it. Right-click on the project and select the Java
    EE Tools | Generate Deployment Descriptor Stub option. This creates `web.xml`
    in the `WebContent/WEB-INF` folder. Add the following servlet definition and mapping
    (within the `web-app` tag) in `web.xml`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的项目能够使用JSF，我们需要创建`web.xml`并在其中添加JSF servlet定义和映射。在项目上右键单击并选择Java EE Tools
    | Generate Deployment Descriptor Stub选项。这将在`WebContent/WEB-INF`文件夹中创建`web.xml`。在`web.xml`中添加以下servlet定义和映射（在`web-app`标签内）：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For CDI beans to work, we need to create a `beans.xml` file in the `META-INF`
    folder. You will find the `META-INF` folder under the `WebContent` folder in the
    project in Eclipse. Let''s create the `bean.xml` file in `META-INF` with the following
    content:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使CDI（Contexts and Dependency Injection）组件工作，我们需要在`META-INF`文件夹中创建一个`beans.xml`文件。你可以在Eclipse项目中`WebContent`文件夹下找到`META-INF`文件夹。让我们在`META-INF`中创建一个包含以下内容的`bean.xml`文件：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will now create two CDI beans for the JSF page. The first one is `CourseManagedMsgSenderBean`.
    The second one is `CourseJSFBean`, which will be referenced from the JSF page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为JSF页面创建两个CDI（Contexts and Dependency Injection）组件。第一个是`CourseManagedMsgSenderBean`。第二个是`CourseJSFBean`，它将在JSF页面中被引用。
- en: 'Create the `CourseManagedMsgSenderBean` class in the `packt.jee.eclipse.jms.jsf_bean`
    package with the following content:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`packt.jee.eclipse.jms.jsf_bean`包中创建`CourseManagedMsgSenderBean`类，内容如下：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the JMS connection factory and queue objects are injected using the `@Resource`
    annotation. We have used the `@PostConstruct` annotation to create a JMS a connection
    and a session and the `@PreDestroy` annotation for the clean-up operation. The `addCourse`
    method is similar to the code that we already implemented in the `CourseQueueSender`
    class in the previous section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JMS连接工厂和队列对象是通过`@Resource`注解注入的。我们使用了`@PostConstruct`注解来创建一个JMS连接和会话，以及`@PreDestroy`注解来进行清理操作。`addCourse`方法与我们在上一节中实现的`CourseQueueSender`类中的代码类似。
- en: 'Let''s now create the `CourseJSFBean` class in the `packt.jee.eclipse.jms.jsf_bean`
    package with the following content:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`packt.jee.eclipse.jms.jsf_bean`包中创建`CourseJSFBean`类，内容如下：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: An instance of `CourseManagedMsgSenderBean` is injected into `CourseJSFBean` using the `@Inject`
    annotation. The `addCourse` method simply calls the same named method in `CourseManagedMsgSenderBean`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Inject`注解将`CourseManagedMsgSenderBean`的实例注入到`CourseJSFBean`中。`addCourse`方法简单地调用相同名称的方法在`CourseManagedMsgSenderBean`中。
- en: 'Finally, let''s create `addCourse.xhtml` in the `WebContents` folder with the
    following content:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在`WebContents`文件夹中创建`addCourse.xhtml`，内容如下：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Form fields are bound to fields in `CourseJSFBean`. When the Submit button is
    clicked, the `addCourse` method of the same bean is called, which puts a message
    in the JMS queue.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段绑定到`CourseJSFBean`中的字段。当点击提交按钮时，将调用相同bean中的`addCourse`方法，该方法将消息放入JMS队列。
- en: Republish the project and execute `addCourse.xhtml` by right-clicking it and
    selecting Run As | Run on Server. Add a course and see the message printed in
    the GlassFish Console view of Eclipse.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重新发布项目并通过右键单击`addCourse.xhtml`选择运行方式 | 在服务器上运行来执行它。添加一门课程并查看在Eclipse的GlassFish控制台视图中打印的消息。
- en: Consuming JMS messages using MDBs
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消息驱动Bean（MDBs）消费JMS消息
- en: '**Message-driven beans** (**MDBs**) make consuming JMS messages a lot easier.
    With just a couple of annotations and implementing the `onMessage` method, you
    can make any Java object a consumer of JMS messages. In this section, we will
    implement an MDB to consume messages from the `Course` queue. To implement MDBs,
    we need to create an EJB project. Select File | New | EJB Project from the main
    menu:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息驱动Bean（MDB**）使消费JMS消息变得容易得多。只需使用几个注解并实现`onMessage`方法，你就可以使任何Java对象成为JMS消息的消费者。在本节中，我们将实现一个MDB来从`Course`队列中消费消息。要实现MDB，我们需要创建一个EJB项目。从主菜单中选择“文件
    | 新建 | EJB项目”：'
- en: '![](img/00207.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00207.jpeg)'
- en: 'Figure 10.9: Create a EJB project to implement MDBs'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：创建一个EJB项目以实现消息驱动Bean（MDB）
- en: Enter Project name as `CourseManagementEJB`. Click Next. Accept the default
    values on the subsequent pages and click Finish on the last page.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目名称输入为`CourseManagementEJB`。点击“下一步”。在随后的页面上接受默认值，并在最后一页点击“完成”。
- en: 'Right-click on the project and select the New | Message-Driven Bean option.
    This opens the MDB creation wizard:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击项目，选择“新建 | 消息驱动Bean”选项。这会打开MDB创建向导：
- en: '![](img/00208.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00208.jpeg)'
- en: 'Figure 10.10: MDB creation wizard – class file information'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：MDB创建向导 – 类文件信息
- en: Enter `packt.jee.eclipse.jms.mdb` as Java package and `CourseMDB` as Class name.
    Keep Destination type as Queue.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将`packt.jee.eclipse.jms.mdb`作为Java包名，将`CourseMDB`作为类名。保持目标类型为队列。
- en: 'Destination name is the physical destination name that we specified when creating
    the queue and is not the JNDI name:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目标名称是在创建队列时指定的物理目标名称，而不是JNDI名称：
- en: '![](img/00209.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00209.jpeg)'
- en: 'Figure 10.11: JMS queue physical destination name in the GlassFish admin console'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：GlassFish管理控制台中的JMS队列物理目标名称
- en: 'Enter `CourseManagementQueue` as Destination type. Click Next. Accept the default
    values on the second page and click Finish. The wizard generates the following
    code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将目标类型输入为`CourseManagementQueue`。点击“下一步”。在第二页接受默认值并点击“完成”。向导生成以下代码：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The class is annotated with `@MessageDriven` with `activationConfig` and the
    JMS destination parameters specified in the wizard. It also creates the `onMessage`
    method. In this method, we just print the message that the MDB received for adding
    a course. To process `ObjectMessage` in this class, we will have to refactor the `CourseDTO`
    class to a shared `.jar` between EJB and the web project. This is left to the
    readers as an exercise.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用`@MessageDriven`注解，并在向导中指定了`activationConfig`和JMS目标参数。它还创建了`onMessage`方法。在这个方法中，我们只是打印出MDB接收到的用于添加课程的消息。为了处理本类中的`ObjectMessage`，我们需要将`CourseDTO`类重构为一个共享的`.jar`文件，在EJB和Web项目之间。这留作读者的练习。
- en: The JEE container creates a pool of MDB objects for a single MDB class. An incoming
    message can be handled by any one of the instances of MDB in the pool. This can
    help in building a scalable message processing application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: JEE容器为单个MDB类创建一个MDB对象池。传入的消息可以由池中的任何一个MDB实例处理。这有助于构建可扩展的消息处理应用程序。
- en: If you want to test the MDB, add the project to the GlassFish Server configured
    in Eclipse. To do this, right-click on the configured server in the Servers view
    of Eclipse and select the Add and Remove... option. Select the CourseManagementEJB
    project that we created and click Finish. Make sure that the server is started
    and the status is [Started, Synchronized]. You also need to add the CourseManagementJMSWeb
    project to the server, because we have JSF and JSP pages to add a course in that
    project. Run `addCourse.xhtml` or `addCourse.jsp` from the CourseManagementJMSWeb
    project, add a course, and check the GlassFish console in Eclipse for messages
    printed from message receivers and the MDB we created in this section. However,
    note that either the MDB or one of the queue listeners we developed in CourseManagementJMSWeb
    will be receiving the message, and not all of the receivers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试MDB，请将项目添加到在Eclipse中配置的GlassFish服务器。为此，在Eclipse的“服务器”视图中右键单击配置的服务器，并选择“添加和移除...”选项。选择我们创建的`CourseManagementEJB`项目并点击“完成”。确保服务器已启动且状态为[已启动，同步]。你还需要将`CourseManagementJMSWeb`项目添加到服务器，因为我们有JSF和JSP页面在该项目中添加课程。从`CourseManagementJMSWeb`项目运行`addCourse.xhtml`或`addCourse.jsp`，添加课程，并在Eclipse中的GlassFish控制台检查从消息接收器和本节中创建的MDB打印的消息。然而，请注意，无论是MDB还是我们在`CourseManagementJMSWeb`中开发的队列监听器之一，都将接收消息，而不是所有接收器。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A messaging system can be a powerful tool for integrating disparate applications.
    It provides an asynchronous model of programming. The client does not wait for
    the response from the server and the server does not necessarily process requests
    at the same time that the client sends them. A messaging system can also be useful
    for building scalable applications and batch processing. JMS provides uniform
    APIs to access different messaging systems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 消息系统可以是一个强大的工具，用于整合不同的应用程序。它提供了一个异步的编程模型。客户端不需要等待服务器的响应，服务器也不一定会在客户端发送请求的同时处理这些请求。消息系统对于构建可扩展的应用程序和批量处理也非常有用。JMS提供了统一的API来访问不同的消息系统。
- en: In this chapter, we learned how to send and receive messages from queues and
    to publish and subscribe messages from topics. There are many different ways to
    use JMS APIs. We started with the basic JMS APIs and then learned how annotations
    can help reduce some of the code. We also learned how to use MDBs to consume messages.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何从队列发送和接收消息，以及如何从主题发布和订阅消息。使用JMS API有众多不同的方式。我们首先从基本的JMS API开始，然后学习了注解如何帮助减少一些代码。我们还学习了如何使用消息驱动Bean（MDB）来消费消息。
- en: In the next chapter, we will see some of the techniques and tools used for profiling
    CPU and memory usages in Java applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到一些用于分析Java应用程序CPU和内存使用情况的技巧和工具。
