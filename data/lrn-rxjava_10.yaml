- en: Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试
- en: While unit testing is not a silver bullet to ensure that your code works properly,
    it is a good practice to strive for. This is especially true if your logic is
    highly deterministic and modular enough to isolate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试并不是确保您的代码正确工作的银弹，但追求它是良好的实践。这对于您的逻辑高度确定性和足够模块化以隔离的情况尤其正确。
- en: Testing with RxJava at first glance may not seem straightforward. After all,
    RxJava declares behaviors rather than states. So how do we test whether behaviors
    are working correctly, especially when most testing frameworks expect a stateful
    result? Fortunately, RxJava comes with several tools to aid testing, and you can
    use these tools with your favorite testing frameworks. There are many testing
    tools available on the market that can work with RxJava, but in this chapter,
    we will use JUnit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，使用 RxJava 进行测试可能并不直接。毕竟，RxJava 声明的是行为而不是状态。那么我们如何测试行为是否正确工作，尤其是在大多数测试框架期望有状态结果的情况下呢？幸运的是，RxJava
    提供了几个辅助测试的工具，您可以使用这些工具与您喜欢的测试框架一起使用。市场上有很多可以与 RxJava 一起工作的测试工具，但本章我们将使用 JUnit。
- en: 'We will also cover a few tips to effectively debug RxJava programs. One of
    the downsides of RxJava is that when bugs occur, traditional approaches to debugging
    are not always effective, particularly because the stack traces are not always
    helpful and breakpoints do not apply easily. But there is a benefit RxJava offers
    in debugging: with the right approach, you can walk through your entire reactive
    chain and find the operator that causes things to go wrong. The problem becomes
    very linear and a matter of isolating the bad link. This can simplify the debugging
    process significantly.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍一些调试 RxJava 程序的技巧。RxJava 的一个缺点是，当出现错误时，传统的调试方法并不总是有效的，尤其是因为堆栈跟踪并不总是有帮助，断点也不容易应用。但是，RxJava
    在调试方面提供了一个好处：通过正确的方法，您可以遍历整个响应式链，找到导致问题发生的算子。问题变得非常线性，变成隔离坏链的问题。这可以显著简化调试过程。
- en: This chapter has a number of testing features to cover, so we will start with
    simpler naive approaches to cover basic blocking operators. Then, we will escalate
    to the more robust tools, such as `TestObserver`, `TestSubscriber`, and `TestScheduler`,
    which you will likely use in your applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖许多测试功能，因此我们将从简单的直观方法开始，以涵盖基本的阻塞算子。然后，我们将升级到更健壮的工具，例如 `TestObserver`、`TestSubscriber`
    和 `TestScheduler`，您可能会在您的应用程序中使用这些工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '`blockingSubscribe()`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockingSubscribe()`'
- en: Blocking operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞算子
- en: '`TestObserver` and `TestSubscriber`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestObserver` 和 `TestSubscriber`'
- en: '`TestScheduler`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestScheduler`'
- en: RxJava debugging strategies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava 调试策略
- en: Configuring JUnit
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 JUnit
- en: In this section, we will be using JUnit as our testing framework. Add the following
    dependency to your Maven or Gradle project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 JUnit 作为我们的测试框架。请将以下依赖项添加到您的 Maven 或 Gradle 项目中。
- en: 'Here is the configuration for Maven:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Maven 的配置：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the configuration for Gradle:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Gradle 的配置：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To save yourself hassle, organize your code project to conform to the Maven
    Standard Directory layout. You might want to place your test classes in a `/src/test/java/`
    folder so Maven and Gradle will automatically recognize it as the test code folder.
    You also should put your production code in a `/src/main/java/` folder in your
    project. You can read more about the Maven Standard Directory layout at [https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省您的时间，组织您的代码项目以符合 Maven 标准目录布局。您可能希望将测试类放在 `/src/test/java/` 文件夹中，这样 Maven
    和 Gradle 将自动将其识别为测试代码文件夹。您还应该在项目的 `/src/main/java/` 文件夹中放置您的生产代码。您可以在 [https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)
    上了解更多关于 Maven 标准目录布局的信息。
- en: Blocking subscribers
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞订阅者
- en: 'Remember how sometimes we have to stop the main thread from racing past an
    `Observable` or `Flowable` that operates on a different thread and keep it from
    exiting the application before it has a chance to fire? We often prevented this
    using `Thread.sleep()`, especially when we used `Observable.interval()`, `subscribeOn()`,
    or `observeOn()`. The following code shows how we did this typically and kept
    an `Observable.interval()` application alive for five seconds:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记得有时候我们不得不阻止主线程从不同的线程上跳过`Observable`或`Flowable`操作，并防止它在有机会触发之前退出应用程序吗？我们经常使用`Thread.sleep()`来防止这种情况，尤其是在我们使用`Observable.interval()`、`subscribeOn()`或`observeOn()`时。以下代码展示了我们通常是如何做到这一点的，并使一个`Observable.interval()`应用程序保持活跃五秒钟：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When it comes to unit testing, the unit test usually has to complete before
    it starts the next one. This can become quite messy when we have an `Observable`
    or `Flowable` operation that happens on a different thread. When a `test` method
    declares an asynchronous `Observable` or `Flowable` chain operation, we need to
    block and wait for that operation to complete.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到单元测试时，单元测试通常必须在开始下一个测试之前完成。当我们有一个在另一个线程上发生的`Observable`或`Flowable`操作时，这可能会变得相当混乱。当一个`test`方法声明了一个异步的`Observable`或`Flowable`链操作时，我们需要阻塞并等待该操作完成。
- en: 'Here, we create a test to ensure that five emissions are emitted from `Observable.interval()`,
    and we increment `AtomicInteger` before validating that it was incremented five
    times:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个测试来确保从`Observable.interval()`发出五个发射，并在验证它被增加了五次之前增加`AtomicInteger`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use the `@Test` annotation to tell `JUnit` that this is a test method. You
    can run it in Intellij IDEA by clicking on its green triangular *play* button
    in the gutter or by running the test task in Gradle or Maven.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@Test`注解来告诉`JUnit`这是一个测试方法。您可以通过在IntelliJ IDEA的gutter中点击其绿色的三角形*播放*按钮或在Gradle或Maven中运行测试任务来运行它。
- en: There is a problem, though. When you run this test, the assertion fails. `Observable.interval()`
    is running on a computation thread and the main thread rushes past it. The main
    thread performs `assertTrue()` before the five emissions are fired and therefore
    finds `hitCount` to be `0` rather than `5`. We need to stop the main thread until
    `subscribe()` finishes and calls `onComplete()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个问题。当你运行这个测试时，断言失败。`Observable.interval()`正在计算线程上运行，而主线程在五个发射触发之前就冲过去了。主线程在五个发射触发之前执行`assertTrue()`，因此发现`hitCount`是`0`而不是`5`。我们需要停止主线程，直到`subscribe()`完成并调用`onComplete()`。
- en: 'Thankfully, we do not have to get creative using synchronizers and other native
    Java concurrency tools. Instead, we can use `blockingSubscribe()`, which will
    block the declaring main thread until `onComplete()` (or `onError()`) is called.
    Once those five emissions are gathered, the main thread can proceed and perform
    the assertion successfully, as demonstrated here. The test should then pass:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要使用同步器和其他原生Java并发工具来发挥创意。相反，我们可以使用`blockingSubscribe()`，它将阻塞声明的主线程，直到`onComplete()`（或`onError()`）被调用。一旦收集到这五个发射，主线程就可以继续进行，并成功执行断言，就像这里所展示的。然后测试应该通过：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we will see in this chapter, there are better ways to test other than `blockingSubscribe()`.
    But `blockingSubscribe()` is a quick and effective way to stop the declaring thread
    and wait for the `Observable` or `Flowable` to finish before proceeding, even
    if it is on a different thread. Just make sure that the source terminates at some
    point, or the test will never finish.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章中看到的，除了`blockingSubscribe()`之外，还有更好的测试方法。但`blockingSubscribe()`是一个快速而有效的方法来停止声明线程，并在继续之前等待`Observable`或`Flowable`完成，即使它是在不同的线程上。只需确保源在某一点终止，否则测试将永远不会完成。
- en: Be judicious in how you use `blockingSubscribe()` outside the context of testing
    and using it in production. There are definitely times it is a legitimate solution
    to interface with a non-reactive API. For example, it can be valid to use it in
    production to keep an application alive indefinitely and is an effective alternative
    to using `Thread.sleep()`. Just be careful to ensure the asynchronous benefits
    of RxJava are not undermined.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试之外以及在生产环境中使用`blockingSubscribe()`时，要谨慎。确实有在接口非响应式API时它是合法解决方案的时候。例如，在生产环境中使用它来无限期地保持应用程序活跃，并且是使用`Thread.sleep()`的有效替代方案。只是要小心确保RxJava的异步优势不被削弱。
- en: Blocking operators
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞算子
- en: In RxJava, there is a set of operators we have not covered yet called **blocking
    operators**. These operators serve as an immediate proxy between the reactive
    world and the stateful one, blocking and waiting for results to be emitted, but
    returned in a non-reactive way. Even if the reactive operations are working on
    different threads, blocking operators will stop the declaring thread and make
    it wait for the results in a synchronized manner, much like `blockingSubscribe()`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava中，有一组我们尚未介绍的称为**阻塞操作符**的操作符。这些操作符充当反应式世界和有状态世界之间的即时代理，阻塞并等待结果发出，但以非反应式的方式返回。即使反应式操作在不同的线程上运行，阻塞操作符也会停止声明线程并使其以同步方式等待结果，就像`blockingSubscribe()`一样。
- en: Blocking operators are especially helpful in making the results of an `Observable`
    or `Flowable` easily available for evaluation. However, you will want to avoid
    using them in production because they encourage anti-patterns and undermine the
    benefits of reactive programming. For testing, you will still want to prefer `TestObserver`
    and `TestSubscriber`, which we will cover later. But here are the blocking operators
    if you ever have a need for them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞操作符在使`Observable`或`Flowable`的结果易于评估方面特别有用。然而，你希望在生产环境中避免使用它们，因为它们会鼓励反模式并损害响应式编程的好处。对于测试，你仍然希望优先考虑`TestObserver`和`TestSubscriber`，我们将在后面介绍。但如果你确实需要它们，这里有一些阻塞操作符。
- en: blockingFirst()
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: blockingFirst()
- en: 'The `blockingFirst()` operator will stop the calling thread and make it wait
    for the first value to be emitted and returned (even if the chain is operating
    on a different thread with `observeOn()` and `subscribeOn()`). Say we want to
    test an `Observable` chain that filters a sequence of string emissions for only
    ones that have a length of four. If we want to assert that the first emission
    to make it through this operation is `Beta`, we can test for it like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockingFirst()`操作符将停止调用线程并使其等待第一个值被发射并返回（即使链在具有`observeOn()`和`subscribeOn()`的不同线程上运行）。假设我们想要测试一个`Observable`链，该链仅过滤长度为四的字符串发射序列。如果我们想要断言第一个通过此操作的发射是`Beta`，我们可以这样测试：'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, our unit test is called `testFirst()`, and it will assert that the first
    string emitted with a length of four is `Beta`. Note that instead of using `subscribe()`
    or `blockingSubscribe()` to receive the emissions, we use `blockingFirst()`, which
    will return the first emission in a non-reactive way. In other words, it returns
    a straight-up string and not an `Observable` emitting string.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的单元测试称为`testFirst()`，它将断言第一个长度为四的字符串是`Beta`。请注意，我们不是使用`subscribe()`或`blockingSubscribe()`来接收发射，而是使用`blockingFirst()`，它将以非反应式的方式返回第一个发射。换句话说，它返回一个简单的字符串，而不是发出字符串的`Observable`。
- en: This will block the declaring thread until the value is returned and assigned
    to `firstWithLengthFour`. We then use that saved value to assert that it is, in
    fact, `Beta`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻塞声明线程，直到返回值并分配给`firstWithLengthFour`。然后我们使用这个保存的值来断言它实际上是`Beta`。
- en: Looking at `blockingFirst()`, you may be tempted to use it in production code
    to save a result statefully and refer to it later. Try not to do that! While there
    are certain cases where you might be able to justify it (such as saving emissions
    into a `HashMap` for expensive computations and lookups), blocking operators can
    easily be abused. If you need to persist values, try to use `replay()` and other
    reactive caching strategies so that you can easily change its behaviors and concurrency
    policies down the road. Blocking will often make your code less flexible and undermine
    the benefits of Rx.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看到blockingFirst()，你可能想在生产代码中使用它来保存结果状态并稍后引用它。尽量不要这样做！虽然在某些情况下你可能会找到合理的理由（例如，将发射保存到`HashMap`中进行昂贵的计算和查找），但阻塞操作符很容易被滥用。如果你需要持久化值，尽量使用`replay()`和其他反应式缓存策略，这样你就可以轻松地更改其行为和并发策略。阻塞通常会使得你的代码更缺乏灵活性，并损害Rx的好处。
- en: Note that the `blockingFirst()` operator will throw an error and fail the test
    if no emissions come through. However, you can provide a default value as an overload
    to `blockingFirst()` so it always has a value to fall back on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有任何发射通过，`blockingFirst()`操作符将抛出错误并使测试失败。但是，你可以提供一个默认值作为`blockingFirst()`的重载，这样它总是有一个回退值。
- en: A similar blocking operator to `blockingFirst()` is `blockingSingle()`, which
    expects only a single item to be emitted, but throws an error if there are more.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与`blockingFirst()`类似的阻塞操作符是`blockingSingle()`，它期望只发射一个项目，但如果有多于一个项目，则抛出错误。
- en: blockingGet()
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: blockingGet()
- en: '`Maybe` and `Single` do not have `blockingFirst()` since there can only be
    one element at most. Logically, for a `Single` and `Maybe`, it is not exactly
    the *first* element, but rather the *only* element, so the equivalent operator
    is `blockingGet()`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe` 和 `Single` 没有提供 `blockingFirst()`，因为最多只能有一个元素。从逻辑上讲，对于 `Single` 和 `Maybe`，这并不是确切的第一元素，而是唯一的元素，所以等效的算子是
    `blockingGet()`。'
- en: 'Here, we assert that all items of length four include only `Beta` and `Zeta`,
    and we collect them with `toList()`, which yields a `Single<List<String>>`. We
    can use `blockingGet()` to wait for this list and assert that it is equal to our
    desired result:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们断言长度为四的所有项只包含 `Beta` 和 `Zeta`，并且我们使用 `toList()` 收集它们，这会产生一个 `Single<List<String>>`。我们可以使用
    `blockingGet()` 等待这个列表，并断言它等于我们期望的结果：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: blockingLast()
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: blockingLast()
- en: If there is `blockingFirst()`, it only makes sense to have `blockingLast()`.
    This will block and return the last value to be emitted from an `Observable` or
    `Flowable` operation. Of course, it will not return anything until `onComplete()`
    is called, so this is something you will want to avoid using with infinite sources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有 `blockingFirst()`，那么只有 `blockingLast()` 才有意义。这将阻塞并返回从 `Observable` 或 `Flowable`
    操作中发出的最后一个值。当然，它不会返回任何内容，直到 `onComplete()` 被调用，所以这是你想要避免与无限源一起使用的情况。
- en: 'Here, we assert that the last four-character string emitted from our operation
    is `Zeta`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们断言从我们的操作中发出的最后一个四字符字符串是 `Zeta`：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like `blockingFirst()`, `blockingLast()` will throw an error if no emissions
    occur, but you can specify an overload for a default value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `blockingFirst()` 一样，如果没有任何排放发生，`blockingLast()` 将会抛出一个错误，但你可以为默认值指定一个重载。
- en: blockingIterable()
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: blockingIterable()
- en: 'One of the most interesting blocking operators is `blockingIterable()`. Rather
    than returning a single emission like our previous examples, it will provide the
    emissions as they become available through `iterable<T>`. The `Iterator<T>` provided
    by the `Iterable<T>` will keep blocking the iterating thread until the next emission
    is available, and the iteration will end when `onComplete()` is called. Here,
    we iterate through each returned string value to ensure that its length is actually
    `5`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的阻塞算子之一是 `blockingIterable()`。与之前的示例不同，它不会返回单个排放，而是会通过 `iterable<T>` 提供排放。`Iterable<T>`
    提供的 `Iterator<T>` 将会阻塞迭代线程，直到下一个排放可用，迭代将在 `onComplete()` 被调用时结束。在这里，我们遍历每个返回的字符串值，以确保其实际长度是
    `5`：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `blockingIterable()` will queue up unconsumed values until the `Iterator`
    is able to process them. This can be problematic without backpressure as you may
    run into `OutOfMemoryException` errors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockingIterable()` 将会排队等待未消费的值，直到 `Iterator` 能够处理它们。在没有背压的情况下，这可能会出现问题，因为你可能会遇到
    `OutOfMemoryException` 错误。'
- en: Unlike C#, note that Java's for-each construct will not handle cancellation,
    breaking, or disposal. You can work around this by iterating the `Iterator` from
    the iterable inside `try-finally`. In the `finally` block, cast the `Iterator`
    to a `disposable` so you can call its `dispose()` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 不同，请注意 Java 的 for-each 构造不会处理取消、中断或处置。你可以通过在 `try-finally` 中迭代可迭代的 `Iterator`
    来解决这个问题。在 `finally` 块中，将 `Iterator` 强制转换为 `disposable`，这样你就可以调用它的 `dispose()`
    方法。
- en: The `blockingIterable()` can be helpful in quickly turning an `Observable` or
    `Flowable` into pull-driven functional sequence types such as a Java 8 Stream
    or Kotlin sequence, which can be built-off iterables. However, for Java 8 streams,
    you are likely better-off using David Karnok's RxJava2Jdk8Interop library ([https://github.com/akarnokd/RxJava2Jdk8Interop](https://github.com/akarnokd/RxJava2Jdk8Interop)),
    so that termination is handled more safely.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockingIterable()` 可以帮助快速将 `Observable` 或 `Flowable` 转换为拉取驱动的函数序列类型，例如 Java
    8 Stream 或 Kotlin 序列，这些可以基于可迭代对象构建。然而，对于 Java 8 streams，你可能会更倾向于使用 David Karnok
    的 RxJava2Jdk8Interop 库 ([https://github.com/akarnokd/RxJava2Jdk8Interop](https://github.com/akarnokd/RxJava2Jdk8Interop))，这样终止处理会更加安全。'
- en: blockingForEach()
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: blockingForEach()
- en: 'A more fluent way in which we can execute a blocking for each task is to use
    the `blockingForEach()` operator instead of `blockingIterable()`. This will block
    the declaring thread and wait for each emission to be processed before allowing
    the thread to continue. We can streamline our earlier example, where we iterated
    each emitted string and ensured that its length was five and specify the assertion
    as a lambda in the `forEach()` operator instead:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以更流畅的方式为每个任务执行阻塞，即使用`blockingForEach()`操作符而不是`blockingIterable()`。这将阻塞声明线程，等待每个发射被处理后再允许线程继续。我们可以简化之前的示例，其中我们迭代每个发射的字符串并确保其长度为五，并将断言作为lambda表达式指定在`forEach()`操作符中：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A variant of `blockingForEach()` is `blockingForEachWhile()`, which accepts
    a predicate that gracefully terminates the sequence if the predicate evaluates
    to false against an emission. This can be desirable if all emissions are not going
    to be consumed and you want to gracefully terminate.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockingForEach()`的一个变体是`blockingForEachWhile()`，它接受一个谓词，如果谓词对发射评估为假，则优雅地终止序列。如果所有发射都不将被消费，并且你希望优雅地终止，这可能是有用的。'
- en: blockingNext()
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`blockingNext()`'
- en: 'The `blockingNext()` will return an iterable and block each iterator''s `next()`
    request until the next value is provided. Emissions that occur after the last
    fulfilled `next()` request and before the current `next()` are ignored. Here,
    we have a source that emits every microsecond (1/1000th of a millisecond). Note
    that the iterable returned from `blockingNext()` ignored previous values it missed:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockingNext()`将返回一个可迭代对象，并阻塞每个迭代器的`next()`请求，直到下一个值被提供。在最后一个满足的`next()`请求之后和当前`next()`之前发生的发射将被忽略。在这里，我们有一个每微秒（千分之一毫秒）发射的源。请注意，`blockingNext()`返回的可迭代对象忽略了它之前错过的值：'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: blockingLatest()
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`blockingLatest()`'
- en: 'The iterable from `blockingLatest()`, on the other hand, does not wait for
    the next value, but requests the last emitted value. Any values before that which
    were not captured are forgotten. It will not reconsume the latest value if the
    iterator''s `next()` consumed it previously and will block until the next one
    comes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与`blockingLatest()`相反，`blockingLatest()`的可迭代对象不会等待下一个值，而是请求最后一个发射的值。在此之前的任何未捕获的值都将被遗忘。如果迭代器的`next()`之前已经消费了最新的值，它将不会重新消费，并且会阻塞，直到下一个值到来：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: blockingMostRecent()
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`blockingMostRecent()`'
- en: 'The `blockingMostRecent()` is similar to `blockingLatest()`, but it will re-consume
    the latest value repeatedly for every `next()` call from the iterator even if
    it was consumed already. It also requires a `defaultValue` argument so it has
    something to return if no value is emitted yet. Here, we use `blockingMostRecent()`
    against an `Observable` emitting every 10 milliseconds. The default value is `-1`,
    and it consumes each value repeatedly until the next value is provided:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockingMostRecent()`与`blockingLatest()`类似，但它会在迭代器的每个`next()`调用中重复消费最新的值，即使它已经被消费过。它还需要一个`defaultValue`参数，以便在没有发射值时返回某个值。在这里，我们使用`blockingMostRecent()`对每10毫秒发射一次的`Observable`进行操作。默认值是`-1`，并且它会重复消费每个值，直到下一个值被提供：'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we finish covering blocking operators, it should be emphasized again that
    they can be an effective way to do simple assertions and provide means to block
    for results so they can be consumed easily by a testing framework. However, you
    will want to avoid using blocking operators for production as much as possible.
    Try not to give into the sirens of convenience, as you will find that they can
    quickly undermine the flexibility and benefits of reactive programming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成对阻塞操作符的介绍后，应该再次强调，它们可以是一种有效的简单断言方式，并提供阻塞以获取结果的方法，以便它们可以轻松地被测试框架消费。然而，你应尽可能避免在生产中使用阻塞操作符。尽量不要屈服于便利的诱惑，因为你会发现它们可以迅速削弱响应式编程的灵活性和优势。
- en: Using TestObserver and TestSubscriber
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TestObserver和TestSubscriber
- en: We've covered `blockingSubscribe()` and several blocking operators in this chapter
    so far. While you can use these blocking tools to do simple assertions, there
    is a much more comprehensive way to test reactive code than simply blocking for
    one or more values. After all, we should do more than test `onNext()` calls. We
    also have `onComplete()` and `onError()` events to account for! It also would
    be great to streamline testing other RxJava events, such as subscription, disposal,
    and cancellation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在本章中介绍了 `blockingSubscribe()` 和几个阻塞操作符。虽然你可以使用这些阻塞工具来进行简单的断言，但测试反应式代码的更全面的方法不仅仅是阻塞一个或多个值。毕竟，我们应该做的不仅仅是测试
    `onNext()` 调用。我们还有 `onComplete()` 和 `onError()` 事件需要考虑！此外，简化测试其他 RxJava 事件，如订阅、处置和取消，也会很棒。
- en: So let's introduce the `TestObserver` and `TestSubscriber`, your two best friends
    in testing your RxJava applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们来介绍 `TestObserver` 和 `TestSubscriber`，它们是你在测试 RxJava 应用程序时的两位最佳伙伴。
- en: '`TestObserver` and `TestSubscriber` are a treasure trove of convenient methods
    to aid testing, many of which assert that certain events have occurred or specific
    values were received. There are also blocking methods, such as `awaitTerminalEvent()`,
    which will stop the calling thread until the reactive operation terminates.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestObserver` 和 `TestSubscriber` 是一个方便的测试方法宝库，其中许多方法断言某些事件已经发生或接收到了特定的值。还有一些阻塞方法，例如
    `awaitTerminalEvent()`，它将停止调用线程，直到反应式操作终止。'
- en: '`TestObserver` is used for `Observable`, `Single`, `Maybe`, and `Completable`
    sources, while `TestSubscriber` is used for Flowable sources. Here is a unit test
    showcasing several `TestObserver` methods, which also exist on `TestSubscriber`
    if you are working with Flowables. These methods perform tasks such as asserting
    that certain events have (or have not) occurred, awaiting terminations or asserting
    that certain values were received:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestObserver` 用于 `Observable`、`Single`、`Maybe` 和 `Completable` 源，而 `TestSubscriber`
    用于 `Flowable` 源。以下是一个单元测试示例，展示了几个 `TestObserver` 方法，这些方法也存在于 `TestSubscriber`
    上，如果你正在处理 `Flowables`。这些方法执行诸如断言某些事件是否发生（或未发生）、等待终止或断言接收到了特定值等任务：'
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is just a handful of many testing methods available, and they will make
    your unit tests in a much more comprehensive and streamlined manner. Most of the
    `TestObserver` methods return `TestObserver` so you can actually chain these assertions
    fluently (and this also applies to `TestSubscriber`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是众多测试方法中的一小部分，它们将使你的单元测试更加全面和流畅。大多数 `TestObserver` 方法返回 `TestObserver`，因此你可以流畅地链式调用这些断言（这也适用于
    `TestSubscriber`）。
- en: Note also that the `awaitTerminalEvent()` operator can accept a timeout argument
    that will throw an error if the source does not complete before that time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`awaitTerminalEvent()` 操作符可以接受一个超时参数，如果在指定时间之前源没有完成，它将抛出一个错误。
- en: Spend some time going through all these testing methods so you are aware of
    the different assertions you make. Prefer `TestObserver` and `TestSubscriber`
    over blocking operators as much as possible. This way, you can spend less time
    maintaining your tests and ensure that you cover the full spectrum of events in
    the life cycle of an `Observable` or `Flowable` operation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间熟悉所有这些测试方法，以便你了解你做出的不同断言。尽可能优先使用 `TestObserver` 和 `TestSubscriber` 而不是阻塞操作符。这样，你可以花更少的时间维护测试，并确保你覆盖了
    `Observable` 或 `Flowable` 操作的生命周期中的所有事件范围。
- en: '`TestObserver` implements `Observer`, `MaybeObserver`, `SingleObserver`, and
    `CompetableObserver` to support all these reactive types. If you live test a long-running
    asynchronous source, you might want to use `awaitCount()` to wait for a minimum
    number of emissions to assert with and not wait for the `onComplete()` call.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestObserver` 实现了 `Observer`、`MaybeObserver`、`SingleObserver` 和 `CompetableObserver`，以支持所有这些反应式类型。如果你正在测试一个长时间运行的异步源，你可能想使用
    `awaitCount()` 来等待至少一定数量的发射以进行断言，而不是等待 `onComplete()` 调用。'
- en: Manipulating time with the TestScheduler
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TestScheduler 操作时间
- en: In our previous examples, did you notice that testing a time-driven `Observable`
    or `Flowable` requires that time to elapse before the test completes? In the last
    exercise, we took five emissions from an `Observable.interval()` emitting every
    1 second, so that test took 5 seconds to complete. If we have a lot of unit tests
    that deal with time-driven sources, it can take a long time for testing to complete.
    Would it not be nice if we could simulate time elapses rather than experiencing
    them?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，您注意到测试一个时间驱动的 `Observable` 或 `Flowable` 需要时间流逝到测试完成吗？在上一个练习中，我们从每秒发射一次的
    `Observable.interval()` 中获取了五次发射，因此该测试花费了 5 秒来完成。如果我们有很多处理时间驱动源的单元测试，测试完成可能需要很长时间。如果我们可以模拟时间流逝而不是实际体验它们，那不是很好吗？
- en: The `TestScheduler` does exactly this. It is a Scheduler implementation that
    allows us to *fast-forward* by a specific amount of elapsed time, and we can do
    any assertions after each f*ast-forward* to see what events have occurred.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestScheduler` 正好能做这件事。它是一个调度器实现，允许我们通过特定的已过时间量进行快进，并且我们可以在每次快进后进行任何断言，以查看发生了哪些事件。'
- en: 'Here, we create a test against `Observable.interval()` that emits every minute and
    ultimately asserts that 90 emissions have occurred after 90 minutes. Rather than
    having to wait the entire 90 minutes in real time, we use `TestObserver` to artificially
    elapse these 90 minutes. This allows the test to run instantly:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个针对每分钟发射一次的 `Observable.interval()` 的测试，并最终断言在 90 分钟后发生了 90 次发射。我们不必在真实时间中等待整整
    90 分钟，而是使用 `TestObserver` 人工地流逝这 90 分钟。这使得测试可以立即运行：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Cool, right? It is almost like time travel! We put `Observable.interval()` on
    our `TestScheduler`. This way, `TestScheduler` controls how the `Observable` interprets
    time and pushes emissions. We fast-forward 30 seconds using `advanceTimeBy()` and
    then assert that no emissions have happened yet. We then use `advanceTimeTo()`
    to jump 70 seconds after subscription occurred and assert that one emission did
    happen. Finally, we advance 90 minutes after subscription, and we assert that
    90 emissions did, in fact, occur.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？这几乎就像是时间旅行！我们将 `Observable.interval()` 放在 `TestScheduler` 上。这样，`TestScheduler`
    控制了 `Observable` 如何解释时间并推动发射。我们使用 `advanceTimeBy()` 快进 30 秒，然后断言还没有发生任何发射。然后我们使用
    `advanceTimeTo()` 跳转到订阅发生后的 70 秒，并断言确实发生了一次发射。最后，我们在订阅后快进 90 分钟，并断言确实发生了 90 次发射。
- en: This all ran instantly rather than taking 90 minutes, showing that it is indeed
    possible to test time-driven `Observable`/`Flowable` operations without having
    to actually elapse that time. Carefully note that `advanceTimeBy()` will fast-forward
    the specified time interval relative to the *current* time, whereas `advanceTimeTo()`
    will jump to the exact time elapsed since the subscription has occurred.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在瞬间完成，而不是花费 90 分钟，这表明确实可以在不实际流逝该时间的情况下测试时间驱动的 `Observable`/`Flowable` 操作。请注意，`advanceTimeBy()`
    将相对于当前时间快进指定的时间间隔，而 `advanceTimeTo()` 将跳转到自订阅发生以来的确切流逝时间。
- en: In summary, use `TestScheduler` when you need to virtually represent time elapsing,
    but note that it is not a thread-safe Scheduler and should not be used with actual
    concurrency. A common pitfall is complicated flows that use many operators and
    Schedulers are not easily configurable to use `TestScheduler`. In this case, you
    can use `RxJavaPlugins.setComputationScheduler()` and similar methods that override
    the standard Schedulers and inject `TestScheduler` in its place.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当您需要虚拟表示时间流逝时，请使用 `TestScheduler`，但请注意，它不是一个线程安全的调度器，不应与实际并发一起使用。一个常见的陷阱是使用许多操作符和调度器的复杂流程，这些调度器不易配置为使用
    `TestScheduler`。在这种情况下，您可以使用 `RxJavaPlugins.setComputationScheduler()` 和类似方法来覆盖标准调度器，并在其中注入
    `TestScheduler`。
- en: There are two other methods to note in `TestScheduler`. The `now()` will return
    how much time has virtually elapsed in the unit you specify. The `triggerActions()`
    method will kick-off any actions that are scheduled to be triggered, but have
    not virtually been elapsed yet.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TestScheduler` 中还有两个其他方法需要注意。`now()` 将返回在您指定的单位中虚拟流逝了多少时间。`triggerActions()`
    方法将启动任何计划触发但尚未虚拟流逝的动作。
- en: Debugging RxJava code
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 RxJava 代码
- en: RxJava is not easy to debug at first glance, primarily due to the lack of debug
    tooling and the large stack traces it can produce. There are efforts in creating
    effective debugging tools for RxJava, most notably the Frodo library for Android
    ([https://github.com/android10/frodo](https://github.com/android10/frodo)). We
    will not cover any debugging tools for RxJava as nothing has been standardized
    quite yet, but we will learn about an effective approach that you can take to
    debug reactive code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 初看起来并不容易调试，主要是因为缺乏调试工具和它可能产生的大量堆栈跟踪。有创建针对 RxJava 的有效调试工具的努力，最著名的是 Android
    的 Frodo 库 ([https://github.com/android10/frodo](https://github.com/android10/frodo))。我们不会涵盖任何
    RxJava 的调试工具，因为还没有标准化，但我们将了解一种有效的调试反应式代码的方法。
- en: A common theme in debugging RxJava operations is finding the bad link or the
    operator in the `Observable`/`Flowable` chain that is causing the problem. Whether
    an error is being emitted, `onComplete()` is never being called, or an `Observable`
    is unexpectedly empty, you often have to start at the beginning of the chain at
    the source and then validate each step downstream until you find the one not working
    correctly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试 RxJava 操作中，一个常见的主题是找到导致问题的 `Observable`/`Flowable` 链中的坏链接或操作符。无论是否正在发射错误，`onComplete()`
    永远没有被调用，或者 `Observable` 突然为空，你通常必须从链的起始处，即源头开始，然后验证每个下游步骤，直到找到不正常工作的那个。
- en: 'Say, we have an `Observable` pushing five strings containing numbers and alphabetic
    words separated by slashes "`/`". We want to break these up on the slashes "`/`",
    filter only for the alphabetic words, and capture them in `TestObserver`. However,
    run this operation and you will see that this test fails:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，我们有一个 `Observable` 正在推送包含数字和由斜杠 "`/`" 分隔的字母词的五个字符串。我们想要在斜杠 "`/`" 上分割这些字符串，只过滤字母词，并将它们捕获在
    `TestObserver` 中。然而，运行这个操作，你会看到这个测试失败了：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So what in the world went wrong? How do we debug this failing test? Well, remember
    that RxJava operations are a pipeline. The correct emissions are supposed to flow
    through and make it to the `Observer`. But no emissions were received instead.
    Let's get our plumber gear on and find out where the clog in the pipeline is.
    We will start at the source.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么到底出了什么问题？我们如何调试这个失败的测试？嗯，记住 RxJava 操作是一个管道。正确的发射项应该流动并通过，到达 `Observer`。但是没有收到任何发射项。让我们穿上我们的管道工装备，找出管道中的堵塞在哪里。我们将从源头开始。
- en: 'Place `doOnNext()` immediately after the source and before `concatMap()`, and
    print each emission. This gives us visibility into what is coming out of the source
    `Observable`. As shown here, we should see all the emissions from the source print,
    which shows that no emissions are being omitted and the source upstream is working
    correctly:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在源头之后和 `concatMap()` 之前立即放置 `doOnNext()`，并打印每个发射项。这让我们能够看到从源头 `Observable` 中出来的内容。如图所示，我们应该看到所有来自源头的发射项被打印出来，这表明没有发射项被遗漏，并且源头上游运行正常：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s move downstream and look at `concatMap()` next. Maybe that is omitting
    emissions, so let''s check. Move `doOnNext()` after `concatMap()` and print each
    emission to see whether all of them are coming through, as shown next:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向下流，接下来看看 `concatMap()`。也许它遗漏了发射项，所以让我们检查一下。在 `concatMap()` 之后放置 `doOnNext()`
    并打印每个发射项，以查看是否所有这些都能通过，如图所示：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Okay, so `concatMap()` is working fine and all the emissions are going through.
    So nothing is wrong with the splitting operation inside `concatMap()`. Let''s
    move on downstream and put `doOnNext()` after `filter()`. As shown, print each
    emission to see whether the ones we want come out of the `filter()`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以 `concatMap()` 运行正常，所有的发射项都通过了。所以 `concatMap()` 内部的分割操作没有问题。让我们继续向下流，在
    `filter()` 之后放置 `doOnNext()`。如图所示，打印每个发射项以查看我们想要的项是否从 `filter()` 中出来：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Aha! No emissions were printed after `filter()`, which means nothing flowed
    through it. The `filter()` is the operator causing the problem. We intended to
    filter out the numeric strings and only emit the alphabetic words. But for some
    reason, all emissions were filtered out. If you know anything about regular expressions,
    note that we are only qualifying strings that are entirely uppercase. We actually
    need to qualify lowercase letters too, so here is the correction we need:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 哎！在`filter()`之后没有打印出任何排放项，这意味着没有任何东西通过它。`filter()`是导致问题的操作符。我们原本打算过滤掉数字字符串，只发出字母词。但不知何故，所有排放项都被过滤掉了。如果你对正则表达式有所了解，请注意我们只对完全大写的字符串进行限定。实际上，我们还需要对小写字母进行限定，所以这里是我们需要的修正：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alright, it is fixed! Our unit test passed finally, and here it is in its entirety.
    Now that the problem is solved and we are finished debugging, we can remove `doOnNext()`
    and any print calls:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它已经修复了！我们的单元测试最终通过了，下面是它的全部内容。现在问题已经解决，我们完成了调试，我们可以移除`doOnNext()`和任何打印调用：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In summary, when you have an `Observable` or `Flowable` operation that is emitting
    an error, the wrong items, or no items at all, start at the source and work your
    way downstream until you find the operator causing the problem. You can also put
    `TestObserver` at each step to get a more comprehensive report of what happened
    in that operation, but using operators such as `doOnNext()`, `doOnError()`, `doOnComplete()`,
    `doOnSubscribe()`, and so on are quick and easy ways to get an insight into what
    is happening in that part of the pipeline.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当你有一个正在发出错误、错误项或没有任何项的`Observable`或`Flowable`操作时，从源头开始，逐步向下工作，直到找到导致问题的操作符。你还可以在每个步骤放置`TestObserver`以获取该操作中发生的更全面的报告，但使用`doOnNext()`、`doOnError()`、`doOnComplete()`、`doOnSubscribe()`等操作符是快速且简单的方法，可以深入了解管道该部分正在发生的事情。
- en: It may not be optimal that you have to modify code with `doXXX()` operators
    to debug it. If you are using Intellij IDEA, you can try to use breakpoints within
    lambdas, although I have only had mixed success with this approach. You can also
    research RxJava debugging libraries to get detailed logs without modifying your
    code. Hopefully, as RxJava continues to gain traction, more useful debugging tools
    will pop up and become standardized.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不是最优的做法是必须使用`doXXX()`操作符修改代码来调试它。如果你使用Intellij IDEA，你可以尝试在lambda中设置断点，尽管我使用这种方法只有混合的成功率。你还可以研究RxJava调试库，以获取不修改代码的详细日志。希望随着RxJava继续获得关注，将出现更多有用的调试工具，并成为标准。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to test and debug RxJava code. When you create
    an application or an API that is built on RxJava, you may want to build unit tests
    around it in order to ensure that sanity checks are always enforced. You can use
    blocking operators to help perform assertions, but `TestObserver` and `TestSubscriber`
    will give you a much more comprehensive and streamlined testing experience. You
    can also use `TestScheduler` to simulate time elapses so that time-based Observables
    can be tested instantly. Finally, we covered a debugging strategy in RxJava, which
    often involves finding the *broken operator*, starting at the source, and moving
    downstream until it is found.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何测试和调试RxJava代码。当你创建一个基于RxJava的应用程序或API时，你可能想要围绕它构建单元测试，以确保始终执行健全性检查。你可以使用阻塞操作符来帮助执行断言，但`TestObserver`和`TestSubscriber`将为你提供更全面和流畅的测试体验。你还可以使用`TestScheduler`来模拟时间流逝，以便可以立即测试基于时间的Observables。最后，我们介绍了RxJava的调试策略，这通常涉及找到*损坏的操作符*，从源头开始，向下移动直到找到。
- en: 'This chapter closes our journey covering the RxJava library, so congratulations
    if you got here! You now have a solid foundation of building reactive Java applications.
    In the final two chapters, we will cover RxJava in two specific domains: Android
    and Kotlin.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了我们对RxJava库的探索之旅，所以如果你已经到达这里，恭喜你！你现在有了构建响应式Java应用程序的坚实基础。在最后两章中，我们将涵盖RxJava在两个特定领域中的应用：Android和Kotlin。
