- en: Microbenchmarking Applications with JMH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMH进行微基准测试的应用
- en: In the previous chapter, we took an in-depth review of **garbage collection**
    to include an object life cycle, garbage collection algorithms, garbage collection
    options, and methods related to garbage collection. We took a brief look at upgrades
    to garbage collection in Java 8 and focused on changes with the new Java 9 platform.
    Our exploration of garbage collection in Java 9 included looks at default garbage
    collection, depreciated garbage collection combinations, unified garbage collection
    logging, and garbage collection issues that persist, even after Java 9.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入回顾了垃圾收集，包括对象生命周期、垃圾收集算法、垃圾收集选项以及与垃圾收集相关的方法。我们简要地看了Java 8中垃圾收集的升级，并专注于新Java
    9平台的变化。我们对Java 9中的垃圾收集的探索包括默认垃圾收集、已弃用的垃圾收集组合、统一的垃圾收集日志以及即使在Java 9之后仍然存在的垃圾收集问题。
- en: In this chapter, we will look at how to write performance tests using the **Java
    Microbenchmark Harness** (**JMH**), a Java harness library for writing benchmarks
    for the **Java Virtual Machine** (**JVM**). We will use Maven along with JMH to
    help illustrate the power of microbenchmarking with the new Java 9 platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用**Java微基准工具**（**JMH**），这是一个用于编写针对**Java虚拟机**（**JVM**）的基准测试的Java工具库。我们将使用Maven和JMH来帮助说明使用新Java
    9平台进行微基准测试的强大功能。
- en: 'Specifically, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: Microbenchmarking overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微基准测试概述
- en: Microbenchmarking with Maven
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven进行微基准测试
- en: Benchmarking options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试选项
- en: Techniques for avoiding microbenchmarking pitfalls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免微基准测试陷阱的技术
- en: Microbenchmarking overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微基准测试概述
- en: Microbenchmarking is used to test the performance of a system. This differs
    from macrobenchmarking which runs tests on different platforms for efficiency
    comparison and subsequent analysis. With microbenchmarking, we typically target
    a specific slice of code on one system such as a method or loop. The primary purpose
    of microbenchmarking is to identify optimization opportunities in our code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试用于测试系统的性能。这与宏观基准测试不同，宏观基准测试在不同的平台上运行测试以比较效率和进行后续分析。在微基准测试中，我们通常针对一个系统上的特定代码片段进行测试，例如一个方法或循环。微基准测试的主要目的是在我们的代码中识别优化机会。
- en: There are multiple approaches to benchmarking and we will focus on using the
    JMH tool. So, why benchmark at all? Developers do not always concern themselves
    with performance issues unless performance is a stated requirement. This can lead
    to post-deployment surprises that could have been avoided if microbenchmarking
    was conducted as part of the development process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试有多种方法，我们将重点介绍使用JMH工具。那么，为什么要进行基准测试呢？开发者并不总是关心性能问题，除非性能是一个明确的要求。这可能导致部署后的意外，如果微基准测试作为开发过程的一部分进行，这些意外本可以避免。
- en: 'Microbenchmarking takes place across several phases of a process. As shown
    in the following diagram, the process involves design, implementation, execution,
    analysis, and enhancement:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试发生在过程的几个阶段。如图所示，该过程包括设计、实现、执行、分析和增强：
- en: '![](img/9977e7cd-6e56-40fc-abfd-4c115659bf82.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9977e7cd-6e56-40fc-abfd-4c115659bf82.png)'
- en: In the **Design** phase, we determine our goals and design our microbenchmark
    accordingly. In the **Implement** phase, we are writing the microbenchmark and
    then, in the **Execution** phase, we actually run the test. With microbenchmarking
    results in hand, we interpret and analyze the results in the **Analysis** phase.
    This leads to code improvements in the **Enhancement** phase. Once our code has
    been updated, we redesign the microbenchmarking test, adjust the implementation,
    or go straight to the **Execution** phase. This is a cyclical process that continues
    until we have achieved the performance optimization we identified in our goals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在**设计**阶段，我们确定我们的目标并相应地设计微基准测试。在**实现**阶段，我们编写微基准测试，然后在**执行**阶段实际运行测试。有了微基准测试的结果，我们在**分析**阶段解释和分析结果。这导致在**增强**阶段对代码进行改进。一旦我们的代码被更新，我们重新设计微基准测试，调整实现，或者直接进入**执行**阶段。这是一个循环过程，直到我们达到目标中确定的性能优化。
- en: Approach to using JMH
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMH的方法
- en: Oracle's documentation indicates that the most ideal JMH use case is to use
    a Maven project that is dependent on the application's JAR files. They further
    recommend that microbenchmarking take place via the command-line and not from
    within an **Integrated Development Environment** (**IDE**), as that could impact
    the results.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle的文档表明，最理想的JMH使用案例是使用依赖于应用程序JAR文件的Maven项目。他们还建议，微基准测试应通过命令行进行，而不是在**集成开发环境**（**IDE**）内进行，因为这可能会影响结果。
- en: Maven, also referred to as Apache Maven, is a project management and comprehension
    tool that we can use to manage our application project build, reporting, and documentation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Maven，也称为Apache Maven，是一个项目管理和理解工具，我们可以用它来管理我们的应用程序项目构建、报告和文档。
- en: To use JMH, we will use bytecode processors (annotations) to generate the benchmark
    code. We use Maven archetypes to enable JMH.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JMH，我们将使用字节码处理器（注解）来生成基准代码。我们使用Maven原型来启用JMH。
- en: In order to test the JMH, we require an IDE with support for Maven and Java
    9\. If you do not yet have Java 9 or an IDE with Java 9 support, you can follow
    the steps in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试JMH，我们需要一个支持Maven和Java 9的IDE。如果您还没有Java 9或支持Java 9的IDE，您可以按照下一节中的步骤进行操作。
- en: Installing Java 9 and Eclipse with Java 9 support
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Java 9和具有Java 9支持的Eclipse
- en: You can download and install Java 9 from the JDK 9 early access builds page--[http://jdk.java.net/9/](http://jdk.java.net/9/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从JDK 9早期访问构建页面下载并安装Java 9--[http://jdk.java.net/9/](http://jdk.java.net/9/)。
- en: Once you have Java 9 installed, download the latest version of Eclipse. At the
    time of writing this book, that was Oxygen. Here is the relevant link--[https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了Java 9，请下载Eclipse的最新版本。在撰写本书时，那是Oxygen。以下是相关链接--[https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)。
- en: 'The next step is to enable Java 9 support in your IDE. Launch Eclipse Oxygen
    and select Help | Eclipse Marketplace... , as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在您的IDE中启用Java 9支持。启动Eclipse Oxygen并选择帮助 | Eclipse Marketplace... ，如下截图所示：
- en: '![](img/e58605c5-04d5-43d6-942f-30f91ead584a.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e58605c5-04d5-43d6-942f-30f91ead584a.png)'
- en: 'With the Eclipse Marketplace dialog window present search for `Java 9 support`
    using the search box. As you can see in the following screenshot, you will be
    presented with an Install button:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse Marketplace对话框窗口中，使用搜索框搜索“Java 9支持”。如您在以下截图中所见，您将看到一个安装按钮：
- en: '![](img/88048ea3-6896-40f5-8e18-0ca017da2467.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88048ea3-6896-40f5-8e18-0ca017da2467.png)'
- en: During the installation process, you will be required to accept the license
    agreement and, upon completion, you will be required to restart Eclipse.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，您将需要接受许可协议，并在完成后，您将需要重新启动Eclipse。
- en: Hands-on experiment
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践实验
- en: 'Now that we have Eclipse updated to support Java 9, you can run a quick test
    to determine if JMH is working on your development computer. Start by creating
    a new Maven project as illustrated in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将Eclipse更新以支持Java 9，您可以对您的开发计算机进行快速测试以确定JMH是否正常工作。首先创建一个新的Maven项目，如下截图所示：
- en: '![](img/a0904716-b8d9-449f-9268-135f980bb6c6.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0904716-b8d9-449f-9268-135f980bb6c6.png)'
- en: 'Next, we need to add a dependency. We can do this by editing the `pom.xml`
    file directly with the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个依赖项。我们可以通过直接编辑`pom.xml`文件来完成此操作，如下代码所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, we can use the dependencies tab to enter the data in a dialog
    window, as shown in the following screenshot. Using this form updates the `pom.xml`
    file with the preceding code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用依赖项选项卡在对话框窗口中输入数据，如下截图所示。使用此表单将更新`pom.xml`文件中的上述代码：
- en: '![](img/8ffc4351-aeba-4856-9192-4a51606dc064.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ffc4351-aeba-4856-9192-4a51606dc064.png)'
- en: 'Next, we need to write a class that contains a JMH method. This is just as
    an initial test to confirm our recently updated development environment. Here
    is sample code you can use for your test:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个包含JMH方法的类。这只是一个初始测试，以确认我们最近更新的开发环境。以下是您可以用于测试的示例代码：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now compile and run our very simple test program. The results are provided
    in the Console tab, or the actual console if you are using the command-line. Here
    is what you will see:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编译并运行我们的非常简单的测试程序。结果在控制台选项卡中提供，或者如果您使用的是命令行，则是实际的控制台。您将看到以下内容：
- en: '![](img/2805c145-4579-4ce4-8cb5-ae9b8cb969e1.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2805c145-4579-4ce4-8cb5-ae9b8cb969e1.png)'
- en: You can see that the program worked sufficiently to let us know that JMH is
    working. Of course, there was, as the output indicates, no benchmarks set up.
    We will take care of that in the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到程序运行得足够好，足以让我们知道 JMH 正在运行。当然，正如输出所示，没有设置基准。我们将在下一节中处理这个问题。
- en: Microbenchmarking with Maven
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven 进行微基准测试
- en: 'One approach to getting started with JMH is to use the JMH Maven archetype.
    The first step is to create a new JMH project. At our system''s command prompt,
    we will enter the `mvn` command followed by a long set of parameters to create
    a new Java project and the necessary Maven `pom.xml` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 JMH 的一种方法是通过 JMH Maven 架构。第一步是创建一个新的 JMH 项目。在我们的系统命令提示符中，我们将输入 `mvn` 命令，然后输入一系列长参数来创建一个新的
    Java 项目和必要的 Maven `pom.xml` 文件：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you enter the `mvn` command and the preceding detailed parameters, you
    will see the results reported to you via the Terminal. Depending on your level
    of use, you might see a large number of downloads from [https://repo.maven.apache.org/maven2/org/apache/mave/plugins](https://repo.maven.apache.org/maven2/org/apache/mave/plugins)
    and other similar repository sites.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入 `mvn` 命令和前面的详细参数，你将通过终端看到报告给你的结果。根据你的使用水平，你可能会看到从 [https://repo.maven.apache.org/maven2/org/apache/mave/plugins](https://repo.maven.apache.org/maven2/org/apache/mave/plugins)
    和其他类似仓库站点的大量下载。
- en: 'You will also see an information section that informs you about the project
    build process:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将看到一个信息部分，它会告诉你有关项目构建过程的信息：
- en: '![](img/14f51f0d-5ca9-43ef-9dc3-12be9b272e61.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14f51f0d-5ca9-43ef-9dc3-12be9b272e61.png)'
- en: 'There will likely be additional plugin and other resources downloaded from
    the [https://repo.maven.apache.org](https://repo.maven.apache.org) repositories.
    Then, you will see an informational feedback component that lets you know the
    project is being generated in batch mode:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能还会从 [https://repo.maven.apache.org](https://repo.maven.apache.org) 仓库下载额外的插件和其他资源。然后，你将看到一个信息反馈组件，它会告诉你项目正在批量模式下生成：
- en: '![](img/1426df05-6070-4f4c-a711-451f75765d2d.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1426df05-6070-4f4c-a711-451f75765d2d.png)'
- en: 'Finally, you will be presented with a set of parameters and a note that your
    project build was successful. As you can see with the following example, the process
    took less than 21 seconds to complete:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将看到一个参数集和一个说明，表明你的项目构建成功。正如以下示例所示，整个过程不到 21 秒就完成了：
- en: '![](img/188f1b35-cf34-416f-8019-07dd0806dbe4.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/188f1b35-cf34-416f-8019-07dd0806dbe4.png)'
- en: 'A folder will be created based on the parameter we included in the `-DartifactId`
    option. In our example, we used `-DartifactId=chapter8-benchmark`, and Maven created
    a `chapter8-benchmark` project folder:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在 `-DartifactId` 选项中包含的参数，将创建一个文件夹。在我们的示例中，我们使用了 `-DartifactId=chapter8-benchmark`，Maven
    创建了一个 `chapter8-benchmark` 项目文件夹：
- en: '![](img/b3aa8bd9-3964-4a9d-8f04-d22ae270f386.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3aa8bd9-3964-4a9d-8f04-d22ae270f386.png)'
- en: 'You will see that Maven created the `pom.xml` file as well as a source (`src`)
    folder. In that folder, under the subdirectory structure of `C:chapter8-benchmarksrcmainjavacompackt`,
    is the `MyBenchmark.java` file. Maven created a benchmark class for us:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到 Maven 创建了 `pom.xml` 文件以及一个源文件夹 (`src`)。在该文件夹中，在 `C:chapter8-benchmarksrcmainjavacompackt`
    的子目录结构下是 `MyBenchmark.java` 文件。Maven 为我们创建了一个基准类：
- en: '![](img/12e79714-00f2-4413-8eb4-1705d52cbc06.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12e79714-00f2-4413-8eb4-1705d52cbc06.png)'
- en: 'Here are the contents of the `MyBenchmark.java` class created by the JMH Maven
    project creation process:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 JMH Maven 项目创建过程创建的 `MyBenchmark.java` 类的内容：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our next step is to modify the `testMethod()` so that there is something to
    test. Here is the modified method we will use for the benchmark test:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是修改 `testMethod()`，使其有可测试的内容。以下是我们将用于基准测试的修改后的方法：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With our code edited, we will navigate back to the project folder, `C:chapter8-benchmark`,
    in our example, and execute `mvn clean install` at the command prompt.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编辑了代码之后，我们将导航回项目文件夹，例如在我们的例子中，回到 `C:chapter8-benchmark`，并在命令提示符下执行 `mvn clean
    install`。
- en: 'You will see several repository downloads, source compilations, plugin installations
    and, finally the Build Success indicator, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到几个仓库下载、源编译、插件安装，最后是如这里所示的构建成功指示器：
- en: '![](img/fe83ee6f-a43d-461b-9a11-b0d6a8f67a51.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe83ee6f-a43d-461b-9a11-b0d6a8f67a51.png)'
- en: 'You will now see `.classpath` and `.project` files as well as a new `.settings`
    and target subfolders in the project directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在项目目录中看到 `.classpath` 和 `.project` 文件，以及新的 `.settings` 和目标子文件夹：
- en: '![](img/62579177-8493-4b9f-8973-68928d464e29.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62579177-8493-4b9f-8973-68928d464e29.png)'
- en: If you navigate to the `target` subfolder, you will see that our `benchmarks.jar`
    file was created. This JAR contains what we need to run our benchmarks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到`target`子文件夹，你会看到我们的`benchmarks.jar`文件已被创建。这个JAR文件包含我们运行基准测试所需的内容。
- en: 'We can update our `MyBenchmark.java` file in an IDE, such as Eclipse. Then,
    we can execute `mvn clean install` again to overwrite our files. After the initial
    time, our builds will be much faster, as nothing will need to be downloaded. Here
    is a look at the output from the build process other than the first time:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在IDE中更新我们的`MyBenchmark.java`文件，例如Eclipse。然后，我们可以再次执行`mvn clean install`来覆盖我们的文件。在初始时间之后，我们的构建将会更快，因为不需要下载任何内容。以下是除了第一次之外构建过程的输出：
- en: '![](img/25c6fa3b-caf1-4c57-af99-8c1b1cc7c8db.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25c6fa3b-caf1-4c57-af99-8c1b1cc7c8db.png)'
- en: Our last step is to run the benchmark tool. We can do that with the following
    command--`java -jar benchmarks.jar`. Even for small benchmarks on simplistic code,
    as with our example, the benchmarks could take some time to run. There will likely
    be several iterations including warmups to provide a more concise and valid set
    of benchmark results.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是运行基准工具。我们可以使用以下命令来执行--`java -jar benchmarks.jar`。即使是针对简单代码的小型基准测试，如我们的示例，基准测试也可能需要一些时间来运行。可能会有几个迭代，包括预热，以提供更简洁和有效的基准结果集。
- en: 'Our benchmark results are provided here. As you can see, the test ran for 8
    minutes and 8 seconds:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的基准结果如下。如您所见，测试运行了8分钟8秒：
- en: '![](img/fccf36e9-565b-4d8b-a090-3a168879b908.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fccf36e9-565b-4d8b-a090-3a168879b908.png)'
- en: Benchmarking options
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试选项
- en: 'In the previous section, you learned how to run a benchmark test. In this section,
    we will look at the following configurable options for running our benchmarks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何运行基准测试。在本节中，我们将查看运行基准测试的以下可配置选项：
- en: Modes
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: Time units
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间单位
- en: Modes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: 'The output of our benchmark results, from the previous section, included a
    **Mode** column that had the value of **thrpt** which is short for **throughput**.
    This is the default mode and there are an additional four modes. All JMH benchmark
    modes are listed and described as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基准结果输出的上一节中，包括了一个**模式**列，其值为**thrpt**，它是**吞吐量**的缩写。这是默认模式，还有另外四种模式。所有JMH基准模式都列出来并如下描述：
- en: '| **Mode** | **Description** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| All | Measures all other modes inclusively. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 所有 | 测量所有其他模式，包括在内。 |'
- en: '| Average | This mode measures the average time for a single benchmark to run.
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 平均 | 此模式测量单个基准运行的平均时间。 |'
- en: '| Sample Time | This mode measures the benchmark execution time and includes
    min and max times. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 样本时间 | 此模式测量基准执行时间，包括最小和最大时间。 |'
- en: '| Single Shot Time | With this mode, there is no JVM warm up and the test is
    to determine how long a single benchmark method takes to run. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 单次射击时间 | 使用此模式时，没有JVM预热，测试是为了确定单个基准方法运行所需的时间。 |'
- en: '| Throughput | This is the default mode and measures the number of operations
    per second the benchmark could be run. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 吞吐量 | 这是默认模式，测量基准每秒可以运行的操作数。 |'
- en: 'To dictate which benchmark mode to use, you will modify your `@Benchmark` line
    of code to one of the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定要使用的基准模式，您需要将代码中的`@Benchmark`行修改为以下之一：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Time units
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间单位
- en: 'In order to gain greater fidelity in benchmark output, we can designate a specific
    unit of time, listed here from shortest to longest:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在基准输出中获得更高的保真度，我们可以指定一个特定的单位时间，以下是从最短到最长的列表：
- en: '`NANOSECONDS`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NANOSECONDS`'
- en: '`MICROSECONDS`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MICROSECONDS`'
- en: '`MILLISECONDS`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MILLISECONDS`'
- en: '`SECONDS`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECONDS`'
- en: '`MINUTES`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MINUTES`'
- en: '`HOURS`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HOURS`'
- en: '`DAYS`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAYS`'
- en: 'In order to make this designation, we simply add the following code to our
    `@Benchmark` line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行此指定，我们只需将以下代码添加到我们的`@Benchmark`行：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we have designated the average mode and nanoseconds
    as the time unit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们指定了平均模式和纳秒作为时间单位。
- en: Techniques for avoiding microbenchmarking pitfalls
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免微基准测试陷阱的技术
- en: Microbenchmarking is not something that every developer will have to worry about,
    but for those that do, there are several pitfalls that you should be aware of.
    In this section we will review the most common pitfalls and suggest strategies
    for avoiding them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试不是每个开发者都必须担心的事情，但对于那些需要担心的人来说，有一些陷阱你应该注意。在本节中，我们将回顾最常见的陷阱，并提出避免它们的策略。
- en: Power management
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功率管理
- en: There are many subsystems that can be used to help you manage the balance between
    power and performance (that is, `cpufreq`). These systems can alter the state
    of time during benchmarks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多子系统可以帮助你管理功率和性能之间的平衡（即`cpufreq`）。这些系统可以改变基准测试期间时间的状态。
- en: 'There are two suggested strategies to this pitfall:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种建议的策略来避免这个陷阱：
- en: Disable any power management systems before running tests
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行测试之前禁用任何电源管理系统
- en: Run the benchmarks for longer periods
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行更长时间的基准测试
- en: OS schedulers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统调度器
- en: Operating system schedulers, such as Solaris schedulers, help determine which
    software processes gain access to a system's resources. Use of these schedulers
    can result in unreliable benchmarking results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统调度器，如Solaris调度器，有助于确定哪些软件进程可以访问系统资源。使用这些调度器可能会导致不可靠的基准测试结果。
- en: 'There are two suggested strategies to this pitfall:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种建议的策略来避免这个陷阱：
- en: Refine your system scheduling policies
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精炼你的系统调度策略
- en: Run the benchmarks for longer periods
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行更长时间的基准测试
- en: Time sharing
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分时
- en: Time-sharing systems are used to help balance system resources. Use of these
    systems often results in irregular gaps between a thread's start and stop time.
    Also, CPU load will not be uniform and our benchmarking data will not be as useful
    to us.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 分时系统用于帮助平衡系统资源。使用这些系统通常会导致线程启动和停止时间之间的不规则间隔。此外，CPU负载将不会均匀，我们的基准测试数据对我们来说将不那么有用。
- en: 'There are two suggested strategies to avoid this pitfall:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种建议的策略来避免这个陷阱：
- en: Test all code before running benchmarks to ensure things work as they should
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行基准测试之前测试所有代码，以确保一切按预期工作
- en: Use JMH to measure only after all threads have started or all threads have stopped
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有线程启动或所有线程停止后使用JMH进行测量
- en: Eliminating dead-code and constant folding
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除死代码和常量折叠
- en: 'Dead-code and constant folding are often referred to as redundant code and
    our modern compilers are pretty good at eliminating them. An example of dead-code
    is code that will never be reached. Consider the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 死代码和常量折叠通常被称为冗余代码，而我们的现代编译器在消除它们方面相当出色。一个死代码的例子是永远不会被执行的代码。考虑以下示例：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our preceding example, the line identified as dead-code is never reached
    since the variable value will never be equal to null. It is set to `10` immediately
    before the conditional `if` statement evaluates the variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的例子中，被识别为死代码的行永远不会被执行，因为变量的值永远不会等于null。它在条件`if`语句评估变量之前立即被设置为`10`。
- en: The problem is that benchmarking code can sometimes be removed in the attempt
    to eliminate dead-code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，在尝试消除死代码的过程中，有时可能会移除基准测试代码。
- en: 'Constant folding is the compiler operation that occurs when compile-time constraints
    are replaced with actual results. The compiler performs constant folding to remove
    any redundant runtime computations. In the following example, we have a `final
    int` followed by a second `int` based on a mathematical calculation involving
    the first `int`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 常量折叠是编译器操作，当编译时约束被替换为实际结果时发生。编译器执行常量折叠以消除任何冗余的运行时计算。在以下示例中，我们有一个`final int`，后面跟着一个基于涉及第一个`int`的数学计算的第二个`int`：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The constant folding operation would convert the two lines of the preceding
    code to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 常量折叠操作会将前面代码的两行转换为以下内容：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is one suggested strategy to this pitfall:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种建议的策略来避免这个陷阱：
- en: Use the JMH API support to ensure your benchmarking code is not eliminated
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JMH API支持来确保你的基准测试代码不会被消除
- en: Run-to-run variance
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行到运行差异
- en: There are a plethora of issues that can drastically impact the run-to-run variance
    in benchmarking.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多问题可能会严重影响基准测试的运行到运行差异。
- en: 'There are two suggested strategies to this pitfall:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种建议的策略来避免这个陷阱：
- en: Run the JVM multiple times within every subsystem
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个子系统内多次运行JVM
- en: Use multiple JMH folks
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个JMH人员
- en: Cache capacity
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存容量
- en: '**Dynamic randomly accessed memory** (**DRAM**) is very slow. This can result
    in very different performance results during benchmarking.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态随机存取存储器**（**DRAM**）非常慢。这可能导致基准测试期间非常不同的性能结果。'
- en: 'There are two suggested strategies to this pitfall:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种建议的策略来避免这个陷阱：
- en: Run multiple benchmarks with varying problem sets. Keep track of your memory
    footprint during tests.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的问题集运行多个基准测试。在测试期间跟踪你的内存占用。
- en: 'Use the `@State` annotation to dictate the JMH state. This annotation is sued
    to define the instance''s scope. There are three states:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@State`注解来指定JMH状态。这个注解用于定义实例的作用域。有三个状态：
- en: '`Scope.Benchmark`: The instance is shared across all threads that are running
    the same test.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scope.Benchmark`: 实例在运行相同测试的所有线程之间共享。'
- en: '`Scope.Group`: One instance is allocated per thread group.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scope.Group`: 每个线程组分配一个实例。'
- en: '`Scope.Thread`: Each thread will have its own instance. This is the default
    state.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scope.Thread`: 每个线程都将拥有自己的实例。这是默认状态。'
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that the JMH is a Java harness library for writing
    benchmarks for the JVM. We experimented with writing performance tests using Maven
    along with JMH to help illustrate the procedures of microbenchmarking with the
    new Java 9 platform. We started with a microbenchmarking overview, then dove deep
    into microbenchmarking with Maven, reviewed benchmarking options, and concluded
    with a few techniques for avoiding microbenchmarking pitfalls.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到JMH是一个用于为JVM编写基准测试的Java工具库。我们通过使用Maven和JMH来编写性能测试，帮助说明使用新Java 9平台进行微基准测试的流程。我们从微基准测试概述开始，然后深入探讨了使用Maven进行微基准测试，回顾了基准测试选项，并以一些避免微基准测试陷阱的技术结束。
- en: In the next chapter, we will learn to write an application that is managing
    other processes and utilizes the modern process management API of the Java 9 platform.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何编写一个管理其他进程并利用Java 9平台现代进程管理API的应用程序。
