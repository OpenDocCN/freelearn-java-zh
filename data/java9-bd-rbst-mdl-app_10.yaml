- en: Making Use of the ProcessHandle API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ProcessHandle API
- en: In the previous chapter, we discovered the **Java Microbenchmark Harness** (**JMH**).
    We explored performance tests and how to write them using JMH, the Java library
    for writing benchmarks for the Java Virtual Machine. We started with an overview
    of microbenchmarking, then looked at microbenchmarking with Maven, reviewed benchmarking
    options, and concluded with techniques for avoiding microbenchmarking pitfalls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们发现了**Java微基准工具**（**JMH**）。我们探讨了性能测试以及如何使用JMH编写Java虚拟机的基准测试，JMH是一个Java库。我们从微基准测试的概述开始，然后探讨了使用Maven进行微基准测试，回顾了基准测试选项，并以避免微基准测试陷阱的技术结束。
- en: In this chapter, we will focus on the updates to the `Process` class and the
    new `java.lang.ProcessHandle` API. Prior to Java 9, managing processes in Java
    was never easy, because Java was rarely used to automate the controlling of other
    processes. The API was insufficient with some features lacking and some tasks
    needed to be solved in a system specific manner. For example, in Java 8, giving
    a process access to its own **process identifier** (**PID**) was an unnecessarily
    difficult task.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于 `Process` 类的更新和新的 `java.lang.ProcessHandle` API。在Java 9之前，在Java中管理进程从未容易过，因为Java很少被用来自动化控制其他进程。API功能不足，一些功能缺失，一些任务需要以系统特定的方式解决。例如，在Java
    8中，给进程访问其自己的**进程标识符**（**PID**）是一个不必要的困难任务。
- en: In this chapter, the reader will gain all the knowledge that is needed to write
    an application that manages other processes and utilizes the modern process management
    API of Java.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将获得编写管理其他进程并利用Java现代进程管理API的应用程序所需的所有知识。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is and how to use the new `ProcessHandle` interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是新的 `ProcessHandle` 接口以及如何使用它
- en: How to get the PID of the current process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取当前进程的PID
- en: How to list different processes that run in the operating system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何列出在操作系统中运行的不同进程
- en: How to effectively wait for an external process to finish
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何有效地等待外部进程完成
- en: How to terminate external processes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何终止外部进程
- en: What are processes?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是进程？
- en: In this section, we will review what processes are in the context of Java application
    programming. If you are already familiar with processes, you might consider skipping
    this section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾在Java应用程序编程中进程的含义。如果您已经熟悉进程，您可能考虑跳过这一节。
- en: Processes are executional units in the operating system. When you start a program,
    you start a process. When the machine boots the code, the first thing it does
    is, execute the boot process. This process then starts other processes that become
    the child of the boot process. These child processes may start other processes.
    This way, when the machine runs there are trees of processes running. When the
    machine does something, it is done in some code executing inside some process.
    The operating system also runs as several processes that execute simultaneously.
    Applications are executed as one or more processes. Most of the applications run
    as a single process but as an example, the Chrome browser starts several processes
    to do all the rendering and network communication operations that finally function
    as a browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是操作系统的执行单元。当您启动一个程序时，您启动一个进程。当机器启动代码时，它首先执行启动进程。然后，该进程启动其他进程，这些进程成为启动进程的子进程。这些子进程可能启动其他进程。这样，当机器运行时，会有进程树在运行。当机器执行某项操作时，它是在某个进程内部执行的代码中完成的。操作系统也作为几个同时执行的过程运行。应用程序作为一个或多个进程执行。大多数应用程序作为一个单独的进程运行，但以为例，Chrome浏览器启动几个进程来完成所有的渲染和网络通信操作，最终作为一个浏览器工作。
- en: To get a better idea about what processes are, start the task manager on Windows
    or the Activity Monitor on OS X and click on the Process tab. You will see the
    different processes that currently exist on the machine. Using these tools, you
    can look at the parameters of the processes, or you can kill an individual process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地了解进程是什么，请在Windows上启动任务管理器或在OS X上启动活动监视器，然后点击进程标签。您将看到机器上当前存在的不同进程。使用这些工具，您可以查看进程的参数，或者您可以终止单个进程。
- en: The individual processes have their memory allocated for their work and they
    are not allowed to freely access each other's memory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单个进程为其工作分配了内存，并且不允许它们自由访问彼此的内存。
- en: The execution unit scheduled by the operating system is a thread. A process
    consists of one or more threads. These threads are scheduled by the operating
    system scheduler and are executed in time slots.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统安排的执行单元是线程。一个进程由一个或多个线程组成。这些线程由操作系统调度器调度，并在时间槽中执行。
- en: With every operating system, processes have a process identifier, which is a
    number that identifies the process. No two processes can be active at a time,
    sharing the same PID. When we want to identify an active process in the operating
    system we use the PID. On Linux and other Unix-like operating systems, the `kill`
    command terminates a process. The argument to be passed to this program is the
    PID of the process, to terminate. Termination can be graceful. It is something
    like asking the process to exit. If the process decides not to, it can keep running.
    Programs can be prepared to stop upon such requests. For example, a Java application
    may add a `Thread` object calling the `Runtime.getRuntime().addShutdownHook(Thread
    t)` method. The thread passed is supposed to start when the process is asked to
    stop and the thread can perform all tasks that the program has to do before it
    exits. However, there is no guarantee that it does start. It depends on the actual
    implementation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有进程标识符，这是一个标识进程的数字。在任何时候，不会有两个进程同时活跃，共享相同的PID。当我们想要在操作系统中识别一个活跃的进程时，我们使用PID。在Linux和其他类Unix操作系统中，`kill`命令用于终止进程。传递给此程序的参数是要终止的进程的PID。终止可以是优雅的。这就像请求进程退出。如果进程决定不退出，它可以继续运行。程序可以准备在收到此类请求时停止。例如，一个Java应用程序可能添加一个调用`Runtime.getRuntime().addShutdownHook(Thread
    t)`方法的`Thread`对象。传递的线程应该在进程被请求停止时启动，并且线程可以执行程序退出前必须完成的全部任务。然而，没有保证它一定会启动。这取决于实际的实现。
- en: The new ProcessHandle interface
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的ProcessHandle接口
- en: There are two new interfaces and also their implementations in Java 9 supporting
    the handling of operating system processes. One of them is `ProcessHandle`, the
    other one is `ProcessHandle.Info`, a nested interface of the prior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，有两个新的接口及其实现支持操作系统进程的处理。其中一个是`ProcessHandle`，另一个是`ProcessHandle.Info`，它是前者的嵌套接口。
- en: A `ProcessHandle` object identifies an operating system process and provides
    methods to manage the process. In prior versions of Java, this was possible only
    using operating system specific methods using the PID to identify the process.
    The major problem with this approach is that the PID is unique only while the
    process is active. When a process finishes, the operating system is free to reuse
    the PID for a new process. When we know only the PID of a process and check to
    see if the process is still running, what we are really doing is checking if there
    is an active process with that PID. Our process may be alive when we check it,
    but the next time our program queries the process state, it might be a different
    process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessHandle`对象用于标识操作系统进程，并提供管理进程的方法。在Java的早期版本中，这只能通过使用特定于操作系统的方法，并使用PID来识别进程来实现。这种方法的主要问题是PID仅在进程活跃时是唯一的。当进程结束时，操作系统可以自由地重新使用PID为新进程分配。当我们只知道进程的PID并检查进程是否仍在运行时，我们实际上是在检查是否存在具有该PID的活跃进程。当我们检查时，我们的进程可能仍然存活，但当我们下次程序查询进程状态时，它可能是一个不同的进程。'
- en: The desktop and server operating systems try not to reuse the PID values for
    as long as possible. On some embedded systems the operating system may only use
    16-bit to store the PID. When only 16-bit values are used, there is a greater
    chance that the PIDs will be reused. We can avoid this problem using the `ProcessHandle`
    API. We can receive a `ProcessHandle` and can call the `handle.isAlive()` method.
    This method will return `false` when the process finishes. This works even if
    the PID was reused.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面和服务器操作系统会尽可能长时间地不重用PID值。在一些嵌入式系统中，操作系统可能只使用16位来存储PID。当只使用16位值时，PID被重用的可能性更大。我们可以使用`ProcessHandle`
    API来避免这个问题。我们可以接收一个`ProcessHandle`并调用`handle.isAlive()`方法。当进程结束时，此方法将返回`false`。即使PID被重用，这也同样有效。
- en: Getting the PID of the current process
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前进程的PID
- en: We can gain access to the PID of the processes via the handle. The `handle.getPid()`method
    returns a `Long` representing the numerical value of the PID. Since it is safer
    to access the processes through the handle, the importance of this method is limited.
    It may come in handy when our code wants to give information about itself to some
    other management tool. It is a common practice for programs to create a file that
    has the numeric PID as the name of the file. It may be a requirement that a certain
    program does not run in multiple processes. In that case, the code writes its
    own PID file to a specific directory. If a PID file with that name already exists,
    processing stops. If the previous process crashed and terminated without deleting
    the PID file, then the system manager can easily delete the file and start the
    new process. If the program hangs, then the system manager can easily kill the
    dead process if s/he knows the PID.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过句柄访问进程的PID。`handle.getPid()`方法返回一个表示PID数值的`Long`。由于通过句柄访问进程更安全，因此此方法的重要性有限。当我们的代码想要向其他管理工具提供有关自身的信息时，它可能很有用。对于程序来说，创建一个以数值PID为文件名的文件是一种常见做法。可能存在某些程序不能在多个进程中运行的要求。在这种情况下，代码将将其自己的PID文件写入特定目录。如果已存在同名PID文件，则处理停止。如果先前的进程崩溃并终止而没有删除PID文件，那么系统管理员可以轻松删除文件并启动新进程。如果程序挂起，那么如果系统管理员知道PID，则可以轻松地杀死已死的进程。
- en: To get the PID of the current process, the call chain `ProcessHandle.current().
    getPid()` can be used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前进程的PID，可以使用调用链`ProcessHandle.current().getPid()`。
- en: Getting information about a process
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取进程信息
- en: To get information about a process, we need access to the `Info` object of the
    process. This is available through a `ProcessHandle`. We use a call to the `handle.info()`
    method to return it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取进程信息，我们需要访问进程的`Info`对象。这可以通过`ProcessHandle`来实现。我们通过调用`handle.info()`方法来返回它。
- en: 'The `Info` interface defines query methods that deliver information about the
    process. These are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Info`接口定义了查询方法，用于提供有关进程的信息。这些方法是：'
- en: '`command()` returns an `Optional<String>` containing the command that was used
    to start the process'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command()`返回一个包含启动进程所使用的命令的`Optional<String>`'
- en: '`arguments()` returns an `Optional<String[]>` that contains the arguments that
    were used on the command-line after the command to start the process'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments()`返回一个包含在启动进程的命令行之后使用的参数的`Optional<String[]>`'
- en: '`commandLine()` returns an `Optional<String>` that contains the whole command-line'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commandLine()`返回一个包含整个命令行的`Optional<String>`'
- en: '`startInstant()` returns an `Optional<Instant>`, which essentially represents
    the time the process was started'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startInstant()`返回一个`Optional<Instant>`，它本质上表示进程启动的时间'
- en: '`totalCpuDuration()` returns an `Optional<Duration>`, which represents the
    CPU time used by the process since it was started'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalCpuDuration()`返回一个`Optional<Duration>`，它表示进程自启动以来使用的CPU时间'
- en: '`user()` returns an `Optional<String>` that holds the name of the user the
    process belongs to'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user()`返回一个包含进程所属用户名的`Optional<String>`'
- en: The values returned by these methods are all `Optional` because there is no
    guarantee that the actual operating system or the Java implementation can return
    the information. However, on most operating systems it should work and the returned
    values should be present.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回的值都是`Optional`，因为没有保证实际操作系统或Java实现可以返回信息。然而，在大多数操作系统上，它应该可以工作，并且返回的值应该存在。
- en: 'The following sample code displays the information on a given process:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码显示了给定进程的信息：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the console output for the preceding code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的控制台输出：
- en: '![](img/b6e50be9-a42b-4244-b5ef-9c56c07b0918.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6e50be9-a42b-4244-b5ef-9c56c07b0918.png)'
- en: Listing processes
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出进程
- en: Prior to Java 9, we did not have the means to obtain a list of active processes.
    With Java 9 it is now possible to get the processes in a stream. There are three
    methods that return a `Stream<ProcessHandle>`. One lists the child processes.
    The other lists all the descendants; the children and the children of those recursively.
    The third lists all the processes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，我们没有获取活动进程列表的方法。现在，使用Java 9，我们可以通过流来获取进程。有三个方法返回`Stream<ProcessHandle>`。一个列出子进程。另一个列出所有后代；包括子进程及其子进程。第三个列出所有进程。
- en: Listing children
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出子进程
- en: To get the stream of process handles that can be used to control the children,
    the static method `processHandle.children()` should be used. This will create
    a snapshot of the children processes of the process represented by `processHandle`
    and create the `Stream`. Since processes are dynamic there is no guarantee that
    during the code execution, while our program attends to the handles, that all
    children processes are still active. Some of them may terminate and our process
    may spawn new children, perhaps from a different thread. Thus the code should
    not assume that each of the `ProcessHandle` elements of the stream represents
    an active and running process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可以用来控制子进程的进程句柄流，应使用静态方法`processHandle.children()`。这将创建由`processHandle`表示的进程的后代进程的快照并创建`Stream`。由于进程是动态的，因此无法保证在代码执行期间，当我们的程序关注句柄时，所有子进程都仍然处于活动状态。其中一些可能已终止，我们的进程可能从不同的线程派生新的子进程。因此，代码不应假设流中的每个`ProcessHandle`元素都代表一个活跃且正在运行的进程。
- en: 'The following program starts 10 command prompts in Windows and then counts
    the number of children processes and prints it to standard output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序在Windows中启动10个命令提示符，然后计算子进程的数量并将其打印到标准输出：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Executing the program will result in the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序将产生以下结果：
- en: '![](img/2a4889f9-7db7-4782-ba6c-aeff89937ce5.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a4889f9-7db7-4782-ba6c-aeff89937ce5.png)'
- en: Listing descendants
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出后代
- en: 'Listing the descendants is very similar to listing children, but if we call
    the `processHandle.descendants()` method then the `Stream` will contain all the
    children processes and the children processes of those processes and so on. The
    following program starts command prompts with command-line arguments so that they
    also spawn another `cmd.exe` that terminates:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列出后代与列出子进程非常相似，但如果我们调用`processHandle.descendants()`方法，则`Stream`将包含所有子进程以及这些子进程的后代进程，依此类推。以下程序以命令行参数启动命令提示符，以便它们也生成另一个终止的`cmd.exe`：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the command a few times will result in the following, non-deterministic
    output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令几次将产生以下非确定性的输出：
- en: '![](img/eeff92fc-0f2e-4f28-ae6a-733dbaf8a370.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eeff92fc-0f2e-4f28-ae6a-733dbaf8a370.png)'
- en: The output clearly demonstrates that when the `Stream` of the descendants is
    created not all processes are alive. The sample code starts 10 processes and each
    of them starts another. The `Stream` does not have 20 elements because some of
    these sub-processes were terminated during processing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地表明，当创建后代的`Stream`时，并非所有进程都处于活动状态。示例代码启动了10个进程，每个进程又启动了另一个。`Stream`中没有20个元素，因为其中一些子进程在处理过程中已终止。
- en: Listing all processes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有进程
- en: Listing all the processes is slightly different from listing descendants and
    children. The method `allProcess()` is static and returns a `Stream` of handles
    of all processes that are active in the operating system at the time of execution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有进程与列出后代和子进程略有不同。方法`allProcess()`是静态的，并在执行时返回操作系统所有活动进程的句柄`Stream`。
- en: 'The following sample code prints the process commands to the console that seem
    to be Java processes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码将看起来像是Java进程的进程命令打印到控制台：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the program lists all the process commands that have the string
    `java` inside:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出列出了包含字符串`java`的所有进程命令：
- en: '![](img/9f029ce2-ba76-4987-82b1-7a59f58d2e6e.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f029ce2-ba76-4987-82b1-7a59f58d2e6e.png)'
- en: Your actual output may, of course, be different.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您的实际输出可能会有所不同。
- en: Waiting for processes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待进程
- en: When a process starts another process, it may wait for the process many times
    because it needs the result of the other program. If the structure of the task
    can be organized in a way that the parent program can do something else while
    waiting for the child process to finish, then the parent process can invoke the
    `isAlive()` method on the process handle. Many times, the parent process has nothing
    to do until the spawned process finishes. Old applications implemented loops that
    called the `Thread.sleep()` method so CPU was not excessively wasted and from
    time to time the process was checked to see if it was still alive. Java 9 offers
    a much better approach to the waiting process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程启动另一个进程时，它可能需要多次等待该进程，因为它需要另一个程序的结果。如果可以将任务结构组织成父程序可以在等待子进程完成时做其他事情的方式，那么父进程就可以在进程句柄上调用`isAlive()`方法。很多时候，父进程直到派生的进程完成之前都没有事情可做。旧应用程序实现了循环，调用`Thread.sleep()`方法，这样CPU就不会过度浪费，并且不时检查进程是否仍然处于活动状态。Java
    9为等待进程提供了一种更好的方法。
- en: The `ProcessHandle` interface has a method called `onExit` that returns a `CompletableFuture`.
    This class was introduced in Java 8 and makes it possible to wait for a task to
    be finished without looping. If we have the handle to a process we can simply
    call the `handle.onExit().join()` method to wait until the process finishes. The
    `get()` method of the returned `CompletableFuture` will return the `ProcessHandle`
    instance that was used to create it in the first place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessHandle`接口有一个名为`onExit`的方法，它返回一个`CompletableFuture`。这个类是在Java 8中引入的，使得在没有循环的情况下等待任务完成成为可能。如果我们有一个进程的句柄，我们可以简单地调用`handle.onExit().join()`方法来等待进程完成。返回的`CompletableFuture`的`get()`方法将返回最初用于创建它的`ProcessHandle`实例。'
- en: We can call the `onExit()` method on the handle many times and each time it
    will return a different `CompletableFuture` object, each related to the same process.
    We can call the `cancel()` method on the object but it will only cancel the `CompletableFuture`
    object and not the process and also does not have any effect on the other `CompletableFuture`
    objects that were created from the same `ProcessHandle` instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在句柄上多次调用`onExit()`方法，每次都会返回一个不同的`CompletableFuture`对象，每个对象都与同一个进程相关。我们可以在对象上调用`cancel()`方法，但它只会取消`CompletableFuture`对象，而不会取消进程，也不会对从同一个`ProcessHandle`实例创建的其他`CompletableFuture`对象产生任何影响。
- en: Terminating processes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止进程
- en: To terminate a process we can call the `destroy()` method or the `destroyForcibly()`
    method on the `ProcessHandle` instance. Both of these methods will terminate the
    process. The `destroy()` method is expected to terminate the process gracefully
    executing the process shutdown sequence. In this case the shutdown hooks added
    to the run time are executed if the actual implementation supports the graceful,
    normal termination of processes. The `destroyForcibly()` method will enforce process
    termination, and in this case the shutdown sequence will not be executed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要终止一个进程，我们可以在`ProcessHandle`实例上调用`destroy()`方法或`destroyForcibly()`方法。这两个方法都会终止进程。`destroy()`方法预期将以优雅的方式终止进程，执行进程关闭序列。在这种情况下，如果实际实现支持进程的优雅、正常终止，则会执行添加到运行时的关闭钩子。`destroyForcibly()`方法将强制终止进程，在这种情况下，不会执行关闭序列。
- en: If the process managed by the handle is not alive then nothing happens when
    the code calls any of these methods. If there are any `CompletableFuture` objects
    created calling the `onExit()` method on the handle then they will be completed
    after the call to the `destroy()` or `destroyForcefully()` method when the process
    has terminated. This means that the `CompletableFuture` object will return from
    a `join()` or some similar method after some time when the process termination
    is complete and not immediately after `destroy()` or `destroyForcefully()` returned.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由句柄管理的进程已经不活跃，则在代码调用这些方法中的任何一个时，都不会发生任何操作。如果有任何创建于句柄上调用`onExit()`方法的`CompletableFuture`对象，那么在进程终止后，它们将在调用`destroy()`或`destroyForcefully()`方法之后完成。这意味着`CompletableFuture`对象将在进程终止完成后的一段时间后从`join()`或类似方法返回，而不是在`destroy()`或`destroyForcefully()`返回后立即返回。
- en: It is also important to note that process termination may depend on many things.
    If the actual process that is waiting to terminate another does not have the right
    to terminate the other process then the request will fail. In this case the return
    value of the method is `false`. It is also important to understand that a return
    value of `true` does not mean that the process has actually terminated. It only
    means that the termination request was accepted by the operating system and that
    the operating system will terminate the process at some point in the future. This
    will actually happen rather soon, but not instantaneously and thus it should not
    be a surprise if the method `isAlive()` returns `true` for some time after the
    method `destroy()` or `destroyForcefully()` returned the value `true`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，进程的终止可能取决于许多因素。如果实际等待终止另一个进程的进程没有终止其他进程的权限，则请求将失败。在这种情况下，方法的返回值是`false`。同样重要的是要理解，返回值为`true`并不意味着进程实际上已经终止。它仅意味着操作系统已接受终止请求，操作系统将在未来的某个时刻终止进程。这实际上会很快发生，但不是瞬间发生，因此如果在`destroy()`或`destroyForcefully()`返回`true`后的一段时间内，`isAlive()`方法返回`true`，这不应感到惊讶。
- en: The difference between `destroy()` and `destroyForcefully()` is implementation
    specific. The Java standard does not state that `destroy()` does terminate the
    process letting the shutdown sequence be executed. It only *requests the process
    be killed. Whether the process represented by this ProcessHandle object is* *normally
    terminated* *or not is implementation dependent* ([http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--](http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--))*.*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy()`和`destroyForcefully()`之间的区别是具体实现的。Java标准并没有声明`destroy()`确实会终止进程，让关闭序列被执行。它只是*请求终止进程*。由这个`ProcessHandle`对象表示的进程是否*正常终止*是依赖于实现的*([http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--](http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--))*。'
- en: To learn more about `ProcessHandle` interface, visit [http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html](http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`ProcessHandle`接口的信息，请访问[http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html](http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html)。
- en: This is because some operating systems do not implement the graceful process
    termination feature. In such situations, the implementation of `destroy()` is
    the same as calling `destroyForcefully()`.The system specific implementation of
    the interface `ProcessHandle` must implement the method `supportsNormalTermination()`
    that is `true` only if the implementation supports normal (not forceful) process
    termination. The method is expected to return the same value for all invocations
    in an actual implementation and should not change the return value during the
    execution of a JVM instance. There is no need to call the method multiple times.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为某些操作系统没有实现优雅的进程终止功能。在这种情况下，`destroy()`的实现与调用`destroyForcefully()`相同。接口`ProcessHandle`的系统特定实现必须实现`supportsNormalTermination()`方法，该方法仅在实现支持正常（非强制）进程终止时才返回`true`。该方法预期在实现的实际调用中返回相同的值，并且在JVM实例执行期间不应更改返回值。不需要多次调用该方法。
- en: 'The following examples demonstrate process starting, process termination, and
    waiting for the process to terminate. In our example, we use two classes. This
    first class demonstrates the `.sleep()` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了进程启动、进程终止和等待进程终止。在我们的例子中，我们使用两个类。第一个类演示了`.sleep()`方法：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second class in our example calls the `WaitForChildToBeTerminated` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们例子中的第二个类调用了`WaitForChildToBeTerminated`类：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code starts 10 processes, each executing the program that sleeps
    `10` seconds. Then it forcibly destroys the processes, more specifically, the
    operating system is asked to destroy them. Our example joins the `CompletableFuture`
    that is composed from the array of `CompletableFuture` objects, which are created
    using the handles of the individual processes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码启动了10个进程，每个进程执行休眠`10`秒的程序。然后强制销毁这些进程，更具体地说，操作系统被要求销毁它们。我们的例子将`CompletableFuture`与由`CompletableFuture`对象数组组成的`CompletableFuture`连接起来，这些对象使用单个进程的句柄创建。
- en: When all the processes are finished then it prints out the measured time in
    milliseconds. The time interval starts when the processes are created and the
    process creation loop finished. The end of the measured time interval is when
    the processes are recognized by the JVM returning from the `join()` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有进程完成后，它将打印出测量的时间（以毫秒为单位）。时间间隔从进程创建开始，直到进程创建循环结束。测量时间间隔的结束是当进程被JVM通过`join()`方法返回时被识别。
- en: The sample code sets the sleeping time to 10 seconds. This is a more noticeable
    time period. Running the code twice and deleting the line that destroys the processes
    can result a much slower printout. Actually the measured and printed elapsed times
    will also show that terminating the processes has an effect.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码将休眠时间设置为10秒。这是一个更明显的时间段。运行代码两次并删除销毁进程的行可能会导致打印速度变慢。实际上，测量和打印的经过时间也会显示终止进程有影响。
- en: A small process controller application
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个小型进程控制器应用程序
- en: To summarize and put into use all that we have learned in this chapter we look
    at a sample process control application. The functionality of the application
    is very simple. It reads from a series of configuration file(s) parameters how
    to start some processes and then if any of them stops, it tries to restart the
    process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结并应用我们在本章中学到的所有内容，我们来看一个示例过程控制应用程序。该应用程序的功能非常简单。它从一系列配置文件中读取参数，以启动一些进程，然后如果其中任何一个停止，它将尝试重新启动该进程。
- en: Even a real life application can be created from this demo version. You can
    extend the set of parameters of the process with environment variable specifications.
    You can add default directory for the process, input and output redirection or
    even how much CPU a process is allowed to consume without the controlling application
    killing and restarting it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是从这个演示版本中也可以创建一个真实的应用程序。你可以通过环境变量规范扩展进程的参数集。你可以为进程添加默认目录、输入和输出重定向，甚至可以指定进程允许消耗多少CPU，而无需控制应用程序杀死和重新启动它。
- en: The application consists of four classes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序由四个类组成。
- en: '`Main`: This class that contains the public static void main method and is
    used to start up the daemon.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main`: 这个类包含公共静态的`main`方法，用于启动守护进程。'
- en: '`Parameters`: This class contains the configuration parameters for a process.
    In this simple case it will only contain one field, the `commandLine`. If the
    application gets extended this class will contain the default directory, the redirections,
    and CPU use limiting data.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameters`: 这个类包含进程的配置参数。在这个简单的例子中，它将只包含一个字段，即`commandLine`。如果应用程序被扩展，这个类将包含默认目录、重定向和CPU使用限制数据。'
- en: '`ParamsAndHandle`: This class that is nothing else than a data tuple holding
    a reference to a `Parameters` object and also a process handle. When a process
    dies and gets restarted the process handle is replaced by the new handle, but
    the reference to the `Parameters` object never changes, it is configuration.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParamsAndHandle`: 这个类实际上只是一个数据元组，它包含对`Parameters`对象的引用以及一个进程句柄。当一个进程死亡并被重新启动时，进程句柄将被新的句柄替换，但`Parameters`对象的引用永远不会改变，它是配置。'
- en: '`ControlDaemon`: This class implements the interface `Runnable` and is started
    as a separate thread.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlDaemon`: 这个类实现了`Runnable`接口，并作为一个独立的线程启动。'
- en: In the code we will use most of the process API we discussed in the previous
    sections, *Terminating processes* and we will use a lot of threading code and
    stream operations. Understanding the threading work of the JVM is important independent
    of the process management also. It has, however emphasized importance when used
    together with the process API.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们将使用我们在上一节中讨论的大多数进程API，*终止进程*，并且我们将使用大量的线程代码和流操作。理解JVM的线程工作对于进程管理来说也很重要。然而，当与进程API一起使用时，它的重要性被强调了。
- en: Main class
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主类
- en: 'The main method takes the name of the directory from the command line argument.
    It treats this as relative to the current working directory. It uses a separate
    method from the same class to read the set of configurations from the files in
    the directory and then starts the control daemon. The following code if the `main`
    method of the program:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法从命令行参数中获取目录名称。它将此视为相对于当前工作目录的相对路径。它使用同一类中的另一个单独的方法从目录中的文件中读取配置集，然后启动控制守护进程。以下代码是该程序的`main`方法：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although this is a daemon, we are starting it as a normal thread and not as
    a daemon thread. When a thread is set to be a daemon thread it will not keep the
    JVM alive. When all other non-daemon threads stop, the JVM will just exit and
    the daemon threads will be stopped. In our case, the daemon thread we execute
    is the only one that keeps the code running. After that was started the main thread
    has nothing more to do, but the JVM should stay alive, until it is killed by the
    operator issuing a Unix `kill` command or pressing *Control* + *C* on the command
    line.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个守护进程，但我们是以普通线程而不是守护线程的方式启动它的。当一个线程被设置为守护线程时，它不会保持JVM存活。当所有其他非守护线程停止时，JVM将直接退出，守护线程也将停止。在我们的情况下，我们执行的守护线程是唯一一个保持代码运行的那个。在那之后，主线程就没有其他事情可做了，但JVM应该保持存活，直到被操作员发出的Unix
    `kill`命令或按命令行上的*Control* + *C*键杀死。
- en: 'Getting the list of the files that are in the directory specified and getting
    the parameters from the file is simple using the new `Files` and `Paths` classes
    from the JDK:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的`Files`和`Paths`类从JDK获取指定目录中的文件列表以及从文件中获取参数非常简单：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We get a stream of the files in the form of `Path` objects, map it to `File`
    objects, then we filter out the directories if there are any in the configuration
    directory and map the remaining plain files to `Parameters` objects using the
    static method `fromFile` of the `Parameters` class. Finally, we return a `Set`
    of the objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 `Path` 对象的形式获取文件流，将其映射到 `File` 对象，然后如果配置目录中有目录，则过滤掉它们，并使用 `Parameters` 类的静态方法
    `fromFile` 将剩余的普通文件映射到 `Parameters` 对象。最后，我们返回一个对象集的 `Set`。
- en: Parameters class
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数类
- en: 'Our `Parameters` class has a field and a constructor as listed as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Parameters` 类具有以下字段和构造函数：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The parameter class has two methods. The first method, `getCommandLineStrings`,
    gets the command line strings from the properties. This array contains the command
    and the command line parameters. If it was not defined in the file then we return
    an empty array:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 参数类有两个方法。第一个方法 `getCommandLineStrings` 从属性中获取命令行字符串。这个数组包含命令和命令行参数。如果没有在文件中定义，则返回一个空数组：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second method is the `static fromFile` that reads the properties from a
    properties file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法是 `static fromFile`，它从属性文件中读取属性：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the set of parameters handled by the program is extended then this class
    should also be modified.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序处理的参数集被扩展，那么这个类也应该被修改。
- en: The ParamsAndHandle class
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ParamsAndHandle` 类'
- en: 'The `ParamsAndHandle` is a very simple class that holds two fields. One for
    the parameters and the other is the handle to the process handle that is used
    to access the process started using the parameters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParamsAndHandle` 是一个非常简单的类，它包含两个字段。一个用于参数，另一个是用于访问使用参数启动的进程的进程句柄：'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the class is closely tied to the `ControlDaemon` class from where it is
    used there is no mutator or accessor associated with the field. We see the two
    classes as something inside the same encapsulation boundaries. The `toHandle`
    method is there so that we can use it as a method handle, as we will see in the
    next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该类与使用的 `ControlDaemon` 类紧密相关，因此没有与字段关联的修改器或访问器。我们将这两个类视为同一封装边界内的东西。`toHandle`
    方法存在是为了我们可以将其用作方法句柄，正如我们将在下一章中看到的。
- en: The ControlDaemon class
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ControlDaemon` 类'
- en: 'The `ControlDaemon` class implements the `Runnable` interface and is started
    as a separate thread. The constructor gets the set of the parameters that were
    read from the properties files and converts them to a set of `ParamsAndHandle`
    objects:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`ControlDaemon` 类实现了 `Runnable` 接口，并作为一个单独的线程启动。构造函数获取从属性文件中读取的参数集，并将其转换为 `ParamsAndHandle`
    对象集：'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because the processes are not started at this point, the handles are all `null`.
    The `run()` method starts the processes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为此时进程尚未启动，所以所有的句柄都是 `null`。`run()` 方法启动进程：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Processing goes through the set of parameters and uses the method (implemented
    in this class later) to start the processes. The handles to each process get to
    the `ParamsAndHandle` object. After that, the `keepProcessesAlive` method is called
    and waits for the processes to finish. When a process stops it gets restarted.
    If it cannot be restarted it will be removed from the set.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 处理过程通过参数集进行，并使用（在此类中稍后实现的）方法启动进程。每个进程的句柄都到达 `ParamsAndHandle` 对象。之后，调用 `keepProcessesAlive`
    方法并等待进程完成。当进程停止时，它将被重新启动。如果无法重新启动，它将被从集合中移除。
- en: The `allMyProcesses` method (also implemented in this class) returns a `CompletableFuture`
    that gets completed when all the started processes have stopped. Some of the processes
    may have been restarted by the time the `join()` method returns. As long as there
    is at least one process running, the thread should run.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`allMyProcesses` 方法（也在此类中实现）返回一个 `CompletableFuture`，当所有启动的进程都停止时完成。在 `join()`
    方法返回时，一些进程可能已经被重启。只要至少有一个进程在运行，线程就应该运行。'
- en: 'Using the `CompletableFuture` to wait for the processes and the `while` loop,
    we use minimal CPU to keep the thread alive so long as long there is at least
    one process we manage running, presumably even after a few restarts. We have to
    keep this thread alive even if it does not use CPU and executes no code most of
    the time to let the `keepProcessesAlive()` method do its work using `CompletableFutures`.
    The method is shown in the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CompletableFuture` 等待进程和 `while` 循环，我们使用最少的 CPU 来保持线程存活，只要我们管理的至少有一个进程在运行，即使经过几次重启也是如此。即使这个线程大部分时间不使用
    CPU 且不执行任何代码，我们也必须保持这个线程存活，以便让 `keepProcessesAlive()` 方法使用 `CompletableFutures`
    来完成其工作。以下代码片段展示了该方法：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `keepProcessesAlive()` method calls the `anyOfMyProcesses()` method that
    returns a `CompletableFuture`, which is completed when any of the managed processes
    exits. The method schedules to execute the lambda passed as an argument to the
    `thenAccept()` method for the time the `CompletableFuture` is completed. The lambda
    does two things:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`keepProcessesAlive()`方法调用`anyOfMyProcesses()`方法，该方法返回一个`CompletableFuture`，当任何受管理进程退出时完成。该方法安排在`CompletableFuture`完成时执行传递给`thenAccept()`方法的lambda表达式。lambda执行两件事：'
- en: Restarts the processes that are stopped (probably only one)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动已停止的进程（可能只有一个）
- en: Calls the `keepProcessesAlive()` method
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`keepProcessesAlive()`方法
- en: It is important to understand that this call is not performed from within the
    `keepProcessesAlive()` method itself. This is not a recursive call. This is scheduled
    as a `CompletableFuture` action. We are not implementing a loop in a recursive
    call, because we would run out of stack space. We ask the JVM executors to execute
    this method again when the processes are restarted.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解这个调用不是从`keepProcessesAlive()`方法本身执行的。这不是一个递归调用。这被安排为一个`CompletableFuture`操作。我们不是在递归调用中实现循环，因为我们可能会耗尽堆栈空间。当进程重新启动时，我们要求JVM执行器再次执行此方法。
- en: It is important to know that the JVM uses the default `ForkJoinPool` to schedule
    these tasks and this pool contains daemon threads. That is the reason we have
    to wait and keep the method running because that is the only non-daemon thread
    that prevents the JVM from exiting.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道JVM使用默认的`ForkJoinPool`来调度这些任务，并且此池包含守护线程。这就是我们必须等待并保持方法运行的原因，因为这是唯一非守护线程，它可以防止JVM退出。
- en: 'The next method is `restartProcesses()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是`restartProcesses()`：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method starts the processes that are in our set of managed processes and
    which are not alive. If any of the restarts fail it removes the failing processes
    from the set. (Be aware not to remove it in the loop to avoid `ConcurrentModificationException`.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法启动我们管理进程集中的非活动进程。如果任何重启失败，它会从集中移除失败的进程。（请注意，不要在循环中移除它，以避免`ConcurrentModificationException`。）
- en: 'The `anyOfMyProcesses()` and `allMyProcesses()` methods are using the auxiliary
    `completableFuturesOfTheProcessesand()` method and are straight forward:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`anyOfMyProcesses()`和`allMyProcesses()`方法使用辅助方法`completableFuturesOfTheProcessesand()`，并且很简单：'
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `completableFuturesOfTheProcesses()` method returns an array of `CompletableFutures`
    created from the currently running managed processes calling their `onExit()`
    method. This is done in a compact and easy to read functional programming style,
    as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`completableFuturesOfTheProcesses()`方法返回一个由当前运行的受管理进程调用其`onExit()`方法创建的`CompletableFutures`数组。这是以紧凑且易于阅读的函数式编程风格完成的，如下所示：'
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The set is converted to a `stream`, mapped to a `stream` of `ProcessHandle`
    objects (this is why we needed the `toHandle()` method in the `ParamsAndHandle`
    class). Then the handles are mapped to `CompletableFuture` stream using the `onExit()`
    method and finally we collect it to a list and convert to an array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 集合被转换为`stream`，映射为`ProcessHandle`对象的`stream`（这就是为什么在`ParamsAndHandle`类中需要`toHandle()`方法的原因）。然后，使用`onExit()`方法将这些句柄映射到`CompletableFuture`流，最后我们将它收集到一个列表中并转换为数组。
- en: 'Our last method to complete our sample application is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的示例应用程序的最后一个方法是以下内容：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method starts the process using a `ProcessBuilder` and returns the `ProcessHandle`
    so that we can replace the old one in our set and manage the new process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`ProcessBuilder`启动进程，并返回`ProcessHandle`，以便我们可以用我们的集合中的旧进程替换它并管理新进程。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we discussed how Java 9 better enables us to manage processes.
    Prior to Java 9, process management from within Java required OS specific implementations
    and was less than optimal in terms of CPU use and coding practice. The modern
    API, with new classes like `ProcessHandle,` makes it possible to handle almost
    all aspects of processes. We listed the new API, and had simple example codes
    for the use of each of them. In the second half of the chapter we put together
    a whole application managing processes where the learned API was put into practice.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Java 9如何更好地使我们能够管理进程。在Java 9之前，从Java内部进行进程管理需要特定于操作系统的实现，并且在CPU使用和编码实践方面并不理想。现代API，如`ProcessHandle`等新类，使得处理几乎所有的进程方面成为可能。我们列出了新的API，并为每个API提供了简单的示例代码。在章节的后半部分，我们组合了一个整个应用程序来管理进程，其中所学的API得到了实际应用。
- en: In the next chapter, we will take a detailed look at the new Java Stack Walking
    API released with Java 9\. We will use code samples to illustrate how to use the
    API.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨与Java 9一同发布的Java Stack Walking API。我们将通过代码示例来说明如何使用该API。
