- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: This appendix will walk you through lambda expressions, functional types, mixing
    object-oriented and reactive programming, and how schedulers work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录将带你了解 lambda 表达式、函数式类型、面向对象和响应式编程的混合以及调度器的工作原理。
- en: Introducing lambda expressions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 lambda 表达式
- en: Java officially supported lambda expressions when Java 8 was released in 2014\.
    *Lambda expressions* are shorthand implementations for **single abstract method**
    (**SAM**) classes. In other words, they are quick ways to pass functional arguments
    instead of anonymous classes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在 2014 年发布的 Java 8 中正式支持 lambda 表达式。*Lambda 表达式* 是 **单抽象方法** (**SAM**)
    类的简写实现。换句话说，它们是传递函数式参数而不是匿名类的快捷方式。
- en: Making a Runnable a lambda
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Runnable 转换为 lambda
- en: 'Prior to Java 8, you might have leveraged anonymous classes to implement interfaces,
    such as `Runnable`, on the fly as shown in the following code snippet:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 之前，你可能已经利用匿名类即时实现接口，例如 `Runnable`，如下所示：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To implement `Runnable` without declaring an explicit class, you had to implement
    its `run()` abstract method in a block immediately after the constructor. This
    created a lot of boilerplate and became a major pain point with Java development,
    and was a barrier to using Java for functional programming. Thankfully, Java 8
    officially brought lambdas to the Java language. With lambda expressions, you
    can express this in a much more concise way:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `Runnable` 而不声明一个显式的类，你必须立即在构造函数之后在一个块中实现其 `run()` 抽象方法。这产生了大量的样板代码，并成为
    Java 开发的一个主要痛点，也是使用 Java 进行函数式编程的障碍。幸运的是，Java 8 正式将 lambda 引入到 Java 语言中。有了 lambda
    表达式，你可以用更简洁的方式表达这一点：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Awesome, right? That is a lot less code and boilerplate noise, and we will dive
    into how this works. Lambda expressions can target any interface or abstract class
    with one abstract method, which is called *single abstract method* types. In the
    preceding code, the `Runnable` interface has a single abstract method called `run()`.
    If you pass a lambda that matches the arguments and return type for that abstract
    method, the compiler will use that lambda for the implementation of that method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，对吧？这减少了大量的代码和样板，我们将深入探讨它是如何工作的。Lambda 表达式可以针对任何只有一个抽象方法的接口或抽象类，这些类型被称为 *单抽象方法*
    类型。在上面的代码中，`Runnable` 接口有一个名为 `run()` 的单抽象方法。如果你传递一个与该抽象方法的参数和返回类型匹配的 lambda，编译器将使用该
    lambda 来实现该方法。
- en: Everything to the left of the `->` arrow is an argument. The `run()` method
    of `Runnable` does not take any arguments, so the lambda provides no arguments
    with the empty parenthesis `()`. The right side of the arrow `->` is the action
    to be executed. In this example, we are calling a single statement and printing
    a simple message with `System.out.println("run() was called!");`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`->` 箭头左侧是参数。`Runnable` 的 `run()` 方法不接收任何参数，因此 lambda 使用空括号 `()` 提供没有参数。箭头
    `->` 的右侧是要执行的操作。在这个例子中，我们调用一个单条语句并使用 `System.out.println("run() was called!");`
    打印一个简单的消息。'
- en: 'Java 8 lambdas can support multiple statements in the body. Say we have this
    `Runnable` anonymous inner class with multiple statements in its `run()` implementation,
    as shown in the following code snippet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 的 lambda 表达式可以在主体中支持多个语句。比如说，我们有一个包含多个语句的 `Runnable` 匿名内部类，其 `run()`
    方法的实现如以下代码片段所示：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can move both `System.out.println()` statements to a lambda by wrapping
    them in a multiline `{ }` block to the right of the arrow `->`. Note that you
    need to use semicolons to terminate each line within the lambda, shown in the
    following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将两个 `System.out.println()` 语句移动到 lambda 中，通过在箭头 `->` 右侧的 `{ }` 多行块中包裹它们。请注意，你需要在
    lambda 中的每一行使用分号来终止，如下所示：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Making a Supplier a lambda
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Supplier 转换为 lambda
- en: 'Lambdas can also implement methods that return items. For instance, the `Supplier`
    class introduced in Java 8 (and originally introduced in Google Guava) has an
    abstract `get()` method that returns a `T` item for a given `Supplier<T>`. If
    we have a `Supplier<List<String>>` whose `get()` returns `List<String>`, we can
    implement it using an old-fashioned anonymous class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式还可以实现返回项的方法。例如，Java 8 中引入的 `Supplier` 类（最初由 Google Guava 引入）有一个抽象的
    `get()` 方法，它为给定的 `Supplier<T>` 返回一个 `T` 项。如果我们有一个 `Supplier<List<String>>`，其 `get()`
    返回 `List<String>`，我们可以使用传统的匿名类来实现它：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But we can also use a lambda, which can implement `get()` much more succinctly
    and yield `List<String>`, shown as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用 lambda，它可以更简洁地实现 `get()` 并返回 `List<String>`，如下所示：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When your lambda is simplify invoking a constructor on a type using the `new`
    keyword, you can use a double colon `::` lambda syntax to invoke the constructor
    on that class. This way, you can leave out the symbols `()` and `->`, shown as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 lambda 简单地使用 `new` 关键字在类型上调用构造函数时，你可以使用双冒号 `::` lambda 语法来调用该类上的构造函数。这样，你可以省略
    `()` 和 `->` 符号，如下所示：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: RxJava does not have Java 8's Supplier but rather a Callable, which accomplishes
    the same purpose.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 没有Java 8的 Supplier，而是有一个 Callable，它实现了相同的目的。
- en: Making a Consumer a lambda
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Consumer 实现为 lambda
- en: '`Consumer<T>` accepts a `T` argument and performs an action with it but does
    not return any value. Using an anonymous class, we can create a `Consumer<String>`
    that simply prints the string as shown in the following code snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer<T>` 接受一个 `T` 参数并使用它执行一个操作，但不返回任何值。使用匿名类，我们可以创建一个 `Consumer<String>`，它简单地打印字符串，如下面的代码片段所示：'
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can implement this as a lambda. We can choose to call the `String` parameter
    `s` on the left-hand side of the lambda arrow `->` and print it on the right-hand
    side:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其实现为一个 lambda。我们可以在 lambda 箭头 `->` 的左侧选择调用 `String` 参数 `s`，然后在右侧打印它：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The compiler can actually infer that `s` is a `String` type based on the `Consumer<String>`
    you are targeting. So you can leave that explicit type declaration out, as shown
    in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器实际上可以根据你正在针对的 `Consumer<String>` 推断出 `s` 是一个 `String` 类型。因此，你可以省略那个显式的类型声明，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For a simple single method invocation, you can actually use another syntax
    to declare the lambda using a double colon `::`. Declare the type you are targeting
    on the left-hand side of the double-colon and invoke its method on the right-hand
    side of the double colon. The compiler will be smart enough to figure out you
    are trying to pass the `String` argument to `System.out::println`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的单方法调用，实际上你可以使用另一种语法来使用双冒号 `::` 声明 lambda。在双冒号的左侧声明你正在针对的类型，然后在双冒号的右侧调用其方法。编译器足够智能，可以推断出你试图将
    `String` 参数传递给 `System.out::println`：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Making a Function a lambda
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Function 实现为 lambda
- en: 'Lambdas can also implement single abstract methods that accept arguments and
    return an item. For instance, RxJava 2.0 (as well as Java 8) has a `Function<T,R>`
    type that accepts a `T` type and returns an `R` type. For instance, you can declare
    a `Function<String,Integer>`, whose `apply()` method will accept a `String`  and
    return an `Integer`. Here, we implement `apply()` by returning the string''s length
    in an anonymous class, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 也可以实现接受参数并返回项的单个抽象方法。例如，RxJava 2.0（以及 Java 8）有一个 `Function<T,R>` 类型，它接受
    `T` 类型并返回 `R` 类型。例如，你可以声明一个 `Function<String,Integer>`，其 `apply()` 方法将接受一个 `String`
    并返回一个 `Integer`。在这里，我们通过在匿名类中返回字符串的长度来实现 `apply()`，如下所示：
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can make this even more concise by implementing `Function<String,Integer>`
    with a lambda, as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 lambda 来使这个实现更加简洁，如下所示：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have a couple of syntaxes we can alternatively use to implement `Function<String,Integer>`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个可选的语法可以用来实现 `Function<String,Integer>`。
- en: 'Java 8''s compiler is smart enough to see that our parameter `s` is a `String`
    based on the `Function<String,Integer>` type we are assigning it to. Therefore,
    we do not need to explicitly declare `s` as a `String` because it can infer it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 的编译器足够智能，可以根据我们分配给它的 `Function<String,Integer>` 类型推断出我们的参数 `s` 是一个 `String`
    类型。因此，我们不需要显式声明 `s` 为 `String` 类型，因为它可以推断出来：
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We do not need to wrap our `s` in parentheses `(s)` either, as those are not
    needed for a single argument (but are needed for multiple arguments, as we will
    see later):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不需要将 `s` 括在括号 `(s)` 中，因为对于单个参数来说，这些括号不是必需的（但如我们稍后看到的，对于多个参数来说，这些括号是必需的）：
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we are simply calling a method or property on the incoming item, we can
    use the double colon `::` syntax to call the method on that type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是在传入的项目上调用方法或属性，我们可以使用双冒号 `::` 语法来调用该类型上的方法：
- en: '[PRE17]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Function<T,R>` is heavily used in RxJava as `Observable` operators often to
    transform emissions. The most common example is the `map()` operator, which turns
    each `T` emission into an `R` emission and derives an `Observable<R>` from an `Observable<T>`.:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T,R>` 在 RxJava 中被广泛用作 `Observable` 操作符，通常用于转换发射的数据。最常用的例子是 `map()`
    操作符，它将每个 `T` 发射转换为 `R` 发射，并从 `Observable<T>` 导出 `Observable<R>`：'
- en: '[PRE18]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that there are other flavors of `Function`, such as `Predicate` and `BiFunction`,  which
     accept two arguments, not one. The `reduce()` operator accepts a `BiFunction<T,T,T>`
    where the first `T` argument is the rolling aggregation, the second `T` is the
    next item to put into the aggregation, and the third `T` is the result of merging
    the two. In this case, we use `reduce()` to add all the items using a rolling
    total:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有其他 `Function` 的变体，例如 `Predicate` 和 `BiFunction`，它们接受两个参数，而不是一个。`reduce()`
    操作符接受一个 `BiFunction<T,T,T>`，其中第一个 `T` 参数是滚动聚合，第二个 `T` 是要放入聚合中的下一个项，第三个 `T` 是合并两个的结果。在这种情况下，我们使用
    `reduce()` 来通过滚动总数添加所有项：
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Functional types
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能类型
- en: Here are all the functional types available in RxJava 2.0 at the time of writing
    this, and you can find them in the `io.reactivex.functions` package. You may recognize
    many of these functional types as being almost identical to those in Java 8 (in `java.util.function`)
    or Google Guava. However, they were somewhat copied in RxJava 2.0 to make them
    available for use in Java 6 and 7\. A subtle difference is that RxJava's implementations
    throw checked exceptions. This eliminates a pain point from RxJava 1.0 where checked
    exceptions had to be handled in lambdas that yielded them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，以下是 RxJava 2.0 中所有可用的功能类型，您可以在 `io.reactivex.functions` 包中找到它们。您可能会认出其中许多功能类型几乎与
    Java 8（在 `java.util.function` 中）或 Google Guava 中的类型相同。然而，它们在 RxJava 2.0 中被部分复制，以便在
    Java 6 和 7 中使用。一个细微的区别是 RxJava 的实现会抛出检查异常。这消除了 RxJava 1.0 中的一个痛点，即检查异常必须在返回它们的
    lambda 表达式中处理。
- en: 'The RxJava 1.0 equivalents are listed as well, but note that the single abstract
    method (SAM) column corresponds to the RxJava 2.0 type. RxJava 1.0 functions implement
    `call()` and do not support primitives. RxJava 2.0 implemented a few functional
    types with primitives to reduce boxing overhead where reasonably possible:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了 RxJava 1.0 的等效项，但请注意，单抽象方法（SAM）列对应于 RxJava 2.0 类型。RxJava 1.0 函数实现 `call()`
    并不支持原始类型。RxJava 2.0 实现了一些带有原始类型的功能类型，以尽可能减少装箱开销：
- en: '| **RxJava 2.0** | **RxJava 1.0** | **SAM** | **Description** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **RxJava 2.0** | **RxJava 1.0** | **SAM** | **描述** |'
- en: '| `Action` | `Action0` | `run()` | Executes an action, much like `Runnable`
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Action` | `Action0` | `run()` | 执行操作，类似于 `Runnable` |'
- en: '| `Callable<T>` | `Func0<T>` | `get()` | Returns a single item of type `T`
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Callable<T>` | `Func0<T>` | `get()` | 返回单个类型为 `T` 的项 |'
- en: '| `Consumer<T>` | `Action1<T>` | `accept()` | Performs an action on a given
    `T` item but returns nothing |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Consumer<T>` | `Action1<T>` | `accept()` | 在给定的 `T` 项上执行操作，但不返回任何内容 |'
- en: '| `Function<T,R>` | `Func1<T,R>` | `apply()` | Accepts a type `T` and returns
    a type `R` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Function<T,R>` | `Func1<T,R>` | `apply()` | 接受类型 `T` 并返回类型 `R` |'
- en: '| `Predicate<T>` | `Func1<T,Boolean>` | `test()` | Accepts a `T` item and returns
    a primitive `boolean` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Predicate<T>` | `Func1<T,Boolean>` | `test()` | 接受 `T` 项并返回原始 `boolean`
    |'
- en: '| `BiConsumer<T1,T2>` | `Action2<T1,T2>` | `accept()` | Performs an action
    on a `T1` and `T2` item but returns nothing |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `BiConsumer<T1,T2>` | `Action2<T1,T2>` | `accept()` | 在 `T1` 和 `T2` 项上执行操作，但不返回任何内容
    |'
- en: '| `BiFunction<T1,T2,R>` | `Func2<T1,T2,R>` | `apply()` | Accepts a `T1` and
    `T2` and returns a type `R` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `BiFunction<T1,T2,R>` | `Func2<T1,T2,R>` | `apply()` | 接受 `T1` 和 `T2` 并返回类型
    `R` |'
- en: '| `BiPredicate<T1,T2>` | `Func2<T1,T2,Boolean>` | `test()` | Accepts a `T1`
    and `T2` and returns a primitive `boolean` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `BiPredicate<T1,T2>` | `Func2<T1,T2,Boolean>` | `test()` | 接受 `T1` 和 `T2`
    并返回原始 `boolean` |'
- en: '| `Function3<T1,T2,T3,R>` | `Func3<T1,T2,T3,R>` | `apply()` | Accepts three
    arguments and returns an `R` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Function3<T1,T2,T3,R>` | `Func3<T1,T2,T3,R>` | `apply()` | 接受三个参数并返回 `R`
    |'
- en: '| `BooleanSupplier` | `Func0<Boolean>` | `getAsBoolean()` | Returns a single
    primitive `boolean` value |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `BooleanSupplier` | `Func0<Boolean>` | `getAsBoolean()` | 返回单个原始 `boolean`
    值 |'
- en: '| `LongConsumer` | `Action1<Long>` | `accept()` | Performs an action on a given
    `Long` but returns nothing |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `LongConsumer` | `Action1<Long>` | `accept()` | 在给定的 `Long` 上执行操作，但不返回任何内容
    |'
- en: '| `IntFunction` | `Func1<T>` | `apply()` | Accepts a primitive `int` and returns
    an item of type `T` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `IntFunction` | `Func1<T>` | `apply()` | 接受原始 `int` 并返回类型为 `T` 的项 |'
- en: Not every primitive equivalent for a functional type has been implemented in
    RxJava 2.0\. For example, currently, there is no `IntSupplier` like there is in
    Java 8's standard library. This is because RxJava 2.0 does not need it to implement
    any of its operators.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 2.0 中，并非所有功能类型的原始等效项都已实现。例如，目前还没有像 Java 8 标准库中那样的 `IntSupplier`。这是因为
    RxJava 2.0 不需要它来实现其任何操作符。
- en: Mixing object-oriented and reactive programming
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合面向对象和响应式编程
- en: As you start applying your RxJava knowledge to real-world problems, something
    that may not immediately be clear is how to mix it with object-oriented programming.
    Leveraging multiple paradigms such as object-oriented and functional programming
    is becoming increasingly common. Reactive programming and object-oriented programming,
    especially in a Java environment, can definitely work together for the greater
    good.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始将 RxJava 知识应用于现实世界的问题时，可能不会立即清楚的是如何将其与面向对象编程相结合。利用面向对象和函数式编程等多个范式正变得越来越普遍。在
    Java 环境中，响应式编程和面向对象编程肯定可以为了更大的利益而协同工作。
- en: 'Obviously, you can emit any type `T` from an `Observable` or any of the other
    reactive types. Emitting objects built off your own classes is one way object-oriented
    and reactive programming work together. We have seen a number of examples in this
    book. For instance, Java 8''s `LocalDate` is a complex object-oriented type, but
    you can push it through an `Observable<LocalDate>`, as shown in the following
    code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以从 `Observable` 或其他响应式类型中发射任何类型 `T`。发射基于你自己的类构建的对象是面向对象和响应式编程协同工作的一种方式。我们在本书中看到了许多例子。例如，Java
    8 的 `LocalDate` 是一个复杂的面向对象类型，但你可以将它通过一个 `Observable<LocalDate>` 推送，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we have seen in several examples throughout the book, a number of RxJava
    operators provide adapters to take a stateful, object-oriented item and turn it
    into a reactive stream. For instance, there is the `generate()` factory for `Flowable`
    and `Observable` to build a series of emissions off a mutable object that is updated
    incrementally. In the following code, we emit an infinite, consecutive sequence
    of Java 8 LocalDates but take only the first 60 emissions. Since `LocalDate` is
    immutable, we wrap the seed `LocalDate` of `2017-1-1` in an `AtomicReference`
    so it can be mutably replaced with each increment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中的几个例子中所看到的，许多 RxJava 操作符提供了适配器，可以将有状态的、面向对象的项目转换为响应式流。例如，有 `generate()`
    工厂用于 `Flowable` 和 `Observable`，可以从一个可变对象构建一系列发射，该对象是逐步更新的。在下面的代码中，我们发射了一个无限连续的
    Java 8 `LocalDate` 序列，但只取前 60 个发射。由于 `LocalDate` 是不可变的，我们将 `2017-1-1` 的种子 `LocalDate`
    包裹在一个 `AtomicReference` 中，以便它可以被可变地替换为每次增量：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So again, RxJava has many factories and tools to adapt your object-oriented,
    imperative operations and make them reactive. Many of them are covered throughout
    this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RxJava 有许多工厂和工具来适应你的面向对象、命令式操作，并将它们变为响应式。其中许多在本书中都有涉及。
- en: But are there cases for a class to return an `Observable`, `Flowable`, `Single`,
    or `Maybe` from a property or method? Certainly! When your object has properties
    or methods whose results are dynamic and change over time and represent an event(s)
    or a sizable sequence of data, they are candidates to be returned as a reactive
    type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，是否存在一个类从属性或方法返回 `Observable`、`Flowable`、`Single` 或 `Maybe` 的情况？当然有！当你的对象具有结果动态且随时间变化，并代表事件或大量数据序列的属性或方法时，它们是作为响应式类型返回的候选者。
- en: 'Here is an abstract example: say, you have a `DroneBot` type that represents
    a flying drone. You could have a property called `getLocation()` that returns
    an `Observable<Point>` instead of `Point`. This way, you can get a live feed that
    pushes a new `Point` emission every time the drone''s location changes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个抽象的例子：比如说，你有一个表示飞行无人机的 `DroneBot` 类型。你可以有一个名为 `getLocation()` 的属性，它返回一个
    `Observable<Point>` 而不是 `Point`。这样，你就可以获得一个实时流，每次无人机位置改变时都会推送一个新的 `Point` 发射：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This `DroneBot` example shows another way in which you can mix object-oriented
    and reactive programming effectively. You can easily get a live feed of that drone''s
    movements by returning an `Observable`. There are many use cases for this pattern:
    stock feeds, vehicle locations, weather station feeds, social networks, and so
    on. However, be careful if the properties are infinite. If you wanted to manage
    the location feeds of 100 drones, flat mapping all their infinite location feeds
    together into a single stream is likely not going to produce anything meaningful,
    apart from a noisy sequence of locations with no context. You will likely subscribe
    to each one separately, in a UI that populates a `Location` field in a table displaying
    all the drones, or you will use `Observable.combineLatest()` to emit a snapshot
    of the latest locations for all drones. The latter can be helpful in displaying
    points on a geographic map live.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`DroneBot`示例展示了另一种有效混合面向对象和反应式编程的方式。你可以通过返回一个`Observable`来轻松获取该无人机的实时运动数据。这种模式有众多用例：股票行情、车辆位置、气象站数据、社交网络等等。然而，如果属性是无限的，就要小心了。如果你想要管理100个无人机的位置数据流，将它们所有的无限位置数据流扁平映射到一个单独的流中可能不会产生任何有意义的输出，除了一个没有上下文的位置噪声序列。你可能会分别订阅每一个，在一个UI中填充一个显示所有无人机的`Location`字段的表格，或者使用`Observable.combineLatest()`来发出所有无人机的最新位置快照。后者在实时显示地理地图上的点时可能很有帮助。
- en: 'Having reactive class properties is useful when they are finite as well. Say
    you have a list of warehouses, and you want to count the total inventory across
    all of them. Each `Warehouse` contains an `Observable<ProductStock>`, which returns
    a finite sequence of the product stocks currently available. The `getQuantity()`
    operator of `ProductStock` returns the quantity of that product available. We
    can use `reduce()` on the `getQuantity()` values to get a sum of all the available
    inventory, as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当类属性有限时，拥有反应式类属性也是有用的。比如说，你有一份仓库列表，并且想要计算所有仓库的总库存。每个`Warehouse`对象包含一个`Observable<ProductStock>`，它返回当前可用的产品库存的有限序列。`ProductStock`的`getQuantity()`方法返回该产品的可用数量。我们可以对`getQuantity()`值使用`reduce()`操作来获取所有可用库存的总和，如下所示：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, finite Observables like the ones returned from `getProducts()` on `Warehouse`
    can be helpful too and are especially helpful for analytical tasks. But note that
    this particular business case decided that `getProducts()` would return the products
    available at that moment, not an infinite feed that broadcasts the inventory every
    time it changes. This was a design decision, and sometimes, representing snapshot
    data in a cold manner is better than a hot infinite feed. An infinite feed would
    have required `Observable<List<ProductStock>>` (or `Observable<Observable<ProductStock>>`)
    to be returned so logical snapshots are emitted. You can always add a separate
    `Observable` that emits notifications of changes and then uses `flatMap()` on
    your `getProducts()` to create a hot feed of inventory changes. This way, you
    create basic building blocks in your code model and then compose them together
    reactively to accomplish more complex tasks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像从`Warehouse`的`getProducts()`返回的有限`Observable`也有帮助，并且对于分析任务尤其有帮助。但请注意，这个特定的业务案例决定`getProducts()`将返回当时可用的产品，而不是每次库存变化时都广播库存的无限数据流。这是一个设计决策，有时，以冷数据的方式表示快照数据比热无限数据流更好。无限数据流将需要返回`Observable<List<ProductStock>>`（或`Observable<Observable<ProductStock>>`）以发出逻辑快照。你总是可以添加一个单独的`Observable`来发出更改通知，然后使用`flatMap()`在你的`getProducts()`上创建库存更改的热流。这样，你就在代码模型中创建了基本构建块，然后通过反应式地组合它们来完成更复杂的任务。
- en: 'Note that you can have methods that return reactive types accept arguments.
    This is a powerful way to create an `Observable` or `Flowable` catered to a specific
    task. For instance, we could add a `getProductsOnDate()` method to our `warehouse`
    that returns an `Observable` emitting product stock from a given date, as shown
    in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以有返回反应式类型的方法并接受参数。这是一种创建针对特定任务定制的`Observable`或`Flowable`的强大方式。例如，我们可以在`warehouse`中添加一个`getProductsOnDate()`方法，该方法返回从给定日期发出的产品库存的`Observable`，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In summary, mixing reactive and object-oriented programming is not only beneficial,
    but also necessary. When you design your domain classes, think carefully what
    properties and methods should be made reactive and whether they should be cold,
    hot, and/or infinite. Imagine how you will be using your class and whether your
    candidate design will be easy or difficult to work with. Be sure to not make every
    property and method reactive for the sake of being reactive either. Only make
    it reactive when there is usability or performance benefit. For example, you should
    not make a `getId()` property for your domain type reactive. This ID on that class
    instance is unlikely to change, and it is just a single value, not a sequence
    of values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，混合响应式和面向对象编程不仅有益，而且是必要的。在设计领域类时，仔细考虑哪些属性和方法应该做成响应式的，以及它们应该是冷、热和/或无限。想象一下你将如何使用你的类，以及你的候选设计是否容易或难以操作。确保不要为了响应式而将每个属性和方法都做成响应式的。只有当有可用性或性能优势时才将其做成响应式的。例如，你不应该将领域类型的
    `getId()` 属性做成响应式的。这个类实例上的 ID 很可能不会改变，它只是一个单一值，不是一个值序列。
- en: Materializing and Dematerializing
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物质化和去物质化
- en: Two interesting operators we did not cover are `materialize()` and `dematerialize()`.
    We did not cover them in [Chapter 3](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml), *Basic
    Operators*, with all the other operators because it might have been confusing
    at that point in your learning curve. But hopefully, the point at which you are
    reading this, you understand the `onNext()`, `onComplete()`, and `onError()` events
    well enough to use an operator that abstractly packages them in a different way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有涵盖的两个有趣的操作符是 `materialize()` 和 `dematerialize()`。我们没有在 [第 3 章](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml)，“基本操作符”，中涵盖它们，因为那时在学习曲线上可能会造成混淆。但希望你在阅读这段内容时，已经足够了解
    `onNext()`、`onComplete()` 和 `onError()` 事件，足以使用一个以不同方式抽象封装它们的操作符。
- en: 'The `materialize()` operator will take these three events, `onNext()`, `onComplete()`,
    and `onError()`, and turn all of them into emissions wrapped in a `Notification<T>`.
    So if your source emits five emissions, you will get six emissions where the last
    one will be `onComplete()` or `onError()`. In the following code, we materialize
    an `Observable` emitting five strings, which are turned into six `Notification`
    emissions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`materialize()` 操作符将这三个事件，`onNext()`、`onComplete()` 和 `onError()`，将它们全部转换为包装在
    `Notification<T>` 中的发射项。所以如果您的源发出五个发射项，您将得到六个发射项，其中最后一个将是 `onComplete()` 或 `onError()`。在下面的代码中，我们使用五个字符串的
    `Observable` 进行 materialize，这些字符串被转换成六个 `Notification` 发射项：'
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Each `Notification` has three methods, `isOnNext()`, `isOnComplete()`, and
    `isOnError()`, to determine what type of event `Notification` is. There is also
    `getValue()`, which will return the emission value for `onNext()` but will be
    null for `onComplete()` or `onError()`. We leverage these methods on `Notification`,
    as shown in the following code, to filter out the three events to three separate
    Observers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Notification` 有三个方法，`isOnNext()`、`isOnComplete()` 和 `isOnError()`，用于确定 `Notification`
    是哪种类型的事件。还有一个 `getValue()` 方法，它将为 `onNext()` 返回发射值，但对于 `onComplete()` 或 `onError()`
    将返回 null。我们利用 `Notification` 上的这些方法，如下面的代码所示，来过滤出三个事件到三个不同的观察者：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also use `dematerialize()` to turn an `Observable` or `Flowable` emitting
    notifications back into a normal `Observable` or `Flowable`. It will produce an
    error if any emissions are not `Notification`. Unfortunately, at compile time,
    Java cannot enforce operators being applied to Observables/Flowables emitting
    specific types such as Kotlin:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `dematerialize()` 将发出通知的 `Observable` 或 `Flowable` 转换回正常的 `Observable`
    或 `Flowable`。如果任何发射项不是 `Notification`，它将产生错误。不幸的是，在编译时，Java 无法强制执行应用于发出特定类型（如
    Kotlin）的 Observables/Flowables 的操作符：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So what exactly would you use `materialize()` and `dematerialize()` for? You
    may not use them often, which is another reason why they are covered here in the
    appendix. But they can be handy in composing more complex operators with transformers and
    stretching transformers to do more without creating low-level operators from scratch.
    For instance, RxJava2-Extras uses `materialize()` for a number of its operators,
    including `collectWhile()`. By treating `onComplete()` an emission itself, `collectWhile()`
    can map it to push the collection buffer downstream and start the next buffer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你到底会用 `materialize()` 和 `dematerialize()` 做什么呢？你可能不会经常使用它们，这也是为什么它们被放在附录中的另一个原因。但它们在组合更复杂的操作符和扩展转换器以执行更多操作而不从头创建低级操作符时非常有用。例如，RxJava2-Extras
    使用 `materialize()` 来实现其操作符中的许多操作，包括 `collectWhile()`。通过将 `onComplete()` 视为一个发射事件，`collectWhile()`
    可以将其映射到推动收集缓冲区到下游并开始下一个缓冲区。
- en: Otherwise, you will likely not use it often. But it is good to be aware that
    it exists if you need it to build more complex transformers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可能不会经常使用它。但如果你需要用它来构建更复杂的转换器，了解它的存在是好的。
- en: Understanding Schedulers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解调度器
- en: You will likely not use schedulers like this in isolation as we are about to
    do in this section. You are more likely to use them with `observeOn()` and `subscribeOn()`.
    But here is how they work in isolation outside of an Rx context.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会单独使用这样的调度器，就像我们即将在本节中做的那样。你更有可能使用 `observeOn()` 和 `subscribeOn()`。但这里是如何在
    Rx 上下文之外独立工作的。
- en: 'A Scheduler is RxJava''s abstraction for pooling threads and scheduling tasks
    to be executed by them. These tasks may be executed immediately, delayed, or repeated
    periodically depending on which of its execution methods are called. These execution
    methods are `scheduleDirect()` and `schedulePeriodicallyDirect()`, which have
    a few overloads. Below, we use the computation Scheduler to execute an immediate
    task, a delayed task, and a repeated task as shown below:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器是 RxJava 对线程池和调度任务以由它们执行的概念抽象。这些任务可能根据其调用的执行方法立即执行、延迟执行或周期性重复执行。这些执行方法是 `scheduleDirect()`
    和 `schedulePeriodicallyDirect()`，它们有几个重载。下面，我们使用计算调度器来执行一个立即任务、一个延迟任务和一个重复任务，如下所示：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Your output will likely be the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出可能如下所示：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `scheduleDirect()` will only execute a one-time task, and accepts optional
    overloads to specify a time delay. `schedulePeriodicallyDirect()` will repeat
    infinitely. Interestingly, all of these methods return a `Disposable` to allow
    cancellation of the task it is executing or waiting to execute.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`scheduleDirect()` 将只执行一次任务，并接受可选的重载来指定时间延迟。`schedulePeriodicallyDirect()`
    将无限重复。有趣的是，所有这些方法都返回一个 `Disposable`，以便取消正在执行或等待执行的任务。'
- en: 'These three methods will automatically pass tasks to a `Worker`, which is an
    abstraction that wraps around a single thread that sequentially does work given
    to it. You can actually call the Scheduler''s `createWorker()` method to explicitly
    get a Worker and delegate tasks to it directly. Its `schedule()` and `schedulePeriodically()`
    methods operate just like Scheduler''s `scheduleDirect()` and `schedulePeriodicallyDirect()`
    respectively (and also return disposables), but they are executed by the specified
    worker. When you are done with a worker, you should dispose it so it can be discarded
    or returned to the `Scheduler`. Here is an equivalent of our earlier example using
    a `Worker`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法会自动将任务传递给一个 `Worker`，这是一个抽象，它围绕一个单线程进行工作，该线程按顺序执行分配给它的任务。你实际上可以调用调度器的 `createWorker()`
    方法来显式获取一个 Worker 并直接将任务委托给它。它的 `schedule()` 和 `schedulePeriodically()` 方法与调度器的
    `scheduleDirect()` 和 `schedulePeriodicallyDirect()` 方法操作类似（并且也返回可取消的），但它们是由指定的
    Worker 执行的。当你完成一个 Worker 时，你应该取消它，以便它可以被丢弃或返回到 `Scheduler`。以下是我们之前示例使用 `Worker`
    的等效示例：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the output you may get:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到以下输出：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Of course, every Scheduler is implemented differently . A Scheduler may use
    one thread or several threads. It may cache and reuse threads, or not reuse them
    at all. It may use an Android thread or a JavaFX thread (as we have seen with
    RxAndroid and RxJavaFX in this book). But that is essentially how schedulers work,
    and you can perhaps see why they are useful in implemeting RxJava operators.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每个调度器的实现方式都不同。一个调度器可能使用一个线程或多个线程。它可能缓存和重用线程，也可能完全不重用它们。它可能使用 Android 线程或
    JavaFX 线程（正如我们在本书中看到的 RxAndroid 和 RxJavaFX）。但这就是调度器的基本工作方式，也许你可以看到为什么它们在实现 RxJava
    操作符时很有用。
