- en: Deploying Our Microservices to Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的微服务部署到Kubernetes
- en: In this chapter, we will deploy the microservices in this book to Kubernetes.
    We will also learn about some of the core features of Kubernetes, such as using
    **Kustomize** to configure deployments for different runtime environments and
    using Kubernetes deployments object for rolling upgrades. Before we do that, we
    need to review how we use service discovery. Since Kubernetes comes with built-in
    support for service discovery, it seems unnecessary to deploy our own since we
    have been using Netflix Eureka up to this point.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把本书中的微服务部署到Kubernetes。我们还将学习Kubernetes的一些核心特性，例如使用**Kustomize**为不同的运行时环境配置部署，以及使用Kubernetes部署对象进行滚动升级。在那之前，我们需要回顾一下我们如何使用服务发现。由于Kubernetes内置了对服务发现的支持，因此似乎没有必要部署我们自己的服务发现，毕竟我们到目前为止一直在使用Netflix
    Eureka。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Replacing Netflix Eureka with Kubernetes `Service` objects and `kube-proxy`
    for service discovery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Kubernetes `Service`对象和`kube-proxy`替换Netflix Eureka进行服务发现
- en: Using Kustomize to prepare the microservices to be deployed in different environments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kustomize准备在不同环境中部署的微服务
- en: Testing the deployments with a version of the test script, `test-em-all.bash`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试脚本的某个版本来测试部署，`test-em-all.bash`
- en: Performing rolling upgrades
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行滚动升级
- en: Learning how to roll back a failed upgrade
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何回滚一个失败的升级
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands that are described in this book are run on a MacBook Pro using
    macOS Mojave but should be straightforward to modify if you want to run them on
    another platform such as Linux or Windows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在一个MacBook Pro上使用macOS Mojave运行的，但如果你想在其他平台（如Linux或Windows）上运行它们，应该很容易进行修改。
- en: 'The only new tool that''s required for this chapter is the `siege` command-line
    tool, which is used for HTTP-based load testing and benchmarking. We will use
    `siege` to put some load on the Kubernetes cluster while performing rolling upgrades.
    The tool can be installed using Homebrew with the following commands:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的一个新工具是`siege`命令行工具，用于基于HTTP的负载测试和基准测试。在我们执行滚动升级时，我们将使用`siege`给Kubernetes集群施加一些负载。该工具可以通过Homebrew使用以下命令安装：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter16](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter16).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter16](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter16)。
- en: 'To be able to run the commands that are described in this book, you need to
    download the source code to a folder and set up an environment variable, `$BOOK_HOME`,
    that points to that folder. Some sample commands are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，你需要将源代码下载到一个文件夹中，并设置一个环境变量，`$BOOK_HOME`，该变量指向该文件夹。一些示例命令如下：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All the source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter16` and have
    been tested using Kubernetes 1.15.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有源代码示例都来自`$BOOK_HOME/Chapter16`的源代码，并且已经使用Kubernetes 1.15进行了测试。
- en: If you want to see the changes that were applied to the source code in this
    chapter, that is, see the changes that are required to be able to deploy the microservices
    on Kubernetes, you can compare it with the source code for [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml),
    *Introduction to Kubernetes*. You can use your favorite `diff` tool and compare
    the two folders, `$BOOK_HOME/Chapter15` and `$BOOK_HOME/Chapter16`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看在本章中应用到源代码的变化，也就是说，查看部署到Kubernetes上的微服务所需的变化，你可以与[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)的*Kubernetes入门*源代码进行对比。你可以使用你喜欢的`diff`工具，比较两个文件夹，`$BOOK_HOME/Chapter15`和`$BOOK_HOME/Chapter16`。
- en: Replacing Netflix Eureka with Kubernetes services
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Kubernetes服务替换Netflix Eureka
- en: As shown in the previous chapter, [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml),
    *Introduction to Kubernetes*, Kubernetes comes with a built-in discovery service
    based on Kubernetes `Service` objects and the `kube-proxy` runtime component.
    This makes it unnecessary to deploy a separate discovery service such as Netflix
    Eureka, which we used in the previous chapters. An advantage of using Kubernetes
    discovery service is that it doesn't require a client library such as Netflix
    Ribbon, which we have been using together with Netflix Eureka. This makes the
    Kubernetes discovery service easy to use, independent of which language or framework
    a microservice is based on. A drawback of using the Kubernetes discovery service
    is that it only works in a Kubernetes environment. However, since the discovery
    service is based on `kube-proxy`, which accepts requests to the DNS name or IP
    address of a service object, it should be fairly simple to replace it with a similar
    discovery service, for example, one that comes bundled with another container
    orchestrator.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前章所示，[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)，*Kubernetes简介*，Kubernetes带有一个基于Kubernetes
    `Service`对象和`kube-proxy`运行时组件的内置发现服务。这使得不需要部署一个单独的发现服务，如我们前几章中使用的Netflix Eureka。使用Kubernetes发现服务的一个优点是，它不需要像我们与Netflix
    Eureka一起使用的Netflix Ribbon这样的客户端库。这使得Kubernetes发现服务易于使用，且与微服务基于哪种语言或框架无关。使用Kubernetes发现服务的缺点是，它只能在Kubernetes环境中运行。然而，由于发现服务基于`kube-proxy`，后者接受对服务对象DNS名称或IP地址的请求，因此应该相当简单地用类似的服务替换它，例如另一个容器编排器的捆绑服务。
- en: 'To summarize this, we will remove the discovery server based on Netflix Eureka
    from our microservice landscape, as illustrated in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将从我们的微服务架构中移除基于Netflix Eureka的发现服务器，如图所示：
- en: '![](img/8b8eed5f-e4b6-4d3a-85a1-e0df126462ee.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b8eed5f-e4b6-4d3a-85a1-e0df126462ee.png)'
- en: 'To replace the discovery server based on Netflix Eureka with the Kubernetes
    built-in discovery service, the following changes have been applied to the source
    code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将基于Netflix Eureka的发现服务器替换为Kubernetes内置的发现服务，已对源代码应用了以下更改：
- en: Netflix Eureka and the Ribbon-specific configuration (client and server) have
    been removed from the configuration repository, `config-repo`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经从配置仓库`config-repo`中移除了Netflix Eureka和Ribbon特定的配置（客户端和服务器）。
- en: Routing rules in the gateway service to the Eureka server have been removed
    from the `config-repo/gateway.yml` file.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关服务中的路由规则已从`config-repo/gateway.yml`文件中移除。
- en: We've removed the Eureka server project, that is, we've removed the `spring-cloud/eureka-server` folder.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经移除了Eureka服务器项目，即移除了`spring-cloud/eureka-server`文件夹。
- en: We've removed the Eureka server from the Docker Compose files and the `settings.gradle` Gradle
    file.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经从Docker Compose文件和`settings.gradle`Gradle文件中移除了Eureka服务器。
- en: We've removed the dependency to `spring-cloud-starter-netflix-eureka-client`
    in all of Eureka's client build files, that is, `build.gradle`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经在所有Eureka客户端的构建文件中移除了对`spring-cloud-starter-netflix-eureka-client`的依赖，即`build.gradle`文件。
- en: We've removed the no-longer-required `eureka.client.enabled=false` property
    setting from all of Eureka's client integration tests.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经从所有Eureka客户端集成测试中移除了不再需要的`eureka.client.enabled=false`属性设置。
- en: The gateway service no longer uses routing based on the client-side load balancer
    in Spring Cloud using the `lb` protocol. For example,  the `lb://product-composite` routing
    destination has been replaced by the `http://product-composite` in the `config-repo/gateway.yml` file.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关服务不再使用基于客户端负载均衡器的Spring Cloud路由，使用`lb`协议。例如，`lb://product-composite`路由目的地已替换为`http://product-composite`在`config-repo/gateway.yml`文件中。
- en: 'The HTTP port used by the microservices and the authorization server has been
    changed from port the `8080` port (`9999` in the case of the authorization server)
    to the default HTTP port `80`. This has been configured in `config-repo` for each
    affected service like so:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务和授权服务器使用的HTTP端口已从端口`8080`（在授权服务器的情况下为端口`9999`）更改为默认的HTTP端口`80`。这在受影响的每个服务的`config-repo`中进行了配置，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'None of the HTTP addresses that we are using are affected by the replacement
    of Netflix Eureka with Kubernetes services. For example, addresses used by the
    composite service are unaffected:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的所有HTTP地址都不会因将Netflix Eureka替换为Kubernetes服务而受到影响。例如，复合服务使用的地址不受影响：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is achieved by changing the HTTP port used by the microservices and the
    authorization server to the default HTTP port, `80`, as described previously.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过改变微服务和授权服务器所使用的HTTP端口为默认的HTTP端口`80`，如前所述来实现的。
- en: Using Docker Compose still works, even though Netflix Eureka has been removed.
    This can be used for running functional tests of the microservices without deploying
    them to Kubernetes, for example, running `test-em-all.bash` together with Docker
    for macOS in the same way as in the previous chapters. Removing Netflix Eureka,
    however, means that we no longer have a discovery service in place when using
    plain Docker and Docker Compose. Therefore, scaling microservices will only work
    when deploying to Kubernetes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose仍然可行，尽管Netflix Eureka已经被移除。这可以用来在不将微服务部署到Kubernetes的情况下运行其功能测试，例如，与macOS上的Docker一起运行`test-em-all.bash`，就像前几章中一样。然而，移除Netflix
    Eureka意味着当我们仅使用Docker和Docker Compose时，我们不再有一个发现服务。因此，只有在部署到Kubernetes时，微服务才能进行扩展。
- en: Now that we've familiarized ourselves with Kubernetes services, let's move on
    to Kustomize, a tool that's used for customizing Kubernetes objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Kubernetes服务，接下来让我们看看Kustomize，这是一个用于自定义Kubernetes对象的工具有。
- en: Introducing Kustomize
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kustomize
- en: '**Kustomize** is a tool that''s used for creating environment-specific customizations
    of the Kubernetes definitions files, that is, the YAML files, for example, for development,
    test, staging, and production environments. Common definition files are stored
    in a `base` folder, while environment-specific additions are kept in environment-specific
    `overlay` folders. Environment-specific information can, for example, be any of
    the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kustomize**是一个用于创建Kubernetes定义文件（即YAML文件）的环境特定自定义的工具，例如，用于开发、测试、暂存和生产环境。常见的定义文件存储在一个`base`文件夹中，而环境特定的添加内容则保存在特定的`overlay`文件夹中。环境特定的信息可以是以下任意一种：'
- en: What version of the Docker images to use
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用哪个版本的Docker镜像
- en: Number of replicas to run
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行的副本数量
- en: Resource quotas in terms of CPU and memory
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于CPU和内存的资源配额
- en: Each folder contains a `kustomization.yml` file that describes its content for
    Kustomize. When deploying to a specific environment, Kustomize will take the content
    from the `base` folder and the environment-specific `overlay` folder and send
    the combined result to `kubectl`. Properties from the files in the `overlay` folder
    will override the corresponding properties in the `base` folder, if any.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件夹中都包含一个`kustomization.yml`文件，它描述了其内容给Kustomize。当部署到特定环境时，Kustomize将从`base`文件夹和环境特定的`overlay`文件夹中获取内容，并将组合后的结果发送给`kubectl`。来自`overlay`文件夹中的文件属性将覆盖`base`文件夹中相应的属性，如果有的话。
- en: 'In this chapter, we will set up customizations for two sample environments:
    development and production.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为两个示例环境设置自定义：开发和生产。
- en: 'The folder structure under `$BOOK_HOME/Chapter16` looks as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter16`下的文件夹结构如下所示：'
- en: '![](img/a62901e6-d94d-49e1-be8f-22ba37d810c2.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a62901e6-d94d-49e1-be8f-22ba37d810c2.png)'
- en: Since Kubernetes 1.14, `kubectl` comes with built-in support for Kustomize using
    the `-k` flag. As we will see as we proceed, deploying to the development environment
    using Kustomize will be done with the `kubectl apply -k kubernetes/services/overlays/dev` command.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自Kubernetes 1.14起，`kubectl`自带了对Kustomize的内置支持，使用`-k`标志。正如我们将继续看到的，使用Kustomize将服务部署到开发环境，将由`kubectl
    apply -k kubernetes/services/overlays/dev`命令完成。
- en: Setting up common definitions in the base folder
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在基础文件夹中设置常见定义
- en: In the `base` folder, we will have one definition file for each microservice,
    but none for the resource managers (MongoDB, MySQL, and RabbitMQ). The resource
    managers will only be deployed in Kubernetes in the development environment and
    are expected to run outside of Kubernetes in the production environment—for example,
    in an existing database and queue manager service on premises or as a managed
    service in the cloud.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`base`文件夹中，我们将为每个微服务都有一个定义文件，但对于资源管理器（MongoDB、MySQL和RabbitMQ）则没有。资源管理器只在开发环境中部署到Kubernetes，并预期在生产环境中运行在Kubernetes之外——例如，作为现有本地数据库和消息队列管理服务的一部分，或者作为云上的托管服务。
- en: 'The definition files in the `base` folder contain a deployment object and a
    service object for each microservice. Let''s go through a typical deployment object
    in `kubernetes/services/base/product.yml`. It is geared toward what is required
    in a development environment. It starts with the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`base` 文件夹中的定义文件包含每个微服务的部署对象和服务对象。让我们来看一下 `kubernetes/services/base/product.yml`
    中的典型部署对象。它旨在满足开发环境的需求。它从以下代码开始：'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This part looks exactly the same as it does for the NGINX deployment we used
    in the previous chapter, [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml),
    *Introduction to Kubernetes*, in the *Trying out a sample deployment* section,
    so we don't need to go through it again.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分看起来与前一章中使用的 NGINX 部署完全一样，因此我们不需要再次讨论。[第 15 章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)
    *Kubernetes 简介*中的*尝试样本部署*部分，所以我们不需要再次讨论。
- en: 'The next part looks a bit different:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分看起来有点不同：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The Docker image specified, `hands-on/product-service`, will be created underneath
    where we build our microservices. See the *Building Docker images* section for
    more information.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的 Docker 镜像 `hands-on/product-service` 将在我们构建微服务时创建。有关更多信息，请参阅*构建 Docker 镜像*部分。
- en: 'The `imagePullPolicy: Never` declaration tells Kubernetes to not try to download
    the Docker image from a Docker registry. See the *Building Docker images* section
    for further information.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagePullPolicy: Never` 声明告诉 Kubernetes 不要尝试从 Docker 注册表下载 Docker 镜像。有关更多信息，请参阅*构建
    Docker 镜像*部分。'
- en: The `SPRING_PROFILES_ACTIVE` environment variable is defined to tell the Spring
    application to use the `docker` Spring profile in the configuration repository.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPRING_PROFILES_ACTIVE` 环境变量被定义为告诉 Spring 应用程序在配置存储库中使用 `docker` Spring 配置文件。'
- en: A secret, `config-client-credentials`, is used to provide the container with
    credentials for accessing the configuration server.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用秘密 `config-client-credentials` 为容器提供访问配置服务器的凭据。
- en: The HTTP port that's used is the default HTTP port `80`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的 HTTP 端口是默认的 HTTP 端口 `80`。
- en: A resource limit is defined to maximize the available memory to 350 MB, that
    is, in the same way as when we used Docker Compose in the previous chapters.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了资源限制，以将可用内存最大化到 350 MB，这与前面章节中使用 Docker Compose 的方式相同。
- en: 'The last part of the declaration of the deployment object contains liveness
    and readiness probes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 部署对象的最后一部分包含存活和就绪探针：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The **liveness** **probe** is based on an HTTP request that's sent to the Spring
    Boot Actuator `info` endpoint. This means that if the microservice instance is
    in such bad shape that it is not capable of responding 200 (OK) to a request that's
    sent to the lightweight `info` endpoint, it is time for Kubernetes to restart
    the microservice instance.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存活探针**是基于发送到 Spring Boot Actuator `info` 端点的 HTTP 请求。这意味着，如果微服务实例处于如此糟糕的状态，以至于无法对发送到轻量级
    `info` 端点的请求返回 200（OK）状态码，那么是时候让 Kubernetes 重新启动微服务实例了。'
- en: The **readiness probe** is based on an HTTP request that's sent to the Spring
    Boot Actuator `health` endpoint. Kubernetes will only send requests to the microservice
    instance if its `health` endpoint responds with the HTTP status 200 (OK). Not
    responding with 200 (OK) typically means that the microservice instance has problems
    with reaching some of the resources it depends on, and so it makes sense to not
    send any requests to a microservice instance when it does not respond with 200
    (OK) on the `health` endpoint.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**就绪探针**是基于发送到 Spring Boot Actuator `health` 端点的 HTTP 请求。Kubernetes 只会在微服务实例的
    `health` 端点返回 HTTP 状态码 200（OK）时发送请求到微服务实例。如果没有返回 200（OK）状态码，通常意味着微服务实例在访问其所依赖的一些资源时存在问题，因此在微服务实例没有在
    `health` 端点返回 200（OK）时，不向其发送任何请求是有意义的。'
- en: 'The liveness and the readiness probes can be configured using the following
    properties:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存活和就绪探针可以通过以下属性进行配置：
- en: '`initialDelaySeconds` specifies how long Kubernetes waits to probe a container
    after it''s started up.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialDelaySeconds` 指定 Kubernetes 在容器启动后等待探针的时间。'
- en: '`periodSeconds` specifies the time between probe requests sent by Kubernetes.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`periodSeconds` 指定 Kubernetes 发送探针请求之间的时间。'
- en: '`timeoutSeconds` specifies how long Kubernetes waits on a response before it
    treats the probe as failed.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeoutSeconds` 指定 Kubernetes 等待响应的时间，如果在规定时间内没有响应，则认为探针失败。'
- en: '`failureThreshold` specifies how many failed attempts Kubernetes makes before
    giving up. In the case of a liveness probe, this means restarting the pod. In
    the case of a readiness probe, it means that Kubernetes will not send any more
    requests to the container.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureThreshold`指定Kubernetes在放弃之前尝试失败的次数。对于存活探针，这意味着重启容器。对于就绪探针，这意味着Kubernetes将不再向容器发送任何请求。'
- en: '`successThreshold` specifies the number of successful attempts that are required
    for a probe to be considered successful again after a failure. This only applies
    to readiness probes since they must be set to `1` if specified for liveness probes.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successThreshold`指定探针在失败后需要成功尝试的次数才能被认为是成功的。这仅适用于就绪探针，因为如果为存活探针指定，它们必须设置为`1`。'
- en: Finding optimal settings for the probes can be challenging, that is, finding
    a proper balance between getting a swift reaction from Kubernetes when the availability
    of a pod changes and not overloading the pods with probe requests. Specifically
    configuring a liveness probe with values that are too low can result in Kubernetes
    restarting pods that just take some time to start, that is, that don't need to
    be restarted. Starting a large number of pods with values that have been set too
    low on the liveness probes can result in a lot of unnecessary restarts. Setting
    the configuration values too high on the probes (except for the `successThreshold`
    value) makes Kubernetes react slower, which can be annoying in a development environment.
    Proper values also depend on the available hardware, which affects the startup
    times for the pods. For the scope of this book, `failureThreshold` for the liveness
    probes is set to a high value, `20`, to avoid unnecessary restarts on computers
    with limited hardware resources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为探针寻找最佳设置可能具有挑战性，也就是说，找到当探针的可用性发生变化时Kubernetes能够快速反应以及不过度加载探针请求之间的适当平衡。特别是如果为存活探针配置的值过低，可能导致Kubernetes重启刚刚需要一些时间启动的容器，即不需要重启的容器。如果为存活探针设置的值过低，启动大量容器可能会导致很多不必要的重启。在探针上设置配置值过高（除了`successThreshold`值）会使Kubernetes反应变慢，这在开发环境中可能会很烦人。适当的值还取决于可用硬件，这会影响容器的启动时间。对于本书的范围，存活探针的`failureThreshold`设置为一个高值`20`，以避免在硬件资源有限的计算机上进行不必要的重启。
- en: 'The service object in `kubernetes/services/base/product.yml` looks as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubernetes/services/base/product.yml`文件中的服务对象如下所示：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The service object looks similar to the NGINX service object we used in the
    previous chapter, [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction
    to Kubernetes*, in the *Trying out a sample deployment* section. One difference
    is that the service type is `ClusterIP` (which is the default type and therefore
    not specified). The service object will receive internal requests on port `80`
    and forward them to the target port, `80`, on the selected pod. The only exception
    to this is the gateway microservice that is exposed externally using a `NodePort`
    service on the host''s port, that is, `31443`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对象与我们在上一章[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)、*Kubernetes简介*中的*尝试样本部署*部分使用的NGINX服务对象类似。不同之处在于服务类型是`ClusterIP`（这是默认类型，因此没有指定）。服务对象将接收端口`80`上的内部请求，并将它们转发到所选容器的目标端口`80`。这个规则的唯一例外是通过宿主机的端口`NodePort`暴露的外部网关微服务，即`31443`：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we have the Kustomize file that binds everything together in the `base`
    folder:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`base`文件夹中有一个将所有内容结合在一起的Kustomize文件：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It simply lists the YAML definition files that Kustomize shall use in the `base`
    folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它简单地列出了Kustomize将在`base`文件夹中使用的YAML定义文件。
- en: Now, we will see how we can use these base definitions with the definitions
    in the `overlay` folders, and see how they are applied using the `-k` switch with
    the `kubectl apply` command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看我们如何可以使用这些基本定义与`overlay`文件夹中的定义一起使用，并了解它们是如何使用`kubectl apply`命令的`-k`选项应用的。
- en: Deploying to Kubernetes for development and test
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序部署到Kubernetes以供开发和测试使用
- en: In this section, we will deploy the microservices in an environment to be used
    for development and test activities, for example, system integration tests. This
    type of environment is used primarily for functional tests and is therefore configured
    to use minimal system resources.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将部署用于开发和测试活动的微服务环境，例如系统集成测试。这种环境主要用于功能测试，因此配置为使用最少的系统资源。
- en: 'Since the deployment objects in the `base` folder are configured for a development
    environment, they don''t need any further refinement in the overlay for development.
    We only have to add deployment and service objects for the three resource managers
    for RabbitMQ, MySQL, and MongoDB in the same way as when using Docker Compose.
    We will deploy the resource managers in the same Kubernetes namespace as the microservices.
    This is illustrated by the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`base`文件夹中的部署对象是为开发环境配置的，因此它们在开发的上层叠加中不需要进一步的细化。我们只需要像使用Docker Compose一样为RabbitMQ、MySQL和MongoDB的三个资源管理器添加部署和服务对象。我们将在这三个资源管理器中部署与微服务相同的Kubernetes命名空间。下面的图表展示了这一点：
- en: '![](img/c5ebe638-fb4c-4344-ab1d-2cd3b1698480.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5ebe638-fb4c-4344-ab1d-2cd3b1698480.png)'
- en: The definition files for the resource managers can be found in the `kubernetes/services/overlays/dev` folder.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管理器的定义文件可以在`kubernetes/services/overlays/dev`文件夹中找到。
- en: 'The `kustomization.yml` file looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`kustomization.yml`文件看起来像这样：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It defines that the `base` folder shall be used as the base and adds the three
    resources we mentioned previously.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了`base`文件夹作为基础，并添加了我们之前提到的三个资源。
- en: Building Docker images
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: Normally, we have to push images to a Docker registry and configure Kubernetes
    to pull images from the registry. In our case, where we have a local single node
    cluster, we can shortcut this process by pointing our Docker client to the Docker
    engine in Minikube and then run the `docker-compose build` command. This will
    result in the Docker images being immediately available to Kubernetes. For development,
    we will be using `latest` as the Docker image version for the microservices.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要将镜像推送到Docker注册表，并配置Kubernetes从注册表中拉取镜像。在我们的案例中，我们有一个本地的单节点集群，我们可以通过将Docker客户端指向Minikube中的Docker引擎，然后运行`docker-compose
    build`命令，来简化这个过程。这将使Docker镜像立即可供Kubernetes使用。对于开发，我们将使用`latest`作为微服务的Docker镜像版本。
- en: You might be wondering how we can update a pod that uses the `latest` Docker
    image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道我们如何更新使用`latest` Docker镜像的pods。
- en: From Kubernetes 1.15, this is very simple. Just change the code and rebuild
    the Docker image, for example, using the `build` command that's described here.
    Then, update a pod with the `kubectl rollout restart` command.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes 1.15开始，这非常简单。只需更改代码并重新构建Docker镜像，例如使用这里描述的`build`命令。然后，使用`kubectl
    rollout restart`命令更新一个pods。
- en: For example, if the `product` service has been updated, run the `kubectl rollout
    restart deploy product` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`product`服务已更新，运行`kubectl rollout restart deploy product`命令。
- en: 'You can build Docker images from source as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从源代码构建Docker镜像，如下所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `eval $(minikube docker-env)` command directs the local Docker client to
    communicate with the Docker engine in Minikube, for example, when building the
    Docker images.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval $(minikube docker-env)`命令使本地Docker客户端与Minikube中的Docker引擎通信，例如，在构建Docker镜像时。'
- en: 'The `docker-compose.yml` file has been updated to specify a name for the Docker
    images it builds. For example, for the `product` service, we have the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`文件已更新以指定构建的Docker镜像的名称。例如，对于`product`服务，我们有如下内容：'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`latest` is the default tag for a Docker image name, so it is not specified.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`latest`是Docker镜像名称的默认标签，因此不需要指定。'
- en: With the Docker images built, we can start creating the Kubernetes resource
    objects!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像后，我们可以开始创建Kubernetes资源对象！
- en: Deploying to Kubernetes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Kubernetes
- en: Before we can deploy the microservices to Kubernetes, we need to create a namespace,
    the required config maps, and secrets. After the deployment is performed, we will
    wait for the deployments to be up and running, and also verify that we got the
    expected result in terms of deployed pods and Docker images that were used per
    pod.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将微服务部署到Kubernetes之前，我们需要创建一个命名空间，所需的config maps和secrets。部署完成后，我们将等待部署运行起来，并验证我们在部署的pods和每个pod中使用的Docker镜像是否符合预期。
- en: 'Create a namespace, `hands-on`, and set it as the default namespace for `kubectl`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个命名空间，`hands-on`，并将其设置为`kubectl`的默认命名空间：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All application configuration is kept in the configuration repository that's
    managed by the configuration server. The only configuration information that needs
    to be stored outside of the configuration repository is the credentials for connecting
    to the configuration server and an encryption key. The encryption key is used
    by the configuration server to keep sensitive information in the configuration
    repository encrypted at rest, that is, on disk.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序配置都保存在由配置服务器管理的配置仓库中。唯一需要存储在配置仓库外的配置信息是连接到配置服务器的凭据和一个加密密钥。加密密钥由配置服务器使用，以保持配置仓库中的敏感信息在磁盘上加密。
- en: We will store the configuration repository in a config map with all the sensitive
    information encrypted; see [Chapter 12](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml),
    *Centralized Configuration*, for details. The credentials for connecting to the
    configuration server and the encryption key will be stored in two secrets, one
    for the configuration server and one for its clients.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把配置仓库存储在一个带有所有敏感信息加密的config map中；具体请参阅[第12章](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml)，*集中配置*。连接配置服务器和加密密钥的凭据将存储在两个秘密中，一个用于配置服务器，一个用于其客户端。
- en: 'To check this, perform the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，请执行以下步骤：
- en: 'Create the config map for the configuration repository based on the files in
    the `config-repo` folder with the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`config-repo`文件夹中的文件，使用以下命令创建config map：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the secret for the configuration server with the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建配置服务器秘密：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the secret for the clients of the configuration server with the following
    command:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为配置服务器的客户端创建秘密：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we have just entered commands that contain sensitive information in clear
    text, for example, passwords and an encryption key, it is a good idea to clear
    the `history` command. To clear the `history` command both in memory and on disk,
    run the `history -c; history -w` command.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚输入了包含敏感信息的明文命令，例如密码和加密密钥，清除`history`命令是一个好主意。要清除内存和磁盘上的`history`命令，请运行`history
    -c; history -w`命令。
- en: See the discussion at [https://unix.stackexchange.com/a/416831](https://unix.stackexchange.com/a/416831)
    for details on the `history` command.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`history`命令的详细信息，请参阅[https://unix.stackexchange.com/a/416831](https://unix.stackexchange.com/a/416831)的讨论。
- en: 'To avoid a slow deployment due to Kubernetes downloading Docker images (potentially
    causing the liveness probes we described previously to restart our pods), run
    the following `docker pull` commands to download the images:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免由于Kubernetes下载Docker镜像而导致部署缓慢（可能会导致我们之前描述的存活探针重启我们的pods），请运行以下`docker pull`命令以下载镜像：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Deploy the microservices for the development environment, based on the `dev`
    overlay, using the `-k` switch to activate Kustomize, as described previously:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`dev`覆盖层，使用`-k`开关激活Kustomize，如前所述部署开发环境的微服务：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Wait for the deployments and their pods to be up and running by running the
    following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令等待部署及其pods启动并运行：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Expect each command to respond with `deployment.extensions/... condition met`.
    `...` will be replaced with the name of the actual deployment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 期望每个命令的响应为`deployment.extensions/... condition met`。`...`将被实际部署的名称替换。
- en: 'To see the Docker images that are used for development, run the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看用于开发的Docker镜像，请运行以下命令：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The response should look similar to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应类似于以下内容：
- en: '![](img/42300572-7769-4a8b-9b4d-5efd9d361dab.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42300572-7769-4a8b-9b4d-5efd9d361dab.png)'
- en: We are now ready to test our deployment!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好测试我们的部署！
- en: But before we can do that, we need to go through changes that are required in
    the test script for use with Kubernetes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能做到这一点之前，我们需要经历测试脚本中必须与Kubernetes一起使用的更改。
- en: Changes in the test script for use with Kubernetes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于与Kubernetes一起使用的测试脚本的更改
- en: 'To test the deployment we will, as usual, run the test script, that is, `test-em-all.bash`.
    To work with Kubernetes, the circuit breaker tests have been slightly modified.
    Take a look at the `testCircuitBreaker()` function for more details. The circuit
    breaker tests call the `actuator` endpoints on the `product-composite` service
    to check their health state and get access to circuit breaker events. The `actuator`
    endpoints are not exposed externally, so the test script needs to use different
    techniques to access the internal endpoints when using Docker Compose and Kubernetes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试部署，我们将像往常一样运行测试脚本，即`test-em-all.bash`。为了与Kubernetes配合工作，电路断路器测试做了一些微小修改。详情请查看`testCircuitBreaker()`函数。电路断路器测试调用`product-composite`服务上的`actuator`端点，以检查其健康状态并获得电路断路器事件访问权限。`actuator`端点并未对外暴露，因此当使用Docker
    Compose和Kubernetes时，测试脚本需要使用不同的技术来访问内部端点：
- en: When using Docker Compose, the test script will launch a Docker container using
    a plain `docker run` command that calls the `actuator` endpoints from the inside
    of the network created by Docker Compose.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用Docker Compose时，测试脚本将使用简单的`docker run`命令启动一个Docker容器，该命令从Docker Compose创建的网络内部调用`actuator`端点。
- en: When using Kubernetes, the test script will launch a Kubernetes pod that it
    can use to run the corresponding commands inside Kubernetes.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用Kubernetes时，测试脚本将启动一个Kubernetes pod，它可以在Kubernetes内部运行相应的命令。
- en: Let's see how this is done when using Docker Compose and Kubernetes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在使用Docker Compose和Kubernetes时是如何做到的。
- en: Reaching the internal actuator endpoint using Docker Compose
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose访问内部actuator端点
- en: 'The base command that''s defined for Docker Compose is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为Docker Compose定义的基本命令如下：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the container will be killed using the `--rm` switch after each execution
    of a test command.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每次执行测试命令后，使用`--rm`选项将容器杀死。
- en: Reaching the internal actuator endpoint using Kubernetes
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes访问内部actuator端点
- en: Since launching a pod in Kubernetes is slower than starting a container, the
    test script will launch a single pod, `alpine-client`. The pod will be launched at
    the start of the `testCircuitBreaker()` function, and the tests will use the `kubectl
    exec` command to run the test commands in this pod. This will be much faster than
    creating and deleting a pod for each test command.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Kubernetes中启动pod比启动容器慢，测试脚本将启动一个名为`alpine-client`的单个pod，该pod将在`testCircuitBreaker()`函数的开始处启动，并且测试将使用`kubectl
    exec`命令在这个pod中运行测试命令。这将比为每个测试命令创建和删除一个pod要快得多。
- en: 'Launching the single pod is handled at the beginning of the `testCircuitBreaker()`
    function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 启动单个pod是在`testCircuitBreaker()`函数的开始处处理的：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At the end of the circuit breaker tests, the pod is deleted by using the following
    command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在电路断路器测试的最后，使用以下命令删除pod：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Choosing between Docker Compose and Kubernetes
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择Docker Compose和Kubernetes
- en: 'To make the test script work with both Docker Compose and Kubernetes, it assumes
    that Docker Compose will be used if the `HOST` environment variable is set to
    `localhost`; otherwise, it assumes that Kubernetes will be used. See the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试脚本能够与Docker Compose和Kubernetes一起工作，它假定如果`HOST`环境变量设置为`localhost`，则将使用Docker
    Compose；否则，它假定将使用Kubernetes。如下代码所示：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The default value for the `HOST` environment variable in the test script is `localhost`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本中`HOST`环境变量的默认值是`localhost`。
- en: 'Once the `EXEC` variable has been set up, depending on whether the tests are
    running on Docker Compose or on Kubernetes, it is used in the `testCircuitBreaker()` test
    function. The test starts by verifying that the circuit breaker is closed with
    the following statement:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了`EXEC`变量，根据测试是在Docker Compose还是Kubernetes上运行，它将在`testCircuitBreaker()`测试函数中使用。测试首先通过以下语句验证电路断路器是关闭的：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A final change in the test script occurs because our services are now reachable
    on the `80` port inside the cluster; that is, they are no longer on the `8080`
    port.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本中的最后一步更改是因为我们的服务现在可以在集群内的`80`端口访问；也就是说，它们不再在`8080`端口。
- en: If the various ports that we've used seem confusing, review the definitions
    of the services in the *Setting up common definitions in the base folder* section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用过的各种端口看起来令人困惑，请回顾*在基础文件夹中设置常用定义*部分中服务定义。
- en: Testing the deployment
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试部署
- en: When launching the test script, we have to give it the address of the host that
    runs Kubernetes, that is, our Minikube instance, and the external port where our
    gateway service listens for external requests. The `minikube ip` command can be
    used to find the IP address of the Minikube instance and, as mentioned in the
    *Setting up common definitions in the base folder* section, we have assigned the
    external `NodePort 31443` to the gateway service.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动测试脚本时，我们必须给它运行 Kubernetes 的主机的地址，即我们的 Minikube 实例，以及我们的网关服务监听外部请求的外部端口。可以使用
    `minikube ip` 命令来查找 Minikube 实例的 IP 地址，正如在 *在基础文件夹中设置公共定义* 部分提到的，我们已经将网关服务的外部
    `NodePort 31443` 分配给了网关服务。
- en: 'Start the tests with the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令开始测试：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the output from the script we will see how the IP address of the Minikube
    instance is used and also how the `alpine-client` pod is created and destroyed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本的输出中，我们将看到 Minikube 实例的 IP 地址的使用，以及如何创建和销毁 `alpine-client` 容器：
- en: '![](img/97c12d92-177b-46e9-9f35-57cef2157850.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97c12d92-177b-46e9-9f35-57cef2157850.png)'
- en: Before we move on and look at how to set up a corresponding environment for
    staging and production use, let's clean up what we have installed in the development
    environment to preserve resources in the Kubernetes cluster. We can do this by
    simply deleting the namespace. Deleting the namespace will recursively delete
    the resources that exist in the namespace.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续查看如何为阶段和生产使用设置相应的环境之前，让我们清理一下我们在开发环境中安装的内容，以节省 Kubernetes 集群中的资源。我们可以通过简单地删除命名空间来实现这一点。删除命名空间将递归删除命名空间中存在的所有资源。
- en: 'Delete the namespace with the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令删除命名空间：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the development environment removed, we can move on and set up an environment
    targeting staging and production.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 移除了开发环境之后，我们可以继续设置一个针对阶段和生产的环境。
- en: Deploying to Kubernetes for staging and production
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务部署到 Kubernetes 用于阶段和生产
- en: In this section, we will deploy the microservices in an environment for staging
    and production usage. A staging environment is used for performing **quality**
    **assurance** (**QA**) and **user acceptance tests** (**UAT**) as the last step
    before taking a new release into production. To be able to verify that the new
    release not only meets functional requirements but also non-functional requirements,
    for example, in terms of performance, robustness, scalability, and resilience,
    a staging environment is configured to be as similar as possible to the production
    environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将把微服务部署到一个用于阶段和生产环境的系统中。阶段环境用于进行**质量保证**（**QA**）和**用户验收测试**（**UAT**），这是将新版本投入生产之前的最后一步。为了验证新版本不仅满足功能性需求，还包括性能、健壮性、可伸缩性和弹性等非功能性需求，阶段环境应尽可能与生产环境相似。
- en: 'When deploying to an environment for staging or production, there are a number
    of changes required compared to when deploying for development or tests:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当将服务部署到用于阶段或生产的环境时，与开发或测试相比需要进行许多更改：
- en: '**Resource managers should run outside of the Kubernetes cluster**: It is technically
    feasible to run databases and queue managers for production use on Kubernetes
    as stateful containers using `StatefulSets` and `PersistentVolumes`. At the time
    of writing this chapter, I recommend against it, mainly because the support for
    stateful containers is relatively new and unproven in Kubernetes. Instead, I recommend using
    the existing database and queue manager services on premises or managed services
    in the cloud, leaving Kubernetes to do what it is best for, that is, running stateless
    containers. For the scope of this book, to simulate a production environment,
    we will run MySQL, MongoDB, and RabbitMQ as plain Docker containers outside of
    Kubernetes using the already existing Docker Compose files.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理器应运行在 Kubernetes 集群之外**：从技术上讲，将数据库和队列管理器作为有状态容器在 Kubernetes 上运行以供生产使用是可行的，可以使用
    `StatefulSets` 和 `PersistentVolumes`。在撰写本章时，我建议不要这样做，主要是因为对有状态容器的支持相对较新，在 Kubernetes
    中尚未得到验证。相反，我建议使用本地或云上的现有数据库和队列管理服务，让 Kubernetes 做它最擅长的事情，即运行无状态容器。对于本书的范围，为了模拟生产环境，我们将使用现有的
    Docker Compose 文件，将 MySQL、MongoDB 和 RabbitMQ 作为普通的 Docker 容器在 Kubernetes 之外运行。'
- en: '**Lockdown:**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁定**：'
- en: For security reasons, things like `actuator` endpoints and log levels need to
    be constrained in a production environment.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出于安全原因，诸如 `actuator` 端点和日志级别等事物需要在生产环境中受到限制。
- en: Externally exposed endpoints should also be reviewed from a security perspective.
    For example, access to the configuration server should most probably be locked
    down in a production environment, but we will keep it exposed in this book for
    convenience.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部暴露的端点也应从安全角度进行审查。例如，配置服务器的访问在生产环境中很可能需要受到限制，但为了方便起见，我们将在本书中将其暴露出来。
- en: Docker image tags must be specified to be able to track which versions of the
    microservices have been deployed.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像标签必须指定，才能跟踪已部署微服务的哪些版本。
- en: '**Scale up available resources**: To meet the requirements of both high availability
    and higher load, we need to run at least two pods per deployment. We might also
    need to increase the amount of memory and CPU that are allowed to be used per
    pod. To avoid running out of memory in the Minikube instance, we will keep one
    pod per deployment but increase the maximum memory allowed in the production environment.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩大可用资源规模**：为了满足高可用性和更高负载的需求，每个部署至少需要运行两个pods。我们可能还需要增加每个pods允许使用的内存和CPU。为了避免Minikube实例中内存耗尽，我们将在每个部署中保留一个pods，但在生产环境中增加允许的最大内存。'
- en: '**Set up a production-ready Kubernetes cluster**:This is outside the scope
    of this book, but, if feasible, I recommend using one of the managed Kubernetes
    services provided by the leading cloud providers. For the scope of this book,
    we will deploy to our local Minikube instance.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建立一个生产就绪的Kubernetes集群**：这超出了本书的范围，但如果可行，我建议使用领先云服务提供商提供的托管Kubernetes服务。在本书的范围内，我们将部署到我们的本地Minikube实例。'
- en: This is not meant to be an exhaustive list of things that have to be considered
    when setting up an environment for production, but it's a good start.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是在设置生产环境时需要考虑的详尽列表，但这是一个不错的开始。
- en: 'Our simulated production environment will look as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟生产环境将如下所示：
- en: '![](img/3ddfcf4d-89dd-4007-a19c-4568e6cb2220.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ddfcf4d-89dd-4007-a19c-4568e6cb2220.png)'
- en: Changes in the source code
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码中的更改：
- en: 'The following changes have been applied to the source code to prepare for deployment
    in an environment that''s used for production:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改已应用于源代码，以准备在用于生产的环境中部署：
- en: 'A Spring profile named `prod`  has been added to the configuration files in
    the `config-repo` configuration repository:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`config-repo`配置仓库中添加了一个名为`prod`的Spring配置文件：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `prod` profiles, the following has been added:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`prod`配置文件中，已添加以下内容：
- en: 'URLs to the resource managers that run as plain Docker containers:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行为普通Docker容器的资源管理器URL：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using the `172.17.0.1` IP address to address the Docker engine in the
    Minikube instance. This is the default IP address for the Docker engine when creating
    it with Minikube, at least for Minikube up to version 1.2.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`172.17.0.1`IP地址来访问Minikube实例中的Docker引擎。这是在创建Minikube时，至少对于版本1.2的Minikube，Docker引擎的默认IP地址。
- en: There is work ongoing for establishing a standard DNS name for containers to
    use if they need to access the Docker host they are running on, but at the time
    of writing this chapter, this work effort hasn't been completed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正在开展的工作是建立一个标准的DNS名称，供容器在需要访问它们正在运行的Docker主机时使用，但在撰写本章时，这项工作尚未完成。
- en: 'Log levels have been set to warning or higher, that is, error or fatal. For
    example:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别已设置为警告或更高，即错误或致命。例如：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The only `actuator` endpoints that are exposed over HTTP are the `info` and `health` endpoints
    that are used by the liveness and readiness probes in Kubernetes, as well as the `circuitbreakerevents` endpoint
    that''s used by the test script, `test-em-all.bash`:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP暴露的`actuator`端点仅有`info`和`health`端点，这些端点被Kubernetes中的存活和就绪探针使用，以及被测试脚本`test-em-all.bash`使用的`circuitbreakerevents`端点：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the production `overlay` folder, `kubernetes/services/overlays/prod`, one
    deployment object for each microservice has been added with the following content
    so that it can be merged with the base definition:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产`overlay`文件夹`kubernetes/services/overlays/prod`中，为每个微服务添加了一个部署对象，并具有以下内容，以便与基本定义合并：
- en: 'For all microservices, `v1` is specified as the Docker `image` tag, and the
    `prod` profile is added to the active Spring profiles. For example, we have the
    following for the `product` service:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有微服务，`v1`被指定为Docker `image`标签，并且`prod`配置文件被添加到活动Spring配置文件中。例如，对于`product`服务，我们有以下内容：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the Zipkin and configuration server, which don''t keep their configuration
    in the configuration repository, environment variables have been added in their
    deployment definitions with the corresponding configuration:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不将其配置保存在配置仓库中的 Zipkin 和配置服务器，在它们的部署定义中添加了相应的环境变量：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, a `kustomization.yml` file defines that the files in the `prod overlay`
    folder shall be merged by specifying the `patchesStrategicMerge` patch mechanism
    with the corresponding definition in the `base` folder:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`kustomization.yml` 文件定义了将 `prod overlay` 文件夹中的文件合并的 `patchesStrategicMerge`
    补丁机制，并在 `base` 文件夹中指定相应的定义：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In a real-world production environment, we should have also changed the `imagePullPolicy:
    Never` setting to `IfNotPresent`, that is, to download Docker images from a Docker
    registry. But since we will be deploying the production setup to the Minikube
    instance where we manually build and tag the Docker images, we will not update
    this setting.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '在实际的生产环境中，我们还应该将 `imagePullPolicy: Never` 设置更改为 `IfNotPresent`，即从 Docker 仓库下载
    Docker 镜像。但是，由于我们将把生产设置部署到 Minikube 实例，我们在那里手动构建和打标签 Docker 镜像，所以不会更新此设置。'
- en: Deploying to Kubernetes
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Kubernetes
- en: 'To simulate production-grade resource managers, MySQL, MongoDB, and RabbitMQ will
    run outside of Kubernetes using Docker Compose. We start them up as we did in
    the previous chapters:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟生产级别的资源管理器，MySQL、MongoDB 和 RabbitMQ 将使用 Docker Compose 在 Kubernetes 外运行。我们像前几章一样启动它们：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to tag the existing Docker images with `v1` using the following
    commands:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用以下命令将现有的 Docker 镜像标记为 `v1`：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From here, the commands are very similar to how we deployed to the development
    environment.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，命令与部署到开发环境非常相似。
- en: 'We will use another Kustomize overlay and use different credentials for the
    configuration server, but, otherwise, it will be the same (which, of course, is
    a good thing!). We will use the same configuration repository but configure the
    pods to use the `prod` Spring profile, as described previously. Follow these steps
    to do so:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用另一个 Kustomize 覆盖层，并为配置服务器使用不同的凭据，但是，除此之外，它将保持不变（这当然是一件好事！）。我们将使用相同的配置仓库，但配置
    Pod 以使用 `prod` Spring 配置文件，如前所述。按照以下步骤进行操作：
- en: 'Create a namespace, `hands-on`, and set this as the default namespace for `kubectl`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `hands-on` 的命名空间，并将其设置为 `kubectl` 的默认命名空间：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the config map for the configuration repository based on the files in
    the `config-repo` folder with the following command:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令基于 `config-repo` 文件夹中的文件为配置仓库创建配置映射：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the secret for the configuration server with the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为配置服务器创建密钥：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the secret for the clients of the configuration server with the following
    command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为配置服务器的客户端创建密钥：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Remove the clear text encryption key and passwords from the command history:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将明文加密密钥和密码从命令历史中删除：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Deploy the microservices for the development environment, based on the `prod` overlay,
    using the `-k` switch to activate Kustomize, as described previously:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于 `prod` 覆盖层，使用 `-k` 选项激活 Kustomize，如前所述，部署开发环境中的微服务：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Wait for the deployments to be up and running:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待部署运行起来：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To see the Docker images that are currently being used for production, run
    the following command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看当前用于生产的 Docker 镜像，运行以下命令：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The response should look something like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该类似于以下内容：
- en: '![](img/3f3b0b67-78f2-4815-8c42-3f67a8931783.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f3b0b67-78f2-4815-8c42-3f67a8931783.png)'
- en: Note the `v1` version of the Docker images!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Docker 镜像的 `v1` 版本！
- en: Also note that the resource manager pods for MySQL, MongoDB, and RabbitMQ are
    gone; these can be found with the `docker-compose ps` command.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，MySQL、MongoDB 和 RabbitMQ 的资源管理器 Pod 已经消失了；这些可以通过 `docker-compose ps` 命令找到。
- en: 'Run the test script, `thest-em-all.bash`, to verify the simulated production
    environment:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试脚本 `thest-em-all.bash` 以验证模拟的生产环境：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Expect the same type of output that we got when the test script was run against
    the development environment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到与针对开发环境运行测试脚本时相同的输出。
- en: Performing a rolling upgrade
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行滚动升级
- en: Historically, updates often result in some downtime of the component that is
    updated. In a system landscape with an increasing number of autonomous microservices
    that are updated independently of each other, recurring downtimes due to frequent
    updates of the microservices is not acceptable. Being able to deploy an update
    without downtime becomes crucial.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，更新往往导致被更新组件的短暂停机。在具有越来越多的独立更新彼此的其他组件的系统架构中，由于频繁更新微服务而导致的重复停机是不可接受的。能够在不停机的情况下部署更新变得至关重要。
- en: In this section, we will see how we can perform a rolling upgrade, updating
    a microservice to a new version of its Docker image without requiring any downtime.
    Performing a rolling upgrade means that Kubernetes first starts the new version
    of the microservice in a new pod, and when it reports as being healthy, Kubernetes
    will terminate the old one. This ensures that there is always a pod up and running,
    ready to serve incoming requests during the upgrade. A prerequisite for a rolling
    upgrade to work is that the upgrade is backward compatible, both in terms of APIs
    and message formats that are used to communicate with other services and database
    structures. If the new version of the microservice requires changes to either
    the external APIs, message formats, or database structures that the old version
    can't handle, a rolling upgrade can't be applied. A deployment object is configured
    to perform any updates as a rolling upgrade by default.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何执行滚动升级，即在不需要任何停机的情况下将微服务更新为其Docker镜像的新版本。执行滚动升级意味着Kubernetes首先在新pods中启动微服务的新版本，当它报告为健康时，Kubernetes将终止旧的pods。这确保了在升级期间始终有一个pods在运行，准备处理传入的请求。滚动升级能够工作的前提是升级是向后兼容的，这包括与其他服务和数据库结构通信时使用的API和消息格式。如果微服务的新版本需要对外部API、消息格式或数据库结构进行更改，而旧版本无法处理，则无法应用滚动升级。默认情况下，部署对象被配置为执行任何更新作为滚动升级。
- en: To try this out, we will create a v2 version of the Docker image for the `product`
    service and then start up a test client, `siege`, that will submit one request
    per second during the rolling upgrade. The assumption is that the test client
    will report 200 (OK) for all the requests that it sends during the upgrade.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个，我们将为`product`服务创建一个v2版本的Docker镜像，然后启动一个测试客户端`siege`，在滚动升级期间每秒提交一个请求。假设测试客户端在升级期间发送的所有请求都会报告200（OK）。
- en: Preparing the rolling upgrade
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备滚动升级
- en: 'To prepare for the rolling upgrade, first, verify that we have the `v1` version
    of the product pod deployed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备滚动升级，首先验证我们已经部署了`v1`版本的产品pods：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The expected output should reveal that `v1` of the Docker image is in use:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出应该显示Docker镜像的`v1`版本正在使用：
- en: '![](img/8ba120f8-86f6-4b8e-9f5c-88e9e66e05cf.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ba120f8-86f6-4b8e-9f5c-88e9e66e05cf.png)'
- en: 'Create a `v2` tag on the Docker image for the `product` service with the following
    command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在Docker镜像上为`product`服务创建一个`v2`标签：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To try out a rolling upgrade from a Kubernetes perspective, we don't need to
    change any code in the `product` service. Deploying a Docker image with another
    tag than the existing one will start up a rolling upgrade.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Kubernetes的角度尝试滚动升级，我们不需要在`product`服务中更改任何代码。部署一个不同于现有版本的Docker镜像将启动滚动升级。
- en: 'To be able to observe whether any downtime occurs during the upgrade, we will
    start a low volume load test using `siege`. The following command starts a load
    test that simulates one user (`-c1`) that submits one request per second on average
    (`-d1`):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够观察到升级期间是否发生停机，我们将使用`siege`启动低负载负载测试。以下命令启动了一个模拟一个用户（`-c1`）平均每秒提交一个请求的负载测试（`-d1`）：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since the test calls the gateways health endpoint, it verifies that all the
    services are healthy.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试调用网关的健康端点，它验证了所有服务都是健康的。
- en: 'You should receive an output that looks similar to the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收到如下所示的输出：
- en: '![](img/2a9f905e-809b-4146-9b64-208c924649cb.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a9f905e-809b-4146-9b64-208c924649cb.png)'
- en: The interesting part in the response is the HTTP status code, which we expect
    to be `200` at all times.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中的有趣部分是HTTP状态码，我们期望它始终为`200`。
- en: 'Also, monitor changes to the state of the product pods with the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 也要监控产品pods状态的变化，可以使用以下命令：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Upgrading the product service from v1 to v2
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从v1升级到v2的产品服务
- en: 'To upgrade the `product` service, edit the `kubernetes/services/overlays/prod/product-prod.yml` file
    and change `image: hands-on/product-service:v1` to `image: hands-on/product-service:v2`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '-   要升级`product`服务，请编辑`kubernetes/services/overlays/prod/product-prod.yml`文件，将`image:
    hands-on/product-service:v1`更改为`image: hands-on/product-service:v2`。'
- en: 'Apply the update with the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '-   使用以下命令应用更新：'
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Expect a response from the command that reports that most of the objects are
    left unchanged, except for the product deployment that should be reported to be
    updated to `deployment.apps/product configured`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '-   期望命令的响应报告大多数对象保持不变，除了产品部署应报告为更新到`deployment.apps/product configured`。'
- en: Kubernetes comes with some shorthand commands. For example, `kubectl set image
    deployment/product pro=hands-on/product-service:v2` can be used to perform the
    same update that we did by updating the definitions file and running the `kubectl
    apply` command. A major benefit of using the `kubectl apply` command is that we
    can keep track of the changes by pushing the changes in the source code to a version
    control system such as Git. This is very important if we want to be able to handle
    our infrastructure as code. When playing around with a Kubernetes cluster, only
    use it to test shorthand commands, as this can be very useful.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '-   Kubernetes提供了一些简写命令。例如，`kubectl set image deployment/product pro=hands-on/product-service:v2`可以用来执行与更新定义文件并运行`kubectl
    apply`命令相同的更新。使用`kubectl apply`命令的一个主要好处是我们可以通过将更改推送到Git等版本控制系统的源代码来跟踪更改。如果我们想能够以代码方式处理我们的基础设施，这非常重要。在测试Kubernetes集群时，只使用它来测试简写命令，因为这将非常有用。'
- en: 'In the output from the `kubectl get pod -l app=product -w` command we launched in
    the *Preparing the rolling upgrade* section, we will see some action occurring.
    Take a look at the following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '-   在*准备滚动升级*部分中启动的`kubectl get pod -l app=product -w`命令的输出中，我们将看到一些动作发生。请看以下截图：'
- en: '![](img/e395b5c0-fc40-43f1-b8ec-f85a9ce86628.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e395b5c0-fc40-43f1-b8ec-f85a9ce86628.png)'
- en: Here, we can see how the existing pod (`ffrdh`) initially reported that it was
    up and running and also reported to be healthy when a new pod was launched (`t8mcl`).
    After a while (`16s`, in my case), it is reported as up and running as well. During
    a certain time period, both pods will be up and running and processing requests.
    After a while, the first pod is terminated (2 minutes, in my case).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '-   在这里，我们可以看到现有的Pod（`ffrdh`）最初报告它正在运行，并在启动新的Pod（`t8mcl`）后也报告为健康。经过一段时间（在我的案例中是`16s`），它也被报告为正在运行。在一段时间内，两个Pod都会运行并处理请求。经过一段时间，第一个Pod被终止（在我的案例中是2分钟）。'
- en: 'When looking at the `siege` output, we can sometimes find a few errors being
    reported in terms of the `503` service unavailable errors:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '-   当查看`siege`输出时，有时可以在`503`服务不可用错误方面找到一些错误：'
- en: '![](img/3caab39b-4d02-4f93-ace5-5402b72aac09.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3caab39b-4d02-4f93-ace5-5402b72aac09.png)'
- en: This typically happens when the old pod is terminated. Before the old pod is
    reported unhealthy by the readiness probe, it can receive a few requests during
    its termination, that is, when it is no longer capable of serving any requests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '-   这通常发生在旧Pod被终止时。在旧Pod被readiness探针报告为不健康之前，它可以在终止过程中接收到几个请求，即它不再能够处理任何请求时。'
- en: In [Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml), *Using a Service
    Mesh to Improve Observability and Management*, we will see how we can set up routing
    rules that move traffic in a smoother way from an old pod to a newer one without
    causing 503 errors. We will also see how we can apply retry mechanisms to stop
    temporary failures from reaching an end user.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '-   在[第18章](422649a4-94bc-48ae-b92b-e3894c014962.xhtml)《使用服务网格提高可观测性和管理能力》中，我们将了解如何设置路由规则，以更平滑地将流量从旧容器移动到新容器，而不会导致503错误。我们还将了解如何应用重试机制，以防止临时故障影响到最终用户。'
- en: 'Wrap this up by verifying that the pod is using the new `v2` version of the
    Docker image:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '-   通过验证Pod是否正在使用Docker镜像的新`v2`版本来完成更新：'
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The expected output reveals that `v2` of the Docker image is in use:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '-   期望的输出显示Docker镜像的`v2`版本正在使用：'
- en: '![](img/bd38e1cd-b695-49b8-991b-63e395ee577d.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd38e1cd-b695-49b8-991b-63e395ee577d.png)'
- en: After performing this upgrade, we can move on to learning what happens when
    things fail. In the next section, we will see how we can roll back a failed deployment.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '-   在执行此升级后，我们可以继续学习当事情失败时会发生什么。在下一节中，我们将了解如何回滚一个失败的部署。'
- en: Rolling back a failed deployment
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   回滚失败的部署'
- en: From time to time, things don't go according to plan, for example, an upgrade
    of deployments and pods can fail for various reasons. To demonstrate how to roll
    back a failed upgrade, let's try to upgrade to `v3` without creating a `v3` tag
    on the Docker image!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，事情并不会按照计划进行，例如，部署和pods的升级可能会因各种原因失败。为了演示如何回滚失败的升级，让我们尝试在不创建`v3`标签的Docker镜像的情况下升级到`v3`！
- en: 'Let''s try out the following shorthand command to perform the update:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用以下简写命令来执行更新：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Expect to see the following changes reported by the `kubectl get pod -l app=product
    -w` command we launched in the *Preparing the rolling upgrade*section:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 预期`kubectl get pod -l app=product -w`命令会报告以下变化（在“准备滚动升级”部分启动）：
- en: <q>![](img/290f3cd4-de45-4a31-8abb-495b8f20c15e.png)</q>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <q>![](img/290f3cd4-de45-4a31-8abb-495b8f20c15e.png)</q>
- en: We can clearly see that the new pod (ending with `m2dtn`, in my case) has failed
    to start because of a problem finding its Docker image (as expected). If we look
    at the output from the `siege` test tool, no errors are reported, only 200 (OK)!
    Here, the deployment hangs since it can't find the requested Docker image, but
    no errors are affecting end users since the new pod couldn't even start.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，新部署的pods（在我的案例中以`m2dtn`结尾）因为找不到Docker镜像而无法启动，这是预期的。如果我们查看`siege`测试工具的输出，没有错误报告，只有200（OK）！在这里，部署挂起，因为它找不到请求的Docker镜像，但终端用户没有受到任何影响，因为新pods甚至没有启动。
- en: 'Let''s see what history Kubernetes has regarding the product''s deployment.
    Run the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看Kubernetes关于产品部署的历史记录。运行以下命令：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You will receive output similar to the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到如下类似输出：
- en: '![](img/f5e3c16a-efab-43df-a5a5-04dda9c5c4c9.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5e3c16a-efab-43df-a5a5-04dda9c5c4c9.png)'
- en: 'We can guess that revision 2 is the one with the latest successful deployment,
    that is, `v2` of the Docker image. Let''s check this with the following command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以猜测修订2是最新成功部署的，也就是Docker镜像的`v2`。让我们用以下命令来验证：
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the response, we can see that `revision #2` is the one with Docker image
    `v2`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '在响应中，我们可以看到`revision #2`带有Docker镜像`v2`：'
- en: '![](img/4e3d11c8-a112-40c0-be6b-29631e196c19.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e3d11c8-a112-40c0-be6b-29631e196c19.png)'
- en: 'Let''s roll back our deployment to `revision=2` with the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以将部署回滚到`revision=2`：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Expect a response that confirms the rollback, like so:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 预期会有一个确认回滚的响应，如下所示：
- en: '![](img/936308fe-f3a2-45aa-949b-2fe8fe52cbe5.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/936308fe-f3a2-45aa-949b-2fe8fe52cbe5.png)'
- en: 'The `kubectl get pod -l app=product -w` command we launched in the *Preparing
    the rolling upgrade* section will report that the new (not working) pod has been
    removed by the `rollback` command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在“准备滚动升级”部分启动的`kubectl get pod -l app=product -w`命令会报告新（不可用）pods已被`rollback`命令移除：
- en: '![](img/0f0d45ea-cb69-4f32-a2fa-55edca821532.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f0d45ea-cb69-4f32-a2fa-55edca821532.png)'
- en: 'We can wrap this up by verifying that the current image version is still `v2`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过验证当前镜像版本仍为`v2`来结束本章：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Cleaning up
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'To delete the resources that we used, run the following commands:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除我们使用的资源，请运行以下命令：
- en: Stop the watch command, `kubectl get pod -l app=product -w`, and the load test
    program, `siege`, with *Ctrl* *+* *C*.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止`kubectl get pod -l app=product -w`命令（用于监控）和`siege`负载测试程序。
- en: 'Delete the namespace:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除命名空间：
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Shut down the resource managers that run outside of Kubernetes:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭运行在Kubernetes之外的资源管理器：
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `kubectl delete namespace` command will recursively delete all Kubernetes
    resources that existed in the namespace, and the `docker-compose down` command
    will stop MySQL, MongoDB, and RabbitMQ. With the production environment removed,
    we have reached the end of this chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl delete namespace`命令将递归删除命名空间中存在的所有Kubernetes资源，`docker-compose down`命令将停止MySQL、MongoDB和RabbitMQ。删除生产环境后，我们结束了这一章。'
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to deploy the microservices in this book on
    Kubernetes. We also introduced some core features in Kubernetes, such as using Kustomize to
    configure deployments for different runtime environments, using Kubernetes deployment
    objects for rolling upgrades, and how to roll back a failed update if required. To
    help Kubernetes understand when the microservices need to be restarted and if
    they are ready to accept requests, we implemented liveness and readiness probes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Kubernetes上部署本书中的微服务。我们还介绍了Kubernetes的一些核心功能，例如使用Kustomize为不同的运行时环境配置部署，使用Kubernetes部署对象进行滚动升级，以及如果需要如何回滚失败的更新。为了帮助Kubernetes了解何时需要重新启动微服务以及它们是否准备好接收请求，我们实现了生存和就绪探针。
- en: Finally, to be able to deploy our microservices, we had to replace Netflix Eureka
    with the built-in discovery service in Kubernetes. Changing the discovery service
    was done without any code changes – all we had to do was apply changes to the
    build dependencies and some of the configuration.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了能够部署我们的微服务，我们必须用 Kubernetes 内置的发现服务替换 Netflix Eureka。更改发现服务时，没有进行任何代码更改——我们所需要做的就是应用构建依赖项和一些配置的变化。
- en: In the next chapter, we will see how we can further utilize Kubernetes to reduce
    the number of supporting services we need to deploy in Kubernetes. Head over to
    the next chapter to see how we can eliminate the need for the configuration server
    and how our edge server can be replaced by a Kubernetes ingress controller.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何进一步利用 Kubernetes 来减少我们需要在 Kubernetes 中部署的支持服务的数量。翻到下一章，了解我们如何消除配置服务器的需求，以及我们的边缘服务器如何被
    Kubernetes 入口控制器所替代。
- en: Questions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why did we remove the Eureka server from the microservices landscape when deploying
    it on Kubernetes?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在将微服务部署到 Kubernetes 时删除了 Eureka 服务器？
- en: What did we replace the Eureka server with and how was the source code of the
    microservices affected by this change?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用什么替换了 Eureka 服务器，这次变更如何影响了微服务的源代码？
- en: How are base and overlay folders used with Kustomize?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kustomize 中 base 和 overlay 文件夹是如何使用的？
- en: How can we get a running pod updated with changes in a config map or secret?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将配置映射（config map）或机密（secret）中的更改应用到正在运行的 Pod？
- en: If we are using the latest tag on a Docker image, how can we get running pods
    using a new build of the Docker image?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们正在使用 Docker 镜像的最新标签，那么如何使用新的 Docker 镜像构建来运行正在运行的 Pod？
- en: What commands can we use to roll back a failed deployment?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些命令来回滚一个失败的部署？
- en: What's the purpose of liveness and readiness probes?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存活探针（liveness probes）和就绪探针（readiness probes）的目的是什么？
- en: What are the different ports that are being used in the following service definition?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下服务定义中使用了哪些不同的端口？
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
