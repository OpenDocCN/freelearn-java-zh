- en: Understanding Spring Database Interactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Spring数据库交互
- en: In previous chapters, we learned about Spring core features, such as **dependency
    injection** (DI) and its configuration. We also saw how we can implement reusable
    code with the help of Spring **Aspect-Oriented Programming** (**AOP**). We learned
    how we can develop loosely coupled web applications with the help of Spring **Model-View-Controller**
    (**MVC**), and how we can optimize Spring MVC implementation to achieve better
    results using asynchronous features, multithreading, and authentication caching.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了Spring核心特性，如**依赖注入**（DI）及其配置。我们还看到了如何利用Spring **面向切面编程**（**AOP**）实现可重用的代码。我们学习了如何利用Spring
    **模型-视图-控制器**（**MVC**）开发松耦合的Web应用程序，以及如何通过异步特性、多线程和认证缓存来优化Spring MVC实现以获得更好的结果。
- en: In this chapter, we will learn about database interaction with Spring Framework.
    Database interaction is the biggest bottleneck in application performance. Spring
    Framework supports all major data access technologies, such as **Java Database
    Connectivity** (**JDBC**) directly, any **object-relational mapping** (**ORM)**
    framework (such as Hibernate), the **Java Persistence API** (**JPA**), and others.
    We can choose any of the data access technologies to persist our application data.
    Here, we will explore database interaction with Spring JDBC. We will also learn
    about common performance traps with Spring JDBC and the best practices of database
    design. We will then take a look at Spring transaction management and optimal
    connection pooling configuration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Spring框架与数据库交互。数据库交互是应用程序性能中最大的瓶颈。Spring框架支持所有主要的数据访问技术，如**Java数据库连接**（**JDBC**）直接，任何**对象关系映射**（**ORM**）框架（如Hibernate），**Java持久化API**（**JPA**）等。我们可以选择任何数据访问技术来持久化我们的应用程序数据。在这里，我们将探讨Spring
    JDBC的数据库交互。我们还将学习Spring JDBC的常见性能陷阱和最佳的数据库设计实践。然后我们将看一下Spring事务管理和最佳的连接池配置。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Spring JDBC configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring JDBC配置
- en: Database design for optimal performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获得最佳性能的数据库设计
- en: Transaction management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理
- en: Declarative ACID using `@Transactional`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Transactional`进行声明性ACID
- en: Optimal isolation levels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳的隔离级别
- en: Optimal fetch size
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳的获取大小
- en: Optimal connection pooling configuration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳的连接池配置
- en: Tomcat JDBC connection pool versus HikariCP
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat JDBC连接池与HikariCP
- en: Database design best practices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库设计最佳实践
- en: Spring JDBC configuration
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring JDBC配置
- en: Without using JDBC, we cannot connect to a database using Java only. JDBC will
    be involved, either directly or indirectly, in connecting a database. But there
    are problems faced by Java programmers if they are working directly with core
    JDBC. Let's see what those problems are.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用JDBC，我们无法仅使用Java连接到数据库。JDBC将以直接或间接的方式涉及到连接数据库。但是，如果Java程序员直接使用核心JDBC，会面临一些问题。让我们看看这些问题是什么。
- en: Problems with core JDBC
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心JDBC的问题
- en: 'The following illustrates the problems that we have to face when we work with
    the core JDBC API:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用核心JDBC API时，我们将面临以下问题：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, I have highlighted some code. Only the code in bold
    format is important; the rest is plumbing code. So, we have to write that redundant
    code every time, to perform a database operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我已经突出显示了一些代码。只有粗体格式的代码是重要的；其余是冗余的代码。因此，我们必须每次都写这些冗余的代码来执行数据库操作。
- en: 'Let''s see some other problems with core JDBC:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看核心JDBC的其他问题：
- en: JDBC API exceptions are checked that forces the developers to handle errors,
    which increases the code, as well as the complexity, of the application
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC API异常是被检查的，这迫使开发人员处理错误，增加了应用程序的代码和复杂性
- en: In JDBC, we have to close the database connection; if the developer forgets
    to close the connection, then we get some connection issues in our application
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JDBC中，我们必须关闭数据库连接；如果开发人员忘记关闭连接，那么我们的应用程序就会出现一些连接问题
- en: Solving problems with Spring JDBC
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring JDBC解决问题
- en: 'To overcome the preceding problems with core JDBC, Spring Framework provides
    excellent database integration with the Spring JDBC module. Spring JDBC provides
    the `JdbcTemplate` class, which helps us to remove the plumbing code, and also
    helps the developer to concentrate only on the SQL query and parameters. We just
    need to configure the `JdbcTemplate` with a `dataSource` and write code like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服核心JDBC的前述问题，Spring框架提供了与Spring JDBC模块的出色数据库集成。Spring JDBC提供了`JdbcTemplate`类，它帮助我们去除冗余代码，并且帮助开发人员只专注于SQL查询和参数。我们只需要配置`JdbcTemplate`与`dataSource`，并编写如下代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we saw in the previous example, Spring provides a simplification for handling
    database access by using the JDBC template. The JDBC template uses core JDBC code
    internally and provides a new and efficient way to deal with the database. The
    Spring JDBC template has the following advantages, as compared to core JDBC:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中看到的，Spring通过使用JDBC模板简化了处理数据库访问的过程。JDBC模板在内部使用核心JDBC代码，并提供了一种新的高效的处理数据库的方式。与核心JDBC相比，Spring
    JDBC模板具有以下优势：
- en: The JDBC template cleans up the resources automatically, by releasing database
    connections
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC模板通过释放数据库连接自动清理资源
- en: It converts the core JDBC `SQLException` into `RuntimeExceptions`, which provides
    a better error detection mechanism
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将核心JDBC的`SQLException`转换为`RuntimeExceptions`，从而提供更好的错误检测机制
- en: The JDBC template provides various methods to write the SQL queries directly, so
    it saves a lot of work and time
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC模板提供了各种方法来直接编写SQL查询，因此节省了大量的工作和时间
- en: 'The following diagram shows a high-level overview of the Spring JDBC template:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了Spring JDBC模板的高级概述：
- en: '![](img/b5608665-5489-4ffc-b7cd-fef724395459.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5608665-5489-4ffc-b7cd-fef724395459.png)'
- en: 'The various approaches provided by the Spring JDBC for accessing the database
    are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring JDBC提供的用于访问数据库的各种方法如下：
- en: '`JdbcTemplate`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JdbcTemplate`'
- en: '`NamedParameterJdbcTemplate`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NamedParameterJdbcTemplate`'
- en: '`SimpleJdbcTemplate`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleJdbcTemplate`'
- en: '`SimpleJdbcInsert`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleJdbcInsert`'
- en: '`SimpleJdbcCall`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleJdbcCall`'
- en: Spring JDBC dependencies
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring JDBC依赖项
- en: 'The following are the Spring JDBC dependencies available in the `pom.xml` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Spring JDBC依赖项在`pom.xml`文件中可用如下：
- en: 'The following code is for the Spring JDBC dependency:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码是Spring JDBC的依赖项：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code is for the PostgreSQL dependency:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码是PostgreSQL依赖项：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have specified the dependency for Spring JDBC and
    PostgreSQL, respectively. The rest of the dependencies will be automatically resolved
    by Maven. Here, I am using the PostgreSQL database for our testing purposes, so
    I have added a PostgreSQL dependency. If you are using some other RDBMS, then
    you should make changes in the dependencies accordingly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们分别指定了Spring JDBC和PostgreSQL的依赖项。其余的依赖项将由Maven自动解析。在这里，我正在使用PostgreSQL数据库进行测试，所以我添加了一个PostgreSQL依赖项。如果您使用其他RDBMS，则应相应地更改依赖项。
- en: Spring JDBC example
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring JDBC示例
- en: 'In this example, we are using the PostgreSQL database. The table schema is
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用的是PostgreSQL数据库。表结构如下：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will use the DAO pattern for JDBC operations, so let''s create a Java bean
    that will model our `Account` table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用DAO模式进行JDBC操作，因此让我们创建一个Java bean来模拟我们的`Account`表：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following `AccountDao` interface declares the operation that we want to
    implement:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`AccountDao`接口声明了我们要实现的操作：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Spring bean configuration class is as follows. For bean configuration,
    simply annotate a method with the `@Bean` annotation. When `JavaConfig` finds
    such a method, it will execute that method and register the return value as a
    bean within `BeanFactory`. Here, we have registered `JdbcTemplate`, `dataSource`,
    and `AccountDao` beans:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Spring bean配置类如下。对于bean配置，只需使用`@Bean`注解注释一个方法。当`JavaConfig`找到这样的方法时，它将执行该方法并将返回值注册为`BeanFactory`中的bean。在这里，我们注册了`JdbcTemplate`、`dataSource`和`AccountDao`
    beans。
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous configuration file, we created a `DataSource` object of the
    class `DriverManagerDataSource`. This class provides a basic implementation of
    `DataSource` that we can use. We have also passed the PostgreSQL database URL,
    username, and password as properties to the `dataSource` bean. Also, the `dataSource`
    bean is set to the `AccountDaoImpl` bean, and we are ready with our Spring JDBC
    implementation. The implementation is loosely coupled, and if we want to switch
    to some other implementation or move to another database server, then we need
    to make changes only in the bean configuration. This is one of the major advantages
    provided by the Spring JDBC framework.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配置文件中，我们创建了`DriverManagerDataSource`类的`DataSource`对象。这个类提供了一个我们可以使用的`DataSource`的基本实现。我们还将PostgreSQL数据库的URL、用户名和密码作为属性传递给`dataSource`
    bean。此外，`dataSource` bean设置为`AccountDaoImpl` bean，我们的Spring JDBC实现已经准备就绪。该实现是松散耦合的，如果我们想要切换到其他实现或移动到另一个数据库服务器，那么我们只需要在bean配置中进行更改。这是Spring
    JDBC框架提供的主要优势之一。
- en: 'Here is the implementation of `AccountDAO` where we use the Spring `JdbcTemplate`
    class to insert data into the table:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`AccountDAO`的实现，我们在这里使用Spring的`JdbcTemplate`类将数据插入表中：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous example, we used the `org.springframework.jdbc.core.JdbcTemplate`
    class to access a persistence resource. The Spring `JdbcTemplate` is the central
    class in the Spring JDBC core package and provides a lot of methods to execute
    queries and automatically parse `ResultSet` to get the object or list of objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们使用了`org.springframework.jdbc.core.JdbcTemplate`类来访问持久性资源。Spring的`JdbcTemplate`是Spring
    JDBC核心包中的中心类，提供了许多方法来执行查询并自动解析`ResultSet`以获取对象或对象列表。
- en: 'The following is the test class for the preceding implementation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述实现的测试类：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we run the previous program, we get the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上一个程序时，我们会得到以下输出：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Database design for optimal performance
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了实现最佳性能的数据库设计
- en: Nowadays, it is very easy to design a database with the help of modern tools
    and processes, but we must know that it is a very crucial part of our application
    and it directly impacts the application performance. Once an application has been
    implemented with an inaccurate database design, it's too late to fix it. We have
    no other option but to buy expensive hardware to cope with the problem. So, we
    should be aware of some of the basic concepts and best practices of database table
    design, database partitioning, and good indexing, which improve our application's
    performance. Let's see the fundamental rules and best practices for developing
    high-performance database applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用现代工具和流程设计数据库非常容易，但我们必须知道这是我们应用程序的一个非常关键的部分，它直接影响应用程序的性能。一旦应用程序实施了不准确的数据库设计，要修复它就太晚了。我们别无选择，只能购买昂贵的硬件来应对问题。因此，我们应该了解一些数据库表设计、数据库分区和良好索引的基本概念和最佳实践，这些可以提高我们应用程序的性能。让我们看看开发高性能数据库应用程序的基本规则和最佳实践。
- en: Table design
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表设计
- en: The table design type can be normalized or denormalized, but each type has its
    own benefits. If the table design is normalized, it means that redundant data
    is eliminated, and data is logically stored with the primary key/foreign key relationship,
    which improves data integrity. If the table design is denormalized, it means increased
    data redundancy and creates inconsistent dependencies between tables. In the denormalized
    type, all of the data for a query is usually stored in a single row in the table;
    that's why it is faster to retrieve data and improves query performance. In the
    normalized type, we have to use joins in our queries to fetch the data from the
    database and, due to the joins, the performance of the query is impacted. Whether
    we should use normalization or denormalization totally depends on our application's
    nature and the business requirements. Normally, databases planned for **online
    transaction processing** (**OLTP**) are typically more normalized than databases
    planned for **online analytical processing** (**OLAP**). From a performance point
    of view, normalization is generally used where more `INSERT`/`UPDATE`/`DELETE`
    operations are required, while denormalization is used where more `READ` operations
    are required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表设计类型可以是规范化的或非规范化的，但每种类型都有其自身的好处。如果表设计是规范化的，意味着冗余数据被消除，数据以主键/外键关系逻辑存储，从而提高了数据完整性。如果表设计是非规范化的，意味着增加了数据冗余，并创建了表之间不一致的依赖关系。在非规范化类型中，查询的所有数据通常存储在表中的单行中；这就是为什么检索数据更快，提高了查询性能。在规范化类型中，我们必须在查询中使用连接来从数据库中获取数据，并且由于连接的存在，查询的性能受到影响。我们是否应该使用规范化或非规范化完全取决于我们应用的性质和业务需求。通常，为在线事务处理（OLTP）计划的数据库通常比为在线分析处理（OLAP）计划的数据库更规范化。从性能的角度来看，规范化通常用于需要更多的INSERT/UPDATE/DELETE操作的地方，而非规范化用于需要更多READ操作的地方。
- en: Vertical partitioning of a table
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表的垂直分区
- en: In the use of vertical partitioning, we split a table with many columns into
    multiple tables with particular columns. For example, we must not define very
    wide text or **binary large object** (**BLOB**) data columns infrequently queried
    tables because of performance issues. This data must be placed in a separate table
    structure, and a pointer can be used in queried tables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用垂直分区时，我们将具有许多列的表分割为具有特定列的多个表。例如，我们不应该在很少查询的表中定义非常宽的文本或二进制大对象（BLOB）数据列，因为性能问题。这些数据必须放置在单独的表结构中，并且可以在查询的表中使用指针。
- en: 'What follows is a simple example of how we can use vertical partitioning on
    a `customer` table and move a binary data type column, `customer_Image`, into
    a separate table:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个简单的示例，说明我们如何在customer表上使用垂直分区，并将二进制数据类型列customer_Image移入单独的表中：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Partition data vertically, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直分区数据如下：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In JPA/Hibernate, we can easily map the previous example with a lazy one-to-many
    relationship between the tables. The data usages of the `customer_Image` table
    are not frequent, so we can set it as lazily loaded. Its data is retrieved when
    a client requests the specific columns of the relationship.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在JPA/Hibernate中，我们可以很容易地将前面的示例映射为表之间的延迟一对多关系。customer_Image表的数据使用不频繁，因此我们可以将其设置为延迟加载。当客户端请求关系的特定列时，其数据将被检索。
- en: Use indexing
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引
- en: We should use indexes for frequently used queries on big tables because index
    functionality is one of the best ways to improve the read performance of a database
    schema. Index entries are stored in a sorted order, which helps when processing
    the `GROUP BY` and `ORDER BY` clauses. Without an index, a database has to perform
    sort operations at the time of query executions. Through indexes, we can minimize
    the query execution time and improve query performance, but we should take care
    when creating indexes on a table; there are certain drawbacks, as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为大表上频繁使用的查询使用索引，因为索引功能是改善数据库模式读性能的最佳方式之一。索引条目以排序顺序存储，这有助于处理GROUP BY和ORDER
    BY子句。没有索引，数据库在查询执行时必须执行排序操作。通过索引，我们可以最小化查询执行时间并提高查询性能，但在创建表上的索引时，我们应该注意，也有一些缺点。
- en: We should not create too many indexes on tables that update frequently because,
    at the time of any data modification on the table, indexing is also changed. We
    should use a maximum of four to five indexes on a table. If the table is read-only,
    then we can add more indexes without worrying.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该在频繁更新的表上创建太多索引，因为在表上进行任何数据修改时，索引也会发生变化。我们应该在表上最多使用四到五个索引。如果表是只读的，那么我们可以添加更多索引而不必担心。
- en: 'Here are the guidelines to build the most effective indexes for your application,
    which are valid for every database:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为您的应用程序构建最有效索引的指南，对每个数据库都适用：
- en: In order to achieve the maximum benefits of indexes, we should use indexes on
    appropriate columns. Indexes should be used on those columns that are frequently
    used in `WHERE`, `ORDER BY`, or `GROUP BY` clauses in queries.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实现索引的最大效益，我们应该在适当的列上使用索引。索引应该用于那些在查询的WHERE、ORDER BY或GROUP BY子句中频繁使用的列。
- en: Always choose integer data type columns for indexing because they provide better
    performance than other data type columns. Keep indexes small because short indexes
    are processed faster in terms of I/O.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终选择整数数据类型列进行索引，因为它们比其他数据类型列提供更好的性能。保持索引小，因为短索引在I/O方面处理更快。
- en: Clustered indexes are usually better for queries retrieving a range of rows.
    Non-clustered indexes are usually better for point queries.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于检索一系列行的查询，聚集索引通常更好。非聚集索引通常更适合点查询。
- en: Using the correct data type
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正确的数据类型
- en: A data type determines the type of data that can be stored in a database table
    column. When we create a table, we should define the proper data type for each
    column, as per its storage requirement. For example, a `SMALLINT` occupies 2 bytes
    of space, while an `INT` occupies 4 bytes of space. When we define the `INT` data
    type, it means that we must store all 4 bytes into that column every time. If
    we are storing a number like 10 or 20, then it's a waste of bytes. This will eventually
    make your reads slower because the database must read over multiple sectors of
    the disk. Also, choosing the right data type helps us store the right data into
    the column. For example, if we use the date data type for a column, then the database
    does not allow any string and numeric data in a column that does not represent
    a date.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型确定可以存储在数据库表列中的数据类型。当我们创建表时，应根据其存储需求为每个列定义适当的数据类型。例如，`SMALLINT`占用2个字节的空间，而`INT`占用4个字节的空间。当我们定义`INT`数据类型时，这意味着我们必须每次将所有4个字节存储到该列中。如果我们存储像10或20这样的数字，那么这是字节的浪费。这最终会使您的读取速度变慢，因为数据库必须读取磁盘的多个扇区。此外，选择正确的数据类型有助于我们将正确的数据存储到列中。例如，如果我们为列使用日期数据类型，则数据库不允许在不表示日期的列中插入任何字符串和数字数据。
- en: Defining column constraints
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义列约束
- en: Column constraints enforce limits on the data or types of data that can be inserted/updated/deleted
    from a table. The whole purpose of constraints is to maintain the data integrity
    during an `UPDATE`/`DELETE`/`INSERT` into a table. However, we should only define
    constraints where appropriate; otherwise, we will create a negative impact on
    performance. For example, defining `NOT NULL` constraints does not impose noticeable
    overhead during query processing, but defining `CHECK` constraints might create
    a negative effect on performance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列约束强制执行对表中可以插入/更新/删除的数据或数据类型的限制。约束的整个目的是在`UPDATE`/`DELETE`/`INSERT`到表中时维护数据完整性。但是，我们应该只在适当的地方定义约束；否则，我们将对性能产生负面影响。例如，定义`NOT
    NULL`约束在查询处理过程中不会产生明显的开销，但定义`CHECK`约束可能会对性能产生负面影响。
- en: Using stored procedures
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存储过程
- en: Data access performance can be tuned by using stored procedures to process data
    in the database server to reduce the network overhead, and also by caching data
    within your application to reduce the number of accesses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用存储过程在数据库服务器中处理数据来减少网络开销，以及通过在应用程序中缓存数据来减少访问次数，可以调整数据访问性能。
- en: Transaction management
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务管理
- en: 'A database transaction is a critical part of any application. A database transaction
    is a sequence of actions that are treated as a single unit of work. These actions
    should either be completed entirely or take no effect at all. The management of
    the sequence of actions is known as **transaction management**. Transaction management
    is an important part of any RDBMS-oriented enterprise applications, to ensure
    data integrity and consistency. The concept of transactions can be described with
    four key properties: **atomicity**, **consistency**, **isolation**, **and durability**
    (**ACID**).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库事务是任何应用程序的关键部分。数据库事务是一系列被视为单个工作单元的操作。这些操作应该完全完成或根本不产生任何效果。对操作序列的管理称为事务管理。事务管理是任何面向RDBMS的企业应用程序的重要部分，以确保数据完整性和一致性。事务的概念可以用四个关键属性来描述：原子性、一致性、隔离性和持久性（ACID）。
- en: 'Transactions are described as ACID, which stands for the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 事务被描述为ACID，代表以下内容：
- en: 'Atomicity: A transaction should be treated as a single unit of operation, which
    means that either the entire sequence of operations is completed, or it takes
    no effect at all'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子性：事务应被视为单个操作单元，这意味着要么整个操作序列完成，要么根本不起作用
- en: 'Consistency: Once a transaction is completed and committed, then your data
    and resources will be in a consistent state that conforms to business rules'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性：一旦事务完成并提交，那么您的数据和资源将处于符合业务规则的一致状态
- en: 'Isolation: If many transactions are being processed with the same dataset at
    the same time, then each transaction should be isolated from others to prevent
    data corruption'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离：如果同时处理同一数据集的许多事务，则每个事务应该与其他事务隔离开，以防止数据损坏
- en: 'Durability: Once a transaction has completed, the results of the transaction
    are written to persistent storage and cannot be erased from the database due to
    system failure'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性：一旦事务完成，事务的结果将被写入持久存储，并且由于系统故障无法从数据库中删除
- en: Choosing a transaction manager in Spring
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring中选择事务管理器
- en: Spring provides different transaction managers, based on different platforms.
    Here, a different platform means a different persistence framework, such as JDBC,
    MyBatis, Hibernate, and **Java Transaction API** (**JTA**). So, we have to choose
    the transaction manager provided by Spring accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了不同的事务管理器，基于不同的平台。这里，不同的平台意味着不同的持久性框架，如JDBC、MyBatis、Hibernate和Java事务API（JTA）。因此，我们必须相应地选择Spring提供的事务管理器。
- en: 'The following diagram describes platform-specific transaction management provided
    by Spring:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了Spring提供的特定于平台的事务管理：
- en: '![](img/dc325c62-bd48-4502-8b86-fc0af3e09694.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc325c62-bd48-4502-8b86-fc0af3e09694.jpg)'
- en: 'Spring supports two types of transaction management:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持两种类型的事务管理：
- en: 'Programmatic: This means that we can write our transactions using Java source
    code directly. This gives us extreme flexibility, but it is difficult to maintain.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化：这意味着我们可以直接使用Java源代码编写我们的事务。这给了我们极大的灵活性，但很难维护。
- en: Declarative: This means that we can manage transactions in either a centralized
    way, by using XML, or in a distributed way, by using annotations.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性：这意味着我们可以通过使用XML以集中的方式或者通过使用注释以分布式的方式来管理事务。
- en: Declarative ACID using @Transactional
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@Transactional声明性ACID
- en: Declarative transactions are highly recommended because they keep transaction
    management out of business logic and are easy to configure. Let's see an example
    of annotation-based declarative transaction management.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议使用声明式事务，因为它们将事务管理从业务逻辑中分离出来，并且易于配置。让我们看一个基于注解的声明式事务管理的示例。
- en: Let's use the same example that was used in the Spring JDBC section. In our
    example, we are using `JdbcTemplate` for database interaction. So, we need to
    add `DataSourceTransactionManager` in our Spring configuration file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在Spring JDBC部分中使用的相同示例。在我们的示例中，我们使用`JdbcTemplate`进行数据库交互。因此，我们需要在Spring配置文件中添加`DataSourceTransactionManager`。
- en: 'The following is the Spring bean configuration class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Spring bean配置类：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code, we created a `dataSource` bean. It is used to create the
    `DataSource` object. Here, we need to provide the database configuration properties,
    such as `DriverClassName`, `Url`, `Username`, and `Password`. You can change these
    values based on your local settings.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们创建了一个`dataSource` bean。它用于创建`DataSource`对象。在这里，我们需要提供数据库配置属性，比如`DriverClassName`、`Url`、`Username`和`Password`。您可以根据您的本地设置更改这些值。
- en: We are using JDBC to interact with the database; that is why we have created
    a `transactionManager` bean of the type `org.springframework.jdbc.datasource.DataSourceTransactionManager`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用JDBC与数据库交互；这就是为什么我们创建了一个`transactionManager`类型为`org.springframework.jdbc.datasource.DataSourceTransactionManager`的bean。
- en: The `@EnableTransactionManagement` annotation is used to turn on transaction
    support in our Spring application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableTransactionManagement`注解用于在我们的Spring应用程序中启用事务支持。'
- en: 'The following is an `AccountDao` implementation class to create a record in
    an `Account` table:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`AccountDao`实现类，用于在`Account`表中创建记录：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code, we provided declarative transaction management through
    annotating the `insertAccountWithJdbcTemplate()` method with the `@Transactional`
    annotation. The `@Transactional` annotation can be used with a method, as well
    as at the class level. In the previous code, I threw the `RuntimeException` exception
    after inserting `Account`, to check how the transaction will be rolled back after
    an exception is generated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过在`insertAccountWithJdbcTemplate()`方法上注释`@Transactional`提供了声明式事务管理。`@Transactional`注解可以用于方法，也可以用于类级别。在前面的代码中，我在插入`Account`后抛出了`RuntimeException`异常，以检查在生成异常后事务将如何回滚。
- en: 'The following is the `main` class to check our transaction management implementation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于检查我们的事务管理实现的`main`类：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, when we run the preceding code, we get the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行上面的代码时，我们会得到以下输出：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous log, data is inserted into the `Account` table successfully.
    But, if you check the `Account` table, you won't find a row there, which means
    that the transaction is rolled back completely after `RuntimeException`. Spring
    Framework is committing the transaction only if the method returns successfully.
    If there is an exception, it rolls back the whole transaction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的日志中，数据成功插入到`Account`表中。但是，如果您检查`Account`表，您将找不到一行数据，这意味着在`RuntimeException`之后事务完全回滚。Spring框架仅在方法成功返回时才提交事务。如果出现异常，它将回滚整个事务。
- en: Optimal isolation levels
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳隔离级别
- en: As we learned in the previous section, the concept of a transaction is described
    with ACID. Transaction isolation level is a concept that is not limited to Spring
    Framework but is applicable to any application that interacts with a database.
    The isolation level defines how the changes made to some data repository by one
    transaction affect other concurrent transactions, and also how and when that changed
    data becomes available to other transactions. In Spring Framework, we define the
    isolation level of a transaction along with the `@Transaction` annotation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中学到的，事务的概念是用ACID描述的。事务隔离级别是一个概念，不仅适用于Spring框架，而且适用于与数据库交互的任何应用程序。隔离级别定义了一个事务对某个数据存储库所做的更改如何影响其他并发事务，以及更改的数据何时以及如何对其他事务可用。在Spring框架中，我们与`@Transaction`注解一起定义事务的隔离级别。
- en: 'The following snippet is an example of how we can define the `isolation` level
    in a transactional method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段是一个示例，说明我们如何在事务方法中定义`隔离`级别：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we defined a method with a transaction `isolation` level
    of `READ_UNCOMMITTED`. This means that the transaction in this method is executed
    with that `isolation` level.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了一个具有`READ_UNCOMMITTED`隔离级别的事务方法。这意味着该方法中的事务是以该隔离级别执行的。
- en: Let's see each `isolation` level in detail in the following sections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下部分详细看一下每个`隔离`级别。
- en: Read uncommitted
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取未提交
- en: Read uncommitted is the lowest isolation level. This isolation level defines
    that a transaction may read data that is still uncommitted by other transactions,
    which means that the data is not consistent with other parts of the table or the
    query. This isolation level ensures the quickest performance because data is read
    from a table block directly, and there is no need for further processing, validation,
    or other verification; but it may lead to some issues, such as dirty reads.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 读取未提交是最低的隔离级别。这种隔离级别定义了事务可以读取其他事务仍未提交的数据，这意味着数据与表或查询的其他部分不一致。这种隔离级别确保了最快的性能，因为数据直接从表块中读取，不需要进一步处理、验证或其他验证；但可能会导致一些问题，比如脏读。
- en: 'Let''s see the following diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图表：
- en: '![](img/ec6551f4-f0be-4a36-b21d-0bce9c32033e.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec6551f4-f0be-4a36-b21d-0bce9c32033e.png)'
- en: In the preceding diagram, **Transaction A** writes data; meanwhile, **Transaction
    B** reads that same data before **Transaction A** commits it. Later, **Transaction
    A** decides to **rollback**, due to some exception. Now, the data in **Transaction
    B** is inconsistent. Here, **Transaction B** was running in a `READ_UNCOMMITTED`
    isolation level, so it was able to read data from **Transaction A** before a commit
    occurred.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，**事务A**写入数据；与此同时，**事务B**在**事务A**提交之前读取了相同的数据。后来，**事务A**由于某些异常决定**回滚**。现在，**事务B**中的数据是不一致的。在这里，**事务B**运行在`READ_UNCOMMITTED`隔离级别，因此它能够在提交之前从**事务A**中读取数据。
- en: Note that `READ_UNCOMMITTED` can also create issues like **non-repeatable reads**
    and **phantom reads**. A non-repeatable read occurs when a transaction isolation
    selected as `READ_COMMITTED`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`READ_UNCOMMITTED`也可能会产生不可重复读和幻读等问题。当事务隔离级别选择为`READ_COMMITTED`时，就会出现不可重复读。
- en: Let's see the `READ_COMMITTED` isolation level in detail.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看`READ_COMMITTED`隔离级别。
- en: Read committed
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读已提交
- en: The read committed isolation level defines that a transaction can't read data
    that is not committed by other transactions. This means that the dirty read is
    no longer an issue, but other issues may occur.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 读已提交隔离级别定义了事务不能读取其他事务尚未提交的数据。这意味着脏读不再是一个问题，但可能会出现其他问题。
- en: 'Let''s see the following diagram:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下的图表：
- en: '![](img/9d62954e-612a-4509-9657-0faac6ad332c.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d62954e-612a-4509-9657-0faac6ad332c.png)'
- en: In this example, **Transaction A** reads some data. Then, **Transaction B**
    writes that same data and commits. Later, **Transaction A** reads that same data
    again and may get different values, because **Transaction B** already made changes
    to that data and committed. This is a non-repeatable read.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**事务A**读取了一些数据。然后，**事务B**写入了相同的数据并提交。后来，**事务A**再次读取相同的数据，可能会得到不同的值，因为**事务B**已经对数据进行了更改并提交。这就是不可重复读。
- en: Note that `READ_COMMITTED` can also create issues like **phantom reads**. A
    phantom reads occurs when a transaction isolation is selected as `REPEATABLE_READ`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`READ_COMMITTED`也可能会产生幻读等问题。幻读发生在选择`REPEATABLE_READ`作为事务隔离级别时。
- en: Let's see the `REPEATABLE_READ` isolation level in detail.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看`REPEATABLE_READ`隔离级别。
- en: Repeatable read
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重复读
- en: The `REPEATABLE_READ` isolation level defines that if a transaction reads one
    record from the database multiple times, the results of all of those reading operations
    must be the same. This isolation helps us to prevent issues like dirty reads and
    non-repeatable reads, but it may create another issue.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`REPEATABLE_READ`隔离级别定义了如果一个事务多次从数据库中读取一条记录，那么所有这些读取操作的结果必须相同。这种隔离有助于防止脏读和不可重复读等问题，但可能会产生另一个问题。'
- en: 'Let''s see the following diagram:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下的图表：
- en: '![](img/d654c888-d00c-4dbe-b0cd-22b71cb75d56.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d654c888-d00c-4dbe-b0cd-22b71cb75d56.png)'
- en: In this example, **Transaction A** reads a range of data. Simultaneously, **Transaction
    B** inserts new data in the same range that **Transaction A** initially fetched
    and commits. Later, **Transaction A** reads the same range again and will also
    get the record that **Transaction B** just inserted. This is a phantom read. Here,
    **Transaction A** fetched a range of records from the database multiple times and
    got different result sets.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**事务A**读取了一段数据。与此同时，**事务B**在相同的范围内插入了新数据，**事务A**最初获取并提交了。后来，**事务A**再次读取相同的范围，也会得到**事务B**刚刚插入的记录。这就是幻读。在这里，**事务A**多次从数据库中获取了一系列记录，并得到了不同的结果集。
- en: Serializable
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可串行化
- en: The serializable isolation level is the highest and more restrictive of all
    isolation levels. It protects against dirty, non-repeatable reads and phantom
    reads. Transactions are executed with locking at all levels (**read**, **range**,
    and **write** locking), so they appear as if they were executed in a serialized
    way. In serializable isolation, we will ensure that no issues will happen, but
    concurrently executing transactions occurs to be serially executing that degrade
    the performance of the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可串行化隔离级别是所有隔离级别中最高和最严格的。它可以防止脏读、不可重复读和幻读。事务在所有级别（读、范围和写锁定）上都会执行锁定，因此它们看起来就像是以串行方式执行的。在可串行化隔离中，我们将确保不会发生问题，但同时执行的事务会被串行执行，从而降低了应用程序的性能。
- en: 'The following is a summary of the relationships between isolation levels and
    read phenomena:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是隔离级别和读现象之间关系的总结：
- en: '| **Levels** | **Dirty reads** | **Non-repeatable reads** | **Phantom reads**
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **脏读** | **不可重复读** | **幻读** |'
- en: '| `READ_UNCOMMITTED` | Yes | Yes | Yes |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `READ_UNCOMMITTED` | 是 | 是 | 是 |'
- en: '| `READ_COMMITTED` | No | Yes | Yes |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `READ_COMMITTED` | 否 | 是 | 是 |'
- en: '| `REPEATABLE_READ` | No | No | Yes |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `REPEATABLE_READ` | 否 | 否 | 是 |'
- en: '| `SERIALIZABLE` | No | No | No |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `SERIALIZABLE` | 否 | 否 | 否 |'
- en: If the isolation level is not explicitly set, then the transaction uses a default
    isolation level, as per the related database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果隔离级别没有被明确设置，那么事务将使用默认的隔离级别，根据相关数据库的设置。
- en: Optimal fetch size
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳的获取大小
- en: The network traffic between the application and the database server is one of
    the key factors of your application performance. If we can reduce the traffic,
    it will help us improve the performance of the application. The fetch size is
    the number of rows retrieved from the database at one time. It depends on the
    JDBC driver. The default fetch size of most of the JDBC drivers is 10\. In normal
    JDBC programming, if you want to retrieve 1,000 rows, then you will need 100 network
    round-trips between the application and database server to retrieve all of the
    rows. It will increase the network traffic, and also impact performance. But if
    we set the fetch size to 100, then the number of network round-trips will be 10\.
    This will greatly improve the performance of your application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序与数据库服务器之间的网络流量是应用程序性能的关键因素之一。如果我们能减少流量，将有助于提高应用程序的性能。获取大小是一次从数据库中检索的行数。它取决于JDBC驱动程序。大多数JDBC驱动程序的默认获取大小为10。在正常的JDBC编程中，如果要检索1000行，那么您将需要在应用程序和数据库服务器之间进行100次网络往返以检索所有行。这将增加网络流量，也会影响性能。但是，如果我们将获取大小设置为100，那么网络往返的次数将为10。这将极大地提高您的应用程序性能。
- en: Many frameworks, such as Spring or Hibernate, give you very convenient APIs
    to do this. If we do not set the fetch size, then it will take the default value
    and provide poor performance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多框架，如Spring或Hibernate，为您提供非常方便的API来执行此操作。如果我们不设置获取大小，那么它将采用默认值并提供较差的性能。
- en: 'The following sets the `FetchSize`, with standard JDBC calls:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用标准JDBC调用设置`FetchSize`的方法：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous code, we can set the fetch size on each `Statement` or `PreparedStatement`,
    or even on `ResultSet`. By default, `ResultSet` uses the fetch size of `Statement`; `Statement`
    and `PreparedStatement` use the fetch size of a specific JDBC driver.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以在每个`Statement`或`PreparedStatement`上设置获取大小，甚至在`ResultSet`上设置。默认情况下，`ResultSet`使用`Statement`的获取大小；`Statement`和`PreparedStatement`使用特定JDBC驱动程序的获取大小。
- en: 'We can also set the `FetchSize` in the Spring `JdbcTemplate`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在Spring的`JdbcTemplate`中设置`FetchSize`：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following points should be considered when setting the fetch size:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 设置获取大小时应考虑以下几点：
- en: Make sure that your JDBC driver supports configuring the fetch size
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的JDBC驱动程序支持配置获取大小。
- en: The fetch size should not be hardcoded; keep it configurable because it depends
    on JVM heap memory size, which varies with different environments
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取大小不应该是硬编码的；保持可配置，因为它取决于JVM堆内存大小，在不同环境中会有所不同
- en: If the fetch size is large, the application might encounter an out of memory
    issue
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果获取的大小很大，应用程序可能会遇到内存不足的问题
- en: Optimal connection pooling configuration
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳连接池配置
- en: JDBC uses a connection pool when accessing a database. **Connection pooling**
    is similar to any other form of object pooling. Connection pooling usually involves
    little or no code modification, but it can provide significant benefits in terms
    of application performance. Database connection performs the various task while
    creating, such as initializing a session in the database, performing user authentication
    and establishing transaction contexts. Creating a connection is not a zero cost
    process; therefore, we should create connections in an optimal way and reduce
    impacts on performance. A connection pool allows for the reuse of physical connections
    and minimizes expensive operations in the creation and closure of sessions. Also,
    maintaining many idle connections is expensive for a database management system,
    and the pool can optimize the usage of idle connections or disconnect those no
    longer used.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC在访问数据库时使用连接池。**连接池**类似于任何其他形式的对象池。连接池通常涉及很少或没有代码修改，但它可以在应用程序性能方面提供显着的好处。数据库连接在创建时执行各种任务，例如在数据库中初始化会话、执行用户身份验证和建立事务上下文。创建连接不是零成本的过程；因此，我们应该以最佳方式创建连接，并减少对性能的影响。连接池允许重用物理连接，并最小化创建和关闭会话的昂贵操作。此外，对于数据库管理系统来说，维护许多空闲连接是昂贵的，连接池可以优化空闲连接的使用或断开不再使用的连接。
- en: 'Why is pooling useful? Here are a few reasons:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么连接池有用？以下是一些原因：
- en: Frequently opening and closing connections can be expensive; it is better to
    cache and reuse.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁打开和关闭连接可能很昂贵；最好进行缓存和重用。
- en: We can limit the number of connections to the database. This will stop from
    accessing a connection until it is available. This is especially helpful in distributed
    environments.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以限制对数据库的连接数。这将阻止在连接可用之前访问连接。这在分布式环境中特别有帮助。
- en: We can use multiple connection pools for common operations, based on our requirements.
    We can design one connection pool for OLAP and another for OLAP, each with different
    configurations.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们的需求，我们可以为常见操作使用多个连接池。我们可以为OLAP设计一个连接池，为OLAP设计另一个连接池，每个连接池都有不同的配置。
- en: In this section, we will see what the optimal connection pooling configuration
    is, to help improve the performance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到最佳的连接池配置是什么，以帮助提高性能。
- en: 'The following is a simple connection pool configuration for PostgreSQL:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于PostgreSQL的简单连接池配置：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sizing the connection pool
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整连接池的大小
- en: 'We need to work with the following attributes to size the connection pool:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用以下属性来调整连接池的大小：
- en: '`initialSize`: The `initialSize` attribute defines the number of connections
    that will be established when the connection pool is started.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialSize`：`initialSize`属性定义了连接池启动时将建立的连接数。'
- en: '`maxActive`: The `maxActive` attribute can be used to limit the maximum number
    of established connections to the database.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxActive`：`maxActive`属性可用于限制与数据库建立的最大连接数。'
- en: '`maxIdle`: The `maxIdeal` attribute is used to maintain the maximum number
    of idle connections in the pool at all times.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxIdle`：`maxIdeal`属性用于始终保持池中空闲连接的最大数量。'
- en: '`minIdle`: The `minIdeal` attribute is used to maintain the minimum number
    of idle connections in the pool at all times.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minIdle`：`minIdeal`属性用于始终保持池中空闲连接的最小数量。'
- en: '`timeBetweenEvictionRunsMillis`: The validation/cleaner thread runs every `timeBetweenEvictionRunsMillis`
    milliseconds. It''s a background thread that can test idle, abandoned connections,
    and resize the pool while the pool is active. The thread is also responsible for
    connection leak detection. This value should not be set below 1 second.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeBetweenEvictionRunsMillis`：验证/清理线程每隔`timeBetweenEvictionRunsMillis`毫秒运行一次。这是一个后台线程，可以测试空闲的废弃连接，并在池处于活动状态时调整池的大小。该线程还负责检测连接泄漏。此值不应设置为低于1秒。'
- en: '`minEvictableIdleTimeMillis`: The minimum amount of time an object may sit
    idle in the pool before it is eligible for eviction.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minEvictableIdleTimeMillis`：对象在池中空闲的最短时间。'
- en: Validate connections
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证连接
- en: The advantage of setting this configuration is that an invalid connection will
    never be used, and it helps us to prevent client errors. The disadvantage of this
    configuration is a small performance penalty because to validate the connection,
    one round-trip to the database is required to check whether the session is still
    active. The validation is accomplished via sending a small query to the server,
    but the cost of this query could be lower.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此配置的优势是无效的连接永远不会被使用，并且有助于防止客户端错误。此配置的缺点是性能会有一些损失，因为要验证连接，需要向数据库发送一次往返的查询来检查会话是否仍然活动。验证是通过向服务器发送一个小查询来完成的，但此查询的成本可能较低。
- en: 'The configuration parameters for validating connections are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 用于验证连接的配置参数如下：
- en: '`testOnBorrow`: When the `testOnBorrow` attribute is defined as true, the connection
    object is validated before use. If it fails to validate, it will be dropped into
    the pool, and another connection object will be chosen. Here, we need to make
    sure that the `validationQuery` attribute is not null; otherwise, there is no
    effect on configuration.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testOnBorrow`：当定义`testOnBorrow`属性为true时，在使用连接对象之前会对其进行验证。如果验证失败，连接对象将被放回池中，然后选择另一个连接对象。在这里，我们需要确保`validationQuery`属性不为空；否则，配置不会产生任何效果。'
- en: '`validationInterval`: The `validationInterval` attribute defines the frequency
    of the validating connection. It should not be more than 34 seconds. If we set
    a larger value, it will improve the application performance, but will also increase
    the chances of a stale connection being present in our application.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validationInterval`：`validationInterval`属性定义验证连接的频率。它不应超过34秒。如果设置一个较大的值，将提高应用程序的性能，但也会增加应用程序中存在陈旧连接的机会。'
- en: '`validationQuery`: The `SELECT 1` PostgreSQL query is used to validate connections
    from the pool before sending them to serve a request.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validationQuery`：在将连接发送到服务请求之前，使用`SELECT 1` PostgreSQL查询来验证连接池中的连接。'
- en: Connection leaks
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接泄漏
- en: 'The following configuration settings can help us to detect connection leaks:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置设置可以帮助我们检测连接泄漏：
- en: '`removeAbandoned`: This flag should be true. It means that abandoned connections
    are removed if they exceed `removeAbandonedTimeout`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeAbandoned`：此标志应为true。这意味着如果连接超过`removeAbandonedTimeout`，则会删除废弃的连接。'
- en: '`removeAbandonedTimeout`: This is in seconds. A connection is considered abandoned
    if it''s running more than `removeAbandonedTimeout`. The value depends on the
    longest running query in your applications.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeAbandonedTimeout`：以秒为单位。如果连接运行时间超过`removeAbandonedTimeout`，则认为连接已被废弃。该值取决于应用程序中运行时间最长的查询。'
- en: 'So, in order to get optimal pool sizing, we need to modify our configuration
    to meet one of following conditions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获得最佳的池大小，我们需要修改我们的配置以满足以下条件之一：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tomcat JDBC connection pool versus HikariCP
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tomcat JDBC连接池与HikariCP
- en: There are many open source connection pool libraries available, such as C3P0,
    Apache Commons DBCP, BoneCP, Tomcat, Vibur, and Hikari. But which one to use depends
    on certain criteria. The following criteria will help to decide which connection
    pool to go with.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开源连接池库可用，如C3P0、Apache Commons DBCP、BoneCP、Tomcat、Vibur和Hikari。但要使用哪一个取决于某些标准。以下标准将帮助决定使用哪个连接池。
- en: Reliability
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性
- en: 'Performance is always good, but the reliability of a library is always more
    important than performance. We should not go with a library that gives a higher
    performance but is not reliable. The following things should be considered when
    selecting a library:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 性能总是很好，但是库的可靠性总是比性能更重要。我们不应该选择一个性能更高但不可靠的库。在选择库时应考虑以下事项：
- en: How widely it is used?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被广泛使用吗？
- en: How is the code maintained?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是如何维护的？
- en: The number of outstanding bugs open in the library.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库中尚未解决的bug数量。
- en: It's community of developers and users.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者和用户的社区。
- en: How active is the library development?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库的开发活跃程度如何？
- en: Performance
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: Performance is also considered important criteria. The performance of the library
    depends on how it is configured, and the environment in which it is tested. We
    need to make sure that the library that we choose will have good performance in
    our own environment, with our own configurations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 性能也被视为重要标准。库的性能取决于其配置方式以及测试环境。我们需要确保我们选择的库在我们自己的环境中，以我们自己的配置具有良好的性能。
- en: Features
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能
- en: It is also important to look at the features provided by the library. We should
    check all parameters, and also check the default value of the parameters if we
    don't provide them. Also, we need to look at some of the connection strategies,
    such as auto-commit, isolation level, and statement caching.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 查看库提供的功能也很重要。我们应该检查所有参数，还要检查参数的默认值（如果我们没有提供）。此外，我们需要查看一些连接策略，如自动提交、隔离级别和语句缓存。
- en: Ease of use
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易用性
- en: It is important how easily we can configure the connection pool with the use
    of a library. Also, it should be well documented and frequently updated.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库时如何轻松配置连接池也很重要。此外，它应该有良好的文档和经常更新。
- en: 'The following table lists the differences between a Tomcat JDBC connection
    pool and HikariCP:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表列出了Tomcat JDBC连接池和HikariCP之间的区别：
- en: '| **Tomcat JDBC** | **HikariCP** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **Tomcat JDBC** | **HikariCP** |'
- en: '| Does not test connections on `getConnection()` by default. | Tests connections
    on `getConnection()`. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 默认情况下不在`getConnection()`上测试连接。 | 在`getConnection()`上测试连接。 |'
- en: '| Does not close abandoned open statements. | Tracks and closes abandoned connections.
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 不关闭被遗弃的打开语句。 | 跟踪并关闭被遗弃的连接。 |'
- en: '| Does not by default reset auto-commit and transaction levels for connections
    in the pool; users must configure custom interceptors to do this. | Resets auto-commit,
    transaction isolation, and read-only status. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 默认情况下不重置连接池中连接的自动提交和事务级别；用户必须配置自定义拦截器来执行此操作。 | 重置自动提交、事务隔离和只读状态。 |'
- en: '| Pool prepared statement properties are not used. | We can use pool prepared
    statement properties. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 不使用池准备语句属性。 | 我们可以使用池准备语句属性。 |'
- en: '| Does not, by default, execute a `rollback()` on connections returned to the
    pool. | By default, executes a `rollback()` on connections returned to the pool.
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 默认情况下不在连接返回到池中执行`rollback()`。 | 默认情况下在连接返回到池中执行`rollback()`。 |'
- en: Database interaction best practices
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库交互最佳实践
- en: This section lists some basic rules that developers should be aware of when
    developing any applications. A failure to follow the rules will result in a poorly
    performing application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了开发人员在开发任何应用程序时应该注意的一些基本规则。不遵循这些规则将导致性能不佳的应用程序。
- en: Using Statement versus PreparedStatement versus CallableStatement
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Statement与PreparedStatement与CallableStatement
- en: 'Choose between the `Statement`, `PreparedStatement`, and `CallableStatement`
    interfaces; it depends on how you plan to use the interface. The `Statement` interface
    is optimized for a single execution of an SQL statement, while the `PreparedStatement`
    object is optimized for SQL statements that will be executed multiple times, and
    `CallableStatement` is generally preferred for executing stored procedures:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Statement`、`PreparedStatement`和`CallableStatement`接口之间的区别；这取决于你计划如何使用接口。`Statement`接口针对单次执行SQL语句进行了优化，而`PreparedStatement`对象针对将被多次执行的SQL语句进行了优化，`CallableStatement`通常用于执行存储过程：
- en: '`Statement`: The `PreparedStatement` is used to execute normal SQL queries.
    It is preferred when a particular SQL query is to be executed only once. The performance
    of this interface is very low.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Statement`：`PreparedStatement`用于执行普通的SQL查询。当特定的SQL查询只需执行一次时，它是首选的。该接口的性能非常低。'
- en: '`PreparedStatement`: The `PreparedStatement` interface is used to execute parametrized
    or dynamic SQL queries. It is preferred when a particular query is to be executed
    multiple times. The performance of this interface is better than the `Statement`
    interface (when used for multiple executions of the same query).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreparedStatement`：`PreparedStatement`接口用于执行参数化或动态SQL查询。当特定查询需要多次执行时，它是首选的。该接口的性能优于`Statement`接口（用于多次执行相同查询时）。'
- en: '`CallableStatement`: The `CallableStatement` interface is preferred when the
    stored procedures are to be executed. The performance of this interface is high.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallableStatement`：当要执行存储过程时，首选`CallableStatement`接口。该接口的性能很高。'
- en: Using Batch instead of PreparedStatement
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用批处理而不是PreparedStatement
- en: Inserting a large amount of data into a database is typically done by preparing
    an `INSERT` statement and executing that statement multiple times. This increases
    the number of JDBC calls and impacts the performance. To reduce the number of
    JDBC calls and improve the performance, you can send multiple queries to the database
    at a time by using the `addBatch` method of the `PreparedStatement` object.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据库插入大量数据通常是通过准备一个`INSERT`语句并多次执行该语句来完成的。这会增加JDBC调用的次数并影响性能。为了减少JDBC调用的次数并提高性能，可以使用`PreparedStatement`对象的`addBatch`方法一次向数据库发送多个查询。
- en: 'Let''s look at the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding example, `PreparedStatement` is used to execute an `INSERT`
    statement multiple times. For executing the preceding `INSERT` operation, 101
    network round-trips are required: one to prepare the statement, and the remaining
    100 to execute the `INSERT` SQL statement. So, inserting and updating a large
    amount of data actually increases network traffic and, due to that, impacts performance.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`PreparedStatement`用于多次执行`INSERT`语句。为了执行前面的`INSERT`操作，需要101次网络往返：一次是为了准备语句，其余100次是为了执行`INSERT`
    SQL语句。因此，插入和更新大量数据实际上会增加网络流量，并因此影响性能。
- en: 'Let''s see how we can reduce the network traffic and improve performance with
    the use of `Batch`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过使用“批处理”来减少网络流量并提高性能：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the previous example, I used the `addBatch()` method. It consolidates all
    100 `INSERT` SQLs and executes the entire operation with only two network round-trips:
    one for preparing the statement and another for executing the batch of consolidated
    SQLs.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我使用了`addBatch()`方法。它将所有100个`INSERT` SQL语句合并并仅使用两次网络往返来执行整个操作：一次是为了准备语句，另一次是为了执行合并的SQL语句批处理。
- en: Minimizing the use of database metadata methods
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化数据库元数据方法的使用
- en: 'Although almost no JDBC application can be written without database metadata
    methods, compared to other JDBC methods, database metadata methods are slow. When
    we use a metadata method, a `SELECT` statement makes two round-trips to the database:
    one for metadata, and the second for the data. This is very performance expensive.
    We can improve the performance by minimizing the use of metadata methods.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管几乎没有JDBC应用程序可以在没有数据库元数据方法的情况下编写，但与其他JDBC方法相比，数据库元数据方法很慢。当我们使用元数据方法时，`SELECT`语句会使数据库进行两次往返：一次是为了元数据，另一次是为了数据。这是非常耗费性能的。我们可以通过最小化元数据方法的使用来提高性能。
- en: An application should cache all metadata, as they will not change, so multiple
    executions are not needed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该缓存所有元数据，因为它们不会改变，所以不需要多次执行。
- en: Using get methods effectively
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效使用get方法
- en: JDBC provides different types of methods to retrieve data from a result set,
    such as `getInt`, `getString`, and `getObject`; the `getObject` method is the
    generic one, and you can use it for all data types. But, we should always avoid
    the use of `getObject` because it gives worse performance than others. When we
    get data with the use of `getObject`, the JDBC driver must perform extra processing
    to determine the type of value being fetched and generate the appropriate mapping.
    We should always use the specific method for the data type; this provides better
    performance than using a generic one like `getObject`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC提供了不同类型的方法来从结果集中检索数据，如`getInt`，`getString`和`getObject`；`getObject`方法是通用的，可以用于所有数据类型。但是，我们应该始终避免使用`getObject`，因为它的性能比其他方法差。当我们使用`getObject`获取数据时，JDBC驱动程序必须执行额外的处理来确定正在获取的值的类型，并生成适当的映射。我们应该始终使用特定数据类型的方法；这比使用`getObject`等通用方法提供更好的性能。
- en: We can also improve the performance by using a column number instead of a column
    name; for example, `getInt(1)`, `getString(2)`, and `getLong(3)`. If we are using
    a column name instead of a column number (for example, `getString("accountName")`),
    then the database driver first converts the column name to uppercase (if required),
    then compares `accountName` with all columns available in the result set. This
    processing time directly impacts performance. We should reduce that processing
    time with the use of column numbers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用列号而不是列名来提高性能；例如，`getInt(1)`，`getString(2)`和`getLong(3)`。如果我们使用列名而不是列号（例如，`getString("accountName")`），那么数据库驱动程序首先将列名转换为大写（如果需要），然后将`accountName`与结果集中的所有列进行比较。这个处理时间直接影响性能。我们应该通过使用列号来减少处理时间。
- en: When to avoid connection pooling
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免连接池的时机
- en: 'The use of connection pooling on certain kinds of applications can definitely
    degrade the performance. If your application has any of the following characteristics,
    it is not a suitable candidate for connection pooling:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些类型的应用程序上使用连接池肯定会降低性能。如果您的应用程序具有以下任何特征，则不适合连接池：
- en: If an application restarts many times daily, we should avoid connection pooling
    because, based on the configuration of the connection pool, it may be populated
    with connections each time the application is started, which would cause a performance
    penalty up front.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个应用程序每天重新启动多次，我们应该避免连接池，因为根据连接池的配置，每次启动应用程序时都可能会填充连接，这将导致前期性能损失。
- en: If you have single-user applications, such as applications only generating reports
    (in this type of application, the user only uses the application three to four
    times daily, for generating reports), then avoid connection pooling. The memory
    utilization for establishing a database connection three to four times daily is
    low, compared to the database connection associated with a connection pool. In
    such cases, configuring a connection pool degrades the overall performance of
    the application.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有单用户应用程序，比如只生成报告的应用程序（在这种类型的应用程序中，用户每天只使用应用程序三到四次，用于生成报告），则应避免连接池。与与连接池相关的数据库连接相比，每天建立数据库连接的内存利用率较低。在这种情况下，配置连接池会降低应用程序的整体性能。
- en: If an application runs only batch jobs, there is no advantage to using connection
    pooling. Normally, a batch job is run at the end of the day or month or year,
    during the off hours, when performance is not as much of a concern.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个应用程序只运行批处理作业，则使用连接池没有任何优势。通常，批处理作业是在一天、一个月或一年的结束时运行，在性能不那么重要的时候运行。
- en: Choose commit mode carefully
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎选择提交模式
- en: When we commit a transaction, the database server must write the changes made
    by the transaction to the database. This involves expensive disk input/output
    and the driver need to send requests over the socket.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交事务时，数据库服务器必须将事务所做的更改写入数据库。这涉及昂贵的磁盘输入/输出和驱动程序需要通过套接字发送请求。
- en: In most standard APIs, the default commit mode is auto-commit. In the auto-commit
    mode, the database performs a commit for each SQL statement, such as `INSERT`,
    `UPDATE`, `DELETE`, and `SELECT` statements. The database driver sends a commit
    request to the database after each SQL statement operation. This request requires
    one network round-trip. The round-trip to the database occurs even though the
    SQL statement execution made no changes to the database. For example, the driver
    makes a network round-trip even when a `SELECT` statement is executed. The auto-commit
    mode usually impacts performance because of the significant amount of disk input/output
    needed to commit every operation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数标准API中，默认的提交模式是自动提交。在自动提交模式下，数据库对每个SQL语句（如`INSERT`，`UPDATE`，`DELETE`和`SELECT`语句）执行提交。数据库驱动程序在每个SQL语句操作后向数据库发送提交请求。这个请求需要一个网络往返。即使SQL语句的执行对数据库没有做出任何更改，也会发生与数据库的往返。例如，即使执行`SELECT`语句，驱动程序也会进行网络往返。自动提交模式通常会影响性能，因为需要大量的磁盘输入/输出来提交每个操作。
- en: So, we set the auto-commit mode to off to improve the performance of the application,
    but leaving the transaction active is also not advisable. Leaving transactions
    active can reduce throughput by holding locks on rows for longer than necessary
    and preventing other users from accessing the rows. Commit transactions in intervals
    that allow maximum concurrency.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将自动提交模式设置为关闭，以提高应用程序的性能，但保持事务活动也是不可取的。保持事务活动可能会通过长时间持有行锁并阻止其他用户访问行来降低吞吐量。以允许最大并发性的间隔提交事务。
- en: Setting the auto-commit mode to off and doing a manual commit is also not advisable
    for certain applications. For example, consider a banking application that allows
    users to transfer money from one account to another. To protect the data integrity
    of that work, it is required to commit the transaction after both accounts are
    updated with the new amounts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将自动提交模式设置为关闭并进行手动提交对于某些应用程序也是不可取的。例如，考虑一个银行应用程序，允许用户将资金从一个账户转移到另一个账户。为了保护这项工作的数据完整性，需要在更新两个账户的新金额后提交交易。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got a clear idea of the Spring JDBC module and learned how
    Spring JDBC helps to remove the boilerplate code that we use in core JDBC. We
    also learned how to design our database for optimal performance. We saw the various
    benefits of transaction management in Spring. We learned about various configuration
    techniques, such as isolation level, fetch size, and connection pooling, which
    improves the performance of our application. At the end, we looked at the best
    practices for database interaction, which can help us to improve our application's
    performance.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们清楚地了解了Spring JDBC模块，并学习了Spring JDBC如何帮助我们消除在核心JDBC中使用的样板代码。我们还学习了如何设计我们的数据库以获得最佳性能。我们看到了Spring事务管理的各种好处。我们学习了各种配置技术，如隔离级别、获取大小和连接池，这些技术可以提高我们应用程序的性能。最后，我们看了数据库交互的最佳实践，这可以帮助我们提高应用程序的性能。
- en: In the next chapter, we will see database interaction using ORM frameworks (such
    as Hibernate), and we will learn about Hibernate configurations in Spring, common
    Hibernate traps, and Hibernate performance tuning.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到使用ORM框架（如Hibernate）进行数据库交互，并学习Spring中的Hibernate配置、常见的Hibernate陷阱和Hibernate性能调优。
