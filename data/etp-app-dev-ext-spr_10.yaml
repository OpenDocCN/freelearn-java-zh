- en: Chapter 10. Logging On and Maintaining Users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。登录和维护用户
- en: The most creative part of the enterprise application lifecycle revolves around
    the user interface design. Your goal as an enterprise application developer is
    to create a user interface that is intuitive, consistent, and easy to use. User
    interface design requires a thorough understanding of the tools you have available.
    Thankfully, Ext JS 4 has a comprehensive range of widgets that cover the core
    functionality required for any enterprise application. If you have not already
    visited the examples page, then take some time now to become familiar with the
    full range of Ext JS 4 components at [http://docs.sencha.com/extjs/4.2.2/#!/example](http://docs.sencha.com/extjs/4.2.2/#!/example).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序生命周期中最有创意的部分围绕用户界面设计。作为企业应用程序开发人员，您的目标是创建一个直观、一致且易于使用的用户界面。用户界面设计需要对您可用的工具有深入的了解。幸运的是，Ext
    JS 4具有全面的小部件范围，涵盖了任何企业应用程序所需的核心功能。如果您还没有访问示例页面，请立即花些时间熟悉[http://docs.sencha.com/extjs/4.2.2/#!/example](http://docs.sencha.com/extjs/4.2.2/#!/example)上的Ext
    JS 4组件的全部范围。
- en: 'This chapter will focus on building the logon and user administration interfaces.
    We will develop a set of view components and wire them together with controllers
    to perform the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍构建登录和用户管理界面。我们将开发一组视图组件，并使用控制器将它们连接起来，以执行以下操作：
- en: Log on to the application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录到应用程序
- en: Display the main application viewport
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示主应用程序视口
- en: Provide a user maintenance interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用户维护界面
- en: The user maintenance interface will introduce model persistence and validation
    properties that are used for CRUD operations. We have quite a bit to do, so let's
    start by examining the application layouts and workflow.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 用户维护界面将引入用于CRUD操作的模型持久性和验证属性。我们有很多工作要做，所以让我们从检查应用程序布局和工作流程开始。
- en: Layouts, screens, and workflows
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局、屏幕和工作流程
- en: 'The application starts by displaying the logon window. Without a successful
    logon you will be unable to reach the main application viewport. The logon window
    has a very simple design as shown in the following screenshot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序从显示登录窗口开始。如果登录不成功，您将无法到达主应用程序视口。登录窗口的设计非常简单，如下截图所示：
- en: '![Layouts, screens, and workflows](img/5457_10_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![布局、屏幕和工作流程](img/5457_10_01.jpg)'
- en: 'A successful logon will be displayed on the welcome screen as shown in the
    following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的登录将显示在欢迎屏幕上，如下截图所示：
- en: '![Layouts, screens, and workflows](img/5457_10_02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![布局、屏幕和工作流程](img/5457_10_02.jpg)'
- en: The welcome screen has a number of buttons in the header dependent on your permissions.
    A normal user will only see the **Task Logs** button and the **Logoff** button.
    An admin user will see the additional **3T Admin** and **Users** buttons. We will
    leave the **3T Admin** and **Task Log** modules for the subsequent chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎屏幕在标题中有许多按钮，取决于您的权限。普通用户只会看到**任务日志**按钮和**注销**按钮。管理员用户将看到额外的**3T管理员**和**用户**按钮。我们将把**3T管理员**和**任务日志**模块留到后续章节。
- en: 'The user administration interface is based on the most common design pattern
    in modern enterprise applications. This layout displays a list of users in the
    left-hand side panel and the user details in the right-hand side panel:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理界面基于现代企业应用程序中最常见的设计模式。此布局在左侧面板中显示用户列表，右侧面板显示用户详细信息：
- en: '![Layouts, screens, and workflows](img/5457_10_04.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![布局、屏幕和工作流程](img/5457_10_04.jpg)'
- en: Each of these screen designs has icons and a logo that are not part of the Ext
    JS framework. The code in the following sections will define the appropriate styles
    but you will need to include the required resources to achieve the same look and
    feel. The full source code including resources can be downloaded from this book's
    website.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些屏幕设计中的每个都有图标和标志，这些都不是Ext JS框架的一部分。以下各节中的代码将定义适当的样式，但您需要包含所需的资源以实现相同的外观和感觉。包括资源在内的完整源代码可以从本书的网站下载。
- en: Defining view components
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义视图组件
- en: 'One of the hardest decisions to make when implementing wireframes and UI mockups
    is how to split up the view. Consider our user maintenance screen as shown in
    the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施线框和UI模型时，最难的决定之一是如何分割视图。考虑下面截图中显示的用户维护屏幕：
- en: '![Defining view components](img/5457_10_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![定义视图组件](img/5457_10_03.jpg)'
- en: 'How many separate views should we create? If we create too many views, they
    become difficult to manage. If there are too few views, we lose flexibility. Striking
    the right balance comes only with experience. We tend to encourage a middle-road
    approach based on logical regions within the layout itself. The previous design,
    for example, could be split into the following view components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该创建多少个单独的视图？如果创建太多视图，它们将变得难以管理。如果视图太少，我们将失去灵活性。只有通过经验才能找到正确的平衡。我们倾向于鼓励基于布局本身的逻辑区域的中间路线方法。例如，先前的设计可以分成以下视图组件：
- en: '![Defining view components](img/5457_10_11.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![定义视图组件](img/5457_10_11.jpg)'
- en: 'This is the structure we will be implementing. However, we could easily implement
    the following design:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要实施的结构。然而，我们可以轻松地实现以下设计：
- en: '![Defining view components](img/5457_10_12.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![定义视图组件](img/5457_10_12.jpg)'
- en: The second version would use a single view to encapsulate the user grid, form,
    and toolbar. The resulting `ManageUsers.js` file would be approximately 200 lines
    long; not a large file by any stretch of the imagination. From a functional perspective
    there would be no difference between the two designs. However, the first approach
    gives us more flexibility. We can easily rearrange the views on the page or refactor
    the interface without much effort (for example, moving `UserForm` to a pop-up
    window and allowing the user list to fill the entire width of the screen). This
    would not be as easy with the second design version.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本将使用单个视图来封装用户网格、表单和工具栏。生成的`ManageUsers.js`文件将大约有200行长；从功能角度来看，两种设计之间没有区别。然而，第一种方法给了我们更多的灵活性。我们可以轻松地重新排列页面上的视图或重构界面而不费吹灰之力（例如，将`UserForm`移动到弹出窗口，并允许用户列表填满整个屏幕宽度）。这在第二种设计版本中不会那么容易。
- en: When in doubt, you should err on the side of simplicity. Complex views with
    many hundreds or even thousands of lines of code should be avoided at all costs.
    Think of your views as discrete objects with specific purposes and keep them simple.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，应该偏向简单。应尽量避免具有数百甚至数千行代码的复杂视图。将视图视为具有特定目的的离散对象，并保持它们简单。
- en: Building our views
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的视图
- en: Now that we have some practical guidelines to building views, it is time to
    create our application interface. A user must be able to log on successfully to
    work with the application, so let's start with the logon window.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些构建视图的实用指南，是时候创建我们的应用程序界面了。用户必须能够成功登录以使用应用程序，因此让我们从登录窗口开始。
- en: Defining the Logon window
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义登录窗口
- en: 'The **Task Time Tracker Logon** window is the first thing a user will see,
    which is shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务时间跟踪登录**窗口是用户将看到的第一件事，如下截图所示：'
- en: '![Defining the Logon window](img/5457_10_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![定义登录窗口](img/5457_10_01.jpg)'
- en: 'The logon window definition follows the given code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 登录窗口定义如下所示的代码：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This window definition extends the `Ext.window.Window` and adds the two text
    fields and logon button. The `LogonWindow` class is namespaced to `view` and will
    hence reside in the `app/view` directory. The defined `xtype` property is the
    lowercase version of the class name and will be used in the controller to reference
    the `LogonWindow` instance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口定义扩展了`Ext.window.Window`，并添加了两个文本字段和登录按钮。`LogonWindow`类被命名空间为`view`，因此将驻留在`app/view`目录中。定义的`xtype`属性是类名的小写版本，并将在控制器中用于引用`LogonWindow`实例。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An `xtype` property is a symbolic name (alias or shortcut) for a class. The
    xtype property is a powerful concept in Ext JS that allows components to be configured,
    but not rendered, until the owning container deems it necessary. A full explanation
    of components' lazy initialization by `xtype` can be found here [http://docs.sencha.com/extjs/4.2.2/#!/guide/components](http://docs.sencha.com/extjs/4.2.2/#!/guide/components).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`xtype`属性是一个类的符号名称（别名或快捷方式）。`xtype`属性是Ext JS中一个强大的概念，允许组件被配置，但不渲染，直到拥有容器认为有必要。可以在这里找到关于组件通过`xtype`进行延迟初始化的完整解释：[http://docs.sencha.com/extjs/4.2.2/#!/guide/components](http://docs.sencha.com/extjs/4.2.2/#!/guide/components)。'
- en: The MVC design pattern encourages Ext JS 4 developers to implement business
    logic in the controller layer, leaving the views as dumb objects. The only meta
    logic we are applying in this window is the `allowBlank:false` property combined
    with `validateOnBlur:true`. This will give the user a visual clue if moving off
    the field without entering text.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: MVC设计模式鼓励Ext JS 4开发人员在控制器层实现业务逻辑，将视图作为哑对象。我们在这个窗口中应用的唯一元逻辑是`allowBlank:false`属性与`validateOnBlur:true`的组合。这将在用户在不输入文本的情况下移开字段时给出视觉提示。
- en: Using the initComponent() function
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`initComponent()`函数
- en: 'The `initComponent` function is a template function that is invoked by the
    constructor during object creation. The template design pattern allows subclasses
    to define specific behavior without changing the semantics of the base class processing
    algorithm. A detailed explanation of this pattern can be found here: [http://en.wikipedia.org/wiki/Template_method_design_pattern](http://en.wikipedia.org/wiki/Template_method_design_pattern).
    Ext JS uses the template design pattern to allow developers to specify logic during
    certain well-defined phases in the component''s lifecycle. The `initComponent`
    function is probably the most used but there are many other template hooks that
    can be implemented. A full list of component template functions can be found here:
    [http://docs.sencha.com/extjs/4.2.2/#!/guide/components](http://docs.sencha.com/extjs/4.2.2/#!/guide/components).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`initComponent`函数是在对象创建期间由构造函数调用的模板函数。模板设计模式允许子类定义特定行为，而不改变基类处理算法的语义。关于这种模式的详细解释可以在这里找到：[http://en.wikipedia.org/wiki/Template_method_design_pattern](http://en.wikipedia.org/wiki/Template_method_design_pattern)。Ext
    JS使用模板设计模式允许开发人员在组件生命周期的某些明确定义的阶段指定逻辑。`initComponent`函数可能是最常用的，但还有许多其他模板钩子可以实现。可以在这里找到组件模板函数的完整列表：[http://docs.sencha.com/extjs/4.2.2/#!/guide/components](http://docs.sencha.com/extjs/4.2.2/#!/guide/components)。'
- en: 'The `initComponent` function is used to initialize data, set up configurations,
    and attach event handlers to the component. The recommended usage pattern for
    this function (or any template function) includes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`initComponent`函数用于初始化数据、设置配置，并将事件处理程序附加到组件上。对于这个函数（或任何模板函数）的推荐使用模式包括：'
- en: Reference the current scope as a local closured variable using `var me = this`.
    Use the `me` reference everywhere in the function when referring to the object
    instance. This will help with correct JavaScript closure for complex objects by
    ensuring `me` and `this` refer to the correct object scope.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`var me = this`将当前作用域引用为本地闭包变量。在函数中引用对象实例时，到处使用`me`引用。这将有助于通过确保`me`和`this`引用正确的对象作用域来正确处理复杂对象的JavaScript闭包。
- en: Use `Ext.applyIf` to add class-specific properties to the configuration. Note
    that we are not using `Ext.apply`, which will override properties that are already
    defined; only new properties that do not exist in `me` will be copied. This ensures
    that xtype-based configuration properties take precedence.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Ext.applyIf`向配置添加特定于类的属性。请注意，我们没有使用`Ext.apply`，它将覆盖已定义的属性；只会复制`me`中不存在的新属性。这确保了基于xtype的配置属性优先。
- en: Complete the `initComponent` function by calling the parent function with the
    supplied arguments using `me.callParent(arguments)`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`me.callParent(arguments)`调用父函数来完成`initComponent`函数。
- en: These three points outline some advanced concepts that may be a bit beyond the
    intermediate reader. Don't despair if some of this doesn't make sense yet; follow
    the design pattern and things will become clearer with experience!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这三点概述了一些高级概念，可能对中级读者来说有点超出范围。如果其中有些内容还不太清楚，不要绝望；遵循设计模式，随着经验的积累，事情会变得更清晰！
- en: Defining the viewport
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义视口
- en: 'The `Viewport` view uses a `vbox` layout to split the view into two regions,
    the header and the main content areas, as shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Viewport`视图使用`vbox`布局将视图分为两个区域，标题和主要内容区域，如下面的屏幕截图所示：'
- en: '![Defining the viewport](img/5457_10_13.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![定义视口](img/5457_10_13.jpg)'
- en: We could have used a `border` layout to achieve the same visual result but the
    `vbox` layout is a lighter weight component. Only use the `border` layout if your
    application needs additional functionality such as expandable/collapsible regions
    or resizable split views.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`border`布局来实现相同的视觉效果，但`vbox`布局是一个更轻量级的组件。只有在应用程序需要额外功能，如可展开/可折叠区域或可调整大小的分割视图时才使用`border`布局。
- en: 'The `Viewport` definition is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Viewport`定义如下：'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are two views that now need to be defined: one for the main header, the
    second for the main region card layout.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要定义两个视图：一个用于主标题，另一个用于主区域卡片布局。
- en: The MainHeader.js view
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MainHeader.js视图
- en: 'The `MainHeader` defines and positions the 3T logo and buttons as shown in
    the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainHeader`定义并定位了3T标志和按钮，如下面的代码所示：'
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each button defines an `itemId` property to help uniquely identify the button
    when using selectors in the controller. The two administrative buttons use the
    `hidden` property to hide the button if the user is not an administrator. The
    `TTT.getApplication().isAdmin()` function has not been defined as yet but this
    will be added to the `Application.js` function in the section ahead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都定义了一个`itemId`属性，以帮助在控制器中使用选择器唯一标识按钮。两个管理按钮使用`hidden`属性来隐藏按钮，如果用户不是管理员，则使用`TTT.getApplication().isAdmin()`函数。该函数尚未定义，但将在后面的部分中添加到`Application.js`函数中。
- en: The MainCards.js file
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MainCards.js文件
- en: 'The `MainCards` component is a card layout container that holds all the components
    that will be rendered in the main content area as shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainCards`组件是一个卡片布局容器，包含将在主内容区域中呈现的所有组件，如下面的代码所示：'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will be adding items to the `MainCards` as we build our functionality. For
    this chapter we will focus on the `Welcome` and `ManageUsers` components.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建功能，我们将向`MainCards`添加项目。在本章中，我们将专注于`Welcome`和`ManageUsers`组件。
- en: Defining the Welcome panel
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义欢迎面板
- en: The `Welcome` panel uses an `XTemplate` to render a simple welcome message based
    on the logged-on user. The user data is retrieved from the application using the
    `TTT.getApplication().getUser()` function that will be added to the `Application.js`
    function after a successful logon.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Welcome`面板使用`XTemplate`根据已登录用户呈现简单的欢迎消息。用户数据是使用`TTT.getApplication().getUser()`函数从应用程序中检索的，该函数将在成功登录后添加到`Application.js`函数中。'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining the user management components
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用户管理组件
- en: 'The user management interface consists of three view files as shown in the
    following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理界面由三个视图文件组成，如下面的屏幕截图所示：
- en: '![Defining the user management components](img/5457_10_17.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![定义用户管理组件](img/5457_10_17.jpg)'
- en: In addition to the views we will also need to define a user store that manages
    the data displayed in the user listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了视图之外，我们还需要定义一个用户存储，用于管理用户列表中显示的数据。
- en: The ManageUsers.js file
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ManageUsers.js文件
- en: 'The `ManageUsers` file is a simple `hbox` layout that displays the `UserList`
    and `UserForm`. The toolbar contains the single **Add User** button. This file
    has a very simple definition, which is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManageUsers`文件是一个简单的`hbox`布局，显示`UserList`和`UserForm`。工具栏包含单个**添加用户**按钮。该文件有一个非常简单的定义，如下所示：'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The UserForm.js file
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UserForm.js文件
- en: 'This `UserForm.js` file displays the user details as shown in the following
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserForm.js`文件显示了用户详细信息，如下面的代码所示：'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each button has an `itemId` property defined to allow us to uniquely identify
    them in the controller. Each field name in the form exactly matches the field
    name in the `User` model defined in the previous chapter. This will allow us to
    easily load a user model instance into the form.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都有一个`itemId`属性，用于在控制器中唯一标识它们。表单中的每个字段名称与前一章中定义的`User`模型中的字段名称完全匹配。这将允许我们轻松地将用户模型实例加载到表单中。
- en: The UserList.js file
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UserList.js文件
- en: 'The `UserList` file is a grid panel with the following definition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserList`文件是一个带有以下定义的网格面板：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The grid columns use the `flex` config property to define the relative width
    of each column. The `email` column will hence be twice the width of the other
    columns.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 网格列使用`flex`配置属性来定义每列的相对宽度。因此，`email`列的宽度将是其他列的两倍。
- en: 'The `markDirty:false` in the `viewConfig` is used to remove the dirty cell
    indicator when a cell value is modified. Without this property the grid would
    render changed cell values as shown, even after the record has been successfully
    saved:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`viewConfig`中的`markDirty:false`用于在修改单元格值时移除脏单元格指示器。如果没有此属性，即使记录已成功保存，网格也会呈现已更改的单元格值，如下所示：
- en: '![The UserList.js file](img/5457_10_18.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![UserList.js文件](img/5457_10_18.jpg)'
- en: The `User` store is yet to be defined, so let's add it now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`存储尚未定义，所以让我们现在添加它。'
- en: The User store
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户存储
- en: 'The `User` store loads users from the `ttt/user/findAll.json` URL. which is
    mapped to the `UserHandler.findAll` method. Readers should recall that the `ttt/
    prefix` URL corresponds to the servlet mapping specified in the `com.gieman.tttracker.web.WebApp.getServletMappings()`
    method in [Chapter 7](ch07.html "Chapter 7. The Web Request Handling Layer"),
    *The Web Request Handling Layer*. Each user record in the JSON array will result
    in the creation of a `TTT.model.User` model instance. The store definition is
    explained in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 存储从 `ttt/user/findAll.json` URL 加载用户。这与 `UserHandler.findAll` 方法相对应。读者应该记得，`ttt/前缀`
    URL 对应于 [第 7 章](ch07.html "第 7 章. Web 请求处理层") 中的 `com.gieman.tttracker.web.WebApp.getServletMappings()`
    方法中指定的 servlet 映射，*Web 请求处理层*。JSON 数组中的每个用户记录将导致创建一个 `TTT.model.User` 模型实例。存储定义在以下代码中：'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `User` model was defined in the previous chapter and currently looks like
    the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 模型在上一章中被定义，目前看起来如下：'
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ext JS 4 models are a key part of the MVC framework and we will now spend some
    time learning about these important objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 4 模型是 MVC 框架的关键部分，现在我们将花一些时间学习这些重要的对象。
- en: Models and persistence
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型和持久性
- en: 'Ext JS 4 models are similar to JPA entities in that they define data fields
    that represent columns in the underlying database tables. Each model instance
    represents a row in the table. The primary key field is defined using the `idProperty`
    of the model, which must match one of the field names. The `User` model can now
    be updated as shown:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 4 模型类似于 JPA 实体，因为它们定义了表示基础数据库表中列的数据字段。每个模型实例代表表中的一行。使用模型的 `idProperty`
    定义主键字段，它必须与字段名称之一匹配。`User` 模型现在可以更新如下：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Defining the proxy
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义代理
- en: Each model can be made persistent aware by configuring an appropriate proxy.
    All loading and saving of data is then handled by the proxy when the `load`, `save`,
    or `destroy` method on the model is called. There are several different types
    of proxies but the most widely used is the `Ext.data.ajax.Proxy` (alternate name
    `Ext.data.AjaxProxy`). The `AjaxProxy` uses AJAX requests to read and write data
    from the server. Requests are sent as `GET` or `POST` methods depending on the
    operation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置适当的代理，每个模型都可以被设置为持久感知。然后，当调用模型的 `load`、`save` 或 `destroy` 方法时，所有数据的加载和保存都由代理处理。有几种不同类型的代理，但最常用的是
    `Ext.data.ajax.Proxy`（另一个名称是 `Ext.data.AjaxProxy`）。`AjaxProxy` 使用 AJAX 请求从服务器读取和写入数据。请求根据操作以
    `GET` 或 `POST` 方法发送。
- en: A second useful proxy is `Ajax.data.RestProxy`. The `RestProxy` is a specialization
    of the `AjaxProxy` that maps the four `CRUD` actions to the appropriate RESTful
    HTTP methods (`GET`, `POST`, `PUT`, and `DELETE`). The `RestProxy` would be used
    when connecting to RESTful web services. Our application will use `AjaxProxy`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个有用的代理是 `Ajax.data.RestProxy`。`RestProxy` 是 `AjaxProxy` 的一个特例，它将四个 `CRUD`
    操作映射到适当的 RESTful HTTP 方法（`GET`、`POST`、`PUT` 和 `DELETE`）。当连接到 RESTful web 服务时，将使用
    `RestProxy`。我们的应用程序将使用 `AjaxProxy`。
- en: 'The `User` model definition including proxy follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 包括代理在内的 `User` 模型定义如下：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The proxy is defined as type `ajax` and specifies the primary key field in
    the model with the `idParam` property. The `idParam` is used when generating the
    URL for the `read` operation. For example, if trying to load the user record with
    username `bjones`, the proxy would generate a URL as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代理被定义为类型 `ajax`，并使用 `idParam` 属性指定模型中的主键字段。在生成 `read` 操作的 URL 时使用 `idParam`。例如，如果尝试加载用户名为
    `bjones` 的用户记录，则代理将生成以下 URL：
- en: '`ttt/user/find.json?username=bjones`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttt/user/find.json?username=bjones`'
- en: 'If the `idParam` property was omitted, the URL generated would be as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了 `idParam` 属性，则生成的 URL 将如下所示：
- en: '`ttt/user/find.json?id=bjones`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttt/user/find.json?id=bjones`'
- en: The `api` properties define the URLs to call on CRUD action methods. Each URL
    maps to an appropriate handler method in `UserHandler`. Note that the `update`
    and `create` URLs are the same as both actions are handled by the `UserHandler.store`
    method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`api` 属性定义了在 CRUD 操作方法上调用的 URL。每个 URL 映射到 `UserHandler` 中的适当处理程序方法。请注意，`update`
    和 `create` URL 是相同的，因为这两个操作都由 `UserHandler.store` 方法处理。'
- en: It is important to note that the `AjaxProxy` read operation uses a `GET` request
    while all other operations use `POST` requests. This is different from the `RestProxy`
    method, which uses a different request method for each operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`AjaxProxy` 的读取操作使用 `GET` 请求，而所有其他操作使用 `POST` 请求。这与 `RestProxy` 方法不同，后者对每个操作使用不同的请求方法。
- en: Comparing AJAX and REST proxies
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较 AJAX 和 REST 代理
- en: Our request handling layer has been designed to consume AJAX requests in a format
    submitted by Ext JS 4 clients. Each handler that processes an update action is
    configured with `RequestMethod.POST` and expects a `data` parameter that holds
    the JSON object applicable to the action.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的请求处理层已经设计为以 Ext JS 4 客户端提交的格式消耗 AJAX 请求。处理更新操作的每个处理程序都配置为 `RequestMethod.POST`，并期望包含适用于操作的
    JSON 对象的 `data` 参数。
- en: 'We could have implemented the request handling layer as a RESTful API where
    each method is mapped to an appropriate request method type (`GET`, `POST`, `PUT`,
    or `DELETE`). Implementing a delete action would then encode the `id` of the item
    in the URL of a `DELETE` submitted request. Deleting the `bjones` user, for example,
    could be achieved by submitting a DELETE request method URL as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将请求处理层实现为 RESTful API，其中每个方法都映射到适当的请求方法类型（`GET`、`POST`、`PUT` 或 `DELETE`）。然后，实现删除操作将在
    `DELETE` 提交的请求的 URL 中编码项目的 `id`。例如，通过提交以下方式的 DELETE 请求方法 URL，可以删除 `bjones` 用户：
- en: '`user/bjones`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`user/bjones`'
- en: 'The `UserHandler.remove` method could then be defined as:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将 `UserHandler.remove` 方法定义为：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@PathVariable` extracts the `username` (in our sample URL this is `bjones`)
    from the URL, which is then used in the call to the `userService.remove` method.
    The `@RequestMapping method` of `RequestMethod.DELETE` ensures the method is only
    executed when a DELETE request matching the URL path of `/user/{username}` is
    submitted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PathVariable`从URL中提取`username`（在我们的示例URL中为`bjones`），然后在调用`userService.remove`方法时使用。`RequestMethod.DELETE`的`@RequestMapping`方法确保只有在提交匹配URL路径`/user/{username}`的DELETE请求时才执行该方法。'
- en: The RESTful API is a specific style of using HTTP that encodes the item you
    want to retrieve or manipulate in the URL itself (via its ID) and encodes what
    action you want to perform on it in the HTTP method used (`GET` for retrieving,
    `POST` for changing, `PUT` for creating, `DELETE` for deleting). The `Rest` proxy
    in Ext JS is a specialization of the `AjaxProxy` that simply maps the four CRUD
    actions to their RESTful HTTP equivalent method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API是一种特定的使用HTTP的风格，它在URL本身中对要检索或操作的项目进行编码（通过其ID），并在所使用的HTTP方法中对要执行的操作进行编码（`GET`用于检索，`POST`用于更改，`PUT`用于创建，`DELETE`用于删除）。Ext
    JS中的`Rest`代理是`AjaxProxy`的一个特例，它简单地将四个CRUD操作映射到它们的RESTful HTTP等效方法。
- en: 'There is no significant difference in implementing either the AJAX or REST
    alternative in Ext JS 4\. Configuring the proxy with `type:''ajax''` or `type:''rest''`
    is all that is required. The request handling layer, however, would need to be
    implemented in a very different way to process the `@PathVariable` parameters.
    We prefer the AJAX implementation for the following reasons:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS 4中，实现AJAX或REST替代方案没有显著的差异。配置代理为`type:'ajax'`或`type:'rest'`就足够了。然而，请求处理层需要以非常不同的方式实现来处理`@PathVariable`参数。出于以下原因，我们更喜欢AJAX实现：
- en: REST has traditionally been used for server-to-server communication, most notably
    in web services, and not for browser-server interactions.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST传统上用于服务器间通信，尤其是在Web服务中，而不是用于浏览器与服务器的交互。
- en: The URLs for CRUD AJAX requests are unique and become self-documenting.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRUD AJAX请求的URL是唯一的，并且变得自我描述。
- en: The 3T application is not a web service and is based on HTML 5.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3T应用程序不是Web服务，而是基于HTML 5。
- en: The HTML 5 specification no longer supports `PUT` and `DELETE` as HTTP methods
    for `form` elements (see [http://www.w3.org/TR/2010/WD-html5-diff-20101019/#changes-2010-06-24](http://www.w3.org/TR/2010/WD-html5-diff-20101019/#changes-2010-06-24)).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 5规范不再支持`PUT`和`DELETE`作为`form`元素的HTTP方法（参见[http://www.w3.org/TR/2010/WD-html5-diff-20101019/#changes-2010-06-24](http://www.w3.org/TR/2010/WD-html5-diff-20101019/#changes-2010-06-24)）。
- en: REST is not a flexible solution and is usually based around atomic actions (one
    item processed per request). AJAX and Ext JS combine to allow more complex interactions
    with bulk updating possible (many updates in a single request are possible for
    all create, update, and destroy URLs. This will be explained later in the *Defining
    the writer* section).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST不是一种灵活的解决方案，通常基于原子操作（每个请求处理一个项目）。AJAX和Ext JS结合起来允许更复杂的交互，可以进行批量更新（可以对所有创建、更新和销毁URL进行多个更新的单个请求）。这将在*定义writer*部分中进行解释。
- en: '`PUT` and `DELETE` requests are often considered a security risk (in addition
    to `OPTIONS`, `TRACE`, and `CONNECT` methods) and are often disabled in enterprise
    web application environments. Applications that specifically require these methods
    (for example, web services) usually expose these URLs to a limited number of trusted
    users under secure conditions (usually with SSL certificates).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`和`DELETE`请求通常被认为是安全风险（除了`OPTIONS`、`TRACE`和`CONNECT`方法），并且通常在企业Web应用环境中被禁用。通常需要这些方法的应用程序（例如Web服务）通常在安全条件下向有限数量的受信任用户公开这些URL（通常使用SSL证书）。'
- en: There is no definitive or compelling reason to use AJAX over REST or vice versa.
    In fact the online discussions around when to use REST over AJAX are quite extensive,
    and often very confusing. We have chosen what we believe to be is the simplest
    and most flexible implementation by using AJAX without the need for REST.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 没有明确或令人信服的理由来使用AJAX或REST。事实上，关于何时使用REST而不是AJAX的在线讨论非常广泛，而且经常令人困惑。我们选择了我们认为是最简单和最灵活的实现，即使用AJAX而不需要REST。
- en: Defining the reader
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义reader
- en: 'The `reader` with type `json` instantiates a `Ext.data.reader.Json` instance
    to decode the server''s response to an operation. It reads the JSON `data` node
    (identified by the `root` property of the reader) and populates the field values
    in the model. Executing a read operation for the `User` model using `ttt/user/find.json?username=bjones`
    will return:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 具有类型`json`的`reader`实例化了一个`Ext.data.reader.Json`实例，以解码服务器对操作的响应。它读取JSON `data`节点（由reader的`root`属性标识）并填充模型中的字段值。使用`ttt/user/find.json?username=bjones`对`User`模型执行读取操作将返回：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The reader will then parse the JSON file and set the corresponding field values
    on the model.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，reader将解析JSON文件并在模型上设置相应的字段值。
- en: Defining the writer
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义writer
- en: 'The `writer` with type `json` instantiates an `Ext.data.writer.Json` instance
    to encode any request sent to the server in the JSON format. The `encode:true`
    property combines with the `root` property to define the HTTP request parameter
    that holds the JSON data. This combination ensures that a single request parameter
    with name `data` will hold the JSON representation of the model. For example,
    saving the previous `bjones` user record will result in a request being submitted
    with one parameter named `data` holding the following string:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 具有类型`json`的`writer`实例化了一个`Ext.data.writer.Json`实例，以将发送到服务器的任何请求编码为JSON格式。`encode:true`属性与`root`属性结合，定义了保存JSON数据的HTTP请求参数。这种组合确保一个名为`data`的单个请求参数将保存模型的JSON表示。例如，保存先前的`bjones`用户记录将导致提交一个名为`data`的参数，其中包含以下字符串：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It should be noted that this representation is formatted for readability; the
    actual data will be a string of characters on one line. This representation is
    then parsed into a `JsonObject` in the `UserHandler.store` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，此表示已格式化以便阅读；实际数据将是一行字符的字符串。然后将此表示解析为`UserHandler.store`方法中的`JsonObject`：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The appropriate `jsonObject` values are then extracted as required.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后根据需要提取适当的`jsonObject`值。
- en: The `writeAllFields` property will ensure that all fields in the model are sent
    in the request, not just the modified fields. Our handler methods require all
    model fields to be present. However, note that we have added the `persist:false`
    property to the `fullName` field. This field is not required as it is not a persistent
    field in the `User` domain object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeAllFields`属性将确保在请求中发送模型中的所有字段，而不仅仅是修改过的字段。我们的处理程序方法要求所有模型字段都存在。但是，请注意，我们已将`persist:false`属性添加到`fullName`字段。由于`fullName`字段不是`User`域对象中的持久字段，因此不需要该字段。'
- en: 'The final `writer` property that needs explanation is `allowSingle:true`. This
    is the default value and ensures a single record is sent without a wrapping array.
    If your application performs bulk updates (multiple records are sent in the same
    single request) then you will need to set this property to `false`. This would
    result in single records being sent within an array, as shown in the following
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解释的最终`writer`属性是`allowSingle:true`。这是默认值，确保发送单个记录而不是包装数组。如果您的应用程序执行批量更新（在同一请求中发送多个记录），那么您需要将此属性设置为`false`。这将导致单个记录被发送到数组中，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The 3T application does not implement bulk updates and always expects a single
    JSON record to be sent in each request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 3T应用程序不实现批量更新，并且始终期望每个请求中发送一个单个的JSON记录。
- en: Defining validations
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义验证
- en: Each model has built-in support for validating field data. The core validation
    functions include checks for `presence`, `length`, `inclusion`, `exclusion`, `format`
    (using regular expressions), and `email`. A model instance can be validated by
    calling the `validate` function, which returns an `Ext.data.Errors` object. The
    `errors` object can then be tested to see if there are any validation errors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型都内置了验证字段数据的支持。核心验证函数包括`presence`、`length`、`inclusion`、`exclusion`、`format`（使用正则表达式）和`email`的检查。可以通过调用`validate`函数来验证模型实例，该函数返回一个`Ext.data.Errors`对象。然后可以测试`errors`对象以查看是否存在任何验证错误。
- en: 'The `User` model validations are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`模型的验证如下：'
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `presence` validation ensures that a value is present for the field. The
    `length` validation checks for field size. Our validations require a minimum `password`
    size of six characters and a minimum `username` of four characters. First and
    last names have a minimum size of two characters. The `inclusion` validation tests
    to ensure the field value is one of the entries in the defined list. As a result,
    our `adminRole` value must be either a `Y` or `N`. The `email` validation ensures
    the e-mail field has a valid e-mail format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`presence`验证确保字段的值存在。`length`验证检查字段大小。我们的验证要求`password`的最小长度为六个字符，`username`的最小长度为四个字符。名字和姓氏的最小长度为两个字符。`inclusion`验证测试以确保字段值是定义列表中的条目之一。因此，我们的`adminRole`值必须是`Y`或`N`中的一个。`email`验证确保电子邮件字段具有有效的电子邮件格式。'
- en: 'The final code listing for our `User` model can now be defined as:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`User`模型的最终代码清单可以定义为：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Controlling the Logon and Viewport actions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制登录和视口操作
- en: We are now ready to define the `MainController` that will be used to process
    the core application actions. These include logging on, logging off, and clicking
    on the header buttons to display the different management panels in the main content
    area.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备定义将用于处理核心应用程序操作的`MainController`。这些操作包括登录、注销和单击标题按钮以在主内容区域中显示不同的管理面板。
- en: The MainController.js file
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MainController.js文件
- en: 'The `MainController.js` definition is as the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainController.js`的定义如下代码：'
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `MainController` is responsible for managing three views as defined in
    the views configuration array: `MainHeader`, `MainCards`, and `LogonWindow`. Each
    `ref` defines a component that is needed by the controller to perform an action.
    The `ref` value is used during initialization of the controller to automatically
    create a `getter` function that can be used to access the component. In our `MainController`
    the ref value `mainCards` will result in a `getMainCards` function being created.
    This function is used in the `doHeaderButtonClick` function to access the `MainCards`
    component.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainController`负责管理视图配置数组中定义的三个视图：`MainHeader`、`MainCards`和`LogonWindow`。每个`ref`定义了控制器执行操作所需的组件。在控制器初始化期间，`ref`值用于自动创建一个`getter`函数，该函数可用于访问组件。在我们的`MainController`中，`mainCards`的`ref`值将导致创建一个`getMainCards`函数。此函数在`doHeaderButtonClick`函数中用于访问`MainCards`组件。'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name of a function should identify the core purpose of the code it defines.
    We will prefix all functions that perform actions with `do`. In our example, it
    should be clear to any developer what the purpose of the `doHeaderButtonClick`
    function is.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称应该标识代码定义的核心目的。我们将所有执行操作的函数前缀为`do`。在我们的示例中，任何开发人员都应该清楚`doHeaderButtonClick`函数的目的是什么。
- en: The `MainController.init()` function calls the `control()` function to configure
    event handling in the views. The `control()` function is a convenient method to
    assign a set of event listeners in one action. The `mainheader` button selector
    configures the `click` event on all button objects in the `MainHeader`. Whenever
    a button in the header is clicked the `doHeaderButtonClick` function is called.
    This function will then determine which button has been clicked by examining the
    `itemId` of the `button` argument. The appropriate card in the `MainCards` is
    then activated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainController.init()`函数调用`control()`函数来配置视图中的事件处理。`control()`函数是一种方便的方法，可以在一个操作中分配一组事件侦听器。`mainheader`按钮选择器配置`MainHeader`中所有按钮对象的`click`事件。每当标题中的按钮被点击时，将调用`doHeaderButtonClick`函数。然后，该函数将通过检查`button`参数的`itemId`来确定已单击哪个按钮。然后激活`MainCards`中的适当卡。'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note we have added code to display the `manageTasksCard` and `taskLogCard` even
    though they are not currently available. These user interfaces will be developed
    in the following chapters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经添加了代码来显示`manageTasksCard`和`taskLogCard`，即使它们目前还不可用。这些用户界面将在接下来的章节中开发。
- en: The `logonwindow` button selector configures the `click` event on the **Logon**
    button of the `LogonWindow`. The `doLogon` function is called when the button
    is clicked to trigger the logon process. This function validates the `username`
    and `password` fields and, if both are valid, submits an AJAX request to authenticate
    the user. A successful logon will then call the `TTT.getApplication().doAfterLogon()`
    function passing the user JSON data as the argument.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`logonwindow`按钮选择器配置了`LogonWindow`上**登录**按钮的`click`事件。当单击按钮以触发登录过程时，将调用`doLogon`函数。此函数验证`username`和`password`字段，如果两者都有效，则提交AJAX请求以验证用户。成功登录将调用`TTT.getApplication().doAfterLogon()`函数，将用户JSON数据作为参数传递。'
- en: The `doLogoff` function is triggered when the user clicks on the **Logout**
    button in the header. A prompt is presented to the user and if confirmed the `logout`
    action is processed. This will clear the session in the backend before reloading
    the browser window and presenting the user with the `LogonWindow` once again.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在页眉中单击**注销**按钮时，将触发`doLogoff`函数。系统会向用户提示，如果确认，则会处理`logout`操作。这将在重新加载浏览器窗口之前清除后端的会话，并再次呈现用户`LogonWindow`。
- en: Controlling our user views
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制我们的用户视图
- en: 'The glue that links the three user views together is the `UserController`.
    It is here that we place all logic for managing user maintenance. You have seen
    that each view defined earlier is dumb in that there is only presentation logic
    defined. Actions, validations, and selections are all handled within the `UserController`
    and are explained in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将三个用户视图联系在一起的粘合剂是`UserController`。在这里，我们放置了所有管理用户维护的逻辑。您已经看到，之前定义的每个视图都是愚蠢的，因为只定义了表示逻辑。操作、验证和选择都在`UserController`中处理，并在下面的代码中进行了解释：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `UserController` is defined with a single view to manage users as shown
    in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserController`被定义为一个单一视图，用于管理用户，如下面的代码所示：'
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This allows us to define a set of references using the component query language
    starting with the `manageusers` root selector. We can hence reference the save
    button on the `UserForm` by the selector:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用组件查询语言来定义一组引用，从`manageusers`根选择器开始。因此，我们可以通过选择器引用`UserForm`上的保存按钮：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `#saveBtn` refers to the component with `itemId saveBtn` on the `userform`
    within the `manageusers` component.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`#saveBtn`指的是`manageusers`组件内`userform`上带有`itemId saveBtn`的组件。'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only define references that are used by the controller to process business logic.
    Do not create a reference for components that are never accessed within your code.
    Keep your code simple and clean!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 只定义控制器用于处理业务逻辑的引用。不要为代码中从未访问的组件创建引用。保持代码简单和清晰！
- en: The `init` function defines the listeners that should be processed in the interface.
    Each button click is matched to an appropriate `handler` function. The user list
    `itemclick` event is handled by the `doSelectUser` function. The `viewready` event
    on the `userlist` triggers the initial load of the grid's store. Each listener
    event is handled by a single function with a clear purpose. Let's now examine
    the core functions in detail.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`函数定义了应在界面中处理的监听器。每次按钮点击都与适当的`handler`函数匹配。用户列表`itemclick`事件由`doSelectUser`函数处理。`userlist`上的`viewready`事件触发了网格存储的初始加载。每个监听器事件都由一个具有明确目的的单个函数处理。现在让我们详细检查核心函数。'
- en: The doAddUser function
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doAddUser函数
- en: 'The `doAddUser` function is called when the **Add User** button is clicked.
    We set the title on the form `fieldset` to display **Add New User** and then enable
    the `username` field as shown in the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击**添加用户**按钮时，将调用`doAddUser`函数。我们将表单`fieldset`的标题设置为显示**添加新用户**，然后如下所示启用`username`字段：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We only enable the `username` field when adding a new user; the `username`
    field is not editable for existing users as it represents the primary key. We
    then create a new User model and load the record into the user form:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在添加新用户时才启用`username`字段；对于现有用户，`username`字段不可编辑，因为它代表主键。然后，我们创建一个新的User模型并将记录加载到用户表单中：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this stage the user form would look like the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，用户表单将如下截图所示：
- en: '![The doAddUser function](img/5457_10_19.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![The doAddUser function](img/5457_10_19.jpg)'
- en: 'The **Delete** button serves no useful purpose for adding a new user and hence
    we disable it as shown in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除**按钮对于添加新用户没有任何有用的目的，因此我们将其禁用，如下所示：'
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This gives us the following **Add New User** interface as shown in the following
    screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下**添加新用户**界面，如下截图所示：
- en: '![The doAddUser function](img/5457_10_20.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![The doAddUser function](img/5457_10_20.jpg)'
- en: We could just as easily have hidden the delete button instead of disabling it;
    your approach will depend on your client specifications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择隐藏删除按钮而不是禁用它；您的方法将取决于客户端的规格。
- en: The form is now ready for entering a new user.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表单已准备好输入新用户。
- en: The doSelectUser function
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doSelectUser函数
- en: 'The `doSelectUser` function handles the `itemclick` event on the `userlist`
    grid panel. The arguments to this function are the grid itself and the selected
    record. This makes loading the form with the selected user record a simple task:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`doSelectUser`函数处理`userlist`网格面板上的`itemclick`事件。此函数的参数是网格本身和所选记录。这使得使用所选用户记录加载表单变得简单：'
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `fieldset` title is changed to reflect the user being edited and the `username`
    field is disabled. We also ensure the **Delete** button is enabled as we require
    the option to delete an existing record. Clicking on the **Betty Jones** record
    in the user list would then display the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`fieldset`标题更改以反映正在编辑的用户，并且`username`字段被禁用。我们还确保**删除**按钮被启用，因为我们需要删除现有记录的选项。点击用户列表中的**Betty
    Jones**记录将显示以下截图：'
- en: '![The doSelectUser function](img/5457_10_21.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![doSelectUser函数](img/5457_10_21.jpg)'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Readers will note that the **Password** field is empty. This means that saving
    a user record via the form will require a password to be set. The backend handler
    method and service layer also require a valid password when saving a user. In
    the real world this would not be the case; you do not want an administrator changing
    the password every time they save user details! A **Change Password** form, perhaps
    in a pop-up window, would normally trigger a separate AJAX request to change the
    user's password.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 读者会注意到**密码**字段是空的。这意味着通过表单保存用户记录将需要设置密码。当保存用户时，后端处理程序和服务层也需要有效的密码。在现实世界中，情况并非如此；您不希望管理员每次保存用户详细信息时都更改密码！**更改密码**表单，也许在弹出窗口中，通常会触发单独的AJAX请求来更改用户的密码。
- en: It is now time to code the **Save** button action.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写**保存**按钮的操作了。
- en: The doSaveUser function
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doSaveUser函数
- en: The `doSaveUser` function processes the saving of a user record. In most applications
    the `save` function will contain the most code as validations and user feedback
    are important steps in the process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`doSaveUser`函数处理保存用户记录的过程。在大多数应用程序中，`save`函数将包含大部分代码，因为验证和用户反馈是流程中重要的步骤。'
- en: 'The first step is to retrieve the user record instance that was loaded in the
    form as shown in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检索在表单中加载的用户记录实例，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If valid, the record is updated with the values entered in the form text fields
    as shown in the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有效，记录将使用表单文本字段中输入的值进行更新，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At this stage the user record will be in sync with the fields entered in the
    form. This means all fields in the form will have been copied to the model instance.
    We can now validate the user record as given in the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，用户记录将与表单中输入的字段同步。这意味着表单中的所有字段都已复制到模型实例中。现在我们可以验证用户记录，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If there are no validation errors, the record is saved using the `save()` function
    on the record itself. There are two possible callbacks depending on the returned
    JSON response. A successful save will trigger the success handler as shown in
    the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有验证错误，记录将使用记录本身的`save()`函数保存。根据返回的JSON响应，有两种可能的回调。成功保存将触发成功处理程序，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `success` callback will check if the record exists in the store. If not,
    the record is added to the `User` store and selected in the user list. The **Delete**
    button will then be enabled and the `fieldset` title set appropriately.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`success`回调将检查记录是否存在于存储中。如果不存在，记录将被添加到`User`存储并在用户列表中选择。**删除**按钮将被启用，并且`fieldset`标题将被适当设置。'
- en: 'The `failure` action will simply inform the user of the cause as shown in the
    following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`failure`操作将简单地通知用户原因，如下面的代码所示：'
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If there are errors encountered during validation, we mark the invalid fields
    and display a generic error message as shown in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在验证过程中遇到错误，我们会标记无效字段并显示通用错误消息，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Trying to save a user record without a valid e-mail or password would then
    display a message as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试保存一个没有有效电子邮件或密码的用户记录将显示如下消息：
- en: '![The doSaveUser function](img/5457_10_22.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![doSaveUser函数](img/5457_10_22.jpg)'
- en: The doDeleteUser function
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doDeleteUser函数
- en: 'The final handler processes the delete action. The `doDeleteUser` function
    prompts the user for confirmation before triggering the `destroy` function on
    the record if required:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最终处理程序处理删除操作。`doDeleteUser`函数在触发`destroy`函数之前提示用户确认是否需要删除记录：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `User` store will automatically remove the successfully destroyed user
    model from the store itself. Any failure will inform the user of the reason. Attempting
    to delete the record for **John Smith** will result in the message shown in the
    following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`存储将自动从存储中删除成功销毁的用户模型。任何失败都会告知用户原因。尝试删除**John Smith**的记录将导致以下代码中显示的消息：'
- en: '![The doDeleteUser function](img/5457_10_23.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![doDeleteUser函数](img/5457_10_23.jpg)'
- en: 'Where is this message coming from? It is generated in the service layer `UserServiceImpl.remove`
    method that was coded when implementing the business logic for the delete action.
    What about trying to delete the currently logged-on user? This will result in
    the following message:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息是从哪里来的？它是在实现删除操作的业务逻辑时编写的服务层`UserServiceImpl.remove`方法生成的。那么试试删除当前登录的用户呢？这将导致以下消息：
- en: '![The doDeleteUser function](img/5457_10_24.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![doDeleteUser函数](img/5457_10_24.jpg)'
- en: Once again this is coming from the service layer business logic.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是来自服务层业务逻辑。
- en: Let's log on!
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们登录！
- en: 'It is now time to enable our controllers and test the functionality. Update
    the `Application.js` file as displayed in the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候启用我们的控制器并测试功能了。按照下面的代码更新`Application.js`文件：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Application.js` represents the entire application and defines all components
    bundled in the application (models, stores, and controllers). Note that views
    are not listed here as they are managed by the controllers directly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.js`代表整个应用程序，并定义了应用程序中捆绑的所有组件（模型、存储和控制器）。请注意，视图在此处未列出，因为它们由控制器直接管理。'
- en: We have defined a `requires` array containing the `TTT.view.LogonWindow` and
    `TTT.view.Viewport` classes. Although this is strictly not essential, as these
    definitions also reside in the appropriate controllers, it is considered best
    practice to always include `requires` entries for all `Ext.create()` function
    calls in the class. We create both the `TTT.view.LogonWindow` and `TTT.view.Viewport`
    using `Ext.create()`, so have included these in the `requires` list.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个`requires`数组，其中包含`TTT.view.LogonWindow`和`TTT.view.Viewport`类。虽然这并非必不可少，因为这些定义也驻留在适当的控制器中，但通常最好的做法是始终为类中的所有`Ext.create()`函数调用包括`requires`条目。我们使用`Ext.create()`创建了`TTT.view.LogonWindow`和`TTT.view.Viewport`，因此已将它们包含在`requires`列表中。
- en: Our `controllers` array contains the `MainController` and `UserController` as
    expected. We have also added the `User` model as this is the only model we currently
    need. Likewise the `User` store has been added to the `stores` array.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`controllers`数组包含了`MainController`和`UserController`，这是预期的。我们还添加了`User`模型，因为这是我们目前唯一需要的模型。同样，`User`存储已添加到`stores`数组中。
- en: 'The `init` function is a template method that is called when the application
    boots. We have added code to the `Ext.Ajax beforerequest` event to prefix all
    URLs with the servlet path configured in the `com.gieman.tttracker.web.WebApp.getServletMappings()`
    method; this is shown in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`函数是应用程序启动时调用的模板方法。我们已经在`Ext.Ajax beforerequest`事件中添加了代码，以在`com.gieman.tttracker.web.WebApp.getServletMappings()`方法中配置的servlet路径前缀所有URL；如下所示：'
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `ttt/` prefix is added to each `Ext.Ajax` request URL to ensure the correct
    mapping to the request handling layer. Without this `beforerequest` event code
    each URL would need to be prefixed with `ttt` as we have already coded in the
    `User` model `api`, the `User` store URL, and the `Ajax.request` URLs for logon
    actions in the `MainController`. We can now omit the `ttt/` prefix in all URLs
    that access servlet resources. The `User` model `api` can now be changed to the
    following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttt/`前缀被添加到每个`Ext.Ajax`请求URL中，以确保正确映射到请求处理层。如果没有这个`beforerequest`事件代码，每个URL都需要以`ttt`为前缀，就像我们已经在`User`模型`api`中编码的那样，`User`存储URL以及`MainController`中的登录操作的`Ajax.request`
    URL。现在我们可以在访问servlet资源的所有URL中省略`ttt/`前缀。`User`模型`api`现在可以更改为以下代码：'
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In a similar way we can now remove the `ttt/` prefix from the `User` store and
    `MainController.doLogon/Logoff` URLs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们现在可以从`User`存储和`MainController.doLogon/Logoff`的URL中删除`ttt/`前缀。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This technique of using the `beforerequest` event to prefix all Ajax URLs may
    only be used for simple projects that consume resources from a single mapped servlet.
    If multiple mappings are used, a different strategy would need to be implemented.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`beforerequest`事件为所有Ajax URL添加前缀的技术只能用于从单个映射的servlet消耗资源的简单项目。如果使用了多个映射，则需要实现不同的策略。
- en: The `launch` function is another template method called when the page is ready
    and all JavaScript has been loaded. The `TTT.console` function defines a lightweight
    logger that sends the output to the browser console, if available. It is not a
    replacement for the `Ext.log()` function but is simpler to use. We encourage you
    to use the `TTT.console` function liberally to analyze your code and debug processing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch`函数是另一个模板方法，在页面准备就绪并且所有JavaScript已加载时调用。`TTT.console`函数定义了一个轻量级的记录器，如果可用，它会将输出发送到浏览器控制台。它并不是`Ext.log()`函数的替代品，但使用起来更简单。我们鼓励您大量使用`TTT.console`函数来分析您的代码和调试处理过程。'
- en: The final step in the `launch` function creates and assigns the `LogonWindow`
    instance to the application scoped variable `logonWindow`. This will display the
    logon window when the application is loaded.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch`函数的最后一步是创建并将`LogonWindow`实例分配给应用程序范围的变量`logonWindow`。这将在应用程序加载时显示登录窗口。'
- en: 'The `doAfterLogon` function is used to postprocess the successful logon and
    initialises the application environment. The `doAfterLogon` argument is the JSON
    data object returned after a successful logon and has the following structure:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAfterLogon`函数用于后处理成功登录并初始化应用程序环境。`doAfterLogon`参数是成功登录后返回的JSON数据对象，具有以下结构：'
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function will create two helper functions that can be called by any component
    to retrieve user details and to test if the user is an administrator. An example
    of calling these functions in code has already been shown in the `MainHeader.js`.
    The `TTT` namespace is used to access the application functions via `TTT.getApplication().isAdmin()`
    and `TTT.getApplication().getUser()`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将创建两个辅助函数，可以由任何组件调用以检索用户详细信息并测试用户是否为管理员。在`MainHeader.js`中已经展示了在代码中调用这些函数的示例。`TTT`命名空间用于通过`TTT.getApplication().isAdmin()`和`TTT.getApplication().getUser()`访问应用程序函数。
- en: The final step in the `doAfterLogon` process is to create the application viewport
    and hide the logon window. We will be calling the `doAfterLogon` function, strangely
    enough, after we have successfully logged on!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAfterLogon`过程的最后一步是创建应用视图并隐藏登录窗口。奇怪的是，我们将在成功登录后调用`doAfterLogon`函数！'
- en: 'Run the application and test the logon screen with username `bjones` and password
    `admin`. You should see the interface with all header buttons enabled, as **Betty
    Jones** is an admin user:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，并使用用户名`bjones`和密码`admin`测试登录屏幕。您应该会看到界面上所有标题按钮都是可用的，因为**Betty Jones**是管理员用户。
- en: '![Let''s log on!](img/5457_10_14.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![让我们登录！](img/5457_10_14.jpg)'
- en: 'Test the logon screen with username `jsmith` and password `admin`. You should
    see the interface without the admin buttons, as **John Smith** is a normal user:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户名`jsmith`和密码`admin`测试登录屏幕。您应该会看到界面上没有管理员按钮，因为**John Smith**是普通用户：
- en: '![Let''s log on!](img/5457_10_15.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![让我们登录！](img/5457_10_15.jpg)'
- en: 'Try clicking on the **Logoff** button. You should be prompted with a confirmation
    window as shown:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击**注销**按钮。您应该会看到一个确认窗口，如下所示：
- en: '![Let''s log on!](img/5457_10_16.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![让我们登录！](img/5457_10_16.jpg)'
- en: Selecting the **Yes** option will trigger the `MainController.doLogoff` function
    to log out the user and reload the browser to display the `LogonWindow` again.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**是**选项将触发`MainController.doLogoff`函数，注销用户并重新加载浏览器以再次显示`LogonWindow`。
- en: Let's maintain users
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们维护用户
- en: 'Log on as the **bjones** user and click on the **Users** button. The following
    screen will be displayed:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以**bjones**用户身份登录，然后单击**用户**按钮。将显示以下屏幕：
- en: '![Let''s maintain users](img/5457_10_03.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![让我们维护用户](img/5457_10_03.jpg)'
- en: 'Enter the letter `A` in all fields and click the **Save** button. The **Invalid
    Fields** message will then be displayed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有字段中输入字母`A`，然后单击**保存**按钮。然后将显示**无效字段**消息：
- en: '![Let''s maintain users](img/5457_10_25.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![让我们维护用户](img/5457_10_25.jpg)'
- en: 'Enter valid entries (remembering the validation rules!) and click the **Save**
    button. The new user record should then be added to the user list:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 输入有效条目（记住验证规则！）并单击**保存**按钮。然后新用户记录应该被添加到用户列表中：
- en: '![Let''s maintain users](img/5457_10_26.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![让我们维护用户](img/5457_10_26.jpg)'
- en: 'You can now try to delete and update users to test the different functions
    you have written. There is a lot of activity hidden from view when you are performing
    such tests. You can open the JavaScript console appropriate for your browser (Safari
    Web Inspector, Firefox Firebug, Chrome Developer Tools, or the generic Fiddler
    [http://fiddler2.com/get-fiddler](http://fiddler2.com/get-fiddler)) to inspect
    the requests being sent. Try logging on again as `bjones`, clicking on the **Users**
    button, adding a new user, and then deleting this new user. You will see the following
    requests being sent to the server:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以尝试删除和更新用户，以测试您编写的不同功能。在执行此类测试时，有很多隐藏的活动。您可以打开适合您的浏览器的JavaScript控制台（Safari
    Web Inspector，Firefox Firebug，Chrome Developer Tools或通用的Fiddler [http://fiddler2.com/get-fiddler](http://fiddler2.com/get-fiddler)）来检查发送的请求。尝试以`bjones`身份再次登录，单击**用户**按钮，添加新用户，然后删除此新用户。您将看到以下请求被发送到服务器：
- en: '![Let''s maintain users](img/5457_10_27.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![让我们维护用户](img/5457_10_27.jpg)'
- en: 'Liberal use of `TTT.console()` in your functions will also help in debugging
    properties and application state. Adding the statement `TTT.console(userObj);`
    to the first line of the `Application.js doAfterLogon(userObj)` function will
    output the following to the console after a successful logon:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的函数中大量使用`TTT.console()`也有助于调试属性和应用程序状态。将语句`TTT.console(userObj);`添加到`Application.js
    doAfterLogon(userObj)`函数的第一行后，成功登录后将在控制台中输出以下内容：
- en: '![Let''s maintain users](img/5457_10_28.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![让我们维护用户](img/5457_10_28.jpg)'
- en: Take your time to test and experiment with the different functions you have
    written. We have covered a lot of concepts in this chapter!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间测试和尝试你编写的不同功能。在本章中，我们涵盖了许多概念！
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced Ext JS 4 view and controller concepts, building
    the logon window, and user maintenance interfaces. We have also introduced key
    model concepts including persistence and validations. The pieces of the puzzle
    have finally fallen into place, with our frontend actions interacting with backend
    business logic. [Chapter 11](ch11.html "Chapter 11. Building the Task Log User
    Interface"), *Building the Task Log User Interface*, will continue to enhance
    our understanding of Ext JS 4 components as we implement the Task Log user interface.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Ext JS 4视图和控制器概念，构建登录窗口和用户维护界面。我们还介绍了包括持久性和验证在内的关键模型概念。拼图的各个部分终于落入了位，我们的前端操作与后端业务逻辑进行了交互。[第11章](ch11.html
    "第11章。构建任务日志用户界面")*构建任务日志用户界面*，将继续增强我们对Ext JS 4组件的理解，因为我们实现任务日志用户界面。
