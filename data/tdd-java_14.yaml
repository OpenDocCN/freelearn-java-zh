- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Driving the Database Layer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动数据库层
- en: In this chapter, we will implement a database adapter for one of our ports in
    the domain model, represented by the `WordRepository` interface. This will allow
    our domain model to fetch words to guess from a real database, in this case, using
    the popular open source database **Postgres**. We will test-drive both the database
    setup and the code that accesses the database. To help us do that, we will use
    a test framework that is designed to simplify writing database integration tests,
    called **DBRider**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现领域模型中的一个端口的数据库适配器，该端口由`WordRepository`接口表示。这将允许我们的领域模型从真实数据库（在这种情况下，使用流行的开源数据库**Postgres**）中检索猜测单词。我们将驱动数据库设置和访问数据库的代码的测试驱动开发。为了帮助我们做到这一点，我们将使用一个旨在简化编写数据库集成测试的测试框架，称为**DBRider**。
- en: By the end of the chapter, we will have written an integration test against
    a running database, implemented the `fetchesWordByNumber()` method from the `WordRepository`
    interface, and used the **JDBI** database access library to help us. We will create
    a database user with permissions on a table storing words to guess. We will create
    that table, then write a SQL query that JDBI will use to retrieve the word we
    are looking for. We will use a named parameter SQL query to avoid some application
    security issues caused by SQL injections.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将编写一个针对运行中的数据库的集成测试，实现`WordRepository`接口中的`fetchesWordByNumber()`方法，并使用**JDBI**数据库访问库来帮助我们。我们将创建一个具有对存储猜测单词的表权限的数据库用户。我们将创建该表，然后编写JDBI将用于检索我们正在寻找的单词的SQL查询。我们将使用命名参数SQL查询来避免由SQL注入引起的一些应用程序安全问题。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating a database integration test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库集成测试
- en: Implementing the word repository adapter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现单词存储库适配器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The final code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter14](B18384_14.xhtml#_idTextAnchor302).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter14](B18384_14.xhtml#_idTextAnchor302)找到。
- en: Installing the Postgres database
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Postgres数据库
- en: 'We will be using the Postgres database in this chapter, which needs installation.
    To install Postgres, follow these steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Postgres数据库，这需要安装。要安装Postgres，请按照以下步骤操作：
- en: 'Go to the following web page: [https://www.postgresql.org/download/](B18384_14.xhtml#_idTextAnchor301).'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问以下网页：[https://www.postgresql.org/download/](B18384_14.xhtml#_idTextAnchor301)。
- en: Follow the installation instructions for your operating system.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照您操作系统的安装说明进行操作。
- en: The code has been tested with version 14.5\. It is expected to work on all versions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已与14.5版本进行测试。预计将在所有版本上工作。
- en: With the setup completed, let’s get started implementing our database code.
    In the next section, we will use the DBRider framework to create a database integration
    test.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，让我们开始实现数据库代码。在下一节中，我们将使用DBRider框架创建数据库集成测试。
- en: Creating a database integration test
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库集成测试
- en: In this section, we will create the skeleton of a database integration test
    using a test framework called DBRider. We will use this test to drive out the
    creation of a database table and database user. We will be working towards implementing
    the `WordRepository` interface, which will access words stored in a Postgres database.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用名为DBRider的测试框架创建数据库集成测试的框架。我们将使用这个测试来驱动数据库表和数据库用户的创建。我们将致力于实现`WordRepository`接口，该接口将访问存储在Postgres数据库中的单词。
- en: Previously, we created a domain model for our Wordz application, using hexagonal
    architecture to guide us. Instead of accessing a database directly, our domain
    model uses an abstraction, known as a `WordRepository` interface, which represents
    stored words for guessing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们为Wordz应用程序创建了一个领域模型，使用六边形架构来指导我们。我们的领域模型不是直接访问数据库，而是使用一个名为`WordRepository`接口的抽象，它代表用于猜测的存储单词。
- en: Ports must always be implemented by adapters in hexagonal architecture. An adapter
    for the `WordRepository` interface will be a class that implements the interface,
    containing all the code needed to access the real database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形架构中，端口必须始终由适配器实现。`WordRepository`接口的适配器将是一个实现接口的类，包含访问真实数据库所需的所有代码。
- en: 'To test-drive this adapter code, we will write an integration test, using a
    library that supports testing databases. The library is called DBRider, and is
    one of the dependencies listed in the project’s `gradle.build` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试驱动此适配器代码，我们将编写一个集成测试，使用支持测试数据库的库。这个库叫做DBRider，它是项目`gradle.build`文件中列出的依赖之一：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: DBRider has an accompanying library called **rider-junit5**, which integrates
    with **JUnit5**. With this new test tooling, we can start to write our test. The
    first thing to do is set up the test so that it uses DBRider to connect to our
    Postgres database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DBRider有一个配套的库叫做**rider-junit5**，它与**JUnit5**集成。有了这个新的测试工具，我们可以开始编写测试。首先要做的是设置测试，使其使用DBRider连接到我们的Postgres数据库。
- en: Creating a database test with DBRider
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DBRider创建数据库测试
- en: 'Before we test-drive any application code, we will need a test that is connected
    to our Postgres database, running locally. We start in the usual way, by writing
    a JUnit5 test class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试驱动任何应用程序代码之前，我们需要一个连接到我们的Postgres数据库、在本地上运行的测试。我们以通常的方式开始，编写一个JUnit5测试类：
- en: 'Create a new test class file in the `/test/` directory in the new `com.wordz.adapters.db`
    package:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新`com.wordz.adapters.db`包的`/test/`目录中创建一个新的测试类文件：
- en: '![Figure 14.1 – Integration test](img/Figure_14.01_B18384.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 集成测试](img/Figure_14.01_B18384.jpg)'
- en: Figure 14.1 – Integration test
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 集成测试
- en: The IDE will generate the empty test class for us.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: IDE将为我们生成空测试类。
- en: 'Add the `@DBRider` and `@DBUnit` annotations to the test class:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@DBRider`和`@DBUnit`注解添加到测试类中：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The parameters in the `@DBUnit` annotation mitigate some odd interactions between
    Postgres and the DBRider test framework to do with case sensitivity on table and
    column names.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DBUnit` 注解中的参数减轻了Postgres和DBRider测试框架之间的一些奇怪交互，这些交互与表和列名的大小写敏感性有关。'
- en: 'We want to test that a word can be fetched. Add an empty test method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想测试能否检索一个单词。添加一个空测试方法：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the test. It will fail:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。它将失败：
- en: '![Figure 14.2 – DBRider cannot connect to the database](img/Figure_14.02_B18384.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – DBRider无法连接到数据库](img/Figure_14.02_B18384.jpg)'
- en: Figure 14.2 – DBRider cannot connect to the database
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – DBRider无法连接到数据库
- en: 'The next step to fixing this is to follow the DBRider documentation and add
    code that will be used by the DBRider framework. We add a `connectionHolder` field
    and a `javax.sqlDataSource` field to support that:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复此问题的下一步是遵循DBRider文档并添加将被DBRider框架使用的代码。我们添加一个`connectionHolder`字段和一个`javax.sqlDataSource`字段来支持它：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `dataSource` is the standard **JDBC** way of creating a connection to our
    Postgres database. We run the test. It fails with a different error message:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataSource`是创建与我们的Postgres数据库连接的标准**JDBC**方式。我们运行测试。它以不同的错误消息失败：'
- en: '![Figure 14.3 – dataSource is null](img/Figure_14.03_B18384.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – dataSource为空](img/Figure_14.03_B18384.jpg)'
- en: Figure 14.3 – dataSource is null
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – dataSource为空
- en: 'We correct this by adding a `@BeforeEach` method to set up `dataSource`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过添加一个`@BeforeEach`方法来设置`dataSource`来纠正这个问题：
- en: '[PRE15]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This specifies we want a user called `ciuser` with the password `cipassword`
    to connect to a database called `wordzdb`, running on `localhost` at the default
    port for Postgres (`5432`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了我们想要一个名为`ciuser`、密码为`cipassword`的用户连接到名为`wordzdb`的数据库，该数据库在`localhost`上以Postgres的默认端口（`5432`）运行。
- en: 'Run the test and see it fail:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并查看它失败：
- en: '![Figure 14.4 – User does not exist](img/Figure_14.04_B18384.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 用户不存在](img/Figure_14.04_B18384.jpg)'
- en: Figure 14.4 – User does not exist
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 用户不存在
- en: The error is caused because we do not have a `ciuser` user known to our Postgres
    database yet. Let’s create one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 错误产生的原因是我们还没有在我们的Postgres数据库中知道名为`ciuser`的用户。让我们创建一个。
- en: 'Open a `psql` terminal and create the user:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`psql`终端并创建用户：
- en: '[PRE25]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the test again:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试：
- en: '![Figure 14.5 – Database not found](img/Figure_14.05_B18384.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 数据库未找到](img/Figure_14.05_B18384.jpg)'
- en: Figure 14.5 – Database not found
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 数据库未找到
- en: It fails because the DBRider framework is looking to connect our new `ciuser`
    user to the `wordzdb` database. This database does not exist.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败，因为DBRider框架正在尝试将我们的新`ciuser`用户连接到`wordzdb`数据库。此数据库不存在。
- en: 'In the `psql` terminal, create the database:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`psql`终端中创建数据库：
- en: '[PRE26]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the test again:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试：
- en: '![Figure 14.6 – Test passes](img/Figure_14.06_B18384.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 测试通过](img/Figure_14.06_B18384.jpg)'
- en: Figure 14.6 – Test passes
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 测试通过
- en: The `fetchesWord()` test now passes. We recall that the test method itself is
    empty, but this means we have enough database set up to proceed with test-driving
    production code. We will return to database setup soon enough, but we will allow
    our test-driving to guide us. The next job is to add the missing Arrange, Act,
    and Assert code to the `fetchesWord()` test.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchesWord()` 测试现在通过了。我们回忆起测试方法本身是空的，但这意味着我们已经有了足够的数据库设置来继续进行测试驱动开发代码。我们很快就会回到数据库设置，但我们将让测试驱动引导我们。下一项任务是向
    `fetchesWord()` 测试中添加缺失的 Arrange、Act 和 Assert 代码。'
- en: Driving out the production code
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱动生产代码
- en: 'Our goal is to test-drive code to fetch a word from the database. We want that
    code to be in a class that implements the `WordRepository` interface, which we
    defined in the domain model. We will want to design enough of our database schema
    to support this. By starting to add code to the *Assert* step, we can drive out
    an implementation quickly. This is a useful technique – writing the test by starting
    with the assert, so that we start with the desired outcome. We can then work backward
    to include everything necessary for delivering it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是通过测试驱动代码从数据库中获取一个单词。我们希望这段代码在一个实现 `WordRepository` 接口的类中，这是我们定义在领域模型中的。我们将需要设计足够的数据库模式来支持这一点。通过从
    *Assert* 步骤开始添加代码，我们可以快速实现一个实现。这是一个有用的技术——从断言开始编写测试，这样我们就从期望的结果开始。然后我们可以反向工作，包括实现它所需的一切：
- en: 'Add the Assert step to our `fetchesWord()` test:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将断言步骤添加到我们的 `fetchesWord()` 测试中：
- en: '[PRE27]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We want to check that we can fetch the word `ARISE` from the database. This
    test fails. We need to create a class to contain the necessary code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望检查能否从数据库中获取单词 `ARISE`。这个测试失败了。我们需要创建一个类来包含必要的代码。
- en: 'We want our new adapter class to implement the `WordRepository` interface,
    so we drive this out in the Arrange step of our test:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望我们的新适配器类实现 `WordRepository` 接口，因此我们在测试的 Arrange 步骤中驱动这一点：
- en: '[PRE32]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now let the IDE wizard do most of the work in creating our new adapter class.
    Let’s call it `WordRepositoryPostgres`, which links the two facts that the class
    implements the `WordRepository` interface and is also implementing access to a
    Postgres database. We use the `com.wordz.adapters.db`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们让 IDE 工具在创建我们的新适配器类时做大部分工作。让我们称它为 `WordRepositoryPostgres`，它连接了两个事实：该类实现了
    `WordRepository` 接口，并且也在实现访问 Postgres 数据库。我们使用 `com.wordz.adapters.db`：
- en: '![Figure 14.7 – New Class wizard](img/Figure_14.07_B18384.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 新类向导](img/Figure_14.07_B18384.jpg)'
- en: Figure 14.7 – New Class wizard
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 新类向导
- en: 'This results in an empty skeleton for the class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致类的骨架为空：
- en: '[PRE39]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The IDE will auto-generate method stubs for the interface:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE 将自动生成接口的方法存根：
- en: '[PRE40]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Returning to our test, we can add the act line, which will call the `fetchWordByNumber()`
    method:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到我们的测试，我们可以添加 act 行，这将调用 `fetchWordByNumber()` 方法：
- en: '[PRE50]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A word of explanation about the mysterious constant `27` passed in to the `fetchWordByNumber()`
    method. This is an *arbitrary* number used to identify a particular word. Its
    only hard requirement is that it must line up with the word number given in the
    stub test data, which we will see a little later in a JSON file. The actual value
    of `27` is of no significance beyond lining up with the word number of the stub
    data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于传递给 `fetchWordByNumber()` 方法的神秘常量 `27` 的解释。这是一个 *任意* 的数字，用于标识特定的单词。它的唯一硬性要求是它必须与稍后将在
    JSON 文件中看到的存根测试数据中的单词编号相匹配。`27` 的实际值在匹配存根数据中的单词编号之外没有意义。
- en: 'Pass `dataSource` in to the `WordRepositoryPostgres` constructor so that our
    class has a way to access the database:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dataSource` 传递给 `WordRepositoryPostgres` 构造函数，以便我们的类能够访问数据库：
- en: '[PRE58]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This drives out a change to the constructor:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致构造函数发生了变化：
- en: '[PRE66]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The last bit of setup to do in our test is to populate the database with the
    word `ARISE`. We do this using a JSON file that the DBRider framework will apply
    to our database on test startup:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的测试中要做的最后一点设置是将单词 `ARISE` 填充到数据库中。我们使用 DBRider 框架在测试启动时应用到我们的数据库中的 JSON 文件来完成此操作：
- en: '[PRE67]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `"word_number": 27` code here corresponds to the value used in the test
    code.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的 `"word_number": 27` 代码对应于测试代码中使用的值。'
- en: 'This file must be saved in a specific location so that DBRider can find it.
    We call the file `wordTable.json` and save it in the test directory, in `/resources/adapters/data`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文件必须保存在特定位置，以便 DBRider 可以找到它。我们称此文件为 `wordTable.json` 并将其保存在测试目录中的 `/resources/adapters/data`：
- en: '![Figure 14.8 – Location of wordTable.json](img/Figure_14.08_B18384.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8 – wordTable.json 的位置](img/Figure_14.08_B18384.jpg)'
- en: Figure 14.8 – Location of wordTable.json
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – wordTable.json的位置
- en: 'The final step in setting up our failing test is to link the test data `wordTable.json`
    file to our `fetchesWord()` test method. We do this using the DBRider `@``DataSet`
    annotation:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的失败测试的最终一步是将测试数据`wordTable.json`文件链接到我们的`fetchesWord()`测试方法。我们使用DBRider的`@DataSet`注解来完成此操作：
- en: '[PRE75]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The test now fails and is in a position where we can make it pass by writing
    the database access code. In the next section, we will use the popular library
    JDBI to implement database access in an adapter class for our `WordRepository`
    interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在失败了，并且处于我们可以通过编写数据库访问代码使其通过的位置。在下一节中，我们将使用流行的库JDBI为我们的`WordRepository`接口实现适配器类的数据库访问。
- en: Implementing the WordRepository adapter
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现WordRepository适配器
- en: In this section, we will use the popular database library JDBI to implement
    the `fetchWordByNumber()` method of `interface WordRepository` and make our failing
    integration test pass.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用流行的数据库库JDBI来实现`WordRepository`接口的`fetchWordByNumber()`方法，并使我们的失败集成测试通过。
- en: Hexagonal architectures were covered in [*Chapter 9*](B18384_09.xhtml#_idTextAnchor179),
    *Hexagonal Architecture – Decoupling External Systems*. An external system like
    a database is accessed through a port in the domain model. The code that is specific
    to that external system is contained in an adapter. Our failing test enables us
    to write the database access code to fetch a word to guess.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18384_09.xhtml#_idTextAnchor179)中介绍了六边形架构，*六边形架构 – 解耦外部系统*。外部系统，如数据库，通过领域模型中的端口进行访问。特定于该外部系统的代码包含在适配器中。我们的失败测试使我们能够编写数据库访问代码以获取一个要猜测的单词。
- en: A little bit of database design thinking needs to be done before we begin writing
    code. For the task at hand, it is enough to note that we will store all available
    words to guess in a database table named `word`. This table will have two columns.
    There will be a primary key named `word_number` and a five-letter word in a column
    named `word`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，需要做一些数据库设计思考。对于当前任务，我们只需注意，我们将把所有可猜测的单词存储在名为`word`的数据库表中。这个表将有两个列。将有一个名为`word_number`的主键和一个名为`word`的五个字母的单词列。
- en: 'Let’s test-drive this out:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: 'Run the test to reveal that the `word` table does not exist:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以显示`word`表不存在：
- en: '![Figure 14.9 – Table not found](img/Figure_14.09_B18384.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9 – 表未找到](img/Figure_14.09_B18384.jpg)'
- en: Figure 14.9 – Table not found
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – 表未找到
- en: 'Correct this by creating a `word` table in the database. We use the `psql`
    console to run the SQL `create` `table` command:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在数据库中创建一个`word`表来纠正这个问题。我们使用`psql`控制台运行SQL `create` `table`命令：
- en: '[PRE84]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Run the test again. The error changes to show our `ciuser` user has insufficient
    permissions:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。错误变为显示我们的`ciuser`用户权限不足：
- en: '![Figure 14.10 – Insufficient permissions](img/Figure_14.10_B18384.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10 – 权限不足](img/Figure_14.10_B18384.jpg)'
- en: Figure 14.10 – Insufficient permissions
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – 权限不足
- en: 'We correct this by running the SQL `grant` command in the `psql` console:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在`psql`控制台中运行SQL `grant`命令来纠正这个问题：
- en: '[PRE86]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Run the test again. The error changes to show us that the `word` has not been
    read from the database table:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。错误变为显示`word`尚未从数据库表中读取：
- en: '![Figure 14.11 – Word not found](img/Figure_14.11_B18384.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图14.11 – 未找到单词](img/Figure_14.11_B18384.jpg)'
- en: Figure 14.11 – Word not found
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 – 未找到单词
- en: Accessing the database
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数据库
- en: 'Having set up the database side of things, we can move on to adding the code
    that will access the database. The first step is to add the database library we
    will use. It is JDBI, and to use it, we must add the `jdbi3-core` dependency to
    our `gradle.build` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好数据库方面的事情之后，我们可以继续添加将访问数据库的代码。第一步是添加我们将使用的数据库库。它是JDBI，为了使用它，我们必须将`jdbi3-core`依赖项添加到我们的`gradle.build`文件中：
- en: '[PRE87]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code itself is as described in the JDBI documentation, found here: [https://jdbi.org/#_queries](B18384_14.xhtml#_idTextAnchor300).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身如JDBI文档中所述，可在以下链接找到：[https://jdbi.org/#_queries](B18384_14.xhtml#_idTextAnchor300)。
- en: 'Follow these steps to access the database:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤访问数据库：
- en: 'First, create a `jdbi` object in the constructor of our class:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们的类构造函数中创建一个`jdbi`对象：
- en: '[PRE88]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This gives us access to the JDBI library. We have arranged it so that JDBI will
    access whatever `DataSource` we pass into our constructor.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够访问JDBI库。我们已经安排好，JDBI将访问我们传递给构造函数的任何`DataSource`。
- en: 'We add the JDBI code to send a SQL query to the database and fetch the word
    corresponding to the `wordNumber` we provide as a method parameter. First, we
    add the SQL query we will use:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 JDBI 代码添加到发送 SQL 查询到数据库并获取我们作为方法参数提供的 `wordNumber` 对应的单词。首先，我们添加我们将使用的 SQL
    查询：
- en: '[PRE96]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `jdbi` access code can be added to the `fetchWordByNumber()` method:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jdbi` 访问代码可以被添加到 `fetchWordByNumber()` 方法中：'
- en: '[PRE99]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Run the test again:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试：
- en: '![Figure 14.12 – Test passing](img/Figure_14.12_B18384.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – 测试通过](img/Figure_14.12_B18384.jpg)'
- en: Figure 14.12 – Test passing
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 测试通过
- en: Our integration test now passes. The adapter class has read the word from the
    database and returned it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的集成测试通过了。适配器类已从数据库中读取单词并返回。
- en: Implementing GameRepository
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 GameRepository
- en: The same process is used to test-drive the `highestWordNumber()` method and
    to create adapters for the other database access code implementing the `GameRepository`
    interface. The final code for these can be seen on GitHub with comments to explore
    some of the issues in database testing, such as how to avoid test failures caused
    by stored data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的过程用于测试驱动 `highestWordNumber()` 方法并为实现 `GameRepository` 接口的其它数据库访问代码创建适配器。这些代码的最终版本可以在
    GitHub 上看到，其中包含了一些关于数据库测试问题的注释，例如如何避免由存储数据引起的测试失败。
- en: There is a manual step needed to test-drive the implementation code for the
    `GameRepository` interface. We must create a `game` table.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个手动步骤来测试驱动 `GameRepository` 接口的实现代码。我们必须创建一个 `game` 表。
- en: 'In psql, type the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 psql 中，输入以下内容：
- en: '[PRE109]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have created an integration test for our database. We used
    that to test-drive the implementation of a database user, the database table,
    and the code needed to access our data. This code implemented the adapter for
    one of our ports in our hexagonal architecture. Along the way, we used some new
    tools. The DBRider database test framework simplified our test code. The JDBI
    database access library simplified our data access code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的数据库创建了一个集成测试。我们使用它来测试驱动数据库用户的实现、数据库表以及访问我们数据的代码。此代码实现了我们六边形架构中的一个端口适配器。在这个过程中，我们使用了一些新工具。DBRider
    数据库测试框架简化了我们的测试代码。JDBI 数据库访问库简化了我们的数据访问代码。
- en: In the next and final chapter, [*Chapter 15*](B18384_15.xhtml#_idTextAnchor306),
    *Driving the Web Layer*, we will add an HTTP interface to our application, turning
    it into a complete microservice. We will integrate all the components together,
    then play our first game of Wordz using the HTTP test tool Postman.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章，[*第 15 章*](B18384_15.xhtml#_idTextAnchor306)，*驱动 Web 层*，我们将向我们的应用程序添加
    HTTP 接口，使其成为一个完整的微服务。我们将集成所有组件，然后使用 HTTP 测试工具 Postman 玩我们的第一次 Wordz 游戏。
- en: Questions and answers
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: Should we automate the manual steps of creating the database?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否应该自动化创建数据库的手动步骤？
- en: Yes. This is an important part of DevOps, where we developers are responsible
    for getting the code into production and keeping it running there. The key technique
    is **Infrastructure as Code** (**IaC**), which means automating manual steps as
    code that we check in to the main repository.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。这是 DevOps 的重要部分，我们开发者负责将代码部署到生产环境并保持其运行。关键技术是 **基础设施即代码**（**IaC**），这意味着将手动步骤作为代码自动化，并将其提交到主仓库。
- en: What tools can help with automating database creation?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些工具可以帮助自动化数据库创建？
- en: Popular tools are **Flyway** and **Liquibase**. Both allow us to write scripts
    that are run at application startup and will migrate the database schema from
    one version to the next. They assist in migrating data across schema changes where
    that is required. These are outside the scope of this book.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 流行工具是 **Flyway** 和 **Liquibase**。两者都允许我们编写在应用程序启动时运行的脚本，并将数据库模式从一种版本迁移到另一种版本。它们在需要迁移数据跨模式更改时提供帮助。这些也超出了本书的范围。
- en: What tools can help with installing the database?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些工具可以帮助安装数据库？
- en: Access to a running database server is part of platform engineering. For cloud-native
    designs that run on Amazon Web Service, Microsoft Azure, or Google Cloud Platform,
    use configuration scripting for that platform. One popular approach is to use
    Hashicorp’s **Terraform**, which aims to be a cross-provider universal scripting
    language for cloud configuration. This is outside of the scope of this book.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 访问运行中的数据库服务器是平台工程的一部分。对于在亚马逊网络服务、微软 Azure 或谷歌云平台运行的云原生设计，使用该平台的配置脚本。一种流行的方法是使用
    Hashicorp 的 **Terraform**，它旨在成为云配置的跨提供商通用脚本语言。这超出了本书的范围。
- en: How often should we run the integration tests?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该多久运行一次集成测试？
- en: Before every check-in to the repository. While unit tests are fast to run and
    should be run all the time, integration tests by nature are slower to execute.
    It is reasonable to run only unit tests while working on domain code. We must
    always ensure we haven’t broken anything unexpectedly. This is where running integration
    tests comes in. These reveal whether we have accidentally changed something that
    affects the adapter layer code, or whether something has changed regarding database
    layout.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次向仓库提交之前。虽然单元测试运行速度快，应该一直运行，但集成测试由于本质上是慢速执行的。在编写领域代码时仅运行单元测试是合理的。我们必须始终确保我们没有意外地破坏任何东西。这就是运行集成测试的用武之地。这些测试会揭示我们是否意外地更改了影响适配器层代码的内容，或者数据库布局是否有所变化。
- en: Further reading
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Documentation for DBRider: [https://github.com/database-rider/database-rider](B18384_14.xhtml#_idTextAnchor299)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DBRider 的文档：[https://github.com/database-rider/database-rider](B18384_14.xhtml#_idTextAnchor299)
- en: 'JDBI documentation: [https://jdbi.org/#_introduction_to_jdbi_3](B18384_14.xhtml#_idTextAnchor298)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBI 文档：[https://jdbi.org/#_introduction_to_jdbi_3](B18384_14.xhtml#_idTextAnchor298)
- en: 'Flyway is a library that allows us to store the SQL commands to create and
    modify our database schema as source code. This allows us to automate database
    changes: [https://flywaydb.org/](B18384_14.xhtml#_idTextAnchor297)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flyway 是一个库，允许我们将创建和修改数据库模式的 SQL 命令作为源代码存储。这使得我们可以自动化数据库更改：[https://flywaydb.org/](B18384_14.xhtml#_idTextAnchor297)
- en: 'As our application design grows, our database schema will need to change. This
    website and the accompanying books describe ways to do this while managing risk:
    [https://databaserefactoring.com/](B18384_14.xhtml#_idTextAnchor296)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着我们的应用程序设计不断发展，我们的数据库模式也需要进行更改。本网站和配套书籍描述了如何在管理风险的同时进行这种更改：[https://databaserefactoring.com/](B18384_14.xhtml#_idTextAnchor296)
- en: 'Hosting a Postgres database on Amazon Web Services using their RDS service:
    [https://aws.amazon.com/rds](B18384_14.xhtml#_idTextAnchor295)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在亚马逊网络服务上托管 Postgres 数据库，使用他们的 RDS 服务：[https://aws.amazon.com/rds](B18384_14.xhtml#_idTextAnchor295)
