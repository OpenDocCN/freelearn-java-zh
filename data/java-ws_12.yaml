- en: 12\. Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 正则表达式
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter discusses regular expressions and considers both how and why they
    are so useful in Java. To begin, you will first explore how to construct these
    expressions in order to search for information in your program—a fundamental skill
    for any developer. When you have a firm understanding of the nature and function
    of these regular expressions, you will be able to use them to perform simple full-body
    matches in your search, and, later in the chapter, to extract substrings from
    a text using groups and non-capturing groups. In the final exercise, you have
    to employ all of these skills to perform recursive matches and extract a set of
    similar elements (i.e. a pattern) from a text.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论正则表达式，并考虑了它们在Java中为何以及如何如此有用。首先，你将探索如何构建这些表达式以便在程序中搜索信息——这是任何开发者的一项基本技能。当你对正则表达式的本质和功能有了牢固的理解后，你将能够使用它们在搜索中执行简单的全文匹配，并在本章的后面部分，使用组和非捕获组从文本中提取子字符串。在最后的练习中，你必须运用所有这些技能来执行递归匹配，并从文本中提取一组相似元素（即模式）。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In your career as a developer, you will often find a search for information
    to be a logical first step to problem-solving: searching for documentation, searching
    for a specific line of code, or just making a program that extracts information
    from a given body of text into data that the program can understand.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的开发者职业生涯中，你经常会发现搜索信息是解决问题的逻辑第一步：搜索文档、搜索特定的代码行，或者只是编写一个程序，从给定的文本体中提取信息，使其成为程序可以理解的数据。
- en: A regular expression is a specific language for defining these search rules,
    much like Java is a language to construct programs. The syntax can be quite complex.
    When you see a regular expression for the first time, it can be daunting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是定义这些搜索规则的一种特定语言，就像Java是一种构建程序的语言一样。其语法可能相当复杂。当你第一次看到正则表达式时，可能会感到有些令人畏惧。
- en: 'The following is a very basic pattern matcher for an email address construction,
    with many flaws:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个非常基础的用于构建电子邮件地址的模式匹配器，存在许多缺陷：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you''re seeing this for the first time, you might think that it''s a typographical
    error (or that a cat was involved). However, it''s perfectly legitimate code.
    We''ll dive deeper into the construction of this example shortly, but first, let''s
    take a look at a more thorough pattern-matcher that validates an email address''
    construction:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次看到这个，你可能会认为这是一个打字错误（或者认为一只猫参与了其中）。然而，这是一段完全合法的代码。我们很快就会深入探讨这个示例的构建，但首先，让我们看看一个更详尽的模式匹配器，它可以验证电子邮件地址的构建：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This looks like even more gibberish to the novice. Perhaps the same cat was
    making a nest on your keyboard.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，这看起来更像是一堆乱码。也许同样的猫正在你的键盘上筑巢。
- en: In this chapter, we uncover the logic behind this madness. We will start with
    decrypting what regular expressions mean, then look at how this will come in handy
    in Java.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将揭示这种疯狂背后的逻辑。我们将从解码正则表达式的含义开始，然后看看这如何在Java中派上用场。
- en: Decrypting Regular Expressions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码正则表达式
- en: The way regular expressions are constructed follows some basic rules that are
    the same on every platform and implementation; however, there are some implementation-specific
    rules that might vary depending on the platform and implementation the regular
    expression was constructed for.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的构建遵循一些基本规则，这些规则在所有平台和实现中都是相同的；然而，有些实现特定的规则可能会根据正则表达式构建的平台和实现而有所不同。
- en: Let's revisit our initial email pattern matching `/.+\@.+\..+/` expression.
    We can see that it starts with a slash mark like this, `/` and ends with a `/`.
    These are the opening and closing markers for the expression; anything within
    these characters belongs to the actual expression.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下最初的电子邮件模式匹配表达式 `/.+\@.+\..+/`。我们可以看到它以一个斜杠标记开始，像这样 `/`，并以一个斜杠结束。这些是表达式的开始和结束标记；这些字符之间的任何内容都属于实际的表达式。
- en: Regular expressions are constructed from a few basic components; they are character
    classes, anchors, groups, and special escape characters. Then, we have the quantifiers
    that control how many of the preceding characters should be matched. Last but
    not least, we have the expression flags, which control certain behaviors for the
    whole expression. Let's look at them in more detail in the upcoming sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式由几个基本组件构成；它们是字符类、锚点、组和特殊转义字符。然后，我们有量词，它控制应该匹配前面多少个字符。最后但同样重要的是，我们有表达式标志，它控制整个表达式的某些行为。让我们在接下来的章节中更详细地看看它们。
- en: Character Classes
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类
- en: Character classes define the sets of characters that the pattern matcher will
    search for. The set is defined in square brackets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类定义了模式匹配器将搜索的字符集。集是在方括号中定义的。
- en: 'The expression `[xyz]` will match an `x`, `a y`, or a `z`. These are case sensitive,
    so an `X` will not match. If you''re matching characters that follow alphabetically,
    you can replace the expression with a range. Instead of `[xyz]`, you can write
    `[x-z]`. This is very convenient if you want to cover many characters in your
    expression:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `[xyz]` 将匹配一个 `x`、`a y` 或一个 `z`。这些是区分大小写的，所以 `X` 不会匹配。如果你要匹配按字母顺序排列的字符，你可以用范围来替换表达式。而不是
    `[xyz]`，你可以写成 `[x-z]`。如果你想在表达式中覆盖很多字符，这非常方便：
- en: '![Figure 12.1: Regular expressions for character classes'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1：字符类的正则表达式](img/C13927_12_01.jpg)'
- en: '](img/C13927_12_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_02.jpg)'
- en: 'Figure 12.1: Regular expressions for character classes'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：字符类的正则表达式
- en: There are also predefined character classes. These allow you to search for specific
    sets of characters without having to type out the full character set. For example,
    the dot (`.`) shown earlier will match any character except for line breaks. Written
    out in full as a set, the expression for this search would look like `[^\n\r]`,
    so you can see how just using `.` is quicker and easier. You can see in the following
    tables what the `^`, `\n`, and `\r` symbols represent.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也存在预定义的字符类。这些允许你搜索特定的字符集，而无需输入完整的字符集。例如，前面提到的点（`.`）将匹配除换行符之外的任何字符。如果完整地写出作为一个集合，这个搜索的表达式看起来会是
    `[^\n\r]`，所以你可以看到仅使用 `.` 是更快更简单的。你可以在以下表中看到 `^`、`\n` 和 `\r` 符号代表什么。
- en: You can also search using negated sets. This will match everything that is not
    part of that set.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用否定集进行搜索。这将匹配不属于该集的任何内容。
- en: Character Sets
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符集
- en: 'A character set matches any character defined in the set. The following figure
    shows a couple of examples:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 字符集匹配集合中定义的任何字符。以下图示展示了几个示例：
- en: '![Figure 12.2: Regular expressions for character sets'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2：字符集的正则表达式](img/C13927_12_04.jpg)'
- en: '](img/C13927_12_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_01.jpg)'
- en: 'Figure 12.2: Regular expressions for character sets'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：字符集的正则表达式
- en: 'Predefined character sets help you build quick expressions. The following figure
    lists predefined character sets, which are useful for building quick expressions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义字符集帮助你快速构建表达式。以下图列出了预定义字符集，这对于构建快速表达式很有用：
- en: '![Figure 12.3: Regular expressions for predefined character sets'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3：预定义字符集的正则表达式](img/C13927_12_03.jpg)'
- en: '](img/C13927_12_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_03.jpg)'
- en: 'Figure 12.3: Regular expressions for predefined character sets'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：预定义字符集的正则表达式
- en: Quantifiers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量词
- en: 'Quantifiers are simple rules that allow you to define how the preceding character
    sets should be matched. Should only one of the characters be allowed, or a range
    between one and three? See the following figure for acceptable quantifiers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 量词是简单的规则，允许你定义前面的字符集应该如何匹配。是否只允许一个字符，或者一个介于一个和三个之间的范围？请参见以下图示以了解可接受的量词：
- en: '![Figure 12.4: Regular expressions for quantifiers'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.4：量词的正则表达式](img/C13927_12_04.jpg)'
- en: '](img/C13927_12_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_02.jpg)'
- en: 'Figure 12.4: Regular expressions for quantifiers'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：量词的正则表达式
- en: Anchors
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锚点
- en: 'Anchors give you one extra dimension of control so you can define the boundaries
    in a text rather than the text itself:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点为你提供了一个额外的控制维度，这样你就可以定义文本的边界而不是文本本身：
- en: '![Figure 12.5: Regular expressions for anchors'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.5：锚点的正则表达式](img/C13927_12_05.jpg)'
- en: '](img/C13927_12_05.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_05.jpg)'
- en: 'Figure 12.5: Regular expressions for anchors'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：锚点的正则表达式
- en: Capturing Groups
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获组
- en: 'Capturing groups allow you to group tokens in an expression to form sub-strings.
    Any capturing token can be used within a group, including nesting other groups.
    They also allow for reuse in the expression using references:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获组允许你在表达式中对标记进行分组以形成子字符串。任何捕获标记都可以在组中使用，包括嵌套其他组。它们还允许在表达式中使用引用进行重用：
- en: '![Figure 12.6: Regular expressions for capturing groups'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：捕获组的正则表达式'
- en: '](img/C13927_12_06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_06.jpg)'
- en: 'Figure 12.6: Regular expressions for capturing groups'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：捕获组的正则表达式
- en: Escaped Characters
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义字符
- en: You can use the `\` character to escape characters to match them in the string.
    It is useful for matching serialized data such as XML and JSON. It is also used
    to match non-text characters such as a tab and a newline.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用反斜杠字符`\`来转义字符以在字符串中匹配它们。这对于匹配序列化数据（如XML和JSON）非常有用。它也用于匹配非文本字符，如制表符和换行符。
- en: 'Here are some common escaped characters:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常见的转义字符：
- en: '![Figure 12.7: Regular expressions for escaped characters'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7：转义字符的正则表达式'
- en: '](img/C13927_12_07.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_07.jpg)'
- en: 'Figure 12.7: Regular expressions for escaped characters'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：转义字符的正则表达式
- en: Flags
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志
- en: Any characters placed directly after the closing marker are called flags. There
    are five flags, which you may combine in any way, though you may avoid using flags
    altogether.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 直接放置在结束标记之后的任何字符都称为标志。有五个标志，你可以以任何方式组合它们，尽管你可以完全避免使用标志。
- en: '![Figure 12.8: Regular expressions for flags'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：标志的正则表达式'
- en: '](img/C13927_12_08.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_08.jpg)'
- en: 'Figure 12.8: Regular expressions for flags'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：标志的正则表达式
- en: Now that you have a basic understanding of how these regular expressions work,
    let's look at a full-fledged example in the following exercise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经基本了解了这些正则表达式的工作原理，让我们在下面的练习中看看一个完整的示例。
- en: 'Exercise 1: Implementing Regular Expressions'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1：实现正则表达式
- en: Using an online regular expression checker, we'll build a regular expression
    that verifies whether a street address is correctly specified. The format that
    the address follows is the street name followed by the street number. The street
    name and the street number are separated by a single whitespace.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在线正则表达式检查器，我们将构建一个正则表达式来验证街道地址是否正确指定。地址遵循的格式是街道名称后跟街道号码。街道名称和街道号码之间用一个空格分隔。
- en: 'We will check if the following common Swedish addresses are valid or not:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查以下常见的瑞典地址是否有效：
- en: Strandvagen 1
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Strandvagen 1
- en: Storgatan 2
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storgatan 2
- en: Ringvagen3
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ringvagen3
- en: Storgatan
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storgatan
- en: 'Note:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：
- en: We will use [https://packt.live/2MYzyFq](https://packt.live/2MYzyFq) for this
    exercise because of its easy-to-use interface and modern feel. However, the regular
    expression should work on other platforms as well.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用[https://packt.live/2MYzyFq](https://packt.live/2MYzyFq)进行此练习，因为它具有易于使用的界面和现代感。然而，正则表达式也应该在其他平台上工作。
- en: 'To complete the exercise, perform the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成练习，请执行以下步骤：
- en: Visit [https://packt.live/2MYzyFq](https://packt.live/2MYzyFq).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://packt.live/2MYzyFq](https://packt.live/2MYzyFq)。
- en: 'Enter three different local addresses of your choice in the space under the
    title `Text`, at least one should be incorrectly formatted. The addresses I''ve
    chosen are `Strandvagen 1`, `Storgatan 2`, and `Ringvagen3`. These are all very
    common street names in Sweden, the last of which is incorrectly formatted as it
    is lacking a whitespace between the street name and the number.![Figure 12.9:
    Inputting incorrectly formatted text'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标题“文本”下的空间中输入你选择的三个不同的本地地址，至少有一个地址格式不正确。我选择的地址是“Strandvagen 1”、“Storgatan 2”和“Ringvagen3”。这些都是瑞典非常常见的街道名称，最后一个地址格式不正确，因为它在街道名称和号码之间缺少空格。![图12.9：输入格式不正确的文本
- en: '](img/C13927_12_09.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C13927_12_09.jpg)'
- en: 'Figure 12.9: Inputting incorrectly formatted text'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.9：输入格式不正确的文本
- en: 'From the simple rules we defined, we can extract the following:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从我们定义的简单规则中，我们可以提取以下内容：
- en: the street address must start with a name
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 街道地址必须以名称开头
- en: the street address should have a number
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 街道地址应该有一个号码
- en: 'Add the first rule. The name is an alphabetic-only word (i.e. contains only
    letters):![Figure 12.10: Adding the first rule'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一条规则。名称是一个仅包含字母的单词（即只包含字母）：![图12.10：添加第一条规则
- en: '](img/C13927_12_10.jpg)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C13927_12_10.jpg)'
- en: 'Figure 12.10: Adding the first rule'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.10：添加第一条规则
- en: 'Let there be, at most, one empty space between the digit and the number. We
    can already see that one address is incorrectly formatted:![Figure 12.11: Modifying
    the rule to consider one empty space between digit and number'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数字和数字之间，最多只能有一个空格。我们已经开始看到有一个地址格式不正确：![图12.11：修改规则以考虑数字和数字之间有一个空格
- en: '](img/C13927_12_11.jpg)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C13927_12_11.jpg)'
- en: 'Figure 12.11: Modifying the rule to consider one empty space between digit
    and number'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.11：修改规则以考虑数字和数字之间有一个空格
- en: 'Add at least one digit to the address. Now one more address has disappeared:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少在地址中添加一个数字。现在又有一个地址消失了：
- en: '![Figure 12.12: Modifying the rule to add one digit to the address'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12：修改规则以在地址中添加一个数字'
- en: '](img/C13927_12_12.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_12_12.jpg)'
- en: 'Figure 12.12: Modifying the rule to add one digit to the address'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：修改规则以在地址中添加一个数字
- en: This example shows a simple procedure to construct a regular expression to validate
    an address.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了一个简单的构建正则表达式以验证地址的过程。
- en: 'Activity 1: Regular Expressions to Check If the Entrance is Entered in the
    Desired Format'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一：使用正则表达式检查入口是否以期望的格式输入
- en: Add one more rule to the preceding regular expression; allow for one optional
    character after the number. This will define which entrance to use at an address
    that has multiple entrances—for example, `Strandvagen 1a` or `Ringvagen 2b`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的正则表达式中添加一条新规则；允许在数字后面有一个可选字符。这将定义在地址有多个入口时使用哪个入口——例如，`Strandvagen 1a`或`Ringvagen
    2b`。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 560.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第560页找到。
- en: Regular Expressions in Java
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的正则表达式
- en: Now that you have an idea of how regular expressions can be used to match patterns,
    this topic will focus on how regular expressions can be used within Java applications.
    To use regular expressions in Java, the `java.util.regex` package is available.
    The two main classes there are called `Pattern` and `Matcher`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了正则表达式如何用于匹配模式，这个主题将重点介绍如何在Java应用程序中使用正则表达式。要在Java中使用正则表达式，可以使用`java.util.regex`包。那里有两个主要的类，分别称为`Pattern`和`Matcher`。
- en: The `Pattern` class handles the actual pattern; it validates, compiles, and
    returns a `Pattern` object that you can store and reuse multiple times. It can
    also be used to perform quick validations against a supplied string.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pattern`类处理实际的模式；它验证、编译并返回一个可以存储和多次重用的`Pattern`对象。它还可以用于对提供的字符串进行快速验证。'
- en: The `Matcher` class allows us to extract more information, and to perform different
    kinds of matching on the supplied text.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matcher`类允许我们提取更多信息，并在提供的文本上执行不同类型的匹配。'
- en: Creating a `Pattern` object is as simple as using the static `compile` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Pattern`对象就像使用静态的`compile`方法一样简单。
- en: 'For example, you would like to compile a pattern to ensure that a text contains
    at least one `a`. Your Java code should be as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想编译一个模式以确保文本中至少有一个`a`。你的Java代码应该是这样的：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Java, we shouldn't supply the starting and ending token of the regular expression.
    With the `Pattern` object, then, you can perform a match on a given string.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们不应该提供正则表达式的起始和结束标记。有了`Pattern`对象，然后你可以在给定的字符串上执行匹配。
- en: Note that this method will attempt to match the entire string to the regular
    expression; if only part of the string matches the regular expression, it will
    return false.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法将尝试将整个字符串与正则表达式匹配；如果只有字符串的一部分与正则表达式匹配，它将返回false。
- en: 'If, instead, you just wish to make a quick validation, you can use the static
    `matches` method, which will return a Boolean; it is just a shorthand for doing
    exactly the same as the previous example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想进行快速验证，可以使用静态的`matches`方法，它将返回一个布尔值；它只是上一个示例的简写：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Exercise 2: Extracting the Domain Using Pattern Matching'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2：使用模式匹配提取域名
- en: 'In this exercise, you will extract every part of a URL and store them in variables,
    starting with the protocol, then the domain, and then finally the path:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将提取URL的每个部分并将它们存储在变量中，从协议开始，然后是域名，最后是路径：
- en: If IntelliJ IDEA is already started, but no project is open, select `Create
    New Project`. If IntelliJ already has a project open, select `File` -> `New` ->
    `Project` from the menu.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果IntelliJ IDEA已经启动，但没有打开任何项目，请选择`创建新项目`。如果IntelliJ已经打开了一个项目，请从菜单中选择`文件` ->
    `新建` -> `项目`。
- en: In the `New Project` dialog, select a Java project. Click `Next`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`新建项目`对话框中，选择一个Java项目。点击`下一步`。
- en: Check the box to create the project from a template. Select `Command Line App`.
    Click `Next`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开复选框以从模板创建项目。选择`命令行应用程序`。点击`下一步`。
- en: Give the new project the name `Chapter12`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新项目命名为`Chapter12`。
- en: IntelliJ will provide a default project location. You can enter any other desired
    location as well.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IntelliJ将提供默认的项目位置。你也可以输入任何其他希望的位置。
- en: Set the package name to `com.packt.java.chapter12`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包名设置为`com.packt.java.chapter12`。
- en: Click `Finish`. Your project will be created with the standard folder structure,
    and an entry point class for your program.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`完成`。你的项目将以标准文件夹结构创建，并包含程序的入口点类。
- en: 'Rename this file `Exercise2.java`. When you''re done, it should look like this:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件重命名为`Exercise2.java`。完成时，它应该看起来像这样：
- en: '[PRE4]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare this book''s website `url`, which we''ll split into separate parts.
    If you haven''t visited the website yet, you can find it at [https://www.packtpub.com/application-development/mastering-java-9](https://www.packtpub.com/application-development/mastering-java-9):'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明这本书的网站`url`，我们将将其分割成单独的部分。如果你还没有访问过该网站，你可以在[https://www.packtpub.com/application-development/mastering-java-9](https://www.packtpub.com/application-development/mastering-java-9)找到它：
- en: '[PRE5]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll start by finding just the protocol using regular expressions. Declare
    a string to hold the regular expression and call it `regex`. It should contain
    at least the letters `http` and an optional `s`. Wrap the whole expression in
    a group to ensure you can extract it as a substring later:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先使用正则表达式找到协议。声明一个字符串来保存正则表达式，并将其命名为`regex`。它应该至少包含字母`http`和一个可选的`s`。将整个表达式包裹在一个组中，以确保你可以在稍后将其提取为子字符串：
- en: '[PRE6]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This is, of course, just one example of extracting the protocol. You can experiment
    with finding strings before the first colon or other interesting expressions.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这当然只是提取协议的一个例子。你可以尝试找到第一个冒号之前或其它有趣的字符串。
- en: 'Compile the expression into a `pattern` object. Since we''re not performing
    a global match, we''ll not use the shorthand. Instead, we''ll create the `Matcher`
    for later use:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表达式编译成`pattern`对象。由于我们不是进行全局匹配，所以不会使用简写。相反，我们将创建`Matcher`以供以后使用：
- en: '[PRE7]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Attempt to find the first group, using the `find()` method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`find()`方法找到第一个组：
- en: '[PRE8]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the number of available groups using the `groupCount()` method.
    This is very useful if you want to loop through all groups in order.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用`groupCount()`方法找到可用的组数。如果你想要按顺序遍历所有组，这将非常有用。
- en: 'If any matches were found, start extracting the groups into variables. For
    now, simply print the variable:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了匹配项，开始将组提取到变量中。目前，只需简单地打印变量：
- en: '[PRE9]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before capturing the domain name, we need to ignore the useless characters
    between that and the protocol—the `://`. Add a non-capturing group for those characters:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在捕获域名之前，我们需要忽略域名和协议之间的无用字符——`://`。为这些字符添加一个非捕获组：
- en: '[PRE10]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, add a third group to the regular expression to find the domain. We''ll
    try to find the whole domain, letting the `www` application notation be optional:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在正则表达式中添加第三个组来查找域名。我们将尝试找到整个域名，让`www`应用标记是可选的：
- en: '[PRE11]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, collect the domain group and print it:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，收集域名组并打印出来：
- en: '[PRE12]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, extract the `path` components and print them to the terminal:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，提取`path`组件并将它们打印到终端：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When running this exercise, you should see the following text in the terminal:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个练习时，你应该在终端看到以下文本：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example shows how to use capturing groups to extract only the vital information
    from a small string. However, you'll notice that the match is only performed once.
    In Java, it's easy to do a recursive match on a large body of text using similar
    techniques to this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何使用捕获组从一个小字符串中提取关键信息。然而，你会注意到匹配操作只进行了一次。在Java中，使用类似的技术，对大量文本进行递归匹配很容易。
- en: 'Exercise 3: Extracting Links Using Pattern Matching'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3：使用模式匹配提取链接
- en: In this exercise, you'll perform a recursive matching on the Packt website to
    extract all links, then print these links in the terminal. For simplicity, we'll
    use an already saved dump of the Packt website; of course you can go ahead and
    download the website on your own using curl, wget, or similar tools depending
    on the platform you're using. You can also view the source of the website in your
    favorite browser and copy it to a file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将对Packt网站进行递归匹配以提取所有链接，然后在终端打印这些链接。为了简单起见，我们将使用已保存的Packt网站快照；当然，你也可以根据自己的平台使用curl、wget或类似工具下载网站。你还可以在你的浏览器中查看网站的源代码并将其复制到文件中。
- en: Open the `Chapter12` project in IntelliJ IDEA if it's not already open.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未打开，请打开IntelliJ IDEA中的`Chapter12`项目。
- en: Create a new Java class by going to `File` -> `New` -> `Java Class`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问`File` -> `New` -> `Java Class`创建一个新的Java类。
- en: 'Enter `Exercise 3` as the name and click `OK`. IntelliJ IDEA will create a
    new class, which should look something like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称输入为`Exercise 3`并点击`OK`。IntelliJ IDEA将创建一个新的类，其外观可能如下所示：
- en: '[PRE15]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the main entry point for your program – the `static` `main` method:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的程序创建主入口点——`static` `main`方法：
- en: '[PRE16]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Copy the Packt website dump into your project's `res` folder. If the folder
    doesn't exist, create it as a sibling to `src`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Packt网站的数据包复制到你的项目的`res`文件夹中。如果该文件夹不存在，则将其创建为`src`的兄弟文件夹。
- en: 'Read the contents of the file into a new string; call it `packtDump`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件内容读取到新的字符串中；命名为`packtDump`：
- en: '[PRE17]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Start creating a regular expression for capturing links from a website. They
    usually look something like this. We need to look for the starting and the ending
    tokens of the link, and capture anything in between:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建用于从网站捕获链接的正则表达式。它们通常看起来像这样。我们需要寻找链接的开始和结束标记，并捕获两者之间的任何内容：
- en: '[PRE18]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start by looking for the opening token, `"<a href=\"`:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先寻找开标记，`"<a href=\"`：
- en: '[PRE19]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add another non-capturing group for the ending token. The link ends with the
    next instance of double quotation marks (`"`):'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为结束标记添加另一个非捕获组。链接以下一个双引号实例结束（`"`）：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, add the only capturing group needed for this regular expression—the
    link group:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加这个正则表达式所需的唯一捕获组——链接组：
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compile the pattern and match it against the `packtDump` string:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模式并将其与`packtDump`字符串匹配：
- en: '[PRE22]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a list for storing the links:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于存储链接的列表：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, loop through all matches and add them to the list. We only have one
    capturing group here, so there''s no need to check the number of groups and loop
    through them:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，遍历所有匹配项并将它们添加到列表中。这里我们只有一个捕获组，因此没有必要检查组数并遍历它们：
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you can wrap the exercise up by printing the list to the terminal:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以通过将列表打印到终端来结束练习：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Executing this exercise, you should see a long list of both relative and absolute
    links in your terminal.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此练习时，你应该在终端看到一个包含相对和绝对链接的长列表。
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You''ve successfully extracted the links from the Packt website. A real-world
    application may use this to build site-maps or otherwise document how websites
    are interconnected. The next step in this program is all up to you. The following
    steps will let you analyze the content of the Packt website more thoroughly:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你已成功从Packt网站提取了链接。现实世界的应用可能使用此功能来构建网站地图或以其他方式记录网站之间的相互连接。这个程序的下一步完全取决于你。以下步骤将帮助你更彻底地分析Packt网站的内容：
- en: Remove any non-functional links such as `#` and links back to `home /`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除任何非函数式链接，例如`#`和指向`home /`的链接。
- en: Also, remove all links that start with `http`; only the relative links should
    remain.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，删除所有以`http`开头的链接；只保留相对链接。
- en: The first path of the relative links represents the category of that book. Divide
    the books on the website into different categories and see which category is the
    most popular.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相对链接的第一个路径代表该书的类别。将网站上的书籍分为不同的类别，并查看哪个类别最受欢迎。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've learned how to use regular expressions to search and
    extract information from large bodies of text. This can be very handy when parsing
    structured or semi-structured data. Regular expressions are not specific to Java.
    The Java implementation may differ slightly from other platforms and languages;
    however, the general syntax remains the same.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用正则表达式从大量文本中搜索和提取信息。这在解析结构化或半结构化数据时非常有用。正则表达式并非特定于Java。Java实现可能与其他平台和语言略有不同；然而，通用语法保持不变。
- en: In the next chapter, you'll explore a programming paradigm that is growing in
    popularity. Functional programming, while not originally intended for Java, can
    help you to write programs that you can test more easily, which may limit the
    number of state-changing problems.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索一个日益流行的编程范式。虽然函数式编程最初并非为Java设计，但它可以帮助你编写更容易测试的程序，这可能会限制状态改变问题的数量。
