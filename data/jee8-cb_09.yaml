- en: Using Multithreading on Enterprise Context
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在企业上下文中使用多线程
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下配方：
- en: Building asynchronous tasks with returning results
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用返回结果构建异步任务
- en: Using transactions with asynchronous tasks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务处理异步任务
- en: Checking the status of asynchronous tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查异步任务的状况
- en: Building managed threads with returning results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用返回结果构建管理线程
- en: Scheduling asynchronous tasks with returning results
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用返回结果调度异步任务
- en: Using injected proxies for asynchronous tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注入代理进行异步任务
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Threading** is a common issue in most software projects, no matter which
    language or other technology is involved. When talking about enterprise applications,
    things become even more important, and sometimes harder.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**是大多数软件项目中的常见问题，无论涉及哪种语言或其他技术。当谈到企业应用时，事情变得更加重要，有时也更难。'
- en: A single mistake in some thread can affect the whole system, or even the whole
    infrastructure. Think about some resources that are never released, memory consumption
    that never stops increasing, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些线程中犯的一个错误可能会影响整个系统，甚至整个基础设施。想想看，一些资源永远不会释放，内存消耗永远不会停止增加，等等。
- en: The Java EE environment has some great features for dealing with these and plenty
    of other challenges, and this chapter will show you some of them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 环境有一些处理这些以及其他许多挑战的出色功能，本章将向您展示其中的一些。
- en: Building asynchronous tasks with returning results
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用返回结果构建异步任务
- en: 'One of the first challenges you will face if you have never worked with asynchronous
    tasks is: how on Earth do you return results from an asynchronous task if you
    don''t know when the execution will end?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未处理过异步任务，你将面临的一个首要挑战是：如果你不知道执行何时结束，你该如何从异步任务中返回结果？
- en: Well, this recipe show you how. `AsyncResponse` for the win!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个配方会告诉你如何做。`AsyncResponse` 赢了！
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加我们的 Java EE 8 依赖项：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we create a `User` POJO:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `User` POJO：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we create `UserService` to emulate a *remote* slow endpoint:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建 `UserService` 来模拟一个 *远程* 慢速端点：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we create an asynchronous client that will reach that endpoint and get
    the result:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个异步客户端，它将到达该端点并获取结果：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally, we create a service (endpoint) that will use the client to write
    the result in the response:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个服务（端点），它将使用客户端将结果写入响应：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To run this example, just deploy it in GlassFish 5 and open this URL in your
    browser:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，只需将其部署到 GlassFish 5，并在您的浏览器中打开此 URL：
- en: '`http://localhost:8080/ch09-async-result/asyncService`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch09-async-result/asyncService`'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, our remote endpoint is creating `User` and converting it to a response
    entity:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的远程端点正在创建 `User` 并将其转换为响应实体：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, with no effort at all, your `User` is now a JSON object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，毫不费力，您的 `User` 现在已经是一个 JSON 对象。
- en: 'Now let''s take a look at the key method in `AsyncResultClient`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `AsyncResultClient` 中的关键方法：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `rx()` method is a part of the Reactive Client API introduced in Java EE
    8\. We'll discuss reactive in more detail in the next chapter. It basically returns
    `CompletionStageInvoker`, which will allow you to get `CompletionStage<Response>`
    (the returning value for this method).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`rx()` 方法是 Java EE 8 中引入的响应式客户端 API 的一部分。我们将在下一章中更详细地讨论响应式编程。它基本上返回 `CompletionStageInvoker`，这将允许你获取
    `CompletionStage<Response>`（此方法的返回值）。'
- en: In other words, this is an asynchronous/non-blocking code that gets results
    from the remote endpoint.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这是一段异步/非阻塞代码，它从远程端点获取结果。
- en: 'Note that we use the `@Stateless` annotation with this client so that we can
    inject it into our main endpoint:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `@Stateless` 注解与此客户端一起，这样我们就可以将其注入到我们的主要端点：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s our asynchronous method for writing a response:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的异步方法来写入响应：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that it's a `void` method. It doesn't return anything because it will return
    the result to a callback.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个 `void` 方法。它不返回任何内容，因为它会将结果返回给回调。
- en: 'The `@Suspended` annotation combined with `AsyncResponse` will make the response
    resume once the processing is done, and this happens because we are using the
    beautiful, one-line, Java 8-style code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Suspended` 注解与 `AsyncResponse` 结合使用，将在处理完成后恢复响应，这是因为我们使用了美丽的一行，Java 8 风格的代码：'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before going into the details, let''s just clarify our local `readResponse` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们先澄清我们的本地 `readResponse` 方法：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It just reads the `User` entity embedded in `Response` and transforms it to
    a `String` object (a JSON string).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是读取嵌入在`Response`中的`User`实体并将其转换为`String`对象（一个JSON字符串）。
- en: 'Another way that this one-line code could be written is like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码的另一种写法可以是这样的：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But the first way is more concise, less verbose, and more fun!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但第一种方法更简洁、更简洁、更有趣！
- en: The key is the `resume` method from the `AsyncReponse` object. It will write
    the response to the callback and return it to whoever asked it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于`AsyncResponse`对象的`resume`方法。它将响应写入回调并返回给请求者。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-result](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-result).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码位于[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-result](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-result)。
- en: Using transactions with asynchronous tasks
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事务与异步任务
- en: 'Using asynchronous tasks could be already a challenge: what if you need to
    add some spice and add a transaction to it?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步任务可能已经是一个挑战：如果你需要添加一些特色并添加一个事务怎么办？
- en: Usually, a transaction means something like *code blocking*. Isn't it awkward
    to combine two opposing concepts? Well, it's not! They can work together nicely,
    as this recipe will show you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，事务意味着像*代码阻塞*这样的东西。将两个对立的概念结合起来不是有点尴尬吗？嗯，不是！它们可以很好地一起工作，就像这个菜谱将向您展示的那样。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的Java EE 8依赖项：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s first create a `User` POJO:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个`User` POJO：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And here is a slow bean that will return `User`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个将返回`User`的慢速bean：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we create a task to be executed that will return `User` using some transaction
    stuff:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个要执行的任务，该任务将使用一些事务相关的内容返回`User`：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And finally, here is the service endpoint that will use the task to write the
    result to a response:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这里是使用任务将结果写入响应的服务端点：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试此代码，只需将其部署到GlassFish 5并打开此URL：
- en: '`http://localhost:8080/ch09-async-transaction/asyncService`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch09-async-transaction/asyncService`'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The magic happens in the `AsyncTask` class, where we will first take a look
    at the `performLookups` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法发生在`AsyncTask`类中，我们将首先看看`performLookups`方法：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It will give you the instances of both `UserTransaction` and `UserBean` from
    the application server. Then you can relax and rely on the things already instantiated
    for you.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它将提供来自应用服务器的`UserTransaction`和`UserBean`实例。然后你可以放松并依赖为你已经实例化的东西。
- en: 'As our task implements a `Callabe<V>` object that it needs to implement the
    `call()` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的任务实现了一个需要实现`call()`方法的`Callable<V>`对象：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see `Callable` as a `Runnable` interface that returns a result.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`Callable`看作是一个返回结果的`Runnable`接口。
- en: 'Our transaction code lives here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事务代码存放在这里：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And if anything goes wrong, we have the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何问题，我们有以下情况：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we will look at `AsyncService`. First, we have some declarations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看`AsyncService`。首先，我们有一些声明：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are asking the container to give us an instance from `ManagedExecutorService`,
    which It is responsible for executing the task in the enterprise context.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求容器给我们一个`ManagedExecutorService`的实例，它负责在企业上下文中执行任务。
- en: Then we call an `init()` method, and the bean is constructed (`@PostConstruct`).
    This instantiates the task.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用一个`init()`方法，bean被构建（`@PostConstruct`）。这实例化了任务。
- en: 'Now we have our task execution:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了任务执行：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the executor returns `Future<User>`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，执行器返回`Future<User>`：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This means this task will be executed asynchronously. Then we check its execution
    status until it''s done:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个任务将被异步执行。然后我们检查其执行状态，直到它完成：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And once it''s done, we write it down to the asynchronous response:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们就将其写入异步响应：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-transaction](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-transaction).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码位于[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-transaction](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-transaction)。
- en: Checking the status of asynchronous tasks
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查异步任务的状态
- en: Beyond executing asynchronous tasks, which opens up a lot of possibilities,
    sometimes it is useful and necessary to get the status of those tasks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行异步任务，这开辟了许多可能性之外，有时获取这些任务的状态是有用且必要的。
- en: For example, you could use it as a check the time elapsed on each task stage.
    You should also think about logging and monitoring.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以用它来检查每个任务阶段的耗时。你也应该考虑日志和监控。
- en: This recipe will show you an easy way to do this.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向你展示一个简单的方法来做这件事。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加我们的Java EE 8依赖项：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s first create a `User` POJO:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we create a slow bean for returning `User`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个慢速的Bean来返回`User`：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we create a managed task so we can monitor it:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个托管任务，以便我们可以监控它：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And finally, we create a service endpoint to execute our task and return its
    results:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个服务端点来执行我们的任务并返回其结果：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，只需将其部署到GlassFish 5并打开此URL：
- en: '`http://localhost:8080/ch09-task-status/asyncService`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch09-task-status/asyncService`'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you have been through the last recipe, you will already be familiar with
    the `Callable` task, so I won''t give you more details about it here. But now,
    we are implementing our task using both the `Callable` and `ManagedTaskListener`
    interfaces. The second one gives us all the methods for checking the task''s status:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了上一个菜谱，你将已经熟悉了`Callable`任务，所以在这里我不会给出更多细节。但现在，我们正在使用`Callable`和`ManagedTaskListener`接口来实现我们的任务。第二个接口提供了检查任务状态的所有方法：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The best part is that you don't need to call any of them—`ManagedExecutorService`
    (explained next) will do it for you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是，你不需要调用任何一个——`ManagedExecutorService`（将在下一节中解释）会为你做这件事。
- en: 'Finally, we have `AsyncService`. The first declaration is for our executor:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`AsyncService`。第一个声明是为我们的执行器：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the service itself, we are getting four users from our asynchronous task:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务本身中，我们正在从我们的异步任务中获取四个用户：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once it''s done, it''s written to the asynchronous response:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，它将被写入异步响应：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, if you look at your server log output, there are messages from the `ManagedTaskListener`
    interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看你的服务器日志输出，将会有来自`ManagedTaskListener`接口的消息。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-task-status](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-task-status).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-task-status](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-task-status)查看这个菜谱的完整源代码。
- en: Building managed threads with returning results
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用返回结果的托管线程构建
- en: Sometimes you need to improve the way you look at the threads you are using;
    maybe to improve your logging features, maybe to manage their priorities. It would
    be nice if you could also get the results back from them. This recipe will show
    you how to do it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要改进你看待你正在使用的线程的方式；也许是为了改进你的日志功能，也许是为了管理它们的优先级。如果你也能从它们那里获取结果，那就太好了。这个菜谱将向你展示如何做到这一点。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加我们的Java EE 8依赖项：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s first create a `User` POJO:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And then, we create a slow bean to return `User`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个慢速的Bean来返回`User`：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And finally, we create an endpoint to get the result from the task:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个端点来获取任务的结果：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，只需将其部署到GlassFish 5并打开此URL：
- en: '`http://localhost:8080/ch09-managed-thread/asyncService`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch09-managed-thread/asyncService`'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The only way you should use threads in an enterprise context, and if you really
    want to use it, is when the application server creates the thread. So here, we
    are kindly asking the container to do it using `factory`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中使用线程的唯一方式，如果你真的想使用它，就是当应用程序服务器创建线程时。所以在这里，我们礼貌地请求容器使用`factory`来创建线程：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using some functional-style code, we create our thread:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些函数式风格的代码，我们创建我们的线程：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, moving to the managed stuff, we can set the name and priority of the just-created
    thread:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转向托管部分，我们可以设置新创建的线程的名称和优先级：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And don''t forget to ask the container to start it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 并且不要忘记要求容器启动它：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See also
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-managed-thread](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-managed-thread).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-managed-thread](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-managed-thread)查看这个菜谱的完整源代码。
- en: Scheduling asynchronous tasks with returning results
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用返回结果的异步任务调度
- en: Using tasks means also being able to define when they should be executed. This
    recipe is all about this topic, and also about getting the returning results whenever
    they return.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任务意味着也能够定义它们应该在何时执行。这个配方就是关于这个主题的，也是关于在它们返回时获取返回结果。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的Java EE 8依赖项：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s first create a `User` POJO:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个`User` POJO：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And then, we create a slow bean to return `User`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个慢速bean来返回`User`：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we create a simple `Callable` task to communicate with the bean:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个简单的`Callable`任务与bean通信：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And finally, we create our service to schedule and write the task''s result
    in the response:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的服务以安排任务并将结果写入响应：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，只需将其部署到GlassFish 5并打开此URL：
- en: '`http://localhost:8080/ch09-scheduled-task/asyncService`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch09-scheduled-task/asyncService`'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the magic relies on the `AsyncService` class, so we will focus on that.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有魔法都依赖于`AsyncService`类，所以我们将重点关注它。
- en: 'First, we ask the server an instance of an executor:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向服务器请求一个执行器的实例：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'But it is not just any executor—it''s an executor that''s specific to scheduling:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但它不仅仅是一个执行器——这是一个专门用于调度的执行器：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, we are scheduling our task to be executed in five seconds. Note that we
    are also not using a regular `Future`, but `ScheduledFuture`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将任务安排在五秒后执行。请注意，我们也没有使用常规的`Future`，而是使用`ScheduledFuture`。
- en: 'The rest is a usual task execution:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的都是常规的任务执行：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And this is how we write the results to the response:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将结果写入响应的方式：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See also
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-scheduled-task](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-scheduled-task).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-scheduled-task](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-scheduled-task)中查看此配方的完整源代码。
- en: Using injected proxies for asynchronous tasks
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注入的代理进行异步任务
- en: When using tasks, you could also create your own executor. If you have very
    specific needs, it could be really handy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用任务时，您也可以创建自己的执行器。如果您有非常具体的需求，这可能会非常有用。
- en: This recipe will show you how to create a proxy executor that can be injected
    and used in the whole context of your application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示如何创建一个可以注入并用于应用程序整个上下文的代理执行器。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的Java EE 8依赖项：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'First, we create a `User` POJO:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then we create a slow bean to return `User`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个慢速bean来返回`User`：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we create a simple `Callable` task to communicate with the slow bean:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个简单的`Callable`任务与慢速bean通信：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, we call our proxy:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们调用我们的代理：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And finally, we create the endpoint that will use the proxy:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建将使用代理的端点：
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，只需将其部署到GlassFish 5并打开此URL：
- en: '`http://localhost:8080/ch09-proxy-task/asyncService`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch09-proxy-task/asyncService`'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The magic really happens here in the `ExecutorProxy` task. First note that
    we are defining it as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的魔法就在这里的`ExecutorProxy`任务中。首先请注意，我们是这样定义它的：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are making sure to have one and only one instance of it in the context.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保在上下文中只有一个实例。
- en: 'Now note that even though we are creating our own executor, we are still relying
    on the application server context for it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请注意，尽管我们正在创建自己的执行器，但我们仍然依赖于应用程序服务器上下文：
- en: '[PRE59]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This guarantees that you don't violate any context rules and ruin your application
    for good.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这保证了您不会违反任何上下文规则并永久性地破坏您的应用程序。
- en: 'Then we create a pool for executing threads:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个线程池来执行线程：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And finally, we create the method for sending tasks to the executing queue:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建将任务发送到执行队列的方法：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now our proxy is ready to be injected:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代理已准备好注入：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It is also ready to be called and to return results:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它也准备好被调用并返回结果：
- en: '[PRE63]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-proxy-task](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-proxy-task).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-proxy-task](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-proxy-task)中查看此配方的完整源代码。
