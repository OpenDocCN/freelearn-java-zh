- en: Chapter 2. JavaServer Faces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 JavaServer Faces
- en: In this chapter, we will cover **JavaServer Faces** (**JSF**), the standard
    component framework of the Java EE platform. Java EE 7 includes JSF 2.2, the latest
    version of JSF. JSF relies a lot on convention over configuration. If we follow
    JSF conventions, then we don't need to write a lot of configuration. In most cases,
    we don't need to write any configuration at all. This fact, combined with the
    fact that `web.xml` has been optional since Java EE 6, means that in many cases,
    we can write complete web applications without having to write a single line of
    XML configuration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Java EE 平台的标准组件框架 **JavaServer Faces**（**JSF**）。Java EE 7 包含了 JSF
    2.2，这是 JSF 的最新版本。JSF 非常依赖于约定优于配置。如果我们遵循 JSF 约定，那么我们就不需要编写很多配置。在大多数情况下，我们甚至不需要编写任何配置。这一事实，加上
    `web.xml` 自 Java EE 6 以来一直是可选的，意味着在许多情况下，我们可以编写完整的 Web 应用程序，而无需编写任何一行 XML 配置。
- en: Introduction to JSF
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 简介
- en: JSF 2.0 introduced a number of enhancements to make JSF application development
    easier. In the following few sections, we will explain some of these features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0 引入了许多增强功能，使得 JSF 应用程序开发更加容易。在接下来的几节中，我们将解释其中的一些特性。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Readers unfamiliar with the earlier versions of JSF may not understand the following
    few sections completely. Don't worry, everything will be perfectly clear by the
    end of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉 JSF 早期版本的读者来说，可能无法完全理解以下几节。不用担心，到本章结束时，一切都会非常清晰。
- en: Facelets
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facelets
- en: One notable difference between the modern versions of JSF and the earlier versions
    is that Facelets is now the preferred view technology. The earlier versions of
    JSF used JSP as their default view technology. Since JSP technology predates JSF,
    sometimes using JSP with JSF felt unnatural or created problems. For example,
    the lifecycle of JSPs is different from the lifecycle of JSFs; this mismatch introduced
    some problems for JSF 1.x application developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 现代版本与早期版本之间一个明显的区别是，现在 Facelets 是首选的视图技术。JSF 的早期版本使用 JSP 作为它们的默认视图技术。由于
    JSP 技术早于 JSF，有时使用 JSP 与 JSF 感觉不自然或产生问题。例如，JSP 的生命周期与 JSF 的生命周期不同；这种不匹配为 JSF 1.x
    应用程序开发者引入了一些问题。
- en: JSF was designed from the beginning to support multiple view technologies. To
    take advantage of this capability, Jacob Hookom wrote a view technology specifically
    for JSF. He named his view technology **Facelets**. Facelets was so successful
    that it became a de facto standard for JSF. The JSF expert group recognized Facelets'
    popularity and made it the official view technology for JSF in Version 2.0 of
    the JSF specification.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 从一开始就被设计成支持多种视图技术。为了利用这一功能，Jacob Hookom 为 JSF 编写了一种特定的视图技术。他将自己的视图技术命名为
    **Facelets**。Facelets 非常成功，以至于它成为了 JSF 的实际标准。JSF 专家组认识到 Facelets 的流行，并在 JSF 规范的
    2.0 版本中将 Facelets 定为官方视图技术。
- en: Optional faces-config.xml
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选的 faces-config.xml
- en: Legacy J2EE applications suffered what some would have considered being excessive
    XML configuration.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 J2EE 应用程序遭受了一些人认为过度的 XML 配置。
- en: Java EE 5 took some measures to reduce the XML configuration considerably. Java
    EE 6 reduced the required configuration even further, making the `faces-config.xml`
    JSF configuration file optional in JSF 2.0.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 5 采取了一些措施来显著减少 XML 配置。Java EE 6 进一步减少了所需的配置，使得在 JSF 2.0 中 `faces-config.xml`
    JSF 配置文件成为可选的。
- en: In JSF 2.0 and newer, JSF managed beans can be configured via the `@ManagedBean`
    annotation, obviating the need to configure them in `faces-config.xml`. Java EE
    6 introduced the **Contexts and Dependency Injection** (**CDI**) API, which provides
    an alternative way to implement the functionality that was typically implemented
    with JSF managed beans. As of JSF 2.2, CDI named beans are preferred over JSF
    managed beans.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 2.0 及更高版本中，可以通过 `@ManagedBean` 注解配置 JSF 管理器豆，从而无需在 `faces-config.xml`
    中配置它们。Java EE 6 引入了 **上下文和依赖注入**（**CDI**）API，它提供了一种替代方法来实现通常使用 JSF 管理器豆实现的功能。截至
    JSF 2.2，CDI 命名豆比 JSF 管理器豆更受欢迎。
- en: Additionally, there is a convention for JSF navigation. If the value of the
    `action` attribute of a JSF 2 command link or command button matches the name
    of a facelet (minus the XHTML extension), then by convention, the application
    will navigate to the facelet that matches the action name. This convention allows
    us to avoid having to configure an application's navigation in `faces-config.xml`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JSF 导航有一个约定。如果一个 JSF 2 命令链接或命令按钮的 `action` 属性值与 facelet（去掉 XHTML 扩展名）的名称匹配，那么按照约定，应用程序将导航到与动作名称匹配的
    facelet。这个约定允许我们避免在 `faces-config.xml` 中配置应用程序的导航。
- en: For many modern JSF applications, `faces-config.xml` is completely unnecessary
    as long as the established JSF conventions are followed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多现代 JSF 应用程序，只要遵循已建立的 JSF 约定，`faces-config.xml` 就完全没有必要。
- en: Standard resource locations
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准资源位置
- en: JSF 2.0 introduced standard resource locations. Resources are the artifacts
    that a page or JSF component needs to render properly, such as CSS style sheets,
    JavaScript files, and images.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0 引入了标准的资源位置。资源是页面或 JSF 组件需要正确渲染的工件，例如 CSS 样式表、JavaScript 文件和图像。
- en: In JSF 2.0 and newer, resources can be placed in a subdirectory under a folder
    called `resources` either at the root of the WAR file or under `META-INF`. By
    convention, JSF components know that they can retrieve resources from one of these
    two locations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 2.0 及更高版本中，资源可以放置在 `resources` 文件夹下的子目录中，这个文件夹位于 WAR 文件的根目录下或 `META-INF`
    下。按照约定，JSF 组件知道它们可以从这两个位置之一检索资源。
- en: In order to avoid cluttering the resources directory, resources are typically
    placed in a subdirectory. This subdirectory is referred to from the `library`
    attribute of JSF components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免资源目录杂乱，资源通常放置在子目录中。这个子目录通过 JSF 组件的 `library` 属性来引用。
- en: For example, we could place a CSS style sheet called `styles.css` under `/resources/css/`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 `/resources/css/` 下放置一个名为 `styles.css` 的 CSS 样式表。
- en: 'In our JSF pages, we can retrieve this CSS file using the `<h:outputStylesheet>`
    tag as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 JSF 页面中，我们可以使用 `<h:outputStylesheet>` 标签来检索此 CSS 文件，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of the `library` attribute must match the subdirectory where our style
    sheet is located.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`library` 属性的值必须与我们的样式表所在的子目录匹配。'
- en: 'Similarly, we can have a JavaScript file, `somescript.js`, under `/resources/scripts/`
    and we can access it using the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在 `/resources/scripts/` 下有一个名为 `somescript.js` 的 JavaScript 文件，并且我们可以使用以下代码来访问它：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can have an image, `logo.png`, under `/resources/images/` and we can access
    this resource with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `/resources/images/` 下放置一个名为 `logo.png` 的图像，并且我们可以使用以下代码来访问这个资源：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that in each case, the value of the `library` attribute matches the corresponding
    subdirectory name under the `resources` directory and the value of the `name`
    attribute matches the resource's filename.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每种情况下，`library` 属性的值都与 `resources` 目录下的相应子目录名称匹配，而 `name` 属性的值与资源的文件名匹配。
- en: Developing our first JSF application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的第一个 JSF 应用程序
- en: To illustrate basic JSF concepts, we will develop a simple application consisting
    of two Facelets pages and a single CDI named bean.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明基本的 JSF 概念，我们将开发一个简单的应用程序，该应用程序由两个 Facelets 页面和一个名为 CDI 的命名豆组成。
- en: Facelets
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facelets
- en: 'As we mentioned in this chapter''s introduction, the default view technology
    for JSF 2 is Facelets. Facelets need to be written using standard XML. The most
    popular way of developing Facelets pages is to use XHTML in conjunction with JSF-specific
    XML namespaces. The following example shows how a typical Facelets page looks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章引言中提到的，JSF 2 的默认视图技术是 Facelets。Facelets 需要使用标准的 XML 编写。开发 Facelets 页面最流行的方式是结合使用
    XHTML 和 JSF 特定的 XML 命名空间。以下示例显示了典型的 Facelets 页面看起来像什么：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot illustrates how our example page is rendered in the
    browser:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了我们的示例页面在浏览器中的渲染方式：
- en: '![Facelets](img/6886EN_02_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Facelets](img/6886EN_02_01.jpg)'
- en: The preceding screenshot, of course, was taken after entering some data in every
    text field; originally, each text field was blank.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的截图是在每个文本字段输入一些数据之后拍摄的；最初，每个文本字段都是空的。
- en: Pretty much any Facelets JSF page will include the two namespaces illustrated
    in the example. The first namespace (``) is for the tags that render HTML components;
    by convention, the prefix `h` (for HTML) is used when using this tag library.``
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何 Facelets JSF 页面都会包括示例中展示的两个命名空间。第一个命名空间（``）用于渲染 HTML 组件的标签；按照约定，当使用此标签库时，使用前缀
    `h`（代表 HTML）。``
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`` `Tip` ``'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`` `提示` ``'
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`` `![Facelets](img/6886EN_02_02.jpg)` ``'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![Facelets](img/6886EN_02_02.jpg)` ``'
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`` `Project stages` ``'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `项目阶段` ``'
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`` `To avoid the situation described in the previous paragraph, JSF 2.0 introduced
    the concept of **project stages**.` ``'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `为了避免前一段描述的情况，JSF 2.0 引入了 **项目阶段** 的概念。` ``'
- en: '`` `The following project stages are defined in JSF 2:` ``'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `以下是在 JSF 2 中定义的项目阶段：` ``'
- en: '`` `Production` ``'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `生产` ``'
- en: '`` `Development` ``'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `开发` ``'
- en: '`` `UnitTest` ``'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `单元测试` ``'
- en: '`` `SystemTest` ``'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `系统测试` ``'
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`` `With GlassFish, we can do this by logging in to the web console, navigating
    to **JNDI** | **Custom Resources**, and then clicking on the **New...** button.
    The page that appears looks as shown in the following screenshot:` ``'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `使用 GlassFish，我们可以通过登录到 Web 控制台，导航到 **JNDI** | **自定义资源**，然后点击 **新建...**
    按钮。出现的页面如图所示：` ``'
- en: '`` `![Project stages](img/6886EN_02_03.jpg)` ``'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![项目阶段](img/6886EN_02_03.jpg)` ``'
- en: '`` `In the resulting page, we need to enter the following information:` ``'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `在生成的页面中，我们需要输入以下信息：` ``'
- en: '| **JNDI Name** | `javax.faces.PROJECT_STAGE` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **JNDI 名称** | `javax.faces.PROJECT_STAGE` |'
- en: '| **Resource Type** | `java.lang.String` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **资源类型** | `java.lang.String` |'
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`` `After entering the values, we need to add a new property with a name of
    the stage and a value corresponding to the project stage we wish to use.` ``'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `输入值后，我们需要添加一个新的属性，其名称为阶段，其值对应于我们希望使用的项目阶段。` ``'
- en: '`` `Setting the project stage allows us to perform some logic only if we are
    running the program in a specific stage. For instance, in one of our named beans,
    we could have code that looks as follows:` ``'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `设置项目阶段允许我们在特定阶段运行程序时执行一些逻辑。例如，在我们的一个命名豆中，我们可能有如下代码：` ``'
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`` `![Project stages](img/6886EN_02_04.jpg)` ``'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![项目阶段](img/6886EN_02_04.jpg)` ``'
- en: '`` `In the default Production stage, this error message is not displayed on
    the page, leaving us confused as to why our page navigation doesn''t seem to work.`
    ``'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `在默认的生产阶段，此错误消息不会在页面上显示，使我们困惑于为什么我们的页面导航似乎不起作用。` ``'
- en: '`` `Validation` ``'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `验证` ``'
- en: '`` `JSF provides built-in input validation capabilities.` ``'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `JSF 提供了内置的输入验证功能。` ``'
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`` `![Validation](img/6886EN_02_05.jpg)` ``'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![验证](img/6886EN_02_05.jpg)` ``'
- en: '`` `Again, the default message and style can be overridden; we will cover how
    to do this later in this chapter in the *Customizing JSF''s default messages*
    section.` ``'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `同样，默认消息和样式可以被覆盖；我们将在本章后面的 *自定义 JSF 的默认消息* 部分介绍如何做到这一点。` ``'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| Validation tag | Description |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 验证标签 | 描述 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<f:validateBean>` | Bean validation allows us to validate named bean values
    using annotations in our named beans without having to add validators to our JSF
    tags. These tags allow us to fine-tune Bean Validation if necessary. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateBean>` | 使用注解在命名豆中验证命名豆值，而无需在我们的 JSF 标签中添加验证器，这允许我们根据需要微调 Bean
    验证。这些标签允许我们根据需要微调 Bean 验证。 |'
- en: '| `<f:validateDoubleRange>` | This tag validates that the input is a valid
    `Double` value between the two values specified by the tag''s `minimum` and `maximum`
    attributes, inclusive. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateDoubleRange>` | 此标签验证输入是否为在标签的 `minimum` 和 `maximum` 属性指定的两个值之间的有效
    `Double` 值，包括这些值。 |'
- en: '| `<f:validateLength>` | This tag validates that the input''s length is between
    the values specified by the tag''s `minimum` and `maximum` values, inclusive.
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLength>` | 此标签验证输入的长度是否在标签的 `minimum` 和 `maximum` 值之间，包括这些值。
    |'
- en: '| `<f:validateLongRange>` | This tag validates that the input is a valid `Long`
    value between the values specified by the tag''s `minimum` and `maximum` attributes,
    inclusive. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLongRange>` | 此标签验证输入是否为在标签的 `minimum` 和 `maximum` 属性指定的值之间的有效
    `Long` 值，包括这些值。 |'
- en: '| `<f:validateRegex>` | This tag validates that the input matches a regular
    expression pattern specified in the tag''s `pattern` attribute. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRegex>` | 此标签验证输入是否与标签的 `pattern` 属性中指定的正则表达式模式匹配。 |'
- en: '| `<f:validateRequired>` | This tag validates that the input is not empty.
    This tag is equivalent to setting the `required` attribute to `true` in the parent
    input field. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRequired>` | 此标签验证输入是否不为空。此标签等同于在父输入字段中将 `required` 属性设置为 `true`。
    |'
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`` `If we wish to take advantage of Bean Validation, all we need to do is annotate
    the desired field with the appropriate Bean Validation annotation, without having
    to explicitly use a JSF validator.` ``'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `如果我们想利用 Bean 验证，我们只需要使用适当的 Bean 验证注解注释所需的字段，而无需显式使用 JSF 验证器。` ``'
- en: '`` `Note` ``'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`` `注意` ``'
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`` `Grouping components` ``'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `组件分组` ``'
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`` `Form submission` ``'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `表单提交` ``'
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`` `Note` ``'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`` `注意` ``'
- en: '`` `Even though the label for the button reads **Save**, in our simple example
    clicking on the button won''t actually save any data.` ``'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `尽管按钮的标签读作**保存**，但在我们的简单示例中，点击按钮实际上不会保存任何数据。` ``'
- en: '`` `Named beans` ``'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `命名bean` ``'
- en: '`` `There are two types of JavaBeans that can interact with JSF pages: JSF
    managed beans and CDI named beans. JSF managed beans have been around since the
    first version of the JSF specification and can be used only in a JSF context.
    CDI named beans were introduced in Java EE 6 and can interoperate with other Java
    EE APIs such as Enterprise JavaBeans. For these reasons, CDI named beans are preferred
    over JSF managed beans.` ``'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `有两种类型的JavaBeans可以与JSF页面交互：JSF管理bean和CDI命名bean。JSF管理bean自JSF规范的第一版以来就存在了，并且只能在JSF上下文中使用。CDI命名bean在Java
    EE 6中引入，可以与其他Java EE API（如企业JavaBeans）交互。因此，CDI命名bean比JSF管理bean更受欢迎。` ``'
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`` `Named beans always have a scope. A named bean scope defines the lifespan
    of the bean, and it is defined by a class-level annotation. The following table
    lists all valid named bean scopes:` ``'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `命名bean始终有一个作用域。命名bean作用域定义了bean的生命周期，它由类级别的注解定义。下表列出了所有有效的命名bean作用域：` ``'
- en: '| Named bean scope annotation | Description |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 命名bean作用域注解 | 描述 |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@ApplicationScoped` | The same instance of the application scoped named
    beans are available to all of our application''s clients. If one client modifies
    the value of an application scoped managed bean, the change is reflected across
    all clients. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `@ApplicationScoped` | 应用程序作用域的命名bean的同一实例对所有应用程序的客户端都是可用的。如果一个客户端修改了应用程序作用域管理bean的值，该更改将在所有客户端中反映出来。
    |'
- en: '| `@SessionScoped` | An instance of each session scoped named bean is assigned
    to each of our application''s clients. A session scoped named bean can be used
    to hold client-specific data across requests. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `@SessionScoped` | 每个会话作用域的命名bean实例都被分配给我们的应用程序的每个客户端。会话作用域的命名bean可以用来在请求之间保持客户端特定的数据。
    |'
- en: '| `@RequestScoped` | Request scoped named beans only live through a single
    request. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `@RequestScoped` | 请求作用域的命名bean只存在于单个请求中。 |'
- en: '| `@Dependent` | Dependent scoped named beans are assigned the same scope as
    the bean they are injected into. This is the default scope if none is specified.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `@Dependent` | 依赖作用域的命名bean被分配给它们注入的bean相同的范围。如果没有指定，这是默认的作用域。 |'
- en: '| `@ConversationScoped` | The conversation scope can span multiple requests
    and is typically shorter than the session scope. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `@ConversationScoped` | 会话作用域可以跨越多个请求，通常比会话作用域短。 |'
- en: '`` `Navigation` ``'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `导航` ``'
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`` `Tip` ``'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`` `提示` ``'
- en: '`` `**Does the same page reload when you click on a button or link that should
    navigate to another page?**` ``'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `**当你点击一个应该导航到另一个页面的按钮或链接时，页面会重新加载吗？**` ``'
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`` `![Navigation](img/6886EN_02_06.jpg)` ``'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![导航](img/6886EN_02_06.jpg)` ``'
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]`# Custom data validation    In addition to providing standard validators,
    JSF allows us to create custom validators. This can be done in two ways: by creating
    a custom validator class or by adding validation methods to our named beans.    ##
    Creating custom validators    In addition to the standard validators, JSF allows
    us to create custom validators by creating a Java class that implements the `javax.faces.validator.Validator`
    interface.    The following class implements an e-mail validator, which we will
    use to validate the e-mail text input field in our customer data entry screen.    [PRE44]    The
    `@FacesValidator` annotation registers our class as a JSF custom validator class.
    The value of its `value` attribute is the logical name that JSF pages can use
    for reference.    As can be seen in the example, the only method we need to implement
    when implementing the `Validator` interface is a method called `validate()`. This
    method takes three parameters: an instance of `javax.faces.context.FacesContext`,
    an instance of `javax.faces.component.UIComponent`, and an object. Typically,
    application developers only need to be concerned with the last two. The second
    parameter is the component whose data we are validating, and the third parameter
    is the actual value. In the example, we cast `uiComponent` to `javax.faces.component.html.HtmlInputText`;
    in this way, we get access to its `getLabel()` method, which we can use as part
    of the error message.    If the entered value is not in a valid e-mail address
    format, a new instance of `javax.faces.application.FacesMessage` is created, passing
    the error message to be displayed in the browser as its constructor parameter.
    We then throw a new exception as `javax.faces.validator.ValidatorException`. The
    error message is then displayed in the browser.    ### Tip    **Apache Commons
    Validator**    Our custom JSF validator uses the Apache Commons Validator to do
    the actual validation. This library includes many common validations such as dates,
    credit card numbers, ISBN numbers, and e-mails. When implementing a custom validator,
    it is worth investigating if this library already has a validator that we can
    use.    In order to use our validator in our page, we need to use the `<f:validator>`
    JSF tag. The following Facelets page is a modified version of the customer data
    entry screen. This version uses the `<f:validator>` tag to validate e-mails.    [PRE45]    Notice
    that the value of the `validatorId` attribute of `<f:validator>` matches the `value`
    attribute of the `@FacesValidator` annotation in our custom validator.    After
    writing our custom validator and modifying our page to take advantage of it, we
    can see our validator in action as shown in the following screenshot:  ![Creating
    custom validators](img/6886EN_02_07.jpg)  ## Validator methods    Another way
    we can implement custom validation is by adding validation methods to one or more
    of the application''s named beans. The following Java class illustrates the use
    of validator methods for JSF validation:    [PRE46]    In this example, the class
    contains only the validator method. We can give our validator method any name
    we want; however, its return value must be void, and it must take the three parameters
    illustrated in the example, in that order. In other words, except for the method
    name, the signature of a validator method must be identical to the signature of
    the `validate()` method defined in the `javax.faces.validator.Validator` interface.    As
    we can see, the body of our validator method is nearly identical to the body of
    our custom validator''s `validate()` method. We check the value entered by the
    user to make sure that it contains only alphabetic characters and/or spaces. If
    it does not, then we throw `ValidatorException`, passing an instance of `FacesMessage`
    containing an appropriate `String` error message.    ### Tip    **StringUtils**    In
    the example, we used `org.apache.commons.lang.StringUtils` to perform the actual
    validation logic. In addition to the method used in the example, this class contains
    several methods to verify whether a string is numeric or alphanumeric. This class,
    part of the Apache `commons-lang` library, is very useful when writing custom
    validators.    Since every validator method must be in a named bean, we need to
    make sure that the class containing our validator method is annotated with the
    `@Named` annotation, as illustrated in our example.    The last thing we need
    to do in order to use our validator method is to bind it to our component via
    the tag''s `validator` attribute. The code to do so is as follows:    [PRE47]    Since
    neither the first name nor the last name fields would accept anything other than
    alphabetic characters or spaces, we added our custom validator method to both
    of these fields.    Notice that the value of the `validator` attribute of the
    `<h:inputText>` tag is a JSF expression language expression that uses the default
    name for the bean containing our validation method. `alphaValidator` is the name
    of our bean, and `validateAlpha` is the name of our validator method.    After
    modifying our page to use our custom validator, we can now see it in action as
    follows:  ![Validator methods](img/6886EN_02_08.jpg)  Note how for the **First
    Name** field both our custom validator message and the standard length validator
    were executed.    The advantage of implementing validator methods is that you
    do not need the overhead of creating a whole class just for a single validator
    method. (Our example does just that, but in many cases, validator methods are
    added to an existing named bean containing other methods.) The disadvantage of
    validator methods is that each component can only be validated by a single validator
    method. When using validator classes, several `<f:validator>` tags can be nested
    inside the tag to be validated; therefore, multiple validations, both custom and
    standard, can be done to the field.    # Customizing JSF''s default messages    As
    we mentioned earlier, it is possible to customize the style (font, color, text,
    and so on) of JSF default validation messages. Additionally, it is possible to
    modify the text of the default JSF validation messages. In the following sections,
    we will explain how to modify error message formatting and text.    ## Customizing
    message styles    Customizing message styles can be done via **Cascading Style
    Sheets** (**CSS**). This can be accomplished using the `<h:message>` style or
    the `styleClass` attributes. The `style` attribute is used when we want to declare
    the CSS style inline. The `styleClass` attribute is used when we want to use a
    predefined style in a CSS style sheet or inside a `<style>` tag in our page.    The
    following markup illustrates the use of the `styleClass` attribute to alter the
    style of error messages. It is a modified version of the input page that we saw
    in the previous section.    [PRE48]    The only difference between this page and
    the previous one is the use of the `styleClass` attribute of the `<h:messages>`
    tag. As mentioned earlier, the value of the `styleClass` attribute must match
    the name of a CSS style defined in a cascading style sheet that our page can access.    In
    our case, we defined a CSS style in `style.css` for messages as follows:    [PRE49]    We
    then used this style as the value of the `styleClass` attribute of our `<h:messages>`
    tag.    The following screenshot illustrates how the validation error messages
    look after we have implemented this change:  ![Customizing message styles](img/6886EN_02_09.jpg)  In
    this particular case, we just set the color of the error message text to red,
    but we are only limited by CSS capabilities in setting the style of the error
    messages.    ## Customizing message text    Sometimes it is desirable to override
    JSF''s default validation errors. Default validation errors are defined in a resource
    bundle called `Messages.properties`. This file can be found inside the `javax.faces.jar`
    file under `[glassfish installation directory]/glassfish/modules`. It can be found
    under the `javax/faces` folder inside the JAR file. The file contains several
    messages, but we are only interested in validation errors at this point. The default
    validation error messages are defined as follows:    [PRE50]    In order to override
    the default error messages, we need to create our own resource bundle using the
    same keys used in the default one, but altering the values to suit our needs.
    The following is a very simple customized resource bundle for our application:    [PRE51]    In
    this resource bundle, we override the error message for when the value entered
    for a field validated by the `<f:validateLength>` tag is less than the allowed
    minimum. In order to let our application know that we have a custom resource bundle
    for message properties, we need to modify the application''s `faces-config.xml`
    file as follows:    [PRE52]    As we can see, the only thing we need to do to
    the application''s `faces-config.xml` file is to add a `<message-bundle>` element
    indicating the name and location of the resource bundle containing our custom
    messages.    ### Note    A custom error message text definition is one of the
    few cases in which we still need to define a `faces-config.xml` file for modern
    JSF applications. However, note how simple our `faces-config.xml` file is; it
    is a far cry from a typical `faces-config.xml` file for JSF 1.x, which typically
    contains named bean definitions, navigation rules, JSF validator definitions,
    and so on.    After adding our custom message resource bundle and modifying the
    application''s `faces-config.xml` file, we can see our custom validation message
    in action, as shown in the following screenshot:  ![Customizing message text](img/6886EN_02_10.jpg)  As
    can be seen in the screenshot, if we haven''t overridden a validation message,
    the default will still be displayed. In our resource bundle, we only overrode
    the minimum length validation error message; therefore, our custom error message
    is shown for the **First Name** text field. Since we didn''t override the error
    messages for the other standard JSF validators, the default error message is shown
    for each one of them. The e-mail validator is the custom validator we developed
    previously in this chapter. Since it is a custom validator, its error message
    is not affected.    # Ajax-enabling JSF applications    Early versions of JSF
    did not include native Ajax support. Custom JSF library vendors were forced to
    implement Ajax in their own way. Unfortunately, this state of events introduced
    incompatibilities between JSF component libraries. JSF 2.0 standardized Ajax support
    by introducing the `<f:ajax>` tag.    The following page illustrates the typical
    usage of the `<f:ajax>` tag:    [PRE53]    After deploying our application, our
    page renders as illustrated in the following screenshot:  ![Ajax-enabling JSF
    applications](img/6886EN_02_11.jpg)  This example page illustrates two uses of
    the `<f:ajax>` tag. At the top of the page, we have used this tag for implementing
    a typical Ajax Echo example, in which we have an `<h:outputText>` component updating
    itself with the value of an input text component. Any time a character is entered
    into the input field, the value of the `<h:outputText>` component is automatically
    updated.    To implement the functionality described in the previous paragraph,
    we put an `<f:ajax>` tag inside an `<h:inputText>` tag. The value of the `render`
    attribute of the `<f:ajax>` tag must correspond to the ID of a component we wish
    to update after the Ajax request finishes. In our example, we wish to update the
    `<h:outputText>` component with an ID of "`textVal`"; therefore, we will use this
    value for the `render` attribute of our `<f:ajax>` tag.    ### Note    In some
    cases, we may need to render more than one JSF component after an Ajax event finishes;
    in order to accommodate this, we can add several IDs as the value of the `render`
    attribute, and we simply need to separate them by spaces.    The other `<f:ajax>`
    attribute we used in this instance is the `event` attribute. This attribute indicates
    the JavaScript event that triggers the Ajax event. In this particular case, we
    need to trigger the event any time a key is released while a user is typing into
    the input field; therefore, the appropriate event to use is `keyup`.    The following
    table lists all supported JavaScript events:     | Event | Description | | ---
    | --- | | `blur` | The component loses focus. | | `change` | The component loses
    focus, and its value is modified. | | `click` | The component is clicked on. |
    | `dblclick` | The component is double-clicked on. | | `focus` | The component
    gains focus. | | `keydown` | A key is depressed while the component has focus.
    | | `keypress` | A key is pressed or held down while the component has focus.
    | | `keyup` | A key is released while the component has focus. | | `mousedown`
    | The mouse button is depressed while the component has focus. | | `mousemove`
    | The mouse pointer is moved over the component. | | `mouseout` | The mouse pointer
    leaves the component. | | `mouseover` | The mouse pointer is placed over the component.
    | | `mouseup` | The mouse button is released while the component has focus. |
    | `select` | The component''s text is selected. | | `valueChange` | Equivalent
    to `change`; the component loses focus and its value has been modified. |    We
    use the `<f:ajax>` tag once again farther down in the page to Ajax-enable a command
    button component. In this instance, we want to recalculate a value based on the
    value of two input components. In order to have the values on the server updated
    with the latest user input, we used the `execute` attribute of `<f:ajax>`; this
    attribute takes a space-separated list of component IDs to use as input. We then
    use the `render` attribute just as before to specify which components need to
    be re-rendered after the Ajax request finishes.    Notice that we used the `actionListener`
    attribute of `<h:commandButton>`. This attribute is typically used when we don''t
    need to navigate to another page after clicking on the button. The value for this
    attribute is an action listener method we wrote in one of our named beans. Action
    listener methods must return void and take an instance of `javax.faces.event.ActionEvent`
    as their sole parameter.    The named bean for our application looks as follows:    [PRE54]    Notice
    that we didn''t have to do anything special in our named bean to enable Ajax in
    our application. It is all controlled by the `<f:ajax>` tag on the page.    As
    we can see from this example, Ajax-enabling JSF applications is very simple. We
    simply need to use a single tag to Ajax-enable our page, without having to write
    a single line of JavaScript, JSON, or XML.    # JSF 2.2 HTML5 support    HTML
    5 is the latest version of the HTML specification. It includes several improvements
    over the previous version of HTML. JSF 2.2 includes several updates to make JSF
    pages work nicely with HTML5.    ## The HTML5-friendly markup    Through the use
    of pass-through elements, we can develop our pages using HTML 5 tags and also
    treat them as JSF components. To do this, we need to specify at least one of the
    `element` attributes using the `http://xmlns.jcp.org/jsf` namespace. The following
    example demonstrates this approach in action:    [PRE55]    The first thing we
    should notice about this example is the XML namespace prefixed by `jsf` near the
    top of the page. This namespace allows us to add JSF-specific attributes to HTML
    5 pages. When the JSF runtime encounters attributes prefixed by `jsf` in any of
    the tags on the page, it automatically converts the HTML5 tag to the equivalent
    JSF component. JSF-specific tags are the same as in regular JSF pages, except
    that they are prefixed with `jsf`. Therefore, at this point, they should be self-explanatory
    and will not be discussed in detail. Our example will render and behave just like
    the first example in this chapter.    The technique described in this section
    is useful if you have experienced HTML web designers in your team who prefer to
    have full control over the look of the page. The pages are developed using standard
    HTML5 with JSF-specific attributes so that the JSF runtime can manage user input.    If
    your team consists primarily of Java developers with limited CSS/HTML knowledge,
    then it is preferable to develop the web pages for your web application using
    JSF components. HTML 5 introduced several new attributes that didn''t exist in
    the previous versions of HTML. For this reason, JSF 2.2 introduces the ability
    to add arbitrary attributes to JSF components. This JSF/HTML5 integration technique
    is discussed in the next section.    ## Pass-through elements    JSF 2.2 allows
    the definition of any arbitrary attributes (not processed by the JSF engine).
    These attributes are simply rendered as is on the generated HTML displayed in
    the browser. The following example is a new version of an earlier example in this
    chapter, which has been modified to take advantage of the HTML5 pass-through elements:    [PRE56]    The
    first thing we should notice about this example is the addition of the ``id227"
    class="indexterm"/>by the defined prefix for the namespace at the top of the application
    (`p`, in our case). The placeholder HTML attribute simply adds some placeholder
    text to the input fields, which is automatically deleted once the user starts
    typing in the input field (this technique was commonly implemented "by hand" using
    JavaScript before HTML5).``    The following screenshot shows our updated page
    in action:  ![Pass-through elements](img/6886EN_02_12.jpg)  # JSF 2.2 Faces Flows    Faces
    Flows is a new JSF 2.2 feature that defines a scope that can span several pages.
    Flow scoped beans are created when the user enters a flow (a set of web pages)
    and are destroyed when the user leaves the flow.    Faces Flows adopts the convention
    over configuration principle of JSF. The following conventions are typically used
    when developing applications employing Faces Flows:    *   All pages in the flow
    must be placed in a directory with a name that defines the name of the flow *   An
    XML configuration file named after the directory name and suffixed with `-flow`
    must exist inside the directory that contains the pages in the flow (the file
    may be empty, but it must exist) *   The first page in the flow must be named
    after the directory name that contains the flow *   The last page in the flow
    must not be located inside the directory containing the flow and must be named
    after the directory name and suffixed with `-return`    The following screenshot
    illustrates these conventions:  ![JSF 2.2 Faces Flows](img/6886EN_02_13.jpg)  In
    this example, we define a flow named `customerinfo`; by convention, these files
    are inside a directory named `customerinfo`, and the first page of the flow is
    named `customerinfo.xhtml` (there are no restrictions on the names of other pages
    in the flow). When we exit the flow, we navigate to `customerinfo-return.xhtml`,
    which follows the naming convention and takes us out of the flow.    The markup
    for the pages doesn''t illustrate anything we haven''t seen before, so we will
    not show it. All example code is available as part of this book''s code download
    bundle.    All the pages in our example store data in a named bean called `Customer`,
    which has a scope of flow.    [PRE57]    The `@FlowScoped` annotation has a `value`
    attribute that must match the name of the flow that the bean is meant to work
    with (`customerinfo` in this example).    This example creates a wizard-style
    set of pages in which data for a user is entered across several pages in the flow.    On
    the first page, we enter information about the name.  ![JSF 2.2 Faces Flows](img/6886EN_02_14.jpg)  On
    the second page, we enter address information as shown in the following screenshot:  ![JSF
    2.2 Faces Flows](img/6886EN_02_15.jpg)  On the next page, we enter phone number
    information as shown in the following screenshot:  ![JSF 2.2 Faces Flows](img/6886EN_02_16.jpg)  Finally,
    we display a confirmation page as shown in the following screenshot:  ![JSF 2.2
    Faces Flows](img/6886EN_02_17.jpg)  If the user verifies that the information
    is correct, we navigate outside the flow to `customerinfo-return.xhtml`; otherwise,
    we go back to the first page in the flow to allow the user to make any necessary
    corrections.    # Additional JSF component libraries    In addition to the standard
    JSF component libraries, there are a number of third-party JSF tag libraries available.
    The following table lists some of the most popular ones:     | Tag library | Distributor
    | License | URL | | --- | --- | --- | --- | | ICEfaces | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    | | RichFaces | Red Hat/JBoss | LGPL | [http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)
    | | Primefaces | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |    # Summary    In this chapter, we covered how to develop web-based applications
    using JavaServer Faces, the standard component framework for the Java EE platform.
    We covered how to write a simple application by creating pages using Facelets
    as the view technology and CDI named beans. We also covered how to validate user
    input by using JSF''s standard validators and by creating our own custom validators
    or by writing validator methods. Additionally, we covered how to customize standard
    JSF error messages, both the message text and the message style (font, color,
    and so on). Also, we covered how to develop Ajax-enabled JSF pages as well as
    how to integrate JSF and HTML5.    In the next chapter, we will cover how to interact
    with relational databases via the Java Persistence API.[PRE58]``'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE43]`# 自定义数据验证    除了提供标准验证器外，JSF 允许我们创建自定义验证器。这可以通过两种方式完成：创建自定义验证器类或将验证方法添加到我们的命名豆中。    ##
    创建自定义验证器    除了标准验证器外，JSF 允许我们通过创建实现 `javax.faces.validator.Validator` 接口的 Java
    类来创建自定义验证器。    以下类实现了一个电子邮件验证器，我们将使用它来验证客户数据输入屏幕中的电子邮件文本输入字段。    [PRE44]    `@FacesValidator`
    注解将我们的类注册为 JSF 自定义验证器类。其 `value` 属性的值是 JSF 页面可以使用的逻辑名称。    如示例所示，在实现 `Validator`
    接口时，我们只需要实现一个名为 `validate()` 的方法。此方法接受三个参数：`javax.faces.context.FacesContext`
    的一个实例、`javax.faces.component.UIComponent` 的一个实例和一个对象。通常，应用程序开发人员只需关注后两个参数。第二个参数是我们正在验证数据的组件，第三个参数是实际值。在示例中，我们将
    `uiComponent` 强制转换为 `javax.faces.component.html.HtmlInputText`；这样，我们可以访问其 `getLabel()`
    方法，我们可以将其用作错误消息的一部分。    如果输入的值不是有效的电子邮件地址格式，则创建一个新的 `javax.faces.application.FacesMessage`
    实例，将要在浏览器中显示的错误消息作为其构造函数参数传递。然后我们抛出一个新的 `javax.faces.validator.ValidatorException`
    异常。错误消息随后在浏览器中显示。    ### 小贴士    **Apache Commons Validator**    我们的自定义 JSF 验证器使用
    Apache Commons Validator 进行实际验证。此库包括许多常见的验证，如日期、信用卡号码、ISBN 号码和电子邮件。在实现自定义验证器时，值得调查是否已经存在我们可以使用的验证器。    为了在我们的页面上使用我们的验证器，我们需要使用
    `<f:validator>` JSF 标签。以下 Facelets 页面是客户数据输入屏幕的修改版本。此版本使用 `<f:validator>` 标签来验证电子邮件。    [PRE45]    注意到
    `<f:validator>` 标签的 `validatorId` 属性值与我们的自定义验证器中 `@FacesValidator` 注解的 `value`
    属性值相匹配。    在编写我们的自定义验证器并修改我们的页面以利用它之后，我们可以在以下屏幕截图中看到我们的验证器在行动：  ![创建自定义验证器](img/6886EN_02_07.jpg)  ##
    验证器方法    另一种实现自定义验证的方法是将验证方法添加到应用程序的一个或多个命名豆中。以下 Java 类说明了 JSF 验证中使用验证器方法的使用：    [PRE46]    在此示例中，该类仅包含验证器方法。我们可以给我们的验证器方法起任何名字；然而，它的返回值必须是
    void，并且它必须按照示例中所示按顺序接受三个参数。换句话说，除了方法名外，验证器方法的签名必须与在 `javax.faces.validator.Validator`
    接口中定义的 `validate()` 方法的签名相同。    如我们所见，我们的验证器方法的主体几乎与我们的自定义验证器的 `validate()` 方法的主体相同。我们检查用户输入的值以确保它只包含字母字符和/或空格。如果不满足这些条件，则抛出
    `ValidatorException`，传递一个包含适当的 `String` 错误消息的 `FacesMessage` 实例。    ### 小贴士    **StringUtils**    在示例中，我们使用了
    `org.apache.commons.lang.StringUtils` 来执行实际的验证逻辑。除了示例中使用的该方法外，此类还包含几个用于验证字符串是否为数字或字母数字的方法。此类是
    Apache `commons-lang` 库的一部分，在编写自定义验证器时非常有用。    由于每个验证器方法都必须在命名豆中，因此我们需要确保包含我们的验证器方法的类被
    `@Named` 注解标记，如我们的示例所示。    为了使用我们的验证器方法，我们需要通过标签的 `validator` 属性将其绑定到我们的组件。执行此操作的代码如下：    [PRE47]    由于姓名和姓氏字段都不会接受除字母字符或空格之外的内容，我们将我们的自定义验证器方法添加到这两个字段。    注意到
    `<h:inputText>` 标签的 `validator` 属性值是一个 JSF 表达式语言表达式，它使用包含我们的验证方法的命名豆的默认名称。`alphaValidator`
    是我们的命名豆的名称，`validateAlpha` 是我们的验证器方法的名称。    在修改我们的页面以使用自定义验证器之后，我们现在可以按照以下方式看到它在行动：  ![验证器方法](img/6886EN_02_08.jpg)  注意到对于
    **First Name** 字段，我们的自定义验证器消息和标准长度验证器都执行了。    实现验证器方法的优点是您不需要创建一个仅用于单个验证器的整个类。（我们的示例就是这样做的，但在许多情况下，验证器方法被添加到包含其他方法的现有命名豆中。）验证器方法的缺点是每个组件只能由单个验证器方法进行验证。当使用验证器类时，可以在要验证的标签内部嵌套多个
    `<f:validator>` 标签；因此，可以对字段执行多个验证，包括自定义和标准验证。    # 自定义 JSF 的默认消息    如我们之前提到的，可以自定义
    JSF 默认验证消息的样式（字体、颜色、文本等）。此外，还可以修改默认 JSF 验证消息的文本。在以下部分中，我们将解释如何修改错误消息的格式和文本。    ##
    自定义消息样式    可以通过 **Cascading Style Sheets** （**CSS**）来自定义消息样式。这可以通过使用 `<h:message>`
    样式或 `styleClass` 属性来完成。当我们要声明内联 CSS 样式时，使用 `style` 属性。当我们要在 CSS 样式表中或在我们的页面中的
    `<style>` 标签内使用预定义的样式时，使用 `styleClass` 属性。    以下标记说明了使用 `styleClass` 属性来更改错误消息样式的用法。这是我们在上一节中看到的输入页面的修改版本。    [PRE48]    与上一个页面相比，唯一的区别是使用了
    `<h:messages>` 标签的 `styleClass` 属性。如前所述，`styleClass` 属性的值必须与在层叠样式表中定义的 CSS 样式的名称相匹配。    在我们的情况下，我们在
    `style.css` 中为消息定义了一个 CSS 样式，如下所示：    [PRE49]    然后，我们将此样式用作 `<h:messages>` 标签的
    `styleClass` 属性的值。    以下屏幕截图说明了在实施此更改后验证错误消息的外观：  ![自定义消息样式](img/6886EN_02_09.jpg)  在这个特定的例子中，我们只是将错误消息文本的颜色设置为红色，但我们只受
    CSS 功能的限制来设置错误消息的样式。    ## 自定义消息文本    有时可能希望覆盖 JSF 的默认验证错误。默认验证错误在名为 `Messages.properties`
    的资源包中定义。此文件位于 `[glassfish 安装目录]/glassfish/modules` 下的 `javax.faces.jar` 文件中。它位于
    JAR 文件中的 `javax/faces` 文件夹内。该文件包含多个消息，但在此阶段我们只对验证错误感兴趣。默认验证错误消息如下定义：    [PRE50]    为了覆盖默认错误消息，我们需要创建自己的资源包，使用与默认资源包相同的键，但更改值以适应我们的需求。以下是我们应用程序的非常简单的自定义资源包：    [PRE51]    在此资源包中，我们覆盖了由
    `<f:validateLength>` 标签验证的字段输入的值小于允许的最小值时的错误消息。为了让我们的应用程序知道我们有一个包含消息属性的自定义资源包，我们需要按照以下方式修改应用程序的
    `faces-config.xml` 文件：    [PRE52]    如我们所见，我们只需对应用程序的 `faces-config.xml` 文件进行修改，添加一个
    `<message-bundle>` 元素，指示包含我们的自定义消息的资源包的名称和位置。    ### 注意    自定义错误消息文本定义是少数几种我们仍然需要为现代
    JSF 应用程序定义 `faces-config.xml` 文件的情况之一。然而，请注意我们的 `faces-config.xml` 文件是多么简单；它与
    JSF 1.x 的典型 `faces-config.xml` 文件大相径庭，JSF 1.x 的典型 `faces-config.xml` 文件通常包含命名豆定义、导航规则、JSF
    验证器定义等。    在添加我们的自定义消息资源包并修改应用程序的 `faces-config.xml` 文件后，我们可以在以下屏幕截图中看到我们的自定义验证消息在行动：  ![自定义消息文本](img/6886EN_02_10.jpg)  如屏幕截图所示，如果我们没有覆盖验证消息，则默认值仍然会显示。在我们的资源包中，我们只覆盖了最小长度验证错误消息；因此，我们的自定义错误消息显示在
    **First Name** 文本字段中。由于我们没有覆盖其他标准 JSF 验证器的错误消息，因此对于每个验证器，都显示了默认错误消息。电子邮件验证器是我们在本章前面开发的自定义验证器。由于它是一个自定义验证器，因此其错误消息不受影响。    #
    启用 JSF 应用程序的 Ajax    JSF 的早期版本没有包含本机 Ajax 支持。自定义 JSF 库供应商被迫以自己的方式实现 Ajax。不幸的是，这种状态引入了
    JSF 组件库之间的不兼容性。JSF 2.0 通过引入 `<f:ajax>` 标签来标准化 Ajax 支持。    以下页面说明了 `<f:ajax>` 标签的典型用法：    [PRE53]    在部署我们的应用程序后，我们的页面渲染如下所示：  ![启用
    JSF 应用程序的 Ajax](img/6886EN_02_11.jpg)  此示例页面说明了 `<f:ajax>` 标签的两个用途。在页面的顶部，我们使用了此标签来实现一个典型的
    Ajax Echo 示例，其中 `<h:outputText>` 组件使用输入文本组件的值来更新自己。每次在输入字段中输入字符时，`<h:outputText>`
    组件的值都会自动更新。    为了实现上一段中描述的功能，我们在 `<h:inputText>` 标签内放置了一个 `<f:ajax>` 标签。`<f:ajax>`
    标签的 `render` 属性的值必须与我们在 Ajax 请求完成后希望更新的组件的 ID 相对应。在我们的示例中，我们希望使用 ID 为 "`textVal`"
    的 `<h:outputText>` 组件进行更新；因此，我们将此值用作 `<f:ajax>` 标签的 `render` 属性的值。    ### 注意    在某些情况下，我们可能需要在
    Ajax 事件完成后渲染多个 JSF 组件；为了适应这种情况，我们可以将多个 ID 作为 `render` 属性的值，我们只需用空格将它们分开即可。    我们在此实例中使用的另一个
    `<f:ajax>` 属性是 `event` 属性。此属性指示触发 Ajax 事件的 JavaScript 事件。在这种情况下，我们需要在用户在输入字段中键入时释放任何键时触发事件；因此，要使用的事件是
    `keyup`。    以下表格列出了所有支持的 JavaScript 事件：     | 事件 | 描述 | | --- | --- | | `blur`
    | 组件失去焦点。 | | `change` | 组件失去焦点，其值已修改。 | | `click` | 在组件上单击。 | | `dblclick` |
    在组件上双击。 | | `focus` | 组件获得焦点。 | | `keydown` | 在组件具有焦点时按下键。 | | `keypress` | 在组件具有焦点时按下或保持按下的键。
    | | `keyup` | 在组件具有焦点时释放键。 | | `mousedown` | 在组件具有焦点时按下鼠标按钮。 | | `mousemove` |
    鼠标指针在组件上移动。 | | `mouseout` | 鼠标指针离开组件。 | | `mouseover` | 鼠标指针放在组件上。 | | `mouseup`
    | 在组件具有焦点时释放鼠标按钮。 | | `select` | 选择组件的文本。 | | `valueChange` | 等同于 `change`；组件失去焦点，其值已修改。
    |    我们再次使用 `<f:ajax>` 标签在页面下方较远的位置来启用命令按钮组件的 Ajax。在这种情况下，我们希望根据两个输入组件的值重新计算一个值。为了在服务器上使用最新的用户输入更新值，我们使用了
    `<f:ajax>` 的 `execute` 属性；此属性接受一个空格分隔的组件 ID 列表，用作输入。然后我们像以前一样使用 `render` 属性来指定在
    Ajax 请求完成后需要重新渲染哪些组件。    注意到我们使用了 `<h:commandButton>` 的 `actionListener` 属性。此属性通常用于在单击按钮后不需要导航到另一个页面时使用。此属性的值是我们在一个命名豆中编写的动作监听器方法。动作监听器方法必须返回
    void，并接受一个 `javax.faces.event.ActionEvent` 实例作为其唯一参数。    我们应用程序的命名豆如下所示：    [PRE54]    注意到我们不需要在我们的命名豆中做任何特殊的事情来在我们的应用程序中启用
    Ajax。一切都在页面的 `<f:ajax>` 标签中控制。    如此示例所示，启用 JSF 应用程序的 Ajax 非常简单。我们只需使用一个标签来启用我们的页面，而无需编写任何
    JavaScript、JSON 或 XML 代码。    # JSF 2.2 HTML5 支持    HTML 5 是 HTML 规范的最新版本。它包括比之前版本的
    HTML 多几个改进。JSF 2.2 通过引入 `<f:ajax>` 标签来包含对 HTML5 的支持。    ## HTML5 友好标记    通过使用透传元素，我们可以使用
    HTML 5 标签开发页面，并将它们视为 JSF 组件。为此，我们需要使用 `http://xmlns'
