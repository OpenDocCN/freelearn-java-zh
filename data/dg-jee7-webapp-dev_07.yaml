- en: Chapter 7. Progressive JavaScript Frameworks and Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。渐进式 JavaScript 框架和模块
- en: '|   | *"If you''re a runner and you run in a race, you might lose. If you don''t
    run, you''re guaranteed to lose."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"如果你是一个跑步者，你在比赛中跑步，你可能会输。如果你不跑，你肯定要输。"* |   |'
- en: '|   | --*Reverend Jesse Jackson* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*耶稣会士杰西·杰克逊* |'
- en: In the contemporary way of building a website, there is no escape from the language
    of JavaScript because it is a de facto standard of modern web browsers. JavaScript
    is either a pleasure or major inconvenience for developers. If you write or intend
    to build digital web applications for a customer, there is almost no escape from
    the knowledge of HTML5, CSS, and JavaScript. Fortunately, you do not need to be
    an expert in JavaScript in order to be productive because there are many frameworks
    that help you and you can leverage these ideas. Essentially, where JavaScript
    is concerned, you need to know and catch up with the modern digital best practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今构建网站的方式中，无法避开 JavaScript 语言，因为它是现代网络浏览器的事实标准。JavaScript 对于开发者来说要么是一种乐趣，要么是一种重大不便。如果你为客户编写或打算构建数字网络应用程序，几乎无法避开
    HTML5、CSS 和 JavaScript 的知识。幸运的是，你不需要成为 JavaScript 的专家才能变得高效，因为有许多框架可以帮助你，你可以利用这些想法。本质上，在
    JavaScript 方面，你需要了解并跟上现代数字的最佳实践。
- en: While JavaScript is a very relevant topic for the digital websites, this chapter
    cannot teach you everything that you need to know. Instead, I will endeavor to
    point you in the correct direction and provide you with an oversight, and you
    should definitely extend your knowledge with further resources.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JavaScript 对于数字网站来说是一个非常相关的话题，但这一章不能教你所有你需要知道的内容。相反，我将努力指出正确的方向，并提供一个概述，你应该肯定地通过进一步资源扩展你的知识。
- en: We will start with the fundamental JavaScript programming and an idea of the
    language. We will then dive straight into programming with the JavaScript objects.
    Afterwards, we will look at a few of the major frameworks in the world of JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基本的 JavaScript 编程和语言的概念开始。然后我们将直接进入使用 JavaScript 对象的编程。之后，我们将查看世界上一些主要的
    JavaScript 框架。
- en: JavaScript essentials
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 基础
- en: 'JavaScript is a respected programming language by itself. It has a standard
    called ECMAScript ([http://www.ecmascript.org/](http://www.ecmascript.org/)) and
    is accepted as a ratified standard by the W3C. The language is a part of the trinity
    of the fundamental standard web technologies: HTML5, CSS, and JavaScript. That
    said, what is JavaScript? It is a prototype dynamically typed scripting language
    with object types and enclosed scoped function blocks. In JavaScript, every type
    is strictly an object. The JavaScript support functions as a first-class citizen
    and rules on a and supports the declaration of functions that are assigned to
    an associated lexically scoped variable, property, or entity. JavaScript has a
    support for strings, integers, floating point numbers, and prototypes. JavaScript
    is essentially a property and prototypical language. It has a lexical support
    of object-based programming through scopes and closures. The widespread use of
    the language does not explicitly have reserved keywords and it structures out
    of the support object-oriented inheritance. Through clever programming and prototypes,
    developers can replicate the object class inheritance.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 本身是一种备受尊重的编程语言。它有一个名为 ECMAScript 的标准([http://www.ecmascript.org/](http://www.ecmascript.org/))，并被
    W3C 承认为一个批准的标准。这种语言是基本标准网络技术的三合一之一：HTML5、CSS 和 JavaScript。那么，什么是 JavaScript 呢？它是一种具有对象类型和封闭作用域函数块的动态类型脚本语言。在
    JavaScript 中，每个类型严格上是对象。JavaScript 支持函数作为一等公民，并支持将函数分配给相关词法作用域变量、属性或实体的声明。JavaScript
    支持字符串、整数、浮点数和原型。JavaScript 本质上是一种属性和原型语言。它通过作用域和闭包支持基于对象的编程。该语言的广泛应用并不显式地有保留关键字，并且它通过支持面向对象继承的结构化。通过巧妙的编程和原型，开发者可以复制对象类继承。
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What is the base level standard JavaScript that I should learn?**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该学习哪种基础标准的 JavaScript？**'
- en: 'This chapter looks at JavaScript 1.5, which is ECMA Script Edition 3\. This
    version of the language works in all the major web browsers: Firefox, Chrome,
    Safari, and Internet Explorer. The upcoming JavaScript ECMA 6 will have support
    for object-oriented programming ([http://es6-features.org/](http://es6-features.org/)).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 JavaScript 1.5，即 ECMA Script 版本 3。这种语言版本可以在所有主要网络浏览器（Firefox、Chrome、Safari
    和 Internet Explorer）中运行。即将推出的 JavaScript ECMA 6 将支持面向对象编程（[http://es6-features.org/](http://es6-features.org/)）。
- en: JavaScript is a popular language on the client side of a normal Java web application.
    You should be aware that JavaScript can also operate on the server side through
    an implementation such as Node.js or Nashorn. These topics are, however, out of
    the scope for this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是在正常 Java 网络应用程序客户端上的一种流行语言。你应该知道，JavaScript 也可以通过 Node.js 或 Nashorn
    等实现方式在服务器端运行。然而，这些内容并不在本章的讨论范围内。
- en: Creating objects
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'Let''s wade into JavaScript on the client side. What is JavaScript programming
    with an object that you, as a digital developer, can write? Here is one answer—an
    HTML5 web page with an embedded script that creates a contact detail, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨客户端的 JavaScript。作为数字开发者，你能用对象编写什么样的 JavaScript 程序呢？以下是一个答案——一个嵌入脚本的 HTML5
    网页，该脚本创建了一个联系人详细信息，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This simple program creates a contact detail with properties. The JavaScript
    properties may be integer, numerical numbers: number, or Boolean or String types.
    A JavaScript object may also define the methods as in the case of `getFullName()`.
    For a stock blue-collar Classic Java developer, this syntax of defining a property
    from a function looks peculiar; however, the functions are first-class citizens
    of many languages. The JavaScript functions that define an object are called methods.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序创建了一个具有属性的联系人详细信息。JavaScript 属性可以是整数、数值数字：number、布尔值或 String 类型。JavaScript
    对象还可以定义方法，例如 `getFullName()`。对于一个经验丰富的经典 Java 开发者来说，这种从函数定义属性的方法看起来很奇特；然而，函数是许多语言的一等公民。定义对象的
    JavaScript 函数被称为方法。
- en: 'In the modern JavaScript writing practices, you will learn to recognize the
    functions written similarly in this vein, which is the reverse of the Java notation.
    Here is a third order polynomial function from mathematics in JavaScript:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 JavaScript 编写实践中，你将学会识别类似这种风格的函数，这与 Java 语法相反。以下是一个来自数学的第三阶多项式函数在 JavaScript
    中的示例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This variable defines a JavaScript function called `polynomial()`, which accepts
    three number type arguments. It also returns a Number type. JavaScript is a dynamically
    typed language and thus, there is no static typing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量定义了一个名为 `polynomial()` 的 JavaScript 函数，它接受三个数字类型的参数，并返回一个数字类型。JavaScript
    是一种动态类型语言，因此没有静态类型。
- en: The console log
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制台日志
- en: 'The console log is a standard object that is a part of the modern web browsers:
    Firefox, Chrome, Opera, Safari, and Internet Explorer. It is usually available
    from the menu that is reserved for the debugging. Formerly, the console object
    was not completely supported for browsers.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台日志是现代网络浏览器（Firefox、Chrome、Opera、Safari 和 Internet Explorer）中的一个标准对象。它通常可以从用于调试的菜单中访问。以前，控制台对象并未完全支持所有浏览器。
- en: 'Thankfully, we will not be writing the following conditional code in 2016:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不会在 2016 年编写以下条件代码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s move to the object constructors. Allow me to provide a final note of
    advice about writing a console log: use it only in the development code. Developers
    have been forgotten to remove the console log output from production code, which
    eventually led to crash in a certain web browser, ruining the digital customer''s
    journey. Take advantage of a JavaScript framework such as jQuery, RequireJS, or
    Dojo, which abstracts away the console log in a library function.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向对象构造函数。让我提供一条关于编写控制台日志的最终建议：仅在开发代码中使用它。开发者们常常忘记从生产代码中移除控制台日志输出，这最终导致某些网络浏览器崩溃，破坏了数字客户的旅程。利用像
    jQuery、RequireJS 或 Dojo 这样的 JavaScript 框架，这些框架通过库函数抽象化控制台日志。
- en: If you haven't eventually done so, I strongly recommend that you download the
    Chrome Developer and Web Developer tools for either the Google Chrome or Firefox
    web browsers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，我强烈建议你下载适用于 Google Chrome 或 Firefox 网络浏览器的 Chrome 开发者工具和 Web 开发者工具。
- en: Writing JavaScript object constructors
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 JavaScript 对象构造函数
- en: 'The JavaScript language consists of a limited variety of primitive types in
    comparison. Loosely, these primitives are String, Number, Boolean, Array, and
    Object. These can be created using native JavaScript object constructors: `String()`,
    `Number()`, `Boolean()`, `Array()`, and `Object()`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言相比，JavaScript 语言具有有限的原始类型。粗略地说，这些原始类型包括 String、Number、Boolean、Array 和 Object。这些类型可以使用原生的
    JavaScript 对象构造函数创建：`String()`、`Number()`、`Boolean()`、`Array()` 和 `Object()`。
- en: 'Here is an illustration of how to use these native constructors:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用这些原生构造函数的示例：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Obviously, it is rare to assign the String, Boolean, and Number types from the
    native constructors. However, note the use of the Array native constructor. In
    JavaScript, arrays are treated as objects. They are enumerated from the index
    zero like most computer languages. To find the size of the array, invoke the implicit
    length property (`name.length`).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，很少将 String、Boolean 和 Number 类型从原生构造函数中分配。然而，请注意 Array 原生构造函数的使用。在 JavaScript
    中，数组被视为对象。它们从索引零开始枚举，就像大多数计算机语言一样。要找到数组的大小，调用隐式长度属性（`name.length`）。
- en: 'To establish the JavaScript essentials, we can finesse the earlier example
    and take advantage of the ability of the functions to introduce their own scope,
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立 JavaScript 的基础知识，我们可以改进前面的示例，并利用函数引入它们自己的作用域的能力，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a few things going on with this second example. First, we will assign
    a function type to the `ContactDetail` variable. This function is actually a constructor
    for a new object type named by the variable name. In this constructor, there is
    a special `this` reference variable that is associated with the function scope
    at this level. When the reference is returned, it becomes the object instance.
    In the function, we are allowed to define the other functions that are associated
    with the object, such as `getFullName()`. This is how object-based programming
    works in modern JavaScript.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个示例中，有几件事情正在进行。首先，我们将函数类型分配给 `ContactDetail` 变量。实际上，这个函数是一个名为变量名称的新对象类型的构造函数。在这个构造函数中，有一个特殊的
    `this` 引用变量，它与当前级别的函数作用域相关联。当引用返回时，它成为对象实例。在函数中，我们允许定义与对象关联的其他函数，例如 `getFullName()`。这就是现代
    JavaScript 中基于对象的编程方式。
- en: We will use this new object type constructor to declare a contact detail in
    the variable called `anne`. For Java regular programmers, this syntax might look
    very weird at first, but this JavaScript is completely different to Java and is
    seriously accepted as a programming language in its own right. A scope has practical
    uses in defining the object modules, which I showed in the first chapter of this
    book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个新的对象类型构造函数在名为 `anne` 的变量中声明联系详情。对于 Java 习惯程序员来说，这种语法一开始可能看起来非常奇怪，但 JavaScript
    完全不同于 Java，并且作为一个独立的编程语言被认真接受。作用域在定义对象模块中有实际用途，我在本书的第一章中展示了这些对象模块。
- en: The JavaScript property notations
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 属性表示法
- en: There are two fundamental ways to access the JavaScript properties in a type.
    The first way is pretty familiar to all Java programmers. It is the dot notation.
    The second way is called the bracket notation, which looks like a map or dictionary
    association in the languages other than Java. The bracket notation is equivalent
    to the dot notation and has its uses.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型中访问 JavaScript 属性有两种基本方法。第一种方法对所有 Java 程序员来说都很熟悉。它是点符号。第二种方法称为括号符号，在其他非 Java
    语言中看起来像映射或字典关联。括号符号等同于点符号，并且有其用途。
- en: Examine the following code, which demonstrates another way to create a JavaScript
    object. Remember that JavaScript is a dynamically typed language.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下代码，它演示了创建 JavaScript 对象的另一种方法。记住，JavaScript 是一种动态类型语言。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Did you spot the introduction of a new property to the object called subject
    and also a method function? Of course, I am promoting the title of my first technical
    book here, but that is beside the point. JavaScript allows programmers to be quite
    flexible with object internals and properties. The declaration of the object product
    should ring some bells because it is remarkable how similar this declaration is
    to the de facto **JavaScript Object Notation** (**JSON**) standard. The open curly
    bracket notation is a way to define an object with the property key and values.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到了对象中引入了一个名为subject的新属性以及一个方法函数？当然，我在这里推广的是我的第一本技术书的标题，但这不是重点。JavaScript允许程序员在对象内部和属性上相当灵活。对象product的声明应该会让人想起一些东西，因为它与事实上的**JavaScript对象表示法**（**JSON**）标准非常相似。开括号表示法是一种定义具有属性键和值的对象的方式。
- en: Dealing with a null and undefined reference pointer
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理null和undefined引用指针
- en: 'Professor Charles Antony Richard Hoare (Tony Hoare) developed the classic computer
    science algorithm called **QuickSort**, but he also regretted when he said that
    it was also the invention of a billion dollar mistake: the dreaded null reference
    pointer. Personally, I would have thought that someone else would have stumbled
    on such an obvious workaround and quick fit for a general problem.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·安东尼·理查德·霍尔爵士（Tony Hoare）开发了经典的计算机科学算法**快速排序**，但他也后悔地说，这也是一个价值十亿美元的错误：可怕的null引用指针。我个人认为，其他人可能会偶然发现这样一个明显的解决方案，以快速解决一个普遍问题。
- en: 'JavaScript deals with a null reference as a sentinel and also features undefined.
    The following JavaScript extract attempts to print the null reference in a `test`
    object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript将null引用视为哨兵，并具有undefined。以下JavaScript摘录尝试在`test`对象中打印null引用：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The null value tells you that the object type thing is defined but is not yet
    available. The undefined value informs the developer that something is missing.
    Remember that JavaScript is a dynamic language and therefore, it is entirely possible
    to navigate across the object graph and not find the object type that your team
    thought was placed there.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: null值告诉你对象类型的东西已定义但尚未可用。undefined值通知开发者某些东西缺失。记住，JavaScript是一种动态语言，因此，在对象图中导航并找不到团队认为放置在那里的对象类型是完全可能的。
- en: 'In JavaScript, if you need to test for a null value, you must use the triple
    equal operator (`===`), as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，如果你需要测试一个null值，你必须使用三等号运算符（`===`），如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Writing about equivalence, how do we know when two objects are equivalent in
    JavaScript?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于等价性的写作，我们如何在JavaScript中知道两个对象何时是等价的？
- en: The JavaScript truth
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript真值
- en: 'In JavaScript, the conditional expression is false, if it matches one of the
    Set of Empty Values: `false`, `0`, `-0`, `null`, empty string (`''''`), `NaN`,
    or `undefined`. A value evaluates to the JavaScript truth in a conditional expression,
    if and only if the value does not match any of the elements in the Empty Values
    set. Every other value that does match any of the elements is an empty value set
    that evaluates to JavaScript true.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，条件表达式为假，如果它匹配以下空值集合之一：`false`、`0`、`-0`、`null`、空字符串（`''`）、`NaN`或`undefined`。一个值在条件表达式中评估为JavaScript真值，当且仅当该值不匹配空值集合中的任何元素。任何匹配空值集合中元素的值都是评估为JavaScript真的空值集合。
- en: 'The following JavaScript all evaluates to false:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下JavaScript都评估为假：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we use the `Boolean` constructor with the new keyword to instantiate
    a type directly. These statements evaluate to true:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用带有new关键字的`Boolean`构造函数直接实例化一个类型。以下语句评估为真：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Runtime type information
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时类型信息
- en: 'In order to find out the runtime information of the JavaScript values, you
    can apply the `typeof` operator. This permits the programmer to write a specialist
    code in order to check the arguments to a function. Here is an example of the
    `typeof` interrogation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出JavaScript值的运行时信息，你可以应用`typeof`运算符。这允许程序员编写专门代码来检查函数的参数。以下是一个`typeof`查询的示例：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'JavaScript has some other quirks, if you use the native constructors:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用原生构造函数，JavaScript有一些其他怪癖：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is surprising! Here is the evidence where you can see why digital web developers
    are driven mad because of the inconsistency in the language, standards, and implementations
    of these standards.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这很令人惊讶！以下证据显示了为什么数字网络开发者因为语言、标准和这些标准的实现不一致而发疯。
- en: The JavaScript functions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript函数
- en: In modern JavaScript, you will see a lot of quasi-functional programming in
    comparison to Classic Java (Java before version 8 and Lambda expressions). The
    functions are the first-class citizens. You can supply functions as parameters
    to the functions. You can also return a function type from a function. How does
    passing a function as a parameter to a method help? In JavaScript, you can write
    anonymous functions without a name. You can take advantage of passing around the
    blocks of code to the library functions. This style is the basis of functional
    programming. Instead of coding imperatively, we can write concise code and inline,
    which is almost declarative.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JavaScript中，与经典Java（8版本之前的Java和Lambda表达式）相比，你会看到很多准函数式编程。函数是一等公民。你可以将函数作为参数传递给函数。你也可以从一个函数中返回一个函数类型。将函数作为参数传递给方法有什么帮助？在JavaScript中，你可以编写无名的匿名函数。你可以利用将代码块传递给库函数的优势。这种风格是函数式编程的基础。我们不是用命令式编程，而是可以编写简洁且内联的代码，这几乎是声明式的。
- en: 'Here is an anonymous function example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个匿名函数的示例：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `outside()` function accepts an anonymous `yourIn()` function, as a single
    argument. Now inside the `outside()` function, it immediately invokes the argument
    `yourIn`, which is the supplied anonymously defined function. This is a powerful
    technique.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`outside()`函数接受一个匿名`yourIn()`函数作为单一参数。现在在`outside()`函数内部，它立即调用参数`yourIn`，即提供的匿名定义的函数。这是一个强大的技术。'
- en: 'JavaScript has one other trick that lends itself to the declaration of modules,
    especially when it is combined with the functional object scopes. It is possible
    to define a function and invoke it inline and directly. Consider this example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还有一个技巧，有助于模块的声明，尤其是当它与函数对象作用域结合使用时。可以定义一个函数并直接内联调用它。考虑以下示例：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we defined a variable called `initializeGui` and assigned
    it an anonymous function. The key to the definition is the final round brackets
    at the end of the method statement. JavaScript immediately invokes the function
    at the precise location where the definition is parsed. Here, we are pretending
    to initialize a client side GUI by writing to the console.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为`initializeGui`的变量，并将其分配给一个匿名函数。定义的关键在于方法语句末尾的最终圆括号。JavaScript立即在定义解析的确切位置调用函数。在这里，我们假装通过写入控制台来初始化客户端GUI。
- en: 'You can also pass the parameters to an inlined function, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将参数传递给内联函数，如下所示：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This preceding code demonstrates that the parameters are passed from the outside
    global scope to the invoked function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码演示了参数是从外部全局作用域传递到被调用的函数的。
- en: 'In fact, we can get rid of the variable `initializeGui2` and create a self-invocation
    anonymous function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以去掉变量`initializeGui2`并创建一个自调用的匿名函数：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This kind of code is fairly typical and seen in the popular JavaScript frameworks
    and applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码相当典型，在流行的JavaScript框架和应用程序中都可以看到。
- en: In the function definition, we will take advantage of the JavaScript scope.
    See [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Digital Java EE 7"), *Digital
    Java EE 7* for an earlier explanation on the module namespace technique.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，我们将利用JavaScript的作用域。参见[第1章](part0015.xhtml#aid-E9OE1 "第1章 数字Java EE 7")，*数字Java
    EE 7*，了解关于模块命名空间技术的早期解释。
- en: 'I think I will stop here. There is a tremendous variety and a deeper knowledge
    track to the modern JavaScript programming than I can write about here. I recommend
    that you invest in other introductory programming books such as Douglas Crockford''s
    excellent *JavaScript: The Good Parts* and also Packt Publishing''s *Object-Oriented
    JavaScript* by authors *Stoyan Stefanov* and *Kumar Chetan Sharma*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我该停在这里了。现代JavaScript编程的多样性和更深入的知识轨迹远远超出了我所能描述的范围。我建议你投资于其他入门级编程书籍，例如Douglas
    Crockford的杰出作品*JavaScript：The Good Parts*，以及作者*Stoyan Stefanov*和*Kumar Chetan
    Sharma*的Packt Publishing的*面向对象的JavaScript*。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Steve Kwan has written an excellent example of the Module Pattern in JavaScript;
    you might want to investigate his best practices at [https://github.com/stevekwan/best-practices/blob/master/javascript/best-practices.md](https://github.com/stevekwan/best-practices/blob/master/javascript/best-practices.md).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Steve Kwan已经编写了一个关于JavaScript模块模式的优秀示例；你可能想调查他的最佳实践，请参阅[https://github.com/stevekwan/best-practices/blob/master/javascript/best-practices.md](https://github.com/stevekwan/best-practices/blob/master/javascript/best-practices.md)。
- en: Let's look at a very important programming framework for JavaScript, jQuery.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看JavaScript的一个非常重要的编程框架，jQuery。
- en: Introducing the jQuery framework
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 jQuery 框架
- en: jQuery ([http://learn.jquery.com/](http://learn.jquery.com/)) is a cross-platform
    JavaScript framework for client-side web application development. It is a survivor
    from the original AJAX craze from 2004 and 2005, where it was and still is competing
    with Prototype ([http://prototypejs.org/](http://prototypejs.org/)) and Scriptaculous
    ([http://script.aculo.us/](http://script.aculo.us/)). jQuery has been called the
    equivalent of what the Java Collections framework did for the Java programming
    language. According to Wikipedia, jQuery is 70 percent of the 10,000 most visited
    websites in the world. In other words, it is the first JavaScript framework that
    really caught the attention of the developers and caused them to rethink the furthest
    capabilities of the underlying language. jQuery is free and provided under the
    MIT open source license.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery ([http://learn.jquery.com/](http://learn.jquery.com/)) 是一个跨平台的 JavaScript
    框架，用于客户端 Web 应用程序开发。它是 2004 年和 2005 年原始 AJAX 狂潮的幸存者，当时它与 Prototype ([http://prototypejs.org/](http://prototypejs.org/))
    和 Scriptaculous ([http://script.aculo.us/](http://script.aculo.us/)) 竞争，现在仍在竞争。jQuery
    被称为 Java 集合框架对 Java 编程语言所做贡献的等价物。根据维基百科，jQuery 占据了世界上 10,000 个最受欢迎的网站中的 70%。换句话说，它是第一个真正引起开发者注意并使他们重新思考底层语言最远能力的
    JavaScript 框架。jQuery 是免费的，并且根据 MIT 开源许可证提供。
- en: jQuery was built to make the manipulation of the **Document Object Model** (**DOM**)
    easier and apply CSS to the HTML elements. In jQuery, there is a secret sauce
    called Sizzle, which is a selector engine that traverses over the DOM. The engine
    combines the flexibility of selection, a respect for functional programming, and
    callback to allow an engineer to comfortably write JavaScript that leverages the
    underlying HTML and CSS elements in a web page.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的构建目的是使操作 **文档对象模型** (**DOM**) 更容易，并将 CSS 应用到 HTML 元素上。在 jQuery 中，有一个名为
    Sizzle 的秘密配方，它是一个遍历 DOM 的选择器引擎。该引擎结合了选择的灵活性、对函数式编程的尊重以及回调，使工程师能够舒适地编写利用网页中底层 HTML
    和 CSS 元素的 JavaScript 代码。
- en: Including jQuery in a JSF application
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JSF 应用程序中包含 jQuery
- en: 'You can include the jQuery JavaScript library in your page view. In JSF, the
    folder would be under the `src/main/webapp/resources/` folder:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 jQuery JavaScript 库包含在您的页面视图中。在 JSF 中，该文件夹位于 `src/main/webapp/resources/`
    文件夹下：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will use the expression language, `#{request.contextPath}`, in order to provide
    location independence. Good digital developers will use the minified JavaScript
    for performance and to improve their business SEO chances!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用表达式语言 `#{request.contextPath}` 来提供位置独立性。优秀的数字开发者会使用压缩的 JavaScript 来提高性能并增加他们的商业
    SEO 机会！
- en: jQuery ready function callbacks
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery 准备函数回调
- en: The jQuery framework repurposes the `$` symbol in the global head scope exclusively
    for our use. (The dollar symbol is an alias for the jQuery object instance and
    it is obviously short.) Through clever programming, which is out of the scope
    of this book, jQuery accepts a parameter that represents an HTML DOM object. A
    jQuery entry point is the `ready()` method, which accepts a function object type
    argument.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 框架将全局作用域中的 `$` 符号专门用于我们的使用。美元符号是 jQuery 对象实例的别名，显然它很简洁。通过巧妙的编程，这超出了本书的范围，jQuery
    接受一个代表 HTML DOM 对象的参数。jQuery 的入口点是 `ready()` 方法，它接受一个函数对象类型的参数。
- en: 'This argument can be an anonymous or a named function as we will demonstrate
    here to initialize a fictional website:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数可以是一个匿名函数或一个命名函数，正如我们在这里演示的，以初始化一个虚构的网站：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When jQuery invokes the anonymous function, the framework can make certain
    guarantees that the browser has been initialized, the images have all been downloaded,
    the event stack is set to go, and the other proprietary features of certain web
    clients have been finished. In the preceding example, we will initialize the other
    JavaScript libraries in the module pattern and log to the console:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 jQuery 调用匿名函数时，框架可以保证浏览器已经初始化，所有图片都已下载，事件堆栈已设置，以及某些 Web 客户端的其它专有功能已完成。在前面的示例中，我们将以模块模式初始化模块中的其他
    JavaScript 库并将日志记录到控制台：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `$( document )` expression can be generalized to the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`$( document )` 表达式可以概括为以下内容：'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The expression-selector stanza can be a CSS selector expression or an HTML
    DOM element. Here are some example selectors:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式选择器段落可以是 CSS 选择器表达式或 HTML DOM 元素。以下是一些示例选择器：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The element selectors that start with a hash character (`#`) are equivalent
    to the DOM HTML API call, `getElementById()`, which means that they might return
    the element or not. The `#offerSubmitBtn` selector retrieves an element that is
    specified with the ID attribute:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以哈希字符（`#`）开头的元素选择器等同于 DOM HTML API 调用 `getElementById()`，这意味着它们可能返回元素也可能不返回。`#offerSubmitBtn`
    选择器检索具有 ID 属性指定的元素：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: jQuery offers very powerful class selectors, which retrieve a collection of
    the HTML elements. The `$('div')` selector retrieves all of the HTML `div` elements
    in the document and page views. Likewise, the `$('div')` class selector retrieves
    all the HTML anchor elements. As some might say, knowledge is power! We can combine
    the CSS class selectors to turn down and fine tune the elements that we want to
    manipulate. The `$( ".footerArea div" )` selector restricts the HTML `div` elements
    in the footer area.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 提供了非常强大的类选择器，可以检索一组 HTML 元素。`$('div')` 选择器检索文档和页面视图中的所有 HTML `div` 元素。同样，`$('div')`
    类选择器检索所有 HTML 锚点元素。正如有些人所说，知识就是力量！我们可以组合 CSS 类选择器，以降低和微调我们想要操作的元素。`$( ".footerArea
    div" )` 选择器限制了页脚区域中的 HTML `div` 元素。
- en: Acting on the jQuery selectors
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 jQuery 选择器进行操作
- en: jQuery allows a digital developer to access the HTML DOM elements on the web
    page. So how do you act on these powerful selectors? The API features many callback
    methods that accept a function type parameter. Let's take a look at such a method
    called `click()`, which fires an event when the particular HTML element is pressed
    and depressed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 允许数字开发者访问网页上的 HTML DOM 元素。那么，如何对这些强大的选择器进行操作呢？API 提供了许多接受函数类型参数的回调方法。让我们看看这样一个名为
    `click()` 的方法，当特定的 HTML 元素被按下和释放时，它会触发一个事件。
- en: 'Here is the code for the red button that we saw earlier:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前看到的红色按钮的代码：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the user clicks on the red button, jQuery handles the DOM event and invokes
    the anonymous function that is associated to the jQuery matched selector. The
    user sees the alert dialog. It does not stop there. Here is some code to make
    the red button fade out of the view:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击红色按钮时，jQuery 处理 DOM 事件并调用与 jQuery 匹配选择器关联的匿名函数。用户会看到警告对话框。但这并没有结束。以下是一些使红色按钮从视图中淡出的代码：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is an example of the jQuery animation capability. The `animate()` method
    accepts two arguments: the key and value for the animation properties and a duration
    time. Here we will specify the opacity of the button but we can set other properties
    such as the width or height of the element, and even three-dimensional transformations
    of your target web clients will be served against the CSS3 confirmed web browsers
    only. The duration time is measured in milliseconds.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 jQuery 动画能力的示例。`animate()` 方法接受两个参数：动画属性的关键和值以及持续时间。在这里，我们将指定按钮的不透明度，但我们也可以设置其他属性，例如元素的宽度或高度，甚至可以为仅针对
    CSS3 确认的 Web 浏览器提供目标 Web 客户端的 3D 变换。持续时间以毫秒为单位。
- en: 'If this was a code that is designed to be reused and I wanted a clean modular
    code for a team of interface developers, here is how I would tidy up the code
    and avoid embarrassment:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一段旨在重用的代码，并且我想为界面开发者团队编写干净模块化的代码，以下是我会整理代码并避免尴尬的方法：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using the popular module pattern, I pushed the initialized code for jQuery into
    a `RedModule` module with the `DigitalJavaEE7` namespace. In the `init()` function
    of this module, I optimized the CSS selector in one call to a `redButton` variable.
    It turns out that jQuery works hard at interpreting the CSS selector to a group
    of potential HTML DOM elements. So, we will avoid asking the framework to do this
    search of the DOM twice. Code is essentially the same, but more concise and still
    comprehensible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流行的模块模式，我将 jQuery 的初始化代码推入一个名为 `RedModule` 的模块中，该模块具有 `DigitalJavaEE7` 命名空间。在这个模块的
    `init()` 函数中，我将 CSS 选择器在一个调用中优化为 `redButton` 变量。结果发现，jQuery 正在努力将 CSS 选择器解释为一组潜在的
    HTML DOM 元素。因此，我们将避免让框架对 DOM 进行两次搜索。代码本质上相同，但更简洁且易于理解。
- en: Manipulating the DOM elements
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作 DOM 元素
- en: In the previous section, you learned how to select the DOM elements with jQuery.
    Group elements can be retrieved with the jQuery selectors. Using the manipulation
    part of the API, we will add and remove the class styles to the elements, insert
    the elements before and after a component, and replace the content of the elements.
    There are lots of calls to learn; we will review a small set here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用jQuery选择DOM元素。可以使用jQuery选择器检索组元素。使用API的操纵部分，我们将向元素添加和删除类样式，在组件前后插入元素，并替换元素的内容。有许多调用需要学习；我们在这里将回顾一小部分。
- en: 'In order to demonstrate how we can manipulate the DOM elements, let''s define
    two HTML button elements. We will apply a style of the red color and the other
    will be blue. Here is the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们如何操作DOM元素，让我们定义两个HTML按钮元素。我们将应用红色样式，另一个将是蓝色。以下是代码：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will set up the anonymous functions to add a Bootstrap class, text-danger,
    to `messageArea`, which you can rightly assume is a reserved `div` element for
    a textual output. The `addClass()` method appends a style class to the matching
    elements. We will add the style to the text area with the callback for the `redButton`
    element. The second anonymous function for `blueButton` deletes the class from
    the element. Both the functions will change the message in the display area.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置匿名函数，为`messageArea`添加一个Bootstrap类和text-danger类，你可以合理地假设这是一个用于文本输出的保留`div`元素。`addClass()`方法将样式类追加到匹配的元素上。我们将使用`redButton`元素的回调函数将样式添加到文本区域。为`blueButton`设置的第二个匿名函数将从元素中删除该类。这两个函数都将改变显示区域中的消息。
- en: 'The `html()` method is dual purpose. It is overloaded in the jQuery framework.
    When `html()` is called with a single argument, it replaces the contents of the
    element. We will use the `html()` method to change the text in the message area.
    If the method is called with no arguments, it returns the element''s content.
    There are several API methods in jQuery that have this duality such as `attr()`
    and `val()`. They are described as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`html()`方法具有双重用途。在jQuery框架中，它被重载。当`html()`方法带有一个单一参数被调用时，它将替换元素的内容。我们将使用`html()`方法来更改消息区域中的文本。如果没有参数传递给该方法，它将返回元素的内容。jQuery中有几个具有这种双重性的API方法，例如`attr()`和`val()`。以下是它们的描述：'
- en: The `attr()` method either retrieves or manipulates the attributes for the DOM
    elements.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr()`方法可以检索或操作DOM元素的属性。'
- en: The `val()` method retrieves the current value of the first element in the set
    of matched elements or it sets the value of every matched element. The `val()`
    method is particularly useful to access the name and values in a set of HTML select
    option elements.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val()`方法检索匹配元素集中第一个元素当前的值，或者设置每个匹配元素的值。`val()`方法特别有用，可以访问HTML选择选项元素集中的名称和值。'
- en: Animation
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画
- en: The most sophisticated digital applications on a website incorporate smart animations
    and hints (obviously approved by the Head of UX) to guide the user on their digital
    journey. Usually, it is just enough to provide subtle hints on how the user can
    achieve the best experience with a website and this can make a huge difference
    in the overall satisfaction. jQuery has a base level animation feature such as
    sliding up and down the `div` layers and popups, shrinking and expanding the layers,
    and opacity tricks that can lend a hand.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 网站上最复杂的数字应用程序集成了智能动画和提示（显然得到了UX负责人的批准），以引导用户在他们的数字旅程中。通常，只需提供一些微妙的提示，告诉用户如何获得最佳的网站体验就足够了，这可以在整体满意度上产生巨大的差异。jQuery具有基本的动画功能，如滑动`div`层和弹出窗口，缩小和扩大层，以及透明度技巧，这些都可能提供帮助。
- en: To see the animation, let's examine how to use jQuery to animate a scroll-to-the-top
    arrow when the user scrolls down a page for a certain distance. This is a common
    user interface design pattern. We will not put in a module pattern for obvious
    space reasons.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看动画，让我们看看如何使用jQuery在用户向下滚动页面一定距离时动画化滚动到顶部的箭头。这是一个常见的用户界面设计模式。出于明显的空间原因，我们不会在这里使用模块模式。
- en: 'Let''s assume we have a simple HTML content on our JSF page view:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在JSF页面视图中有一个简单的HTML内容：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we will need to write a function handler that listens to scroll events
    when the user is scrolling up or down the page view. In the DOM, there is a standard
    method, `scroll()`, on the global Window object that accepts a function object
    as a callback.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编写一个函数处理程序，当用户在页面视图中向上或向下滚动时，它会监听滚动事件。在DOM中，全局Window对象上有一个标准方法`scroll()`，它接受一个函数对象作为回调。
- en: 'With an entry point, we will write a handler function, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个入口点，我们将编写一个处理函数，如下所示：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Don't be afraid of the length of this JavaScript function because all will be
    revealed now. It turns out that attaching a callback as a scroll listener means
    that the web browser potentially invokes the callback for perhaps 10 or perhaps
    scores of times per second depending on the user's device. Therefore, we have
    introduced a dampening factor, `scrollingCount`, as a countdown variable, which
    prevents the animation being hyper triggered. The `epsilon` variable also controls
    the sensitivity of the animation when it is activated. We can use set minimum
    and maximum opacity values to bound the animation activations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕这个JavaScript函数的长度，因为现在所有内容都将揭晓。结果是，将回调附加为滚动监听器意味着网络浏览器可能会根据用户的设备每秒调用回调10次或更多次。因此，我们引入了一个阻尼因子，`scrollingCount`，作为一个倒计时变量，以防止动画被过度触发。`epsilon`变量还控制动画激活时的灵敏度。我们可以使用设置的最小和最大不透明度值来限制动画激活。
- en: As the jQuery selector API, `$('#scrollBackTopArrow')`, may retrieve zero or
    more DOM elements, we will invoke the `each()` method to effectively iterate through
    the elements. We do so with the anonymous function, which takes a single argument
    of the element. In this case, we know the selector will only ever return one DOM
    element, if it exists at all.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为jQuery选择器API，`$('#scrollBackTopArrow')`可能会检索零个或多个DOM元素，我们将调用`each()`方法来有效地遍历这些元素。我们使用匿名函数这样做，该函数接受一个元素作为单个参数。在这种情况下，我们知道选择器将只返回一个DOM元素，如果它确实存在的话。
- en: 'We will capture the current window height, `$(window).height()`, in a variable
    in the function. Using the `windowHeight` variable, we will derive some vertical
    limits where the arrow should fade in and out: lower and upper. The origin coordinate
    `(0,0)` sits on the top left-hand corner of the device window. The function call
    `${window).scrollTop()` retrieves an integer position that represents the current
    scroll position of the page.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在函数中捕获当前窗口高度，`$(window).height()`，并将其存储在一个变量中。使用`windowHeight`变量，我们将推导出一些垂直限制，其中箭头应该淡入和淡出：下限和上限。原点坐标`(0,0)`位于设备窗口的左上角。函数调用`${window).scrollTop()`检索一个整数位置，表示页面当前的滚动位置。
- en: Now we will explain the tricky parts. The two conditional statements check if
    the page view scroll position is above the lowest or highest bounds. If the scroll
    position exceeds the upper bound, then we will fade in the arrow from view. If
    the scroll position is less than the lower bound, then we will fade out the arrow
    from view. We will set up a countdown timer in order to prevent the retriggering
    of the animation. Note that JavaScript supports access to a lexical scope for
    the variables that are declared outside the function definition, also known as
    closures. The `minOpacity`, `maxOpacity`, `epsilon`, and `scrollingCount` variables
    are the closure variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将解释一些棘手的部分。两个条件语句检查页面视图滚动位置是否在最低或最高边界之上。如果滚动位置超过上限，我们将从视图中淡入箭头。如果滚动位置低于下限，我们将从视图中淡出箭头。我们将设置一个倒计时计时器以防止动画重新触发。请注意，JavaScript支持访问函数定义外部声明的变量，也称为闭包。`minOpacity`、`maxOpacity`、`epsilon`和`scrollingCount`变量是闭包变量。
- en: 'Here is another example of jQuery that uses the CSS3 three-dimensional transformations
    to achieve the expanding buttons or icons. This effect is borrowed from the older
    Mac OS X style user interface where the application icons expand and contract
    in the dock application bar, as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个使用CSS3三维变换来实现扩展按钮或图标的jQuery示例。这个效果借鉴了较老的Mac OS X风格用户界面，其中应用程序图标在应用栏中扩展和收缩，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will use the `mouseenter()` and `mouseexit()` methods in order to build the
    effect. These methods respectively capture the desktop mouse entering and leaving
    the button, if it is displayed and can be seen. The anonymous functions set up
    the CSS in motion. CSS 3 already has the animation class styles. The transition
    class declares the length of the total animation, which is 0.5 milliseconds, and
    we also declare a 2D transform that scales the element up or down. To expand the
    button element, we will set the scale-factor to `1.667` of the default button
    size. To contract the button element, we will reset the scale-factor to the default
    rendering size of `1.0`. Note that we still have to declare the proprietary browser
    classes such as—webkit-transform for the WebKit browsers such as Apple's Safari
    and the previous editions of Google Chrome. Ultimately, this example is unhelpful
    for the touch screen devices because there are no devices available (yet) that
    can detect fingers hovering very close over a screen! (See the exercise at the
    end of this chapter.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`mouseenter()`和`mouseexit()`方法来构建效果。这些方法分别捕获鼠标进入和离开按钮的情况，如果按钮显示且可见。匿名函数设置CSS动画。CSS
    3已经具有动画类样式。过渡类声明了动画的总长度，为0.5毫秒，我们还声明了一个2D变换，该变换可以放大或缩小元素。为了扩展按钮元素，我们将比例因子设置为默认按钮大小的`1.667`。为了收缩按钮元素，我们将比例因子重置为默认渲染大小`1.0`。请注意，我们仍然需要声明专有浏览器类，例如WebKit浏览器（如苹果的Safari和之前的Google
    Chrome版本）的`-webkit-transform`。最终，这个例子对于触摸屏设备来说并不实用，因为没有设备（目前）能够检测手指在屏幕上非常接近的悬停！（参见本章末尾的练习。）
- en: Working with HTML, JavaScript, and CSS can be quite involved, and it is a job
    of an interface developer to figure out the requirements and build frontends.
    However, a Java developer should also appreciate the work. I hope you see some
    results.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML、JavaScript和CSS可能相当复杂，这是界面开发者的工作，了解需求并构建前端。然而，Java开发者也应该欣赏这项工作。我希望你能看到一些结果。
- en: The RequireJS framework
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RequireJS框架
- en: If you are serious about the organization of lots of JavaScript files and components,
    then you will be happy that ideas from dependency injection frameworks such as
    CDI and Spring have also made it in the world. Some professional organizations
    already rely on a small framework called RequireJS ([http://requirejs.org/](http://requirejs.org/)).
    The RequireJS framework is a JavaScript file and module loader. The framework
    has a built-in module script loader, which will improve the speed and quality
    of your code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认真对待大量JavaScript文件和组件的组织，那么你会很高兴地发现依赖注入框架（如CDI和Spring）的想法也已经进入世界。一些专业组织已经依赖于一个小型框架，称为RequireJS([http://requirejs.org/](http://requirejs.org/))。RequireJS框架是一个JavaScript文件和模块加载器。该框架具有内置的模块脚本加载器，这将提高你代码的速度和质量。
- en: RequireJS implements the **Asychronous Module Definition** (**AMD**) specification
    for JavaScript ([https://github.com/amdjs/amdjs-api/wiki/AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)).
    This specification defines a mechanism that in turn defines the modules and dependencies
    between modules and how they can be asynchronously loaded.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS实现了JavaScript的**异步模块定义**（**AMD**）规范([https://github.com/amdjs/amdjs-api/wiki/AMD](https://github.com/amdjs/amdjs-api/wiki/AMD))。这个规范定义了一种机制，该机制反过来定义了模块以及模块之间的依赖关系，以及它们如何异步加载。
- en: The AMD specification solves the critical issues where you have many JavaScript
    modules and define the multiple HTML script elements so as to load them, but then
    you find that each module had a dependency order.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: AMD规范解决了当你有许多JavaScript模块并定义多个HTML脚本元素以加载它们时出现的关键问题，但你发现每个模块都有一个依赖顺序。
- en: 'Let''s suppose that we have a JavaScript module A that has a dependency on
    a module B, then module B has a dependency on modules C and D. You might forget
    to include the dependency for the module D. Worse, you might get the order of
    the dependencies wrong:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为A的JavaScript模块，它依赖于模块B，然后模块B又依赖于模块C和D。你可能会忘记包含模块D的依赖项。更糟糕的是，你可能会弄错依赖项的顺序：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: RequireJS helps with these transient dependencies. First, we must understand
    how RequireJS loads the JavaScript files. The framework has a best practice folder
    layout.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS帮助处理这些临时依赖。首先，我们必须了解RequireJS如何加载JavaScript文件。该框架有一个最佳实践文件夹布局。
- en: 'In terms of a Java web application, let''s define some files in a project,
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Web应用程序方面，让我们在一个项目中定义一些文件，如下所示：
- en: '`src/main/webapp/`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/`'
- en: '`src/main/webapp/index.xhtml`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/index.xhtml`'
- en: '`src/main/webapp/resources/js/`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/`'
- en: '`src/main/webapp/resources/js/app.js`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/app.js`'
- en: '`src/main/webapp/resources/js/app/`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/app/`'
- en: '`src/main/webapp/resources/js/app/easel.js`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/app/easel.js`'
- en: '`src/main/webapp/resources/js/app/nested/sub.js`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/app/nested/sub.js`'
- en: '`src/main/webapp/resources/js/lib/`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/lib/`'
- en: '`src/main/webapp/resources/js/lib/jquery-2.1.1.js`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/lib/jquery-2.1.1.js`'
- en: '`src/main/webapp/resources/js/lib/bootstrap-3.2.0.js`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/lib/bootstrap-3.2.0.js`'
- en: '`src/main/webapp/resources/js/require.js`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/require.js`'
- en: '`src/main/webapp/resources/js/require-setup.js`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/resources/js/require-setup.js`'
- en: In a JSF application, we will place the JavaScript modules in the `resources`
    folder. This reads differently to the standard JavaScript descriptions because
    of the indirection required for JSF. The application files are usually saved in
    the `/js/app` folder. The JavaScript libraries are stored in the `/js/lib` folder.
    The `/js/require.js` file is the JavaScript file for a RequireJS framework module.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个JSF应用中，我们将JavaScript模块放在`resources`文件夹中。由于JSF需要间接引用，所以这与标准的JavaScript描述不同。应用文件通常保存在`/js/app`文件夹中。JavaScript库存储在`/js/lib`文件夹中。`/js/require.js`文件是RequireJS框架模块的JavaScript文件。
- en: 'With an HTML5 application, you will first include a reference to the RequireJS
    file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个HTML5应用中，您首先需要包含对RequireJS文件的引用：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code is a practical use of RequireJS because we are using Bootstrap
    and jQuery in an application. The most important HTML script element is the second
    one because it loads RequireJS (require.js). The first script tag is important
    as it configures the RequireJS framework. We will see this in a moment. The third
    script tag loads an application JavaScript module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是RequireJS的实际应用，因为我们在一个应用中使用了Bootstrap和jQuery。最重要的HTML脚本元素是第二个，因为它加载了RequireJS（require.js）。第一个脚本标签很重要，因为它配置了RequireJS框架。我们稍后会看到这一点。第三个脚本标签加载了一个应用JavaScript模块。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many commercial websites place tags at the bottom of the page content for a
    best practice convention use and to ease the performance. However, because RequireJS
    is designed for AMD, then this practice may defeat the purpose to load and execute
    the scripts asynchronously while the page continues to load. In other words, your
    mileage may vary and you need to test this out in development work.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业网站在页面内容底部放置标签，以遵循最佳实践惯例并提高性能。然而，由于RequireJS是为AMD设计的，因此这种做法可能会违背在页面继续加载的同时异步加载和执行脚本的目的。换句话说，效果可能因应用而异，您需要在开发工作中进行测试。
- en: A RequireJS configuration
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RequireJS配置
- en: 'Let''s look in reverse order at the loaded JavaScript files, so this is `/js/app/app.js`.
    This is the target of the reference data-main attribute in the `<script>` tag
    element that includes the RequireJS library:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逆序查看已加载的JavaScript文件，因此这是 `/js/app/app.js`。这是包含RequireJS库的`<script>`标签元素中引用数据-main属性的的目标：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This file configures how RequireJS searches and loads the JavaScript files as
    modules. The `requirejs` is JavaScript Object type variable that the library defines
    in a global head scope. The reference object has a method called `config()` that
    accepts a JavaScript property object. The `baseUrl` property defines the default
    location to load the files. The paths property is a nested property, which lists
    a collection of the paths that are exceptions to the default loading rule.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件配置了RequireJS如何搜索和加载JavaScript文件作为模块。`requirejs`是库在全局头作用域中定义的JavaScript对象类型变量。引用对象有一个名为`config()`的方法，它接受一个JavaScript属性对象。`baseUrl`属性定义了加载文件的默认位置。`paths`属性是一个嵌套属性，它列出了一个路径集合，这些路径是默认加载规则的例外。
- en: By default the previous RequireJS configuration loads any module by ID from
    the folder `js/lib`. However if the module ID start with the prefix `app`, then
    it is loaded from the `js/app` directory as specified by the path key.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，之前的RequireJS配置从`js/lib`文件夹加载任何模块的ID。但是，如果模块ID以前缀`app`开头，则它将从`js/app`目录加载，如路径键指定的那样。
- en: The paths property configuration is relative to `baseUrl` and never includes
    a `.js` suffix extension as the paths property could stand for a directory folder.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`paths`属性配置相对于`baseUrl`，并且从不包含`.js`后缀扩展名，因为`paths`属性可以代表目录文件夹。'
- en: As we will load jQuery and Bootstrap for this example, we will need to shove
    a square peg in a round hole. In the JavaScript programming world, in order to
    avoid conflicts with many popular libraries, the authors have adopted the idea
    of shims.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将为这个示例加载 jQuery 和 Bootstrap，我们需要将一个方形的木塞塞入一个圆形的洞中。在 JavaScript 编程世界中，为了避免与许多流行的库冲突，作者采用了
    shims 的想法。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What is a shim?**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是 Shim？**'
- en: A shim is the idea of a colloquial expression in the JavaScript parlance to
    force the different frameworks to work together. It is also a term for monkey-patching
    a JavaScript context to contain all of the EmcaScript 5 methods.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Shim 是 JavaScript 术语中的一个俚语表达，用于强制不同的框架协同工作。它也是一个用于在 JavaScript 上下文中 monkey-patching
    以包含所有 ECMAScript 5 方法的术语。
- en: 'In RequireJS, we must set this up in the first loaded file (`require-setup.js`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RequireJS 中，我们必须在第一个加载的文件（`require-setup.js`）中设置此配置：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is helpful to re-examine the folder layout for our JavaScript files. The
    require-setup file simply sets up a special named variable called `require` in
    the global head scope with an object definition. The nest object referenced by
    the property name shim defines two changes. First, that a module called `bootstrap`
    has a dependency on a module called `jquery`. Second, the `jquery` module exports
    the symbol (`$`).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视我们的 JavaScript 文件夹布局是有帮助的。require-setup 文件简单地设置了一个名为 `require` 的特殊变量，在全局
    head 范围内使用对象定义。通过属性名 shim 引用的嵌套对象定义了两个更改。首先，一个名为 `bootstrap` 的模块依赖于一个名为 `jquery`
    的模块。其次，`jquery` 模块导出符号（`$`）。
- en: The second property key called paths in the configuration defines an association
    object for the module names. Each module name is mapped to its true name. So,
    the `jquery` module is actually associated with a file called `jquery-2.1.3`.
    There is a bonus feature with the indirection because now we have an easy way
    of upgrading the library versions. It's a one line change!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中的第二个属性键 paths 定义了一个模块名称的关联对象。每个模块名称都映射到其真实名称。因此，`jquery` 模块实际上与一个名为 `jquery-2.1.3`
    的文件相关联。由于现在我们可以轻松地升级库版本，这有一个额外的好处。这是一个单行更改！
- en: An application module
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用模块
- en: 'With the configuration of RequireJS completed, we can now write the default
    application module for our application, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完成RequireJS的配置后，我们现在可以编写我们应用程序的默认应用模块，如下所示：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding `/js/app/main.js` script is the common file for our simple client-side
    application. The global `requirejs()` function is the pathway to the library''s
    feature of a dependency injection. The following is the format of this function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `/js/app/main.js` 脚本是我们的简单客户端应用程序的通用文件。全局 `requirejs()` 函数是库依赖注入功能的路径。以下是这个函数的格式：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, `< MODULE-ARRAY-LIST>` is the list collection of the module name dependencies
    and `<CALLBACK>` is the single function argument.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<MODULE-ARRAY-LIST>` 是模块名称依赖项的列表集合，而 `<CALLBACK>` 是单个函数参数。
- en: 'Therefore, the code example asks RequireJS to initialize the modules: `jquery`,
    `bootstrap`, `easel`, and `nested/sub`. Pay particular attention to the last module
    because `sub.js` is in a subdirectory of the `app` folder; therefore, the name
    uses the path separator. Remember, with RequireJS, you do not need to add the
    suffix (`.js`).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码示例要求 RequireJS 初始化以下模块：`jquery`、`bootstrap`、`easel` 和 `nested/sub`。请特别注意最后一个模块，因为
    `sub.js` 位于 `app` 文件夹的子目录中；因此，名称使用了路径分隔符。记住，使用 RequireJS，你不需要添加后缀（`.js`）。
- en: By the time RequireJS invokes the callback function, the modules are loaded.
    Hence, we will write to the console log, and if we are using jQuery, we will make
    another anonymous function declaration in order to do some fancy selector manipulation
    on the toggle buttons. It should start to make sense as to why we will explicitly
    export the dollar symbol in the preceding shim configuration. Also note that we
    are able to access the reference dependencies through the function arguments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当 RequireJS 调用回调函数时，模块已经加载。因此，我们将写入控制台日志，如果我们使用 jQuery，我们将在另一个匿名函数声明中做一些关于切换按钮的复杂选择器操作。这应该开始让人明白为什么我们会在先前的
    shim 配置中明确导出美元符号。还请注意，我们能够通过函数参数访问引用依赖项。
- en: So, how will we define the module patterns with RequireJS? Read the next section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们将如何使用 RequireJS 定义模块模式？请阅读下一节。
- en: Defining modules
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模块
- en: 'In order to define our own custom modules with RequireJS, we will make use
    of another global scope method from the framework. Following the AMD specification,
    the framework provides a method called `define()`. The format for this method
    is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用RequireJS定义我们自己的自定义模块，我们将利用框架中的另一个全局作用域方法。遵循AMD规范，框架提供了一个名为`define()`的方法。此方法的格式如下：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is almost the same as the `requirejs()` call. The `define()` method accepts
    a list of the module names as a dependency. The `<FUNCTION-OBJECT>` second argument
    means that the function must explicitly return a JavaScript object. In other words,
    it can't return a void or nothing result.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与`requirejs()`调用相同。`define()`方法接受一个模块名称列表作为依赖项。`<FUNCTION-OBJECT>`第二个参数意味着该函数必须显式返回一个JavaScript对象。换句话说，它不能返回空或无结果。
- en: 'Let''s look at the definition for the canvas module:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看canvas模块的定义：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The module list can be an empty array, which means that the module has no required
    dependencies. The file path is `/js/app/easel.js`. In the anonymous function,
    we will instantiate our JavaScript constructor object with methods and properties
    and then return it to RequireJS. The module just defines a method called `getName()`,
    which returns the value of a private accessible variable. Following the module
    pattern in JavaScript, it is possible to declare the private scope variables and
    functions such as `_name` in the example, which are not accessible outside of
    the function definition.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模块列表可以是一个空数组，这意味着该模块没有所需的依赖项。文件路径是`/js/app/easel.js`。在匿名函数中，我们将使用方法和属性实例化我们的JavaScript构造函数对象，并将其返回给RequireJS。该模块仅定义了一个名为`getName()`的方法，它返回一个私有可访问变量的值。遵循JavaScript的模块模式，可以在示例中声明私有作用域变量和函数，如`_name`，这些变量和函数在函数定义之外不可访问。
- en: 'Here is the listing of the other module with a file path of `/js/app/nested/sub.js`,
    which has a dependency on the easel module:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个模块的列表，其文件路径为`/js/app/nested/sub.js`，它依赖于easel模块：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `nested/sub module` defines a function object that contains two methods:
    `getName()` and `getCanvasName()`. We will create an object variable called `easel`.
    RequireJS supplies the module reference as an argument during the invocation of
    the function. The `getCanvasName()` method uses this private reference to invoke
    the `getName()` method on the dependent module, `easel`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`nested/sub模块`定义了一个包含两个方法的对象：`getName()`和`getCanvasName()`。我们将创建一个名为`easel`的对象变量。在函数调用期间，RequireJS将模块引用作为参数提供。`getCanvasName()`方法使用这个私有引用在依赖模块`easel`上调用`getName()`方法。'
- en: 'Here is a screenshot of RequireJS in action, loading the modules. The Chrome
    Developer Tools has a network view that allows us to inspect the JavaScript files
    being loaded over the wire:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是RequireJS在加载模块时的截图：
- en: '![Defining modules](img/image00417.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![定义模块](img/image00417.jpeg)'
- en: A screenshot of the RequireJS example application
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS示例应用的截图
- en: If you find this terse at first, please bear in mind that it takes a little
    while to get your head around the functions and object scopes. The advantages
    are clear to the professional interface developers to get around the severe drawbacks
    of JavaScript's original design. We covered enough of RequireJS for the digital
    development to continue far and wide. We will move on to another framework.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一开始觉得这很简略，请记住，要完全理解函数和对象作用域需要一点时间。对于专业的界面开发者来说，其优势很明显，可以克服JavaScript原始设计中的严重缺点。我们已经涵盖了足够多的RequireJS，以便数字开发可以继续广泛进行。我们将继续介绍另一个框架。
- en: UnderscoreJS
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UnderscoreJS
- en: I will introduce you to one more JavaScript framework that can be helpful in
    development. UnderscoreJS ([http://underscorejs.org/](http://underscorejs.org/))
    is a framework that brings functional programming constructs and techniques to
    the language. The library contains over 100 methods that add functional support
    to JavaScript.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您介绍另一个在开发中可能很有用的JavaScript框架。UnderscoreJS（[http://underscorejs.org/](http://underscorejs.org/））是一个将函数式编程构造和技巧引入语言的框架。该库包含超过100个方法，为JavaScript添加了函数式支持。
- en: 'UnderscoreJS is a single JavaScript file downloaded just like jQuery and RequireJS.
    If you add the requisite versioned `underscore.js` file to the `/js/lib` folder,
    then you already have the means to inject it into your application. Here is the
    additional configuration in the file, `require-setup.js`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: UnderscoreJS 是一个像 jQuery 和 RequireJS 一样下载的单个 JavaScript 文件。如果你将必需的版本化的 `underscore.js`
    文件添加到 `/js/lib` 文件夹，那么你已经有方法将其注入到你的应用程序中。以下是文件 `require-setup.js` 中的附加配置：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: UnderscoreJS exports the symbol underscore (`_`) for its library to a developer
    and its function methods are accessible through the symbol. We will review a small
    subset of these methods.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: UnderscoreJS 将符号下划线（`_`）导出为其库给开发者，并且其函数方法可以通过该符号访问。我们将回顾这些方法的小子集。
- en: 'Functional programmers tend to be interested in the following five primary
    concerns:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序员通常对以下五个主要关注点感兴趣：
- en: How to internally iterate through a collection of elements?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在内部遍历元素集合？
- en: How to filter the elements in a collection?
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何过滤集合中的元素？
- en: How to map the elements in a collection from one type to another?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将集合中的元素从一种类型映射到另一种类型？
- en: How to flatten a collection of elements into just a collection?
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将元素集合扁平化成一个集合？
- en: Finally, how to collect or reduce the elements in a collection to a single element
    or value?
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如何将集合中的元素收集或归约成一个单一元素或值？
- en: You may recognize these concerns as standard ideas in the alternative programming
    languages in JVM such as Scala, Clojure, or even Java 8 with Lambdas.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会将这些关注点识别为 JVM 中替代编程语言的标准化思想，例如 Scala、Clojure，甚至是带有 Lambda 的 Java 8。
- en: The for-each operations
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历操作
- en: In UnderscoreJS, we can take an array object and simply iterate over it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UnderscoreJS 中，我们可以取一个数组对象并简单地遍历它。
- en: 'The `each()` function allows you to iterate over the list collections, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`each()` 函数允许你遍历列表集合，如下所示：'
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we used RequireJS as an AMD loader in a module called `underscore-demo.js`.
    The `each()` function iterates over the elements of the array object and invokes
    the supplied function, which is called the **iteratee** with the element as a
    single argument. The `each()` function replaces the typically `foreach` or `for-do`
    compound statements in imperative programming languages.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了在 `underscore-demo.js` 模块中作为 AMD 加载器的 RequireJS。`each()` 函数遍历数组对象中的元素，并调用提供的函数，该函数被称为**迭代器**，以元素作为单个参数。`each()`
    函数替换了命令式编程语言中的典型 `foreach` 或 `for-do` 复合语句。
- en: The filter operations
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤操作
- en: 'Filtering can be achieved in several ways. Let''s take a basic example of filtering
    a list:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤可以通过多种方式实现。让我们以过滤列表的基本示例为例：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code searches through each value in the list, returning an array of all
    the values that pass a truth test (predicate). The second argument to `filter()`
    is known as the predicate, which is a function callback that returns a Boolean
    value if the element that is supplied meets the condition test or not. Here, we
    are filtering the names in the list if they begin with the letter `P`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遍历列表中的每个值，返回一个通过真值测试（谓词）的所有值的数组。`filter()` 的第二个参数被称为谓词，它是一个回调函数，如果提供的元素满足条件测试，则返回一个布尔值。在这里，我们正在过滤以字母
    `P` 开头的列表中的名称。
- en: 'UnderscoreJS also provides a more sophisticated filtering method. The `where()`
    method searches a list and returns an array of all the values that contain all
    of the key-value pairs listed in the properties:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: UnderscoreJS 还提供了一种更复杂的过滤方法。`where()` 方法搜索列表并返回一个包含所有具有列出的键值对属性的值的数组：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code uses the `ContactDetail` JavaScript object that we defined
    earlier in this chapter. We will invoke the `where()` method with the list of
    contacts and supplied key-value objects with the properties that we want to filter.
    The result is `ContactDetail` that matches Anne Jackson because she has a matching
    occupation (software developer) and age (28).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用了我们在本章前面定义的 `ContactDetail` JavaScript 对象。我们将使用联系人列表和提供的键值对象（包含我们想要过滤的属性）调用
    `where()` 方法。结果是匹配安妮·杰克逊的 `ContactDetail`，因为她有匹配的职业（软件开发者）和年龄（28）。
- en: The map operations
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射操作
- en: 'The `map()` function produces a new array object by mapping each element in
    the list, with the user supplied function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数通过映射列表中的每个元素，并使用用户提供的函数，生成一个新的数组对象：'
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The user-supplied function accepts the current element parameter and is responsible
    for returning the new element type. In these examples, we will create a new array
    list of triples of the number element, and next, we will create a new array list
    of the squares of the number element. Finally, we will create an array list of
    the string elements.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供的函数接受当前元素参数，并负责返回新的元素类型。在这些例子中，我们将创建一个新的包含数字元素的三个元素的数组列表，然后我们将创建一个新的包含数字元素平方的数组列表。最后，我们将创建一个包含字符串元素的数组列表。
- en: The flatten operations
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展平操作
- en: Now that we know how to iterate, filter, and map a collection with UnderscoreJS,
    we should also learn how to flatten the collections of elements. There is a method
    called `flatten()` that accepts a collection of elements and flattens it if one
    or more of these elements is itself a collection.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 UnderscoreJS 迭代、过滤和映射集合，我们也应该学习如何展平元素集合。有一个名为 `flatten()` 的方法，它接受一个元素集合，并在这些元素中有一个或多个本身是集合的情况下将其展平。
- en: 'Let''s examine the following two examples:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下两个例子：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we defined an object called `Sector` that represents, say, the sales and
    marketing data. We created a nested collection, `salesSectorData`, which is actually
    an array of two elements but each element is a further collection. In short, `salesSectorData`
    is a level two ordered data structure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `Sector` 的对象，它代表，比如说，销售和营销数据。我们创建了一个嵌套集合 `salesSectorData`，实际上它是一个包含两个元素的数组，但每个元素都是一个更进一步的集合。简而言之，`salesSectorData`
    是一个二级有序数据结构。
- en: The first `flatten()` call completely flattens the data structure in an array
    list. So we will end up with an array of five items. We will pass a second argument
    to the second `flatten()` call, which is a boolean argument that specifies whether
    the flatten operation should operate also on the elements of the collection or
    not. The result of `f4` is an array of four items. The first element is an array
    list of two items, the second element is an array list of one item, and then the
    remaining elements will follow.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次 `flatten()` 调用将数组列表中的数据结构完全展平。因此，我们将得到一个包含五个元素的数组。我们将向第二个 `flatten()` 调用传递第二个参数，这是一个布尔参数，用于指定是否应该对集合的元素也执行展平操作。`f4`
    的结果是包含四个元素的数组。第一个元素是一个包含两个元素的数组列表，第二个元素是一个包含一个元素的数组列表，然后剩余的元素将依次排列。
- en: It should be clear why a JavaScript interface developer raves about UnderscoreJS.
    We will move on to the final operation in this firebrand review.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，为什么一个 JavaScript 接口开发者会对 UnderscoreJS 赞不绝口。我们将继续进行这次火热的审查中的最后一个操作。
- en: The reduction operations
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少操作
- en: What good are all of these functional operations if we cannot reduce them to
    a single scalar value or object? Thankfully, RequireJS provides us with several
    varieties of methods such as `reduce()`, `reduceRight()`, `min()`, and `max()`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能将这些功能操作缩减为单一的标量值或对象，它们有什么好处呢？幸运的是，RequireJS 为我们提供了几种方法，如 `reduce()`、`reduceRight()`、`min()`
    和 `max()`。
- en: 'We will just look at the `reduce()` operation for now. If we wanted to discover
    the total sale value for all of the previous sector objects, how will we do it?
    Here is the answer:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只看看 `reduce()` 操作。如果我们想发现所有之前部门对象的销售额总和，我们该如何做呢？下面是答案：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `reduce()` operation accepts three arguments: the collection, an iteratee
    function, and initial value. In order to reduce the collection to a single scalar
    value, the `reduce()` operation calls the iteratee on each element. The iteratee
    function accepts the scalar value argument and element. The anonymous function
    adds the sale sector value to the accumulator.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()` 操作接受三个参数：集合、迭代函数和初始值。为了将集合缩减为一个单一的标量值，`reduce()` 操作会在每个元素上调用迭代函数。迭代函数接受标量值参数和元素。匿名函数将销售部门值添加到累加器中。'
- en: The `reduce()` operator is left-associative in respect to the collection, whereas
    `reduceRight()` is right-associative. This completes our journey in UnderscoreJS.
    A more interested reader can delve further into this framework online and through
    other resources of information.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()` 操作符在集合方面是左结合的，而 `reduceRight()` 是右结合的。这完成了我们在 UnderscoreJS 中的旅程。一个更有兴趣的读者可以进一步在线和通过其他信息资源深入了解这个框架。'
- en: GruntJS
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GruntJS
- en: Before we conclude this chapter on progressive JavaScript programming, we will
    quickly take a look at a tool to launch actions. This tool is GruntJS ([http://gruntjs.com/](http://gruntjs.com/)),
    and the people behind it describe it as the JavaScript task runner. GruntJS is
    a Node.js tool and works in this ecosystem. Therefore, developers must install
    Node.js before they can work with GruntJS.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束关于渐进式JavaScript编程的这一章之前，我们将快速了解一下一个用于启动动作的工具。这个工具是GruntJS ([http://gruntjs.com/](http://gruntjs.com/))，其背后的团队将其描述为JavaScript任务运行器。GruntJS是一个Node.js工具，在这个生态系统中工作。因此，开发者在使用GruntJS之前必须安装Node.js。
- en: 'The tool is currently a favorite with many in the digital community. The following
    are some of the reasons why GruntJS is seen as a bonus:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具目前在数字社区中很受欢迎。以下是GruntJS被视为加分项的一些原因：
- en: The configuration is in one place and can be shared among other developers,
    testers, and operators across your digital team.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置在一个地方，并且可以在你的数字团队中的其他开发人员、测试人员和操作人员之间共享。
- en: GruntJS is built with a plugin system.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GruntJS采用插件系统构建。
- en: The tool compresses your CSS and minimizes your JavaScript files for performance
    and delivery to the product site.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具压缩你的CSS并最小化你的JavaScript文件，以提高性能并将它们交付到产品网站。
- en: GruntJS allows teams of dedicated interface developers to work separately or
    together on the client-side bits of a website. The tools then concatenate their
    JavaScript and CSS components together for a production delivery.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GruntJS允许专门的界面开发团队在网站的客户端部分分别或共同工作。然后，这些工具将他们的JavaScript和CSS组件合并在一起，以便进行生产交付。
- en: It can optimize your images to reduce the overall file size and yet still retain
    the quality, which is perfect to deliver the massive *hero* style retina display
    graphics and also create mobile-friendly images.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以优化你的图像以减少整体文件大小，同时仍然保持质量，这对于交付大规模的*英雄*风格视网膜显示屏图形以及创建移动友好型图像是完美的。
- en: Developers can take advantage of Sass and Less for CSS authoring.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以利用Sass和Less进行CSS编写。
- en: There are GruntJS plugins for Less, Sass, RequireJS, CoffeeScript, and others.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有GruntJS插件用于Less、Sass、RequireJS、CoffeeScript等。
- en: Node.js is a JavaScript runtime platform and therefore, it is absolutely different
    from the Java platform. If you happen to use Gradle, there are two open source
    plugins available that help to bridge the gap between them. They are called Gradle-GruntJS
    Plugin ([https://github.com/srs/gradle-grunt-plugin](https://github.com/srs/gradle-grunt-plugin))
    and Gradle-Node Plugin ([https://github.com/srs/gradle-node-plugin](https://github.com/srs/gradle-node-plugin)).
    Node.js also has its own package manager called npm, which handles the installation,
    updating, and removing of the libraries. Npm permits the Node.js and JavaScript
    open source libraries to be shared with the community.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个JavaScript运行平台，因此，它与Java平台绝对不同。如果你恰好使用Gradle，有两个开源插件可以帮助它们之间的桥梁。它们被称为Gradle-GruntJS插件
    ([https://github.com/srs/gradle-grunt-plugin](https://github.com/srs/gradle-grunt-plugin))
    和 Gradle-Node插件 ([https://github.com/srs/gradle-node-plugin](https://github.com/srs/gradle-node-plugin))。Node.js还有一个自己的包管理器，称为npm，它处理库的安装、更新和删除。Npm允许Node.js和JavaScript开源库与社区共享。
- en: 'Every GruntJS project requires the following two files in the root folder:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GruntJS项目都需要在根目录下放置以下两个文件：
- en: '`package.json`: This file specifies the metadata for an npm project and contains
    JavaScript tool and library dependencies that your project requires, including
    GruntJS.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`：此文件指定了npm项目的元数据，并包含了项目所需的JavaScript工具和库依赖项，包括GruntJS。'
- en: '`gruntfile.js`: This file configures and defines the build tasks for your project.
    It is the file where you can also add dependencies for the GruntJS plugins.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gruntfile.js`：此文件配置并定义了项目的构建任务。你还可以在此文件中添加GruntJS插件的依赖项。'
- en: 'For a JSF project, you will place `package.json` in the project root folder.
    Here is a code for the file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个JSF项目，你需要在项目根目录下放置`package.json`文件。以下是该文件的代码示例：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You will notice that the file looks almost like a JSON file. The critical `devDependencies`
    property declares a set of npm tools and frameworks. We want to definitely load
    GruntJS from version 0.4.5 or better.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现这个文件看起来几乎像是一个JSON文件。关键的`devDependencies`属性声明了一组npm工具和框架。我们肯定希望从版本0.4.5或更高版本加载GruntJS。
- en: Now, we will dive straight into a real-world case of GruntJS. In a digital project,
    we want to optimize the performance and ensure our SEO ranking with the search
    engines. We are required to merge together the third-party JavaScript libraries
    and minimize the JavaScript files. The interface developers prefer to keep using
    the Sass tool for the flexibility management of the CSS files. We have an agreement
    with our management to keep the developed JavaScript files untouched for now.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将直接深入一个实际的 GruntJS 应用案例。在一个数字项目中，我们希望优化性能并确保我们的搜索引擎优化排名。我们需要合并第三方 JavaScript
    库并最小化 JavaScript 文件。界面开发者更喜欢继续使用 Sass 工具来管理 CSS 文件的灵活性。我们已经与我们的管理层达成协议，目前保持开发的
    JavaScript 文件不变。
- en: 'Here is the `gruntfile.js` file that achieves this ambition:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现这一目标的 `gruntfile.js` 文件：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding `gruntfile.js` file defines a single module in the Node.js system.
    It sounds confusing to have a module system in another module; however, all we
    have to know is that modules are a form of encapsulation that permits sharing
    through reuse. The `module.exports` definition allows grunt to participate in
    the Node.js system. Therefore, it is possible to share this grunt module with
    the other node modules.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `gruntfile.js` 文件在 Node.js 系统中定义了一个模块。在另一个模块中有一个模块系统听起来可能有些令人困惑；然而，我们只需知道模块是一种封装形式，它允许通过重用进行共享。`module.exports`
    定义允许 Grunt 参与到 Node.js 系统中。因此，可以将这个 Grunt 模块与其他 Node.js 模块共享。
- en: 'The `grunt.initConfig()` stanza is required to initialize the GruntJS tool.
    The most important part specifies the name of the metadata file, `package.json`.
    Afterwards, we have an area reserved for the plugin configuration. Each GruntJS
    plugin has a separate configuration of properties. There are three plugins: `grunt-contrib-concat`,
    `grunt-contrib-uglify`, and `grunt-contrib-sass`. Each plugin declares a configuration
    property name: `concat`, `uglify`, and `sass`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`grunt.initConfig()` 段落是初始化 GruntJS 工具所必需的。其中最重要的部分指定了元数据文件的名称，`package.json`。之后，我们有一个预留的区域用于插件配置。每个
    GruntJS 插件都有独立的属性配置。有三个插件：`grunt-contrib-concat`、`grunt-contrib-uglify` 和 `grunt-contrib-sass`。每个插件声明了一个配置属性名称：`concat`、`uglify`
    和 `sass`。'
- en: 'To configure the concatenation plugin, we have the following stanza:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置连接插件，我们有以下段落：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `grunt-contrib-concat` plugin requires a source of files and a destination
    file. It takes whatever JavaScript library files that are there and then generates
    a single file called `thirdparty.js`. In our Gradle (or Maven project), let's
    assume that we have a WAR task that will eventually bundle the final destination
    file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`grunt-contrib-concat` 插件需要一个文件源和一个目标文件。它会将所有现有的 JavaScript 库文件整合在一起，然后生成一个名为
    `thirdparty.js` 的单个文件。在我们的 Gradle（或 Maven）项目中，假设我们有一个将最终打包目标文件的 WAR 任务。'
- en: We must be aware of the de facto Gradle and Maven directory layout configuration
    for the web projects. Therefore, we will add `src/main/webapp` to the file paths.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须了解事实上的 Gradle 和 Maven 目录布局配置，这对于 Web 项目来说。因此，我们将 `src/main/webapp` 添加到文件路径中。
- en: 'To configure the minimization plugin, we will execute the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置压缩插件，我们将执行以下代码：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This configuration is very easy to understand; we will just point the `grunt-uglify-contrib`
    plugin to a source and target the file path.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置非常容易理解；我们只需将 `grunt-uglify-contrib` 插件指向源并指定目标文件路径。
- en: 'Finally, we will configure the Sass CSS build plugin as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将按照以下方式配置 Sass CSS 构建插件：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will need slightly more instructions for the `grunt-contrib-sass` plugin.
    This plugin requires the key-value properties of files. The target file is the
    key property and the SASS source file is the value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `grunt-contrib-sass` 插件，我们需要稍微更多的指令。这个插件需要文件的键值属性。目标文件是键属性，SASS 源文件是值。
- en: Tip
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Installing SASS additionally requires the installation of a valid Ruby installation
    and the corresponding RubyGem.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 SASS 还需要安装有效的 Ruby 安装和相应的 RubyGem。
- en: GruntJS is an exciting and powerful tool for the client-side digital developers.
    There is no doubt about this. The plugin system is still quite immature and I
    recommend that you check the documentation for the configuration changes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: GruntJS 是客户端数字开发者的一款令人兴奋且强大的工具。这一点毫无疑问。插件系统仍然相当不成熟，我建议您检查文档以了解配置更改。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a whirlwind tour of the modern digital JavaScript programming.
    If you have not worked with the JavaScript language at all or left it far behind
    for several years, then I do hope that you have been invigorated to learn this
    essential skill. We looked at the programming of the JavaScript objects. We saw
    how to construct the objects. We learned about the property notations and dealt
    with the JavaScript truth.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对现代数字 JavaScript 编程的快速浏览。如果您从未使用过 JavaScript 语言，或者已经多年远离它，那么我真心希望您已经重新振作起来，学习这项基本技能。我们研究了
    JavaScript 对象的编程。我们看到了如何构建对象。我们了解了属性表示法，并处理了 JavaScript 的真值。
- en: We paid a particular respectable visit to jQuery—the grandmother or granddaddy
    of the JavaScript programming. If you learned nothing else, then you can now understand
    jQuery. We saw how the selectors can search HTML DOM for the elements, which can
    then be manipulated for effect. We made a brief foray into animation, which opened
    the door to the creation of more sophisticated experiences for the customers and
    business owners.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别拜访了 jQuery——JavaScript 编程的祖母或祖父。如果您没有学到其他东西，那么现在您应该能够理解 jQuery。我们看到了选择器如何搜索
    HTML DOM 中的元素，然后可以对这些元素进行操作以产生效果。我们简要地涉猎了动画，这为为顾客和商业主创造更复杂体验打开了大门。
- en: We ventured into dependency management of the modules with RequireJS. We learned
    how this framework can help a digital developer to organize the modules and leave
    the order of retrieving them to the framework.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了 RequireJS 的模块依赖管理。我们学习了这个框架如何帮助数字开发者组织模块，并将检索它们的顺序留给框架。
- en: At the end of the chapter, we crossed the bridge to a non-Java platform called
    Node.js and, in particular, learned the basic details about GruntJS. We studied
    an example of a GruntJS definition that bundled the JavaScript library files together,
    generated CSS from Sass, and optimized the size of the JavaScript files.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们跨越了非 Java 平台 Node.js 的桥梁，特别是学习了 GruntJS 的基本细节。我们研究了 GruntJS 定义的一个示例，该定义将
    JavaScript 库文件捆绑在一起，从 Sass 生成 CSS，并优化了 JavaScript 文件的大小。
- en: In the next chapters, we will look at AngularJS and the up-and-coming Java EE
    MVC framework.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨 AngularJS 以及新兴的 Java EE MVC 框架。
- en: Exercises
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following are the exercises and questions for this chapter:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为本章的练习和问题：
- en: What does the following JavaScript code define? What else is similar to it?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 JavaScript 代码定义了什么？还有哪些与之类似？
- en: '[PRE50]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: From the preceding code, explain what is the main difference between the `hospital.patients`
    and `hospital['patients']` property accessors?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的代码中，解释 `hospital.patients` 和 `hospital['patients']` 属性访问器之间的主要区别是什么？
- en: Write a JavaScript object that constructs a participant to a Java User Group
    member. Let's say you call your object `JUGParticipant`. You will need to capture
    their first and last names, their telephone contact numbers, their e-mail addresses
    (optional), and also their specific interests (optional).
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 JavaScript 对象，构建一个 Java 用户组成员的参与者。假设您将您的对象命名为 `JUGParticipant`。您需要捕捉他们的名字、电话联系方式、电子邮件地址（可选），以及他们的特定兴趣（可选）。
- en: Modify `JUGParticipant` to accept the interests as another object. Write a JavaScript
    Tag object so that you build an array of skills such as Java EE, Android, or HTML.
    Demonstrate that you can build this object graph of the `JUGParticipants` and
    Tag objects.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `JUGParticipant` 修改为接受兴趣作为另一个对象。编写一个 JavaScript 标签对象，以便构建包含 Java EE、Android
    或 HTML 等技能的数组。演示您能够构建 `JUGParticipants` 和标签对象的这种对象图。
- en: Adapt your JavaScript object graph by creating a `JUGEvent` meeting object.
    Your object will need to hold properties such as the event title, its description,
    location, presentation speaker (optional), and willing `JUGParticipants`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个 `JUGEvent` 会议对象来调整您的 JavaScript 对象图。您的对象需要包含诸如事件标题、描述、地点、演讲者（可选）以及愿意的
    `JUGParticipants` 等属性。
- en: 'Find out the nine native object constructors in JavaScript 1.5 (or ECMAScript
    edition 3). To start you off, here are four: `Number()`, `String()`, `Boolean()`,
    and `Object()`.'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解 JavaScript 1.5（或 ECMAScript 版本 3）中的九个原生对象构造函数。为了开始，这里有四个：`Number()`、`String()`、`Boolean()`
    和 `Object()`。
- en: With the following HTML, use jQuery to change the background color of the `div`
    element, `messageArea`. There are three buttons in the code to denote the convention
    of a traffic light. (You are allowed to make the content pretty!)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 HTML，使用 jQuery 改变 `div` 元素 `messageArea` 的背景颜色。代码中有三个按钮，表示交通灯的规则。（您允许使内容更美观！）
- en: '[PRE51]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Explain the difference between the following two jQuery statements:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释以下两个 jQuery 语句之间的区别：
- en: '[PRE52]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With the following HTML5 code, which displays a Bootstrap alert box, we want
    the user to make the warning disappear when they click on the close icon. Write
    JavaScript and jQuery to animate the critical notice, fade it out, and then remove
    the content from HTML.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 HTML5 代码，该代码显示一个 Bootstrap 警告框，我们希望用户在点击关闭图标时使警告消失。编写 JavaScript 和 jQuery
    来动画化关键通知，使其淡出，然后从 HTML 中移除内容。
- en: '[PRE53]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Look at the book's source code and get started with RequireJS. Study the code.
    Your task is to modify the code and add your module, which you may call `/js/app/oxygen.js`.
    You will need to use the AMD specification `define()` method call.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看书籍的源代码，并开始使用 RequireJS。研究代码。你的任务是修改代码并添加你的模块，你可以将其命名为 `/js/app/oxygen.js`。你需要使用
    AMD 规范的 `define()` 方法调用。
- en: Now that you have written the new RequireJS module, `oxygen.js`, how do you
    know that it works as expected? Did you write a test web page? You will probably
    need to write a `/js/app/oxygendemo.js` JavaScript file.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经编写了新的 RequireJS 模块 `oxygen.js`，你怎么知道它按预期工作？你是否编写了一个测试网页？你可能需要编写一个 `/js/app/oxygendemo.js`
    JavaScript 文件。
- en: 'Define two modules called `/js/app/hydrogen.js` and `/js/app/water.js`. Set
    up the water module such that it depends on the other two modules: hydrogen and
    oxygen.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个模块，分别命名为 `/js/app/hydrogen.js` 和 `/js/app/water.js`。设置水模块，使其依赖于其他两个模块：氢和氧。
- en: 'Working with UnderscoreJS and assuming that you have set up the dependencies,
    exercise the following JavaScript example:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 UnderscoreJS 并假设你已经设置了依赖项，练习以下 JavaScript 示例：
- en: '[PRE54]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Look at the following JavaScript code, which defines a percentage and an array
    of product prices. Using UnderscoreJS, calculate the grand total price and also
    the grand total price when each price is increased by the percentage:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下 JavaScript 代码，该代码定义了一个百分比和一个产品价格数组。使用 UnderscoreJS 计算总价格，以及当每个价格增加百分比时的总价格：
- en: '[PRE55]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that we have different types of products. Using UnderscoreJS, work out
    the grand total of the original prices and then work out the grand total with
    an increase of 5.35 percent.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们有不同类型的产品。使用 UnderscoreJS，计算原始价格的总金额，然后计算增加 5.35% 的总金额。
