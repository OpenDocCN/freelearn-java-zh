- en: Spring Security Add-Ons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring安全附加组件
- en: In previous chapters, we covered the implementation details of the multiple
    ways in which core security aspects, such as authentication and authorization,
    use Spring Security. In doing so, we just skimmed over a very thin layer of the
    capabilities that can be achieved using Spring Security. In this chapter, we will
    cover some other capabilities provided by Spring Security in a concise manner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们介绍了核心安全方面（如身份验证和授权）使用Spring安全的多种方式的实现细节。在这样做时，我们只是浅尝辄止了Spring安全可以实现的能力的一层薄薄的表面。在本章中，我们将简要介绍Spring安全提供的一些其他能力。
- en: In addition, the chapter introduces many products (open source and paid versions)
    that can be considered for use along with Spring Security. I am not backing any
    of these products, but I do consider them strong contenders for achieving the
    technical capabilities that you are looking for. We will start off introducing
    a product by giving a gist of the technical capability that we need to address,
    then introduce you briefly to the product.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章介绍了许多产品（开源和付费版本），可以考虑与Spring安全一起使用。我不支持这些产品中的任何一个，但我确实认为它们是实现您所寻找的技术能力的强有力竞争者。我们将通过简要介绍产品的技术能力的要点来介绍一个产品，然后简要介绍给您。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Remember-me authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住我认证
- en: Session management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理
- en: CSRF
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSRF
- en: CSP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSP
- en: Channel security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道安全
- en: CORS Support
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CORS支持
- en: The Crypto module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密模块
- en: Secret management
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密管理
- en: HTTP Data Integrity Validator
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP数据完整性验证器
- en: Custom DSL
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义DSL
- en: Remember-me authentication
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住我认证
- en: We will be reusing and enhancing the example that we built in [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security* (`jetty-db-basic-authentication`), to explain how
    Spring Security can be used to achieve remember me, or persistent login, functionality.
    In the example that we are going to reuse, we have used basic authentication,
    in which user credentials are stored in a MySQL database.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用并增强我们在[第2章](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml)中构建的示例，*深入Spring安全*（`jetty-db-basic-authentication`），以解释Spring安全如何用于实现记住我或持久登录功能。在我们要重用的示例中，我们使用了基本身份验证，其中用户凭据存储在MySQL数据库中。
- en: Remember me functionality is achieved in Spring Security by sending cookies
    to the browser when the user chooses to remember his/her credentials on the client
    side. The cookie can be configured to be stored in the browser for a stipulated
    time. If the cookie exists and is valid, the next time the user accesses the application,
    they are taken straight to the user's home page and avoid explicit authentication
    with a username/password combination.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring安全中，通过在用户选择在客户端记住他/她的凭据时向浏览器发送cookie来实现记住我功能。可以配置cookie在浏览器中存储一段时间。如果cookie存在且有效，用户下次访问应用程序时，将直接进入用户的主页，避免使用用户名/密码组合进行显式认证。
- en: 'Remember me functionality can be achieved using two approaches:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种方法实现记住我功能：
- en: '**Hash-based tokens**: Username, expiry time, password, and a private key are
    hashed and send to the client as a token'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于哈希的令牌**：用户名、过期时间、密码和私钥被哈希并作为令牌发送到客户端'
- en: '**Persistent tokens**: A persistent storage mechanism is used to store the
    token on the server'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久令牌**：使用持久存储机制在服务器上存储令牌'
- en: We will now go through a simple implementation of the persistent token approach
    to explain this concept in detail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过一个简单的持久令牌方法来详细解释这个概念。
- en: Creating a new table in MySQL database
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MySQL数据库中创建一个新表
- en: 'We will use the same schema as the MySQL DB that we used in [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security*. Keep everything as is, and then create a new table
    in the MySQL database for storing persistent tokens by executing the following
    DDL statement in the MySQL workbench:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与我们在[第2章](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml)中使用的MySQL数据库相同的模式。保持一切不变，然后在MySQL工作台中执行以下DDL语句来创建一个新表，用于存储持久令牌：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Spring Security configuration
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring安全配置
- en: 'In [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep Diving into
    Spring Security* (in the Spring Security setup sub-section of the `Sample` application
    section), we saw basic authentication, which we configured in our configure method
    in the Spring Security Configuration class. In this example, we will create a
    custom login page and change the login mechanism to form-based. Open the `SpringSecurityConfig`
    class and change the configure method, as shown in the following code snippet.
    Then, add the `tokenRepository` bean that we are going to use to accomplish remember
    me functionality:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml)中，*深入Spring安全*（在`Sample`应用程序部分的Spring安全设置子部分），我们看到了基本身份验证，我们在Spring安全配置类的configure方法中进行了配置。在这个例子中，我们将创建一个自定义登录页面，并将登录机制更改为基于表单的。打开`SpringSecurityConfig`类，并按照下面的代码片段更改configure方法。然后，添加我们将使用的`tokenRepository`
    bean来实现记住我功能：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The custom login page
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义登录页面
- en: 'Create a new page, namely `login.jsp` in the `src/main/webapp/WEB-INF/view`
    folder. The main section of the page, containing the `username`, `password`, and
    `rememberme` fields, is as shown in the following code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main/webapp/WEB-INF/view`文件夹中创建一个新页面，名为`login.jsp`。页面的主要部分包含`username`、`password`和`rememberme`字段，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Make sure that you name the remember me checkbox the same as you specified in
    the Spring Security configuration.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您将记住我复选框的名称与您在Spring安全配置中指定的名称相同。
- en: Running the application and testing
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序并进行测试
- en: 'Run the project by executing the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令来运行项目：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Wait for the console to print [INFO] Started Jetty Server.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 等待控制台打印[INFO] Started Jetty Server。
- en: 'Open a browser (I use Firefox in private mode for testing) and navigate to
    `http://localhost:8080`, and you will be shown the custom login page that you
    created, as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器（我在测试时使用Firefox的隐私模式）并导航到`http://localhost:8080`，你将看到你创建的自定义登录页面，如下截图所示：
- en: '![](img/08fa314d-719a-44ba-935e-2b5ec788d304.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08fa314d-719a-44ba-935e-2b5ec788d304.png)'
- en: 'Figure 1: The custom login page'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '图1: 自定义登录页面'
- en: 'Enter `user`/`user@password` as the username and password. Click on `Remember
    me` and click the `Login` button, and you will be navigated to the user home page,
    as shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`user`/`user@password`作为用户名和密码。点击`Remember me`并点击`Login`按钮，你将被导航到用户主页，如下所示：
- en: '![](img/eb50890a-9b60-47b6-b8f9-e6b253f303bf.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb50890a-9b60-47b6-b8f9-e6b253f303bf.png)'
- en: 'Figure 2: User home page'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '图2: 用户主页'
- en: 'Query your MySQL database for the `persistent_logins` table, and you will see
    a new record, as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查询你的MySQL数据库的`persistent_logins`表，你将看到一个新记录，如下截图所示：
- en: '![](img/973617d1-af29-4ebf-999a-eee1c92e9ea9.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/973617d1-af29-4ebf-999a-eee1c92e9ea9.png)'
- en: 'Figure 3: MySQLWorkbench querying new persistent_logins table'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '图3: MySQLWorkbench查询新的persistent_logins表'
- en: 'Now, go to the developer tools in your browser and check for cookies. Depending
    on the browser that you are using, you should see something similar to this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开浏览器中的开发者工具并检查cookies。根据你使用的浏览器，你应该看到类似于这样的东西：
- en: '![](img/a4f15410-f35e-481e-8f6b-21f82a4ef7af.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4f15410-f35e-481e-8f6b-21f82a4ef7af.png)'
- en: 'Figure 4: Browser cookie set to achieve remember-me functionality'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '图4: 浏览器cookie设置以实现记住我功能'
- en: The entire project for this example can be found at the book’s GitHub page in
    the `jetty-db-basic-authentication-remember-me` project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的整个项目可以在书的GitHub页面的`jetty-db-basic-authentication-remember-me`项目中找到。
- en: Session management
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理
- en: 'Spring Security allows you to manage sessions on your server with only some
    configuration. Some of the most important session management activities are listed
    here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security允许你只需一些配置就可以管理服务器上的会话。以下是一些最重要的会话管理活动：
- en: '**Session creation**: This decides when a session needs to be created and the
    ways in which you can interact with it. In the Spring Security configuration,
    put in the following code:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话创建**: 这决定了何时需要创建会话以及您可以与之交互的方式。在Spring Security配置中，输入以下代码：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are four session creation policies that you can choose from. They are
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种会话创建策略可供选择。它们如下：
- en: '`ALWAYS`: Always create a session if it doesn''t exist.'
  id: totrans-53
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALWAYS`: 如果不存在会话，总是创建一个会话。'
- en: '`IF_REQUIRED`: If required, a session is created.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IF_REQUIRED`: 如果需要，会创建一个会话。'
- en: '`NEVER`: This will never create a session; rather, it will use the session
    if it exists.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEVER`: 永远不会创建会话；相反，它将使用已存在的会话。'
- en: '`STATELESS`: No session will be created nor used.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无状态`: 不会创建或使用会话。'
- en: '`invalidSession`: This controls how the user is intimated if the server sees
    an invalid session:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidSession`: 这控制着服务器检测到无效会话时如何通知用户：'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Session timeout**: This controls how the user is intimated if the session
    has expired.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话超时**: 这控制着用户在会话过期时如何被通知。'
- en: '**Concurrent session**: This allows control over how many sessions a user can
    start in an application. If the maximum sessions is set as `1`, when the user
    logs in for the second time, the previous session is invalidated and the user
    is logged out. If the value specified is greater than `1`, the user is allowed
    to have that many sessions concurrently:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发会话**: 这允许控制用户在应用程序中可以启动多少个会话。如果最大会话数设置为`1`，当用户第二次登录时，先前的会话将被失效，用户将被注销。如果指定的值大于`1`，则允许用户同时拥有这么多会话：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the default error screen, that pops up when
    more than the desired amount of sessions (as configured) are created by the same
    user:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了默认的错误屏幕，当同一用户创建了超过所配置的期望数量的会话时弹出：
- en: '![](img/a56b4b3d-0c1a-4b4f-8212-066588d543ae.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a56b4b3d-0c1a-4b4f-8212-066588d543ae.png)'
- en: 'Figure 5: Error thrown when a user accesses multiple sessions'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '图5: 用户访问多个会话时抛出的错误'
- en: '**Session fixation**: This is very similar to concurrent session control. This
    setting allows us to control what will happen when a new session is initiated
    by a user. We can specify the following three values:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话固定**: 这与并发会话控制非常相似。此设置允许我们控制用户启动新会话时会发生什么。我们可以指定以下三个值：'
- en: '`migrateSession`: On the creation of a new session after successful authentication,
    the old session is invalidated and all attributes are copied to the new session:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`migrateSession`: 在成功认证后创建新会话时，旧会话将被失效，并且所有属性将被复制到新会话：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`newSession`: A new session is created without copying any of the attributes
    from the previous valid session:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSession`: 创建一个新会话，而不复制先前有效会话的任何属性：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`none`: The old session is reused and is not invalidated:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无`: 旧会话被重用并且不会失效：'
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: CSRF
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF
- en: '**Cross-Site Request Forgery** (**CSRF**) ([https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)))
    is an attack that forces an end user to execute unwanted actions on a web application
    in which they''re currently authenticated. CSRF attacks specifically target state-changing
    requests, not theft of data, since the attacker has no way to see the response
    to the forged request.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）([https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)))是一种攻击，它迫使最终用户在当前已认证的Web应用程序上执行不需要的操作。CSRF攻击专门针对改变状态的请求，而不是数据的窃取，因为攻击者无法看到伪造请求的响应。'
- en: The **Open Web Application Security Project** (**OWASP**) considers CSRF as
    one of the most common security risks for web applications. OWASP publishes a
    list (known as the OWASP Top 10) every year, highlighting the top 10 security
    risks plaguing web applications—it considers CSRF to be in fifth position.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放Web应用安全项目**（**OWASP**）认为CSRF是Web应用程序中最常见的安全风险之一。OWASP每年发布一个名为OWASP十大的列表，突出显示困扰Web应用程序的前10个安全风险，它认为CSRF位列第五位。'
- en: 'In Spring Security, CSRF is enabled by default. If needs be (we have disabled
    this in many of our examples so that we are able to concentrate on the main concept
    that the examples are supposed to convey), we can disable it explicitly by adding
    the following code snippet in your Spring Security configuration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security中，默认情况下启用CSRF。如果需要（我们已在许多示例中禁用了这一点，以便能够集中精力关注示例应传达的主要概念），我们可以通过在Spring
    Security配置中添加以下代码片段来显式禁用它：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Even though CSRF is enabled by default, for it to function, each request needs
    to provide a CSRF token. If a CSRF token is not sent across to the server, the
    server will reject the request and throw an error. If you are using **Java Server
    Page** (**JSP**) as your view, just by including hidden input, as shown in the
    following code snippet, many things would happen auto-magically:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使CSRF默认启用，但为了使其正常工作，每个请求都需要提供CSRF令牌。如果未将CSRF令牌发送到服务器，服务器将拒绝请求并抛出错误。如果您将**Java服务器页面**（**JSP**）作为视图，只需包含隐藏输入，如下面的代码片段所示，许多事情都会自动发生：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you are using an AJAX request to call a server, instead of hidden input,
    you can supply the CSRF token in the form of an HTTP header. You can declare the
    CSRF-related header as meta tags, as shown in the following code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用AJAX请求调用服务器，可以以HTTP标头的形式提供CSRF令牌，而不是隐藏输入。您可以将与CSRF相关的标头声明为元标记，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After that, while calling the server, include these (`_csrf` and `_csrf_header`)
    as headers and you will be allowed to call the required endpoints.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在调用服务器时，将这些（`_csrf`和`_csrf_header`）作为标头包含进去，您将被允许调用所需的端点。
- en: 'If you would like to persist the CSRF token, Spring Security allows you to
    do this by tweaking the configuration as shown in the following code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要持久保存CSRF令牌，Spring Security允许您通过调整配置来实现，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While doing this, the CSRF token is persisted as a cookie, which can be read
    by the server and validated (all done auto-magically).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作时，CSRF令牌将作为cookie持久保存，服务器可以读取并验证（所有这些都是自动完成的）。
- en: CSP
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSP
- en: '**Content Security Policy** (**CSP**) ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP))
    is an added layer of security that helps to detect and mitigate certain types
    of attacks, including **Cross Site Scripting** (**XSS**) and data injection attacks.
    These attacks are used for everything from data theft to site defacement or distribution
    of malware.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容安全策略**（**CSP**）（[https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)）是一种增加的安全层，有助于检测和缓解某些类型的攻击，包括**跨站脚本**（**XSS**）和数据注入攻击。这些攻击用于从数据窃取到网站损坏或恶意软件分发等各种用途。'
- en: A proper CSP setup in your application can handle content injection vulnerabilities,
    and is a great way to reduce XSS. XSS stands at number two in the OWASP Top 10.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中进行适当的CSP设置可以处理内容注入漏洞，并是减少XSS的好方法。XSS在OWASP十大中排名第二。
- en: A CSP is not a solution to handling all injection vulnerabilities, but can be
    used as one of the tools to reduce injection attacks to a reasonable level.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: CSP并非处理所有注入漏洞的解决方案，但可以用作减少注入攻击的工具之一。
- en: 'CSP is a declarative policy, implemented using HTTP headers. It can be run
    in an application in two modes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CSP是一种声明性策略，使用HTTP标头实现。它可以在应用程序中以两种模式运行：
- en: Production mode (declared as CSP)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产模式（声明为CSP）
- en: Report-only mode (used for testing and are declared as *Content-Security-Policy-Report-Only*)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅报告模式（用于测试并声明为*Content-Security-Policy-Report-Only*）
- en: 'CSP contains a set of security policy directives responsible for putting appropriate
    restrictions on a web resource and then informing the client (user agent) accordingly
    when breached. For example, the following security policy snippet loads scripts
    from the defined trusted domains:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CSP包含一组安全策略指令，负责对Web资源施加适当的限制，然后在违规时相应地通知客户端（用户代理）。例如，以下安全策略片段从定义的受信任域加载脚本：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If there''s a breach, the user agent will block it, and if the policy specifies
    a `report-uri` parameter, as shown in the following example, it will report the
    violation in the form of JSON to that URI:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生违规行为，用户代理将阻止它，如果策略指定了`report-uri`参数，如下例所示，它将以JSON的形式向该URI报告违规行为：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous examples showcase CSP working in production mode. If you would
    like to first test the security policy and after a particular period of time make
    those policies in production mode, CSP provides a mechanism for that, as shown
    in the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了CSP在生产模式下的工作。如果您想首先测试安全策略，然后在一段时间后将这些策略转为生产模式，CSP提供了一种机制，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In report-only mode, when a breach is detected, the report is posted to the
    `report-uri` in JSON format, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅报告模式下，当检测到违规行为时，报告将以JSON格式发布到`report-uri`，如下例所示：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Apart from the security directives detailed in the preceding examples, there
    are a number of security directives that can be used while setting up your CSP.
    For a full list of directives, please refer to [https://content-security-policy.com/](https://content-security-policy.com/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面示例中详细介绍的安全指令之外，还有一些安全指令可在设置CSP时使用。有关完整的指令列表，请参阅[https://content-security-policy.com/](https://content-security-policy.com/)。
- en: 'In a similar way to CSRF tokens, CSP can also be used to make sure that specific
    resources contain a token while accessing the server. The following example shows
    the use of this nonce approach:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSRF令牌类似，CSP也可以用于确保在访问服务器时特定资源包含一个令牌。以下示例显示了使用这种nonce方法：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similar to a CSRF token, this nonce has to be included along with any resource
    access in the server, and this has to be newly generated while a page is loaded.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSRF令牌类似，这个nonce必须在服务器中的任何资源访问中包含，并且在加载页面时必须新生成。
- en: 'CSP also allows you to load the resources only if they match the hash that
    the server expects. The following policy is used to achieve this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: CSP还允许您仅在资源与服务器期望的哈希匹配时加载资源。以下策略用于实现这一点：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: CSP is supported by almost all modern browsers. Even if some security directives
    are not supported by certain browsers, other supported directives will work without
    any problem. The best way to handle that is to send only the security directives
    that will definitely be supported by the browser by deciphering the user agent,
    rather than throwing errors on the client.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: CSP受到几乎所有现代浏览器的支持。即使某些浏览器不支持某些安全指令，其他支持的指令也可以正常工作。处理这个问题的最佳方式是通过解密用户代理，只发送浏览器肯定支持的安全指令，而不是在客户端上抛出错误。
- en: CSP using Spring Security
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security的CSP
- en: 'Configuring CSP using Spring Security configuration is a breeze. By default,
    CSP is not enabled. You can enable it in Spring Security configuration, as shown
    in the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Security配置CSP非常简单。默认情况下，CSP是未启用的。您可以在Spring Security配置中启用它，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The report-only CSP in the Spring Security configuration is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security配置中的报告仅CSP如下：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Channel security
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道安全
- en: In addition to authentication and authorization, Spring Security can also be
    used to check for any additional property presence for each request reaching the
    server. It can check for protocol (transport type, HTTP, or HTTPS), presence of
    certain HTTP headers, and more. SSL is now the de facto standard for any web application
    (or website) to comply with, and many search engines (such as Google, for example)
    even penalize you if your website is not HTTPS. SSL is made use of in securing
    the channel on which data flows from client to server and vice versa.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了身份验证和授权之外，Spring Security还可以用于检查每个到达服务器的请求是否具有任何额外的属性。它可以检查协议（传输类型、HTTP或HTTPS）、某些HTTP头的存在等。SSL现在是任何Web应用程序（或网站）遵守的事实标准，并且许多搜索引擎（例如Google）甚至会对您的网站不使用HTTPS进行惩罚。SSL用于保护从客户端到服务器以及反之的数据流通道。
- en: Spring Security can be configured to explicitly check for URL patterns and explicitly
    redirect the user to HTTPS if they are coming with the HTTP protocol.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security可以配置为显式检查URL模式，并在使用HTTP协议访问时显式将用户重定向到HTTPS。
- en: 'This can be easily done by configuring the appropriate URL pattern in your
    Spring Security configuration, as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在Spring Security配置中配置适当的URL模式来轻松实现，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When users access the `/httpsRequired/**` URL pattern and if the protocol is
    HTTP, Spring Security will redirect the user to the same URL with the HTTPS protocol.
    The following configuration is used to secure all requests:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问`/httpsRequired/**`URL模式并且协议是HTTP时，Spring Security将用户重定向到相同的URL，使用HTTPS协议。以下配置用于保护所有请求：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To explicitly mention certain URLs as insecure, use the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确指定某些URL为不安全的，请使用以下代码：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code snippet shows how to specify any request to be HTTP (insecure):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何指定任何请求为HTTP（不安全）：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: CORS Support
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CORS支持
- en: '**Cross-Origin Resource Sharing** (**CORS**) ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS))
    is a mechanism that uses additional HTTP headers to tell a browser to let a web
    application running at one origin (domain) have permission to access selected
    resources from a server at a different origin. A web application makes a cross-origin
    HTTP request when it requests a resource that has a different origin (domain,
    protocol, and port) than its own origin.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域资源共享（CORS）（[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)）是一种机制，它使用额外的HTTP头来告诉浏览器，让一个在一个源（域）上运行的Web应用程序有权限访问来自不同源服务器的选定资源。当Web应用程序请求具有不同源（域、协议和端口）的资源时，它会发出跨源HTTP请求。
- en: We won't be creating full-fledged projects in this section to explain the working
    of CORS. We will use code snippets and will explain each bit of code so that the
    section is concise.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会创建完整的项目来解释CORS的工作原理。我们将使用代码片段，并解释每一部分代码，以便本节简洁明了。
- en: 'Change your Spring Security configuration, as shown in the following code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下代码片段更改Spring Security配置：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we configure CORS in the Spring Security `configure`
    method. We then create a new bean, `corsConfigurationSource`, in which we enable
    the `*/***` path to be accessible by other domains. This is not really ideal in
    many scenarios, and the following code snippet shows the more enhanced `CorsConfiguration`
    class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在Spring Security的`configure`方法中配置了CORS。然后我们创建了一个新的bean，`corsConfigurationSource`，在其中启用了`*/***`路径以供其他域访问。在许多情况下，这并不是真正理想的，下面的代码片段显示了更加强化的`CorsConfiguration`类：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If it is a Spring MVC application, you can have a Spring MVC configuration
    file in which you can specify CORS mapping by creating a bean, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是Spring MVC应用程序，可以通过创建一个bean来指定CORS映射，如下所示：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I have copied a previous example from [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security*, and created a new project in this chapter, containing
    full source code in `spring-boot-in-memory-basic-authentication-with-cors`. What
    we have done here is set the CORS global configuration by declaring the `CorsConfigurationSource`
    bean.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我从[第2章](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml)中复制了一个先前的示例，*深入Spring安全*，并在本章中创建了一个新项目，其中包含`spring-boot-in-memory-basic-authentication-with-cors`的完整源代码。我们在这里所做的是通过声明`CorsConfigurationSource`
    bean来设置CORS全局配置。
- en: The Crypto module
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密模块
- en: The Spring Security Crypto module allows you to do password encoding, symmetric
    encryption, and key generation. The module is bundled as part of the core Spring
    Security offering with no dependency upon other Spring Security code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security Crypto模块允许您进行密码编码、对称加密和密钥生成。该模块作为核心Spring Security提供的一部分捆绑在一起，不依赖于其他Spring
    Security代码。
- en: Password encoding
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码编码
- en: 'Modernized password encoding is one of the new features of Spring Security
    5\. Spring Security''s `PasswordEncoder` interface is central to it and does one-way
    hashing of passwords using various algorithms, which can then be stored securely.
    Spring Security supports a number of password-encoding algorithms:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现代化的密码编码是Spring Security 5的新功能之一。Spring Security的`PasswordEncoder`接口是其核心，它使用各种算法对密码进行单向哈希处理，然后可以安全地存储。Spring
    Security支持多种密码编码算法：
- en: '`BcryptPasswordEncoder`: This uses the Bcrypt strong hash function. You can
    optionally supply the strength parameter (default value is 10); the higher the
    value, the more work has to be done to hash the password.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BcryptPasswordEncoder`：这使用Bcrypt强哈希函数。您可以选择性地提供强度参数（默认值为10）；值越高，哈希密码所需的工作量就越大。'
- en: '`Pbkdf2PasswordEncoder`: This uses **Password-Based Key Derivation Function
    2** (**PKDF2**) with a configurable number of iterations and an 8-byte random
    salt value.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pbkdf2PasswordEncoder`：这使用**基于密码的密钥派生函数2**（**PKDF2**），具有可配置的迭代次数和8字节的随机盐值。'
- en: '`ScryptPasswordEncoder`: This uses the Scrypt hashing function. While hashing,
    clients can supply a CPU cost parameter, a memory cost parameter, and a parallelization
    parameter. The current implementation uses the Bouncy Castle library.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScryptPasswordEncoder`：这使用Scrypt哈希函数。在哈希过程中，客户端可以提供CPU成本参数、内存成本参数和并行化参数。当前实现使用Bouncy
    Castle库。'
- en: Encryption
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密
- en: 'Spring Security''s `org.springframework.security.crypto.encrypt.Encryptors`
    class has factory methods that can be used to create symmetric encryptors. The
    class supports two encryptors:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security的`org.springframework.security.crypto.encrypt.Encryptors`类有工厂方法，可以用来创建对称加密器。该类支持两种加密器：
- en: '`BytesEncryptor`: The service interface for symmetric data encryption of data
    in the form of raw byte arrays.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BytesEncryptor`：用于对原始字节数组形式的数据进行对称数据加密的服务接口。'
- en: '`TextEncryptor`: The service interface for symmetric data encryption of text
    strings:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextEncryptor`：用于对文本字符串进行对称数据加密的服务接口：'
- en: '![](img/0a10170e-1db7-4e62-81fe-4c5ed66c830f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a10170e-1db7-4e62-81fe-4c5ed66c830f.png)'
- en: Key generation
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密钥生成
- en: As seen in the previous section on encryption, Spring Security has a class,
    namely `org.springframework.security.crypto.keygen.KeyGenerators`, that has a
    number of factory methods that can used to construct a number of keys needed for
    your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面加密部分所示，Spring Security有一个类，即`org.springframework.security.crypto.keygen.KeyGenerators`，它有许多工厂方法，可以用来构造应用程序所需的许多密钥。
- en: 'The following are the two supported types of key generator:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是支持的两种密钥生成器类型：
- en: '`BytesKeyGenerator`: The generator for generating unique byte array-based keys.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BytesKeyGenerator`：用于生成唯一基于字节数组的密钥的生成器。'
- en: '`StringKeyGenerator`: The generator for unique string keys:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringKeyGenerator`：用于生成唯一字符串密钥的生成器：'
- en: '![](img/50f4bea4-d4a6-447c-be97-1a746f3a7d4e.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50f4bea4-d4a6-447c-be97-1a746f3a7d4e.png)'
- en: 'Figure 7: The BytesKeyGenerator and StringKeyGenerator factory methods'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：BytesKeyGenerator和StringKeyGenerator工厂方法
- en: Secret management
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密管理
- en: In an application, we need to handle a variety of secret/secure data in the
    form of API keys, other application passwords, and more. Often, for an application
    deployed and running in a production environment, keeping these in plain text
    can result in security breaches. With automation up for grabs quite cheaply nowadays,
    for modern applications, storing such data securely with access control and secure
    storage is a must.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，我们需要处理各种形式的API密钥、其他应用程序密码等秘密/安全数据。通常情况下，对于部署和运行在生产环境中的应用程序，将这些数据以明文形式存储可能导致安全漏洞。如今，自动化技术变得非常便宜，对于现代应用程序来说，安全地存储这些数据并进行访问控制是必不可少的。
- en: Encryption is something that has been widely embraced, but for decryption, a
    key needs to be circulated, and this circulation of the key is usually a big problem.
    If a person decides to take the key outside of the organization, there can be
    serious problems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是被广泛接受的，但是对于解密，需要传播一个密钥，而这个密钥的传播通常是一个大问题。如果一个人决定将密钥带出组织，就会出现严重问题。
- en: Vault from HashiCorp is a very strong contender as a solution to this issue,
    and helps in managing these secrets easily with very rigid controls. It provides
    APIs that give access based on set policies. It also has the capability to provide
    access control, and it also comes with encryption functionality out of box. In
    addition, it has a variety of persistent backend supports, such as Consul (from
    HashiCorp), and more, making it easy for enterprises to adopt it. Vault is written
    in Go and has binaries available for many platforms, and can be downloaded from
    its website. In this section, we will quickly run you through the Vault product
    itself, and then go through an example in which we will create a Spring Boot project
    and securely access some of the secrets stored in the Vault. Without further ado,
    let's get our hands dirty with actual code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp的Vault是解决此问题的一个非常有力的竞争者，并且可以帮助轻松管理这些秘密，并具有非常严格的控制。它提供了基于设置策略的访问API。它还具有提供访问控制的功能，并且还具有开箱即用的加密功能。此外，它具有各种持久后端支持，例如Consul（来自HashiCorp）等，使企业可以轻松采用它。Vault是用Go编写的，并且可以在许多平台上下载到二进制文件，并且可以从其网站下载。在本节中，我们将快速介绍Vault产品本身，然后通过一个示例，我们将创建一个Spring
    Boot项目，并安全地访问Vault中存储的一些秘密。言归正传，让我们开始实际的代码。
- en: Starting by unsealing Vault
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从解封Vault开始
- en: 'Download the latest binary from the Vault project''s website ([https://www.vaultproject.io/downloads.html](https://www.vaultproject.io/downloads.html)),
    according to your operating system, and install it. To start Vault, you need to
    have a file—`vault.conf`—in which we will specify some of the options that are
    needed for Vault to start. Here is a sample `vault.conf` file that you can use:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从Vault项目的网站（[https://www.vaultproject.io/downloads.html](https://www.vaultproject.io/downloads.html)）下载最新的二进制文件，根据您的操作系统进行安装。要启动Vault，您需要一个文件`vault.conf`，其中我们将指定Vault启动所需的一些选项。以下是一个示例`vault.conf`文件，您可以使用：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `vault.conf` file, we explicitly set the address that it will listen
    to and also disable TLS/SSL (so that it runs in plain text mode).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vault.conf`文件中，我们明确设置它将监听的地址，并且还禁用了TLS/SSL（以便以纯文本模式运行）。
- en: 'Start Vault by specifying the location of the `vault.conf` file with the following
    command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令指定`vault.conf`文件的位置启动Vault：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see from the screenshot below, Vault is running in plain text mode
    (with TLS/SSL disabled):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的屏幕截图所示，Vault以纯文本模式运行（已禁用TLS/SSL）：
- en: '![](img/8aa8b640-96ed-40d7-bcf8-b5bc1dbc50fa.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8aa8b640-96ed-40d7-bcf8-b5bc1dbc50fa.png)'
- en: 'Figure 8: Starting and configuring Vault'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：启动和配置Vault
- en: 'Open a new command prompt, which is where we will now start administering Vault.
    Set an environment variable by executing the following command to let the clients
    know that they have to use plain text to connect to Vault (as we have disabled
    TLS/SSL):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的命令提示符，我们现在将开始管理Vault。通过执行以下命令设置一个环境变量，让客户端知道他们必须使用纯文本连接到Vault（因为我们已禁用了TLS/SSL）：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After this, initialize Vault key generation by executing the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过执行以下命令初始化Vault密钥生成：
- en: '![](img/49566220-3be6-4426-9f52-7bd0b97fef42.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49566220-3be6-4426-9f52-7bd0b97fef42.png)'
- en: 'Figure 9: Initializing Vault'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：初始化Vault
- en: The command that we have used gave us five key shares and a key threshold of
    two. It's important to note that we cannot change these values once Vault is initialized
    (output is shown only once). Be careful to gather the necessary information; otherwise,
    you will not be able to retrieve any data stored in Vault. As you can see from
    the preceding screenshot, the `init` command of Vault gives us the keys and token
    that are needed to unseal Vault. Before we can use Vault, it has to be unsealed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的命令给了我们五个密钥份额和两个密钥阈值。重要的是要注意，一旦Vault被初始化，就无法更改这些值（输出仅显示一次）。务必收集必要的信息；否则，您将无法检索存储在Vault中的任何数据。如前面的屏幕截图所示，Vault的`init`命令为我们提供了解封Vault所需的密钥和令牌。在我们可以使用Vault之前，必须对其进行解封。
- en: '**Unsealing** ([https://www.vaultproject.io/docs/concepts/seal.html](https://www.vaultproject.io/docs/concepts/seal.html)) is
    the process of constructing the master key necessary to read the decryption key
    to decrypt the data, allowing access to the Vault. Prior to unsealing, almost
    no operations are possible with Vault.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**解封** ([https://www.vaultproject.io/docs/concepts/seal.html](https://www.vaultproject.io/docs/concepts/seal.html))
    是构建读取解密密钥以解密数据所必需的主密钥的过程，从而允许访问Vault。在解封之前，几乎无法对Vault进行任何操作。'
- en: 'You can unseal Vault by executing the following command and providing any of
    the keys generated during the Vault initialization process:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令并提供在Vault初始化过程中生成的任何密钥来解封Vault：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following screenshot shows the successful execution of the preceding command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了上述命令的成功执行：
- en: '![](img/b1a8f86b-355d-4c7e-8cca-d7bc68756af3.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1a8f86b-355d-4c7e-8cca-d7bc68756af3.png)'
- en: 'Figure 10: Unsealing Vault'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：解封Vault
- en: Once it is unsealed, your Vault is now ready to store the secret data that you
    may want to use in your application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解封，您的Vault现在已准备好存储您可能想在应用程序中使用的秘密数据。
- en: 'After you have successfully unsealed Vault, to store any data, you first need
    to authenticate. When we initialized Vault, we were shown a token (on the screen),
    and this token is used to authenticate. One of the easiest ways to achieve authentication
    using this token is to set up a new environment variable (`VAULT_TOKEN`). Execute
    the following command as shown, and when Vault starts, it will make use of this
    environment variable and authenticate itself:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 成功解封Vault后，要存储任何数据，您首先需要进行身份验证。当我们初始化Vault时，会显示一个令牌（在屏幕上），此令牌用于进行身份验证。使用此令牌进行身份验证的最简单方法之一是设置一个新的环境变量（`VAULT_TOKEN`）。执行以下命令，当Vault启动时，它将使用此环境变量并进行身份验证：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the preceding command is executed, you can now write your secret by executing
    the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，现在可以通过执行以下命令编写您的秘密：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After you enter the command, you should receive the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输入命令后，您应该收到以下输出：
- en: '![](img/c8663c6c-36f8-4f51-9e57-e5605f5ad26e.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8663c6c-36f8-4f51-9e57-e5605f5ad26e.png)'
- en: 'Figure 11: Writing a secret to your Vault'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：将秘密写入Vault
- en: Tokens are the primary way in which authentication is done in Vault. Besides
    that, there are other mechanisms, such as LDAP and username/password, with which
    authentication can be done.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌是Vault中进行身份验证的主要方式。除此之外，还有其他机制，如LDAP和用户名/密码，可以进行身份验证。
- en: The Spring Boot project
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot项目
- en: Spring has a dedicated module, called Spring Cloud Vault, that makes use of
    Vault in your application a breeze. Spring Cloud Vault is very easy to use, and
    we will be covering how to use it in this section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Spring有一个专门的模块，称为Spring Cloud Vault，可以轻松地在应用程序中使用Vault。Spring Cloud Vault非常易于使用，我们将在本节中介绍如何使用它。
- en: '**Spring Cloud Vault Config** ([http://cloud.spring.io/spring-cloud-vault/](http://cloud.spring.io/spring-cloud-vault/))
    provides client-side support for externalized configuration in a distributed system.
    With HashiCorp''s Vault you have a central place to manage external secret properties
    for applications across all environments. Vault can manage static and dynamic
    secrets such as username/password for remote applications/resources and provide
    credentials for external services such as MySQL, PostgreSQL, Apache Cassandra,
    MongoDB, Consul, AWS, and more.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Cloud Vault Config**（[http://cloud.spring.io/spring-cloud-vault/](http://cloud.spring.io/spring-cloud-vault/)）为分布式系统中的外部化配置提供了客户端支持。使用HashiCorp的Vault，您可以管理应用程序在所有环境中的外部秘密属性的中心位置。Vault可以管理静态和动态秘密，如远程应用程序/资源的用户名/密码，并为MySQL、PostgreSQL、Apache
    Cassandra、MongoDB、Consul、AWS等外部服务提供凭据。'
- en: 'We will be using the Spring Boot project (generated using Spring Initializr,
    [https://start.spring.io](https://start.spring.io)). At the start of the application,
    Vault is started and all the secrets are picked up:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Boot项目（使用Spring Initializr生成，[https://start.spring.io](https://start.spring.io)）。在应用程序启动时，Vault会启动并获取所有的秘密：
- en: '![](img/ef82792e-746b-438b-9813-4fb8a1b0ffbc.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef82792e-746b-438b-9813-4fb8a1b0ffbc.png)'
- en: 'Figure 12: Creation of an empty Spring Initializr project'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：创建一个空的Spring Initializr项目
- en: 'Unzip the downloaded Spring Initializr project by executing the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令解压下载的Spring Initializr项目：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Import the project in your favorite IDE (I am using IntelliJ).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在您喜欢的IDE中导入项目（我在使用IntelliJ）。
- en: The Maven dependency
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖项
- en: 'Make sure that your project''s `pom.xml` has the following Maven dependency
    added:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的项目的`pom.xml`中添加了以下Maven依赖项：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When the Spring Boot project starts, it will pick the default Vault configuration
    if the Vault server is running on port `8200`. If you want to customize these
    properties, you can specify `bootstrap.yml` or `bootstrap.properties`. In our
    example, we will explicitly set the `bootstrap.yml` file with the following content:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring Boot项目启动时，如果Vault服务器运行在端口`8200`上，它将选择默认的Vault配置。如果您想自定义这些属性，可以指定`bootstrap.yml`或`bootstrap.properties`。在我们的示例中，我们将明确设置`bootstrap.yml`文件，内容如下：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will be using the HTTP scheme, as we started Vault in plain text mode. If
    you would like to use HTTPS, it's quite easy to do so, as most things are done
    through scripts already provided. This is the default scheme in which Vault runs,
    and this is how it has to be in the production setup. Let's understand this concept
    first before going into a bit more depth when you implement the actual use case.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用HTTP方案，因为我们以纯文本模式启动了Vault。如果您想使用HTTPS，这也很容易做到，因为大多数操作都是通过提供的脚本完成的。这是Vault运行的默认方案，在生产设置中必须是这样。在实现实际用例时，让我们先了解这个概念，然后再深入一点。
- en: If you would like to run Vault in the HTTPS scheme, Spring Cloud Vault has a
    number of scripts available in its source code under `src/test/bash` ([https://github.com/spring-cloud/spring-cloud-vault/tree/master/src/test/bash](https://github.com/spring-cloud/spring-cloud-vault/tree/master/src/test/bash))
    that can be used to create the necessary certificates and then run Vault in this
    scheme. To keep this section concise, we won't be covering this aspect in much
    more detail here.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在HTTPS方案中运行Vault，Spring Cloud Vault在其源代码的`src/test/bash`目录下提供了许多脚本（[https://github.com/spring-cloud/spring-cloud-vault/tree/master/src/test/bash](https://github.com/spring-cloud/spring-cloud-vault/tree/master/src/test/bash)），可以用于创建必要的证书，然后在此方案下运行Vault。为了简洁起见，我们不会在这里详细介绍这个方面。
- en: 'In the `.yml` file, we have used the root token that was created as part of
    the initialization of Vault. If you need to, you can get a new token by executing
    the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.yml`文件中，我们使用了作为Vault初始化的一部分创建的根令牌。如果需要，可以通过执行以下命令获取新令牌：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following screenshot shows the successful execution of the `token create`
    command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`token create`命令的成功执行：
- en: '![](img/82e4a39d-39fb-4181-8952-d676cbe990e4.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82e4a39d-39fb-4181-8952-d676cbe990e4.png)'
- en: 'Figure 13: New Vault token creation'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：创建新的Vault令牌
- en: 'In your Spring Boot project, add the following code snippet in your application
    run class, `SpringBootSpringCloudVaultApplication`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Spring Boot项目中，在应用程序运行类`SpringBootSpringCloudVaultApplication`中添加以下代码片段：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this code, the `password` field will be filled by Spring Cloud Vault, and
    if you run the application (using command `mvn spring-boot:run`), you should see
    that Spring Cloud Vault connects to the running Vault (using the configuration
    in the `bootstrap.yml` file) and retrieves the value that we wrote to Vault for
    `movie-application`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`password`字段将由Spring Cloud Vault填充，如果您运行应用程序（使用命令`mvn spring-boot:run`），您应该看到Spring
    Cloud Vault连接到运行的Vault（使用`bootstrap.yml`文件中的配置）并检索我们为`movie-application`写入Vault的值。
- en: This concludes our look at a base application using Spring Boot and Spring Cloud
    Vault. You can see the full source in the book's GitHub page in the project under
    this chapter, named `spring-boot-spring-cloud-vault`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对使用Spring Boot和Spring Cloud Vault的基本应用程序的介绍。您可以在本书的GitHub页面中的本章项目中查看完整的源代码，名称为`spring-boot-spring-cloud-vault`。
- en: HTTP Data Integrity Validator
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP数据完整性验证器
- en: Spring Security aids us in enriching our application with common security features,
    allowing us to do so very easily and with minimal code. However, Spring Security
    is slowly and steadily catching up with many of the additional security features
    needed in modern applications. Most of these applications are deployed on the
    cloud and have very high rates of changes pushed to production on a day-to-day
    basis. **HTTP Data Integrity Validator** (**HDIV**) is a product that can be used
    to further enrich your application security.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security帮助我们通过简单的方式和最少的代码来丰富我们的应用程序的常见安全功能。然而，Spring Security正在逐渐赶上现代应用程序中需要的许多额外安全功能。这些应用程序大多部署在云上，并且每天都有大量的变更推送到生产环境。**HTTP数据完整性验证器**（**HDIV**）是一个可以用来进一步丰富您的应用程序安全性的产品。
- en: What is HDIV?
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是HDIV？
- en: HDIV was originally born as an open source project when it was developed by
    Roberto Velasco, Gotzon Illarramendi, and Gorka Vicente to confront security issues
    detected in production environments. The first stable Version 1.0 was released
    in 2008, in the form of a security library to be integrated within web applications.
    HDIV was officially integrated with Spring MVC, the most-used Java solution for
    web application development in 2011\. In 2012, HDIV was integrated with Grails.
    In 2015, HDIV was included within Spring Framework official documentation as a
    solution related to web security. Based on global interest and responding to high
    market demand, the creators founded the **HDIV Security **([https://hdivsecurity.com/](https://hdivsecurity.com/))
    company and launched the commercial version of HDIV in 2016\. HDIV solutions are
    built into applications during development to deliver the strongest available
    **Runtime Application Self Protection** (**RASP**) against the OWASP Top 10 threats.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: HDIV最初是作为一个开源项目诞生的，当时由Roberto Velasco、Gotzon Illarramendi和Gorka Vicente开发，以应对在生产环境中检测到的安全问题。第一个稳定版本1.0于2008年发布，以安全库的形式集成到Web应用程序中。2011年，HDIV正式与Spring
    MVC集成，这是最常用的Java解决方案，用于Web应用程序开发。2012年，HDIV与Grails集成。2015年，HDIV被包含在Spring Framework官方文档中，作为与Web安全相关的解决方案。基于全球的兴趣和对高市场需求的回应，创始人成立了**HDIV
    Security**([https://hdivsecurity.com/](https://hdivsecurity.com/))公司，并于2016年推出了HDIV的商业版本。HDIV解决方案在开发过程中构建到应用程序中，以提供最强大的**运行时应用程序自我保护**（**RASP**）来抵御OWASP十大威胁。
- en: HDIV was born to protect applications against parameter-tampering attacks. Its
    first purpose (looking at the acronym) was to guarantee the integrity (no data
    modification) of all the data generated by the server (links, hidden fields, combo
    values, radio buttons, destiny pages, cookies, headers, and more). HDIV extends
    a web application's behavior by adding security functionalities, as well as maintaining
    the API and the framework specification. HDIV gradually incorporated capabilities
    such as CSRF, **SQL Injection** (**SQLi**), and XSS protection, thus offering
    greatly increased security and being more than just an HTTP data integrity validator.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: HDIV诞生的目的是保护应用程序免受参数篡改攻击。它的第一个目的（从首字母缩写来看）是保证服务器生成的所有数据的完整性（不进行数据修改）。HDIV通过添加安全功能来扩展Web应用程序的行为，同时保持API和框架规范。HDIV逐渐增加了CSRF、**SQL注入**（**SQLi**）和XSS保护等功能，从而提供了更高的安全性，不仅仅是一个HTTP数据完整性验证器。
- en: 'Attacks are becoming lower in cost and more automated. Manual security testing
    is becoming a costly bottleneck. Spring Security protects the application by easily
    implementing the most important security aspects, such as authentication and authorization,
    but does not protect from common security bugs and design flaws in your application
    code. This is where integrating a Spring application that is already secured using
    Spring Security can bring in HDIV. We will be going through a very simple example,
    which will showcase a few of the areas where HDIV shines. Here are some of those
    advantages, as detailed by their website:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击成本越来越低，自动化程度越来越高。手动安全测试变得成本高昂。Spring Security通过轻松实现最重要的安全方面（如身份验证和授权）来保护应用程序，但不能保护应用程序代码中常见的安全漏洞和设计缺陷。这就是集成已经使用Spring
    Security进行保护的Spring应用程序可以引入HDIV的地方。我们将通过一个非常简单的示例来展示HDIV的一些亮点。以下是他们网站上详细介绍的一些优势：
- en: HDIV detects security bugs in source code before it is exploited, using a runtime
    dataflow technique to report the file and line number of the vulnerability. Reporting
    is immediate to developers during the development process either within the web
    browser or within a centralized web console.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HDIV在利用源代码之前检测安全漏洞，使用运行时数据流技术报告漏洞的文件和行号。开发人员在开发过程中可以立即在Web浏览器或集中式Web控制台中进行报告。
- en: It protects from business logic flaws with no need to learn applications and
    offers detection and protection from security bugs without changing the source
    code.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以保护免受业务逻辑缺陷的影响，无需学习应用程序，并提供检测和保护免受安全漏洞的影响，而无需更改源代码。
- en: HDIV makes integration possible between the pen-testing tool (Burp Suite) and
    the application, communicating valuable information to the pen-tester. It avoids
    many hand-coded steps, focusing the attention and effort of pen-testers on the
    most vulnerable entry points.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HDIV使得渗透测试工具（Burp Suite）与应用程序之间的集成成为可能，向渗透测试人员传递有价值的信息。它避免了许多手工编码的步骤，将渗透测试人员的注意力和努力集中在最脆弱的入口点上。
- en: 'For more information, you can check the following link: [https://hdivsecurity.com/](https://hdivsecurity.com/).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以查看以下链接：[https://hdivsecurity.com/](https://hdivsecurity.com/)。
- en: Let's start building a simple example that showcases the protection that HDIV
    does by protecting links and form data in your application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建一个简单的示例，展示HDIV在保护应用程序中链接和表单数据方面的保护。
- en: The Bootstrap project
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap项目
- en: 'We will be using a base project created out of Spring Initializr for creating
    our HDIV sample, as shown here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用通过Spring Initializr创建的基础项目来创建我们的HDIV示例，如下所示：
- en: '![](img/cda8ae32-ec39-4227-8761-4f613e718a7d.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cda8ae32-ec39-4227-8761-4f613e718a7d.png)'
- en: 'Figure 14: Basic Spring Initializr project setup'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：基本的Spring Initializr项目设置
- en: Maven dependencies
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖项
- en: 'In the following code, we are calling out explicit dependency that we need
    as part of this project, which is HDIV:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们正在调用我们需要作为项目一部分的显式依赖项，即HDIV：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: HDIV has support for a number of web application frameworks. In our example,
    we'll be using Spring MVC along with Thymeleaf and above mentioned dependency
    takes care of this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: HDIV支持多种Web应用程序框架。在我们的示例中，我们将使用Spring MVC以及Thymeleaf和上述依赖项来处理这个问题。
- en: Spring Security configuration
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security配置
- en: By now, you will already know what goes in the Spring Security configuration
    file. We will have in-memory authentication and will be configuring two users
    (similar to what we have been doing all throughout this book). We will have form-based
    login and also will be creating our own login page.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经知道Spring Security配置文件中包含什么。我们将进行内存身份验证，并配置两个用户（与本书中一直在做的类似）。我们将进行基于表单的登录，并将创建自己的登录页面。
- en: Spring MVC configuration
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC配置
- en: The Spring MVC configuration that we have been looking at so far is very basic.
    There isn't anything worth a special mention here. We will just need to ensure
    that the controller attached to the login page is explicitly defined.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在看的Spring MVC配置非常基本。这里没有什么值得特别提及的。我们只需要确保附加到登录页面的控制器被明确定义。
- en: HDIV configuration
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HDIV配置
- en: 'This magic class will bring in HDIV capability to your application without
    too much trouble. The full class is as shown here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个神奇的类将在不太麻烦的情况下为您的应用程序带来HDIV功能。完整的类如下所示：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The heavy lifting is done by the class that we are extending, `HdivWebSecurityConfigurerAdapter`.
    Also, the `@EnableHdivWebSecurity` annotation makes sure that much of the setup
    is automatically taken care of. We just need to make sure that the configuration
    of our login page URL is excluded from HDIV security by overriding the `addExclusions`
    method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的重要工作是由我们正在扩展的类`HdivWebSecurityConfigurerAdapter`完成。此外，`@EnableHdivWebSecurity`注解确保大部分设置会自动处理。我们只需要确保我们的登录页面URL的配置通过覆盖`addExclusions`方法来排除HDIV安全。
- en: The Model class
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型类
- en: We will be using the same model class we have been using throughout this book—`Movie`.
    To ease coding, we will be using the Lombok library, which does all the magic
    by looking at the various annotations configured in the class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本书中一直在使用的相同模型类`Movie`。为了简化编码，我们将使用Lombok库，该库通过查看类中配置的各种注释来完成所有魔术。
- en: The Controller class
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器类
- en: 'We will just have one controller class, where we will map all the pages that
    we are going to create in this example. To showcase the power of HDIV, we will
    see HDIV in action for two cases:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会有一个控制器类，我们将在这个示例中映射所有要创建的页面。为展示HDIV的功能，我们将看到HDIV在两种情况下的运行：
- en: A movie creation page (movie bean), showing HDIV at work in a page containing
    a form
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个电影创建页面（电影bean），显示在包含表单的页面中HDIV的工作
- en: A links page that shows HDIV intercepting and throwing errors when someone manipulates
    the actual link
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示HDIV拦截并在有人操纵实际链接时抛出错误的链接页面
- en: The class is quite straightforward and doesn't need to be detailed here.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该类非常简单，这里不需要详细说明。
- en: Pages
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面
- en: 'As mentioned before, we will have the following pages created in our example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在我们的示例中创建以下页面：
- en: '`login.html`: The custom login page that we will use for users to log in to
    the application'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login.html`：我们将用于用户登录应用程序的自定义登录页面'
- en: '`main.html`: The page that the user navigates to after successful login, containing
    links to the movie creation and links pages'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.html`：成功登录后用户导航到的页面，包含指向电影创建和链接页面的链接'
- en: '`links.html`: The page that the user is navigated to when they click on the
    links URL'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links.html`：用户单击链接URL时导航到的页面'
- en: '`movie.html`: The movie creation page, containing two fields—title and genre'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie.html`：电影创建页面，包含两个字段——标题和类型'
- en: Running the application
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Run the application just like any other Spring Boot project by executing the
    following command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令运行应用程序，就像运行任何其他Spring Boot项目一样：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Go to a browser and navigate to `http://localhost:8080` and you will be presented
    with a login page, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 转到浏览器并导航到`http://localhost:8080`，您将看到一个登录页面，如下所示：
- en: '![](img/d0bf4a33-f46f-439f-896a-1f910bb133b3.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0bf4a33-f46f-439f-896a-1f910bb133b3.png)'
- en: 'Figure 15: Login page'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：登录页面
- en: 'As shown in the preceding screenshot, enter the `username`/`password` and click
    on the Login button, and you will be navigated to the home page:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，输入`用户名`/`密码`并单击“登录”按钮，您将被导航到主页：
- en: '![](img/6a7dd816-60cf-422f-b918-c9476182fbc4.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a7dd816-60cf-422f-b918-c9476182fbc4.png)'
- en: 'Figure 16: The home page, which is presented to the user after successful login'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图16：成功登录后呈现给用户的主页
- en: 'Click on the link to navigate to the page where you can create a new movie.
    You will be navigated to the page shown in the following screenshot. Look closely
    at the URL and you will see a new query parameter has been added, `_HDIV_STATE_`.
    The server validates and ensures that the submitted form is genuine by looking
    at that value:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 单击链接导航到创建新电影的页面。您将被导航到以下截图中显示的页面。仔细观察URL，您将看到已添加新的查询参数“_HDIV_STATE_”。服务器通过查看该值来验证并确保提交的表单是真实的：
- en: '![](img/b3f55fb0-c2d2-4093-84b1-bced8cdfa19d.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3f55fb0-c2d2-4093-84b1-bced8cdfa19d.png)'
- en: 'Figure 17: The Create Movie screen, showing off the _HDIV_STATE_ query string'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图17：创建电影屏幕，展示_HDIV_STATE_查询字符串
- en: 'Now go back to the home page and click on the links page. You will be navigated
    to the following page:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回主页并单击链接页面。您将被导航到以下页面：
- en: '![](img/1b408edd-622f-4516-9f9a-6eb4349414d6.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b408edd-622f-4516-9f9a-6eb4349414d6.png)'
- en: 'Figure 18: The links page, showing the _HDIV_STATE_ query string'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图18：链接页面，显示_HDIV_STATE_查询字符串
- en: 'As stated in the page, try manipulating the link (change the `_HDIV_STATE_`
    value) and you will be taken to the HDIV error page:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如页面所述，尝试操纵链接（更改“_HDIV_STATE_”值），您将被带到HDIV错误页面：
- en: '![](img/0823acb2-e4c4-4bce-a081-d1fdc3ed267e.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0823acb2-e4c4-4bce-a081-d1fdc3ed267e.png)'
- en: 'Figure 19: The HDIV error page, which displays in the case of error conditions'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图19：HDIV错误页面，在错误条件下显示
- en: 'This example showcases just two of the cases where HDIV shows its worth when
    working alongside Spring Security. For more details, I urge you to look at the
    HDIV website and documentation, which is available here:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了HDIV在与Spring Security一起工作时显示其价值的两种情况。有关更多详细信息，请查看HDIV网站和文档，网址如下：
- en: '[https://hdivsecurity.com/docs/](https://hdivsecurity.com/docs/)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://hdivsecurity.com/docs/](https://hdivsecurity.com/docs/)'
- en: '[https://hdivsecurity.com/docs/installation/library-setup/](https://hdivsecurity.com/docs/installation/library-setup/)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://hdivsecurity.com/docs/installation/library-setup/](https://hdivsecurity.com/docs/installation/library-setup/)'
- en: '[https://github.com/hdiv/hdiv](https://github.com/hdiv/hdiv)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/hdiv/hdiv](https://github.com/hdiv/hdiv)'
- en: Custom DSL
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义DSL
- en: Spring Security allows you to write your own **Domain Specific Language** (**DSL**),
    which can be used to configure security in your application. We have already seen
    a custom DSL in action when we implemented SAML authentication using OKTA. We
    used an OKTA-provided custom DSL to configure Spring Security.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security允许您编写自己的**领域特定语言**（**DSL**），该语言可用于配置应用程序中的安全性。当我们使用OKTA实现SAML身份验证时，我们已经看到了自定义DSL的实际应用。我们使用了由OKTA提供的自定义DSL来配置Spring
    Security。
- en: 'To write your own custom DSL, you can extend the `AbstractHttpConfigurer` *class *and
    override a few of it''s methods, as shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写自己的自定义DSL，您可以扩展`AbstractHttpConfigurer` *类*并覆盖其中的一些方法，如下所示：
- en: '[PRE43]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In your Spring Security configuration class (the configure method), you can
    then use your custom DSL, as shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Spring Security配置类（configure方法）中，您可以使用自定义DSL，如下所示：
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When Spring Security sees a custom DSL setup, the execution of code is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring Security看到自定义DSL设置时，代码的执行顺序如下：
- en: Invoke the Spring Security configuration class's `configure` method
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用Spring Security配置类的`configure`方法
- en: Invoke the custom DSL `init` method
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用自定义DSL的`init`方法
- en: Invoke the custom DSL `configure` method
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用自定义DSL的`configure`方法
- en: Spring Security uses this approach to implement `authorizeRequests()`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security使用这种方法来实现`authorizeRequests()`。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to some of the other capabilities of Spring Security
    that can be used in your application. Using examples, we covered how to achieve
    remember-me functionality in your application. We also touched briefly upon concepts
    such as CSRF, CORS, CSP, channel security, and session management. We also covered
    the Crypto module in Spring Security concisely.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Spring Security的一些其他功能，这些功能可以在您的应用程序中使用。通过示例，我们介绍了如何在应用程序中实现记住我功能。我们还简要涉及了CSRF、CORS、CSP、通道安全和会话管理等概念。我们还简要介绍了Spring
    Security中的加密模块。
- en: We wrapped up the chapter by introducing two products that can work along with
    Spring Security—HashiCorp Vault (for secret management) and HDIV (for additional
    security features).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过介绍了两种可以与Spring Security一起使用的产品来结束了本章——HashiCorp Vault（用于秘密管理）和HDIV（用于附加安全功能）。
- en: After reading this chapter, you should have a clear understanding of some of
    the additional features that can be implemented using Spring Security. You should
    also have a good understanding of some of the products that can be used alongside
    Spring Security to achieve some of the most important technical capabilities that
    are needed for modern applications.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您应该清楚地了解了一些可以使用Spring Security实现的附加功能。您还应该对可以与Spring Security一起使用以实现现代应用程序所需的一些最重要的技术功能有很好的理解。
- en: Now, pat yourself your back if you are reading this, as with this chapter, we
    complete the book. I hope you have enjoyed every bit of this book, and I hope
    you have learned something new that can be used for creating  wonderful and innovative
    new applications.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您正在阅读本章，那么请为自己鼓掌，因为通过本章，我们完成了本书。我希望您已经享受了本书的每一部分，并且希望您已经学到了一些可以用于创建精彩和创新的新应用程序的新知识。
- en: Thank you for reading!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢阅读！
