- en: Deployment and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和测试
- en: In this chapter, we'll continue from where we left off in [Chapter 4](4561ba72-866e-45f9-88ac-761a62242e26.xhtml),
    *Implementing a Microservice*. We'll add a few more services to groom our online
    table reservation system (OTRS) application that only depends on three functional
    services (Restaurant, User, and Booking services) and Eureka (service discovery
    and registration) to create a fully functional microservice stack. This stack
    will have gateway (Zuul), load balancing (Ribbon with Zuul and Eureka), and monitoring
    (Hystrix, Turbine, and the Hystrix dashboard). You want to have composite APIs
    and see how one microservice talks to others. This chapter will also explain how
    to containerize microservices using Docker and how to run multiple containers
    together using `docker-compose`. On top of this, we'll also add the integration
    tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将接着[第4章](4561ba72-866e-45f9-88ac-761a62242e26.xhtml)《实现微服务》的内容继续讲解。我们将向仅依赖于三个功能性服务（餐厅、用户和预订服务）以及Eureka（服务发现和注册）的在线桌位预订系统（OTRS）应用程序添加一些更多服务，以创建一个完全功能的微服务堆栈。这个堆栈将包括网关（Zuul）、负载均衡（Ribbon与Zuul和Eureka）、监控（Hystrix、Turbine和Hystrix仪表板）。你希望拥有组合API，并了解一个微服务如何与其他微服务通信。本章还将解释如何使用Docker容器化微服务，以及如何使用`docker-compose`一起运行多个容器。在此基础上，我们还将添加集成测试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: An overview of microservice architecture using Netflix OSS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Netflix OSS的微服务架构概述
- en: Edge servers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: Load balancing microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡微服务
- en: Circuit breakers and monitoring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器和监控
- en: Microservice deployment using containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器部署微服务
- en: Microservice integration testing using Docker containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器进行微服务集成测试
- en: Mandatory services for good microservices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好的微服务所需的强制服务
- en: 'There are a few patterns/services that should be in place for implementing
    microservice-based design. This list consists of the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现基于微服务的架构设计，应该有一些模式/服务需要到位。这个列表包括以下内容：
- en: Service discovery and registration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现和注册
- en: Edge or proxy server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘或代理服务器
- en: Load balancing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Circuit breaker
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: Monitoring
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: We'll implement these services in this chapter to complete our OTRS system.
    Following is a brief overview. We'll discuss these patterns/services in detail
    later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章实现这些服务，以完成我们的OTRS系统。以下是简要概述。我们稍后详细讨论这些模式/服务。
- en: Service discovery and registration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现和注册
- en: The Netflix Eureka server is used for service discovery and registration. We
    created the Eureka service in the last chapter. It not only allows you to register
    and discover services, but also provides load balancing using Ribbon.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka服务器用于服务发现和注册。我们在上一章创建了Eureka服务。它不仅允许你注册和发现服务，还提供使用Ribbon的负载均衡。
- en: Edge servers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: An edge server provides a single point of access to allow the external world
    to interact with your system. All of your APIs and frontends are only accessible
    using this server. Therefore, these are also referred to as gateway or proxy servers.
    These are configured to route requests to different microservices or frontend
    applications. We'll use the Netflix Zuul server as an edge server in the OTRS
    application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务器提供一个单一的访问点，允许外部世界与你的系统交互。你的所有API和前端都只能通过这个服务器访问。因此，这些也被称为网关或代理服务器。这些被配置为将请求路由到不同的微服务或前端应用程序。在OTRS应用程序中，我们将使用Netflix
    Zuul服务器作为边缘服务器。
- en: Load balancing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Netflix Ribbon is used for load balancing. It is integrated with the Zuul and
    Eureka services to provide load balancing for both internal and external calls.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Ribbon用于负载均衡。它与Zuul和Eureka服务集成，为内部和外部调用提供负载均衡。
- en: Circuit breakers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器
- en: A fault or break should not prevent your whole system from working. Also, the
    repeated failure of a service or an API should be handled properly. Circuit breakers
    provide these features. Netflix Hystrix is used as a circuit breaker and helps
    to keep the system up.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个故障或断裂不应该阻止你的整个系统运行。此外，一个服务或API的反复失败应该得到适当的处理。断路器提供了这些功能。Netflix Hystrix作为断路器使用，有助于保持系统运行。
- en: Monitoring
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: The Hystrix dashboard is used with Netflix Turbine for microservice monitoring.
    It provides a dashboard to check the health of running microservices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Netflix Hystrix仪表板和Netflix Turbine进行微服务监控。它提供了一个仪表板，用于检查运行中微服务的状态。
- en: An overview of microservice architecture using Netflix OSS
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netflix OSS的微服务架构概述
- en: Netflix are pioneers in microservice architecture. They were the first to successfully
    implement microservice architecture on a large scale. They also helped increase
    its popularity and contributed immensely to microservices by open sourcing most
    of their microservice tools with Netflix **Open Source Software Center** (**OSS**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix是微服务架构的先驱。他们是第一个成功在大规模实施微服务架构的人。他们还通过将大部分微服务工具开源，并命名为Netflix **开源软件中心**（**OSS**），极大地提高了微服务的普及程度并做出了巨大贡献。
- en: According to the Netflix blog, when Netflix was developing their platform, they
    used Apache Cassandra for data storage, which is an open source tool from Apache.
    They started contributing to Cassandra with fixes and optimization extensions.
    This led to Netflix seeing the benefits of releasing Netflix projects with the
    name OSS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Netflix的博客，当Netflix开发他们的平台时，他们使用了Apache Cassandra进行数据存储，这是一个来自Apache的开源工具。他们开始通过修复和优化扩展为Cassandra做贡献。这导致了Netflix看到将Netflix项目以OSS的名义发布的益处。
- en: Spring took the opportunity to integrate many Netflix OSS projects, such as
    Zuul, Ribbon, Hystrix, the Eureka server, and Turbine, into Spring Cloud. This
    is one of the reasons Spring Cloud provides a ready-made platform for developing
    production-ready microservices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Spring抓住了机会，将许多Netflix的开源项目（如Zuul、Ribbon、Hystrix、Eureka服务器和Turbine）集成到Spring
    Cloud中。这是Spring Cloud能够为生产就绪的微服务提供现成平台的原因之一。
- en: 'Now, let''s take a look at a few important Netflix tools and how they fit into
    microservice architecture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看几个重要的Netflix工具以及它们如何在微服务架构中发挥作用：
- en: '![](img/451c2530-d3dd-4dca-ab1e-04a6f2c8c0a0.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/451c2530-d3dd-4dca-ab1e-04a6f2c8c0a0.jpg)'
- en: Microservice architecture diagram
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构图
- en: 'As you can see in the preceding diagram, for each of the microservice practices,
    we have a Netflix tool associated with it. We can go through the following mapping
    to understand it. Detailed information is covered in the respective sections of
    this chapter except concerning Eureka, which is elaborated on in the last chapter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图表中所看到的，对于每一种微服务实践，我们都有一个与之相关的Netflix工具。我们可以通过以下映射来了解它。详细信息在本章的相应部分中介绍，关于Eureka的部分在最后一章中有详细说明：
- en: '**Edge server**: We use the Netflix Zuul server as an edge server.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘服务器**：我们使用Netflix Zuul服务器作为边缘服务器。'
- en: '**Load balancing**: Netflix Ribbon is used for load balancing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：Netflix Ribbon用于负载均衡。'
- en: '**Circuit breaker**: Netflix Hystrix is used as a circuit breaker and helps
    to keep the system up.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：Netflix Hystrix用作断路器，有助于保持系统运行。'
- en: '**Service discovery and registration**: The Netflix Eureka server is used for
    service discovery and registration.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现与注册**：Netflix Eureka服务器用于服务发现和注册。'
- en: '**Monitoring dashboard**: The Hystrix dashboard is used with Netflix Turbine
    for microservice monitoring. It provides a dashboard to check the health of running
    microservices.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控仪表板**：Hystrix监控仪表板与Netflix Turbine配合使用，用于微服务监控。它提供了一个仪表板，用于检查运行中微服务的状态。'
- en: Load balancing
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Load balancing is required to service requests in a manner that maximizes speed
    and capacity utilization, and it makes sure that no server is overloaded with
    requests. The load balancer also redirects requests to the remaining host servers
    if a server goes down. In microservice architecture, a microservice can serve
    internal or external requests. Based on this, we can have two types of load balancing—client-side
    and server-side load balancing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡是服务于请求的方式，以最大化速度和容量利用率，并确保没有服务器因请求过多而超载。负载均衡器还将请求重定向到其他主机服务器，如果服务器宕机的话。在微服务架构中，微服务可以服务于内部或外部请求。基于这一点，我们可以有两种类型的负载均衡——客户端负载均衡和服务器端负载均衡。
- en: Server-side load balancing
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端负载均衡
- en: We'll discuss server-side load balancing; before that, we'll discuss routing.
    It is important to define the routing mechanism for our OTRS application from
    the microservice architecture point of view. For example, `/` (root) could be
    mapped to our UI application. Similarly, `/restaurantapi` and `/userapi` could
    be mapped to the Restaurant service and User service respectively. The edge server
    also performs routing with load balancing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论服务器端负载均衡；在那之前，我们先讨论路由。从微服务架构的角度来看，为我们的OTRS应用程序定义路由机制是很重要的。例如，`/`（根）可以映射到我们的UI应用程序。同样，`/restaurantapi`和`/userapi`可以分别映射到餐厅服务和用户服务。边缘服务器也执行带有负载均衡的路由。
- en: We'll use the Netflix Zuul server as our edge server. Zuul is a JVM-based router
    and server-side load balancer. Zuul supports any JVM language for writing rules
    and filters and has built-in support for Java and Groovy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Netflix Zuul 服务器作为我们的边缘服务器。Zuul 是一个基于 JVM 的路由和服务器端负载均衡器。Zuul 支持用任何 JVM
    语言编写规则和过滤器，并内置了对 Java 和 Groovy 的支持。
- en: Netflix Zuul, by default, has discovery client (Eureka client) support. Zuul
    also makes use of Ribbon and Eureka for load balancing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Zuul 默认具有发现客户端（Eureka 客户端）支持。Zuul 还利用 Ribbon 和 Eureka 进行负载均衡。
- en: The external world (the UI and other clients) calls the edge server, which uses
    the routes defined in `application.yml` to call internal services and provide
    the response. Your guess is right if you think it acts as a proxy server, carries
    gateway responsibility for internal networks, and calls internal services for
    defined and configured routes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 外部世界（UI 和其他客户端）调用边缘服务器，使用`application.yml`中定义的路线调用内部服务并提供响应。如果您认为它充当代理服务器，为内部网络承担网关责任，并且为定义和配置的路线调用内部服务，那么您的猜测是正确的。
- en: Normally, it is recommended to have a single edge server for all requests. However,
    a few companies use a single edge server per client to scale. For example, Netflix
    uses a dedicated edge server for each device type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，建议对所有请求使用单个边缘服务器。然而，一些公司为了扩展，每个客户端使用一个边缘服务器。例如，Netflix 为每种设备类型使用一个专用的边缘服务器。
- en: An edge server will also be used in the next chapter, when we configure and
    implement microservice security.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们配置和实现微服务安全时，也将使用边缘服务器。
- en: 'Configuring and using the edge server is pretty simple in Spring Cloud. You
    need to perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Cloud 中配置和使用边缘服务器相当简单。您需要执行以下步骤：
- en: 'Define the Zuul server dependency in the `pom.xml` file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件中定义 Zuul 服务器依赖项：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Use the `@EnableZuulProxy` annotation in your application class. It also internally
    uses the `@EnableDiscoveryClient` annotation; therefore, it is also registered
    to the Eureka server automatically. You can find the registered Zuul server in
    the figure in *Client-side load balancing section*.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序类中使用`@EnableZuulProxy`注解。它还内部使用`@EnableDiscoveryClient`注解；因此，它也会自动注册到
    Eureka 服务器。您可以在*客户端负载均衡部分*的图中找到注册的 Zuul 服务器。
- en: 'Update the Zuul configuration in the `application.yml` file, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`application.yml`文件中的 Zuul 配置，如下所示：
- en: '`zuul:ignoredServices`: This skips the automatic addition of services. We can
    define service ID patterns here. The `*` denotes that we are ignoring all services.
    In the following sample, all services are ignored except `restaurant-service`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zuul:ignoredServices`：这跳过了服务的自动添加。我们可以在这里定义服务ID模式。`*`表示我们忽略所有服务。在下面的示例中，除了`restaurant-service`，所有服务都被忽略。'
- en: '`Zuul.routes`: This contains the `path` attribute that defines the URI''s pattern.
    Here, `/restaurantapi` is mapped to `restaurant-service` using the `serviceId`
    attribute. The `serviceId` attribute represents the service in the Eureka server.
    You can use a URL in place of a service, if the Eureka server is not used. We
    have also used the `stripPrefix` attribute to strip the prefix (`/restaurantapi`),
    and the resultant `/restaurantapi/v1/restaurants/1` call converts to `/v1/restaurants/1`
    while calling the service:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zuul.routes`：这包含定义 URI 模式的`path`属性。在这里，`/restaurantapi`通过`serviceId`属性映射到`restaurant-service`。`serviceId`属性代表
    Eureka 服务器中的服务。如果未使用 Eureka 服务器，可以使用 URL 代替服务。我们还使用了`stripPrefix`属性来去除前缀（`/restaurantapi`），结果`/restaurantapi/v1/restaurants/1`调用转换为在调用服务时`/v1/restaurants/1`:'
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Please note that Eureka applications only register a single instance of any
    service for each host. You need to use the following value for `metadataMap.instanceid`
    to register multiple instances of the same application on one host for load balancing
    to work:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Eureka 应用程序只在每台主机上注册任何服务的单个实例。您需要为`metadataMap.instanceid`使用以下值，以便在同一台主机上注册同一应用程序的多个实例，以便负载均衡工作：
- en: '`${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}`'
- en: 'Let''s see a working edge server. First, we''ll call the Restaurant service
    deployed on port `3402`, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个工作的边缘服务器。首先，我们将按照以下方式调用端口`3402`上部署的餐厅服务：
- en: '![](img/96fe451a-e8c4-48fc-b80a-a09784c1795b.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96fe451a-e8c4-48fc-b80a-a09784c1795b.png)'
- en: Direct Restaurant service call
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用餐厅服务
- en: 'Then, we''ll call the same service using the edge server that is deployed on
    port `8765`. You can see that the `/restaurantapi` prefix is used for calling
    `/v1/restaurants?name=o`, and it gives the same result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用部署在端口`8765`的边缘服务器调用同一服务。你可以看到，调用`/v1/restaurants?name=o`时使用了`/restaurantapi`前缀，并且给出了相同的结果：
- en: '![](img/6202f3a7-e83f-4f7f-a992-5f153e395f66.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6202f3a7-e83f-4f7f-a992-5f153e395f66.png)'
- en: Restaurant Service call using the edge server
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边缘服务器调用餐厅服务
- en: Client-side load balancing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端负载均衡
- en: Microservices need interprocess communication so that services can communicate
    with each other. Spring Cloud uses Netflix Ribbon, a client-side load balancer
    that plays this critical role and can handle both HTTP and TCP. Ribbon is cloud-enabled
    and provides built-in failure resiliency. Ribbon also allows you to use multiple
    and pluggable load balancing rules. It integrates clients with load balancers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务需要进程间通信，以便服务能够相互通信。Spring Cloud使用Netflix Ribbon，这是一个客户端负载均衡器，扮演着这一关键角色，并可以处理HTTP和TCP。Ribbon是云兼容的，并提供了内置的故障弹性。Ribbon还允许你使用多个可插拔的负载均衡规则。它将客户端与负载均衡器集成在一起。
- en: 'In the last chapter, we added the Eureka server. Ribbon is integrated with
    the Eureka server in Spring Cloud by default. This integration provides the following
    features:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们添加了Eureka服务器。Spring Cloud默认通过Ribbon与Eureka服务器集成。这种集成提供了以下功能：
- en: You don't need to hardcode remote server URLs for discovery when the Eureka
    server is used. This is a prominent advantage, although you can still use the
    configured server list (`listOfServers`) in the `application.yml` file if required.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用Eureka服务器时，你不需要硬编码远程服务器URL进行发现。这是一个显著的优势，尽管如果你需要，你仍然可以使用`application.yml`文件中配置的服务器列表（`listOfServers`）。
- en: The server list gets populated from the Eureka server. The Eureka server overrides
    `ribbonServerList` with the `DiscoveryEnabledNIWSServerList` interface.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器列表从Eureka服务器获取。Eureka服务器用`DiscoveryEnabledNIWSServerList`接口覆盖了`ribbonServerList`。
- en: The request to find out whether the server is up is delegated to Eureka. The
    `DiscoveryEnabledNIWSServerList` interface is used in place of Ribbon's `IPing`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找服务器是否运行的请求被委托给Eureka。这里使用了`DiscoveryEnabledNIWSServerList`接口来代替Ribbon的`IPing`。
- en: There are different clients available in Spring Cloud that use Ribbon, such
    as `RestTemplate` or `FeignClient`. These clients allow microservices to communicate
    with each other. Clients use instance IDs in place of hostnames and ports for
    making an HTTP call to service instances when the Eureka server is used. The client
    passes the service ID to Ribbon and it then uses the load balancer to pick the
    instance from the Eureka server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud中，使用Ribbon有不同的客户端可供选择，比如`RestTemplate`或`FeignClient`。这些客户端使得微服务之间能够相互通信。当使用Eureka服务器时，客户端使用实例ID代替主机名和端口来对服务实例进行HTTP调用。客户端将服务ID传递给Ribbon，然后Ribbon使用负载均衡器从Eureka服务器中选择实例。
- en: 'If there are multiple instances of services available in Eureka, as shown in
    the following screenshot, Ribbon picks only one for the request, based on load
    balancing algorithms:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下屏幕截图所示，如果Eureka中有多个服务实例可用，Ribbon根据负载均衡算法只为请求选择一个：
- en: '![](img/ff86c7a3-c57c-4228-b6a2-5b87de6eacea.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff86c7a3-c57c-4228-b6a2-5b87de6eacea.png)'
- en: Multiple service registration - Restaurant service
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 多服务注册 - 餐厅服务
- en: We can use the `DiscoveryClient` to find all of the available service instances
    in the Eureka server, as shown in the following code. The `getLocalServiceInstance()`
    method of the `DiscoveryClientSample` class returns all of the local service instances
    available in the Eureka server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`DiscoveryClient`来查找Eureka服务器中所有可用的服务实例，如下面的代码所示。`DiscoveryClientSample`类中的`getLocalServiceInstance()`方法返回Eureka服务器中所有可用的本地服务实例。
- en: 'This is the `DiscoveryClient` sample:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`DiscoveryClient`示例：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When executed, this code prints the following information. It shows two instances
    of the Restaurant service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，它会打印以下信息。它显示了餐厅服务的两个实例：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following samples showcase how these clients can be used. You can see that
    in both clients, the service name `restaurant-service` is used in place of a service
    hostname and port. These clients call `/v1/restaurants` to get a list of restaurants
    containing the name given in the name query parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了这些客户端如何使用。你可以在两个客户端中看到，服务名称`restaurant-service`被用来代替服务主机名和端口。这些客户端调用`/v1/restaurants`来获取包含在名称查询参数中的餐厅名称的餐厅列表。
- en: 'This is the`RestTemplate` sample:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`RestTemplate`示例：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the`FeignClient` sample:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`FeignClient`示例：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All preceding examples will print the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的示例都将打印以下输出：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For demonstration purposes, we have added all clients—`discovery` client, `RestTemplate`
    client, and `FeignClient` added in the edge application main class Java file.
    Since we have all of these clients implementing the `CommandLineRunner` interface,
    this gets executed immediately after the edge application service starts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们在边缘应用程序主类Java文件中添加了所有客户端—`discovery`客户端、`RestTemplate`客户端和`FeignClient`。由于我们所有这些客户端都实现了`CommandLineRunner`接口，这会在边缘应用程序服务启动后立即执行。
- en: Circuit breakers and monitoring
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器与监控
- en: In general terms, a circuit breaker is a*n automatic device for stopping the
    flow of current in an electric circuit as a safety measure.*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常而言，断路器是一种*自动装置，用于在电气电路中作为安全措施停止电流的流动*。
- en: The same concept is used for microservice development, known as the **circuit
    breaker** design pattern. It tracks the availability of external services such
    as the Eureka server, API services such as `restaurant-service`, and so on, and
    prevents service consumers from performing any action on any service that is not
    available.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的概念也用于微服务开发，称为**断路器**设计模式。它跟踪外部服务的可用性，如Eureka服务器、API服务如`restaurant-service`等，并防止服务消费者对任何不可用的服务执行任何操作。
- en: It is another important aspect of microservice architecture, a safety measure
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务架构的另一个重要方面，一种安全措施
- en: (failsafe mechanism) when the service does not respond to a call made by the
    service consumer, which is called a circuit breaker.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: （安全机制）当服务消费者对服务的调用没有响应时，这称为断路器。
- en: We'll use Netflix Hystrix as a circuit breaker. It calls the internal fallback
    method in the service consumer when failures occur (for example, due to a communication
    error or timeout). It executes embedded within its consumer of service. In the
    next section, you will find the code that implements this feature.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Netflix Hystrix作为断路器。当发生故障时（例如，由于通信错误或超时），它在服务消费者内部调用回退方法。它在服务消费者内执行。在下一节中，您将找到实现此功能的代码。
- en: Hystrix opens the circuit and failfast when the service fails to respond repeatedly,
    until the service is available again. When calls to a particular service reach
    a certain threshold (the default threshold is 20 failures in five seconds), the
    circuit opens and the call is not made. You must be wondering, if Hystrix opens
    the circuit, then how does it know that the service is available? It exceptionally
    allows some requests to call the service.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix在服务未能响应时打开电路，并在服务再次可用之前快速失败。当对特定服务的调用达到一定阈值（默认阈值是五秒内20次失败），电路打开，调用不再进行。您可能想知道，如果Hystrix打开电路，那么它是如何知道服务可用的？它异常地允许一些请求调用服务。
- en: Using Hystrix's fallback methods
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hystrix的回退方法
- en: 'There are five steps for implementing fallback methods. For this purpose, we''ll
    create another service, `api-service`, in the same way as we have created other
    services. The `api-service` service will consume the other services such as `restaurant-service`
    and so on, and will be configured in the edge server for exposing the OTRS API
    to external use. The five steps are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实现回退方法有五个步骤。为此，我们将创建另一个服务，`api-service`，就像我们创建其他服务一样。`api-service`服务将消费其他服务，如`restaurant-service`等，并将在边缘服务器中配置以对外暴露OTRS
    API。这五个步骤如下：
- en: '**Enable the circuit breaker**: The main class of microservice that consumes
    other services should be annotated with `@EnableCircuitBreaker`. Therefore, we''ll
    annotate `src\main\java\com\packtpub\mmj\api\service\ApiApp.java`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用断路器**：主要消费其他服务的微服务类应该用`@EnableCircuitBreaker`注解标记。因此，我们将注释`src\main\java\com\packtpub\mmj\api\service\ApiApp.java`：'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Configure the fallback method**: The annotation `@HystrixCommand` is used
    to configure the `fallbackMethod`. We''ll annotate controller methods to configure
    the fallback methods. This is the file: `src\main\java\com\packtpub\mmj\api\service\restaurant\RestaurantServiceAPI.java`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置回退方法**：用`@HystrixCommand`注解来配置`fallbackMethod`。我们将注释控制器方法来配置回退方法。这是文件：`src\main\java\com\packtpub\mmj\api\service\restaurant\RestaurantServiceAPI.java`：'
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Define the fallback method**: A method that handles the failure and performs
    the steps for safety. Here, we have just added a sample; this can be modified
    based on the way we want to handle the failure:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义回退方法**：处理失败并执行安全步骤的方法。在这里，我们只是添加了一个示例；这可以根据我们想要处理失败的方式进行修改：'
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Maven dependencies**: We need to add the following dependencies in `pom.xml`
    for an API service or in a project in which we want to failsafe API calls:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Maven依赖项**：我们需要在`pom.xml`中为API服务或希望确保API调用的项目中添加以下依赖项：'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Configuring Hystrix in `application.yml`**: We will add the following Hystrix
    properties in our `application.yml` file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在`application.yml`中配置Hystrix**：我们将在我们的`application.yml`文件中添加以下Hystrix属性：'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These steps should be enough to failsafe the service calls and return a more
    appropriate response to the service consumer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤应该足以确保服务调用的安全，并向服务消费者返回一个更合适的响应。
- en: Monitoring
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: 'Hystrix provides a dashboard with a web UI that provides nice graphics of circuit
    breakers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix提供了一个带有web UI的仪表板，提供很好的电路断路器图形：
- en: '![](img/88b20511-ffd5-4562-979d-50210d86d46c.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88b20511-ffd5-4562-979d-50210d86d46c.jpg)'
- en: Default Hystrix dashboard
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Hystrix仪表板
- en: Netflix Turbine is a web application that connects to the instances of your
    Hystrix applications in a cluster and aggregates information, which it does in
    real time (updated every 0.5 seconds). Turbine provides information using a stream
    that is known as a Turbine stream.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Turbine是一个web应用程序，它连接到Hystrix应用程序集群的实例并聚合信息，实时进行（每0.5秒更新一次）。Turbine使用称为Turbine流的流提供信息。
- en: If you combine Hystrix with Netflix Turbine, then you can get all of the information
    from the Eureka server on the Hystrix dashboard. This gives you a landscape view
    of all of the information about the circuit breakers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将Hystrix与Netflix Turbine结合使用，那么你可以在Hystrix仪表板上获取Eureka服务器上的所有信息。这为你提供了有关所有电路断路器的信息的全景视图。
- en: To use Turbine with Hystrix, just type in the Turbine URL `http://localhost:8989/turbine.stream`
    (port `8989` is configured for the Turbine server in `application.yml`) in the
    first textbox shown in the preceding screenshot, and click on Monitor Stream.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Turbine和Hystrix，只需在前面截图中的第一个文本框中输入Turbine的URL`http://localhost:8989/turbine.stream`（在`application.yml`中为Turbine服务器配置了端口`8989`），然后点击监控流。
- en: Netflix Hystrix and Turbine use RabbitMQ, an open source message queuing software.
    RabbitMQ works on **Advance Messaging Queue Protocol** (**AMQP**). It is a software
    in which queues can be defined and used by connected applications to exchange
    messages. A message can include any kind of information. A message can be stored
    in the RabbitMQ queue until a receiver application connects and consumes the message
    (taking the message off the queue).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Hystrix和Turbine使用RabbitMQ，这是一个开源的消息队列软件。RabbitMQ基于**高级消息队列协议**（**AMQP**）工作。这是一个软件，在此软件中可以定义队列并由连接的应用程序交换消息。消息可以包含任何类型的信息。消息可以存储在RabbitMQ队列中，直到接收应用程序连接并消耗消息（将消息从队列中移除）。
- en: Hystrix uses RabbitMQ to send metrics data feed to Turbine.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix使用RabbitMQ将度量数据发送到Turbine。
- en: Before we configure Hystrix and Turbine, please install the RabbitMQ application
    on your platform. Hystrix and Turbine use RabbitMQ to communicate between themselves.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置Hystrix和Turbine之前，请在你的平台上演示安装RabbitMQ应用程序。Hystrix和Turbine使用RabbitMQ彼此之间进行通信。
- en: Setting up the Hystrix dashboard
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Hystrix仪表板
- en: We'll create another project in the IDE for the Hystrix dashboard in the same
    way as we created other services. Inside this new project, we'll add the new Maven
    dependency, `dashboard-server`, for the Hystrix server. Configuring and using
    the Hystrix dashboard is pretty simple in Spring Cloud.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在IDE中创建另一个项目，以与创建其他服务相同的方式创建Hystrix仪表板。在这个新项目中，我们将添加新的Maven依赖项`dashboard-server`，用于Hystrix服务器。在Spring
    Cloud中配置和使用Hystrix仪表板相当简单。
- en: 'When you run the Hystrix dashboard application, it will look like the default
    Hystrix dashboard screenshot shown earlier. You just need to follow these steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行Hystrix仪表板应用程序时，它会看起来像前面所示的默认Hystrix仪表板快照。你只需要按照以下步骤操作：
- en: 'Define the Hystrix dashboard dependency in the `pom.xml` file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件中定义Hystrix仪表板依赖项：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `@EnableHystrixDashboard` annotation in the main Java class does everything
    for you to use it. We''ll also use the `@Controller` to forward the request from
    the root URI to the Hystrix dashboard UI URI (`/hystrix`), as shown here:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主Java类中的`@EnableHystrixDashboard`注解为您使用它做了所有事情。我们还将使用`@Controller`将根URI的请求转发到Hystrix仪表板UI
    URI（`/hystrix`），如下所示：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update the dashboard application configuration in `application.yml`, as shown
    here:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如所示更新`application.yml`中的仪表板应用程序配置：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating Turbine services
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Turbine服务
- en: Turbine aggregates all `/hystrix.stream` endpoints into a combined `/turbine.stream`
    for use in the Hystrix dashboard, which is more helpful as it allows to see the
    overall health of the system in a single dashboard rather than monitoring the
    individual services using `/hystrix.stream`. We'll create another service project
    in the IDE like the others. Then, we'll add Maven dependencies for Turbine in
    `pom.xml`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Turbine将所有`/hystrix.stream`端点聚合成一个合并的`/turbine.stream`，以供Hystrix仪表板使用，这更有助于查看系统的整体健康状况，而不是使用`/hystrix.stream`监视各个服务。我们将在IDE中创建另一个服务项目，然后在`pom.xml`中为Turbine添加Maven依赖项。
- en: 'Now, we will configure the Turbine server using the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下步骤配置Turbine服务器：
- en: 'Define the Turbine Server dependency in `pom.xml`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`中定义Turbine服务器的依赖项：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Use the `@EnableTurbineStream` annotation in your application class, as
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序类中使用`@EnableTurbineStream`注解，如
- en: 'shown here. We are also defining a bean that will return the RabbitMQ `ConnectionFactory`:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此处显示。我们还定义了一个将返回RabbitMQ `ConnectionFactory`的Bean：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update the Turbine configuration in `application.yml`, as shown here:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据下面所示，更新`application.yml`中的Turbine配置：
- en: '`server:port`: The main port used by the the Turbine HTTP'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server:port`：Turbine HTTP使用的主要端口'
- en: '`management:port`: Port of Turbine actuator endpoints:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`management:port`：Turbine执行器端点的端口：'
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Earlier, we have added the User and Restaurant services in a cluster using the
    `turbine.aggregator.clusterConfig` property. Here, values are in uppercase because
    Eureka returns the service names in capital letters. Also, the `turbine.appConfig`
    property contains the list of the Eureka service IDs that will be used by the
    Turbine to look up instances. Please be aware that the preceding steps always
    create the respective servers with default configurations. If required, you can
    override the default configuration with specific settings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用`turbine.aggregator.clusterConfig`属性将用户和餐厅服务添加到一个集群中。这里，值以大写字母表示，因为Eureka以大写字母返回服务名称。而且，`turbine.appConfig`属性包含了Turbine用来查找实例的Eureka服务ID列表。请注意，之前的步骤总是使用默认配置创建了相应的服务器。如有需要，可以使用特定设置覆盖默认配置。
- en: Building and running the OTRS application
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行OTRS应用程序
- en: 'Build all of the projects using `mvn clean install` using the following file:
    `..\Chapter5 \pom.xml`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下文件：`..\Chapter5 \pom.xml`，使用`mvn clean install`构建所有项目。
- en: 'The output should look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, on command prompt, go to `<path to source>/6392_chapter5` and run the
    following commands:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，命令提示符上进入`<path to source>/6392_chapter5`并运行以下命令：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note: Before starting the Zuul service, please make sure that all of the services
    are up in the Eureka dashboard: `http://localhost:8761/`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在启动Zuul服务之前，请确保Eureka仪表板上的所有服务都处于启动状态：`http://localhost:8761/`：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, check the Eureka dashboard that all applications should be up. Then,
    perform the testing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查Eureka仪表板，所有应用程序都应该处于启动状态。然后进行测试。
- en: Microservice deployment using containers
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器部署微服务
- en: You might have got the point about Docker after reading [Chapter 1](8ea8ade6-8194-4739-94ed-92454e884d9d.xhtml),
    *A Solution Approach*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 读完[第1章](8ea8ade6-8194-4739-94ed-92454e884d9d.xhtml)《解决方案方法》后，您可能已经理解了Docker的要点。
- en: A Docker container provides a lightweight runtime environment, consisting of
    the core features of a virtual machine and the isolated services of operating
    systems, known as a Docker image. Docker makes the packaging and execution of
    microservices easier and smoother. Each operating system can have multiple Dockers,
    and each Docker can run single application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器提供了一个轻量级的运行时环境，由虚拟机的核心功能和操作系统的隔离服务组成，称为Docker镜像。Docker使微服务的打包和执行变得更加简单。每个操作系统可以有多个Docker，每个Docker可以运行单个应用程序。
- en: Installation and configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装与配置
- en: Docker needs a virtualized server if you are not using a Linux OS. You can install
    VirtualBox or similar tools such as Docker Toolbox to make it work for you. The
    Docker installation page gives more details about it and lets you know how to
    do it. So, leave it to the Docker installation guide available on Docker's website.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Linux操作系统，Docker需要一个虚拟化服务器。您可以安装VirtualBox或类似的工具，如Docker Toolbox，使其适用于您。Docker安装页面提供了更多关于它的细节，并告诉您如何执行。所以，请参考Docker网站上的Docker安装指南。
- en: 'You can install Docker, based on your platform, by following the instructions
    given at: [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据你的平台，通过遵循给出的说明安装Docker：[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)。
- en: DockerToolbox-1.9.1f was the latest version available at the time of writing.
    This is the version we used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: DockerToolbox-1.9.1f是在写作时可用的最新版本。这个版本我们使用了。
- en: Docker machine with 4 GB
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有4GB内存的Docker虚拟机
- en: 'Default machines are created with 2 GB of memory. We''ll recreate a Docker
    machine with 4 GB of memory:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的虚拟机创建时会分配2GB的内存。我们将重新创建一个具有4GB内存的Docker虚拟机：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Building Docker images with Maven
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven构建Docker镜像
- en: 'There are various Docker Maven plugins that can be used:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种Docker Maven插件可以使用：
- en: '[https://github.com/rhuss/docker-maven-plugin](https://github.com/rhuss/docker-maven-plugin)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/rhuss/docker-maven-plugin](https://github.com/rhuss/docker-maven-plugin)'
- en: '[https://github.com/alexec/docker-maven-plugin](https://github.com/alexec/docker-maven-plugin)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/alexec/docker-maven-plugin](https://github.com/alexec/docker-maven-plugin)'
- en: '[https://github.com/spotify/docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/spotify/docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)'
- en: You can use any of these, based on your choice. I found the Docker Maven plugin
    by `@rhuss` to be best suited for us. It is updated regularly and has many extra
    features when compared to the others.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据你的选择使用这些方法中的任何一个。我发现由`@rhuss`编写的Docker Maven插件最适合我们使用。这个插件定期更新，并且相比其他插件拥有许多额外的功能。
- en: 'We need to introduce the Docker Spring profile in `application.yml` before
    we start discussing the configuration of `docker-maven-plugin`. It will make our
    job easier when building services for various platforms. We need to configure
    the following four properties:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论`docker-maven-plugin`的配置之前，我们需要在`application.yml`中引入Docker Spring配置文件。这样我们在为不同平台构建服务时，工作会更加容易。我们需要配置以下四个属性：
- en: We'll use the Spring profile identified as Docker.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用标识为Docker的Spring配置文件。
- en: There won't be any conflict of ports among embedded Tomcat, since services will
    be executed in their own respective containers. We can now use port `8080`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务将在它们自己的容器中执行，所以嵌入式Tomcat之间不会有端口冲突。现在我们可以使用端口`8080`。
- en: We will prefer to use an IP address to register our services in Eureka. Therefore,
    the Eureka instance property `preferIpAddress` will be set to `true`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更倾向于使用IP地址来在我们的Eureka中注册服务。因此，Eureka实例属性`preferIpAddress`将被设置为`true`。
- en: Finally, we'll use the Eureka server hostname in `serviceUrl:defaultZone`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将在`serviceUrl:defaultZone`中使用Eureka服务器的主机名。
- en: 'To add a Spring profile in your project, add the following lines in `application.yml`
    after the existing content:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的项目中添加Spring配置文件，请在`application.yml`中现有内容之后添加以下行：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `mvn -P docker clean package` command will generate the `service` JAR with
    Tomcat's `8080` port and will get registered on the Eureka Server with the hostname
    `eureka`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令`mvn -P docker clean package`将生成带有Tomcat的`8080`端口的`service` JAR，并且该JAR会在Eureka服务器上以主机名`eureka`注册。
- en: 'Now, let''s configure the `docker-maven-plugin` to build the image with our
    restaurant microservice. This plugin has to create a Dockerfile first. The Dockerfile
    is configured in two places—in the `pom.xml` and `docker-assembly.xml` files.
    We''ll use the following plugin configuration in `pom.xml`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置`docker-maven-plugin`以构建带有我们的餐厅微服务的镜像。这个插件首先必须创建一个Dockerfile。Dockerfile在两个地方配置——在`pom.xml`和`docker-assembly.xml`文件中。我们将在`pom.xml`文件中使用以下的插件配置：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a Dockerfile before the Docker Maven plugin configuration that extends
    the JRE 8 (`java:8-jre`) base image. This exposes ports `8080` and `8081`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Maven插件配置之前创建一个Dockerfile，该Dockerfile扩展了JRE 8（`java:8-jre`）的基础镜像。这个镜像暴露了端口`8080`和`8081`。
- en: 'Next, we''ll configure the `docker-assembly.xml` file, which tells the plugin
    which files should be put into the container. It will be placed under the `src/main/docker`
    directory:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置`docker-assembly.xml`文件，该文件告诉插件哪些文件应该被放入容器中。这个文件将被放置在`src/main/docker`目录下：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding assembly, adds the `service` JAR and the `docker-config.yml`
    file in the generated Dockerfile. This Dockerfile is located under `target/docker/`.
    On opening this file, you will find the content to be similar to this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的组装，在生成的Dockerfile中添加了`service` JAR和`docker-config.yml`文件。这个Dockerfile位于`target/docker/`目录下。打开这个文件，你会发现内容与这个类似：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding file can be found in the `restaurant-service\target\docker\sousharm\restaurant-service\PACKT-SNAPSHOT\build`
    directory. The `build` directory also contains the `maven` directory, which contains
    everything mentioned in the `docker-assembly.xml` file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的文件可以在 `restaurant-service\target\docker\sousharm\restaurant-service\PACKT-SNAPSHOT\build`
    目录中找到。`build` 目录还包含 `maven` 目录，其中包含 `docker-assembly.xml` 文件中提到的所有内容。
- en: 'Let''s build the Docker image:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来构建 Docker 镜像：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once this command completes, we can validate the image in the local repository
    using Docker images, or by running the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此命令完成，我们可以使用 Docker 镜像在本地仓库中验证镜像，或者通过运行以下命令来实现：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use `-it` to execute this command in the foreground, in place of `-d`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-it` 来在前台执行此命令，而不是 `-d`。
- en: Running Docker using Maven
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven 运行 Docker
- en: 'To execute a Docker image with Maven, we need to add the following configuration
    in the `pom.xml` file. The `<run>` block, to be put where we marked the `To Do`
    under the image block of `docker-maven-plugin` section in the `pom.xml` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要用 Maven 执行 Docker 镜像，我们需要在 `pom.xml` 文件中添加以下配置。`<run>` 块，放在 `pom.xml` 文件中 `docker-maven-plugin`
    部分下的 `docker-maven-plugin` 块中标记的 `To Do` 下面：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have defined the parameters for running our Restaurant service container.
    We have mapped Docker container ports `8080` and `8081` to the host system's ports,
    which allows us to access the service. Similarly, we have also bound the container's
    `log` directory to the host system's `<home>/logs` directory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已经定义了运行我们的 Restaurant 服务容器的参数。我们将 Docker 容器端口 `8080` 和 `8081` 映射到宿主系统的端口，这使我们能够访问服务。同样，我们也将容器的
    `log` 目录绑定到宿主系统的 `<home>/logs` 目录。
- en: The Docker Maven plugin can detect whether the container has finished starting
    up by polling the ping URL of the admin backend until it receives an answer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Maven 插件可以通过轮询管理后端的 ping URL 来检测容器是否已完成启动。
- en: Please note that the Docker host is not localhost if you are using DockerToolbox
    or boot2docker on Windows or MacOS X. You can check the Docker image IP by executing
    `docker-machine ip default`. It is also shown while starting up.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在 Windows 或 MacOS X 上使用 DockerToolbox 或 boot2docker，Docker 主机不是 localhost。您可以执行
    `docker-machine ip default` 来检查 Docker 镜像 IP。在启动时也会显示。
- en: 'The Docker container is ready to start. Use the following command to start
    it using Maven:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器准备启动。使用以下命令使用 Maven 启动它：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Integration testing with Docker
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 进行集成测试
- en: 'Starting and stopping a Docker container can be done by binding the following
    executions to the `docker-maven-plugin` life cycle phase in `pom.xml`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 启动和停止 Docker 容器可以通过在 `pom.xml` 文件中的 `docker-maven-plugin` 生命周期阶段绑定以下执行来实现：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will now configure the Failsafe plugin to perform integration testing with
    Docker. This allows us to execute the integration tests. We are passing the service
    URL in the `service.url` tag, so that our integration test can use it to perform
    integration testing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将配置 Failsafe 插件，使用 Docker 执行集成测试。这允许我们执行集成测试。我们在 `service.url` 标签中传递了服务
    URL，这样我们的集成测试就可以使用它来执行集成测试。
- en: 'We''ll use the `DockerIntegrationTest` marker to mark our Docker integration
    tests. It is defined as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `DockerIntegrationTest` 标记来标记我们的 Docker 集成测试。它定义如下：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Look at the following integration `plugin` code. You can see that `DockerIT`
    is configured for the inclusion of integration tests (Failsafe plugin), whereas
    it is used for excluding in unit tests (Surefire plugin):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的集成 `plugin` 代码。你可以看到 `DockerIT` 被配置为包含集成测试（Failsafe 插件），而它被用于在单元测试中排除（Surefire
    插件）：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A simple integration test looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的集成测试看起来像这样：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can use the following command to perform integration testing using Maven
    (please make sure to run `mvn clean install` from the root of the project directory
    before running integration tests):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令执行使用 Maven 的集成测试（请确保在运行集成测试之前从项目目录的根目录运行 `mvn clean install`）：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Pushing the image to a registry
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将镜像推送到注册表
- en: 'Add the following tags under `docker-maven-plugin` to publish the Docker image
    to the Docker hub:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker-maven-plugin` 下添加以下标签以将 Docker 镜像发布到 Docker hub：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can skip JAR publishing by using the following configuration for `maven-deploy-plugin`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用以下配置跳过 JAR 发布，为 `maven-deploy-plugin`：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Publishing a Docker image in the Docker hub also requires a username and password:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker hub 发布 Docker 镜像也需要用户名和密码：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also push a Docker image to your own Docker registry. To do this, add
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 Docker 镜像推送到您自己的 Docker 注册表。为此，请添加
- en: the `docker.registry.name` tag, as shown in the following code. For example,
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，添加`docker.registry.name`标签。例如，
- en: if your Docker registry is available at `xyz.domain.com` on port `4994`, then
    define
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Docker注册表可在`xyz.domain.com`端口`4994`上访问，那么定义
- en: 'it by adding the following line of code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下代码行：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This does the job and we can not only deploy, but also test our Dockerized service.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅完成了部署，还可以测试我们的Docker化服务。
- en: Managing Docker containers
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Docker容器
- en: Each microservice will have its own Docker container. Therefore, we'll use `Docker
    Compose` to manage our containers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都将有自己的Docker容器。因此，我们将使用`Docker Compose`来管理我们的容器。
- en: Docker Compose will help us to specify the number of containers and how these
    will be executed. We can specify the Docker image, ports, and each container's
    links to other Docker containers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose将帮助我们指定容器的数量以及这些容器的执行方式。我们可以指定Docker镜像、端口以及每个容器与其他Docker容器的链接。
- en: 'We''ll create a file called `docker-compose.yml` in our root project directory
    and add all of the microservice containers to it. We''ll first specify the Eureka
    server, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在根项目目录中创建一个名为`docker-compose.yml`的文件，并将所有微服务容器添加到其中。我们首先指定Eureka服务器，如下所示：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `image` represents the published Docker image for the Eureka server and
    `ports` represents the mapping between the host being used for executing the Docker
    image and the Docker host.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`image`代表Eureka服务器的发布Docker镜像，`ports`代表执行Docker镜像的主机和Docker主机的映射。
- en: This will start the Eureka server and publish the specified ports for external
    access.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Eureka服务器，并为外部访问发布指定的端口。
- en: 'Now our services can use these containers (dependent containers such as Eureka).
    Let''s see how `restaurant-service` can be linked to dependent containers. It
    is simple; just use the `links` directive:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务可以使用这些容器（如Eureka的依赖容器）。让我们看看`restaurant-service`如何可以链接到依赖容器。很简单；只需使用`links`指令：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding links declaration will update the `/etc/hosts` file in the `restaurant-service`
    container with one line per service that the `restaurant-service` depends on (let''s
    assume the `security` container is also linked), for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述链接声明将更新`restaurant-service`容器中的`/etc/hosts`文件，每个服务占一行，`restaurant-service`依赖的服务（假设`security`容器也链接了），例如：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you don't have a Docker local registry set up, then please do this first
    for issueless or smoother execution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有设置本地Docker注册表，那么为了无问题或更平滑的执行，请先设置。
- en: 'Build the docker local registry by running the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令构建本地Docker注册表：
- en: '**docker run -d -p 5000:5000 --restart=always --name registry registry:2**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker run -d -p 5000:5000 --restart=always --name registry registry:2**'
- en: 'Then, perform push and pull commands for the local images:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为本地镜像执行推送和拉取命令：
- en: '**docker push localhost:5000/sourabhh/restaurant-service:PACKT- SNAPSHOT**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker push localhost:5000/sourabhh/restaurant-service:PACKT-SNAPSHOT**'
- en: '**docker-compose pull**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker-compose pull**'
- en: 'Finally, execute docker-compose:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，执行docker-compose:'
- en: '**docker-compose up -d**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker-compose up -d**'
- en: 'Once all of the microservice containers (service and server) are configured,
    we can start all Docker containers with a single command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有微服务容器（服务和服务器）都配置好了，我们可以用一个命令启动所有Docker容器：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will start up all Docker containers configured in Docker Composer. The
    following command will list them:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Docker Compose中配置的所有Docker容器。以下命令将列出它们：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also check Docker image logs using the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令检查Docker镜像日志：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: References
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'The following links will give you more information:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接将为您提供更多信息：
- en: '**Netflix** **Ribbon**: [https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netflix** **Ribbon**: [https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon)'
- en: '**Netflix** **Zuul**: [https://github.com/Netflix/zuul](https://github.com/Netflix/zuul)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netflix** **Zuul**: [https://github.com/Netflix/zuul](https://github.com/Netflix/zuul)'
- en: '**RabbitMQ**: [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RabbitMQ**: [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)'
- en: '**Hystrix**: [https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hystrix**: [https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix)'
- en: '**Turbine**: [https://github.com/Netflix/Turbine](https://github.com/Netflix/Turbine)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Turbine**: [https://github.com/Netflix/Turbine](https://github.com/Netflix/Turbine)'
- en: '**Docker**: [https://www.docker.com/](https://www.docker.com/)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**: [https://www.docker.com/](https://www.docker.com/)'
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have learned about various microservice management features:
    load balancing, edge (gateway) servers, circuit breakers, and monitoring. You
    should now know how to implement load balancing and routing after going through
    this chapter. We have also learned how edge servers can be set up and configured.
    The failsafe mechanism is another important part that you have learned in this
    chapter. Deployment can be made simple by using Docker or any other container.
    Docker was demonstrated and integrated using Maven Build.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于微服务管理的一系列特性：负载均衡、边缘（网关）服务器、断路器以及监控。在本章学习结束后，你应该知道如何实现负载均衡和路由。我们也学习了如何设置和配置边缘服务器。本章还介绍了另一个重要的安全机制。通过使用Docker或其他容器，可以使部署变得简单。本章通过Maven构建演示并集成了Docker。
- en: From a testing point of view, we performed the integration testing on the Docker
    image of the service. We also explored the way we can write clients such as `RestTemplate`
    and Netflix Feign.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试的角度来看，我们对服务的Docker镜像进行了集成测试。我们还探讨了编写客户端的方法，例如`RestTemplate`和Netflix Feign。
- en: In the next chapter, we will learn to secure the microservices with respect
    to authentication and authorization. We will also explore the other aspects of
    microservice securities.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过身份验证和授权来保护微服务。我们还将探讨微服务安全的其他方面。
