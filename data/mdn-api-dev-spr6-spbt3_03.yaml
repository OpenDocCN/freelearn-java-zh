- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: API Specifications and Implementation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API规范和实现
- en: In previous chapters, we learned about the design aspects of REST APIs and the
    Spring fundamentals required to develop RESTful web services. In this chapter,
    you’ll make use of these two areas to implement REST APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了REST API的设计方面以及开发RESTful Web服务所需的Spring基础知识。在本章中，您将利用这两个领域来实现REST
    API。
- en: We have chosen a design-first approach for implementation to make our development
    process understandable for non-technical stakeholders as well. To make this approach
    possible, we will make use of the **OpenAPI Specification** (**OAS**) to, first,
    design an API and, later, implement it. We will also learn how to handle errors
    that occur while serving the request. In this chapter, we will use the example
    of designing and implementing an API of a sample e-commerce app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了先设计后实现的方法来使我们的开发过程对非技术利益相关者来说也是可理解的。为了使这种方法成为可能，我们将使用**OpenAPI规范**（**OAS**）首先设计一个API，然后实现它。我们还将学习如何处理在处理请求时发生的错误。在本章中，我们将使用设计并实现一个示例电子商务应用程序API的例子。
- en: By the end of this chapter, you should be able to design the API specifications
    and make use of the OpenAPI codegen to generate the code for models and API Java
    interfaces. You will also know how to write the pseudo-Spring controllers to implement
    the API Java interfaces and Global Exception Handler for the web service.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够设计API规范并使用OpenAPI代码生成器生成模型和API Java接口的代码。您还将了解如何编写伪Spring控制器以实现API
    Java接口和Web服务的全局异常处理器。
- en: 'We’ll cover the following topics as part of this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Designing APIs with OAS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAS设计API
- en: Understanding the basic structure of OAS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解OAS的基本结构
- en: Converting OAS to Spring code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将OAS转换为Spring代码
- en: Implementing the OAS code interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现OAS代码接口
- en: Adding a Global Exception Handler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加全局异常处理器
- en: Testing the implementation of the controllers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试控制器的实现
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You need the following to execute the instructions in this and the following
    chapters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下内容来执行本章和以下章节中的说明：
- en: Any Java IDE, such as NetBeans, IntelliJ, or Eclipse
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何Java IDE，例如NetBeans、IntelliJ或Eclipse
- en: '**Java Development Kit** (**JDK**) 17'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java开发工具包**（**JDK**）17'
- en: An internet connection to download the dependencies and Gradle
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接以下载依赖项和Gradle
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03)。
- en: Designing APIs with OAS
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAS设计API
- en: You can directly start coding the API; however, this approach leads to many
    issues, such as frequent modifications, difficulty in API management, and difficulty
    in reviews specifically led by non-technical domain teams. Therefore, you should
    use the **design-first approach**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接开始编写API的代码；然而，这种方法会导致许多问题，例如频繁的修改、API管理的困难以及由非技术领域团队主导的审查困难。因此，您应该使用**先设计后实现的方法**。
- en: The first question that comes to mind is, how can we design REST APIs? You learned
    in [*Chapter 1*](B19349_01.xhtml#_idTextAnchor014), *RESTful Web Service Fundamentals*,
    that there is no existing standard to govern REST API implementation. OAS was
    introduced to solve at least the aspects of the REST API’s specification and description.
    It allows you to write REST APIs in the **YAML Ain’t Markup Language** (**YAML**)
    or **JavaScript Object Notation** (**JSON**) markup languages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个出现在脑海中的问题是，我们如何设计REST API？您在[*第一章*](B19349_01.xhtml#_idTextAnchor014)，*RESTful
    Web服务基础*中了解到，目前没有现成的标准来规范REST API的实现。OAS被引入来解决至少REST API规范和描述的方面。它允许您使用**YAML
    Ain’t Markup Language**（**YAML**）或**JavaScript Object Notation**（**JSON**）标记语言编写REST
    API。
- en: 'We’ll use version 3.0 of OAS ([https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md))
    to implement the e-commerce app REST API. We’ll use YAML (pronounced as *yamel*,
    rhyming with *camel*), which is cleaner and easier to read. YAML is also space-sensitive.
    It uses space for indentation; for example, it represents the `key: value` pair
    (pay attention to the space after the colon – `:`). You can read more about YAML
    at [https://yaml.org/spec/](https://yaml.org/spec/).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用 OAS 的 3.0 版本 ([https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md))
    来实现电子商务应用的 REST API。我们将使用 YAML（发音为 *yamel*，与 *camel* 同韵），它更简洁，更容易阅读。YAML 也是空格敏感的。它使用空格进行缩进；例如，它表示
    `key: value` 对（注意冒号后面的空格——`:`）。您可以在 [https://yaml.org/spec/](https://yaml.org/spec/)
    上了解更多关于 YAML 的信息。'
- en: 'OAS was earlier known as the *Swagger Specification*. Today, OAS-supporting
    tools are still known as **Swagger tools**. Swagger tools are open source projects
    that help the overall development life cycle of REST APIs. We’ll make use of the
    following Swagger tools in this chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OAS 之前被称为 *Swagger 规范*。今天，OAS 支持的工具仍然被称为 **Swagger 工具**。Swagger 工具是开源项目，有助于
    REST API 的整体开发周期。在本章中，我们将使用以下 Swagger 工具：
- en: '**Swagger Editor** ([https://editor.swagger.io/](https://editor.swagger.io/)):
    This tool is used to design and describe the e-commerce app REST APIs. It allows
    you to write and preview, at the same time, your REST APIs’ design and description.
    Make sure that you use OAS 3.0\. Its beta version is available at [https://editor-next.swagger.io/](https://editor-next.swagger.io/).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger Editor** ([https://editor.swagger.io/](https://editor.swagger.io/))：这个工具用于设计和描述电子商务应用的
    REST API。它允许您同时编写和预览您的 REST API 的设计和描述。请确保您使用 OAS 3.0。其测试版可在 [https://editor-next.swagger.io/](https://editor-next.swagger.io/)
    获取。'
- en: '**Swagger Codegen** ([https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)):
    This tool is used to generate the Spring-based API models and Java interfaces.
    You’ll use the Gradle plugin ([https://github.com/int128/gradle-swagger-generator-plugin](https://github.com/int128/gradle-swagger-generator-plugin))
    to generate code that works on top of Swagger Codegen. There is also an OpenAPI
    tool Gradle plugin – OpenAPI Generator ([https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin](https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin)).
    However, we’ll opt for the former one because of the open issues count, which
    is 3.2k (there are multiple for Java/Spring as well) at the time of writing.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger Codegen** ([https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen))：这个工具用于生成基于
    Spring 的 API 模型和 Java 接口。您将使用 Gradle 插件 ([https://github.com/int128/gradle-swagger-generator-plugin](https://github.com/int128/gradle-swagger-generator-plugin))
    来生成在 Swagger Codegen 之上工作的代码。还有一个 OpenAPI 工具 Gradle 插件——OpenAPI Generator ([https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin](https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin))。然而，由于编写时存在
    3.2k 个开放问题（Java/Spring 也有多个），我们将选择前者。'
- en: '**Swagger UI** ([https://swagger.io/swagger-ui/](https://swagger.io/swagger-ui/)):
    This tool is used to generate the REST API documentation. The same Gradle plugin
    will be used to generate the API documentation.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger UI** ([https://swagger.io/swagger-ui/](https://swagger.io/swagger-ui/))：这个工具用于生成
    REST API 文档。我们将使用相同的 Gradle 插件来生成 API 文档。'
- en: Now that you have some idea of how the design-first approach can be used to
    develop APIs using OAS supporting tools, let’s understand the basic structure
    of OAS.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用 OAS 支持的工具以设计优先的方法来开发 API，让我们了解 OAS 的基本结构。
- en: Understanding the basic structure of OAS
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OAS 的基本结构
- en: 'The OpenAPI definition structure can be divided into the following sections
    (all are keywords and case-sensitive):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 定义结构可以分为以下部分（所有都是关键字，并且区分大小写）：
- en: '`openapi (version)`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openapi (版本)`'
- en: '`info`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`'
- en: '`externalDocs`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`externalDocs`'
- en: '`servers`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servers`'
- en: '`tags`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`'
- en: '`paths`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths`'
- en: '`components`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`'
- en: All the preceding terms are part of `root`. The first three sections (`openapi`,
    `info`, and `externalDocs`) are used to define the metadata of the API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的术语都是 `root` 的一部分。前三个部分（`openapi`、`info` 和 `externalDocs`）用于定义 API 的元数据。
- en: You can place an API’s definition either in a single file or divided into multiple
    files. OAS supports both. We’ll use a single file to define the sample e-commerce
    API.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 API 的定义放在单个文件中，也可以将其分成多个文件。OAS 支持这两种方式。我们将使用单个文件来定义示例电子商务 API。
- en: Instead of discussing all the sections theoretically and then writing the e-commerce
    API definitions, we’ll do both together. First, we’ll cover each section definition
    of the e-commerce API, and then we’ll discuss why we have used it and what it
    implies.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是先理论上讨论所有部分，然后编写电子商务API定义，而是将两者结合起来。首先，我们将涵盖电子商务API的每个部分定义，然后讨论为什么我们使用了它以及它意味着什么。
- en: The metadata sections of OAS
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAS的元数据部分
- en: 'Let’s have a look at the metadata sections of the e-commerce API definitions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看电子商务API定义的元数据部分：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
- en: 'Now, let us discuss each code section in detail:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细讨论每个代码部分：
- en: '`openapi`: The `openapi` section tells us which OAS is used to write the API’s
    definition. OpenAPI uses semantic versioning ([https://semver.org/](https://semver.org/)),
    which means the version will be in the `major:minor:patch` form. If you look at
    the `openapi` metadata value, we use `3.0.3`. This reveals that we use major version
    `3` with patch `3` (the minor version is `0`).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openapi`: `openapi`部分告诉我们使用了哪个OAS来编写API的定义。OpenAPI使用语义版本控制([https://semver.org/](https://semver.org/))，这意味着版本将采用`major:minor:patch`的形式。如果您查看`openapi`元数据值，我们使用`3.0.3`。这表明我们使用了主版本`3`和补丁版本`3`（次要版本是`0`）。'
- en: '`info`: The `info` section contains the metadata about the API. This information
    is used to generate documentation and can be used by the client. It contains the
    following fields, out of which only `title` and `version` are mandatory fields,
    with the others being optional:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`: `info`部分包含关于API的元数据。这些信息用于生成文档，并且可以被客户端使用。它包含以下字段，其中只有`title`和`version`是必填字段，其余为可选字段：'
- en: '`title`: The title of the API.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: API的标题。'
- en: '`description`: This is used to describe the API details. As you can see, we
    can use Markdown ([https://spec.commonmark.org/](https://spec.commonmark.org/))
    here. An `>` (angular bracket) symbol is used to add multi-line values.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 这用于描述API的详细信息。如您所见，我们在这里可以使用Markdown([https://spec.commonmark.org/](https://spec.commonmark.org/))。使用`>`（尖括号）符号来添加多行值。'
- en: '`termsOfService`: This is a URL that links to the terms of services. Make sure
    that it follows the proper URL format.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`termsOfService`: 这是一个链接到服务条款的URL。请确保它遵循正确的URL格式。'
- en: '`contact`: This is the contact information of the API provider. The `email`
    attribute should be the email address of the contact person/organization. Other
    attributes are `name` and `url`. The `name` attribute represents the name of the
    contact person or organization. The `url` attribute provides the link to the contact
    page. This is an optional field, and all attributes are also optional.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact`: 这是API提供者的联系信息。`email`属性应该是联系人的电子邮件地址。其他属性是`name`和`url`。`name`属性代表联系人的名字或组织。`url`属性提供联系页面的链接。这是一个可选字段，并且所有属性都是可选的。'
- en: '`license`: This is the license information. The `name` attribute is a required
    field that represents the correct license name, such as MIT. `url` is optional
    and provides a link to the license document.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license`: 这是许可信息。`name`属性是一个必填字段，代表正确的许可名称，例如MIT。`url`是可选的，并提供指向许可文档的链接。'
- en: '`version`: This exposes the API version in the string format.'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 这以字符串格式暴露API版本。'
- en: '`externalDocs`: This is an optional field that points to extended documentation
    of the exposed API. It has two attributes – `description` and `url`. The `description`
    attribute is an optional field that defines a summary of the external documentation.
    You can use the Markdown syntax for the description. The `url` attribute is *mandatory*
    and links to external documentation.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`externalDocs`: 这是一个可选字段，指向暴露的API的扩展文档。它有两个属性——`description`和`url`。`description`属性是一个可选字段，用于定义外部文档的摘要。您可以使用Markdown语法来描述。`url`属性是*必填的*，并链接到外部文档。'
- en: Let’s continue building our API definition. We have completed the metadata section,
    so let’s discuss the servers and tags sections.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建我们的API定义。我们已经完成了元数据部分，所以让我们讨论服务器和标签部分。
- en: The servers and tags sections of OAS
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAS的服务器和标签部分
- en: 'After the metadata section, we can now describe the `servers` and `tags` sections.
    Let’s have a look at the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在元数据部分之后，我们现在可以描述`服务器`和`标签`部分。让我们看看以下代码：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
- en: 'Now, let us discuss each code section in detail:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细讨论每个代码部分：
- en: '`servers`: The `servers` section is an optional section that contains a list
    of servers that host the API. If the hosted API document is interactive, then
    it can be used by Swagger UI to directly call the API and show the response. If
    it is not provided, then it points to the root (`/`) of the hosted document server.
    Server URLs are shown using the `url` attribute.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`服务器`: `服务器`部分是一个可选部分，包含托管API的服务器列表。如果托管API文档是交互式的，那么它可以通过Swagger UI直接调用API并显示响应。如果没有提供，则指向托管文档服务器的根（`/`）。服务器URL使用`url`属性显示。'
- en: '`tags`: The `tags` section, defined at the root level, contains the collection
    of tags and their metadata. Tags are used to group the operations performed on
    the resources. The `tags` metadata contains `name`, which is a mandatory field,
    and two additional optional attributes: `description` and `externalDocs`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`: `标签`部分在根级别定义，包含标签及其元数据的集合。标签用于对资源执行的操作进行分组。`标签`元数据包含一个必填字段`name`，以及两个额外的可选属性：`description`和`externalDocs`。'
- en: The `name` attribute contains the tag name. We have already discussed the description
    and `externalDocs` fields in the previous section on metadata.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性包含标签名称。我们已经在上一节关于元数据的讨论中讨论了描述和`externalDocs`字段。'
- en: Let’s discuss the last two sections of OAS.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论OAS的最后两个部分。
- en: The components section of OAS
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAS的组件部分
- en: If we were going through the structure sequentially, we would have discussed
    `path` first. However, conceptually, we want to write our models first before
    we use them in the `path` section. Therefore, we’ll discuss the `components` section
    first, which is used to define the models.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按顺序遍历结构，我们首先会讨论`路径`。然而，从概念上讲，我们希望在`路径`部分使用它们之前先编写我们的模型。因此，我们将首先讨论`组件`部分，该部分用于定义模型。
- en: 'Here is a code snippet from the `components` section of the sample e-commerce
    app:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从示例电子商务应用的`组件`部分的代码片段：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
- en: If you are working with YAML for the first time, you may find it a bit uncomfortable.
    However, once you go through this section, you’ll feel more comfortable with YAML.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是第一次使用YAML，您可能会觉得它有点不舒服。然而，一旦您通过这一节，您会对YAML感到更加自在。
- en: Here, we define a model called `Cart`. The `Cart` model is of the `object` type
    and contains two fields, namely `customerId` (a string) and `items` (an array).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`Cart`的模型。`Cart`模型是`对象`类型，包含两个字段，即`customerId`（一个字符串）和`items`（一个数组）。
- en: The object data type
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数据类型
- en: 'You can define any model or field as an object. Once you mark a type as `object`,
    the next attribute is `properties`, which consists of all the object’s fields.
    For example, the `Cart` model in the previous code will have the following syntax:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将任何模型或字段定义为对象。一旦将类型标记为`对象`，下一个属性就是`属性`，它包含所有对象的字段。例如，前面代码中的`Cart`模型将有以下语法：
- en: '`type: object`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`类型: 对象`'
- en: '`properties:`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`属性:`'
- en: '`<``field name>:`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`<``字段名>:`'
- en: '`type: <``data type>`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`类型: <``数据类型>`'
- en: 'OAS supports six basic data types, which are as follows (all are in lowercase):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: OAS支持六个基本数据类型，如下所示（所有都是小写）：
- en: '`string`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字符串`'
- en: '`number`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数字`'
- en: '`integer`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`整数`'
- en: '`boolean`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`布尔`'
- en: '`object`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对象`'
- en: '`array`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数组`'
- en: 'Let’s discuss the `Cart` model, in which we use the `string`, `object`, and
    `array` data types. Other data types are `number`, `integer`, and `boolean`. Now,
    you may be wondering how to define the `date`, `time`, and `float` types, and
    so on. You can do that with the `format` attribute, which you can use along with
    the `object` type. For example, take a look at the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论 `Cart` 模型，其中我们使用了 `string`、`object` 和 `array` 数据类型。其他数据类型有 `number`、`integer`
    和 `boolean`。现在，你可能想知道如何定义 `date`、`time` 和 `float` 类型等。你可以使用 `format` 属性来完成，你可以与
    `object` 类型一起使用。例如，看看以下代码：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous code, `orderDate` is defined with `type string`, but `format`
    determines what string value it will contain. Since `format` is marked with `date-time`,
    the `orderDate` field will contain the date and time in the format defined in
    *RFC 3339*, *section 5.6* (https://tools.ietf.org/html/rfc3339#section-5.6) –
    for example, `2020-10-22T19:31:58Z`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`orderDate` 被定义为 `type string`，但 `format` 决定了它将包含什么字符串值。由于 `format`
    被标记为 `date-time`，`orderDate` 字段将包含按照 *RFC 3339*，*第 5.6 节*（https://tools.ietf.org/html/rfc3339#section-5.6）定义的日期和时间格式
    – 例如，`2020-10-22T19:31:58Z`。
- en: 'There are some other common formats you can use along with types, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一些其他常见的格式与类型一起使用，如下所示：
- en: '`type: number` with `format: float`: This will contain the floating-point number'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: number` with `format: float`: 这将包含浮点数'
- en: '`type: number` with `format: double`: This will contain the floating-point
    number with double precision'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: number` with `format: double`: 这将包含双精度浮点数'
- en: '`type: integer` with `format: int32`: This will contain the `int` type (signed
    32-bit integer)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: integer` with `format: int32`: 这将包含 `int` 类型（有符号 32 位整数）'
- en: '`type: integer` with `format: int64`: This will contain the long type (signed
    64-bit integer)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: integer` with `format: int64`: 这将包含长类型（有符号 64 位整数）'
- en: '`type: string` with `format: date`: This will contain the date as per *RFC
    3339* – for example, `2020-10-22`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: string` with `format: date`: 这将包含按照 *RFC 3339* – 例如，`2020-10-22` 格式的日期'
- en: '`type: string` with `format: byte`: This will contain the Base64-encoded values'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: string` with `format: byte`: 这将包含 Base64 编码的值'
- en: '`type: string` with `format: binary`: This will contain the binary data (and
    can be used for files)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: string` with `format: binary`: 这将包含二进制数据（可用于文件）'
- en: Our `Cart` model’s `items` field is an array of the user-defined `Item` type.
    Here, `Item` is another model and referenced using `$ref`. In fact, all user-defined
    types are referenced using `$ref`. The `Item` model is also part of the `components`/`schema`
    section. Therefore, the value of `$ref` contains an anchor for user-defined types
    with `#/``component/ schemas/{type}`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Cart` 模型的 `items` 字段是用户定义的 `Item` 类型的数组。在这里，`Item` 是另一个模型，并使用 `$ref` 进行引用。实际上，所有用户定义的类型都是使用
    `$ref` 进行引用的。`Item` 模型也是 `components`/`schema` 部分的一部分。因此，`$ref` 的值包含用户定义类型的锚点，格式为
    `#/component/schemas/{type}`。
- en: '`$ref` represents the reference object. It is based on the JSON reference ([https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03))
    and follows the same semantics in YAML. It can refer to an object in the same
    document or external documents. Therefore, it is used when you have API definitions
    divided into multiple files. You have already seen one example of its usage in
    the previous code. Let’s see one more example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ref` 表示引用对象。它基于 JSON 引用 ([https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03))，并在
    YAML 中遵循相同的语义。它可以引用同一文档中的对象或外部文档。因此，当你的 API 定义被分成多个文件时，它会用到。你已经在之前的代码中看到了它的一个使用示例。让我们再看一个示例：'
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is another caveat to the previous code. If you look closely, you will
    find two *items* – one is a property of the `Cart` object type and another one
    is an attribute of the array type. The former one is simple – a field of the `Cart`
    object. However, the latter belongs to `array` and is a part of the `array` syntax.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码还有一个需要注意的地方。如果你仔细看，你会找到两个 *items* – 一个是 `Cart` 对象类型的属性，另一个是数组类型的属性。前者很简单
    – `Cart` 对象的字段。然而，后者属于 `array`，是数组语法的组成部分。
- en: Array syntax
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数组语法
- en: '`type: array`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`type: array`'
- en: '`items:`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`items:`'
- en: '`type: <type` `of object>`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`type: <type` `of object>`'
- en: i. You could have a nested array if you placed the type of object as `array`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: i. 如果你将对象的类型设置为 `array`，你可以有一个嵌套数组
- en: "ii. You can also refer to the user-defined type using `$ref`, as shown in the\
    \ code\L (then, the `type` attribute is not required for `items`)"
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'ii. 你也可以使用 `$ref` 来引用用户定义的类型，如代码所示     （然后，对于 `items`，不需要 `type` 属性）'
- en: 'Let’s see what the `Item` model looks like:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Item` 模型的样子：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
- en: The `Item` model is also part of the `components`/`schema` section. We have
    defined several models used by the e-commerce app API. You can find them in the
    GitHub code at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter03/src/main/resources/api/openapi.yaml).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item` 模型也是 `components`/`schema` 部分的一部分。我们已经定义了电子商务应用 API 使用的几个模型。你可以在 GitHub
    代码中找到它们，链接为 [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter03/src/main/resources/api/openapi.yaml)。'
- en: Now, you have learned how you can define models under the `components`/`schema`
    section. We’ll now discuss how to define an API’s endpoints in the `path` section
    of OAS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何在 OAS 的 `components`/`schema` 部分定义模型。我们将现在讨论如何在 OAS 的 `path` 部分定义
    API 的端点。
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Like `schemas`, you can also define `requestBodies` (the request payload) and
    `responses` in the `components` section. This is useful when you have common request
    bodies and responses.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `schemas` 类似，你还可以在 `components` 部分定义 `requestBodies`（请求有效载荷）和 `responses`。当你有常见的请求体和响应时，这很有用。
- en: The path section of OAS
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAS 的路径部分
- en: The `path` section is the last section of OAS (sequence-wise, it is second-to-last,
    but we already discussed `components` in the previous subsection), where we define
    the endpoints. This is the place where we form the URI and attach the HTTP methods.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 部分是 OAS 的最后一个部分（按顺序，它是倒数第二个，但我们已经在上一个子节中讨论了 `components`），在这里我们定义端点。这是我们形成
    URI 并附加 HTTP 方法的位置。'
- en: 'Let’s write the definition for `GET /api/v1/carts/{customerId}/items`. This
    API gets the items of the cart associated with a given customer identifier:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `GET /api/v1/carts/{customerId}/items` 定义这个 API 的定义。这个 API 获取与给定客户标识符关联的购物车中的项目：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
- en: If you just go through the previous code, you can see what the endpoint is,
    what HTTP method and parameter this API uses, and most importantly, what response
    you can expect. Let’s discuss this in more detail. Here, `v1` represents the version
    of the API. Each endpoint path (such as `/api/v1/carts/{customerId}/items`) has
    an HTTP method (such as `POST`) associated with it. The endpoint path always starts
    with `/`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是浏览之前的代码，你可以看到端点是什么，这个 API 使用什么 HTTP 方法以及参数，最重要的是，你可以期待什么响应。让我们更详细地讨论这个问题。在这里，`v1`
    代表 API 的版本。每个端点路径（如 `/api/v1/carts/{customerId}/items`）都与一个 HTTP 方法（如 `POST`）相关联。端点路径始终以
    `/` 开头。
- en: 'Each method can then have seven fields – `tags`, `summary`, `description`,
    `operationId`, `parameters`, `responses`, and `requestBody`. Let us learn about
    each of them:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都可以有七个字段 - `tags`、`summary`、`description`、`operationId`、`parameters`、`responses`
    和 `requestBody`。让我们来了解它们每一个：
- en: '`tags`: Tags are used to group APIs, as shown in the following screenshot for
    APIs tagged with `cart`. `cart` endpoints in the following screenshot will be
    in `CartsApi.java`:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`：标签用于对 API 进行分组，如下面的截图所示，标记为 `cart` 的 API。下面的截图中的 `cart` 端点将在 `CartsApi.java`
    中：'
- en: '![Figure 3.1 – Cart APIs](img/Figure_03.1_B19349.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 购物车 API](img/Figure_03.1_B19349.jpg)'
- en: Figure 3.1 – Cart APIs
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 购物车 API
- en: '`summary` and `description`: The `summary` and `description` sections are the
    same as we ones we discussed in the *The metadata sections of OAS* section. They
    contain the given API’s operation summary and detailed description, respectively.
    As usual, you can use Markdown in the description field, as it refers to the same
    schema.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summary` 和 `description`：`summary` 和 `description` 部分与我们之前在 *OAS 元数据部分* 中讨论的相同。它们分别包含给定
    API 的操作摘要和详细描述。通常，你可以在描述字段中使用 Markdown，因为它引用的是相同的模式。'
- en: '`operationId`: This represents the name of the operation. As you can see in
    the previous code, we have assigned the `getCartByCustomerId` value to it. This
    same operation name will be used by Swagger Codegen as a method name in the generated
    API Java interface.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operationId`：这代表操作名称。正如你在之前的代码中所看到的，我们将其赋值为 `getCartByCustomerId`。这个相同的操作名称将被
    Swagger Codegen 用作生成 API Java 接口中的方法名称。'
- en: '`Parameters`: If you look closely, you’ll find `-` (a hyphen) in front of the
    name field. This is used to declare it as an array element. The `parameters` field
    can contain multiple parameters – in fact, a combination of the `path` and `query`
    parameters; therefore, it is declared as an array.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameters`：如果你仔细看，你会在名称字段前找到 `-`（一个连字符）。这用于将其声明为数组元素。`parameters` 字段可以包含多个参数——实际上，是
    `path` 和 `query` 参数的组合；因此，它被声明为数组。'
- en: For `path` parameters, you need to make sure that the value of `name`, under
    `parameters`, is the same as given in `path` inside curly braces.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `path` 参数，你需要确保 `parameters` 下的 `name` 值与花括号内的 `path` 中给出的值相同。
- en: The `parameters` field contains the API `query`, `path`, `header`, and `cookie`
    parameters. In the previous code, we used the `path` parameter (the value of the
    `in` field). You can change the value to `query` if you want to declare it as
    a `query` parameter and so on for other parameter types.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`parameters` 字段包含 API 的 `query`、`path`、`header` 和 `cookie` 参数。在之前的代码中，我们使用了
    `path` 参数（`in` 字段的值）。如果你想将其声明为 `query` 参数，以及其他参数类型，你可以更改其值。'
- en: You can mark a field as required or optional using the `required` field inside
    the `parameters` section, which is a Boolean parameter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `parameters` 部分内的 `required` 字段标记一个字段为必填或可选，这是一个布尔参数。
- en: Finally, you must declare the data type of the parameter, which is where the
    `schema` field is used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须声明参数的数据类型，这是使用 `schema` 字段的地方。
- en: '`responses`: The `responses` field is a required field for all API operations.
    This defines the type of responses that can be sent by the API operation when
    requested. It contains HTTP status codes as the default field. The field must
    have at least one response, which can be a `default` response or any successful
    HTTP status code, such as `200`. As the name suggests, the default response will
    be used when no other response is defined or available in the API operation.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responses`：对于所有 API 操作，`responses` 字段是一个必填字段。它定义了 API 操作在请求时可以发送的响应类型。它包含默认字段中的
    HTTP 状态码。该字段必须至少有一个响应，可以是 `default` 响应或任何成功的 HTTP 状态码，如 `200`。正如其名所示，如果没有其他响应在
    API 操作中定义或可用，将使用默认响应。'
- en: 'The response type (such as `200` or `default`) field contains three types of
    fields – `description`, `content`, and `headers`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 响应类型（如 `200` 或 `default`）字段包含三种类型的字段——`description`、`content` 和 `headers`：
- en: The `description` field is used to describe the response.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description` 字段用于描述响应。'
- en: 'The `headers` field is used to define the header and its value. A `headers`
    example is shown as follows:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers` 字段用于定义头和其值。以下是一个 `headers` 的示例：'
- en: '[PRE7]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `content` field, like we have in previous code, defines the type of content
    that denotes the different media types. We use `application/json`. Similarly,
    you can define other media types, such as `application/xml`. The `content` type
    field contains the actual response object that can be defined using the `schema`
    field, as we have defined an array of the `Item` model inside it.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content` 字段，就像我们在之前的代码中做的那样，定义了表示不同媒体类型的内容的类型。我们使用 `application/json`。同样，你可以定义其他媒体类型，如
    `application/xml`。`content` 类型字段包含实际的响应对象，可以使用 `schema` 字段定义，就像我们在其中定义了 `Item`
    模型的数组一样。'
- en: As mentioned earlier, you can create a reusable response under the `components`
    section and directly use it with `$ref`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以在 `components` 部分下创建一个可重用的响应，并直接使用 `$ref`。
- en: '`requestBody`: The `requestBody` field is used to define the request payload
    object. Like the `responses` object, `requestBody` also contains the description
    and content fields. Content can be defined in a similar fashion to the way it
    is defined for the `responses` object. You can refer to the previous code of `POST
    /carts/{customerId}/items` for an example. As a response, you can also create
    reusable request bodies under the `components` section and directly use them with
    `$ref`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestBody`：`requestBody`字段用于定义请求负载对象。与`responses`对象一样，`requestBody`也包含描述和内容字段。内容可以以与为`responses`对象定义的方式类似的方式进行定义。您可以参考`POST
    /carts/{customerId}/items`的先前代码以获取示例。作为响应，您还可以在`components`部分下创建可重用的请求体，并直接使用它们与`$ref`。'
- en: Now, you know how to define the API specification using OAS. Great! Here, we
    just described part of a sample e-commerce app’s API. Similarly, you can describe
    other APIs. You can refer to `openapi.yaml` ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml))
    for the complete code of our e-commerce API definitions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您知道如何使用OAS定义API规范了。太好了！在这里，我们只是描述了一个示例电子商务应用程序API的一部分。同样，您可以描述其他API。您可以参考`openapi.yaml`([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml))以获取我们电子商务API定义的完整代码。
- en: I suggest that you copy the code from `openapi.yaml` and paste it into the editor
    at [https://editor.swagger.io](https://editor.swagger.io) to view the API in a
    nice user interface and play around with it. Make sure to convert the API to OpenAPI
    version 3 using the **Edit** menu if the default version is not set to 3.0.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您将`openapi.yaml`中的代码复制并粘贴到[https://editor.swagger.io](https://editor.swagger.io)编辑器中，以在友好的用户界面中查看API并进行操作。如果默认版本未设置为3.0，请确保使用**编辑**菜单将API转换为OpenAPI版本3。
- en: We have finished designing our APIs, so now let’s generate code using `openapi.yaml`
    and enjoy the fruits of our hard work.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了API的设计，现在让我们使用`openapi.yaml`生成代码，享受我们辛勤工作的果实。
- en: Converting OAS to Spring code
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将OAS转换为Spring代码
- en: I am sure you are as excited as I am to start implementing the API. So far,
    we have learned about the RESTful web service theory and concepts and Spring fundamentals,
    and also designed our first API specs for a sample e-commerce application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您和我一样兴奋地开始实现API。到目前为止，我们已经学习了RESTful Web服务理论和概念以及Spring基础知识，并且为示例电子商务应用程序设计了我们的第一个API规范。
- en: 'For this section, you can either clone the Git repository ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3))
    or start to create a Spring project from scratch using **Spring Initializr** ([https://start.spring.io/](https://start.spring.io/))
    with the following options:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，您可以选择克隆Git仓库([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3))，或者从零开始使用**Spring
    Initializr**([https://start.spring.io/](https://start.spring.io/))创建Spring项目，以下是一些选项：
- en: '`Gradle -` `Groovy`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gradle -` `Groovy`'
- en: '`Java`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Java`'
- en: '`3.0.8`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3.0.8`'
- en: Or use the 3.X.X available version. Replace the project metadata with your preferred
    values
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用可用的3.X.X版本。将项目元数据替换为您喜欢的值
- en: '`Jar`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jar`'
- en: '`17`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`17`'
- en: '`Spring Web`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spring Web`'
- en: 'Once you open the project in your favorite IDE (IntelliJ, Eclipse, or NetBeans),
    you can add the following extra dependencies required for OpenAPI support under
    `dependencies` in the `build.gradle` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在您最喜欢的IDE（IntelliJ、Eclipse或NetBeans）中打开项目，您可以在`build.gradle`文件的`dependencies`下添加以下额外的依赖项，这些依赖项对于OpenAPI支持是必需的：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/build.gradle)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/build.gradle)'
- en: As mentioned earlier, we will use the Swagger plugin for code generation from
    the API definitions we just wrote. Follow the next seven steps to generate the
    code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用Swagger插件从我们刚刚编写的API定义中生成代码。按照以下七个步骤生成代码。
- en: '`plugins {}` in `build.gradle`, as shown here:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.gradle`中的`plugins {}`，如下所示：
- en: '[PRE9]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '{  "library": "spring-boot",  "dateLibrary": "java8",  "hideGenerationTimestamp":
    true,  "modelPackage": "com.packt.modern.api.model",  "apiPackage": "com.packt.modern.api",  "invokerPackage":
    "com.packt.modern.api",  "serializableModel": true,  "useTags": true,  "useGzipFeature"
    : true,  "hateoas": true,  "unhandledException": true,  "useSpringBoot3": true,  "useSwaggerUI":
    true,   …   …  "importMappings": {    "ResourceSupport":"org.springframework.hateoas.        RepresentationModel",    "Link":
    "org.springframework.hateoas.Link"  }}'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{  "library": "spring-boot",  "dateLibrary": "java8",  "hideGenerationTimestamp":
    true,  "modelPackage": "com.packt.modern.api.model",  "apiPackage": "com.packt.modern.api",  "invokerPackage":
    "com.packt.modern.api",  "serializableModel": true,  "useTags": true,  "useGzipFeature"
    : true,  "hateoas": true,  "unhandledException": true,  "useSpringBoot3": true,  "useSwaggerUI":
    true,   …   …  "importMappings": {    "ResourceSupport":"org.springframework.hateoas.        RepresentationModel",    "Link":
    "org.springframework.hateoas.Link"  }}'
- en: '[PRE10]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/config.json](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/config.json)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/config.json](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/config.json)'
- en: This configuration sets `spring-boot` as `library` – that is, Swagger Codegen
    will generate the classes aligned with Spring Boot. You can see that `useSpringBoot3`
    is set to `true` to make sure that generated classes are aligned with Spring Boot
    3.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将`spring-boot`设置为`library`——也就是说，Swagger Codegen将生成与Spring Boot对齐的类。您可以看到`useSpringBoot3`被设置为`true`，以确保生成的类与Spring
    Boot 3对齐。
- en: All other properties are self-explanatory except `importMappings`. It contains
    the mapping of a type from a YAML file to Java or a type existing in the external
    library. Therefore, once code is generated for the `importMappings` object, it
    uses the mapped class in the generated code. If we use `Link` in any of the models,
    then the generated models will use the mapped `org.springframework.hateoas.Link`
    class instead of the model defined in the YAML file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`importMappings`之外，所有其他属性都是不言自明的。它包含从YAML文件到Java或外部库中存在的类型的映射。因此，一旦为`importMappings`对象生成代码，它就会在生成的代码中使用映射的类。如果我们任何模型中使用`Link`，则生成的模型将使用映射的`org.springframework.hateoas.Link`类，而不是YAML文件中定义的模型。
- en: The `hateoas` configuration property allows us to use the Spring HATEOAS library
    and add HATEOAS links.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`hateoas`配置属性允许我们使用Spring HATEOAS库并添加HATEOAS链接。'
- en: You can find more information about the configuration at [https://github.com/swagger-api/swagger-codegen#customizing-the-generator](https://github.com/swagger-api/swagger-codegen#customizing-the-generator).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/swagger-api/swagger-codegen#customizing-the-generator](https://github.com/swagger-api/swagger-codegen#customizing-the-generator)找到有关配置的更多信息。
- en: "`.gitignore` like file \Lto ignore certain code you don’t want to generate.\
    \ Add the following line of code to the file (`/``src/main/resources/api/.openapi-generator-ignore`):"
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于`.gitignore`的文件来忽略您不想生成的某些代码。将以下代码行添加到文件中（`/src/main/resources/api/.openapi-generator-ignore`）：
- en: '[PRE11]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We don’t want to generate controllers. After the code’s addition, only API Java
    interfaces and models will be generated. We’ll add controllers manually.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想生成控制器。在代码添加后，将只生成API Java接口和模型。我们将手动添加控制器。
- en: Copy the OAS file from [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter03/src/main/resources/api/openapi.yaml)
    in `/src/main/resources/api`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter03/src/main/resources/api/openapi.yaml)文件从`/src/main/resources/api`复制过来。
- en: '`swaggerSources` task in the `build.gradle` file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build.gradle`文件中的`swaggerSources`任务：'
- en: '[PRE12]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we defined `eStore` (the user-defined name), which contains `inputFile`,
    pointing to the location of the `openapi.yaml` file. After defining the input,
    the generator needs to produce the output, which is configured in `code`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`eStore`（用户定义的名称），其中包含`inputFile`，指向`openapi.yaml`文件的位置。在定义输入后，生成器需要生成输出，该输出在`code`中配置。
- en: For the `code` block, `language` is set to Spring (it supports various languages);
    `configFile` points to `config.json`; `rawOptions` contains an `ignore` file,
    type mapping, and import mappings; and `components` contains the file flags you
    want to generate – models and API Java interfaces. Except for `language`, all
    our other configuration properties are optional in the `code` block.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `code` 块，`language` 设置为 Spring（它支持各种语言）；`configFile` 指向 `config.json`；`rawOptions`
    包含一个 `ignore` 文件，类型映射和导入映射；`components` 包含您想要生成的文件标志 - 模型和API Java接口。除了 `language`
    之外，我们所有的其他配置属性在 `code` 块中都是可选的。
- en: We only want to generate models and APIs. You can generate other files too,
    such as clients or test files. `ApiUtil.java` is required in the generated API
    Java interface otherwise, it will give a compilation error during build time.
    Therefore, it is added to `components`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想生成模型和API。您也可以生成其他文件，例如客户端或测试文件。在生成的API Java接口中需要 `ApiUtil.java`，否则，在构建时将给出编译错误。因此，它被添加到
    `components`。
- en: '`swaggerSources` to the `compileJava` task as a dependent task.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`swaggerSources` 作为依赖任务添加到 `compileJava` 任务。'
- en: 'This task points to the `code` block defined under `eStore`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务指向在 `eStore` 下定义的 `code` 块：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: processResources {  dependsOn(generateSwaggerCode)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: processResources {  dependsOn(generateSwaggerCode)
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: sourceSets.main.java.srcDir "${swaggerSources.eStore.code.outputDir}/src/main/java"sourceSets.main.resources.srcDir
    "${swaggerSources.eStore.code  .outputDir}/src/main/resources"
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sourceSets.main.java.srcDir "${swaggerSources.eStore.code.outputDir}/src/main/java"sourceSets.main.resources.srcDir
    "${swaggerSources.eStore.code  .outputDir}/src/main/resources"
- en: '[PRE15]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: $ gradlew clean build
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ gradlew clean build
- en: '[PRE16]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '@RestControllerpublic class CartsController implements CartApi {'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '@RestControllerpublic class CartsController implements CartApi {'
- en: private static final Logger log = LoggerFactory.getLogger(CartsController.class);
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: private static final Logger log = LoggerFactory.getLogger(CartsController.class);
- en: '@Override'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public ResponseEntity<List<Item>> addCartItemsBy
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: public ResponseEntity<List<Item>> addCartItemsBy
- en: CustomerId(String customerId, @Valid Item item) {
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: CustomerId(String customerId, @Valid Item item) {
- en: 'log.info("Request for customer ID: {}\nItem: {}",customerId, item);'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'log.info("Request for customer ID: {}\nItem: {}",customerId, item);'
- en: return ok(Collections.EMPTY_LIST);
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 ok(Collections.EMPTY_LIST);
- en: '}'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public ResponseEntity<List<Cart>> getCartByCustomerId(String customerId) {
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: public ResponseEntity<List<Cart>> getCartByCustomerId(String customerId) {
- en: throw new RuntimeException("Manual Exception thrown");
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出运行时异常("手动异常抛出");
- en: '}'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // Other method implementations (omitted)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: // 其他方法实现（省略）
- en: '}'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: public class Error {  private static final long serialVersionUID = 1L;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: public class Error {  private static final long serialVersionUID = 1L;
- en: private String errorCode;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: private String errorCode;
- en: private String message;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: private String message;
- en: private Integer status;
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: private Integer status;
- en: private String url = "Not available";
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: private String url = "不可用";
- en: private String reqMethod = "Not available";
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: private String reqMethod = "不可用";
- en: // getters and setters (omitted)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: // 获取器和设置器（省略）
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: public enum ErrorCode {  GENERIC_ERROR("PACKT-0001", "The system is unable to
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: public enum ErrorCode {  GENERIC_ERROR("PACKT-0001"，"系统无法
- en: complete the request. Contact system support."),
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: complete the request. 联系系统支持。"),
- en: HTTP_MEDIATYPE_NOT_SUPPORTED("PACKT-0002", "Requested
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP媒体类型不受支持("PACKT-0002"，"请求
- en: media type is not supported. Please use
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体类型不受支持。请使用
- en: application/json or application/xml as 'Content-
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: application/json 或 application/xml 作为 'Content-
- en: Type' header value"),
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 输入标题值"),
- en: HTTP_MESSAGE_NOT_WRITABLE("PACKT-0003", "Missing 'Accept'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP消息不可写("PACKT-0003"，"根据 'Content-Type' 缺少 'Accept'
- en: header. Please add 'Accept' header."),
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: header. 请添加 'Accept' header."),
- en: HTTP_MEDIA_TYPE_NOT_ACCEPTABLE("PACKT-0004", "Requested
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP媒体类型不可接受("PACKT-0004"，"请求
- en: '''Accept'' header value is not supported. Please use'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '''Accept'' header value is not supported. Please use'
- en: application/json or application/xml as 'Accept'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: application/json 或 application/xml 作为 'Accept'
- en: value"),
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: value"),
- en: JSON_PARSE_ERROR("PACKT-0005", "Make sure request payload
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: JSON解析错误("PACKT-0005"，"确保请求负载
- en: should be a valid JSON object."),
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应该是一个有效的JSON对象。"),
- en: HTTP_MESSAGE_NOT_READABLE("PACKT-0006", "Make sure
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP消息不可读("PACKT-0006"，"确保
- en: request payload should be a valid JSON or XML
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请求负载应该是有效的JSON或XML
- en: object according to 'Content-Type'.");
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。");
- en: private String errCode;
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: private String errCode;
- en: private String errMsgKey;
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: private String errMsgKey;
- en: ErrorCode(final String errCode, final String errMsgKey) {
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ErrorCode(final String errCode, final String errMsgKey) {
- en: this.errCode = errCode;
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: this.errCode = errCode;
- en: this.errMsgKey = errMsgKey;
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: this.errMsgKey = errMsgKey;
- en: '}'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getErrCode() {  return errCode;  }
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: public String getErrCode() {  return errCode;  }
- en: public String getErrMsgKey() {  return errMsgKey;  }
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: public String getErrMsgKey() {  return errMsgKey;  }
- en: '}'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: public class ErrorUtils {  private ErrorUtils() {}
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: public class ErrorUtils {  private ErrorUtils() {}
- en: public static Error createError(final String errMsgKey,
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: public static Error createError(final String errMsgKey,
- en: final String errorCode, final Integer httpStatusCode) {
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: final String errorCode, final Integer httpStatusCode) {
- en: Error error = new Error();
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Error error = new Error();
- en: error.setMessage(errMsgKey);
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: error.setMessage(errMsgKey);
- en: error.setErrorCode(errorCode);
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: error.setErrorCode(errorCode);
- en: error.setStatus(httpStatusCode);
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: error.setStatus(httpStatusCode);
- en: return error;
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: return error;
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '@ControllerAdvicepublic class RestApiErrorHandler {'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '@ControllerAdvicepublic class RestApiErrorHandler {'
- en: private final MessageSource messageSource;
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: private final MessageSource messageSource;
- en: '@Autowired'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '@Autowired'
- en: public RestApiErrorHandler(MessageSource messageSource) {
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: public RestApiErrorHandler(MessageSource messageSource) {
- en: this.messageSource = messageSource;
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: this.messageSource = messageSource;
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@ExceptionHandler(Exception.class)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '@ExceptionHandler(Exception.class)'
- en: public ResponseEntity<Error> handleException(HttpServletRequest request, Exception
    ex,Locale locale) {
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: public ResponseEntity<Error> handleException(HttpServletRequest request, Exception
    ex,Locale locale) {
- en: Error error = ErrorUtils
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Error error = ErrorUtils
- en: .createError(ErrorCode.GENERIC_ERROR.getErrMsgKey(),  ErrorCode.GENERIC_ERROR.getErrCode(),  HttpStatus.INTERNAL_SERVER_ERROR.value())     .setUrl(request.getRequestURL().toString())  .setReqMethod(request.getMethod());
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: .createError(ErrorCode.GENERIC_ERROR.getErrMsgKey(),  ErrorCode.GENERIC_ERROR.getErrCode(),  HttpStatus.INTERNAL_SERVER_ERROR.value())     .setUrl(request.getRequestURL().toString())  .setReqMethod(request.getMethod());
- en: return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
- en: '}'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@ExceptionHandler(HttpMediaTypeNotSupportedException.class)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '@ExceptionHandler(HttpMediaTypeNotSupportedException.class)'
- en: public ResponseEntity<Error>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: public ResponseEntity<Error>
- en: handleHttpMediaTypeNotSupportedException(
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: handleHttpMediaTypeNotSupportedException(
- en: HttpServletRequest request,
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: HttpServletRequest request,
- en: HttpMediaTypeNotSupportedException ex, Locale locale){
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: HttpMediaTypeNotSupportedException ex, Locale locale){
- en: Error error = ErrorUtils
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Error error = ErrorUtils
- en: .createError(ErrorCode.HTTP_MEDIATYPE_NOT_SUPPORTED
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: .createError(ErrorCode.HTTP_MEDIATYPE_NOT_SUPPORTED
- en: .getErrMsgKey(),
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: .getErrMsgKey(),
- en: ErrorCode.HTTP_MEDIATYPE_NOT_SUPPORTED.getErrCode(),
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ErrorCode.HTTP_MEDIATYPE_NOT_SUPPORTED.getErrCode(),
- en: HttpStatus.UNSUPPORTED_MEDIA_TYPE.value())
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: HttpStatus.UNSUPPORTED_MEDIA_TYPE.value())
- en: .setUrl(request.getRequestURL().toString())
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: .setUrl(request.getRequestURL().toString())
- en: .setReqMethod(request.getMethod());
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: .setReqMethod(request.getMethod());
- en: return new ResponseEntity<>(
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: return new ResponseEntity<>(
- en: error, HttpStatus.INTERNAL_SERVER_ERROR);
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: error, HttpStatus.INTERNAL_SERVER_ERROR);
- en: '}'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // removed code for brevity
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: // removed code for brevity
- en: '}'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE21]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: $ ./gradlew clean build
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: $ ./gradlew clean build
- en: '[PRE22]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: $ java -jar build/libs/Chapter03-0.0.1-SNAPSHOT.jar
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: $ java -jar build/libs/Chapter03-0.0.1-SNAPSHOT.jar
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '$ curl --request GET ''http://localhost:8080/api/v1/carts/1'' --header ''Accept:
    application/xml'''
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '$ curl --request GET ''http://localhost:8080/api/v1/carts/1'' --header ''Accept:
    application/xml'''
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <Error>  <errorCode>PACKT-0001</errorCode>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <Error>  <errorCode>PACKT-0001</errorCode>
- en: <message>The system is unable to complete the request.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <message>The system is unable to complete the request.
- en: Contact system support.</message>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Contact system support.</message>
- en: <status>500</status>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <status>500</status>
- en: <url>http://localhost:8080/api/v1/carts/1</url>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <url>http://localhost:8080/api/v1/carts/1</url>
- en: <reqMethod>GET</reqMethod>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <reqMethod>GET</reqMethod>
- en: </Error>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: </Error>
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '$ curl --request GET ''http://localhost:8080/api/v1/carts/1'' --header ''Accept:
    application/json''{'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '$ curl --request GET ''http://localhost:8080/api/v1/carts/1'' --header ''Accept:
    application/json''{'
- en: '"errorCode":"PACKT-0001",'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '"errorCode":"PACKT-0001",'
- en: '"message":"The system is unable to complete the request.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '"message":"The system is unable to complete the request.'
- en: Contact system support.",
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Contact system support.",
- en: '"status":500,'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '"status":500,'
- en: '"url":"http://localhost:8080/api/v1/carts/1",'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '"url":"http://localhost:8080/api/v1/carts/1",'
- en: '"reqMethod":"GET"'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '"reqMethod":"GET"'
- en: '}'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '$ curl --request POST ''http://localhost:8080/api/v1/carts/1/items'' \ --header
    ''Content-Type: application/json'' \'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '$ curl --request POST ''http://localhost:8080/api/v1/carts/1/items'' \ --header
    ''Content-Type: application/json'' \'
- en: '--header ''Accept: application/json'' \'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '--header ''Accept: application/json'' \'
- en: --data-raw '{
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: --data-raw '{
- en: '"id": "1",'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '"id": "1",'
- en: '"quantity": 1,'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '"quantity": 1,'
- en: '"unitPrice": 2.5'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '"unitPrice": 2.5'
- en: '}'''
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '}'''
- en: '[]'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[]'
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'type: arrayitems:  type: array  items:    type: string'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'type: arrayitems:  type: array  items:    type: string'
- en: '[PRE28]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
