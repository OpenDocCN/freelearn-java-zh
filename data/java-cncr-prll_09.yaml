- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Serverless Computing and Java’s Concurrent Capabilities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器计算与 Java 的并发能力
- en: Serverless computing has revolutionized application deployment and management,
    allowing developers to focus on writing code while cloud providers handle the
    underlying infrastructure. This chapter explores the essentials of serverless
    computing and how Java’s concurrent capabilities can be effectively utilized in
    this environment. We’ll delve into the fundamental concepts of serverless computing,
    its advantages, specific scenarios where it’s particularly beneficial, and the
    trade-offs involved.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算彻底改变了应用程序的部署和管理，允许开发者专注于编写代码，而云服务提供商则处理底层基础设施。本章探讨了无服务器计算的基本要素以及 Java
    的并发能力如何在此环境中有效利用。我们将深入研究无服务器计算的基本概念、其优势、特别有益的具体场景以及涉及的权衡。
- en: Serverless architectures offer significant benefits in terms of scalability,
    cost efficiency, and reduced operational overhead, but they also come with challenges
    such as cold start latency, resource limits, and vendor lock-in. Understanding
    these trade-offs is crucial for making informed decisions about when and how to
    use serverless computing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构在可扩展性、成本效益和降低运营成本方面提供了显著的好处，但同时也带来了冷启动延迟、资源限制和供应商锁定等挑战。了解这些权衡对于做出关于何时以及如何使用无服务器计算的明智决策至关重要。
- en: 'The chapter will cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Fundamentals of serverless computing in Java
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 无服务器计算基础
- en: Adapting Java’s concurrency model to serverless environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Java 的并发模型适配到无服务器环境中
- en: 'Introducing serverless frameworks and services: AWS SAM, Azure Functions Core
    Tools, Google Cloud Functions, and Oracle Functions'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍无服务器框架和服务：AWS SAM、Azure Functions Core Tools、Google Cloud Functions 和 Oracle
    Functions
- en: Industry examples of Java serverless functions with a focus on concurrency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于并发的 Java 无服务器函数的行业实例
- en: A practical approach to building with serverless frameworks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无服务器框架构建的实际方法
- en: We’ll explore how Java’s concurrency features can be adapted to serverless environments,
    enabling the development of scalable and efficient applications. Through practical
    examples and code snippets, you’ll learn how to implement concurrency in Java
    serverless applications, leveraging tools such as ExecutorService, CompletableFuture,
    and parallel streams.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何将 Java 的并发功能适配到无服务器环境中，从而开发出可扩展且高效的应用程序。通过实际示例和代码片段，您将学习如何在 Java 无服务器应用程序中实现并发，利用
    ExecutorService、CompletableFuture 和并行流等工具。
- en: We’ll also discuss best practices for optimizing Java serverless applications,
    including minimizing cold starts, efficient resource management, and leveraging
    frameworks such as Spring Cloud Function, Micronaut, and Quarkus.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论优化 Java 无服务器应用程序的最佳实践，包括最小化冷启动、高效资源管理和利用 Spring Cloud Function、Micronaut
    和 Quarkus 等框架。
- en: By the end of this chapter, you’ll be equipped with the knowledge to build and
    optimize Java-based serverless applications, ensuring high performance and responsiveness
    across various cloud platforms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将具备构建和优化基于 Java 的无服务器应用程序的知识，确保在各种云平台上实现高性能和响应性。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You’ll need the AWS **Command Line Interface** (**CLI**) installed and configured:
    [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装并配置 AWS **命令行界面**（**CLI**）：[https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)。
- en: 'Here are the instructions for doing so:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行此操作的说明：
- en: Visit the official AWS CLI installation page.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问官方 AWS CLI 安装页面。
- en: Choose your operating system (Windows, Mac, or Linux) and download the installer.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的操作系统（Windows、Mac 或 Linux）并下载安装程序。
- en: Run the installer and follow the on-screen instructions.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序并遵循屏幕上的说明。
- en: After installation, configure your AWS CLI with credentials using the aws configure
    command. You’ll need your access key ID and secret access key, which can be found
    in your AWS IAM console.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，使用 aws configure 命令配置您的 AWS CLI 并提供凭证。您需要您的访问密钥 ID 和秘密访问密钥，这些可以在您的 AWS
    IAM 控制台中找到。
- en: 'You’ll also need the AWS Serverless Application Model CLI for deploying serverless
    applications: [https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要AWS无服务器应用程序模型CLI来部署无服务器应用程序：[https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html)。
- en: 'Here are the instructions for that:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的说明：
- en: Visit the official AWS SAM CLI installation page.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问官方AWS SAM CLI安装页面。
- en: Follow the instructions for your operating system (Windows, Mac, or Linux).
    These typically involve downloading and running a script or installer.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照您操作系统的说明（Windows、Mac或Linux）进行操作。这通常涉及下载并运行脚本或安装程序。
- en: After installation, verify the installation by running sam --version in your
    terminal. This should display the installed version of the AWS SAM CLI.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，通过在终端中运行sam --version来验证安装。这应该会显示安装的AWS SAM CLI版本。
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Fundamentals of serverless computing in java
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java无服务器计算的基础
- en: Serverless computing is a cloud-computing execution model that has revolutionized
    the way applications are developed and deployed. In this model, the cloud provider
    dynamically manages the allocation and provisioning of servers, allowing developers
    to focus on writing code without worrying about the underlying infrastructure.
    Although applications still run on servers, the management of these servers, including
    scaling and maintenance, is entirely handled by the cloud provider. This approach
    marks a significant departure from traditional server-based architectures, where
    developers are responsible for managing and maintaining the servers that host
    their applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算是一种云计算执行模型，它彻底改变了应用程序的开发和部署方式。在这个模型中，云服务提供商动态管理服务器的分配和配置，使得开发者可以专注于编写代码，无需担心底层基础设施。尽管应用程序仍然运行在服务器上，但这些服务器的管理，包括扩展和维护，完全由云服务提供商处理。这种方法与传统基于服务器的架构有显著的不同，在传统架构中，开发者负责管理和维护承载其应用程序的服务器。
- en: Core concepts of serverless computing
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器计算的核心概念
- en: Serverless architectures are built around several core concepts. One of the
    key concepts is the event-driven approach, where functions are executed in response
    to various triggers such as HTTP requests, database events, and device activity.
    This model is particularly well suited for Java developers because Java’s concurrency
    features, such as multithreading and asynchronous processing, align seamlessly
    with the event-driven nature of serverless computing. Additionally, Java’s extensive
    ecosystem of libraries and tools enhances its integration with cloud functions
    from providers such as Amazon AWS Lambda, Google Cloud, and Azure Functions. These
    attributes make Java a powerful choice for developing scalable and efficient serverless
    applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构围绕几个核心概念构建。其中一个关键概念是事件驱动方法，函数在响应各种触发器时执行，如HTTP请求、数据库事件和设备活动。这种模型特别适合Java开发者，因为Java的并发特性，如多线程和异步处理，与无服务器计算的事件驱动特性完美契合。此外，Java广泛的库和工具生态系统增强了它与亚马逊AWS
    Lambda、谷歌云和Azure Functions等提供商的云函数的集成。这些特性使Java成为开发可扩展和高效无服务器应用程序的强大选择。
- en: Another crucial concept is statelessness, which means that functions typically
    execute without retaining any state between invocations. This enables high levels
    of scalability, as multiple instances of a function can run concurrently without
    interfering with each other. However, functions can also be designed to be stateful
    by using external data sources or services, such as AWS Lambda with an external
    database or Kalix for stateful serverless applications. Serverless platforms also
    provide automatic scaling based on demand, eliminating the need for manual scaling
    and ensuring that applications can handle variable workloads efficiently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键概念是无状态，这意味着函数通常在调用之间不保留任何状态。这使可扩展性达到高水平，因为多个函数实例可以并发运行而不相互干扰。然而，函数也可以通过使用外部数据源或服务（如AWS
    Lambda与外部数据库或Kalix用于有状态无服务器应用程序）来设计为有状态。无服务器平台还提供基于需求的自动扩展，消除了手动扩展的需要，并确保应用程序能够高效地处理可变的工作负载。
- en: Additionally, serverless computing simplifies backend development by offloading
    routine tasks such as server and database management to the cloud provider, allowing
    developers to focus on writing business logic. Finally, serverless architectures
    are highly compatible with microservice architectures, enabling the independent
    deployment of discrete pieces of functionality.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无服务器计算通过将服务器和数据库管理等常规任务卸载给云服务提供商，简化了后端开发，使开发者能够专注于编写业务逻辑。最后，无服务器架构与微服务架构高度兼容，允许独立部署功能离散的部分。
- en: Traditionally, Java has not been the first choice for serverless computing due
    to its verbose syntax and slower startup times compared to languages such as Python
    or JavaScript. However, recent developments in frameworks such as Quarkus and
    Micronaut have significantly reduced Java’s startup time and memory usage, boosting
    its suitability for serverless environments. While Spring Native initially showed
    promise in this area, it has since been deprecated in favor of the official native
    support integrated into Spring Boot 3+. This new native support within Spring
    Boot 3+ offers enhanced features and capabilities, enabling Java developers to
    create efficient, scalable serverless applications that fully leverage the advantages
    of cloud-native architectures.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Java由于其冗长的语法和与Python或JavaScript等语言相比较慢的启动时间，并不是无服务器计算的首选。然而，Quarkus和Micronaut等框架的最新发展显著降低了Java的启动时间和内存使用，提高了其在无服务器环境中的适用性。虽然Spring
    Native最初在这个领域显示出希望，但它已被弃用，转而采用集成到Spring Boot 3+中的官方原生支持。Spring Boot 3+中的这一新原生支持提供了增强的功能和能力，使Java开发者能够创建高效、可扩展的无服务器应用程序，充分利用云原生架构的优势。
- en: Advantages of and scenarios for using serverless computing
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器计算的优势和使用场景
- en: Serverless computing offers several compelling advantages, particularly in terms
    of scalability, cost-effectiveness, and reduced operational overhead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算提供了几个令人信服的优势，尤其是在可扩展性、成本效益和降低运营成本方面。
- en: One of the most significant benefits is enhanced scalability. Serverless architectures
    can instantly and automatically scale up or down based on the demand for the application.
    This means that during peak traffic periods, the application can seamlessly handle
    increased loads without any manual intervention. Additionally, the stateless nature
    of serverless functions allows them to run concurrently and in parallel, enabling
    high throughput and responsiveness.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的好处之一是增强了可扩展性。无服务器架构可以根据应用程序的需求即时自动扩展或缩减。这意味着在高峰流量期间，应用程序可以无缝地处理增加的负载，而无需任何人工干预。此外，无服务器函数的无状态特性允许它们并发和并行运行，从而实现高吞吐量和响应速度。
- en: Another key advantage of serverless computing is cost-effectiveness. With a
    pay-per-use pricing model, you only pay for the resources your functions consume
    during their execution time. This eliminates the costs associated with idle compute
    resources, making it an attractive option for applications with variable or sporadic
    workloads. Moreover, serverless computing can reduce the total cost of ownership
    by minimizing the need for ongoing server maintenance and management.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算的另一个关键优势是成本效益。采用按使用付费的定价模式，您只需为函数在执行时间内的资源消耗付费。这消除了与闲置计算资源相关的成本，使其成为具有可变或间歇性工作负载的应用程序的有吸引力的选择。此外，无服务器计算可以通过最小化对持续服务器维护和管理的需求来降低总拥有成本。
- en: Serverless computing offers the potential for reduced operational overhead.
    By offloading server management tasks such as maintenance, patching, and scaling
    to the cloud provider, developers can focus more on code and functionality. Deployment
    processes are often simplified, allowing for quicker updates and feature releases
    without directly managing infrastructure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算提供了降低运营开销的潜力。通过将服务器管理任务，如维护、打补丁和扩展等任务外包给云服务提供商，开发者可以更多地关注代码和功能。部署流程通常简化，允许更快地更新和发布新功能，而无需直接管理基础设施。
- en: However, it’s important to note that serverless architectures can introduce
    their own complexities. Managing multiple runtimes for different functions or
    services may require additional configuration and monitoring. This is particularly
    relevant for larger applications where maintaining consistency across diverse
    environments can become challenging. While serverless platforms often provide
    built-in high availability and fault tolerance features, ensuring application
    resilience may still require careful design and optimization.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，无服务器架构可能会引入自己的复杂性。管理不同函数或服务的多个运行时可能需要额外的配置和监控。这对于大型应用程序尤其相关，因为在不同的环境中保持一致性可能变得具有挑战性。虽然无服务器平台通常提供内置的高可用性和容错功能，但确保应用程序的弹性可能仍然需要仔细的设计和优化。
- en: Furthermore, serverless architectures can easily integrate with other cloud
    services and be automatically triggered by events from these services, enabling
    the creation of highly responsive, event-driven applications and automated workflows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无服务器架构可以轻松集成到其他云服务中，并能够由这些服务的事件自动触发，从而创建高度响应的事件驱动应用程序和自动化工作流程。
- en: Overall, serverless computing can be a powerful tool, but it’s important to
    evaluate its suitability for your specific use case and understand the potential
    trade-offs involved.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，无服务器计算可以是一个强大的工具，但评估其是否适合您的特定用例以及了解涉及的潜在权衡是很重要的。
- en: Drawbacks and trade-offs of serverless computing
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器计算的优势和权衡
- en: 'While serverless computing offers numerous benefits, it also comes with several
    trade-offs and potential drawbacks that developers must consider:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无服务器计算提供了许多好处，但它也伴随着一些权衡和潜在的缺点，开发者必须考虑：
- en: '**Cold starts**: One of the most commonly cited drawbacks is the cold start
    latency. When a serverless function is invoked after a period of inactivity, it
    can take some time to initialize, leading to delays in response times. This can
    be particularly problematic for applications requiring low-latency responses.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷启动**：最常被引用的缺点之一是冷启动延迟。当无服务器函数在一段时间的不活跃后调用时，它可能需要一些时间来初始化，导致响应时间延迟。这对于需要低延迟响应的应用程序来说可能特别有问题。'
- en: '**Resource limits**: Serverless platforms impose limits on the execution time,
    memory, and computational resources available to each function. These constraints
    can make it challenging to run long-running processes or compute-intensive tasks.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制**：无服务器平台对每个函数可用的执行时间、内存和计算资源施加限制。这些限制可能使得运行长时间运行的过程或计算密集型任务变得具有挑战性。'
- en: '**Vendor lock-in**: Using serverless architectures often ties developers to
    a specific cloud provider’s ecosystem, making it difficult to migrate applications
    to another provider without significant rework.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商锁定**：使用无服务器架构通常会使开发者绑定到特定云服务提供商的生态系统，这使得在没有重大重做的情况下迁移应用程序到另一个提供商变得困难。'
- en: '**Complexity in debugging and monitoring**: Debugging serverless functions
    can be more complex compared to traditional server-based applications. The ephemeral
    nature of serverless functions and their distributed execution environments can
    complicate the debugging process. Additionally, monitoring and maintaining observability
    across multiple serverless functions requires robust tooling and practices.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试和监控的复杂性**：与传统基于服务器的应用程序相比，调试无服务器函数可能更加复杂。无服务器函数的短暂性和它们分布式的执行环境可能会使调试过程变得复杂。此外，监控和维护多个无服务器函数的可观察性需要强大的工具和实践。'
- en: '**State management**: Serverless functions are inherently stateless, which
    can complicate the management of application state across multiple invocations.
    Developers need to use external storage solutions such as databases or caching
    services to manage state, which can introduce additional complexity and latency.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态管理**：无服务器函数本质上是无状态的，这可能会使跨多个调用管理应用程序状态变得复杂。开发者需要使用外部存储解决方案，如数据库或缓存服务来管理状态，这可能会引入额外的复杂性和延迟。'
- en: '**Cost efficiency**: While serverless computing can be cost-effective for many
    use cases, it may not always be the most economical option. High-frequency invocations
    or applications with constant traffic may incur higher costs compared to reserved
    instances or traditional server-based architectures.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本效益**：虽然无服务器计算对于许多用例可能是成本效益的，但它可能并不总是最经济的选择。高频调用或具有持续流量的应用程序与预留实例或传统基于服务器的架构相比，可能会产生更高的成本。'
- en: '**Security concerns**: The abstraction of infrastructure management in serverless
    computing means that developers have less control over the underlying environment.
    This can introduce security concerns, as vulnerabilities or misconfigurations
    in the cloud provider’s infrastructure can potentially affect the application.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全担忧**：无服务器计算中基础设施管理的抽象意味着开发者对底层环境的控制较少。这可能会引入安全担忧，因为云提供商基础设施中的漏洞或配置错误可能会影响应用程序。'
- en: When to use serverless?
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用无服务器？
- en: 'Combining the advantages outlined previously, here are additional scenarios
    where serverless computing is particularly beneficial:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结合之前概述的优势，以下是一些无服务器计算特别有益的场景：
- en: '**Microservice architectures**: Applications designed with microservice architecture,
    where each service is a small, independently deployable unit.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**：采用微服务架构的应用程序，其中每个服务都是一个小型、可独立部署的单元。'
- en: '**Event-driven applications**: Systems that respond to various events such
    as data streams, user actions, or IoT signals.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动应用程序**：响应各种事件（如数据流、用户操作或物联网信号）的系统。'
- en: '**Stateless processing**: Applications that perform stateless operations, such
    as image processing, data transformation, or **Extract, Transform, Load** (**ETL**)
    tasks.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态处理**：执行无状态操作的应用程序，如图像处理、数据转换或**提取、转换、加载**（**ETL**）任务。'
- en: 'However, it’s important to note that serverless may not be the best fit for
    every scenario. Some situations where serverless might not be ideal include the
    following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，无服务器架构可能并不适合所有场景。以下是一些无服务器可能不是最佳选择的情况：
- en: Applications with long-running processes or high computational requirements
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要长时间运行的过程或高计算需求的应用程序
- en: Workloads that require low-latency responses or have strict performance requirements
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要低延迟响应或具有严格性能要求的工作负载
- en: Applications with complex or stateful workflows that require maintaining server
    state
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要维护服务器状态或具有复杂或状态化工作流程的应用程序
- en: Scenarios where you need complete control over the underlying infrastructure
    and operating system
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要完全控制底层基础设施和操作系统的场景
- en: When deciding whether to use serverless, it’s crucial to evaluate your specific
    application requirements, scalability needs, and cost considerations. Serverless
    can offer significant benefits in terms of scalability, cost efficiency, and development
    agility, but it’s important to carefully assess whether it aligns with your application’s
    characteristics and goals.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否使用无服务器时，评估您特定的应用程序需求、可扩展性需求和成本考虑至关重要。无服务器在可扩展性、成本效率和开发敏捷性方面可以提供显著的好处，但重要的是要仔细评估它是否与您的应用程序特性和目标相匹配。
- en: Adapting Java’s concurrency model to serverless environments
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Java的并发模型适应无服务器环境
- en: Serverless computing presents unique challenges for Java’s traditional concurrency
    model. The ephemeral and stateless nature of serverless functions necessitates
    a shift from long-lived thread pools and shared mutable state to more dynamic
    and isolated concurrency patterns. In this context, developers must focus on designing
    concurrency strategies that align with the short-lived, event-driven nature of
    serverless architectures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算对Java的传统并发模型提出了独特的挑战。无服务器函数的短暂和无状态特性要求从长期运行的线程池和共享可变状态转移到更动态和隔离的并发模式。在这种情况下，开发者必须专注于设计符合无服务器架构短暂、事件驱动特性的并发策略。
- en: Effective serverless concurrency in Java revolves around maximizing function
    efficiency within strict time and resource constraints. This involves leveraging
    asynchronous operations, particularly through CompletableFuture, to handle non-blocking
    I/O tasks and optimize throughput. Developers should structure their code to process
    events efficiently, a central tenet of serverless design.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的有效无服务器并发围绕在严格的时间和资源约束内最大化函数效率。这涉及到利用异步操作，特别是通过CompletableFuture来处理非阻塞I/O任务并优化吞吐量。开发者应该构建代码以高效处理事件，这是无服务器设计的一个核心原则。
- en: When using CompletableFuture for asynchronous processing in serverless functions,
    it’s crucial to consider the function’s execution time limits.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器函数中使用 CompletableFuture 进行异步处理时，考虑函数的执行时间限制至关重要。
- en: 'Here’s an example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This demo showcases how to use `CompletableFuture` for asynchronous processing
    in a serverless function. By performing database queries and API calls concurrently,
    the function minimizes the overall execution time and improves responsiveness.
    This is particularly beneficial in serverless environments where reducing execution
    time can lead to cost reduction and better scalability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此演示展示了如何在无服务器函数中使用 `CompletableFuture` 进行异步处理。通过并发执行数据库查询和 API 调用，函数最小化了整体执行时间并提高了响应性。这在无服务器环境中尤其有益，因为减少执行时间可以导致成本降低和更好的可扩展性。
- en: 'For data processing, while parallel streams can be beneficial, it’s important
    to consider the trade-offs in a serverless context:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据处理，虽然并行流可能有益，但在无服务器环境中，考虑权衡是很重要的：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This demo illustrates the use of Java’s parallel streams to process large datasets
    in a serverless function. By conditionally using parallel streams based on the
    data size, the function can efficiently utilize multiple CPU cores to process
    data concurrently. This approach significantly enhances performance for large
    datasets, making the function more scalable and responsive in serverless environments.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此演示说明了在无服务器函数中使用 Java 的并行流处理大型数据集的方法。通过根据数据大小有条件地使用并行流，函数可以有效地利用多个 CPU 核心，并发处理数据。这种方法显著提高了大型数据集的性能，使函数在无服务器环境中更具可扩展性和响应性。
- en: As serverless computing continues to gain popularity, Java’s concurrency features
    will play a crucial role in enabling developers to build scalable, responsive,
    and high-performance serverless applications. To further optimize Java serverless
    applications, let’s explore best practices in design and the use of frameworks
    and libraries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着无服务器计算继续获得普及，Java 的并发特性将在使开发者能够构建可扩展、响应迅速且高性能的无服务器应用程序中发挥关键作用。为了进一步优化 Java
    无服务器应用程序，让我们探讨设计和使用框架及库的最佳实践。
- en: Designing efficient Java serverless applications
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计高效的 Java 无服务器应用程序
- en: 'To ensure optimal performance and cost-efficiency in Java serverless applications,
    it’s crucial to follow best practices in design and leverage appropriate frameworks
    and libraries. Here are the key guidelines and recommendations:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 Java 无服务器应用程序的性能和成本效益最佳，遵循设计最佳实践并利用适当的框架和库至关重要。以下是一些关键指南和建议：
- en: '**Minimizing cold starts**: Cold starts occur when a new instance of a serverless
    function is provisioned. To reduce cold start times, developers can employ several
    techniques:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化冷启动**：冷启动发生在为无服务器函数分配新实例时。为了减少冷启动时间，开发者可以采用几种技术：'
- en: '**AWS Lambda SnapStart**: SnapStart optimizes the initialization process by
    taking a snapshot of the initialized execution environment and restoring it when
    needed, significantly reducing cold start latency. To use SnapStart, enable it
    in your Lambda function configuration and ensure your code is compatible with
    serialization.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Lambda SnapStart**：SnapStart 通过对初始化执行环境进行快照并在需要时恢复它来优化初始化过程，显著减少了冷启动延迟。要使用
    SnapStart，请在您的 Lambda 函数配置中启用它，并确保您的代码与序列化兼容。'
- en: '**Enable provisioned concurrency**: This feature keeps functions warm by pre-initializing
    instances, ensuring quick response times. Set up provisioned concurrency in your
    Lambda function settings based on expected traffic patterns.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用已配置并发性**：此功能通过预初始化实例来保持函数活跃，确保快速响应时间。根据预期的流量模式，在您的 Lambda 函数设置中配置已配置并发性。'
- en: '**Optimize Java Virtual Machine runtime with custom images**: Tools such as
    GraalVM Native Image can compile Java applications into native executables, reducing
    startup time and memory consumption. To use custom images, do the following:'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用自定义镜像优化 Java 虚拟机运行时**：例如 GraalVM Native Image 工具可以将 Java 应用程序编译成本地可执行文件，从而减少启动时间和内存消耗。要使用自定义镜像，请执行以下操作：'
- en: Build your application using GraalVM Native Image.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GraalVM Native Image 构建您的应用程序。
- en: Create a custom Lambda runtime using AWS Lambda Runtime Interface Client.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS Lambda Runtime Interface Client 创建自定义 Lambda 运行时。
- en: Package your native executable with the custom runtime.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的本地可执行文件与自定义运行时打包在一起。
- en: Deploy the package as a Lambda function.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将包作为 Lambda 函数部署。
- en: '**Additional optimizations**:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外的优化**：'
- en: Minimize dependencies in your function to reduce package size
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的函数中尽量减少依赖以减小包大小
- en: Use lazy loading for non-essential resources
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对非必需资源使用懒加载
- en: Implement caching strategies for frequently accessed data
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施缓存策略以处理频繁访问的数据
- en: Optimize your code for quick startup, moving initialization logic out of the
    handler method where possible
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化您的代码以快速启动，尽可能将初始化逻辑移出处理器方法
- en: '**Efficient memory and** **resource management**:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效内存和资源管理**：'
- en: '**Right-size function memory**: Allocate sufficient memory to avoid performance
    bottlenecks while being mindful of costs.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合理分配函数内存**：分配足够的内存以避免性能瓶颈，同时注意成本。'
- en: '**Optimize code execution**: Write efficient code to reduce execution time,
    avoiding heavy initialization logic within the function handler.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化代码执行**：编写高效的代码以减少执行时间，避免在函数处理器中包含繁重的初始化逻辑。'
- en: '**Connection pooling**: Use Amazon RDS Proxy for managing database connections
    effectively, as traditional connection pooling libraries such as HikariCP are
    not recommended for serverless use.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接池**：使用 Amazon RDS Proxy 有效地管理数据库连接，因为传统的连接池库，如 HikariCP，不建议用于无服务器使用。'
- en: '**Stateless design**: Design functions to be stateless to ensure scalability
    and avoid state management issues. Use external storage services such as Amazon
    **Simple Storage Service** (**S3**), DynamoDB, or Redis for state persistence.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态设计**：设计函数为无状态，以确保可扩展性并避免状态管理问题。使用外部存储服务，如 Amazon **简单存储服务**（**S3**）、DynamoDB
    或 Redis 进行状态持久化。'
- en: '**Efficient** **data handling**:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效的数据处理**：'
- en: '**Use streams for large data**: Stream processing helps to handle large datasets
    without loading all data into memory. Java’s Stream API is useful for this purpose.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用流处理大量数据**：流处理有助于处理大型数据集，而无需将所有数据加载到内存中。Java 的 Stream API 对此很有用。'
- en: '**Optimize serializations**: Use efficient serialization libraries such as
    Jackson for JSON processing and optimize serialization/deserialization processes.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化序列化**：使用高效的序列化库，如 Jackson 进行 JSON 处理，并优化序列化和反序列化过程。'
- en: '**Monitoring** **and logging**:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和日志记录**：'
- en: '**Integrated logging**: Use centralized logging services such as AWS CloudWatch
    Logs and structure logs for easy tracing and debugging.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成日志记录**：使用集中式日志服务，如 AWS CloudWatch Logs，并结构化日志以便于跟踪和调试。'
- en: '**Performance monitoring**: Tools such as AWS X-Ray are helpful for tracing
    and monitoring the performance of serverless functions.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能监控**：工具如 AWS X-Ray 有助于跟踪和监控无服务器函数的性能。'
- en: Java-specific optimization techniques for AWS Lambda
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS Lambda 的 Java 特定优化技术
- en: 'For Java developers working with AWS Lambda, there are various techniques available
    to optimize the runtime performance of your functions. These techniques can help
    you minimize cold start times, reduce memory usage, and improve overall execution
    speed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 AWS Lambda 的 Java 开发者来说，有多种技术可用于优化函数的运行时性能。这些技术可以帮助您最小化冷启动时间，减少内存使用，并提高整体执行速度：
- en: '**Application class data sharing (AppCDS)**: Improves startup time and memory
    footprint by saving the metadata of loaded classes into an archive file, which
    can be memory-mapped during subsequent JVM startups'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序类数据共享（AppCDS）**：通过将加载类的元数据保存到存档文件中，从而在后续 JVM 启动时内存映射，提高启动时间和内存占用。'
- en: '`-XX:+TieredCompilation -XX:TieredStopAtLevel=1`, to balance startup time and
    long-term performance'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+TieredCompilation -XX:TieredStopAtLevel=1`，以平衡启动时间和长期性能。'
- en: '**Leveraging GraalVM native image**: Compiling your Java application into a
    native executable can significantly reduce cold start times and memory usage'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用 GraalVM 原生映像**：将 Java 应用程序编译成原生可执行文件可以显著减少冷启动时间和内存使用。'
- en: Frameworks and libraries
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架和库
- en: '**Spring Cloud Function** simplifies serverless development by enabling developers
    to write cloud-agnostic functions using standard Java interfaces and Spring annotations.
    This allows for local creation, testing, and deployment, followed by seamless
    execution on various cloud infrastructures without code modifications. It supports
    an event-driven architecture, handling triggers such as HTTP requests, message
    queues, and timers, while its auto-discovery and registration of functions streamline
    the development process.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Cloud Function** 通过允许开发者使用标准 Java 接口和 Spring 注解编写无服务器函数，简化了无服务器开发。这允许在本地创建、测试和部署，然后在各种云基础设施上无缝执行，无需修改代码。它支持事件驱动架构，处理触发器，如
    HTTP 请求、消息队列和计时器，同时其函数的自动发现和注册简化了开发过程。'
- en: 'To illustrate, consider a simple Spring Boot application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑一个简单的 Spring Boot 应用程序：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Within this Spring Boot application, Spring Cloud Function automatically registers
    the `uppercase()` method as a function. When triggered, Spring Cloud Function
    maps incoming requests to the corresponding function, executes it with the provided
    input, and returns the result. This abstraction layer allows for seamless deployment
    across diverse serverless environments, freeing developers to focus solely on
    business logic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此 Spring Boot 应用程序中，Spring Cloud Function 自动注册 `uppercase()` 方法作为函数。当触发时，Spring
    Cloud Function 将传入的请求映射到相应的函数，使用提供的输入执行它，并返回结果。这一抽象层允许无缝部署到各种无服务器环境，让开发者能够专注于业务逻辑。
- en: '**Micronaut**, renowned for its fast startup times and minimal memory footprint,
    presents an ideal choice for building serverless functions. Designed for creating
    lightweight and modular JVM-based applications, Micronaut seamlessly integrates
    with popular serverless platforms.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micronaut**，以其快速的启动时间和最小的内存占用而闻名，是构建无服务器函数的理想选择。Micronaut 设计用于创建轻量级和模块化的
    JVM 基于应用程序，与流行的无服务器平台无缝集成。'
- en: 'Let’s take a look at a simple Micronaut function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 Micronaut 函数：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code, the `@FunctionBean("helloFunction")` annotation designates the
    `HelloFunction` class as a Micronaut function bean. The `HelloFunction` class
    extends `FunctionInitializer` and implements the Function interface, specifically
    for processing API Gateway HTTP events (`APIGatewayV2HTTPEvent`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`@FunctionBean("helloFunction")` 注解指定了 `HelloFunction` 类作为 Micronaut 函数
    bean。`HelloFunction` 类继承自 `FunctionInitializer` 并实现了 Function 接口，专门用于处理 API Gateway
    HTTP 事件 (`APIGatewayV2HTTPEvent`)。
- en: The overridden `apply()` method efficiently handles incoming requests, returning
    an `APIGatewayV2HTTPResponse` with a status code of 200 and the message `"Hello
    World"` in the body. This setup allows for easy deployment of the function to
    various serverless platforms, including AWS Lambda.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的 `apply()` 方法高效地处理传入的请求，返回一个包含状态码 200 和正文 `"Hello World"` 的 `APIGatewayV2HTTPResponse`。这种设置使得函数的部署到各种无服务器平台变得简单，包括
    AWS Lambda。
- en: '`GraalVM` and `OpenJDK HotSpot`. Its design prioritizes fast boot times and
    low memory consumption, making it a compelling choice for serverless applications.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraalVM` 和 `OpenJDK HotSpot`。其设计优先考虑快速启动时间和低内存消耗，使其成为无服务器应用程序的一个有吸引力的选择。'
- en: 'Let’s look at a basic Quarkus function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本的 Quarkus 函数：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code snippet showcases a serverless function built with Quarkus. The `GreetingLambda`
    class features a `handleRequest()` method specifically crafted to manage incoming
    AWS API Gateway requests (`APIGatewayProxyRequestEvent`). This method processes
    the request and constructs an `APIGatewayProxyResponseEvent`, returning a 200
    status code along with a personalized greeting that incorporates the request body.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段展示了使用 Quarkus 构建的函数。`GreetingLambda` 类具有一个 `handleRequest()` 方法，专门用于管理传入的
    AWS API Gateway 请求 (`APIGatewayProxyRequestEvent`)。此方法处理请求并构建一个 `APIGatewayProxyResponseEvent`，返回一个状态码为
    200 的响应，并包含一个结合请求体的个性化问候。
- en: While this function is inherently tailored for deployment on AWS Lambda, adapting
    it for Azure Functions or Google Cloud Functions necessitates modifications to
    accommodate the distinct mechanisms these platforms employ for handling HTTP requests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此函数本质上是针对 AWS Lambda 部署而设计的，但要将其适配到 Azure Functions 或 Google Cloud Functions，则需要修改以适应这些平台处理
    HTTP 请求的独特机制。
- en: AWS Lambda Java libraries
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS Lambda Java 库
- en: Amazon provides a set of libraries specifically designed for building serverless
    applications on AWS Lambda ([https://docs.aws.amazon.com/lambda/latest/dg/lambda-java.html](https://docs.aws.amazon.com/lambda/latest/dg/lambda-java.html)),
    which greatly simplifies the process of integrating with other AWS services. These
    libraries are tailored to streamline the development of Lambda functions, ensuring
    they can efficiently interact with various AWS resources and services.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊提供了一套专门为在 AWS Lambda 上构建无服务器应用程序设计的库 ([https://docs.aws.amazon.com/lambda/latest/dg/lambda-java.html](https://docs.aws.amazon.com/lambda/latest/dg/lambda-java.html))，这极大地简化了与其他
    AWS 服务的集成过程。这些库针对简化 Lambda 函数的开发而定制，确保它们可以高效地与各种 AWS 资源和服务交互。
- en: 'Let’s examine a simple AWS Lambda function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个简单的 AWS Lambda 函数：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code demonstrates how to utilize AWS Lambda Java libraries to build a serverless
    function that responds to S3 events. The `RequestHandler` interface and `S3Event`
    class are provided by the `aws-lambda-java-core` and `aws-lambda-java-events`
    libraries respectively. The `context` object offers runtime information and a
    logger for the Lambda function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了如何利用 AWS Lambda Java 库构建一个响应 S3 事件的 serverless 函数。`RequestHandler` 接口和
    `S3Event` 类分别由 `aws-lambda-java-core` 和 `aws-lambda-java-events` 库提供。`context`
    对象提供了 Lambda 函数的运行时信息和日志记录器。
- en: By adhering to best practices and leveraging the right frameworks and libraries,
    developers can build efficient and scalable Java serverless applications. These
    practices ensure reduced latency, optimal resource usage, and easier maintenance,
    while the frameworks and libraries provide powerful tools to streamline development
    and deployment processes. Moving forward, applying these principles will help
    in achieving high-performance serverless applications that meet modern cloud computing
    demands.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循最佳实践并利用正确的框架和库，开发者可以构建高效且可扩展的 Java 无服务器应用程序。这些实践确保了降低延迟、优化资源使用和易于维护，而框架和库提供了强大的工具以简化开发和部署流程。展望未来，应用这些原则将有助于实现满足现代云计算需求的高性能无服务器应用程序。
- en: Introducing serverless frameworks and services – AWS SAM, Azure Functions Core
    Tools, Google Cloud Functions, and Oracle Functions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入无服务器框架和服务 - AWS SAM、Azure Functions Core Tools、Google Cloud Functions 和 Oracle
    Functions
- en: To effectively manage and deploy serverless applications across different cloud
    platforms, it is crucial to understand the frameworks provided by AWS, Azure,
    and Google Cloud. These frameworks simplify the process of defining, deploying,
    and managing serverless resources, making it easier for developers to build and
    maintain scalable applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地管理和在不同云平台上部署无服务器应用程序，了解 AWS、Azure 和 Google Cloud 提供的框架至关重要。这些框架简化了定义、部署和管理无服务器资源的过程，使开发者更容易构建和维护可扩展的应用程序。
- en: AWS Serverless Application Model
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS 无服务器应用程序模型
- en: 'AWS **Serverless Application Model** (**SAM**) is a framework for building
    serverless applications on AWS. It extends AWS CloudFormation to provide a simplified
    way of defining serverless resources such as AWS Lambda functions, API Gateway
    APIs, DynamoDB tables, and more. This is illustrated in *Figure 9**.1*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: AWS **无服务器应用程序模型**（**SAM**）是一个在 AWS 上构建无服务器应用程序的框架。它扩展了 AWS CloudFormation，提供了一种简化定义无服务器资源（如
    AWS Lambda 函数、API Gateway API、DynamoDB 表等）的方法。这如图 *图 9.1* 所示：
- en: '![Figure 9.1: AWS Serverless Application Model](img/B20937_09_01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1：AWS 无服务器应用程序模型](img/B20937_09_01.jpg)'
- en: 'Figure 9.1: AWS Serverless Application Model'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：AWS 无服务器应用程序模型
- en: 'The AWS SAM framework diagram illustrates the interactions and components involved
    in a typical serverless architecture using AWS services. Here’s a breakdown of
    the key components:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: AWS SAM 框架图展示了使用 AWS 服务构建典型无服务器架构中涉及的交互和组件。以下是关键组件的分解：
- en: '**AWS Lambda**: A serverless computing service. It lets you run code without
    provisioning or managing servers.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Lambda**：一项无服务器计算服务。它允许您在不配置或管理服务器的情况下运行代码。'
- en: '**Amazon API Gateway**: A fully managed service that allows you to create HTTP
    APIs that act as the front door for your serverless applications. Clients can
    invoke your Lambda functions through these APIs.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon API Gateway**：一项完全托管的服务，允许您创建 HTTP API，这些 API 作为无服务器应用程序的前门。客户端可以通过这些
    API 调用您的 Lambda 函数。'
- en: '**Events**: Events trigger the execution of your Lambda functions. These events
    can originate from different sources:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：事件触发 Lambda 函数的执行。这些事件可以来自不同的来源：'
- en: HTTP requests via API Gateway
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 API Gateway 的 HTTP 请求
- en: Changes in data sources such as S3 buckets or DynamoDB tables
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源（如 S3 存储桶或 DynamoDB 表）的变化
- en: Scheduled triggers based on time
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的计划触发器
- en: '**Amazon DynamoDB**: A NoSQL database service for storing and retrieving data
    at any scale. Your Lambda functions can interact with Amazon DynamoDB to store
    or retrieve data.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon DynamoDB**：一项用于存储和检索数据的 NoSQL 数据库服务。您的 Lambda 函数可以与 Amazon DynamoDB
    交互以存储或检索数据。'
- en: '**Amazon S3**: A scalable object storage service. Your Lambda functions can
    interact with Amazon S3 to store or retrieve files.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon S3**：一项可扩展的对象存储服务。您的 Lambda 函数可以与 Amazon S3 交互以存储或检索文件。'
- en: '**Amazon SNS/SQSimple**: **Simple Notification Service** (**SNS**) is a pub/sub
    messaging service, while **Simple Queue Service** (**SQS**) is a message queuing
    service. Your Lambda functions can use SNS to publish messages to SQS queues or
    subscribe to receive messages from them.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon SNS/SQSimple**：**简单通知服务**（**SNS**）是一个发布/订阅消息传递服务，而**简单队列服务**（**SQS**）是一个消息队列服务。您的Lambda函数可以使用SNS将消息发布到SQS队列或订阅从它们接收消息。'
- en: '**AWS Step Functions**: A service for orchestrating workflows made up of multiple
    Lambda functions. It allows you to define the order of execution and handle errors.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Step Functions**：一个用于编排由多个Lambda函数组成的流程的服务。它允许您定义执行顺序并处理错误。'
- en: Figure *9**.1* depicts a serverless application on AWS built with the AWS SAM
    framework. Users initiate interactions through an API Gateway endpoint, which
    then directs those requests to AWS Lambda functions. These Lambda functions can
    access and process data from various sources such as DynamoDB (database), S3 (storage),
    SNS (messaging), and SQS (queuing). Optionally, AWS Step Functions can be used
    to orchestrate complex workflows involving multiple Lambda functions. By leveraging
    AWS SAM and its templates, developers can create scalable and cost-effective serverless
    applications on AWS.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图*9*.1展示了使用AWS SAM框架在AWS上构建的无服务器应用程序。用户通过API网关端点发起交互，然后这些请求被导向AWS Lambda函数。这些Lambda函数可以访问和处理来自各种来源的数据，例如DynamoDB（数据库）、S3（存储）、SNS（消息传递）和SQS（队列）。可选地，可以使用AWS
    Step Functions来编排涉及多个Lambda函数的复杂工作流程。通过利用AWS SAM及其模板，开发者可以在AWS上创建可扩展且成本效益高的无服务器应用程序。
- en: 'SAM also allows for local testing of Lambda functions. This is a valuable feature
    that can help developers to debug and troubleshoot their code before deploying
    it to production. There are two ways to test Lambda functions locally: using AWS
    Toolkits or running AWS SAM in debug mode. AWS Toolkits are IDE plugins that allow
    you to set breakpoints, inspect variables, and execute code one line at a time.
    SAM also allows you to run AWS SAM in debug mode to attach to third-party debuggers
    such as ptvsd or Delve.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SAM还允许对Lambda函数进行本地测试。这是一个非常有用的功能，可以帮助开发者在将代码部署到生产环境之前进行调试和故障排除。本地测试Lambda函数有两种方式：使用AWS工具包或在调试模式下运行AWS
    SAM。AWS工具包是IDE插件，允许您设置断点、检查变量并逐行执行代码。SAM还允许您在调试模式下运行AWS SAM，以便连接到第三方调试器，如ptvsd或Delve。
- en: 'For more information on local testing with SAM, please refer to the AWS documentation:
    [https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging.html).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用SAM进行本地测试的更多信息，请参阅AWS文档：[https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging.html)。
- en: Azure Functions Core Tools
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions核心工具
- en: 'This **command-line interface** (**CLI**) provides a local development environment
    that mimics the Azure Functions runtime. It allows developers to build, test,
    and debug their functions on their machines before deploying them to Azure. Additionally,
    **Azure Functions Core Tools** integrates with continuous deployment pipelines
    using tools such as Azure DevOps or GitHub Actions. Let’s look at *Figure 9**.2*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此**命令行界面**（**CLI**）提供了一个本地开发环境，该环境模拟Azure Functions的运行时。它允许开发者在将函数部署到Azure之前，在自己的机器上构建、测试和调试它们。此外，**Azure
    Functions核心工具**与Azure DevOps或GitHub Actions等工具的持续部署管道集成。让我们看看*图9*.2：
- en: '![Figure 9.2: Azure Functions Core Tools diagram](img/B20937_09_02.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：Azure Functions核心工具图](img/B20937_09_02.jpg)'
- en: 'Figure 9.2: Azure Functions Core Tools diagram'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：Azure Functions核心工具图
- en: 'Figure *9**.2* illustrates the components and workflow involved in developing,
    testing, and deploying Azure Functions using Azure Functions Core Tools. Here
    is a detailed description:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图*9*.2说明了使用Azure Functions核心工具开发、测试和部署Azure函数所涉及的组件和工作流程。以下是详细描述：
- en: '**Developer**: The developer interacts with the local machine to develop, build,
    test, and debug Azure Functions.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者**：开发者与本地机器交互，以开发、构建、测试和调试Azure Functions。'
- en: '**Local Machine**: This is the developer’s environment where Azure Functions
    Core Tools are installed. It provides a local development environment that mimics
    Azure Functions runtime.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地机器**：这是开发者安装Azure Functions核心工具的环境。它提供了一个本地开发环境，该环境模拟Azure Functions的运行时。'
- en: '**Azure Functions Runtime**: This component simulates the Azure Functions runtime
    on the local machine, allowing the developer to execute and test functions locally
    before deploying them to Azure.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Functions Runtime**：此组件在本地机器上模拟 Azure Functions 运行时，允许开发者在将函数部署到 Azure
    之前在本地执行和测试函数。'
- en: '**Functions**: These are the individual functions created and managed by the
    developer. They are executed by the Azure Functions runtime and can be deployed
    to Azure.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：这些是由开发者创建和管理的单个函数。它们由 Azure Functions 运行时执行，并可以部署到 Azure。'
- en: '**Azure**: This represents the Azure cloud environment where the functions
    are deployed. Once the functions are tested locally, they are deployed to Azure
    for production use.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure**：这代表函数部署的 Azure 云环境。一旦函数在本地测试通过，它们就会被部署到 Azure 以用于生产。'
- en: '**Azure DevOps**: This is a set of development tools and services for managing
    the entire application lifecycle. It integrates with Azure Functions Core Tools
    to enable continuous deployment of functions to Azure.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure DevOps**：这是一套用于管理整个应用程序生命周期的开发工具和服务。它与 Azure Functions Core Tools 集成，以启用函数的持续部署到
    Azure。'
- en: '**GitHub Actions**: This is a **Continuous Integration** (**CI**) and **Continuous
    Deployment** (**CD**) platform provided by GitHub. It integrates with Azure Functions
    Core Tools to automate the deployment of functions to Azure.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub Actions**：这是 GitHub 提供的 **持续集成**（**CI**）和 **持续部署**（**CD**）平台。它与 Azure
    Functions Core Tools 集成，以自动化函数的 Azure 部署。'
- en: '*Figure 9**.2* represents the complete workflow of using Azure Functions Core
    Tools for local development, testing, and continuous deployment of Azure Functions.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9*.2*表示使用 Azure Functions Core Tools 进行本地开发、测试和持续部署 Azure Functions 的完整工作流程。'
- en: Google Cloud Functions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Cloud Functions
- en: '**Google Cloud Functions** is a lightweight, event-driven compute service that
    allows you to run your code in response to events. It is designed for building
    and connecting cloud services with simple, single-purpose functions, as shown
    in *Figure 9**.3*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud Functions** 是一种轻量级的、事件驱动的计算服务，允许您在事件发生时运行代码。它旨在通过简单、单功能的函数构建和连接云服务，如*图
    9*.3*所示：'
- en: '![Figure 9.3: Google Cloud Functions](img/B20937_09_03.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3：Google Cloud Functions](img/B20937_09_03.jpg)'
- en: 'Figure 9.3: Google Cloud Functions'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：Google Cloud Functions
- en: '*Figure 9**.3* illustrates the architecture of Google Cloud Functions, showcasing
    its components and their interactions. Google Cloud Functions is the core component
    where the serverless functions reside. These functions can be triggered by various
    **event sources**, such as the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9*.3*展示了 Google Cloud Functions 的架构，展示了其组件及其交互。Google Cloud Functions 是无服务器函数驻留的核心组件。这些函数可以被各种
    **事件源**触发，如下所示：'
- en: '**HTTP request**: Functions can be triggered by HTTP requests, enabling web-based
    interactions'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP 请求**：函数可以被 HTTP 请求触发，从而实现基于 Web 的交互'
- en: '**Cloud Pub/Sub**: Functions can process messages from Cloud Pub/Sub, a messaging
    service that allows you to send and receive messages between independent applications'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云 Pub/Sub**：函数可以处理 Cloud Pub/Sub（一种允许您在独立应用程序之间发送和接收消息的消息服务）的消息。'
- en: '**Cloud storage**: Functions can be triggered by events in Cloud Storage, such
    as file creation, modification, or deletion'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云存储**：函数可以被云存储中的事件触发，例如文件创建、修改或删除'
- en: '**Firestore**: Functions can interact with Firestore, a NoSQL document database,
    to read and write data'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firestore**：函数可以与 Firestore（一个 NoSQL 文档数据库）交互，以读取和写入数据'
- en: '**Other event sources**: Functions can also be triggered by other supported
    event sources, providing flexibility in handling various types of events'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他事件源**：函数还可以由其他支持的事件源触发，提供了处理各种类型事件时的灵活性'
- en: This architecture allows developers to build event-driven applications using
    serverless functions, eliminating the need to manage server infrastructure. It
    integrates seamlessly with various Google Cloud services, providing a scalable
    and flexible environment for running event-driven code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构允许开发者使用无服务器函数构建事件驱动的应用程序，消除了管理服务器基础设施的需要。它与各种 Google Cloud 服务无缝集成，为运行事件驱动代码提供了一个可扩展和灵活的环境。
- en: Oracle Functions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle Functions
- en: '**Oracle Functions** is a fully managed serverless platform that allows you
    to run your code without provisioning or managing servers.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**Oracle Functions** 是一个完全管理的无服务器平台，允许您运行代码而无需配置或管理服务器。'
- en: '![Figure 9.4: Oracle Functions](img/B20937_09_04.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4：Oracle Functions](img/B20937_09_04.jpg)'
- en: 'Figure 9.4: Oracle Functions'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：Oracle Functions
- en: '*Figure 9**.4* illustrates Oracle Functions’ architecture, highlighting key
    components:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.4* 展示了Oracle Functions的架构，突出了关键组件：'
- en: '**Oracle Functions**: Core serverless compute service built on the open source
    Fn Project'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle Functions**：基于开源Fn Project构建的核心无服务器计算服务'
- en: '**GraalVM**: High-performance runtime environment is known for excellent cold
    start performance'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraalVM**：高性能运行环境以其出色的冷启动性能而闻名'
- en: '**Bare Metal Servers**: Underlying infrastructure for enhanced performance
    and predictability'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**裸金属服务器**：增强性能和可预测性的基础基础设施'
- en: '**API Gateway**: Manages and routes incoming requests to appropriate functions'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关**：管理和路由传入请求到适当的函数'
- en: '**Event sources and triggers**: Various origins and activators of function
    execution'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件源和触发器**：函数执行的多种来源和激活器'
- en: 'The key advantages include the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关键优势包括以下内容：
- en: '**Performance**: GraalVM on bare-metal servers reduces cold start times and
    enhances overall function performance'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：在裸金属服务器上运行的GraalVM减少了冷启动时间并提高了整体函数性能'
- en: '**Flexibility**: Versatile function triggering and management through API Gateway
    and diverse event sources'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：通过API网关和多样化的事件源实现灵活的函数触发和管理'
- en: '**Efficiency**: Better resource utilization by avoiding container overhead'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：通过避免容器开销实现更好的资源利用'
- en: 'The main differences from traditional serverless architectures are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统无服务器架构的主要区别如下：
- en: '**Runtime**: Uses GraalVM instead of traditional JVM runtimes'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**：使用GraalVM而不是传统的JVM运行时'
- en: '**Deployment**: Functions run on bare-metal servers, not virtualized environments
    or containers'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：函数在裸金属服务器上运行，而不是虚拟化环境或容器中'
- en: '**Architecture**: Is container-native but containerless, avoiding common container
    overhead'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构**：是容器原生但无容器，避免了常见的容器开销'
- en: '**Foundation**: Based on the open source Fn Project, unlike many proprietary
    offerings'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础**：基于开源Fn Project，与许多专有产品不同'
- en: These features contribute to Oracle Functions’ focus on high performance and
    efficiency, particularly in cold start times and resource utilization.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性有助于Oracle Functions专注于高性能和效率，尤其是在冷启动时间和资源利用方面。
- en: Oracle Functions’ bare-metal deployment excels in performance-critical scenarios
    where speed and predictable latency are top priorities. However, for cost-conscious
    applications, containerized options such as AWS Lambda may be more appealing.
    If you prioritize cold starts in Java workloads, Oracle Functions, powered by
    GraalVM, offer a potential advantage. For applications processing highly sensitive
    data, bare-metal’s isolation might be preferable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Functions的裸金属部署在性能关键场景中表现出色，在这些场景中，速度和可预测的延迟是首要任务。然而，对于成本敏感的应用，容器化选项如AWS
    Lambda可能更具吸引力。如果您在Java工作负载中优先考虑冷启动，由GraalVM支持的Oracle Functions可能具有潜在优势。对于处理高度敏感数据的应用程序，裸金属的隔离可能更可取。
- en: Industry examples – Java serverless functions with a focus on concurrency
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行业案例 – 专注于并发的Java无服务器函数
- en: Let’s dive into some real-world examples of how companies are using Java serverless
    functions and how they handle concurrency in their applications. We’ll explore
    industry examples, extract valuable lessons learned, and examine a code example
    to understand the practical aspects of implementing Java serverless applications
    with concurrency in mind.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一些公司如何使用Java无服务器函数以及它们如何在应用程序中处理并发的真实世界案例。我们将探讨行业案例，提取宝贵的经验教训，并检查代码示例，以了解在考虑并发的情况下实现Java无服务器应用程序的实际方面。
- en: Airbnb – optimizing property listings with serverless solutions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Airbnb – 使用无服务器解决方案优化房产列表
- en: 'Airbnb, a leading online marketplace for lodging and experiences, employs serverless
    architectures to enhance the management of property listings and user interactions.
    Airbnb uses AWS Lambda to achieve this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Airbnb，领先的在线住宿和体验市场，采用无服务器架构来增强房产列表和用户交互的管理。Airbnb使用AWS Lambda来实现这一点：
- en: '**Image processing**: When a host uploads images of their property, an AWS
    Lambda function is triggered to process and optimize the images for various device
    formats and resolutions. This task is performed concurrently to handle *multiple*
    *uploads efficiently*.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像处理**：当托管方上传其房产的图像时，AWS Lambda函数被触发以处理和优化图像，以适应各种设备格式和分辨率。这项任务以并发方式执行，以有效地处理*多个*
    *上传*。'
- en: '**Search indexing**: AWS Lambda functions update search indexes in real time
    as new properties are listed or existing ones are updated. This ensures that users
    receive the most accurate and current search results.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索索引**：AWS Lambda函数在新的属性被列出或现有的属性被更新时实时更新搜索索引。这确保了用户能够接收到最准确和最新的搜索结果。'
- en: By leveraging AWS Lambda, Airbnb ensures high performance, flexibility, and
    reliability in their serverless architecture. Image processing and search indexing
    are performed quickly and efficiently, enhancing user experience. The ability
    to deploy and update serverless functions independently allows for rapid iteration
    and deployment of new features. Additionally, serverless functions provide high
    availability and fault tolerance, maintaining a seamless experience for users.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用AWS Lambda，Airbnb确保其无服务器架构中的高性能、灵活性和可靠性。图像处理和搜索索引快速高效地执行，提升了用户体验。独立部署和更新无服务器函数的能力允许快速迭代和部署新功能。此外，无服务器函数提供高可用性和容错性，为用户保持无缝体验。
- en: LinkedIn – enhancing data processing with serverless architectures
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LinkedIn – 利用无服务器架构增强数据处理
- en: 'LinkedIn, the world’s largest professional network, utilizes serverless architectures
    to manage and process vast amounts of data generated by user interactions, job
    postings, and content sharing. LinkedIn leverages Azure Functions to handle these
    tasks efficiently:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上最大的职业社交网络LinkedIn利用无服务器架构来管理和处理由用户交互、职位发布和内容共享产生的大量数据。LinkedIn利用Azure Functions来高效地处理这些任务：
- en: '**Real-time notifications**: LinkedIn uses Azure Functions to process real-time
    notifications. When a user receives a connection request or a message, an event
    triggers Azure Functions to process and deliver the notification promptly.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时通知**：LinkedIn使用Azure Functions来处理实时通知。当用户收到连接请求或消息时，一个事件触发Azure Functions来及时处理和发送通知。'
- en: '**Data analytics**: Azure Functions process data streams in real-time, aggregating
    metrics and generating insights. This allows LinkedIn to provide users with up-to-date
    analytics on their profiles, such as profile views and search appearances.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分析**：Azure Functions实时处理数据流，汇总指标并生成洞察。这使得LinkedIn能够向用户提供其个人资料的最新分析，例如资料查看和搜索出现次数。'
- en: Azure Functions enables LinkedIn to achieve scalability, efficiency, and cost-effectiveness
    in their serverless architecture. The automatic scaling capabilities of Azure
    Functions ensure that LinkedIn can handle millions of concurrent user interactions.
    Serverless functions reduce infrastructure management overhead, allowing LinkedIn’s
    engineering team to focus on developing new features. Moreover, the pay-per-use
    pricing model helps optimize costs during varying traffic periods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions使LinkedIn能够在其无服务器架构中实现可扩展性、效率和成本效益。Azure Functions的自动扩展功能确保LinkedIn能够处理数百万并发用户交互。无服务器函数减少了基础设施管理开销，使LinkedIn的工程团队能够专注于开发新功能。此外，按使用付费的定价模型有助于在流量波动期间优化成本。
- en: Expedia – streamlining travel booking with serverless solutions
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Expedia – 使用无服务器解决方案简化旅行预订
- en: 'Expedia, a global travel booking platform, leverages Java-based AWS Lambda
    functions to handle various aspects of its service, ensuring efficient and reliable
    operations across its platform:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 全球旅行预订平台Expedia利用基于Java的AWS Lambda函数来处理其服务的各个方面，确保其平台上的高效和可靠运行：
- en: '**Booking confirmation**: AWS Lambda functions manage booking confirmations
    in real time. When a user completes a booking, an event triggers a Lambda function
    to confirm the reservation, update the inventory, and notify the user.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订确认**：AWS Lambda函数实时管理预订确认。当用户完成预订时，一个事件触发Lambda函数来确认预订、更新库存并通知用户。'
- en: '**Price aggregation**: Expedia uses Lambda to aggregate prices from multiple
    airlines and hotels concurrently. This ensures that users receive the most competitive
    rates in real time, enhancing the booking experience.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**价格聚合**：Expedia使用Lambda从多家航空公司和酒店同时聚合价格。这确保了用户能够实时获得最具竞争力的价格，提升了预订体验。'
- en: '**User notifications**: Lambda functions send personalized notifications to
    users about their bookings, including updates, reminders, and special offers.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户通知**：Lambda函数向用户发送个性化的通知，包括更新、提醒和特别优惠。'
- en: AWS Lambda enables Expedia to achieve scalability, efficiency, and improved
    user experience in its serverless architecture. The automatic scaling capabilities
    of AWS Lambda allow Expedia to handle peaks in booking volumes seamlessly. Serverless
    functions streamline complex processes, such as price aggregation, by handling
    multiple data sources concurrently. Real-time notifications and confirmations
    enhance the overall user experience, providing timely and relevant information
    to travelers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda使Expedia能够在其无服务器架构中实现可扩展性、效率和改进的用户体验。AWS Lambda的自动扩展功能允许Expedia无缝处理预订量的高峰。无服务器函数通过同时处理多个数据源来简化复杂流程，例如价格聚合。实时通知和确认增强了整体用户体验，为旅行者提供及时和相关的信息。
- en: These case studies demonstrate how industry leaders leverage serverless architectures
    and concurrency management to optimize their applications. By employing serverless
    solutions, companies can achieve scalability, efficiency, cost-effectiveness,
    and enhanced user experiences in their respective domains.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些案例研究展示了行业领导者如何利用无服务器架构和并发管理来优化其应用程序。通过采用无服务器解决方案，公司可以在各自的领域实现可扩展性、效率、成本效益和增强的用户体验。
- en: Building with serverless frameworks – a practical approach
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无服务器框架构建——一种实用方法
- en: Serverless frameworks are the developer’s toolbox for crafting efficient and
    robust serverless applications. These frameworks go beyond the core compute services
    offered by cloud providers, providing a comprehensive set of tools and functionalities.
    In this section, we’ll delve into the importance of serverless frameworks and
    how they streamline the development process. To solidify this understanding, we’ll
    explore a real-world example using code demonstrations. Specifically, we’ll see
    how AWS SAM simplifies defining and deploying serverless applications on AWS.
    By the end of this section, you’ll be equipped to leverage the power of serverless
    frameworks in your own projects!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器框架是开发者的工具箱，用于构建高效且健壮的无服务器应用程序。这些框架超越了云提供商提供的核心计算服务，提供了一套全面的工具和功能。在本节中，我们将深入了解无服务器框架的重要性以及它们如何简化开发过程。为了巩固这一理解，我们将通过代码演示探索一个真实世界的例子。具体来说，我们将看到AWS
    SAM如何简化在AWS上定义和部署无服务器应用程序。在本节结束时，您将能够在自己的项目中利用无服务器框架的力量！
- en: Using AWS SAM to define and deploy a serverless application
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AWS SAM定义和部署无服务器应用程序
- en: We’ll design a simulation of a global travel booking platform that leverages
    Java-based AWS Lambda functions to handle various aspects of their service. This
    includes booking validation, payment processing, security checks, inventory updates,
    data processing, and user notifications. We’ll use AWS Step Functions to orchestrate
    these tasks, DynamoDB for data storage, AWS Cognito for security checks, and API
    Gateway to expose endpoints.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个全球旅行预订平台的模拟，该平台利用基于Java的AWS Lambda函数来处理其服务的各个方面。这包括预订验证、支付处理、安全检查、库存更新、数据处理和用户通知。我们将使用AWS
    Step Functions来编排这些任务，使用DynamoDB进行数据存储，使用AWS Cognito进行安全检查，以及使用API Gateway来公开端点。
- en: 'Please look at *Figure 9**.5*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看*图9**.5*：
- en: '![Figure 9.5: A global travel booking system](img/B20937_09_05.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：全球旅行预订系统](img/B20937_09_05.jpg)'
- en: 'Figure 9.5: A global travel booking system'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：全球旅行预订系统
- en: To accomplish this task, we’ll utilize AWS cloud services within a serverless
    architecture. Our approach involves coordinating multiple Lambda functions using
    AWS Step Functions, a service designed to orchestrate complex workflows. This
    allows us to define the order of execution for each function and gracefully handle
    potential errors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这项任务，我们将在无服务器架构中使用AWS云服务。我们的方法涉及使用AWS Step Functions协调多个Lambda函数，这是一个旨在编排复杂工作流的服务。这使得我们能够定义每个函数的执行顺序，并优雅地处理潜在的错误。
- en: In our travel booking system, several specialized Lambda functions collaborate
    within a *Step Functions* workflow. These functions include `BookingValidationFunction`,
    `PaymentProcessingFunction`, `SecurityCheckFunction`, `InventoryUpdateFunction`,
    `DataProcessingFunction`, and `SendNotificationFunction`. Each function handles
    a specific step in the booking process. In this section, we’ll focus on `BookingValidationFunction`
    as an illustrative example. The Java code for this function is presented below,
    while the code for the remaining functions can be found in the GitHub repository.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的旅行预订系统中，几个专门的Lambda函数在*Step Functions*工作流程中协作。这些函数包括`BookingValidationFunction`、`PaymentProcessingFunction`、`SecurityCheckFunction`、`InventoryUpdateFunction`、`DataProcessingFunction`和`SendNotificationFunction`。每个函数处理预订过程中的特定步骤。在本节中，我们将重点关注`BookingValidationFunction`作为示例。此函数的Java代码如下，而其余函数的代码可以在GitHub存储库中找到。
- en: By using Step Functions, we gain the ability to create a more robust and manageable
    system. Step Functions simplify error handling, provide visibility into workflow
    progress, and enable us to retry failed steps automatically. This results in a
    more reliable and scalable solution for managing the complexities of the travel
    booking process.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Step Functions，我们获得了创建更健壮和可管理的系统的能力。Step Functions简化了错误处理，提供了对工作流程进度的可见性，并使我们能够自动重试失败的步骤。这导致了一个更可靠和可扩展的解决方案，用于管理旅行预订过程的复杂性。
- en: '`BookingValidationFunction` is responsible for validating the booking request
    data, ensuring that all required fields and data formats are correct. It also
    verifies the availability of requested items or dates by querying the DynamoDB
    table.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingValidationFunction`负责验证预订请求数据，确保所有必需字段和数据格式都是正确的。它还通过查询DynamoDB表来验证请求的项目或日期的可用性。'
- en: 'Here is the Java code for `BookingValidationFunction`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`BookingValidationFunction`的Java代码：
- en: '[PRE6]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: BookingValidationFunctionApplication is a Spring Boot application that serves
    as a serverless function for validating booking details.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: BookingValidationFunctionApplication是一个Spring Boot应用程序，作为验证预订详情的无服务器函数。
- en: The `bookingValidation()` method, annotated with `@Bean`, is the main function
    that validates the booking details based on the input data. It checks for the
    presence of required fields, verifies the availability of the booking by querying
    `BookingTable` in DynamoDB (placeholder logic), and returns a response map with
    the validation status.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 被`@Bean`注解的`bookingValidation()`方法是根据输入数据验证预订详情的主要功能。它检查所需字段的是否存在，通过查询DynamoDB中的`BookingTable`（占位符逻辑）来验证预订的可用性，并返回包含验证状态的响应映射。
- en: The class also includes placeholder methods for implementing the validation
    logic `validateBooking()` and availability check logic `verifyAvailability()`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包括用于实现验证逻辑的占位符方法`validateBooking()`和可用性检查逻辑`verifyAvailability()`。
- en: 'Next, we create the necessary resources in the CloudFormation template. The
    DynamoDB tables `BookingTable` and `InventoryTable` store and manage the booking
    and inventory data respectively, enabling efficient and scalable persistence of
    information related to travel bookings and available inventory items:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在CloudFormation模板中创建必要的资源。DynamoDB表`BookingTable`和`InventoryTable`分别存储和管理预订和库存数据，从而实现与旅行预订和可用库存项目相关的信息的有效和可扩展的持久化。
- en: '[PRE7]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our serverless architecture, we employ Amazon Cognito to handle user authentication
    and authorization. Cognito is a fully managed service that allows you to easily
    add user sign-up, sign-in, and access control to your web and mobile apps.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的无服务器架构中，我们使用Amazon Cognito来处理用户身份验证和授权。Cognito是一个完全托管的服务，允许您轻松地将用户注册、登录和访问控制添加到您的Web和移动应用程序中。
- en: 'In our case, we’ll create a Cognito user pool (`CognitoUserPool`). This user
    directory serves as the central repository for our application’s user identities.
    When users register or sign in, Cognito securely stores their information and
    handles the authentication process. It provides features such as the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将创建一个Cognito用户池（`CognitoUserPool`）。这个用户目录作为我们应用程序用户身份的中心存储库。当用户注册或登录时，Cognito安全地存储他们的信息并处理身份验证过程。它提供了以下功能：
- en: '**User management**: Create, read, update, and delete user profiles'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户管理**：创建、读取、更新和删除用户资料'
- en: '**Authentication**: Verify user credentials and issue secure tokens (e.g.,
    JWTs) for access'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：验证用户凭据并颁发安全令牌（例如，JWTs）以进行访问'
- en: '**Security**: Enforce password policies, multi-factor authentication (MFA),
    and other security measures'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：强制执行密码策略、多因素认证（MFA）和其他安全措施'
- en: '**Authorization**: Define fine-grained access controls based on user attributes
    or groups'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：根据用户属性或组定义细粒度的访问控制'
- en: '**Federation**: Integrate with external identity providers such as Facebook,
    Google, or enterprise identity systems'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联邦**：与外部身份提供者（如 Facebook、Google 或企业身份系统）集成'
- en: 'By leveraging Cognito, we can offload the complexities of user management and
    focus on building the core functionality of our travel booking application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Cognito，我们可以卸载用户管理的复杂性，专注于构建旅行预订应用程序的核心功能：
- en: '[PRE8]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the data processing is complete, the processed data is uploaded to `ProcessedDataBucket`,
    which is an S3 bucket:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理完成后，处理后的数据上传到 `ProcessedDataBucket`，这是一个 S3 存储桶：
- en: '[PRE9]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create an Amazon SNS topic named `BookingNotificationTopic` to facilitate sending
    notifications related to booking events:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `BookingNotificationTopic` 的 Amazon SNS 主题，以方便发送与预订事件相关的通知：
- en: '[PRE10]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define an AWS `LambdaExecutionRole` with the necessary permissions for the
    Lambda functions to access and interact with various AWS services, such as DynamoDB,
    S3, SNS, and Cognito:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 AWS `LambdaExecutionRole`，为 Lambda 函数提供必要的权限，以便访问和交互各种 AWS 服务，例如 DynamoDB、S3、SNS
    和 Cognito：
- en: '[PRE11]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Specify the function names, handlers, runtime, and code location (S3 bucket
    and key) for each Lambda function. Specify the function names, handlers, runtime,
    and code location (S3 bucket and key) for each Lambda function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个 Lambda 函数指定函数名称、处理程序、运行时和代码位置（S3 存储桶和键）。为每个 Lambda 函数指定函数名称、处理程序、运行时和代码位置（S3
    存储桶和键）：
- en: '[PRE12]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For each of the other Lambda functions (`PaymentProcessingFunction`, `SecurityCheckFunction`,
    `InventoryUpdateFunction`, `DataProcessingFunction`, and `SendNotificationFunction`),
    you would write similar definitions within the `Resources` section of your CloudFormation
    template, adjusting the `FunctionName`, `Handler`, `CodeUri`, and `Policies` properties
    to match their respective implementations.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他每个 Lambda 函数（`PaymentProcessingFunction`、`SecurityCheckFunction`、`InventoryUpdateFunction`、`DataProcessingFunction`
    和 `SendNotificationFunction`），你将在 CloudFormation 模板的 `Resources` 部分中编写类似的定义，调整
    `FunctionName`、`Handler`、`CodeUri` 和 `Policies` 属性以匹配各自的实现。
- en: 'Next, we create the Step Functions state machine in the CloudFormation template.
    Use the `AWS::StepFunctions::StateMachine` resource type and define the state
    machine definition in the `DefinitionString` property using Amazon States Language:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 CloudFormation 模板中创建 Step Functions 状态机。使用 `AWS::StepFunctions::StateMachine`
    资源类型，并在 `DefinitionString` 属性中使用 Amazon States Language 定义状态机定义：
- en: '[PRE13]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This AWS Step Functions state machine definition describes the workflow for
    a travel booking system. The workflow starts with a parallel execution of three
    tasks: `"BookingValidation"`, `"PaymentProcessing"`, and `"SecurityCheck"`. These
    tasks are performed concurrently using separate Lambda functions.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此 AWS Step Functions 状态机定义描述了旅行预订系统的流程。该流程从三个任务的并行执行开始："BookingValidation"、"PaymentProcessing"
    和 "SecurityCheck"。这些任务通过使用单独的 Lambda 函数同时执行。
- en: After the parallel tasks are complete, the workflow proceeds to the `"InventoryUpdate"`
    task, which updates the inventory using the `"InventoryUpdateFunction"` Lambda
    function.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 并行任务完成后，工作流程继续到 `"InventoryUpdate"` 任务，该任务使用 `"InventoryUpdateFunction"` Lambda
    函数更新库存。
- en: Next, the `"DataProcessing"` task is executed using the `"DataProcessingFunction"`
    Lambda function to perform any necessary data processing.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `"DataProcessingFunction"` Lambda 函数执行 `"DataProcessing"` 任务，以进行任何必要的数据处理。
- en: Finally, the `"SendNotification"` task is triggered, which uses the `"SendNotification`
    **Function"** Lambda function to send notifications to the user.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，触发 `"SendNotification"` 任务，该任务使用 `"SendNotification Function"` Lambda 函数向用户发送通知。
- en: The state machine definition utilizes the previously created Lambda functions
    and specifies the flow and order in which these tasks are executed. This enables
    a structured and coordinated workflow for handling travel bookings.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机定义利用之前创建的 Lambda 函数，并指定这些任务执行的流程和顺序。这为处理旅行预订提供了一个结构化和协调的工作流程。
- en: 'The following code sets up an API gateway for the travel booking application:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码为旅行预订应用程序设置 API 网关：
- en: '[PRE14]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `TravelBookingApi` resource creates a new REST API named `TravelBookingApi`.
    Now, `TravelBookingResource` defines a new resource path `/booking` under this
    API. `TravelBookingMethod` sets up a `POST` method for the `/booking` resource,
    which is integrated with AWS Step Functions to start the travel booking workflow
    execution.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`TravelBookingApi` 资源创建了一个名为 `TravelBookingApi` 的新 REST API。现在，`TravelBookingResource`
    在此 API 下定义了一个新的资源路径 `/booking`。`TravelBookingMethod` 为 `/booking` 资源设置了一个 `POST`
    方法，该方法与 AWS Step Functions 集成以启动旅行预订工作流程执行。'
- en: Deploy the Java code and the CloudFormation stack (prepare your environment).
    Ensure you have an AWS account and the necessary permissions to create resources
    such as DynamoDB tables, API Gateway, Lambda functions, IAM roles, and so on.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 代码和 CloudFormation 堆栈部署（准备您的环境）。确保您有一个 AWS 账户，并且有创建资源（如 DynamoDB 表、API
    Gateway、Lambda 函数、IAM 角色 等）所需的必要权限。
- en: Install and configure the AWS CLI if you haven’t already. Instructions can be
    found at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装和配置 AWS CLI，请查阅[https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html)中的说明。
- en: Package your Lambda function code into JAR files and upload them to an S3 bucket.
    Note that the S3 bucket name and the keys (paths) where the JAR files are stored.
    You’ll need these when running the CloudFormation script.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Lambda 函数代码打包成 JAR 文件，并上传到 S3 桶中。请注意 S3 桶的名称以及存储 JAR 文件的键（路径）。在运行 CloudFormation
    脚本时需要这些信息。
- en: 'After that, modify the CloudFormation script. Ensure that the `S3Bucket: !Ref
    Bucket Name` and `S3Key: booking-validation-1.0-SNAPSHOT.jar` parameter values
    match the S3 bucket name where your Lambda code is stored and the JAR file name.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，修改 CloudFormation 脚本。确保 `S3Bucket: !Ref Bucket Name` 和 `S3Key: booking-validation-1.0-SNAPSHOT.jar`
    参数值与存储您的 Lambda 代码的 S3 桶名称和 JAR 文件名称匹配。'
- en: Run the CloudFormation script. Save the CloudFormation script to a file, for
    example, `travel-booking-template.yaml`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 CloudFormation 脚本。将 CloudFormation 脚本保存到文件中，例如，`travel-booking-template.yaml`。
- en: 'Open a terminal or command prompt. Run the following command to create a new
    CloudFormation stack:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端或命令提示符。运行以下命令以创建一个新的 CloudFormation 堆栈：
- en: '[PRE15]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Replace `YOUR_S3_BUCKET_NAME` with the actual name of your S3 bucket, and the
    `stack-name` with your stack name.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `YOUR_S3_BUCKET_NAME` 替换为您的 S3 桶的实际名称，并将 `stack-name` 替换为您的堆栈名称。
- en: The `--parameters` flag is used to pass parameters to the CloudFormation template.
    Parameters are defined in the template and allow you to provide dynamic values
    at stack creation time. In this case, the `--parameters` flag is used to specify
    the S3 bucket name where the Lambda code is stored.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`--parameters` 标志用于将参数传递给 CloudFormation 模板。参数在模板中定义，允许您在堆栈创建时提供动态值。在这种情况下，`--parameters`
    标志用于指定存储 Lambda 代码的 S3 桶名称。'
- en: 'You can monitor the progress of your stack creation in the AWS Management Console
    under CloudFormation. Alternatively, you can use the AWS CLI to check the status:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 AWS 管理控制台中的 CloudFormation 下监控堆栈创建的进度。或者，您可以使用 AWS CLI 检查状态：
- en: '[PRE16]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Replace the stack name `TravelBookingStack` with your stack name.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将堆栈名称 `TravelBookingStack` 替换为您的堆栈名称。
- en: Once the stack creation is complete, verify that all the resources (DynamoDB
    tables, API Gateway, Lambda functions, IAM roles, etc.) have been created successfully.
    You can navigate to each service in the AWS Management Console to check the resources.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦堆栈创建完成，请验证所有资源（DynamoDB 表、API Gateway、Lambda 函数、IAM 角色 等）是否已成功创建。您可以通过 AWS
    管理控制台中的每个服务来检查资源。
- en: After the resources are deployed, you can test the API Gateway endpoint. The
    API Gateway URL can be found in either the outputs section of the CloudFormation
    stack or directly in the API Gateway service in the AWS Management Console.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 资源部署完成后，您可以测试 API Gateway 端点。API Gateway URL 可在 CloudFormation 堆栈的输出部分或 AWS
    管理控制台中的 API Gateway 服务中找到。
- en: We can test API Gateway using a tool such as curl or Postman.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 curl 或 Postman 等工具测试 API Gateway。
- en: 'First, we use curl:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 curl：
- en: '[PRE17]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Replace `YOUR_API_GATEWAY_URL` with the actual URL of your API Gateway instance.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `YOUR_API_GATEWAY_URL` 替换为您的 API Gateway 实例的实际 URL。
- en: 'Next, we use Postman:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 Postman：
- en: Set the HTTP method to `POST`
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 HTTP 方法设置为 `POST`
- en: Enter the URL of your API gateway followed by `/booking`
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入您的 API 网关的 URL，后跟 `/booking`
- en: 'In the body of the request, use raw JSON to provide the required booking details.
    Here is an example of a JSON payload:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求体中，使用原始 JSON 提供所需的预订详情。以下是一个 JSON 有效负载的示例：
- en: '[PRE18]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Deleting the CloudFormation stack will remove all the resources created by
    the stack, helping to avoid unnecessary costs and resource usage. To delete the
    resources created by the CloudFormation stack, run the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 删除CloudFormation堆栈将删除堆栈创建的所有资源，有助于避免不必要的成本和资源使用。要删除CloudFormation堆栈创建的资源，请运行以下命令：
- en: '[PRE19]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Replace the stack name `TravelBookingStack` with your stack name.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 将堆栈名称`TravelBookingStack`替换为您自己的堆栈名称。
- en: 'This section explored serverless frameworks for building travel booking applications.
    We highlighted their advantages and how they streamline development. The key takeaways
    are as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了用于构建旅行预订应用的无服务器框架。我们强调了它们的优点以及它们如何简化开发。关键要点如下：
- en: Serverless frameworks simplify development with comprehensive tools
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器框架通过综合工具简化了开发
- en: We built a Java-based booking validation function using Spring Cloud Function
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Spring Cloud Function构建了一个基于Java的预订验证函数
- en: AWS Step Functions orchestrated tasks within the booking workflow
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Step Functions在预订工作流程中编排任务
- en: We explored integrating DynamoDB, Cognito, API Gateway, and other AWS services
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探讨了将DynamoDB、Cognito、API Gateway和其他AWS服务集成
- en: By understanding these concepts, you’re equipped to leverage serverless frameworks
    for building efficient travel booking applications and explore further functionalities
    offered by these frameworks and AWS services.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些概念，您将能够利用无服务器框架构建高效的旅行预订应用，并探索这些框架和AWS服务提供的进一步功能。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored serverless computing and its integration with Java’s
    concurrency capabilities. We examined the core concepts of serverless architectures,
    including event-driven processing, statelessness, and automatic scaling, along
    with their advantages and potential drawbacks. Understanding these concepts is
    crucial for effectively leveraging serverless computing in your applications.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了无服务器计算及其与Java并发能力的集成。我们检查了无服务器架构的核心概念，包括事件驱动处理、无状态和自动扩展，以及它们的优点和潜在缺点。理解这些概念对于在您的应用程序中有效地利用无服务器计算至关重要。
- en: We discussed adapting Java’s concurrency model to serverless environments, focusing
    on tools such as CompletableFuture and parallel streams. We highlighted the best
    practices for Java serverless applications, including strategies for minimizing
    cold starts, efficient resource management, and leveraging frameworks such as
    Spring Cloud Function, Micronaut, and Quarkus.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了将Java的并发模型适应无服务器环境，重点关注CompletableFuture和并行流等工具。我们强调了Java无服务器应用程序的最佳实践，包括最小化冷启动、高效资源管理和利用Spring
    Cloud Function、Micronaut和Quarkus等框架的策略。
- en: The chapter introduced major serverless platforms such as AWS SAM, Azure Functions
    Core Tools, Google Cloud Functions, and Oracle Functions, highlighting their unique
    features and how they simplify the development and deployment of serverless applications.
    We explored Java-specific optimization techniques to enhance performance and reduce
    latency in serverless environments.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了主要的无服务器平台，如AWS SAM、Azure Functions Core Tools、Google Cloud Functions和Oracle
    Functions，突出了它们的独特功能和如何简化无服务器应用程序的开发和部署。我们探讨了针对Java的优化技术，以增强无服务器环境中的性能并减少延迟。
- en: Through real-world examples from companies such as Airbnb, LinkedIn, and Expedia,
    we saw practical applications of serverless architectures and concurrency management.
    These case studies illustrated how industry leaders leverage serverless solutions
    to achieve scalability, efficiency, and enhanced user experiences.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Airbnb、LinkedIn和Expedia等公司的实际案例，我们看到了无服务器架构和并发管理的实际应用。这些案例研究说明了行业领导者如何利用无服务器解决方案实现可扩展性、效率和提升用户体验。
- en: Finally, we provided a hands-on example of building a travel booking application
    using AWS SAM, demonstrating how to integrate various AWS services and orchestrate
    workflows using AWS Step Functions. This practical approach equipped you with
    the knowledge to deploy and manage serverless applications effectively.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供了一个使用AWS SAM构建旅行预订应用的动手示例，展示了如何集成各种AWS服务并使用AWS Step Functions编排工作流程。这种实用方法使您能够有效地部署和管理无服务器应用程序。
- en: By the end of this chapter, you should be well-equipped to leverage Java’s concurrency
    features in serverless environments, apply optimization best practices, and make
    informed decisions about using serverless architectures in your projects.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够充分利用Java的并发功能，应用优化最佳实践，并在项目中使用无服务器架构做出明智的决定。
- en: 'As we transition from serverless architectures to broader cloud computing paradigms,
    our next chapter will explore another crucial aspect of modern application development:
    auto-scaling. [*Chapter 10*](B20937_10.xhtml#_idTextAnchor256) will delve into
    synchronizing Java’s concurrency models with cloud auto-scaling dynamics, building
    upon the concurrent programming concepts we’ve discussed and applying them to
    the elastic nature of cloud environments. This knowledge will be essential for
    developers looking to create robust, scalable Java applications that can efficiently
    adapt to varying workloads in cloud platforms.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们从无服务器架构过渡到更广泛的云计算范式，下一章将探讨现代应用程序开发的另一个关键方面：自动扩展。[*第10章*](B20937_10.xhtml#_idTextAnchor256)
    将深入探讨同步Java的并发模型与云自动扩展动态，基于我们讨论的并发编程概念，并将它们应用于云环境的弹性特性。对于希望创建健壮、可扩展的Java应用程序，能够高效适应云平台中不同工作负载的开发者来说，这些知识将是必不可少的。
- en: Questions
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the primary advantage of serverless computing over traditional server-based
    architectures?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与传统的基于服务器的架构相比，无服务器计算的主要优势是什么？
- en: Higher server management overhead
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更高的服务器管理开销
- en: Manual scaling of resources
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源的手动扩展
- en: Automatic scaling and reduced operational overhead
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动扩展和降低运营开销
- en: Limited integration with cloud services
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与云服务的集成有限
- en: Which Java concurrency feature is particularly useful for performing asynchronous
    tasks in serverless functions?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Java并发特性特别适用于在无服务器函数中执行异步任务？
- en: '**Java Virtual** **Machine** (**JVM**)'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java虚拟** **机** (**JVM**)'
- en: CompletableFuture
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CompletableFuture
- en: '**Java Database** **Connectivity** (**JDBC**)'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java数据库** **连接** (**JDBC**)'
- en: JavaBeans
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaBeans
- en: What is the primary purpose of the Fork/Join framework in Java serverless applications?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fork/Join框架在Java无服务器应用程序中的主要目的是什么？
- en: Encrypting data transfers
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密数据传输
- en: Handling single-threaded operations
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理单线程操作
- en: Managing recursive tasks by dividing them into smaller subtasks
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将任务划分为更小的子任务来管理递归任务
- en: Logging and error handling
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录和错误处理
- en: Which of the following best practices helps minimize cold starts in Java serverless
    applications?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项最佳实践有助于最小化Java无服务器应用程序的冷启动？
- en: Use the heaviest deployment package possible
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最重的部署包
- en: Optimize function size and use provisioned concurrency
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化函数大小并使用预配并发
- en: Avoid using any form of concurrency
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免使用任何形式的并发
- en: Enable all possible cloud services
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用所有可能的云服务
- en: What is a key benefit of using parallel streams in serverless Java functions?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用并行流在无服务器Java函数中的关键好处是什么？
- en: Blocking the main thread for all tasks
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阻塞所有任务的主线程
- en: Improved performance through concurrent data processing
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过并发数据处理提高性能
- en: Simplifying the deployment process
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化部署过程
- en: Reducing the need for error handling
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少错误处理的需求
- en: 'Part 3: Mastering Concurrency in the Cloud – The Final Frontier'
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：在云中掌握并发——最后的边疆
- en: As we reach the culmination of our journey through Java's concurrency landscape,
    *Part 3* explores the most advanced and forward-looking aspects of concurrent
    programming in cloud environments. This final section synthesizes the knowledge
    gained from previous chapters, applying it to the cutting-edge realm of cloud
    computing and beyond.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过Java并发景观的旅程达到高潮，*第三部分* 探讨了在云环境中并发编程最先进和前瞻性的方面。本节综合了之前章节中获得的知识，将其应用于云计算的前沿领域以及更远的地方。
- en: Each chapter offers practical, real-world examples and use cases, allowing readers
    to apply concepts from earlier parts of the book in innovative ways. As we conclude,
    *Part 3* equips readers with the vision and tools to be at the forefront of concurrent
    programming in the age of cloud computing and beyond, transforming them from proficient
    developers into masters of Java concurrency.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都提供了实用的、现实世界的例子和用例，使读者能够以创新的方式应用书中早期部分的概念。随着我们进入总结阶段，*第三部分* 为读者提供了愿景和工具，使他们能够在云计算时代及其之后的前沿并发编程中处于领先地位，将他们从熟练的开发者转变为Java并发的大师。
- en: 'This part includes the following chapters:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 10*](B20937_10.xhtml#_idTextAnchor256), *Synchronizing Java''s Concurrency
    with Cloud Auto-Scaling Dynamics*'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B20937_10.xhtml#_idTextAnchor256), *同步Java并发与云自动扩展动态*'
- en: '[*Chapter 11*](B20937_11.xhtml#_idTextAnchor278), *Advanced Java Concurrency
    Practices in Cloud Computing*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B20937_11.xhtml#_idTextAnchor278), *云计算中的高级Java并发实践*'
- en: '[*Chapter 12*](B20937_12.xhtml#_idTextAnchor295), *The Horizon Ahead*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B20937_12.xhtml#_idTextAnchor295), *未来的展望*'
