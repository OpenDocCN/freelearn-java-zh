- en: Chapter 6. Developing Applications with JBoss JMS Provider
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使用JBoss JMS提供程序开发应用程序
- en: Messaging is a method of communication between software components and applications.
    **Java Message Service** (**JMS**) is a Java API—designed originally by Sun—that
    allows applications to create, send, receive, and read messages. The new 2.0 version
    of the API has been introduced with JSR 343 ([https://jcp.org/en/jsr/detail?id=343](https://jcp.org/en/jsr/detail?id=343)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递是软件组件和应用程序之间的一种通信方法。**Java消息服务**（JMS）是一个Java API——最初由Sun设计——允许应用程序创建、发送、接收和读取消息。API的新2.0版本随着JSR
    343（[https://jcp.org/en/jsr/detail?id=343](https://jcp.org/en/jsr/detail?id=343)）被引入。
- en: Messaging differs from other standard protocols, such as **Remote Method Invocation**
    (**RMI**) or **Hypertext Transfer Protocol** (**HTTP**), in two ways. First, the
    conversation is mediated by a messaging server so it's not a two-way conversation
    between peers. Second, the sender and the receiver need to know what message format
    and what destination to use. This is in contrast to tightly coupled technologies,
    such as Remote Method Invocation (RMI), that require an application to know about
    a remote application's methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递与其他标准协议（如**远程方法调用**（RMI）或**超文本传输协议**（HTTP））在两个方面有所不同。首先，对话是通过消息服务器介导的，因此不是对等体之间的双向对话。其次，发送者和接收者需要知道使用什么消息格式和目标。这与需要应用程序了解远程应用程序方法的紧密耦合技术（如RMI）形成对比。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A brief introduction to message-oriented systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息导向系统的简要介绍
- en: The building blocks of the JBoss messaging subsystem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JBoss消息子系统的构建块
- en: Setting up proof of concept programming examples
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置概念验证编程示例
- en: How to use JMS and resource adapters to integrate with external systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JMS和资源适配器与外部系统集成
- en: A short introduction to JMS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JMS简述
- en: 'JMS defines a vendor-neutral (but Java-specific) set of programming interfaces
    to interact with asynchronous messaging systems. Messaging enables distributed
    communication that is loosely coupled. The whole messaging interchange is a two-step
    process where a component sends a message to a destination that is in turn retrieved
    by the recipient with the mediation of the JMS server. In JMS, there are two types
    of destinations: topics and queues. These have different semantics, which are
    explained next.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JMS定义了一套供应商中立的（但Java特定的）编程接口，用于与异步消息系统交互。消息传递实现了松散耦合的分布式通信。整个消息交换是一个两步过程，其中组件向目的地发送消息，然后由JMS服务器介导的接收者检索。在JMS中，有两种类型的目的地：主题和队列。它们有不同的语义，将在下面解释。
- en: 'In a point-to-point model, messages are sent from producers to consumers via
    queues. A given queue might have multiple receivers, but only one receiver would
    be able to consume each of the messages. Only the first receiver who requests
    the message will get it, while the others will not, as shown in the following
    image:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在点对点模型中，消息通过队列从生产者发送到消费者。一个特定的队列可能有多个接收者，但只有一个接收者能够消费每条消息。只有第一个请求消息的接收者会得到它，而其他人则不会，如下面的图像所示：
- en: '![A short introduction to JMS](img/00051.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![JMS简述](img/00051.jpeg)'
- en: 'A message sent to a **topic**, on the other hand, might be received by multiple
    parties. Messages published on a specific topic are sent to all the message consumers
    who have registered (subscribed) themselves to receive messages on that topic.
    A subscription can be **durable** or **nondurable**. A nondurable subscriber can
    only receive messages that are published while it is **active**. A nondurable
    subscription does not guarantee the delivery of a message; it might deliver the
    same message more than once. A durable subscription, on the other hand, guarantees
    that the consumer receives the message exactly once, as depicted in the following
    image:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，发送到**主题**的消息可能被多个当事人接收。发布在特定主题上的消息会被所有已注册（订阅）接收该主题消息的消息消费者接收。订阅可以是**持久的**或**非持久的**。非持久订阅者只能接收在其**活动**期间发布的消息。非持久订阅不能保证消息的投递；它可能会多次投递相同的消息。另一方面，持久订阅保证消费者恰好接收一次消息，如下面的图像所示：
- en: '![A short introduction to JMS](img/00052.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![JMS简述](img/00052.jpeg)'
- en: 'As far as message consumption is concerned, even though JMS is inherently asynchronous,
    the JMS specification allows messages to be consumed in either of the following
    two ways:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就消息消费而言，尽管 JMS 本质上是异步的，但 JMS 规范允许以以下两种方式之一消费消息：
- en: '**Synchronously**: A subscriber or a receiver explicitly fetches the message
    from the destination by calling the `receive()` method of any `MessageConsumer`
    instance. The `receive()` method can block until a message arrives or can take
    a time out if a message does not arrive within a specified time limit.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**：订阅者或接收者通过调用任何 `MessageConsumer` 实例的 `receive()` 方法显式地从目的地获取消息。`receive()`
    方法可以阻塞，直到有消息到达，或者如果消息在指定的时间限制内没有到达，可以超时。'
- en: '**Asynchronously**: With the asynchronous mode, the client must implement the
    `javax.jms.MessageListener` interface and overwrite the `onMessage()` method.
    Whenever a message arrives at the destination, the JMS provider delivers the message
    by calling the listener''s `onMessage` method, which acts on the contents of the
    message.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步**：在异步模式下，客户端必须实现 `javax.jms.MessageListener` 接口并重写 `onMessage()` 方法。每当有消息到达目的地时，JMS
    提供者通过调用监听器的 `onMessage` 方法来投递消息，该方法作用于消息的内容。'
- en: A JMS message consists of a header, properties, and a body. The message headers
    provide a fixed set of metadata fields that describe the message with information
    such as where the message is going and when it is received. The properties are
    a set of key-value pairs used for application-specific purposes, usually to help
    filter messages quickly when they are received. Finally, the body contains whatever
    data is being sent to the message.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JMS 消息由一个报头、属性和主体组成。消息报头提供一组固定的元数据字段，用于描述消息，例如消息的去向和接收时间。属性是一组键值对，用于特定应用目的，通常用于在接收时快速过滤消息。最后，主体包含发送到消息中的任何数据。
- en: 'The JMS API supports two delivery modes for messages to specify whether or
    not the messages are lost if the JMS provider fails, indicated by the following
    constants:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JMS API 支持两种消息投递模式，用于指定在 JMS 提供者失败的情况下，消息是否会丢失，以下常量表示：
- en: The **persistent** delivery mode, which is the default, instructs the JMS provider
    to take extra care to ensure that a message is not lost in transit in the case
    of a JMS provider failure. A message sent with this delivery mode is logged to
    stable storage when it is sent.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久**投递模式，这是默认模式，指示 JMS 提供者要格外小心，确保在 JMS 提供者失败的情况下，消息在传输过程中不会丢失。使用此投递模式发送的消息在发送时会被记录到稳定的存储中。'
- en: The **nonpersistent** delivery mode does not require the JMS provider to store
    the message or otherwise guarantee that it is not lost if the provider fails.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非持久**投递模式不需要 JMS 提供者存储消息或保证在提供者失败的情况下不会丢失。'
- en: The building blocks of JMS
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JMS 的基本构建块
- en: 'The basic building blocks of any JMS application consist of the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 JMS 应用程序的基本构建块包括以下内容：
- en: Administered objects—connection factories and destinations
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理对象——连接工厂和目的地
- en: Connections
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接
- en: Sessions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话
- en: Message producers
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息生产者
- en: Message consumers
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息消费者
- en: Messages
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息
- en: 'Let''s take a closer look at them:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看它们：
- en: '**Connection factory**: This object encapsulates a set of connection configuration
    parameters that have been defined by an administrator. A client uses it to create
    a connection with a JMS provider. A connection factory hides provider-specific
    details from JMS clients and abstracts administrative information into objects
    in the Java programming language.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接工厂**：此对象封装了一组由管理员定义的连接配置参数。客户端使用它来与 JMS 提供者建立连接。连接工厂隐藏了特定于提供者的细节，并将管理信息抽象为
    Java 编程语言中的对象。'
- en: '**Destination**: This is the component a client uses to specify the target
    of messages it produces and the source of messages it consumes. In the **point-to-point**
    (**PTP**) messaging domain, destinations are called queues; in the **publish/subscribe
    (pub/sub)** messaging domain, destinations are called topics.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地**：这是客户端用于指定其产生的消息的目标和其消费的消息的来源的组件。在 **点对点**（**PTP**）消息域中，目的地被称为队列；在 **发布/订阅**（**pub/sub**）消息域中，目的地被称为主题。'
- en: '**Connection**: This encapsulates a virtual connection with a JMS provider.
    A connection could represent an open TCP/IP socket between a client and a provider
    service. You use a connection to create one or more sessions.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：这封装了一个与JMS提供程序的虚拟连接。一个连接可以代表客户端和提供程序服务之间的一个打开的TCP/IP套接字。您使用连接来创建一个或多个会话。'
- en: '**Session**: This is a single-threaded context for producing and consuming
    messages. You use sessions to create message producers, message consumers, and
    messages. Sessions serialize the execution of message listeners and provide a
    transactional context with which to group a set of sends and receives into an
    atomic unit of work.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：这是一个用于生产和消费消息的单线程上下文。您使用会话来创建消息生产者、消息消费者和消息。会话序列化消息监听器的执行，并提供一个事务上下文，可以将一系列发送和接收操作组合成一个原子的工作单元。'
- en: '**Message producer**: This is an object created by a session and is used to
    send messages to a destination. The PTP form of a message producer implements
    the `QueueSender` interface. The pub/sub form implements the `TopicPublisher`
    interface. From JMS 2.0, it is possible to rely only on the `JMSProducer` interface.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息生产者**：这是一个由会话创建的对象，用于向目的地发送消息。消息生产者的PTP形式实现了`QueueSender`接口。发布/订阅形式实现了`TopicPublisher`接口。从JMS
    2.0开始，可以仅依赖于`JMSProducer`接口。'
- en: '**Message consumer**: This is an object created by a session and is used to
    receive messages sent to a destination. A message consumer allows a JMS client
    to register interest in a destination with a JMS provider. The JMS provider manages
    the delivery of messages from a destination to the registered consumers of the
    destination. The PTP form of message consumer implements the `QueueReceiver` interface.
    The pub/sub form implements the `TopicSubscriber` interface. The latest JMS version
    supports a new `JMSConsumer` API.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息消费者**：这是一个由会话创建的对象，用于接收发送到目的地的消息。消息消费者允许JMS客户端向JMS提供程序注册对目的地的兴趣。JMS提供程序管理从目的地到已注册消费者目的地的消息传递。消息消费者的PTP形式实现了`QueueReceiver`接口。发布/订阅形式实现了`TopicSubscriber`接口。最新的JMS版本支持新的`JMSConsumer`
    API。'
- en: The JBoss messaging subsystem
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JBoss消息子系统
- en: JBoss AS has used different JMS implementations across its releases, such as
    JBoss MQ and JBoss Messaging. Since JBoss AS 6.0, the default JMS provider is
    **HornetQ** ([http://www.jboss.org/hornetq](http://www.jboss.org/hornetq)), which
    provides a multiprotocol, embeddable, high-performant, and clusterable messaging
    system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss AS在其各个版本中使用了不同的JMS实现，例如JBoss MQ和JBoss Messaging。自JBoss AS 6.0以来，默认的JMS提供程序是**HornetQ**（[http://www.jboss.org/hornetq](http://www.jboss.org/hornetq)），它提供了一个多协议、可嵌入、高性能且可集群的消息系统。
- en: At its core, HornetQ is designed simply as a set of **Plain Old Java Objects**
    (**POJOs**) with few dependencies on external JAR files. In fact, the only one
    JAR dependency is the Netty library, which leverages the Java **New Input-Output**
    (**NIO**) API to build high-performance network applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，HornetQ被设计成一套简单的**普通Java对象**（**POJOs**），对外部JAR文件的依赖很少。实际上，唯一的JAR依赖是Netty库，它利用Java
    **新输入输出**（**NIO**）API来构建高性能网络应用程序。
- en: Because of its easily adaptable architecture, HornetQ can be embedded in your
    own project or instantiated in any dependency injection framework such as JBossMicrocontainer,
    Spring, or Google Guice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其易于适应的架构，HornetQ可以嵌入到您自己的项目中，或者在任何依赖注入框架中实例化，例如JBossMicrocontainer、Spring或Google
    Guice。
- en: 'In this book, we will cover a scenario where HornetQ is integrated into the
    WildFly subsystem as a module, as shown in the following diagram. This diagram
    depicts how the JCA Adapter and the HornetQ server fit in the overall picture:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将介绍一个场景，其中HornetQ作为模块集成到WildFly子系统，如下所示。此图展示了JCA适配器和HornetQ服务器如何在整体图中定位：
- en: '![The JBoss messaging subsystem](img/00053.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![The JBoss messaging subsystem](img/00053.jpeg)'
- en: Creating and using connection factories
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用连接工厂
- en: It is the job of the connection factory that encapsulates the connection's parameters
    to create new JMS connections. A connection factory is bound to the **Java Naming
    Directory Index** (**JNDI**) and can be looked up by both local and remote clients,
    provided they supply the correct environment parameters. Since a connection factory
    can be reused multiple times in your code, it's the kind of object that can be
    conveniently cached by a remote client or a message-driven bean.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 连接工厂封装连接参数的职责是创建新的JMS连接。连接工厂绑定到**Java命名目录索引**（**JNDI**），并且只要它们提供正确的环境参数，本地和远程客户端都可以查找。由于连接工厂可以在你的代码中多次重用，它是一种可以被远程客户端或消息驱动豆方便地缓存的类型。
- en: The definition of connection-factory instances is included in the `full` and
    `full-ha` server configurations. You can choose either of the server configurations
    using the `–c` command argument, for instance, `standalone.bat –c standalone-full.xml`.
    We will cover the configuration profiles in depth in [Chapter 9](part0048_split_000.html#page
    "Chapter 9. Managing the Application Server"), *Managing the Application Server*.
    For now, just remember to start your server with the full configuration profile
    whenever you need JMS.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 连接工厂实例的定义包含在`full`和`full-ha`服务器配置中。你可以使用`–c`命令参数选择任一服务器配置，例如，`standalone.bat
    –c standalone-full.xml`。我们将在[第9章](part0048_split_000.html#page "第9章。管理应用服务器")中深入讨论配置配置文件，*管理应用服务器*。现在，只需记住，每次你需要JMS时，都要使用完整配置配置文件启动你的服务器。
- en: 'You can inspect the connection factories in the overall JMS configuration,
    which is available by surfing the admin console and navigating to **Configuration**
    | **Messaging Destinations** | **Connection Factories**, as shown in the following
    screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过浏览管理控制台并导航到**配置** | **消息目的地** | **连接工厂**来检查整体JMS配置中的连接工厂，如下面的截图所示：
- en: '![Creating and using connection factories](img/00054.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![创建和使用连接工厂](img/00054.jpeg)'
- en: 'As you can see in the previous screenshot, there are the following two out-of-the-box
    connection-factory definitions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，有以下两个内置的连接工厂定义：
- en: '**InVmConnectionFactory**: This connection factory is bound under the `java:/ConnectionFactory`
    entry and is used when the server and client are part of the same process (that
    is, they are running on the same JVM).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InVmConnectionFactory**: 这个连接工厂在`java:/ConnectionFactory`条目下进行绑定，并且当服务器和客户端是同一进程的一部分时（即，它们在同一个JVM上运行）使用。'
- en: '**RemoteConnectionFactory**: This connection factory is bounded under the `java:jboss/exported/jms/RemoteConnectionFactory`
    entry, and as the name implies, it can be used using Netty as the connector when
    JMS connections are provided by a remote server.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RemoteConnectionFactory**: 这个连接工厂在`java:jboss/exported/jms/RemoteConnectionFactory`条目下进行绑定，正如其名称所暗示的，当由远程服务器提供JMS连接时，可以使用Netty作为连接器来使用。'
- en: 'If you want to change the connection factory''s JNDI binding, the simplest
    choice is to go through the server configuration file (for example, `standalone-full.xml`,
    for a standalone mode):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改连接工厂的JNDI绑定，最简单的方法是通过服务器配置文件（例如，对于独立模式，`standalone-full.xml`）：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The connection factory can be injected just like any other Java EE resource;
    the following code fragment shows how a stateless EJB gets the default connection
    factory injected:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 连接工厂可以像任何其他Java EE资源一样注入；以下代码片段显示了无状态EJB如何注入默认连接工厂：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to use the messaging subsystem, you have to start WildFly using a
    Java EE full profile, which includes the messaging subsystem. So, for example,
    if you want to start a standalone server instance that is JMS-aware, you can simply
    use the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用消息子系统，你必须使用Java EE完整配置启动WildFly，该配置包括消息子系统。例如，如果你想启动一个具有JMS感知能力的独立服务器实例，你可以简单地使用以下代码：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using JMS destinations
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JMS目的地
- en: Along with the definition of connection factories, you will need to learn how
    to configure JMS destinations (queues and topics).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了连接工厂的定义外，你还需要了解如何配置JMS目的地（队列和主题）。
- en: This can be achieved with a variety of instruments. Since we have started dealing
    with the web console, just navigate to the **Configuration** tab and pick the
    **Messaging** subsystem from the left panel. Select **Destinations** and click
    on the **View** central link.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过各种工具实现。由于我们已经开始处理Web控制台，只需导航到**配置**选项卡，并从左侧面板中选择**消息**子系统。选择**目的地**并单击**查看**中央链接。
- en: 'From there, you can use the upper menu tab that contains a set of options,
    the first one of which—named **Queues/Topics**—can be used to configure your JMS
    destinations, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，你可以使用包含一组选项的上层菜单标签，其中第一个选项——命名为**队列/主题**——可以用来配置你的JMS目的地，如下面的截图所示：
- en: '![Using JMS destinations](img/00055.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用JMS目的地](img/00055.jpeg)'
- en: 'Now click on the **Add** button. You should see the following dialog:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击**添加**按钮。你应该会看到以下对话框：
- en: '![Using JMS destinations](img/00056.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用JMS目的地](img/00056.jpeg)'
- en: 'Enter the mandatory name for your destination and its JNDI. You can optionally
    choose to define your JMS destination as either of the following options:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您目的地的必填名称及其JNDI。您可以选择性地定义您的JMS目的地为以下任一选项：
- en: '**Durable**: This option allows the JMS server to hold on to a message in case
    the subscriber is temporarily unavailable.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：此选项允许JMS服务器在订阅者暂时不可用的情况下保留消息。'
- en: '**Selector**: This option allows a filter to the JMS destination (we will cover
    this in greater detail later in this chapter).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择器**：此选项允许对JMS目的地进行过滤（我们将在本章后面更详细地介绍）。'
- en: Click on the **Save** button and verify that the queue has been enlisted among
    the JMS destinations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**按钮并验证队列是否已列入JMS目的地之中。
- en: 'The preceding change will reflect in the server configuration file as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更改将在服务器配置文件中反映如下：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's worth noting that the JMS configuration usually differs on every application
    server. In this chapter, we will cover only the approach used in WildFly, but
    the key concepts between different providers stay the same.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，JMS配置通常在每个应用程序服务器上都有所不同。在本章中，我们将只介绍在WildFly中使用的方案，但不同供应商之间的关键概念保持相同。
- en: Adding message-driven beans to your application
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将消息驱动Bean添加到您的应用程序
- en: Once we do the configuration, we can start coding a JMS message consumer, such
    as a message-driven bean.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成配置，我们就可以开始编写JMS消息消费者，例如消息驱动Bean。
- en: '**Message-driven beans** (**MDBs**) are stateless, server-side, and transaction-aware
    components that process asynchronous JMS messages.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息驱动Bean（MDB**）是无状态的、服务器端和事务感知的组件，用于处理异步JMS消息。'
- en: One of the most important aspects of message-driven beans is that they can consume
    and process messages concurrently. This capability provides a significant advantage
    over traditional JMS clients, which must be custom built to manage resources,
    transactions, and security in a multithreaded environment. MDB containers manage
    concurrency automatically so the bean developer can focus on the business logic
    of processing the messages. An MDB can receive hundreds of JMS messages from various
    applications and process them all at the same time because numerous instances
    of it can be executed concurrently in the container.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动Bean最重要的一个方面是它们可以并发地消费和处理消息。这种能力在传统的JMS客户端上提供了显著的优势，因为传统的JMS客户端必须被定制构建以管理多线程环境中的资源、事务和安全。MDB容器自动管理并发，这样Bean开发者就可以专注于处理消息的业务逻辑。一个MDB可以从各种应用程序接收数百条JMS消息，并且可以同时处理它们，因为它的多个实例可以在容器中并发执行。
- en: From the semantic point of view, an MDB is classified as an enterprise bean,
    just like a session or entity bean, but there are some important differences.
    At first, the message-driven bean does not have component interfaces. These are
    absent because the message-driven bean is not accessible via the Java RMI API;
    it responds only to asynchronous messages.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义角度来看，消息驱动Bean（MDB）被归类为企业Bean，就像会话或实体Bean一样，但有一些重要的区别。首先，消息驱动Bean没有组件接口。这是因为消息驱动Bean不能通过Java
    RMI API访问；它只响应异步消息。
- en: 'Just as the entity and session beans have well-defined life cycles, so does
    the MDB bean. The MDB instance''s life cycle has two states, **Does not Exist**
    and **Method ready Pool**, as shown in the following image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如实体和会话Bean有明确的生命周期一样，MDB Bean也是如此。MDB实例的生命周期有两个状态，**不存在**和**方法就绪池**，如下面的图像所示：
- en: '![Adding message-driven beans to your application](img/00057.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![将消息驱动Bean添加到您的应用程序](img/00057.jpeg)'
- en: When a message is received, the EJB container checks to see whether any MDB
    instance is available in the pool. If a bean is available in the free pool, JBoss
    uses that instance. Once an MDB instance's `onMessage()` method is returned, the
    request is complete and the instance is placed back in the free pool. This results
    in the best response time, as the request is served without waiting for a new
    instance to be created.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到消息时，EJB容器会检查池中是否有可用的MDB实例。如果免费池中有可用的Bean，JBoss将使用该实例。一旦MDB实例的`onMessage()`方法返回，请求就完成了，并将实例放回免费池。这导致最佳响应时间，因为请求是在不等待创建新实例的情况下得到服务的。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On the other hand, if all the instances in the pool are busy, the new request
    will be serialized since it's guaranteed that the same instance will not be allowed
    to serve multiple clients at the same time. Also, if a client sends out multiple
    messages to the server containing an MDB, there is no guarantee that the same
    MDB instance will be used for each message or that the messages will be processed
    in the order in which the client sent them. This means that the application should
    be designed to handle messages that arrive out of order.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果池中的所有实例都忙碌，新的请求将被序列化，因为可以保证同一实例不会被允许同时为多个客户端提供服务。此外，如果客户端向服务器发送包含MDB的多个消息，不能保证每个消息都使用相同的MDB实例，或者消息将按照客户端发送的顺序处理。这意味着应用程序应该设计为处理乱序到达的消息。
- en: 'The number of MDBs in the pool is configured in the EJB pool, which can be
    reached from the console by navigating to **Configuration** | **Container** |
    **EJB 3** | **Bean Pools** as depicted in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 池中MDB的数量在EJB池中配置，可以通过控制台导航到**配置** | **容器** | **EJB 3** | **Bean Pools**来访问，如下面的截图所示：
- en: '![Adding message-driven beans to your application](img/00058.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![将消息驱动的Bean添加到你的应用程序](img/00058.jpeg)'
- en: The bean pool's configuration is contained in the bean pool central tab, which
    holds both the stateless and MDB pool configurations. The default value for the
    MDB's max pool size is 20 units.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Bean池的配置包含在Bean池中心标签中，其中包含无状态和MDB池配置。MDB的最大池大小默认值为20个单位。
- en: It is also possible to override pools for specific beans. You can use either
    the JBoss-specific `org.jboss.ejb3.annotation.Pool` annotation or the `jboss-ejb3.xml`
    deployment descriptor. For more information on overriding pools for the chosen
    beans, visit [https://docs.jboss.org/author/display/WFLY8/EJB3+subsystem+configuration+guide](https://docs.jboss.org/author/display/WFLY8/EJB3+subsystem+configuration+guide).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以覆盖特定Bean的池。你可以使用JBoss特定的`org.jboss.ejb3.annotation.Pool`注释或`jboss-ejb3.xml`部署描述符。有关覆盖所选Bean的池的更多信息，请访问[https://docs.jboss.org/author/display/WFLY8/EJB3+subsystem+configuration+guide](https://docs.jboss.org/author/display/WFLY8/EJB3+subsystem+configuration+guide)。
- en: If no bean instances are available, the request will be blocked until an active
    MDB completes a method call or the transaction times out.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的Bean实例，请求将被阻塞，直到一个活动的MDB完成方法调用或事务超时。
- en: Cooking message-driven beans
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息驱动的Bean配置
- en: We will now add a message-driven bean to our application from the previous chapter,
    which will be used to intercept messages when a new ticket is booked. For the
    purpose of our example, we will just trace whether the JMS message has been received;
    however, you can also use it for more complex purposes such as notifying external
    systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将从前一章的应用程序中添加一个消息驱动的Bean，该Bean将用于在预订新票时拦截消息。为了我们的示例，我们只需跟踪JMS消息是否已接收；然而，你也可以用它来实现更复杂的目的，例如通知外部系统。
- en: Create a new Java class, say `BookingQueueReceiver`, and enter the package name
    as `com.packtpub.wflydevelopment.chapter6.jms`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Java类，例如`BookingQueueReceiver`，并将包名输入为`com.packtpub.wflydevelopment.chapter6.jms`。
- en: 'Once done, let''s add the MDB configuration via an annotation, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，让我们通过注释添加MDB配置，如下所示：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we have connected the MDB to our `ticketQueue` destination `[1]` bound
    at `java:jboss/jms/queue/ticketQueue`. The purpose of this component will be to
    trace the message receipt via `java.util.Logger`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将MDB连接到了我们的`ticketQueue`目标 `[1]`，该目标绑定在`java:jboss/jms/queue/ticketQueue`。该组件的目的将是通过`java.util.Logger`跟踪消息接收。
- en: 'Java EE 7 introduces an additional way of the queue definition. Now, you don''t
    have to add a queue from the application server management tool. It is possible
    to define queues and their properties in the code using some basic annotations:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 7引入了队列定义的另一种方式。现在，你不必从应用服务器管理工具中添加队列。你可以使用一些基本注解在代码中定义队列及其属性：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, in `BookingQueueReceiver`, you can just change `propertyValue = "java:jboss/jms/queue/ticketQueue"`
    to `propertyValue = BookingQueueDefinition.BOOKING_QUEUE`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`BookingQueueReceiver`中，你只需将`propertyValue = "java:jboss/jms/queue/ticketQueue"`更改为`propertyValue
    = BookingQueueDefinition.BOOKING_QUEUE`。
- en: Adding the JMS producer
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加JMS生产者
- en: 'Once we''re done with the JMS consumer, we need a component that will take
    care of sending JMS messages. For this purpose, we will add an Application Scoped
    CDI Bean, say `BookingQueueProducer`, which gets injected in the JMS resources:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成JMS消费者，我们需要一个组件来处理发送JMS消息。为此，我们将添加一个应用范围CDI Bean，比如`BookingQueueProducer`，它被注入到JMS资源中：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This might be a bit shocking for those who have used the previous versions
    of the JMS. For those who haven''t, in the following code we present this code''s
    equivalent in JMS 1.1:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对那些使用过JMS先前版本的人来说有些震惊。对于那些还没有使用过的人来说，在下面的代码中，我们展示了JMS 1.1中此代码的等效版本：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Code amount change is impressive. API simplification was one of the major features
    of the new JMS version, and the specification authors did great work on it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码量变化令人印象深刻。API简化是新JMS版本的主要特性之一，规范作者在这方面做得很好。
- en: 'Now, you can use your service to notify some application-specific actions.
    For example, we will inject `BookingQueueProducer` into the `BookerService` bean
    and send a message whenever a user is registered:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用你的服务来通知一些特定于应用程序的操作。例如，我们将`BookingQueueProducer`注入到`BookerService`Bean中，并在用户注册时发送消息：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From JMS 2.0, messages can be sent asynchronously, but then it is important
    to control whether the operations are successful or not. To do this, we have to
    create an object that implements the `CompletionListener` interface, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从JMS 2.0开始，消息可以异步发送，但此时重要的是要控制操作是否成功。为此，我们必须创建一个实现`CompletionListener`接口的对象，如下所示：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'During the `send` operation, we have to specify the asynchronous and use this
    `listener` object. To do this, inject `BookingCompletionListener` to `BookingQueueProducer`
    and send messages with an updated call:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`send`操作期间，我们必须指定异步并使用此`listener`对象。为此，将`BookingCompletionListener`注入到`BookingQueueProducer`中，并使用更新后的调用发送消息：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, appropriate listener methods will be executed when the message `send`
    is completed or failed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当消息`send`完成或失败时，将执行适当的监听器方法：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compiling and deploying the application
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译和部署应用程序
- en: 'We have based our code on the JPA application from the previous chapter. Thanks
    to `javaee-api`, you don''t have to add any new project dependencies in order
    to use JMS! The only thing you have to do is to start WildFly in full profile
    using, for example, `standalone-full.xml standalone-full.xml`—the standard full
    profile configuration:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码基于上一章中的JPA应用程序。多亏了`javaee-api`，你不需要添加任何新的项目依赖项来使用JMS！你唯一需要做的是使用例如`standalone-full.xml`的标准完整配置来启动WildFly的全配置模式：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, when switching to another server configuration, you will need to recreate
    all the example resources, such as data sources, that were set up initially for
    your standalone configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当切换到另一个服务器配置时，你需要重新创建所有最初为你的独立配置设置的资源，例如数据源。
- en: Now deploy your application using either Eclipse's Server view or Maven and
    access the application at `http://localhost:8080/ticket-agency-jms/`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用Eclipse的服务器视图或Maven部署你的应用程序，并通过`http://localhost:8080/ticket-agency-jms/`访问应用程序。
- en: Everything should work just like the earlier JPA project; however, in your application
    server console, you should notice the messages that confirm a seat has been booked.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都应该像早期的JPA项目一样工作；然而，在你的应用服务器控制台中，你应该注意到确认座位已预订的消息。
- en: Specifying which message to receive using selectors
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用选择器指定要接收的消息
- en: Message selectors allow an MDB to be more selective about the messages it receives
    from a particular topic or queue. Message selectors use message properties as
    criteria in conditional expressions. Message properties, upon which message selectors
    are based, are additional headers that can be assigned to a message. They give
    the application developer the ability to attach more information to a message.
    This information can be stored using several primitive values (`boolean`, `byte`,
    `short`, `int`, `long`, `float`, and `double`) or as `String`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 消息选择器允许MDB对从特定主题或队列接收的消息有更多的选择性。消息选择器使用消息属性作为条件表达式的标准。消息选择器基于的消息属性是可以分配给消息的附加头信息。它们给应用程序开发者提供了附加更多信息的可能性。这些信息可以使用几个原始值（`boolean`、`byte`、`short`、`int`、`long`、`float`和`double`）或作为`String`存储。
- en: 'For example, let''s suppose that we want to process two kinds of messages with
    the same queue:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要使用同一个队列处理两种类型的消息：
- en: A trace message indicating that a user has booked a seat
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示用户已预订座位的跟踪消息
- en: A warning message indicating that an error has occurred
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示发生错误的警告消息
- en: 'Hence, our `sendMessage` method can be changed slightly to include a `String`
    property that can be attached to the message:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`sendMessage`方法可以稍作修改，包括一个可以附加到消息上的`String`属性：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, in our application context, we might use the `sendMessage` method, attaching
    a `LOW` value for priority when the user is registered:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的应用程序上下文中，我们可能会使用`sendMessage`方法，当用户注册时附加一个`LOW`优先级值：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the other hand, we could attach a `HIGH` priority when an error occurs:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当发生错误时，我们可以附加一个`HIGH`优先级：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From the MDB perspective, all you need to do in order to filter through messages
    is include the message selector as part of your `ActivationConfigProperty` class
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从MDB的角度来看，你只需要在`ActivationConfigProperty`类中包含消息选择器，如下所示，以便过滤消息：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the same time, you can deploy another MDB that is in charge of consuming
    messages that are sent with a `LOW` priority:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，你可以部署另一个负责消费带有`LOW`优先级消息的MDB：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When talking about filtering, we have to say a few words concerning performance.
    In HornetQ queues and topics, there are filtering messages on a different stage.
    In the case of queues, properties are filtered when they have already been received
    by the listener, while in topics, they are filtered before being added. Keep in
    mind this is not guaranteed by JMS specification (since a specification describes
    the API) and might act differently in other implementations. There are a lot of
    performance options that can be tuned in JMS providers; however, most of the configurations
    must be specifically chosen for every project. Be sure to check additional tuning
    tips in HornetQ's documentation at [http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#perf-tuning](http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#perf-tuning).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到过滤时，我们必须说几句关于性能的话。在HornetQ队列和主题中，过滤消息发生在不同的阶段。在队列的情况下，当属性已经被监听器接收时，它们会被过滤，而在主题中，它们在添加之前被过滤。请记住，这并不由JMS规范保证（因为规范描述了API），并且可能在其他实现中有所不同。JMS提供者中有许多可以调整的性能选项；然而，大多数配置必须为每个项目专门选择。请确保在HornetQ文档中查看额外的调整提示，链接为[http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#perf-tuning](http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#perf-tuning)。
- en: Transaction and acknowledgment modes
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务和确认模式
- en: 'In order to control the overall performance and reliability of an asynchronous
    messaging system, we need to take two factors into account: persisting of messages
    and acknowledgment. Let''s take a look at those characteristics.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制异步消息系统的整体性能和可靠性，我们需要考虑两个因素：消息的持久化和确认。让我们看看这些特性。
- en: Reliability of the system is focused on the ability to deliver messages exactly
    once. This means that no message is lost, and there are no duplicates. For most
    systems, it is a strong requirement that you don't miss or duplicate any orders
    (like in an e-commerce site). However, usually it is not a problem to miss an
    update from the stock market because a newer one would overwrite it in a moment.
    Of course, additional features such as reliability come at a price, and in the
    case of JMS, the price is paid in performance. The more reliable the system, the
    lower its message throughput is.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可靠性集中在能够精确地发送消息一次的能力。这意味着没有消息丢失，也没有重复。对于大多数系统来说，不遗漏或重复任何订单（如电子商务网站上的订单）是一个强烈的要求。然而，通常错过股市更新并不是问题，因为更新的信息很快就会覆盖它。当然，额外的功能如可靠性是有代价的，在JMS的情况下，代价是性能。系统越可靠，其消息吞吐量就越低。
- en: When a message is processed, it can be held only in the memory or persisted
    somewhere on the disk. Messages stored in the memory are lost in the case of a
    failure or when the messaging service is stopped. Persisted messages can be retrieved
    from the disk after the service is restarted and therefore delivered to the consumers
    at least once (but still without any guarantees about the acknowledgment). Without
    this mechanism, messages can potentially be lost in the system because a failure
    might occur before they are delivered. However, the overhead of storing them can
    have a serious impact on the system's performance characteristics.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理消息时，它只能保存在内存中或在磁盘上的某个位置。保存在内存中的消息在失败或消息服务停止时丢失。持久化的消息在服务重启后可以从磁盘检索，因此至少被投递给消费者一次（但仍没有任何关于确认的保证）。如果没有这种机制，消息可能会因为失败发生在它们被投递之前而丢失。然而，存储它们的开销可能会对系统的性能特性产生严重影响。
- en: Acknowledgment is important to inform the JMS service that the message was really
    received and processed by the consumer. Different levels of acknowledgments can
    be used to avoid duplicates or to trigger JMS to send the message once more, possibly
    to another consumer. A JMS provider will ensure that an acknowledged message is
    delivered only once. The application is responsible for properly handling rolled
    back messages that were redelivered (such messages are marked with the `JMSRedelivered`
    header).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 确认对于通知JMS服务消息确实被接收和处理非常重要。可以使用不同级别的确认来避免重复或触发JMS再次发送消息，可能发送给另一个消费者。JMS提供者将确保已确认的消息只被投递一次。应用程序负责正确处理已重新投递的回滚消息（这些消息带有`JMSRedelivered`头）。
- en: 'If the consumer session is handled in a transaction, then the messages are
    acknowledged only when the transaction is committed. However, there is an option
    to disable transactional message-driven beans and manually handle the acknowledgment.
    In this case, there are the following three types of acknowledgement options:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消费者会话在事务中处理，则只有在事务提交时才会确认消息。然而，可以选择禁用事务性消息驱动豆并手动处理确认。在这种情况下，有以下三种确认选项：
- en: '**AUTO_ACKNOWLEDGE**: With this, the consumed messages are being acknowledged
    automatically'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AUTO_ACKNOWLEDGE**：使用此选项，消费的消息将被自动确认'
- en: '**DUPS_OK_ACKNOWLEDGE**: With this, the delivered messages are being lazily
    acknowledged; this means that the client might receive some duplicated messages'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DUPS_OK_ACKNOWLEDGE**：使用此选项，已发送的消息将被延迟确认；这意味着客户端可能会接收到一些重复的消息'
- en: '**CLIENT_ACKNOWLEDGES**: With this, the client manually acknowledges received
    messages using the `acknowledge` method'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLIENT_ACKNOWLEDGES**：使用此选项，客户端通过`acknowledge`方法手动确认接收到的消息'
- en: 'The modes can be set when you retrieve `JMSContext` from a connection factory:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在从连接工厂检索`JMSContext`时设置模式：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first argument is an integer flag that accepts the values mentioned previously
    along with a `SESSION_TRANSACTED` entry (which is the standard mode for JTA-managed
    message-driven beans).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个整数标志，接受之前提到的值以及`SESSION_TRANSACTED`条目（这是JTA管理的消息驱动豆的标准模式）。
- en: Using JMS to integrate with external systems
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JMS与外部系统集成
- en: At the beginning of this chapter, we mentioned that the JCA adaptor handles
    the communication between the application server and the HornetQ server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到JCA适配器负责处理应用服务器和HornetQ服务器之间的通信。
- en: As a matter of fact, one possible way to perform **Enterprise Application Integration**
    (**EAI**) is via **Java Connector Architecture** (**JCA**), which can be used
    to drive JMS's inbound and outbound connections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，执行**企业应用集成**（**EAI**）的一种可能方式是通过**Java连接器架构**（**JCA**），它可以用来驱动JMS的入站和出站连接。
- en: Initially, Java connectors were intended to access legacy transaction servers
    on mainframes in a synchronous request/reply mode, and this is how the majority
    of the connectors worked in the beginning. The standard is currently evolving
    toward more asynchronous and two-way connectivity; this is exactly the case with
    JMS communication, which is inherently asynchronous (but also offers the capability
    of simulating a synchronous request/response mode). In the next section, we will
    show you how to use a Java Resource Adapter to enable communication between JBoss'
    HornetQ Messaging system and a standalone instance of the Apache ActiveMQ broker
    (which can be used, for instance, by a non-Java EE application).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Java连接器旨在以同步请求/回复模式访问大型机上的遗留事务服务器，这就是大多数连接器最初是如何工作的。该标准目前正在向更异步和双向连接发展；这正是JMS通信的情况，它本质上是异步的（但也提供了模拟同步请求/回复模式的能力）。在下一节中，我们将向您展示如何使用Java资源适配器来启用JBoss
    HornetQ消息系统与Apache ActiveMQ代理（例如，由非Java EE应用程序使用）之间的通信。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**JMS/JCA integration versus web services**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**JMS/JCA集成与Web服务**'
- en: If we are discussing EAI, we cannot help but talk about the difference between
    web services, which is the de facto standard for integrating heterogeneous systems.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在讨论EAI，我们不可避免地要谈到Web服务之间的区别，这是异构系统集成的既定标准。
- en: One advantage of using the JMS/JCA integration is that it provides support for
    resource adaptation, which maps the Java EE security, transaction, and communication
    pooling to the corresponding EIS technology. This makes this technology fairly
    attractive, especially if you are trying to connect some existing, well-consolidated,
    and homogeneous systems (remember that if you are using JMS as the driver, you
    are bound to a Java-to-Java interaction).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JMS/JCA集成的一个优点是它提供了对资源适应性的支持，将Java EE安全、事务和通信池映射到相应的EIS技术。这使得这项技术相当有吸引力，尤其是如果你正在尝试连接一些现有的、稳固的、同质化的系统（记住，如果你使用JMS作为驱动，你将绑定到Java到Java的交互）。
- en: On the other hand, if you are planning to connect different business partners
    (for example, Java and .NET applications) or simply build a new system from scratch
    with no clear interactions defined, it would be better to use web services for
    transport and connection.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你计划连接不同的商业伙伴（例如，Java和.NET应用）或者从头开始构建一个没有明确交互定义的新系统，使用Web服务进行传输和连接会更好。
- en: We will learn more about web services in [Chapter 7](part0038_split_000.html#page
    "Chapter 7. Adding Web Services to Your Applications"), *Adding Web Services to
    Your Applications*, which should provide you with quite a complete overview of
    your EAI alternatives.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](part0038_split_000.html#page "第7章。向您的应用程序添加Web服务")中了解更多关于Web服务的内容，*向您的应用程序添加Web服务*，这应该会为你提供一个相当完整的EAI替代方案概述。
- en: A real-world example – HornetQ and ActiveMQ integration
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个现实世界的例子——HornetQ和ActiveMQ集成
- en: In this section, we will provide an example scenario, which includes an external
    component such as the Apache ActiveMQ (Apache 2.0 open source licensed) message
    broker that fully implements **Java Message Service 1.1** (**JMS**). Another application
    could be communicating with our ticketing system using this broker, but in our
    sample, we will simulate the external system using the ActiveMQ administration
    console.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一个示例场景，其中包括一个外部组件，例如完全实现**Java消息服务1.1**（**JMS**）的Apache ActiveMQ（Apache
    2.0开源许可）消息代理。另一个应用可能是使用此代理与我们的票务系统进行通信，但在我们的示例中，我们将使用ActiveMQ管理控制台来模拟外部系统。
- en: In order to run this example, we will need to pick up the ActiveMQ resource
    adapter, `activemq-rar-5.9.0.rar`, which can be downloaded from the Maven repository
    at [http://repo1.maven.org/maven2/org/apache/activemq/activemq-rar/5.9.0/](http://repo1.maven.org/maven2/org/apache/activemq/activemq-rar/5.9.0/).
    You will also need the ActiveMQ broker, which you can download from [https://activemq.apache.org/activemq-590-release.html](https://activemq.apache.org/activemq-590-release.html).
    Simply extract the binary distribution and run the `/apache-activemq-5.9.0/bin/activemq.bat`
    file to start the broker.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此示例，我们需要选择 ActiveMQ 资源适配器 `activemq-rar-5.9.0.rar`，可以从 Maven 仓库 [http://repo1.maven.org/maven2/org/apache/activemq/activemq-rar/5.9.0/](http://repo1.maven.org/maven2/org/apache/activemq/activemq-rar/5.9.0/)
    下载。你还需要 ActiveMQ 代理，你可以从 [https://activemq.apache.org/activemq-590-release.html](https://activemq.apache.org/activemq-590-release.html)
    下载。只需提取二进制发行版并运行 `/apache-activemq-5.9.0/bin/activemq.bat` 文件来启动代理。
- en: Installing the ActiveMQ resource adapter
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 ActiveMQ 资源适配器
- en: Resource adapters (`.rar`) can be deployed using either WildFly management instruments
    or by copying the resource adapter into the deployments directory for standalone
    servers. Before doing this, we need to configure the Resource adapter in your
    server configuration. This can be done by adding the configuration to the JCA
    subsystem or (suggested choice) by creating a JCA descriptor of the external resource.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 资源适配器（`.rar`）可以使用 WildFly 管理工具或通过将资源适配器复制到独立服务器的部署目录中来部署。在这样做之前，我们需要在服务器配置中配置资源适配器。这可以通过将配置添加到
    JCA 子系统或（建议选择）创建外部资源的 JCA 描述符来完成。
- en: JCA descriptors can be created by using an utility contained in JBoss' JCA implementation
    named **IronJacamar** ([http://www.jboss.org/ironjacamar](http://www.jboss.org/ironjacamar)).
    Within IronJacamar 1.1 or later distributions (accessible at [http://www.jboss.org/ironjacamar/downloads](http://www.jboss.org/ironjacamar/downloads)),
    you can find a resource adapter information tool (`rar-info.bat`) that can be
    used to create the resource adapter deployment descriptor by generating a report
    file containing all the necessary information.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: JCA 描述符可以通过使用 JBoss JCA 实现中包含的一个实用工具创建，该工具名为 **IronJacamar** ([http://www.jboss.org/ironjacamar](http://www.jboss.org/ironjacamar)).
    在 IronJacamar 1.1 或更高版本的发行版（可在 [http://www.jboss.org/ironjacamar/downloads](http://www.jboss.org/ironjacamar/downloads)
    访问）中，你可以找到一个资源适配器信息工具 (`rar-info.bat`)，它可以用来通过生成包含所有必要信息的报告文件来创建资源适配器部署描述符。
- en: 'The `rar-info.bat` tool can be found in the `doc/as` folder of your IronJacamar
    distribution. So let''s move to this folder:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`rar-info.bat` 工具可以在你的 IronJacamar 发行版的 `doc/as` 文件夹中找到。所以让我们转到这个文件夹：'
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now issue the following command, which assumes that you have saved your resource
    adapter in the `/usr/doc` folder:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下命令，假设你已经将你的资源适配器保存在 `/usr/doc` 文件夹中：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Troubleshooting the rar-info shell**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决 rar-info 命令行问题**'
- en: 'The `rar-info` command shell includes a set of libraries that are used to execute
    the main utility class. In order to inspect the JMS adapter, however, you need
    to manually edit the shell file and add `jboss-jms-api_2.0_spec-1.0.0.Final` and
    `jboss-transaction-api_1.2_spec-1.0.0.Final.jar` to the classpath. Those JAR files
    are contained in the main folder under `JBOSS_HOME/modules/system/layers/base/javax/jms/api/`
    and `JBOSS_HOME/modules/system/layers/base/javax/transaction/api/`. Simply add
    paths for them in the `rar-info.bat` file (separated by character); for example,
    refer to the following (assuming the jars are in the same directory as `rar-info.bat`):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`rar-info` 命令行包括一组库，用于执行主实用程序类。然而，为了检查 JMS 适配器，你需要手动编辑命令行文件，并将 `jboss-jms-api_2.0_spec-1.0.0.Final`
    和 `jboss-transaction-api_1.2_spec-1.0.0.Final.jar` 添加到类路径中。这些 JAR 文件位于 `JBOSS_HOME/modules/system/layers/base/javax/jms/api/`
    和 `JBOSS_HOME/modules/system/layers/base/javax/transaction/api/` 的主文件夹中。只需在 `rar-info.bat`
    文件中添加它们的路径（用字符分隔）；例如，参考以下内容（假设 JAR 文件与 `rar-info.bat` 在同一目录中）：'
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will generate a file called `activemq-rar-5.9.0-report.txt`, which will
    provide you with the required information to construct your own JBoss' JCA configuration
    file that needs to be named `ironjacamar.xml`. Feel free to check out its contents.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `activemq-rar-5.9.0-report.txt` 的文件，它将为你提供构建自己的 JBoss JCA 配置文件所需的信息，该文件需要命名为
    `ironjacamar.xml`。请随意查看其内容。
- en: 'In the following code, you can find a sample `ironjacamar.xml` file that defines
    a new queue (`java:jboss/activemq/queue/TicketQueue`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '在以下代码中，你可以找到一个示例 `ironjacamar.xml` 文件，它定义了一个新的队列 (`java:jboss/activemq/queue/TicketQueue`):'
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, this file contains the definition of ActiveMQ connection factories
    along with the mapping of JMS administration objects, which will be imported by
    the resource adapter. The `ironjacamar.xml` file needs to be copied into the `META-INF`
    folder of `activemq-rar-5.9.0.rar` (you can open the RAR file using the compressed
    files manager of your choice, for example, 7-Zip).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此文件包含ActiveMQ连接工厂的定义以及JMS管理对象的映射，这些将被资源适配器导入。`ironjacamar.xml`文件需要复制到`activemq-rar-5.9.0.rar`的`META-INF`文件夹中（您可以使用您选择的压缩文件管理器打开RAR文件，例如7-Zip）。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Additional configuration requirements of the resource adapter**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源适配器的附加配置要求**'
- en: Along with the `ironjacamar.xml` file, there is another configuration file that
    is contained in the `META-INF` folder of your `activemq-rar-5.9.0.rar` file. The
    `ra.xml` file is the standard JCA configuration file and describes the resource-adapter-related
    attribute's type and its deployment properties. We, however, do not need to alter
    its contents for our basic sample.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ironjacamar.xml`文件外，还有一个配置文件包含在您的`activemq-rar-5.9.0.rar`文件的`META-INF`文件夹中。`ra.xml`文件是标准的JCA配置文件，描述了资源适配器相关属性的类型及其部署属性。然而，对于我们的基本示例，我们不需要修改其内容。
- en: 'Now that we have completed the configuration, let''s deploy the resource adapter
    (`activemq-rar-5.9.0.rar`) into our WildFly and check that the JCA factories and
    objects have been correctly bound to the application server. After the deployment,
    you should see the following similar messages in WildFly''s console:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了配置，让我们将资源适配器（`activemq-rar-5.9.0.rar`）部署到我们的WildFly中，并检查JCA工厂和对象是否已正确绑定到应用服务器。部署后，您应该在WildFly的控制台中看到以下类似的消息：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Consuming ActiveMQ messages
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费ActiveMQ消息
- en: 'Well done! The hardest part is done. Now in order to consume JMS messages sent
    by the ActiveMQ broker, we will add a `@ResourceAdapter` annotation to a message-driven
    bean. This MDB will intercept bookings from the ActiveMQ broker. In order to be
    able to use the `@ResourceAdapter` annotation, we will need to add a JBoss-specific
    dependency to our `pom.xml`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！最困难的部分已经完成。现在，为了消费ActiveMQ代理发送的JMS消息，我们将在消息驱动Bean上添加一个`@ResourceAdapter`注解。这个消息驱动Bean将拦截来自ActiveMQ代理的预订。为了能够使用`@ResourceAdapter`注解，我们需要在我们的`pom.xml`中添加一个JBoss特定的依赖项：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our new annotated message bean is presented as follows (note that the property
    `destinationType` is the destination now):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新注解消息Bean如下所示（注意，属性`destinationType`现在是目标）：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once a message is received, it is written to a console. This means that it
    is time to deploy our application. If your ActiveMQ broker is running, you should
    see the following similar messages during the deployment phase:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到消息，它就会被写入控制台。这意味着是时候部署我们的应用程序了。如果您的ActiveMQ代理正在运行，您应该在部署阶段看到以下类似的消息：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now it is time to test our connection using the ActiveMQ console, which will
    send a message straight to the ActiveMQ broker. ActiveMQ 5.9.0 is equipped with
    a bundled **hawt.io** console. It is a pluggable web dashboard that can be configured
    to administer various applications. One of them is ActiveMQ. And, one of the benefits
    of using this console is that you can deploy it on almost any JVM-based container,
    including WildFly. Check out [http://hawt.io/](http://hawt.io/) along with the
    ActiveMQ plugin ([http://hawt.io/plugins/activemq/](http://hawt.io/plugins/activemq/))
    for more information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用ActiveMQ控制台测试我们的连接了，它将直接向ActiveMQ代理发送消息。ActiveMQ 5.9.0配备了捆绑的**hawt.io**控制台。这是一个可插拔的Web仪表板，可以配置来管理各种应用程序。其中之一是ActiveMQ。使用此控制台的一个好处是，您几乎可以在任何基于JVM的容器上部署它，包括WildFly。查看[http://hawt.io/](http://hawt.io/)以及ActiveMQ插件（[http://hawt.io/plugins/activemq/](http://hawt.io/plugins/activemq/））以获取更多信息。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From Version 5.10.0, ActiveMQ is not prebundled with hawt.io anymore. You can
    prepare your own hawt.io console by following the guidelines available at [http://hawt.io/getstarted/index.html](http://hawt.io/getstarted/index.html);
    installing the ActiveMQ plugin; or (which we strongly recommend) using Version
    5.9.0 in your samples, which is conveniently preconfigured.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本5.10.0开始，ActiveMQ不再预捆绑hawt.io。您可以通过遵循[http://hawt.io/getstarted/index.html](http://hawt.io/getstarted/index.html)上的指南来准备自己的hawt.io控制台；安装ActiveMQ插件；或者（我们强烈推荐）在您的示例中使用5.9.0版本，它已经方便地预配置了。
- en: 'Go to `http://localhost:8161/hawtio/` and log in using the `admin/admin` credentials:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`http://localhost:8161/hawtio/`并使用`admin/admin`凭据登录：
- en: '![Consuming ActiveMQ messages](img/00059.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![消费ActiveMQ消息](img/00059.jpeg)'
- en: After the login, you should see the hawt.io web console. It is worth noting
    that it was created using Twitter Bootstrap, the same front-end framework that
    we are using in our application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你应该会看到hawt.io网络控制台。值得注意的是，它是使用Twitter Bootstrap创建的，这是我们应用程序中使用的相同的前端框架。
- en: 'Select the first tab (ActiveMQ) and you should see a tree that represents the
    current configuration of the broker. Find the node `localhost/Queue/`. When you
    expand it, you should see the queue we defined earlier in our resource adapter:
    `java_jboss/activemq/queue/TicketQueue`. After selecting it, you can choose the
    **Send** tab on the right-hand side. You should see a screen similar to the following
    one:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 选择第一个标签页（ActiveMQ），你应该会看到一个表示代理当前配置的树形结构。找到节点`localhost/Queue/`。当你展开它时，你应该会看到我们在资源适配器中定义的队列：`java_jboss/activemq/queue/TicketQueue`。选择它后，你可以在右侧选择**发送**标签页。你应该会看到一个类似于以下屏幕的界面：
- en: '![Consuming ActiveMQ messages](img/00060.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![消费ActiveMQ消息](img/00060.jpeg)'
- en: 'Enter the desired message into the big text area in the center and click on
    the **Send Message** button. After switching to our WildFly console, we should
    see a log entry with the message we passed to the ActiveMQ broker, as shown in
    the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在中心的较大文本区域中输入所需的消息，然后点击**发送消息**按钮。切换到我们的WildFly控制台后，我们应该会看到一个日志条目，其中包含我们传递给ActiveMQ代理的消息，如下面的截图所示：
- en: '![Consuming ActiveMQ messages](img/00061.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![消费ActiveMQ消息](img/00061.jpeg)'
- en: Congratulations! If you have gone successfully through this example, you have
    just mastered a real-world integration scenario. To make the sample more realistic,
    you could improve the message bean so that it would book tickets if the message
    were to contain the required information (for example, message `55,10` would book
    a seat with ID 55 for 10$). Feel free to experiment!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！如果你已经成功完成了这个示例，那么你已经掌握了一个真实世界的集成场景。为了让这个示例更加真实，你可以改进消息bean，使其在消息包含所需信息时预订票务（例如，消息`55,10`将预订ID为55的座位，价格为10美元）。请随意尝试！
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed JBoss' message-oriented middleware that allows
    you to loosely couple heterogeneous systems together while typically providing
    reliability, transactions, and many other features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了JBoss的消息中间件，它允许你将异构系统松散耦合在一起，同时通常提供可靠性、事务和其他许多功能。
- en: We saw how to configure JMS destinations using the web console and create some
    message-driven beans, which are the standard way to consume messages from within
    the EJB container.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用网络控制台配置JMS目的地并创建一些消息驱动bean，这是在EJB容器内消费消息的标准方式。
- en: We will now move on to another component, which is typically used for integrating
    heterogeneous systems—web services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向另一个组件，它通常用于集成异构系统——Web服务。
