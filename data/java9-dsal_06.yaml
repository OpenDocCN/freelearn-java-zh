- en: Chapter 6. Efficient Sorting – quicksort and mergesort
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 高效排序 – quicksort和mergesort
- en: In the last chapter, we explored a few simple sorting algorithms. The problem
    with those is that they are not efficient enough. In this chapter, we will cover
    two efficient sorting algorithms and we will also see how they are efficient.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探索了几种简单的排序算法。这些算法的问题在于它们不够高效。在本章中，我们将介绍两种高效的排序算法，我们还将了解它们的效率。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: quicksort
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: quicksort
- en: mergesort
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mergesort
- en: Optimality of efficiency in sorting algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序算法效率的最优性
- en: quicksort
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: quicksort
- en: 'We want to develop an algorithm that sorts an array of elements efficiently.
    Our strategy will be simple; we will somehow try to divide the array into two
    halves in such a way that sorting each half will complete the sorting. If we can
    achieve this, we can recursively call the sorting algorithm this way. We already
    know that the number of levels of recursive call will be of the order of *lg n*
    where *lg m* is the logarithm of *m* with the base *2*. So, if we can manage to
    cut the array in a time in the order of *n*, we will still have a complexity of
    *O(n lg n)* This is much better than *O(n* ²*)*, which we saw in the previous
    chapter. But how do we cut the array that way? Let''s try to cut the following
    array as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望开发一个能够高效排序元素数组的算法。我们的策略将很简单；我们将以某种方式尝试将数组分成两半，使得对每个半部分的排序将完成排序。如果我们能实现这一点，我们可以以这种方式递归地调用排序算法。我们已经知道递归调用的层数将是
    *lg n* 的数量级，其中 *lg m* 是以 *2* 为底的对数 *m*。因此，如果我们能以 *n* 的数量级切割数组，我们仍然会有 *O(n lg n)*
    的复杂度。这比我们在上一章中看到的 *O(n²)* 要好得多。但是，我们如何以这种方式切割数组呢？让我们尝试以下方式切割以下数组：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we trivially cut this array, each part will contain all sorts of values.
    Sorting these individual parts would then not cause the entire array to be sorted.
    Instead, we have to cut the array in such a way that all the elements in the left
    part are less than all the elements in the right part. If we can achieve this,
    sorting the parts will achieve sorting the whole. But, of course, we need to make
    some swaps for us to be able to cut the array in such a way. So, we use the following
    trick:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简单地切割这个数组，每个部分将包含各种值。对这些单独的部分进行排序不会导致整个数组被排序。相反，我们必须以某种方式切割数组，使得左边的所有元素都小于右边的所有元素。如果我们能实现这一点，对部分的排序将实现整个数组的排序。但是，当然，我们需要进行一些交换，以便我们能够以这种方式切割数组。因此，我们使用以下技巧：
- en: '![quicksort](img/00030.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![quicksort](img/00030.jpeg)'
- en: This is an example of pivot positioning in quicksort. The one headed arrows
    represent comparison and double headed arrows represent swap.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是quicksort中枢轴定位的一个示例。指向箭头表示比较，双向箭头表示交换。
- en: We first choose the last element and call it *pivot*. Our aim is to make all
    the elements that are less than the pivot to be on its left and all the elements
    that are greater than the pivot to be on its right. Note that this means that
    the pivot is already at the correct position of the array. The preceding figure
    shows how to do it with an example. In the figure, our pivot is **30**. We start
    comparing with the first element and move on. The moment we find an inversion,
    we swap the pivot with that element and keep comparing in the opposite direction.
    We continue this way, swapping every time there is an inversion and reversing
    the direction of comparison each time. We stop when all the elements have been
    compared. Note that after this process, all the elements less than the pivot are
    on its left, and all the elements greater than the pivot are on its right. Why
    does this work? Let's take a closer look.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择最后一个元素，并将其称为 *枢轴*。我们的目标是使所有小于枢轴的元素都位于其左侧，而所有大于枢轴的元素都位于其右侧。请注意，这意味着枢轴已经位于数组的正确位置。前面的图示展示了如何通过一个示例来完成这个过程。在图中，我们的枢轴是
    **30**。我们开始与第一个元素进行比较，并继续进行。当我们找到逆序时，我们将枢轴与该元素交换，并保持相反方向的比较。我们继续这样做，每次发现逆序时都进行交换，并每次反转比较的方向。当我们比较完所有元素时停止。请注意，在此过程之后，所有小于枢轴的元素都位于其左侧，而所有大于枢轴的元素都位于其右侧。这是为什么？让我们更仔细地看看。
- en: Suppose we start comparing from the left. After the first swap, the pivot is
    at the position of the element that was found to be greater than it. All the elements
    that were on the left of it have already been compared with the pivot and found
    to be less than it. The previous figure shows the parts that have already been
    compared. Now it starts comparing from its earlier position in the opposite direction.
    After the second swap, it sits in the position of the element that it has been
    swapped with. All the elements on the right have already been compared with it
    and found to be greater than it. We keep going in the same way, always ensuring
    that the parts that have already been compared follow the rule that the part on
    the left of the pivot contains only elements that are less than or equal to it
    and the part on the right of the pivot contains only elements that are greater
    than or equal to it. So, when we are done with the comparisons, we still hold
    this condition, thus achieving the result. Once we know that all the elements
    on the left of the pivot are less than or equal to all the elements that are on
    its right, we can sort these parts separately and the entire array will be sorted
    as a result. Of course, we sort these parts recursively in the same way.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从左边开始比较。第一次交换后，枢轴位于找到的比它大的元素的位子上。它左边的所有元素都已经与枢轴比较过，并且发现它们都比枢轴小。前一个图显示了已经比较过的部分。现在它从其较早的位置开始向相反方向比较。第二次交换后，它坐在与它交换过的元素的位子上。它右边的所有元素都已经与它比较过，并且发现它们都比它大。我们继续以同样的方式进行，始终确保已经比较过的部分遵循以下规则：枢轴左边的部分只包含小于或等于它的元素，枢轴右边的部分只包含大于或等于它的元素。因此，当我们完成比较后，我们仍然保持这个条件，从而实现结果。一旦我们知道枢轴左边的所有元素都小于或等于其右边的所有元素，我们就可以分别对这些部分进行排序，从而整个数组将被排序。当然，我们以相同的方式递归地对这些部分进行排序。
- en: 'However, before we dive into the code, I would like to introduce a different
    interface for comparison. It is called `java.util.Comparator` and allows us to
    specify any comparison logic while sorting, thus providing more flexibility. Here
    is how it looks:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入代码之前，我想介绍一个不同的比较接口。它被称为`java.util.Comparator`，允许我们在排序时指定任何比较逻辑，从而提供更大的灵活性。以下是它的样子：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is, of course, a very simplified version of the actual interface but has
    got all that we care about. As you can see, this is a functional interface and
    thus can be implemented using a lambda. It should return the same value that is
    conceptually similar to the value returned by `o1.compareTo(o2)`, but a different
    sorting can use a different comparison lambda. The compare method has to follow
    the same rules that are there for the `compareTo` method in the `java.util.Comparable`
    interface we studied in the previous chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个非常简化的实际接口版本，但它包含了我们所有关心的内容。正如你所见，这是一个函数式接口，因此可以使用lambda表达式实现。它应该返回与`o1.compareTo(o2)`返回的概念上相似但不同的值，但不同的排序可以使用不同的比较lambda表达式。比较方法必须遵循我们在上一章中研究的`java.util.Comparable`接口中`compareTo`方法相同的规则。
- en: Now let's jump into the code for quicksort. We know we don't have to sort any
    more when the array to be processed is empty, which would be our base case. Otherwise,
    We create two indexes `i` and `j`, one storing the current end of the left part
    and the other storing the current beginning of the right part that has already
    been compared with the pivot at any given point of time, while the pivot is being
    placed in its correct position. Both the index variables store the indexes that
    are to be compared next. At any given point of time, one of these variables holds
    the position of the pivot and the other stores the current value being compared
    with it. The variable that currently stores the position of the pivot is flagged
    by the Boolean variable, `movingI`. If it is true, it means that we are currently
    moving `i` and hence, `j` is pointing to the pivot. We update the position variables
    and keep comparing, in a loop, until both indexes point to the pivot, when the
    comparison suggests that there is an inversion, we swap and reverse the direction
    of movement. We reverse the direction of movement because the pivot has moved
    to the position indexed by the opposite variable, marked by `movingI` switching
    its value. Otherwise, we just keep updating the appropriate position variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入快速排序的代码。我们知道，当要处理的数组为空时，我们不需要再进行排序，这将是我们的基本情况。否则，我们创建两个索引 `i` 和 `j`，一个存储左侧部分的当前末尾，另一个存储在任意给定时间点已经与枢轴比较过的右侧部分的当前开始，同时枢轴被放置在其正确的位置。这两个索引变量存储的是下一个要比较的索引。在任意给定时间点，这些变量中的一个持有枢轴的位置，另一个存储正在与之比较的当前值。当前存储枢轴位置的变量通过布尔变量
    `movingI` 标记。如果它是真的，这意味着我们目前正在移动 `i`，因此 `j` 指向枢轴。我们更新位置变量并持续在循环中比较，直到两个索引都指向枢轴，当比较表明存在逆序时，我们交换并反转移动方向。我们反转移动方向是因为枢轴已经移动到由相反变量索引的位置，由
    `movingI` 的值改变标记。否则，我们只是持续更新适当的位置变量。
- en: 'When `movingI` is false, it means that `i` is storing the position of the pivot.
    And finally, when the pivot is at the correct position and all the elements on
    its left are less than or equal to all the elements on its right, we recursively
    call **quicksort** on each part:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `movingI` 为假时，这意味着 `i` 存储枢轴的位置。最后，当枢轴处于正确的位置，并且其左侧的所有元素都小于或等于其右侧的所有元素时，我们递归地对每个部分调用
    **quicksort**：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can wrap this method to avoid having to pass the start and end parameters:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此方法包装起来，以避免需要传递起始和结束参数：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use this method to sort an array. Let''s see how to sort an integer
    array:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此方法来排序一个数组。让我们看看如何对整数数组进行排序：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following would be the output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note how we passed the simple comparator using a lambda. If we pass a lambda
    `(a,b)->b-a` instead, we will get the array reversed. In fact, this flexibility
    lets us sort arrays containing complex objects according to any comparison we
    like. For example, it is easy to sort an array of `Person` objects by age using
    the lambda, `(p1, p2)->p1.getAge() - p2.getAge()`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用 lambda 传递简单的比较器的。如果我们传递一个 lambda `(a,b)->b-a`，我们将得到一个反转的数组。实际上，这种灵活性让我们可以根据任何比较来对包含复杂对象的数组进行排序。例如，使用
    lambda `(p1, p2)->p1.getAge() - p2.getAge()`，很容易根据年龄对 `Person` 对象的数组进行排序。
- en: Complexity of quicksort
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速排序的复杂度
- en: Like always, we will try to figure out the worst case of quicksort. To begin
    with, we notice that after the pivot has been positioned correctly, it is not
    positioned in the middle of the array. In fact, its final position depends on
    what value it has with respect to the other elements of the array. Since it is
    always positioned as per its rank, its rank determines the final position. We
    also notice that the worst case for quicksort would be when the pivot does not
    cut the array at all, that is, when all the other elements are either to its left
    or to its right. This will happen when the pivot is the largest or the smallest
    element. This will happen when the highest or the lowest element is at the end
    of the array. So, for example, if the array is already sorted, the highest element
    would be at the end of the array in every step, and we will choose this element
    as our pivot. This gives us the counter intuitive conclusion that an array that
    is already sorted would be the worst case for the quicksort algorithm. An array
    that is sorted in the opposite direction is also one of the worst cases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将尝试找出快速排序的最坏情况。首先，我们注意到枢轴被正确放置后，它不会位于数组的中间。实际上，它的最终位置取决于它与数组中其他元素相比的值。由于它总是按照其排名来定位，其排名决定了最终位置。我们还注意到，快速排序的最坏情况是枢轴根本不切割数组，也就是说，所有其他元素要么在它的左边，要么在它的右边。这将在枢轴是最大或最小元素时发生。这将在最高或最低元素位于数组末尾时发生。因此，例如，如果数组已经排序，则每个步骤中最大的元素都会位于数组的末尾，我们将选择这个元素作为枢轴。这给出了一个反直觉的结论，即已经排序的数组将是快速排序算法的最坏情况。按相反方向排序的数组也是最坏情况之一。
- en: 'So, what is the complexity if the worst case happens? Since it is the worst
    case where every step is made out of two recursive calls, one of which is with
    an empty array and thus needing a constant time to process, and another having
    an array with one less element. Also, in each step, the pivot is compared with
    every other element, thus taking time proportional to *(n-1)* for an *n*-element
    step. So, we have the recursive equation for the time `T(n)` as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果发生最坏情况，其复杂度是多少呢？由于最坏情况是每一步都由两个递归调用组成，其中一个是对空数组的调用，因此需要常数时间来处理，另一个是少一个元素的数组。此外，在每一步中，枢轴都与每个其他元素进行比较，因此对于包含
    *n* 个元素的步骤，所需时间与 *(n-1)* 成正比。因此，我们得到时间 `T(n)` 的递归方程如下：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since this is valid for all values of `n`, we have:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这对于所有 `n` 的值都成立，我们有：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Summing both sides, we have the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将两边相加，我们得到以下结果：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is not very good. It is still `O(n²` `).` Is it really an efficient algorithm?
    Well, to answer that, we need to consider the average case. The average case is
    the probabilistically weighted average of the complexities for all possible inputs.
    This is quite complicated. So, we will use something that we can call a typical
    case, which is sort of the complexity of the usual case. So, what would happen
    in a typical randomly unsorted array, that is, where the input array is arranged
    quite randomly? The rank of the pivot will be equally likely to be any value from
    `1` to `n`, where `n` is the length of the array. So, it will sort of split the
    array near the middle in general. So, what is the complexity if we do manage to
    cut the array in halves? Let''s find out:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不好。它仍然是 `O(n²)`。这真的是一个高效的算法吗？好吧，为了回答这个问题，我们需要考虑平均情况。平均情况是所有可能输入的复杂性的概率加权平均值。这相当复杂。因此，我们将使用我们可以称之为典型情况的东西，这有点像是通常情况的复杂度。那么，在一个典型的随机未排序数组中会发生什么呢？也就是说，输入数组被相当随机地排列？枢轴的排名将等可能地是
    `1` 到 `n` 之间的任何值，其中 `n` 是数组的长度。因此，它通常会在中间附近分割数组。那么，如果我们成功将数组分成两半，其复杂度是多少呢？让我们来看看：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a little difficult to solve, so we take `n/2` instead of `(n-1)/2`,
    which can only increase the estimate of complexity. So, we have the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点有点难以解决，所以我们取 `n/2` 而不是 `(n-1)/2`，这只会增加复杂度的估计。因此，我们有以下结果：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let `m = lg n` and `S(m) = T(n)`, and hence, `n = 2m`. So, we have this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 令 `m = lg n` 和 `S(m) = T(n)`，因此 `n = 2m`。所以我们有如下结果：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since this is valid for all `m`, we can apply the same formula for `S(m-1)`
    as well. So, we have the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这对于所有 `m` 都成立，我们可以将相同的公式应用于 `S(m-1)`。因此，我们有以下结果：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Proceeding similarly, we have this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式继续，我们得到如下结果：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is pretty good. In fact, this is way better than the quadratic complexity
    we saw in the previous chapter. In fact, *n lg n* grows so slow that *n lg n =
    O(na)* for any `a` greater than *1*. That is to say that the function *n1.000000001*
    grows faster than *n lg n*. So, we have found an algorithm that performs quite
    well in most cases. Remember that the worst case for quicksort is still *O(n²)*.
    We will try to address this problem in the next subsection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当不错。事实上，这比我们在上一章中看到的二次复杂度要好得多。实际上，*n lg n*增长得非常慢，以至于对于任何大于*1*的`a`，*n lg n
    = O(na)*。这意味着函数*n1.000000001*增长速度比*n lg n*快。因此，我们找到了一个在大多数情况下表现相当好的算法。记住，快速排序的最坏情况仍然是*O(n²)*。我们将在下一小节中尝试解决这个问题。
- en: Random pivot selection in quicksort
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速排序中的随机枢轴选择
- en: 'The problem with quicksort is that it performs really badly if the array is
    already sorted or sorted in the reverse direction. This is because we would be
    always choosing the pivot to be the smallest or the largest element of the array.
    If we can avoid that, we can avoid the worst case time as well. Ideally, we want
    to select the pivot that is the median of all the elements of the array, that
    is, the middle element when the array is sorted. But it is not possible to compute
    the median efficiently enough. One trick is to choose an element randomly among
    all the elements and use it as a pivot. So, in each step, we randomly choose an
    element and swap it with the end element. After this, we can perform the quicksort
    as we did earlier. So, we update the quicksort method as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序的问题在于，如果数组已经排序或反向排序，它的性能会非常糟糕。这是因为我们总是会选择数组的最大或最小元素作为枢轴。如果我们能避免这种情况，我们也可以避免最坏情况的时间复杂度。理想情况下，我们希望选择数组的所有元素的中位数作为枢轴，即在数组排序时的中间元素。但是，无法高效地计算中位数。一个技巧是在所有元素中随机选择一个元素并将其用作枢轴。因此，在每一步中，我们随机选择一个元素并将其与末尾元素交换。之后，我们可以像之前一样执行快速排序。因此，我们将快速排序方法更新如下：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even now we can be very unlucky and pick the end element every time, but it
    is very unlikely to happen. In this case, we will almost always get an *n lg n*
    complexity, as desired.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 即使现在我们每次都非常不幸地选择末尾元素，但这非常不可能发生。在这种情况下，我们几乎总是能得到期望的*n lg n*复杂度。
- en: mergesort
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序
- en: In the previous section, we tried to divide the array in such a way that when
    we sort each part, the entire array is sorted. We faced the problem that when
    we try to do that, the two parts are not equal in size causing the algorithm to
    sometimes take a quadratic amount of time. What if, instead of trying to divide
    the array in a way that sorting the parts would sort the whole, we just divide
    the array into two equal halves? Of course then, sorting the parts will not sort
    the entire array. However, if we have two array parts sorted on their own, can
    we merge them together to produce a sorted array as a whole? If we can do this
    efficiently enough, we would have an algorithm guaranteed to be efficient. As
    it turns out, it is possible. But we need to think about where the merged array
    will be stored. Since the values are being copied from the source array, the result
    needs to be stored in a separate place. So, we will need another storage of equal
    size for mergesort.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们试图以这种方式分割数组，即当我们对每个部分进行排序时，整个数组也会被排序。我们遇到了一个问题，当我们尝试这样做时，两个部分的大小并不相等，导致算法有时需要二次时间复杂度。如果我们不尝试以排序部分来排序整个数组的方式分割数组，而是将数组分成两个大小相等的部分呢？当然，然后，排序部分不会排序整个数组。然而，如果我们有两个已各自排序的数组部分，我们能否将它们合并在一起以产生一个整体排序的数组？如果我们能足够高效地做到这一点，我们就会有一个保证高效的算法。实际上，这是可能的。但是，我们需要考虑合并数组将存储在哪里。由于值是从源数组复制的，结果需要存储在另一个地方。因此，我们需要为归并排序提供另一个大小相等的存储空间。
- en: .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: '![mergesort](img/00031.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![归并排序](img/00031.jpeg)'
- en: Merge of sorted arrays
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 排序数组的合并
- en: The preceding figure shows a part of the merging operation. We keep the current
    position of each of the arrays. In each step, we compare the values in the current
    positions in both the input sorted arrays.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了合并操作的一部分。我们保持每个数组的当前位置。在每一步中，我们比较两个输入排序数组中当前位置的值。
- en: 'We copy whichever of them is smaller to the target location and increment the
    corresponding current position. We keep doing this until we finish one of the
    arrays, after which the elements of the other array can just be copied over. The
    following shows the code for the merge operation. One thing to note is that, since
    the merge will be used for a mergesort, it presumes both the input arrays to be
    the same array with different indexes and the target arrays to have the same size.
    The source has three indexes: `start`, `mid`, and `end`. It is assumed that the
    source parts are residing side by side in the source array. The variable `start`
    points to the start of the first part. The integer `mid` stores the index of the
    start of the second part and also acts as the end of the first part, as the parts
    are contiguous. Finally, the `end` variable stores the end of the second array:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将较小的那个复制到目标位置，并递增相应的当前位置。我们一直这样做，直到完成一个数组，之后另一个数组的元素可以直接复制过来。以下显示了归并操作的代码。需要注意的是，由于归并将用于归并排序，它假定输入数组是同一个数组，具有不同的索引，目标数组具有相同的大小。源数组有三个索引：`start`、`mid`和`end`。假设源部分在源数组中相邻。变量`start`指向第一部分的开始。整数`mid`存储第二部分开始的索引，也作为第一部分的结束，因为部分是连续的。最后，`end`变量存储第二数组的结束：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first two cases are for the time when one of the source arrays has been
    exhausted:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个情况是当其中一个源数组耗尽时的情况：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If none of the arrays are exhausted, copy from the correct array:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何数组耗尽，从正确的数组复制：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the target location must also be incremented:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，目标位置也必须递增：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this `merge` function available to us, we can now proceed to do the mergesort.
    It involves the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个`merge`函数，我们可以继续进行归并排序。它包括以下步骤：
- en: Divide the array into two equal parts.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组分成两等份。
- en: Mergesort the parts.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对部分进行归并排序。
- en: Merge the sorted parts into a full sorted array.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将排序好的部分合并成一个完整的排序数组。
- en: 'Of course, we do not need to do anything for an array with zero or one element.
    So, that will be our exit case:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于零个或一个元素的数组，我们不需要做任何事情。所以，那将是我们的退出情况：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Just return to the calling function for an array of zero or one element. This
    is our base case:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于零个或一个元素的数组，直接返回调用函数。这是我们的基本情况：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For any array of size bigger than `1`, divide the array into two halves–start
    to mid and mid to end. Then merge-sort them separately, and then merge the two
    sorted subarrays to a combined sorted array in `tempArray`, which is an auxiliary
    space that we are using:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何大于`1`的数组，将其分成两半——从开始到中间和从中间到结束。然后分别对它们进行归并排序，然后将两个排序好的子数组合并到`tempArray`中，这是一个辅助空间，我们正在使用：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, copy the contents of `tempArray` to `sourceArray` so that the source
    is now sorted:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`tempArray`的内容复制到`sourceArray`中，这样源数组现在就是排序好的：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complexity of mergesort
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归并排序的复杂度
- en: 'Let''s start from the complexity of the merge operation. The merge operation
    is not recursive. In every step, it increments either `i` or `j`. When both these
    variables reach the end of the respective arrays, the merge ends. The comparison
    happens at most once per any of these increments. This means that there are at
    most as many comparisons as there are elements in both the sub-arrays combined.
    The copying of the contents of `tempArray` to `sourceArray` also, of course, takes
    operations proportional to the number of elements in `tempArray`, which is the
    same as the number of elements in the `sourceArray`. So, the number of operations
    in each step is proportional to *n*, apart from the recursive call. The recursive
    call works on both parts of the array, which are themselves half the size of the
    entire array. Thus, if *T(n)* is the time taken, we have the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从归并操作的复杂度开始。归并操作不是递归的。在每一步中，它要么增加`i`，要么增加`j`。当这两个变量都达到各自数组的末尾时，归并结束。比较最多在每个增量发生一次。这意味着比较的次数最多与两个子数组中元素的总数相同。当然，将`tempArray`的内容复制到`sourceArray`的操作也与`tempArray`中的元素数量成比例，这与`sourceArray`中的元素数量相同。因此，每一步的操作数量与*n*成比例，除了递归调用。递归调用作用于数组的两部分，这两部分本身是整个数组大小的一半。因此，如果*T(n)*是所需时间，我们有以下结果：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `a` and `b` are constants.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a`和`b`是常数。
- en: This is the same equation as the one obtained for the typical case of the quicksort
    algorithm, and we know that the solution gives us *T(n) = θ(n lg n)*. This is
    the estimate for the both the average case and the worst case because, in both
    cases, the array will always be divided into two equal halves irrespective of
    the contents of the array. In fact, the worst case is when all the copying also
    requires a comparison, which is the case we considered.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这与快速排序算法典型情况得到的方程式相同，我们知道这个解给出了*T(n) = θ(n lg n)*。这是对平均情况和最坏情况的估计，因为在两种情况下，数组都将始终被分成两个大小相等的部分，无论数组的内容如何。实际上，最坏的情况是所有的复制也需要比较，这正是我们考虑的情况。
- en: In the best case, one of the arrays will have all its elements copied before
    even the first element of the second array is copied, thus requiring only half
    as many comparisons. But this case gives the same complexity of *T(n) = θ(n lg
    n)*. So, irrespective of the actual contents of the array we started with, mergesort
    will always have the same asymptotic complexity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳情况下，其中一个数组在复制第二个数组的第一个元素之前就已经复制了所有元素，因此只需要一半的比较次数。但这种情况给出了相同的复杂度*T(n) = θ(n
    lg n)*。所以，无论我们开始时的数组实际内容如何，归并排序都将具有相同的渐进复杂度。
- en: Avoiding the copying of tempArray
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免复制`tempArray`
- en: In our rather simplistic example, we first merged the subarrays into `tempArray`,
    and then we copied it back to `sourceArray`. Can the copying be avoided? Can we
    use `tempArray` itself as the result of the merge? It turns out that we can. In
    this case, both `sourceArray` and `tempArray` would be used rather symmetrically,
    the only difference being that `sourceArray` holds the original input array. Otherwise,
    they are two pre-allocated arrays of the same size. However, the code will get
    a little more complicated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们相当简单的例子中，我们首先将子数组合并到`tempArray`中，然后将其复制回`sourceArray`。能否避免复制？我们能否将`tempArray`本身用作合并的结果？结果是我们可以这样做。在这种情况下，`sourceArray`和`tempArray`将被相当对称地使用，唯一的区别是`sourceArray`持有原始输入数组。否则，它们是大小相同的预分配数组。然而，代码将变得稍微复杂一些。
- en: Let us first consider what would happen if we do not copy the contents of `tempArray`
    to `sourceArray` and try to use `tempArray` itself as the content of the sorted
    array. Then, in each step, `sourceArray` and `tempArray` would need to be swapped,
    that is, `tempArray` would become `sourceArray` and vice versa. Since in each
    step, `tempArray` and `sourceArray` are getting swapped, the actual array that
    holds the result depends on whether the number of steps required to sort the array
    is odd or even.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑如果我们没有将`tempArray`的内容复制到`sourceArray`，而是试图直接使用`tempArray`作为排序数组的内容会发生什么。然后，在每一步中，`sourceArray`和`tempArray`都需要进行交换，也就是说`tempArray`会变成`sourceArray`，反之亦然。由于在每一步中，`tempArray`和`sourceArray`都在进行交换，所以实际持有结果的数组取决于排序数组所需的步数是奇数还是偶数。
- en: Now, if the array we started with had a number of elements equal to an exact
    integral power of 2, the source array could always be divided into two sub-arrays
    of the exact same size. This means, the number of steps required to sort each
    of these sub-arrays would be exactly the same. This means that the actual array
    that holds the sorted result would be the same after sorting either sub-array.
    However, in reality, the number of elements in the array is not an exact power
    of 2 most of the time, and hence, one sub-array is a little bigger than the other.
    This results in a different number of steps being required to sort either sub-array,
    causing them to potentially store the resultant sorted array in different arrays.
    We have to consider these cases as well. So, when the result of sorting either
    sub-array is stored in the same array, we store the output of the merge in the
    other array. If not, we always store the output of the merge in the array that
    holds the result of sorting the second part of the array.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果开始时的数组元素数量等于2的精确整数次幂，源数组可以始终被分成两个大小完全相同的子数组。这意味着，排序每个子数组所需的步数将完全相同。这意味着在排序任一子数组后，实际持有排序结果的数组将是相同的。然而，在现实中，数组中的元素数量大多数情况下不是2的精确整数次幂，因此，一个子数组会比另一个稍微大一点。这导致排序任一子数组所需的步数不同，它们可能会将结果排序数组存储在不同的数组中。我们必须考虑这些情况。所以，当排序任一子数组的结果存储在同一个数组中时，我们将合并的输出存储在另一个数组中。如果不是，我们总是将合并的输出存储在持有数组第二部分排序结果的那个数组中。
- en: 'First, we change the `merge` function to handle two different arrays holding
    the contents of two different inputs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`merge`函数修改为处理包含两个不同输入内容的两个不同数组：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this `merge` function available, we write our efficient mergesort in the
    following way. Note that we need some way to inform the calling function about
    which pre-allocated array contains the result, so we return that array:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个`merge`函数可用后，我们以以下方式编写我们的高效归并排序。注意，我们需要某种方式来通知调用函数哪个预分配的数组包含结果，因此我们返回那个数组：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, split and merge-sort the sub-arrays as usual:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像往常一样分割并归并排序子数组：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If both the sorted sub-arrays are stored in the same pre-allocated array, use
    the other pre-allocated array to store the result of the merge:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个排序后的子数组都存储在同一个预分配的数组中，则使用另一个预分配的数组来存储归并的结果：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this case, we store the result in `sortedPart2` because it has the first
    portion empty:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将结果存储在`sortedPart2`中，因为它有第一部分是空的：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can use this mergesort as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以这样使用这个归并排序：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that this time, we had to ensure that we use the output returned by the
    method as, in some cases, `anotherArray` may contain the final sorted values.
    The efficient no-copy version of the mergesort does not have any asymptotic performance
    improvement, but it improves the time by a constant. This is something worth doing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次，我们必须确保我们使用方法返回的输出，因为在某些情况下，`anotherArray`可能包含最终的排序值。归并排序的高效无复制版本并没有任何渐近性能提升，但它通过常数提高了时间。这是值得做的事情。
- en: Complexity of any comparison-based sorting
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任何基于比较的排序的复杂度
- en: Now that we have seen two algorithms for sorting that are more efficient than
    the ones described in the previous chapter, how do we know that they are as efficient
    as a sorting can be? Can we make algorithms that are even faster? We will see
    in this section that we have reached our asymptotic limit of efficiency, that
    is, a comparison-based sorting will have a minimum time complexity of *θ(m lg
    m)*, where *m* is the number of elements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了两种比上一章描述的算法更高效的排序算法，我们如何知道它们是排序可能达到的最高效率呢？我们能否创造出更快算法？在本节中，我们将看到我们已经达到了效率的渐近极限，也就是说，基于比较的排序将具有最小的时间复杂度为*θ(m
    lg m)*，其中*m*是元素的数量。
- en: Suppose we start with an array of *m* elements. For the time being, let's assume
    they are all distinct. After all, if such an array is a possible input, we need
    to consider this case as well. The number of different arrangements possible with
    these elements is *m!*. One of these arrangements is the correct sorted one. Any
    algorithm that will sort this array using comparison will have to be able to distinguish
    this particular arrangement from all others using only comparison between pairs
    of elements. Any comparison divides the arrangements into two sets–one that causes
    an inversion as per the comparison between those two exact values and one that
    does not. This is to say that given any two values *a* and *b* from the arrays,
    a comparison that returns *a<b* will divide the set of arrangements into two partitions;
    the first set will contain all the arrangements where *b* comes before *a*, and
    the second set will contain all the arrangements where *a* comes before *b*. The
    sorted arrangement is, of course, a member of the second set. Any algorithm that
    sorts based on comparisons will have to do enough of them to pin down on the single
    correct arrangement, that is, the sorted arrangement. Basically, it will first
    perform a comparison, choose the correct subset, then perform another comparison
    and choose the correct subset of the subset, and so on, until it reaches a set
    of arrangements containing just one arrangement. This particular arrangement is
    the sorted version of the array. What is the minimum number of comparisons that
    are required to find one particular arrangement out of *m!* arrangements? This
    is the same as asking how many times you have to halve a set of *m!* elements
    to reach a set of only one element. It is, of course, *lg (m!)*. This is a rough
    estimation; in fact, the number of comparisons required would be a bit more than
    this because the two subsets that each comparison creates may not be equal in
    size. But we know that the number of comparisons required is *lg (m!)* at the
    minimum.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从一个包含 *m* 个元素的数组开始。暂时，让我们假设它们都是不同的。毕竟，如果这样的数组是可能的输入，我们需要考虑这种情况。这些元素可能的不同排列数量是
    *m!*。其中一种排列是正确的排序。任何使用比较来排序这个数组的算法都必须能够仅通过元素对之间的比较来区分这个特定的排列和其他所有排列。任何比较都将排列分为两组——一组在比较这两个确切值时会导致反转，另一组则不会。这意味着，给定数组中的任何两个值
    *a* 和 *b*，返回 *a<b* 的比较将排列集分为两个部分；第一组将包含所有 *b* 在 *a* 之前的所有排列，而第二组将包含所有 *a* 在 *b*
    之前的所有排列。排序排列当然是第二组的一个成员。任何基于比较的排序算法都必须进行足够的比较，以确定单个正确的排列，即排序排列。基本上，它将首先执行一个比较，选择正确的子集，然后执行另一个比较并选择子集的正确子集，依此类推，直到它达到只包含一个排列的排列集。这个特定的排列是数组的排序版本。找到
    *m!* 个排列中的特定排列所需的最小比较次数是多少？这等同于询问你需要将 *m!* 个元素的集合减半多少次才能达到只包含一个元素的集合。当然，是 *lg
    (m!)*。这是一个粗略估计；实际上，所需的比较次数会略多于这个数字，因为每个比较创建的两个子集可能大小不等。但我们知道，所需的比较次数至少是 *lg (m!)*。
- en: Now, how much is *lg m!*? Well, it is *(ln (m!)) (lg e)*, where *ln (x)* is
    the natural logarithm of *x*. We will find a simpler asymptotic complexity for
    the function *ln(m!)*. It requires a little bit of calculus.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*lg m!* 是多少呢？嗯，它是 *(ln (m!)) (lg e)*，其中 *ln (x)* 是 *x* 的自然对数。我们将找到函数 *ln(m!)*
    的一个更简单的渐近复杂度。这需要一点微积分知识。
- en: 'Let''s look at the following figure:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图：
- en: '![Complexity of any comparison-based sorting](img/00032.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![任何基于比较的排序的复杂度](img/00032.jpeg)'
- en: Area under the curve y = ln x.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线 y = ln x 下的面积。
- en: 'The diagram shows some plots. We know that the integral measures the area under
    the curve of a function. Now, the area under the curve *y=ln b* between *a* and
    *b* is *(b-a)ln b*, and the area under the curve *y=ln a* is *(b-a) ln a*. The
    area under the curve *y=lg x* in the same interval is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了某些图表。我们知道积分衡量的是函数曲线下的面积。现在，曲线 *y=ln b* 在 *a* 和 *b* 之间的面积是 *(b-a)ln b*，而曲线
    *y=ln a* 下的面积是 *(b-a) ln a*。在相同区间内，曲线 *y=lg x* 下的面积如下：
- en: '![Complexity of any comparison-based sorting](img/00033.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![任何基于比较的排序的复杂度](img/00033.jpeg)'
- en: 'From the graph in the preceding figure, the following is clear:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个图中的图形，以下内容是清晰的：
- en: '![Complexity of any comparison-based sorting](img/00034.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![任何基于比较的排序的复杂度](img/00034.jpeg)'
- en: 'In particular, having *b=a+1*, we get the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，当 *b=a+1* 时，我们得到以下结果：
- en: '![Complexity of any comparison-based sorting](img/00035.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![任何基于比较的排序的复杂度](img/00035.jpeg)'
- en: 'So, we set *a = 1* and move up to *a = m-1*, to get the following set of inequalities:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们设 *a = 1* 并逐步增加到 *a = m-1*，得到以下一系列不等式：
- en: '![Complexity of any comparison-based sorting](img/00036.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![任何比较排序的复杂度](img/00036.jpeg)'
- en: 'Adding respective sides, we get the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将相应的两边相加，我们得到以下结果：
- en: '![Complexity of any comparison-based sorting](img/00037.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![任何比较排序的复杂度](img/00037.jpeg)'
- en: 'Now, of course we know the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当然我们知道以下内容：
- en: '![Complexity of any comparison-based sorting](img/00038.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![任何比较排序的复杂度](img/00038.jpeg)'
- en: 'So, we have the following inequalities:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下不等式：
- en: '![Complexity of any comparison-based sorting](img/00039.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![任何比较排序的复杂度](img/00039.jpeg)'
- en: 'In the left inequality, if we put m instead of *m-1*, we will have the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边的不等式中，如果我们用 m 代替 *m-1*，我们将得到以下结果：
- en: '![Complexity of any comparison-based sorting](img/00040.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![任何比较排序的复杂度](img/00040.jpeg)'
- en: 'This, combined with the right inequality, gives the following relations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这与右边的不等式相结合，给出了以下关系：
- en: '![Complexity of any comparison-based sorting](img/00041.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![任何比较排序的复杂度](img/00041.jpeg)'
- en: This gives a pretty good upper bound and lower bound on the value of *ln(m!)*.
    Both the upper bound and lower bound are *θ(m ln m)*. So, we can conclude that
    *ln(m!) = θ(m ln m)*. This means that *lg(m!) = (ln (m!))(lg e)* is also *θ(m
    ln m) = θ(m lg m)* because *lg(m) = (ln m )(lg e)*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了对 *ln(m!)* 值的一个很好的上界和下界。上界和下界都是 *θ(m ln m)*。因此，我们可以得出结论，*ln(m!) = θ(m ln
    m)*。这意味着 *lg(m!) = (ln (m!))(lg e)* 也是 *θ(m ln m) = θ(m lg m)*，因为 *lg(m) = (ln
    m )(lg e)*。
- en: So, the minimum time complexity of a comparison-based sorting algorithm would
    have to be at least *θ(m lg m)* just because of the minimum number of comparisons
    that would be needed to do this. Therefore, mergesort and the typical case of
    quicksort are asymptotically optimal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于比较的排序算法的最小时间复杂度至少必须是 *θ(m lg m)*，仅仅是因为完成这个任务所需的比较的最小数量。因此，归并排序和快速排序的典型情况在渐近上是最佳的。
- en: The stability of a sorting algorithm
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法的稳定性
- en: The stability of a sorting algorithm is the property that the elements that
    compare to be equal preserve their original order after sorting. For example,
    if we have an array of objects containing the ID number and the age of some people
    and we want to sort them in increasing order of age, a stable sorting algorithm
    will preserve the original order of the people with the same age. This can be
    helpful if we are trying to sort multiple times. For example, if we want the IDs
    to be in increasing order for people with the same age, we can first sort the
    array by ID and then sort it again by age. If the sorting algorithm is stable,
    it will ensure that the final sorted array is in increasing order of age, and
    for the same age, it is in increasing order of ID. Of course, this effect can
    also be achieved by having a more complex comparison with a single sorting operation.
    Quicksort is not stable, but mergesort is. It is easy to see why mergesort is
    stable. During merging, we preserve the order, that is, values from the left half
    precede values from the right half when they compare as equal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法的稳定性是指比较相等的元素在排序后保持其原始顺序的性质。例如，如果我们有一个包含某些人的ID号和年龄的对象数组，并且我们想要按年龄递增的顺序对它们进行排序，一个稳定的排序算法将保持具有相同年龄的人的原始顺序。如果我们尝试多次排序，这可能会很有帮助。例如，如果我们想将具有相同年龄的人的ID按递增顺序排列，我们首先可以按ID对数组进行排序，然后再次按年龄排序。如果排序算法是稳定的，它将确保最终排序数组按年龄递增，对于相同年龄，则是按ID递增。当然，这种效果也可以通过在单个排序操作中进行更复杂的比较来实现。快速排序不是稳定的，但归并排序是。很容易看出为什么归并排序是稳定的。在合并过程中，我们保持顺序，即当它们比较相等时，左半部分的值先于右半部分的值。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored two efficient sorting algorithms. The basic principle,
    in both cases, was to divide the array and to sort the parts separately. If we
    ensure that sorting the parts will cause the entire array to be sorted by readjusting
    the elements, it is quicksort. If we just divide the array into two equal parts
    first and–after sorting each part–merge the results to cause the entire array
    to be sorted, it is a mergesort. This way of dividing the input into smaller parts,
    solving the problem for the smaller parts and then combining the results to find
    the solution for the entire problem is a common pattern in solving computational
    problems, and it is called the divide and conquer pattern.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两种高效的排序算法。在两种情况下，基本原理都是将数组分割，并分别对部分进行排序。如果我们确保对部分进行排序会导致通过重新调整元素使整个数组排序，那么这就是快速排序。如果我们首先将数组分成两个相等的部分，然后对每个部分进行排序，最后合并结果以使整个数组排序，那么这就是归并排序。这种将输入分割成更小部分，对较小部分解决问题，然后合并结果以找到整个问题的解决方案的方法是解决计算问题中的一种常见模式，称为分而治之模式。
- en: We have also seen an asymptotic lower bound for any sorting algorithm that works
    using comparisons. Both quicksort and mergesort achieve this lower bound and hence,
    are asymptotically optimal. In the next chapter, we will move to a different kind
    of data structures called trees.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了任何使用比较进行排序的排序算法的渐近下界。快速排序和归并排序都达到了这个下界，因此它们在渐近意义上是最佳的。在下一章中，我们将转向另一种称为树的数据结构。
