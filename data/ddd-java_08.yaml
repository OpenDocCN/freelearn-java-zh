- en: '*Chapter 6*: Implementing the User Interface – Task-Based'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：基于任务的用户界面实现'
- en: To accomplish a difficult task, one must first make it easy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成一项艰巨的任务，首先必须使其变得简单。
- en: – Marty Rubin
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 马蒂·鲁宾
- en: The essence of **Domain-Driven Design** (**DDD**) is about capturing the business
    process and user intent. In the previous chapter, we designed a set of APIs without
    paying much attention to how those APIs would get consumed by their eventual users.
    In this chapter, we will design the GUI for the LC application using the JavaFX
    framework. As part of that, we will examine how this approach of designing APIs
    in isolation can cause an impedance mismatch between the producers and the consumers.
    We will examine the consequences of this impedance mismatch and how task-based
    UIs can help cope with this mismatch.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（DDD）的精髓在于捕捉业务流程和用户意图。在前一章中，我们设计了一套API，并没有过多关注这些API最终用户将如何使用它们。在这一章中，我们将使用JavaFX框架为LC应用程序设计GUI。作为其中的一部分，我们将检查这种独立设计API的方法如何导致生产者和消费者之间的阻抗不匹配。我们将检查这种阻抗不匹配的后果以及基于任务的UI如何帮助应对这种不匹配。'
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: API styles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API样式
- en: Bootstrapping the UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动UI
- en: Implementing the UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现UI
- en: By the end of the chapter, you will know how to employ DDD principles to help
    you build robust user experiences that are simple and intuitive. You will also
    learn why it may be prudent to design your backend interfaces (APIs) from the
    perspective of the consumer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何运用DDD原则来帮助你构建简单直观的健壮用户体验。你还将了解为什么从消费者的角度设计你的后端接口（API）可能是明智的。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need access to the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要访问以下内容：
- en: JDK 1.8+ (we have used Java 16 to compile sample sources)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+（我们使用了Java 16来编译示例源代码）
- en: JavaFX SDK 16 and Scene Builder
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX SDK 16和Scene Builder
- en: Maven 3.x
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 3.x
- en: Spring Boot 2.4.x
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 2.4.x
- en: mvvmFX 1.8 ([https://sialcasa.github.io/mvvmFX/](https://sialcasa.github.io/mvvmFX/))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mvvmFX 1.8 ([https://sialcasa.github.io/mvvmFX/](https://sialcasa.github.io/mvvmFX/))
- en: JUnit 5.7.x (included with Spring Boot)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5.7.x（包含在Spring Boot中）
- en: TestFX (for UI testing)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TestFX（用于UI测试）
- en: OpenJFX Monocle (for headless UI testing)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJFX Monocle（用于无头UI测试）
- en: Project Lombok (to reduce verbosity)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Lombok（用于减少冗余）
- en: Before we dive deep into building the GUI solution, let’s do a quick recap of
    where we left the APIs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入构建GUI解决方案之前，让我们快速回顾一下我们之前留下的API状态。
- en: API styles
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API样式
- en: 'If you recall from [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*, we created the following commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第5章](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)中的*实现领域逻辑*，我们创建了以下命令：
- en: '![Figure 6.1 – Commands from the eventstorming session'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 事件风暴会议中的命令'
- en: '](img/B16716_Figure_6.1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_6.1.jpg](img/B16716_Figure_6.1.jpg)'
- en: Figure 6.1 – Commands from the eventstorming session
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 事件风暴会议中的命令
- en: 'If you observe carefully, there seem to be commands at two levels of granularity.
    **Create LC Application** and **Update LC Application** are coarse-grained, whereas
    the others are a lot more focused in terms of their intent. One possible decomposition
    of the coarse-grained commands can be as depicted here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，似乎有两个粒度的命令。**创建LC应用程序**和**更新LC应用程序**是粗粒度的，而其他的则更专注于它们的意图。粗粒度命令的可能分解方式如下所示：
- en: '![Figure 6.2 – Decomposed commands'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 分解的命令'
- en: '](img/B16716_Figure_6.2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_6.2.jpg](img/B16716_Figure_6.2.jpg)'
- en: Figure 6.2 – Decomposed commands
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 分解的命令
- en: 'In addition to just being more fine-grained than the commands in the previous
    iteration, the revised commands seem to better capture the user’s intent. This
    may feel like a minor change in semantics, but can have a huge impact on the way
    our solution is used by its ultimate end users. The question then is whether we
    should *always* prefer fine-grained APIs over coarse-grained ones. The answer
    can be a lot more nuanced. When designing APIs and experiences, we see two main
    styles being employed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比前一个迭代的命令更细粒度之外，修订后的命令似乎更好地捕捉了用户的意图。这可能感觉像是一个微小的语义变化，但可能会对我们解决方案的最终用户使用方式产生巨大影响。那么问题来了，我们是否应该*始终*偏好细粒度API而不是粗粒度API。答案可能更加复杂。在设计API和体验时，我们看到两种主要风格被采用：
- en: CRUD-based
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于CRUD
- en: Task-based
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于任务
- en: Let’s look at each of these in a bit more detail.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些。
- en: CRUD-based APIs
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于CRUD的API
- en: '`Insert`, `Select`, `Update`, and `Delete`. Similarly, the HTTP protocol has
    `POST`, `GET`, `PUT`, and `DELETE` as verbs to represent these CRUD operations.
    This approach has been extended to the design of our APIs as well. This has resulted
    in the proliferation of both CRUD-based APIs and user experiences. Take a look
    at `CreateLCApplicationCommand` from [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Insert`、`Select`、`Update` 和 `Delete`。同样，HTTP协议有 `POST`、`GET`、`PUT` 和 `DELETE`
    作为动词来表示这些CRUD操作。这种方法已经扩展到我们API的设计中。这导致了基于CRUD的API和用户体验的激增。看看来自 [*第5章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)
    的 `CreateLCApplicationCommand`，*实现领域逻辑*：'
- en: '![](img/ch6-1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![img/ch6-1.jpg](img/ch6-1.jpg)'
- en: 'Along similar lines, it would not be uncommon to create a corresponding `UpdateLCApplicationCommand`,
    as depicted here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着类似的思路，创建相应的 `UpdateLCApplicationCommand` 并不罕见，如下所示：
- en: '![](img/ch6-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![img/ch6-2.jpg](img/ch6-2.jpg)'
- en: 'While this is very common and also very easy to grasp, it is not without problems.
    Here are some questions that taking this approach raises:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这非常常见且很容易理解，但并非没有问题。以下是一些采取这种方法会引发的问题：
- en: Are we allowed to change everything listed in the `update` command?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否允许更改 `update` 命令中列出的所有内容？
- en: Assuming that everything can change, do they all change at the same time?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设一切都可以改变，它们是否同时改变？
- en: How do we know what exactly changed? Should we be doing a diff?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何知道确切发生了什么变化？我们应该进行差异比较吗？
- en: What if all the attributes mentioned above are not included in the `update` command?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上述所有属性都没有包含在 `update` 命令中怎么办？
- en: What if we need to add attributes in the future?
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未来需要添加属性怎么办？
- en: Is the business intent of what the user wanted to accomplish captured?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户想要完成的事务的业务意图是否被捕捉到了？
- en: In a simple system, the answer to these questions may not matter that much.
    However, as system complexity increases, will this approach remain resilient to
    change? We feel that it merits taking a look at another approach called task-based
    APIs to be able to answer these questions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的系统中，这些问题的答案可能并不那么重要。然而，随着系统复杂性的增加，这种方法是否仍然能够适应变化？我们认为，有必要考虑另一种方法，即基于任务的API，以便能够回答这些问题。
- en: Task-based APIs
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于任务的API
- en: In a typical organization, individuals perform tasks relevant to their specialization.
    The bigger the organization, the higher the degree of specialization. This approach
    of segregating tasks according to one’s specialization makes sense because it
    mitigates the possibility of stepping on each other’s shoes, especially when getting
    complex pieces of work done. For example, in the LC application process, there
    is a need to establish the value/legality of the product while also determining
    the creditworthiness of the applicant. It makes sense that each of these tasks
    is usually performed by individuals in unrelated departments. It also follows
    that these tasks can be performed independently of the other.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的组织中，个人执行与其专业相关的任务。组织越大，专业化的程度越高。根据个人专业来隔离任务的方法是有道理的，因为它减少了相互干扰的可能性，尤其是在完成复杂工作的时候。例如，在LC申请流程中，需要确定产品的价值/合法性，同时也要确定申请人的信用度。这些任务通常由不同部门的个人执行是有意义的，这也意味着这些任务可以独立于其他任务执行。
- en: In terms of a business process, if we have a single `CreateLCApplicationCommand`
    command that precedes these operations, individuals in both departments firstly
    have to wait for the entire application to be filled out before either can commence
    their work. Secondly, if either piece of information is updated through a single
    `UpdateLCApplicationCommand` command, it is unclear what changed. This can result
    in a spurious notification being sent to at least one department because of this
    lack of clarity in the process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务流程方面，如果我们有一个名为 `CreateLCApplicationCommand` 的命令先于这些操作，那么两个部门的个人首先必须等待整个申请表填写完毕，然后才能开始他们的工作。其次，如果通过单个
    `UpdateLCApplicationCommand` 命令更新任何信息，那么不清楚具体发生了什么变化。这种流程中的不明确性可能导致至少一个部门收到虚假通知。
- en: Since most work happens in the form of specific tasks, it can work to our advantage
    if our processes and, by extension, our APIs mirror these behaviors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大部分工作都是以特定任务的形式进行的，如果我们的流程和API能够反映这些行为，这将对我们有利。
- en: 'Keeping this in mind, let’s re-examine our revised APIs for the LC application
    process:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们重新审视我们修订后的LC申请流程API：
- en: '![Figure 6.3 – Revised commands'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.3 – 修订后的命令'
- en: '](img/B16716_Figure_6.3.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_6.3.jpg](img/B16716_Figure_6.3.jpg)'
- en: Figure 6.3 – Revised commands
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 修订后的命令
- en: While it may have appeared previously that we have simply converted our coarse-grained
    APIs to become more fine-grained, this, in reality, is a better representation
    of the tasks that the user intended to perform. So, in essence, task-based APIs
    are the decomposition of work in a manner that aligns more closely to the users’
    intents. With our new APIs, product validation can commence as soon as `ChangeMerchandise`
    happens. Also, it is unambiguously clear what the user did and what needs to happen
    in reaction to the user’s action. It then begs the question of whether we should
    employ task-based APIs all the time. Let’s look at the implications in more detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前可能看起来我们只是将粗粒度的API转换为更细粒度，但实际上，这更好地代表了用户意图要执行的任务。因此，本质上，基于任务的API是以与用户意图更紧密对齐的方式对工作进行分解。使用我们新的API，产品验证可以在`ChangeMerchandise`发生时立即开始。此外，用户的行为以及对此行为需要做出何种反应都变得明确无误。这随即引发了一个问题：我们是否应该始终使用基于任务的API。让我们更详细地看看其影响。
- en: Task-based or CRUD-based?
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于任务还是基于CRUD？
- en: 'CRUD-based APIs seem to operate at the level of the aggregate. In our example,
    we have the LC aggregate. In the simplest case, this essentially translates to
    four operations aligned with each of the CRUD verbs. However, as we are seeing,
    even in our simplified version, the LC is becoming a fairly complex concept. Having
    to work with just four operations at the level of the LC is cognitively complex.
    With more requirements, this complexity will only continue to increase. For example,
    consider a situation where the business expresses a need to capture a lot more
    information about `merchandise`, where today, this is simply captured in the form
    of free-form text. A more elaborate version of merchandise information is shown
    here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基于CRUD的API似乎在聚合级别上运行。在我们的例子中，我们有LC聚合。在最简单的情况下，这本质上等同于与每个CRUD动词对齐的四个操作。然而，正如我们所看到的，即使在我们的简化版本中，LC正成为一个相当复杂的概念。在LC级别上仅需要处理四个操作，从认知上来说是复杂的。随着需求的增加，这种复杂性只会继续增加。例如，考虑一种情况，业务表达了对捕获更多关于“商品”信息的需要，而今天，这仅仅以自由文本的形式被捕获。这里展示了商品信息的更详细版本：
- en: '![](img/ch6-3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch6-3.jpg)'
- en: 'In our current design, the implications of this change are far-reaching for
    both the provider and the consumer(s). Let’s look at some of the consequences
    in more detail:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的设计中，这种变化的含义对提供者和消费者（们）都产生了深远的影响。让我们更详细地看看一些后果：
- en: '![](img/B16716_06_Table_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16716_06_Table_01.jpg)'
- en: In our current design, the implications of this change are far-reaching for
    both the provider and the consumer(s). Let’s look at some of the consequences
    in more detail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的设计中，这种变化的含义对提供者和消费者（们）都产生了深远的影响。让我们更详细地看看一些后果。
- en: As we can see, the decision between CRUD-based and task-based interfaces is
    nuanced. We are not suggesting that you should choose one over the other. Which
    style you use will depend on your specific requirements and context. In our experience,
    task-based interfaces treat user intents as first-class citizens and perpetuate
    the spirit of DDD’s ubiquitous language very elegantly. Our preference is to design
    interfaces as task-based where possible because they result in more intuitive
    interfaces that better express the problem domain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，基于CRUD和基于任务的接口之间的选择是微妙的。我们并不是建议你应该选择其中之一。你使用哪种风格将取决于你的具体需求和上下文。根据我们的经验，基于任务的接口将用户意图视为一等公民，并以非常优雅的方式延续了DDD的通用语言精神。我们更倾向于尽可能地将接口设计为基于任务的，因为它们会产生更直观的界面，更好地表达问题域。
- en: 'As systems evolve, and they begin to support richer user experiences and multiple
    channels, the CRUD-based interface seems to require additional translation layers
    to cater to user experience needs. The visual here depicts a typical layered architecture
    of a solution that supports multiple-user experience channels:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的演变，它们开始支持更丰富的用户体验和多个渠道，基于CRUD的接口似乎需要额外的翻译层来满足用户体验需求。下面的图示描绘了一个支持多用户体验渠道的解决方案的典型分层架构：
- en: '![Figure 6.4 – Layered architecture supporting multiple-user experience channels'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 支持多用户体验渠道的分层架构'
- en: '](img/B16716_Figure_6.4.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_6.4.jpg)'
- en: Figure 6.4 – Layered architecture supporting multiple-user experience channels
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 支持多用户体验渠道的分层架构
- en: 'This setup is usually composed of the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置通常由以下内容组成：
- en: A domain tier comprised of CRUD-based services that simply map closely to database
    entities
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由基于CRUD的服务组成的领域层，这些服务简单地映射到数据库实体
- en: A composite tier comprised of business capabilities that span more than one
    core service
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由跨越多个核心服务的企业能力组成的复合层
- en: A **Backend for Frontend** (**BFF**) tier, comprised of channel-specific APIs
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由特定通道API组成的**前端后端**（**BFF**）层
- en: Note that the composite and BFF tiers exist primarily as a means to map backend
    capabilities to user intent. In an ideal world, where backend APIs reflect user
    intent closely, the need for translations should be minimal (if at all). Our experience
    suggests that such a setup causes business logic to get pushed closer to the user
    channels as opposed to being encapsulated within the confines of well-factored
    business services. In addition, these tiers cause inconsistent experiences across
    channels for the same functionality, given that modern teams are structured along
    tier boundaries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，复合层和BFF层主要作为将后端能力映射到用户意图的手段。在一个理想的世界里，如果后端API紧密反映用户意图，那么翻译的需求应该是最小的（如果有的话）。我们的经验表明，这种设置会导致业务逻辑被推向用户通道，而不是封装在精心设计的业务服务中。此外，这些层会导致同一功能在不同通道上产生不一致的体验，因为现代团队是按照层边界结构化的。
- en: Important Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are not opposed to the use of layered architectures. We recognize that a
    layered architecture can bring modularity, separation of concerns, and other related
    benefits. However, we are opposed to creating additional tiers merely as a means
    to compensate for poorly factored core domain APIs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不反对使用分层架构。我们认识到分层架构可以带来模块化、关注点分离和其他相关好处。然而，我们反对仅仅为了补偿核心领域API设计不当而创建额外的层级。
- en: A well-factored API tier can have a profound effect on how great user experiences
    are built. However, this is a chapter on implementing the user interface. Let’s
    revert to creating the user interface for the LC application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个精心设计的API层可以对构建出色的用户体验产生深远的影响。然而，这是一章关于实现用户界面的内容。让我们回到为LC应用程序创建用户界面的任务。
- en: Bootstrapping the UI
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动UI
- en: 'We will simply be building the UI for the LC application we created in [*Chapter
    5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing Domain Logic*.
    For detailed instructions, refer to the *Bootstrapping the application* section.
    In addition, we will need to add the following dependencies to the `dependencies`
    section of the Maven `pom.xml` file in the root directory of the project:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地为我们创建的LC应用程序构建UI，该应用程序在[*第5章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)中实现，*实现领域逻辑*。有关详细说明，请参阅*启动应用程序*部分。此外，我们还需要将以下依赖项添加到项目根目录下的Maven
    `pom.xml`文件的`dependencies`部分：
- en: '![](img/ch6-4.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-4.jpg)'
- en: 'To run UI tests, you will need to add the following dependencies:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行UI测试，你需要添加以下依赖项：
- en: '![](img/ch6-5.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-5.jpg)'
- en: 'To be able to run the application from the command line, you will need to add
    `javafx-maven-plugin` to the `plugins` section of your `pom.xml` file, per the
    following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够从命令行运行应用程序，你需要在`pom.xml`文件的`plugins`部分添加`javafx-maven-plugin`，如下所示：
- en: '![](img/ch6-6.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-6.jpg)'
- en: 'To run the application from the command line, use the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行应用程序，请使用以下命令：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you are using a JDK greater than version 1.8, the JavaFX libraries may not
    be bundled with the JDK itself. When running the application from your IDE, you
    will likely need to add the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是版本大于1.8的JDK，JavaFX库可能不会与JDK本身捆绑。当你从你的IDE运行应用程序时，你可能会需要添加以下内容：
- en: '`--module-path=<path-to-javafx-sdk>/lib/ \`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`--module-path=<path-to-javafx-sdk>/lib/ \`'
- en: '`--add-modules=javafx.controls,javafx.graphics,`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`--add-modules=javafx.controls,javafx.graphics,`'
- en: '`javafx.fxml,javafx.media`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`javafx.fxml,javafx.media`'
- en: 'We are making use of the mvvmFX framework to assemble the UI. To make this
    work with Spring Boot, the application launcher looks as depicted here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用mvvmFX框架来组装UI。为了与Spring Boot兼容，应用程序启动器看起来如下所示：
- en: '![](img/ch6-7.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-7.jpg)'
- en: Important Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are required to extend from the `MvvmfxSpringApplication` mvvmFX framework
    class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`MvvmfxSpringApplication` mvvmFX框架类扩展。
- en: Please refer to the `ch06` directory of the accompanying source code repository
    for the complete example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考附带源代码仓库中的`ch06`目录以获取完整示例。
- en: Implementing the UI
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现UI
- en: 'When working with user interfaces, it is fairly customary to use one of these
    presentation patterns:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当与用户界面一起工作时，使用以下这些表示模式是相当常见的：
- en: '**Model View Controller** (**MVC**)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）'
- en: '**Model View Presenter** (**MVP**)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-演示者**（**MVP**）'
- en: '**Model View View Model** (**MVVM**)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）'
- en: The MVC pattern has been around for the longest time. The idea of separating
    concerns among collaborating model, view, and controller objects is a sound one.
    However, beyond the definition of these objects, actual implementations seem to
    vary wildly – with the controller becoming overly complex in a lot of cases. In
    contrast, MVP and MVVM, while being derivatives of MVC, seem to bring about a
    better separation of concerns between the collaborating objects. MVVM, in particular
    when coupled with data-binding constructs, makes for code that is much more readable,
    maintainable, and testable. In this book, we make use of MVVM because it enables
    test-driven development, which is a strong personal preference for us. Let’s look
    at a quick MVVM primer, as implemented in the mvvmFX framework.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式存在时间最长。在协作的模型、视图和控制器对象之间分离关注点的想法是合理的。然而，在实际实现中，这些对象的定义似乎有很大的差异——在许多情况下，控制器变得过于复杂。相比之下，MVP和MVVM，虽然都是MVC的衍生品，但似乎在协作对象之间带来了更好的关注点分离。特别是当与数据绑定构造结合使用时，MVVM使得代码更加易于阅读、维护和测试。在这本书中，我们使用MVVM，因为它使我们能够进行测试驱动开发，这是我们强烈偏好的。让我们快速了解一下MVVM入门，如mvvmFX框架中实现的那样。
- en: MVVM primer
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM入门
- en: 'Modern UI frameworks started adopting a declarative style to express the view.
    MVVM was designed to remove all GUI code (code-behind) from the view by making
    use of binding expressions. This allowed for a cleaner separation of stylistic
    versus programming concerns. A high-level visual of how this pattern is implemented
    is shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现代UI框架开始采用声明性风格来表示视图。MVVM旨在通过使用绑定表达式从视图中移除所有GUI代码（代码后置），从而实现风格与编程关注点之间的更清晰分离。这里展示了如何实现此模式的视觉高级概述：
- en: '![Figure 6.5 – MVVM design pattern'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.5 – MVVM设计模式](img/Figure_6.5_MVVM_design_pattern.jpg)'
- en: '](img/B16716_Figure_6.6.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![B16716_Figure_6.6.jpg](img/B16716_Figure_6.6.jpg)'
- en: Figure 6.5 – MVVM design pattern
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – MVVM设计模式
- en: 'The pattern comprises the following components:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式包含以下组件：
- en: '**Model**: Responsible for housing the business logic and managing the state
    of the application.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：负责容纳业务逻辑和管理应用程序的状态。'
- en: '**View**: Responsible for presenting data to the user and notifying the view-model
    about user interactions through the view delegate.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：负责向用户展示数据，并通过视图代理通知视图模型关于用户交互。'
- en: '**View Delegate**: Responsible for keeping the view and the view-model in sync
    as changes are made by the user or on the view-model. It is also responsible for
    transmitting actions performed on the view to the view-model.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图代理**：负责在用户或视图模型进行更改时保持视图和视图模型同步。它还负责将视图上执行的操作传输到视图模型。'
- en: '**View-Model**: Responsible for handling user interactions on behalf of the
    view. The view-model interacts with the view using the observer pattern (typically,
    one-way or two-way data binding to make it more convenient). The view-model interacts
    with the model for updates and read operations.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：负责代表视图处理用户交互。视图模型使用观察者模式（通常是一向或双向数据绑定，使其更方便）与视图交互。视图模型与模型交互以进行更新和读取操作。'
- en: Creating a new LC
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的LC
- en: 'Let’s consider the example of creating a new LC. To start the creation of a
    new LC, all we need is for the applicant to provide a friendly client reference.
    This is an easy-to-remember string of free text. A simple rendition of this UI
    is shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑创建新的LC的例子。要开始创建新的LC，我们只需要申请人提供一个友好的客户端引用。这是一个容易记住的文本字符串。这里展示了这个UI的简单版本：
- en: '![Figure 6.7 – Start LC creation screen'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.7 – Start LC creation screen](img/Figure_6.7_Start_LC_creation_screen.jpg)'
- en: '](img/B16716_Figure_6.7.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![B16716_Figure_6.7.jpg](img/B16716_Figure_6.7.jpg)'
- en: Figure 6.7 – Start LC creation screen
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 开始LC创建屏幕
- en: Let’s examine the implementation and purpose of each component in more detail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查每个组件的实现和目的。
- en: Declarative view
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明性视图
- en: 'When working with JavaFX, the view can be rendered using a declarative style
    in FXML format. Important excerpts from the `StartLCView.fxml` file to start creating
    a new LC are shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JavaFX时，视图可以使用FXML格式的声明性风格进行渲染。以下是从`StartLCView.fxml`文件中提取的重要片段，用于开始创建新的LC：
- en: '![](img/ch6-8.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![ch6-8.jpg](img/ch6-8.jpg)'
- en: The `StartLCView` class acts as the view delegate for the FXML view and is assigned
    using the `fx:controller` attribute of the root element (`javafx.scene.layout.Pane`,
    in this case).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StartLCView`类作为FXML视图的视图代理，并使用根元素（在这种情况下为`javafx.scene.layout.Pane`）的`fx:controller`属性进行分配。'
- en: In order to reference the `client-reference` input field in the view delegate,
    we use the `fx:id` annotation (`clientReference`, in this case).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在视图代理中引用`client-reference`输入字段，我们使用`fx:id`注解（在这种情况下为`clientReference`）。
- en: Similarly, the start button is referenced using "`fx:id=startButton"` in the
    view delegate. Furthermore, the `start` method in the view delegate is assigned
    to handle the default action (the button press event for `javafx.scene.control.Button`).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在视图代理中使用`"`fx:id=startButton"`来引用启动按钮。此外，视图代理中的`start`方法被分配来处理默认操作（`javafx.scene.control.Button`的按钮按下事件）。
- en: View delegate
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图代理
- en: 'Next, let’s look at the structure of the `com.premonition.lc.issuance.ui.views.StartLCView`
    view delegate:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`com.premonition.lc.issuance.ui.views.StartLCView`视图代理的结构：
- en: '![](img/ch6-9.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-9.jpg)'
- en: This is the view delegate class for the `StartLCView.fxml` view.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`StartLCView.fxml`视图的视图代理类。
- en: This is the Java binding for the `clientReference` textbox in the view. The
    name of the member needs to match exactly with the value of the `fx:id` attribute
    in the view. Further, it needs to be annotated with the `@javafx.fxml.FXML` annotation.
    The use of the `@FXML` annotation is optional if the member in the view delegate
    is public and matches the name in the view.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是视图中的`clientReference`文本框的Java绑定。成员的名称需要与视图中的`fx:id`属性值完全匹配。此外，它需要使用`@javafx.fxml.FXML`注解进行注解。如果视图代理中的成员是公共的并且与视图中的名称匹配，则使用`@FXML`注解是可选的。
- en: Similarly, `startButton` is bound to the corresponding button widget in the
    view.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`startButton`被绑定到视图中的相应按钮小部件。
- en: This is the method for the action handler when `startButton` is pressed.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是当按下`startButton`时的动作处理方法。
- en: View-model
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图模型
- en: 'The `StartLCViewModel` view-model class for `StartLCView` is shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`StartLCView`的`StartLCViewModel`视图模型类：
- en: '![](img/ch6-10.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-10.jpg)'
- en: This is the view-model class for `StartLCView`. Note that we are required to
    implement the `de.saxsys.mvvmfx.ViewModel` interface provided by the mvvmFX framework.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`StartLCView`的视图模型类。请注意，我们必须实现mvvmFX框架提供的`de.saxsys.mvvmfx.ViewModel`接口。
- en: We are initializing the `clientReference` property using `SimpleStringProperty`
    provided by JavaFX. There are several other property classes to define more complex
    types. Please refer to the JavaFX documentation for more details.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用JavaFX提供的`SimpleStringProperty`初始化`clientReference`属性。还有其他几个属性类可以定义更复杂的数据类型。请参阅JavaFX文档以获取更多详细信息。
- en: This is the value of `clientReference` in the view-model. We will look at how
    to associate this with the value of the `clientReference` textbox in the view
    shortly. Note that we are using `StringProperty` provided by JavaFX, which provides
    access to the underlying string value of the client reference.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是视图模型中`clientReference`的值。我们很快将看看如何将其与视图中的`clientReference`文本框的值关联起来。请注意，我们正在使用JavaFX提供的`StringProperty`，它提供了对客户端引用底层字符串值的访问。
- en: JavaFX beans are required to create a special accessor for the property itself
    in addition to the standard getter and setter for the underlying value.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了为底层值的标准获取器和设置器之外，JavaFX beans还需要创建一个特殊的访问器来处理该属性本身。
- en: Binding the view to the view-model
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将视图绑定到视图模型
- en: 'Next, let’s look at how to associate the view to the view-model:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何将视图与视图模型关联起来：
- en: '![](img/ch6-11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-11.jpg)'
- en: The `mvvmFX` framework requires that the `view delegate` implement the `FXMLView<?`
    `extends` `ViewModelType>`. In this case, the view-model type is `StartLCViewModel`.
    The `mvvmFX` framework supports other view types as well. Please refer to the
    framework documentation for more details.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mvvmFX`框架要求`view delegate`实现`FXMLView<? extends ViewModelType>`。在这种情况下，视图模型类型是`StartLCViewModel`。`mvvmFX`框架还支持其他视图类型。请参阅框架文档以获取更多详细信息。'
- en: The framework provides a `@de.saxsys.mvvmfx.InjectViewModel` annotation to allow
    dependency, injecting the view-model into the view delegate.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 框架提供了一个`@de.saxsys.mvvmfx.InjectViewModel`注解，允许依赖注入，将视图模型注入到视图代理中。
- en: The framework will invoke all methods annotated with the `@de.saxsys.mvvmfx.Initialize`
    annotation during the initialization process. The annotation can be omitted if
    the method is named `initialize` and is declared public. Please refer to the framework
    documentation for more details.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 框架将在初始化过程中调用所有带有`@de.saxsys.mvvmfx.Initialize`注解的方法。如果方法名为`initialize`且声明为public，则可以省略此注解。请参阅框架文档以获取更多详细信息。
- en: We have now bound the text property of the `clientReference` textbox in the
    view delegate to the corresponding property in the view-model. Note that this
    is a bidirectional binding, which means that the value in the view and the view-model
    are kept in sync if it changes on either side.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经将视图代理中`clientReference`文本框的文本属性绑定到视图模型中的相应属性。请注意，这是一个双向绑定，这意味着如果任一端发生变化，视图和视图模型中的值都将保持同步。
- en: This is another variation of binding in action, where we are making use of a
    unidirectional binding. Here, we are binding the disabled property of the start
    button to the corresponding property on the view-model. We will look at why we
    need to do this shortly.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是绑定操作的另一种变体，我们在这里使用的是单向绑定。在这里，我们将启动按钮的禁用属性绑定到视图模型上的相应属性。我们很快就会看到为什么我们需要这样做。
- en: Enforcing business validations in the UI
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在UI中强制执行业务验证
- en: We have a business validation that the client reference for an LC needs to be
    at least four characters in length. This will be enforced on the backend. However,
    to provide a richer user experience, we will also enforce this validation on the
    UI.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个业务验证，即LC的客户端引用长度至少需要四个字符。这将在后端强制执行。然而，为了提供更丰富的用户体验，我们也将在这个UI上强制执行此验证。
- en: Important Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This may feel contrary to the notion of centralizing business validations on
    the backend. While this may be a noble attempt at implementing the **Don’t Repeat
    Yourself** (**DRY**) principle, in reality, it poses a lot of practical problems.
    Distributed systems expert Udi Dahan has a very interesting take on why this may
    not be such a virtuous thing to pursue. Ted Neward also talks about this in his
    blog, entitled *The Fallacies of Enterprise Computing*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与我们集中业务验证在后端的概念相悖。虽然这可能是一个崇高的尝试来实施**不要重复自己**（**DRY**）原则，但在现实中，它带来了许多实际的问题。分布式系统专家Udi
    Dahan对为什么这可能不是一个值得追求的善举有非常有趣的看法。Ted Neward也在他的博客中谈到了这一点，标题为*企业计算的谬误*。
- en: 'The advantage of using MVVM is that this logic is easily testable in a simple
    unit test of the view-model. Let’s see this in action now:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVVM的优势在于，这个逻辑可以很容易地在视图模型的简单单元测试中进行测试。现在让我们看看它是如何工作的：
- en: '![](img/ch6-12.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch6-12.jpg)'
- en: 'Now, let’s look at the implementation for this functionality in the view-model:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看视图模型中这个功能的实现：
- en: '![](img/ch6-13.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch6-13.jpg)'
- en: We declare a `startDisabled` property in the view-model to manage when the start
    button should be disabled.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在视图模型中声明了一个`startDisabled`属性来管理何时应禁用启动按钮。
- en: The minimum length for a valid client reference is injected into the view-model.
    It is conceivable that this value will be provided as part of the external configuration,
    or possibly from the backend.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有效客户端引用的最小长度被注入到视图模型中。可以想象，这个值可能是作为外部配置的一部分提供的，或者可能来自后端。
- en: We create a binding expression to match the business requirement.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个绑定表达式来匹配业务要求。
- en: We bind the view-model property to the disabled property of the start button
    in the view delegate.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将视图模型属性绑定到视图代理中启动按钮的禁用属性。
- en: 'Let’s also look at how to write an end-to-end, headless UI test, as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看如何编写一个端到端、无头UI测试，如下所示：
- en: '![](img/ch6-14.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch6-14.jpg)'
- en: We have written a convenience `@UITest` extension to combine the Spring Framework
    and TestFX testing. Please refer to the accompanying source code with the book
    for more details.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写了一个方便的`@UITest`扩展，用于结合Spring框架和TestFX测试。请参阅书中附带的源代码以获取更多详细信息。
- en: We set up the Spring context to act as the dependency injection provider for
    the mvvmFX framework and its injection annotations (for example, `@InjectViewModel`)
    to work.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了Spring上下文，使其作为mvvmFX框架及其注入注解（例如，`@InjectViewModel`）的依赖注入提供者。
- en: We are using the `@Start` annotation provided by the TestFX framework to launch
    the UI.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用TestFX框架提供的`@Start`注解来启动UI。
- en: The TestFX framework injects an instance of the FxRobot UI helper, which we
    can use to access UI elements.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TestFX框架注入了一个FxRobot UI辅助实例，我们可以使用它来访问UI元素。
- en: We are using the TestFX framework-provided convenience-matchers for test assertions.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用TestFX框架提供的便利匹配器进行测试断言。
- en: 'Now, when we run the application, we can see that the start button is enabled
    when a valid client reference is entered:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行应用程序时，我们可以看到在输入有效的客户端引用时启动按钮是启用的：
- en: '![Figure 6.8 – The start button is enabled with a valid client reference'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 – 使用有效的客户端引用启用启动按钮'
- en: '](img/B16716_Figure_6.8.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_6.8.jpg)'
- en: Figure 6.8 – The start button is enabled with a valid client reference
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 使用有效的客户端引用启用启动按钮
- en: Now that we have the start button enabling correctly, let’s implement the actual
    creation of the LC itself by invoking the backend API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确地启用了启动按钮，让我们实现LC本身的实际创建，通过调用后端API。
- en: Integrating with the backend
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成后端
- en: 'LC creation is a complex process, requiring information about a variety of
    items as evidenced when we decomposed the LC creation process. In this section,
    we will integrate the UI with the command to start the creation of a new LC. This
    happens when we press the `StartNewLCApplicationCommand` looks as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: LC创建是一个复杂的过程，需要各种物品的信息，正如我们在分解LC创建过程时所证明的那样。在本节中，我们将集成UI与启动新LC创建的命令。这发生在我们按下`StartNewLCApplicationCommand`时，如下所示：
- en: '![](img/ch6-15.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-15.jpg)'
- en: To start a new LC application, we need `applicantId` and `clientReference`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动一个新的LC应用程序，我们需要`applicantId`和`clientReference`。
- en: 'Given that we are using the MVVM pattern, the code to invoke the backend service
    is part of the view-model. Let’s test-drive this functionality:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用MVVM模式，调用后端服务的代码是视图模型的一部分。让我们驱动测试这个功能：
- en: '![](img/ch6-16.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-16.jpg)'
- en: 'The view-model is enhanced accordingly to inject an instance of `BackendService`
    and looks as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型相应增强以注入`BackendService`的实例，如下所示：
- en: '![](img/ch6-17.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-17.jpg)'
- en: 'Now, let’s test to actually make sure that the backend gets invoked only when
    a valid client reference is input:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试以确保只有在输入有效的客户端引用时才调用后端：
- en: '![](img/ch6-18.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-18.jpg)'
- en: We set the logged-in user.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置已登录用户。
- en: When the client reference is blank, there should be no interactions with the
    backend service.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端引用为空时，不应与后端服务有任何交互。
- en: When a valid value for the client reference is entered, the backend should be
    invoked with the entered value.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当输入有效的客户端引用值时，后端应该使用输入的值进行调用。
- en: 'The implementation to make this test pass looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使此测试通过的实现看起来像这样：
- en: '![](img/ch6-19.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-19.jpg)'
- en: We check that the start button is enabled before invoking the backend.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在调用后端之前检查启动按钮是否启用。
- en: These are the actual backend calls with the appropriate values.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是实际的带有适当值的后端调用。
- en: 'Now, let’s look at how to integrate the backend call from the view. We test
    this in a UI test, as shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从视图中集成后端调用。我们在UI测试中进行了此测试，如下所示：
- en: '![](img/ch6-20.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-20.jpg)'
- en: We inject a mock instance of the backend service.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们注入后端服务的模拟实例。
- en: We stub the call to the backend to return successfully.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们模拟后端调用以成功返回。
- en: We type in a valid value for the client reference.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们输入有效的客户端引用值。
- en: We click on the **Start** button.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击**启动**按钮。
- en: We verify that the service was indeed invoked with the correct arguments.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们验证服务确实使用正确的参数进行了调用。
- en: We verify that we have moved to the next screen in the UI (the LC details screen).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们验证我们已经移动到UI中的下一个屏幕（LC详细信息屏幕）。
- en: 'Let’s also look at what happens when the service invocation fails in another
    test:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当服务调用在另一个测试中失败时会发生什么：
- en: '![](img/ch6-21.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-21.jpg)'
- en: We stub the backend service call to fail with an exception.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们模拟后端服务调用失败并抛出异常。
- en: We verify that we continue to remain on `start-lc-screen`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们验证我们继续停留在`start-lc-screen`。
- en: 'The view implementation for this functionality is shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能的视图实现如下所示：
- en: '![](img/ch6-22.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-22.jpg)'
- en: JavaFX, like most frontend frameworks, is single-threaded and requires that
    long-running tasks not be invoked on the UI thread. For this purpose, it provides
    the `javafx.concurrent.Service` abstraction to handle such interactions elegantly
    in a background thread.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaFX，像大多数前端框架一样，是单线程的，并且要求长时间运行的任务不要在UI线程上调用。为此，它提供了`javafx.concurrent.Service`抽象，以在后台线程中优雅地处理此类交互。
- en: The actual invocation of the backend through the view-model happens here.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过视图模型实际调用后端发生在这里。
- en: We show the next screen to enter more LC details here.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里显示下一个屏幕以输入更多的LC详细信息。
- en: 'Finally, the service implementation itself is shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务实现本身如下所示：
- en: '![](img/ch6-23.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch6-23.jpg)'
- en: We inject `org.axonframework.commandhandling.gateway.CommandGateway` provided
    by Axon Framework to invoke the command.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们注入由 Axon 框架提供的 `org.axonframework.commandhandling.gateway.CommandGateway`
    来调用命令。
- en: The actual invocation of the backend using the `sendAndWait` method happens
    here. In this case, we are blocking until the backend call completes. There are
    other variations that do not require this kind of blocking. Please refer to the
    Axon Framework documentation for more details.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，使用 `sendAndWait` 方法调用后端发生在这里。在这种情况下，我们会阻塞，直到后端调用完成。还有其他不需要这种阻塞的变体。请参阅 Axon
    框架文档以获取更多详细信息。
- en: We have now seen a complete example of how to implement the UI and invoke the
    backend API.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了一个完整的示例，展示了如何实现 UI 和调用后端 API。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the nuances of API styles and clarified why it
    is very important to design APIs that capture the users’ intent closely. We looked
    at the differences between CRUD-based and task-based APIs. Finally, we implemented
    the UI making use of the MVVM design pattern and demonstrated how it aids in test-driving
    frontend functionality.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 API 风格的细微差别，并阐明了设计能够紧密捕捉用户意图的 API 非常重要的原因。我们比较了基于 CRUD 和基于任务的 API
    的区别。最后，我们利用 MVVM 设计模式实现了 UI，并展示了它是如何帮助测试驱动前端功能的。
- en: Now that we have implemented the creation of a new LC, for implementing the
    subsequent commands we will require access to an existing LC. In the next chapter,
    we will look at how to implement the query side and how to keep it in sync with
    the command side.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了创建新的 LC，为了实现后续的命令，我们需要访问现有的 LC。在下一章中，我们将探讨如何实现查询端以及如何使其与命令端保持同步。
- en: Further reading
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '![](img/B16716_06_Table_02.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16716_06_Table_02.jpg)'
