- en: 16\. Predicates and Other Functional Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16. 谓词和其他函数式接口
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter explores all the valid use cases of functional interfaces. It will
    first define what these interfaces are (beginning with the predicate interface),
    as well as how best to employ them in your code. You will then learn how to build
    and apply predicates, studying their composition and how to use this to model
    complex behavior. You will practice creating consumer interfaces to change the
    state of your program, and, eventually, use functions to extract useful constructs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了所有有效的函数式接口的使用案例。它将首先定义这些接口是什么（从谓词接口开始），以及如何在代码中最佳地使用它们。然后，你将学习如何构建和应用谓词，研究它们的组合以及如何使用这种组合来模拟复杂行为。你将练习创建消费者接口以改变程序的状态，并最终使用函数来提取有用的结构。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Alongside the many other improvements in Java 8 (such as the streaming API,
    method references, optionals, and collectors) there are interface improvements
    that allow default and static methods known as functional interfaces. These are
    interfaces with one single abstract method, which enables their transformation
    into lambdas. You can read more about this in *Chapter 13*, *Functional Programming
    with Lambda Expressions*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Java 8 的许多其他改进（如流式 API、方法引用、可选和收集器）之外，还有接口改进，允许默认和静态方法，这些方法被称为函数式接口。这些接口只有一个抽象方法，这使得它们可以转换为
    lambda 表达式。你可以在第 13 章*使用 Lambda 表达式的函数式编程*中了解更多相关信息。
- en: There are a total of 43 unique functional interfaces in the `java.util.function`
    package; most of them are variants of the same kind of interface, albeit with
    different data types. In this chapter, we'll introduce you to the **predicate
    functional interface**, along with a few other selected interfaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.util.function` 包中总共有 43 个独特的函数式接口；它们大多数是同一类接口的变体，尽管数据类型不同。在本章中，我们将向您介绍**谓词函数式接口**，以及一些其他精选的接口。
- en: Here, you'll find that many of the functional interfaces operate in very similar
    ways, often just replacing the type of data that the interface can operate on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会发现许多函数式接口以非常相似的方式操作，通常只是替换了接口可以操作的数据类型。
- en: Predicate Interface
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谓词接口
- en: The predicate interface is a quite simple, yet surprisingly elegant and complex,
    functional interface that allows you, as a programmer, to define functions that
    describe the state of your program in the shape of Booleans. In Java, speech predicates
    are one-argument functions that return a Boolean value.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词接口是一个相当简单，但出奇地优雅和复杂的函数式接口，它允许你作为程序员，以布尔形式定义描述程序状态的函数。在 Java 中，言语谓词是一元函数，返回一个布尔值。
- en: 'The predicate API looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词 API 看起来是这样的：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, the predicate API also utilizes the new interface features of Java
    8\. Its sports default and static functions to enrich the API, allowing more complex
    descriptions of your program''s state. Here, three functions are important:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，谓词 API 还利用了 Java 8 的新接口功能。它使用默认和静态函数来丰富 API，允许更复杂地描述程序的状态。在这里，有三个函数很重要：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With these three functions, you can chain predicates to describe more complex
    queries on your program's state. The `and` function will combine two or more predicates,
    ensuring that every predicate supplied returns true.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个函数，你可以将谓词链起来，以描述对程序状态的更复杂查询。`and` 函数将组合两个或多个谓词，确保提供的每个谓词都返回 true。
- en: The `or` function is equivalent to a logical OR, letting you short-circuit the
    predicate chain when required.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`or` 函数等同于逻辑或，允许在需要时短路谓词链。'
- en: Finally, the `not` function returns the negated version of the predicate supplied,
    and it has the exact same effect as calling `negate()` on the supplied predicate.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`not` 函数返回所提供的谓词的否定版本，并且它具有与在所提供的谓词上调用 `negate()` 相同的效果。
- en: There is also a `helper` function to build a predicate that checks whether two
    objects are identical according to the `equals` method on said objects. We can
    use the static `isEqual(Object target)` method to build that predicate for two
    objects The following exercise will serve as an example of defining a predicate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `helper` 函数用于构建一个谓词，该谓词根据对象上的 `equals` 方法检查两个对象是否相同。我们可以使用静态的 `isEqual(Object
    target)` 方法为两个对象构建该谓词。以下练习将作为定义谓词的示例。
- en: 'Exercise 1: Defining a predicate'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：定义谓词
- en: 'Defining a predicate is quite simple. Consider building the backend server
    of a home alarm system. This system needs to easily understand the state of numerous
    different sensors at the same time—instances such as: Is the door open or closed?
    Is the battery healthy or not? Are the sensors connected?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个谓词相当简单。考虑构建一个家庭警报系统的后端服务器。这个系统需要能够同时轻松理解多个不同传感器的状态——例如：门是开还是关？电池是否健康？传感器是否连接？
- en: 'Building such a system is a complex task. We''ll try simplifying the process
    in this exercise:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这样一个系统是一个复杂任务。我们将尝试在这个练习中简化这个过程：
- en: If IntelliJ is already started, but no project is open, select `Create New Project`.
    If IntelliJ already has a project open, select `File` -> `New` -> `Project` from
    the menu.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 IntelliJ 已经启动，但没有打开项目，请选择 `创建新项目`。如果 IntelliJ 已经打开了项目，请从菜单中选择 `文件` -> `新建`
    -> `项目`。
- en: In `New Project` dialog, select a Java project. Click `Next`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `新建项目` 对话框中，选择一个 Java 项目。点击 `下一步`。
- en: Check the box to create the project from a template. Select `Command Line App`.
    Click `Next`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打勾以从模板创建项目。选择 `命令行应用程序`。点击 `下一步`。
- en: Give the new project the name `Chapter16`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新的项目命名为 `Chapter16`。
- en: IntelliJ will give you a default project location. If you wish to select one,
    you may enter it here.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IntelliJ 会为你提供一个默认的项目位置。如果你希望选择一个，你可以在这里输入。
- en: Set the package name to `com.packt.java.chapter16`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包名设置为 `com.packt.java.chapter16`。
- en: Click `Finish`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `完成`。
- en: 'Your project will be created with the standard folder structure, and with an
    entry point class for your program. It will look something like this:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的项目将以标准的文件夹结构创建，并包含一个程序的入口点类。它看起来可能像这样：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Rename this file to `Exercise1.java`, making sure to use the `Refactor` | `Rename`
    menu. When you''re done, it should look like this:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件重命名为 `Exercise1.java`，确保使用 `重构` | `重命名` 菜单。完成时，它应该看起来像这样：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The alarm system will have three different kinds of sensors – a `Gateway sensor`,
    a `Movement sensor`, and a `Fire sensor`. They will all have the same basic qualities
    but may differ in certain aspects. Create the `Base` sensor interface and let
    it have two getter/setter pairs. The first pair should be called `batteryHealth`
    and will return an integer between 0 and 100, and the second pair will be a Boolean
    value called `triggered`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报系统将有三类不同的传感器——一个 `网关传感器`、一个 `运动传感器` 和一个 `火灾传感器`。它们都将具有相同的基本特性，但在某些方面可能有所不同。创建
    `Base` 传感器接口，并让它有两个 getter/setter 对，第一对应该命名为 `batteryHealth`，它将返回一个介于 0 和 100
    之间的整数，第二对将是一个布尔值，命名为 `triggered`：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create the `Gateway Sensor` class, and allow it to implement the `Sensor` interface
    and return instance variables:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Gateway Sensor` 类，并允许它实现 `Sensor` 接口并返回实例变量：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Do the same thing for the `Movement` and `Fire` sensor classes, except the
    `Fire` sensor will also have the current `temperature`, and the `movement sensor`
    will return the strength of the ambient light in the room:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `Movement` 和 `Fire` 传感器类做同样的事情，除了 `Fire` 传感器还将有当前的 `温度`，而 `运动传感器` 将返回房间内环境光的强度：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code for `Movement` class is as follows:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Movement` 类的代码如下：'
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add constructors to all three sensor classes, utilizing IntelliJ helpers to
    this end. Open the `Fire` class, use the `Code` | `Generate` menu, and select
    `Constructor`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有三个传感器类添加构造函数，利用 IntelliJ 的助手来完成这个任务。打开 `Fire` 类，使用 `代码` | `生成` 菜单，并选择 `构造函数`。
- en: 'Select all three variables and click `OK`. Your `Fire` class should now look
    something like this:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有三个变量并点击 `确定`。你的 `Fire` 类现在应该看起来像这样：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generate constructors for the `Gateway` and `Movement` sensors as well.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Gateway` 和 `Movement` 传感器生成构造函数。
- en: You should now have three functioning classes representing sensor states in
    your program.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该在你的程序中有了三个代表传感器状态的类。
- en: 'It''s now time to describe your first predicate class, the predicate that describes
    whether a sensor has a triggered alarm. Create a new class, and call it `HasAlarm`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候描述你的第一个谓词类了，这个谓词用来描述传感器是否触发了警报。创建一个新的类，并将其命名为 `HasAlarm`：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the `Predicate` interface, using `Sensor` as the type definition.
    In the `test` function, return the trigger status of the sensor:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Predicate` 接口，使用 `Sensor` 作为类型定义。在 `test` 函数中，返回传感器的触发状态：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Back in your program''s entry point, the `main` method, create a list of sensors
    and add a few `Gateway` sensors to it:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的程序入口点，即 `main` 方法中，创建一个传感器列表，并添加几个 `Gateway` 传感器到其中：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use a `for` loop in the main method to iterate through the list. In the `for`
    loop, add an `if` statement that uses the predicate to check whether an alarm
    was triggered:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主方法中使用`for`循环遍历列表。在`for`循环中，添加一个使用谓词检查是否触发了警报的`if`语句：
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You may very well ask yourself what the point of this is. This is no different
    from using the sensor's `public triggered()` function. This is also an uncommon
    way of applying predicates, but it illustrates how predicates work. A much more
    common approach involves using streams and lambdas.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会问自己这有什么用。这与使用传感器的`public triggered()`函数没有区别。这也是应用谓词的一种不常见方式，但它说明了谓词的工作原理。一个更常见的方法是使用流和lambda表达式。
- en: 'Now, create another predicate and call it `HasWarning`. In this class, we''ll
    simply check whether the battery status is below a threshold of `10`, which will
    symbolize 10% in our example:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建另一个谓词，并将其命名为`HasWarning`。在这个类中，我们将简单地检查电池状态是否低于`10`的阈值，在我们的例子中这表示10%：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the `HasAlarm` and `HasWarning` predicates to generate a newly composed
    predicate. Instantiate the `HasAlarm` predicate and apply the default `or()` function
    to chain the `HasWarning` predicate as well:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`HasAlarm`和`HasWarning`谓词生成一个新的组合谓词。实例化`HasAlarm`谓词，并应用默认的`or()`函数来链式添加`HasWarning`谓词：
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a new `if` statement in the `for` loop using the newly composed predicate:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环中使用新组成的谓词添加一个新的`if`语句：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As mentioned earlier, applying predicates—or any other functional interface,
    for that matter—directly on objects in loops like this is uncommon. Instead you
    will primarily use the Java streams API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在像这样的循环中对对象直接应用谓词（或任何其他功能性接口）是不常见的。相反，你将主要使用Java流API。
- en: 'Activity 1: Toggling the Sensor States'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动一：切换传感器状态
- en: Rewrite the program once more, adding a scanner to your program to toggle sensor
    states from the command line. Each sensor should be capable of at least toggling
    the battery health and triggered status. When a sensor has updated, you should
    check the system for changes and generate a proper response on the command line
    if a warning or alarm has been triggered.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写程序一次，向你的程序中添加一个扫描器以从命令行切换传感器状态。每个传感器应至少能够切换电池健康状态和触发状态。当传感器更新时，你应该检查系统是否有变化，并在命令行上生成适当的响应，如果已触发警告或警报。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this Activity can be found on page 565.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第565页找到。
- en: Consumer Interface
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费者接口
- en: 'In functional programming, we''re often told to avoid side effects in our code.
    The consumer functional interface, however, is an exception to this rule. Its
    only purpose is to produce a side effect based on the state of the argument. The
    consumer has quite a simple API, the core function of which is called `accept()`
    and doesn''t return anything:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们经常被告知要避免在代码中产生副作用。然而，消费者功能性接口是这一规则的例外。它的唯一目的是根据参数的状态产生副作用。消费者有一个相当简单的API，其核心功能称为`accept()`，不返回任何内容：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This can also be used for chaining multiple consumers by using the `andThen()`
    function, which returns the newly chained consumer:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过使用`andThen()`函数来链式使用多个消费者，该函数返回新链式连接的消费者：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Exercise 2: Producing Side Effects'
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2：产生副作用
- en: 'Continuing the previous exercise, consider the following example wherein we
    will add functionality for reacting to warnings and alarms in the system. You
    can use consumers to produce side effects and to store the current state of the
    system in variables:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个练习，考虑以下示例，我们将添加对系统警告和警报的反应功能。你可以使用消费者来产生副作用并将系统的当前状态存储在变量中：
- en: Copy the `Exercise1.java` class, and call it `Exercise2`. Remove the whole `for`
    loop, but leave the instantiated predicate.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`Exercise1.java`类，并将其命名为`Exercise2`。删除整个`for`循环，但保留实例化的谓词。
- en: 'Create a new static Boolean variable in `Exercise2`, and call it `alarmServiceNotified`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercise2`中创建一个新的静态布尔变量，并将其命名为`alarmServiceNotified`：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This is, of course, not the manner in which you'd commonly apply static variables
    (if you ever really should use static variables). However, in this example, it
    makes it a lot easier to illustrate side effects.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，这并不是你通常应用静态变量的方式（如果你真的应该使用静态变量）。然而，在这个例子中，它使说明副作用变得容易得多。
- en: 'Create a new class, call it `SendAlarm`, and allow it to implement the consumer
    interface. It should look something like this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为`SendAlarm`，并允许它实现消费者接口。它看起来可能像这样：
- en: '[PRE19]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the `accept(Sensor sensor)` function, check whether the sensor has been
    triggered. If it has been triggered, set the static variable to `true`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `accept(Sensor sensor)` 函数内部，检查传感器是否已被触发。如果已被触发，将静态变量设置为 `true`：
- en: '[PRE20]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Back in the `main` method, instantiate a new `SendAlarm` consumer:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `main` 方法中，实例化一个新的 `SendAlarm` 消费者：
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using streams, first, filter the list of sensors based on the previously defined
    composed predicate. Then, use `forEach` to apply the `SendAlarm` consumer to each
    of the sensors that have an alarm or warning triggered:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用流，首先，根据之前定义的复合谓词过滤传感器列表。然后，使用 `forEach` 将 `SendAlarm` 消费者应用于每个触发警报或警告的传感器：
- en: '[PRE22]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, add an `if` statement, checking whether the alarm service was notified,
    and print a message if it was:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个 `if` 语句，检查是否通知了警报服务，如果是的话，打印一条消息：
- en: '[PRE23]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Build one more consumer, and this time call it `ResetAlarm`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建另一个消费者，这次命名为 `ResetAlarm`：
- en: '[PRE24]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add logic to the `ResetAlarm` `accept()` function to set `batteryHealth` to
    `50` and `Triggered` to `false`. Also, set the static notification variable to
    `false`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ResetAlarm` 的 `accept()` 函数中添加逻辑，将 `batteryHealth` 设置为 `50`，将 `Triggered`
    设置为 `false`。同时，将静态通知变量设置为 `false`：
- en: '[PRE25]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instantiate the new `ResetAlarm` consumer, and then apply it after the `SendAlarm`
    consumer using the `andThen()` function:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化新的 `ResetAlarm` 消费者，然后使用 `andThen()` 函数在 `SendAlarm` 消费者之后应用它：
- en: '[PRE26]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, a bonus. At the very end of *Exercise 2*, *Producing Side Effects*
    ''s `main` method, apply the negated version of the `hasAlarmOrWarning` predicate,
    and print out an `Everything okay` message:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一个额外的奖励。在 *练习 2* 的最后，*产生副作用* 的 `main` 方法中，应用 `hasAlarmOrWarning` 谓词的否定版本，并打印出
    `一切正常` 消息：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Function
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: The function, functional interface (yes, it's called a function) was introduced
    mainly to translate one value into another. It is often used in mapping scenarios.
    It also contains default methods to combine multiple functions into one, and chain
    functions after one another.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（是的，它被称为函数）主要被引入来将一个值转换成另一个值。它通常用于映射场景。它还包含默认方法，可以将多个函数组合成一个，并在函数之间进行链式调用。
- en: 'The main function in the interface is called `apply`, and it looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的主函数被称为 `apply`，它看起来像这样：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It defines a return value, `R`, and an input to the function. The idea is that
    the return value and input don't have to be of the same type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个返回值 `R` 和函数的输入。想法是返回值和输入不必是同一类型。
- en: 'The composition is handled by the `compose` function, which also returns an
    instance of the interface, which means that you can chain compositions. The order
    is right to left; in other words, the argument function is applied before the
    calling function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 组合由 `compose` 函数处理，它也返回接口的一个实例，这意味着你可以链式调用组合。顺序是从右到左；换句话说，参数函数在调用函数之前被应用：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, the `andThen` function allows you to chain functions after one another:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`andThen` 函数允许你将函数一个接一个地链式调用：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the following exercise, you will practice using these functions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将练习使用这些函数。
- en: 'Exercise 3: Extracting Data'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3：提取数据
- en: 'Extract all of the alarm system data as integers—battery percentages, temperatures,
    triggered status, and others, depending on how far you''ve taken your alarm system.
    Start by extracting the battery health data:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提取所有警报系统的数据作为整数——电池百分比、温度、触发状态等，具体取决于你将警报系统推进到什么程度。首先，提取电池健康数据：
- en: Copy the `Exercise2` class and call it `Exercise3`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `Exercise2` 类并命名为 `Exercise3`。
- en: 'Remove everything except the list of sensors. Your class should look something
    like this:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除除了传感器列表之外的所有内容。你的类应该看起来像这样：
- en: '[PRE31]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a new class, call it `ExtractBatteryHealth`, and let it implement the
    `Function<T, R>` functional interface. Override the `apply` function. Your class
    should look like this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为 `ExtractBatteryHealth`，并让它实现 `Function<T, R>` 函数式接口。重写 `apply` 函数。你的类应该看起来像这样：
- en: '[PRE32]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `apply` function, make it return the battery health, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `apply` 函数中，让它返回电池健康状态，如下所示：
- en: '[PRE33]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Instantiate your new `ExtractBatteryHealth` function and add a few more sensors
    to the list if you haven''t already done so:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化你的新 `ExtractBatteryHealth` 函数，如果你还没有这样做的话，添加一些传感器到列表中：
- en: '[PRE34]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, use the java streams `map` operation and apply your new instance of
    `ExtractBatteryHealth`. Terminate the stream with a `toArray` operation. You should
    now have an array of all your battery health:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 Java 流的 `map` 操作并应用你的新 `ExtractBatteryHealth` 实例。使用 `toArray` 操作终止流。你现在应该有一个包含所有电池健康状态的数组：
- en: '[PRE35]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Print your battery health to the terminal:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的电池健康信息打印到终端：
- en: '[PRE36]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Activity 2: Using a Recursive Function'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二：使用递归函数
- en: Calculate the average battery health in your alarm system—either through a loop,
    a stream, or a recursive function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 计算你的警报系统中的平均电池健康——可以通过循环、流或递归函数来实现。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 566.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第566页找到。
- en: 'Activity 3: Using a Lambda Function'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动三：使用Lambda函数
- en: Instead of instantiating the `ExtractBatteryHealth` functional interface, use
    a lambda and store a reference to that.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不要实例化`ExtractBatteryHealth`功能接口，而是使用lambda表达式并存储其引用。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 567.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第567页找到。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've explored how to use the functional interfaces provided
    by Java 8\. You've used them both in loops, on single instances, and in streams—all
    of which are valid use cases for functional interfaces. However, you'll quickly
    find that these instances of functional interfaces (lamdas, for short) are more
    commonly used together with streams.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经探索了如何使用Java 8提供的功能接口。你已经在循环、单个实例和流中使用了它们，所有这些都是功能接口的有效用例。然而，你很快会发现这些功能接口的实例（简称为lamdas）通常与流一起使用。
- en: There are many pre-defined functional interfaces in Java, but only a few of
    them are unique in the way they work. Most are just primitive versions of the
    different functions, such as `IntPredicate`, `LongPredicate`, `DoublePredicate`,
    and `Predicate`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Java中有许多预定义的功能接口，但其中只有少数在功能上是独特的。大多数只是不同函数的原生版本，例如`IntPredicate`、`LongPredicate`、`DoublePredicate`和`Predicate`。
- en: In the next chapter, you'll learn more about the Reactive Streams initiative,
    the Flow API, and what Java does to build good foundational interfaces for reactive
    programming.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解更多关于反应式流（Reactive Streams）倡议、Flow API以及Java如何构建良好的基础接口以支持反应式编程的内容。
