- en: Introduction to Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: This book does not blindly praise microservices. Instead, it's about how we
    can use their benefits while being able to handle the challenges of building scalable,
    resilient, and manageable microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并非盲目地赞美微服务。相反，它关于我们如何能够利用它们的好处，同时能够处理构建可扩展、有弹性和可管理的微服务的挑战。
- en: 'As an introduction to this book, the following topics will be covered in this
    chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的引言，本章将涵盖以下内容：
- en: How I learned about microservices and what experience I have of their benefits
    and challenges
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何了解微服务以及我对它们的好处和挑战的经验
- en: What is a microservice-based architecture?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务基础架构是什么？
- en: Challenges with microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的挑战
- en: Design patterns for handling challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理挑战的设计模式
- en: Software enablers that can help us handle these challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以帮助我们处理这些挑战的软件促进者
- en: Other important considerations that aren't covered in this book
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书未涵盖的其他重要考虑因素
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: No installations are required for this chapter. However, you may be interested
    in taking a look at the C4 model conventions, [https://c4model.com](https://c4model.com),
    since the illustrations in this chapter are inspired by the C4 model.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章无需安装。不过，您可能想查看 C4 模型约定，[https://c4model.com](https://c4model.com)，因为本章的插图灵感来自于
    C4 模型。
- en: This chapter does not contain any source code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含任何源代码。
- en: My way into microservices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我进入微服务的方式
- en: When I first learned about the concept of microservices back in 2014, I realized
    that I had been developing microservices (well, kind of) for a number of years
    without knowing it was microservices I was dealing with. I was involved in a project
    that started in 2009 where we developed a platform based on a set of separated
    features. The platform was delivered to a number of customers that deployed it
    on-premise. To make it easy for the customers to pick and choose what features
    they wanted to use from the platform, each feature was developed as an **autonomous
    software component**; that is, it had its own persistent data and only communicated
    with other components using well-defined APIs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次在 2014 年了解微服务概念时，我意识到我在开发微服务（好吧，有点）已经好几年了，却不知道自己处理的微服务。我参与了一个始于 2009 年的项目，我们基于一系列分离的功能开发了一个平台。该平台被部署在多个客户的本地服务器上。为了使客户能够轻松选择他们想要从平台中使用的功能，每个功能都是作为**自主软件组件**开发的；也就是说，它有自己的持久数据，并且只使用定义良好的
    API 与其他组件通信。
- en: 'Since I can''t discuss specific features in this project''s platform, I have
    generalized the names of the components, which are labeled from **Component A** to
    **Component F**. The composition of the platform into a set of components is illustrated
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我无法讨论这个平台项目的特定功能，我将组件的名称进行了泛化，从**组件 A** 到 **组件 F** 进行标记。平台组成一组组件的如下所示：
- en: '![](img/a28adfee-5ac7-4006-8bc9-ca0bd3ce0688.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a28adfee-5ac7-4006-8bc9-ca0bd3ce0688.png)'
- en: 'Each component is developed using Java and the Spring Framework, and is packaged
    as a WAR file and deployed as a web app in a Java EE web container, for example,
    Apache Tomcat. Depending on the customer''s specific requirements, the platform
    can be deployed on single or multiple servers. A two-node deployment may look
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都是使用 Java 和 Spring Framework 开发的，打包成 WAR 文件，并在 Java EE 网络容器中（例如，Apache Tomcat）部署为
    Web 应用程序。根据客户的具体要求，平台可以在单台或多台服务器上部署。双节点部署可能如下所示：
- en: '![](img/e608abe5-c594-4079-8523-6f56e88ae3b3.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e608abe5-c594-4079-8523-6f56e88ae3b3.png)'
- en: Benefits of autonomous software components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主软件组件的好处
- en: 'Decomposing the platform''s functionality into a set of autonomous software
    components provides a number of benefits:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将平台的 functionality 分解为一系列自主软件组件提供了许多好处：
- en: A customer can deploy parts of the platform in its own system landscape, integrating
    it with its existing systems using its well-defined APIs.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户可以在自己的系统景观中部署平台的某些部分，使用其定义良好的 API 将其与现有系统集成。
- en: 'The following is an example where one customer decided to deploy **Component
    A**, **Component ****B**, **Component ****D**, and **Component ****E** from the
    platform and integrate them with two existing systems in the customer''s system
    landscape, **System A** and **System B**:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中一个客户决定部署平台中的**组件 A**，**组件 B**，**组件 D** 和 **组件 E**，并将它们与客户系统景观中的两个现有系统**系统
    A** 和 **系统 B** 集成：
- en: '![](img/d9c37999-c0e3-4121-9cf8-0fbc0053acc1.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9c37999-c0e3-4121-9cf8-0fbc0053acc1.png)'
- en: 'Another customer can choose to replace parts of the platform''s functionality
    with implementations that already exist in the customer''s system landscape, potentially
    requiring some adoption of the existing functionality in the platform''s APIs.
    The following is an example where a customer has replaced **Component C** and
    **Component F** in the platform with their own implementation:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一客户可以选择用其在客户系统景观中已存在的实现替换平台的部分功能，这可能会需要对平台API中现有的功能进行一些采用。以下是一个客户用其自己的实现替换了平台中的**组件C**和**组件F**的示例：
- en: '![](img/ec70e06b-72fc-4582-8598-23b2be9da9b2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec70e06b-72fc-4582-8598-23b2be9da9b2.png)'
- en: Each component in the platform can be delivered and upgraded separately. Thanks
    to using well-defined APIs, one component can be upgraded to a new version without
    being dependent on the life cycle of the other components.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台中的每个组件都可以单独交付和升级。由于使用了定义良好的API，一个组件可以升级到新版本，而无需依赖于其他组件的生命周期。
- en: 'The following is an example where **Component A** has been upgraded from version
    **v1.1** to **v1.2**. **Component B**, which calls **Component A**, does not need
    to be upgraded since it uses a well-defined API; that is, it''s still the same
    after the upgrade (or it''s at least backward-compatible):'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中**组件A**从版本**v1.1**升级到了**v1.2**。由于它使用了定义良好的API调用**组件A**的**组件B**，在升级后不需要更改（或者至少是向后兼容的）：
- en: '![](img/a8e582ba-86f5-4a7a-9549-b74de17dc705.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8e582ba-86f5-4a7a-9549-b74de17dc705.png)'
- en: 'Thanks to the use of well-defined APIs, each component in the platform can
    also be scaled out to multiple servers independently of the other components.
    Scaling can be done either to meet high availability requirements or to handle
    higher volumes of requests. Technically, this is achieved by *manually* setting
    up load balancers in front of a number of servers, each running a Java EE web
    container. An example where **Component A** has been scaled out to three instances
    looks as follows:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于使用了定义良好的API，平台中的每个组件也可以独立于其他组件扩展到多台服务器。扩展可以是为了满足高可用性要求或处理更高数量的请求。技术上，这是通过*手动*在运行Java
    EE Web容器的几台服务器前设置负载均衡器来实现的。一个**组件A**扩展到三个实例的示例如下：
- en: '![](img/693e8127-e343-4ea8-94fa-14488f1a1673.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/693e8127-e343-4ea8-94fa-14488f1a1673.png)'
- en: Challenges with autonomous software components
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主软件组件的挑战
- en: 'We also learned that decomposing the platform introduced a number of new challenges
    that we were not exposed (at least not to the same degree) when developing more
    traditional, monolithic applications:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现，将平台分解成多个部分引入了许多新的挑战，我们在开发更传统、单片应用程序时并没有暴露（至少没有暴露到同样的程度）到这些挑战：
- en: Adding new instances to a component required manually configuring load balancers
    and manually setting up new nodes. This work was both time-consuming and error-prone.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向组件添加新实例需要手动配置负载均衡器并手动设置新节点。这项工作既耗时又易出错。
- en: The platform was initially prone to errors in the other systems it was communicating
    with. If a system stopped responding to requests that were sent from the platform
    in a timely fashion, the platform quickly ran out of crucial resources, for example,
    OS threads, specifically when exposed to a large number of concurrent requests.
    This caused components in the platform to hang or even crash. Since most of the
    communication in the platform is based on synchronous communication, one component
    crashing can lead to cascading failures; that is, clients of the crashing components
    could also crash after a while. This is known as a **chain of failures**.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台最初容易在与它通信的其他系统出现错误。如果一个系统没有及时响应从平台发送的请求，平台很快就会耗尽关键资源，例如，操作系统线程，特别是当暴露于大量并发请求时。这会导致平台中的组件挂起甚至崩溃。由于平台中的大多数通信基于同步通信，一个组件的崩溃可能会导致级联故障；也就是说，崩溃组件的客户端也可能在一段时间后崩溃。这被称为**故障链**。
- en: Keeping the configuration consistent and up to date in all the instances of
    the components quickly became a problem, causing a lot of manual and repetitive
    work. This led to quality problems from time to time.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持组件所有实例中的配置一致并更新迅速成为一个问题，导致大量手动和重复工作。这导致时不时会出现质量问题。
- en: Monitoring the state of the platform in terms of latency issues and hardware
    usage (for example, usage of CPU, memory, disks, and the network) was more complicated
    compared to monitoring a single instance of a monolithic application.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与监控单体应用程序单个实例的状态（例如，CPU、内存、磁盘和网络的使用情况）相比，监控平台在延迟问题和硬件使用方面的状态更为复杂。
- en: Collecting log files from a number of distributed components and correlating
    related log events from the components was also difficult but feasible since the
    number of components was fixed and known in advance.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个分布式组件中收集日志文件并关联组件相关的日志事件是困难的，但可行的，因为组件的数量是固定的，且事先已知。
- en: Over time, we addressed most of the challenges that were mentioned in the preceding
    list with a mix of in-house-developed tools and well-documented instructions for
    handling these challenges manually. The scale of the operation was, in general,
    at a level where manual procedures for releasing new versions of the components
    and handling runtime issues were acceptable, even though they were not desirable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们通过开发内部工具和处理这些挑战的良好文档说明，解决了前述列表中提到的绝大多数挑战。操作规模通常在一个级别，在该级别上，手动程序对于发布新版本的组件和处理运行时问题是可接受的，尽管这不是理想的。
- en: Enter microservices
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入微服务
- en: Learning about microservice-based architectures in 2014 made me realize that
    other projects had also been struggling with similar challenges (partly for other
    reasons than the ones I described earlier, for example, the large cloud service
    providers meeting web-scale requirements). Many microservice pioneers had published
    details of lessons they'd learned. It was very interesting to learn from these
    lessons.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年了解微服务架构让我意识到其他项目也面临过类似的挑战（部分原因是除了我之前描述的原因之外，例如，大型云服务提供商满足网络规模要求）。许多微服务先驱发表了他们学到的课程细节。从这些教训中学习非常有意思。
- en: Many of the pioneers initially developed monolithic applications that made them
    very successful from a business perspective. But over time, these monolithic applications
    became more and more difficult to maintain and evolve. They also became challenging
    to scale beyond the capabilities of the largest machines available (also known
    as **vertical scaling**). Eventually, the pioneers started to find ways to split
    monolithic applications into smaller components that could be released and scaled
    independently of each other. Scaling small components can be done horizontally,
    that is, deploying a component on a number of smaller servers and placing a load
    balancer in front of it. If done in the cloud, the scaling capability is potentially
    endless – it is just a matter of how many virtual servers you bring in (given
    that your component can scale out on a huge number of instances, but more on that
    later on).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多先驱者最初开发了单体应用，这在商业上使他们非常成功。但随着时间的推移，这些单体应用变得越来越难以维护和进化。它们也挑战性地超出了最大机器的容量（也称为垂直扩展）。最终，先驱们开始寻找将单体应用拆分为更小组件的方法，这些组件可以独立于彼此进行发布和扩展。可以通过水平扩展来扩展小组件，即在多个小型服务器上部署一个组件并在其前面放置一个负载均衡器。如果在云环境中进行，扩展能力是潜在无限的——这只是一个你引入多少虚拟服务器的问题（假设你的组件可以在大量实例上扩展，但稍后再详细介绍）。
- en: 'In 2014, I also learned about a number of new open source projects that delivered
    tools and frameworks that simplified the development of microservices and could
    be used to handle the challenges that come with a microservice-based architecture.
    Some of these are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，我还了解了许多新的开源项目，这些项目提供了工具和框架，简化了微服务的开发，并可用于处理基于微服务架构的挑战。其中一些如下：
- en: Pivotal released **Spring Cloud**, which wraps parts of the **Netflix OSS** in
    order to provide capabilities such as dynamic service discovery, configuration
    management, distributed tracing, circuit breaking, and more.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal 发布了**Spring Cloud**，该框架封装了**Netflix OSS**的部分内容，以提供动态服务发现、配置管理、分布式跟踪、断路器等功能。
- en: I also learned about **Docker** and the container revolution, which is great
    for minimizing the gap between development and production. Being able to package
    a component not only as a deployable runtime artifact (for example, a Java, `war`
    or, `jar` file) but as a complete image ready to be launched as a container (for
    example, an isolated process) on a server running Docker was a great step forward
    for development and testing.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还了解到了**Docker** 和容器革命，这对于缩小开发和生产之间的差距非常有益。能够将一个组件包装为一个可部署的运行时工件（例如，一个 Java、`war`
    或者 `jar` 文件），也可以作为一个完整的镜像在运行 Docker 的服务器上启动（例如，一个隔离的进程），这对开发和测试来说是一个巨大的进步。
- en: A container engine, such as Docker, is not enough to be able to use containers
    in a production environment. Something is needed that, for example, can ensure
    that all the containers are up and running and that they can scale out containers
    on a number of servers, thereby providing high availability and/or increased compute
    resources. These types of product became known as **container orchestrators***.* A
    number of products have evolved over the last few years, such as Apache Mesos,
    Docker in Swarm mode, Amazon ECS, HashiCorp Nomad, and **Kubernetes**. Kubernetes
    was initially developed by Google. When Google released v1.0, they also donated
    Kubernetes to CNCF ([https](https://www.cncf.io/)[://www.cncf.io/](https://www.cncf.io/)).
    During 2018, Kubernetes became kind of a de facto standard, available both pre-packaged
    for on-premise use and available as a service from most major cloud providers.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个容器引擎，比如 Docker，不足以在生产环境中使用容器。需要的东西例如能确保所有容器都运行正常，以及能在多台服务器上扩展容器，从而提供高可用性和/或增加计算资源。这类产品被称为**容器编排器**。过去几年中，出现了一系列产品，例如
    Apache Mesos、Docker 的 Swarm 模式、亚马逊 ECS、HashiCorp Nomad 和 **Kubernetes**。Kubernetes最初由谷歌开发。当谷歌发布
    v1.0 版本时，他们还把 Kubernetes 捐赠给了 CNCF（[https://www.cncf.io/](https://www.cncf.io/)）。在
    2018 年，Kubernetes 成为了一种事实上的标准，既可以预先打包用于本地部署，也可以从大多数主要云服务提供商那里作为服务提供。
- en: I have recently started to learn about the concept of a **service mesh** and
    how a service mesh can complement a container orchestrator to further offload
    microservices from responsibilities to make them manageable and resilient.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我最近开始学习关于**服务网格** 的概念以及服务网格如何补充容器编排器，进一步卸载微服务的职责，使它们变得可管理和有弹性。
- en: A sample microservice landscape
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务示例架构
- en: Since this book can't cover all aspects of the technologies I just mentioned,
    I will focus on the parts that have proven to be useful in customer projects I
    have been involved in since 2014\. I will describe how they can be used together
    to create cooperating microservices that are manageable, scalable, and resilient.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书不能涵盖我刚才提到的所有技术方面，我将重点介绍自 2014 年以来我参与的客户项目中证明有用的部分。我将描述它们如何一起使用，以创建可管理、可扩展和有弹性的协作微服务。
- en: 'Each chapter in this book will address a specific concern. To demonstrate how
    things fit together, I will use a small set of cooperating microservices that
    we will evolve throughout this book:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的每一章都将关注一个特定的问题。为了演示事物是如何整合在一起的，我将使用一组协作的微服务，我们将在本书中逐步完善它们：
- en: '![](img/bd28199a-e796-4dd9-aaf1-ae322a726f93.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd28199a-e796-4dd9-aaf1-ae322a726f93.png)'
- en: Now that we know the how and what of microservices, let's start to look into
    how a microservice can be defined.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了微服务的如何和什么，让我们开始探讨如何定义一个微服务。
- en: Defining a microservice
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义微服务
- en: 'To me, a microservice architecture is about splitting up monolithic applications
    into smaller components, which achieves two major goals:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，微服务架构是关于将单体应用程序拆分成更小的组件，这实现了两个主要目标：
- en: Faster development, enabling continuous deployments
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加快开发，实现持续部署
- en: Easier to scale, manually or automatically
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易扩展，手动或自动
- en: 'A microservice is essentially an autonomous software component that is independently
    upgradeable and scalable. To be able to act as an autonomous component, it must
    fulfill certain criteria as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务本质上是一个可以独立升级和扩展的自主软件组件。为了能够作为一个自主组件行动，它必须满足以下某些标准：
- en: It must conform to a shared-nothing architecture; that is, microservices don't
    share data in databases with each other!
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须遵循一种无共享架构；也就是说，微服务之间不会在数据库中共享数据！
- en: It must only communicate through well-defined interfaces, for example, using
    synchronous services or preferably by sending messages to each other using APIs
    and message formats that are stable, well-documented, and evolve by following
    a defined versioning strategy.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须仅通过定义良好的接口进行通信，例如，使用同步服务，或者更 preferably，通过使用API和稳定的、文档齐全的消息格式彼此发送消息，并且这些消息格式遵循一个定义好的版本策略来发展。
- en: It must be deployed as separate runtime processes. Each instance of a microservice
    runs in a separate runtime process, for example, a Docker container.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须作为独立的运行时进程部署。每个微服务的实例运行在一个单独的运行时进程中，例如，一个Docker容器。
- en: Microservice instances are stateless so that incoming requests to a microservice
    can be handled by any of its instances.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务实例是无状态的，这样对微服务的传入请求可以由其任何一个实例处理。
- en: Using a set of microservices, we can deploy to a number of smaller servers instead
    of being forced to deploy to a single big server, like we have to do when deploying
    a monolithic application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一组微服务，我们可以将部署到多个较小的服务器上，而不是被迫将部署到一个大的单体服务器上，正如我们在部署单体应用时必须做的那样。
- en: Given that the preceding criteria have been fulfilled, it is easier to scale
    up a single microservice into more instances (for example, using more virtual
    servers) compared to scaling up a big monolithic application. Utilizing auto-scaling
    capabilities that are available in the cloud is also a possibility, but not typically
    feasible for a big monolithic application. It's also easier to upgrade or even
    replace a single microservice compared to upgrading a big monolithic application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面提到的条件已经满足，相较于将一个大的单体应用进行扩展，将一个微服务扩展到更多的实例（例如，使用更多的虚拟服务器）会更加容易。利用云服务中可用的自动扩展功能也是一种可能性，但对于一个大的单体应用来说，通常并不可行。与升级一个大的单体应用相比，升级或替换一个微服务也更为容易。
- en: 'This is illustrated by the following diagram, where a monolithic application
    has been divided into six microservices, all of which have been deployed into
    one separate server. Some of the microservices have also been scaled up independently
    of the others:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点可以通过以下图表来说明，其中一个大单体应用被划分为六个微服务，它们都被部署到一个单独的服务器上。其中一些微服务还独立于其他服务进行了扩展：
- en: '![](img/ee5160d1-409d-419e-9a56-489a4e8aa3a9.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee5160d1-409d-419e-9a56-489a4e8aa3a9.png)'
- en: A very frequent question I receive from customers is, *How big should a microservice
    be?*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常从客户那里收到的一个问题是，“**微服务应该有多大？**”
- en: 'I try to use the following rules-of-thumb:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图使用以下经验法则：
- en: Small enough to fit in the head of a developer
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够小，以至于能够装进开发者的头脑中
- en: Big enough to not jeopardize performance (that is, latency) and/or data consistency
    (SQL foreign keys between data that's stored in different microservices are no
    longer something you can take for granted)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够小，不会影响性能（即，延迟）和/或数据一致性（存储在不同微服务中的数据之间的SQL外键不再是你可以轻易假设的东西）。
- en: So, to summarize, a microservice architecture is, in essence, an architectural
    style where we decompose a monolithic application into a group of cooperating
    autonomous software components. The motivation is to enable faster development
    and to make it easier to scale the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总结一下，微服务架构本质上是这样一种架构风格：我们将一个单体应用分解为一组协作的自主软件组件。动机是为了实现更快的开发，并使应用的扩展变得更容易。
- en: Next, we will move on to understand some of the challenges that we will face
    when it comes to microservices.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向了解在微服务方面我们将面临的一些挑战。
- en: Service discovery
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: The **service** **discovery** pattern has the following problem, solution, and
    solution requirements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务发现**模式有以下问题、解决方案和解决方案要求。'
- en: Challenges with microservices
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的挑战
- en: 'In the *Challenges with autonomous software components* section, we have already
    seen some of the challenges that autonomous software components can bring (and
    they all apply to microservices as well) as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在“**自主软件组件的挑战**”一节中，我们已经看到了一些自主软件组件可能会带来的挑战（它们都适用于微服务），如下所示：
- en: Many small components that use synchronous communication can cause *a* *chain
    of failure* problem, especially under high load.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多使用同步通信的小组件可能会导致*连锁故障*问题，尤其是在高负载下。
- en: Keeping the configuration up to date for many small components can be challenging.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于许多小组件保持配置的最新状态可能会很有挑战性。
- en: It's hard to track a request that's being processed and involves many components,
    for example, when performing root cause analysis, where each component stores
    log events locally.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪正在处理并涉及许多组件的请求可能很困难，例如，在执行根本原因分析时，每个组件都本地存储日志事件。
- en: Analyzing the usage of hardware resources on a component level can be challenging
    as well.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析组件级别硬件资源的使用也可能具有挑战性。
- en: Manual configuration and management of many small components can become costly
    and error-prone.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动配置和管理许多小型组件可能会变得昂贵且容易出错。
- en: 'Another downside (but not always obvious initially) of decomposing an application
    into a group of autonomous components is that they form a distributed system.
    Distributed systems are known to be, by their nature, very hard to deal with. This
    has been known for many years (but in many cases neglected until proven differently).
    My favorite quote to establish this fact is from Peter Deutsch who, back in 1994, stated
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解为一组自主组件的另一个缺点（但通常一开始并不明显）是，它们形成了一个分布式系统。分布式系统以其本质而言，很难处理。这一点已经知道很多年了（但在许多情况下直到证明否则才被忽视）。我用来证明这个事实的最喜欢引语来自彼得·德意志，他在1994年提出了以下观点：
- en: '***T*he 8 fallacies of distributed computing***: Essentially everyone, when
    they first build a distributed application, makes the following eight assumptions.
    All prove to be false in the long run and all cause big trouble and painful learning
    experiences:*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '***分布式计算的8大谬误***：基本上每个人在第一次构建分布式应用程序时都会做出以下八个假设。所有这些最终都被证明是错误的，并且都会造成巨大的麻烦和痛苦的学习经验：*'
- en: '*The network is reliable*'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*网络是可靠的*'
- en: '*Latency is zero*'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*延迟为零*'
- en: '*Bandwidth is infinite*'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*带宽是无限的*'
- en: '*The network is secure*'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*网络是安全的*'
- en: '*Topology doesn''t change*'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*拓扑不会改变*'
- en: '*There is one administrator*'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*有一个管理员*'
- en: '*Transport cost is zero*'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*传输成本为零*'
- en: '*The network is homogeneous*'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*网络是同质的*'
- en: '*-- Peter Deutsch, 1994*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*-- 彼得·德意志，1994*'
- en: '**Note:** The eighth fallacy was actually added by James Gosling at a later
    date. For more details, please go to [https://www.rgoarchitects.com/Files/fallacies.pdf](https://www.rgoarchitects.com/Files/fallacies.pdf).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注：**第八个谬误实际上是由詹姆斯·高斯林在后来添加的。更多信息，请访问[https://www.rgoarchitects.com/Files/fallacies.pdf](https://www.rgoarchitects.com/Files/fallacies.pdf)。'
- en: In general, building microservices-based on these false assumptions leads to
    solutions that are prone to both temporary network glitches and problems that
    occur in other microservice instances. When the number of microservices in a system
    landscape increases, the likelihood of problems also goes up. A good rule of thumb
    is to design your microservice architecture based on the assumption that there
    is always something going wrong in the system landscape. The microservice architecture
    needs to be designed to handle this, in terms of detecting problems and restarting
    failed components but also on the client-side so that requests are not sent to
    failed microservice instances. When problems are corrected, requests to the previously
    failing microservice should be resumed; that is, microservice clients need to
    be resilient. All of these need, of course, to be fully automated. With a large
    number of microservices, it is not feasible for operators to handle this manually!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，基于这些错误假设构建微服务会导致解决方案容易出现临时网络故障和其他微服务实例中的问题。当系统景观中的微服务数量增加时，问题的可能性也会上升。一个好的经验法则是，设计你的微服务架构时，假设系统景观中总是有一些东西在出错。微服务架构需要处理这一点，包括检测问题和重新启动失败组件，以及在客户端方面，以便请求不会发送到失败的微服务实例。当问题得到解决时，应恢复对之前失败的微服务的请求；也就是说，微服务客户端需要具有弹性。所有这些当然都需要完全自动化。对于大量的微服务，操作员手动处理这是不可能的！
- en: The scope of this is large, but we will limit ourselves for now and move on
    to study design patterns for microservices.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个范围很大，但我们将暂时限制自己，并继续研究微服务的设计模式。
- en: Design patterns for microservices
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的设计模式
- en: This topic will cover using design patterns to mitigate challenges with microservices,
    as described in the preceding section. Later in this book, we will see how we
    can implement these design patterns using Spring Boot, Spring Cloud, and Kubernetes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍使用设计模式减轻微服务挑战的方法。在这本书的后面，我们将看到我们如何使用Spring Boot、Spring Cloud和Kubernetes实现这些设计模式。
- en: The concept of design patterns is actually quite old; it was invented by Christopher
    Alexander back in 1977\. In essence, a design pattern is about describing a reusable
    solution to a problem when given a specific context.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的概念实际上相当古老；它是在1977年由克里斯托弗·亚历山大发明的。本质上，设计模式是关于在给定特定上下文时描述一个问题的可重用解决方案。
- en: 'The design patterns we will cover are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的设计模式如下：
- en: Service discovery
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Edge server
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: Reactive microservices
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式微服务
- en: Central configuration
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式配置
- en: Centralized log analysis
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式日志分析
- en: Distributed tracing
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式追踪
- en: Circuit Breaker
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熔断器
- en: Control loop
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制循环
- en: Centralized monitoring and alarms
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式监控和警报
- en: This list is not intended to be comprehensive; instead, it's a minimal list
    of design patterns that are required to handle the challenges we described previously.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表并非旨在全面，而是我们之前描述的挑战所需的最小设计模式列表。
- en: 'We will use a lightweight approach to describing design patterns, and focus
    on the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用一种轻量级的方法来描述设计模式，并关注以下内容：
- en: The problem
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题
- en: A solution
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案
- en: Requirements for the solution
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: Later in this book, we will delve more deeply into how to apply these design
    patterns. The context for these design patterns is a system landscape of cooperating
    microservices where the microservices communicate with each other using either
    synchronous requests (for example, using HTTP) or by sending asynchronous messages
    (for example, using a message broker).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将更深入地探讨如何应用这些设计模式。这些设计模式的上下文是一个由合作的微服务组成的系统架构，微服务通过同步请求（例如，使用HTTP）或发送异步消息（例如，使用消息代理）相互通信。
- en: Problem
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can clients find microservices and their instances?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端如何找到微服务和它们的实例？
- en: 'Microservices instances are typically assigned dynamically allocated IP addresses
    when they start up, for example, when running in containers. This makes it difficult
    for a client to make a request to a microservice that, for example, exposes a
    REST API over HTTP. Consider the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务实例在启动时通常会被分配动态分配的IP地址，例如，当它们在容器中运行时。这使得客户端难以向微服务发起请求，例如，向暴露HTTP上的REST API的微服务发起请求。请参考以下图表：
- en: '![](img/ae0b2dda-3e2d-4028-b48b-cff12017468e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae0b2dda-3e2d-4028-b48b-cff12017468e.png)'
- en: Solution
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a new component – a **service discovery** service – to the system landscape,
    which keeps track of currently available microservices and the IP addresses of
    its instances.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统架构中添加一个新组件——**服务发现**服务——跟踪当前可用的微服务和其实例的IP地址。
- en: Solution requirements
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Automatically register/unregister microservices and their instances as they
    come and go.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动注册/注销微服务和它们的实例，因为它们来来去去。
- en: The client must be able to make a request to a logical endpoint for the microservice.
    The request will be routed to one of the microservices available instances.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须能够向微服务的逻辑端点发起请求。请求将被路由到可用的微服务实例之一。
- en: Requests to a microservice must be load-balanced over the available instances.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对微服务的请求必须在可用实例上进行负载均衡。
- en: We must be able to detect instances that are not currently healthy; that is,
    requests will not be routed to them.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须能够检测到当前不健康的实例；也就是说，请求不会被路由到这些实例。
- en: '**Implementation notes:** As we will see, this design pattern can be implemented
    using two different strategies:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现说明：** 正如我们将看到的，这个设计模式可以使用两种不同的策略来实现：'
- en: '**Client-side routing**: The client uses a library that communicates with the
    service discovery service to find out the proper instances to send the requests
    to.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端路由**：客户端使用与服务发现服务通信的库，以找出要发送请求的正确实例。'
- en: '**Server-side routing**: The infrastructure of the service discovery service also
    exposes a reverse proxy that all requests are sent to. The reverse proxy forwards
    the requests to a proper microservice instance on behalf of the client.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端路由**：服务发现服务的架构还暴露了一个反向代理，所有请求都发送到该代理。反向代理代表客户端将请求转发到适当的微服务实例。'
- en: Edge server
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: The edge server pattern has the following problem, solution, and solution requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务器模式有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In a system landscape of microservices, it is in many cases desirable to expose
    some of the microservices to the outside of the system landscape and hide the
    remaining microservices from external access. The exposed microservices must be
    protected against requests from malicious clients.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务系统架构中，许多情况下，希望将一些微服务暴露给系统架构的外部，并将其余的微服务隐藏在外部访问之外。必须保护暴露的微服务免受恶意客户端的请求。
- en: Solution
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component, an **Edge Server**, to the system landscape that all incoming
    requests will go through:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统架构中添加一个新组件，即**边缘服务器**，所有传入请求都将通过它：
- en: '![](img/ae4561e4-4945-4613-9385-0f1bf1719981.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae4561e4-4945-4613-9385-0f1bf1719981.png)'
- en: 'Implementation notes: An edge server typically behaves like a reverse proxy
    and can be integrated with a discovery service to provide dynamic load balancing
    capabilities.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现说明：边缘服务器通常表现得像反向代理，可以与发现服务集成，提供动态负载均衡功能。
- en: Solution requirements
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Hide internal services that should not be exposed outside their context; that
    is, only route requests to microservices that are configured to allow external
    requests.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏不应暴露在外部上下文中的内部服务；也就是说，只将请求路由到配置为允许外部请求的微服务。
- en: Expose external services and protect them from malicious requests; that is,
    use standard protocols and best practices such as OAuth, OIDC, JWT tokens, and
    API keys to ensure that the clients are trustworthy.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露外部服务并保护它们免受恶意请求；也就是说，使用标准协议和最佳实践，如OAuth、OIDC、JWT令牌和API密钥，确保客户端是可信的。
- en: Reactive microservice
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式微服务
- en: The reactive microservice pattern has the following problem, solution, and solution
    requirements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式微服务模式有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Traditionally, as Java developers, we are used to implementing synchronous communication using
    blocking I/O, for example, a RESTful JSON API over HTTP. Using a blocking I/O
    means that a thread is allocated from the operating system for the length of the
    request. If the number of concurrent requests goes up (and/or the number of involved
    components in a request, for example, a chain of cooperating microservices, goes
    up), a server might run out of available threads in the operating system, causing
    problems ranging from longer response times to crashing servers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，作为Java开发者，我们习惯于使用阻塞I/O实现同步通信，例如，通过HTTP实现的RESTful JSON API。使用阻塞I/O意味着操作系统会为请求的长度分配一个线程。如果并发请求的数量增加（以及/或者请求中涉及的组件数量增加，例如，一系列协作的微服务），服务器可能会在操作系统中耗尽可用的线程，导致问题从更长的响应时间到服务器崩溃。
- en: Also, as we already mentioned in this chapter, overusing blocking I/O can make
    a system of microservices prone to errors. For example, an increased delay in
    one service can cause clients to run out of available threads, causing them to
    fail. This, in turn, can cause their clients to have the same types of problem,
    which is also known as a chain of failures. See the *Circuit Breaker* section for
    how to handle a chain-of-failure-related problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在本章中已经提到的，过度使用阻塞I/O会使微服务系统容易出现错误。例如，一个服务的延迟增加可能会导致客户端耗尽可用的线程，从而导致它们失败。这反过来又可能导致它们的客户端出现相同类型的问题，这也被称为故障链。请参阅*断路器*部分，了解如何处理与故障链相关的问题。
- en: Solution
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use non-blocking I/O to ensure that no threads are allocated while waiting for
    processing to occur in another service, that is, a database or another microservice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非阻塞I/O，确保在等待另一个服务（例如，数据库或另一个微服务）处理时不会分配线程。
- en: Solution requirements
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Whenever feasible, use an asynchronous programming model; that is, send messages
    without waiting for the receiver to process them.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要可行，使用异步编程模型；也就是说，发送消息而不等待接收者处理它们。
- en: If a synchronous programming model is preferred, ensure that reactive frameworks
    are used that can execute synchronous requests using non-blocking I/O, that is,
    without allocating a thread while waiting for a response. This will make the microservices
    easier to scale in order to handle an increased workload.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果偏好同步编程模型，确保使用反应式框架，这些框架可以使用非阻塞I/O执行同步请求，即在等待响应时不会分配线程。这将使微服务更容易扩展以处理增加的工作负载。
- en: Microservices must also be designed to be resilient, that is, capable of producing
    a response, even if a service that it depends on fails. Once the failing service
    is operational again, its clients must be able to resume using it, which is known
    as self-healing.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务还必须设计成有恢复力，也就是说，能够产生响应，即使它依赖的服务失败了。一旦失败的服务恢复正常运营，它的客户端必须能够继续使用它，这被称为自愈。
- en: In 2013, key principles for designing systems in these ways were established
    in *The Reactive Manifesto* ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)).
    According to the manifesto, the foundation for reactive systems is that they are
    message-driven; that is, they use asynchronous communication. This allows them
    to be elastic, that is, scalable, and resilient, that is, tolerant to failures.
    Elasticity and resilience together allow a reactive system to be responsive so
    that it can respond in a timely fashion.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在2013年，设计这些方式的关键原则在*《反应式宣言》*中得到了确立（[https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)）。根据宣言，反应式系统的基石是它们是消息驱动的；也就是说，它们使用异步通信。这使得它们能够是弹性的，也就是说，可伸缩的，并且有恢复力，也就是说，能够容忍失败。弹性和恢复力共同使得一个反应式系统能够是有响应性的，这样它能够及时做出反应。
- en: Central configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中配置
- en: The central configuration pattern has the following problem, solution, and solution
    requirements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 集中配置模式有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'An application is, traditionally, deployed together with its configuration,
    for example, a set of environment variables and/or files containing configuration
    information. Given a system landscape based on a microservice architecture, that
    is, with a large number of deployed microservice instances, some queries arise:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序，传统上，是与它的配置一起部署的，例如，一组环境变量和/或包含配置信息的文件。考虑到一个基于微服务架构的系统景观，也就是有大量部署的微服务实例，会有一些查询产生：
- en: How do I get a complete picture of the configuration that is in place for all
    the running microservice instances?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何获得所有运行中的微服务实例中现行的配置的完整视图？
- en: How do I update the configuration and make sure that all the affected microservice
    instances are updated correctly?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何更新配置并确保所有受影响的微服务实例都被正确更新？
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a new component, a **c****onfiguration** server, to the system landscape to
    store the configuration of all the microservices.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统景观中添加一个新的组件，一个**配置**服务器，以存储所有微服务的配置。
- en: Solution requirements
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: Make it possible to store configuration information for a group of microservices
    in one place, with different settings for different environments (for example,
    `dev`, `test`, `qa`, and `prod`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使存储一组微服务的配置信息成为可能，在同一个地方有不同的设置针对不同的环境（例如，`dev`、`test`、`qa`和`prod`）。
- en: Centralized log analysis
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中日志分析
- en: Centralized log analysis has the following problem, solution, and solution requirements.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 集中日志分析有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Traditionally, an application writes log events to log files that are stored
    on the local machine that the application runs on. Given a system landscape based
    on a microservice architecture, that is, with a large number of deployed microservice
    instances on a large number of smaller servers, we can ask the following questions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，一个应用程序会将日志事件写入存储在运行应用程序的本机机器上的日志文件中。考虑到一个基于微服务架构的系统景观，也就是有大量部署在众多小型服务器上的微服务实例，我们可以提出以下问题：
- en: How do I get an overview of what is going on in the system landscape when each microservice
    instance writes to its own local log file?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何获得系统景观的概览，当每个微服务实例向自己的本地日志文件中写入时，系统景观中发生了什么？
- en: How do I find out if any of the microservice instances get into trouble and
    start writing error messages to their log files?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何找出是否有任何微服务实例遇到麻烦并开始向它们的日志文件中写入错误消息？
- en: 'If end users start to report problems, how can I find related log messages;
    that is, how can I identify which microservice instance is the root cause of the
    problem? The following diagram illustrates the problem:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最终用户开始报告问题，我如何找到相关的日志消息；也就是说，我如何确定哪个微服务实例是问题的根源？以下图表说明了这个问题：
- en: '![](img/12e455e5-f256-43f4-b593-7145f36401c7.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12e455e5-f256-43f4-b593-7145f36401c7.png)'
- en: Solution
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component that can manage **centralized logging** and is capable
    of the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的组件，它可以管理**集中日志**，并能够执行以下操作：
- en: Detecting new microservice instances and collecting log events from them
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测新的微服务实例并从它们那里收集日志事件
- en: Interpreting and storing log events in a structured and searchable way in a
    central database
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中心数据库中以结构化和可搜索的方式解释和存储日志事件
- en: Providing APIs and graphical tools for querying and analyzing log events
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供API和图形工具以查询和分析日志事件
- en: Distributed tracing
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式追踪
- en: Distributed tracing has the following problem, solution, and solution requirements.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: It must be possible to track requests and messages that flow between microservices
    while processing an external call to the system landscape.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 必须能够在处理系统景观的外部调用时跟踪微服务之间的请求和消息。
- en: 'Some examples of fault scenarios are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些故障场景的例子：
- en: If end users start to file support cases regarding a specific failure, how can
    we identify the microservice that caused the problem, that is, the root cause?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最终用户开始就特定的故障提起支持案例，我们如何确定导致问题的微服务，即根本原因？
- en: If one support case mentions problems related to a specific entity, for example,
    a specific order number, how can we find log messages related to processing this
    specific order – for example, log messages from all microservices that were involved
    in processing this specific order?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个支持案例提到了与特定实体相关的问题，例如，特定的订单号，我们如何找到与处理这个特定订单相关的日志消息——例如，参与处理这个特定订单的所有微服务的日志消息？
- en: 'The following diagram depicts this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这一点：
- en: '![](img/a7e6182c-b5f4-4344-8e98-3e9f62aef421.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7e6182c-b5f4-4344-8e98-3e9f62aef421.png)'
- en: Solution
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: To track the processing between cooperating microservices, we need to ensure
    that all related requests and messages are marked with a common correlation ID
    and that the correlation ID is part of all log events. Based on a correlation
    ID, we can use the centralized logging service to find all related log events.
    If one of the log events also includes information about a business-related identifier,
    for example, the ID of a customer, product, order, and so on, we can find all
    related log events for that business identifier using the correlation ID.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪合作微服务之间的处理过程，我们需要确保所有相关请求和消息都标记有一个共同的关联ID，并且关联ID是所有日志事件的一部分。基于关联ID，我们可以使用集中的日志服务找到所有相关的日志事件。如果其中一个日志事件还包括与业务相关的标识信息，例如客户、产品、订单等的ID，我们可以使用关联ID找到与该业务标识所有相关的日志事件。
- en: Solution requirements
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'The solution requirements are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案要求如下：
- en: Assign unique correlation IDs to all incoming or new requests and events in
    a well-known place, such as a header with a recognized name.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有传入或新请求和事件分配唯一的关联ID，例如，在一个有已知名称的头部中。
- en: When a microservice makes an outgoing request or sends a message, it must add
    the correlation ID to the request and message.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个微服务发出一个外部请求或发送一个消息时，它必须给请求和消息添加一个关联ID。
- en: All log events must include the correlation ID in a predefined format so that
    the centralized logging service can extract the correlation ID from the log event
    and make it searchable.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有日志事件必须以预定义的格式包括关联ID，以便集中的日志服务可以从日志事件中提取关联ID并使其可搜索。
- en: Circuit Breaker
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: The Circuit Breaker pattern will have the following problem, solution, and solution
    requirements.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式将会有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: A system landscape of microservices that uses synchronous intercommunication
    can be exposed to a *chain of failure*. If one microservice stops responding,
    its clients might get into problems as well and stop responding to requests from
    their clients. The problem can propagate recursively throughout a system landscape
    and take out major parts of it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同步交互的微服务系统景观可能会遭受*故障链*。如果一个微服务停止响应，它的客户端也可能遇到问题并且停止响应它们客户端的请求。问题可能会递归地在系统景观中传播，并使其大部分失效。
- en: This is especially common in cases where synchronous requests are executed using
    blocking I/O, that is, blocking a thread from the underlying operating system
    while a request is being processed. Combined with a large number of concurrent
    requests and a service that starts to respond unexpectedly slowly, thread pools
    can quickly become drained, causing the caller to hang and/or crash. This failure
    can spread unpleasantly fast to the caller's caller, and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其在同步请求使用阻塞I/O执行时非常常见，即阻塞来自底层操作系统的线程，当请求正在被处理。结合大量并发请求和服务开始意外地缓慢响应，线程池可能会迅速耗尽，导致调用者挂起和/或崩溃。这种失败会不愉快地迅速传播到调用者的调用者，等等。
- en: Solution
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a Circuit Breaker that prevents new outgoing requests from a caller if it
    detects a problem with the service it calls.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个断路器，如果它检测到它调用的服务有问题，则阻止调用者发出新的外出请求。
- en: Solution requirements
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'The solution requirements are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案要求如下：
- en: Open the circuit and fail fast (without waiting for a timeout) if problems with
    the service are detected.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到服务问题，打开电路并快速失败（不等待超时）。
- en: Probe for failure correction (also known as a **half-open circuit**); that is,
    allow a single request to go through on a regular basis to see if the service
    operates normally again.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探针失败修复（也称为**半开电路**）；也就是说，定期让一个请求通过，以查看服务是否再次正常运行。
- en: Close the circuit if the probe detects that the service operates normally again.
    This capability is very important since it makes the system landscape resilient
    to these kinds of problems; that is, it self-heals.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果探针检测到服务再次正常运行，关闭电路。这种能力非常重要，因为它使系统景观对这些类型的问题具有弹性；也就是说，它具有自我修复能力。
- en: 'The following diagram illustrates a scenario where all synchronous communication
    within the system landscape of microservices goes through Circuit Breakers. All
    the Circuit Breakers are closed; that is, they allow traffic, except for one Circuit
    Breaker detected problems in the service the requests go to. Therefore, this Circuit
    Breaker is open and utilizes fast-fail logic; that is, it does not call the failing
    service and waits for a timeout to occur. In the following, it immediately returns
    a response, optionally applying some fallback logic before responding:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了所有微服务系统景观中的同步通信都通过断路器的情景。所有断路器都是关闭的；也就是说，它们允许流量，除了一个断路器检测到请求所服务的有问题。因此，这个断路器是打开的，并使用快速失败逻辑；也就是说，它不调用失败的服务，等待超时发生。在下面，它会立即返回一个响应，在响应之前可选地应用一些回退逻辑：
- en: '![](img/039f95d4-defe-4ecf-9ce1-71c78ed322ac.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/039f95d4-defe-4ecf-9ce1-71c78ed322ac.png)'
- en: Control loop
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制循环
- en: The control loop pattern will have the following problem, solution, and solution
    requirements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 控制循环模式将有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In a system landscape with a large number of microservice instances spread out
    over a number of servers, it is very difficult to manually detect and correct
    problems such as crashed or hung microservice instances.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个有大量微服务实例的系统景观中，这些实例分布在多个服务器上，手动检测和纠正崩溃或挂起的微服务实例等问题非常困难。
- en: Solution
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component, a **control loop**, to the system landscape; this constantly
    observes the actual state of the system landscape; compares it with the desired
    state, as specified by the operators; and, if required, takes action. For example,
    if the two states differ, it needs to make the actual state equal to the desired
    state:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统景观添加一个新组件，一个**控制循环**，这个组件不断观察系统景观的实际状态；将其与操作员指定的期望状态进行比较，如有必要，采取行动。例如，如果这两个状态不同，它需要使实际状态等于期望状态：
- en: '![](img/4716aa50-5154-4e6a-b6d2-32ae7728d640.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4716aa50-5154-4e6a-b6d2-32ae7728d640.png)'
- en: Solution requirements
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Implementation notes: In the world of containers, a *container orchestrator* such
    as Kubernetes is typically used to implement this pattern. We will learn more
    about Kubernetes in [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml),
    *Introduction to Kubernetes*.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实现说明：在容器的世界里，通常使用如Kubernetes之类的*容器编排器*来实现这个模式。我们将在[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)，*Kubernetes简介*中了解更多关于Kubernetes的内容。
- en: Centralized monitoring and alarms
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中监控和警报
- en: For this pattern, we will have the following problem, solution, and solution
    requirements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，我们将有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: If observed response times and/or the usage of hardware resources become unacceptably
    high, it can be very hard to discover the root cause of the problem. For example,
    we need to be able to analyze hardware resource consumption per microservice.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果观察到的响应时间和/或硬件资源的使用变得不可接受地高，找出问题的根本原因可能非常困难。例如，我们需要能够分析每个微服务的硬件资源消耗。
- en: Solution
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: To curb this, we add a new component, a **monitor service**, to the system landscape,
    which is capable of collecting metrics about hardware resource usage for each
    microservice instance level.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们在系统景观中增加了一个新组件，一个**监控服务**，它能够收集每个微服务实例级别的硬件资源使用情况。
- en: Solution requirements
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'The solution requirements are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案要求如下：
- en: It must be able to collect metrics from all the servers that are used by the
    system landscape, which includes auto-scaling servers.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够从系统景观中使用的所有服务器收集指标，包括自动扩展服务器。
- en: It must be able to detect new microservice instances as they are launched on
    the available servers and start to collect metrics from them.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够检测到在可用服务器上启动的新微服务实例，并开始从它们收集指标。
- en: It must be able to provide APIs and graphical tools for querying and analyzing the
    collected metrics.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够为查询和分析收集的指标提供 API 和图形工具。
- en: 'The following screenshot shows Grafana, which visualizes metrics from Prometheus,
    a monitoring tool that we will look at later in this book:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了 Grafana，它可视化了来自我们稍后在本书中将介绍的监控工具 Prometheus 的指标：
- en: '![](img/c19497ae-0184-4788-baed-9bc5a5f11993.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c19497ae-0184-4788-baed-9bc5a5f11993.png)'
- en: That was an extensive list! I am sure these design patterns helped you understand
    the challenges with microservices better. Next, we will move on to understand
    software enablers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个很长的列表！我相信这些设计模式帮助您更好地理解了微服务的挑战。接下来，我们将转向了解软件使能器。
- en: Software enablers
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件使能器
- en: 'As we''ve already mentioned, we have a number of very good open-source tools
    that can help us both meet our expectations of microservices and, most importantly,
    handle the new challenges that come with them:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们前面已经提到的，我们有多种非常好的开源工具可以帮助我们满足对微服务的期望，最重要的是，它们可以帮助我们处理与它们相关的新的挑战：
- en: Spring Boot
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot
- en: Spring Cloud/Netflix OSS
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud/Netflix OSS
- en: Docker
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Kubernetes
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Istio (a service mesh)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio（服务网格）
- en: 'The following table maps the design patterns we will need to handle these challenges,
    along with the corresponding open-source tool that implements the design pattern:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的表格将我们需要处理这些挑战的设计模式以及实现该设计模式的相应开源工具进行了映射：
- en: '| **Design Pattern** | **Spring Boot** | **Spring Cloud** | **Kubernetes**
    | **Istio** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: 设计模式 | Spring Boot | Spring Cloud | Kubernetes | Istio |
- en: '| **Service discovery** |  | Netflix Eureka and Netflix Ribbon | Kubernetes
    `kube-proxy` and service resources |  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: 服务发现 | | Netflix Eureka 和 Netflix Ribbon | Kubernetes `kube-proxy` 和服务资源 | |
- en: '| **Edge server** |  | Spring Cloud and Spring Security OAuth | Kubernetes
    Ingress controller | Istio ingress gateway |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: 边缘服务器 | | Spring Cloud 和 Spring Security OAuth | Kubernetes Ingress 控制器 | Istio
    入口网关 |
- en: '| **Reactive microservices** | Spring Reactor and Spring WebFlux |  |  |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: 反应式微服务 | Spring Reactor 和 Spring WebFlux | | | |
- en: '| **Central configuration** |  | Spring Config Server | Kubernetes `ConfigMaps`
    and Secrets |  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: 集中式配置 | | Spring Config Server | Kubernetes `ConfigMaps` 和 Secrets | |
- en: '| **Centralized log analysis** |  |  | Elasticsearch, Fluentd, and Kibana **Note**:
    Actually not part of Kubernetes'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式日志分析 | | | Elasticsearch、Fluentd 和 Kibana **注意**：实际上不是 Kubernetes 的一部分
- en: but can easily be deployed and configured together with Kubernetes |  |
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但是可以轻松地与 Kubernetes 一起部署和配置 | |
- en: '| **Distributed tracing** |  | Spring Cloud Sleuth and Zipkin |  | Jaeger |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: 分布式追踪 | | Spring Cloud Sleuth 和 Zipkin | | Jaeger |
- en: '| **Circuit Breaker** |  | Resilience4j |  | Outlier detection |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: 电路 breaker | | Resilience4j | | 异常检测 |
- en: '| **Control loop** |  |  | Kubernetes controller manager |  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: 控制循环 | | | Kubernetes 控制器管理器 | |
- en: '| **Centralized monitoring and alarms** |  |  | Grafana and Prometheus **Note:** Actually
    not part of Kubernetes'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式监控和警报 | | | Grafana 和 Prometheus **注意**：实际上不是 Kubernetes 的一部分
- en: but can easily be deployed and configured  together with Kubernetes | Kiali,
    Grafana, and Prometheus |
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但是可以轻松地与 Kubernetes 一起部署和配置 | Kiali、Grafana 和 Prometheus |
- en: Please note that Spring Cloud, Kubernetes, and Istio can be used to implement
    some design patterns, such as service discovery, edge server, and central configuration.
    We will discuss the pros and cons of using these alternatives later in this book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Spring Cloud、Kubernetes 和 Istio 可以用来实现一些设计模式，如服务发现、边缘服务器和集中配置。我们将在本书的后面讨论使用这些替代方案的优缺点。
- en: Now, let's look at some other important things that we need to take into consideration.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看其他一些我们需要考虑的重要事情。
- en: Other important considerations
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要考虑因素
- en: 'To be successful implementing a microservice architecture, there are a number
    of related areas to consider as well. I will not cover these areas in this book;
    instead, I''ll just briefly mention them here as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实现微服务架构的成功，还需要考虑许多相关领域。我不会在这本书中涵盖这些领域；相反，我只是在这里简要提及如下：
- en: '**Importance of Dev/Ops**:One of the benefits of a microservice architecture
    is that it enables shorter delivery times and, in extreme cases allows the *continuous
    delivery* of new versions. To be able to deliver that fast, you need to establish
    an organization where dev and ops work together under the mantra *you built it,
    you run it*. This means that developers are no longer allowed to simply pass new
    versions of the software over to the operations team. Instead, the dev and ops
    organizations need to work much more closely together, organized into teams that
    have full responsibility for the end-to-end life cycle of one microservice (or
    a group of related microservices). Besides the organizational part of `dev`/`ops`,
    the teams also need to automate the delivery chain, that is, the steps for building,
    testing, packaging, and deploying the microservices to the various deployment
    environments. This is known as setting up a *delivery pipeline*.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dev/Ops 的重要性**：微服务架构的一个好处是，它能够缩短交付时间，在极端情况下甚至允许*持续交付*新版本。为了能够那么快地交付，你需要建立一个组织，在这个组织中，开发和运维人员共同工作，遵循“*你构建它，你运行它*”的宗旨。这意味着开发者不再被允许只是将软件的新版本交给运维团队。相反，开发和运维组织需要更紧密地一起工作，组成具有全面责任的一个微服务（或一组相关的微服务）的整个生命周期的团队。除了组织的`dev`/`ops`部分，团队还需要自动化交付链，即构建、测试、打包和将微服务部署到各种部署环境中的步骤。这被称为建立一个*交付管道*。'
- en: '**Organizational aspects and Conway''s law**: Another interesting aspect of
    how a microservice architecture might affect the organization is *Conway''s law*,
    which states the following:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织方面和康威定律**：微服务架构可能如何影响组织的另一个有趣方面是*康威定律*，它陈述如下：'
- en: '"Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization''s communication structure."'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: “任何设计系统（定义广泛）的组织都会产生一个其结构是该组织通信结构副本的设计。”
- en: -- Melvyn Conway, 1967
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: -- Melvyn Conway，1967
- en: This means that the traditional approach of organizing IT teams for large applications
    based on their technology expertise (for example, UX, business logic, and databases-teams)
    will lead to a big three-tier application – typically a big monolithic application
    with a separately deployable unit for the UI, one for processing the business
    logic, and one for the big database. To successfully deliver an application based
    on a microservice architecture, the organization needs to be changed into teams
    that work with one or a group of related microservices. The team must have the
    skills that are required for those microservices, for example, languages and frameworks
    for the business logic and database technologies for persisting its data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，基于技术专长（例如，UX、业务逻辑和数据库团队）来组织大型应用程序的传统方法会导致一个大的三层应用程序——通常是一个大的单体应用程序，其中有一个可独立部署的UI单元、一个处理业务逻辑的单元和一个大数据库。为了成功交付一个基于微服务架构的应用程序，组织需要变成一个或一组相关微服务的团队。这个团队必须拥有那些微服务所需的技能，例如，业务逻辑的语言和框架以及持久化其数据的数据库技术。
- en: '**Decomposing a monolithic application into microservices: **One of the most
    difficult and expensive decisions is how to decompose a monolithic application
    into a set of cooperating microservices. If this is done in the wrong way, you
    will end up with problems such as the following:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将单体应用分解为微服务：**最困难和昂贵的决定之一是如何将单体应用分解为一组协作的微服务。如果这样做错了，你最终会面临如下问题：'
- en: '**Slow delivery**: Changes in the business requirements will affect too many
    of the microservices, resulting in extra work.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交付缓慢：**业务需求的变化将影响太多的微服务，导致额外的工作。'
- en: '**Slow performance**: To be able to perform a specific business function, a
    lot of requests have to be passed between various microservices, resulting in
    long response times.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能缓慢：**为了能够执行特定的业务功能，许多请求必须在不同的微服务之间传递，导致响应时间长。'
- en: '**Inconsistent data**: Since related data is separated into different microservices,
    inconsistencies can appear over time in data that''s managed by different microservices.'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据不一致性：**由于相关数据被分离到不同的微服务中，随着时间的推移，由不同微服务管理的数据可能会出现不一致。'
- en: A good approach to finding proper boundaries for microservices is to apply **Domain-Driven
    Design** and its **Bounded Context** concept. According to Eric Evans, a *Bounded
    Context* is "*A description of a boundary (typically a subsystem, or the work
    of a particular team) within which a particular model is defined and applicable." *This
    means that the microservice defined by a Bounded Context will have a well-defined
    model of its own data.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找微服务适当边界的良好方法是应用**领域驱动设计**及其**边界上下文**概念。根据Eric Evans的说法，*边界上下文*是"*一个描述（通常是一个子系统，或特定团队的工作）的边界，在这个边界内定义了一个特定的模型并且适用。"*这意味着由边界上下文定义的微服务将拥有其自身数据的良好定义模型。
- en: '**Importance of API design: **If a group of microservices expose a common,
    externally available API, it is important that the API is easy to understand and
    consumes the following:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API设计的重要性：**如果一组微服务暴露了一个共同的、对外可用的API，那么这个API必须是易于理解的，并且要符合以下要求：'
- en: If the same concept is used in multiple APIs, it should have the same description
    in terms of the naming and data types used.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果同一个概念在多个API中使用，那么在命名和数据类型方面应该有相同的描述。
- en: It is of great importance that APIs are allowed to evolve in a controlled manner.
    This typically requires applying a proper versioning schema for the APIs, for
    example, [https://semver.org/](https://semver.org/), and having the capability
    of handling multiple major versions of an API over a specific period of time,
    allowing clients of the API to migrate to new major versions at their own pace.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许API以受控的方式进行演变是非常重要的。这通常需要为API应用适当的版本控制方案，例如，[https://semver.org/](https://semver.org/)，并有能力在特定时间段内处理API的多个主要版本，允许API的客户端按照自己的节奏迁移到新的主要版本。
- en: '**Migration paths from on-premise to the cloud**:Many companies today run their
    workload on-premise, but are searching for ways to move parts of their workload
    to the cloud. Since most cloud providers today offer Kubernetes as a Service,
    an appealing migration approach can be to first move the workload into Kubernetes on-premise (as
    microservices or not) and then redeploy it on a *Kubernetes as a Service* offering
    provided by a preferred cloud provider.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从本地部署到云的迁移路径：**如今，许多公司仍在本地运行其工作负载，但正在寻找将部分工作负载迁移到云的方法。由于大多数云服务提供商今天都提供Kubernetes作为服务，一个吸引人的迁移方法可以是首先将工作负载迁移到本地的Kubernetes（作为微服务或不是），然后将其重新部署在首选云提供商提供的*Kubernetes作为服务*上。'
- en: '**Good design principles for microservices, the 12-factor app**:The 12-factor
    app ([https://12factor.net](https://12factor.net/)) is a set of design principles
    for building software that can be deployed in the cloud. Most of these design
    principles are applicable to building microservices independently of where and
    how they will be deployed, that is, in the cloud or on-premise. Some of these
    principles will be covered in this book, such as config, processes, and logs, but
    not all.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务和12因子应用的良好设计原则：**12因子应用（[https://12factor.net](https://12factor.net/)）是一组适用于构建可部署在云上的软件的设计原则。其中大多数设计原则适用于独立于部署位置（即云或本地）构建微服务，但并非全部。'
- en: That's it for the first chapter! I hope this gave you a good basic idea of microservices
    and helped you understand the large scale topics that will be covered in this
    book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章就到这里！希望这为您提供了微服务的好基本概念，并帮助您理解本书将涵盖的大规模主题。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this introductory chapter, I described my own way into microservices and
    delved into a bit of their history. We defined what a microservice is, that is,
    a kind of autonomous distributed component with some specific requirements. We
    also went through the good and challenging aspects of a microservice-based architecture.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这章开头，我描述了我自己对微服务的理解，并简要了解了它们的历史。我们定义了微服务是什么，即具有一些特定要求的一种自主分布式组件。我们还讨论了微服务架构的优点和挑战。
- en: To handle these challenges, we defined a set of design patterns and briefly
    mapped the capabilities of open source products such as Spring Boot, Spring Cloud,
    and Kubernetes to them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，我们定义了一组设计模式，并简要地将开源产品如Spring Boot、Spring Cloud和Kubernetes的能力与它们进行了映射。
- en: You're eager to develop your first microservice now, right? In the next chapter,
    we will be introduced to Spring Boot and complementary open source tools that
    we will use to develop our first microservices
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在迫不及待地想开发你的第一个微服务了吧？在下一章中，我们将介绍Spring Boot以及与之互补的开源工具，我们将使用它们来开发我们的第一个微服务。
