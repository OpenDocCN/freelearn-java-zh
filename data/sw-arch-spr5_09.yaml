- en: Serverless Architectures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器架构
- en: Serverless architectures are becoming a popular trend in IT system building.
    As a consequence, it's quite common to hear people discussing cloud providers
    such as **Amazon Web services** (**AWS**), Google Cloud, and Microsoft Azure,
    among others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构正在成为IT系统构建中的一种流行趋势。因此，人们经常讨论亚马逊网络服务（AWS）、谷歌云和微软Azure等云提供商。
- en: In this chapter, we will explore the meaning of serverless architecture and
    how this new way of building systems can help us to address business requirements
    in shorter amounts of time, thus reducing the effort required to build business
    solutions. We will also look at how this approach can be used to drastically reduce
    the time required to reach production by utilizing ready-to-use, third-party services
    and implementing custom functionalities, thereby creating stateless functions
    that can be deployed on the cloud.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨无服务器架构的含义，以及这种新的构建系统的方式如何帮助我们在更短的时间内满足业务需求，从而减少构建业务解决方案所需的工作量。我们还将看看如何利用现成的第三方服务和实现自定义功能，从而创建可以部署在云上的无状态函数，从而大大减少到达生产所需的时间。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to serverless architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器架构简介
- en: Infrastructure and file storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施和文件存储
- en: Benefits and pitfalls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好处和陷阱
- en: Backend as a service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端即服务
- en: Function as a service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数即服务
- en: 'Concerns about serverless architectures:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对无服务器架构的担忧：
- en: Vendor lock-in concerns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商锁定问题
- en: Security concerns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全问题
- en: Framework support
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架支持
- en: Troubleshooting
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除
- en: Examples and commons uses of serverless architecture
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器架构的示例和常见用途
- en: 'Implementing applications using serverless architecture:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无服务器架构实施应用程序：
- en: How to write functions with Spring
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Spring编写函数
- en: Using adapters for AWS Lambda and Azure
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS Lambda和Azure的适配器
- en: An introduction to serverless architecture
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器架构简介
- en: Serverless architecture was born through the initiative of Amazon. The company
    was looking to promote an environment wherein a development team could be autonomous,
    small, and self-managed, allowing it to work on the whole software development
    cycle, from writing the code to shipping and delivering to production environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构是通过亚马逊的倡议诞生的。该公司希望推广一个开发团队可以自主、小型和自我管理的环境，使其能够从编写代码到在生产环境中交付和交付整个软件开发周期。
- en: 'Serverless architecture is sometimes misunderstood as the concept of software
    systems that are deployed without the need for a physical server. To understand
    this idea, you can review the definition of serverless in Martin Fowler''s blog:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构有时被误解为部署软件系统而无需物理服务器的概念。要理解这个想法，您可以查看Martin Fowler的博客中对无服务器的定义：
- en: '"It''s important to understand that a serverless architecture is the approach
    in which developers code business logic as functions, forgetting about the server''s
    provisioning and scaling concerns where the logic will be executed."'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “重要的是要理解，无服务器架构是开发人员将业务逻辑编码为函数的方法，忘记了服务器的配置和扩展问题，其中逻辑将被执行。”
- en: '- [https://martinfowler.com/articles/serverless.html](https://martinfowler.com/articles/serverless.html)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://martinfowler.com/articles/serverless.html](https://martinfowler.com/articles/serverless.html)'
- en: 'Common examples of serverless and FaaS include:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器和FaaS的常见示例包括：
- en: Authentication
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: SMS notifications
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短信通知
- en: Email services
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件服务
- en: On the other hand, within a serverless world, it's common to create applications
    in which third-party services are adopted as a part of the system (rather than
    creating services from scratch). These services are commonly known as **backend
    as a service** (**BaaS**) or **mobile backend as a service** (**MBaaS**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在无服务器的世界中，通常会创建应用程序，其中采用第三方服务作为系统的一部分（而不是从头开始创建服务）。这些服务通常被称为后端即服务（BaaS）或移动后端即服务（MBaaS）。
- en: Following the same approach, we can code our custom business logic in the form
    of functions that can be deployed on the cloud. These services are known as **function
    as a service** (**FaaS**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 采用相同的方法，我们可以将自定义业务逻辑编码为可以部署在云上的函数。这些服务被称为函数即服务（FaaS）。
- en: 'The following diagram illustrates how third-party services and custom functions
    are created, deployed, and consumed by different software systems:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了第三方服务和自定义功能是如何被不同的软件系统创建、部署和消费的：
- en: '![](img/2a9521c5-ac3c-4b18-a3aa-55abc5441088.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a9521c5-ac3c-4b18-a3aa-55abc5441088.png)'
- en: Third-party services and custom functions
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方服务和自定义功能
- en: Infrastructure and file storage
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施和文件存储
- en: Infrastructure and file storage are also considered serverless, because the
    business (or person) that owns the system does not have to purchase, rent, or
    provision servers or virtual machines to use them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施和文件存储也被视为无服务器，因为拥有系统的业务（或个人）不必购买、租用或配置服务器或虚拟机来使用它们。
- en: As developers, if we take the old-fashioned approach (provisioning all of the
    infrastructure by using an on-premise environment), we have to set up all of the
    software and hardware requirements for every environment in which we want to deploy
    our software systems. This provisioning process has to be repeated for all of
    the environments, until we get into production, at which point we have to take
    care of other features, such as scaling and monitoring. In many cases, our infrastructure
    will be under-utilized, which is a waste of money, since we have purchased powerful
    servers to deploy applications that don't need many resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，如果我们采用老式方法（使用本地环境提供所有基础设施），我们必须为我们想要部署软件系统的每个环境设置所有软件和硬件要求。这个配置过程必须在所有环境中重复进行，直到我们进入生产阶段，在这一点上，我们必须处理其他功能，如扩展和监控。在许多情况下，我们的基础设施将被低效利用，这是一种浪费金钱的行为，因为我们购买了强大的服务器来部署不需要太多资源的应用程序。
- en: Benefits and pitfalls
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处和陷阱
- en: 'Adopting a serverless architecture approach to creating applications provides
    us with many benefits, but there are also some pitfalls that we should address.
    Let''s start by reviewing the benefits:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 采用无服务器架构方法创建应用程序为我们提供了许多好处，但也有一些缺点需要解决。让我们先来回顾一下好处：
- en: Developers using a serverless architecture can focus primarily on the code,
    and can forget everything related to provisioning servers, which is a task handled
    by the cloud provider itself.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无服务器架构的开发人员可以主要专注于代码，可以忘记与服务器供应有关的一切，这是云提供商自己处理的任务。
- en: The scaling of the code is ephemeral, meaning that it can be scaled and can
    spin up or down, based on the number of requests retrieved.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的扩展是短暂的，意味着它可以根据检索的请求数量进行扩展和启动或关闭。
- en: By definition, all of the functions used to code the business logic must be
    stateless, and therefore, loosely coupled. In this way, the tasks are focused
    on well-defined responsibilities.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据定义，用于编写业务逻辑的所有功能必须是无状态的，因此松散耦合。这样，任务就可以专注于明确定义的责任。
- en: Functions can be asynchronously triggered by events.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能可以通过事件异步触发。
- en: We only have to pay for the compute time consumed.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只需支付所消耗的计算时间。
- en: The functions base their functionality on an event-driven model.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些功能的功能是基于事件驱动模型的。
- en: Infinite scaling can be achieved for developers in a transparent way.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以以透明的方式实现无限扩展。
- en: 'On the other hand, there are also some pitfalls:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，也存在一些缺点：
- en: A lack of documentation and showcases that can be used as references
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏可用作参考的文档和展示
- en: Latency issues that are introduced when many services have to be consumed at
    the same time
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要同时使用多个服务时引入的延迟问题
- en: Some features are only available from certain cloud providers.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些功能仅在特定的云服务提供商中可用。
- en: Vendor lock-in
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商锁定
- en: In order to tackle the pitfall of vendor lock-in, it is highly recommended to
    use a **polycloud** approach as a part of a serverless architecture. A polycloud
    strategy involves using more than one cloud provider. This is important because,
    with it, we can take advantage of the strengths of different vendors and different
    products. For example, Google offers awesome services for machine learning, AWS
    provides a wide variety of standard services, and Microsoft Azure has awesome
    features for functions such as remote debugging. On the other hand, cloud-agnostic strategies
    recommend that we avoid sticking to a determined cloud provider as much as possible,
    in order to have the freedom to deploy systems whenever we want to. However, this
    would be difficult to achieve, because it would mean designing systems in a more
    generic way, ignoring specific vendor features that offer additional advantages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决供应商锁定的问题，强烈建议在无服务器架构的一部分使用**多云**方法。多云策略涉及使用多个云提供商。这很重要，因为通过它，我们可以利用不同供应商和不同产品的优势。例如，Google提供了出色的机器学习服务，AWS提供了各种标准服务，微软Azure为远程调试等功能提供了出色的功能。另一方面，云无关的策略建议我们尽可能避免依赖特定的云提供商，以便在需要时自由部署系统。然而，这将很难实现，因为这意味着以更通用的方式设计系统，忽略提供额外优势的特定供应商功能。
- en: Backend as a service
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端即服务
- en: The simplest scenario for using a BaaS approach occurs when we create **single
    page applications** (**SPA**), or mobile apps that interact with services available
    in the cloud.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BaaS方法的最简单情景是创建**单页应用程序**（**SPA**）或与云中可用服务交互的移动应用程序。
- en: It's common to find applications wherein the authentication process is delegated
    to third-party services, using standard protocols (such as OAuth), persisting
    information in cloud databases (such as Google Firebase), or sending notifications
    via SMS services (such as Twilio).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以找到应用程序，其中认证过程委托给第三方服务，使用标准协议（如OAuth），将信息持久存储在云数据库（如Google Firebase），或通过短信服务（如Twilio）发送通知。
- en: 'BaaS can help us with several concerns out of the box so that we can deploy
    into the production environment without having to worry about the server or virtual
    machine of the application. In addition, BaaS also provides us with a whole infrastructure
    and nodes, such as the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: BaaS可以帮助我们解决一些问题，以便我们可以在不必担心应用程序的服务器或虚拟机的情况下部署到生产环境。此外，BaaS还为我们提供了整个基础设施和节点，例如以下内容：
- en: Load Balancer
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: Database to store our data (NoSQL or RDBMS)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库用于存储我们的数据（NoSQL或RDBMS）
- en: Filesystems
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统
- en: Queue servers
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列服务器
- en: 'BaaS also takes care of the following requirements:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: BaaS还满足以下要求：
- en: Backup
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份
- en: Replication
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: Patches
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁
- en: Scale
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模
- en: High availability
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性
- en: 'On the other hand, BaaS has increased the birth of new products as services,
    including the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，BaaS也增加了作为服务的新产品的诞生，包括以下内容：
- en: '**Firebase**: This provides us with features such as analytics, databases,
    messaging, and crash reporting'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firebase**：这为我们提供了分析、数据库、消息传递和崩溃报告等功能'
- en: '**Amazon DynamoDB**: This key-value of the store is a non-relational database'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon DynamoDB**：这个键值存储是非关系型数据库'
- en: '**Azure Cosmos DB**: This is a globally distributed, multi-model database service'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Cosmos DB**：这是一个全球分布的多模型数据库服务'
- en: With all of these changes and new tools, we have to embrace a new way of thinking
    and break the paradigms of how we build our applications. As serverless is a new
    technology, it is recommended to experiment, starting with using a small piece
    of an application. Think of three examples from your current applications that
    would be interesting to refactor using a serverless approach. Now, confer with
    your team and organize an Architectural Clash ([http://architecturalclash.org/](http://architecturalclash.org/))
    workshop to identify whether or not your ideas are feasible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着所有这些变化和新工具，我们必须接受一种新的思维方式，并打破构建应用程序的范式。由于无服务器是一种新技术，建议进行实验，从使用应用程序的一小部分开始。想想您当前应用程序中的三个例子，这些例子使用无服务器方法进行重构将会很有趣。现在，与您的团队商讨并组织一个架构对抗（http://architecturalclash.org/）研讨会，以确定您的想法是否可行。
- en: Function as a service
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数即服务
- en: Since AWS Lambda gained popularity in 2014, the use of code implemented as functions
    has become increasingly popular. In some cases, there is even the option to build
    a whole application using a FaaS approach; in other cases, the approach is used
    to solve specific requirements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自2014年以来，AWS Lambda的使用越来越受欢迎。在某些情况下，甚至可以使用FaaS方法构建整个应用程序；在其他情况下，该方法用于解决特定要求。
- en: Code deployed in the form of functions is executed when an event occurs. Once
    the event happens, the code is executed, and the function is then shut down. For
    that reason, functions are stateless by nature, since there is no state or context
    to share with other applications.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 函数形式部署的代码在事件发生时被执行。一旦事件发生，代码被执行，然后函数被关闭。因此，函数本质上是无状态的，因为没有状态或上下文可以与其他应用程序共享。
- en: 'A FaaS is ephemeral, meaning that when a function needs to be executed, the
    cloud provider will automatically provision an environment using the metadata
    associated with the function. This will scale depending on the processing needs,
    and, once the processing has finished, the execution environment will be destroyed,
    as shown in the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS是短暂的，意味着当需要执行函数时，云提供商将自动使用与函数相关的元数据来提供环境。这将根据处理需求进行扩展，并且一旦处理完成，执行环境将被销毁，如下图所示：
- en: '![](img/9b51d091-c38d-4713-88ff-3f1775474b06.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b51d091-c38d-4713-88ff-3f1775474b06.png)'
- en: Ephemeral FaaS process
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 短暂的FaaS过程
- en: 'Implementing code using a FaaS approach will provide you with the following
    benefits:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FaaS方法实现代码将为您提供以下好处：
- en: You won't have to worry about host configuration
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不必担心主机配置
- en: Transparent scale-up on demand
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明的按需扩展
- en: Automatic spin up/down
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动启动/关闭
- en: You will only pay for what you use
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只需为您使用的部分付费
- en: Concerns about serverless architectures
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于无服务器架构的担忧
- en: New technology trends sometimes create resilience and concerns, but they also
    provide the opportunity to experiment and gain benefits for applications and business.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 新的技术趋势有时会产生韧性和担忧，但它们也提供了实验和为应用程序和业务获益的机会。
- en: 'The most common concerns involved in serverless architecture are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器无架构涉及的最常见问题如下：
- en: Vendor lock-in
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商锁定
- en: Security
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Framework support
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架支持
- en: Troubleshooting
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除
- en: Vendor lock-in
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商锁定
- en: With vendor lock-in, the main concern is the impossibility of embracing new
    services as part of the vendors' serverless architecture. This concern comes down
    to a fear of being locked in with a cloud provider.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在供应商锁定方面，主要问题是无法将新服务作为供应商的无服务器架构的一部分。这个问题归结为对与云提供商绑定的恐惧。
- en: It is recommended to use as many features as you can of the cloud provider of
    your choosing. You can do so by starting a pilot and evaluating the cloud provider;
    be sure to create an assessment of pros and cons before moving more code onto
    the cloud.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 建议尽可能使用您选择的云提供商的许多功能。您可以通过开始一个试点并评估云提供商来做到这一点；在将更多代码移至云之前，一定要创建一个利弊评估。
- en: Don't let this concern put you off of using serverless architecture. Instead,
    it is recommended to start a proof of concept and evaluate the cloud provider.
    Serverless is a new technology that will evolve with time, and there are ways
    to keep FaaS independent, such as by using Spring Cloud functionality. We will
    work on an example of this in a later section of this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为这个问题而放弃使用无服务器架构。相反，建议开始一个概念验证并评估云提供商。无服务器是一种新技术，将随着时间的推移而发展，有办法保持FaaS的独立性，例如使用Spring
    Cloud功能。我们将在本章的后面部分的一个示例中进行这方面的工作。
- en: Finally, you should understand that moving to another vendor (from cloud-to-cloud)
    is not as difficult as it was in the past (when we were moving our application
    or legacy code to on-premises environments).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该明白，从一个供应商转移到另一个供应商（从云到云）并不像过去（当我们将应用程序或传统代码转移到本地环境时）那么困难。
- en: Security
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is a key concern, independent of the architecture of the application,
    and serverless is no exception. Since we are creating functions as services in
    the cloud, we need to take care in our authentication, authorization of execution,
    and the OWASP. However, in this context, the cloud provider—such as AWS or Azure—provides
    us with guides and practices out of the box, in order to minimize our concerns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一个关键问题，与应用程序的架构无关，无服务器也不例外。由于我们在云中创建函数作为服务，我们需要在我们的身份验证、执行授权和OWASP方面小心。然而，在这种情况下，云提供商（如AWS或Azure）为我们提供了开箱即用的指南和实践，以减少我们的担忧。
- en: Another security concern to consider in serverless is the lack of a clearly
    shaped security perimeter. In other words, when the security perimeter of one
    of the functions ends and another starts, different cloud providers provide different ways
    to make those functions work as a whole; for example, AWS does this by using a
    service called an API Gateway. This API is used to orchestrate and compose the
    created FaaS. On the other hand, as is the case with everything that is ephemeral,
    many of these concerns may go away because the concept of ephemeral in FaaS is
    that the function will be created, run, and destroyed as many requests received
    on there are isolated each time that the FaaS is called.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器中需要考虑的另一个安全问题是缺乏明确定义的安全边界。换句话说，当一个函数的安全边界结束并且另一个函数开始时，不同的云提供商提供不同的方法来使这些函数作为一个整体工作；例如，AWS通过使用称为API网关的服务来实现这一点。这个API用于编排和组合创建的FaaS。另一方面，正如一切都是短暂的一样，许多这些问题可能会消失，因为FaaS中的短暂概念是每次调用FaaS时都会创建、运行和销毁函数的请求都是隔离的。
- en: To clarify any concerns, we will start to move some of our code to serverless/FaaS,
    creating an experimental development and incrementing when we feel more confident
    with the concept.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清任何疑虑，我们将开始将部分代码移动到无服务器/函数即服务，创建一个实验性的开发，并在对该概念更有信心时逐步增加。
- en: Framework support
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架支持
- en: There are several frameworks working to create environments that develop serverless
    architectures without being attached to the cloud provider. In my experience,
    it is preferable to create functions as services that exploit the cloud platform
    as much as possible. As a function is a small piece of code with a clear input
    or output, it is better to use the language and technology that you feel comfortable
    with, or even to try new technologies or programming languages, in order to determine
    how good they are.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个框架正在努力创建开发无服务器架构的环境，而不依赖于云提供商。根据我的经验，最好创建函数作为服务，尽可能地利用云平台。由于函数是具有清晰输入或输出的小段代码，最好使用您感到舒适的语言和技术，甚至尝试新技术或编程语言，以确定它们的优劣。
- en: 'At this stage, serverless supports several languages for building functions.
    Currently, the most common options to deploy FaaS are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，无服务器支持多种语言来构建函数。目前，部署FaaS的最常见选项如下：
- en: AWS Lamba
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lamba
- en: Azure functions
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure函数
- en: Google functions
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google函数
- en: One benefit for Java developers is that most cloud providers offer support for
    Java as a programming language to deploy functions. Moreover, Spring Framework
    has a project named Spring Functions that can be used to code functions; we will
    implement some functionality using this project later in this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发人员的一个好处是，大多数云提供商都支持Java作为一种编程语言来部署函数。此外，Spring Framework有一个名为Spring Functions的项目，可以用来编写函数；我们将在本章后面使用这个项目来实现一些功能。
- en: A benefit of using Spring Functions is that we can develop and test our code
    in our local machine, and then wrap the code using an adaptor, in order to deploy
    it on a cloud provider.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Functions的一个好处是，我们可以在本地机器上开发和测试我们的代码，然后使用适配器包装代码，以便在云提供商上部署它。
- en: Troubleshooting
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: Once an application (or function, in this case) is deployed into production,
    one of the key aspects to consider is how to trace, find, and fix bugs. With serverless,
    this can be tricky, because we are dealing with a more segregated scenario, and
    our system has small parts that are not divided into services and microservices.
    Several functions are smaller pieces of logic and code. To deal with this concern,
    each cloud provider has tools to monitor and trace functions, dealing with one
    error in an ephemeral environment. If we compose logic for several functions,
    we will have to apply techniques like aggregate logging and use tools to collect
    information associated with the executed code. We will review some techniques
    to deal with this concept in [Chapter 12](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml), *Monitoring*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序（或在本例中的函数）部署到生产环境中，需要考虑的关键方面之一是如何跟踪、查找和修复错误。对于无服务器来说，这可能会很棘手，因为我们正在处理一个更为分隔的场景，我们的系统有一些未分成服务和微服务的小部分。几个函数是逻辑和代码的小部分。为了解决这个问题，每个云提供商都有工具来监视和跟踪函数，处理短暂环境中的错误。如果我们组合了几个函数的逻辑，我们将不得不应用聚合日志记录等技术，并使用工具来收集与执行的代码相关的信息。我们将在[第12章](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml)中审查一些处理这个概念的技术，*监控*。
- en: Examples and common use cases
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例和常见用例
- en: Even when a serverless architecture provides us with a lot of benefits, those
    benefits cannot be applied to everything. It's quite common to find applications
    using hybrid models, when an application consumes a backend deployed on a traditional
    server (on-premise or cloud-based) and also using FaaS or third-party services
    for specific requirements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 即使无服务器架构为我们提供了许多好处，这些好处也不能应用于所有情况。当应用程序同时使用传统服务器（本地或基于云的）部署的后端和用于特定需求的FaaS或第三方服务时，使用混合模型是非常常见的。
- en: 'Some common scenarios that serverless architectures can be applied to are as
    follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构可以应用于以下一些常见场景：
- en: Processing webhooks
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理webhooks
- en: Tasks or jobs that should be scheduled or triggered under certain circumstances
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在特定情况下安排或触发的任务或工作
- en: 'Data transformation, for example:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转换，例如：
- en: Image manipulation, compression, or conversion
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理、压缩或转换
- en: Voice data transcribed into text, such as Alexa or Cortana
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语音数据转录成文本，比如Alexa或Cortana
- en: A certain logic for mobile applications, based on the mobile backend as a service
    approach
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于移动后端作为服务方法的移动应用程序的某种逻辑
- en: Single-page applications
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序
- en: Chatbots
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天机器人
- en: 'On the other hand, serverless architectures are not suitable for the following
    scenarios:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，无服务器架构不适用于以下情况：
- en: Long-running processes where huge amounts of resources (such as CPU and memory)
    are required
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要大量资源（如CPU和内存）的长时间运行的进程
- en: Any blocking processes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何阻塞进程
- en: Adopting serverless architectures for SPA
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用无服务器架构为SPA提供支持
- en: '**Single-page applications (SPAs)** provide one of the most suitable scenarios
    for adopting a serverless architecture approach. After all, they do not involve
    much-coded business logic, and they mainly serve and consume content provided
    by services deployed somewhere else.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用程序（SPA）**为采用无服务器架构方法提供了最适合的场景之一。毕竟，它们不涉及太多编码的业务逻辑，它们主要提供和消费由其他地方部署的服务提供的内容。'
- en: 'For example, suppose that we need to build an application to send the World
    Cup results to users. In this example, we will need to address the following requirements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要构建一个应用程序来向用户发送世界杯比赛结果。在这个例子中，我们需要满足以下要求：
- en: Authentication
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Data storage
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储
- en: Notification mechanisms
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知机制
- en: 'Using a serverless architecture approach, these requirements can be addressed
    by the following service providers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 采用无服务器架构方法，这些要求可以由以下服务提供商解决：
- en: '**Authentication**: Google OAuth'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：Google OAuth'
- en: '**Data** **storage**: Google Firebase'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：Google Firebase'
- en: '**Notification** **mechanisms**:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知机制**：'
- en: SMS, using Twilio
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短信，使用Twilio
- en: Email, using SparkPost
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件，使用SparkPost
- en: 'The following diagram illustrates how to use the preceding services (Google
    OAuth, Firebase, Twilo, and SparkPost) as parts of an application:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了如何将前述服务（Google OAuth、Firebase、Twilo和SparkPost）作为应用程序的一部分使用：
- en: '![](img/72855d45-d8aa-4459-aed9-b2b8d8f7c805.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72855d45-d8aa-4459-aed9-b2b8d8f7c805.png)'
- en: Integrating different third-party applications
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 集成不同的第三方应用程序
- en: The preceding diagram shows some of the most well-known service providers, but
    there are a lot of other options available on the internet.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了一些最知名的服务提供商，但在互联网上还有很多其他选择。
- en: One of the benefits of the preceding services is that all of them provide an
    SDK, or library, that can be used directly from an SPA, including common JavaScript
    libraries, such as Angular.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前述服务的一个好处是它们都提供了一个可以直接从SPA中使用的SDK或库，包括常见的JavaScript库，如Angular。
- en: Implementing FaaS with Spring Cloud Functions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Functions实现FaaS
- en: Under the umbrella of Spring projects, you will find the Spring Cloud Function
    project ([https://cloud.spring.io/spring-cloud-function/](https://cloud.spring.io/spring-cloud-function/)),
    which is designed to implement applications using a serverless architecture model.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring项目的支持下，您会发现Spring Cloud Function项目（[https://cloud.spring.io/spring-cloud-function/](https://cloud.spring.io/spring-cloud-function/)），它旨在使用无服务器架构模型实现应用程序。
- en: Using Spring Cloud Function, we can code functions that can be launched on different
    cloud providers that support FaaS. There's no need to learn something new from
    scratch, because all of the core concepts and main features of Spring Framework,
    such as autoconfiguration, dependency injection, and built-in metrics, are applied
    in the same way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Function，我们可以编写可以在支持FaaS的不同云提供商上启动的函数。无需从头学习新东西，因为Spring Framework的所有核心概念和主要功能，如自动配置、依赖注入和内置指标，都以相同的方式应用。
- en: Once a function has been coded, it can be deployed as a web endpoint, a stream
    processor, or simple tasks that are triggered by certain events or via a scheduler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数编码完成，它可以部署为Web端点、流处理器，或者简单的任务，这些任务由特定事件触发或通过调度程序触发。
- en: 'Looking at an example of an SPA, we can implement an application using third-party
    services, the existing REST API, and custom functions. The following diagram illustrates
    how an application can be created by using all of the previously mentioned options:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SPA的一个例子，我们可以使用第三方服务、现有的REST API和自定义函数来实现一个应用程序。以下图表说明了如何使用前面提到的所有选项来创建一个应用程序：
- en: '![](img/b25759bc-4d9f-4662-8f0a-5eb4b4059b00.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b25759bc-4d9f-4662-8f0a-5eb4b4059b00.png)'
- en: Integrating FaaS in applications
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将FaaS集成到应用程序中
- en: 'Let''s review how the components in the preceding diagram work:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看前面图表中的组件是如何工作的：
- en: Authentication is provided by a third-party service
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证由第三方服务提供
- en: The application uses the business logic that resides in the REST API
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序使用驻留在REST API中的业务逻辑
- en: A custom function can be used as a part of the SPA
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义函数可以作为SPA的一部分使用
- en: 'The following diagram illustrates how a function works:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了函数的工作原理：
- en: '![](img/031689ad-d967-430b-ba3a-5fb17771f1a2.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/031689ad-d967-430b-ba3a-5fb17771f1a2.png)'
- en: Function as a service
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数即服务
- en: 'Let''s review each part of the diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾图表的每个部分：
- en: Functions provide a way to use an event-driven programming model.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数提供了一种使用事件驱动编程模型的方式。
- en: We can scale infinitely, in a way that is transparent to developers. This scale
    will be handled by the platform that we use to deploy the function.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以以对开发人员透明的方式进行无限扩展。这种扩展将由我们用来部署函数的平台处理。
- en: Finally, we only pay for the time and resources consumed by the functions during
    their execution.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们只需支付函数在执行过程中消耗的时间和资源。
- en: Functions with Spring
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring的函数
- en: 'Spring Cloud Function brings us four main features, described in detail in
    the official documentation ([https://github.com/spring-cloud/spring-cloud-function](https://github.com/spring-cloud/spring-cloud-function)),
    that are worth mentioning here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Function为我们带来了四个主要功能，详细描述在官方文档中（[https://github.com/spring-cloud/spring-cloud-function](https://github.com/spring-cloud/spring-cloud-function)），这里值得一提：
- en: It provides the ability to wrap the `@Beans` type of function, consumer, and
    supplier. This makes it possible to expose functionalities as HTTP endpoints and
    stream messaging via listeners or publishers, with a message broker such as RabbitMQ,
    ActiveMQ, or Kafka.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了包装`@Beans`类型的函数、消费者和供应商的能力。这使得可以将功能公开为HTTP端点，并通过监听器或发布者进行流消息传递，使用消息代理如RabbitMQ、ActiveMQ或Kafka。
- en: It provides compiled strings, which will be wrapped as function bodies.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了编译的字符串，这些字符串将被包装为函数体。
- en: We can deploy a JAR file with our function, with an isolated classloader that
    will run on a single Java virtual machine.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以部署一个带有我们的函数的JAR文件，带有一个独立的类加载器，它将在单个Java虚拟机上运行。
- en: 'It provides adaptors for different cloud providers that support serverless
    architecture, such as the following:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为支持无服务器架构的不同云提供商提供适配器，例如以下：
- en: AWS Lambda
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: Open Whisk
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Open Whisk
- en: Azure
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure
- en: Coding the example
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写示例
- en: 'Now, we will create a function that masks bank account numbers. Let''s start
    by creating a new Spring Boot application from scratch, using the Spring Initializr
    website ([https://start.spring.io](https://start.spring.io)):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个掩码银行帐户号码的函数。让我们从头开始创建一个新的Spring Boot应用程序，使用Spring Initializr网站（[https://start.spring.io](https://start.spring.io)）：
- en: '![](img/5619b314-f7dd-441d-8b7e-58b911dac1ea.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5619b314-f7dd-441d-8b7e-58b911dac1ea.png)'
- en: Spring Initializr website
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr网站
- en: 'At the moment, there''s no need to include additional dependencies as a part
    of the project. The project structure is pretty simple, and it will look as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，作为项目的一部分，不需要包含额外的依赖项。项目结构非常简单，如下所示：
- en: '![](img/a3436649-226c-4e1e-81d8-212a23d10aae.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3436649-226c-4e1e-81d8-212a23d10aae.png)'
- en: 'In order to write functions using Spring, we have to include the Spring Cloud
    Function project as a dependency; first, let''s add some properties to specify
    the version that we are going to use, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Spring编写函数，我们必须将Spring Cloud Function项目作为依赖项包含进来；首先，让我们添加一些属性来指定我们将要使用的版本，如下所示：
- en: '[PRE0]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that we will downgrade the Spring version to 1.5.11 RELEASE, because Spring
    Cloud Function is not currently ready to be used in Spring Boot 2.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将将Spring版本降级为1.5.11 RELEASE，因为Spring Cloud Function目前尚未准备好在Spring Boot
    2中使用。
- en: 'Now, we will add the dependency, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加依赖项，如下所示：
- en: '[PRE1]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we have to add an entry as a part of the dependency management section,
    to allow Maven to automatically resolve all transitive dependencies:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在依赖管理部分中添加一个条目，以便Maven自动解析所有传递依赖项：
- en: '[PRE2]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we will include some plugins that will allow us to wrap the coded
    functions, by adding the following entries as a part of the `pom.xml` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将包含一些插件，这些插件将允许我们通过将以下条目添加为`pom.xml`文件的一部分来包装编码的函数：
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are now ready to implement a function to mask account numbers. Let''s review
    the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好实现一个掩码帐户号码的函数。让我们回顾以下代码片段：
- en: '[PRE4]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `@FunctionScan` annotation is used to allow the Spring Function adapter
    to find the beans that will be deployed as functions in the cloud provider.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FunctionScan`注释用于允许Spring Function适配器找到将部署为云提供商中的函数的bean。'
- en: 'Once the function has been coded, we will register it using the `application.properties`
    file, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数编码完成，我们将使用`application.properties`文件进行注册，如下所示：
- en: '[PRE5]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, it''s time to execute the function locally, using the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用以下步骤在本地执行函数了：
- en: 'Generate the artifact:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成artifact：
- en: '[PRE6]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Execute the generated artifact:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行生成的artifact：
- en: '[PRE7]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should now see output similar to the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该看到类似以下的输出：
- en: '![](img/72edff3a-1d89-4adc-8184-d35a64d8f2b8.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72edff3a-1d89-4adc-8184-d35a64d8f2b8.png)'
- en: Console output
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出
- en: 'Let''s try to execute the function using the following `CURL` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用以下`CURL`命令执行函数：
- en: '[PRE8]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As a result, we will get a masked account number: `****7979`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将获得一个掩码帐户号码：`****7979`。
- en: In the next section, we will review how to deploy the function using different
    cloud providers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾如何使用不同的云提供商部署函数。
- en: In order to create an account on any cloud provider, such as AWS or Azure, you
    will need a credit or debit card, even if the provider offers free tiers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在任何云提供商上创建帐户，例如AWS或Azure，您将需要信用卡或借记卡，即使提供商提供免费套餐也是如此。
- en: Adapters
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: 'Spring Cloud Function provides adapters for different cloud providers, in order
    to deploy the coded business logic using functions. At the moment, there are adapters
    for use with the following cloud providers:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Function为不同的云提供商提供适配器，以便使用函数部署编码的业务逻辑。目前，有以下云提供商的适配器：
- en: AWS Lambda
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: Azure
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure
- en: Apache OpenWhisk
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache OpenWhisk
- en: In the next section, we will cover how these adapters can be used.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何使用这些适配器。
- en: AWS Lambda adapter
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda适配器
- en: This project was designed to allow for deploying applications that use Spring
    Cloud Function to AWS Lambda ([https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目旨在允许部署使用Spring Cloud Function的应用程序到AWS Lambda（[https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)）。
- en: This adapter is a layer over the Spring Cloud Function application that lets
    us deploy our functions into AWS.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该适配器是Spring Cloud Function应用程序的一层，它使我们能够将我们的函数部署到AWS中。
- en: You can find the sources of the project on GitHub, at the following link: [https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws](https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到项目的源代码，链接如下：[https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws](https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws)
- en: 'Before using the AWS Lambda adaptor, we have to add it as a dependency of the
    project. Let''s start by defining some properties inside of the `pom.xml` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用AWS Lambda适配器之前，我们必须将其添加为项目的依赖项。让我们首先在`pom.xml`文件中定义一些属性：
- en: '[PRE9]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we have to add the required dependencies for AWS:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须为AWS添加所需的依赖项：
- en: '[PRE10]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, add it to the `dependency` management section, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将其添加到`dependency`管理部分，如下所示：
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, add it to the `plugin` section, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将其添加到`plugin`部分，如下所示：
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will write a class that will work as an adapter for AWS. This adaptor
    should extend the `SpringBootRequestHandler` class, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个作为AWS适配器工作的类。该适配器应该扩展`SpringBootRequestHandler`类，如下所示：
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the adapter has been written, we will need to modify the previously implemented
    function as a part of the `MaskAccountsApplication.java` file. Here, we are going
    to change the name of the method to `function`, and the input and output of the
    function will be **plain old Java objects (POJOs)** with setters and getters,
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦适配器编写完成，我们将需要修改先前实现的函数作为`MaskAccountsApplication.java`文件的一部分。在这里，我们将更改方法的名称为`function`，函数的输入和输出将是具有setter和getter的**普通旧Java对象（POJOs）**，如下所示：
- en: '[PRE14]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to wrap the coded function, we have to create a JAR file, using the
    following Maven goals:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包装编码的函数，我们必须创建一个JAR文件，使用以下Maven目标：
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the JAR file has been created, we can use the **command-line interface
    (CLI)** provided by AWS ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)) to
    upload the generated JAR file, by running the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦JAR文件创建完成，我们可以使用AWS提供的**命令行界面（CLI）**（[https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)）上传生成的JAR文件，运行以下命令：
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `[USERID]` quote is based on your AWS account and the `[ROLE]` quote. If
    you have any doubts about how to create an AWS account, go to [https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`[USERID]`引用基于您的AWS账户和`[ROLE]`引用。如果您对如何创建AWS账户有任何疑问，请访问[https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/)。 '
- en: For more information about the AWS lambda `create-function`, refer to [https://docs.aws.amazon.com/cli/latest/reference/lambda/create-function.html](https://docs.aws.amazon.com/cli/latest/reference/lambda/create-function.html).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有关AWS lambda `create-function`的更多信息，请参阅[https://docs.aws.amazon.com/cli/latest/reference/lambda/create-function.html](https://docs.aws.amazon.com/cli/latest/reference/lambda/create-function.html)。
- en: If you don't set the credentials of your AWS account, you will get an error
    message that states *unable to locate credentials. *You can configure credentials
    by running the `aws configure` command.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有设置AWS账户的凭据，您将收到一个错误消息，指出*无法找到凭据。*您可以通过运行`aws configure`命令来配置凭据。
- en: Don't forget that you will need to create an AWS user with a a role with permission
    to run AWS Lambda.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，您需要创建一个具有权限运行AWS Lambda的角色的AWS用户。
- en: 'Once the function has been successfully deployed, you will see an output similar
    to the following in the Console:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数成功部署，您将在控制台中看到类似以下的输出：
- en: '![](img/57d6acad-a6b3-4bc5-b37f-4a64f0b6bfb8.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57d6acad-a6b3-4bc5-b37f-4a64f0b6bfb8.png)'
- en: Output processing
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 输出处理
- en: 'The recently deployed function will now be listed in the AWS Lambda console,
    as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最近部署的函数现在将在AWS Lambda控制台中列出，如下所示：
- en: '![](img/497b329e-d515-4d71-bfa6-988174f78986.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/497b329e-d515-4d71-bfa6-988174f78986.png)'
- en: AWS Lambda console
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda控制台
- en: If you don't see the recently deployed function in the web console, you must
    review the location where your function was created. In the example, we use the
    `us-east-1` region, which means that the function was deployed in North Virginia.
    You can check this value next to your name, at the top of the AWS Lambda console.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Web控制台中看不到最近部署的函数，则必须检查创建函数的位置。在本例中，我们使用`us-east-1`地区，这意味着函数部署在北弗吉尼亚。您可以在AWS
    Lambda控制台顶部的名称旁边检查此值。
- en: 'Finally, we are going to test our results in the AWS Lambda console. In the
    Test section, create some input with the value to mask, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在AWS Lambda控制台中测试我们的结果。在测试部分，创建一些输入以进行蒙版处理，如下所示：
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The expected result is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果如下：
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the AWS console, you will see the following results:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS控制台中，您将看到以下结果：
- en: '![](img/94c8f09d-15a3-4f65-a962-5996869afc54.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94c8f09d-15a3-4f65-a962-5996869afc54.png)'
- en: AWS console test result for the maskAccount function
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: maskAccount函数的AWS控制台测试结果
- en: Azure adapter
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure适配器
- en: In this section, we will review how to deploy the previously coded function
    to Azure, which is a cloud provider supported by Microsoft. Azure supports functions
    by using Microsoft Azure Functions ([https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾如何将先前编码的函数部署到Azure，这是Microsoft支持的云提供商。Azure通过使用Microsoft Azure Functions（[https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)）支持函数。
- en: The Azure adapter is a layer coded over the Spring Cloud Function project. You can
    find the source of the project on GitHub ([https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure](https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure)).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Azure适配器是在Spring Cloud Function项目上编写的一层。您可以在GitHub上找到该项目的源代码（[https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure](https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure)）。
- en: 'Let''s start by adding the following properties as a part of the `pom.xml`
    file, in the properties section:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将以下属性添加为`pom.xml`文件的一部分，在属性部分：
- en: '[PRE19]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s add the required dependencies for this adapter, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加此适配器所需的依赖项，如下所示：
- en: '[PRE20]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we will add some plugins to allow the adapter to work, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一些插件以允许适配器工作，如下所示：
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we will create an adapter that should extend from the `AzureSpringBootRequestHandler`
    class. The extended class will provide us with the input and output types that
    enable Azure functions to inspect the class and perform any JSON conversion to
    consume/produce data:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个适配器，该适配器应该扩展自`AzureSpringBootRequestHandler`类。扩展类将为我们提供输入和输出类型，使Azure函数能够检查类并执行任何JSON转换以消耗/生成数据：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will modify the coded function that resides in the `MaskAccountsApplication.java`
    file; we will change the input and output of the function, in order to use a plain
    old Java object with setters and getters:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改`MaskAccountsApplication.java`文件中的编码函数；我们将更改函数的输入和输出，以便使用具有setter和getter的普通旧Java对象：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then we have to add a JSON configuration for Azure tooling, so we are going
    to create a JSON file named `function.json`, in a new folder behind the `src/main`
    folder, with the name of the function (`maskAccount`). This file will be used
    to let Azure know about the function that we want to deploy, by specifying the Java
    class that will be used as the entry point. The `src` folder should look as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须为Azure工具创建一个JSON配置，因此我们将在`src/main`文件夹后面的新文件夹中创建一个名为`function.json`的JSON文件，文件名为函数（`maskAccount`）。此文件将用于让Azure了解我们要部署的函数，通过指定将用作入口点的Java类。`src`文件夹应如下所示：
- en: '![](img/7d28f945-e2ae-4bfe-be18-6615a4c454bc.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d28f945-e2ae-4bfe-be18-6615a4c454bc.png)'
- en: 'The content of the `function.json` file will be as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`function.json`文件的内容将如下所示：'
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The JSON files can be created with the Maven plugin for a non-Spring function,
    but the tooling doesn't work with the current version of the adapter.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Maven插件为非Spring函数创建JSON文件，但是该工具与当前版本的适配器不兼容。
- en: Before generating the artifact that will be deployed, we have to create an `assembly`
    file, which is required by the Azure Maven plugin that we are using.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成将要部署的构件之前，我们必须创建一个`assembly`文件，这是我们正在使用的Azure Maven插件所需的。
- en: 'The `assembly` file should be placed in the `src/assembly` directory; the file
    will be named `azure.xml`, and will include the following content:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`assembly`文件应放在`src/assembly`目录中；文件将被命名为`azure.xml`，并包含以下内容：'
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, the JAR file can be created by using the following Maven goals:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用以下Maven目标创建JAR文件：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The function can be deployed locally for testing purposes, running the JAR
    file as a regular Java application by using the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可以在本地部署进行测试，通过使用以下命令将JAR文件作为常规Java应用程序运行：
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will then see that the application is running, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将看到应用程序正在运行，如下所示：
- en: '![](img/fe28fac1-dd85-46d3-9921-855ee63b06f2.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe28fac1-dd85-46d3-9921-855ee63b06f2.png)'
- en: The output of the Spring application, running locally
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本地运行的Spring应用程序的输出
- en: 'Let''s try out the function using the following `curl` command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用以下`curl`命令来测试该功能：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will see the following output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](img/1bec9055-4f45-4f7b-aaf2-a005b7643f36.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bec9055-4f45-4f7b-aaf2-a005b7643f36.png)'
- en: Alternatively, we can deploy our function to Azure using Azure Functions Core
    Tools.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用Azure Functions Core Tools将我们的函数部署到Azure。
- en: 'To do so, first, you have to install all of the required tools using the information
    provided at [https://github.com/azure/azure-functions-core-tools#installing](https://github.com/azure/azure-functions-core-tools#installing).
    Once the required tools have been installed, you can log in to Azure using the
    following command in your Terminal:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，首先，您必须使用提供在[https://github.com/azure/azure-functions-core-tools#installing](https://github.com/azure/azure-functions-core-tools#installing)上的信息安装所有所需的工具。安装了所需的工具后，您可以使用终端中的以下命令登录到Azure：
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After you have entered your credentials, you will see the following output on
    the console:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入了您的凭据之后，您将在控制台上看到以下输出：
- en: '![](img/683acc84-c48f-4b65-a0c9-4ea33ab015eb.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/683acc84-c48f-4b65-a0c9-4ea33ab015eb.png)'
- en: 'Deploying the coded function to Azure is pretty simple; you only have to execute
    the following Maven:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将编码的函数部署到Azure非常简单；您只需执行以下Maven命令：
- en: '[PRE30]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, you can try out the deployed function using the following `curl` command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下`curl`命令尝试部署的函数：
- en: '[PRE31]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `<azure-function-url-from-the-log>` is the URL that you will get after
    running the `mvn azure-functions:deploy` command. For example, in the following
    screenshot, you can see the `https://function-mask-account-azure.azurewebsites.net/` URL:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`<azure-function-url-from-the-log>`是在运行`mvn azure-functions:deploy`命令后获得的URL。例如，在以下屏幕截图中，您可以看到`https://function-mask-account-azure.azurewebsites.net/`URL：'
- en: '![](img/c3e9e981-a55c-4bd2-9b70-7461ebc86e42.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3e9e981-a55c-4bd2-9b70-7461ebc86e42.png)'
- en: 'After executing the `curl` command, the output received will be as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`curl`命令后，收到的输出将如下所示：
- en: '![](img/6028e45a-7c53-484f-abf8-a551e65a7c10.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6028e45a-7c53-484f-abf8-a551e65a7c10.png)'
- en: Output processing
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输出处理
- en: We can also test the same function on the Azure Functions console, just as we
    did with AWS Lambda.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在Azure Functions控制台上测试相同的函数，就像我们在AWS Lambda上做的那样。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the concepts behind serverless architecture. You
    learned how functions can be implemented using Spring Cloud Functions, and we
    reviewed the adapters that can be used to deploy the functions in different cloud
    providers, such as AWS Lambda and Microsoft Azure Functions.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了无服务器架构背后的概念。您了解了如何使用Spring Cloud Functions实现函数，并且我们回顾了可以用于在不同云提供商（如AWS
    Lambda和Microsoft Azure Functions）部署函数的适配器。
- en: In the next chapter, we will describe what containers are, and how you can use
    them to containerize applications.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述容器是什么，以及您如何使用它们来容器化应用程序。
