- en: Security of Enterprise Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业架构安全
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下食谱：
- en: Domain protection with authentication
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用认证进行域保护
- en: Granting rights through authorization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过授权授予权利
- en: Protecting data confidentiality and integrity with SSL/TLS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSL/TLS保护数据机密性和完整性
- en: Using declarative security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声明式安全
- en: Using programmatic security
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用程序化安全
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Security** is surely one of the hottest topics of all time in the software
    industry, and there''s no reason for that to change any time soon. Actually, it
    will probably become even hotter as time goes on.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全**无疑是软件行业有史以来最热门的话题之一，而且没有理由认为这种情况会很快改变。实际上，随着时间的推移，它可能会变得更加热门。'
- en: With all your data being streamed through the cloud, passing through uncountable
    servers, links, databases, sessions, devices, and so on, what you would expect,
    at least, is that it is well-protected, secured, and that its integrity is kept.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有数据都通过云传输，经过无数的服务器、链接、数据库、会话、设备等等，您至少会期望它得到良好的保护、安全，并且其完整性得到保持。
- en: Now, finally, Java EE has its own Security API, with Soteria being its reference
    implementation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，Java EE 有它自己的安全API，Soteria是其参考实现。
- en: Security is a subject worthy of dozens of books; that's a fact. But this chapter
    will cover some common use cases that you may come across in your daily projects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个值得数十本书讨论的主题；这是一个事实。但本章将涵盖一些您可能在日常项目中遇到的常见用例。
- en: Domain protection with authentication
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用认证进行域保护
- en: Authentication is whatever process, task, and/or policy is used to define who
    can access your domain. It's like, for example, a badge that you use to access
    your office.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是用于定义谁可以访问您的域的任何过程、任务和/或策略。例如，它就像您用来进入办公室的徽章。
- en: In applications, the most common use of authentication is to allow access to
    your domain to users who are already registered.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，认证最常见的使用是允许已注册的用户访问您的域。
- en: This recipe will show you how to use a simple code and configuration to control
    who can and who cannot access some of the resources of your application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将向您展示如何使用简单的代码和配置来控制谁可以访问以及谁不能访问您应用程序的一些资源。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We begin by adding our dependency:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加我们的依赖项：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'First, we do some configuration in the `web.xml` file:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在`web.xml`文件中进行一些配置：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we create a servlet to deal with our user access:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个servlet来处理我们的用户访问：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And finally, we create the class that will define our authentication policy:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个将定义我们的认证策略的类：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you run this project in a Java EE 8-compatible server, you should use this
    URL (assuming that you are running locally. If not, make the appropriate changes):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个Java EE 8兼容的服务器上运行此项目，您应该使用此URL（假设您是在本地运行。如果不是，请进行适当的更改）：
- en: '`http://localhost:8080/ch05-authentication/UserAuthenticationServlet?name=user`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-authentication/UserAuthenticationServlet?name=user`'
- en: 'This should result in a page with these messages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个包含以下信息的页面：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Try making any change to the `name` parameter, such as this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对`name`参数进行任何更改，例如这样：
- en: '`http://localhost:8080/ch05-authentication/UserAuthenticationServlet?name=anotheruser`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-authentication/UserAuthenticationServlet?name=anotheruser`'
- en: 'Then the result will be as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，结果将如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's split up the code shown earlier, so that we can better understand what's
    happening.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把之前显示的代码分开，这样我们可以更好地理解正在发生的事情。
- en: 'In the `web.xml` file, we are creating a security constraint:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web.xml`文件中，我们创建一个安全约束：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''re defining a resource inside it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在它内部定义一个资源：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And we''re defining an authorization policy. In this case, it''s a role:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一个授权策略。在这种情况下，它是一个角色：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we have `UserAuthenticationServlet`. We should pay attention to this annotation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有`UserAuthenticationServlet`。我们应该注意这个注解：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It defines which roles are part of the context of this particular servlet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了哪些角色是特定servlet上下文的一部分。
- en: 'Another important actor in this scene is this one:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景中的另一个重要角色是这个：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we are asking the server to give us a security context so that we can
    use it for our purpose. It will make sense in a minute.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在请求服务器给我们一个安全上下文，以便我们可以用它来实现我们的目的。这将在一分钟内变得有意义。
- en: 'Then, if the `name` parameter is filled, we reach this line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果`name`参数被填充，我们将到达这一行：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will ask the Java EE server to process an authentication. But...based on
    what? That's where our `HttpAuthenticationMechanism` implementation comes in.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求Java EE服务器处理一个认证。但是...基于什么？这就是我们的`HttpAuthenticationMechanism`实现发挥作用的地方。
- en: 'As the preceding code created `CallerOnlyCredential`, our authentication mechanism
    will be based on it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码创建了`CallerOnlyCredential`，因此我们的认证机制将基于它：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And once we have a `credential` instance, we can check if the user "exists":'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个`credential`实例，我们可以检查用户“是否存在”：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As an example, we have just compared the names, but in a real case you could
    search your database, an LDAP server, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们刚刚比较了名称，但在实际情况下，你可以搜索数据库、LDAP服务器等。
- en: 'If the user exists, we proceed with the authentication based on some rules:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户存在，我们将根据一些规则进行认证。
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, we have said that the user has access to `"role1"` and `"role2"`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们表示用户可以访问`"role1"`和`"role2"`。
- en: 'Once the authentication is done, it comes back to the servlet and uses the
    result to finish the process:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 认证完成后，它将返回到servlet并使用结果来完成过程：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, this code will print `true` for `"role1"` and `"role2"`, and `false` for
    `"role3"`. Because `"/authServlet"` is allowed for `"role1"`, the user will have
    access to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这段代码将为`"role1"`和`"role2"`打印`true`，而为`"role3"`打印`false`。因为`"/authServlet"`对`"role1"`是允许的，所以用户将能够访问它。
- en: See also
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The full source code of this recipe is available at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-authentication](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-authentication).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱的完整源代码可在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-authentication](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-authentication)找到。
- en: Granting rights through authorization
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过授权授予权限
- en: If authentication is the way to define who can access a particular resource,
    authorization is the way to define what a user can and cannot do once they have
    access to the domain.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证是定义谁可以访问特定资源的方式，那么授权就是定义用户一旦获得域访问权限后可以做什么和不能做什么的方式。
- en: It's like allowing someone to get into your house, but denying them access to
    the remote control for your TV (very important access, by the way). Or, allowing
    access to the remote control, but denying access to adult channels.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像允许某人进入你的房子，但拒绝他们访问你的电视遥控器（顺便说一句，这是一个非常重要的访问权限）。或者，允许访问遥控器，但拒绝访问成人频道。
- en: One way to do it is through profiles, and that's what we are going to do in
    this recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现方式是通过配置文件，这正是我们将在这个菜谱中要做的。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start by adding the dependency:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加依赖项：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'First, we define some roles in a separate class so that we can reuse it:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在一个单独的类中定义一些角色，以便我们可以重用它：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we define some things that the application''s users can do:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一些应用程序用户可以执行的操作：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s create an interface for executable tasks:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个用于可执行任务的接口：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And let''s create another for the roles that will execute them:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后让我们为执行它们的角色创建另一个：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For each role, we create an executor. It will be like an environment that owns
    the rights of that role:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个角色，我们创建一个执行器。它将像是一个拥有该角色权利的环境：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then we implement `HttpAuthenticationMechanism`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们实现`HttpAuthenticationMechanism`：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And finally, we create the servlet that will manage all these resources:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个管理所有这些资源的servlet：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To try this code out, you can run these URLs:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，你可以运行以下URL：
- en: '`http://localhost:8080/ch05-authorization/UserAuthorizationServlet?name=user1`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-authorization/UserAuthorizationServlet?name=user1`'
- en: '`http://localhost:8080/ch05-authorization/UserAuthorizationServlet?name=user2`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-authorization/UserAuthorizationServlet?name=user2`'
- en: '`http://localhost:8080/ch05-authorization/UserAuthorizationServlet?name=user3`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-authorization/UserAuthorizationServlet?name=user3`'
- en: 'The result for `user1`, for example, will be like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`user1`的结果将如下所示：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And if you try with a user that doesn''t exist, the result will be like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用一个不存在的用户，结果将如下所示：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Well, we have a lot of things happening here! Let's begin with our `UserActivity`
    class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里发生了很多事情！让我们从我们的`UserActivity`类开始。
- en: 'We used the `@RolesAllowed` annotation to define the role that can access each
    method of the class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@RolesAllowed`注解来定义可以访问该类每个方法的角色：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can add more than one role inside the annotation (it's an array).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在注解内添加多个角色（它是一个数组）。
- en: 'We also had two others interesting annotations, `@PermitAll` and `@DenyAll`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个其他有趣的注解，`@PermitAll`和`@DenyAll`：
- en: The `@PermitAll` annotation allows anyone to access the method, even without
    any authentication.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PermitAll` 注解允许任何人访问该方法，甚至无需任何认证。'
- en: The `@DenyAll` annotation denies everyone access to the method, even authenticated
    users with the highest privileges.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DenyAll` 注解拒绝所有人访问该方法，即使是拥有最高权限的已认证用户。'
- en: 'Then we have what we called executors:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有了我们所说的执行器：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We used the `@RunAs` annotation at the class level, which means that this class
    inherits all the privileges of the defined role (in this case, `"role1"`). It
    means that every single method of this class will have the `"role1"` privileges.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类级别使用了 `@RunAs` 注解，这意味着这个类继承了定义的角色（在这种情况下，`"role1"`）的所有权限。这意味着这个类的每一个方法都将拥有
    `"role1"` 权限。
- en: 'Now, looking at `UserAuthorizationServlet`, right at the beginning we have
    an important object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看 `UserAuthorizationServlet`，在开始的地方有一个重要的对象：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we are asking the server to give us a security context instance so that
    we can use it for authentication purposes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求服务器给我们一个安全上下文实例，以便我们可以用它进行认证。
- en: 'Then, if the `name` parameter is filled, we reach this line:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果 `name` 参数被填写，我们就到达这一行：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will ask the Java EE server to process an authentication. That's where
    our `HttpAuthenticationMechanism` implementation comes in.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求Java EE服务器处理认证。这就是我们的 `HttpAuthenticationMechanism` 实现发挥作用的地方。
- en: 'As the preceding code created `CallerOnlyCredential`, our authentication mechanism
    will be based on it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的代码创建了 `CallerOnlyCredential`，我们的认证机制将基于它：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And once we have a credential instance, we can check if the user exists:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了凭证实例，我们可以检查用户是否存在：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So we are saying that `"user1"` has access to `"role1"`, `"user2"` to `"role2"`,
    and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们说 `"user1"` 可以访问 `"role1"`，`"user2"` 可以访问 `"role2"`，依此类推。
- en: 'Once the user role is defined, we are back to the servlet and can choose which
    environment (executor) will be used:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了用户角色，我们就回到了servlet，并可以选择使用哪个环境（执行器）：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And then we try all the methods of the `UserActivity` class. Only the methods
    allowed for that specific role will be executed; the others will fall into an
    exception, except for the `@PermitAll` method, which will run anyway, and `@DenyAll`,
    which will not run anyway.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们尝试 `UserActivity` 类的所有方法。只有允许该特定角色的方法将被执行；其他方法将抛出异常，除了 `@PermitAll` 方法，它无论如何都会运行，以及
    `@DenyAll`，它无论如何都不会运行。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-authorization](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-authorization).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-authorization](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-authorization)查看这个菜谱的完整源代码。
- en: Protecting data confidentiality and integrity with SSL/TLS
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SSL/TLS保护数据机密性和完整性
- en: Security also means protecting the transportation of your data, and for this
    purpose we have the most popular method, which is called the **Secure Sockets
    Layer** (**SSL**).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性也意味着保护你的数据传输，为此我们有了最流行的方法，被称为**安全套接字层**（**SSL**）。
- en: '**Transport Layer Security**, or **TLS**, is the newest version of SSL. So,
    we have SSL 3.0 and TLS 1.0 as the protocols supported by GlassFish 5.0.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输层安全性**，或**TLS**，是SSL的最新版本。因此，GlassFish 5.0支持SSL 3.0和TLS 1.0作为协议。'
- en: This recipe will show you how to enable GlassFish 5.0 to work properly with
    SSL. All Java EE servers have their own way of doing this.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向你展示如何使GlassFish 5.0能够正确地与SSL一起工作。所有Java EE服务器都有自己实现这一点的独特方式。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To enable SSL in GlassFish, you need to configure an HTTP listener for SSL.
    All you need to do is this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要在GlassFish中启用SSL，你需要配置SSL HTTP监听器。你只需要做以下这些：
- en: Make sure GlassFish is up and running.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保GlassFish正在运行。
- en: Use the `create-ssl` command to create your HTTP listener for SSL.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `create-ssl` 命令创建你的SSL HTTP监听器。
- en: Restart the GlassFish server.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动GlassFish服务器。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To do this task, you need to access the GlassFish remote **command-line interface**
    (**CLI**). You can do it by going to this path:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成这个任务，你需要访问GlassFish的远程**命令行界面**（**CLI**）。你可以通过访问以下路径来完成：
- en: '`$GLASSFISH_HOME/bin`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`$GLASSFISH_HOME/bin`'
- en: 'Once you are there, execute the following command:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你到了那里，执行以下命令：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When the prompt is ready, you can execute this command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示准备好后，你可以执行这个命令：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then you can restart the server and your `http-listener-1` will work with SSL.
    If you want to drop SSL from the listener, just go back to the prompt and execute
    this command:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后您可以重新启动服务器，您的`http-listener-1`将使用SSL工作。如果您想从监听器中删除SSL，只需回到提示并执行此命令：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With SSL, both the client and the server encrypt data before sending it, and
    decrypt data upon receiving it. When a browser opens a secured website (using
    HTTPS), something happens that is called a **handshake**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSL，客户端和服务器在发送数据之前加密数据，在接收数据时解密数据。当浏览器打开一个加密网站（使用HTTPS）时，会发生一个称为**握手**的过程。
- en: In the handshake, the browser asks the server  for a session; the server answers
    by sending a certificate and the public key. The browser validates the certificate
    and, if it is valid, generates an unique session key, encrypts it with the server
    public key, and sends it back to the server. Once the server receives the session
    key, it decrypts it with its private key.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在握手过程中，浏览器向服务器请求一个会话；服务器通过发送证书和公钥来回答。浏览器验证证书，如果有效，则生成一个唯一的会话密钥，使用服务器公钥加密它，并将其发送回服务器。一旦服务器收到会话密钥，它就会使用其私钥解密它。
- en: Now, both client and server, and only them, have a copy of the session key and
    can ensure that the communication is secure.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端和服务器，只有它们，拥有会话密钥的副本，并可以确保通信是安全的。
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's strongly recommended that you use a certificate from a **Certification
    Authority** (**CA**) instead of a self-created certificate like we did in this
    recipe.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您使用来自**认证机构**（**CA**）的证书，而不是像我们在本配方中那样使用自签名证书。
- en: You can check out [https://letsencrypt.org](https://letsencrypt.org), where
    you can get your free certificate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看[https://letsencrypt.org](https://letsencrypt.org)，在那里您可以获取免费的证书。
- en: The process of using it is the same; you will just change the value in the `--certname` parameter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它的过程是相同的；你只需更改`--certname`参数的值。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For detailed information about all the security aspects and configuration for
    GlassFish 5, check out [https://javaee.github.io/glassfish/doc/5.0/security-guide.pdf](https://javaee.github.io/glassfish/doc/5.0/security-guide.pdf).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解关于GlassFish 5所有安全方面和配置的详细信息，请查看[https://javaee.github.io/glassfish/doc/5.0/security-guide.pdf](https://javaee.github.io/glassfish/doc/5.0/security-guide.pdf)。
- en: Using declarative security
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用声明式安全
- en: 'When building your application''s security features, you can basically use
    two approaches: **programmatic security** and **declarative security**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序的安全功能时，你可以基本上使用两种方法：**编程安全**和**声明式安全**：
- en: The programmatic approach is when you define the security policy of your application
    using code.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程方法是指您使用代码定义应用程序的安全策略。
- en: The declarative approach is when you do it by declaring the policies and then
    applying them accordingly.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式方法是指通过声明策略然后相应地应用它们来执行。
- en: This recipe will show you the declarative approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向你展示声明式方法。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start by adding the dependency:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加依赖项开始：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create a list of roles for our application:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的应用程序创建一个角色列表：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then we create a list of tasks that could be performed by only one of the roles, one
    task that everyone can do, and another task that no one can do:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个只能由一个角色执行的任务列表，一个每个人都可以执行的任务，以及一个没有人可以执行的任务：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we create an environment for both the `USER` and `ADMIN` roles to do their
    stuff:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为`USER`和`ADMIN`角色创建一个环境，以便它们执行各自的操作：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we implement `HttpAuthenticationMechanism`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后我们实现`HttpAuthenticationMechanism`:'
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And finally, we create one servlet for each role (`USER` and `ADMIN`):'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为每个角色（`USER`和`ADMIN`）创建一个servlet：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Looking at `UserServlet` (which applies to the `USER` role), we first see the
    authentication step:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`UserServlet`（适用于`USER`角色），我们首先看到认证步骤：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For example, we''ve used the role name as a username because if we look at
    the `AuthenticationMechanism` class (implementing `HttpAuthenticationMechanism`),
    we see it doing all the hard work of authenticating and assigning the right role
    to the user:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用角色名称作为用户名，因为如果我们查看`AuthenticationMechanism`类（实现`HttpAuthenticationMechanism`），我们会看到它在执行所有认证和为用户分配正确角色的艰苦工作：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And back to our `UserServlet`, now that the user has the proper role assigned,
    it is just a matter of what they can and cannot do:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后回到我们的`UserServlet`，现在用户已经分配了适当的角色，他们能做什么以及不能做什么就只是个问题了：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And also, we try the tasks that everyone and no one can perform:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还尝试了每个人都可以执行以及没有人可以执行的任务：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `AdminServlet` class goes through exactly the same steps using an `AdminExecutor`
    environment, so we will omit it for the sake of space.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdminServlet`类使用`AdminExecutor`环境执行完全相同的步骤，因此为了节省空间，我们将省略它。'
- en: 'To try out this code, just run it on a Java EE 8-compatible server using these
    URLs:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，只需在Java EE 8兼容的服务器上使用以下URL运行它：
- en: '`http://localhost:8080/ch05-declarative/AdminServlet`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-declarative/AdminServlet`'
- en: '`http://localhost:8080/ch05-declarative/UserServlet`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-declarative/UserServlet`'
- en: 'The result example for `AdminServlet` will be like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdminServlet`的结果示例将如下所示：'
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-declarative](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-declarative).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-declarative](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-declarative)查看此菜谱的完整源代码。
- en: Using programmatic security
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用程序化安全
- en: We've already seen the declarative approach, so now let's see the programmatic
    approach.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了声明式方法，现在让我们看看程序化方法。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Let''s start by adding the dependency:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加依赖项：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s first define our roles list:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义我们的角色列表：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, let''s define a list of tasks to be done based on the role:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们定义一个基于角色的任务列表：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now let''s implement the `IndentityStore` interface. Here, we define our policy
    for validating the user''s identity:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现`IndentityStore`接口。在这里，我们定义了验证用户身份的策略：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we implement the `HttpAuthenticationMethod` interface:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们实现了`HttpAuthenticationMethod`接口：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And finally, we create the servlet where the user will both authenticate and
    do their stuff:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个servlet，用户将在这里进行身份验证并执行他们的操作：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To try out this code, run it in a Java EE 8-compatible server using these URLs:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，请在Java EE 8兼容的服务器上使用以下URL运行它：
- en: '`http://localhost:8080/ch05-programmatic/OperationServlet?name=user&password=1234`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-programmatic/OperationServlet?name=user&password=1234`'
- en: '`http://localhost:8080/ch05-programmatic/OperationServlet?name=admin&password=1234`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch05-programmatic/OperationServlet?name=admin&password=1234`'
- en: 'An example of an `ADMIN` role''s result is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADMIN`角色的一个示例结果如下：'
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And if you use a wrong name/password pair, you get this result:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用错误的用户名/密码对，您将得到以下结果：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Contrary to the declarative approach (see the previous recipe in this chapter),
    here we are using code to validate the user. We've done it by implementing the
    `IdentityStore` interface.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与声明式方法（参见本章前面的菜谱）相反，这里我们使用代码来验证用户。我们通过实现`IdentityStore`接口来完成它。
- en: 'For example, even though we''ve hardcoded the password, you can use the same
    piece of code to validate the password against a database, LDAP, an external endpoint,
    and many more:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，即使我们已经硬编码了密码，您也可以使用相同的代码片段来验证密码与数据库、LDAP、外部端点等：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Authenticating using `IdentityStore` means just delegating using `HttpAuthenticationMethod`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`IdentityStore`进行身份验证意味着只是通过`HttpAuthenticationMethod`进行委托：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And then, `OperationServlet` will just try an authentication:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`OperationServlet`将尝试进行身份验证：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Based on this, we will define the flow of what will happen next:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们将定义接下来会发生什么流程：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Pay attention! That is your code defining what each role will do.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！这是您定义每个角色将做什么的代码。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code for this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-programmatic](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-programmatic).
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-programmatic](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter05/ch05-programmatic)查看此菜谱的完整源代码。
