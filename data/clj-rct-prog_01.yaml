- en: Chapter 1. What is Reactive Programming?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：什么是响应式编程？
- en: Reactive Programming is both an overloaded term and a broad topic. As such,
    this book will focus on a specific formulation of Reactive Programming called
    **Compositional Event Systems** (**CES**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是一个既复杂又广泛的话题。因此，这本书将专注于响应式编程的一个特定公式，称为**组合事件系统**（**CES**）。
- en: 'Before covering some history and background behind Reactive Programming and
    CES, I would like to open with a working and hopefully compelling example: an
    animation in which we draw a sine wave onto a web page.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍响应式编程和CES的历史和背景之前，我想从一个实际且希望引人入胜的例子开始：一个在网页上绘制正弦波的动画示例。
- en: 'The sine wave is simply the graph representation of the sine function. It is
    a smooth, repetitive oscillation, and at the end of our animation it will look
    like the following screenshot:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦波是正弦函数的图形表示。它是一种平滑、重复的振荡，在动画结束时，它将看起来像以下截图：
- en: '![What is Reactive Programming?](img/00002.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![什么是响应式编程？](img/00002.jpeg)'
- en: 'This example will highlight how CES:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将突出CES：
- en: Urges us to think about *what* we would like to do as opposed to *how*
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调我们应该思考*我们想要做什么*，而不是*如何做*
- en: Encourages small, specific abstractions that can be composed together
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼓励构建小的、具体的抽象，这些抽象可以组合在一起
- en: Produces terse and maintainable code that is easy to change
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成简洁且易于维护的代码，易于更改
- en: 'The core of this program boils down to four lines of ClojureScript:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的核心归结为四行ClojureScript代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Simply by looking at this code it is impossible to determine precisely what
    it does. However, do take the time to read and imagine what it *could* do.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看这段代码，我们无法确切地知道它做什么。然而，请花时间阅读并想象它*可能*做什么。
- en: 'First, we have a variable called `sine-wave`, which represents the 2D coordinates
    we will draw onto the web page. The next line gives us the intuition that `sine-wave`
    is some sort of collection-like abstraction: we use `.take` to retrieve 600 coordinates
    from it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个名为`sine-wave`的变量，它代表我们将绘制到网页上的2D坐标。下一行给出了`sine-wave`是一种类似集合的抽象的直观感觉：我们使用`.take`从其中检索600个坐标。
- en: Finally, we `.subscribe` to this "collection" by passing it a callback. This
    callback will be called for each item in the sine-wave, finally drawing at the
    given *x* and *y* coordinates using the `fill-rect` function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过传递一个回调函数来`.subscribe`到这个“集合”。这个回调函数将为正弦波中的每个项目被调用，最终使用`fill-rect`函数在给定的*x*和*y*坐标处绘制。
- en: 'This is quite a bit to take in for now as we haven''t seen any other code yet—but
    that was the point of this little exercise: even though we know nothing about
    the specifics of this example, we are able to develop an intuition of how it might
    work.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 目前来说，这需要我们吸收很多信息，因为我们还没有看到其他代码——但这就是这个小练习的目的：尽管我们对这个示例的具体细节一无所知，但我们仍然能够发展出对它可能如何工作的直觉。
- en: Let's see what else is necessary to make this snippet animate a sine wave on
    our screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看还需要什么来使这个片段在我们的屏幕上动画化正弦波。
- en: A taste of Reactive Programming
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程的初体验
- en: This example is built in ClojureScript and uses HTML 5 Canvas for rendering
    and RxJS (see [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS))—a
    framework for Reactive Programming in JavaScript.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是用ClojureScript构建的，并使用HTML 5 Canvas进行渲染，以及RxJS（见[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)）——一个JavaScript中的响应式编程框架。
- en: Before we start, keep in mind that we will not go into the details of these
    frameworks yet—that will happen later in this book. This means I'll be asking
    you to take quite a few things at face value, so don't worry if you don't immediately
    grasp how things work. The purpose of this example is to simply get us started
    in the world of Reactive Programming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请记住我们不会深入探讨这些框架的细节——这些将在本书的后面部分进行。这意味着我会要求你们接受相当多的事情，所以如果你没有立即理解事物是如何工作的，请不要担心。这个示例的目的是让我们简单地开始了解响应式编程的世界。
- en: For this project, we will be using Chestnut (see [https://github.com/plexus/chestnut](https://github.com/plexus/chestnut))—a
    leiningen template for ClojureScript that gives us a sample working application
    we can use as a skeleton.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用Chestnut（见[https://github.com/plexus/chestnut](https://github.com/plexus/chestnut)）——一个ClojureScript的leiningen模板，它提供了一个我们可以用作框架的示例工作应用程序。
- en: 'To create our new project, head over to the command line and invoke leiningen
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的新项目，请转到命令行并按照以下方式调用leiningen：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to modify a couple of things in the generated project. Open up
    `sin-wave/resources/index.html` and update it to look like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改生成项目中的几个地方。打开`sin-wave/resources/index.html`并将其更新如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This simply ensures that we import both our application code and RxJS. We haven't
    downloaded RxJS yet so let's do this now. Browse to [https://github.com/Reactive-Extensions/RxJS/blob/master/dist/rx.all.js](https://github.com/Reactive-Extensions/RxJS/blob/master/dist/rx.all.js)
    and save this file to `sin-wave/resources/public`. The previous snippets also
    add an HTML 5 Canvas element onto which we will be drawing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是确保我们导入了我们的应用程序代码和RxJS。我们还没有下载RxJS，所以让我们现在就做。浏览到[https://github.com/Reactive-Extensions/RxJS/blob/master/dist/rx.all.js](https://github.com/Reactive-Extensions/RxJS/blob/master/dist/rx.all.js)并将此文件保存到`sin-wave/resources/public`。前面的代码片段还添加了一个HTML
    5 Canvas元素，我们将在此元素上绘制。
- en: 'Now, open `/src/cljs/sin_wave/core.cljs`. This is where our application code
    will live. You can ignore what is currently there. Make sure you have a clean
    slate like the following one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`/src/cljs/sin_wave/core.cljs`。我们的应用程序代码将在这里。您可以忽略当前的内容。确保您有一个像以下这样的干净画布：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, go back to the command line—under the `sin-wave` folder—and start
    up the following application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到命令行——在`sin-wave`文件夹下——启动以下应用程序：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the previous command finishes, the application will be available at `http://localhost:10555`,
    where you will find a blank, rectangular canvas. We are now ready to begin.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦之前的命令完成，应用程序将在`http://localhost:10555`上可用，在那里您将找到一个空白的长方形画布。我们现在可以开始了。
- en: The main reason we are using the Chestnut template for this example is that
    it performs hot-reloading of our application code via websockets. This means we
    can have the browser and the editor side by side, and as we update our code, we
    will see the results immediately in the browser without having to reload the page.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Chestnut模板的主要原因是为了这个示例，它通过websockets执行我们的应用程序代码的热重载。这意味着我们可以将浏览器和编辑器并排放置，并且在我们更新代码时，我们将在浏览器中立即看到结果，而无需重新加载页面。
- en: 'To validate that this is working, open your web browser''s console so that
    you can see the output of the scripts in the page. Then add this to `/src/cljs/sin_wave/core.cljs`
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这是否正常工作，请打开您的网页浏览器的控制台，以便您可以看到页面中脚本的输出。然后按照以下方式将以下内容添加到`/src/cljs/sin_wave/core.cljs`中：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should have seen the `hello clojurescript` message printed to your browser's
    console. Make sure you have a working environment up to this point as we will
    be relying on this workflow to interactively build our application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经看到了打印到浏览器控制台的`hello clojurescript`消息。请确保您的工作环境正常，因为我们将会依赖这个工作流程来交互式地构建我们的应用程序。
- en: 'It is also a good idea to make sure we clear the canvas every time Chestnut
    reloads our file. This is simple enough to do by adding the following snippet
    to our core namespace:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，确保每次Chestnut重新加载我们的文件时清除画布也是个好主意。通过将以下代码片段添加到我们的核心命名空间中，这很简单：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating time
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建时间
- en: Now that we have a working environment, we can progress with our animation.
    It is probably a good idea to specify how often we would like to have a new animation
    frame.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了正常的工作环境，我们可以继续我们的动画。指定我们希望多久创建一个新动画帧可能是个好主意。
- en: 'This effectively means adding the concept of *time* to our application. You''re
    free to play with different values, but let''s start with a new frame every 10
    milliseconds:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着将*时间*的概念添加到我们的应用程序中。您可以自由地尝试不同的值，但让我们从每10毫秒创建一个新帧开始：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As RxJS is a JavaScript library, we need to use ClojureScript's interoperability
    to call its functions. For convenience, we bind the `interval` function of RxJS
    to a local var. We will use this approach throughout this book when appropriate.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RxJS是一个JavaScript库，我们需要使用ClojureScript的互操作性来调用其函数。为了方便，我们将RxJS的`interval`函数绑定到一个局部变量。在本书中，当适用时，我们将使用这种方法。
- en: 'Next, we create an infinite stream of numbers—starting at 0—that will have
    a new element every 10 milliseconds. Let''s make sure this is working as expected:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个无限数字流——从0开始，每10毫秒有一个新元素。让我们确保这是按预期工作的：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I use the term *stream* very loosely here. It will be defined more precisely
    later in this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里非常宽松地使用*流*这个术语。稍后在本书中将更精确地定义它。
- en: Remember time is infinite, so we use `.take` in order to avoid indefinitely
    printing out numbers to the console.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 记住时间是无限的，所以我们使用`.take`来避免无限期地向控制台打印数字。
- en: 'Our next step is to calculate the 2D coordinate representing a segment of the
    sine wave we can draw. This will be given by the following functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是计算代表正弦波一段的 2D 坐标，我们可以用以下函数来完成：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `sine-coord` function takes an `x` point of our 2D Canvas and calculates
    the `y` point based on the sine of `x`. The constants `100` and `90` simply control
    how tall and sharp the slope should be. As an example, try calculating the sine
    coordinate when `x` is 50:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`sine-coord` 函数接受我们 2D 画布上的一个 `x` 点，并根据 `x` 的正弦值计算 `y` 点。常数 `100` 和 `90` 简单地控制斜率的高度和尖锐程度。例如，尝试计算当
    `x` 为 50 时的正弦坐标：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will be using `time` as the source for the values of `x`. Creating the sine
    wave now is only a matter of combining both `time` and `sine-coord`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `time` 作为 `x` 值的来源。现在创建正弦波只是将 `time` 和 `sine-coord` 结合起来：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Just like `time`, `sine-wave` is an infinite stream. The difference is that
    instead of just integers, we will now have the `x` and `y` coordinates of our
    sine wave, as demonstrated in the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `time` 一样，`sine-wave` 是一个无限流。不同的是，我们现在将拥有正弦波的 `x` 和 `y` 坐标，如下所示：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This brings us to the original code snippet which piqued our interest, alongside
    a function to perform the actual drawing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们回到了最初引起我们兴趣的代码片段，以及一个执行实际绘制的函数：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As this point, we can save the file again and watch as the sine wave we have
    just created gracefully appears on the screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以再次保存文件，并观察我们刚刚创建的正弦波优雅地出现在屏幕上。
- en: More colors
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多颜色
- en: One of the points this example sets out to illustrate is how thinking in terms
    of very simple abstractions and then building more complex ones on top of them
    make for code that is simpler to maintain and easier to modify.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子旨在说明，以非常简单的抽象方式思考，然后在它们之上构建更复杂的抽象，可以使代码更容易维护和修改。
- en: As such, we will now update our animation to draw the sine wave in different
    colors. In this case, we would like to draw the wave in red if the sine of `x`
    is negative and blue otherwise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将更新我们的动画，以不同颜色绘制正弦波。在这种情况下，我们希望当 `x` 的正弦值为负时绘制红色，否则为蓝色。
- en: 'We already have the sine value coming through the `sine-wave` stream, so all
    we need to do is to transform this stream into one that will give us the colors
    according to the preceding criteria:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了通过 `sine-wave` 流传递的正弦值，所以我们只需要将这个流转换成一个会根据先前标准给出颜色的流：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to add the new stream into the main drawing loop—remember
    to comment the previous one so that we don''t end up with multiple waves being
    drawn at the same time:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将新的流添加到主绘制循环中——记得注释掉之前的代码，以免同时绘制多个波：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we save the file, we should see a new sine wave alternating between red
    and blue as the sine of `x` oscillates from –1 to 1.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，我们应该看到一个新正弦波在红色和蓝色之间交替，因为 `x` 的正弦值在 -1 到 1 之间振荡。
- en: Making it reactive
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其变得反应式
- en: As fun as this has been so far, the animation we have created isn't really reactive.
    Sure, it does react to time itself, but that is the very nature of animation.
    As we will later see, Reactive Programming is so called because programs react
    to external inputs such as mouse or network events.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止这很有趣，但我们创建的动画实际上并不是反应式的。当然，它确实对时间本身做出了反应，但这正是动画的本质。正如我们稍后将会看到的，响应式编程之所以被称为响应式编程，是因为程序对外部输入（如鼠标或网络事件）做出反应。
- en: 'We will, therefore, update the animation so that the user is in control of
    when the color switch occurs: the wave will start red and switch to blue when
    the user clicks anywhere within the canvas area. Further clicks will simply alternate
    between red and blue.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将更新动画，让用户控制颜色切换的时间：波将开始为红色，当用户在画布区域内点击时切换到蓝色。进一步的点击将简单地交替在红色和蓝色之间。
- en: 'We start by creating infinite—as per the definition of `time`—streams for our
    color primitives as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建无限流——根据 `time` 的定义——为我们的颜色原语，如下所示：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On their own, `red` and `blue` aren''t that interesting as their values don''t
    change. We can think of them as *constant* streams. They become a lot more interesting
    when combined with another infinite stream that cycles between them based on user
    input:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，`red` 和 `blue` 并不有趣，因为它们的值没有变化。我们可以把它们看作是 *常数* 流。当与另一个无限流结合，该流根据用户输入在它们之间循环时，它们就变得更有趣了：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is our most complex update so far. If you look closely, you will also notice
    that `cycle-colour` is a recursive stream; that is, it is defined in terms of
    itself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们迄今为止最复杂的更新。如果你仔细观察，你也会注意到`cycle-colour`是一个递归流；也就是说，它是根据自身定义的。
- en: 'When we first saw code of this nature, we took a leap of faith in trying to
    understand what it does. After a quick read, however, we realized that `cycle-colour`
    follows closely how we might have *talked* about the problem: we will use red
    until a mouse click occurs, after which we will use blue until another mouse click
    occurs. Then, we start the recursion.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次看到这种代码时，我们尝试理解它所做的事情时，我们做出了一个大胆的假设。然而，在快速阅读之后，我们意识到`cycle-colour`紧密遵循我们可能如何*讨论*问题的方法：我们将使用红色，直到鼠标点击发生，然后我们将使用蓝色，直到另一个鼠标点击发生。然后，我们开始递归。
- en: 'The change to our animation loop is minimal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对动画循环的更改很小：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The purpose of this book is to help you develop the instinct required to model
    problems in the way demonstrated here. After each chapter, more and more of this
    example will make sense. Additionally, a number of frameworks will be used both
    in ClojureScript and Clojure to give you a wide range of tools to choose from.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是帮助你培养出以这种方式建模问题的本能。在每一章之后，越来越多的示例将变得有意义。此外，我们将在ClojureScript和Clojure中使用多个框架，为你提供广泛的选择工具。
- en: Before we move on to that, we must take a little detour and understand how we
    got here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们必须稍微绕个弯，理解我们是如何到达这里的。
- en: Exercise 1.1
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.1
- en: 'Modify the previous example in such a way that the sine wave is drawn using
    all rainbow colors. The drawing loop should look like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 修改之前的示例，以便使用所有彩虹颜色绘制正弦波。绘图循环应如下所示：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Your task is to implement the `rainbow-colours` stream. As everything up until
    now has been very light on explanations, you might choose to come back to this
    exercise later, once we have covered more about CES.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是实现`rainbow-colours`流。由于到目前为止的解释非常少，你可能选择在覆盖更多关于CES的内容之后再回来做这个练习。
- en: The `repeat`, `scan`, and `flatMap` functions may be useful in solving this
    exercise. Be sure to consult RxJs' API at [https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/rx.complete.md](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/rx.complete.md).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`、`scan`和`flatMap`函数可能有助于解决这个练习。请务必查阅RxJs的API：[https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/rx.complete.md](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/rx.complete.md)。'
- en: A bit of history
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点历史
- en: Before we talk about what Reactive Programming is, it is important to understand
    how other relevant programming paradigms influenced how we develop software. This
    will also help us understand the motivations behind reactive programming.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们谈论响应式编程之前，了解其他相关编程范式如何影响我们开发软件的方式非常重要。这也有助于我们理解响应式编程背后的动机。
- en: With few exceptions most of us have been taught—either self-taught or at school/university—imperative
    programming languages such as C and Pascal or object-oriented languages such as
    Java and C++.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了少数例外，我们大多数人要么自学，要么在学校/大学里被教授了诸如C和Pascal之类的命令式编程语言，或者诸如Java和C++之类的面向对象语言。
- en: In both cases, the imperative programming paradigm—of which object-oriented
    languages are part—dictates we write programs as a series of statements that modify
    program state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，命令式编程范式——其中面向对象语言是其中一部分——规定我们编写程序作为一系列修改程序状态的语句。
- en: 'In order to understand what this means, let''s look at a short program written
    in pseudo-code that calculates the sum and the mean value of a list of numbers:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这意味着什么，让我们看看一个用伪代码编写的简短程序，该程序计算数字列表的总和和平均值：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The mean value is the average of the numbers in the list, obtained by dividing
    the sum by the number of elements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值是列表中数字的平均值，通过将总和除以元素数量得到。
- en: First, we create a new array of integers, called `numbers`, with numbers from
    1 to 6, inclusive. Then, we initialize `sum` to zero. Next, we iterate over the
    array of integers, one at a time, adding to `sum` the value of each number.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的整数数组，称为`numbers`，包含从1到6的数字，包括6。然后，我们将`sum`初始化为零。接下来，我们逐个遍历整数数组，将每个数字的值加到`sum`上。
- en: Lastly, we calculate and assign the average of the numbers in the list to the
    `mean` local variable. This concludes the program logic.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算并将列表中数字的平均值赋给局部变量`mean`。这完成了程序逻辑。
- en: This program would print 21 for the sum and 3 for the mean, if executed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行此程序，它将打印总和为21，平均值为3。
- en: 'Though a simple example, it highlights its imperative style: we set up an application
    state—`sum`—and then explicitly tell the computer how to modify that state in
    order to calculate the result.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的例子，但它突出了其命令式风格：我们设置一个应用程序状态——`sum`——然后明确告诉计算机如何修改该状态以计算结果。
- en: Dataflow programming
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据流编程
- en: 'The previous example has an interesting property: the value of `mean` clearly
    has a dependency on the contents of `sum`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子有一个有趣的特性：`mean` 的值明显依赖于 `sum` 的内容。
- en: Dataflow programming makes this relationship explicit. It models applications
    as a dependency graph through which data flows—from operation to operation—and
    as values change, these changes are propagated to its dependencies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流编程使这种关系明确。它将应用程序建模为一个依赖图，数据通过该图从操作到操作流动——并且当值发生变化时，这些变化会传播到其依赖项。
- en: Historically, dataflow programming has been supported by custom-built languages
    such as Lucid and BLODI, as such, leaving other general purpose programming languages
    out.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，数据流编程由 Lucid 和 BLODI 等定制构建的语言支持，因此，其他通用编程语言被排除在外。
- en: Let's see how this new insight would impact our previous example. We know that
    once the last line gets executed, the value of `mean` is assigned and won't change
    unless we explicitly reassign the variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种新的见解将如何影响我们之前的例子。我们知道一旦执行了最后一行，`mean` 的值就会被赋值，并且除非我们显式地重新赋值变量，否则它不会改变。
- en: 'However, let''s imagine for a second that the pseudo-language we used earlier
    does support dataflow programming. In that case, assigning `mean` to an expression
    that refers to both `sum` and `count`, such as `sum / count(numbers)`, would be
    enough to create the directed dependency graph in the following diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们想象一下，我们之前使用的伪语言确实支持数据流编程。在这种情况下，将 `mean` 赋值给一个同时引用 `sum` 和 `count` 的表达式，例如
    `sum / count(numbers)`，就足以在以下图中创建有向依赖图：
- en: '![Dataflow programming](img/00003.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![数据流编程](img/00003.jpeg)'
- en: Note that a direct side effect of this relationship is that an implicit dependency
    from `sum` to `numbers` is also created. This means that if `numbers` change,
    the change is propagated through the graph, first updating `sum` and then finally
    updating `mean`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种关系的直接副作用是创建了一个从 `sum` 到 `numbers` 的隐式依赖。这意味着如果 `numbers` 发生变化，变化会通过图传播，首先更新
    `sum`，然后最终更新 `mean`。
- en: This is where Reactive Programming comes in. This paradigm builds on dataflow
    programming and change propagation to bring this style of programming to languages
    that don't have native support for it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是响应式编程发挥作用的地方。这种范式建立在数据流编程和变化传播的基础上，将这种编程风格带到那些没有原生支持的编程语言中。
- en: For imperative programming languages, Reactive Programming can be made available
    via libraries or language extensions. We don't cover this approach in this book,
    but should the reader want more information on the subject, please refer to *dc-lib*
    (see [https://code.google.com/p/dc-lib/](https://code.google.com/p/dc-lib/)) for
    an example. It is a framework that adds Reactive Programming support to C++ via
    dataflow constraints.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令式编程语言，响应式编程可以通过库或语言扩展来提供。本书不涉及这种方法，但如果读者想了解更多关于这个主题的信息，请参考 *dc-lib*（见 [https://code.google.com/p/dc-lib/](https://code.google.com/p/dc-lib/)）的示例。这是一个通过数据流约束为
    C++ 添加响应式编程支持的框架。
- en: Object-oriented Reactive Programming
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象响应式编程
- en: When designing interactive applications such as desktop **Graphical User Interfaces**
    (**GUIs**), we are essentially using an object-oriented approach to Reactive Programming.
    We will build a simple calculator application to demonstrate this style.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计桌面 **图形用户界面（GUIs**）等交互式应用程序时，我们本质上是在使用面向对象的方法来进行响应式编程。我们将构建一个简单的计算器应用程序来展示这种风格。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Clojure isn't an object-oriented language, but we will be interacting with parts
    of the Java API to build user interfaces that were developed in an OO paradigm,
    hence the title of this section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 不是一个面向对象的语言，但我们将与 Java API 的部分进行交互，以构建在面向对象范式下开发的用户界面，因此本节的标题是“面向对象响应式编程”。
- en: 'Let''s start by creating a new leiningen project from the command line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从命令行创建一个新的 leiningen 项目开始：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will create a directory called `calculator` in the current folder. Next,
    open the `project.clj` file in your favorite text editor and add a dependency
    on Seesaw, a Clojure library for working with Java Swing:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前文件夹中创建一个名为 `calculator` 的目录。接下来，使用您最喜欢的文本编辑器打开 `project.clj` 文件，并添加对 Seesaw
    的依赖，Seesaw 是一个用于处理 Java Swing 的 Clojure 库：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At the time of this writing, the latest Seesaw version available is 1.4.4.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，可用的最新Seesaw版本是1.4.4。
- en: 'Next, in the `src/calculator/core.clj` file, we''ll start by requiring the
    Seesaw library and creating the visual components we''ll be using:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`src/calculator/core.clj`文件中，我们将首先导入Seesaw库并创建我们将要使用的视觉组件：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We would like the label to be updated automatically as soon as a user types
    a new number in any of the input fields. The following code does exactly that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望标签能够自动更新，一旦用户在任一输入字段中输入一个新的数字。以下代码正是这样做的：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first function, `update-sum`, is our event handler. It sets the text of
    `result-label` to the sum of the values in `field-x` and `field-y`. We use try/catch
    here as a really basic way to handle errors since the key pressed might not have
    been a number. We then add the event handler to the `:key-released` event of both
    input fields.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`update-sum`是我们的事件处理程序。它将`result-label`的文本设置为`field-x`和`field-y`中值的总和。我们在这里使用try/catch作为一个非常基本的错误处理方式，因为按下的键可能不是一个数字。然后我们将事件处理程序添加到两个输入字段的`:key-released`事件中。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In real applications, we never want a catch block such as the previous one.
    This is considered bad style, and the catch block should do something more useful
    such as logging the exception, firing a notification, or resuming the application
    if possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用程序中，我们永远不希望有一个像之前的那样的catch块。这被认为是不良风格，catch块应该执行一些更有用的操作，例如记录异常、触发通知或在可能的情况下恢复应用程序。
- en: 'We are almost done. All we need to do now is add the components we have created
    so far to our `main-frame` and finally display it as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。我们现在需要做的只是将我们迄今为止创建的组件添加到`main-frame`中，并最终按以下方式显示它：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can save the file and run the program from the command line in the project''s
    root directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存文件，并在项目的根目录下通过命令行运行程序：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see something like the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下截图：
- en: '![Object-oriented Reactive Programming](img/00004.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![面向对象的响应式编程](img/00004.jpeg)'
- en: Experiment by typing some numbers in either or both text input fields and watch
    how the value of the label changes automatically, displaying the sum of both numbers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在任一或两个文本输入字段中输入一些数字进行实验，并观察标签的值如何自动更改，显示两个数字的和。
- en: Congratulations! You have just created your first reactive application!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你第一个响应式应用程序！
- en: As alluded to previously, this application is reactive because the value of
    the result label *reacts* to user input and is updated automatically. However,
    this isn't the whole story—it lacks in composability and requires us to specify
    the how, not the what of what we're trying to achieve.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个应用程序是响应式的，因为结果标签的值会根据用户输入而*响应*并自动更新。然而，这并不是全部的故事——它缺乏可组合性，需要我们指定我们试图实现的*如何*，而不是*什么*。
- en: As familiar as this style of programming may be, making applications reactive
    this way isn't always ideal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种编程风格可能很熟悉，但以这种方式使应用程序响应式并不总是理想的。
- en: Given previous discussions, we notice we still had to be fairly explicit in
    setting up the relationships between the various components as evidenced by having
    to write a custom handler and bind it to both input fields.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的讨论，我们注意到我们仍然需要相当明确地设置各个组件之间的关系，正如需要编写一个自定义处理程序并将其绑定到两个输入字段所证明的那样。
- en: As we will see throughout the rest of this book, there is a much better way
    to handle similar scenarios.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本书的其余部分看到的那样，处理类似场景有更好的方法。
- en: The most widely used reactive program
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最广泛使用的响应式程序
- en: Both examples in the previous section will feel familiar to some readers. If
    we call the input text fields "cells" and the result label's handler a "formula",
    we now have the nomenclature used in modern spreadsheet applications such as Microsoft
    Excel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的两个示例对一些读者来说可能很熟悉。如果我们把输入文本字段称为“单元格”，把结果标签的处理程序称为“公式”，我们现在就有了现代电子表格应用程序（如Microsoft
    Excel）中使用的术语。
- en: The term Reactive Programming has only been in use in recent years, but the
    idea of a reactive application isn't new. The first electronic spreadsheet dates
    back to 1969 when Rene Pardo and Remy Landau, then recent graduates from Harvard
    University, created **LANPAR** (**LANguage for Programming Arrays at Random**)
    [1].
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 术语响应式编程仅在近年来开始使用，但响应式应用程序的概念并不新鲜。第一个电子表格可以追溯到1969年，当时哈佛大学的毕业生Rene Pardo和Remy
    Landau创建了**LANPAR**（**用于随机编程数组的语言**）[1]。
- en: 'It was invented to solve a problem that Bell Canada and AT&T had at the time:
    their budgeting forms had 2000 cells that, when modified, forced a software re-write
    taking anywhere from six months to two years.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它是为了解决 Bell Canada 和 AT&T 在当时遇到的问题而发明的：他们的预算表有 2000 个单元格，当修改时，迫使软件重写，耗时从六个月到两年不等。
- en: To this day, electronic spreadsheets remain a powerful and useful tool for professionals
    of various fields.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，电子表格仍然是各个领域专业人士的强大且有用的工具。
- en: The Observer design pattern
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者设计模式
- en: Another similarity the keen reader may have noticed is with the Observer design
    pattern. It is mainly used in object-oriented applications as a way for objects
    to communicate with each other without having any knowledge of who depends on
    its changes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 留意细节的读者可能会注意到与观察者设计模式的相似之处。它主要在面向对象的应用程序中使用，作为对象之间通信的方式，而无需知道谁依赖于其变化。
- en: 'In Clojure, a simple version of the Observer pattern can be implemented using
    *watches*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，可以使用 *watches* 实现观察者模式的简单版本：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We start by creating our program state, in this case an atom holding an empty
    vector. Next, we create a watch function that knows how to sum all numbers in
    `numbers`. Finally, we add our watch function to the numbers atom under the `:adder`
    key (useful for removing watches).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建我们的程序状态，在这种情况下是一个包含空向量的原子。接下来，我们创建一个知道如何求和 `numbers` 中所有数字的监视函数。最后，我们将监视函数添加到
    `numbers` 原子下的 `:adder` 键（用于移除监视）。
- en: The `adder` key conforms with the API contract required by `add-watch` and receives
    four arguments. In this example, we only care about `new-state`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`adder` 键符合 `add-watch` 所需的 API 合同，并接收四个参数。在这个例子中，我们只关心 `new-state`。'
- en: 'Now, whenever we update the value of `numbers`, its watch will be executed,
    as demonstrated in the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当更新 `numbers` 的值时，其监视都会被执行，如下所示：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The highlighted lines above indicate the result that is printed on the screen
    each time we update the atom.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的高亮行表示每次我们更新原子时打印在屏幕上的结果。
- en: Though useful, the Observer pattern still requires some amount of work in setting
    up the dependencies and the required program state in addition to being hard to
    compose.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有用，但观察者模式仍然需要在设置依赖关系和所需的程序状态上做一些工作，而且难以组合。
- en: That being said, this pattern has been extended and is at the core of one of
    the Reactive Programming frameworks we will look at later in this book, Microsoft's
    **Reactive Extensions** (**Rx**).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这个模式已经被扩展，并成为我们将在本书后面部分探讨的其中一个反应式编程框架的核心，即微软的 **Reactive Extensions**（**Rx**）。
- en: Functional Reactive Programming
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式反应式编程
- en: Just like Reactive Programming, **Functional Reactive Programming**—**FRP**
    for short—has unfortunately become an overloaded term.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就像反应式编程一样，**函数式反应式编程**（简称 **FRP**）不幸地成为了一个多义词。
- en: Frameworks such as RxJava (see [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)),
    ReactiveCocoa (see [https://github.com/ReactiveCocoa/ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)),
    and Bacon.js (see [https://baconjs.github.io/](https://baconjs.github.io/)) became
    extremely popular in recent years and had positioned themselves incorrectly as
    FRP libraries. This led to the confusion surrounding the terminology.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，RxJava（见 [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)）、ReactiveCocoa（见
    [https://github.com/ReactiveCocoa/ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)）和
    Bacon.js（见 [https://baconjs.github.io/](https://baconjs.github.io/)）等框架在近年来变得极为流行，并错误地将自己定位为
    FRP 库。这导致了围绕术语的混淆。
- en: As we will see, these frameworks do not implement FRP but rather are inspired
    by it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这些框架并没有实现 FRP，而是受到了它的启发。
- en: In the interest of using the correct terminology as well as understanding what
    "inspired by FRP" means, we will have a brief look at the different formulations
    of FRP.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用正确的术语以及理解“受 FRP 启发”的含义，我们将简要地看看 FRP 的不同表述。
- en: Higher-order FRP
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶 FRP
- en: Higher-order FRP refers to the original research on FRP developed by Conal Elliott
    and Paul Hudak in their paper *Functional Reactive Animation* [2] from 1997\.
    This paper presents *Fran*, a domain-specific language embedded in Haskell for
    creating reactive animations. It has since been implemented in several languages
    as a library as well as purpose built reactive languages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶 FRP 指的是 Conal Elliott 和 Paul Hudak 在他们 1997 年的论文 *Functional Reactive Animation*
    [2] 中开发的 FRP 的原始研究。这篇论文介绍了 *Fran*，这是一个嵌入 Haskell 中的特定领域语言，用于创建反应式动画。它后来被作为库以及专门构建的反应式语言实现。
- en: 'If you recall the calculator example we created a few pages ago, we can see
    how that style of Reactive Programming requires us to manage state explicitly
    by directly reading and writing from/to the input fields. As Clojure developers,
    we know that avoiding state and mutable data is a good principle to keep in mind
    when building software. This principle is at the core of Functional Programming:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回忆一下我们之前几页创建的计算器示例，我们可以看到这种响应式编程风格要求我们通过直接从输入字段读取和写入来显式地管理状态。作为Clojure开发者，我们知道在构建软件时避免状态和可变数据是一个值得记住的好原则。这个原则是函数式编程的核心：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This short program increments by one all elements in the original list, filters
    all even numbers, and adds them up using `reduce`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的程序通过`reduce`将原始列表中的所有元素加一，过滤掉所有偶数，并将它们相加。
- en: Note how we didn't have to explicitly manage local state through at each step
    of the computation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不需要在计算的每一步显式地管理局部状态。
- en: Differently from imperative programming, we focus on what we want to do, for
    example iteration, and not how we want it to be done, for example using a `for`
    loop. This is why the implementation matches our description of the program closely.
    This is known as declarative programming.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令式编程不同，我们关注我们想要做什么，例如迭代，而不是我们想要如何做，例如使用`for`循环。这就是为什么实现与我们的程序描述非常接近。这被称为声明式编程。
- en: 'FRP brings the same philosophy to Reactive Programming. As the Haskell programming
    language wiki on the subject has wisely put it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: FRP将相同的哲学带到了响应式编程中。正如关于该主题的Haskell编程语言维基百科明智地指出：
- en: '*FRP is about handling time-varying values like they were regular values.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*FRP是关于处理随时间变化的价值，就像它们是常规价值一样。*'
- en: Put another way, FRP is a declarative way of modeling systems that respond to
    input over time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，FRP是一种声明式的方法，用于建模随时间输入做出响应的系统。
- en: 'Both statements touch on the concept of time. We''ll be exploring that in the
    next section, where we introduce the key abstractions provided by FRP: signals
    (or behaviors) and events.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句都触及了时间这一概念。我们将在下一节中探讨这一点，届时我们将介绍FRP提供的关键抽象：信号（或行为）和事件。
- en: Signals and events
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和事件
- en: So far we have been dealing with the idea of programs that react to user input.
    This is of course only a small subset of reactive systems but is enough for the
    purposes of this discussion.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理程序对用户输入做出反应的想法。这当然只是响应式系统的一小部分，但对于这次讨论来说已经足够了。
- en: 'User input happens several times through the execution of a program: key presses,
    mouse drags, and clicks are but a few examples of how a user might interact with
    our system. All these interactions happen over a period of time. FRP recognizes
    that time is an important aspect of reactive programs and makes it a first-class
    citizen through its abstractions.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入在程序执行过程中多次发生：按键、鼠标拖动和点击只是用户可能与我们系统交互的几个例子。所有这些交互都在一段时间内发生。FRP认识到时间是响应式程序的一个重要方面，并通过其抽象将其作为一等公民。
- en: Both signals (also called behaviors) and events are related to time. Signals
    represent continuous, time-varying values. Events, on the other hand, represent
    discrete occurrences at a given point in time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 信号（也称为行为）和事件都与时间相关。信号表示连续、随时间变化的价值。另一方面，事件代表在特定时间点的离散发生。
- en: For example, time is itself a signal. It varies continuously and indefinitely.
    On the other hand, a key press by a user is an event, a discrete occurrence.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，时间本身就是一个信号。它连续且无限地变化。另一方面，用户的按键是一个事件，一个离散的发生。
- en: It is important to note, however, that the semantics of how a signal changes
    need not be continuous. Imagine a signal that represents the current (x,y) coordinates
    of your mouse pointer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，信号如何变化的语义不必是连续的。想象一下代表你的鼠标指针当前（x,y）坐标的信号。
- en: This signal is said to change discretely as it depends on the user moving the
    mouse pointer—an event—which isn't a continuous action.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信号被称为离散变化，因为它依赖于用户移动鼠标指针——一个事件，这不是一个连续的动作。
- en: Implementation challenges
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现挑战
- en: Perhaps the most defining characteristic of classical FRP is the use of continuous
    time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 经典FRP最定义性的特征可能是对连续时间的使用。
- en: This means FRP assumes that signals are changing all the time, even if their
    value is still the same, leading to needless recomputation. For example, the mouse
    position signal will trigger updates to the application dependency graph—like
    the one we saw previously for the mean program—even when the mouse is stationary.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着FRP假设信号始终在变化，即使它们的值仍然是相同的，这会导致不必要的重新计算。例如，鼠标位置信号将触发应用程序依赖图的更新——就像我们之前看到的平均程序依赖图——即使鼠标是静止的。
- en: 'Another problem is that classical FRP is synchronous by default: events are
    processed in order, one at a time. Harmless at first, this can cause delays, which
    would render an application unresponsive should an event take substantially longer
    to process.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于，经典FRP默认是同步的：事件按顺序逐个处理。起初可能无害，但这可能导致延迟，如果某个事件处理时间显著较长，则会使应用程序无响应。
- en: Paul Hudak and others furthered research on higher-order FRP [7] [8] to address
    these issues, but that came at the cost of expressivity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Paul Hudak和其他人进一步研究了高阶FRP[7][8]，以解决这些问题，但这是以牺牲可表达性为代价的。
- en: The other formulations of FRP aim to overcome these implementation challenges.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: FRP的其他公式旨在克服这些实现挑战。
- en: Throughout the rest of the chapter, I'll be using signals and behaviors interchangeably.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将交替使用信号和行为。
- en: First-order FRP
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一阶FRP
- en: 'The most well-known reactive language in this category is Elm (see [http://elm-lang.org/](http://elm-lang.org/)),
    an FRP language that compiles to JavaScript. It was created by Evan Czaplicki
    and presented in his paper *Elm: Concurrent FRP for Functional GUIs* [3].'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类别中，最著名的响应式语言是Elm（见[http://elm-lang.org/](http://elm-lang.org/)），这是一种编译为JavaScript的FRP语言。它由Evan
    Czaplicki创建，并在他的论文《Elm：用于功能GUI的并发FRP》[3]中提出。
- en: Elm makes some significant changes to higher-order FRP.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Elm对高阶FRP进行了一些重大改进。
- en: It abandons the idea of continuous time and is entirely event-driven. As a result,
    it solves the problem of needless recomputation highlighted earlier. First-order
    FRP combines both behaviors and events into signals which, in contrast to higher-order
    FRP, are discrete.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它放弃了连续时间这一概念，完全采用事件驱动。因此，它解决了之前提到的无谓重新计算问题。一阶FRP将行为和事件结合到信号中，与高阶FRP不同，这些信号是离散的。
- en: Additionally, first-order FRP allows the programmer to specify when synchronous
    processing of events isn't necessary, preventing unnecessary processing delays.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一阶FRP允许程序员指定何时同步处理事件不是必要的，从而防止不必要的处理延迟。
- en: Finally, Elm is a strict programming language—meaning arguments to functions
    are evaluated eagerly—and that is a conscious decision as it prevents space and
    time leaks, which are possible in a lazy language such as Haskell.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Elm是一种严格的编程语言——这意味着函数的参数会被积极评估——这是一个有意识的决策，因为它可以防止在像Haskell这样的惰性语言中可能出现的空间和时间泄漏。
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In an FRP library such as Fran, implemented in a lazy language, memory usage
    can grow unwieldy as computations are deferred to the absolutely last possible
    moment, therefore causing a space leak. These larger computations, accumulated
    over time due to laziness, can then cause unexpected delays when finally executed,
    causing time leaks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Fran这样的FRP库中，由于在惰性语言中计算被推迟到绝对最后时刻，内存使用可能会变得难以控制，因此导致空间泄漏。这些较大的计算，由于惰性而随着时间的推移积累，最终执行时可能会造成意外的延迟，导致时间泄漏。
- en: Asynchronous data flow
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步数据流
- en: Asynchronous Data Flow generally refers to frameworks such as **Reactive Extensions**
    (**Rx**), **ReactiveCocoa**, and **Bacon.js**. It is called as such as it completely
    eliminates synchronous updates.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 异步数据流通常指的是如**Reactive Extensions**（**Rx**）、**ReactiveCocoa**和**Bacon.js**等框架。之所以称为异步数据流，是因为它完全消除了同步更新。
- en: These frameworks introduce the concept of **Observable Sequences** [4], sometimes
    called Event Streams.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架引入了**可观察序列**的概念[4]，有时也称为事件流。
- en: This formulation of FRP has the advantage of not being confined to functional
    languages. Therefore, even imperative languages like Java can take advantage of
    this style of programming.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种FRP公式的优点是不局限于函数式语言。因此，即使是像Java这样的命令式语言也可以利用这种编程风格。
- en: Arguably, these frameworks were responsible for the confusion around FRP terminology.
    Conal Elliott at some point suggested the term CES (see [https://twitter.com/conal/status/468875014461468677](https://twitter.com/conal/status/468875014461468677)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说，这些框架导致了FRP术语的混淆。Conal Elliott在某个时候提出了CES这个术语（见[https://twitter.com/conal/status/468875014461468677](https://twitter.com/conal/status/468875014461468677))）。
- en: 'I have since adopted this terminology (see [http://vimeo.com/100688924](http://vimeo.com/100688924))
    as I believe it highlights two important factors:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经采用了这个术语（见[http://vimeo.com/100688924](http://vimeo.com/100688924)），因为我相信它突出了两个重要因素：
- en: 'A fundamental difference between CES and FRP: CES is entirely event-driven'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CES和FRP之间的基本区别：CES完全是事件驱动的
- en: CES is highly composable via combinators, taking inspiration from FRP
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CES通过组合子高度可组合，并从FRP中汲取灵感
- en: CES is the main focus of this book.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CES是本书的主要内容。
- en: Arrowized FRP
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头化FRP
- en: 'This is the last formulation we will look at. Arrowized FRP [5] introduces
    two main differences over higher-order FRP: it uses signal functions instead of
    signals and is built on top of John Hughes'' Arrow combinators [6].'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要查看的最后一个公式。箭头化的FRP [5] 在高于阶FRP上引入了两个主要区别：它使用信号函数而不是信号，并且建立在John Hughes的Arrow组合子
    [6] 之上。
- en: It is mostly about a different way of structuring code and can be implemented
    as a library. As an example, Elm supports Arrowized FRP via its Automaton (see
    [https://github.com/evancz/automaton](https://github.com/evancz/automaton)) library.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是一种不同的代码结构方式，可以作为库实现。例如，Elm通过其Automaton（见[https://github.com/evancz/automaton](https://github.com/evancz/automaton)）库支持箭头化的FRP。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The first draft of this chapter grouped the different formulations of FRP under
    the broad categories of *Continuous and Discrete* FRP. Thanks to Evan Czaplicki''s
    excellent talk *Controlling Time and Space: understanding the many formulations
    of FRP* (see [https://www.youtube.com/watch?v=Agu6jipKfYw](https://www.youtube.com/watch?v=Agu6jipKfYw)),
    I was able to borrow the more specific categories used here. These come in handy
    when discussing the different approaches to FRP.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个草稿将FRP的不同公式归类为广泛的*连续和离散*FRP类别。多亏了Evan Czaplicki出色的演讲*控制时间和空间：理解FRP的多种公式*（见[https://www.youtube.com/watch?v=Agu6jipKfYw](https://www.youtube.com/watch?v=Agu6jipKfYw)），我能够借用这里使用的更具体的类别。这些在讨论FRP的不同方法时非常有用。
- en: Applications of FRP
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FRP的应用
- en: The different FRP formulations are being used today in several problem spaces
    by professionals and big organizations alike. Throughout this book, we'll look
    at several examples of how CES can be applied. Some of these are interrelated
    as most modern programs have several cross-cutting concerns, but we will highlight
    two main areas.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的FRP公式今天被专业人士和大型组织在几个问题空间中使用。在这本书中，我们将查看几个CES如何应用的例子。其中一些是相互关联的，因为大多数现代程序都有几个横切关注点，但我们将突出两个主要领域。
- en: Asynchronous programming and networking
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程和网络
- en: GUIs are a great example of asynchronous programming. Once you open a web or
    a desktop application, it simply sits there, idle, waiting for user input.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: GUI是异步编程的一个很好的例子。一旦你打开一个网页或桌面应用程序，它就简单地坐在那里，空闲，等待用户输入。
- en: This state is often called the event or main event loop. It is simply waiting
    for external stimuli, such as a key press, a mouse button click, new data from
    the network, or even a simple timer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种状态通常被称为事件或主事件循环。它只是简单地等待外部刺激，例如按键、鼠标按钮点击、来自网络的新数据，甚至一个简单的计时器。
- en: Each of these stimuli is associated with an event handler that gets called when
    one of these events happen, hence the asynchronous nature of GUI systems.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些刺激都与一个事件处理器相关联，当这些事件发生时，会调用该事件处理器，因此GUI系统的异步特性。
- en: This is a style of programming we have been used to for many years, but as business
    and user needs grow, these applications grow in complexity as well, and better
    abstractions are needed to handle the dependencies between all the components
    of an application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们多年来习惯的编程风格，但随着商业和用户需求的增长，这些应用程序的复杂性也在增加，因此需要更好的抽象来处理应用程序所有组件之间的依赖关系。
- en: Another great example that deals with managing complexity around network traffic
    is Netflix, which uses CES to provide a reactive API to their backend services.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个处理网络流量周围复杂性的优秀例子是Netflix，它使用CES为后端服务提供反应式API。
- en: Complex GUIs and animations
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂的GUI和动画
- en: Games are, perhaps, the best example of complex user interfaces as they have
    intricate requirements around user input and animations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏可能是复杂用户界面的最佳例子，因为它们在用户输入和动画方面有复杂的要求。
- en: The Elm language we mentioned before is one of the most exciting efforts in
    building complex GUIs. Another example is Flapjax, also targeted at web applications,
    but is provided as a JavaScript library that can be integrated with existing JavaScript
    code bases.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的Elm语言是构建复杂GUI（图形用户界面）中最激动人心的努力之一。另一个例子是Flapjax，它也针对Web应用程序，但提供的是一个可以与现有JavaScript代码库集成的JavaScript库。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Reactive Programming is all about building responsive applications. There are
    several ways in which we can make our applications reactive. Some are old ideas:
    dataflow programming, electronic spreadsheets, and the Observer pattern are all
    examples. But CES in particular has become popular in recent years.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程的核心在于构建响应式应用程序。我们可以通过多种方式使我们的应用程序变得响应式。其中一些是旧有的理念：数据流编程、电子表格和观察者模式都是例子。但CES在近年来尤其受到欢迎。
- en: CES aims to bring to Reactive Programming the declarative way of modeling problems
    that is at the core of Functional Programming. We should worry about what and
    not about how.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: CES旨在将函数式编程核心中的声明式问题建模方式引入响应式编程。我们应该关注“什么”，而不是“如何”。
- en: In next chapters, we will learn how we can apply CES to our own programs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何将CES应用到我们自己的程序中。
