- en: '*Chapter 11***: MicroProfile GraphQL**'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章***：MicroProfile GraphQL**'
- en: '**GraphQL** is a distributed query language that addresses some of the shortcomings
    of **REpresentational State Transfer** (**REST**). In particular, GraphQL addresses
    the notions of **over-fetching** (receiving more data than the client intended)
    and **under-fetching** (requiring the client to make multiple requests to get
    the data it requires). GraphQL applications make use of a schema file that presents
    clients with the queries and mutations at its disposal, as well as the entities
    it can access and manipulate.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL** 是一种分布式查询语言，它解决了 **REpresentational State Transfer** （**REST**）
    的一些缺点。特别是，GraphQL 解决了 **过度获取**（接收比客户端预期更多的数据）和 **不足获取**（要求客户端发出多个请求以获取所需的数据）的概念。GraphQL
    应用程序利用一个模式文件，向客户端展示其可用的查询和突变，以及它可以访问和操作的对象。'
- en: The ease of use and robustness of GraphQL explains why its popularity is growing,
    especially in cloud-native applications. **MicroProfile GraphQL** (**MP GraphQL**)
    makes it easy to create GraphQL-based applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 的易用性和健壮性解释了为什么它的受欢迎程度在增长，尤其是在云原生应用中。**MicroProfile GraphQL** （**MP GraphQL**）
    使得创建基于 GraphQL 的应用变得简单。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding GraphQL basics and when to use it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GraphQL 基础知识及其适用场景
- en: Building services with MP GraphQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MP GraphQL 构建服务
- en: Consuming GraphQL services with client **application programming interfaces**
    (**APIs**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端 **应用程序编程接口** （**APIs**） 消费 GraphQL 服务
- en: By the end of this chapter, you will have learned what GraphQL is and when it
    is appropriate to use it, and you will be able to build your own GraphQL application
    ready to deploy in open source, cloud-ready servers such as Open Liberty.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解 GraphQL 是什么以及何时适合使用它，并且您将能够构建自己的 GraphQL 应用程序，准备在开源、云就绪服务器（如 Open
    Liberty）上部署。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To build and run the samples mentioned in this chapter, you will need a Mac
    or PC (Windows or Linux) with the following software:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行本章中提到的示例，您需要一个装有以下软件的 Mac 或 PC（Windows 或 Linux）：
- en: '**Java Development Kit** (**JDK**) version 8 or higher ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 开发工具包** （**JDK**） 版本 8 或更高 ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
- en: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
- en: A Git client ([https://git-scm.com/](https://git-scm.com/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 客户端 ([https://git-scm.com/](https://git-scm.com/))
- en: All of the source code used in this chapter is available on GitHub at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有源代码都可以在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11)。
- en: 'Once you have cloned the GitHub repository, you can start the Open Liberty
    server where these code samples will execute by entering the `Chapter11` directory
    and executing the following command from the command line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已经克隆了 GitHub 仓库，您可以通过进入 `Chapter11` 目录并在命令行中执行以下命令来启动 Open Liberty 服务器，这些代码示例将在其中执行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can then stop the server in the same command window by pressing *Ctrl +
    C*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过按 *Ctrl + C* 在同一个命令窗口中停止服务器。
- en: Now we've got the prerequisites taken care of, let's start by learning the basics
    of GraphQL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理好了先决条件，让我们从学习 GraphQL 的基础知识开始。
- en: Understanding GraphQL basics and when to use it
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GraphQL 基础知识及其适用场景
- en: As with REST, GraphQL is a means of accessing and modifying remote data over
    web-based transports. It uses a publicly visible schema, allowing clients to know
    exactly which entities it can query, which fields can be modified, and so on.
    This is similar to how OpenAPI describes RESTful APIs. The schema acts as a contract
    between the client and the service. GraphQL strictly enforces the schema, preventing
    clients from accessing or modifying entities or fields that are not defined within
    it. This strictness provides a lot of freedom for developers of both clients and
    services, which we'll cover later in this section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST一样，GraphQL是通过基于Web的传输访问和修改远程数据的一种方式。它使用一个公开可见的模式，允许客户端确切地知道它可以查询哪些实体，哪些字段可以修改，等等。这与OpenAPI描述RESTful
    API的方式相似。该模式充当客户端和服务的合同。GraphQL严格强制执行模式，防止客户端访问或修改未在该模式中定义的实体或字段。这种严格性为客户端和服务端开发者提供了很多自由，我们将在本节稍后介绍。
- en: 'GraphQL supports the following operations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL支持以下操作：
- en: '`GET` requests in REST.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST中的`GET`请求。
- en: '**Mutations**: Mutations are used for modifying data—that is, creating, updating,
    and/or deleting it.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更**：变更用于修改数据——即创建、更新和/或删除它。'
- en: '**Subscriptions**: Subscriptions are used so that clients can receive notifications
    of specific events, such as when a particular entity has been created or a field
    has dropped below a certain threshold, or even unrelated events.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅**：订阅用于使客户端能够接收特定事件的通知，例如当某个特定实体被创建或某个字段低于某个特定阈值，或者甚至是无关的事件。'
- en: Unlike REST, where different parts of the API are spread out across multiple
    **HyperText Transfer Protocol** (**HTTP**) endpoints, GraphQL applications typically
    use a single HTTP endpoint, and the operations are embedded in the HTTP request's
    body.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST不同，在REST中，API的不同部分分散在多个**超文本传输协议**（**HTTP**）端点，GraphQL应用程序通常使用单个HTTP端点，并且操作嵌入在HTTP请求的主体中。
- en: GraphQL operations and schemas use their own syntax, but the response is in
    **JavaScript Object Notation** (**JSON**) format. This allows GraphQL services
    and clients to be written in any language. While we plan to cover creating services
    in Java, it is also currently possible to write service and client applications
    in JavaScript, Python, Go, Haskell, Perl, Ruby, Scala, and many others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL操作和模式使用它们自己的语法，但响应以**JavaScript对象表示法**（**JSON**）格式。这允许GraphQL服务和客户端用任何语言编写。虽然我们计划介绍如何在Java中创建服务，但目前也可以用JavaScript、Python、Go、Haskell、Perl、Ruby、Scala以及许多其他语言编写服务和客户端应用程序。
- en: 'The schema defines the types of entities accessible for the service, as well
    as the operations that can be performed. Built-in or primitive GraphQL types are
    called **scalars**. Any service is free to define its own scalar types, but the
    GraphQL specification states that all services must use at least these five standard
    scalars:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模式定义了服务可访问的实体类型以及可以执行的操作。内置或原始的GraphQL类型被称为**标量**。任何服务都可以自由定义自己的标量类型，但GraphQL规范指出，所有服务都必须至少使用以下五个标准标量：
- en: '`int`—A 32-bit signed integer'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`—32位有符号整数'
- en: '`float`—Signed double-precision floating-point number'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`—有符号双精度浮点数'
- en: '`string`—A sequence of characters using **Unicode Transformation Format-8**
    (**UTF-8**) encoding'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`—使用**Unicode转换格式-8**（**UTF-8**）编码的字符序列'
- en: '`boolean`—`true` or `false`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`—`true`或`false`'
- en: '`ID`—A string that is intended to be a unique **identifier** (**ID**) for an
    entity; it is not intended to be human-readable'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`—一个旨在作为实体的唯一**标识符**（**ID**）的字符串；它不打算供人类阅读'
- en: GraphQL objects can be made up of scalars or other objects. Each operation must
    explicitly specify all fields that it wishes to view in the response. For complex
    types (types that include other types or scalars), this might mean specifying
    fields several layers deep.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL对象可以由标量或其他对象组成。每个操作必须明确指定它希望在响应中查看的所有字段。对于复杂类型（包含其他类型或标量的类型），这可能意味着指定多层深度的字段。
- en: Requiring clients to specify all fields in a query ensures backward compatibility
    when you add new fields to existing objects. A client cannot be caught off guard
    if a new field appears on an object since their existing query didn't specify
    it!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要求客户端在查询中指定所有字段，确保在向现有对象添加新字段时保持向后兼容性。如果对象上出现新字段，而客户端现有的查询没有指定它，那么客户端就不会感到意外！
- en: Another advantage of requiring clients to specify all fields that they are interested
    in is that it avoids **over-fetching**. Over-fetching occurs when more data is
    sent over the network than is necessary. One common example of over-fetching in
    REST is weather data. If you issue a RESTful request to check the current conditions
    for a particular location from various weather sites, you will see an enormous
    amount of information, but most of that data is unused when you just wanted to
    know what the outside temperature is and whether or not it's raining.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要求客户端指定他们感兴趣的所有字段的好处之一是避免了**过度获取**。过度获取发生在通过网络发送的数据多于所需的情况。REST中过度获取的一个常见例子是天气数据。如果你向多个天气网站发出RESTful请求，以检查特定位置的当前条件，你会看到大量的信息，但当你只想知道室外温度以及是否下雨时，大部分数据都是未使用的。
- en: By sending queries as the payload of an HTTP request, GraphQL also avoids **under-fetching**.
    As you've probably guessed, under-fetching occurs when the data returned is insufficient.
    Using the weather example, suppose you also wanted to know the temperature at
    your friends' homes in other cities. You'd have to issue similar RESTful requests
    to the weather site for each location. But in GraphQL, you can issue multiple
    queries in a single HTTP request, enabling you to get exactly the data you need
    with a single round trip to the server and making it fast and efficient!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将查询作为HTTP请求的有效负载发送，GraphQL还避免了**不足获取**。正如你可能猜到的，不足获取发生在返回的数据不足的情况下。使用天气示例，假设你还想了解其他城市朋友家的温度。你必须为每个位置向天气网站发出类似的RESTful请求。但在GraphQL中，你可以在单个HTTP请求中发出多个查询，使你能够通过单次往返服务器获取所需的确切数据，从而使其快速高效！
- en: Queries and mutations have their own syntax, though it is similar to JSON and
    other query languages. Generally, these operations start with `query` or `mutation`
    and then a label for the operation, then, inside curly braces, you would specify
    the query or mutation to invoke with any parameters inside parentheses. You would
    then add the fields you are interested in inside curly braces. We'll see some
    example queries and mutations later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 查询和突变有自己的语法，尽管它与JSON和其他查询语言相似。通常，这些操作以`query`或`mutation`开头，然后是操作的标签，然后在大括号内指定要调用的查询或突变，以及括号内的任何参数。然后，你会在大括号内添加你感兴趣的字段。我们将在本章后面看到一些查询和突变的示例。
- en: GraphQL also allows `503` (service unavailable) error. Some data is still better
    than none, right?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL还允许`503`（服务不可用）错误。有些数据总比没有好，对吧？
- en: Since the schema is exposed to clients, various tools can introspect the schema,
    allowing users to construct queries and mutations and test them in real time.
    One such tool, which we'll discuss later, is called **GraphiQL** ([https://github.com/graphql/graphiql](https://github.com/graphql/graphiql)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模式对客户端是公开的，各种工具可以内省模式，使用户能够构建查询和突变并在实时中测试它们。我们将稍后讨论的一个这样的工具被称为**GraphiQL**([https://github.com/graphql/graphiql](https://github.com/graphql/graphiql))。
- en: While REST is still the more widely used communication architecture in the cloud,
    GraphQL is quickly gaining in popularity as it addresses many of the gaps in REST.
    So, which approach is right for you? The answer, as with most things, is *it depends*.
    GraphQL primarily only works with JSON as the response type; if you want to use
    other data types, you might want to consider REST or an alternative approach.
    If your data is hierarchical in nature, it might lend itself better to REST.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然REST仍然是云中更广泛使用的通信架构，但GraphQL正迅速获得人气，因为它解决了REST中的许多差距。那么，哪种方法适合你？答案，就像大多数事情一样，是*取决于*。GraphQL主要只与JSON作为响应类型一起工作；如果你想使用其他数据类型，你可能需要考虑REST或另一种方法。如果你的数据本质上是分层的，它可能更适合REST。
- en: Another consideration is security-based in relation to `/public/*`) while restricting
    access to other entities (for example, `/private/*`). This isn't possible in GraphQL
    without splitting the service into separate public and private services, which
    might not be ideal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是针对`/public/*`的安全限制，同时限制对其他实体的访问（例如，`/private/*`）。在GraphQL中，如果不将服务拆分为单独的公共和私有服务，这是不可能实现的，这可能不是最佳方案。
- en: Similarly, HTTP caching is more complicated with GraphQL. Since REST uses URI
    paths, both clients and servers can cache entity results based on the path used.
    It is possible to cache based on paths in GraphQL, but this would require clients
    to pass their queries as HTTP `GET` query parameters. This could be cumbersome
    for the client, as well as being a potential security risk as proxy servers would
    be able to see query parameters, and you may still have issues with caching, depending
    on the spacing and formatting of the query. Fortunately, most implementations
    of GraphQL use query caching on the server side to reduce unnecessary duplication
    of work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，与 GraphQL 一起，HTTP 缓存也更加复杂。由于 REST 使用 URI 路径，客户端和服务器都可以根据使用的路径缓存实体结果。在 GraphQL
    中，根据路径进行缓存是可能的，但这将要求客户端将它们的查询作为 HTTP `GET` 查询参数传递。这可能对客户端来说很麻烦，同时也可能是一个潜在的安全风险，因为代理服务器将能够看到查询参数，并且您可能仍然会因查询的间距和格式问题而遇到缓存问题。幸运的是，大多数
    GraphQL 的实现都在服务器端使用查询缓存来减少不必要的重复工作。
- en: So, when would you use GraphQL? GraphQL tends to cost a little more on the server
    (in order to filter results to get the client exactly what it wants), but that
    trade-off means that client-side processing is significantly reduced. So, if you
    have a lot of clients or want to optimize your client performance, GraphQL is
    a good approach.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您何时会使用 GraphQL 呢？GraphQL 在服务器端（为了过滤结果以获取客户端所需的确切内容）可能会稍微昂贵一些，但这种权衡意味着客户端处理显著减少。因此，如果您有很多客户端或希望优化客户端性能，GraphQL
    是一个好的选择。
- en: GraphQL tends to reduce network traffic since it avoids under-fetching and over-fetching.
    In environments where network bandwidth is expensive, GraphQL is ideal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 通常可以减少网络流量，因为它避免了数据获取不足和过度获取。在网络带宽昂贵的环境中，GraphQL 是理想的解决方案。
- en: It should also be noted that nothing prevents you from writing both GraphQL
    and RESTful APIs for the same service. This might add more maintenance, but it
    allows your clients to choose.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意的是，没有任何东西阻止您为同一服务同时编写 GraphQL 和 RESTful API。这可能会增加更多的维护工作，但它允许您的客户端进行选择。
- en: Now we understand what GraphQL is and when we should use it, let's explore how
    we can build GraphQL applications using MicroProfile.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是 GraphQL 以及何时应该使用它，接下来让我们探讨如何使用 MicroProfile 来构建 GraphQL 应用程序。
- en: Building services with MP GraphQL
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MP GraphQL 构建服务
- en: In this section, we will learn how to develop a GraphQL application using the
    MP GraphQL APIs and runtime framework. We'll cover building queries and mutations,
    and how to invoke them using an interactive web tool called **GraphiQL**. We'll
    also cover entities and enumerated types. Finally, we'll cover a technique to
    reduce unnecessary server-side computations and deliver partial results.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 MP GraphQL API 和运行时框架开发 GraphQL 应用程序。我们将涵盖构建查询和突变，以及如何使用一个名为
    **GraphiQL** 的交互式网络工具来调用它们。我们还将涵盖实体和枚举类型。最后，我们将介绍一种减少不必要的服务器端计算并传递部分结果的技术。
- en: Most GraphQL APIs for Java require you to write a schema first and then build
    the Java code around it. This approach tends to cause some level of dual maintenance,
    and it can slow down development as you evolve your application. MP GraphQL uses
    a `Hello World` query service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数针对 Java 的 GraphQL API 都需要您首先编写一个模式，然后围绕它构建 Java 代码。这种方法往往会导致一定程度的双重维护，并且随着您应用的发展，它可能会减慢开发速度。MP
    GraphQL 使用一个 `Hello World` 查询服务。
- en: Developing queries
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发查询
- en: As with JAX-RS, MP GraphQL is based on annotations. The first annotation to
    consider is `@GraphQLApi`. This annotation is a **Contexts and Dependency Injection**
    (**CDI**) bean-defining annotation, which means that when you apply this annotation
    to a class, it becomes a CDI bean. This enables the CDI framework to manage its
    life cycle and inject dependencies. This annotation is required on classes that
    contain query or mutation methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JAX-RS 一样，MP GraphQL 也是基于注解的。首先需要考虑的注解是 `@GraphQLApi`。这个注解是一个 **Contexts and
    Dependency Injection** (**CDI**) 的 bean 定义注解，这意味着当您将此注解应用于一个类时，它就变成了一个 CDI bean。这使
    CDI 框架能够管理其生命周期并注入依赖项。这个注解对于包含查询或突变方法的类是必需的。
- en: 'The next annotation we''ll consider is `@Query`. When this annotation is applied
    to methods, it tells the MP GraphQL runtime to create a top-level query in the
    schema. Let''s see a simple example, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要考虑的下一个注解是 `@Query`。当这个注解应用于方法时，它告诉 MP GraphQL 运行时在模式中创建一个顶级查询。让我们看看一个简单的例子，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `@GraphQLApi` annotation tells the runtime to manage the life cycle of
    this bean, and the `@Query` annotation tells the runtime to generate a query in
    the schema with no parameters that returns a `String` scalar. If we run this example
    in an MP GraphQL server such as Open Liberty, we can then see the schema file
    by browsing to `http://localhost:9080/ch11/graphql/schema.graphql`. Then, we''ll
    see something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GraphQLApi`注解告诉运行时管理此bean的生命周期，而`@Query`注解告诉运行时在模式中生成一个无参数的查询，该查询返回一个`String`标量。如果我们在一个MP
    GraphQL服务器（如Open Liberty）上运行此示例，然后我们可以通过浏览到`http://localhost:9080/ch11/graphql/schema.graphql`来查看模式文件。然后，我们会看到类似这样的：'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using `http://localhost:9080/ch11/graphql-ui` and then enter this query string:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`http://localhost:9080/ch11/graphql-ui`然后输入以下查询字符串：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, click the triangular *play* button to see the results. You should see
    something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击三角形的*播放*按钮查看结果。你应该看到类似这样的：
- en: '![Figure 11.1 – Simple query in GraphiQL'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – GraphiQL中的简单查询'
- en: '](img/B17377_11_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17377_11_01.jpg)'
- en: Figure 11.1 – Simple query in GraphiQL
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – GraphiQL中的简单查询
- en: Notice that the result is a JSON object with a field labeled `data`. The results
    of the query are always under the `data` field. If an error were to occur, there
    would be a separate `errors` field instead of, or in addition to, the `data` field.
    This field would include details of the error(s).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果是带有标签`data`的JSON对象。查询的结果始终位于`data`字段下。如果发生错误，将会有一个单独的`errors`字段，而不是`data`字段，或者与`data`字段一起。该字段将包括错误详情。
- en: This is a nice start, and you can probably guess that you could have multiple
    query methods in this class that could return different data, but queries are
    much more powerful when they have parameters. In previous chapters, we've been
    working with the **Stock Trader** application. Let's GraphQL-ize that application
    in our following examples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的开始，你可能会猜到在这个类中可以有多个查询方法，它们可以返回不同的数据，但带有参数的查询要强大得多。在之前的章节中，我们一直在处理**股票交易员**应用程序。让我们在我们的后续示例中将该应用程序GraphQL化。
- en: 'If we want the client to be able to specify parameters to a query, we simply
    add Java method parameters to the `@Query`-annotated methods. Let''s take a look
    at what we might do for the `Portfolio` service, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让客户端能够指定查询的参数，我们只需将Java方法参数添加到`@Query`注解的方法中。让我们看看`Portfolio`服务可能的做法，如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a few new things to consider here. First, we inject `PortfolioDatabase`
    instance. This is nothing more than a wrapper around a `HashMap`, but it could
    just as well access a real relational or NoSQL database to retrieve stock portfolio
    data. CDI injects this for us. *Muchas gracias!*
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新事物需要考虑。首先，我们注入`PortfolioDatabase`实例。这不过是一个`HashMap`的包装器，但它也可以访问真实的SQL或NoSQL数据库来检索股票投资组合数据。CDI为我们注入了它。*非常感谢！*
- en: Next, the `portfolio` query method also has a `@Description` annotation applied
    to it. This allows us to specify a human-readable description that will appear
    in the generated schema, which is useful for describing the intent of the query
    and its parameters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`portfolio`查询方法也应用了`@Description`注解。这允许我们指定一个人类可读的描述，该描述将出现在生成的模式中，这对于描述查询及其参数的意图很有用。
- en: Speaking of parameters, the method takes a `String` parameter called `owner`.
    The `@Name` annotation tells the runtime which name to use when generating the
    schema.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 说到参数，该方法接受一个名为`owner`的`String`参数。`@Name`注解告诉运行时在生成模式时使用哪个名称。
- en: Best practice
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Use `@Name` annotations on parameters for portability. Some MP GraphQL implementations
    may not be able to determine the parameter name from the code and will end up
    writing the schema with parameter names such as `arg0`, `arg1`, and so on. The
    `@Name` annotation guarantees that the runtime will generate the specified parameter
    name in the schema.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Name`注解在参数上以实现可移植性。某些MP GraphQL实现可能无法从代码中确定参数名称，并最终使用`arg0`、`arg1`等参数名称编写模式。`@Name`注解确保运行时将在模式中生成指定的参数名称。
- en: 'Another thing worth noting in the aforementioned code is that instead of returning
    a `string` or other primitive, we are returning a `Portfolio` object. This is
    a custom object in our application. By doing so, the runtime will introspect the
    `Portfolio` Java object and will generate it as an entity in the schema. It will
    also generate any other object that it references. Let''s take a look at the schema
    generated from this code, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中还有一点值得注意，那就是我们不是返回一个 `string` 或其他原始数据类型，而是返回一个 `Portfolio` 对象。这是我们应用程序中的一个自定义对象。通过这样做，运行时会反射
    `Portfolio` Java 对象，并将其作为模式中的实体生成。它还会生成它引用的任何其他对象。让我们看看从这个代码生成的模式，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we see the `Portfolio` type (entity) and its various fields and their
    types. So, the `accountID` field is a `string`; the `total` field is a `float`,
    with the exclamation mark indicating that the value for this field must be non-null;
    the `stocks` field is an array of `Stock` objects, with the square brackets indicating
    an **array**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到 `Portfolio` 类型（实体）及其各种字段及其类型。因此，`accountID` 字段是一个 `string`；`total` 字段是一个
    `float`，感叹号表示该字段的值必须非空；`stocks` 字段是一个 `Stock` 对象的数组，方括号表示这是一个 **数组**。
- en: We also see the text description for our query. The query section indicates
    that the `portfolio` query takes a single `String` parameter called `owner` and
    returns a `Portfolio` object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了我们查询的文本描述。查询部分表明，`portfolio` 查询接受一个名为 `owner` 的单个 `String` 参数，并返回一个 `Portfolio`
    对象。
- en: The `Stock` type is pulled in because it is referenced by the `Portfolio` type.
    Likewise, the `Loyalty` `Portfolio` type. Enums in GraphQL are generated from
    Java `enums` and behave similarly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stock` 类型被引入是因为它被 `Portfolio` 类型所引用。同样，`Loyalty` `Portfolio` 类型。GraphQL 中的枚举是从
    Java `枚举` 生成的，并且行为类似。'
- en: 'Let''s take one last look at the code that generated this schema, and we''ll
    see that the `portfolio` method throws an `UnknownPortfolioException` exception.
    This exception is handled by the framework. When the exception is thrown, the
    framework will return an error response to the client. Let''s see what happens
    when we query for two portfolios—one that exists and one that doesn''t, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看生成此模式的代码，我们会看到 `portfolio` 方法抛出 `UnknownPortfolioException` 异常。这个异常由框架处理。当异常被抛出时，框架将向客户端返回一个错误响应。让我们看看当我们查询两个投资组合——一个存在的和一个不存在的——会发生什么，如下所示：
- en: '![Figure 11.2 – Multiple queries: one successful, one failing with an expected
    exception'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – 多个查询：一个成功，一个失败并抛出预期异常'
- en: '](img/B17377_11_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17377_11_02.jpg)'
- en: 'Figure 11.2 – Multiple queries: one successful, one failing with an expected
    exception'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 多个查询：一个成功，一个失败并抛出预期异常
- en: '*Figure 11.2* shows us that we can send multiple queries in the same request.
    It also shows us that we can receive partial results. In this case, the query
    to find portfolio details for `Emily J` was successful, but the query to find
    portfolio details for `Andy M` failed because his portfolio is not yet in the
    database.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.2* 显示我们可以在同一个请求中发送多个查询。它还显示我们可以接收部分结果。在这种情况下，查询 `Emily J` 的投资组合详情是成功的，但查询
    `Andy M` 的投资组合详情失败了，因为他的投资组合尚未在数据库中。'
- en: Now we have a basic understanding of how to create query methods, let's take
    a look at how we can create mutations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了如何创建查询方法，让我们看看我们如何创建突变。
- en: Developing mutations
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发突变
- en: When we think of **create, read, update, and delete** (**CRUD**) operations,
    queries are the *read* part, while mutations are everything else. That said, queries
    and mutations are just labels—a GraphQL query could certainly create, update,
    or delete entities, and a mutation could simply return a view of an entity, but
    that is not the intended practice.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到 **创建、读取、更新和删除** (**CRUD**) 操作时，查询是 *读取* 部分，而突变是其他所有操作。尽管如此，查询和突变只是标签——一个
    GraphQL 查询当然可以创建、更新或删除实体，而突变可以简单地返回实体的视图，但这不是预期的实践。
- en: Best practice
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Query methods should never manipulate entity data. Use queries for returning
    the current state of entities and mutations for changing that data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查询方法永远不应该操作实体数据。使用查询来返回实体的当前状态，使用突变来更改这些数据。
- en: 'To create a mutation method, you would just apply the `@Mutation` annotation
    to your Java method. In most cases, mutation methods will take parameters to indicate
    what sort of change to make and/or to specify which entities to update or delete.
    Let''s take a look at how we might use a mutation method to create a `Portfolio`
    object, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个变异方法，你只需将`@Mutation`注解应用到你的Java方法上。在大多数情况下，变异方法将接受参数来指示要进行的更改类型，以及/或者指定要更新或删除的实体。让我们看看我们如何使用变异方法来创建一个`Portfolio`对象，如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are a few things to notice here. First, the `createNewPortfolio` method
    returns the `Portfolio` object it just created—it actually calls the `portfolio`
    method we wrote in the last section to ensure that the new `Portfolio` object
    was created successfully in the database. Mutations, as with queries, must always
    return something. Void mutation or query methods are not allowed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。首先，`createNewPortfolio`方法返回它刚刚创建的`Portfolio`对象——它实际上调用了我们在上一节中编写的`portfolio`方法，以确保新的`Portfolio`对象在数据库中成功创建。变异，就像查询一样，必须始终返回某些内容。不允许有空的变异或查询方法。
- en: Suggestion
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 建议
- en: If you really don't want to return anything, consider returning a `boolean`
    value to indicate whether the mutation was completed successfully, or consider
    returning an `int` value, indicating how many entities were created/updated/deleted.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的不想返回任何内容，可以考虑返回一个`boolean`类型的值来表示变异是否成功完成，或者考虑返回一个`int`类型的值，表示创建了/更新了/删除了多少实体。
- en: 'The second thing to notice about this code is that it accepts a complex object
    as a parameter. This will cause some new entries to be generated in the schema.
    Let''s take a look, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此代码的第二个需要注意的地方是它接受一个复杂对象作为参数。这将在模式中生成一些新的条目。让我们看看如下：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These input types look very similar to the types we saw when we generated the
    schema for our query method. The difference is that these types are appended with
    `input`. GraphQL differentiates between types used for input and types used for
    output. One advantage of this is that it means it might be possible for clients
    to view things that they cannot modify or vice versa. So, what might the mutation
    look like in **GraphiQL**? Let''s take a look, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输入类型与我们生成查询方法模式时看到的类型非常相似。不同之处在于这些类型后面附加了`input`。GraphQL区分用于输入的类型和用于输出的类型。这有一个优点，即这意味着客户端可能可以查看他们无法修改或反之亦然的内容。那么，变异在**GraphiQL**中看起来会是什么样子呢？让我们看看如下：
- en: '![Figure 11.3 – Mutation creating a new portfolio'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 – 创建新投资组合的变异]'
- en: '](img/B17377_11_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17377_11_03.jpg](img/B17377_11_03.jpg)'
- en: Figure 11.3 – Mutation creating a new portfolio
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 创建新投资组合的变异
- en: '*Figure 11.3* shows how to specify a complex parameter, `portfolio`. The syntax
    is very similar to JSON, but not exactly—notice that the field names are not in
    quotes. Notice also that the mutation specifies a return value, `owner`—a valid
    query or mutation must contain at least one return value.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.3* 展示了如何指定一个复杂的参数，`portfolio`。语法与JSON非常相似，但并不完全一样——注意字段名没有引号。还要注意变异指定了一个返回值，`owner`——一个有效的查询或变异必须包含至少一个返回值。'
- en: A note about parameters and pagination
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于参数和分页的说明
- en: Parameters in a query or mutation do not need to be related to the underlying
    business entity. You could also use parameters for `pageNumber` and `entriesPerPage`
    so that the client can process the portfolios at its own pace.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或变异中的参数不需要与底层业务实体相关。你也可以使用参数来指定`pageNumber`和`entriesPerPage`，这样客户端就可以根据自己的节奏处理投资组合。
- en: Now we've covered queries and mutations, let's take a closer look at entities
    and how we can shape them into what we want in the GraphQL world!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了查询和变异，让我们更深入地看看实体以及我们如何在GraphQL世界中塑造它们！
- en: Writing entities
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写实体
- en: Entities are all complex types (not **scalars**) used for input or output. The
    MP GraphQL runtime will compute all entities that are referenced by root-level
    queries and mutations, and it will automatically add them to the schema. It will
    differentiate between entities that are used as parameters (input) and entities
    used as return values (output). And, as we discovered in the last section, the
    framework will also add entities referenced by other entities that may not necessarily
    be directly referenced by root-level queries and mutations. This includes classes,
    enums, and **interfaces**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实体都是用于输入或输出的复杂类型（不是**标量**）。MP GraphQL 运行时会计算所有由根级查询和突变引用的实体，并将它们自动添加到模式中。它将区分用作参数（输入）的实体和用作返回值（输出）的实体。而且，正如我们在上一节中发现的那样，框架还会添加由其他实体引用的实体，这些实体可能不是由根级查询和突变直接引用的。这包括类、枚举和**接口**。
- en: Using GraphQL interfaces
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 GraphQL 接口
- en: 'We''ve already covered basic classes and enums as entities, so let''s now take
    a look at interfaces. Just as with interfaces in Java, GraphQL interfaces can
    be implemented by concrete GraphQL types. One difference is that input types cannot
    implement interfaces, which can make things tricky. Let''s take a look at an example
    to get a better understanding. Suppose we want to have a portfolio owner *profile*
    that contains the contact information of the account owner. Since some portfolio
    accounts might be managed by somebody other than the owner, we might want two
    different types of profiles—one for single-person owners and one for accounts
    with a designated manager. To meet this requirement, we might code up something
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了作为实体的基本类和枚举，现在让我们看看接口。与 Java 中的接口一样，GraphQL 接口可以被具体的 GraphQL 类型实现。一个区别是输入类型不能实现接口，这可能会使事情变得复杂。让我们通过一个例子来更好地理解。假设我们想要一个包含账户所有者联系信息的投资组合所有者*配置文件*。由于一些投资组合账户可能由除所有者之外的人管理，我们可能想要两种不同的配置文件类型——一种用于单人所有者，另一种用于指定管理员的账户。为了满足这个要求，我们可能编写如下代码：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code snippet, we see the `@Interface` annotation applied to
    the `OwnerProfile` interface. This tells the MP GraphQL framework to treat this
    interface as a GraphQL interface in the schema. The framework will then search
    for implementations of this interface and add them to the schema as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们看到 `@Interface` 注解应用于 `OwnerProfile` 接口。这告诉 MP GraphQL 框架将此接口作为模式中的
    GraphQL 接口处理。然后，框架将搜索此接口的实现，并将它们也添加到模式中。
- en: 'Next, let''s take a look at what the API class might look like, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 API 类可能的样子，如下所示：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that the API class has separate mutation methods for creating each type
    of profile. This is an unfortunate side effect of GraphQL not allowing input types
    to implement interfaces—even though the Java code implements the interface, the
    GraphQL code does not. This means that the parameters must not be interfaces.
    On the other hand, output types don''t have this limitation, so we can use a single-query
    method that will handle both profile types. The combination of this API class
    and the entity interface and classes will generate a schema that looks like this
    (abbreviated):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，API 类为创建每种类型的配置文件提供了单独的突变方法。这是 GraphQL 不允许输入类型实现接口的一个不幸副作用——尽管 Java 代码实现了接口，但
    GraphQL 代码并没有。这意味着参数不能是接口。另一方面，输出类型没有这种限制，因此我们可以使用一个查询方法来处理两种配置文件类型。这个 API 类与实体接口和类的组合将生成一个如下所示的模式（简化版）：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we''d expect, the `ManagedOwnerProfileImpl` type implements the `OwnerProfile`
    interface. It has the same fields as the interface, and it also has a couple of
    extra fields. So, how do we access these extra fields in a query? The magic happens
    on *lines 6* and *14* of the query, as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，`ManagedOwnerProfileImpl` 类型实现了 `OwnerProfile` 接口。它具有与接口相同的字段，并且还有一些额外的字段。那么，我们如何在查询中访问这些额外的字段呢？魔法发生在查询的*第
    6 行*和*第 14 行*，如下面的截图所示：
- en: '![Figure 11.4 – Query using interfaces'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 – 使用接口的查询'
- en: '](img/B17377_11_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17377_11_04.jpg)'
- en: Figure 11.4 – Query using interfaces
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 使用接口的查询
- en: As seen in *Figure 11.4*, the `… on ManagedOwnerProfileImpl` code is similar
    to casting the interface to the implementation class and then invoking getter
    methods that only exist on the implementation class in Java. Notice in the output
    that the profile type returned for `Emily J` is not a `ManagedOwnerProfileImpl`
    type, so it does not contain the additional fields.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11.4* 所示，`… on ManagedOwnerProfileImpl` 代码类似于将接口转换为实现类，然后调用仅在实现类上存在的 getter
    方法。注意在输出中，为 `Emily J` 返回的配置文件类型不是 `ManagedOwnerProfileImpl` 类型，因此它不包含额外的字段。
- en: Just as with Java, interfaces can be quite useful for organizing and reusing
    entities. Now, let's look at how we can further refine entities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Java 一样，接口对于组织和重用实体非常有用。现在，让我们看看我们如何进一步细化实体。
- en: Using entity annotations
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用实体注解
- en: It's not uncommon to have an entity class that you want to expose as part of
    the GraphQL schema, but maybe rename a field (or exclude one) or make a field
    read-only, or make some other modification. This is possible using annotations
    on entity fields and/or getter/setter methods. Since MP GraphQL integrates with
    **JSON Binding** (**JSON-B**), many of the MP GraphQL-specific annotations can
    be replaced by JSON-B annotations to avoid annotation overload.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 模式中将实体类公开是很常见的，但可能需要重命名一个字段（或排除一个）或使一个字段为只读，或者进行其他修改。这可以通过在实体字段和/或
    getter/setter 方法上使用注解来实现。由于 MP GraphQL 与 **JSON 绑定**（**JSON-B**）集成，许多 MP GraphQL
    特定的注解可以被 JSON-B 注解所替代，以避免注解过载。
- en: We've already seen the `@Name` annotation used on parameters in query/mutation
    methods, but we can also use this annotation on entity fields and getters/setters
    to *rename* the field in the generated GraphQL schema. As with all of the annotations
    described in this section, if you put the annotation on the getter method it will
    only apply to the output type. If you put the annotation on the setter method,
    it will only apply to the input type. If you put it on the field, it will apply
    to both.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在查询/突变方法中的参数上使用 `@Name` 注解，但我们也可以在实体字段和 getters/setters 上使用此注解来 *重命名*
    在生成的 GraphQL 模式中字段。与本章中描述的所有注解一样，如果您将注解放在 getter 方法上，它将仅应用于输出类型。如果您将注解放在 setter
    方法上，它将仅应用于输入类型。如果您将其放在字段上，它将应用于两者。
- en: 'The following table lists the annotations that can be quite useful when adding
    entities to your GraphQL applications:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了在向您的 GraphQL 应用程序添加实体时可能非常有用的注解：
- en: '![Table 11.1 – MP GraphQL entity annotations and their JSON-B equivalents'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 11.1 – MP GraphQL 实体注解及其 JSON-B 等价物'
- en: '](img/Table_11.1.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_11.1.jpg)'
- en: Table 11.1 – MP GraphQL entity annotations and their JSON-B equivalents
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 – MP GraphQL 实体注解及其 JSON-B 等价物
- en: Applying these annotations to your entity types allows you to better control
    the external view of your model classes and better reuse existing classes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些注解应用于您的实体类型可以使您更好地控制模型类的外部视图，并更好地重用现有类。
- en: Outsourcing
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外包
- en: Suppose you have an entity with a field that is expensive to compute—maybe it
    requires intensive mathematical computation, or perhaps it requires querying a
    remote database, and so on. It seems wasteful to compute that field when the client
    isn't interested in it. Fortunately, it's possible to avoid expensive computation
    by `@Source` annotation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个具有计算成本高昂的字段的实体——可能需要复杂的数学计算，或者可能需要查询远程数据库等。当客户端对它不感兴趣时计算该字段似乎是浪费的。幸运的是，可以通过
    `@Source` 注解避免昂贵的计算。
- en: 'For example, let''s suppose that the profile service wants to be able to check
    the loyalty level of a given portfolio owner, but that information is in the portfolio
    database, not the profile database. So, in this example, a client wanting to see
    profile data would end up asking the server to connect to two different databases
    to get the results. We can optimize this situation by only checking the portfolio
    database if the client requests the loyalty field. We do this by putting a `getLoyalty(@Source
    OwnerProfileImpl profile)` method in the `ProfileGraphQLApi` class, like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设配置文件服务需要能够检查特定投资组合所有者的忠诚度级别，但该信息位于投资组合数据库中，而不是配置文件数据库中。因此，在这个例子中，想要查看配置文件数据的客户端最终会要求服务器连接到两个不同的数据库以获取结果。我们可以通过仅在客户端请求忠诚度字段时检查投资组合数据库来优化这种情况。我们通过在
    `ProfileGraphQLApi` 类中添加一个 `getLoyalty(@Source OwnerProfileImpl profile)` 方法来实现这一点，如下所示：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What this does is *adds* a new field, `loyalty`, to the `OwnerProfileImpl` entity
    in the schema. From the client's view, this new field is just like any other field,
    but the `getLoyalty` method is only invoked if the client specifically requests
    that field. This is a useful way to avoid paying for expensive operations when
    the client has no use for the resulting data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的操作是在模式中的`OwnerProfileImpl`实体中*添加*了一个新的字段，`loyalty`。从客户端的角度来看，这个新字段就像任何其他字段一样，但只有当客户端明确请求该字段时，`getLoyalty`方法才会被调用。这是一种避免在客户端不需要结果数据时支付昂贵操作费用的有用方式。
- en: Best practice
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Use the `@Source` annotation for expensive data fetching in order to optimize
    server-side performance. This also enables you to reduce memory consumption on
    the server for large queries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Source`注解进行昂贵的数据获取，以优化服务器端性能。这也使得你能够减少大型查询在服务器上的内存消耗。
- en: If the `@Source` method throws an exception, the MP GraphQL framework will return
    a null result for that field and will send error data but will continue to send
    the data from other fields as partial results.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`@Source`方法抛出异常，MP GraphQL框架将为该字段返回一个null结果，并将发送错误数据，但将继续发送来自其他字段的数据作为部分结果。
- en: Sending partial results using GraphQLException
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GraphQLException发送部分结果
- en: We've now seen two ways that we can send `@Source` annotation to outsource a
    field's data fetcher.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种方法可以将`@Source`注解发送出去以外包字段的数据获取器。
- en: 'A third way to send partial results is by using a `GraphQLException` exception.
    This exception allows you to include partial results before throwing the exception
    back to the MP GraphQL framework. The framework will then attempt to send the
    partial results with the error data back to the client. Here is an example of
    this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`GraphQLException`异常，还有一种发送部分结果的方法。这个异常允许你在抛出异常回MP GraphQL框架之前包含部分结果。然后框架将尝试将部分结果与错误数据一起发送回客户端。以下是一个示例：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This mutation allows clients to create multiple new portfolios in one request.
    If the client attempts to create a portfolio for an owner that already exists,
    this will cause an exception, but all of the other portfolios will still be created
    and their results will be sent back to the client, along with a list of portfolios
    that could not be created in the error data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变更允许客户端在一次请求中创建多个新的投资组合。如果客户端尝试为已存在的所有者创建投资组合，这将引发异常，但所有其他投资组合仍然会被创建，并将它们的结果以及无法创建的投资组合列表发送回客户端。
- en: In this section, we've learned how to construct a server-side GraphQL application
    in Java using MP GraphQL. While not specifically covered in this section, it should
    be noted that MP GraphQL integrates nicely with other MicroProfile features, such
    as Fault Tolerance and Metrics. The MP GraphQL 1.0 specification is officially
    released and supported in open source Java servers such as Open Liberty, Quarkus,
    and WildFly. Future versions of the specification will add new features such as
    support for subscriptions, the ability to define custom scalars, union types,
    built-in pagination support, and client APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用MP GraphQL在Java中构建服务器端GraphQL应用程序。虽然本节没有具体涉及，但应注意的是，MP GraphQL与MicroProfile的其他功能，如容错和度量，很好地集成。MP
    GraphQL 1.0规范已正式发布，并得到开源Java服务器（如Open Liberty、Quarkus和WildFly）的支持。规范的未来版本将添加新的功能，例如支持订阅、定义自定义标量、联合类型、内置分页支持和客户端API。
- en: In this section, we learned how to write simple and advanced GraphQL services
    using MicroProfile APIs. So far, we've only invoked these services using the **GraphiQL**
    tool. In the next section, we'll learn how we can invoke these services using
    Java APIs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用MicroProfile API编写简单和高级的GraphQL服务。到目前为止，我们只使用**GraphiQL**工具调用了这些服务。在下一节中，我们将学习如何使用Java
    API调用这些服务。
- en: Consuming GraphQL services with client APIs
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用客户端API消费GraphQL服务
- en: The client APIs are not officially part of the MP GraphQL specification yet.
    At the time of writing, these APIs are still under development in the **SmallRye
    GraphQL** project, with the intention of formalizing them into the specification.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端API目前还不是MP GraphQL规范的官方部分。在撰写本文时，这些API仍在**SmallRye GraphQL**项目中开发，目的是将它们正式纳入规范。
- en: Disclaimer
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 免责声明
- en: Since these APIs are not official yet, they are subject to change. The information
    in this section pertains to the SmallRye GraphQL version 1.2.3 client APIs. These
    APIs may change when added to the official MP GraphQL specification, so please
    check with the official documentation at [https://github.com/eclipse/microprofile-graphql](https://github.com/eclipse/microprofile-graphql)
    for any changes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些API尚未官方发布，它们可能会发生变化。本节中的信息适用于SmallRye GraphQL版本1.2.3客户端API。当这些API添加到官方MP
    GraphQL规范中时，它们可能会发生变化，因此请查阅[https://github.com/eclipse/microprofile-graphql](https://github.com/eclipse/microprofile-graphql)的官方文档以了解任何更改。
- en: The MP GraphQL project intends to support two flavors of client APIs. Similar
    to the JAX-RS client and the MicroProfile REST client (see [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*), there is a **dynamic client** API and
    a **type-safe client** API. As with the JAX-RS client, the dynamic client allows
    users to specify the nitty-gritty details of the request, while the type-safe
    client allows users to construct an interface to model the remote service and
    simply invokes it when it wants to make a new request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: MP GraphQL项目旨在支持两种客户端API的版本。类似于JAX-RS客户端和MicroProfile REST客户端（见[*第4章*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068)，*开发云原生应用*），存在一个**动态客户端**API和一个**类型安全的客户端**API。与JAX-RS客户端一样，动态客户端允许用户指定请求的细节，而类型安全的客户端允许用户构建一个接口来模拟远程服务，并在需要发送新请求时简单地调用它。
- en: Both of these client APIs are demonstrated as integration tests in the GitHub
    repository at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client).
    They test an `allProfiles` query that returns all of the profiles known to the
    server. In our example, we've created two profiles for testing purposes. Let's
    take a look at the dynamic client first.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个客户端API在GitHub仓库的集成测试中得到了演示，仓库地址为[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client)。它们测试了一个`allProfiles`查询，该查询返回服务器所知的所有配置文件。在我们的例子中，我们创建了两个用于测试的配置文件。让我们首先看看动态客户端。
- en: Dynamic client
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态客户端
- en: 'The dynamic client works by building a `DynamicGraphQLClient` instance and
    then passing it as either a `Request` or a `Document` object. The `Request` object
    usually contains a plain text string with the query or mutation you wish to execute,
    while a `Document` object must be constructed programmatically. Let''s take a
    look at the `Request` approach first, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 动态客户端通过构建一个`DynamicGraphQLClient`实例，然后将其作为`Request`或`Document`对象传递来工作。`Request`对象通常包含一个包含您要执行的查询或变异的纯文本字符串，而`Document`对象必须通过编程方式构建。让我们首先看看`Request`方法，如下所示：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code snippet, we create a new `DynamicGraphQLClient` instance using
    the builder pattern and specifying the `http://localhost:9080/ch11/graphql`. We
    then call the `executeSync` method on that client instance, passing it as `RequestImpl`
    with our query in a plain text string. This returns a `Response` object that we
    can extract a JSON-P `JsonObject` instance from that contains the data from the
    GraphQL result.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们使用建造者模式创建一个新的`DynamicGraphQLClient`实例，并指定`http://localhost:9080/ch11/graphql`。然后，我们在该客户端实例上调用`executeSync`方法，将带有我们的查询的纯文本字符串作为`RequestImpl`传递。这返回一个`Response`对象，我们可以从中提取包含GraphQL结果的JSON-P
    `JsonObject`实例。
- en: 'Another way that we could write this is more like a builder pattern, where
    we build each part of the query into a `Document` object using Java code. Here
    is an example of this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用更类似于建造者模式的方式来编写这个，其中我们使用Java代码将查询的每一部分构建成一个`Document`对象。以下是一个例子：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this code, we create an `allProfiles` field for the query itself, and then
    create the sub-fields we are interested in: `ownerId` and `emailAddress`. We then
    construct an `Operation` from the query field and a `Document` object from the
    `Operation`. We then pass the `Document` object to the `executeSync` method in
    order to invoke the query, and our `Response` object is the same as in the previous
    code snippet. This may seem more complicated than simply writing up the query
    in plain text, but the advantage is that you could use this approach to build
    more complicated queries depending on the situation—for example, you could programmatically
    request additional fields in your query for certain situations.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们为查询本身创建了一个 `allProfiles` 字段，然后创建了我们所感兴趣的子字段：`ownerId` 和 `emailAddress`。然后，我们从查询字段构造一个
    `Operation`，并从 `Operation` 构造一个 `Document` 对象。然后，我们将 `Document` 对象传递给 `executeSync`
    方法以调用查询，我们的 `Response` 对象与之前的代码片段相同。这可能会比简单地用纯文本编写查询看起来更复杂，但优点是你可以根据情况使用这种方法构建更复杂的查询——例如，你可以根据某些情况在查询中程序化地请求额外的字段。
- en: The dynamic client is a nice way to write GraphQL queries and mutations that
    might require changes, depending on when they are invoked. For situations where
    you expect the query to be somewhat static, the type-safe client is more appropriate.
    Let's see what that looks like next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 动态客户端是一种编写可能需要根据调用时间进行更改的 GraphQL 查询和变异的好方法。对于预期查询相对静态的情况，类型安全的客户端更为合适。接下来，让我们看看它是什么样子。
- en: Type-safe client
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型安全客户端
- en: 'The type-safe client borrows a lot of its design from the MicroProfile REST
    client. It uses annotations and interfaces to represent the remote service and
    then either a builder pattern or CDI injection to create a client instance. Let''s
    take a look at how we might code this up in an integration test case. First, we''ll
    need to represent the actual response object, the `OwnerProfile` object, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全的客户端借鉴了 MicroProfile REST 客户端的设计。它使用注解和接口来表示远程服务，然后使用构建器模式或 CDI 注入来创建客户端实例。让我们看看我们如何在集成测试用例中实现这一点。首先，我们需要表示实际的响应对象，即
    `OwnerProfile` 对象，如下所示：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is very similar to the same class on the server side. Let''s now see what
    the client interface looks like, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这与服务器端的相同类非常相似。现在，让我们看看客户端接口的样子，如下所示：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This interface is annotated with `@GraphQLClientApi` to indicate that it represents
    the remote service. Because we are only interested in the `allProfiles` query,
    we only have one method: `allProfiles`. We could add other methods to match other
    queries or mutations. Since this is a single-query method, we don''t need to annotate
    it with `@Query`, but if we wanted to include mutations, then we would need to
    specify which methods are which, with the `@Query` and `@Mutation` annotations.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口使用 `@GraphQLClientApi` 注解来表示它代表远程服务。因为我们只对 `allProfiles` 查询感兴趣，所以我们只有一个方法：`allProfiles`。我们可以添加其他方法来匹配其他查询或变异。由于这是一个单查询方法，我们不需要用
    `@Query` 注解它，但如果我们想包括变异，那么我们就需要使用 `@Query` 和 `@Mutation` 注解来指定哪些方法是哪些。
- en: 'Let''s now tie this all together with the builder code and the execution, as
    follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过构建代码和执行来整合所有这些内容，如下所示：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We build an instance of the `ProfileApi` client interface using `TypesafeGraphQLClientBuilder`.
    Then, once we invoke a method on this interface, the query is sent to the server
    and returns with a list of owner profiles identical to the data returned using
    the dynamic client in the previous section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `TypesafeGraphQLClientBuilder` 构建一个 `ProfileApi` 客户端接口的实例。然后，一旦我们在该接口上调用一个方法，查询就会被发送到服务器，并返回与上一节中动态客户端返回的相同的数据列表。
- en: Both of these client options provide a lot of power and flexibility for invoking
    remote GraphQL services, even those not built with MicroProfile—or even Java.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种客户端选项都为调用远程 GraphQL 服务提供了大量的功能和灵活性，即使这些服务不是用 MicroProfile 或 Java 构建的。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned about GraphQL and how it addresses some of the
    gaps in REST. We've also learned how to create and consume GraphQL services using
    MP GraphQL, without the overhead of maintaining a schema in addition to Java code.
    We've learned that we can build queries and mutations by applying annotations
    to our API classes and that we can enrich them by adding descriptions, parameters,
    formatting, and more. By outsourcing, we've learned that we can avoid executing
    expensive operations when they are not necessary. We've also learned how to send
    partial results when exceptions occur. We've learned that there are some useful
    tools such as **GraphiQL** that can simplify testing. And while the client APIs
    aren't fully supported from the specification, we've been able to view two different
    clients, and we've seen how we could use them for integration testing or to consume
    GraphQL services.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 GraphQL 以及它是如何填补 REST 中的一些空白的。我们还学习了如何使用 MP GraphQL 创建和消费 GraphQL
    服务，而无需额外维护一个与 Java 代码并存的模式。我们了解到，通过在 API 类上应用注解，我们可以构建查询和突变，并通过添加描述、参数、格式化等功能来丰富它们。通过外包，我们学会了在不需要时避免执行昂贵的操作。我们还学习了在发生异常时如何发送部分结果。我们还了解到，有一些有用的工具，如
    **GraphiQL**，可以简化测试。尽管客户端 API 在规范中并未得到完全支持，但我们已经能够查看两个不同的客户端，并看到我们如何可以使用它们进行集成测试或消费
    GraphQL 服务。
- en: With what we've learned in this chapter, combined with the tools available at
    our disposal, we are now able to develop and test cloud-native GraphQL applications
    or apply a GraphQL frontend to our existing applications. Our microservices can
    now avoid over-fetching and under-fetching, reducing network traffic and giving
    clients exactly what they want.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 结合本章所学，再加上我们可用的工具，我们现在能够开发和测试云原生 GraphQL 应用，或者将 GraphQL 前端应用到我们的现有应用中。我们的微服务现在可以避免过度获取和不足获取，减少网络流量，并为客户提供他们真正需要的内容。
- en: In the next chapter, we will take a look at the future of MicroProfile and see
    what changes we can expect to see in the years to come.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 MicroProfile 的未来，并看看我们未来几年可以期待看到哪些变化。
