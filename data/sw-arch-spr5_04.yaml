- en: Client-Server Architectures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: The client-server architecture is one of the most common architectural styles
    applied today, and it has been used in many different ways.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构是当今最常见的架构风格之一，并且已经以许多不同的方式使用。
- en: When we hear the term client-server architecture, we often think of old applications
    that provide a UI for editing complex databases in which the major part of the
    business logic resides. However, the truth is that this architectural style offers
    underlying support for almost every single modern architectural style, including
    microservices, event-driven architectures, or any distributed computing system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们听到客户端-服务器架构这个术语时，我们经常会想到提供UI用于编辑复杂数据库的旧应用程序，其中大部分业务逻辑驻留。然而，事实是，这种架构风格为几乎每种现代架构风格提供了基础支持，包括微服务、事件驱动架构或任何分布式计算系统。
- en: In this chapter, we will review how the client-server architecture works, as
    well as how it can be implemented. We will use the Spring Framework to build the
    server side, and then we'll code clients interacting with the server using Java.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾客户端-服务器架构的工作原理，以及如何实现它。我们将使用Spring框架构建服务器端，然后使用Java编写与服务器交互的客户端。
- en: 'This chapter will cover the following points:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Understanding client-server architectures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解客户端-服务器架构
- en: Where to apply client-server architectures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何处应用客户端-服务器架构
- en: 'Implementing client-server architectures:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现客户端-服务器架构：
- en: Writing a server with Spring
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring编写服务器
- en: Introducing Spring actuator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Spring执行器
- en: Monitoring the health of an application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控应用程序的健康状况
- en: Writing clients with Java FX and Android
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java FX和Android编写客户端
- en: Testing the implemented code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试实现的代码
- en: Understanding client-server architectures
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解客户端-服务器架构
- en: 'In client-server architectures, each running process is either a server or
    a client. They interact with each other using requests that are sent through a
    defined communication channel, in a network that connects them together. We have all used
    an email service, and we understand how such a service works; that is the quintessential
    example of a client-server architecture, illustrated in the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器架构中，每个运行的进程都是服务器或客户端。它们通过定义的通信渠道在网络中相互交互。我们都使用过电子邮件服务，并且了解这样的服务是如何工作的；这是客户端-服务器架构的典型例子，如下图所示：
- en: '![](img/f5421274-ee5a-4aaf-9e8d-827353a7a226.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5421274-ee5a-4aaf-9e8d-827353a7a226.png)'
- en: Email service components
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件服务组件
- en: 'We will now provide a brief overview of each component in the preceding diagram,
    in order to explain how it fits within the client-server architectural style.
    The precedingdiagram is comprised of the following parts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简要概述前面图表中的每个组件，以解释它们如何适用于客户端-服务器架构风格。前面的图表由以下部分组成：
- en: The server (**1**)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器（**1**）
- en: The request payload (2)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求有效载荷（2）
- en: The clients accessing the server resources (**3**)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问服务器资源的客户端（**3**）
- en: Server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: The server is in charge of processing the received requests (which should comply
    with a predefined format), and then producing results.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器负责处理接收到的请求（应符合预定义格式），然后生成结果。
- en: Once the data is retrieved, a whole process begins, checking the requests before
    processing them. This process begins by authenticating and authorizing checks
    that verify the client’s identity. A validation process then starts, to review
    the input provided by clients, and the provided body request is tested to verify
    its structure. After that, checks to validate that the data complies with the
    business logic constraints are executed. To finish, the requests are processed
    by the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被检索，整个过程开始，检查请求之前进行处理。这个过程从验证和授权检查开始，验证客户端的身份。然后开始验证过程，以审查客户端提供的输入，并测试提供的请求主体以验证其结构。之后，执行验证数据是否符合业务逻辑约束的检查。最后，服务器处理请求。
- en: These steps make it possible to achieve a certain level of reliability within
    the application, since ill-intentioned or corrupt requests that would eventually
    destroy the data or convert the system into an inconsistent state are not processed
    at all.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤使得在应用程序中实现一定程度的可靠性成为可能，因为恶意或损坏的请求根本不会被处理，这些请求最终会破坏数据或使系统变得不一致。
- en: The responses offered by the server are often services or resources that will
    be consumed by the clients later. When the requests are not processed successfully,
    a response, including reasonable information, is remitted to the client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器提供的响应通常是稍后由客户端使用的服务或资源。当请求未能成功处理时，将向客户端发送包含合理信息的响应。
- en: A high-performance server is used to support the required processing. The servers
    are located in an on-premise or cloud-based infrastructure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能服务器用于支持所需的处理。服务器位于本地或基于云的基础设施中。
- en: Scaling
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: Once the server is in production, it's a good idea to monitor its resource consumption
    and business metrics associated with the application. If we identify any anomalies
    or high traffic, we should consider scaling the server to offer a better user
    experience.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器投入生产，监控其资源消耗和与应用程序相关的业务指标是个好主意。如果我们发现任何异常或高流量，我们应该考虑扩展服务器以提供更好的用户体验。
- en: Since a client can be any device that is able to connect to the server, including separate
    computers, we might suddenly have millions of clients accessing the server. When
    the application ran on one machine, the balance of resource consumption between
    the client and server parts of the application was fixed. However, as soon as
    clients and servers could be scaled independently, it became easy for clients
    to scale way out of proportion to the server's capacity. Today, clients only need
    to interact with one user. Because of this, it is easy for them to have adequate
    resources. However, servers may be asked to support numbers of clients across
    a wide, dynamic range. It’s in this situation that scaling becomes an important
    technical requirement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端可以是任何能够连接到服务器的设备，包括独立的计算机，我们可能会突然有数百万个客户端访问服务器。当应用程序在一台机器上运行时，应用程序的客户端和服务器部分之间的资源消耗平衡是固定的。然而，一旦客户端和服务器可以独立扩展，客户端的规模就变得远远超过服务器的容量。今天，客户端只需要与一个用户进行交互。因此，他们很容易获得足够的资源。然而，服务器可能被要求支持跨广泛、动态范围的客户端数量。在这种情况下，扩展成为一个重要的技术要求。
- en: 'We have two options for scaling a server, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种选项来扩展服务器，如下所示：
- en: Vertical
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直
- en: Horizontal
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平
- en: We can think about vertical scaling for services that cannot be deployed on
    more than one node, because of its own nature. A node can be represented by a
    computer or process running the service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于因其自身特性而无法部署在多个节点上的服务，我们可以考虑垂直扩展。一个节点可以由运行服务的计算机或进程来表示。
- en: 'In this scaling option, we can only scale a service by adding more resources,
    such as RAM, CPU, hard-disk, and so on, as shown in the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种扩展选项中，我们只能通过增加更多资源（如RAM、CPU、硬盘等）来扩展服务，如下图所示：
- en: '![](img/99beb40a-bd5a-490a-bac7-8258f95e3d53.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99beb40a-bd5a-490a-bac7-8258f95e3d53.png)'
- en: Vertical scaling
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展
- en: An explicit limitation that we have is that we can only increase the power of
    the unique process that is running the service.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一个明确限制是，我们只能增加运行服务的唯一进程的功率。
- en: On the other hand, if you have a stateless service, like a REST API, it can
    be deployed on more than one node, making it possible to scale the service horizontally.
    This approach allows us to scale applications in a better way, but a load balancer
    should be in front of them, in order to route the request appropriately, using
    an algorithm for it. A typical algorithm to use is round-robin, which distributes
    the requests equally among all of the available nodes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您有一个无状态的服务，比如REST API，它可以部署在多个节点上，从而可以水平扩展服务。这种方法允许我们更好地扩展应用程序，但负载均衡器应该放在它们的前面，以便使用算法适当地路由请求。一个典型的算法是轮询，它将请求均匀地分配给所有可用的节点。
- en: 'The following diagram shows servers arranged behind a load balancer, using
    a horizontal scaling approach:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了服务器在负载均衡器后面排列，使用水平扩展方法：
- en: '![](img/0c8e0523-718c-400c-95ae-c40d00a2f5bf.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c8e0523-718c-400c-95ae-c40d00a2f5bf.png)'
- en: Horizontal scaling
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展
- en: Request
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求
- en: A request is a piece of information that is sent to the server by a client.
    The client and the server have to agree on the protocol that they use to communicate,
    in order to allow them to interact with each other.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请求是客户端向服务器发送的一段信息。客户端和服务器必须就它们用于通信的协议达成一致，以便允许它们相互交互。
- en: In order to facilitate the exchange of data, it is recommended that an SDK (or
    some sort of library) be provided by the product vendors. For example, if you're
    interested in interacting with a database from a Java application, there are drivers
    coded in the form of libraries that can be used for that. Furthermore, the database
    vendors also provide drivers for different programming languages, desktop applications,
    or UIs, to interact with servers such as pgAdmin or MySQL Workbench.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进数据交换，建议产品供应商提供SDK（或某种库）。例如，如果您想从Java应用程序与数据库进行交互，那么有以库形式编码的驱动程序可供使用。此外，数据库供应商还为不同的编程语言、桌面应用程序或UI提供与服务器交互的驱动程序，如pgAdmin或MySQL
    Workbench。
- en: Providing an SDK is not a must; even when an SDK is provided, an easy to understand
    document will avoid introducing a conformist relationship between the server and
    clients.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 提供SDK并不是必须的；即使提供了SDK，易于理解的文档也会避免在服务器和客户端之间引入顺从关系。
- en: '**Conformist relationship** is a term coined by domain driven design. It suggests
    that a service has a complex and large model that forces the downstream dependencies
    to be modified when the server introduces new changes or releases new features.
    The modification should happen, because the effort required to write their own
    model adaptations or mechanisms to interact with the server is extremely high
    and is difficult to achieve.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺从关系**是领域驱动设计提出的一个术语。它表明一个服务有一个复杂和庞大的模型，当服务器引入新的变化或发布新的功能时，强制下游依赖关系进行修改。修改应该发生，因为编写自己的模型适应或与服务器交互的机制所需的工作量非常大，难以实现。'
- en: Client
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'There are a plenty of options that can be used for application clients. For
    the email example, it''s well known that there are native applications included
    as part of the computers'' operating systems, and also in mobile devices like
    smartphones, iPads, or tablets, that can be configured to interact with existing
    email servers. There are two types of clients, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于应用程序客户端的选项有很多。以电子邮件为例，众所周知，计算机操作系统中包含原生应用程序，移动设备如智能手机、iPad或平板电脑也可以配置为与现有的电子邮件服务器进行交互。有两种类型的客户端，如下所示：
- en: Fat clients
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fat clients
- en: Thin clients
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thin clients
- en: Fat clients have implemented logic that is in charge of performing some validations,
    formatting data, and fulfilling other related duties. They are designed to make
    the interaction between the end users and the server easier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Fat clients具有实现逻辑，负责执行一些验证、格式化数据和履行其他相关职责。它们旨在使最终用户与服务器之间的交互更加容易。
- en: Think about a Windows PC running Outlook. This represents a classic example
    of a fat client. In contrast, a web browser talking to a webmail site is a good
    example of a thin client.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下运行Outlook的Windows PC。这代表了一个典型的厚客户端的例子。相比之下，与Web邮件站点进行通信的Web浏览器是一个瘦客户端的典型例子。
- en: We can also compare fat clients with regards to the native applications running
    on our mobile phones that can partially work when they are unable to establish
    communication with the server; meanwhile, a thin client, like a web browser, is
    absolutely useless.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将厚客户端与在我们的手机上运行的本机应用程序进行比较，当它们无法与服务器建立通信时，它们可以部分工作；与之相反，像Web浏览器这样的瘦客户端是绝对无用的。
- en: Within the fat client category, we also have middleware, which often consumes
    more than one service and orchestrates the requests to accomplish a business goal.
    The most common examples are the **enterprise service buses** (**ESB**) commonly
    used as part of SOA architectures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在厚客户端类别中，我们还有中间件，它通常消耗多个服务并编排请求以实现业务目标。最常见的例子是作为SOA架构的一部分常用的**企业服务总线**（**ESB**）。
- en: Thin clients are quite simple, and they count with a simple mechanism that makes
    it possible to interact with the server. A common example of this is `curl` commands,
    used to interact with Rest-APIs through the HTTP(S) protocol.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 瘦客户端非常简单，并且具有一个简单的机制，可以与服务器进行交互。一个常见的例子是使用`curl`命令通过HTTP(S)协议与Rest-API进行交互。
- en: Network
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: A network is a medium that supports communications between servers and clients,
    following the request-response messaging pattern in which a client sends a request
    to the server and the server responds to the request by using this medium. A typical
    example of a network is the internet, which enables us to communicate with all
    devices connected to it. Today, there are tons of devices that can be connected
    to the internet, including computers, tablets, smartphones, Arduino, Raspberry
    PI, and others. The use of these devices has enabled the growth of the **Internet
    of Things** (**IoT**), giving us the chance to innovate and create a new era of
    applications. There are also other sorts of networks, such as Bluetooth, LiFi,
    LAN, and so on, that can be used to allow interaction between clients and servers,
    depending on business needs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一种支持服务器和客户端之间通信的媒介，遵循请求-响应消息传递模式，其中客户端通过这种媒介向服务器发送请求，服务器通过这种媒介响应请求。网络的一个典型例子是互联网，它使我们能够与连接到它的所有设备进行通信。今天，有大量设备可以连接到互联网，包括计算机、平板电脑、智能手机、Arduino、树莓派等。这些设备的使用已经推动了**物联网**（**IoT**）的发展，使我们有机会创新并创建一个新的应用时代。还有其他类型的网络，如蓝牙、LiFi、局域网等，可以根据业务需求允许客户端和服务器之间的交互。
- en: Where to apply client-server architectures
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在哪里应用客户端-服务器架构
- en: There are a bunch of situations where the client-server architectural style
    can be used. Let's review some typical examples, in order to better understand
    this approach.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下可以使用客户端-服务器架构风格。让我们回顾一些典型的例子，以更好地理解这种方法。
- en: As mentioned previously, databases commonly fit this architectural style. Currently,
    we have many database vendors available in the market, and the majority of them
    only offer the chance to scale vertically. Two classic examples of this approach
    are SQL Server and PostgreSQL. However, there are options to scale horizontally,
    as well. The most well-known database following this model is Cassandra, which
    is a database created by Facebook that was later adopted as an Apache project.
    This database uses a ring model to connect different nodes, where the data is
    stored. In this manner, you can add as many nodes as you need to, in order to
    support high-availability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据库通常适用于这种架构风格。目前，市场上有许多数据库供应商，其中大多数只提供垂直扩展的机会。这种方法的两个经典例子是SQL Server和PostgreSQL。然而，也有水平扩展的选项。按照这种模型的最著名的数据库是Cassandra，这是Facebook创建的数据库，后来被采纳为Apache项目。这个数据库使用环模型连接不同的节点，数据存储在其中。通过这种方式，您可以根据需要添加尽可能多的节点，以支持高可用性。
- en: Chat services, like Slack, are a classic example of client-server architectures
    that use the cloud. This chat has clients for almost any computer operating system,
    and for mobile platforms, as well; you can even use it directly on the browser,
    if you don't want to install a native application on your device.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 像Slack这样的聊天服务是使用云的客户端-服务器架构的经典例子。这个聊天软件几乎为任何计算机操作系统提供客户端，也为移动平台提供客户端；甚至可以直接在浏览器上使用，如果您不想在设备上安装本机应用程序。
- en: Agents are also an interesting application of this architectural style. An agent
    is a piece of software in charge of sending information from the clients to the
    server, without needing human interaction attached to it. For example, New Relic
    ([https://newrelic.com/](https://newrelic.com/)) is an **Application Performance
    Monitoring and Management** (**APM**) used to monitor the health of servers and
    applications using agents.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也是这种架构风格的一个有趣的应用。代理是负责将客户端发送的信息发送到服务器的软件部分，无需人类交互。例如，New Relic（[https://newrelic.com/](https://newrelic.com/)）是一个用于监控服务器和应用程序健康状况的**应用性能监控和管理**（**APM**），使用代理发送数据。
- en: Let's suppose that you want to monitor your existing Java application. To achieve
    this goal, you only need to add the New Relic agent when the application is started,
    using the `javaagent` option. In this way, the agent will continually be sending
    information to New Relic, which will give us information related to the memory
    and CPU consumption, response time, and so on. In this case, the server that processes
    the data sent by the agents is also in the cloud.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要监视现有的Java应用程序。为了实现这个目标，您只需要在应用程序启动时添加New Relic代理，使用`javaagent`选项。这样，代理将不断向New
    Relic发送信息，这将为我们提供与内存和CPU消耗、响应时间等相关的信息。在这种情况下，处理代理发送的数据的服务器也在云中。
- en: The IoT also relies heavily on the use of client-server architectures, where
    small devices with sensors (or some other mechanisms) used to gather data are
    constantly sending information to servers in charge of analyzing that data, in
    order to execute operations, depending on what is needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网也严重依赖于客户端-服务器架构的使用，其中具有传感器（或其他机制）的小型设备不断向负责分析数据的服务器发送信息，以执行操作，具体取决于所需的操作。
- en: Implementing client-server architectures with Spring
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring实现客户端-服务器架构
- en: 'Now that you have a better comprehension of client-server architectures, we
    will code an example that follows this diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对客户端-服务器架构有了更好的理解，我们将编写一个遵循此图表的示例：
- en: '![](img/3d08bec7-ac5c-4d42-9a00-240da83e5b5f.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d08bec7-ac5c-4d42-9a00-240da83e5b5f.png)'
- en: Example of client-server architecture
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构示例
- en: The functionality of our application will be simple. The server will expose
    an endpoint with the customer's bank statement, and then we will code a few clients
    to consume that information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的功能将是简单的。服务器将公开一个包含客户银行对账单的端点，然后我们将编写几个客户端来使用该信息。
- en: The server
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: 'There are a bunch of options to build the server side using the Spring Framework,
    including the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring框架构建服务器端的选项有很多，包括以下内容：
- en: SOAP web services
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP Web服务
- en: RESTful Web Services
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful Web服务
- en: '**Common Object Request Broker Architecture** (**CORBA**)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共对象请求代理架构**（**CORBA**）'
- en: Sockets
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字
- en: AMQP
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMQP
- en: SOAP web services
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP Web服务
- en: 'SOAP web services were widely implemented by developers before the REST style
    appeared, and they are heavily based on the use of XML. There are also a bunch
    of libraries available to deal with them, including Apache CXF, and JAX-WS. The
    following screenshot represents a request payload for a simple addition operation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST风格出现之前，开发人员广泛实现了SOAP Web服务，它们严重依赖于XML的使用。还有一堆库可用于处理它们，包括Apache CXF和JAX-WS。以下屏幕截图代表了一个简单加法操作的请求有效载荷：
- en: '![](img/acbef2f4-beac-4927-bc6f-626025f79fb7.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acbef2f4-beac-4927-bc6f-626025f79fb7.png)'
- en: Request payload
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请求有效载荷
- en: 'The following screenshot shows how the response looks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了响应的外观：
- en: '![](img/4ad9822f-9121-4cb8-a9c1-c527959c0607.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ad9822f-9121-4cb8-a9c1-c527959c0607.png)'
- en: Response payload
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 响应有效载荷
- en: The preceding examples were taken from [http://www.dneonline.com/calculator.asmx?op=Add](http://www.dneonline.com/calculator.asmx?op=Add).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子取自[http://www.dneonline.com/calculator.asmx?op=Add](http://www.dneonline.com/calculator.asmx?op=Add)。
- en: These XML files are following the **Web Services Description Language** (**WSDL**)
    format used by SOAP web services.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些XML文件遵循SOAP Web服务使用的**Web服务描述语言**（**WSDL**）格式。
- en: RESTful web services
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful Web服务
- en: 'The RESTful style, on the other hand, is currently preferred, and there are
    a bunch of public APIs that use it. Common examples are companies such as GitHub
    and Yahoo. This style bases its functionality on the use of HTTP verbs, making
    it easy to understand how they work. For example, the following HTTP request makes
    it possible to query the repositories from GitHub:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，目前更受欢迎的是RESTful风格，有很多公共API使用它。常见的例子是GitHub和Yahoo等公司。这种风格基于HTTP动词的功能，使人们很容易理解它们的工作原理。例如，以下HTTP请求可以查询GitHub的存储库：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This style appeared in 2000, with Roy Fielding''s doctoral dissertation that
    explains the REST principles and dictates how well-designed web applications should
    behave. The use of HTTP verbs is described in the following table:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格于2000年出现，由Roy Fielding的博士论文解释了REST原则，并规定了良好设计的Web应用程序应该如何行为。使用HTTP动词的方法在下表中描述：
- en: '| **HTTP Method/Verb** | **Usage** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法/动词** | **用途** |'
- en: '| `GET` | Lists all of the resources available under the specified URI |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 列出指定URI下的所有资源 |'
- en: '| `POST` | Creates a new resource in the specified URI |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 在指定的URI中创建新资源 |'
- en: '| `PUT` | Replaces the existing resource under the specified URI with another
    one |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 用另一个资源替换指定URI下的现有资源 |'
- en: '| `DELETE` | Deletes the resource specified in the URI |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除指定URI中的资源 |'
- en: '| `PATCH` | Partially updates a resource that resides in the specified URI
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 部分更新驻留在指定URI中的资源 |'
- en: CORBA
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CORBA
- en: The CORBA is a really old standard, designed to allow applications written in
    different programming languages to interact with each other. It is hard to use
    this standard because of all of the required plumbing code to achieve the goal.
    CORBA is not popular nowadays, but some legacy applications still use it to interact
    with old code, written mainly in Cobol, which was one of the preferred programming
    languages to write banking cores.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CORBA是一个非常古老的标准，旨在允许用不同编程语言编写的应用程序相互交互。由于需要所有必需的管道代码来实现目标，使用这个标准很困难。CORBA如今不再流行，但一些遗留应用程序仍然使用它与主要用Cobol编写的旧代码进行交互，Cobol是编写银行核心的首选编程语言之一。
- en: Sockets
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字
- en: Sockets are a common protocol that became even more popular with the emergence
    of WebSockets, which establishes a full-duplex communication channel among the
    server and clients. A typical scenario wherein this protocol is used includes
    messenger applications, such as Slack.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是一种常见的协议，随着WebSockets的出现变得更加流行，它在服务器和客户端之间建立了全双工通信通道。这种协议通常用于包括Slack在内的信使应用程序的典型场景。
- en: AMQP
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AMQP
- en: Applications using the AMQP, or any similar messaging protocol, are designed
    to allow for interoperability among heterogeneous applications, with an asynchronous
    approach. There are a bunch of commercial and open source implementations, such
    as AWS-SQS/SNS and RabbitMQ, among others, that can be used to implement applications
    using this model. We are going to review how this works in detail in [Chapter
    6](47f3823d-e7cd-4384-b392-71c7daf27b2d.xhtml), *Event-Driven Architectures*.
    The basic concept of this approach is to use a messaging broker in charge of receiving
    messages, and then distribute them to their subscribers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AMQP或任何类似的消息传递协议的应用程序旨在允许异构应用程序之间的互操作性，采用异步方法。有许多商业和开源实现，如AWS-SQS/SNS和RabbitMQ等，可以用于实现使用此模型的应用程序。我们将在[第6章](47f3823d-e7cd-4384-b392-71c7daf27b2d.xhtml)中详细审查这个工作原理，*事件驱动架构*。这种方法的基本概念是使用消息代理来接收消息，然后将它们分发给订阅者。
- en: For our example, we are going to choose RESTful web services, which is a popular
    choice nowadays. In order to accomplish our goal, we will use Spring Boot (to
    bootstrap our application) together with Spring Data (to persist the information
    using H2, which is an in-memory database). Our app will be secured using the JSON
    Web Tokens RFC ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将选择RESTful Web服务，这是目前很受欢迎的选择。为了实现我们的目标，我们将使用Spring Boot（引导我们的应用程序）以及Spring
    Data（使用H2持久化信息，H2是一个内存数据库）。我们的应用程序将使用JSON Web Tokens RFC（[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)）进行安全保护。
- en: 'JWT is an open standard, intended to allow for authenticating clients with
    servers. Another use case is to validate the integrity of the messages. In order
    to use JWT as an authentication mechanism, the clients should send their credentials
    to the server, and it will respond to them with a token in the form of a string.
    This token should be used for the subsequent requests. When they are executed,
    if the provided token is invalid or expired, we will receive a 401 UNAUTHORIZED
    status code from the server. Otherwise, the request will be successful:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一个开放标准，旨在允许服务器对客户进行身份验证。另一个用例是验证消息的完整性。为了将JWT用作身份验证机制，客户端应该将他们的凭据发送到服务器，服务器将以字符串形式的令牌回应他们。这个令牌应该用于后续的请求。当执行它们时，如果提供的令牌无效或过期，我们将从服务器收到401未经授权的状态代码。否则，请求将成功：
- en: '![](img/f58c13ed-3bf8-4c93-b45b-bce3456ce155.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f58c13ed-3bf8-4c93-b45b-bce3456ce155.png)'
- en: JWT authentication flow
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JWT身份验证流程
- en: Since the functionality of this application doesn't require a considerable amount
    of computing or real-time processing, we used Groovy as the programming language.
    Groovy has a pretty similar syntax to Java, but with tons of built-in functionalities
    that allow us to avoid writing verbose code. In conjunction with Groovy, we will
    use Spock as a testing framework. This will enable us to write highly expressive
    tests using a **Behavior Driven Development** (**BDD**) approach, with the `given`,
    `when`, and `then` syntax. The main idea behind BDD is to reduce the uncertainty
    about what a test method is testing, using expressive test names that are helpful
    for understanding what goes wrong when a test fails.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此应用程序的功能不需要大量的计算或实时处理，我们使用Groovy作为编程语言。Groovy的语法与Java非常相似，但具有大量内置功能，可以避免编写冗长的代码。与Groovy一起，我们将使用Spock作为测试框架。这将使我们能够使用**行为驱动开发**（BDD）方法编写高度表达性的测试，使用`given`，`when`和`then`语法。BDD的主要思想是通过具有帮助理解测试失败原因的表达性测试名称，减少对测试方法正在测试什么的不确定性。
- en: 'The BDD approach is based on the structure of user stories, and the idea is
    to write tests that make it clear what they are testing. A classic example, used
    to explain this concept, is provided by Dan North (the BDD creator) and starts
    with the following user story related to how an ATM works:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: BDD方法基于用户故事的结构，其思想是编写能清楚表明正在测试什么的测试。一个经典的例子是由BDD的创始人Dan North提供的，以以下与ATM工作相关的用户故事为例：
- en: '| **Title – Customer withdraws cash** | **Scenario 1 – Account is on credit**
    | **Scenario 2 – Account is overdrawn past the overdraft limit** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **标题 - 客户取款** | **场景1 - 账户有余额** | **场景2 - 账户透支超过透支限额** |'
- en: '| As a customer, I want to withdraw cash from an ATM so that I don’t have to
    wait in line at the bank. | Given that the account is in credit, the card is valid
    and the dispenser contains cash, when the customer requests cash, then ensure
    that the account is debited, cash is dispensed, and the card is returned. | Given
    that the account is overdrawn and the card is valid, when the customer requests
    cash, then ensure a rejection message is displayed. Ensure that cash is not dispensed
    and the card is returned. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 作为客户，我想从ATM取款，这样我就不必在银行排队等候。 | 假设账户有余额，卡片有效，取款机有现金，当客户请求现金时，确保账户被借记，现金被发放，卡片被归还。
    | 假设账户透支，卡片有效，当客户请求现金时，确保显示拒绝消息。确保不发放现金并归还卡片。'
- en: 'The preceding validation can be easily expressed with code by using Spock.
    Let''s check one of our implemented tests to understand how it works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Spock，前面的验证可以很容易地用代码表达。让我们检查我们实现的测试之一，以了解它是如何工作的：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the test explains itself well, using the `given`, `when`, and `then`
    syntax provided by Spock.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，测试使用Spock提供的`given`，`when`和`then`语法，能够很好地解释自己。
- en: Spock also allows for using mocks, without needing additional libraries such
    as Mockito, because this feature is built in. If you are interested in knowing
    more about Spock, I encourage you to visit [http://spockframework.org/](http://spockframework.org/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Spock还允许使用模拟，无需额外的库，如Mockito，因为这个功能是内置的。如果您对Spock想了解更多，我鼓励您访问[http://spockframework.org/](http://spockframework.org/)。
- en: Implementing the server
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务器
- en: 'Let''s implement the server project for our example. We are going to organize
    its functionalities in modules, in order to make it easy to evolve and understand.
    For the sake of simplicity, we are going to add a simple functionality that will
    later be consumed by different application clients. The server example will have
    three modules, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的示例实现服务器项目。我们将以模块的形式组织其功能，以便易于演变和理解。为简单起见，我们将添加一个简单的功能，稍后将由不同的应用程序客户端使用。服务器示例将有三个模块，如下所示：
- en: Banking-domain
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 银行业务
- en: Banking-api
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 银行API
- en: Banking-client
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 银行客户端
- en: Banking-domain
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 银行业务
- en: 'This module contains all of the domain objects required to build our application;
    it''s a good idea to keep them separated, as another module. By doing this, you
    can later include the module as a dependency of other modules, which will help
    to avoid writing the same code twice. The following diagram shows the contents
    of this module:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块包含构建我们应用程序所需的所有领域对象；将它们作为另一个模块保持分离是个好主意。通过这样做，您可以稍后将模块包含为其他模块的依赖项，这将有助于避免重复编写相同的代码。以下图表显示了此模块的内容：
- en: '![](img/a0b438f3-9599-42c5-988e-cb187a8d2d48.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0b438f3-9599-42c5-988e-cb187a8d2d48.png)'
- en: The banking-domain module
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 银行业务模块
- en: As you can see, this module contains only two classes. The `Credentials`class
    is used as the payload, to authenticate a user and retrieve the JSON web token,
    and the `BalanceInformation`class contains the payload resultant of querying the
    customer account balance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此模块仅包含两个类。`Credentials`类用作有效负载，用于验证用户并检索JSON Web令牌，而`BalanceInformation`类包含查询客户账户余额的有效负载结果。
- en: Banking-api
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 银行API
- en: 'The banking-api module contains the functionality exposed by the server that
    will later be consumed by different application clients; the functionality will
    be made available for RESTful web services. Let''s review the project structure
    for this API:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 银行API模块包含服务器公开的功能，稍后将由不同的应用程序客户端使用；该功能将可用于RESTful Web服务。让我们回顾一下此API的项目结构：
- en: '![](img/4edbb43b-ff0a-41eb-a670-605e57bd0fb7.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4edbb43b-ff0a-41eb-a670-605e57bd0fb7.png)'
- en: The banking-api module
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 银行API模块
- en: As mentioned previously, this module is implemented entirely using Groovy, and
    that's why all of the files have a `.groovy` extension. The project structure
    is more important here, as the project is separated into `balance`, `config`,
    and `security` packages, which makes it fairly simple to understand their purposes. It's
    always worth organizing the code in this way, in order to make it easy to understand.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此模块完全使用Groovy实现，这就是为什么所有文件都具有`.groovy`扩展名。项目结构在这里更为重要，因为项目分为`balance`、`config`和`security`包，这使得理解它们的目的相当简单。以这种方式组织代码总是值得的，以便易于理解。
- en: 'We mentioned previously that not only should an SDK be provided, but proper
    documentation is also highly recommended. The tedious part of writing documentation
    is that you need to keep it in sync with the new features added to the project.
    To achieve this goal, we have integrated Swagger into our application. This is
    a helpful tool that generates a website with examples to consume the endpoints
    of an application. Furthermore, it also creates payload demos for each one of
    them when it''s required, as shown in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到不仅应提供SDK，而且还应强烈推荐提供适当的文档。编写文档的繁琐部分在于您需要将其与项目中添加的新功能保持同步。为了实现这一目标，我们已将Swagger集成到我们的应用程序中。这是一个有用的工具，可以生成一个网站，其中包含消费应用程序端点的示例。此外，当需要时，它还为每个端点创建有效负载演示，如下图所示：
- en: '![](img/ef6bcad6-a52b-4cd4-86dc-7072982edd28.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef6bcad6-a52b-4cd4-86dc-7072982edd28.png)'
- en: Autogenerated Swagger UI
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的Swagger UI
- en: This portal is available at `http://localhost:8080/swagger-ui.html`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该门户网站可在`http://localhost:8080/swagger-ui.html`上使用。
- en: Now, let's briefly review the packages listed in the screenshot for each module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要回顾一下每个模块中屏幕截图中列出的包。
- en: Boundaries
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界
- en: The `boundaries` package contains the functionality exposed by the application
    that will be used to allow for the interaction with the clients. In this case,
    we are placing the endpoints of our service here.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`boundaries`包含应用程序公开的功能，用于与客户端进行交互。在这种情况下，我们将放置我们服务的端点。'
- en: Domain
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域
- en: The domainpackage has the domain objects that are required only by this module.
    The classes placed here won't be used in any other place, and that's why it doesn't
    make sense to place them in the banking-domain module, which is intended to be
    shared.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 领域包含此模块所需的领域对象。放置在这里的类不会在任何其他地方使用，这就是为什么将它们放在银行业务模块中没有意义的原因。
- en: Persistence
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化
- en: As the name suggests, we are going to write the required code to persist information in
    this package. Since the persistence storage of our application is a database,
    and we defined that we are going to use Spring-data for it, we have our Spring-data
    repositories here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，我们将在此包中编写持久化信息所需的代码。由于我们应用程序的持久化存储是数据库，并且我们已经定义了要使用Spring-data，我们在这里有我们的Spring-data存储库。
- en: Service
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: We have put the required business logic for our service into this package. This
    is where the interaction with many classes happens, in order to achieve the business
    requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将所需的业务逻辑放入此包中。这是与许多类进行交互以实现业务需求的地方。
- en: Monitoring the server
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控服务器
- en: 'We mentioned earlier that monitoring is quite important to understanding how
    an application performs in the wild. Fortunately, Spring has `actuator`, which
    is a library that can be easily attached to an existing Spring Boot application
    by adding the following dependency:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到监控对于了解应用程序在实际中的表现非常重要。幸运的是，Spring有`actuator`，这是一个可以轻松附加到现有Spring Boot应用程序的库，只需添加以下依赖项：
- en: '[PRE2]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Spring Boot Actuator provides a bunch of endpoints that are ready to be consumed
    and provide useful information about the application. Let''s review some of them
    in the following table:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot执行器提供了一堆准备好供使用的端点，并提供有关应用程序的有用信息。让我们在下表中审查其中一些：
- en: '| **Endpoint** | **Brief Description** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **端点** | **简要描述** |'
- en: '| `/health` | This provides brief information about the application status
    and its main dependencies, such as databases or messaging systems. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `/health` | 这提供了有关应用程序状态及其主要依赖项（如数据库或消息系统）的简要信息。'
- en: '| `/autoconfig` | This provides information about the auto-configuration provided
    for the app by the Spring Framework. Remember that Spring prefers convention over
    configuration, so you''ll find tons of default values here. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `/autoconfig` | 这提供了关于Spring框架为应用程序提供的自动配置的信息。请记住，Spring更喜欢约定胜过配置，所以你会在这里找到大量的默认值。'
- en: '| `/beans` | This shows the list of Spring beans configured as a part of the
    application context. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `/beans` | 这显示了作为应用程序上下文的一部分配置的Spring bean列表。'
- en: '| `/dump` | This performs a thread dump at the exact moment that the endpoint
    is requested. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `/dump` | 这在请求端点的确切时刻执行线程转储。'
- en: '| `/env` | This lists all of the variables configured in the server. Values
    provided as a part of `.properties`/`.yml` files and arguments provided to run
    the application are listed, as well. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `/env` | 这列出了服务器中配置的所有变量。作为`.properties`/`.yml`文件的一部分提供的值以及提供给运行应用程序的参数也会列出。'
- en: '| `/metrics` | This shows some metrics around the available endpoints exposed
    in the app. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `/metrics` | 这显示了应用程序中公开的可用端点周围的一些指标。'
- en: '| `/trace` | This gives information regarding the last 100 (by default) requests,
    including details about the requests and responses. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `/trace` | 这提供了有关最后100个（默认值）请求的信息，包括有关请求和响应的详细信息。'
- en: If you are interested in a complete list of the endpoints available by default,
    I encourage you to visit [https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对默认可用的端点完整列表感兴趣，我鼓励您访问[https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html)。
- en: 'All of the preceding endpoints can mainly be configured with three parameters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述的端点主要可以配置三个参数：
- en: '`id`: This is the endpoint identification'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是端点标识'
- en: '`sensitive`: This indicates whether or not Spring Actuator should enforce security'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sensitive`：这表示Spring执行器是否应强制执行安全性'
- en: '`enabled`: This indicates whether or not the Spring Actuator endpoints are
    available'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`：这表示Spring执行器端点是否可用'
- en: 'If you want to configure the endpoints, you have to use the following entries
    as a part of your configuration (`.properties`/`.yml`) file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要配置端点，必须在配置（`.properties`/`.yml`）文件中使用以下条目：
- en: '[PRE3]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following bullet points expand upon this idea:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点扩展了这个想法：
- en: '`endpoints`: This is a constant value.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoints`：这是一个常量值。'
- en: '`endpoint_name`: This should be replaced with the desired endpoint.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoint_name`：这应该替换为所需的端点。'
- en: '`property`: This can be `id`, `sensitive`, or `enabled`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`property`：这可以是`id`、`sensitive`或`enabled`。'
- en: 'For example, let''s suppose that you want to enable the `health` endpoint,
    rename it to `status`, and not enforce `security`. To achieve this requirement,
    the configuration should look as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想要启用`health`端点，将其重命名为`status`，并且不强制执行`security`。为了满足这个要求，配置应该如下所示：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All of the endpoints are enabled by default, except for `/shutdown`, which is
    intended to stop the application gracefully.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有端点默认情况下都是启用的，除了`/shutdown`，它旨在优雅地停止应用程序。
- en: Furthermore, Spring actuator can be configured to generate business metrics,
    as well. This is an excellent feature that can be integrated with other tools,
    which makes it possible to visualize the collected metrics using graphical interfaces.
    We will review this feature in detail in [Chapter 12](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml),
    *Monitoring*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Spring执行器也可以配置生成业务指标。这是一个很棒的功能，可以与其他工具集成，从而可以使用图形界面可视化收集的指标。我们将在[第12章](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml)中详细审查此功能，*监控*。
- en: Testing
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Up until now, we have introduced unit tests to validate that the code is working
    as expected. However, we would like to add even more tests. After all, the more
    tests we include in our system, the more confidence we will gain.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了单元测试来验证代码是否按预期工作。但是，我们希望添加更多的测试。毕竟，我们在系统中包含的测试越多，我们就会获得越多的信心。
- en: 'Since we are writing a rest API, we will create a simple script that will exercise
    our endpoints from time to time, giving us the confidence that the app is always
    working. To achieve this goal, our tests will follow a simple process:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写一个rest API，我们将创建一个简单的脚本，定期测试我们的端点，从而确保应用程序始终正常工作。为了实现这个目标，我们的测试将遵循一个简单的流程：
- en: Authenticate the user using the endpoint.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用端点对用户进行身份验证。
- en: Validate the status code from the response.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证响应中的状态代码。
- en: Take the token from the response body.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从响应体中获取令牌。
- en: Hit the balance endpoint using the token.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用令牌击中余额端点。
- en: Validate the status code from the response.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证响应中的状态代码。
- en: The easiest way to achieve this goal is by using Postman ( [https://www.getpostman.com/](https://www.getpostman.com/)).
    This is a handy tool that allows for trying RESTful web services, and creating
    tests for them, as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个目标的最简单方法是使用Postman（[https://www.getpostman.com/](https://www.getpostman.com/)）。这是一个方便的工具，可以尝试RESTful
    web服务，并为它们创建测试。
- en: 'Let''s discuss the test generated for the endpoint to authenticate a user,
    as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论为验证用户身份而生成的端点的测试，如下面的屏幕截图所示：
- en: '![](img/a3dfe152-f51d-4715-a024-d59d408cfbfd.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3dfe152-f51d-4715-a024-d59d408cfbfd.png)'
- en: Test for the authentication endpoint in Postman
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中对身份验证端点进行测试
- en: The first three lines of the preceding code check the retrieved status code,
    and line 5 stores the retrieved body response as a variable named `jwt-token`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的前三行检查了检索到的状态码，第5行将检索到的响应体作为名为`jwt-token`的变量存储。
- en: Using the preceding code, we can later inject the value of this variable into
    the subsequent requests and perform whatever validations we want.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们可以将这个变量的值注入到后续的请求中，并执行任何我们想要的验证。
- en: 'Once all of the tests have been created, we can generate a link referring to
    the collection that contains them, as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试都创建好了，我们可以生成一个链接，指向包含它们的集合，如下面的截图所示：
- en: '![](img/5cb40230-86c1-406f-9529-fe601617ea9f.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cb40230-86c1-406f-9529-fe601617ea9f.png)'
- en: Postman collection link
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Postman集合链接
- en: 'With this link, the collection of tests can be executed over and over again,
    using a command-line integration runner named Newman ([https://www.npmjs.com/package/newman](https://www.npmjs.com/package/newman))
    and the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个链接，测试集合可以一遍又一遍地执行，使用一个名为Newman的命令行集成运行器（[https://www.npmjs.com/package/newman](https://www.npmjs.com/package/newman)）和以下命令：
- en: '[PRE5]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the results of the Newman command''s execution:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了Newman命令的执行结果：
- en: '![](img/aa4ee1ac-45f4-4e45-9374-c5f735614c6b.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa4ee1ac-45f4-4e45-9374-c5f735614c6b.png)'
- en: The results of the Newman command execution
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Newman命令执行的结果
- en: This tool can be integrated with any CI server, such as Jenkins, to schedule
    jobs in charge of verifying the health of the application regularly, which will
    give us the confidence that our app is always working.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具可以与任何CI服务器集成，比如Jenkins，以定期安排任务来验证应用程序的健康状况，这将给我们带来信心，确保我们的应用程序一直在工作。
- en: Banking-client
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 银行客户端
- en: Since our server is implemented using RESTful web services, there are a bunch
    of options for writing clients and consuming them with libraries, such as Netflix
    Feign, OkHttp, Spring Rest Template, and Retrofit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务器是使用RESTful web服务实现的，有很多选项可以编写客户端，并使用Netflix Feign、OkHttp、Spring Rest
    Template和Retrofit等库来消耗它们。
- en: Because of this, the clients can have their own implemented mechanisms to consume
    the services. This approach is not bad at all; actually, we should keep it open,
    and the decision of writing our own tool to interact with the server should be
    a client choice, in order to avoid the conformist relationship described earlier.
    However, it's always a good idea to provide a built-in SDK or library to interact
    with the server and reduce the amount of effort required for it, and that's the
    reason we have the banking-client module.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端可以有自己实现的机制来消耗服务。这种方法并不坏；实际上，我们应该保持开放，编写自己的工具与服务器交互的决定应该是客户端的选择，以避免前面描述的顺从关系。然而，提供一个内置的SDK或库与服务器交互并减少所需的工作量总是一个好主意，这就是我们有银行客户端模块的原因。
- en: It's quite common to find SDKs provided by product vendors. For example, AWS
    provides SDKs with support for a bunch of programming languages, in conjunction
    with a developer guide document that explains how to use them. This is helpful
    for accelerating and encouraging the adoption of products to build applications
    by other developers. Another example is Google Firebase, which is a real-time
    database that provides SDKs that are ready to use in different platforms; it has
    a website with excellent demos that make it possible for developers to understand
    how it works and how to use it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 产品供应商通常提供SDK。例如，AWS提供了支持多种编程语言的SDK，配合开发者指南文件，解释了如何使用它们。这有助于加速和鼓励其他开发者构建应用程序来采用产品。另一个例子是Google
    Firebase，它是一个实时数据库，提供了准备在不同平台上使用的SDK；它有一个网站，上面有出色的演示，让开发者能够理解它的工作原理和如何使用它。
- en: 'This banking-client module is implemented using a library named Retrofit ([http://square.github.io/retrofit/](http://square.github.io/retrofit/)),
    which makes it possible to write type-safe HTTP clients that can be used for almost
    any kind of Java application. This also offers many benefits, such as the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个银行客户端模块是使用一个名为Retrofit的库实现的（[http://square.github.io/retrofit/](http://square.github.io/retrofit/)），它可以编写类型安全的HTTP客户端，几乎可以用于任何类型的Java应用程序。这也提供了许多好处，比如：
- en: Support for mobile apps, like Android
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持移动应用，比如Android
- en: Code that is easy to read and explains itself well
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于阅读并且解释自身良好的代码
- en: Support for synchronous and asynchronous resource consumption
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持同步和异步资源消耗
- en: Smooth integration with converters, such as GSON
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与转换器的顺畅集成，比如GSON
- en: Let's take a look at the implemented clients, in order to consume the endpoints.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下实现的客户端，以便消耗这些终端。
- en: Authentication endpoint client
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证终端客户端
- en: 'In order to consume a RESTful web service, we only have to create an interface
    with a few annotations to provide some metadata:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消耗RESTful web服务，我们只需要创建一个带有一些注解的接口，提供一些元数据：
- en: '[PRE6]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's fairly simple to understand that the authentication endpoint uses the `POST`
    HTTP verb. This is available in the URI `/api/public/auth`, and it needs a `Credentials`
    object as the request body.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解认证终端使用`POST` HTTP动词。它位于URI`/api/public/auth`，并且需要一个`Credentials`对象作为请求体。
- en: Account balance endpoint client
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账户余额终端客户端
- en: 'In this case, we will consume an endpoint, available in the URI `/api/secure/balance`**, **that
    uses the `GET` HTTP verb and requires that the token be used as a header in the
    request:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将消耗一个终端，位于URI`/api/secure/balance`，使用`GET` HTTP动词，并要求在请求中使用令牌作为标头：
- en: '[PRE7]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you have probably noticed, this module uses the `BalanceInformation` and
    `Credentials` classes, so we don't need to write them again; we only need to add
    the banking-domain module as a dependency.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这个模块使用了`BalanceInformation`和`Credentials`类，所以我们不需要再次编写它们；我们只需要将银行域模块作为依赖添加进来。
- en: 'You''re probably wondering where you have to specify the IP address and port
    for the server, and that is done in the `Retrofit` object, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道在哪里指定服务器的IP地址和端口，这是在`Retrofit`对象中完成的，如下所示：
- en: '[PRE8]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the client's implementation, we will review how to use this `Retrofit` object
    in conjunction with the interfaces, in order to make the requests.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端的实现中，我们将审查如何使用`Retrofit`对象与接口一起进行请求。
- en: The clients
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Now that we have implemented the server, we are going to build three clients,
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了服务器，我们将构建三个客户端，如下所示：
- en: JavaFX client
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX客户端
- en: Android client
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓客户端
- en: Thin client, using CURL
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瘦客户端，使用CURL
- en: These clients will use the HTTP protocol to send the requests and retrieve the
    responses. Since we have written a client module, the interaction with the server
    will be fairly simple.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些客户端将使用HTTP协议发送请求并检索响应。由于我们编写了一个客户端模块，与服务器的交互将非常简单。
- en: JavaFX client
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaFX客户端
- en: This client is a simple JavaFX application that has a dependency on the banking-client
    module to interact with the server. We can say that this client is a sort of fat
    client, since it has some code written to simplify the interaction with the server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端是一个简单的JavaFX应用程序，它依赖于banking-client模块与服务器进行交互。我们可以说这个客户端是一种类似于fat client的客户端，因为它有一些代码用于简化与服务器的交互。
- en: 'Let''s review the project structure in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下截图中审查项目结构：
- en: '![](img/911f12ec-265c-44ad-b576-bdbac2a574bf.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/911f12ec-265c-44ad-b576-bdbac2a574bf.png)'
- en: JavaFX client project structure
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX客户端项目结构
- en: This project is fairly simple, and it has only two screens, which allow the
    users to enter their credentials and then query their account balance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目非常简单，只有两个屏幕，允许用户输入他们的凭据然后查询他们的账户余额。
- en: 'Retrofit offers the availability to make synchronous and asynchronous requests.
    In this client, we will use synchronous requests, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit提供了进行同步和异步请求的功能。在这个客户端中，我们将使用同步请求，如下所示：
- en: '[PRE9]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `execute`method allows for making synchronous requests. The `Retrofit` object
    contains the base URI that will be used in conjunction with the partial URIs provided
    in the client interfaces, in order to form the full URI to hit the endpoints.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute`方法允许进行同步请求。`Retrofit`对象包含将与客户端接口中提供的部分URI一起使用的基本URI，以形成命中端点的完整URI。'
- en: 'The process of this client application is shown in the following screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端应用程序的流程如下截图所示：
- en: '![](img/ae4ab25f-74d1-4c79-9ff1-9c5383960b86.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae4ab25f-74d1-4c79-9ff1-9c5383960b86.png)'
- en: JavaFX client application
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX客户端应用程序
- en: Android client
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓客户端
- en: The Android client also uses the provided banking-client module to interact
    with the server, but in this case, it's necessary to use the asynchronous method
    to make requests (this requirement comes from the nature of how Android works).
    We can also say that this is a fat client, by looking at the definition provided earlier.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓客户端还使用提供的banking-client模块与服务器进行交互，但在这种情况下，需要使用异步方法进行请求（这个要求来自安卓的工作方式）。我们也可以说这是一个fat
    client，通过之前提供的定义来看。
- en: 'Let''s review the structure of this project in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下截图中审查该项目的结构：
- en: '![](img/59d157df-8691-43a8-93e7-084f2591f2b1.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59d157df-8691-43a8-93e7-084f2591f2b1.png)'
- en: Android client project structure
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓客户端项目结构
- en: 'The `Activity` classes have the code to make the asynchronous requests, as
    follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`类包含编写异步请求的代码，如下所示：'
- en: '[PRE10]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `enqueue`method allows for hitting the endpoint asynchronously, and it registers
    two callbacks that will be executed, depending on whether the response fails or
    succeeds.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue`方法允许异步地命中端点，并注册两个回调函数，这些函数将根据响应是失败还是成功而执行。'
- en: 'The execution flow for this client application is shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端应用程序的执行流程如下截图所示：
- en: '![](img/ed9cfd5b-76e5-4719-8576-3915e754d2de.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed9cfd5b-76e5-4719-8576-3915e754d2de.png)'
- en: Android client application
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓客户端应用程序
- en: Thin client
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瘦客户端
- en: As mentioned previously, there are also thin clients, which don't include a
    lot of code to interact with the server; one good example of a thin RESTful web
    service client is `curl`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，还有瘦客户端，它们不包括大量与服务器交互的代码；`curl`是一个瘦RESTful web服务客户端的很好的例子。
- en: 'In order to interact with the endpoints provided by the server example, we
    can use two `curl` commands, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与服务器提供的端点进行交互，我们可以使用两个`curl`命令，如下所示：
- en: 'The following code provides for retrieving the authentication JWT token:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码提供了检索认证JWT令牌的功能：
- en: '[PRE11]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code provides for using the JWT token to query the user''s account
    balance:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码提供了使用JWT令牌查询用户账户余额的功能：
- en: '[PRE12]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For these kinds of clients, we don't have to write our own code; the interaction
    with the server doesn't have a fancy frontend, which can be good (in cases where
    the API is used for other middleware, for example).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种类型的客户端，我们不必编写自己的代码；与服务器的交互没有花哨的前端，这可能是好事（例如，在API用于其他中间件的情况下）。
- en: As you can see, our client-server architecture implementation is simple, but
    it uses all of the necessary pieces to make it work. In this case, we have used
    the HTTP protocol as the communication channel. However, depending on what kind
    of server you are implementing, it may be different, and it can also affect the
    authentication mechanism. For example, when you're using a message broker such
    as RabbitMQ to allow for the interaction between servers and clients, the protocol
    to establish the communication is AMQP, which is a different protocol (in comparison
    to HTTP).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的客户端-服务器架构实现是简单的，但它使用了所有必要的部分使其工作。在这种情况下，我们使用HTTP协议作为通信渠道。然而，根据你实现的服务器类型，可能会有所不同，并且也可能会影响认证机制。例如，当你使用消息代理（如RabbitMQ）允许服务器和客户端之间的交互时，用于建立通信的协议是AMQP，这是一种不同的协议（与HTTP相比）。
- en: The kinds of clients that your application will have also affects the way in
    which you will build the solution. Let's suppose that you're using agents as clients;
    a more secure authentication mechanism would be based on the use of certificates
    instead of tokens, as seen in the preceding example.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序将拥有的客户端类型也会影响你构建解决方案的方式。假设你正在使用代理作为客户端；一个更安全的身份验证机制将基于证书而不是令牌，就像前面的例子中所示。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed what client-server architectures are and how to
    implement them using the Spring Framework. One important aspect to remember is
    that when we are building applications following this architectural style, it's
    always worth providing an SDK to make the server resources easy to consume.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了什么是客户端-服务器架构以及如何使用Spring框架实现它们。要记住的一个重要方面是，当我们按照这种架构风格构建应用程序时，值得提供一个SDK来使服务器资源易于消耗。
- en: Providing proper documentation can help clients to write their own code to interact
    with the server, if necessary. In this case, we will avoid introducing a conformist
    relationship among the server and clients. We also explored spring actuator, a
    library that can be used to add endpoints that provide information about the application.
    Furthermore, we reviewed how to use Postman to create tests that can regularly assess
    the application's health.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提供适当的文档可以帮助客户端编写他们自己的代码与服务器进行交互，如果有必要的话。在这种情况下，我们将避免在服务器和客户端之间引入一种顺从的关系。我们还探讨了Spring
    Actuator，这是一个可以用来添加提供有关应用程序信息的端点的库。此外，我们还回顾了如何使用Postman创建测试，以便定期评估应用程序的健康状况。
- en: In the end, we created a couple of clients using a library implemented with
    Retrofit, which drastically reduced the effort required to consume the resources
    exposed by the server.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Retrofit实现的库创建了一些客户端，这大大减少了消耗服务器资源的工作量。
- en: In the next chapter, we will review MVC architectures and how to write them
    using Spring.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾MVC架构以及如何使用Spring编写它们。
