- en: Discovering Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现Java 9
- en: Java 9 represents a major release and consists of a large number of internal
    changes to the Java platform. Collectively, these internal changes represent a
    tremendous set of new possibilities for Java developers, some stemming from developer
    requests, others from Oracle-inspired enhancements. In this chapter, we will review
    26 of the most important changes. Each change is related to a **JDK Enhancement
    Proposal** (**JEP**). JEPs are indexed and housed at [openjdk.java.net/jeps/0](http://openjdk.java.net/jeps/0).
    You can visit this site for additional information on each JEP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9代表了一个主要版本，包括对Java平台的大量内部更改。这些内部更改共同为Java开发者提供了一组巨大的新可能性，其中一些来自开发者的请求，另一些来自Oracle启发的增强。在本章中，我们将回顾26个最重要的更改。每个更改都与一个**JDK增强提案**（**JEP**）相关。JEPs被索引并托管在[openjdk.java.net/jeps/0](http://openjdk.java.net/jeps/0)。您可以访问此网站以获取有关每个JEP的更多信息。
- en: The JEP program is part of Oracle's support for open source, open innovation,
    and open standards. While other open source Java projects can be found, OpenJDK
    is the only one supported by Oracle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JEP项目是Oracle对开源、开源创新和开源标准的支持的一部分。虽然可以找到其他开源Java项目，但OpenJDK是Oracle唯一支持的项目。
- en: 'In this chapter, we will cover changes to the Java platform. These changes
    have several impressive implications, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Java平台的变化。这些变化具有几个令人印象深刻的含义，包括：
- en: Heap space efficiencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆空间效率
- en: Memory allocation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配
- en: Compilation process improvements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译过程改进
- en: Type testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型测试
- en: Annotations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解
- en: Automated runtime compiler tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化的运行时编译器测试
- en: Improved garbage collection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的垃圾收集
- en: Improved Contended Locking [JEP 143]
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进的竞争锁 [JEP 143]
- en: The JVM uses Heap space for classes and objects. The JVM allocates memory on
    the heap whenever we create an object. This helps facilitate Java's garbage collection
    which releases memory previously used to hold objects that no longer have a reference
    to it. Java Stack memory is a bit different and is usually much smaller than heap
    memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JVM使用堆空间为类和对象分配内存。每当创建一个对象时，JVM都会在堆上分配内存。这有助于促进Java的垃圾收集，释放不再有引用的对象之前使用的内存。Java栈内存略有不同，通常比堆内存小得多。
- en: The JVM does a good job of managing data areas that are shared by multiple threads.
    It associates a monitor with every object and class; these monitors have locks
    that are controlled by a single thread at any one time. These locks, controlled
    by the JVM, are, in essence, giving the controlling thread the object's monitor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JVM在管理多个线程共享的数据区域方面做得很好。它将一个监控器与每个对象和类关联；这些监控器有由单个线程在任何时候控制的锁。这些由JVM控制的锁本质上是在给控制线程提供对象的监控器。
- en: 'So, what is contended locking? When a thread is in a queue for a currently
    locked object, it is said to be in contention for that lock. The following diagram
    shows a high-level view of this contention:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是竞争锁？当一个线程正在等待当前已锁定对象的队列中时，它被说是在竞争该锁。以下图表展示了这种竞争的高级视图：
- en: '![](img/d08f3d3c-7ad3-4c5b-8f25-3e405467be9d.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d08f3d3c-7ad3-4c5b-8f25-3e405467be9d.png)'
- en: As you can see in the preceding illustration, any threads in waiting cannot
    use a locked object until it is released.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，任何等待的线程在对象释放之前都不能使用已锁定的对象。
- en: Improvement goals
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进目标
- en: 'The general goal of JEP 143 was to increase the overall performance of how
    the JVM manages contention over locked Java object monitors. The improvements
    to contended locking were all internal to the JVM and do not require any developer
    actions to benefit from them. The overall improvement goals were related to faster
    operations. These include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 143的一般目标是提高JVM管理锁定Java对象监控的总体性能。对竞争锁的改进全部在JVM内部进行，不需要任何开发者采取行动即可从中受益。总体改进目标与更快操作相关。这包括：
- en: Faster monitor enter
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的监控进入
- en: Faster monitor exit
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的监控退出
- en: Faster notifications
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的通知
- en: The notifications are the `notify()` and `notifyAll()` operations that are called
    when the locked status of an object is changed. Testing this improvement is not
    something you can easily accomplish. Greater efficiency, at any level, is welcome,
    so this improvement is one we can be thankful for even without any easily observable
    testing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是当对象锁定状态改变时调用的`notify()`和`notifyAll()`操作。测试这种改进不是一件容易的事情。任何级别的更高效率都是受欢迎的，因此这种改进是我们即使没有容易观察到的测试也可以感激的。
- en: Segmented code cache [JEP 197]
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分段代码缓存 [JEP 197]
- en: The segmented code cache JEP (197) upgrade was completed and results in faster,
    more efficient execution time. At the core of this change was the segmentation
    of the code cache into three distinct segments--non-method, profiled, and non-profiled
    code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 分段代码缓存JEP（197）的升级已完成，并导致执行时间更快、更高效。这一变化的核心是将代码缓存分为三个不同的段——非方法、分析和非分析代码。
- en: A code cache is the area of memory where the Java Virtual Machine stores generated
    native code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码缓存是Java虚拟机存储生成的本地代码的区域。
- en: 'Each of the aforementioned code cache segments will hold a specific type of
    compiled code. As you can see in the following diagram, the code heap areas are
    segmented by type of compiled code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的上述代码缓存段将包含特定类型的编译代码。正如您在以下图中可以看到的，代码堆区域根据编译代码的类型进行了分段：
- en: '![](img/80b55837-7e19-4eaa-92d5-ec65f6e9e776.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80b55837-7e19-4eaa-92d5-ec65f6e9e776.png)'
- en: Memory allocation
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配
- en: The code heap containing non-method code is for JVM internal code and consists
    of a 3 MB fixed memory block. The rest of the code cache memory is equally allocated
    for the profiled code and non-profiled code segments. You have control of this
    via command-line commands.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 包含非方法代码的代码堆是用于JVM内部代码的，由一个3MB的固定内存块组成。其余的代码缓存内存平均分配给分析代码和非分析代码段。您可以通过命令行命令来控制这一点。
- en: 'The following command can be used to define the code heap size for the non-method
    compiled code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以用来定义非方法编译代码的代码堆大小：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following command can be used to define the code heap size for the profiled
    compiled methods:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以用来定义分析编译方法的代码堆大小：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following command can be used to define the code heap size for the non-profiled
    compiled methods:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可以用来定义非分析编译方法的代码堆大小：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This Java 9 feature certainly stands to improve Java application efficiency.
    It also impacts other processes that employ the code cache.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Java 9特性确实可以改善Java应用程序的效率。它还影响了使用代码缓存的其他进程。
- en: Smart Java compilation, phase two [JEP 199]
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能Java编译，第二阶段 [JEP 199]
- en: The JDK Enhancement Proposal 199 is aimed at improving the code compilation
    process. All Java developers will be familiar with the **javac** tool for compiling
    source code to bytecode, which is used by the JVM to run Java programs. **Smart
    Java Compilation**, also referred to as Smart Javac and **sjavac**, adds a *smart*
    wrapper around the javac process. Perhaps the core improvement sjavac adds is
    that only the necessary code is recompiled. Necessary code, in this context, is
    code that has changed since the last compile cycle.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JDK增强提案199旨在改进代码编译过程。所有Java开发者都应该熟悉用于将源代码编译成字节码的**javac**工具，该工具由JVM用于运行Java程序。**智能Java编译**，也称为Smart
    Javac和**sjavac**，在javac进程周围添加了一个*智能*包装器。也许sjavac添加的核心改进是只重新编译必要的代码。在这个上下文中，必要的代码是指自上次编译周期以来已更改的代码。
- en: This enhancement might not get developers excited if they only work on small
    projects. Consider, however, the tremendous gains in efficiency when you continuously
    have to recompile your code for medium and large projects. The time developers
    stand to save is enough reason to embrace JEP 199.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者只在小项目上工作，这个增强可能不会让他们感到兴奋。然而，考虑到在中等和大型项目中您必须不断重新编译代码时效率的巨大提升，开发者可以节省的时间就足以让他们接受JEP
    199。
- en: How will this change how you compile your code? It probably will not, at least
    not yet. Javac will remain the default compiler. While sjavac offers efficiencies
    regarding incremental builds, Oracle has deemed it to not have sufficient stability
    to become part of the standard compilation workflow.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将如何改变您编译代码的方式？可能不会，至少目前不会。Javac将仍然是默认的编译器。虽然sjavac在增量构建方面提供了效率，但Oracle认为它没有足够的稳定性成为标准编译工作流程的一部分。
- en: 'You can read more information about the smart javac wrapper tool here: [http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html](http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处阅读有关智能javac包装器工具的更多信息：[http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html](http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html)。
- en: Resolving Lint and Doclint warnings [JEP 212]
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决Lint和Doclint警告 [JEP 212]
- en: 'Do not worry if you are not familiar with Lint or Doclint in Java. As you can
    determine from the section title, they are sources that report warnings to javac.
    Let''s take a look at each one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Java 中的 Lint 或 Doclint 不熟悉，请不要担心。正如标题所示，它们是向 javac 报告警告的来源。让我们逐一看看：
- en: '**Lint** analyzes byte code and source code for javac. The goal of Lint is
    to identify security vulnerabilities in the code being analyzed. Lint can also
    provide insights into scalability and thread locking concerns. There is more to
    Lint, and the overall purpose is to save developers time.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lint** 分析 javac 的字节码和源代码。Lint 的目标是识别被分析代码中的安全漏洞。Lint 还可以提供关于可扩展性和线程锁定问题的见解。Lint
    还有更多功能，其总体目的是节省开发者的时间。'
- en: 'You can read more about Lint here: [https://en.wikipedia.org/wiki/Lint_(software)](https://en.wikipedia.org/wiki/Lint_(software)).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 Lint 的信息：[https://en.wikipedia.org/wiki/Lint_(software)](https://en.wikipedia.org/wiki/Lint_(software))。
- en: '**Doclint** is similar to Lint and is specific to javadoc. Both Lint and Doclint
    report errors and warnings during the compile process. Resolution of these warnings
    was the focus of JEP 212\. When using core libraries, there should not be any
    warnings. This mindset led to JEP 212, which has been resolved and implemented
    in Java 9.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Doclint** 与 Lint 类似，但特定于 javadoc。Lint 和 Doclint 都在编译过程中报告错误和警告。JEP 212 的重点是解决这些警告。当使用核心库时，不应该有任何警告。这种思维方式导致了
    JEP 212，它已在 Java 9 中得到解决并实现。'
- en: A comprehensive list of the Lint and Doclint warnings can be reviewed in the
    [https://bugs.openjdk.java.net](https://bugs.openjdk.java.net) JDK Bug System.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://bugs.openjdk.java.net](https://bugs.openjdk.java.net) JDK Bug 系统中查看
    Lint 和 Doclint 警告的完整列表。
- en: Tiered attribution for javac [JEP 215]
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: javac 的分层归因 [JEP 215]
- en: JEP 215 represents an impressive undertaking to streamline javac's type checking
    schema. Let's first review how type checking works in Java 8; then we will explore
    the changes in Java 9.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 215 代表了对 javac 类型检查方案的优化工作。让我们首先回顾一下 Java 8 中类型检查是如何工作的；然后我们将探讨 Java 9 中的变化。
- en: In Java 8, type checking of poly expressions is handled by a **speculative attribution**
    tool.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中，多态表达式的类型检查由一个**推测性归因**工具处理。
- en: Speculative attribution is a method of type checking as part of javac's compilation
    process. It has a significant processing overhead.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 推测性归因是类型检查的一种方法，它是 javac 编译过程的一部分。它有显著的计算开销。
- en: Using the speculative attribution approach to type checking is accurate, but
    lacks efficiency. These checks include argument position, and are exponentially
    slower when testing in the midst of recursion, polymorphism, nested loops, and
    lambda expressions. So the goal with JEP 215 was to change the type checking schema
    to create faster results. The results themselves were not inaccurate with speculative
    attribution; they were just not generated rapidly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用推测性归因方法进行类型检查是准确的，但效率不高。这些检查包括参数位置，在递归、多态、嵌套循环和 Lambda 表达式中测试时，速度会呈指数级下降。因此，JEP
    215 的目标是将类型检查方案改为创建更快的结果。使用推测性归因的结果本身并没有不准确，只是生成速度不够快。
- en: 'The new approach, released with Java 9, uses a tiered attribution tool. This
    tool implements a tiered approach for type checking argument expressions for all
    method calls. Permissions are also made for method overriding. In order for this
    new schema to work, new structural types are created for each of the following
    listed types of method arguments:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 9 一起发布的新方法使用分层归因工具。此工具为所有方法调用中的参数表达式实现分层类型检查方法。还允许方法重写。为了使此新方案工作，为以下列出的每种方法参数类型创建了新的结构类型：
- en: Lambda expressions
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Poly expressions
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态表达式
- en: Regular method calls
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规方法调用
- en: Method references
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用
- en: Diamond instance creation expressions
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钻石实例创建表达式
- en: The changes to javac from JEP 215 are more complex than what has been highlighted
    in this section. There is no immediate impact to developers other than a more
    efficient javac and time saved.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 215 对 javac 的更改比本节中突出显示的更复杂。除了更高效的 javac 和节省时间之外，对开发者的直接影响并不立即显现。
- en: Annotations pipeline 2.0 [JEP 217]
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解管道 2.0 [JEP 217]
- en: Java annotations refer to a special kind of metadata that resides inside your
    Java source code files. They are not stripped by javac, so that they can remain
    available to the JVM at runtime.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Java 注解指的是位于你的 Java 源代码文件中的特殊类型元数据。它们不会被 javac 移除，这样它们就可以在运行时对 JVM 可用。
- en: 'Annotations look similar to JavaDocs references because they start with the
    `@` symbol. There are three types of annotations. Let''s examine each:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注释看起来类似于 JavaDocs 引用，因为它们以 `@` 符号开头。有三种类型的注释。让我们逐一检查：
- en: 'The most basic form of annotation is a **marker** annotation. These are standalone
    annotations with the only component being the name of the animation. Here is an
    example:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最基本的注释形式是 **标记** 注释。这些是独立的注释，唯一的组件是动画的名称。以下是一个示例：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second type of annotation is one that contains a *single value*, or piece
    of data. As you can see in the following code, the annotation, which starts with
    the `@` symbol, is followed by parentheses containing data:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种注释类型是包含 *单个值* 或数据片段的注释。正如您在以下代码中所见，以 `@` 符号开头的注释后面跟着包含数据的括号：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An alternative way of coding the single value annotation type is to omit the
    `data=` component, as illustrated in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 编码单值注释类型的一种替代方法是省略 `data=` 组件，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The third type of annotation is when there is *more than one data component*.
    With this type of annotation, the `data=` component cannot be omitted. Here is
    an example:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种注释类型是当存在 *多个数据组件* 时。在这种类型的注释中，不能省略 `data=` 组件。以下是一个示例：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, what has changed in Java 9? To answer this question, we need to recall
    a couple of changes introduced with Java 8 that impacted Java annotations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Java 9 中有哪些变化？要回答这个问题，我们需要回顾一下 Java 8 中引入的一些变化，这些变化影响了 Java 注释：
- en: Lambda expressions
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Repeated annotations
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的注释
- en: Java type annotations
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 类型注释
- en: These Java 8 related changes impacted Java annotations, but did not usher in
    a change to how javac processed them. There were some hardcoded solutions that
    allowed javac to handle the new annotations, but they were not efficient. Moreover,
    this type of coding (hardcoding workarounds) is difficult to maintain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与 Java 8 相关的更改影响了 Java 注释，但并没有导致 javac 处理它们的方式发生变化。有一些硬编码的解决方案允许 javac 处理新的注释，但它们效率不高。此外，这种编码（硬编码解决方案）难以维护。
- en: So, JEP 217 focused on refactoring the javac annotation pipeline. This refactoring
    was all internal to javac, so it should not be evident to developers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JEP 217 专注于重构 javac 注释管道。这次重构完全是 javac 内部的，因此它不应该对开发者明显。
- en: New version-string scheme [JEP 223]
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的版本字符串方案 [JEP 223]
- en: 'Prior to Java 9, the release numbers did not follow industry standard versioning--**semantic
    versioning**. For example, at the time of writing, the last four JDK releases
    were:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，发布号没有遵循行业标准版本控制——**语义版本控制**。例如，在撰写本文时，最后四个 JDK 发布版本是：
- en: JDK 8 update 131
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8 更新 131
- en: JDK 8 update 121
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8 更新 121
- en: JDK 8 update 112
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8 更新 112
- en: '**Semantic versioning** uses a major, minor, patch (0.0.0) schema:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义版本控制** 使用主版本、次版本、补丁版本（0.0.0）的方案：'
- en: '**Major** equates to new API changes that are not backwards compatible.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**主要** 相当于引入了不向后兼容的新 API 变更。'
- en: '**Minor** is when functionality is added that is backwards compatible.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**次要** 指的是添加的功能是向后兼容的。'
- en: '**Patch** refers to bug fixes or minor changes that are backwards compatible.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**补丁** 指的是向后兼容的错误修复或小更改。'
- en: 'Oracle has embraced semantic versioning for Java 9 and beyond. For Java, a
    **major-minor-security** schema will be used for the first three elements of Java
    version numbers:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 已经接受了 Java 9 及以后的语义版本控制。对于 Java，Java 版本号的前三个元素将使用 **主要-次要-安全** 方案：
- en: '**Major**: A major release consisting of a significant new set of features'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要**：包含一组重大新功能的重大版本'
- en: '**Minor**: Revisions and bug fixes that are backwards compatible'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要**：向后兼容的修订和错误修复'
- en: '**Security**: Fixes deemed critical to improve security'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：被认为对提高安全性至关重要的修复'
- en: 'This description of JEP 223 might make the versioning schema seem basic. To
    the contrary, a very detailed set of rules and practices have been developed to
    manage the future version numbers. To demonstrate the complexity, see the following
    example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 223 的这一描述可能会让版本控制方案看起来很基础。相反，已经制定了一套非常详细的规则和实践来管理未来的版本号。为了展示其复杂性，请看以下示例：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Generating run-time compiler tests automatically [JEP 233]
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动生成运行时编译器测试 [JEP 233]
- en: Java is arguably the most used programming language and resides on an increasingly
    diverse number of platforms. This exacerbates the problem of running targeted
    compiler tests in an efficient manner. The purpose of JEP 233 was to create a
    tool that could automate the runtime compiler tests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java可以说是最常用的编程语言，并且运行在日益多样化的平台上。这加剧了在高效方式下运行针对编译器的测试的问题。JEP 233的目的是创建一个可以自动化运行时编译器测试的工具。
- en: 'The tool that was created starts by generating a random set of Java source
    code and/or byte code. The generated code will have three key characteristics:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的工具首先生成一组随机的Java源代码和/或字节码。生成的代码将具有三个关键特征：
- en: Be syntactically correct
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法正确
- en: Be semantically correct
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义正确
- en: Use a random seed that permits reusing the same randomly-generated code
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用允许重用相同随机生成代码的随机种子
- en: 'The source code that is randomly generated will be saved in the following directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随机生成的源代码将被保存在以下目录中：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These test cases will be stored for later re-use. They can be run from the `j-treg`
    directory or from the tool's makefile. One of the benefits of re-running saved
    tests is to test the stability of your system.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试用例将被存储以供以后重用。可以从`j-treg`目录或从工具的makefile中运行。重新运行保存的测试的好处之一是测试系统的稳定性。
- en: Testing class-file attributes generated by Javac [JEP 235]
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试由Javac生成的类文件属性[JEP 235]
- en: The lack of, or insufficient, capability to create tests for class-file attributes
    was the impetus behind JEP 235\. The goal is to ensure javac creates a class-file's
    attributes completely and correctly. This suggests that even if some attributes
    are not used by the class-file, all class-files should be generated with a complete
    set of attributes. There also needs to be a way of testing that the class-files
    were created correctly, in regards to the file's attributes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏或不足的创建类文件属性测试的能力是JEP 235背后的动力。目标是确保javac完全且正确地创建类文件的属性。这表明即使某些属性没有被类文件使用，所有类文件都应该生成一个完整的属性集。还需要有一种方法来测试类文件是否正确创建，特别是关于文件的属性。
- en: Prior to Java 9, there was no method of testing a class-file's attributes. Running
    a class and testing the code for anticipated or expected results was the most
    commonly used method of testing javac generated class-files. This technique falls
    short of testing to validate the file's attributes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，没有测试类文件属性的方法。运行类并测试代码以获得预期或期望的结果是测试javac生成的类文件最常用的方法。这种技术不足以测试以验证文件的属性。
- en: There are three categories of class-file attributes--attributes used by the
    JVM, optional attributes, and attributes not used by the JVM.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类文件属性有三个类别——JVM使用的属性、可选属性和JVM未使用的属性。
- en: 'Attributes used by the JVM include:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JVM使用的属性包括：
- en: '`BootstrapMethods`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BootstrapMethods`'
- en: '`Code`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Code`'
- en: '`ConstantValue`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConstantValue`'
- en: '`Exceptions`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exceptions`'
- en: '`StackMapTable`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackMapTable`'
- en: 'Optional attributes include:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可选属性包括：
- en: '`Deprecated`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deprecated`'
- en: '`LineNumberTable`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineNumberTable`'
- en: '`LocalVariableTable`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalVariableTable`'
- en: '`LocalVariableTypeTable`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalVariableTypeTable`'
- en: '`SourceDebugExtension`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SourceDebugExtension`'
- en: '`SourceFile`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SourceFile`'
- en: 'Attributes not used by the JVM include:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JVM未使用的属性包括：
- en: '`AnnotationDefault`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationDefault`'
- en: '`EnclosingMethod`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnclosingMethod`'
- en: '`InnerClasses`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InnerClasses`'
- en: '`MethodParameters`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodParameters`'
- en: '`RuntimeInvisibleAnnotations`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeInvisibleAnnotations`'
- en: '`RuntimeInvisibleParameterAnnotations`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeInvisibleParameterAnnotations`'
- en: '`RuntimeInvisibleTypeAnnotations`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeInvisibleTypeAnnotations`'
- en: '`RuntimeVisibleAnnotations`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeVisibleAnnotations`'
- en: '`RuntimeVisibleParameterAnnotations`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeVisibleParameterAnnotations`'
- en: '`RuntimeVisibleTypeAnnotations`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RuntimeVisibleTypeAnnotations`'
- en: '`Signature`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Signature`'
- en: '`Synthetic`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Synthetic`'
- en: Storing interned strings in CDS archives [JEP 250]
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CDS存档中存储内部字符串[JEP 250]
- en: 'The method in which strings are stored and accessed to and from **Class Data
    Sharing** (**CDS**) archives is inefficient, excessively time consuming, and wastes
    memory. The following diagram illustrates the method in which Java stores interned
    strings in a CDS archive:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和访问字符串到和从**类数据共享**（**CDS**）存档的方法效率低下，耗时过多，且浪费内存。以下图表说明了Java在CDS存档中存储内部字符串的方法：
- en: '![](img/83403665-1780-4ddb-b210-a48a73f3c8bb.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83403665-1780-4ddb-b210-a48a73f3c8bb.png)'
- en: The inefficiency stems from the current storage schema. Especially when the
    **Class Data Sharing** tool dumps the classes into the shared archive file, the
    constant pools containing `CONSTANT_String` items have a UTF-8 string representation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 低效源于当前的存储架构。特别是当 **类数据共享** 工具将类倾倒到共享存档文件中时，包含 `CONSTANT_String` 项的常量池具有 UTF-8
    字符串表示形式。
- en: UTF-8 is an 8-bit variable-length character encoding standard.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 是一个 8 位可变长度字符编码标准。
- en: The problem
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: With the current use of UTF-8, the strings must be converted to string objects,
    instances of the `java.lang.String` class. This conversion takes place on-demand
    which can result in slower systems and unnecessary memory usage. The processing
    time is extremely short, but the memory usage cannot be overlooked. Every character
    in an interned string requires at least 3 bytes of memory and potentially more.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前使用 UTF-8 的情况下，字符串必须转换为字符串对象，即 `java.lang.String` 类的实例。这种转换是按需进行的，可能会导致系统变慢和不必要的内存使用。处理时间非常短，但内存使用不能忽视。每个内部字符串中的字符至少需要
    3 字节内存，可能还需要更多。
- en: A related problem is that the stored strings are not accessible to all JVM processes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关问题是存储的字符串对所有 JVM 进程不可访问。
- en: The solution
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'CDS archives now allocate specific space on the heap for strings:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: CDS 存档现在在堆上为字符串分配特定空间：
- en: '![](img/56d58b41-3585-4518-a9b7-140f836aec34.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56d58b41-3585-4518-a9b7-140f836aec34.png)'
- en: The string space is mapped using a shared-string table, hash tables, and deduplication.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串空间是通过共享字符串表、哈希表和去重来映射的。
- en: Deduplication is a data compression technique that eliminates duplicative information
    in an archive.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 去重是数据压缩技术，它可以消除存档中的重复信息。
- en: Preparing JavaFX UI controls and CSS APIs for modularization [JEP 253]
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模块化准备 JavaFX UI 控件和 CSS API [JEP 253]
- en: JavaFX is a set of packages that permits the design and development of media-rich
    graphical user interfaces. JavaFX applications provide developers with a great
    API for creating a consistent interface for applications. **Cascading Style Sheets**
    (**CSS**) can be used to customize the interfaces. One of the great things about
    JavaFX is that the tasks of programming and interface design can easily be separated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 是一套允许设计和开发媒体丰富的图形用户界面的包。JavaFX 应用程序为开发者提供了一个创建一致界面的强大 API。**层叠样式表**（**CSS**）可以用来自定义界面。JavaFX
    的一个优点是编程和界面设计任务可以轻松分离。
- en: JavaFX overview
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaFX 概述
- en: There is a wonderful visual scripting tool called Scene Builder that allows
    you to create graphical user interfaces by using drag and drop and property settings.
    Scene Builder generates the necessary FXML files that are used by your **Integrated
    Development Environment** (**IDE**) such as NetBeans.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个叫做 Scene Builder 的出色的可视化脚本工具，它允许你通过拖放和属性设置来创建图形用户界面。Scene Builder 生成必要的 FXML
    文件，这些文件被你的 **集成开发环境**（**IDE**）如 NetBeans 所使用。
- en: 'Here is a sample UI created with Scene Builder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 Scene Builder 创建的示例 UI：
- en: '![](img/212c2118-bfc9-4c03-b687-38b7d45203a9.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/212c2118-bfc9-4c03-b687-38b7d45203a9.png)'
- en: 'And, here is the FXML file created by Scene Builder:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是 Scene Builder 创建的 FXML 文件：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implications for Java 9
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9 的影响
- en: Prior to Java 9, JavaFX controls as well as CSS functionality were only available
    to developers by interfacing with internal APIs. Java 9's modularization has made
    the internal APIs inaccessible. Therefore, JEP 253 was created to define public,
    instead of internal, APIs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，JavaFX 控件以及 CSS 功能只能通过接口内部 API 由开发者访问。Java 9 的模块化使得内部 API 不可访问。因此，JEP
    253 被创建来定义公共 API，而不是内部 API。
- en: 'This was a larger undertaking than it might seem. Here are a few actions that
    were taken as part of this JEP:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项比看起来更大的任务。以下是一些作为此 JEP 部分采取的行动：
- en: Moving javaFX control skins from the internal to public API (`javafx.scene.skin`)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 javaFX 控件皮肤从内部移动到公共 API (`javafx.scene.skin`)
- en: Ensuring API consistencies
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保API一致性
- en: Generation of a thorough javadoc
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成详尽的 javadoc
- en: 'The following classes were moved from internal packages to a public `javafx.scene.control.skin`
    package:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类已从内部包移动到公共 `javafx.scene.control.skin` 包：
- en: '| `AccordionSkin` | `ButtonBarSkin` | `ButtonSkin` | `CellSkinBase` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `AccordionSkin` | `ButtonBarSkin` | `ButtonSkin` | `CellSkinBase` |'
- en: '| `CheckBoxSkin` | `ChoiceBoxSkin` | `ColorPickerSkin` | `ComboBoxBaseSkin`
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `CheckBoxSkin` | `ChoiceBoxSkin` | `ColorPickerSkin` | `ComboBoxBaseSkin`
    |'
- en: '| `ComboBoxListViewSkin` | `ComboBoxPopupControl` | `ContextMenuSkin` | `DateCellSkin`
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `ComboBoxListViewSkin` | `ComboBoxPopupControl` | `ContextMenuSkin` | `DateCellSkin`
    |'
- en: '| `DatePickerSkin` | `HyperLinkSkin` | `LabelSkin` | `LabeledSkinBase` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `DatePickerSkin` | `HyperLinkSkin` | `LabelSkin` | `LabeledSkinBase` |'
- en: '| `ListCellSkin` | `ListViewSkin` | `MenuBarSkin` | `MenuButtonSkin` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `ListCellSkin` | `ListViewSkin` | `MenuBarSkin` | `MenuButtonSkin` |'
- en: '| `MenuButtonSkinbase` | `NestedTableColumHeader` | `PaginationSkin` | `ProgressBarSkin`
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `MenuButtonSkinbase` | `NestedTableColumHeader` | `PaginationSkin` | `ProgressBarSkin`
    |'
- en: '| `ProgressIndicatorSkin` | `RadioButtonSkin` | `ScrollBarSkin` | `ScrollPaneSkin`
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `ProgressIndicatorSkin` | `RadioButtonSkin` | `ScrollBarSkin` | `ScrollPaneSkin`
    |'
- en: '| `SeparatorSkin` | `SliderSkin` | `SpinnerSkin` | `SplitMenuButtonSkin` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `SeparatorSkin` | `SliderSkin` | `SpinnerSkin` | `SplitMenuButtonSkin` |'
- en: '| `SplitPaneSkin` | `TabPaneSkin` | `TableCellSkin` | `TableCellSkinBase` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `SplitPaneSkin` | `TabPaneSkin` | `TableCellSkin` | `TableCellSkinBase` |'
- en: '| `TableColumnHeader` | `TableHeaderRow` | `TableHeaderSkin` | `TableRowSkinBase`
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `TableColumnHeader` | `TableHeaderRow` | `TableHeaderSkin` | `TableRowSkinBase`
    |'
- en: '| `TableViewSkin` | `TableViewSkinBase` | `TextAreaSkin` | `TextFieldSkin`
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `TableViewSkin` | `TableViewSkinBase` | `TextAreaSkin` | `TextFieldSkin`
    |'
- en: '| `TextInputControlSkin` | `TitledPaneSkin` | `ToggleButtonSkin` | `TooBarSkin`
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `TextInputControlSkin` | `TitledPaneSkin` | `ToggleButtonSkin` | `TooBarSkin`
    |'
- en: '| `TooltipSkin` | `TreeCellSkin` | `TreeTableCellSkin` | `TreeTableRowSkin`
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `TooltipSkin` | `TreeCellSkin` | `TreeTableCellSkin` | `TreeTableRowSkin`
    |'
- en: '| `TreeTableViewSkin` | `TreeViewSkin` | `VirtualContainerBase` | `VirtualFlow`
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `TreeTableViewSkin` | `TreeViewSkin` | `VirtualContainerBase` | `VirtualFlow`
    |'
- en: 'The public `javafx.css` package now has the additional classes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的`javafx.css`包现在有额外的类：
- en: '`CascadingStyle.java:public class CascadingStyle implements Comparable<CascadingStyle>`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CascadingStyle.java:public class CascadingStyle implements Comparable<CascadingStyle>`'
- en: '`CompoundSelector.java:final public class CompoundSelector extends Selector`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompoundSelector.java:final public class CompoundSelector extends Selector`'
- en: '`CssError.java:public class CssError`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CssError.java:public class CssError`'
- en: '`Declaration.java:final public class Declaration`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Declaration.java:final public class Declaration`'
- en: '`Rule.java:final public class Rule`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rule.java:final public class Rule`'
- en: '`Selector.java:abstract public class Selector`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector.java:abstract public class Selector`'
- en: '`SimpleSelector.java:final public class SimpleSelector extends Selector`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleSelector.java:final public class SimpleSelector extends Selector`'
- en: '`Size.java:final public class Size`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size.java:final public class Size`'
- en: '`Style.java:final public class Style`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Style.java:final public class Style`'
- en: '`Stylesheet.java:public class Stylesheet`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stylesheet.java:public class Stylesheet`'
- en: '`CssParser.java:final public class CssParser`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CssParser.java:final public class CssParser`'
- en: Compact strings [JEP 254]
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧凑字符串 [JEP 254]
- en: The string data type is an important part of nearly every Java app. While JEP
    254's aim was to make strings more space-efficient, it was approached with caution
    so that existing performance and compatibilities would not be negatively impacted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型是几乎所有Java应用程序的重要部分。虽然JEP 254的目标是使字符串更节省空间，但它采取了谨慎的态度，以确保现有的性能和兼容性不会受到负面影响。
- en: Pre-Java 9 status
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9之前的状态
- en: Prior to Java 9, string data was stored as an array of chars. This required
    16 bits for each char. It was determined that the majority of String objects could
    be stored with only 8 bits, or 1 byte of storage. This is due to the fact that
    most strings consist of Latin-1 characters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，字符串数据存储为字符数组。每个字符需要16位。确定大多数String对象可以用仅8位，即1个字节的存储来存储。这是因为大多数字符串由拉丁-1字符组成。
- en: The ISO Latin-1 Character Set is a single-byte set of character's encodings.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ISO Latin-1字符集是一个单字节字符编码集。
- en: New with Java 9
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9的新特性
- en: Starting with Java 9, strings are now internally represented using a byte array
    along with a flag field for encoding references.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 9开始，字符串现在使用字节数组和编码引用的标志字段内部表示。
- en: Merging selected Xerces 2.11.0 updates into JAXP [JEP 255]
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将选定的Xerces 2.11.0更新合并到JAXP [JEP 255]
- en: Xerces is a library used for parsing XML in Java. It was updated to 2.11.0 in
    late 2010, so JEP 255's aim was to update JAXP to incorporate changes in Xerces
    2.11.0.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Xerces是一个用于在Java中解析XML的库。它在2010年底更新到2.11.0，因此JEP 255的目标是更新JAXP以包含Xerces 2.11.0的变化。
- en: JAXP is Java's API for XML processing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: JAXP是Java的XML处理API。
- en: Prior to Java 9, the JDK's latest update regarding XML processing was based
    on Xerces 2.7.1\. There were some additional changes to JDK 7 based on Xerces,
    2.10.0\. JEP 255 is a further refinement of the JAXP based on Xerces 2.11.0.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，JDK关于XML处理的最新更新基于Xerces 2.7.1。基于Xerces对JDK 7的一些额外更改，2.10.0。JEP 255是基于Xerces
    2.11.0的JAXP的进一步改进。
- en: 'Xerces 2.11.0 supports the following standards:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Xerces 2.11.0支持以下标准：
- en: XML 1.0, Fourth Edition
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 1.0，第四版
- en: Namespaces in XML 1.0, Second Edition
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 1.0，第二版中的命名空间
- en: XML 1.1, Second Edition
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 1.1，第二版
- en: Namespaces in XML 1.1, Second Edition
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 1.1，第二版中的命名空间
- en: XML Inclusions 1.0, Second Edition
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 包含 1.0，第二版
- en: '**Document Object Model** (**DOM**)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档对象模型** (**DOM**)'
- en: Level 3
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 3 级
- en: Core
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心
- en: Load & save
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载 & 保存
- en: Level 2
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 2 级
- en: Core
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心
- en: Events
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Traversal & Range
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历 & 范围
- en: Element Traversal, First Edition
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素遍历，第一版
- en: Simple API for XML 2.0.2
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单 XML API 2.0.2
- en: '**Java APIs for XML Processing** (**JAXP**) 1.4'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java XML 处理 API** (**JAXP**) 1.4'
- en: Streaming API for XML 1.0
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 流式处理 API 1.0
- en: XML Schema 1.0
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 模式 1.0
- en: XML Schema 1.1
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 模式 1.1
- en: XML Schema Definition Language
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 模式定义语言
- en: 'The JDK was updated to include the following Xerces 2.11.0 categories:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 已更新以包含以下 Xerces 2.11.0 类别：
- en: Catalog resolver
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录解析器
- en: Datatypes
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Document Object Model Level 3
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档对象模型第 3 级
- en: XML Schema Validation
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 模式验证
- en: XPointer
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XPointer
- en: The public API for JAXP was not changed in Java 9.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中未更改 JAXP 的公共 API。
- en: Updating JavaFX/Media to newer version of GStreamer [JEP 257]
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 JavaFX/Media 更新到 GStreamer 的新版本 [JEP 257]
- en: 'JavaFX is used for creating desktop and web applications. JavaFX was created
    to replace Swing as Java''s standard GUI library. The `Media` class, `javafx.scene.media.Media`,
    is used to instantiate an object representing a media resource. JavaFX/Media refers
    to the following class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 用于创建桌面和 Web 应用程序。JavaFX 是为了取代 Swing 作为 Java 的标准 GUI 库而创建的。`Media` 类，`javafx.scene.media.Media`，用于实例化表示媒体资源的对象。JavaFX/Media
    指的是以下类：
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class provides referential data to a media resource. The `javafx.scene.media`
    package provides developers with the ability to incorporate media into their JavaFX
    applications. JavaFX/Media utilizes a GStreamer pipeline.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此类提供对媒体资源的引用数据。`javafx.scene.media` 包为开发人员提供了将媒体集成到他们的 JavaFX 应用程序中的能力。JavaFX/Media
    使用 GStreamer 管道。
- en: GStreamer is a multimedia processing framework that can be used to build systems
    that take in media from several different formats and, after processing, export
    them in selected formats.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer 是一个多媒体处理框架，可用于构建从多种不同格式获取媒体并处理后以选定格式导出的系统。
- en: The purpose of JEP 257 was to ensure JavaFX/Media was updated to include the
    latest release of GStreamer for stability, performance, and security assurances.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 257 的目的是确保 JavaFX/Media 更新到 GStreamer 的最新版本，以确保稳定性、性能和安全保证。
- en: HarfBuzz Font-Layout Engine [JEP 258]
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HarfBuzz 字体布局引擎 [JEP 258]
- en: Prior to Java 9, the layout engine used to handle font complexities; specifically
    fonts that have rendering behaviors beyond what the common Latin fonts have. Java
    used the uniform client interface, also referred to as ICU, as the defacto text
    rendering tool. The ICU layout engine has been depreciated and, in Java 9, has
    been replaced with the HarfBuzz font layout engine.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，布局引擎用于处理字体复杂性；具体来说，是指那些具有超出常见拉丁字体渲染行为的字体。Java 使用统一客户端界面，也称为 ICU，作为默认文本渲染工具。ICU
    布局引擎已被弃用，并在 Java 9 中被 HarfBuzz 字体布局引擎所取代。
- en: HarfBuzz is an **OpenType** text rendering engine. This type of layout engine
    has the characteristic of providing script-aware code to help ensure text is laid
    out as desired.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: HarfBuzz 是一个 **OpenType** 文本渲染引擎。此类布局引擎具有提供脚本感知代码的特性，以帮助确保文本按预期布局。
- en: OpenType is an HTML formatted font format specification.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: OpenType 是一种 HTML 格式化字体格式规范。
- en: The impetus for the change from the ICU Layout Engine to the HarfBuzz Font Layout
    Engine was IBM's decision to cease supporting the ICU Layout Engine. Therefore,
    the JDK was updated to contain the HarfBuzz Font Layout Engine.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ICU 布局引擎到 HarfBuzz 字体布局引擎的变更动力是 IBM 决定停止支持 ICU 布局引擎。因此，JDK 已更新以包含 HarfBuzz
    字体布局引擎。
- en: HiDPI graphics on Windows and Linux [JEP 263]
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 和 Linux 上的 HiDPI 图形 [JEP 263]
- en: 'JEP 263 was focused on ensuring the crispness of on-screen components, relative
    to the pixel density of the display. The following terms are relevant to this
    JEP and are provided along with the below listed descriptive information:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 263 专注于确保屏幕组件的清晰度，相对于显示器的像素密度。以下术语与该 JEP 相关，并附带以下列出的描述信息：
- en: '**DPI-aware application**: An application that is able to detect and scale
    images for the display''s specific pixel density'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DPI 可知应用程序**：一个能够检测和缩放图像以适应显示特定像素密度的应用程序'
- en: '**DPI-unaware application**: An application that makes no attempt to detect
    and scale images for the display''s specific pixel density'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DPI 不可知应用程序**：一个不尝试检测和缩放图像以适应显示特定像素密度的应用程序'
- en: '**HiDPI graphics**: High dots-per-inch graphics'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HiDPI 图形**: 每英寸高点数图形'
- en: '**Retina display**: This term was created by Apple to refer to displays with
    a pixel density of at least 300 pixels per inch'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视网膜显示器**：这个术语由苹果公司创造，指的是至少每英寸300像素密度的显示器'
- en: 'Displaying graphics, both images and graphical user interface components, to
    the user is typically of paramount performance. Displaying this imagery in high
    quality can be somewhat problematic. There is large variability in computer monitor
    DPIs. There are three basic approaches to developing for displays:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户显示图形，无论是图像还是图形用户界面组件，通常具有至关重要的性能。以高质量显示这些图像可能有些问题。计算机监视器的DPI有很大的变化。开发显示器的三种基本方法如下：
- en: Develop apps without regard for the potential different display dimensions.
    In other words, create a DPI-unaware application.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发不考虑潜在不同显示尺寸的应用程序。换句话说，创建一个DPI无感知的应用程序。
- en: Develop a DPI-aware application that selectively uses pre-rendered image sizes
    for a given display.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个对DPI敏感的应用程序，该程序可以选择性地使用给定显示器的预渲染图像大小。
- en: Develop a DPI-aware application that properly scales images up/down to account
    for the specific display the application is run on.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个对DPI敏感的应用程序，该程序能够正确地缩放图像以适应应用程序运行的特定显示器。
- en: Clearly, the first two approaches are problematic, and for different reasons.
    With the first approach, the user experience is not considered. Of course, if
    the application was being developed for a very specific display with no expected
    pixel density variability, then this approach could be viable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前两种方法都有问题，并且原因不同。在第一种方法中，没有考虑用户体验。当然，如果应用程序是为具有无预期像素密度变化的特定显示器开发的，那么这种方法可能是可行的。
- en: The second approach requires a lot of work on the design and development end
    to ensure images for each expected display density are created and implemented
    programmatically. In addition to the tremendous amount of work, the app size will
    unnecessarily increase, and new and different pixel densities will not have been
    accounted for.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法需要在设计和开发端进行大量工作，以确保为每个预期的显示密度创建并程序化实现图像。除了大量的工作外，应用程序的大小将不必要地增加，并且没有考虑到新的和不同的像素密度。
- en: The third approach is to create a DPI-aware application with efficient and effective
    scaling capabilities. This approach works well and has been proven with the Mac
    retina displays.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是为具有高效和有效缩放功能的应用程序创建一个对DPI敏感的应用程序。这种方法效果很好，并且已经在Mac视网膜显示器上得到证明。
- en: Prior to Java 9, automatic scaling and sizing was already implemented in Java
    for the Mac OS X operating system. This capability was added in Java 9 for Windows
    and Linux operating systems.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，自动缩放和尺寸调整已经在Java中实现，用于Mac OS X操作系统。这种功能在Java 9中添加到了Windows和Linux操作系统。
- en: Marlin graphics renderer [JEP 265]
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marlin图形渲染器 [JEP 265]
- en: JEP 265 replaced the Pisces graphics rasterizer with the Marlin graphics renderer
    in the Java 2D API. This API is used to draw 2D graphics and animations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 265在Java 2D API中将Pisces图形光栅化器替换为Marlin图形渲染器。此API用于绘制2D图形和动画。
- en: The goal was to replace Pisces with a rasterizer/renderer that was much more
    efficient and without any quality loss. This goal was realized in Java 9\. An
    intended collateral benefit was to include a developer-accessible API. Previously,
    the means of interfacing with the AWT and Java 2D was internal.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是用一个效率更高且没有质量损失的光栅化器/渲染器替换Pisces。这个目标在Java 9中实现了。一个预期的附带好处是包括一个开发者可访问的API。以前，与AWT和Java
    2D接口的方式是内部的。
- en: Unicode 8.0.0 [JEP 267]
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode 8.0.0 [JEP 267]
- en: Unicode 8.0.0 was released on June 17, 2015\. JEP 267 focused on updating the
    relevant APIs to support Unicode 8.0.0.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 8.0.0于2015年6月17日发布。JEP 267专注于更新相关API以支持Unicode 8.0.0。
- en: New in Unicode 8.0.0
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode 8.0.0中的新内容
- en: 'Unicode 8.0.0 added nearly 8,000 characters. Here are the highlights of the
    release:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 8.0.0增加了近8000个字符。以下是发布的高亮内容：
- en: Ahom script for the Tai Ahom language (India)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ahom语脚本（印度泰阿洪语）
- en: Arwi, Tamil language (Arabic)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arwi，泰米尔语（阿拉伯语）
- en: Cherokee symbols
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切罗基符号
- en: CJK unified ideographs
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CJK统一表意文字
- en: Emoji symbols along with flesh-tone symbol modifiers
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表情符号以及肤色符号修饰符
- en: Georgian lari currency symbol
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格鲁吉亚拉里货币符号
- en: lk language (Uganda)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lk语言（乌干达）
- en: Kulango languge (Côte d’Ivoire)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kulango语言（科特迪瓦）
- en: Updated Classes in Java 9
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9中的更新类
- en: 'In order to fully comply with the new Unicode standard, several Java classes
    were updated. The following listed classes were updated for Java 9 to comply with
    the new Unicode standard:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全符合新的Unicode标准，更新了几个Java类。以下列出的类在Java 9中更新，以符合新的Unicode标准：
- en: '`java.awt.font.NumericShaper`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.font.NumericShaper`'
- en: '`java.lang.Character`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Character`'
- en: '`java.lang.String`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.String`'
- en: '`java.text.Bidi`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.text.Bidi`'
- en: '`java.text.BreakIterator`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.text.BreakIterator`'
- en: '`java.text.Normalizer`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.text.Normalizer`'
- en: Reserved stack areas for critical sections [JEP 270]
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为关键部分预留栈区域 [JEP 270]
- en: The goal of JEP 270 was to mitigate problems stemming from stack overflows during
    the execution of critical sections. This mitigation took the form of reserving
    additional thread stack space.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 270的目标是减轻在执行关键部分时由于栈溢出而产生的问题。这种缓解措施采取了预留额外线程栈空间的形式。
- en: The pre-Java 9 situation
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9之前的状况
- en: The JVM throws a `StackOverflowError` when it is asked to perform data computation
    in a thread that has insufficient stack space and does not have permission to
    allocate additional space. This is an asynchronous exception. The JVM can also
    throw the `StackOverflowError` exception synchronously when a method is invoked.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM被要求在一个没有足够栈空间且没有权限分配额外空间的线程中执行数据计算时，它会抛出`StackOverflowError`。这是一个异步异常。当方法被调用时，JVM也可以同步地抛出`StackOverflowError`异常。
- en: When a method is invoked, an internal process is used to report the Stack Overflow.
    While the current schema works sufficiently for reporting the error, there is
    no room for the calling application to easily recover from the error. This can
    result in being more than a nuisance for developers and users. If the `StackOverflowError`
    was thrown during a critical computational operation, the data might be corrupted,
    causing additional problems.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法被调用时，会使用一个内部过程来报告栈溢出。虽然当前的架构足以报告错误，但调用应用程序没有足够的空间轻松地从错误中恢复。这可能会给开发人员和用户带来更多的不便。如果在关键的计算操作期间抛出了`StackOverflowError`，数据可能会被损坏，导致更多的问题。
- en: While not the sole cause of these problems, the effected status of locks from
    the `ReentrantLock` class were a common cause of undesirable outcomes. This issue
    was evident in Java 7 because the `ConcurrentHasMap` code implemented the `ReentrantLock`
    class. The `ConcurrentHasMap` code was modified for Java 8, but problems still
    persisted for any implementation of the `ReentrantLock` class. Similar problems
    existed beyond just `ReentrantLock` class usage.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些问题的原因并非唯一，但`ReentrantLock`类的受影响状态是导致不理想结果的一个常见原因。这个问题在Java 7中很明显，因为`ConcurrentHasMap`代码实现了`ReentrantLock`类。`ConcurrentHasMap`代码在Java
    8中进行了修改，但对于`ReentrantLock`类的任何实现，问题仍然存在。类似的问题超出了仅仅使用`ReentrantLock`类的情况。
- en: 'The following diagram provides a broad overview of the `StackOverflowError`
    problem:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了`StackOverflowError`问题的广泛概述：
- en: '![](img/3cf09c85-193f-4775-903d-812a81622175.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cf09c85-193f-4775-903d-812a81622175.png)'
- en: In the next section, we will look at how this issue was resolved for Java 9.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何解决Java 9中的这个问题。
- en: New in Java 9
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9新增功能
- en: With the JEP 270 changes for Java 9, a critical section will automatically be
    given additional space so that it can complete its execution and not suffer from
    the `StackOverflowError`. This is predicated on the additional space allocation
    needs being small. The necessary changes have been made to the JVM to permit this
    functionality.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，通过JEP 270的更改，关键部分将自动获得额外的空间，以便它可以完成其执行而不会遭受`StackOverflowError`。这基于额外的空间分配需求很小。JVM已经进行了必要的更改，以允许此功能。
- en: 'The JVM actually delays the `StackOverflowError`, or at least attempts to,
    while critical sections are executing. In order to capitalize on this new schema,
    methods must be annotated with the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM在执行关键部分时，实际上会延迟`StackOverflowError`，或者至少尝试这样做。为了利用这个新架构，方法必须使用以下注解：
- en: '[PRE11]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When a method has this annotation and a `StackOverflowError` condition exists,
    temporary access to the reserved memory space is granted. The new process is,
    at a high level of abstraction, presented as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法有这个注解并且存在`StackOverflowError`条件时，会授予临时访问预留内存空间。这个新过程在高度抽象的层面上可以表示如下：
- en: '![](img/7a3c5ac5-5f52-41fc-806e-3767a1ce541e.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a3c5ac5-5f52-41fc-806e-3767a1ce541e.png)'
- en: Dynamic linking of language-defined object models [JEP 276]
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言定义的对象模型的动态链接 [JEP 276]
- en: Java interoperability was enhanced with JEP 276\. The necessary JDK changes
    were made to permit runtime linkers from multiple languages to coexist in a single
    JVM instance. This change applies to high-level operations, as you would expect.
    An example of a relevant high-level operation is the reading or writing of a property
    with elements such as accessors and mutators.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过JEP 276增强了Java互操作性。必要的JDK更改已做出，以允许来自多种语言的运行时链接器在单个JVM实例中共存。这个更改适用于高级操作，正如您所期望的。一个相关的高级操作示例是读取或写入具有访问器和修改器等元素的属性。
- en: 'The high-level operations apply to objects of unknown types. They can be invoked
    with `INVOKEDYNAMIC` instructions. Here is an example of calling an object''s
    property when the object''s type is unknown at compile time:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 高级操作适用于未知类型的对象。它们可以使用`INVOKEDYNAMIC`指令调用。以下是一个在编译时未知对象类型时调用对象属性示例：
- en: '[PRE12]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Proof of concept
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念证明
- en: 'Nashorn is a lightweight, high-performance, JavaScript runtime that permits
    embedding JavaScript in Java applications. This was created for Java 8 and replaced
    the previous JavaScript scripting engine that was based on Mozilla Rhino. Nashorn
    already has this functionality. It provides linkage between high-level operations
    on any object of unknown type, such as `obj.something`, where it produces the
    following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Nashorn是一个轻量级、高性能的JavaScript运行时，允许在Java应用程序中嵌入JavaScript。这是为Java 8创建的，并取代了基于Mozilla
    Rhino的先前JavaScript脚本引擎。Nashorn已经具有这种功能。它提供任何未知类型对象上的高级操作之间的链接，例如`obj.something`，它产生以下结果：
- en: '[PRE13]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The dynamic linker springs into action and provides, when possible, the appropriate
    implementation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接器立即启动，并在可能的情况下提供适当的实现。
- en: Additional tests for humongous objects in G1 [JEP 278]
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1中巨大对象的附加测试 [JEP 278]
- en: One of the long-favored features of the Java platform is the behind the scenes
    garbage collection. JEP 278's focus was to create additional WhiteBox tests for
    humongous objects as a feature of the G1 garbage collector.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台长期受欢迎的功能之一是幕后垃圾回收。JEP 278的焦点是创建G1垃圾回收器的附加WhiteBox测试，作为对巨大对象的特性。
- en: WhiteBox testing is an API used to query JVM internals. The WhiteBox testing
    API was introduced in Java 7 and upgraded in Java 8 and Java 9.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: WhiteBox测试是一个用于查询JVM内部的API。WhiteBox测试API在Java 7中引入，并在Java 8和Java 9中进行了升级。
- en: 'The G1 garbage collector works extremely well, but there was room for some
    improved efficiency. The way the G1 garbage collector worked is based on first
    dividing the heap into regions of equal size, illustrated as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾回收器工作得非常好，但仍有提高效率的空间。G1垃圾回收器的工作方式是首先将堆分成大小相等的区域，如下所示：
- en: '![](img/8a7a7ad8-1e26-41cd-9d1c-53f866e21cdc.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a7a7ad8-1e26-41cd-9d1c-53f866e21cdc.png)'
- en: The problem with the G1 garbage collector was how humongous objects were handled.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾回收器的问题在于如何处理巨大对象。
- en: A humongous object in the context of garbage collection, is any object that
    takes up more than one region on the heap.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾回收的上下文中，巨大对象是指占据堆上多个区域的对象。
- en: 'The problem with humongous objects was that if they took up any part of a region
    on the heap, the remaining space was not able to be allocated for other objects.
    In Java 9, the WhiteBox API was extended with four types of new methods:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 巨大对象的问题在于，如果它们占据了堆上任何区域的一部分，剩余的空间就无法为其他对象分配。在Java 9中，WhiteBox API通过四种新方法进行了扩展：
- en: Methods with the purpose of blocking full garbage collection and to initiate
    concurrent marking.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于阻止完全垃圾回收并启动并发标记的方法。
- en: Methods that can access individual G1 garbage collection heap regions. Access
    to these regions consist of attribute reading, such as with the current state
    of the region.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以访问单个G1垃圾回收器堆区域的方法。对这些区域的访问包括属性读取，例如区域的当前状态。
- en: Methods with direct access to the G1 garbage collection internal variables.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接访问G1垃圾回收器内部变量的方法。
- en: Methods that can determine if humongous objects reside on the heap and, if so,
    in what regions.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以确定巨大对象是否位于堆上以及它们位于哪些区域的方法。
- en: Improving test-failure troubleshooting [JEP 279]
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进测试失败故障排除 [JEP 279]
- en: For developers that do a lot of testing, JEP 279 is worth reading about. Additional
    functionality has been added in Java 9 to automatically collect information to
    support troubleshooting test failures as well as timeouts. Collecting readily
    available diagnostic information during tests stands to provide developers and
    engineers with greater fidelity in their logs and other output.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于做很多测试的开发者来说，JEP 279值得一读。Java 9中添加了额外的功能，以自动收集信息以支持故障排除测试失败以及超时。在测试期间收集可用的诊断信息，可以为开发者和工程师提供更精确的日志和其他输出。
- en: There are two basic types of information in the context of testing--environmental
    and process.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的上下文中，有两种基本类型的信息——环境和过程。
- en: Environmental information
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境信息
- en: 'When running tests, the testing environment information can be important for
    troubleshooting efforts. This information includes the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试时，测试环境信息对于故障排除工作可能很重要。这些信息包括以下内容：
- en: CPU loads
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU负载
- en: Disk space
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘空间
- en: I/O loads
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O负载
- en: Memory space
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存空间
- en: Open files
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的文件
- en: Open sockets
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的套接字
- en: Processes running
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行的进程
- en: System events
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统事件
- en: System messages
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统消息
- en: Java process information
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java进程信息
- en: 'There is also information available during the testing process directly related
    to Java processes. These include:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，还有与Java进程直接相关的信息。这些包括：
- en: C stacks
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C栈
- en: Core dumps
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心转储
- en: Mini dumps
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型转储
- en: Heap statistics
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆统计信息
- en: Java stacks
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java栈
- en: For additional information on this concept, read about the JDK's regression
    test harness (jtreg).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此概念的更多信息，请阅读关于JDK回归测试工具（jtreg）的内容。
- en: Optimizing string concatenation [JEP 280]
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化字符串连接 [JEP 280]
- en: 'JEP 280 is an interesting enhancement for the Java platform. Prior to Java
    9, string concatenation was translated by javac into `StringBuilder : : append`
    chains. This was a sub-optimal translation methodology often requiring `StringBuilder`
    presizing.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'JEP 280是Java平台的一个有趣增强。在Java 9之前，字符串连接被javac翻译成`StringBuilder :: append`链。这是一种次优的翻译方法，通常需要`StringBuilder`预分配大小。'
- en: The enhancement changed the string concatenation bytecode sequence, generated
    by javac, so that it uses `INVOKEDYNAMIC` calls. The purpose of the enhancement
    was to increase optimization and to support future optimizations without the need
    to reformat the javac's bytecode.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 增强改变了由javac生成的字符串连接字节码序列，使其使用`INVOKEDYNAMIC`调用。增强的目的是提高优化并支持未来的优化，而无需重新格式化javac的字节码。
- en: See JEP 276 for more information on `INVOKEDYNAMIC`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`INVOKEDYNAMIC`的更多信息，请参阅JEP 276。
- en: The use of `INVOKEDYAMIC` calls to `java.lang.invoke.StringConcatFactory` allows
    us to use a methodology similar to lambda expressions instead of using StringBuilder's
    step-wise process. This results in more efficient processing of string concatenation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`INVOKEDYNAMIC`调用`java.lang.invoke.StringConcatFactory`允许我们使用类似于lambda表达式的方法，而不是使用StringBuilder的逐步过程。这导致字符串连接处理更加高效。
- en: HotSpot C++ unit-test framework [JEP 281]
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HotSpot C++单元测试框架 [JEP 281]
- en: 'HotSpot is the name of the JVM. This Java enhancement was intended to support
    the development of C++ unit tests for the JVM. Here is a partial, non-prioritized,
    list of goals for this enhancement:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot是JVM的名称。这个Java增强旨在支持为JVM开发C++单元测试。以下是此增强功能的部分、非优先级列表的目标：
- en: Command-line testing
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行测试
- en: Create appropriate documentation
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建适当的文档
- en: Debug compile targets
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试编译目标
- en: Framework elasticity
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架弹性
- en: IDE support
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE支持
- en: Individual and isolated unit testing
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独和隔离的单元测试
- en: Individualized test results
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性化测试结果
- en: Integrate with existing infrastructure
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现有基础设施集成
- en: Internal test support
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部测试支持
- en: Positive and negative testing
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正面和负面测试
- en: Short execution time testing
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短时间执行测试
- en: Support all JDK 9 build platforms
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持所有JDK 9构建平台
- en: Test compile targets
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试编译目标
- en: Test exclusion
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试排除
- en: Test grouping
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试分组
- en: Testing that requires the JVM to be initialized
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要初始化JVM的测试
- en: Tests co-located with source code
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与源代码位于同一位置的测试
- en: Tests for platform-dependent code
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台相关代码的测试
- en: Write and execute unit testing (for classes and methods)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和执行单元测试（对于类和方法）
- en: This enhancement is evidence of the increasing extensibility.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个增强功能是可扩展性增加的证据。
- en: Enabling GTK 3 on Linux [JEP 283]
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上启用GTK 3 [JEP 283]
- en: GTK+, formally known as the GIMP toolbox, is a cross-platform tool used for
    creating **Graphical User Interfaces** (**GUI**). The tool consists of widgets
    accessible through its API. JEP 283's focus was to ensure GTK 2 and GTK 3 were
    supported on Linux when developing Java applications with graphical components.
    The implementation supports Java apps that employ JavaFX, AWT, and Swing.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: GTK+，正式称为 GIMP 工具箱，是一个跨平台工具，用于创建 **图形用户界面**（**GUI**）。该工具由其 API 可访问的小部件组成。JEP
    283 的重点是确保在开发具有图形组件的 Java 应用程序时，GTK 2 和 GTK 3 在 Linux 上得到支持。该实现支持使用 JavaFX、AWT
    和 Swing 的 Java 应用程序。
- en: 'We can create Java graphical applications with JavaFX, AWT, and Swing. Here
    is a table to summarize those three approaches as they relate to GTK, prior to
    Java 9:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 JavaFX、AWT 和 Swing 创建 Java 图形应用程序。以下表格总结了这三个方法与 GTK 的关系，在 Java 9 之前：
- en: '| **Approach** | **Remarks** |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **备注** |'
- en: '| JavaFX |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| JavaFX |'
- en: Uses a dynamic GTK function lookup
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态 GTK 函数查找
- en: Interacts with AWT and Swing via JFXPanel
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 JFXPanel 与 AWT 和 Swing 交互
- en: Uses AWT printing functionality
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWT 打印功能
- en: '|'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| AWT |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| AWT |'
- en: Uses a dynamic GTK function lookup
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态 GTK 函数查找
- en: '|'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Swing |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| Swing |'
- en: Uses a dynamic GTK function lookup
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态 GTK 函数查找
- en: '|'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'So, what changes were necessary to implement this JEP? For JavaFX, three specific
    things were changed:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了实现这个 JEP，需要做出哪些改变？对于 JavaFX，有三个具体的变化：
- en: Automated testing was added for both GTK 2 and GTK 3
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 GTK 2 和 GTK 3 添加了自动测试
- en: Functionality was added to dynamically load GTK 2
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了动态加载 GTK 2 的功能
- en: Support was added for GTK 3
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了对 GTK 3 的支持
- en: 'For AWT and Swing, the following changes were implemented:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 AWT 和 Swing，实施了以下更改：
- en: Automated testing was added for both GTK 2 and GTK 3
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 GTK 2 和 GTK 3 添加了自动测试
- en: '`AwtRobot` was migrated to GTK 3'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AwtRobot` 已迁移到 GTK 3'
- en: '`FileChooserDilaog` was updated for GTK 3'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileChooserDilaog` 已更新以兼容 GTK 3'
- en: Functionality was added to dynamically load GTK 3
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了动态加载 GTK 3 的功能
- en: The Swing GTK LnF was modified to support GTK 3
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swing GTK LnF 已修改以支持 GTK 3
- en: Swing GTK LnF is short for Swing GTK look and feel.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Swing GTK LnF 是 Swing GTK look and feel 的缩写。
- en: New HotSpot build system [JEP 284]
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的 HotSpot 构建系统 [JEP 284]
- en: 'The Java platform used, prior to Java 9, was a build system riddled with duplicate
    code, redundancies, and other inefficiencies. The build system has been reworked
    for Java 9 based on the build-infra framework. In this context, infra is short
    for infrastructure. The overarching goal for JEP 284 was to upgrade the build
    system to one that was simplified. Specific goals included:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，Java 平台使用的构建系统充满了重复代码、冗余和其他低效之处。基于 build-infra 框架，构建系统已被重新设计以适应
    Java 9。在此上下文中，infra 是基础设施的缩写。JEP 284 的总体目标是升级构建系统，使其简化。具体目标包括：
- en: Leverage existing build system
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用现有的构建系统
- en: Maintainable code
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护的代码
- en: Minimize duplicate code
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化重复代码
- en: Simplification
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化
- en: Support future enhancements
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持未来增强
- en: 'You can learn more about Oracle''s infrastructure framework at this site: [http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html](http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本网站上了解更多关于 Oracle 基础设施框架的信息：[http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html](http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html)
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some impressive new features of the Java platform,
    with specific focus on javac, JDK libraries, and various test suites. Memory management
    improvements, including heap space efficiencies, memory allocation, and improved
    garbage collection represent a powerful new set of Java platform enhancements.
    Changes regarding the compilation process resulting in greater efficiencies were
    part of our chapter. We also covered important improvements, such as with the
    compilation process, type testing, annotations, and automated runtime compiler
    tests.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Java 平台的一些令人印象深刻的新特性，特别关注 javac、JDK 库和各种测试套件。内存管理改进，包括堆空间效率、内存分配和改进的垃圾收集，代表了一组强大的
    Java 平台增强。关于编译过程的改变，以提高效率，也是我们章节的一部分。我们还介绍了重要的改进，如编译过程、类型测试、注解和自动运行时编译器测试。
- en: In the next chapter, we will look at several minor language enhancements introduced
    in Java 9.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Java 9 中引入的几个小的语言增强。
