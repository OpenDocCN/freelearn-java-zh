- en: '*Chapter 19*: Logging and Testing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第19章*：日志记录和测试'
- en: 'In this chapter, we will cover logging and testing from the jOOQ perspective.
    Relying on the fact that these are common-sense notions, I won''t explain what
    logging and testing are, nor will I highlight their obvious importance. That being
    said, let''s jump directly into the agenda of this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从jOOQ的角度介绍日志记录和测试。鉴于这些是常识性的概念，我不会解释日志记录和测试是什么，也不会强调它们显而易见的重要性。话虽如此，让我们直接进入本章的议程：
- en: jOOQ logging
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ日志记录
- en: jOOQ testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ测试
- en: Let's get started!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter19](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter19).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter19](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter19)。
- en: jOOQ logging
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ日志记录
- en: 'By default, you''ll see the jOOQ logs at the `DEBUG` level during code generation
    and during queries/routine execution. For instance, during a regular `SELECT`
    execution, jOOQ logs the query SQL string (with and without the bind values),
    the first 5 records from the fetched result set as a nice formatted table, and
    the size of the result is set as shown in the following figure:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你会在代码生成和查询/过程执行期间看到jOOQ的`DEBUG`级别日志。例如，在常规`SELECT`执行期间，jOOQ记录查询SQL字符串（带有和没有绑定值），获取结果集的前5条记录作为格式良好的表格，以及结果集的大小设置，如图下所示：
- en: '![](img/Figure_19.1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_19.1.jpg)'
- en: Figure 19.1 – A default jOOQ log for a SELECT execution
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1 – 默认jOOQ SELECT执行日志
- en: This figure reveals a few important aspects of jOOQ logging. First of all, the
    jOOQ logger is named `org.jooq.tools.LoggerListener` and represents an implementation
    of the `ExecuteListener` SPI presented in [*Chapter 18*](B16833_18.xhtml#_idTextAnchor338),
    *jOOQ SPI (Providers and Listeners)*. Under the hood, `LoggerListener` uses an
    internal abstraction (`org.jooq.tools.JooqLogger`) that attempts to interact with
    any of the famous loggers, sl4j, log4j, or the Java Logging API (`java.util.logging`).
    So, if your application uses any of these loggers, jOOQ hooks into it and uses
    it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此图揭示了jOOQ日志记录的一些重要方面。首先，jOOQ记录器命名为`org.jooq.tools.LoggerListener`，代表在[*第18章*](B16833_18.xhtml#_idTextAnchor338)，*jOOQ
    SPI（提供者和监听器）*中介绍的`ExecuteListener` SPI的实现。在底层，`LoggerListener`使用一个内部抽象（`org.jooq.tools.JooqLogger`），尝试与任何著名的记录器，sl4j，log4j，或Java日志API（`java.util.logging`）交互。因此，如果你的应用程序使用这些记录器中的任何一个，jOOQ会将其挂钩并使用它。
- en: As you can see in this figure, jOOQ logs the query SQL string when the `renderEnd()`
    callback is invoked, and the fetched result set when the `resultEnd()` callback
    is invoked. Nevertheless, the jOOQ methods that rely on lazy (sequential) access
    to the underlying JDBC `ResultSet` (so, methods that uses `Iterator` of the `Cursor`–
    for instance, `ResultQuery.fetchStream()` and `ResultQuery.collect()`) don't pass
    through `resultStart()` and `resultEnd()`. In such cases, only the first five
    records from `ResultSet` are buffered by jOOQ and are available for logging in
    `fetchEnd()` via `ExecuteContext.data("org.jooq.tools.LoggerListener.BUFFER")`.
    The rest of the records are either lost or skipped.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，当调用`renderEnd()`回调时，jOOQ记录查询SQL字符串，当调用`resultEnd()`回调时，记录获取的结果集。然而，依赖于对底层JDBC
    `ResultSet`的懒（顺序）访问的jOOQ方法（即使用`Cursor`的`Iterator`的方法 – 例如，`ResultQuery.fetchStream()`和`ResultQuery.collect()`）不会通过`resultStart()`和`resultEnd()`。在这种情况下，只有`ResultSet`的前五条记录被jOOQ缓冲，并且可以通过`fetchEnd()`中的`ExecuteContext.data("org.jooq.tools.LoggerListener.BUFFER")`进行日志记录。其余的记录要么丢失，要么被跳过。
- en: If we execute a routine or the query is a DML, then other callbacks are involved
    as well. Are you curious to find out more?! Then you'll enjoy studying the `LoggerListener`
    source code by yourself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行一个常规过程或查询是DML，那么还会涉及其他回调。你好奇想了解更多吗？！那么，你自己研究`LoggerListener`源代码会很有趣。
- en: jOOQ logging in Spring Boot – default zero-configuration logging
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jOOQ在Spring Boot中的日志记录 – 默认零配置日志
- en: In Spring Boot 2.x, without providing any explicit logging configurations, we
    see logs printed in the console at the `INFO` level. This is happening because
    the Spring Boot default logging functionality uses the popular Logback logging
    framework.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot 2.x中，不提供任何明确的日志配置，我们在控制台看到的是`INFO`级别的日志。这是因为Spring Boot默认的日志功能使用流行的Logback日志框架。
- en: Mainly, the Spring Boot logger is determined by the `spring-boot-starter-logging`
    artifact that (based on the provided configuration or auto-configuration) activates
    any of the supported logging providers (`java.util.logging`, log4j2, and Logback).
    This artifact can be imported explicitly or transitively (for instance, as a dependency
    of `spring-boot-starter-web`).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，Spring Boot 日志记录器由 `spring-boot-starter-logging` 依赖项确定，该依赖项（基于提供的配置或自动配置）激活了支持的任何日志提供程序（`java.util.logging`、log4j2
    和 Logback`）。此依赖项可以显式或间接地导入（例如，作为 `spring-boot-starter-web` 的依赖项）。
- en: 'In this context, having a Spring Boot application with no explicit logging
    configurations will not log jOOQ messages. However, we can take advantage of jOOQ
    logging if we simply enable the `DEBUG` level (or `TRACE` for more verbose logging).
    For instance, we can do it in the `application.properties` as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，如果你有一个没有明确日志配置的 Spring Boot 应用程序，则不会记录 jOOQ 消息。然而，如果我们简单地启用 `DEBUG` 级别（或
    `TRACE` 以实现更详细的日志记录），我们可以利用 jOOQ 日志记录。例如，我们可以在 `application.properties` 中这样做：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can practice this example in *SimpleLogging* for MySQL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *SimpleLogging*（MySQL）中练习这个示例。
- en: jOOQ logging with Logback/log4j2
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jOOQ 与 Logback/log4j2 的日志记录
- en: 'If you already have Logback configured (for instance, via `logback-spring.xml`),
    then you''ll need to add the jOOQ logger, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经配置了 Logback（例如，通过 `logback-spring.xml`），那么你需要添加 jOOQ 日志记录器，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can practice this example in *Logback* for MySQL. If you prefer log4j2,
    then consider the *Log4j2* application for MySQL. The jOOQ logger is configured
    in `log4j2.xml`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *Logback*（MySQL）中练习这个示例。如果你更喜欢 log4j2，那么可以考虑 *Log4j2* 应用程序（MySQL）。jOOQ
    日志记录器在 `log4j2.xml` 中配置。
- en: Turn off jOOQ logging
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭 jOOQ 日志记录
- en: 'Turning on/off jOOQ logging can be done via the `set`/`withExecuteLogging()`
    setting. For instance, the following query will not be logged:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `set`/`withExecuteLogging()` 设置可以开启/关闭 jOOQ 日志记录。例如，以下查询将不会被记录：
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can practice this example in *TurnOffLogging* for MySQL. Note that this
    setting doesn''t affect the jOOQ Code Generator logging. That logging is configured
    with `<logging>LEVEL</logging>` (Maven), `logging = ''LEVEL''` (Gradle), or `.withLogging(Logging.LEVEL)`
    (programmatically). `LEVEL` can be any of `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`,
    and `FATAL`. Here is the Maven approach for setting the `WARN` level – log everything
    that is bigger or equal to the `WARN` level:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *TurnOffLogging*（MySQL）中练习这个示例。请注意，此设置不会影响 jOOQ 代码生成器的日志记录。该日志记录是通过 `<logging>LEVEL</logging>`（Maven）、`logging
    = 'LEVEL'`（Gradle）或 `.withLogging(Logging.LEVEL)`（程序化）配置的。`LEVEL` 可以是 `TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`
    和 `FATAL` 中的任何一个。以下是通过 Maven 设置 `WARN` 级别的示例——记录所有大于或等于 `WARN` 级别的日志：
- en: '[PRE21]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can practice this example in *GenCodeLogging* for MySQL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *GenCodeLogging*（MySQL）中练习这个示例。
- en: In the second part of this section, let's tackle a suite of examples that should
    help you to get familiar with different techniques of customizing jOOQ logging.
    Based on these examples, you should be capable of solving your scenarios. Since
    these are just examples, they won't cover all possible cases, which is worth remembering
    in your real scenarios.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第二部分，我们将处理一系列示例，这些示例应该帮助你熟悉自定义 jOOQ 日志记录的不同技术。基于这些示例，你应该能够解决你的场景。由于这些只是示例，它们不会涵盖所有可能的案例，这在你的实际场景中值得记住。
- en: Customizing result set logging
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义结果集日志记录
- en: 'By default, jOOQ truncates the logged result set to five records. However,
    we can easily log the entire result set via `format(int size)`, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，jOOQ 会截断记录的日志结果集为五条记录。然而，我们可以通过 `format(int size)` 容易地记录整个结果集，如下所示：
- en: '[PRE24]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'How about logging the whole result set for every query (excluding queries that
    rely on lazy, sequential access to an underlying JDBC `ResultSet`)? Moreover,
    let''s assume that we plan to log the row number, as shown in the following figure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个查询（不包括依赖于对底层 JDBC `ResultSet` 的懒加载、顺序访问的查询），是否考虑记录整个结果集呢？此外，假设我们计划记录行号，如下图所示：
- en: '![Figure 19.2 – Customizing result set logging'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.2 – 自定义结果集日志记录'
- en: '](img/Figure_19.2.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_19.2.jpg)'
- en: Figure 19.2 – Customizing result set logging
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.2 – 自定义结果集日志记录
- en: 'One approach for accomplishing this consists of writing a custom logger as
    `ExecuteListener` and overriding the `resultEnd()` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法是在 `ExecuteListener` 中编写自定义日志记录器，并重写 `resultEnd()` 方法：
- en: '[PRE30]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can practice this example in *LogAllRS* for MySQL.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *LogAllRS*（MySQL）中练习这个示例。
- en: Customizing binding parameters logging
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义绑定参数日志记录
- en: 'If we switch the logging level to `TRACE` (`logging.level.root=TRACE`), then
    we get more verbose jOOQ logging. For instance, the bind parameters are logged
    as a separate list, as shown in this example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将日志级别切换到 `TRACE` (`logging.level.root=TRACE`)，那么我们将得到更详细的 jOOQ 日志。例如，绑定参数作为单独的列表进行记录，如下例所示：
- en: '[PRE48]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Challenge yourself to customize this list to look different and to be logged
    at `DEBUG` level. You can find some inspiration in *LogBind* for MySQL, which
    logs bindings like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己将此列表定制以呈现不同的外观，并记录在 `DEBUG` 级别。你可以在 *LogBind* for MySQL 中找到一些灵感，它记录了如下绑定：
- en: '[PRE51]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How about log bindings as a nice formatted table? I'm looking forward to seeing
    your code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志绑定作为一个格式良好的表格如何？我期待看到你的代码。
- en: Customizing logging invocation order
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义日志调用顺序
- en: 'Let''s assume that we plan to enrich jOOQ logging to log a chart, as shown
    here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们计划丰富 jOOQ 日志以记录图表，如下所示：
- en: '![Figure 19.3 – Logging a chart'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.3 – 记录图表'
- en: '](img/Figure_19.3.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.3.jpg)'
- en: Figure 19.3 – Logging a chart
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.3 – 记录图表
- en: This chart is logged only for `SELECT` statements that contain `PRODUCT.PRODUCT_ID`
    (represented on the X axis of the chart – category) and `PRODUCT.BUY_PRICE` (represented
    on the Y axis of the chart – value). Moreover, we don't take into account the
    queries that rely on lazy sequential access to the underlying JDBC `ResultSet`,
    such as `ctx.selectFrom(PRODUCT).collect(Collectors.toList());`. In such cases,
    jOOQ buffers for logging only the first five records, so, in most of the cases,
    the chart will be irrelevant.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表仅记录包含 `PRODUCT.PRODUCT_ID`（在图表的 X 轴上表示 – 类别）和 `PRODUCT.BUY_PRICE`（在图表的 Y
    轴上表示 – 值）的 `SELECT` 语句。此外，我们不考虑依赖于底层 JDBC `ResultSet` 的懒加载顺序访问的查询，例如 `ctx.selectFrom(PRODUCT).collect(Collectors.toList());`。在这种情况下，jOOQ
    仅缓冲记录前五条记录以进行日志记录，因此，在大多数情况下，图表将是不相关的。
- en: 'The first step consists of writing a custom `ExecuteListener` (our own logger)
    and overriding the `resultEnd()` method – called after fetching a set of records
    from `ResultSet`. In this method, we search for `PRODUCT.PRODUCT_ID` and `PRODUCT.BUY_PRICE`,
    and if we find them, then we use the jOOQ `ChartFormat` API, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写一个自定义的 `ExecuteListener`（我们的日志记录器）并重写 `resultEnd()` 方法——在从 `ResultSet`
    获取一组记录之后调用。在这个方法中，我们搜索 `PRODUCT.PRODUCT_ID` 和 `PRODUCT.BUY_PRICE`，如果我们找到它们，那么我们使用
    jOOQ 的 `ChartFormat` API，如下所示：
- en: '[PRE54]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'There is one more thing that we need. At this moment, our `resultEnd()` is
    invoked after the jOOQ''s `LoggerListener.resultEnd()` is invoked, which means
    that our chart is logged after the result set. However, if you look at the previous
    figure, you can see that our chart is logged before the result set. This can be
    accomplished by reversing the order of invocation for the `fooEnd()` methods:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一件事。目前，我们的 `resultEnd()` 在 jOOQ 的 `LoggerListener.resultEnd()` 被调用之后被调用，这意味着我们的图表是在结果集之后被记录的。然而，如果你看之前的图，你可以看到我们的图表是在结果集之前被记录的。这可以通过反转
    `fooEnd()` 方法的调用顺序来实现：
- en: '[PRE79]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'So, by default, as long as the jOOQ logger is enabled, our loggers (the overridden
    `fooStart()` and `fooEnd()` methods) are invoked after their counterparts from
    the default logger (`LoggingLogger`). But, we can reverse the default order via
    two settings: `withExecuteListenerStartInvocationOrder()` for `fooStart()` methods
    and `withExecuteListenerEndInvocationOrder()` for `fooEnd()` methods. In our case,
    after reversion, our `resultEnd()` is called before `LoggingLogger.resultEnd()`,
    and this is how we slipped our chart in the proper place. You can practice this
    example in *ReverseLog* for MySQL.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，默认情况下，只要 jOOQ 日志记录器被启用，我们的日志记录器（重写的 `fooStart()` 和 `fooEnd()` 方法）将在默认日志记录器的对应方法之后被调用（`LoggingLogger`）。但是，我们可以通过两个设置来反转默认顺序：`withExecuteListenerStartInvocationOrder()`
    用于 `fooStart()` 方法，`withExecuteListenerEndInvocationOrder()` 用于 `fooEnd()` 方法。在我们的情况下，在反转之后，我们的
    `resultEnd()` 在 `LoggingLogger.resultEnd()` 被调用之前被调用，这就是我们如何将图表插入正确位置的方法。你可以在
    *ReverseLog* for MySQL 中练习这个示例。
- en: Wrapping jOOQ logging into custom text
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 jOOQ 日志包装到自定义文本中
- en: 'Let''s assume that we plan to wrap each query/routine default logging into
    some custom text, as shown in the following figure:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们计划将每个查询/例程的默认日志记录包装到一些自定义文本中，如下图所示：
- en: '![Figure 19.4 – Wrapping jOOQ logging into custom text'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.4 – 将 jOOQ 日志包装到自定义文本中'
- en: '](img/Figure_19.4.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.4.jpg)'
- en: Figure 19.4 – Wrapping jOOQ logging into custom text
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.4 – 将 jOOQ 日志包装到自定义文本中
- en: Before checking a potential solution in *WrapLog* for MySQL, consider challenging
    yourself to solve it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 *WrapLog* for MySQL 中的潜在解决方案之前，考虑挑战自己解决这个问题。
- en: Filtering jOOQ logging
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤 jOOQ 日志
- en: Sometimes, we want to be very selective with what's being logged. For instance,
    let's assume that only the SQL strings for the `INSERT` and `DELETE` statements
    should be logged. So, after we turn off the jOOQ default logger, we set up our
    logger, which should be capable of isolating the `INSERT` and `DELETE` statements
    from the rest of the queries. A simple approach consists of applying a simple
    check, such as (`query instanceof Insert || query instanceof Delete`), where `query`
    is given by `ExecuteContext.query()`. However, this will not work in the case
    of plain SQL or batches containing the `INSERT` and `DELETE` statements. Specifically
    for such cases, we can apply a regular expression, such as "`^(?i:(INSERT|DELETE).*)$`",
    to the SQL string(s) returned via `ExecuteContext` passed in `renderEnd()`. While
    you can find these words materialized in code lines in *FilterLog* for MySQL,
    let's focus on another scenario.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望对记录的内容非常挑剔。例如，假设只有`INSERT`和`DELETE`语句的SQL字符串应该被记录。因此，在我们关闭jOOQ默认记录器后，我们设置我们的记录器，它应该能够隔离`INSERT`和`DELETE`语句与其他查询。一个简单的方法是应用一个简单的检查，例如（`query
    instanceof Insert || query instanceof Delete`），其中`query`由`ExecuteContext.query()`提供。然而，在纯SQL或包含`INSERT`和`DELETE`语句的批处理的情况下，这不会起作用。具体到这些情况，我们可以对通过`ExecuteContext`传递给`renderEnd()`的SQL字符串应用正则表达式，例如"`^(?i:(INSERT|DELETE).*)$`"。虽然你可以在*FilterLog*的MySQL代码行中找到这些词的具体实现，但让我们关注另一个场景。
- en: 'Let''s assume that we plan to log only regular `SELECT`, `INSERT`, `UPDATE`,
    and `DELETE` statements that contain a suite of given tables (plain SQL, batches,
    and routines are not logged at all). For instance, we can conveniently pass the
    desired tables via `data()` as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们计划只记录包含一组给定表的常规`SELECT`、`INSERT`、`UPDATE`和`DELETE`语句（纯SQL、批处理和例程完全不记录）。例如，我们可以方便地通过`data()`传递所需的表，如下所示：
- en: '[PRE82]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'So, if a query refers to the `EMPLOYEE` and `SALE` tables, then, and only then,
    should it be logged. This time, relying on regular expressions can be a little
    bit sophisticated and risky. It would be more proper to rely on a `VisitListener`
    that allows us to inspect the AST and extract the referred tables of the current
    query with a robust approach. Every `QueryPart` passes through `VisitListener`,
    so we can inspect its type and collect it accordingly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个查询引用了`EMPLOYEE`和`SALE`表，那么只有在这种情况下，它才应该被记录。这次，依赖于正则表达式可能会有些复杂和冒险。更合适的是依赖于一个`VisitListener`，它允许我们以稳健的方式检查AST并提取当前查询的引用表。每个`QueryPart`都会通过`VisitListener`，因此我们可以检查其类型并相应地收集：
- en: '[PRE84]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: When `VisitListener` finishes its execution, we have already traversed all `QueryPart`,
    and we've collected all the tables involved in the current query, so we can compare
    these tables with the given tables and decide whether or not to log the current
    query. Note that our `VisitListener` has been declared as `private static class`
    because we use it internally in our `ExecuteListener` (our logger), which orchestrates
    the logging process. More precisely, at the proper moment, we append this `VisitListener`
    to a configuration derived from the configuration of `ExecuteContext`, passed
    to our `ExecuteListener`. So, this `VisitListener` is not appended to the configuration
    of `DSLContext` that is used to execute the query.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当`VisitListener`完成其执行时，我们已遍历所有`QueryPart`，并且收集了当前查询中涉及的所有表，因此我们可以将这些表与给定的表进行比较，并决定是否记录当前查询。请注意，我们的`VisitListener`已被声明为`private
    static class`，因为我们将其内部用于我们的`ExecuteListener`（我们的记录器），它负责协调记录过程。更确切地说，在适当的时刻，我们将这个`VisitListener`添加到从`ExecuteContext`配置派生出来的配置中，该配置传递给我们的`ExecuteListener`。因此，这个`VisitListener`并没有添加到用于执行查询的`DSLContext`配置中。
- en: 'The relevant part of our logger (`ExecuteListener`) is listed here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录器（`ExecuteListener`）的相关部分如下所示：
- en: '[PRE97]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Check out the highlighted code. The `deriveAppending()` method creates a derived
    `Configuration` from this one (by "this one", we understand `Configuration` of
    the current `ExecuteContext`, which was automatically derived from the `Configuration`
    of `DSLContext`), with appended visit listeners. Practically, this `VisitListener`
    is inserted into `Configuration` through `VisitListenerProvider`, which is responsible
    for creating a new listener instance for every rendering life cycle.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 查看高亮代码。`deriveAppending()`方法从这个配置（通过“这个配置”，我们理解是当前`ExecuteContext`的配置，它是自动从`DSLContext`的配置派生出来的）创建一个派生`Configuration`，并附加了访问监听器。实际上，这个`VisitListener`是通过`VisitListenerProvider`插入到`Configuration`中的，`VisitListenerProvider`负责为每个渲染生命周期创建一个新的监听器实例。
- en: However, what's the point of this? In short, it is all about performance and
    scopes (`org.jooq.Scope`). `VisitListener` is intensively called; therefore, it
    can have some impact on rendering performance. So, in order to minimize its usage,
    we ensure that it is used only in the proper conditions from our logger. In addition,
    `VisitListener` should store the list of tables that are being rendered in some
    place accessible to our logger. Since we choose to rely on the `data()` map, we
    have to ensure that the logger and `VisitListener` have access to it. By appending
    `VisitListener` to the logger via `deriveAppending()`, we append its `Scope` as
    well, so the `data()` map is accessible from both. This way, we can share custom
    data between the logger and `VisitContext` for the entire lifetime of the scope.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这有什么意义呢？简而言之，这全部关乎性能和作用域（`org.jooq.Scope`）。`VisitListener`被频繁调用；因此，它可能会对渲染性能产生影响。所以，为了最小化其使用，我们确保它只在我们日志记录器的适当条件下使用。此外，`VisitListener`应将正在渲染的表列表存储在日志记录器可访问的地方。由于我们选择依赖于`data()`映射，我们必须确保日志记录器和`VisitListener`可以访问它。通过通过`deriveAppending()`将`VisitListener`附加到日志记录器，我们也附加了它的`Scope`，这样`data()`映射就可以从两个地方访问。这样，我们可以在作用域的整个生命周期内，在日志记录器和`VisitContext`之间共享自定义数据。
- en: You can practice this example in *FilterVisitLog* for MySQL. Well, that's all
    about logging. Next, let's talk about testing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*FilterVisitLog*（用于MySQL）中练习这个示例。好吧，这就是关于日志的全部内容。接下来，让我们谈谈测试。
- en: jOOQ testing
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ测试
- en: Accomplishing jOOQ testing can be done in several ways, but we can immediately
    highlight that the less appealing option relies on mocking the jOOQ API, while
    the best option relies on writing integration tests against the production database
    (or at least against an in-memory database). Let's start with the option that
    fits well only in simple cases, mocking the jOOQ API.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 完成jOOQ测试可以通过几种方式，但我们可以立即强调，不那么吸引人的选项依赖于模拟jOOQ API，而最佳选项依赖于编写针对生产数据库（或至少是内存数据库）的集成测试。让我们从仅适用于简单情况的选项开始，即模拟jOOQ
    API。
- en: Mocking the jOOQ API
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟jOOQ API
- en: 'While mocking the JDBC API can be really difficult, jOOQ solves this chore
    and exposes a simple mock API via `org.jooq.tools.jdbc`. The climax of this API
    is represented by the `MockConnection` (for mocking a database connection) and
    `MockDataProvider` (for mocking query executions). Assuming that jUnit 5 is used,
    we can mock a connection like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模拟JDBC API可能非常困难，但jOOQ解决了这个难题，并通过`org.jooq.tools.jdbc`暴露了一个简单的模拟API。这个API的巅峰代表是`MockConnection`（用于模拟数据库连接）和`MockDataProvider`（用于模拟查询执行）。假设使用jUnit
    5，我们可以这样模拟一个连接：
- en: '[PRE112]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Before writing tests, we have to prepare `ClassicmodelsMockProvider` as an
    implementation of `MockDataProvider` that overrides the `execute()` method. This
    method returns an array of `MockResult` (each `MockResult` represents a mock result).
    A possible implementation may look as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试之前，我们必须将`ClassicmodelsMockProvider`准备为`MockDataProvider`的实现，它覆盖了`execute()`方法。此方法返回一个`MockResult`数组（每个`MockResult`代表一个模拟结果）。一个可能的实现可能如下所示：
- en: '[PRE128]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now, we are ready to go! First, we can write a test. Here is an example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备出发！首先，我们可以编写一个测试。以下是一个示例：
- en: '[PRE152]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The code that mocks this behavior is added in `ClassicmodelsMockProvider`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟此行为的代码添加在`ClassicmodelsMockProvider`中：
- en: '[PRE165]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The first argument of the `MockResult` constructor represents the number of
    affected rows, and -`1` represents that the row count not being applicable. In
    the bundled code (*Mock* for MySQL), you can see more examples, including testing
    batching, fetching many results, and deciding the result based on the bindings.
    However, do not forget that jOOQ testing is equivalent to testing the database
    interaction, so mocking is proper only for simple cases. Do not use it for transactions,
    locking, or testing your entire database!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockResult`构造函数的第一个参数代表受影响的行数，其中`-1`表示行数不适用。在捆绑的代码（*Mock* 用于 MySQL）中，你可以看到更多示例，包括测试批处理、获取多个结果以及根据绑定决定结果。然而，不要忘记jOOQ测试等同于测试数据库交互，因此模拟仅适用于简单情况。不要用它来测试事务、锁定或测试整个数据库！'
- en: 'If you don''t believe me, then follow Lukas Eder''s statement: *"The fact that
    mocking only fits well in a few cases can''t be stressed enough. People will still
    attempt to use this SPI, because it looks so easy to do, not thinking about the
    fact that they''re about to implement a full-fledged DBMS in the poorest of ways.
    I''ve had numerous users to whom I''ve explained this 3-4x: ''You''re about to
    implement a full-fledged DBMS" and they keep asking me: "Why doesn''t jOOQ ''just''
    execute this query when I mock it?" – "Well jOOQ *isn''t* a DBMS, but it allows
    you to pretend you can write one, using the mocking SPI."* *And they keep asking
    again and again. Hard to imagine what''s tricky about this, but as much as it
    helps with SEO (people want to solve this problem, then discover jOOQ), I regret
    leading some developers down this path... It''s excellent though to test some
    converter and mapping integrations within jOOQ."*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不相信我，那么请遵循 Lukas Eder 的声明：“仅在某些情况下，模拟方法才适用，这一点不容忽视。人们仍然会尝试使用这个 SPI，因为它看起来很容易实现，而没有考虑到他们即将以最糟糕的方式实现一个完整的
    DBMS。我向许多用户解释过这一点 3-4 次：‘你即将实现一个完整的 DBMS’而他们不断问我：‘为什么 jOOQ ‘只是’ 在模拟时执行这个查询？’ –
    ‘嗯，jOOQ ‘不是’ 一个 DBMS，但它允许你假装你可以使用模拟 SPI 来编写一个。’ *他们一次又一次地继续问。很难想象这有什么棘手的地方，但尽管它有助于
    SEO（人们想要解决这个问题，然后发现 jOOQ），我仍然为一些开发者走上了这条道路……尽管如此，在 jOOQ 中测试一些转换和映射集成是非常好的。”*
- en: Writing integration tests
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: 'A quick approach for writing integration tests for jOOQ relies on simply creating
    `DSLContext` for the production database. Here is an example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为 jOOQ 编写集成测试的快速方法就是简单地为生产数据库创建 `DSLContext`。以下是一个示例：
- en: '[PRE176]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: However, this approach (exemplified in *SimpleTest* for MySQL) fits well for
    simple scenarios that don't require dealing with transaction management (begin,
    commit, and rollback). For instance, if you just need to test your `SELECT` statements,
    then most probably this approach is all you need.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法（以 MySQL 的 *SimpleTest* 为例）非常适合简单场景，这些场景不需要处理事务管理（开始、提交和回滚）。例如，如果您只需要测试您的
    `SELECT` 语句，那么这种方法可能就是您所需要的全部。
- en: Using SpringBoot @JooqTest
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SpringBoot @JooqTest
- en: 'On the other hand, it''s a common scenario to run each integration test in
    a separate transaction that rolls back in the end, and to achieve this while testing
    jOOQ in Spring Boot, you can use the `@JooqTest` annotation, as shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在 Spring Boot 中测试 jOOQ 时，通常需要在单独的事务中运行每个集成测试，并在最后回滚，要实现这一点，您可以使用 `@JooqTest`
    注解，如下所示：
- en: '[PRE186]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: This time, Spring Boot automatically creates `DSLContext` for the current profile
    (of course, using explicit profiles is optional, but I added it here, since it
    is a common practice in Spring Boot applications) and automatically wraps each
    test in a separate Spring transaction that is rolled back at the end. In this
    context, if you prefer to use jOOQ transactions for certain tests, then don't
    forget to disable Spring transaction by annotating those test methods with `@Transactional(propagation=Propagation.NEVER)`.
    The same is true for the usage of `TransactionTemplate`. You can practice this
    example in *JooqTest* for MySQL, which contains several tests, including jOOQ
    optimistic locking via `TransactionTemplate` and via jOOQ transactions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，Spring Boot 自动为当前配置文件（当然，使用显式配置文件是可选的，但我在这里添加了它，因为这是 Spring Boot 应用程序中的常见做法）创建
    `DSLContext`，并且自动将每个测试包裹在一个单独的 Spring 事务中，该事务在结束时回滚。在这种情况下，如果您希望某些测试使用 jOOQ 事务，那么请务必通过使用
    `@Transactional(propagation=Propagation.NEVER)` 注解这些测试方法来禁用 Spring 事务。对于 `TransactionTemplate`
    的使用也是如此。您可以在包含多个测试的 *JooqTest* MySQL 示例中练习这个例子，包括通过 `TransactionTemplate` 和 jOOQ
    事务实现的 jOOQ 乐观锁定。
- en: By using Spring Boot profiles, you can easily configure a separate database
    for tests that is (or not) identical to the production database. In *JooqTestDb*,
    you have the MySQL `classicmodels` database for production and the MySQL `classicmodels_test`
    database for testing (both of them have the same schema and data and are managed
    by Flyway).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Spring Boot 配置文件，您可以轻松地为测试配置一个与生产数据库（或不是）相同的单独数据库。在 *JooqTestDb* 中，您有用于生产的
    MySQL `classicmodels` 数据库和用于测试的 MySQL `classicmodels_test` 数据库（它们都具有相同的模式和数据，并由
    Flyway 管理）。
- en: 'Moreover, if you prefer an in-memory database that is destroyed at the end
    of testing, then in *JooqTestInMem* for MySQL, you have the on-disk MySQL `classicmodels`
    database for production and the in-memory H2 `classicmodels_mem_test` database
    for testing (both of them have the same schema and data and are managed by Flyway).
    In these two applications, after you inject the `DSLContext` prepared by Spring
    Boot, you have to point jOOQ to the test schema – for instance, for the in-memory
    database, as shown here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你更喜欢在测试结束时被销毁的内存数据库，那么在 *JooqTestInMem*（MySQL）中，你有一个用于生产的磁盘上的 MySQL `classicmodels`
    数据库和一个用于测试的内存 H2 `classicmodels_mem_test` 数据库（它们都具有相同的模式和数据，并由 Flyway 管理）。在这两个应用程序中，在你注入由
    Spring Boot 准备的 `DSLContext` 之后，你必须将 jOOQ 指向测试模式 - 例如，对于内存数据库，如下所示：
- en: '[PRE197]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: You should be familiar with this technique from [*Chapter 17*](B16833_17.xhtml#_idTextAnchor330),
    *Multitenancy in jOOQ*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉来自 [*第 17 章*](B16833_17.xhtml#_idTextAnchor330)，*jOOQ 中的多租户* 的这项技术。
- en: Using Testcontainers
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Testcontainers
- en: Testcontainers ([https://www.testcontainers.org/](https://www.testcontainers.org/))
    is a Java library that allows us to perform JUnit tests in lightweight Docker
    containers, created and destroyed automatically for the most common databases.
    So, in order to use Testcontainers, you have to install Docker.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Testcontainers ([https://www.testcontainers.org/](https://www.testcontainers.org/))
    是一个 Java 库，它允许我们在轻量级 Docker 容器中执行 JUnit 测试，这些容器会自动创建和销毁，用于最常见的数据库。因此，为了使用 Testcontainers，你必须安装
    Docker。
- en: 'Once you''ve installed Docker and provided the expected dependencies in your
    Spring Boot application, you can start a container and run some tests. Here, I''ve
    done it for MySQL:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 Docker 并在你的 Spring Boot 应用程序中提供了预期的依赖项，你就可以启动一个容器并运行一些测试。这里，我已为 MySQL
    执行了此操作：
- en: '[PRE219]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Note that we''ve populated the test database via Flyway, but this is not mandatory.
    You can use any other dedicated utility, such as Commons DbUtils. For instance,
    you can do it via `org.testcontainers.ext.ScriptUtils`, like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经通过 Flyway 填充了测试数据库，但这不是强制性的。你可以使用任何其他专用工具，例如 Commons DbUtils。例如，你可以通过
    `org.testcontainers.ext.ScriptUtils` 来实现，如下所示：
- en: '[PRE260]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: That's it! Now, you can spin out a throwaway container for testing database
    interaction. Most probably, this is the most preferable approach for testing jOOQ
    applications in production. You can practice this example in *Testcontainers*
    for MySQL.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，你可以为测试数据库交互生成一个一次性容器。这很可能是测试生产中 jOOQ 应用程序的最受欢迎的方法。你可以在 *Testcontainers*（MySQL）中实践这个例子。
- en: Testing R2DBC
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 R2DBC
- en: Finally, if you are using jOOQ R2DBC, then writing tests is quite straightforward.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你正在使用 jOOQ R2DBC，那么编写测试相当直接。
- en: 'In the bundled code, you can find three examples for MySQL, as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到三个 MySQL 的示例，如下所示：
- en: 'The *TestR2DBC* example: `ConnectionFactory` is created via `ConnectionFactories.get()`
    and `DSLContext` via `ctx = DSL.using(connectionFactory)`. The tests are executed
    against a production database.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TestR2DBC* 示例：`ConnectionFactory` 通过 `ConnectionFactories.get()` 创建，`DSLContext`
    通过 `ctx = DSL.using(connectionFactory)` 创建。测试是在生产数据库上执行的。'
- en: 'The *TestR2DBCDb* example: `ConnectionFactory` is automatically created by
    Spring Boot and `DSLContext` is created as `@Bean`. The tests are executed against
    a MySQL test database (`classicmodels_test`), similar to the production one (`classicmodels`).'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TestR2DBCDb* 示例：`ConnectionFactory` 由 Spring Boot 自动创建，`DSLContext` 作为 `@Bean`
    创建。测试是在与生产类似（`classicmodels`）的 MySQL 测试数据库（`classicmodels_test`）上执行的。'
- en: 'The *TestR2DBCInMem* example: `ConnectionFactory` is automatically created
    by Spring Boot and `DSLContext` is created as `@Bean`. The tests are executed
    against an H2 in-memory test database (`classicmodels_mem_test`).'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TestR2DBCInMem* 示例：`ConnectionFactory` 由 Spring Boot 自动创建，`DSLContext` 作为
    `@Bean` 创建。测试是在 H2 内存测试数据库（`classicmodels_mem_test`）上执行的。'
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you just saw, jOOQ has solid support for logging and testing, proving yet
    again that it is a mature technology ready to meet the most demanding expectations
    of a production environment. With a high rate of productivity and a small learning
    curve, jOOQ is the first choice that I use and recommend for projects. I strongly
    encourage you to do the same!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，jOOQ 对日志记录和测试有坚实的支持，再次证明它是一个成熟的技术，能够满足生产环境中最苛刻的期望。凭借高生产率和低学习曲线，jOOQ
    是我首先使用并推荐的项目。我强烈建议你也这样做！
