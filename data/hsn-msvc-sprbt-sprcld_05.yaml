- en: Deploying Our Microservices Using Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 部署我们的微服务。
- en: In this chapter, we will start using Docker and put our microservices into containers!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用 Docker 并将我们的微服务放入容器中！
- en: By the end of this chapter, we will have run fully automated tests of our microservice
    landscape that start all our microservices as Docker containers, requiring no
    other infrastructure than a Docker engine. We will have also run a number of tests
    to verify that the microservices work together as expected and finally shut down
    all the microservices, leaving no traces of the tests we executed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章末尾，我们将运行完全自动化的微服务架构测试，以 Docker 容器的形式启动我们的所有微服务，除了 Docker 引擎之外不需要其他基础架构。我们还将运行一系列测试，以验证微服务按预期一起工作，并在最后关闭所有微服务，不留下我们执行的测试的任何痕迹。
- en: Being able to test a number of cooperating microservices in this way is very
    useful. As developers, we can verify that it works on our local developer machines.
    We can also run exactly the same tests in a build server to automatically verify
    that changes to the source code won't break the tests at a system level. Additionally,
    we don't need to have a dedicated infrastructure allocated to run these types
    of tests. In the upcoming chapters, we will see how we can add databases and queue
    managers to our test landscape, all of which will run as Docker containers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以这种方式测试多个协作的微服务非常有用。作为开发者，我们可以在本地开发机上验证其工作效果。我们还可以在构建服务器上运行完全相同的测试，以自动验证源代码的更改不会在系统层面破坏测试。此外，我们不需要为运行这些类型的测试分配专用的基础架构。在接下来的章节中，我们将了解如何将数据库和队列管理器添加到我们的测试架构中，所有这些都将作为
    Docker 容器运行。
- en: This does not, however, replace the need for automated unit and integrations
    tests, which test individual microservices in isolation. They are as important
    as ever.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不取代自动化单元和集成测试的需要，这些测试孤立地测试单个微服务。它们的重要性与日俱增。
- en: For production usage, as we mentioned earlier in this book, we need a container
    orchestrator such as Kubernetes. We will go back to container orchestrators and
    Kubernetes later in this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产使用，如本书前面提到的，我们需要一个容器编排器，如 Kubernetes。我们将在本书后面回到容器编排器和 Kubernetes。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to Docker.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器简介。
- en: Docker and Java. Java hasn't been very friendly to containers historically,
    but that changed with Java 10\. Let's see how Docker and Java fit together on
    this topic!
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 和 Java。Java 在历史上对容器并不友好，但随着 Java 10 的发布，这一切都改变了。让我们看看 Docker 和 Java 在这个话题上是如何结合在一起的！
- en: Using Docker with one microservice.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 和一个微服务。
- en: Managing a landscape of microservices using Docker Compose.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 管理微服务架构。
- en: Testing them all together automatically.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动测试它们全部。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the commands that are described in this book are run on a MacBook Pro
    using macOS Mojave but should be straightforward to modify if you want to run
    them on another platform such as Linux or Windows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在 MacBook Pro 上使用 macOS Mojave 运行的，但如果你想在其他平台（如 Linux 或 Windows）上运行它们，应该很容易进行修改。
- en: Apart from the technical requirements from the previous chapter, we need to
    have Docker installed. Docker Community Edition can be downloaded from [https://store.docker.com/search?type=edition&offering=community](https://store.docker.com/search?type=edition&offering=community)[.](https://store.docker.com/search?type=edition&offering=community)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前章的技术要求之外，我们还需要安装 Docker。Docker 社区版可以从 [https://store.docker.com/search?type=edition&offering=community](https://store.docker.com/search?type=edition&offering=community)[下载](https://store.docker.com/search?type=edition&offering=community)。
- en: 'To be able to run the examples in this book, it is recommended that you configure
    Docker so that you can use all the CPUs except one (allocating all CPUs to Docker
    can make the computer unresponsive when tests are running) and at least 6 GB of
    memory. This can be configured in the Advanced tab in the Preferences settings
    for Docker, as illustrated by the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中的示例，建议您配置 Docker，使其可以使用除一个以外的所有 CPU（将所有 CPU 分配给 Docker 可能会在测试运行时使计算机失去响应）以及至少
    6 GB 的内存。这可以在 Docker 的“偏好设置”的“高级”选项卡中配置，如下面的屏幕截图所示：
- en: '![](img/5fe1ee81-076f-4652-b550-bd63ba45cc3e.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fe1ee81-076f-4652-b550-bd63ba45cc3e.png)'
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter04).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter04)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，将源代码下载到一个文件夹中，并设置一个环境变量`$BOOK_HOME`，该变量指向该文件夹。一些示例命令如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested to run on Java 12\. This
    chapter uses Spring Boot 2.1.0 (and Spring 5.1.2), the latest available version
    of Spring Boot at the time of writing this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所用的Java源代码是为Java 8编写的，并在Java 12上进行了测试运行。在本章写作时，Spring Boot的最新版本是2.1.0（以及Spring
    5.1.2）。
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter04` but
    in many cases have been edited to remove irrelevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter04`的源代码，但在许多情况下，已经编辑了源代码中不相关部分，例如注释、导入和日志声明。
- en: If you want to see the changes that were applied to the source code in this
    chapter, that is, see what it took to add support for Docker, you can compare
    it with the source code for [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml),
    *Creating a Set of Cooperating Microservices*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter03/2-basic-rest-services` and `$BOOK_HOME/Chapter04`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章应用于源代码中的更改，即了解为Docker添加支持所做的工作，你可以将第3章[创建一组协作的微服务](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)的源代码进行比较，*创建一组协作的微服务*。你可以使用你喜欢的`diff`工具，比较两个文件夹`$BOOK_HOME/Chapter03/2-basic-rest-services`和`$BOOK_HOME/Chapter04`。
- en: Introduction to Docker
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器入门
- en: 'As we already mentioned in [Chapter 2](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml),
    *Introduction to Spring Boot*, Docker made the concept of containers as a lightweight
    alternative to virtual machines very popular in 2013\. Containers are actually
    processed in a Linux host that uses Linux namespaces to provide isolation between
    containers of global system resources, such as users, processes, filesystems,
    and networking. **Linux Control Groups** (also knows as **cgroups**) are used
    to limit the amount of CPU and memory that a container is allowed to consume.
    Compared to a virtual machine that uses a hypervisor to run a complete copy of
    an operating system in each virtual machine, the overhead in a container is a
    fraction of the overhead in a virtual machine. This leads to much faster startup
    times and significantly lower overhead in terms of CPU and memory usage. The isolation
    that''s provided for a container, however, is not considered to be as secure as
    the isolation that''s provided for a virtual machine. With the release of Windows
    Server 2016 and Windows 10 Pro (1607 Anniversary Update), Microsoft supports the
    usage of Docker on Windows as well. Take a look at the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第2章[Spring Boot入门](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml)中提到的，Docker在2013年使容器作为轻量级虚拟机替代品的概念变得非常流行。容器实际上是在使用Linux命名空间的Linux主机上处理的，以提供隔离容器之间全局系统资源的隔离，例如用户、进程、文件系统和网络。**Linux控制组**（也称为**cgroups**）用于限制容器可以消耗的CPU和内存量。与在每台虚拟机中使用虚拟化器运行操作系统完整副本相比，容器的开销只是虚拟机开销的一小部分。这导致了更快的启动时间以及CPU和内存使用上的显著降低。然而，容器提供的隔离被认为不如虚拟机提供的隔离安全。随着Windows
    Server 2016和Windows 10 Pro（1607周年更新）的发布，微软也开始支持在Windows上使用Docker。请看下面的图表：
- en: '![](img/caee1a35-71e9-4b6c-953f-b00a2d6eaca3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/caee1a35-71e9-4b6c-953f-b00a2d6eaca3.png)'
- en: The preceding diagram illustrates the difference between the resource usage
    of virtual machines and containers, visualizing that the same type of server can
    run significantly more containers than virtual machines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图表说明了虚拟机和容器的资源使用差异，可视化同一类型的服务器可以运行远比虚拟机更多的容器。
- en: Running our first Docker commands
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的第一个Docker命令
- en: 'Let''s try to start a container by launching an Ubuntu server in one using
    Docker''s `run` command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '-   让我们尝试通过使用Docker的`run`命令在Docker中启动一个Ubuntu服务器：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the preceding command, we ask Docker to create a container that runs Ubuntu,
    based on the latest version that's available of the official Docker image for
    Ubuntu. The `-it` option is used so that we can interact with the container using
    Terminal, and the `--rm` option tells Docker to remove the container once we exit
    the Terminal session; otherwise, the container will remain in the Docker engine
    with an `Exited` state.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '-   使用前面的命令，我们要求Docker创建一个运行Ubuntu的容器，基于官方Docker镜像中可用的最新版本的Ubuntu。`-it`选项用于使我们能够使用终端与容器交互，`--rm`选项告诉Docker，一旦我们退出终端会话，就删除容器；否则，容器将保留在Docker引擎中，状态为`Exited`。'
- en: The first time we use a Docker image that we haven't built ourselves, Docker
    will download it from a Docker registry, which is Docker Hub by default ([https://hub.docker.com](https://hub.docker.com)).
    This will take some time, but for subsequent usage of that Docker image, the container
    will start in just a few seconds!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '-   第一次使用我们没有自己构建的Docker镜像时，Docker将从Docker注册表中下载它，默认是Docker Hub ([https://hub.docker.com](https://hub.docker.com))。这需要一些时间，但对于该Docker镜像的后续使用，容器将在几秒钟内启动！'
- en: 'Once the Docker image has been downloaded and the container has been started
    up, the Ubuntu server should respond with a prompt such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '-   一旦Docker镜像下载完毕并启动容器，Ubuntu服务器应该会以如下提示响应：'
- en: '![](img/39044aaf-927e-4210-9731-1a3f10fedd10.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39044aaf-927e-4210-9731-1a3f10fedd10.png)'
- en: 'We can try out the container by asking what version of Ubuntu it runs:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '-   我们可以尝试通过询问它运行的是哪个版本的Ubuntu来测试容器：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It should respond with something like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '-   它应该会像下面这样响应：'
- en: '![](img/60a69639-0969-4d0f-ab2c-f8a2582d51eb.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60a69639-0969-4d0f-ab2c-f8a2582d51eb.png)'
- en: We can leave the container with an `exit` command and verify that the Ubuntu
    container no longer exits with the `docker ps -a` command. We need to use the `-a` option
    to see stopped containers; otherwise, only running containers are displayed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '-   我们可以使用`exit`命令离开容器，并验证使用`docker ps -a`命令Ubuntu容器是否不再退出。我们需要使用`-a`选项来查看停止的容器；否则，只显示运行中的容器。'
- en: 'If you favor CentOS over Ubuntu, feel free to try the same with the `docker
    run --rm -it centos` command. Once the CoreOS server has started running in its
    container you can, for example, ask what version of CoreOS that it runs with the `cat
    /etc/redhat-release` command. It should respond with something like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '-   如果你更喜欢CentOS而不是Ubuntu，可以尝试使用`docker run --rm -it centos`命令。一旦CoreOS服务器在其容器中启动运行，你可以，例如，使用`cat
    /etc/redhat-release`命令询问它运行的是哪个版本的CoreOS。它应该会像下面这样响应：'
- en: '![](img/0bc608f2-03e6-40ec-a0b4-d343d9eff2b3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bc608f2-03e6-40ec-a0b4-d343d9eff2b3.png)'
- en: Leave the container with the `exit` command to remove it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '-   使用`exit`命令离开容器以删除它。'
- en: 'If, at some point, you find that you have a lot of unwanted containers in the
    Docker engine and you want to get a clean sheet, that is, get rid of them all,
    you can run the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '-   如果你发现Docker引擎中有许多不想要的容器，并且你想获得一个干净的起点，即摆脱它们全部，你可以运行以下命令：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `docker rm -f` command stops and removes the containers whose container
    IDs are specified to the command. The `docker ps -aq` command lists the container
    IDs of all the running and stopped containers in the Docker engine. The `-q` option
    reduces the output from the `docker ps` command so that it only lists the container
    IDs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '-   `docker rm -f`命令停止并删除指定容器ID的容器。`docker ps -aq`命令列出Docker引擎中所有运行和停止容器的容器ID。`-q`选项减少`docker
    ps`命令的输出，使其只列出容器ID。'
- en: After understanding what Docker is, next we can move on to understand the problems
    which we might face while running Java in Docker.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '-   在了解Docker是什么之后，接下来我们可以理解在Docker中运行Java时可能遇到的问题。'
- en: Challenges with running Java in Docker
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   在Docker中运行Java的挑战'
- en: When it comes to Java, over the past few years, there have been a number of
    attempts to get Java working in Docker in a good way. Currently, the official
    Docker image for Java is based on OpenJDK: [https://hub.docker.com/_/openjdk/](https://hub.docker.com/_/openjdk/).
    We will use Java SE 12 with the Docker tag `openjdk:12.0.2`, that is, Java SE
    v12.0.2.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '-   当谈到Java时，过去几年里，有很多尝试让Java在Docker中良好地运行。目前，Java的官方Docker镜像基于OpenJDK: [https://hub.docker.com/_/openjdk/](https://hub.docker.com/_/openjdk/)。我们将使用带有Docker标签`openjdk:12.0.2`的Java
    SE 12，即Java SE v12.0.2。'
- en: Java has historically not been very good at honoring the quotas specified for
    a Docker container using Linux cgroups; it has simply ignored these settings.
    So, instead of allocating memory inside the JVM in relation to the memory available
    in the container, Java allocated memory as if it had access to all the memory
    in the Docker host, which obviously isn't good! In the same way, Java allocated
    CPU-related resources such as thread pools in relation to the total number of
    available CPU cores in the Docker host instead of the number of CPU cores that
    were made available for the container JVM was running in. In Java SE 9, some initial
    support was provided, which was also back-ported to later versions of Java SE
    8\. In Java 10, however, much-improved support for CPU and memory constraints
    was put in place.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，Java 在尊重 Docker 容器中 Linux cgroups 指定的配额方面做得并不好；它只是简单地忽略了这些设置。因此，Java 并不是在
    JVM 内部根据容器中可用的内存来分配内存，而是好像它能够访问 Docker 主机的所有内存，这显然是不好的！同样，Java 分配与 Docker 主机的总
    CPU 核心数相关的资源，如线程池，而不是为运行的 JVM 分配的 CPU 核心数。在 Java SE 9 中，提供了一些初始支持，这也被反向移植到了 Java
    SE 8 的后续版本中。然而，在 Java 10 中，对 CPU 和内存约束提供了大幅改进的支持。
- en: Let's try it out!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试！
- en: First, we will try out Java commands locally, without Docker, since that tells
    us how much memory and the number of CPU cores that the JVM sees. Next, we will
    try the commands in Docker using Java SE 12 to verify that it honors the constraints
    we set on the Docker container it runs in. Finally, we will also try out a Java
    SE 9 container and see how it fails to honor the constraints and what problems
    it can result in.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将尝试在本地下执行 Java 命令，不使用 Docker，因为这将告诉我们 JVM 看到多少内存和 CPU 核心数。接下来，我们将使用 Java
    SE 12 在 Docker 中尝试这些命令，以验证它是否尊重我们在其中运行的 Docker 容器上设置的约束。最后，我们还将尝试一个 Java SE 9
    容器，并看看它如何不尊重约束以及可能造成什么问题。
- en: Java without Docker
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有 Docker 的 Java
- en: Before we jump in to Docker, let's try the Java commands without Docker to familiarize
    ourselves with the Java commands!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将自己投入到 Docker 之前，让我们不使用 Docker 尝试 Java 命令，以熟悉 Java 命令！
- en: 'Let''s start by finding out how many available processors, that is, CPU cores,
    Java sees when running outside of Docker. We can do this by sending the `Runtime.getRuntime().availableprocessors()` Java
    statement to the Java CLI tool `jshell`, like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先找出 Java 在 Docker 外部运行时看到的有多少可用处理器，即 CPU 核心数。我们可以通过将 `Runtime.getRuntime().availableprocessors()`
    Java 语句发送到 Java CLI 工具 `jshell` 来完成这个操作：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`jshell` requires Java SE 9 or later!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`jshell` 需要 Java SE 9 或更高版本！'
- en: 'On my machine, I get the following response:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我得到以下响应：
- en: '![](img/47ae0858-fb1f-43ec-988a-303e04880a4d.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47ae0858-fb1f-43ec-988a-303e04880a4d.png)'
- en: Okay, `12` cores is as expected, since the processor in my laptop is a six-core Intel
    Core i9 CPU with hyper-threading (the operating system sees two virtual cores
    for each physical core).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`12` 个核心是符合预期的，因为我的笔记本电脑的处理器是六核心的英特尔 Core i9 CPU，具有超线程技术（操作系统为每个物理核心看到两个虚拟核心）。
- en: 'In terms of the amount of available memory, let''s ask the JVM for the maximum
    size that it thinks it can allocate for the heap. We can achieve this by asking
    the JVM for extra runtime information using the `-XX:+PrintFlagsFinal` Java option
    and then using the `grep` command to filter out the `MaxHeapSize` parameter, like
    so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可用的内存量，让我们询问 JVM 它认为可以为其堆分配的最大大小。我们可以通过使用 `-XX:+PrintFlagsFinal` Java 选项向
    JVM 请求额外的运行时信息，然后使用 `grep` 命令过滤出 `MaxHeapSize` 参数来实现这一点：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On my machine, I get the following response:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我得到以下响应：
- en: '![](img/98ea076e-f964-4885-b262-e8020b7b702c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98ea076e-f964-4885-b262-e8020b7b702c.png)'
- en: '`8589934592` bytes happens to be exactly 8 GB, that is, *8 * 1,024^3*. Given
    that we don''t specify any max heap size for the JVM using the `-Xmx` parameter,
    the JVM will set the max value to one quarter of the available memory. Since my laptop
    has 32 GB of memory and *32/4=8*, this is also as expected!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`8589934592` 字节碰巧正好是 8 GB，即 *8 * 1,024^3*。由于我们没有为 JVM 使用 `-Xmx` 参数指定任何最大堆大小，JVM
    将最大值设置为可用内存的四分之一。由于我的笔记本电脑有 32 GB 的内存，*32/4=8*，这也是符合预期的！'
- en: 'Let''s wrap this up by verifying that we can lower the maximum heap size with the `-Xmx` parameter
    to, for example, 200 MB:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过验证能够将最大堆内存大小通过 `-Xmx` 参数降低到例如 200 MB 来总结一下：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The JVM will respond with *209,715,200* bytes, that is, *200 ** *1,024^3* bytes
    = 200 MB, as expected!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 将响应为 *209,715,200* 字节，即 *200 * 1,024^3* 字节 = 200 MB，符合预期！
- en: Now that we have seen how the Java commands work without Docker, let's try this
    with Docker!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了在没有Docker的情况下Java命令是如何工作的，那么让我们试着用Docker来执行这个命令！
- en: Java in Docker
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker中的Java
- en: Let's look at how Java SE 12 responds to limits we set on a container it runs
    in!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Java SE 12如何响应我们在其运行的容器中设置的限制！
- en: Since I'm using Docker for macOS, I'm actually running the Docker engine on
    a virtual machine on my MacBook Pro as the Docker host. I have configured Docker
    for macOS so that it allows the Docker host to use all 12 cores in my macOS but
    only use up to 16 GB of memory. All in all, the Docker host has 12 cores and 16
    GB of memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我使用的是Docker for macOS，实际上我是在我的MacBook Pro上的虚拟机上运行Docker引擎作为Docker宿主。我已经为macOS配置了Docker，使其允许Docker宿主使用我macOS中的所有12个核心，但只使用最多16GB内存。总的来说，Docker宿主有12个核心和16GB内存。
- en: CPU
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU
- en: 'Let''s start by applying no constraints, that is, the same test that we did
    without Docker:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不施加任何限制，也就是说，我们用同样的测试方法，但是不使用Docker：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command will send the `Runtime.getRuntime().availableProcessors()` string
    to the Docker container that will process the string using `jshell`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会将`Runtime.getRuntime().availableProcessors()`字符串发送到Docker容器，该容器将使用`jshell`处理这个字符串。
- en: 'It will respond with the same result, that is, `$1 ==> 12` in my case. Let''s
    move on and restrict the Docker container to only be allowed to use three CPU
    cores using the `--cpus 3` Docker option and ask the JVM about how many available
    processors it sees:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它将响应同样的结果，即在我的情况下为`$1 ==> 12`。让我们继续限制Docker容器只能使用三个CPU核心，使用`--cpus 3` Docker选项，并询问JVM它看到了多少可用的处理器：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The JVM now responds with `$1 ==> 3`, that is, Java SE 12 honors the settings
    in the container and will, therefore, be able to configure CPU-related resources
    such as thread pools correctly!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JVM现在响应为`$1 ==> 3`，即Java SE 12尊重容器中的设置，因此，它能够正确配置与CPU相关的资源，比如线程池！
- en: 'Let''s also try to specify a relative share of the available CPUs instead of
    an exact number of CPUs. 1,024 shares correspond to one core by default, so if
    we want to limit the container to two cores, we set the `--cpu-shares` Docker
    option to 2,048, like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着指定可用的CPU的相对份额，而不是CPU的确切数量。1024个份额默认对应一个核心，所以如果我们想要将容器限制为两个核心，我们将`--cpu-shares`
    Docker选项设置为2048，像这样：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The JVM will respond with `$1 ==> 2`, that is, Java SE 12 honors the relative
    `share` option as well!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将响应`$1 ==> 2`，即Java SE 12也尊重相对`share`选项！
- en: While the `--cpus` option is a hard constraint, the `--cpu-shares` option only
    applies when the Docker host is under high load. This means that a container can
    consume more CPU than what the `share` option indicates whether CPU capacity is
    available.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`--cpus`选项是一个硬性限制，但`--cpu-shares`选项只有在Docker宿主承受高负载时才会生效。这意味着，如果CPU资源可用，容器可以消耗比`share`选项显示的更多的CPU。
- en: Let's try out limiting the amount of memory next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试限制内存量。
- en: Memory
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存
- en: 'With no memory constraints, Docker will allocate one-fourth of the memory to
    the container:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有内存限制，Docker将把内存的四分之一分配给容器：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It will respond with 4,202,692,608 bytes, which equals 4 GB, that is, *8 * 1024^3*.
    Since my Docker host has 16 GB of memory, this is correct, that is, *16/4 = 4*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它将响应4,202,692,608字节，等于4GB，即*8 * 1024^3*。由于我的Docker宿主有16GB内存，这是正确的，即*16/4 = 4*。
- en: 'However, if we constrain the Docker container to only use up to 1 GB of memory
    using the `-m=1024M` Docker option, we will see a lower memory allocation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们限制Docker容器只能使用最多1GB内存，使用`-m=1024M` Docker选项，我们会看到较低的内存分配：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The JVM will respond with 268,435,456 bytes, which equals 256 MB, that is, *2 *
    1024^2* bytes. 256 MB is one-fourth of 1 GB, so again, this is as expected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将响应268,435,456字节，即256MB，也就是*2 * 1024^2*字节。256MB是1GB的四分之一，所以这也在意料之中。
- en: 'We can, as usual, set the max heap size ourselves. For example, if we want
    to allow the heap to use 800 MB of the total 1 GB we have, we can specify that
    using the `-Xmx800m` Java option:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像往常一样，自己设置最大堆大小。例如，如果我们想要允许堆内存使用1GB中的800MB，我们可以使用`-Xmx800m` Java选项指定：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The JVM will respond with 838,860,800 bytes = *800 * 1024^2* bytes = 800 MB,
    as expected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将响应838,860,800字节= *800 * 1024^2*字节= 800MB，如预期一样。
- en: Let's conclude with some out of memory tests to ensure that this really works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过一些内存溢出测试来确保这真的有效。
- en: Let's allocate some memory using `jshell` in a JVM that runs in a container
    that has been given 1 GB of memory; that is, it has a max heap size of 256 MB.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`jshell`在分配了1GB内存的JVM中尝试，也就是说，它的最大堆大小为256MB。
- en: 'First, try to allocate a byte array of 100 MB:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试分配一个100 MB的字节数组：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command will respond with `$1 ==>`, meaning that it worked fine!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将会回应`$1 ==>`，意味着它工作得很好！
- en: Normally, `jshell` will print out the value resulting from the command, but
    100 MB of bytes all set to zero is a bit too much printout, and so we get nothing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`jshell`将打印出命令的结果值，但是100 MB的字节数组全部设置为零输出太多，所以我们什么也没有。
- en: 'Now, let''s try to allocate a byte array that is larger than the max heap size,
    for example, 500 MB:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试分配一个大于最大堆大小的字节数组，例如500 MB：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The JVM sees that it can''t perform the action since it honors the container
    settings of max memory and responds immediately with `Exception java.lang.OutOfMemoryError:
    Java heap space`. Great!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'JVM看到它不能执行该操作，因为它尊重容器的最大内存设置，并立即回应`Exception java.lang.OutOfMemoryError: Java
    heap space`。太好了！'
- en: What would happen in this case if we use a JVM that doesn't honor the container
    settings of max memory?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个不尊重容器设置的最大内存的JVM会怎样？
- en: Let's find out by using Java SE 9!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Java SE 9来找出答案！
- en: Problems with Docker and Java SE 9 (or older)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker和Java SE 9（或更早版本）的问题
- en: First, try out limiting a Java SE 9 JVM to three CPU cores using `openjdk:9-jdk` image.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试使用`openjdk:9-jdk`镜像将Java SE 9 JVM限制在三个CPU核心。
- en: 'Java 9 fails to obey the three-CPU limit:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9无法遵守三个CPU的限制：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It responds with `$1 ==> 12` on my machine, that is, it ignores the limitation
    of three CPU cores.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，它回应为`$1 ==> 12`，也就是说，它忽略了三个CPU核心的限制。
- en: 'We will see the same result, that is, `$1 ==> 12`, if we try out the `--cpu-shares`
    option:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试`--cpu-shares`选项，我们也会得到同样的结果，即`$1 ==> 12`：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s try to limit the memory to 1 GB:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试将内存限制为1 GB：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As expected, Java SE 9 does not honor the memory constraint that we set in Docker;
    that is, it reports a max heap size of 4,202,692,608 bytes = *4 GB – 4 * 1024^3*
    bytes. Here, Java 9 calculated the available memory when given the memory in the
    Docker host, not in the actual container!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期那样，Java SE 9不尊重我们在Docker中设置的内存约束；也就是说，它报告最大堆大小为4,202,692,608字节= *4 GB – 4
    * 1024^3*字节。在这里，Java 9在给定Docker主机的内存时计算了可用的内存，而不是在实际的容器中！
- en: So, what happens if we repeat the memory allocation tests that we did for Java
    SE 12?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们重复对Java SE 12进行的内存分配测试呢？
- en: 'Let''s try out the first test, that is, allocating a 100 MB array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试第一个测试，即分配一个100 MB数组：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The command responds with `$1 ==> byte[100000000] { 0, 0, 0, ...`, so that worked
    fine!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 命令回应为`$1 ==> byte[100000000] { 0, 0, 0, ...`，所以这工作得很好！
- en: 'Now, let''s move on to the really interesting test: what if we allocate a byte
    array of 500 MB that doesn''t fit in the memory that was allocated to the container
    by Docker?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行一个真正有趣的测试：如果我们为Docker分配给容器的内存中分配一个500 MB的字节数组，会发生什么？
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From a Java perspective, this should work. Since Java thinks the total memory
    is 16 GB, it has set the max heap size to 4 GB, so it happily starts to allocate
    500 MB for the byte array. But after a while, the total size of the JVM exceeds
    1 GB and Docker will kill the container with no mercy, resulting in a confusing
    exception such as `State engine terminated`. We basically have no clue what went
    wrong, even though we can guess that we ran out of memory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java的角度来看，这应该可以工作。由于Java认为总内存为16 GB，它已将最大堆大小设置为4 GB，因此它开始为字节数组分配500 MB。但是过了一会儿，JVM的总大小超过1
    GB，Docker将无情地杀死容器，导致诸如`State engine terminated`的混淆异常。我们基本上不知道出了什么问题，尽管我们可以猜测我们耗尽了内存。
- en: So, to summarize, if you plan to do any serious work with Docker and Java, ensure
    that you use Java SE 10 or later!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总结一下，如果你计划在Docker和Java上做任何严肃的工作，确保你使用Java SE 10或更高版本！
- en: To be fair to Java SE 9, it should be mentioned that Java SE 9 contains some
    initial support for cgroups. If you specify the Java options `-XX:+UnlockExperimentalVMOptions` and `-XX:+UseCGroupMemoryLimitForHeap`,
    it will honor parts of the cgroup constraints, but not all of them, and it should
    be noted that this is only experimental. Due to this, it should be avoided in
    production environments. Simply use Java SE 10 or later in Docker!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，应该提到Java SE 9包含对cgroups的一些初步支持。如果你指定了Java选项`-XX:+UnlockExperimentalVMOptions`和`-XX:+UseCGroupMemoryLimitForHeap`，它将尊重cgroup约束的一部分，但不是全部，并且应该注意的是这仅是实验性的。由于这一点，应该避免在生产环境中使用。简单地在Docker中使用Java
    SE 10或更高版本！
- en: Using Docker with one microservice
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单个微服务的Docker
- en: Now that we understand how Java works, we can start using Docker with one of
    our microservices. Before we can run our microservice as a Docker container, we
    need to package it in a Docker image. To build a Docker image, we need a Dockerfile,
    so we will start with that. Next, we need a Docker-specific configuration for
    our microservice. Since a microservice that runs in a container is isolated from
    other microservices, for example, has its own IP address, hostname, and ports,
    it needs a different configuration compared to when it's running on the same host
    with other microservices. For example, since the other microservices no longer
    run on the same host, no port conflicts will occur. When running in Docker, we
    can use the default port `8080` for all our microservices without any risk of
    port conflicts. On the other hand, if we need to talk to the other microservices,
    we can no longer use localhost like we could when we ran them on the same host.
    The source code in the microservices will not be affected by running the microservices
    in containers, only their configuration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们理解了 Java 的工作原理，我们就可以开始使用 Docker 与我们其中一个微服务一起工作了。在我们能够将微服务作为 Docker 容器运行之前，我们需要将其打包到
    Docker 镜像中。要构建 Docker 镜像，我们需要一个 Dockerfile，所以我们从那个开始。接下来，我们需要为我们的微服务创建一个 Docker
    特定的配置。由于在容器中运行的微服务与其他微服务隔离，例如，它有自己的 IP 地址、主机名和端口，因此它需要与在同一主机上与其他微服务一起运行时的配置不同。例如，由于其他微服务不再在同一主机上运行，所以不会发生端口冲突。当在
    Docker 中运行时，我们可以为所有微服务使用默认端口 `8080`，而无需担心端口冲突的风险。另一方面，如果我们需要与其他微服务通信，我们不能再像在同一主机上运行它们时那样使用
    localhost。微服务的源代码不会受到将微服务以容器形式运行的影响，只有它们的配置会受到影响。
- en: To handle the different configurations that are required when running locally
    without Docker and when running the microservices as Docker containers, we will
    use Spring profiles. Since [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating
    a Set of Cooperating Microservices*, we have been using the default Spring profile
    for running locally without Docker, so we will create a Spring profile named `docker`
    for when we run our microservices as containers in Docker.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理在没有 Docker 的情况下本地运行和作为 Docker 容器运行微服务时所需的不同配置，我们将使用 Spring 配置文件。自从第 [3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)
    章 *创建一组协作的微服务* 以来，我们就一直在使用默认的 Spring 配置文件来本地运行而不使用 Docker，因此我们将创建一个名为 `docker`
    的 Spring 配置文件，用于在 Docker 中作为容器运行我们的微服务。
- en: Changes in source code
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码中的更改
- en: We will use the `product` microservice, which can be found in the source code
    at `$BOOK_HOME/Chapter04/microservices/product-service/`. In the next section,
    we will apply this to the other microservices as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `product` 微服务，该微服务可以在源代码中的 `$BOOK_HOME/Chapter04/microservices/product-service/`
    找到。在下一节中，我们将也将这个应用到其他微服务上。
- en: 'First, we add the Spring profile for Docker at the end of the property file
    `$BOOK_HOME/Chapter04/microservices/product-service/src/main/resources/application.yml`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在属性文件 `$BOOK_HOME/Chapter04/microservices/product-service/src/main/resources/application.yml`
    的末尾添加 Docker 的 Spring 配置文件：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Spring profiles can be used to specify environment-specific configuration, which
    in this case is a configuration that is to only be used when running the microservice
    in a Docker container. Other examples are configurations that are specific to
    `dev`, `test`, and production environments. Values in a profile override the default
    values, that is, values from the default profile. Using `.yaml` files, multiple
    Spring profiles can be placed in the same file, separated by ``---``.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 配置文件可以用来指定特定环境的配置，这里的情况是指当微服务在 Docker 容器中运行时才使用该配置。其他例子是那些特定于 `dev`、`test`
    和生产环境的配置。配置文件中的值会覆盖默认值，即默认配置文件中的值。使用 `.yaml` 文件，可以在同一个文件中放置多个 Spring 配置文件，它们之间用
    `---` 分隔。
- en: The only parameter we will change is the port that's being used; that is, we
    will use the default port `8080` when running the microservice in a container.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一要更改的参数是正在使用的端口；也就是说，当微服务在容器中运行时，我们将使用默认端口 `8080`。
- en: 'Next, we will create the `Dockerfile` that we will use to build the Docker
    image, `$BOOK_HOME/Chapter04/microservices/product-service/Dockerfile`. It looks
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 `Dockerfile`，用于构建 Docker 镜像，`$BOOK_HOME/Chapter04/microservices/product-service/Dockerfile`。它看起来像这样：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Some things to take note of are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些事情如下：
- en: We will base our Docker image on the official Docker image for OpenJDK and use
    the Java SE v12.0.2.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将基于 OpenJDK 的官方 Docker 镜像，并使用 Java SE v12.0.2。
- en: We will expose port `8080` to other Docker containers.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将向其他 Docker 容器暴露端口 `8080`。
- en: We add our `fat-jar` file to the Docker image from the Gradle build library, `build/libs`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从Gradle构建库`build/libs`中添加我们的`fat-jar`文件到Docker镜像中：
- en: We will specify the command to be used by Docker when a container is started
    up using this Docker image, that is, `java -jar /app.jar`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将指定Docker在容器启动时使用的命令，即`java -jar /app.jar`。
- en: After taking into account these changes in source code
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑源代码中的这些更改之后
- en: Building a Docker image
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: 'To build the Docker image, we need to build our deployment artifact, that is,
    the fat-file, for `product-service`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建Docker镜像，我们需要为`product-service`构建部署工件，即脂肪文件：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since we only want to build `product-service` and the projects it depends on,
    `api` and `util`, we don't use the normal `build` command, which builds all the
    microservices, but a variant that tells Gradle to only build `product-service`: `:microservices:product-service:build`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想构建`product-service`及其依赖项`api`和`util`，所以我们不使用正常的`build`命令（它会构建所有微服务），而是使用一个告诉Gradle只构建`product-service`的变体：`:microservices:product-service:build`。
- en: 'We can find the `fat-jar` file in the Gradle build library, `build/libs`. For
    example, the `ls -l microservices/product-service/build/libs` command will report
    something like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Gradle构建库`build/libs`中找到`fat-jar`文件。例如，`ls -l microservices/product-service/build/libs`命令将会报告如下内容：
- en: '![](img/2af54aa7-9e16-41b1-964a-021bda81ebd5.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2af54aa7-9e16-41b1-964a-021bda81ebd5.png)'
- en: As you can see, the JAR file is close to 20 MB in size – no wonder they are
    called `fat-jar` files!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，JAR文件的大小接近20 MB——难怪它们被称为`fat-jar`文件！
- en: If you are curious about its actual content, you can view it by using the `unzip
    -l microservices/product-service/build/libs/product-service-1.0.0-SNAPSHOT.jar`
    command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇它的实际内容，可以使用`unzip -l microservices/product-service/build/libs/product-service-1.0.0-SNAPSHOT.jar`命令查看。
- en: 'Next, we will build the Docker image and name it `product-service`, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建Docker镜像并将其命名为`product-service`，如下所示：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Docker will use the Dockerfile in the current directory to build the Docker
    image. The image will be tagged with the name `product-service` and stored locally
    inside the Docker engine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将使用当前目录中的Dockerfile来构建Docker镜像。该镜像将被命名为`product-service`并存储在Docker引擎内部。
- en: 'Verify that we got a Docker image, as expected, by using the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 验证我们是否获取了Docker镜像，使用以下命令：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The expected output is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![](img/81cd92d2-7f8a-42a7-8e75-bfd20c69a1a6.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81cd92d2-7f8a-42a7-8e75-bfd20c69a1a6.png)'
- en: So now that we have built the image, lets see how we can start the service.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经构建了镜像，那么让我们看看如何启动服务。
- en: Starting up the service
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务
- en: 'Let''s start up the `product` microservice as a container by using the following
    command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令以容器形式启动`product`微服务：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is what we can infer from the preceding code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从前面的代码可以推断出的事情：
- en: '`docker run`: The Docker run command will start the container and display log
    output in Terminal. Terminal will be locked as long as the container runs.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run`：Docker运行命令将启动容器并在终端中显示日志输出。只要容器运行，终端就会被锁定。'
- en: We have seen the `--rm` option already; it will tell Docker to clean up the
    container once we stop the execution from Terminal using *Ctrl + C*.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到了`--rm`选项；它将告诉Docker我们在使用*Ctrl + C*从终端停止执行时清理容器。
- en: The `-p8080:8080` option maps port `8080` in the container to port `8080` in
    the Docker host, which makes it possible to call it from the outside. In the case
    of Docker for macOS, which runs Docker in a local Linux virtual machine, the port
    will also be port-forwarded to macOS, which is made available on localhost. We
    can only have one container mapping to a specific port in the Docker host!
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-p8080:8080`选项将容器中的端口`8080`映射到Docker主机的端口`8080`，这使得它可以从外部调用。在macOS上的Docker中，Docker在本地Linux虚拟机中运行，端口也将被映射到macOS上，在本地主机上可用。我们只能在Docker主机上有一个特定端口的容器映射！'
- en: With the `-e` option, we can specify environment variables for the container,
    which in this case is `SPRING_PROFILES_ACTIVE=docker`. The `SPRING_PROFILES_ACTIVE` environment
    variable is used to tell Spring what profile to use. In our case, we want Spring
    to use the `docker` profile.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-e`选项，我们可以为容器指定环境变量，这个例子中是`SPRING_PROFILES_ACTIVE=docker`。`SPRING_PROFILES_ACTIVE`环境变量用于告诉Spring使用哪个配置文件。在我们的例子中，我们希望Spring使用`docker`配置文件。
- en: Finally, we have `product-service`, which is the name of the Docker image that
    Docker will use to start the container.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有了`product-service`，这是Docker将用来启动容器的Docker镜像的名称。
- en: 'The expected output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![](img/6418f725-7182-4415-a87c-283962b36cad.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6418f725-7182-4415-a87c-283962b36cad.png)'
- en: 'This is what we infer from the preceding output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从上述输出中推断出的：
- en: 'The profile that''s used by Spring is `docker`. Look for `The following profiles
    are active: docker` in the output to verify this.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Spring使用的配置文件是`docker`。在输出中查找`以下配置文件处于活动状态: docker`来验证这一点。'
- en: 'The port that''s allocated by the container is `8080`. Look for `Netty started
    on port(s): 8080` in the output to verify this.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '容器分配的端口是`8080`。在输出中查找`Netty started on port(s): 8080`来验证这一点。'
- en: The microservice is ready to accept requests once the log message `Started ProductServiceApplication` has
    been written!
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当日志消息`Started ProductServiceApplication`被写入时，微服务就准备好接受请求了！
- en: 'Try out the following code in another Terminal window:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口尝试以下代码：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we can use port `8080` on localhost, as explained previously!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们可以使用localhost上的端口`8080`，如前所述！
- en: 'The following is the expected output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期输出：
- en: '![](img/da91fca5-5223-4ded-b277-26ef0ea17866.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da91fca5-5223-4ded-b277-26ef0ea17866.png)'
- en: This is similar to the output we received from the previous chapter, but with
    one major difference; we have the content of `"service Address":"aebb42b32fef/172.17.0.2:8080"`,
    the port is `8080`, as expected, and the IP address, `172.17.0.2`, is an IP address
    that's been allocated to the container from an internal network in Docker – but
    where did the hostname, `aebb42b32fef`, come from?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们从上一章获得的输出类似，但有一个主要区别；我们有`"service Address":"aebb42b32fef/172.17.0.2:8080"`的内容，端口是`8080`，如预期那样，IP地址`172.17.0.2`是一个从Docker内部网络分配给容器的IP地址——但是主机名`aebb42b32fef`是从哪里来的？
- en: 'Ask Docker for all the running containers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 询问Docker所有正在运行的容器：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will see something like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到类似以下内容：
- en: '![](img/ab9eb9ee-8dc6-4e0c-bcd2-14269175f84c.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab9eb9ee-8dc6-4e0c-bcd2-14269175f84c.png)'
- en: As we can see from the preceding output that, the hostname is equivalent to
    the ID of the container, which is good to know if you want to understand what
    container actually responded to your request!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中我们可以看到，主机名相当于容器的ID，如果你想要了解哪个容器实际响应了你的请求，这一点是很有帮助的！
- en: Wrap this up by stopping the container in Terminal with the *Ctrl + C* command.
    With this done, we can now move on to running the container detached while being
    detached.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 用*Ctrl + C*命令停止终端中的容器。完成这一步后，我们可以继续运行分离的容器。
- en: Running the container detached
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离运行容器
- en: Okay, that was great, but what if we don't want to hang the Terminal windows
    from where we started the container?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很好，但如果我们不想挂起我们从哪里开始容器的终端窗口怎么办？
- en: It's time to start the container as detached, that is, running the container
    without locking Terminal!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始作为分离容器运行了，也就是说，运行容器而不锁定终端！
- en: 'We can do this by adding the `-d` option and at the same time giving it a name
    using the `--name` option. The `--rm` option is no longer required since we will
    stop and remove the container explicitly when we are done with it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`-d`选项并同时使用`--name`选项为其命名来实现。由于我们将在使用完毕时明确停止和删除容器，所以不再需要`--rm`选项：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we run the `docker ps` command again, we will see our new container, called `my-prd-srv`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行`docker ps`命令，我们将看到我们新创建的容器，名为`my-prd-srv`：
- en: '![](img/a683c0b3-0d98-4e01-afad-b521ee76cd42.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a683c0b3-0d98-4e01-afad-b521ee76cd42.png)'
- en: But how do we get the log output from our container?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何获取容器的日志输出呢？
- en: 'Meet the Docker `logs` command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Docker的`logs`命令：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `-f` option tells the command to follow the log output, that is, not end
    the command when all the current log output has been written to Terminal, but
    also wait for more output. If you expect a lot of old log messages that you don't
    want to see, you can also add the `--tail 0` option so that you only see new log
    messages. Alternatively, you can use the `--since` option and use either an absolute
    timestamp or a relative time, for example, `--since 5m`, to see log messages that
    are at most five minutes old.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`选项告诉命令跟随日志输出，即，当所有当前日志输出被写入终端时，不要结束命令，但也要等待更多输出。如果你预期有很多不想看到的旧日志消息，你还可以添加`--tail
    0`选项，这样你只看到新的日志消息。或者，你可以使用`--since`选项，并使用绝对时间戳或相对时间，例如`--since 5m`，来看最多五分钟内的日志消息。'
- en: Try this out with a new `curl` request. You should see that a new log message
    has been written to the log output in Terminal!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个新的`curl`请求尝试这个。你应该看到一个新的日志消息已经被写入终端的日志输出！
- en: 'Wrap this up by stopping and removing the container:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过停止和删除容器来结束：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `-f` option forces Docker to remove the container, even if it is running.
    Docker will automatically stop the container before it removes it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`选项强制Docker删除容器，即使它正在运行。Docker会在删除之前自动停止容器。'
- en: Now that we know how to use Docker with a microservice, we can now see how to
    manage a microservices landscape with the help of Docker Compose and see the changes
    in it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何使用Docker与微服务，我们可以进一步了解如何使用Docker Compose管理微服务架构，并查看其变化。
- en: Managing a landscape of microservices using Docker Compose
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose管理微服务架构
- en: We've already seen how we can run a single microservice as a Docker container,
    but what about managing a whole system landscape of microservices?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何运行单个微服务作为Docker容器，但是管理整个系统架构的微服务呢？
- en: As we mentioned earlier, this is the purpose of `docker-compose`. By using single
    commands, we can build, start, log, and stop a group of cooperating microservices
    running as Docker containers!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这就是`docker-compose`的目的。通过使用单一命令，我们可以构建、启动、记录和停止作为Docker容器运行的一组协作微服务！
- en: Changes in the source code
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码的变化
- en: To be able to use Docker Compose, we need to create a configuration file, `docker-compose.yml`,
    that describes the microservices Docker Compose will manage for us. We also need
    to set up Dockerfiles for the remaining microservices and add a Docker-specific
    Spring profile to each of them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用Docker Compose，我们需要创建一个配置文件`docker-compose.yml`，描述Docker Compose将为我们管理的微服务。我们还需要为剩余的微服务设置Dockerfile，并为每个微服务添加一个特定的Spring配置文件。
- en: 'All four microservices have their own Dockerfile, but they all look the same
    as the preceding one. You can find them here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个微服务都有自己的Dockerfile，但它们都与前一个相同。您可以在以下位置找到它们：
- en: '`$BOOK_HOME/Chapter04/microservices/product-service/Dockerfile`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter04/microservices/product-service/Dockerfile`'
- en: '`$BOOK_HOME/Chapter04/microservices/recommendation-service/Dockerfile`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter04/microservices/recommendation-service/Dockerfile`'
- en: '`$BOOK_HOME/Chapter04/microservices/review-service/Dockerfile`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter04/microservices/review-service/Dockerfile`'
- en: '`$BOOK_HOME/Chapter04/microservices/product-composite-service/Dockerfile`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter04/microservices/product-composite-service/Dockerfile`'
- en: When it comes to the Spring profiles, the three core services, `product`, `recommendation`,
    and `review-service`, have the same `docker` profile, which only specifies that
    the default port `8080` should be used when running as a container.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到Spring配置文件时，三个核心服务`product`、`recommendation`和`review-service`具有相同的`docker`配置文件，它只指定当作为容器运行时应使用默认端口`8080`。
- en: 'For `product-composite-service`, things are a bit more complicated since it
    needs to know where to find the core services. When we ran all the services on
    localhost, it was configured to use localhost and individual port numbers, `7001`-`7003`,
    for each core service. When running in Docker, each service will have its own
    hostname but will be accessible on the same port number, `8080`. Here, the `docker`
    profile for `product-composite-service` looks as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`product-composite-service`，事情变得有些复杂，因为它需要知道如何找到核心服务。当我们所有服务都运行在localhost上时，它被配置为使用localhost和每个核心服务的个别端口号`7001`-`7003`。当在Docker中运行时，每个服务将有自己的主机名，但可以在相同的端口号`8080`上访问。在此处，`product-composite-service`的`docker`配置文件如下所示：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See `$BOOK_HOME/Chapter04/microservices/product-composite-service/src/main/resources/application.yml` for
    details.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息请参阅`$BOOK_HOME/Chapter04/microservices/product-composite-service/src/main/resources/application.yml`。
- en: Where did the hostnames, products, recommendations, and reviews come from?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名、产品、推荐和评论从何而来？
- en: 'These are specified in the `docker-compose.yml` file, which is located in the
    `$BOOK_HOME/Chapter04` folder. It looks like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在`docker-compose.yml`文件中指定，该文件位于`$BOOK_HOME/Chapter04`文件夹中。它看起来像这样：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For each microservice, we specify the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个微服务，我们指定如下内容：
- en: The name of the microservice. This will also be the hostname of the container
    in the internal Docker network.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务名称。这也将是内部Docker网络中容器的的主机名。
- en: A build directive that specifies where to find the Dockerfile that was used
    to build the Docker image.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建指令指定了查找用于构建Docker镜像的Dockerfile的位置。
- en: A memory limit of 350 MB. This ensures that all containers in this and the upcoming
    chapters will fit in the 6 GB of memory that we allocated to the Docker engine
    in the *Technical requirements* section.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存限制为350 MB。这确保了本章及接下来的章节中所有的容器都能 fits in the 6 GB of memory that we allocated
    to the Docker engine in the *Technical requirements* section。
- en: The environment variables that will be set up for the container. In our case,
    we used these to specify what Spring profile to use.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为容器设置的环境变量。在我们的案例中，我们使用这些来指定要使用的Spring配置文件。
- en: For the `product-composite` service, we will also specify port mappings, that
    is, we will expose its port to the outside of Docker. The other microservices
    will not be accessible from the outside. Next, we will see how to start up a microservice
    landscape.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`product-composite`服务，我们还将指定端口映射，即，我们将将其端口暴露给Docker外部。其他微服务将无法从外部访问。接下来，我们将了解如何启动微服务架构。
- en: Starting up the microservice landscape
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动微服务架构
- en: 'With all the necessary code changes in place, we can build our Docker images,
    start up the microservice landscape, and run some tests to verify that it works
    as expected. For this, we need to do the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有必要的代码更改，我们可以构建Docker镜像，启动微服务架构，并运行一些测试来验证它是否按预期工作。为此，我们需要做以下工作：
- en: 'First, we build our deployment artifacts with Gradle and then the Docker images
    with Docker Compose:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用Gradle构建我们的部署工件，然后使用Docker Compose构建Docker镜像：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we need to verify that we can see our Docker images, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要验证我们是否可以看到我们的Docker镜像，如下所示：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We should see the following output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该看到以下输出：
- en: '![](img/75213781-b3ea-4f66-84b9-62727717d4c5.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75213781-b3ea-4f66-84b9-62727717d4c5.png)'
- en: 'Start up the microservices landscape with the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动微服务架构：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `-d` option means the same as for Docker, as described previously.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`选项的意义与Docker之前描述的意义相同。'
- en: 'We can follow the startup by monitoring the output that''s written to each
    container log with the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令监控每个容器日志中写入的输出，以跟踪启动过程：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `docker compose logs` command supports the same `-f` and `--tail` options
    as `docker logs`, as described earlier.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker compose logs`命令支持与`docker logs`相同的`-f`和`--tail`选项，如前所述。'
- en: The Docker Compose `logs` command also supports restricting the log output to
    a group of containers. Simply add the names of the containers you want to see
    the log output of after the `logs` command. For example, to only see log output
    from the `product` and `review` service, use `docker-compose logs -f product review`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose `logs`命令也支持将日志输出限制为一组容器。只需在`logs`命令之后添加您想要查看日志输出的容器的名称。例如，要只查看`product`和`review`服务的日志输出，请使用`docker-compose
    logs -f product review`。
- en: 'When all four microservices have reported that they have started up, we are
    ready to try out the microservices landscape. Look for the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当四个微服务都报告它们已经启动时，我们就可以尝试使用微服务架构了。寻找以下内容：
- en: '![](img/760e3b57-8782-48c5-90ef-7ec483ef7f0e.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/760e3b57-8782-48c5-90ef-7ec483ef7f0e.png)'
- en: Note that each log message is prefixed with the name of the container that produces
    the output!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个日志消息都以前缀的方式加上了产生输出的容器的名称！
- en: 'Now, we are ready to run some tests to verify that this works as expected. The
    only change we need to make when calling the composite service in Docker from
    when we ran it directly on the localhost, as we did in the previous chapter, is
    the port number. We now use port `8080`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备运行一些测试来验证这是否如预期工作。当我们从前一章直接在localhost上运行复合服务时，调用Docker中的复合服务所需做的唯一更改是端口号。现在我们使用端口`8080`：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will get the same type of response:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到相同的响应：
- en: '![](img/ea65b614-de1e-426a-83dc-b750d6cef6be.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea65b614-de1e-426a-83dc-b750d6cef6be.png)'
- en: 'However, there''s one big difference – the hostnames and ports reported by
    `serviceAddresses` in the response:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个很大的区别——`serviceAddresses`中报告的主机名和端口：
- en: '![](img/60a1a060-0f7d-4bb9-9088-89a1c926ae2b.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60a1a060-0f7d-4bb9-9088-89a1c926ae2b.png)'
- en: Here, we can see the hostnames and IP addresses that have been allocated to
    each of the Docker containers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到分配给每个Docker容器的主机名和IP地址。
- en: 'We''re done; now only one step is left:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了；现在只剩下一步：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding command will shut down the microservices landscape.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令将关闭微服务架构。
- en: Testing them all together automatically
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一起自动测试它们
- en: Docker Compose is really helpful when it comes to manually managing a group
    of microservices! In this section, we will take this one step further and integrate
    Docker Compose into our test script, `test-em-all.bash`. The test script will
    automatically start up the microservice landscape, run all the required tests
    to verify that the microservice landscape works as expected, and finally tear
    it down, leaving no traces behind.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当手动管理一组微服务时，Docker Compose非常有帮助！在本节中，我们将更进一步地将Docker Compose集成到我们的测试脚本`test-em-all.bash`中。测试脚本将自动启动微服务景观，运行所有必要的测试以验证微服务景观按预期工作，并最终拆除它，不留下任何痕迹。
- en: The test script can be found at `$BOOK_HOME/Chapter04/test-em-all.bash`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本可以在`$BOOK_HOME/Chapter04/test-em-all.bash`找到。
- en: 'Before the test script runs the test suite, it will check for the presence
    of a `start` argument in the invocation of the test script. If found, it will
    restart the containers with the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试脚本运行测试套件之前，它会检查测试脚本的调用中是否存在`start`参数。如果找到，它将使用以下代码重新启动容器：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After that, the test script will wait for the `product-composite` service to
    respond with OK:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，测试脚本将等待`product-composite`服务响应OK：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `waitForService` bash function can be implemented like so:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForService`bash函数可以如此实现：'
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, all the tests are executed like they were previously. Afterward, they
    will tear down the landscape if it finds the `stop` argument in the invocation
    of the test scripts:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像之前一样执行所有测试。之后，如果发现测试脚本的调用中存在`stop`参数，它将拆除景观：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that the test script will not tear down the landscape if some tests fail;
    it will simply stop, leaving the landscape up for error analysis!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果某些测试失败，测试脚本将不会拆除景观；它只会停止，留下景观用于错误分析！
- en: The test script has also changed the default port from `7000`, which we used
    when we ran the microservices without Docker, to `8080`, which is used by our
    Docker containers.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本还将将默认端口从`7000`更改为`8080`，我们在没有Docker的情况下运行微服务时使用`7000`，而`8080`被我们的Docker容器使用。
- en: 'Let''s try it out! To start the landscape, run the tests and tear it down afterward,
    like so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧！要启动景观，运行测试并在之后拆除它，像这样：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is some sample output from a test run (with output from the specific
    tests that were deleted):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从一次测试运行中获取的一些示例输出（包括被删除的特定测试的输出）：
- en: '![](img/16df5488-1e1d-45e3-850e-fad5f66cdbaf.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16df5488-1e1d-45e3-850e-fad5f66cdbaf.png)'
- en: After testing these, we can now move on to see how to troubleshoot tests that
    fail.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这些之后，我们可以继续了解如何解决失败的测试问题。
- en: Troubleshooting a test run
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试运行故障排除
- en: 'If the tests that were running `./test-em-all.bash start stop` fail, following
    these steps can help you identify the problem and resume the tests once the problem
    has been fixed:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`./test-em-all.bash start stop`的测试失败，按照这些步骤可以帮助您识别问题并修复问题后继续测试：
- en: 'First, check the status of the running microservices with the following command:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令检查运行中的微服务的状态：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If all the microservices are up and running and healthy, you will receive the
    following output:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有微服务都运行正常且健康，您将收到以下输出：
- en: '![](img/8cdb0618-6760-4126-a3f5-abb60989b739.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cdb0618-6760-4126-a3f5-abb60989b739.png)'
- en: 'If any of the microservices do not have a status of `Up`, check its log output
    for any errors by using the `docker-compose logs` command. For example, you would
    use the following code if you wanted to check the log output for the `product`
    service:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有任何微服务的状态不是`Up`，使用`docker-compose logs`命令检查其日志输出是否有任何错误。例如，如果您想检查`product`服务的日志输出，可以使用以下代码：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If errors in the log output indicate that Docker is running out of disk space,
    parts of it can be reclaimed with the following command:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果错误日志输出显示Docker磁盘空间不足，可以使用以下命令回收部分空间：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If required, you can restart a failed microservice with the `docker-compose
    up -d --scale` command. For example, you would use the following code if you wanted
    to restart the `product` service:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有需要，您可以使用`docker-compose up -d --scale`命令重新启动失败的微服务。例如，如果您想重新启动`product`服务，可以使用以下代码：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If a microservice is missing, for example, due to a crash, you start it up
    with the `docker-compose up -d --scale` command. For example, you would use the
    following code for the `product` service:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个微服务丢失，例如，由于崩溃，您可以使用`docker-compose up -d --scale`命令启动它。例如，您会使用以下代码为`product`服务：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once all the microservices are up and running and healthy, run the test script
    again, but without starting the microservices:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有微服务都运行并保持健康状态，再次运行测试脚本，但这次不启动微服务：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The tests should run fine!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该运行得很好！
- en: 'Finally, a tip about a combined command that builds runtime artifacts and Docker
    images from source and then runs all the tests in Docker:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于一个组合命令的提示，该命令从源代码构建运行时工件和Docker镜像，然后在每个Docker容器中运行所有测试：
- en: '`./gradlew clean build && docker-compose build && ./test-em-all.bash start
    stop`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`./gradlew clean build && docker-compose build && ./test-em-all.bash start
    stop`'
- en: This is perfect if you want to check that everything works before you push new
    code to your Git repository or as part of a build pipeline in your build server!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在将新代码推送到你的Git仓库之前或作为你构建服务器中构建管道的部分来检查一切是否正常，这太完美了！
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how Docker can be used to simplify testing a landscape
    of cooperating microservices.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Docker如何被用来简化对一组协同工作的微服务的测试。
- en: We learned how Java SE since v10 honors constraints that we put on containers
    regarding how much CPU and memory they are allowed to use.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，从Java SE v10开始，它尊重我们对容器施加的约束，关于容器可以使用多少CPU和内存。
- en: We have also seen how little it takes to make it possible to run a Java-based
    microservice as a Docker container. Thanks to Spring profiles, we can run the
    microservice in Docker without having to make any code changes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了，要让一个基于Java的微服务作为Docker容器运行，需要多么小的改动。多亏了Spring配置文件，我们可以在不进行任何代码更改的情况下在Docker中运行微服务。
- en: Finally, we have seen how Docker Compose can help us manage a landscape of cooperating
    microservices with single commands, either manually or, even better, automatically,
    when integrated with a test script such as `test-em-all.bash`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了Docker Compose如何帮助我们用单一命令管理一组协同工作的微服务，无论是手动还是更好的自动方式，当与像`test-em-all.bash`这样的测试脚本集成时。
- en: In the next chapter, we will study how we can add a documentation of the API
    using OpenAPI/Swagger descriptions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用OpenAPI/Swagger描述来添加API文档。
- en: Questions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the major differences between a virtual machine and a Docker container?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟机和Docker容器之间有哪些主要区别？
- en: What is the purpose of namespaces and cgroups in Docker?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间和Docker中的cgroups有什么作用？
- en: What happens with a Java application that doesn't honor the max memory settings
    in a container and allocates more memory than it is allowed to?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Java应用程序如果不尊重容器中的最大内存设置并且分配了比允许更多的内存，会发生什么？
- en: How can we make a Spring-based application run as a Docker container without
    requiring modifications of its source code?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何让一个基于Spring的应用程序在不修改其源代码的情况下作为Docker容器运行？
- en: Why will the following Docker Compose code snippet not work?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么下面的Docker Compose代码段不会工作？
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
