- en: Chapter 7. Concepts of Tree
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 树的概念
- en: 'We have already seen data structures such as linked list and array. They represent
    data stored in a linear fashion. In this chapter, we will discuss a new kind of
    data structure, called a tree. A tree is a generalization of a linked list. While
    a linked list node has one reference to the next node, a tree node has references
    to possibly more than one next node. These next nodes are called children of the
    node, and the node holding the references to the children is called a parent node.
    In this chapter, we will explore the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了像链表和数组这样的数据结构。它们以线性方式表示存储的数据。在本章中，我们将讨论一种新的数据结构，称为树。树是链表的泛化。虽然链表节点有一个指向下一个节点的引用，但树节点有指向可能超过一个下一个节点的引用。这些下一个节点被称为节点的子节点，持有子节点引用的节点称为父节点。在本章中，我们将探讨以下主题：
- en: Concept of a tree as a data structure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树作为数据结构的概念
- en: Concept of a tree as an ADT
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树作为ADT的概念
- en: Binary trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树
- en: Different kinds of tree traversals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的树遍历方式
- en: Tree search algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树搜索算法
- en: So, let's jump into it right away.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们立即开始吧。
- en: A tree data structure
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树数据结构
- en: 'A tree data structure looks very much like a real tree, the kind you can see
    in a garden or by the roadside. If we look at a tree, we will see that it has
    a root that makes the stem outside of the ground. The stem splits into branches,
    and at the end of the branches, we find leaves. In our tree data structure, we
    start from the root. The root is the node that does not have any parent. The children
    can be thought of as being attached to the stem by lines just like the branches
    of a real tree. At the end, we find some nodes that have no children and hence
    are called leaves. The following figure shows an example of a tree:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 树数据结构看起来非常像一棵真正的树，就像你在花园或路边看到的那种。如果我们观察一棵树，我们会看到它有一个根，使茎从地面外露出来。茎分成树枝，在树枝的末端，我们找到叶子。在我们的树数据结构中，我们从根开始。根是没有父节点的节点。子节点可以想象成通过线连接到茎上，就像真实树上的树枝一样。最后，我们找到一些没有子节点的节点，因此被称为叶子。以下图显示了树的示例：
- en: '![A tree data structure](img/00042.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![树数据结构](img/00042.jpeg)'
- en: An example tree
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例树
- en: Note that the tree is drawn upside down. The root is at the top and the leaves
    are below. This is just a convention that most people prefer. Think of this as
    the reflection of a tree on water.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，树是倒置的。根在顶部，叶子在下面。这只是大多数人喜欢的一种惯例。把这想象成树在水中的倒影。
- en: A tree can be represented in many ways, but we will get started with the idea
    of generalization of a **linked** list. In the case of a linked list, a node stores
    a single reference that points to the next node. In a tree, a node needs to store
    the references to all its children. Multiple children could be stored in an array,
    but since we have access to our own class `LinkedList`, we will use that. We will
    use our non-functional version of the linked list because our first tree will
    be non-functional and will allow modification.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 树可以用多种方式表示，但我们将从**链表**的泛化概念开始。在链表的情况下，一个节点存储一个指向下一个节点的单一引用。在树中，一个节点需要存储所有子节点的引用。多个子节点可以存储在数组中，但由于我们有对`LinkedList`类的访问，我们将使用它。我们将使用我们非功能的链表版本，因为我们的第一个树将是非功能的，并允许修改。
- en: 'We start with the following class:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以下类开始：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have defined our `Node` class as an inner class. Apart from remembering
    the value it stores inside and the list of children, it also stores the parent
    and the tree that it is a member of. Once we create an instance of a tree, we
    must be able to store a node in it. The node that does not have a parent is called
    the root of the tree. So, we add an `addRoot` method to add a root to the tree.
    The tree, itself, only has to store the reference of the root node as all the
    other nodes can be reached from this node by traversing the references:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`Node`类定义为内部类。除了记住它内部存储的值和子节点列表外，它还存储其父节点以及它是其成员的树。一旦我们创建了一个树的实例，我们必须能够将一个节点存储在其中。没有父节点的节点被称为树的根。因此，我们添加了一个`addRoot`方法来向树中添加一个根。树本身只需要存储根节点的引用，因为所有其他节点都可以通过遍历引用从这个节点访问：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we test whether the tree already has a root node, in which case, we
    throw an exception.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们测试树是否已经有一个根节点，如果有，则抛出异常。
- en: 'Okay, now that we have a way of adding a root node, we need to have a method
    for adding nodes as we like. The method takes a parent node and a value in order
    to add a new node. This method will return the newly added node so that we keep
    adding more nodes as its children:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经有了添加根节点的方法，我们需要有一个方法来添加我们想要的节点。这个方法接受一个父节点和一个值以添加一个新节点。这个方法将返回新添加的节点，这样我们就可以继续添加更多节点作为其子节点：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we first check whether the parent is null or whether
    the parent is the node of a different tree instance. In either case, an exception
    must be thrown. Otherwise, we just add a new node as the child of the parent node
    passed as an argument.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先检查父节点是否为null，或者父节点是否是不同树实例的节点。在任何情况下，都必须抛出异常。否则，我们只需将新节点添加为作为参数传递的父节点的子节点。
- en: 'But wait a second! How would we ever be able to pass a parent node if we do
    not have a reference to the root node in the calling code? So, we add a method,
    `getRoot`, to access the root node of the Tree:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！如果我们没有在调用代码中获取根节点的引用，我们如何传递父节点呢？因此，我们添加了一个名为`getRoot`的方法来访问树的根节点：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Okay, now let''s create a `Tree` instance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们创建一个`Tree`实例：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code is self-explanatory. We just create a tree by adding the nodes one
    by one. But how do we see what the tree looks like? For that, we will have to
    learn about the traversal of a tree. The preceding code will create the tree shown
    in the following figure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是自我解释的。我们只是通过逐个添加节点来创建树。但我们如何看到树的样子呢？为此，我们将学习树的遍历。前面的代码将创建以下图中所示的树：
- en: '![A tree data structure](img/00043.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![树数据结构](img/00043.jpeg)'
- en: Example tree
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例树
- en: The traversal of a tree
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树的遍历
- en: Tree traversal is an algorithm to visit or to process all nodes of a tree exactly
    once. This obviously involves recursively looking into the children of the nodes.
    The order in which the children are processed depends on the particular algorithm
    we use. The simplest algorithm for traversing a tree is the depth-first traversal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 树遍历是一种算法，用于恰好访问或处理树的所有节点一次。这显然涉及到递归地查看节点的子节点。子节点处理的顺序取决于我们使用的特定算法。遍历树的简单算法是深度优先遍历。
- en: The depth-first traversal
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度优先遍历
- en: In the depth-first traversal, we process every child of a node recursively and
    wait for it to finish with all its descendants before proceeding to the next child.
    To understand the depth-first search, we have to understand what a subtree is.
    A subtree is a node with all its descendants up to the leaves. The following figure
    shows some examples of subtrees.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度优先遍历中，我们递归地处理一个节点的每个子节点，并在继续处理下一个子节点之前等待它及其所有后代的完成。为了理解深度优先搜索，我们必须理解什么是子树。子树是一个节点及其所有后代的集合，直到叶子节点。以下图显示了子树的一些示例。
- en: '![The depth-first traversal](img/00044.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![深度优先遍历](img/00044.jpeg)'
- en: Examplesubtrees
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 子树示例
- en: 'Now, if you think about it, each node not only stores references to the children,
    but also sort of holds references to entire subtrees rooted at the child nodes.
    So, the depth-first traversal algorithm is nothing but the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你仔细想想，每个节点不仅存储了对子节点的引用，而且似乎还持有对以子节点为根的整个子树的引用。因此，深度优先遍历算法实际上就是以下步骤：
- en: Process the value in the current node.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理当前节点中的值。
- en: For each child node of the current node, recursively traverse the entire subtree
    rooted at the child node.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于当前节点的每个子节点，递归遍历以子节点为根的整个子树。
- en: 'The following method does exactly this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法正是这样做的：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The method takes a lambda and a node to traverse. All this method does is first
    run the lambda on the current value and then call itself recursively on each of
    the subtrees. Now, we can write a wrapper method without the parent node argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个lambda表达式和一个节点以进行遍历。这个方法所做的只是首先在当前值上运行lambda表达式，然后递归地对其每个子树调用自身。现在，我们可以编写一个不带父节点参数的包装方法：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is still not clear, though, why this way of traversing is called a depth-first
    traversal. If you think about the order in which the nodes are processed, you
    can see that since the complete subtree root at any child node must be entirely
    processed before the next child is processed, the depth of the tree will be covered
    before the breadth.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这种遍历方式为什么被称为深度优先遍历仍然不清楚。如果你考虑节点处理的顺序，你可以看到，由于任何子节点的完整子树必须在处理下一个子节点之前完全处理，因此树的深度将在宽度之前被覆盖。
- en: 'We have used a recursive function to do our depth-first search. Alternatively,
    we can use a stack to do the trick:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用递归函数来进行深度优先搜索。或者，我们也可以使用栈来完成这个任务：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's see what is happening in the preceding piece of code. We first push the
    root into the stack and go in a loop that continues until all the stack elements
    have been cleared. Every time we pop a node, we process it and push all its children
    into the stack. Now, since the stack is **last in first out** (**LIFO**), all
    these children will be popped and processed before any other node can be processed.
    However, the moment the first of these children is popped, its children will be
    pushed into the stack and would be processed before anything else is processed.
    This will go on until we hit the leaf nodes, which would not have any more children.
    This, in effect, is almost the same as the recursive version.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面那段代码中发生了什么。我们首先将根节点推入栈，然后进入一个循环，直到栈中的所有元素都被清除。每次弹出节点时，我们处理它并将所有子节点推入栈。现在，由于栈是后进先出（LIFO），所有这些子节点都会被弹出并处理，在处理任何其他节点之前。然而，当第一个子节点被弹出时，其子节点将被推入栈，并且会在处理其他任何内容之前被处理。这将一直持续到我们到达叶节点，这些叶节点将没有更多的子节点。实际上，这几乎与递归版本相同。
- en: 'There is a slight difference between the outputs of this code and the recursive
    version, although both are indeed depth-first. However, please note that in the
    case of the recursive version, the child that is near the head of the linked list
    is processed first. In the case of the stack version, we push the children in
    the same order, but since the stack is LIFO, we pop the children in the reverse
    order. To reverse this order, we can store the list of children in the opposite
    order in a temporary list before pushing them into the stack, as shown in the
    following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出与递归版本之间略有不同，尽管两者实际上都是深度优先。然而，请注意，在递归版本的情况下，靠近链表头部的子节点首先被处理。在栈版本的情况下，我们以相同的顺序压入子节点，但由于栈是后进先出（LIFO），我们以相反的顺序弹出子节点。为了反转这个顺序，我们可以在将子节点推入栈之前，将子节点的列表以相反的顺序存储在一个临时列表中，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The list is reversed by storing in a temporary list, called `reverseList`, by
    appending the elements to its beginning. Then, the elements are pushed into the
    stack from `reverseList`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将元素追加到其开头，我们通过一个名为`reverseList`的临时列表来反转列表。然后，元素从`reverseList`中推入栈。
- en: The breadth-first traversal
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广度优先遍历
- en: 'Breadth-first traversal is the opposite of the depth-first traversal, in the
    sense that depth-first traversal processes children before siblings and breadth-first
    traversal processes the nodes of the same level before it processes any node of
    the succeeding level. In other words, in a breadth-first traversal, the nodes
    are processed level by level. This is simply achieved by taking the stack version
    of the depth-first traversal and replacing the stack with a queue. That is all
    that is needed for it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先遍历与深度优先遍历相反，其含义是深度优先遍历先处理子节点再处理兄弟节点，而广度优先遍历则先处理同一层的节点再处理下一层的节点。换句话说，在广度优先遍历中，节点是按层处理的。这可以通过将深度优先遍历的栈版本中的栈替换为队列来实现。这就是它所需要的全部：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that everything else remains exactly the same as that of the depth-first
    traversal. We still take one element from the queue, process its value and then
    enqueue the children.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其他所有内容都与深度优先遍历完全相同。我们仍然从队列中取出一个元素，处理其值，然后将其子节点入队。
- en: 'To understand why the use of a queue lets us process nodes level by level,
    we need the following analysis:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么使用队列可以让我们按层处理节点，我们需要以下分析：
- en: Root is pushed in the beginning, so root is dequeued first and processed.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点最初被压入，因此根节点首先出队并处理。
- en: When the root is processed, the children of root, that is the nodes in level
    1, get enqueued. This means the level 1 nodes would be dequeued before any further
    levels are dequeued.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当根节点被处理时，根节点的子节点，即第1层的节点，被入队。这意味着第1层的节点会在任何其他层的节点之前出队。
- en: When any node in level 1 is dequeued next, its children, which are the nodes
    of level 2, will all get enqueued. However, since all the nodes in level 1 are
    enqueued in the previous step, the nodes of level 2 will not be dequeued before
    the nodes of level 1 are dequeued. When all the nodes of level 1 are dequeued
    and processed, all the level 2 nodes would be enqueued because they are all children
    of level 1 nodes.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从第1级中下一个节点出队时，其子节点，即第2级的节点，都将被入队。然而，由于第1级中的所有节点在之前步骤中都已入队，因此第2级的节点在未从第1级节点出队之前不会出队。当第1级的所有节点都出队并处理完毕后，所有第2级节点都会被入队，因为它们都是第1级节点的子节点。
- en: This means all the level 2 nodes would be dequeued and processed before any
    nodes of higher levels are processed. When all the level 2 nodes are already processed,
    all the level 3 nodes would be enqueued.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着所有第2级节点都会在处理任何更高级别的节点之前出队并处理。当所有第2级节点都已处理完毕后，所有第3级节点都会被入队。
- en: In a similar manner, in all further levels, all the nodes in a particular level
    will be processed before all the nodes of the next level are processed. In other
    words, the nodes will be process level by level.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以类似的方式，在所有后续级别中，特定级别的所有节点都会在处理下一级别的所有节点之前被处理。换句话说，节点将按级别处理。
- en: The tree abstract data type
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的抽象数据类型
- en: 'Now that we have some idea of the tree, we can define the tree ADT. A tree
    ADT can be defined in multiple ways. We will check out two. In an imperative setting,
    that is, when trees are mutable, we can define a tree ADT as having the following
    operations:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对树有了些了解，我们可以定义树的ADT。树的ADT可以以多种方式定义。我们将检查两种。在命令式设置中，即当树是可变的时，我们可以将树ADT定义为具有以下操作：
- en: Get the root node
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取根节点
- en: Given a node, get its children
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个节点，获取其子节点
- en: This is all that is required to have a model for a tree. We may also include
    some appropriate mutation methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建树模型所需的所有内容。我们还可以包括一些适当的变异方法。
- en: 'The recursive definition for the tree ADT can be as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 树的ADT的递归定义可以如下所示：
- en: 'A tree is an ordered pair containing the following:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树是一个包含以下内容的有序对：
- en: a value
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值
- en: a list of other trees, which are meant to be it's subtrees
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他树的一个列表，这些树是它的子树
- en: 'We can develop a tree implementation in exactly the same way as it is defined
    in the functional tree ADT:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与在函数式树ADT中定义的完全相同的方式开发树实现：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As defined in the ADT, the tree is an ordered pair of a value and a list of
    other trees, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如ADT定义，树是一个值和另一个树列表的有序对，如下所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The implementation is quite simple. The depth-first traversal can be achieved
    using recursive calls to the children, which are indeed subtrees. A tree without
    any children needs to have an empty list of children. With this, we can create
    the functional version of the same tree that we had created for an imperative
    version:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当简单。可以通过对子节点的递归调用来实现深度优先遍历，这些子节点实际上是子树。没有子节点的树需要有一个空的子节点列表。有了这个，我们可以创建与命令式版本相同的相同树的函数式版本：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the end, we can do a depth-first traversal to see if it outputs the same
    tree as before:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以进行深度优先遍历来查看它是否输出与之前相同的树：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Binary tree
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: 'A binary tree is a tree that has a maximum of two children per node. The two
    children can be called the left and the right child of a node. The following figure
    shows an example of a binary tree:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是一种每个节点最多有两个子节点的树。这两个子节点可以称为节点的左子节点和右子节点。以下图显示了二叉树的一个示例：
- en: '![Binary tree](img/00045.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![二叉树](img/00045.jpeg)'
- en: Example binary tree
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例二叉树
- en: 'This particular tree is important mostly because of its simplicity. We can
    create a `BinaryTree` class by inheriting the general tree class. However, it
    will be difficult to stop someone from adding more than two nodes and will take
    a lot of code just to perform the checks. So, instead, we will create a `BinaryTree`
    class from scratch:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的树之所以重要，主要是因为它的简单性。我们可以通过继承通用树类来创建一个`BinaryTree`类。然而，阻止某人添加超过两个节点将非常困难，并且仅为了执行检查就需要大量的代码。因此，我们将从头开始创建一个`BinaryTree`类：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Node` has a very obvious implementation just like the generic tree:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`的实现与通用树非常明显：'
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Adding the root is exactly the same as that for a generic tree, except for
    the fact that we don''t check for the existence of the root. This is just to save
    space; you can implement as required:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加根节点与通用树相同，只是我们不检查根的存在。这只是为了节省空间；您可以按需实现：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following method lets us add a child. It takes a Boolean parameter that
    is `true` when the child to be added is the left child and `false` otherwise:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法让我们添加一个子节点。它接受一个布尔参数，当要添加的子节点是左子节点时为`true`，否则为`false`：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We now create two wrapper methods for specifically adding either the left or
    the right child:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了两个包装方法，专门用于添加左子节点或右子节点：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, the traversal algorithms for a generic tree would also work for this
    special case. However, for a binary tree, the depth-first traversal can be of
    three different types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通用树的遍历算法也适用于这个特殊情况。然而，对于二叉树，深度优先遍历可以是三种不同类型之一。
- en: Types of depth-first traversals
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度优先遍历的类型
- en: 'The depth-first traversal of a binary tree can be of three types according
    to when the parent node is processed with respect to when the child subtrees are
    processed. The orders can be summarized as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据父节点相对于子树处理的时间，二叉树的深度优先遍历可以分为三种类型。顺序可以总结如下：
- en: 'Pre-order traversal:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先序遍历：
- en: Process the parent.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理父节点。
- en: Process the left subtree.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理左子树。
- en: Process the right subtree.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理右子树。
- en: 'In-order traversal:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中序遍历：
- en: Process the left subtree.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理左子树。
- en: Process the parent.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理父节点。
- en: Process the right subtree.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理右子树。
- en: 'Post-order traversal:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后序遍历：
- en: Process the left subtree.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理左子树。
- en: Process the right subtree.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理右子树。
- en: Process the parent.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理父节点。
- en: 'These different traversal types will produce a slightly different ordering
    when traversing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的遍历类型在遍历时会产生略微不同的顺序：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have created an `enum` `DepthFirstTraversalType` to pass to the `traverseDepthFirst`
    method. We process the current node according to its value. Note that the only
    thing that changes is when the processor is called to process a node. Let''s create
    a binary tree and see how the results differ in the case of each ordering:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`enum` `DepthFirstTraversalType`，将其传递给`traverseDepthFirst`方法。我们根据其值处理当前节点。请注意，唯一改变的是调用处理器处理节点的时间。让我们创建一个二叉树，看看在每种排序情况下结果有何不同：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have created the same binary tree as shown in the previous figure. The following
    is the output of the program. Try to relate how the positions are getting affected:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了与之前图示相同的二叉树。以下是程序的输出。尝试关联位置是如何受到影响：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can take a note of the following points while matching the program output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配程序输出时，你可以注意以下要点：
- en: In the case of a pre-order traversal, in any path starting from the root to
    any leaf, a parent node will always be printed before any of the children.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在先序遍历的情况下，从根到任何叶子的任何路径中，父节点总是会先于任何子节点被打印。
- en: In the case of an in-order traversal, if we look at any path from the root to
    a particular leaf, whenever we move from the parent to the left child, the parent's
    processing is postponed. But whenever we move from the parent to the right child,
    the parent is immediately processed.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中序遍历的情况下，如果我们观察从根到特定叶子的任何路径，每当我们从父节点移动到左子节点时，父节点的处理会被推迟。但每当我们从父节点移动到右子节点时，父节点会立即被处理。
- en: In the case of a post-order traversal, all the children are processed before
    any parent is processed.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后序遍历的情况下，所有子节点都会在处理任何父节点之前被处理。
- en: Non-recursive depth-first search
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非递归深度优先搜索
- en: 'The depth-first search we have seen for the general tree is pre-order in the
    sense that the parent node is processed before any of the children are processed.
    So, we can use the same implementation for the pre-order traversal of a binary
    tree:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的通用树的深度优先搜索是先序的，因为父节点是在处理任何子节点之前被处理的。因此，我们可以使用相同的实现来处理二叉树的先序遍历：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have to check whether the children are null. This is because the absence
    of children is expressed as null references instead of an empty list, as in the
    case of a generic tree.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须检查子节点是否为空。这是因为子节点的缺失用空引用表示，而不是像通用树那样用空列表表示。
- en: 'Implementation of the in-order and post-order traversals is a bit tricky. We
    need to suspend processing of the parent node even when the children are expanded
    and pushed to the stack. We can achieve this by pushing each node twice. Once,
    we push it when it is first discovered due to its parent being expanded, and the
    next time we do it when its own children are expanded. So, we must remember which
    of these pushes caused it to be in the stack when it''s popped. This is achieved
    using an additional flag, which is then wrapped up in a class called `StackFrame`.
    The in-order algorithm is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 中序和后序遍历的实现有点复杂。即使在子节点被展开并推入栈中时，我们也需要暂停对父节点的处理。我们可以通过将每个节点推入两次来实现这一点。第一次，我们在由于父节点被展开而首次发现该节点时将其推入，下一次是在其自己的子节点被展开时。因此，我们必须记住这些推入中哪一个导致节点在弹出时位于栈中。这是通过使用一个额外的标志来实现的，然后将其封装在一个名为`StackFrame`的类中。中序算法如下：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that the stack is LIFO, so the thing that needs to be popped later must
    be pushed earlier. The post-order version is extremely similar:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，栈是后进先出（LIFO），所以需要稍后弹出的元素必须先被推入。后序版本极其相似：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that the only thing that has changed is the order of pushing the children
    and the parent. Now we write the following code to test these out:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，唯一改变的是子节点和父节点的推送顺序。现在我们编写以下代码来测试这些方法：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We preserved the recursive versions as well so that we can compare the output,
    which is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也保留了递归版本，以便我们可以比较输出，如下所示：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first three lines are the same as the last three, showing that they produce
    the same result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行与最后三行相同，表明它们产生相同的结果。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned what a tree is. We started out with an actual
    implementation and then designed an ADT out of it. You also learned about a binary
    tree, which is just a tree with a maximum of two children per node. We also saw
    different traversal algorithms for a generic tree. They are depth-first and breadth-first
    traversals. In the case of a binary tree, a depth-first traversal can be done
    in three different ways: pre-order, in-order, and post-order. Even in the case
    of a generic tree, we can find equivalents of the pre-order and post-order traversals
    for a depth-first traversal. However, it is difficult to point to any particular
    equivalent of an in-order traversal as it is possible to have more than two children.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了什么是树。我们从实际实现开始，然后从中设计了一个ADT。你还了解到了二叉树，它就是一个每个节点最多有两个子节点的树。我们还看到了针对通用树的不同的遍历算法。它们是深度优先遍历和广度优先遍历。在二叉树的情况下，深度优先遍历可以以三种不同的方式进行：前序、中序和后序。即使在通用树的情况下，我们也可以找到深度优先遍历的前序和后序遍历的等价形式。然而，指出中序遍历的任何特定等价形式是困难的，因为可能存在超过两个子节点的情况。
- en: In the next chapter, we will see the use of a binary tree in searching, and
    we will see some other ways of searching as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到二叉树在搜索中的应用，同时也会介绍一些其他的搜索方法。
