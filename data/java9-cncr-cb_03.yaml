- en: Thread Synchronization Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步工具
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Controlling concurrent access to one or more copies of a resource
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对资源的一个或多个副本的并发访问
- en: Waiting for multiple concurrent events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待多个并发事件
- en: Synchronizing tasks at a common point
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在公共点同步任务
- en: Running concurrent-phased tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行并发阶段任务
- en: Controlling phase change in concurrent-phased tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制并发阶段任务的相变
- en: Exchanging data between concurrent tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并发任务之间交换数据
- en: Completing and linking tasks asynchronously
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步完成和链接任务
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736), *Basic
    Thread Synchronization*, you learned the concepts of synchronization and critical
    sections. Basically, we talk about synchronization when more than one concurrent
    task shares a resource, for example, an object or an attribute of an object. The
    blocks of code that access this shared resource are called critical sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736)，“基本线程同步”中，你学习了同步和临界区的概念。基本上，当我们谈论同步时，是指多个并发任务共享一个资源，例如一个对象或对象的属性。访问这个共享资源的代码块被称为临界区。
- en: If you don't use appropriate mechanisms, you might have incorrect results, data
    inconsistencies, or error conditions. Therefore, we have to adopt one of the synchronization
    mechanisms provided by the Java language to avoid these problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用适当的机制，可能会得到错误的结果，数据不一致或错误条件。因此，我们必须采用Java语言提供的同步机制之一来避免这些问题。
- en: '[Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736), *Basic
    Thread Synchronization*, taught you about the following basic synchronization
    mechanisms:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736)，“基本线程同步”，介绍了以下基本同步机制：'
- en: The `synchronized` keyword
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized`关键字'
- en: 'The Lock interface and its implementation classes: `ReentrantLock`, `ReentrantReadWriteLock.ReadLock`,
    and `ReentrantReadWriteLock.WriteLock`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁接口及其实现类：`ReentrantLock`、`ReentrantReadWriteLock.ReadLock`和`ReentrantReadWriteLock.WriteLock`
- en: The `StampedLock` class
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StampedLock`类'
- en: 'In this chapter, you will learn how to use high-level mechanisms to synchronize
    multiple threads. These high-level mechanisms are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用高级机制来同步多个线程。这些高级机制如下：
- en: '**Semaphores**: A semaphore is a counter that controls access to one or more
    shared resources. This mechanism is one of the basic tools of concurrent programming
    and is provided by most programming languages.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：信号量是一个计数器，用于控制对一个或多个共享资源的访问。这种机制是并发编程的基本工具之一，并被大多数编程语言提供。'
- en: '**CountDownLatch**: The `CountDownLatch` class is a mechanism provided by the
    Java language that allows a thread to wait for the finalization of multiple operations.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CountDownLatch**：`CountDownLatch`类是Java语言提供的一种机制，允许一个线程等待多个操作的完成。'
- en: '**CyclicBarrier**: The `CyclicBarrier` class is another mechanism provided
    by the Java language that allows the synchronization of multiple threads at a
    common point.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CyclicBarrier**：`CyclicBarrier`类是Java语言提供的另一种机制，允许在公共点同步多个线程。'
- en: '**Phaser**: The `Phaser` class is another mechanism provided by the Java language
    that controls the execution of concurrent tasks divided in phases. All the threads
    must finish one phase before they can continue with the next one.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Phaser**：`Phaser`类是Java语言提供的另一种机制，用于控制分阶段执行的并发任务。所有线程必须完成一个阶段，才能继续下一个阶段。'
- en: '**Exchanger**: The `Exchanger` class is another mechanism provided by the Java
    language that provides a point of data interchange between two threads.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Exchanger**：`Exchanger`类是Java语言提供的另一种机制，提供了两个线程之间数据交换的点。'
- en: '**CompletableFuture**: The `CompletableFuture` class provides a mechanism where
    one or more tasks can wait for the finalization of another task that will be explicitly
    completed in an asynchronous way in future. This class was introduced in Java
    8 and has introduced new methods in Java 9.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CompletableFuture**：`CompletableFuture`类提供了一种机制，其中一个或多个任务可以等待另一个任务完成，该任务将在未来的某个时刻以异步方式显式完成。这个类是在Java
    8中引入的，并在Java 9中引入了新的方法。'
- en: Semaphores are generic synchronization mechanisms that you can use to protect
    any critical section in any problem. Other mechanisms are thought to be used in
    applications with specific features, as described previously. Be sure to select
    the appropriate mechanism according to the characteristics of your application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是通用的同步机制，您可以使用它来保护任何问题中的任何临界区。其他机制被认为适用于具有特定功能的应用程序，如前所述。请确保根据您应用程序的特性选择适当的机制。
- en: This chapter presents seven recipes that will show you how to use the mechanisms
    described.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了七个食谱，将向您展示如何使用所描述的机制。
- en: Controlling concurrent access to one or more copies of a resource
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制对资源的一个或多个副本的并发访问
- en: In this recipe, you will learn how to use the semaphore mechanism provided by
    the Java language. A semaphore is a counter that protects access to one or more
    shared resources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用Java语言提供的信号量机制。信号量是一个保护对一个或多个共享资源访问的计数器。
- en: The concept of a semaphore was introduced by Edsger Dijkstra in 1965 and was
    used for the first time in the THEOS operating system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的概念由Edsger Dijkstra于1965年提出，并首次用于THEOS操作系统。
- en: When a thread wants to access one of the shared resources, it must first acquire
    the semaphore. If the internal counter of the semaphore is greater than 0, the
    semaphore decrements the counter and allows access to the shared resource. A counter
    bigger than 0 implies that there are free resources that can be used, so the thread
    can access and use one of them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程想要访问共享资源之一时，它必须首先获取信号量。如果信号量的内部计数器大于0，信号量会递减计数器并允许访问共享资源。计数器大于0表示有可用的资源，因此线程可以访问并使用其中一个。
- en: Otherwise, if the counter is 0, the semaphore puts the thread to sleep until
    the counter is greater than 0\. A value of 0 in the counter means all the shared
    resources are used by other threads, so the thread that wants to use one of them
    must wait until one is free.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果计数器为0，信号量会将线程置于休眠状态，直到计数器大于0。计数器中的0值表示所有共享资源都被其他线程使用，因此想要使用其中一个的线程必须等待直到其中一个变为空闲。
- en: When the thread has finished using the shared resource, it must release the
    semaphore so that another thread can access the resource. This operation increases
    the internal counter of the semaphore.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程完成对共享资源的使用后，它必须释放信号量，以便另一个线程可以访问资源。此操作会增加信号量的内部计数器。
- en: In this recipe, you will learn how to use the `Semaphore` class to protect more
    than one copy of a resource. You are going to implement an example, which has
    a print queue that could print documents in three different printers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用`Semaphore`类来保护多个资源副本。您将实现一个示例，该示例有一个打印队列，可以在三个不同的打印机上打印文档。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用Eclipse IDE实现。如果您使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `PrintQueue` that will implement the print queue:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PrintQueue`的类，该类将实现打印队列：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class will have three private attributes. A semaphore named `semaphore`,
    an array of Booleans named `freePrinters`, and a lock named `lockPrinters`, as
    shown in the following code snippet:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此类将具有三个私有属性。一个名为`semaphore`的信号量，一个名为`freePrinters`的布尔数组，以及一个名为`lockPrinters`的锁，如下代码片段所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the constructor of the class. It initializes the three attributes
    of the class, as shown in the following code snippet:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它初始化类的三个属性，如下代码片段所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement the `printJob()` method that will simulate the printing of a document.
    It receives an object called `document` as a parameter:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现模拟打印文档的`printJob()`方法。它接收一个名为`document`的对象作为参数：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First of all, the `printJob()` method calls the `acquire()` method to acquire
    access to the semaphore. As this method can throw an `InterruptedException` exception,
    you must include the code to process it:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`printJob()`方法调用`acquire()`方法以获取对信号量的访问权限。由于此方法可能会抛出`InterruptedException`异常，您必须包括处理它的代码：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, get the number of the printers assigned to print this job, using the
    private method `getPrinter()`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用私有方法`getPrinter()`获取分配给打印此作业的打印机数量：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, implement the lines that simulate the printing of a document waiting
    for a random period of time:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过创建一个名为`Main`的类并实现`main()`方法来实现示例的主要类：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, release the semaphore by calling the `release()` method and marking
    the printer used as free, and assign `true` to the corresponding index in the
    `freePrinters` array:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用`release()`方法释放信号量，并将使用的打印机标记为空闲，并将`true`赋值给`freePrinters`数组中相应的索引：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, implement the `getPrinter()` method. It''s a private method that returns
    an `int` value and has no parameters:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，实现`getPrinter()`方法。这是一个私有方法，它返回一个`int`值，没有参数：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, declare an `int` variable to store the index of the printer:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明一个用于存储打印机索引的`int`变量：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, get access to the `lockPrinters` object:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，获取对`lockPrinters`对象的访问权限：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Post this, find the first true value in the `freePrinters` array and save its
    index in a variable. Modify this value to `false` because this printer will be
    busy:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`freePrinters`数组中找到第一个真值，并将其索引保存到变量中。将此值修改为`false`，因为此打印机将忙碌：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, free the `lockPrinters` object and return the index of the true value:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，释放`lockPrinters`对象并返回真值索引：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, create a class called `Job` and specify that it implements the `Runnable`
    interface. This class implements the job that will send a document to the printer:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，创建一个名为`Job`的类，并指定它实现`Runnable`接口。此类实现了将文档发送到打印机的作业：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare a `PrintQueue` object. Call it `printQueue`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Semaphore`类有三种额外的`acquire()`方法版本：'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Implement the constructor of the class. It initializes the `PrintQueue` object
    declared in the class:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它初始化类中声明的`PrintQueue`对象：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Implement the `run()` method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`run()`方法：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, this method writes a message to the console that shows that the job
    has started its execution:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，此方法向控制台写入一条消息，显示作业已开始执行：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, it calls the `printJob()` method of the `PrintQueue` object:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它调用`PrintQueue`对象的`printJob()`方法：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, the method writes a message to the console that shows that it has
    finished its execution:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，此方法向控制台写入一条消息，显示作业已开始执行：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, implement the main class of the example by creating a class named `Main`
    and implementing the `main()` method:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过创建一个名为`Main`的类并实现`main()`方法来实现示例的主要类：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `PrintQueue` object named `printQueue`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`printQueue`的`PrintQueue`对象：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create 12 threads. Each one of these threads will execute a `Job` object that
    will send a document to the print queue:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建12个线程。每个线程将执行一个`Job`对象，该对象将发送文档到打印队列：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, start the 12 threads:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动12个线程：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The key to this example is the `printJob()` method of the `PrintQueue` class.
    This method shows three steps you must follow when you use a semaphore to implement
    a critical section and protect access to a shared resource:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在`freePrinters`数组中找到第一个真值，并将其索引保存到变量中。将此值修改为`false`，因为此打印机将忙碌：
- en: First, you acquire the semaphore with the `acquire()` method.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`acquire()`方法获取信号量。
- en: Then, you do the necessary operations with the shared resource.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对共享资源进行必要的操作。
- en: Finally, release the semaphore with the `release()` method.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`release()`方法释放信号量。
- en: Another important point in this example is the constructor of the `PrintQueue`
    class and the initialization of the `Semaphore` object. You pass the value `3`
    as the parameter of this constructor, so you are creating a semaphore that will
    protect three resources. The first three threads that call the `acquire()` method
    will get access to the critical section of this example, while the rest will be
    blocked. When a thread finishes a critical section and releases the semaphore,
    another thread will acquire it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，另一个重要点是`PrintQueue`类的构造函数和`Semaphore`对象的初始化。您将值`3`作为此构造函数的参数传递，因此您正在创建一个将保护三个资源的信号量。前三个调用`acquire()`方法的线程将获得此示例的关键部分访问权限，其余的将被阻塞。当一个线程完成关键部分并释放信号量时，另一个线程将获取它。
- en: 'The following screenshot shows the output of an execution of this example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的执行输出：
- en: '![](img/00020.gif)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: 实现类的构造函数。它初始化类中声明的`PrintQueue`对象：
- en: You can see how the first three print jobs start at the same time. Then, when
    one printer finishes its job, another one begins.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到前三个打印作业是同时开始的。然后，当一个打印机完成其作业时，另一个打印机开始工作。
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Semaphore` class has three additional versions of the `acquire()` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Semaphore`类有三种额外的`acquire()`方法版本：'
- en: '`acquireUninterruptibly()`: The `acquire()` method, when the internal counter
    of the semaphore is `0`, blocks the thread until the semaphore is released. During
    this period, the thread may be interrupted; if this happens, the method will throw
    an `InterruptedException` exception. This version of the `acquire` operation ignores
    the interruption of the thread and doesn''t throw any exceptions.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acquireUninterruptibly()`: `acquire()` 方法，当信号量的内部计数器为 `0` 时，会阻塞线程直到信号量被释放。在此期间，线程可能会被中断；如果发生这种情况，该方法将抛出
    `InterruptedException` 异常。这个版本的 `acquire` 操作忽略线程的中断，并且不会抛出任何异常。'
- en: '`tryAcquire()`: This method tries to acquire the semaphore. If it can, it returns
    the `true` value. But if it can''t, it returns `false` instead of being blocked
    and waits for the release of the semaphore. It''s your responsibility to take
    correct action based on the return value.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryAcquire()`: 此方法尝试获取信号量。如果可以，它返回 `true` 值。但如果不能，它将返回 `false` 而不是被阻塞并等待信号量的释放。根据返回值采取正确的行动是您的责任。'
- en: '`tryAcquire(long timeout, TimeUnit unit)`: This method is equivalent to the
    previous one, but it waits for the semaphore for the period of time specified
    in the parameters. If the period of time ends and the method hasn''t acquired
    the semaphore, it will return `false`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryAcquire(long timeout, TimeUnit unit)`: 此方法与前面的方法等效，但它等待参数中指定的时间段的信号量。如果时间结束且方法尚未获取信号量，它将返回
    `false`。'
- en: The `acquire()`, `acquireUninterruptibly()`, `tryAcquire()`, and `release()`
    methods have an additional version, which has an `int` parameter. This parameter
    represents the number of permits the thread that uses them wants to acquire or
    release, in other words, the number of units that this thread wants to delete
    or add to the internal counter of the semaphore.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire()`、`acquireUninterruptibly()`、`tryAcquire()` 和 `release()` 方法有一个额外的版本，它有一个
    `int` 参数。此参数表示使用它们的线程想要获取或释放的许可证数量，换句话说，就是线程想要从信号量的内部计数器中删除或添加的单位数量。'
- en: In the case of the `acquire()`, `acquireUninterruptibly()`, and `tryAcquire()`
    methods, if the value of the counter is less than the number passed as parameter value,
    the thread will be blocked until the counter gets the same value or a greater
    one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `acquire()`、`acquireUninterruptibly()` 和 `tryAcquire()` 方法的案例中，如果计数器的值小于作为参数值传递的数字，线程将被阻塞，直到计数器达到相同的值或更大的值。
- en: Fairness in semaphores
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量的公平性
- en: The concept of fairness is used by the Java language in all classes that can
    have various threads blocked and are waiting for the release of a synchronization
    resource (for example, a semaphore). The default mode is called **non-fair mode**.
    In this mode, when the synchronization resource is released, one of the waiting
    threads is selected and is given this resource; however, it's selected without
    any criteria. Fair mode, on the other hand, changes this behavior and selects
    the thread that has been waiting for the longest period of time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 公平的概念被 Java 语言用于所有可能具有各种线程阻塞并等待同步资源（例如，信号量）释放的类。默认模式称为 **非公平模式**。在此模式下，当同步资源被释放时，会选择一个等待的线程并分配此资源；然而，选择是没有任何标准的。另一方面，公平模式改变了这种行为，并选择等待时间最长的线程。
- en: As it occurs with other classes, the `Semaphore` class admits a second parameter
    in its constructor. This parameter must take a Boolean value. If you give it a
    false value, you are creating a semaphore that will work in non-fair mode. You
    will get the same behavior if you don't use this parameter. If you give it a true
    value, you are creating a semaphore that will work in fair mode.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他类一样，`Semaphore` 类在其构造函数中接受一个第二个参数。此参数必须接受一个布尔值。如果您给它一个 `false` 值，您将创建一个在非公平模式下工作的信号量。如果您不使用此参数，您将获得相同的行为。如果您给它一个
    `true` 值，您将创建一个在公平模式下工作的信号量。
- en: See also
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Monitoring a Lock interface* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 9 章](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736) 中 *监控锁接口* 的配方，*测试并发应用程序*'
- en: The *Synchronizing a block of code with a lock* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 2 章](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736) 中 *使用锁同步代码块*
    的配方，*基本线程同步*'
- en: Waiting for multiple concurrent events
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待多个并发事件
- en: The Java concurrency API provides a class that allows one or more threads to
    wait until a set of operations are made. It's called the `CountDownLatch` class.
    This class is initialized with an integer number, which is the number of operations
    the threads are going to wait for. When a thread wants to wait for the execution
    of these operations, it uses the `await()` method. This method puts the thread
    to sleep until the operations are completed. When one of these operations finishes,
    it uses the `countDown()` method to decrement the internal counter of the `CountDownLatch`
    class. When the counter arrives at `0`, the class wakes up all the threads that
    were sleeping in the `await()` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了一个允许一个或多个线程等待直到一组操作完成的类。它被称为`CountDownLatch`类。这个类使用一个整数初始化，这是线程将要等待的操作数。当线程想要等待这些操作的执行时，它使用`await()`方法。此方法将线程置于休眠状态，直到操作完成。当这些操作中的任何一个完成时，它使用`countDown()`方法来递减`CountDownLatch`类的内部计数器。当计数器到达`0`时，该类唤醒在`await()`方法中休眠的所有线程。
- en: In this recipe, you will learn how to use the `CountDownLatch` class to implement
    a video conference system. The video conference system should wait for the arrival
    of all the participants before it begins.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用`CountDownLatch`类来实现视频会议系统。视频会议系统应在开始之前等待所有参与者的到达：
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Videoconference` and specify that it implements the `Runnable`
    interface. This class will implement the video conference system:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Videoconference`的类，并指定它实现`Runnable`接口。这个类将实现视频会议系统：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare a `CountDownLatch` object named controller:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`controller`的`CountDownLatch`对象：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement the constructor of the class that initializes the `CountDownLatch`
    attribute. The `Videoconference` class will wait for the arrival of the number
    of participants received as a parameter:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化`CountDownLatch`属性。`Videoconference`类将等待接收到的参与者数量到达：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the `arrive()` method. This method will be called each time a participant
    arrives for the video conference. It receives a `String` type named `name` as
    the parameter:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现参与者的`arrive()`方法。该方法将在每次参与者到达视频会议时被调用。它接收一个名为`name`的`String`类型参数：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, it writes a message with the parameter it has received:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它使用接收到的参数写一条消息：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, it calls the `countDown()` method of the `CountDownLatch` object:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它调用`CountDownLatch`对象的`countDown()`方法：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, it writes another message with the number of participants whose arrival
    is pending, using the `getCount()` method of the `CountDownLatch` object:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它使用`CountDownLatch`对象的`getCount()`方法写另一条消息，其中包含等待到达的参与者数量：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, implement the main method of the video conference system. It''s the `run()`
    method that every `Runnable` object must have:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现视频会议系统的`main`方法。这是每个`Runnable`对象必须有的`run()`方法：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'First, use the `getCount()` method to write a message with the number of participants
    in the video conference:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`getCount()`方法写一条消息，其中包含视频会议中的参与者数量：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, use the `await()` method to wait for all the participants. As this method
    can throw an `InterruptedException` exception, you must include the code to process
    it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`await()`方法等待所有参与者。由于此方法可能会抛出`InterruptedException`异常，你必须包括处理它的代码：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, write a message to indicate that all the participants have arrived:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，写一条消息来表明所有参与者都已到达：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, create the `Participant` class and specify that it implements the `Runnable`
    interface. This class represents each participant in the video conference:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`Participant`类，并指定它实现`Runnable`接口。这个类代表视频会议中的每个参与者：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Declare a private `Videoconference` attribute named `conference`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`conference`的私有`Videoconference`属性：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Declare a private `String` attribute named `name`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement the constructor of the class that initializes both the preceding
    attributes:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化前面提到的两个属性：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the `run()` method of the participants:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现参与者的`run()`方法：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First, put the thread to sleep for a random period of time:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让线程随机休眠一段时间：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, use the `arrive()` method of the `Videoconference` object to indicate
    the arrival of this participant:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`Videoconference`对象的`arrive()`方法来指示这个参与者的到达：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, implement the main class of the example by creating a class named
    `Main` and adding the `main()` method to it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, create a `Videoconference` object named `conference` that waits for 10
    participants:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`conference`的`Videoconference`对象，它等待10个参与者：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create `Thread` to run this `Videoconference` object and start it:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Thread`来运行这个`Videoconference`对象并启动它：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create 10 `Participant` objects, a `Thread` object to run each of them, and
    start all the threads:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建10个`Participant`对象，一个用于运行每个对象的`Thread`对象，并启动所有线程：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `CountDownLatch` class has three basic elements:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch`类有三个基本元素：'
- en: The initialization value that determines how many events the `CountDownLatch`
    object waits for
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定`CountDownLatch`对象等待多少事件的初始化值
- en: The `await()` method, called by the threads that wait for the finalization of
    all the events
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由等待所有事件最终化的线程调用的`await()`方法
- en: The `countDown()` method, called by the events when they finish their execution
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事件完成执行时调用的`countDown()`方法
- en: When you create a `CountDownLatch` object, it uses the constructor's parameter
    to initialize an internal counter. Every time a thread calls the `countDown()`
    method, the `CountDownLatch` object decrements the internal counter in one unit.
    When the internal counter reaches 0, the `CountDownLatch` object wakes up all
    the threads that were waiting in the `await()` method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`CountDownLatch`对象时，它使用构造函数的参数来初始化一个内部计数器。每次一个线程调用`countDown()`方法时，`CountDownLatch`对象将内部计数器减一。当内部计数器达到`0`时，`CountDownLatch`对象唤醒所有在`await()`方法中等待的线程。
- en: There's no way to re-initialize the internal counter of the `CountDownLatch`
    object or modify its value. Once the counter is initialized, the only method you
    can use to modify its value is the `countDown()` method explained earlier. When
    the counter reaches `0`, all the calls to the `await()` method are returned immediately
    and all subsequent calls to the `countDown()` method have no effect.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法重新初始化`CountDownLatch`对象的内部计数器或修改其值。一旦计数器初始化，你可以用来修改其值的唯一方法是前面解释过的`countDown()`方法。当计数器达到`0`时，所有对`await()`方法的调用将立即返回，并且所有后续对`countDown()`方法的调用都没有效果。
- en: 'However, there are some differences with respect to other synchronization methods,
    which are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其他同步方法相比，有一些不同之处，如下所示：
- en: The `CountDownLatch` mechanism is not used to protect a shared resource or a
    critical section. It is used to synchronize one or more threads with the execution
    of various tasks.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`机制不是用来保护共享资源或临界区的。它是用来同步一个或多个线程与各种任务的执行。'
- en: It only admits one use. As explained earlier, once the counter of `CountDownLatch`
    arrives at `0`, all the calls to its methods have no effect. You have to create
    a new object if you want to do the same synchronization again.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只允许一个用途。如前所述，一旦`CountDownLatch`的计数器达到`0`，对其方法的任何调用都将没有效果。如果你想再次进行相同的同步，你必须创建一个新的对象。
- en: 'The following screenshot shows the output of an execution of the example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了示例的执行输出：
- en: '![](img/00021.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: You can see how participants arrive, and once the internal counter arrives at
    `0`, the `CountDownLatch` object wakes up the `Videoconference` object that writes
    the messages indicating that the video conference should start.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到参与者是如何到达的，一旦内部计数器达到`0`，`CountDownLatch`对象就会唤醒写入消息的`Videoconference`对象，表明视频会议应该开始。
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `CountDownLatch` class has another version of the `await()` method, which
    is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch`类还有一个版本的`await()`方法，如下所示：'
- en: '`await(long time, TimeUnit unit)`: In this method, the thread will continue
    to sleep until it''s interrupted, that is, either the internal counter of `CountDownLatch`
    arrives at `0` or the specified time passes. The `TimeUnit` class is an enumeration
    with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`,
    `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await(long time, TimeUnit unit)`：在这个方法中，线程将继续睡眠，直到它被中断，即`CountDownLatch`的内部计数器达到`0`或指定的时长过去。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。'
- en: Synchronizing tasks in a common point
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个共同点上同步任务
- en: The Java concurrency API provides a synchronizing utility that allows the synchronization
    of two or more threads at a determined point. It's the `CyclicBarrier` class.
    This class is similar to the `CountDownLatch` class explained in the *Waiting
    for multiple concurrent events* recipe in this chapter, but it presents some differences
    that make it a more powerful class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Java 并发 API 提供了一个同步实用工具，允许在确定点同步两个或更多线程。它是 `CyclicBarrier` 类。这个类与本章中 *等待多个并发事件*
    食谱中解释的 `CountDownLatch` 类类似，但它有一些差异，使其成为一个更强大的类。
- en: The `CyclicBarrier` class is initialized with an integer number, which is the
    number of threads that will be synchronized at a determined point. When one of
    these threads arrives at the determined point, it calls the `await()` method to
    wait for the other threads. When the thread calls this method, the `CyclicBarrier`
    class blocks the thread that is sleeping until the other threads arrive. When
    the last thread calls the `await()` method of the `CyclicBarrier` object, it wakes
    up all the threads that were waiting and continues with its job.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier` 类使用一个整数初始化，这是将在确定点同步的线程数。当这些线程中的任何一个到达确定点时，它调用 `await()` 方法等待其他线程。当线程调用此方法时，`CyclicBarrier`
    类阻塞正在睡眠的线程，直到其他线程到达。当最后一个线程调用 `CyclicBarrier` 对象的 `await()` 方法时，它唤醒所有等待的线程并继续其工作。'
- en: One interesting advantage of the `CyclicBarrier` class is that you can pass
    an additional `Runnable` object as an initialization parameter, and the `CyclicBarrier`
    class executes this object as a thread when all the threads arrive at the common
    point. This characteristic makes this class adequate for parallelization of tasks
    using the divide and conquer programming technique.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier` 类的一个有趣的优势是，您可以传递一个额外的 `Runnable` 对象作为初始化参数，当所有线程到达共同点时，`CyclicBarrier`
    类将执行此对象作为线程。这一特性使得这个类适合使用分而治之编程技术并行化任务。'
- en: In this recipe, you will learn how to use the `CyclicBarrier` class to synchronize
    a set of threads at a determined point. You will also use a `Runnable` object
    that will be executed after all the threads arrive at this point. In the example,
    you will look for a number in a matrix of numbers. The matrix will be divided
    into subsets (using the divide and conquer technique), so each thread will look
    for the number in one subset. Once all the threads have finished their respective
    jobs, a final task will unify their results.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用 `CyclicBarrier` 类在确定点同步一组线程。您还将使用一个 `Runnable` 对象，该对象将在所有线程到达此点后执行。在示例中，您将在数字矩阵中寻找一个数字。矩阵将被分成子集（使用分而治之技术），因此每个线程将在一个子集中寻找数字。一旦所有线程完成各自的工作，一个最终任务将统一他们的结果。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: 'Follow these steps to implement the example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Start the example by implementing two auxiliary classes. First, create a class
    named `MatrixMock`. This class will generate a random matrix of numbers between
    one and 10, where the threads will look for a number:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现两个辅助类来开始示例。首先，创建一个名为 `MatrixMock` 的类。这个类将生成一个介于 1 和 10 之间的随机数字矩阵，线程将在其中寻找一个数字：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Declare a private `int` matrix named `data`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `data` 的私有 `int` 矩阵：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement the constructor of the class. This constructor will receive the number
    of rows of the matrix, the length of each row, and the number we are going to
    look for as parameters. All the three parameters are of the type `int`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。这个构造函数将接收矩阵的行数、每行的长度以及我们要寻找的数字作为参数。所有三个参数都是 `int` 类型：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Initialize the variables and objects used in the constructor:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化在构造函数中使用的变量和对象：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Fill the matrix with random numbers. Each time you generate a number, compare
    it with the number you are going to look for. If they are equal, increment the
    counter:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用随机数字填充矩阵。每次生成一个数字时，将其与要寻找的数字进行比较。如果它们相等，增加计数器：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, print a message in the console, which shows the number of occurrences
    of the number you are going to look for in the generated matrix. This message
    will be used to check that the threads get the correct result:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在控制台打印一条消息，显示将在生成的矩阵中查找的数字的出现次数。此消息将用于检查线程是否得到正确的结果：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Implement the `getRow()` method. This method receives an `int` parameter with
    the number of a rows in the matrix; it returns the row if it exists and returns
    `null` if it doesn''t:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `getRow()` 方法。此方法接收一个表示矩阵中行号的 `int` 参数；如果存在该行，则返回该行，如果不存在，则返回 `null`：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now implement a class named `Results`. This class will store, in an array,
    the number of occurrences of the searched number in each row of the matrix:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现一个名为 `Results` 的类。此类将存储在数组中，以存储矩阵每行中搜索数字的出现次数：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Declare a private `int` array named `data`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `data` 的私有 `int` 数组：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the constructor of the class. This constructor receives an integer
    parameter with the number of elements of the array:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。此构造函数接收一个表示数组元素数量的整数参数：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Implement the `setData()` method. This method receives a position in the array
    and a value as a parameter, and it establishes the value of that position in the
    array:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `setData()` 方法。此方法接收一个数组位置和一个值作为参数，并设置数组中该位置的价值：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Implement the `getData()` method. This method returns the array with the array
    of the results:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `getData()` 方法。此方法返回包含结果数组的数组：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that you have the auxiliary classes, it''s time to implement threads. First,
    implement the `Searcher` class. This class will look for a number in the determined
    rows of the matrix of random numbers. Create a class named `Searcher` and specify
    that it implements the `Runnable` interface:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有了辅助类，是时候实现线程了。首先，实现 `Searcher` 类。此类将在随机数字矩阵的确定行中查找数字。创建一个名为 `Searcher` 的类，并指定它实现
    `Runnable` 接口：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Declare two private `int` attributes, namely `firstRow` and `lastRow`. These
    two attributes will determine the subset of rows where this object will look for
    the number:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有 `int` 属性，即 `firstRow` 和 `lastRow`。这两个属性将确定此对象将搜索数字的行子集：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Declare a private `MatrixMock` attribute named `mock`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `mock` 的私有 `MatrixMock` 属性：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Declare a private `Results` attribute named `results`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `results` 的私有 `Results` 属性：
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Declare a private `int` attribute named `number`, which will store the number
    we are going to look for:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `number` 的私有 `int` 属性，该属性将存储将要查找的数字：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Declare a `CyclicBarrier` object named `barrier`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `barrier` 的 `CyclicBarrier` 对象：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Implement the constructor of the class that initializes all the attributes
    declared previously:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，该构造函数初始化之前声明的所有属性：
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Implement the `run()` method that will search for the number. It uses an internal
    variable called `counter` that will store the number of occurrences of the number
    in each row:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `run()` 方法，该方法将搜索数字。它使用一个名为 `counter` 的内部变量，该变量将存储每行中数字出现的次数：
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Print a message in the console with the rows assigned to this task:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台打印一条消息，显示分配给此任务的任务行：
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Process all the rows assigned to this thread. For each row, count the number
    of occurrences of the number you are searching for and store this number in the
    corresponding position of the `Results` object:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理分配给此线程的所有行。对于每一行，计算要搜索的数字的出现次数，并将此数字存储在 `Results` 对象的相应位置：
- en: '[PRE67]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Print a message in the console to indicate that this object has finished searching:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台打印一条消息，指示此对象已完成搜索：
- en: '[PRE68]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Call the `await()` method of the `CyclicBarrier` object and add the necessary
    code to process the `InterruptedException` and `BrokenBarrierException` exceptions
    that this method can throw:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `CyclicBarrier` 对象的 `await()` 方法，并添加必要的代码来处理此方法可能抛出的 `InterruptedException`
    和 `BrokenBarrierException` 异常：
- en: '[PRE69]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now implement the class that calculates the total number of occurrences of
    the number in the matrix. This class uses the `Results` object that stores the
    number of appearances of the number in each row of the matrix to make the calculation.
    Create a class named `Grouper` and specify that it implements the `Runnable` interface:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现一个计算矩阵中数字出现总数的类。此类使用存储矩阵每行中数字出现次数的 `Results` 对象来进行计算。创建一个名为 `Grouper` 的类，并指定它实现
    `Runnable` 接口：
- en: '[PRE70]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Declare a private `Results` attribute named `results`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `results` 的私有 `Results` 属性：
- en: '[PRE71]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Implement the constructor of the class that initializes the `Results` attribute:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，该构造函数初始化 `Results` 属性：
- en: '[PRE72]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Implement the `run()` method that will calculate the total number of occurrences
    of the number in the array of results:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `run()` 的方法，该方法将计算数组中数字出现的总次数：
- en: '[PRE73]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Declare an `int` variable and write a message to the console to indicate the
    start of the process:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `int` 变量并向控制台写入一条消息以指示过程的开始：
- en: '[PRE74]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Get the number of occurrences of the number in each row using the `getData()`
    method of the `results` object. Then, process all the elements of the array and
    add their value to the `finalResult` variable:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `results` 对象的 `getData()` 方法获取每行中数字的出现次数。然后，处理数组的所有元素并将它们的值添加到 `finalResult`
    变量中：
- en: '[PRE75]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Print the result in the console:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台打印结果：
- en: '[PRE76]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, implement the main class of the example by creating a class named
    `Main` and adding the `main()` method to it:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE77]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Declare and initialize five constants to store the parameters of the application:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化五个常量以存储应用程序的参数：
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a `MatrixMock` object named `mock`. It will have 10,000 rows of 1,000
    elements. Now, you are going to search for the number five:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `mock` 的 `MatrixMock` 对象。它将有 10,000 行，每行有 1,000 个元素。现在，你将搜索数字五：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a `Results` object named `results`. It will have 10,000 elements:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `results` 的 `Results` 对象。它将有 10,000 个元素：
- en: '[PRE80]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a `Grouper` object named `grouper`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `grouper` 的 `Grouper` 对象：
- en: '[PRE81]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a `CyclicBarrier` object called `barrier`. This object will wait for
    five threads. When these five threads finish, it will execute the `Grouper` object
    created previously:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `barrier` 的 `CyclicBarrier` 对象。此对象将等待五个线程。当这五个线程完成时，它将执行之前创建的 `Grouper`
    对象：
- en: '[PRE82]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create five `Searcher` objects, five threads to execute them, and start the
    five threads:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个 `Searcher` 对象，五个线程来执行它们，并启动这五个线程：
- en: '[PRE83]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the result of an execution of this example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的执行结果：
- en: '![](img/00022.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: The problem resolved in the example is simple. We have a big matrix of random
    integers, and you want to know the total number of occurrences of a number in
    this matrix. To get better performance, we used the divide and conquer technique.
    We divided the matrix into five subsets and used a thread to look for the number
    in each subset. These threads are objects of the `Searcher` class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中解决的问题很简单。我们有一个由随机整数组成的大的矩阵，你想要知道这个矩阵中数字出现的总次数。为了获得更好的性能，我们使用了分而治之的技术。我们将矩阵分为五个子集，并使用一个线程在每个子集中查找数字。这些线程是
    `Searcher` 类的对象。
- en: We used a `CyclicBarrier` object to synchronize the completion of the five threads
    and execute the `Grouper` task to process partial results and calculate the final
    one.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `CyclicBarrier` 对象来同步五个线程的完成，并执行 `Grouper` 任务以处理部分结果并计算最终结果。
- en: As mentioned earlier, the `CyclicBarrier` class has an internal counter to control
    how many threads need to arrive at the synchronization point. Each time a thread
    arrives at the synchronization point, it calls the `await()` method to notify
    the `CyclicBarrier` object that a thread has arrived at its synchronization point.
    `CyclicBarrier` puts the thread to sleep until all the threads reach the synchronization
    point.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`CyclicBarrier` 类有一个内部计数器来控制需要到达同步点的线程数量。每次线程到达同步点时，它都会调用 `await()` 方法来通知
    `CyclicBarrier` 对象一个线程已到达其同步点。`CyclicBarrier` 将线程置于休眠状态，直到所有线程都达到同步点。
- en: When all the threads have arrived, the `CyclicBarrier` object wakes up all the
    threads that were waiting in the `await()` method. Optionally, it creates a new
    thread that executes a `Runnable` object passed as the parameter in the construction
    of `CyclicBarrier` (in our case, a `Grouper` object) to do additional tasks.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有线程到达时，`CyclicBarrier` 对象唤醒在 `await()` 方法中等待的所有线程。可选地，它创建一个新的线程来执行在 `CyclicBarrier`
    构造函数中作为参数传递的 `Runnable` 对象（在我们的情况下，是一个 `Grouper` 对象）以执行额外任务。
- en: There's more...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `CyclicBarrier` class has another version of the `await()` method:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier` 类有另一个版本的 `await()` 方法：'
- en: '`await(long time, TimeUnit unit)`: In this method, the thread will continue
    to sleep until it''s interrupted, that is, either the internal counter of `CyclicBarrier`
    arrives at `0` or the specified time passes. The `TimeUnit` class is an enumeration
    with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`,
    `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await(long time, TimeUnit unit)`: 在这个方法中，线程将继续休眠，直到它被中断，也就是说，要么`CyclicBarrier`的内部计数器达到`0`，要么指定的时长过去。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。'
- en: This class also provides the `getNumberWaiting()` method that returns the number
    of threads that are blocked in the `await()` method and the `getParties()` method
    that returns the number of tasks that are going to be synchronized with `CyclicBarrier`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类还提供了`getNumberWaiting()`方法，它返回在`await()`方法中被阻塞的线程数，以及`getParties()`方法，它返回将要与`CyclicBarrier`同步的任务数。
- en: Resetting a CyclicBarrier object
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置CyclicBarrier对象
- en: The `CyclicBarrier` class has some points in common with the `CountDownLatch`
    class, but they also have some differences. One of the most important differences
    is that a `CyclicBarrier` object can be reset to its initial state, assigning
    to its internal counter the value with which it was initialized.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类与`CountDownLatch`类有一些共同点，但它们也有一些不同之处。最重要的不同之处在于，一个`CyclicBarrier`对象可以被重置到其初始状态，将其内部计数器设置为初始化时的值。'
- en: This reset operation can be done using the `reset()` method of the `CyclicBarrier`
    class. When this occurs, all the threads that were waiting in the `await()` method
    receive a `BrokenBarrierException` exception. This exception was processed in
    the example presented in this recipe by printing the stack trace; however, in
    a more complex application, it could perform some other operation, such as restarting
    the execution or recovering the operation at the point it was interrupted.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重置操作可以使用`CyclicBarrier`类的`reset()`方法来完成。当发生这种情况时，所有在`await()`方法中等待的线程都会收到`BrokenBarrierException`异常。这个异常在本配方中通过打印堆栈跟踪来处理；然而，在一个更复杂的应用程序中，它可能执行其他操作，例如重新启动执行或恢复到中断时的操作点。
- en: Broken CyclicBarrier objects
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 损坏的CyclicBarrier对象
- en: A `CyclicBarrier` object can be in a special state denoted by the broken state.
    When there are various threads waiting in the `await()` method and one of them
    is interrupted, the one that is interrupted receives an `InterruptedException`
    exception, but other threads receive a `BrokenBarrierException` exception; `CyclicBarrier`
    is placed in the broken state.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`CyclicBarrier`对象可以处于一个特殊状态，称为损坏状态。当有多个线程在`await()`方法中等待时，其中一个线程被中断，中断的线程会收到`InterruptedException`异常，但其他线程会收到`BrokenBarrierException`异常；`CyclicBarrier`被置于损坏状态。
- en: The `CyclicBarrier` class provides the `isBroken()` method. It returns `true`
    if the object is in the broken state; otherwise, it returns `false`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类提供了`isBroken()`方法。如果对象处于损坏状态，则返回`true`；否则返回`false`。'
- en: See also
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Waiting for multiple concurrent events* recipe in this chapter
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*等待多个并发事件*配方
- en: Running concurrent-phased tasks
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行并发阶段任务
- en: One of the most complex and powerful functionalities offered by the Java concurrency
    API is the ability to execute concurrent-phased tasks using the `Phaser` class.
    This mechanism is useful when we have some concurrent tasks divided into steps.
    The `Phaser` class provides us with a mechanism to synchronize threads at the
    end of each step, so no thread will start with the second step until all the threads
    have finished the first one.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供的最复杂和强大的功能之一是使用`Phaser`类执行并发阶段任务的能力。这种机制在我们有一些被分为步骤的并发任务时非常有用。`Phaser`类为我们提供了一种机制，在每一步结束时同步线程，因此没有线程会开始第二步，直到所有线程都完成了第一步。
- en: As with other synchronization utilities, we have to initialize the `Phaser`
    class with the number of tasks that participate in the synchronization operation,
    but we can dynamically modify this number by either increasing or decreasing it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他同步工具一样，我们必须使用参与同步操作的任务数量来初始化`Phaser`类，但我们可以通过增加或减少这个数字来动态地修改这个数字。
- en: 'In this recipe, you will learn how to use the `Phaser` class to synchronize
    three concurrent tasks. The three tasks look for files with the extension `.log`
    modified in the last 24 hours in three different folders and their subfolders.
    This task is divided into three steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用`Phaser`类来同步三个并发任务。这三个任务在三个不同的文件夹及其子文件夹中查找扩展名为`.log`且在过去24小时内修改的文件。此任务分为三个步骤：
- en: Get a list of the files with the extension `.log` in the assigned folder and
    its subfolders.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取指定文件夹及其子文件夹中扩展名为`.log`的文件列表。
- en: Filter the list created in the first step by deleting the files modified more
    than 24 hours ago.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过删除24小时前修改的文件来过滤第一步创建的列表。
- en: Print the results in the console.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台打印结果。
- en: At the end of step 1 and step 2, we check whether the list has any elements
    or not. If it doesn't, the thread ends its execution and is eliminated from the
    `Phaser` class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1和步骤2结束时，我们检查列表中是否有任何元素。如果没有，线程结束其执行并被从`Phaser`类中删除。
- en: Getting ready
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例是用Eclipse IDE实现的。如果你使用Eclipse或NetBeans等其他IDE，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `FileSearch` and specify that it implements the `Runnable`
    interface. This class implements the operation of searching for files with a determined
    extension modified in the last 24 hours in a folder and its subfolders:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FileSearch`的类，并指定它实现`Runnable`接口。此类实现了在文件夹及其子文件夹中搜索具有指定扩展名且在过去24小时内修改的文件的操作：
- en: '[PRE84]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Declare a private `String` attribute to store the folder in which the search
    operation will begin:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`String`属性来存储搜索操作将开始的文件夹：
- en: '[PRE85]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Declare another private `String` attribute to store the extension of the files
    we are going to look for:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明另一个私有的`String`属性来存储我们将要查找的文件的扩展名：
- en: '[PRE86]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Declare a private `List` attribute to store the full path of the files we will
    find with the desired characteristics:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`List`属性来存储我们将找到具有所需特征的文件的完整路径：
- en: '[PRE87]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, declare a private `Phaser` attribute to control the synchronization
    of the different phases of the task:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，声明一个私有的`Phaser`属性来控制任务不同阶段的同步：
- en: '[PRE88]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, implement the constructor of the class that will initialize the attributes
    of the class. It receives the full path of the initial folder as parameters, the
    extension of the files, and `phaser`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现类的构造函数，该构造函数将初始化类的属性。它接收初始文件夹的完整路径作为参数，文件的扩展名，以及`phaser`：
- en: '[PRE89]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, implement some auxiliary methods that will be used by the `run()` method.
    The first one is the `directoryProcess()` method. It receives a `File` object
    as a parameter and it processes all its files and subfolders. For each folder,
    the method will make a recursive call while passing the folder as a parameter.
    For each file, the method will call the `fileProcess()` method:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现一些辅助方法，这些方法将由`run()`方法使用。第一个是`directoryProcess()`方法。它接收一个`File`对象作为参数，并处理所有文件和子文件夹。对于每个文件夹，该方法将递归调用，并将文件夹作为参数传递。对于每个文件，该方法将调用`fileProcess()`方法：
- en: '[PRE90]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then, implement the `fileProcess()` method. It receives a `File` object as
    a parameter and checks whether its extension is equal to the one we are looking
    for. If they are equal, this method adds the absolute path of the file to the
    list of results:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`fileProcess()`方法。它接收一个`File`对象作为参数，并检查其扩展名是否与我们正在寻找的扩展名相等。如果它们相等，此方法将文件的绝对路径添加到结果列表中：
- en: '[PRE91]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now implement the `filterResults()` method. It doesn''t receive any parameter
    and filters the list of files obtained in the first phase; it deletes files that
    were modified more than 24 hours ago. First, create a new empty list and get the
    actual date:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现`filterResults()`方法。它不接受任何参数，并过滤第一阶段获取的文件列表；删除24小时前修改的文件。首先，创建一个新的空列表并获取实际日期：
- en: '[PRE92]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then, go through all the elements of the results list. For each path in the
    list of results, create a `File` object for the file and get its last modified
    date:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，遍历结果列表中的所有元素。对于结果列表中的每个路径，为文件创建一个`File`对象并获取其最后修改日期：
- en: '[PRE93]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Then, compare this date with the actual date, and if the difference is less
    than 1 day, add the full path of the file to the new list of results:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此日期与实际日期进行比较，如果差异小于1天，则将文件的完整路径添加到新的结果列表中：
- en: '[PRE94]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Finally, change the old results list to the new ones:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将旧的结果列表更改为新的列表：
- en: '[PRE95]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, implement the `checkResults()` method. This method will be called at
    the end of the first and second phase, and it will check whether the results list
    is empty or not. This method doesn''t have any parameters:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现 `checkResults()` 方法。此方法将在第一和第二阶段结束时被调用，并检查结果列表是否为空。此方法没有任何参数：
- en: '[PRE96]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'First, check the size of the results list. If it''s 0, the object writes a
    message to the console indicating this. After this, it calls the `arriveAndDeregister()`
    method of the `Phaser` object to notify that this thread has finished the actual
    phase and it leaves the phased operation:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查结果列表的大小。如果为 0，对象将向控制台写入一条消息表示这一点。之后，它调用 `Phaser` 对象的 `arriveAndDeregister()`
    方法来通知此线程已完成实际阶段，并离开分阶段操作：
- en: '[PRE97]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If the results list has elements, the object writes a message to the console
    indicating this. Then, it calls the `arriveAndAwaitAdvance()` method of the `Phaser`
    object to notify that this thread has finished the actual phase and it wants to
    be blocked until all the participant threads in the phased operation finish the
    actual phase:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果列表有元素，对象将向控制台写入一条消息表示这一点。然后，它调用 `Phaser` 对象的 `arriveAndAwaitAdvance()` 方法来通知此线程已完成实际阶段，并希望被阻塞，直到分阶段操作中的所有参与者线程完成实际阶段：
- en: '[PRE98]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The last auxiliary method is the `showInfo()` method that prints the elements
    of the results list to the console:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个辅助方法是 `showInfo()` 方法，它将结果列表的元素打印到控制台：
- en: '[PRE99]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'It''s time to implement the `run()` method that executes the operation using
    the auxiliary methods described earlier. We''ll also implement the `Phaser` object
    to control the change between phases. First, call the `arriveAndAwaitAdvance()`
    method of the `Phaser` object. The search won''t begin until all the threads have
    been created:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候实现 `run()` 方法了，该方法使用前面描述的辅助方法执行操作。我们还将实现 `Phaser` 对象来控制阶段之间的转换。首先，调用 `Phaser`
    对象的 `arriveAndAwaitAdvance()` 方法。搜索不会开始，直到所有线程都已创建：
- en: '[PRE100]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, write a message to the console indicating the start of the search task:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向控制台写入一条消息，指示搜索任务的开始：
- en: '[PRE101]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Check that the `initPath` attribute stores the name of a folder and use the
    `directoryProcess()` method to find the files with the specified extension in
    that folder and all its subfolders:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `initPath` 属性是否存储文件夹的名称，并使用 `directoryProcess()` 方法在该文件夹及其所有子文件夹中查找指定扩展名的文件：
- en: '[PRE102]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Check whether there are any results using the `checkResults()` method. If there
    are no results, finish the execution of the thread with the `return` keyword:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `checkResults()` 方法检查是否有任何结果。如果没有结果，使用 `return` 关键字结束线程的执行：
- en: '[PRE103]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Filter the list of results using the `filterResults()` method:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `filterResults()` 方法过滤结果列表：
- en: '[PRE104]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Check whether there are any results using the `checkResults()` method once
    again. If there are no results, finish the execution of the thread with the `return`
    keyword:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用 `checkResults()` 方法检查是否有任何结果。如果没有结果，使用 `return` 关键字结束线程的执行：
- en: '[PRE105]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Print the final list of results to the console with the `showInfo()` method,
    deregister the thread, and print a message indicating the finalization of the
    thread:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `showInfo()` 方法将最终结果列表打印到控制台，注销线程，并打印一条消息，指示线程的最终化：
- en: '[PRE106]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, implement the main class of the example by creating a class named `Main`
    and adding the `main()` method to it:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主要类：
- en: '[PRE107]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a `Phaser` object with three participants:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有三个参与者的 `Phaser` 对象：
- en: '[PRE108]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Create three `FileSearch` objects with a different initial folder for each
    one. Look for the files with the `.log` extension:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个 `FileSearch` 对象，每个对象使用不同的初始文件夹。查找具有 `.log` 扩展名的文件：
- en: '[PRE109]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Create and start a thread to execute the first `FileSearch` object:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个线程来执行第一个 `FileSearch` 对象：
- en: '[PRE110]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Create and start a thread to execute the second `FileSearch` object:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个线程来执行第二个 `FileSearch` 对象：
- en: '[PRE111]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Create and start a thread to execute the third `FileSearch` object:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个线程来执行第三个 `FileSearch` 对象：
- en: '[PRE112]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Wait for the finalization of the three threads:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待三个线程的最终化：
- en: '[PRE113]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Write the value of the finalized flag of the `Phaser` object using the `isFinalized()`
    method:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `isFinalized()` 方法写入 `Phaser` 对象的已最终化标志的值：
- en: '[PRE114]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: How it works...
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The program starts creating a `Phaser` object that will control the synchronization
    of the threads at the end of each phase. The constructor of `Phaser` receives
    the number of participants as a parameter. In our case, `Phaser` has three participants.
    This number indicates `Phaser` the number of threads that need to execute the
    `arriveAndAwaitAdvance()` method before `Phaser` could change the phase and wake
    up the threads that have been sleeping.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始创建一个 `Phaser` 对象，该对象将在每个阶段的末尾控制线程的同步。`Phaser` 的构造函数接收参与者数量作为参数。在我们的例子中，`Phaser`
    有三个参与者。这个数字表示 `Phaser` 需要执行 `arriveAndAwaitAdvance()` 方法的线程数量，在 `Phaser` 能够更改阶段并唤醒休眠的线程之前。
- en: Once `Phaser` has been created, we launch three threads that are executed using
    three different `FileSearch` objects.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `Phaser`，我们就启动三个线程，这些线程使用三个不同的 `FileSearch` 对象来执行。
- en: In this example, we use paths of the Windows operating system. If you work with
    another operating system, modify the paths to adapt them to existing paths in
    your environment, such as `/var/log`, or similar.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用Windows操作系统的路径。如果你使用的是其他操作系统，请修改路径以适应你环境中现有的路径，例如 `/var/log` 或类似路径。
- en: The first instruction in the `run()` method of this `FileSearch` object is a
    call to the `arriveAndAwaitAdvance()` method of the `Phaser` object. As mentioned
    earlier, `Phaser` knows the number of threads that we want to synchronize. When
    a thread calls this method, `Phaser` decreases the number of threads that have
    to finalize the actual phase and puts this thread to sleep until all the remaining
    threads finish this phase. Calling this method at the beginning of the `run()`
    method ensures that none of the `FileSearch` threads begin their job until all
    the threads are created.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `FileSearch` 对象的 `run()` 方法中的第一条指令是调用 `Phaser` 对象的 `arriveAndAwaitAdvance()`
    方法。如前所述，`Phaser` 知道我们想要同步的线程数量。当一个线程调用此方法时，`Phaser` 会减少需要最终确定实际阶段的线程数量，并将此线程置于休眠状态，直到所有剩余的线程完成此阶段。在
    `run()` 方法的开始处调用此方法确保在所有线程创建之前，没有任何 `FileSearch` 线程开始工作。
- en: At the end of phase one and phase two, we check whether the phase has generated
    results and the list with the results has elements or the phase hasn't generated
    results and the list is empty. In the first case, the `checkResults()` method
    calls `arriveAndAwaitAdvance()` as explained earlier. In the second case, if the
    list is empty, there's no point in the thread continuing with its execution, so
    it ends its execution. But you have to notify the `Phaser` object that there will
    be one less participant. For this, we used `arriveAndDeregister()`. This notifies
    `phaser` that the thread has finished the actual phase, but it won't participate
    in future phases, therefore, `phaser` won't have to wait for it to continue.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段和第二阶段结束时，我们检查阶段是否生成了结果以及结果列表是否有元素，或者阶段没有生成结果且列表为空。在第一种情况下，`checkResults()`
    方法调用前面解释过的 `arriveAndAwaitAdvance()` 方法。在第二种情况下，如果列表为空，线程继续执行就没有意义了，因此它结束执行。但是你必须通知
    `Phaser` 对象将有一个参与者减少。为此，我们使用了 `arriveAndDeregister()`。这通知 `phaser` 线程已经完成了实际阶段，但不会参与未来的阶段，因此
    `phaser` 不必等待它继续。
- en: At the end of the phase three implemented in the `showInfo()` method, there
    is a call to the `arriveAndAwaitAdvance()` method of `phaser`. With this call,
    we guarantee that all the threads finish at the same time. When this method ends
    its execution, there is a call to the `arriveAndDeregister()` method of `phaser`.
    With this call, we deregister the threads of `phaser`, as explained before, so
    when all the threads finish, `phaser` will have zero participants.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `showInfo()` 方法中实现的第三阶段结束时，有一个调用 `phaser` 的 `arriveAndAwaitAdvance()` 方法的调用。通过这个调用，我们保证所有线程同时完成。当此方法执行完毕时，有一个调用
    `phaser` 的 `arriveAndDeregister()` 方法的调用。通过这个调用，我们注销 `phaser` 的线程，如前所述，因此当所有线程完成时，`phaser`
    将没有参与者。
- en: Finally, the `main()` method waits for the completion of the three threads and
    calls the `isTerminated()` method of `phaser`. When `phaser` has zero participants,
    it enters the so-called termination state, and this method returns `true`. As
    we deregister all the threads of `phaser`, it will be in the termination state,
    and this call will print `true` to the console.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main()` 方法等待三个线程完成，并调用 `phaser` 的 `isTerminated()` 方法。当 `phaser` 的参与者为零时，它进入所谓的终止状态，并且此方法返回
    `true`。当我们注销 `phaser` 的所有线程时，它将处于终止状态，并且此调用将 `true` 打印到控制台。
- en: 'A `Phaser` object can be in two states:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Phaser` 对象可以处于两种状态：
- en: '**Active**: `Phaser` enters this state when it accepts the registration of
    new participants and its synchronization at the end of each phase. In this state,
    `Phaser` works as it has been explained in this recipe. This state is not mentioned
    in the Java concurrency API.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动**：当`Phaser`接受新参与者的注册并在每个阶段的末尾进行同步时，它会进入此状态。在此状态下，`Phaser`的工作方式如本食谱中所述。此状态在Java并发API中未提及。'
- en: '**Termination**: By default, `Phaser` enters this state when all the participants
    in `Phaser` have been deregistered, which means it has zero participants. Further,
    `Phaser` is in the termination state when the method `onAdvance()` returns `true`.
    If you override this method, you can change the default behavior. When `Phaser`
    is in this state, the synchronization method `arriveAndAwaitAdvance()` returns
    immediately without doing any synchronization operation.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**：默认情况下，当`Phaser`中的所有参与者都已注销时，`Phaser`进入此状态，这意味着它没有参与者。此外，当`onAdvance()`方法返回`true`时，`Phaser`处于终止状态。如果你重写此方法，你可以更改默认行为。当`Phaser`处于此状态时，同步方法`arriveAndAwaitAdvance()`会立即返回，而不执行任何同步操作。'
- en: A notable feature of the `Phaser` class is that you haven't had to control any
    exception from the methods related to `phaser`. Unlike other synchronization utilities,
    threads that are sleeping in `phaser` don't respond to interruption events and
    don't throw an `InterruptedException` exception. There is only one exception,
    which is explained in the next section.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类的一个显著特点是，你不必控制与`phaser`相关的方法抛出的任何异常。与其他同步工具不同，在`phaser`中休眠的线程不会响应中断事件，也不会抛出`InterruptedException`异常。只有一个例外，将在下一节中解释。'
- en: 'The following screenshot shows the results of one execution of the example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了示例的一次执行结果：
- en: '![](img/00023.jpeg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: It shows the first two phases of the execution. You can see how the `Apps` thread
    finishes its execution in phase two because its results list is empty. When you
    execute the example, you will see how some threads finish a phase before the rest
    and how they wait until all have finished one phase before continuing with the
    rest.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了执行的前两个阶段。你可以看到`Apps`线程在第二阶段完成其执行，因为其结果列表为空。当你执行示例时，你会看到一些线程在其余线程之前完成一个阶段，并且它们在所有线程完成一个阶段之前等待，然后继续执行。
- en: There's more...
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Phaser` class provides other methods related to the change of phase. These
    methods are as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类提供了其他与阶段变化相关的方法。这些方法如下：'
- en: '`arrive()`: This method notifies the `Phaser` class that one participant has
    finished the actual phase but it should not wait for the rest of the participants
    to continue with their execution. Be careful with the utilization of this method
    because it doesn''t synchronize with other threads.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrive()`: 此方法通知`Phaser`类一个参与者已完成实际阶段，但它不应等待其余参与者继续执行。在使用此方法时要小心，因为它不与其他线程同步。'
- en: '`awaitAdvance(int phase)`: This method puts the current thread to sleep until
    all the participants of the `phaser` parameter have finished the current phase,
    that is, if the number we pass as the parameter is equal to the actual phase of
    `phaser`. If the parameter and the actual phase of `phaser` aren''t equal, the
    method  ends its execution.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitAdvance(int phase)`: 此方法使当前线程休眠，直到`phaser`参数的所有参与者完成当前阶段，也就是说，如果我们传递的参数数等于`phaser`的实际阶段。如果参数和`phaser`的实际阶段不相等，该方法将结束其执行。'
- en: '`awaitAdvanceInterruptibly(int phaser)`: This method is equal to the method
    explained earlier, but it throws an `InterruptedException` exception if the thread
    that is sleeping in this method is interrupted.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitAdvanceInterruptibly(int phaser)`: 此方法与前面解释的方法相同，但如果在此方法中休眠的线程被中断，则会抛出`InterruptedException`异常。'
- en: Registering participants in Phaser
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`Phaser`中注册参与者
- en: 'When you create a `Phaser` object, you indicate how many participants will
    have that `phaser`. But the `Phaser` class has two methods to increment the number
    of participants of `phaser`. These methods are as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`Phaser`对象时，你指定将有多少参与者拥有该`phaser`。但`Phaser`类有两个方法来增加`phaser`的参与者数量。这些方法如下：
- en: '`register()`: This method adds a new participant to `Phaser`. This new participant
    will be considered unarrived to the actual phase.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register()`: 此方法向`Phaser`添加一个新参与者。这个新参与者将被视为尚未到达实际阶段。'
- en: '`bulkRegister(int Parties)`: This method adds the specified number of participants
    to `phaser`. These new participants will be considered unarrived to the actual
    phase.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bulkRegister(int Parties)`: 此方法将指定的参与者数量添加到`phaser`中。这些新参与者将被视为尚未到达实际阶段。'
- en: The only method provided by the `Phaser` class to decrement the number of participants
    is the `arriveAndDeregister()` method that notifies `phaser` that the thread has
    finished the actual phase and it doesn't want to continue with the phased operation.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类提供的唯一用于减少参与者数量的方法是`arriveAndDeregister()`方法，它通知`phaser`线程已完成实际阶段，并且不想继续进行分阶段操作。'
- en: Forcing the termination of Phaser
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制终止Phaser
- en: When `phaser` has zero participants, it enters a state denoted by termination.
    The `Phaser` class provides `forceTermination()` to change the status of `phaser`
    and makes it enter the termination state independently of the number of participants
    registered in `phaser`. This mechanism may be useful when one of the participants
    has an error situation, where the best thing to do would be to terminate `phaser`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当`phaser`没有参与者时，它会进入一个被称为终止的状态。`Phaser`类提供了`forceTermination()`方法来改变`phaser`的状态，并使其独立于在`phaser`中注册的参与者数量而进入终止状态。这种机制在参与者之一出现错误情况时可能很有用，此时最好的做法是终止`phaser`。
- en: When `phaser` is in the termination state, the `awaitAdvance()` and `arriveAndAwaitAdvance()`
    methods immediately return a negative number, instead of a positive one that is
    returned normally. If you know that your `phaser` could be terminated, you should
    verify the return value of those methods (`awaitAdvance()` and `arriveAndAwaitAdvance()`)
    to know whether `phaser` has been terminated.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当`phaser`处于终止状态时，`awaitAdvance()`和`arriveAndAwaitAdvance()`方法立即返回一个负数，而不是通常返回的正数。如果你知道你的`phaser`可能会被终止，你应该验证这些方法（`awaitAdvance()`和`arriveAndAwaitAdvance()`）的返回值，以了解`phaser`是否已被终止。
- en: See also
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Monitoring a Phaser class* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736)的*监控Phaser类*菜谱中，*测试并发应用程序*，你可以找到更多相关信息。
- en: Controlling phase change in concurrent-phased tasks
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制并发分阶段任务中的阶段变化
- en: 'The `Phaser` class provides a method that is executed each time `phaser` changes
    the phase. It''s the `onAdvance()` method. It receives two parameters: the number
    of the current phases and the number of registered participants. It returns a
    Boolean value `false` if `Phaser` continues its execution or the value `true`
    if `Phaser` has finished and has to enter the termination state.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类提供了一个在`phaser`改变阶段时执行的方法。它是`onAdvance()`方法。它接收两个参数：当前阶段的数量和注册的参与者数量。如果`Phaser`继续执行，则返回一个布尔值`false`；如果`Phaser`已完成并需要进入终止状态，则返回`true`。'
- en: The default implementation of this method returns `true` if the number of registered
    participants is zero, and `false` otherwise. But you can modify this behavior
    if you extend the `Phaser` class and override this method. Normally, you will
    be interested in doing this when you have to execute some actions when you advance
    from one phase to the next.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的默认实现如果注册的参与者数量为零则返回`true`，否则返回`false`。但如果你扩展了`Phaser`类并重写了此方法，你可以修改这种行为。通常，当你需要在从一个阶段过渡到下一个阶段时执行一些操作时，你会有兴趣这样做。
- en: In this recipe, you will learn how to control phase change in a phaser that
    is implementing your own version of the `Phaser` class that overrides the `onAdvance()`
    method to execute some actions in every phase change. You are going to implement
    a simulation of an exam, where there will be some students who have to do three
    exercises. All the students have to finish one exercise before they proceed with
    the next one.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何控制实现`Phaser`类并重写`onAdvance()`方法以在每个阶段变化时执行一些操作的`phaser`中的阶段变化。你将实现一个考试模拟，其中将有一些学生需要完成三个练习。所有学生必须完成一个练习后才能进行下一个练习。
- en: Getting ready
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `MyPhaser` and specify that it extends from the `Phaser`
    class:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyPhaser`的类，并指定它从`Phaser`类扩展：
- en: '[PRE115]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Override the `onAdvance()` method. According to the value of the `phase` attribute,
    we call it a different auxiliary method. If the `phase` attribute is equal to
    zero, you have to call the `studentsArrived()` method. If the `phase` is equal
    to one, you have to call the `finishFirstExercise()` method. If the phase is equal
    to two, you have to call the `finishSecondExercise()` method. Finally, if the
    phase is equal to three, you have to call the `finishExam()` method. Otherwise,
    return the true value to indicate that `phaser` has terminated:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`onAdvance()`方法。根据`phase`属性的值，我们调用不同的辅助方法。如果`phase`属性等于零，你必须调用`studentsArrived()`方法。如果`phase`等于一，你必须调用`finishFirstExercise()`方法。如果`phase`等于二，你必须调用`finishSecondExercise()`方法。最后，如果`phase`等于三，你必须调用`finishExam()`方法。否则，返回true值以指示`phaser`已终止：
- en: '[PRE116]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Implement the auxiliary method `studentsArrived()`. It writes two log messages
    to the console and returns false to indicate that `phaser` is continuing with
    its execution:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`studentsArrived()`。它向控制台写入两条日志消息，并返回false以指示`phaser`正在继续其执行：
- en: '[PRE117]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Implement the auxiliary method `finishFirstExercise()`. It writes two messages
    to the console and returns false to indicate that `phaser` is continuing with
    its execution:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`finishFirstExercise()`。它向控制台写入两条消息，并返回false以指示`phaser`正在继续其执行：
- en: '[PRE118]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Implement the auxiliary method `finishSecondExercise()`. It writes two messages
    to the console and returns false to indicate that `phaser` is continuing with
    its execution:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`finishSecondExercise()`。它向控制台写入两条消息，并返回false以指示`phaser`正在继续其执行：
- en: '[PRE119]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Implement the auxiliary method `finishExam()`. It writes two messages to the
    console and returns true to indicate that `phaser` has finished its work:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`finishExam()`。它向控制台写入两条消息，并返回true以指示`phaser`已完成其工作：
- en: '[PRE120]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Create a class named `Student` and specify that it implements the `Runnable`
    interface. This class will simulate the students of an exam:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Student`的类，并指定它实现`Runnable`接口。此类将模拟考试的学生：
- en: '[PRE121]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Declare a `Phaser` object named `phaser`:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`phaser`的`Phaser`对象：
- en: '[PRE122]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Implement the constructor of the class that initializes the `Phaser` object:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化`Phaser`对象：
- en: '[PRE123]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Implement the `run()` method that will simulate the realization of the exam:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现模拟考试实现的`run()`方法：
- en: '[PRE124]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'First, the method writes a message in the console to indicate that a student
    has arrived at the exam hall and calls the `arriveAndAwaitAdvance()` method of
    `phaser` to wait for the rest of the threads:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，该方法向控制台写入一条消息，指示学生已到达考场，并调用`phaser`的`arriveAndAwaitAdvance()`方法等待其他线程：
- en: '[PRE125]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Then, write a message to the console and call the private `doExercise1()` method
    that simulates the realization of the first exercise of the exam. Post this, write
    another message to the console and the `arriveAndAwaitAdvance()` method of `phaser`
    to wait for the rest of the students to finish the first exercise:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向控制台写入一条消息，并调用模拟考试第一题实现的私有`doExercise1()`方法。之后，再向控制台写入另一条消息，并调用`phaser`的`arriveAndAwaitAdvance()`方法等待其他学生完成第一题：
- en: '[PRE126]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Implement the same code for the second and third exercises:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为第二题和第三题实现相同的代码：
- en: '[PRE127]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Implement the auxiliary method `doExercise1()`. This method puts the current
    thread or the thread that executes the method to sleep for a random period of
    time:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`doExercise1()`。此方法使当前线程或执行方法的线程随机休眠一段时间：
- en: '[PRE128]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Implement the auxiliary method `doExercise2()`. This method puts the current
    thread or the thread that executes the method to sleep for a random period of
    time:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`doExercise2()`。此方法使当前线程或执行方法的线程随机休眠一段时间：
- en: '[PRE129]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Implement the auxiliary method `doExercise3()`. This method puts the thread
    to sleep for a random period of time:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`doExercise3()`。此方法使线程随机休眠一段时间：
- en: '[PRE130]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE131]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Create a `MyPhaser` object:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MyPhaser`对象：
- en: '[PRE132]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Create five `Student` objects and register them in the `phaser` attribute using
    the `register()` method:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个`Student`对象，并使用`register()`方法将它们注册到`phaser`属性中：
- en: '[PRE133]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Create five threads to run students and start them:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个线程来运行学生并启动它们：
- en: '[PRE134]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Wait for the finalization of the five threads:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待五个线程的最终化：
- en: '[PRE135]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Write a message to show that `phaser` is in the termination state, using the
    `isTerminated()` method:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `isTerminated()` 方法写一条消息来显示 `phaser` 处于终止状态：
- en: '[PRE136]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works...
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This exercise simulates the realization of an exam that has three exercises.
    All the students have to finish one exercise before they can start the next one.
    To implement this synchronization requirement, we use the `Phaser` class; however,
    in this case, you implemented your own `phaser`, extending the original class
    to override the `onAdvance()` method.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习模拟了实现一个包含三项练习的考试。所有学生必须完成一项练习后才能开始下一项。为了实现这个同步要求，我们使用了 `Phaser` 类；然而，在这种情况下，您实现了自己的
    `phaser`，通过扩展原始类来重写 `onAdvance()` 方法。
- en: This method is called by `Phaser` before making a phase change and waking up
    all the threads that were sleeping in the `arriveAndAwaitAdvance()` method. The
    method is invoked by the last thread that finishes a phase as part of the code
    of the `arriveAndAwaitAdvance()` method. This method receives the number of the
    actual phase as parameters, where 0 is the number of the first phase and the number
    of registered participants. The most useful parameter is the actual phase. If
    you execute a different operation depending on the actual phase, you have to use
    an alternative structure (`if...else` or `switch`) to select the operation you
    want to execute. In the example, we used a `switch` structure to select a different
    method for each change of phase.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Phaser` 在 `arriveAndAwaitAdvance()` 方法中唤醒所有休眠的线程之前，该方法被 `Phaser` 调用并改变阶段。该方法由作为
    `arriveAndAwaitAdvance()` 方法代码一部分的最后一个完成阶段的线程调用。该方法接收实际阶段的数字作为参数，其中 0 是第一个阶段的数字和注册的参与者数量。最有用的参数是实际阶段。如果您根据实际阶段执行不同的操作，您必须使用替代结构（`if...else`
    或 `switch`）来选择要执行的操作。在示例中，我们使用 `switch` 结构来选择每个阶段变化时不同的方法。
- en: The `onAdvance()` method returns a Boolean value that indicates whether `phaser`
    has terminated or not. If `phaser` returns false, it indicates that it hasn't
    terminated; if this happens, the threads will continue with the execution of other
    phases. If `phaser` returns `true`, then `phaser` still wakes up the pending threads
    but moves `phaser` to the terminated state. With this, all future calls to any
    method of `phaser` will return immediately, and the `isTerminated()` method will
    return `true`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAdvance()` 方法返回一个布尔值，表示 `phaser` 是否已终止。如果 `phaser` 返回 `false`，则表示它尚未终止；如果发生这种情况，线程将继续执行其他阶段的操作。如果
    `phaser` 返回 `true`，则 `phaser` 仍然会唤醒挂起的线程，但将 `phaser` 移至终止状态。因此，所有未来对 `phaser`
    任何方法的调用都将立即返回，并且 `isTerminated()` 方法将返回 `true`。'
- en: In the `Main` class, when you created the `MyPhaser` object, you didn't specify
    the number of participants in the phaser. You made a call to the `register()`
    method for every `Student` object created to register a participant in `phaser`.
    This calling doesn't establish a relation between the `Student` object or the
    thread that executes it and `phaser`. Really, the number of participants in a
    phaser is only a number. There is no relationship between `phaser` and the participants.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Main` 类中，当您创建 `MyPhaser` 对象时，您没有指定 `phaser` 中的参与者数量。您为每个创建的 `Student` 对象调用
    `register()` 方法来在 `phaser` 中注册一个参与者。这种调用并不在 `Student` 对象或执行它的线程与 `phaser` 之间建立关系。实际上，`phaser`
    中的参与者数量只是一个数字。`phaser` 与参与者之间没有关系。
- en: 'The following screenshot shows the results of an execution of this example:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的执行结果：
- en: '![](img/00024.jpeg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: You can see how the students finished the first exercise at different times.
    When all of them finish the first exercise, `phaser` calls the `onAdvance()` method
    that writes the log messages in the console, then all the students start the second
    exercise at the same time.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到学生们完成第一项练习的不同时间。当所有学生都完成第一项练习后，`phaser` 调用 `onAdvance()` 方法在控制台写入日志消息，然后所有学生同时开始第二项练习。
- en: See also
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Running concurrent-phased tasks* recipe in this chapter
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *Running concurrent-phased tasks* 菜谱
- en: The *Monitoring a Phaser class* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 9 章 *Testing Concurrent Applications* 的 *Monitoring a Phaser class* 菜谱中
- en: Exchanging data between concurrent tasks
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并发任务之间交换数据
- en: The Java concurrency API provides a synchronization utility that allows interchange
    of data between two concurrent tasks. In more detail, the `Exchanger` class allows
    you to have a definition of a synchronization point between two threads. When
    the two threads arrive at this point, they interchange a data structure such that
    the data structure of the first thread goes to the second one and vice versa.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Java 并发 API 提供了一个同步实用工具，允许两个并发任务之间交换数据。更详细地说，`Exchanger` 类允许您在两个线程之间定义一个同步点。当两个线程到达这个点时，它们交换一个数据结构，使得第一个线程的数据结构传递给第二个线程，反之亦然。
- en: This class may be very useful in a situation similar to the producer-consumer
    problem. This is a classic concurrent problem where you have a common buffer of
    data, one or more producers of data, and one or more consumers of data. As the
    `Exchanger` class synchronizes only two threads, you can use it if you have a
    producer-consumer problem with one producer and one consumer.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似生产者-消费者问题的场景中，此类可能非常有用。这是一个经典并发问题，其中有一个公共的数据缓冲区，一个或多个数据生产者，以及一个或多个数据消费者。由于
    `Exchanger` 类仅同步两个线程，因此如果您有一个只有一个生产者和一个消费者的生产者-消费者问题，则可以使用它。
- en: In this recipe, you will learn how to use the `Exchanger` class to solve the
    producer-consumer problem with one producer and one consumer.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，您将学习如何使用 `Exchanger` 类解决一个生产者和一个消费者之间的生产者-消费者问题。
- en: Getting ready
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First, begin by implementing the producer. Create a class named `Producer`
    and specify that it implements the `Runnable` interface:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，开始实现生产者。创建一个名为 `Producer` 的类并指定它实现 `Runnable` 接口：
- en: '[PRE137]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Declare a `List<String>` field named `buffer`. This will be the data structure
    that the producer will interchange with the consumer:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `buffer` 的 `List<String>` 字段。这将是一个生产者与消费者之间交换数据的数据结构：
- en: '[PRE138]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Declare an `Exchanger<List<String>>` field named `exchanger`. This will be
    the exchanger object that will be used to synchronize the producer and consumer:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `exchanger` 的 `Exchanger<List<String>>` 字段。这将是一个用于同步生产者和消费者的交换器对象：
- en: '[PRE139]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Implement the constructor of the class that will initialize the two attributes:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化两个属性：
- en: '[PRE140]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Implement the `run()` method. Inside it, implement 10 cycles of interchange:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现方法 `run()`。在其内部，实现 10 次交换循环：
- en: '[PRE141]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'In each cycle, add 10 strings to the buffer:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个循环中，向缓冲区添加 10 个字符串：
- en: '[PRE142]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Call the `exchange()` method to interchange data with the consumer. As this
    method can throw an `InterruptedException` exception, you have to add some code
    to process it.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `exchange()` 方法与消费者交换数据。由于此方法可能会抛出 `InterruptedException` 异常，您必须添加一些代码来处理它。
- en: '[PRE143]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Now, implement the consumer. Create a class named `Consumer` and specify that
    it implements the `Runnable` interface:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现消费者。创建一个名为 `Consumer` 的类并指定它实现 `Runnable` 接口：
- en: '[PRE144]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Declare a `List<String>` field named `buffer`. This will be the data structure
    that the producer will interchange with the consumer:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `buffer` 的 `List<String>` 字段。这将是一个生产者与消费者之间交换数据的数据结构：
- en: '[PRE145]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Declare an `Exchanger<List<String>>` field named `exchanger`. This will be
    the `exchanger` object that will be used to synchronize the producer and consumer:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `exchanger` 的 `Exchanger<List<String>>` 字段。这将是一个用于同步生产者和消费者的 `exchanger`
    对象：
- en: '[PRE146]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Implement the constructor of the class that will initialize the two attributes:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化两个属性：
- en: '[PRE147]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Implement the `run()` method. Inside it, implement 10 cycles of interchange:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现方法 `run()`。在其内部，实现 10 次交换循环：
- en: '[PRE148]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'In each cycle, begin with a call to the `exchange()` method to synchronize
    with the producer. The consumer needs data to consume. As this method can throw
    an `InterruptedException` exception, you have to add some code to process it:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个循环中，首先调用 `exchange()` 方法以与生产者同步。消费者需要数据来消费。由于此方法可能会抛出 `InterruptedException`
    异常，您必须添加一些代码来处理它：
- en: '[PRE149]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Write the 10 strings the producer sent in its buffer to the console and delete
    them from the buffer to leave it empty:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生产者发送到其缓冲区的 10 个字符串写入控制台，并从缓冲区中删除它们以使其为空：
- en: '[PRE150]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Now, implement the `main` class of the example by creating a class named `Main`
    and adding the `main()` method to it:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的 `main` 类：
- en: '[PRE151]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Create two buffers that will be used by the producer and consumer:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个缓冲区，这些缓冲区将被生产者和消费者使用：
- en: '[PRE152]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Create the `Exchanger` object that will be used to synchronize the producer
    and consumer:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于同步生产者和消费者的`Exchanger`对象：
- en: '[PRE153]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Create the `Producer` and `Consumer` objects:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Producer`和`Consumer`对象：
- en: '[PRE154]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Create the threads to execute the producer and consumer and start the threads:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建执行生产者和消费者的线程并启动线程：
- en: '[PRE155]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: How it works...
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The consumer begins with an empty buffer and calls `Exchanger` to synchronize
    with the producer. It needs data to consume. The producer begins its execution
    with an empty buffer. It creates 10 strings, stores them in the buffer, and uses
    the `Exchanger` to synchronize with the consumer.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者从一个空的缓冲区开始，并调用`Exchanger`来与生产者同步。它需要数据来消费。生产者从一个空的缓冲区开始执行。它创建了10个字符串，将它们存储在缓冲区中，并使用`Exchanger`来与消费者同步。
- en: At this point, both the threads (producer and consumer) are in `Exchanger`,
    which changes the data structures. So when the consumer returns from the `exchange()`
    method, it will have a buffer with 10 strings. When the producer returns from
    the `exchange()` method, it will have an empty buffer to fill again. This operation
    will be repeated 10 times.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，两个线程（生产者和消费者）都在`Exchanger`中，它改变了数据结构。因此，当消费者从`exchange()`方法返回时，它将有一个包含10个字符串的缓冲区。当生产者从`exchange()`方法返回时，它将有一个空的缓冲区来再次填充。这个操作将被重复10次。
- en: If you execute the example, you will see how producer and consumer do their
    jobs concurrently and how the two objects interchange their buffers in every step.
    As it occurs with other synchronization utilities, the first thread that calls
    the `exchange()` method is put to sleep until the other threads arrive.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这个示例，你会看到生产者和消费者如何并发地完成他们的工作，以及两个对象在每一步中如何交换它们的缓冲区。正如其他同步工具所发生的那样，第一个调用`exchange()`方法的线程将被置于休眠状态，直到其他线程到达。
- en: There's more...
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Exchanger` class has another version of the `exchange` method: `exchange(V
    data, long time, TimeUnit unit)`. where, `V` is the type used as a parameter in
    the declaration of `Phaser` (`List<String>` in our case). The thread will sleep
    until it''s interrupted, another thread arrives, or the specified time passes.
    In this case, a `TimeoutException` is thrown. The `TimeUnit` class is an enumeration
    with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`,
    `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exchanger`类有一个`exchange`方法的另一个版本：`exchange(V data, long time, TimeUnit unit)`。其中，`V`是用于`Phaser`声明（在我们的情况下是`List<String>`）的参数类型。线程将休眠，直到它被中断，另一个线程到达，或者指定的时长过去。在这种情况下，将抛出`TimeoutException`。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。'
- en: Completing and linking tasks asynchronously
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步完成和链接任务
- en: 'Java 8 Concurrency API includes a new synchronization mechanism with the `CompletableFuture`
    class. This class implements the `Future` object and the `CompletionStage` interface
    that gives it the following two characteristics:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8并发API通过`CompletableFuture`类引入了一种新的同步机制。这个类实现了`Future`对象和`CompletionStage`接口，使其具有以下两个特性：
- en: As the `Future` object, a `CompletableFuture` object will return a result sometime
    in future
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`Future`对象，`CompletableFuture`对象将在未来某个时间返回一个结果
- en: As the `CompletionStage` object, you can execute more asynchronous tasks after
    the completion of one or more `CompletableFuture` objects
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`CompletionStage`对象，你可以在一个或多个`CompletableFuture`对象完成之后执行更多的异步任务
- en: 'You can work with a `CompletableFuture` class in different ways:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用不同的方式与`CompletableFuture`类一起工作：
- en: You can create a `CompletableFuture` object explicitly and use it as a synchronization
    point between tasks. One task will establish the value returned by `CompletableFuture`,
    using the `complete()` method, and the other tasks will wait for this value, using
    the `get()` or `join()` methods.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以显式创建一个`CompletableFuture`对象，并将其用作任务之间的同步点。一个任务将使用`complete()`方法设置`CompletableFuture`返回的值，而其他任务将使用`get()`或`join()`方法等待这个值。
- en: You can use a static method of the `CompletableFuture` class to execute `Runnable`
    or `Supplier` with the `runAsync()` and `supplyAsync()` methods. These methods
    will return a `CompletableFuture` object that will be completed when these tasks
    end their execution. In the second case, the value returned by `Supplier` will
    be the completion value of `CompletableFuture`.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`CompletableFuture`类的静态方法使用`runAsync()`和`supplyAsync()`方法来执行`Runnable`或`Supplier`。这些方法将返回一个`CompletableFuture`对象，当这些任务完成执行时，该对象将被完成。在第二种情况下，`Supplier`返回的值将是`CompletableFuture`的完成值。
- en: You can specify other tasks to be executed in an asynchronous way after the
    completion of one or more `CompletableFuture` objects. This task can implement
    the `Runnable`, `Function`, `Consumer` or `BiConsumer` interfaces.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在一个或多个`CompletableFuture`对象完成之后，异步地指定其他要执行的任务。这个任务可以实现`Runnable`、`Function`、`Consumer`或`BiConsumer`接口。
- en: 'These characteristics make the `CompletableFuture` class very flexible and
    powerful. In this chapter, you will learn how to use this class to organize different
    tasks. The main purpose of the example is that the tasks will be executed, as
    specified in the following diagram:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性使得`CompletableFuture`类非常灵活和强大。在本章中，你将学习如何使用这个类来组织不同的任务。示例的主要目的是任务将按照以下图示执行：
- en: '![](img/00025.jpeg)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00025.jpeg)'
- en: 'First, we''re going to create a task that will generate a seed. Using this
    seed, the next task will generate a list of random numbers. Then, we will execute
    three parallel tasks:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个生成种子的任务。使用这个种子，下一个任务将生成一组随机数字。然后，我们将执行三个并行任务：
- en: Step 1 will calculate the nearest number to 1,000, in a list of random numbers.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步将在一组随机数字中计算出最接近1,000的数字。
- en: Step 2 will calculate the biggest number in a list of random numbers.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步将在一组随机数字中计算出最大的数字。
- en: Step 3 will calculate the average number between the largest and smallest numbers
    in a list of random numbers.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步将在一组随机数字中计算出最大和最小数字之间的平均值。
- en: Getting ready
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的食谱已经使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First, we''re going to implement the auxiliary tasks we will use in the example.
    Create a class named `SeedGenerator`  that implements the `Runnable` interface.
    It will have a `CompletableFuture` object as an attribute, and it will be initialized
    in the constructor of the class:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现示例中将要使用的辅助任务。创建一个名为`SeedGenerator`的类，该类实现了`Runnable`接口。它将有一个`CompletableFuture`对象作为属性，并在类的构造函数中初始化：
- en: '[PRE156]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Then, implement the `run()` method. It will sleep the current thread for 5
    seconds (to simulate a long operation), calculate a random number between 1 and
    10, and then use the `complete()` method of the `resultCommunicator` object to
    complete `CompletableFuture`:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`run()`方法。它将使当前线程休眠5秒（以模拟长时间操作），计算1到10之间的随机数，然后使用`resultCommunicator`对象的`complete()`方法来完成`CompletableFuture`：
- en: '[PRE157]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Create a class named `NumberListGenerator` that implements the `Supplier` interface
    parameterized with the `List<Long>` data type. This means that the `get()` method
    provided by the `Supplier` interface will return a list of large numbers. This
    class will have an integer number as a private attribute, which will be initialized
    in the constructor of the class:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NumberListGenerator`的类，该类实现了以`List<Long>`数据类型参数化的`Supplier`接口。这意味着由`Supplier`接口提供的`get()`方法将返回一个包含大数字的列表。这个类将有一个整数作为私有属性，该属性将在类的构造函数中初始化：
- en: '[PRE158]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Then, implement the `get()` method that will return a list with millions of
    numbers, as specified in the size parameter of larger random numbers:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`get()`方法，该方法将返回一个包含数百万个数字的列表，如较大随机数字的大小参数所指定：
- en: '[PRE159]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Finally, create a class named `NumberSelector` that implements the `Function`
    interface parameterized with the `List<Long>` and `Long` data types. This means
    that the `apply()` method provided by the `Function` interface will receive a
    list of large numbers and will return a `Long` number:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`NumberSelector`的类，该类实现了以`List<Long>`和`Long`数据类型参数化的`Function`接口。这意味着由`Function`接口提供的`apply()`方法将接收一个包含大数字的列表，并将返回一个`Long`数字：
- en: '[PRE160]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Now it''s time to implement the `Main` class and the `main()` method:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候实现`Main`类和`main()`方法了：
- en: '[PRE161]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'First, create a `CompletableFuture` object and a `SeedGenerator` task and execute
    it as a `Thread`:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`CompletableFuture`对象和一个`SeedGenerator`任务，并将其作为一个`Thread`执行：
- en: '[PRE162]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Then, wait for the seed generated by the `SeedGenerator` task, using the `get()`
    method of the `CompletableFuture` object:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`CompletableFuture`对象的`get()`方法等待由`SeedGenerator`任务生成的种子：
- en: '[PRE163]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Now create another `CompletableFuture` object to control the execution of a
    `NumberListGenerator` task, but in this case, use the static method `supplyAsync()`:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建另一个`CompletableFuture`对象来控制`NumberListGenerator`任务的执行，但在这个情况下，使用静态方法`supplyAsync()`：
- en: '[PRE164]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Then, configure the three parallelized tasks that will make calculations based
    on the list of numbers generated in the previous task. These three steps can''t
    start their execution until the `NumberListGenerator` task has finished its execution,
    so we use the `CompletableFuture` object generated in the previous step and the
    `thenApplyAsync()` method to configure these tasks. The first two steps are implemented
    in a functional way, and the third one is an object of the `NumberSelector` class:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，配置三个并行化的任务，这些任务将基于前一个任务生成的数字列表进行计算。这三个步骤不能开始执行，直到`NumberListGenerator`任务完成其执行，因此我们使用前一步生成的`CompletableFuture`对象和`thenApplyAsync()`方法来配置这些任务。前两个步骤以函数式的方式实现，第三个步骤是一个`NumberSelector`类的对象：
- en: '[PRE165]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'We wait for the finalization of the three parallel steps with the `allOf()`
    static method of the `CompletableFuture` class:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`CompletableFuture`类的`allOf()`静态方法等待三个并行步骤的最终完成：
- en: '[PRE166]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Also, we execute a final step to write a message in the console:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们执行一个最终步骤，在控制台写入一条消息：
- en: '[PRE167]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: How it works...
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can use a `CompletableFuture` object with two main purposes:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个`CompletableFuture`对象实现两个主要目的：
- en: Wait for a value or an event that will be produced in future (creating an object
    and using the `complete()` and `get()` or `join()` methods).
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待未来将产生的值或事件（创建一个对象并使用`complete()`和`get()`或`join()`方法）。
- en: To organize a set of tasks to be executed in a determined order so one or more
    tasks won't start their execution until others have finished their execution.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了按确定顺序执行一系列任务，确保一个或多个任务不会在其它任务完成执行之前开始执行。
- en: In this example, we made both uses of the `CompletableFuture` class. First,
    we created an instance of this class and sent it as a parameter to a `SeedGenerator`
    task. This task uses the `complete()` method to send the calculated value, and
    the `main()` method uses the `get()` method to obtain the value. The `get()` method
    sleeps the current thread until `CompletableFuture` has been completed.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`CompletableFuture`类的两种用法。首先，我们创建了这个类的实例，并将其作为参数发送给一个`SeedGenerator`任务。这个任务使用`complete()`方法发送计算值，而`main()`方法使用`get()`方法获取值。`get()`方法将当前线程挂起，直到`CompletableFuture`完成。
- en: Then, we used the `supplyAsync()` method to generate a `CompletableFuture` object.
    This method receives an implementation of the `Supplier` interface as a parameter.
    This interface provides the `get()` method that must return a value. The `supplyAsync()`
    method returns `CompletableFuture`, which will be completed when the `get()` method
    finishes its execution; the value of completion is the value returned by that
    method. The `CompletableFuture` object returned will be executed by a task in
    the `ForkJoinPool` returns the static method `commonPool()`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了`supplyAsync()`方法来生成一个`CompletableFuture`对象。此方法接收一个`Supplier`接口的实现作为参数。该接口提供了一个必须返回值的`get()`方法。`supplyAsync()`方法返回`CompletableFuture`，当`get()`方法完成执行时将完成；完成值是该方法返回的值。返回的`CompletableFuture`对象将由`ForkJoinPool`中的任务执行，该任务返回静态方法`commonPool()`。
- en: Then, we used the `thenApplyAsync()` method to link some tasks. You call this
    method in a `CompletableFuture` object, and you must pass an implementation of
    the `Function` interface as a parameter that can be expressed directly in the
    code using a functional style or an independent object. One powerful characteristic
    is that the value generated by `CompletableFuture` will be passed as a parameter
    to the `Function`. That is to say, in our case, all the three steps will receive
    a random list of numbers as parameters. The `CompletableFuture` class returned
    will be executed by a task in the `ForkJoinPool` returns the static method `commonPool()`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了`thenApplyAsync()`方法来链接一些任务。你需要在`CompletableFuture`对象中调用此方法，并且必须传递一个实现了`Function`接口的实现作为参数，该参数可以直接使用函数式风格或独立对象在代码中表达。一个强大的特性是，由`CompletableFuture`生成的值将被传递给`Function`作为参数。也就是说，在我们的情况下，所有三个步骤都将接收一个随机数字列表作为参数。返回的`CompletableFuture`类将由`ForkJoinPool`中的任务执行，该任务返回静态方法`commonPool()`。
- en: Finally, we used the `allOf()` static method of the `CompletableFuture` class
    to wait for the finalization of various tasks. This method receives a variable
    list of `CompletableFuture` objects and returns a `CompletableFuture` class that
    will be completed when all the `CompletableFuture` class passed as parameters
    are completed. We also used the `thenAcceptAsync()` method as another way to synchronize
    tasks because this method receives `Consumer` as a parameter that is executed
    by the default executor when the `CompletableFuture` object used to call the method
    is completed. Finally, we used the `join()` method to wait for the finalization
    of the last `CompletableFuture` object.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了`CompletableFuture`类的`allOf()`静态方法来等待各种任务的最终化。此方法接收一个可变数量的`CompletableFuture`对象列表，并返回一个`CompletableFuture`类，当所有作为参数传递的`CompletableFuture`类完成时，它将被完成。我们还使用了`thenAcceptAsync()`方法作为同步任务的另一种方式，因为此方法接收`Consumer`作为参数，当使用`CompletableFuture`对象调用该方法时，默认执行器将执行它。最后，我们使用了`join()`方法来等待最后一个`CompletableFuture`对象的最终化。
- en: 'The following screenshot shows the execution of the example. You can see how
    the tasks are executed in the order we organized:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了示例的执行。你可以看到任务是如何按照我们组织的顺序执行的：
- en: '![](img/00026.jpeg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: There's more...
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'In the example of this recipe, we used the `complete()`, `get()`, `join()`,
    `supplyAsync()`, `thenApplyAsync()`, `thenAcceptAsync()`, and `allOf()` methods
    of the `CompletableFuture` class. However, this class has a lot of useful methods
    that help increase the power and flexibility of this class. These are the most
    interesting ones:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱的示例中，我们使用了`CompletableFuture`类的`complete()`、`get()`、`join()`、`supplyAsync()`、`thenApplyAsync()`、`thenAcceptAsync()`和`allOf()`方法。然而，这个类有很多有用的方法，有助于提高这个类的功能和灵活性。这些是最有趣的：
- en: 'Methods to complete a `CompletableFuture` object: In addition to the `complete()`
    method, the `CompletableFuture` class provides the following three methods:'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成完成`CompletableFuture`对象的方法：除了`complete()`方法之外，`CompletableFuture`类还提供了以下三个方法：
- en: '`cancel()`: This completes `CompletableFuture` with a `CancellationException`
    exception.'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancel()`: 这个方法使用`CancellationException`异常来完成`CompletableFuture`。'
- en: '`completeAsync()`: This completes `CompletableFuture` with the result of the
    `Supplier` object passed as a parameter. The `Supplier` object is executed in
    a different thread by the default executor.'
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completeAsync()`: 这个方法使用作为参数传递的`Supplier`对象的结果来完成`CompletableFuture`。默认情况下，`Supplier`对象会在不同的线程中由执行器执行。'
- en: '`completeExceptionally()`: This method completes `CompletableFuture` with the
    exception passed as a parameter.'
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completeExceptionally()`: 这个方法使用作为参数传递的异常来完成`CompletableFuture`。'
- en: 'Methods to execute a task: In addition to the `supplyAsync()` method, the `CompletableFuture`
    class provides the following method:'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行任务的方法：除了`supplyAsync()`方法之外，`CompletableFuture`类还提供了以下方法：
- en: '`runAsync()`: This is a static method of the `CompletableFuture` class that
    returns a `CompletableFuture` object. This object will be completed when the `Runnable`
    interface is passed as a parameter to finish its execution. It will be completed
    with a void result.'
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAsync()`: 这是`CompletableFuture`类的一个静态方法，它返回一个`CompletableFuture`对象。当将`Runnable`接口作为参数传递以完成其执行时，此对象将被完成。它将以空结果完成。'
- en: 'Methods to synchronize the execution of different tasks: In addition to the
    `allOf()`, `thenAcceptAsync()`, and `thenApplyAsync()` methods, the `CompletableFuture`
    class provides the following methods to synchronize the execution of tasks:'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步不同任务执行的方法：除了 `allOf()`、`thenAcceptAsync()` 和 `thenApplyAsync()` 方法外，`CompletableFuture`
    类还提供了以下方法来同步任务的执行：
- en: '`anyOf()`: This is a static method of the `CompletableFuture` class. It receives
    a list of `CompletableFuture` objects and returns a new `CompletableFuture` object.
    This object will be completed with the result of the first `CompletableFuture`
    parameter that is completed.'
  id: totrans-557
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anyOf()`: 这是 `CompletableFuture` 类的静态方法。它接收一个 `CompletableFuture` 对象的列表，并返回一个新的
    `CompletableFuture` 对象。此对象将使用第一个完成的 `CompletableFuture` 参数的结果来完成。'
- en: '`runAfterBothAsync()`: This method receives `CompletionStage` and `Runnable`
    objects as parameters and returns a new `CompletableFuture` object. When `CompletableFuture`
    (which does the calling) and `CompletionStage` (which is received as a parameter) are
    completed, the `Runnable` object is executed by the default executor and then
    the `CompletableFuture` object returned is completed.'
  id: totrans-558
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAfterBothAsync()`: 这个方法接收 `CompletionStage` 和 `Runnable` 对象作为参数，并返回一个新的
    `CompletableFuture` 对象。当 `CompletableFuture`（执行调用）和 `CompletionStage`（作为参数接收）完成时，`Runnable`
    对象将由默认执行器执行，然后返回的 `CompletableFuture` 对象完成。'
- en: '`runAfterEitherAsync()`: This method is similar to the previous one, but here,
    the `Runnable` interface is executed after one of the two (`CompletableFuture`
    or `CompletionStage`) are completed.'
  id: totrans-559
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAfterEitherAsync()`: 这个方法与上一个方法类似，但在这里，`Runnable` 接口在两个（`CompletableFuture`
    或 `CompletionStage`）中的任何一个完成之后执行。'
- en: '`thenAcceptBothAsync()`: This method receives `CompletionStage` and `BiConsumer`
    objects as parameters and returns `CompetableFuture` as a parameter. When `CompletableFuture`
    (which does the calling) and `CompletionStage` (which is passed as a parameter),
    `BiConsumer` is executed by the default executor. It receives the results of the
    two `CompletionStage` objects as parameters but it won''t return any result. When
    `BiConsumer` finishes its execution, the returned `CompletableFuture` class is
    completed without a result.'
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenAcceptBothAsync()`: 这个方法接收 `CompletionStage` 和 `BiConsumer` 对象作为参数，并返回
    `CompetableFuture` 作为参数。当 `CompletableFuture`（执行调用）和 `CompletionStage`（作为参数传递），`BiConsumer`
    由默认执行器执行。它接收两个 `CompletionStage` 对象的结果作为参数，但它不会返回任何结果。当 `BiConsumer` 完成其执行时，返回的
    `CompletableFuture` 类将完成，但没有结果。'
- en: '`thenCombineAsync()`: This method receives a `CompletionStage` object and a
    `BiFunction` object as parameters and returns a new `CompletableFuture` object.
    When `CompletableFuture` (which does the calling) and `CompletionStage` (which
    is passed as a parameter) are completed, the `BiFunction` object is executed;
    it receives the completion values of both the objects and returns a new result
    that will be the completion value of the returned `CompletableFuture` class.'
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenCombineAsync()`: 这个方法接收一个 `CompletionStage` 对象和一个 `BiFunction` 对象作为参数，并返回一个新的
    `CompletableFuture` 对象。当 `CompletableFuture`（执行调用）和 `CompletionStage`（作为参数传递）完成时，`BiFunction`
    对象将被执行；它接收两个对象的完成值，并返回一个新的结果，该结果将成为返回的 `CompletableFuture` 类的完成值。'
- en: '`thenComposeAsync()`:This method is analogous to `thenApplyAsync()`, but it
    is useful when the supplied function returns `CompletableFuture` too.'
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenComposeAsync()`: 这个方法类似于 `thenApplyAsync()`，但当提供的函数也返回 `CompletableFuture`
    时，它非常有用。'
- en: '`thenRunAsync()`: This method is analogous to the `thenAcceptAsync()` method,
    but in this case, it receives a `Runnable` object as a parameter instead of a
    `Consumer` object.'
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenRunAsync()`: 这个方法类似于 `thenAcceptAsync()` 方法，但在这个情况下，它接收一个 `Runnable` 对象作为参数，而不是
    `Consumer` 对象。'
- en: 'Methods to obtain the completion value: In addition to the `get()` and `join()`
    methods, the `CompletableFuture` object provides the following method to get the
    completion value:'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取完成值的方法：除了 `get()` 和 `join()` 方法外，`CompletableFuture` 对象还提供了以下方法来获取完成值：
- en: '`getNow()`: This receives a value of the same type of the completion value
    of `CompletableFuture`. If the object is completed, it returns the completion
    value. Else, it returns the value passed as the parameter.'
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNow()`: 这个方法接收与 `CompletableFuture` 完成值相同类型的值。如果对象已完成，它将返回完成值。否则，它将返回作为参数传递的值。'
- en: See also...
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见...
- en: The *Creating a thread executor and controlling its rejected tasks* and *Executing
    tasks in an executor that returns a result* recipes in [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Executors*
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建线程执行器及其控制拒绝的任务* 和 *在返回结果的执行器中执行任务* 这两个配方在 [第4章](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736)，*线程执行器*
    中介绍。'
