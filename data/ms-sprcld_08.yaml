- en: Routing and Filtering with API Gateway
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 API 网关进行路由和过滤
- en: In this chapter, we will discuss the next important element of microservice-based
    architecture, an API gateway. It is not our first encounter with that element
    in practice. We have already implemented a simple gateway pattern in [Chapter
    4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*, for the purpose
    of presenting how a zoning mechanism works for service discovery with Eureka.
    We used Netflix's Zuul library, which is a JVM-based router and server-side load
    balancer. Netflix designed Zuul to provide features such as authentication, stress
    and canary testing, dynamic routing, and active/active multiregional traffic management. Although
    this is not explicitly stated, it also acts as a gateway in microservice architecture
    and its main task is to hide the complexity of your system from an external client.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论微服务架构中的下一个重要元素——API 网关。在实践中，这并不是我们第一次遇到这个元素。我们已经在[第 4 章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)，*服务发现*中实现了一个简单的网关模式，以展示如何在
    Eureka 中使用分区机制进行服务发现。我们使用了 Netflix 的 Zuul 库，它是一个基于 JVM 的路由和服务器端负载均衡器。Netflix 设计
    Zuul 以提供诸如认证、压力和金丝雀测试、动态路由以及活动/活动多区域流量管理等功能。虽然这没有明确说明，但它也在微服务架构中充当网关，并其主要任务是隐藏系统的外部客户端复杂性。
- en: Until now, Zuul, in fact, didn't have any competition when it came to API gateway
    pattern implementation inside the Spring Cloud framework. However, the situation
    is changing dynamically with the progressive development of a new project called
    Spring Cloud Gateway. It is built on the base of Spring Framework 5, Project Reactor,
    and Spring Boot 2.0\. The last stable version of that library is 1.0.0, but there
    are many crucial changes in the version currently being developed, 2.0.0, which
    is still at the milestone stage. Spring Cloud Gateway aims to provide a simple,
    effective way to route to APIs and provide cross-cutting concerns related to them
    such as security, monitoring/metrics, and resiliency. Although the solution is
    relatively new, it is definitely worthy of attention.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，Zuul 在 Spring Cloud 框架内部实现 API 网关模式时实际上并没有任何竞争。然而，随着一个名为 Spring Cloud Gateway
    的新项目的不断发展，这种情况正在动态变化。它基于 Spring Framework 5、Project Reactor 和 Spring Boot 2.0。该库的最后稳定版本是
    1.0.0，但目前正在开发的版本 2.0.0 中有很多关键变化，目前仍处于里程碑阶段。Spring Cloud Gateway 旨在提供一种简单、有效的方式来路由
    API 并提供与它们相关的交叉关注点，例如安全性、监控/度量以及弹性。尽管这个解决方案相对较新，但它绝对值得关注。
- en: 'The topics we will cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涉及的主题包括：
- en: Static routing and load balancing based on URLs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 URL 的静态路由和负载均衡
- en: Integrating Zuul and Spring Cloud Gateway with service discovery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Zuul 与 Spring Cloud Gateway 集成并实现服务发现
- en: Creating custom filters with Zuul
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Zuul 创建自定义过滤器
- en: Customizing route configuration with Zuul
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Zuul 自定义路由配置
- en: Providing Hystrix fallback in case of route failure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由失败的情况下提供 Hystrix 回退
- en: Description of the main components included in Spring Cloud Gateway—predicators
    and gateway filters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway 中包含的主要组件的描述——预测器和网关过滤器
- en: Using Spring Cloud Netflix Zuul
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Netflix Zuul
- en: Spring Cloud has implemented an embedded Zuul proxy to allow frontend application's
    proxy calls to backend services. This feature is useful for external clients,
    because it hides system complexity and helps to avoid the need to manage CORS
    and authentication concerns independently for all microservices. To enable it,
    you should annotate a Spring Boot main class with `@EnableZuulProxy`, and this
    forwards incoming requests to the target service. Of course, Zuul is integrated
    with the Ribbon load balancer, Hystrix circuit breaker, and service discovery,
    for example with Eureka.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 实现了一个内嵌的 Zuul 代理，以便前端应用程序能够代理调用后端服务。这个特性对于外部客户端来说非常有用，因为它隐藏了系统复杂性，并帮助避免为所有微服务独立管理
    CORS 和认证问题。要启用它，你应该用 `@EnableZuulProxy` 注解标注一个 Spring Boot 主类，然后它将传入的请求转发到目标服务。当然，Zuul
    与 Ribbon 负载均衡器、Hystrix 断路器以及服务发现集成，例如与 Eureka。
- en: Building a gateway application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建网关应用程序
- en: 'Let''s go back to the example from the previous chapter to append the last
    element in the microservice-based architecture, API Gateway. What we haven''t
    considered yet is how the external client would call our services. First, we would
    not want to expose the network addresses of all microservices running inside the
    system. We may also perform some operations such as request authentication or
    setting tracing headers in just one place. The solution is to share only a single
    edge network address, which proxies all the incoming requests to the appropriate
    service. The current example''s system architecture is illustrated in the following
    diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到前一章节的示例，以添加微服务架构的最后一步，API网关。我们还没有考虑的是外部客户端如何调用我们的服务。首先，我们不希望暴露系统内所有微服务的网络地址。我们还可以在单一位置执行一些操作，例如请求认证或设置跟踪头。解决方案是只共享一个边缘网络地址，该地址将所有传入请求代理到适当的服务。当前示例的系统架构在下图中说明：
- en: '![](img/f535ba1e-68e6-4411-9d7d-d75bf828c6bf.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f535ba1e-68e6-4411-9d7d-d75bf828c6bf.png)'
- en: 'For the needs of our current sample, let me go back for a moment to the project
    already discussed in the previous chapter. It is available in GitHub ([https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git))
    in `master` branch. Now, we will add a new module called `gateway-service` to
    that project. The first step is to include Zuul with the Maven dependencies. We
    have to use the `spring-cloud-starter-zuul` starter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足我们当前示例的需求，让我回到前一章节中已经讨论过的项目。它可以在GitHub上找到（[https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git)），在`master`分支中。现在，我们将向该项目添加一个名为`gateway-service`的新模块。第一步是使用Maven依赖项包含Zuul：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After annotating a Spring Boot main class with `@EnableZuulProxy`, we may proceed
    to route configuration, which is provided in the `application.yml` file. By default,
    the Zuul starter artifact does not include the service discovery client. The routes
    are configured statically with the `url` property set to the network address of
    the service. Now, if you launch all the microservices and the gateway application,
    you may try to call them via the gateway. Each service is available under the
    path set in the configuration property `path` for every single route, for example, `http://localhost:8080/account/1`
    would be forwarded to `http://localhost:8091/1`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot主类上使用`@EnableZuulProxy`注解后，我们可以继续进行路由配置，该配置位于`application.yml`文件中。默认情况下，Zuul启动器artifact不包含服务发现客户端。路由是使用`url`属性静态配置的，该属性设置为服务的网络地址。现在，如果您启动了所有微服务和网关应用程序，您可以尝试通过网关调用它们。每个服务都可以在为每个路由配置的`path`属性设置的路径下访问，例如，`http://localhost:8080/account/1`将被转发到`http://localhost:8091/1`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Integration with service discovery
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务发现集成
- en: 'The static route configuration presented in the previous example is not enough
    for a microservice-based system. The main requirement for an API gateway is a
    built-in integration with service discovery. To enable service discovery with
    Eureka for Zuul, we have to include the `spring-cloud-starter-eureka` starter
    in the project dependencies and enable the client by annotating the application''s
    main class with `@EnableDiscoveryClient`. In fact, it does not make sense to let
    the gateway register itself in discovery server, it must only fetch the current
    list of registered services. So we would disable that registration by setting
    the `eureka.client.registerWithEureka` property to `false`. The route''s definition
    in the `application.yml` file is really simple. Each route''s name is mapped to
    the application service name in Eureka:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中呈现的静态路由配置对于基于微服务的系统来说是不够的。API网关的主要要求是与服务发现的内置集成。为了使Zuul与Eureka集成，我们必须在项目依赖项中包含`spring-cloud-starter-eureka`启动器，并通过注释应用程序的主类来启用客户端`@EnableDiscoveryClient`。实际上，让网关自己在发现服务器上注册是没有意义的，它只能获取当前注册的服务列表。因此，我们将通过将`eureka.client.registerWithEureka`属性设置为`false`来禁用该注册。`application.yml`文件中的路由定义非常简单。每个路由的名称映射到Eureka中的应用程序服务名称：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Customizing route configuration
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义路由配置
- en: There are several configuration settings, which allow us to customize the behavior
    of the Zuul proxy. Some of them are strictly related to the service discovery
    integration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些配置设置，允许我们自定义Zuul代理的行为。其中一些与服务发现集成密切相关。
- en: Ignoring registered services
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略注册的服务
- en: 'Spring Cloud Zuul by default exposes all the services registered in Eureka
    server. If you would like to skip the automatic addition of every service, you
    have to set the `zuul.ignored-services` property with a pattern matched to all
    the ignored service names from a discovery server. How does it work in practice?
    Even if you do not provide any configuration with `zuul.routes.*` properties,
    Zuul would fetch the list of services from Eureka and automatically bind them
    to the path with the service name. For example, `account-service` would be available
    under the gateway address `http://localhost:8080/account-service/**`. Now, if
    you set the following configuration in  your `application.yml` file, it would
    ignore `account-service` and respond with an HTTP 404 status:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Cloud Zuul会暴露Eureka服务器中注册的所有服务。如果您想跳过每个服务的自动添加，您必须使用与发现服务器中所有忽略的服务名称匹配的模式设置`zuul.ignored-services`属性。实际工作中它是如何工作的呢？即使您没有提供任何`zuul.routes.*`属性的配置，Zuul也会从Eureka获取服务列表并将它们自动绑定到服务名称的路径下。例如，`account-service`将在网关地址`http://localhost:8080/account-service/**`下可用。现在，如果您在`application.yml`文件中设置了以下配置，它将忽略`account-service`并返回一个HTTP
    404状态码：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You may also ignore all registered services by setting `zuul.ignored-services` to `''*''`. If
    a service matches a pattern that is ignored, but also included in the routes map
    configuration, then it will be included by Zuul. In that case, only `customer-service`
    would be processed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将`zuul.ignored-services`设置为`'*'`来忽略所有注册的服务。如果一个服务与被忽略的模式匹配，但同时也包含在路由映射配置中，那么Zuul将会包含它。在这种情况下，只有`customer-service`会被处理：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Explicity set service name
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式设置服务名称
- en: 'The service name from a discovery server may also be set in configuration using
    the `serviceId` property. It gives you fine-grained control over a route, because
    you can specify the path and the `serviceId` independently. Here''s the equivalent
    configuration of the routes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从发现服务器获取的服务名称也可以在配置中使用`serviceId`属性进行设置。它使你能够对路由进行细粒度控制，因为你可以独立指定路径和`serviceId`。以下是路由的等效配置：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Route definition with the Ribbon client
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有Ribbon客户端的路由定义
- en: 'There is another approach to configuring routes. We may disable Eureka discovery
    in order to rely solely on a list of network addresses provided with the `listOfServers`
    property of the Ribbon client. All incoming requests to the gateway are load balanced
    by default between all instances of the service through a Ribbon client. This
    rule is true even if you enable or disable service discovery, as in the following
    example code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种配置路由的方法。我们可以禁用Eureka发现，以便只依赖于Ribbon客户端提供的`listOfServers`属性的网络地址列表。网关的所有传入请求默认通过Ribbon客户端在所有服务实例之间进行负载均衡。即使您启用了或禁用了服务发现，以下示例代码也是正确的：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Adding a prefix to the path
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为路径添加前缀
- en: Sometimes it is necessary to set a different path for services invoked via a
    gateway rather than allow them being available directly. In that case, Zuul provides
    the ability to add prefixes to all the defined mappings. This may be easily configured
    with the `zuul.prefix` property. By default, Zuul cuts that prefix before forwarding
    requests to the services. However, that behavior can also be disabled by setting
    the `zuul.stripPrefix` property to `false`. A `stripPrefix` property may be configured
    not only globally for all defined routes, but also per single route.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了让通过网关调用的服务设置不同的路径，而不是直接可用，这是必要的。在这种情况下，Zuul提供了为所有定义的映射添加前缀的能力。这可以通过`zuul.prefix`属性轻松配置。默认情况下，Zuul在将请求转发给服务之前截断该前缀。然而，通过将`zuul.stripPrefix`属性设置为`false`，可以禁用这种行为。`stripPrefix`属性不仅可以为所有定义的路由全局配置，还可以为每个单独的路由配置。
- en: 'Here''s an example that adds the `/api` prefix to all the forwarded requests.
    Now, for example, if you would like to call the `GET /{id}` endpoint from `account-service`*,*
    you should use the address `http://localhost:8080/api/account/1`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例为所有转发请求添加了`/api`前缀。现在，例如，如果您想从`account-service`调用`GET /{id}`端点，您应该使用地址`http://localhost:8080/api/account/1`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What would happen if we have provided the configuration with `stripPrefix`
    set to `false`? Zuul would try to look for endpoints in the target services under
    the context paths `/api/account` and `/api/customer`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供了`stripPrefix`设置为`false`的配置会发生什么？Zuul将尝试在目标服务的上下文路径`/api/account`和`/api/customer`下查找端点：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Connection settings and timeouts
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接设置和超时
- en: The main task of Spring Cloud Netflix Zuul is to route incoming requests to
    downstream services. Therefore, it has to use an HTTP client implementation to
    communicate with those services. The default HTTP client used by Zuul is now backed
    by the Apache HTTP Client instead of the deprecated Ribbon `RestClient`. If you
    would like to use Ribbon, you should set the `ribbon.restclient.enabled` property to
    `true`. You may also try `OkHttpClient` by setting the `ribbon.okhttp.enabled` property to
    `true`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Cloud Netflix Zuul的主要任务**是将传入请求路由到下游服务。因此，它必须使用一个HTTP客户端实现与这些服务的通信。Zuul目前默认使用的HTTP客户端是由Apache
    HTTP Client支持的，而不是已被弃用的Ribbon `RestClient`。如果你想要使用Ribbon，你应该将`ribbon.restclient.enabled`属性设置为`true`。你也可以通过将`ribbon.okhttp.enabled`属性设置为`true`来尝试`OkHttpClient`。'
- en: We may configure the basic settings for HTTP clients such as the connect or
    read timeout, and the maximum number of connections. There are two available options
    for such configurations depending on whether we are using service discovery or
    not. If you have defined Zuul routes with a specified network address through
    the `url` property, then you should set `zuul.host.connect-timeout-millis` and
    `zuul.host.socket-timeout-millis`. For the purpose of controlling the maximum
    number of connections, you should override the default value of the `zuul.host.maxTotalConnections`
    property, which is by default set to `200`. It is also possible to define the maximum
    number of connections per single route by setting the `zuul.host.maxPerRouteConnections`
    property, which is by default `20`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为HTTP客户端配置基本设置，如连接或读取超时以及最大连接数。根据我们是否使用服务发现，此类配置有两大选项。如果你通过`url`属性定义了具有指定网络地址的Zuul路由，那么你应该设置`zuul.host.connect-timeout-millis`和`zuul.host.socket-timeout-millis`。为了控制最大连接数，你应该覆盖默认值为`200`的`zuul.host.maxTotalConnections`属性。你也可以通过设置默认值为`20`的`zuul.host.maxPerRouteConnections`属性来定义每个单一路径的最大连接数。
- en: If Zuul is configured to fetch a list of services from the discovery server,
    you need to configure the same timeouts as before with the Ribbon client properties `ribbon.ReadTimeout`
    and `ribbon.SocketTimeout`. The maximum number of connections can be customized
    with `ribbon.MaxTotalConnections` and `ribbon.MaxConnectionsPerHost`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Zuul配置为从发现服务器获取服务列表，你需要使用与Ribbon客户端属性`ribbon.ReadTimeout`和`ribbon.SocketTimeout`相同的超时配置。最大连接数可以通过`ribbon.MaxTotalConnections`和`ribbon.MaxConnectionsPerHost`进行自定义。
- en: Secure headers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全头
- en: 'You may be a little surprised if you set, for example, the `Authorization`
    HTTP header in the request and it isn''t forwarded to the downstream service.
    This is because Zuul defines a default list of sensitive headers, which are removed
    during the routing process. These are the headers `Cookie`, `Set-Cookie`, and
    `Authorization`. This feature has been designed with a view to communicate with external
    servers. While there is no objection to sharing headers between services in the
    same system, it is not recommended to share them with external servers for security
    reasons. This approach may be customized by overriding default values for the `sensitiveHeaders`
    property. It may be set globally for all routes or just for a single route. The
    `sensitiveHeaders` are a not an empty blacklist, so to make Zuul forward all headers,
    you should explicitly set it to the empty list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在请求中设置了例如`Authorization` HTTP头，但它没有被转发到下游服务，你可能会有些惊讶。这是因为Zuul定义了一个默认的敏感头列表，在路由过程中会移除这些头。这些头包括`Cookie`、`Set-Cookie`和`Authorization`。这一特性是为了与外部服务器通信而设计的。虽然对于同一系统中的服务之间共享头没有反对意见，但出于安全原因，不建议与外部服务器共享。可以通过覆盖`sensitiveHeaders`属性的默认值来自定义这种方法。它可以为所有路由或单个路由全局设置。`sensitiveHeaders`不是一个空的黑名单，所以为了使Zuul转发所有头，你应该明确将其设置为空列表：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Management endpoints
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理端点
- en: 'Spring Cloud Netflix Zuul exposes two additional management endpoints for monitoring:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix Zuul暴露了两个用于监控的额外管理端点：
- en: '**Routes**: Prints a list of defined routes'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：打印出定义的路由列表'
- en: '**Filters**: Prints a list of implemented filters (available from version `1.4.0.RELEASE`
    of Spring Cloud Netflix)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：打印出实现过滤器的列表（自Spring Cloud Netflix版本`1.4.0.RELEASE`起可用）'
- en: 'To enable the managements endpoints feature, we have to include (as always) `spring-boot-starter-actuator`
    in the project dependencies. It''s a good idea to disable endpoint security for
    test purposes by setting the `management.security.enabled` property to `false`.
    Now, you may just call the `GET /routes` method and it would print the following
    JSON response for our example system:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用管理端点功能，我们必须（像往常一样）在项目依赖中包含`spring-boot-starter-actuator`。为了测试目的，禁用端点安全是一个好主意，通过将`management.security.enabled`属性设置为`false`。现在，你可以调用`GET
    /routes`方法，它将打印出我们示例系统的以下JSON响应：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For more detailed information, you have to add the `?format=details` query
    string to the `/routes` path. That option is also available from version 1.4.0
    of Spring Cloud (Edgware Release Train). There is also a `POST /route` method
    that would force a refresh of the currently existing routes. Additionally, you
    can disable the whole endpoint by setting `endpoints.routes.enabled` to `false`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多详细信息，必须在`/routes`路径上添加`?format=details`查询字符串。这个选项从Spring Cloud版本1.4.0（Edgware发布列车）也开始提供。还有一个`POST
    /route`方法，可以强制刷新当前存在的路由。另外，您可以通过将`endpoints.routes.enabled`设置为`false`来禁用整个端点：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The response result of the `/filters` endpoint is pretty interesting. You may
    see how many and what types of filters are available by default on the Zuul gateway.
    Here''s the fragment of a response with one selected filter. It contains a full
    class name, the order of calling, and status. For more information about filters,
    you can refer to the section, *Zuul filters*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`/filters`端点的响应结果非常有趣。你可以看到Zuul网关默认提供了多少种过滤器和过滤器类型。以下是带有选定过滤器的一个响应片段。它包含完整的类名，调用顺序和状态。关于过滤器的更多信息，你可以参考*Zuul过滤器*部分：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Providing Hystrix fallback
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供Hystrix回退
- en: We may provide a fallback response for every single route defined in Zuul's
    configuration, in case a circuit is opened. To do that, we should create a bean
    of type `ZuulFallbackProvider` (which is currently deprecated) or `FallbackProvider`.
    Inside that implementation, we have to specify the route ID pattern to match all
    the routes that should be handled by the fallback bean. The second step is to
    return the implementation of the `ClientHttpResponse` interface as a response
    in the `fallbackResponse` method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要为Zuul配置中定义的每个单独的路由提供一个回退响应，以防电路被打开。为此，我们应该创建一个类型为`ZuulFallbackProvider`（目前已被弃用）或`FallbackProvider`的bean。在这个实现中，我们必须指定路由ID模式，以匹配所有应该由回退bean处理的路由。第二步是在`fallbackResponse`方法中返回`ClientHttpResponse`接口的实现作为响应。
- en: 'Here''s a simple fallback bean that maps every exception to the HTTP status
    `200 OK` and sets the `errorCode` and `errorMessage` in the JSON response. Fallback
    is only executed for the `account-service` route:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的回退bean，它将每个异常映射到HTTP状态`200 OK`，并在JSON响应中设置`errorCode`和`errorMessage`。仅针对`account-service`路由执行回退。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Zuul filters
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zuul过滤器
- en: As I have already mentioned, Spring Cloud Zuul by default provides a couple
    of beans, which are the implementations of the `ZuulFilter` interface. Every built-in
    filter may be disabled by setting the `zuul.<SimpleClassName>.<filterType>.disable` property to
    `true`. For example, to disable `org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter`,
    you have to set `zuul.SendResponseFilter.post.disable=true`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我前面已经提到的，Spring Cloud Zuul默认提供了一些bean，这些bean是`ZuulFilter`接口的实现。每个内置过滤器都可以通过将`zuul.<SimpleClassName>.<filterType>.disable`属性设置为`true`来禁用。例如，要禁用`org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter`，你必须设置`zuul.SendResponseFilter.post.disable=true`。
- en: 'The HTTP filtering mechanism is probably well known to you. A filter dynamically
    intercepts requests and responses to transform, or just use, the information taken
    from the HTTP message. It may be triggered before or after an incoming request
    or outgoing response. We may identify a couple of types of filter provided by
    Zuul for Spring Cloud:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP过滤机制你可能已经很熟悉了。过滤器动态地拦截请求和响应以转换，或者只是使用，从HTTP消息中获取的信息。它可能在 incoming request或outgoing
    response之前或之后触发。我们可以识别出由Zuul为Spring Cloud提供的几种类型的过滤器：
- en: '**Pre filter**: It is used to prepare initial data in the `RequestContext`
    for use in filters downstream. The main responsibility is to set information required
    for route filters.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预过滤器**：它用于在`RequestContext`中准备初始数据，以在下游过滤器中使用。主要责任是设置路由过滤器所需的信息。'
- en: '**Route filter**: It is called after the pre filter and is responsible for
    creating requests to other services. The main reason for using it is a need to
    adapt a request or response to the model required by the client.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由过滤器**：它在预过滤器之后调用，负责创建到其他服务的请求。使用它的主要原因是需要适应客户端所需的请求或响应模型。'
- en: '**Post filter**: Most commonly, it manipulates the response. It may even transform
    the response body.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后过滤器**：最常见的是操作响应。它甚至可以转换响应体。'
- en: '**Error filter**: It is executed only if an exception is thrown by other filters.
    There is only one built-in implementation of an error filter. `SendErrorFilter`
    is executed if `RequestContext.getThrowable()` is not null.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误过滤器**：它仅在其他过滤器抛出异常时执行。只有一个内置的错误过滤器实现。如果`RequestContext.getThrowable()`不为空，则执行`SendErrorFilter`。'
- en: Predefined filters
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预定义过滤器
- en: 'If you annotate the main class with `@EnableZuulProxy`, Spring Cloud Zuul loads
    the filter beans used by both `SimpleRouteLocator` and `DiscoveryClientRouteLocator`.
    This is a list of the most important implementations installed as normal Spring
    Beans:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用`@EnableZuulProxy`注解主类，Spring Cloud Zuul会加载`SimpleRouteLocator`和`DiscoveryClientRouteLocator`使用的过滤器bean。这是作为普通Spring
    Bean安装的一些最重要的实现列表：
- en: '`ServletDetectionFilter`: This is a pre filter. It checks whether the request
    is coming through the Spring Dispatcher. Sets a Boolean with the key `FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServletDetectionFilter`：这是一个**预过滤器**。它检查请求是否通过Spring Dispatcher。设置了一个布尔值，键为`FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY`。'
- en: '`FormBodyWrapperFilter`: This is a pre filter. It parses form data and re-encodes
    it for downstream requests.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormBodyWrapperFilter`：这是一个**预过滤器**。它解析表单数据并重新编码以供下游请求使用。'
- en: '`PreDecorationFilter`: This is a pre filter. It determines where and how to
    route based on the supplied `RouteLocator`. It is also responsible for setting
    headers related to the proxy.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreDecorationFilter`：这是一个**预过滤器**。它根据提供的`RouteLocator`确定路由的位置和方式。它还负责设置与代理相关的头信息。'
- en: '`SendForwardFilter`: This is a route filter. It forwards requests using `RequestDispatcher`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendForwardFilter`：这是一个**路由过滤器**。它使用`RequestDispatcher`转发请求。'
- en: '`RibbonRoutingFilter`: This is a route filter. It uses Ribbon, Hystrix, and
    external HTTP clients such as Apache `HttpClient`, `OkHttpClient`, or Ribbon HTTP
    client to send requests. Service IDs are taken from the request context.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RibbonRoutingFilter`：这是一个**路由过滤器**。它使用Ribbon、Hystrix和外部HTTP客户端，如Apache `HttpClient`、`OkHttpClient`或Ribbon
    HTTP客户端来发送请求。服务ID从请求上下文中获取。'
- en: '`SimpleHostRoutingFilter`: This is a route filter. It sends requests to URLs
    via an Apache HTTP client. URLs are found in the request context.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleHostRoutingFilter`：这是一个**路由过滤器**。它通过Apache HTTP客户端将请求发送到URL。 URL在请求上下文中找到。'
- en: '`SendResponseFilter`: This is a post filter. It writes responses from proxied
    requests to the current response.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendResponseFilter`：这是一个**后过滤器**。它将代理请求的响应写入当前响应。'
- en: Custom implementations
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义实现
- en: 'In addition to the filters installed by default, we may create our custom implementations. 
    Each of them has to implement the `ZuulFilter` interface and its four methods.
    These methods are responsible for setting the type of filter (`filterType`), determining
    the order of filter execution between other filtering with the same type (`filterOrder`),
    enabling or disabling the filter (`shouldFilter`) and finally the filter logic
    implementation (`run`). Here''s an example implementation that adds the `X-Response-ID` header to
    the response:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认安装的过滤器之外，我们还可以创建自己的自定义实现。 每个实现都必须实现`ZuulFilter`接口及其四个方法。 这些方法负责设置过滤器的类型（`filterType`）、确定与其他具有相同类型的过滤器执行的顺序（`filterOrder`）、启用或禁用过滤器（`shouldFilter`）以及最后过滤逻辑实现（`run`）。
    以下是一个示例实现，它向响应中添加了`X-Response-ID`头：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s not all that has to be done. The custom filter implementation should
    also be declared as an `@Bean` in the main class or Spring configuration class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多工作要做。自定义过滤器实现也应该在主类或Spring配置类中声明为`@Bean`：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using Spring Cloud Gateway
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway
- en: 'There are three basic concepts around Spring Cloud Gateway:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕Spring Cloud Gateway有三个基本概念：
- en: '**Route**: That is the basic building block of the gateway. It consists of
    a unique ID for identifying a route, a destination URI, a list of predicates,
    and a list of filters. A route is matched only if all the predicates have been
    fulfilled.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：这是网关的基本构建块。它包括一个用于标识路由的唯一ID、一个目标URI、一个断言列表和一个过滤器列表。只有在所有断言都已满足时，才会匹配路由。'
- en: '**Predicates**: These are the logic that is executed before processing each
    request. It is responsible for detecting whether the different attributes of the
    HTTP request, such as headers and parameters, match the defined criteria. The
    implementation is based on the Java 8 interface `java.util.function.Predicate<T>`.
    The input type is in turn based on Spring''s `org.springframework.web.server.ServerWebExchange`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：这是在处理每个请求之前执行的逻辑。它负责检测HTTP请求的不同属性，如头和参数，是否与定义的 criteria 匹配。实现基于Java
    8接口`java.util.function.Predicate<T>`。输入类型反过来基于Spring的`org.springframework.web.server.ServerWebExchange`。'
- en: '**Filters**: They allow the modification of the incoming HTTP request or outgoing
    HTTP response. They may be modified before or after sending the downstream request.
    Route filters are scoped to a particular route. They implement Spring''s `org.springframework.web.server.GatewayFilter`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：它们允许修改传入的HTTP请求或 outgoing HTTP响应。它们可以在发送下游请求之前或之后进行修改。路由过滤器针对特定的路由。它们实现Spring的`org.springframework.web.server.GatewayFilter`。'
- en: Enable Spring Cloud Gateway for a project
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用Spring Cloud Gateway
- en: Spring Cloud Gateway is built on top of the Netty web container and Reactor
    framework. The Reactor project and Spring Web Flux may be used together with version 2.0
    of Spring Boot. Until now, we have used version 1.5, so there is a different declaration
    of parent project version. Currently, Spring Boot 2.0 is still at the milestone
    stage. Here's the fragment from Maven `pom.xml` that inherits from the `spring-boot-starter-parent`
    project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway建立在Netty网络容器和Reactor框架之上。Reactor项目和Spring Web Flux可以与Spring
    Boot 2.0一起使用。到目前为止，我们使用的是1.5版本，因此parent项目版本声明不同。目前，Spring Boot 2.0仍然处于里程碑阶段。以下是继承自`spring-boot-starter-parent`项目的Maven
    `pom.xml`片段：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need to change the release train of Spring Cloud in comparison with
    the previous examples. The newest available milestone version is `Finchley.M5`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例相比，我们还需要更改Spring Cloud的发布列车。最新可用的里程碑版本是`Finchley.M5`：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After setting the right versions of Spring Boot and Spring Cloud, we may finally
    include the `spring-cloud-starter-gateway` starter in the project dependencies:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置正确的Spring Boot和Spring Cloud版本之后，我们终于可以在项目依赖中包含`spring-cloud-starter-gateway`启动器：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Built-in predicates and filters
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置断言和过滤器
- en: 'Spring Cloud Gateway includes many built-in route predicates and gateway filter
    factories. Every route may be defined using configuration properties in the `application.yml`
    file or programmatically with the Fluent Java Routes API. The list of available
    predicate factories is provided in the following table. Multiple factories may
    be combined for a single route definition with a logical `and` relation. The collection
    of filters may be configured in the `application.yml` file under the `spring.cloud.gateway.routes` property for
    each defined route under the `predicates` property:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway包括许多内置的路由断言和网关过滤器工厂。每个路由可以通过`application.yml`文件中的配置属性或使用Fluent
    Java Routes API以编程方式定义。可用的断言工厂列表如下表所示。多个工厂可以组合用于单一路由定义，使用逻辑`and`关系。过滤器的集合可以在`application.yml`文件中，在`spring.cloud.gateway.routes`属性下，每个定义的路由的`predicates`属性下进行配置：
- en: '| **Name** | **Description** | **Example** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `After` Route | It takes a date-time parameter and matches requests that
    happen after it | `After=2017-11-20T...` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `After` 路由 | 它接受一个日期时间参数，并匹配在其之后发生的请求 | `After=2017-11-20T...` |'
- en: '| `Before` Route | It takes a date-time parameter and matches requests that
    happen before it | `Before=2017-11-20T...` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Before` 路由 | 它接受一个日期时间参数，并匹配在其之前的请求 | `Before=2017-11-20T...` |'
- en: '| `Between` Route | It takes two date-time parameters and matches requests
    that happen between those dates | `Between=2017-11-20T..., 2017-11-21T...` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Between` 路由 | 它接受两个日期时间参数，并匹配在这些日期之间的请求 | `Between=2017-11-20T..., 2017-11-21T...`
    |'
- en: '| `Cookie` Route | It takes a cookie name and regular expression parameters,
    finds the cookie in the HTTP request''s header, and matches its value with the
    provided expression  | `Cookie=SessionID, abc.` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `Cookie` 路由 | 它接受一个cookie名称和正则表达式参数，在HTTP请求的头中找到cookie，并将其值与提供的表达式匹配 | `Cookie=SessionID,
    abc.` |'
- en: '| `Header` Route | It takes the header name and regular expression parameters,
    finds a specific header in the HTTP request''s header, and matches its value with
    the provided expression  | `Header=X-Request-Id, \d+` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Header` 路由 | 它接受头名称和正则表达式参数，在HTTP请求的头中找到一个特定的头，并将其值与提供的表达式匹配 | `Header=X-Request-Id,
    \d+` |'
- en: '| `Host` Route | It takes a hostname ANT style pattern with the `.` separator
    as a parameter and matches it with the `Host` header | `Host=**.example.org` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `Host` 路由 | 它接受一个以`.`分隔符的主机名ANT风格模式作为参数，并与`Host`头匹配 | `Host=**.example.org`
    |'
- en: '| `Method` Route | It takes an HTTP method to match as a parameter | `Method=GET`
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Method` 路由 | 它接受一个HTTP方法作为参数以进行匹配 | `Method=GET` |'
- en: '| `Path` Route | It takes a pattern of request context path as a parameter
    | `Path=/account/{id}` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Path` 路由 | 它接受一个请求上下文路径模式作为参数 | `Path=/account/{id}` |'
- en: '| `Query` Route | It takes two parameters—a required param and an optional
    regexp and matches them with query parameters | `Query=accountId, 1.` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Query` 路由 | 它接受两个参数——一个必需的参数和一个可选的正则表达式，并与查询参数匹配 | `Query=accountId, 1.`
    |'
- en: '| `RemoteAddr` Route | It takes a list of IP addresses in CIDR notation, like `192.168.0.1/16`,
    and matches it with the remote address of a request  | `RemoteAddr=192.168.0.1/16`
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `RemoteAddr` 路由 | 它接受一个CIDR表示法的IP地址列表，如`192.168.0.1/16`，并与请求的远程地址匹配 | `RemoteAddr=192.168.0.1/16`
    |'
- en: 'There are a few more built-in implementations of the gateway filter pattern.
    The list of available factories is also provided in the following table. The collection
    of filters may be configured in the `application.yml` file under the `spring.cloud.gateway.routes`
    property for each route defined under the `filters` property:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个网关过滤器模式的内置实现。以下表格还提供了可用工厂列表。每个`filters`属性下定义的路线可以在`application.yml`文件的`spring.cloud.gateway.routes`属性下配置过滤器集合：
- en: '| **Name** | **Description** | **Example** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `AddRequestHeader` | Adds a header to an HTTP request with name and value
    provided in parameters | `AddRequestHeader=X-Response-ID, 123` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `AddRequestHeader` | 在HTTP请求中添加一个头，参数中提供了名称和值 | `AddRequestHeader=X-Response-ID,
    123` |'
- en: '| `AddRequestParameter` | Adds a query parameter to an HTTP request with name
    and value provided in parameters | `AddRequestParameter=id, 123` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `AddRequestParameter` | 在HTTP请求中添加一个查询参数，参数中提供了名称和值 | `AddRequestParameter=id,
    123` |'
- en: '| `AddResponseHeader` | Adds a header to an HTTP response with name and value
    provided in parameters | `AddResponseHeader=X-Response-ID, 123` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `AddResponseHeader` | 在HTTP响应中添加一个头，参数中提供了名称和值 | `AddResponseHeader=X-Response-ID,
    123` |'
- en: '| `Hystrix` |  It takes a parameter, which is the name of the HystrixCommand
    | `Hystrix=account-service` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Hystrix` | 它接受一个参数，该参数是HystrixCommand的名称 | `Hystrix=account-service` |'
- en: '| `PrefixPath` | Adds a prefix to the HTTP request path defined in the parameter
    | `PrefixPath=/api` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `PrefixPath` | 在参数中定义的HTTP请求路径前添加一个前缀 | `PrefixPath=/api` |'
- en: '| `RequestRateLimiter` | It limits the number of processing requests per single
    user based on three input parameters including a maximum number of requests per
    second, burst capacity, and a bean that returns the user key | `RequestRateLimiter=10,
    20, #{@userKeyResolver}` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `RequestRateLimiter` | 它根据三个输入参数限制单个用户的处理请求数量，包括每秒最大请求数、突发容量和一个返回用户键的bean
    | `RequestRateLimiter=10, 20, #{@userKeyResolver}` |'
- en: '| `RedirectTo` | It takes an HTTP status and a redirect URL as parameters and
    puts it to the `Location` HTTP header in order to perform a redirect | `RedirectTo=302,
    http://localhost:8092` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `RedirectTo` | 它接受一个HTTP状态和一个重定向URL作为参数，将其放入`Location` HTTP头中以执行重定向 | `RedirectTo=302,
    http://localhost:8092` |'
- en: '| `RemoveNonProxyHeaders` | It removes some hop-by-hop headers from forwarded
    requests, such as Keep-Alive, Proxy-Authenticate, or Proxy-Authorization | - |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `RemoveNonProxyHeaders` | 它从转发请求中移除一些跳过头的头信息，如Keep-Alive、Proxy-Authenticate或Proxy-Authorization
    | - |'
- en: '| `RemoveRequestHeader` | It takes the name of the header as a parameter and
    removes it from the HTTP request | `RemoveRequestHeader=X-Request-Foo` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `RemoveRequestHeader` | 它接受一个头名称作为参数，并将其从HTTP请求中移除 | `RemoveRequestHeader=X-Request-Foo`
    |'
- en: '| `RemoveResponseHeader` | It takes the name of the header as a parameter and
    removes it from the HTTP response | `RemoveResponseHeader=X-Response-ID` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `RemoveResponseHeader` | 它接受一个头名称作为参数，并将其从HTTP响应中移除 | `RemoveResponseHeader=X-Response-ID`
    |'
- en: '| `RewritePath` | It takes a path regexp parameter and a replacement parameter
    and then rewrites the request path | `RewritePath=/account/(?<path>.*), /$\{path}`
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `RewritePath` | 它接受一个路径正则表达式参数和一个替换参数，然后重写请求路径 | `RewritePath=/account/(?<path>.*),
    /$\{path}` |'
- en: '| `SecureHeaders` | It adds some secure headers to the response | - |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `SecureHeaders` | 它在响应中添加一些安全头 | - |'
- en: '| `SetPath` | It takes a single parameter with a path template parameter and
    changes a request path | `SetPath=/{segment}` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `SetPath` | 它接受一个带有路径模板参数的单参数，并更改请求路径 | `SetPath=/{segment}` |'
- en: '| `SetResponseHeader` | It takes name and value parameters to set a header
    on the HTTP response | `SetResponseHeader=X-Response-ID, 123` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `SetResponseHeader` | 它接受名称和值参数，在HTTP响应中设置一个头 | `SetResponseHeader=X-Response-ID,
    123` |'
- en: '| `SetStatus` | It takes a single status parameter, which must be a valid HTTP
    status, and sets it on a response | `SetStatus=401` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `SetStatus` | 它接受一个单独的状态参数，该参数必须是一个有效的HTTP状态，并在响应中设置它 | `SetStatus=401` |'
- en: 'Here''s a simple example with two predicates and two filters set. Each `GET
    /account/{id}` request coming in to the gateway is forwarded to `http://localhost:8080/api/account/{id}`
    with the new HTTP header, `X-Request-ID`, included:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有两个谓词和两个过滤器设置的简单示例。每个传入的`GET /account/{id}`请求都会被转发到`http://localhost:8080/api/account/{id}`，并包含新的HTTP头`X-Request-ID`：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The same configuration may be provided using a fluent API defined in the `Route`
    class. This style gives us more flexibility. While configuration with YAML may
    combine predicates using logical `and`, the fluent Java API allows you to use
    `and()`, `or()`, and `negate()` operators on the `Predicate` class. Here''s the
    alternative route implemented using the fluent API:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的配置可以使用定义在`Route`类中的流利API提供。这种风格给我们更多的灵活性。虽然使用YAML可以组合使用逻辑`and`的谓词，但流利Java
    API允许你在`Predicate`类上使用`and()`、`or()`和`negate()`操作符。以下是使用流利API实现的替代路由：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Gateway for microservices
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务网关
- en: 'Let''s get back to our example microservice-based system. We have already discussed
    this example in the section on API gateway configuration based on Spring Cloud
    Netflix Zuul. We would like to prepare the same static route definition as was
    already prepared for the application based on a Zuul proxy. Each service would
    then be available under the gateway address and specific path, for example, `http://localhost:8080/account/**`.
    The most suitable way to declare such a configuration with Spring Cloud Gateway is
    through Path Route Predicate Factory and RewritePath GatewayFilter Factory. A
    rewrite path mechanism changes the request path by taking part of it or adding
    some pattern. In our case, every incoming request path is rewritten from, for
    example, `account/123` to `/123`. Here''s the gateway''s `application.yml` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的基于微服务的系统示例。我们已经在基于Spring Cloud Netflix Zuul的API网关配置部分讨论了这个示例。我们希望能够为基于Zuul代理的应用程序准备相同的静态路由定义。然后，每个服务都可以在网关地址和特定路径下可用，例如`http://localhost:8080/account/**`。使用Spring
    Cloud Gateway声明此类配置的最合适方式是通过路径路由谓词工厂和重写路径网关过滤器工厂。重写路径机制通过取其一部分或添加某些模式来改变请求路径。在我们的案例中，每个传入的请求路径都被重写，例如，从`account/123`变为`/123`。以下是网关的`application.yml`文件：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Surprisingly, this is all that has to be done. We don''t have to provide any
    additional annotation compared to what we have been doing when working with other
    Spring Cloud components such as Eureka or Config Server. So, the main class of
    our gateway''s application is visible in the following code fragment. You have
    to build the project using `mvn clean install` and launch it with `java -jar`,
    or just run the main class from your IDE. The example application source code
    is available on GitHub ([https://github.com/piomin/sample-spring-cloud-gateway.git](https://github.com/piomin/sample-spring-cloud-gateway.git)):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '令人惊讶的是，这就足够了。我们不需要提供任何与使用Eureka或Config Server等其他Spring Cloud组件时相比额外的注解。所以，我们网关应用程序的主类如下面的代码片段所示。你必须使用`mvn
    clean install`构建项目，并使用`java -jar`启动它，或者直接从你的IDE运行主类。示例应用程序的源代码可以在GitHub上找到([https://github.com/piomin/sample-spring-cloud-gateway.git](https://github.com/piomin/sample-spring-cloud-gateway.git)):'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Integration with service discovery
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现集成
- en: 'The gateway may be configured to create routes based on the list of services
    registered in service discovery. It can integrate with those solutions that have
    a `DiscoveryClient` compatible service registry, such as Netflix Eureka, Consul,
    or Zookeeper. To enable `DiscoveryClient` Route Definition Locator, you should
    set the `spring.cloud.gateway.discovery.locator.enabled` property to `true` and
    provide a `DiscoveryClient` implementation on the classpath. We use Eureka client
    and server for discovery. Notice that with the newest milestone version, `Finchley.M5`, of
    Spring Cloud all the Netflix''s artifact''s names have been changed and now it
    is, for example, `spring-cloud-starter-netflix-eureka-client` instead of `spring-cloud-starter-eureka`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '网关可以配置为基于服务发现中注册的服务列表创建路由。它可以与那些具有与`DiscoveryClient`兼容的服务注册解决方案集成的解决方案，例如Netflix
    Eureka、Consul或Zookeeper。要启用`DiscoveryClient`路由定义定位器，你应该将`spring.cloud.gateway.discovery.locator.enabled`属性设置为`true`，并在类路径上提供一个`DiscoveryClient`实现。我们使用Eureka客户端和服务器进行发现。请注意，随着Spring
    Cloud最新里程碑版本`Finchley.M5`的发布，所有Netflix构件的名称都发生了变化，现在例如使用`spring-cloud-starter-netflix-eureka-client`而不是`spring-cloud-starter-eureka`:'
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The main class should be the same for the Eureka client application, annotated
    with `@DiscoveryClient`. Here''s the `application.yml` file with routing configuration.
    The only change in comparison with the previous example is in the `uri` property
    for every defined route. Instead of providing their network address we may use
    its name taken from discovery server with an `lb` prefix, for example, `lb://order-service`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '主类对Eureka客户端应用程序来说应该是相同的，用`@DiscoveryClient`注解。这是带有路由配置的`application.yml`文件。与之前的示例相比，唯一的变化是每个定义的路由的`uri`属性。我们不是提供它们的网络地址，而是使用从发现服务器中带有`lb`前缀的名称，例如`lb://order-service`:'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With an API gateway, we have finished the discussion about the implementation
    of the core elements of a microservice-based architecture in Spring Cloud. After
    reading that part of the book, you should be able to customize and use tools such
    as Eureka, Spring Cloud Config, Ribbon, Feign, Hystrix, and finally a gateway
    based on Zuul and Spring Cloud Gateway together.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有了API网关，我们在Spring Cloud中实现微服务架构核心元素的讨论已经结束。阅读了本书这部分内容后，你应该能够定制并使用Eureka、Spring
    Cloud Config、Ribbon、Feign、Hystrix以及最后基于Zuul和Spring Cloud Gateway的网关。
- en: Treat this chapter as a comparison between two available solutions—the older
    Netflix Zuul and the newest one, Spring Cloud Gateway. The second of them is changing
    dynamically. Its current version, 2.0, may be used only with Spring 5 and is still
    not available in release version. The first of them, Netflix Zuul, is stable,
    but it does not support asynchronous, non-blocking connections. It is still based
    on Netflix Zuul 1.0, although there is a new version of Zuul that supports asynchronous
    communication. Regardless of the differences between them, I have described how
    to provide a simple and a more advanced configuration using both of these solutions.
    I have also presented, based on the examples from the previous chapters, an integration
    with a service discovery, client-side load balancer, and circuit breaker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一章节视为两种可用的解决方案——老版本的Netflix Zuul和最新版本的Spring Cloud Gateway之间的比较。其中一个新的解决方案正在动态变化。它的当前版本2.0，可能只与Spring
    5一起使用，并且还没有在发行版中提供。而第一个解决方案，Netflix Zuul，是稳定的，但它不支持异步、非阻塞连接。它仍然基于Netflix Zuul
    1.0，尽管有一个新的Zuul版本支持异步通信。不管它们之间的差异如何，我都描述了如何使用这两种解决方案提供简单和更高级的配置。我还根据前面章节的示例，展示了与服务发现、客户端负载均衡器和断路器的集成。
