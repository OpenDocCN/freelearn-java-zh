- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Consuming the REST API with React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React消费REST API
- en: This chapter explains networking with React. This is a really important skill
    that we need in most React apps. We will learn about promises, which make asynchronous
    code cleaner and more readable. For networking, we will use the `fetch` and Axios
    libraries. As an example, we will use the OpenWeather and GitHub REST APIs to
    demonstrate how to consume RESTful web services with React. We will also see the
    React Query library in action.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了使用React进行网络操作。这是一个在大多数React应用中都需要的重要技能。我们将学习承诺，它可以使异步代码更简洁、更易读。对于网络操作，我们将使用`fetch`和Axios库。作为一个例子，我们将使用OpenWeather和GitHub
    REST API来展示如何使用React消费RESTful Web服务。我们还将看到React Query库的实际应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Promises
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Using the `fetch` API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fetch` API
- en: Using the Axios library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Axios库
- en: Practical examples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际示例
- en: Handling race conditions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理竞态条件
- en: Using the React Query library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Query库
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following GitHub link will be required: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter10).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub链接将需要：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter10)。
- en: Promises
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: 'The traditional way to handle an asynchronous operation is to use **callback
    functions** for the success or failure of the operation. If the operation succeeds,
    the `success` function is ­called; otherwise, the `failure` function is called.
    The following (abstract) example shows the idea of using a callback function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步操作的传统方式是使用**回调函数**来处理操作的成功或失败。如果操作成功，则调用`success`函数；否则，调用`failure`函数。以下（抽象）示例展示了使用回调函数的想法：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Nowadays, **promises** are a fundamental part of asynchronous programming in
    JavaScript. A promise is an object that represents the result of an asynchronous
    operation. The use of promises simplifies the code when you’re executing asynchronous
    calls. Promises are non-blocking. If you are using an older library for asynchronous
    operations that doesn’t support promises, the code becomes much more difficult
    to read and maintain. In that case, you will end up with multiple nested callbacks
    that are really hard to read. Error handling will also be hard because you will
    have to check for errors in each callback.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**承诺**是JavaScript异步编程的一个基本部分。承诺是一个表示异步操作结果的对象。使用承诺可以简化执行异步调用时的代码。承诺是非阻塞的。如果你正在使用不支持承诺的较旧库进行异步操作，代码将变得难以阅读和维护。在这种情况下，你将面临多个嵌套的回调，这些回调非常难以阅读。错误处理也将变得困难，因为你将不得不在每个回调中检查错误。
- en: 'With promises, we can execute asynchronous calls if the API or library we are
    using to send requests supports promises. In the following example, an asynchronous
    call is made. When the response is returned, the callback function inside the
    `then` method is executed, taking the response as an argument:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的API或库支持承诺，我们可以使用承诺执行异步调用。以下示例中，执行了一个异步调用。当响应返回时，`then`方法内部的回调函数将被执行，并将响应作为参数传递：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `then` method returns a promise. A promise can be in one of three states:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`then`方法返回一个承诺。承诺可以处于以下三种状态之一：'
- en: '**Pending**: Initial state'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：初始状态'
- en: '**Fulfilled (or Resolved)**: Successful operation'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已满足（或已解决）**：成功运行'
- en: '**Rejected**: Failed operation'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝**：失败操作'
- en: 'The following code demonstrates a simple promise object, where `setTimeout`
    simulates an asynchronous operation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了一个简单的承诺对象，其中`setTimeout`模拟了一个异步操作：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The promise is in the **pending** state when the promise object is created and
    while the timer is running. After 500 milliseconds, the `resolve` function is
    called with the value `"Hello"` and the promise enters the **fulfilled** state.
    If there is an error, the promise state changes to **rejected**, and that can
    be handled using the `catch()` function, which we’ll show later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当承诺对象被创建以及计时器正在运行时，承诺处于**挂起**状态。500毫秒后，`resolve`函数被调用，并带有值`"Hello"`，承诺进入**已满足**状态。如果有错误，承诺状态将变为**拒绝**，这可以通过稍后展示的`catch()`函数来处理。
- en: 'You can chain many instances of `then` together, which means that you can run
    multiple asynchronous operations one after another:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个 `then` 实例链接起来，这意味着你可以依次运行多个异步操作：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also add error handling to promises by using `catch()`. The `catch()`
    is executed if any error occurs in the preceding `then` chain:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 `catch()` 来向承诺添加错误处理。如果前面的 `then` 链中发生任何错误，`catch()` 将被执行：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: async and await
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: async 和 await
- en: There is a more modern way to handle asynchronous calls that involves `async`/`await`,
    which was introduced in ECMAScript 2017\. The `async`/`await` method is based
    on promises. To use `async`/`await`, you must define an `async()` function that
    can contain `await` expressions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更现代的方式来处理异步调用，它涉及到 `async`/`await`，这是在 ECMAScript 2017 中引入的。`async`/`await`
    方法基于承诺。要使用 `async`/`await`，你必须定义一个可以包含 `await` 表达式的 `async()` 函数。
- en: 'The following is an example of an asynchronous call containing `async`/`await`.
    As you can see, you can write the code in a similar way to synchronous code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含 `async`/`await` 的异步调用的示例。正如你所看到的，你可以以类似于同步代码的方式编写代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `fetch()` function returns a promise, but now it is handled using `await`
    instead of the `then` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 函数返回一个承诺，但现在它使用 `await` 而不是 `then` 方法来处理。'
- en: 'For error handling, you can use `try...catch` with `async`/`await`, as shown
    in the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误处理，你可以使用与 `async`/`await` 一起的 `try...catch`，如下面的示例所示：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we understand promises, we can start learning about the `fetch` API,
    which we can use to make requests in our React apps.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了承诺，我们可以开始学习 `fetch` API，我们可以使用它来在我们的 React 应用中进行请求。
- en: Using the fetch API
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fetch API
- en: With the `fetch` API, you can make web requests. The idea of the `fetch` API
    is similar to the traditional `XMLHttpRequest` or jQuery Ajax API, but the `fetch`
    API also supports promises, which makes it more straightforward to use. You don’t
    have to install any libraries if you are using `fetch` and it is supported by
    modern browsers natively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fetch` API，你可以进行网络请求。`fetch` API 的理念类似于传统的 `XMLHttpRequest` 或 jQuery Ajax
    API，但 `fetch` API 还支持承诺，这使得它更易于使用。如果你使用 `fetch`，并且它被现代浏览器原生支持，你不需要安装任何库。
- en: 'The `fetch` API provides a `fetch()` method that has one mandatory argument:
    the path of the resource you are calling. In the case of a web request, it will
    be the URL of the service. For a simple `GET` method call, which returns a response,
    the syntax is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` API 提供了一个具有一个强制参数的 `fetch()` 方法：你正在调用的资源的路径。在网页请求的情况下，它将是服务的 URL。对于简单的
    `GET` 方法调用，它返回一个响应，其语法如下：'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `fetch()` method returns a promise that contains the response. You can use
    the `json()` method to extract the JSON data from a response, and this method
    also returns a promise.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 方法返回一个包含响应的承诺。你可以使用 `json()` 方法从响应中提取 JSON 数据，此方法也返回一个承诺。'
- en: 'The `response` that is passed to the first `then` statement is an object that
    contains the properties `ok` and `status`, which we can use to check whether the
    request was successful. The `ok` property value is `true` if the response status
    is in the form `2XX`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给第一个 `then` 语句的 `response` 是一个包含 `ok` 和 `status` 属性的对象，我们可以使用这些属性来检查请求是否成功。如果响应状态是
    `2XX` 形式，则 `ok` 属性值为 `true`：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To use another HTTP method, such as `POST`, you must define it in the second
    argument of the `fetch()` method. The second argument is an object where you can
    define multiple request settings. The following source code makes the request
    using the `POST` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用另一个 HTTP 方法，例如 `POST`，你必须定义它在 `fetch()` 方法的第二个参数中。第二个参数是一个对象，你可以在其中定义多个请求设置。以下源代码使用
    `POST` 方法进行请求：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also add headers inside the second argument. The following `fetch()`
    call contains the `''Content-Type'':''application/json''` header. It is recommended
    that you add the `''Content-Type''` header because then the server can interpret
    the request body correctly:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在第二个参数中添加头信息。以下 `fetch()` 调用包含 `'Content-Type':'application/json'` 头信息。建议添加
    `'Content-Type'` 头信息，因为这样服务器可以正确地解释请求体：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you have to send JSON-encoded data inside the request body, the syntax to
    do so is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须在请求体中发送 JSON 编码的数据，这样做的方法如下：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `fetch` API is not the only way to execute requests in the React app. There
    are other libraries that you can use as well. In the next section, we will learn
    how to use one such popular library: `axios`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` API 不是在 React 应用中执行请求的唯一方式。还有其他库你可以使用。在下一节中，我们将学习如何使用这样一个流行的库：`axios`。'
- en: Using the Axios library
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Axios 库
- en: 'You can also use other libraries for network calls. One very popular library
    is `axios` ([https://github.com/axios/axios](https://github.com/axios/axios)),
    which you can install in your React app with `npm`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用其他库进行网络调用。一个非常流行的库是`axios`([https://github.com/axios/axios](https://github.com/axios/axios))，您可以使用`npm`在您的React应用程序中安装它：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You must add the following `import` statement to your React component before
    using it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用它之前，您必须将以下`import`语句添加到您的React组件中：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `axios` library has some benefits, such as automatic transformation of
    the JSON data, so you don’t need the `json()` function when using `axios`. The
    following code shows an example call being made using `axios`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`axios`库有一些优点，例如自动转换JSON数据，因此在使用`axios`时不需要`json()`函数。以下代码展示了使用`axios`进行的一个示例调用：'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `axios` library has its own call methods for the different HTTP methods.
    For example, if you want to make a `POST` request and send an object in the body,
    `axios` provides the `axios.post()` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`axios`库为不同的HTTP方法提供了自己的调用方法。例如，如果您想发送一个`POST`请求并在正文中发送一个对象，`axios`提供了`axios.post()`方法：'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also use the `axios()` function and pass a configuration object that
    specifies the request details, such as the method, header, data, and URL:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`axios()`函数并传递一个配置对象，该对象指定了请求的详细信息，例如方法、头、数据和URL：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The example code above sends a POST request to the https ://myapi .com/api/cars
    endpoint. The request body contains an object and Axios automatically stringifies
    the data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例代码向https ://myapi .com/api/cars端点发送了一个POST请求。请求体包含一个对象，Axios会自动将数据字符串化。
- en: Now, we are ready to look at a few practical examples involving networking with
    React.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备查看一些涉及React网络的实际示例。
- en: Practical examples
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际示例
- en: In this section, we will go through two examples of using public REST APIs in
    your React apps. In the first example, we use the OpenWeather API to fetch the
    current weather for London and render it in the component. In the second example,
    we use the GitHub API and allow the user to fetch repositories by keyword.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过两个示例来介绍在React应用程序中使用公共REST API。在第一个示例中，我们使用OpenWeather API获取伦敦的当前天气并在组件中渲染它。在第二个示例中，我们使用GitHub
    API并允许用户通过关键词检索仓库。
- en: OpenWeather API
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenWeather API
- en: First, we will make a React app that shows the current weather in London. We
    will show the temperature, description, and weather icon in our app. This weather
    data will be fetched from **OpenWeather** ([https://openweathermap.org/](https://openweathermap.org/)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个React应用程序，显示伦敦的当前天气。我们将在应用程序中显示温度、描述和天气图标。这些天气数据将从**OpenWeather**([https://openweathermap.org/](https://openweathermap.org/))获取。
- en: 'You need to register with OpenWeather to get an API key. A free account will
    be sufficient for our needs. Once you have registered, navigate to your account
    information to find the **API keys** tab. There, you’ll see the API key that you
    need for your React weather app:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要注册OpenWeather以获取API密钥。免费账户将满足我们的需求。一旦注册，请导航到您的账户信息以找到**API密钥**标签。在那里，您将看到用于您的React天气应用程序所需的API密钥：
- en: '![](img/B19818_10_01.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_10_01.png)'
- en: 'Figure 10.1: The OpenWeather API key'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：OpenWeather API密钥
- en: Your API key will be activated automatically, up to 2 hours after your successful
    registration, so you may have to wait a while before you can use it in this section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API密钥将在成功注册后的2小时内自动激活，因此您可能需要等待一段时间才能在此部分使用它。
- en: 'Let’s create a new React app with Vite:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Vite创建一个新的React应用程序：
- en: 'Open a terminal in Windows or Terminal in macOS/Linux, and type the following
    command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows的终端或macOS/Linux的终端中打开一个终端，并输入以下命令：
- en: '[PRE17]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Name your app `weatherapp` and select the **React** framework and **JavaScript**
    variant.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的应用程序命名为`weatherapp`，并选择**React**框架和**JavaScript**变体。
- en: 'Navigate to the `weatherapp` folder and install dependencies:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`weatherapp`文件夹并安装依赖项：
- en: '[PRE18]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start your app with the following command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动您的应用程序：
- en: '[PRE19]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open your project folder with VS Code and open the `App.jsx` file in the editor
    view. Remove all the code inside the fragment (`<></>`)and remove unused imports.
    Now, your source code should look as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用VS Code打开您的项目文件夹，并在编辑视图中打开`App.jsx`文件。删除片段（`<></>`）内的所有代码，并删除未使用的导入。现在，您的源代码应该如下所示：
- en: '[PRE20]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First, we must add the states that are needed to store response data. We will
    show the temperature, description, and weather icon in our app. We have three
    related values, so it is better to create one state that is an object instead
    of creating multiple individual states:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须添加存储响应数据的所需状态。在我们的应用中，我们将展示温度、描述和天气图标。我们有三个相关值，因此最好创建一个对象状态，而不是创建多个单独的状态：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you are using a REST API, you should inspect the response so you can see
    the format of the JSON data. Here is the address that returns the current weather
    for London: [https://api.openweathermap.org/data/2.5/weather?q=London&units=Metric&APIkey=YOUR_KEY](https://api.openweathermap.org/data/2.5/weather?q=London&units=Metric&APIkey=YOUR_KEY).'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你使用REST API时，你应该检查响应，以便你可以看到JSON数据的格式。以下是返回伦敦当前天气的地址：[https://api.openweathermap.org/data/2.5/weather?q=London&units=Metric&APIkey=YOUR_KEY](https://api.openweathermap.org/data/2.5/weather?q=London&units=Metric&APIkey=YOUR_KEY)。
- en: 'If you copy the URL into a browser, you can view the JSON response data:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你将URL复制到浏览器中，你可以查看JSON响应数据：
- en: '![](img/B19818_10_02.png)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B19818_10_02.png)'
- en: 'Figure 10.2: Get weather by city'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.2：按城市获取天气
- en: From the response, you can see that `temp` can be accessed using `main.temp`.
    You can also see that `description` and `icon` are inside the `weather` array,
    which has only one element, and that we can access it using `weather[0].description`
    and `weather[0].icon`.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从响应中，你可以看到`temp`可以通过`main.temp`访问。你还可以看到`description`和`icon`位于`weather`数组中，该数组只有一个元素，我们可以通过`weather[0].description`和`weather[0].icon`来访问它。
- en: 'We will implement the `fetch` call in the next few steps, inside the `useEffect`
    hook function. Import `useEffect` from React:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在接下来的几个步骤中，在`useEffect`钩子函数内部实现`fetch`调用。从React导入`useEffect`：
- en: '[PRE22]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The REST API call is executed using `fetch` in the `useEffect` hook function,
    using an empty array as the second argument. Therefore, the fetch is done once,
    after the first render. After a successful response, we save the weather data
    to the states. Once the state values have been changed, the component will be
    re-rendered. The following is the source code for the `useEffect` hook function.
    It will execute the `fetch()` function once after the first render (Note! Use
    your own API key in the code.):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fetch`在`useEffect`钩子函数中执行REST API调用，使用空数组作为第二个参数。因此，fetch是在第一次渲染后执行的。在成功响应后，我们将天气数据保存到状态中。一旦状态值发生变化，组件将重新渲染。以下是为`useEffect`钩子函数提供的源代码。它将在第一次渲染后执行一次`fetch()`函数（注意！请在代码中使用你自己的API密钥）：
- en: '[PRE23]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you have added the `useEffect` function, the request is executed after
    the first render. We can check that everything has been done correctly using React
    Developer Tools. Open your app in a browser and open your React Developer Tools
    **Components** tab. Now, you can see that the states have been updated with the
    values from the response:![](img/B19818_10_03.png)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了`useEffect`函数，请求将在第一次渲染后执行。我们可以使用React Developer Tools来检查是否一切正常。在浏览器中打开你的应用，并打开你的React
    Developer Tools **组件**标签。现在，你可以看到状态已经更新为响应中的值：![](img/B19818_10_03.png)
- en: 'Figure 10.3: Weather component'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.3：天气组件
- en: You can also check that the request status is `200 OK` from the **Network**
    tab.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以从**网络**标签中检查请求状态是否为`200 OK`。
- en: Finally, we will implement the `return` statement to show the weather values.
    We will use **conditional rendering** here; otherwise, we will get an error because
    we don’t have image code in the first render call and the image upload won’t succeed.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现`return`语句以显示天气值。这里我们将使用**条件渲染**；否则，由于第一次渲染调用中没有图像代码，图像上传将不会成功，我们会得到错误。
- en: To show the weather icon, we must add `https://openweathermap.org/img/wn/` before
    the icon code, and `@2x.png` after the icon code.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要显示天气图标，我们必须在图标代码之前添加`https://openweathermap.org/img/wn/`，并在图标代码之后添加`@2x.png`。
- en: 'You can find information about icons in the OpenWeather documentation: [https://openweathermap.org/weather-conditions](https://openweathermap.org/weather-conditions).'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在OpenWeather文档中找到有关图标的信息：[https://openweathermap.org/weather-conditions](https://openweathermap.org/weather-conditions)。
- en: 'Then, we can set the concatenated image URL as the `img` element’s `src` attribute.
    Temperature and description are shown in the paragraph element. `°C` is the degrees
    Celsius symbol:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们可以将连接的图像URL设置为`img`元素的`src`属性。温度和描述显示在段落元素中。`°C`是摄氏度符号：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, your app should be ready. When you open it in a browser, it should look
    as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你的应用应该已经准备好了。当你用浏览器打开它时，它应该看起来如下：
- en: '![](img/B19818_10_04.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_10_04.png)'
- en: 'Figure 10.4: WeatherApp'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：WeatherApp
- en: 'The source code for the entire `App.jsx` file is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 `App.jsx` 文件的源代码如下：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In our example, we checked that the weather icon was loaded to check if the
    fetch was completed. This is not the optimal solution because if the fetch ends
    in an error, our component still renders a loading message. The boolean state
    is used a lot in scenarios like this, but it doesn’t solve the problem either.
    The best solution would be a status that indicates the exact state of the request
    (pending, resolved, rejected). You can read more about this in Kent C. Dodds’
    blog post, *Stop using isLoading Booleans*: [https://kentcdodds.com/blog/stop-using-isloading-booleans](https://kentcdodds.com/blog/stop-using-isloading-booleans).
    This problem is solved by the React Query library, which we will use later in
    this chapter.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们检查了天气图标是否加载以确认获取是否完成。这不是最佳解决方案，因为如果获取以错误结束，我们的组件仍然渲染一个加载消息。布尔状态在这种场景中被大量使用，但它也不能解决问题。最佳解决方案是一个表示请求确切状态的状态（挂起、解决、拒绝）。你可以在
    Kent C. Dodds 的博客文章 *Stop using isLoading Booleans* 中了解更多信息：[https://kentcdodds.com/blog/stop-using-isloading-booleans](https://kentcdodds.com/blog/stop-using-isloading-booleans)。这个问题可以通过
    React Query 库来解决，我们将在本章后面使用它。
- en: GitHub API
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub API
- en: In the second example, we are going to create an app that uses the GitHub API
    to fetch repositories by keyword. The user enters a keyword, and we fetch repositories
    that contain that keyword. We will use the `axios` library for web requests, and
    we will also practice using TypeScript in this example.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将创建一个使用 GitHub API 通过关键词获取仓库的应用。用户输入一个关键词，我们将获取包含该关键词的仓库。我们将使用 `axios`
    库进行网络请求，并且在这个例子中我们也将练习使用 TypeScript。
- en: 'Let’s first see how you can send a `GET` request using `axios` with TypeScript.
    You can make a `GET` request and specify the expected data type using TypeScript
    generics, as shown in the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用 TypeScript 通过 `axios` 发送一个 `GET` 请求。你可以发送一个 `GET` 请求并使用 TypeScript
    泛型指定期望的数据类型，如下面的示例所示：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you try to access some field that is not present in the expected data type,
    you will get an error early in the development phase. At this point, it is important
    to understand that TypeScript is compiled to JavaScript and all type information
    is removed. Therefore, TypeScript doesn’t have a direct impact on runtime behavior.
    If a REST API returns data of a different type than expected, TypeScript won’t
    catch this as a runtime error.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试访问不在期望数据类型中的字段，你将在开发早期阶段得到一个错误。此时，重要的是要理解 TypeScript 被编译成 JavaScript，并且所有类型信息都被移除。因此，TypeScript
    对运行时行为没有直接影响。如果 REST API 返回的数据类型与预期不同，TypeScript 不会将其作为运行时错误捕获。
- en: 'Now, we can start to develop our GitHub app:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始开发我们的 GitHub 应用：
- en: Create a new React app called `restgithub` using Vite, selecting the **React**
    framework and **TypeScript** variant.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Vite 创建一个名为 `restgithub` 的新 React 应用，选择 **React** 框架和 **TypeScript** 变体。
- en: Install dependencies, start the app, and open the project folder with VS Code.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装依赖项，启动应用，并使用 VS Code 打开项目文件夹。
- en: 'Install `axios` using the following `npm` command in your project folder:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中使用以下 `npm` 命令安装 `axios`：
- en: '[PRE27]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Remove the extra code inside the fragment `<></>` from the `App.tsx` file.
    Your `App.tsx` code should look as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `App.tsx` 文件中的片段 `<></>` 内移除额外的代码。你的 `App.tsx` 代码应如下所示：
- en: '[PRE28]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The URL of the GitHub REST API to search repositories is as follows: `https://api.github.com/search/repositories?q={KEYWORD}`.'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 搜索仓库的 GitHub REST API 的 URL 如下：`https://api.github.com/search/repositories?q={KEYWORD}`。
- en: You can find the GitHub REST API documentation at [https://docs.github.com/en/rest](https://docs.github.com/en/rest).
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.github.com/en/rest](https://docs.github.com/en/rest) 找到 GitHub
    REST API 文档。
- en: 'Let’s inspect the JSON response by typing the URL into a browser and using
    the `react` keyword:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们通过在浏览器中输入 URL 并使用 `react` 关键词来检查 JSON 响应：
- en: '![](img/B19818_10_05.png)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B19818_10_05.png)'
- en: 'Figure 10.5: GitHub REST API'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.5：GitHub REST API
- en: From the response, we can see that repositories are returned as a JSON array
    called `items`. From the individual repositories, we will show the `full_name`
    and `html_url` values.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从响应中，我们可以看到仓库以名为 `items` 的 JSON 数组形式返回。从单个仓库中，我们将展示 `full_name` 和 `html_url`
    的值。
- en: We will present the data in the table and use the `map()` function to transform
    the values into table rows, as shown in *Chapter 8*. The `id` can be used as a
    key for a table row.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在表格中展示数据，并使用 `map()` 函数将值转换为表格行，如 *第 8 章* 中所示。`id` 可以用作表格行的键。
- en: We are going to make the REST API call with the keyword from the user input.
    One way to implement this is to create an input field and button. The user types
    the keyword into the input field, and the REST API call is made when the button
    is pressed.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用用户输入的关键字执行REST API调用。一种实现方式是创建一个输入字段和按钮。用户将关键字输入到输入字段中，当按钮被按下时，执行REST API调用。
- en: We can’t make the REST API call in the `useEffect()` hook function because,
    in that phase, the user input isn’t available when the component is rendered the
    first time.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不能在`useEffect()`钩子函数中执行REST API调用，因为在那个阶段，当组件第一次渲染时，用户输入是不可用的。
- en: 'We will create two states, one for the user input and one for the data from
    the JSON response. When we are using TypeScript, we have to define a type for
    the repository, as shown in the following code. The `repodata` state is an array
    of `Repository` type because repositories are returned as JSON arrays in the response.
    We only need to access three fields; therefore, only these fields are defined
    in the type. We will also import `axios`, which we’ll use later when sending a
    request:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建两个状态，一个用于用户输入，一个用于JSON响应中的数据。当我们使用TypeScript时，我们必须为仓库定义一个类型，如下面的代码所示。`repodata`状态是一个`Repository`类型的数组，因为仓库作为JSON数组返回。我们只需要访问三个字段；因此，只定义了这些字段。我们还将导入`axios`，我们将在稍后发送请求时使用它：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we will implement the input field and the button in the `return` statement.
    We also have to add a change listener to our input field to be able to save the
    input value to a state called `keyword`. The button has a click listener, which
    invokes the function that will make the REST API call with the given keyword:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`return`语句中实现输入字段和按钮。我们还需要为我们的输入字段添加一个变化监听器，以便能够将输入值保存到名为`keyword`的状态中。按钮有一个点击监听器，它调用将使用给定关键字执行REST
    API调用的函数：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `handleClick()` function, we will concatenate the `url` and `keyword`
    states using template literals (Note! Use backticks [PRE31]). We will use the
    `axios.get()` method to send a request. As we learned earlier, Axios does not
    require the `.json()` method to be called on the response. Axios automatically
    parses the response data, and then we save the `items` array from the response
    data to the `repodata` state. We also use `catch()` to handle errors. Since we
    are using TypeScript, we will define the expected data type in the `GET` request.
    We have seen that the response is an object that contains an `item` property.
    The content of the `item` property is an array of repository objects; therefore,
    the data type is `<{ items: Repository[] }>`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`handleClick()`函数中，我们将使用模板字符串连接`url`和`keyword`状态（注意！使用反引号[PRE31]）。我们将使用`axios.get()`方法发送请求。正如我们之前所学的，Axios不需要在响应上调用`.json()`方法。Axios会自动解析响应数据，然后我们将响应数据中的`items`数组保存到`repodata`状态。我们还使用`catch()`来处理错误。由于我们使用TypeScript，我们将在`GET`请求中定义预期的数据类型。我们已经看到响应是一个包含`item`属性的对象。`item`属性的内容是一个仓库对象的数组；因此，数据类型是`<{
    items: Repository[] }>`：'
- en: '[PRE32]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `return` statement, we will use the `map()` function to transform the
    `data` state into table rows. The `url` property of a repository will be the `href`
    value of the `<a>` element. Each repository has a unique `id` property, which
    we can use as a key for a table row. We use conditional rendering to handle cases
    where the response doesn’t return any repositories:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`return`语句中，我们将使用`map()`函数将`data`状态转换为表格行。仓库的`url`属性将是`<a>`元素的`href`值。每个仓库都有一个唯一的`id`属性，我们可以将其用作表格行的键。我们使用条件渲染来处理响应没有返回任何仓库的情况：
- en: '[PRE33]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following screenshot shows the final app upon using the `react` keyword
    in the REST API call:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了在REST API调用中使用`react`关键字后的最终应用：
- en: '![](img/B19818_10_06.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_10_06.png)'
- en: 'Figure 10.6: GitHub REST API'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：GitHub REST API
- en: 'The source code for the `App.jsx` file looks as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.jsx`文件的源代码如下：'
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is an API rate limit (number of daily requests without authentication)
    for the GitHub API, so if your code stops working, the reason might be here. The
    search endpoint that we are using has a limit of 10 requests per minute. If you
    exceed the limit, you have to wait one minute.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub API有一个API速率限制（未认证的每日请求数量），所以如果你的代码停止工作，原因可能在这里。我们使用的搜索端点每分钟限制10个请求。如果你超过了这个限制，你必须等待一分钟。
- en: Handling race conditions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理竞态条件
- en: If your component makes several requests quickly, it can lead to a **race condition**
    that can create unpredictable or incorrect results. Network requests are asynchronous;
    therefore, requests don’t necessarily finish in the same order as they were sent.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组件快速进行多次请求，可能会导致**竞态条件**，这可能会产生不可预测或错误的结果。网络请求是异步的；因此，请求不一定按照发送的顺序完成。
- en: 'The following example code sends a network request when the `props.carid` value
    changes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码在`props.carid`值变化时发送网络请求：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, if `carid` changes quickly multiple times, the data that is rendered might
    not be from the last request that was sent.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`carid`快速变化多次，渲染的数据可能不是来自最后发送的请求。
- en: 'We can use the `useEffect` cleanup function to avoid race conditions. First,
    we create a boolean variable named `ignore` inside the `useEffect()`, with an
    initial value of `false`. Then, we update the `ignore` variable value to `true`
    in the cleanup function. In the state update, we check the value of the `ignore`
    variable, and the state is updated only if the value is `false`, which means that
    no new value has replaced `props.carid` and the effect is not cleaned up:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`useEffect`清理函数来避免竞态条件。首先，在`useEffect()`内部创建一个名为`ignore`的布尔变量，初始值为`false`。然后，在清理函数中更新`ignore`变量的值为`true`。在状态更新中，我们检查`ignore`变量的值，并且只有当值为`false`时，状态才会更新，这意味着没有新的值替换`props.carid`，并且效果没有被清理：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, each time a component is re-rendered, the cleanup function is called and
    `ignore` is updated to `true`, and the effect is cleaned up. Only the result from
    the last request is rendered, and we can avoid race conditions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次组件重新渲染时，清理函数都会被调用，并将`ignore`更新为`true`，效果被清理。只有最后请求的结果会被渲染，我们可以避免竞态条件。
- en: React Query, which we will start to use next, provides some mechanisms for handling
    race conditions, such as concurrency control. It takes care that only one request
    is sent at a time for a given query key.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将开始使用的React Query提供了一些处理竞态条件的机制，例如并发控制。它确保对于给定的查询键，一次只发送一个请求。
- en: Using the React Query library
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Query库
- en: In proper React apps where you make a lot of network calls, the use of third-party
    networking libraries is recommended. The two most popular libraries are **React
    Query** ([https://tanstack.com/query](https://tanstack.com/query)), also known
    as **Tanstack Query**, and **SWR** ([https://swr.vercel.app/](https://swr.vercel.app/)).
    These libraries provide a lot of useful features, such as data caching and performance
    optimization.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的React应用程序中，如果你要进行大量的网络调用，建议使用第三方网络库。最受欢迎的两个库是**React Query**（[https://tanstack.com/query](https://tanstack.com/query)），也称为**Tanstack
    Query**，以及**SWR**（[https://swr.vercel.app/](https://swr.vercel.app/)）。这些库提供了许多有用的功能，例如数据缓存和性能优化。
- en: 'In this section, we will learn how you can use React Query to fetch data in
    your React app. We will create a React app that fetches repositories from the
    GitHub REST API using the `react` keyword:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在React应用程序中使用React Query获取数据。我们将创建一个React应用程序，使用`react`关键字从GitHub
    REST API获取仓库：
- en: First, create a React app called `gitapi` using Vite and select the **React**
    framework and **JavaScript** variant. Install dependencies and move to your project
    folder.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用Vite创建一个名为`gitapi`的React应用程序，选择**React**框架和**JavaScript**变体。安装依赖项并移动到你的项目文件夹。
- en: 'Next, install React Query and `axios` using the following commands in your
    project folder (Note! In this book, we are using Tanstack Query v4):'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令在你的项目文件夹中安装React Query和`axios`（注意！在本书中，我们使用Tanstack Query v4）：
- en: '[PRE37]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Remove the extra code inside the fragment `<></>` from the `App.jsx` file.
    Your `App.jsx` code should look as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`App.jsx`文件中移除片段`<></>`内的额外代码。你的`App.jsx`代码应如下所示：
- en: '[PRE38]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'React Query provides the `QueryClientProvider` and `QueryClient` components,
    which handle data caching. Import these components into your `App` component.
    Then, create an instance of `QueryClient` and render `QueryClientProvider` in
    our `App` component:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Query提供了`QueryClientProvider`和`QueryClient`组件，用于处理数据缓存。将这些组件导入到你的`App`组件中。然后，创建一个`QueryClient`实例并在我们的`App`组件中渲染`QueryClientProvider`：
- en: '[PRE39]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'React Query provides the `useQuery` hook function, which is used to invoke
    network requests. The syntax is the following:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: React Query提供了一个名为`useQuery`的钩子函数，用于调用网络请求。其语法如下：
- en: '[PRE40]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：
- en: '`queryKey` is a unique key for a query and it is used for caching and refetching
    data.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryKey`是查询的唯一键，它用于缓存和重新获取数据。'
- en: '`queryFn` is a function to fetch data, and it should return a promise.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryFn` 是一个用于获取数据的函数，它应该返回一个 promise。'
- en: 'The `query` object that the `useQuery` hook returns contains important properties,
    such as the status of the query:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useQuery` 钩子返回的 `query` 对象包含重要的属性，例如查询的状态：'
- en: '[PRE41]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The possible status values are the following:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能的状态值如下：
- en: '`isLoading`: The data is not yet available.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading`：数据尚未可用。'
- en: '`isError`: The query ended with an error.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isError`：查询以错误结束。'
- en: '`isSuccess`: The query ended successfully and query data is available.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSuccess`：查询成功结束，查询数据可用。'
- en: The `query` object’s `data` property contains the data that the response returns.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`query` 对象的 `data` 属性包含响应返回的数据。'
- en: With this information, we can continue our GitHub example using `useQuery`.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这些信息，我们可以继续使用 `useQuery` 使用 GitHub 示例。
- en: 'We will create a new component for fetching data. Create a new file called
    `Repositories.jsx` in the `src` folder, and fill it with the following starter
    code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的组件来获取数据。在 `src` 文件夹中创建一个名为 `Repositories.jsx` 的新文件，并用以下启动代码填充它：
- en: '[PRE42]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Import the `useQuery` hook and create a function called `getRepositories()`
    that invokes `axios.get()` on the GitHub REST API. Here, we use `async`/`await`
    with Axios. Call the `useQuery` hook function and make the value of the `queryFn`
    property our `fetch` function, `getRepositories`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `useQuery` 钩子，创建一个名为 `getRepositories()` 的函数，该函数在 GitHub REST API 上调用 `axios.get()`。在这里，我们使用
    Axios 的 `async`/`await`。调用 `useQuery` 钩子函数，并将 `queryFn` 属性的值设置为我们的 `fetch` 函数，`getRepositories`：
- en: '[PRE43]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, implement the conditional rendering. The repositories are rendered when
    the data is available. We also render a message if the REST API call ends with
    an error:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现条件渲染。当数据可用时渲染仓库。如果 REST API 调用以错误结束，我们也会渲染一条消息：
- en: '[PRE44]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the final step, import our `Repositories` component into the `App` component
    and render it inside the `QueryClientProvider` component:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，将我们的 `Repositories` 组件导入到 `App` 组件中，并在 `QueryClientProvider` 组件内部渲染它：
- en: '[PRE45]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, your app should look like the following, and repositories are fetched
    using the React Query library. We also managed to handle request status easily
    using its built-in features. We don’t need any states to store response data because
    React Query handles data management and caching:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您的应用程序应该看起来如下，并且使用 React Query 库获取了仓库。我们还能够轻松地使用其内置功能处理请求状态。我们不需要任何状态来存储响应数据，因为
    React Query 处理数据管理和缓存：
- en: '![](img/B19818_10_07.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_10_07.png)'
- en: 'Figure 10.7: Tanstack Query'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：Tanstack Query
- en: You should also see that refetching is done automatically by React Query when
    the browser is **refocused** (when the user returns to the application’s window
    or tab). This is a good feature; you can see the updated data each time you refocus
    the browser. You can change this default behavior globally or per query.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该看到，当浏览器 **重新聚焦**（当用户返回到应用程序的窗口或标签页）时，React Query 会自动重新获取。这是一个很好的功能；每次你重新聚焦浏览器时，你都可以看到更新的数据。你可以全局或按查询更改此默认行为。
- en: Refetching is also done automatically when the network is reconnected, or a
    new instance of the query is mounted (component is inserted into the DOM).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络重新连接或查询挂载了一个新实例（组件被插入到 DOM 中）时，也会自动执行重新获取。
- en: 'React Query has an important property called `staleTime` that defines how long
    data is considered fresh before it becomes stale and triggers a re-fetch in the
    background. By default, `staleTime` is 0, which means that data becomes stale
    immediately after a successful query. By setting the `staleTime` value, you can
    avoid unnecessary re-fetches if your data is not changing so often. The following
    example shows how you can set `staleTime` in your query:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 有一个重要的属性称为 `staleTime`，它定义了数据在成为陈旧并触发后台重新获取之前被认为是新鲜的时长。默认情况下，`staleTime`
    为 0，这意味着在查询成功后数据立即变为陈旧。通过设置 `staleTime` 的值，如果您的数据不经常变化，您可以避免不必要的重新获取。以下示例显示了如何在您的查询中设置
    `staleTime`：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There is also a `cacheTime` property that defines when inactive queries are
    garbage collected, and the default time is 5 minutes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `cacheTime` 属性，它定义了何时回收不活跃的查询，默认时间是 5 分钟。
- en: 'React Query simplifies handling data mutations by providing a `useMutation`
    hook for creating, updating, and deleting data, along with built-in error handling
    and cache invalidation. Below is an example of `useMutation` that adds a new car.
    Now, because we want to add a new car, we use the `axios.post()` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: React Query通过提供用于创建、更新和删除数据的`useMutation`钩子，简化了数据处理变动的处理，同时内置了错误处理和缓存失效功能。下面是一个添加新汽车的`useMutation`示例。现在，因为我们想添加一辆新车，所以我们使用`axios.post()`方法：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the case of updating or deleting, you can use the `axios.put()`, `axios.patch()`,
    or `axios.delete()` methods.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新或删除的情况下，你可以使用`axios.put()`、`axios.patch()`或`axios.delete()`方法。
- en: The `mutationFn` property value is a function that sends a `POST` request to
    the server and returns a promise. React Query mutation also provides side effects,
    such as `onSuccess` and `onError`, that can be used in mutations. `onSuccess`
    is used to define a callback function that can perform any necessary actions,
    such as updating the UI or displaying a success message, based on a successful
    mutation response. `onError` is used to specify a callback function that will
    be executed if the mutation operation encounters an error.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutationFn`属性值是一个函数，它向服务器发送`POST`请求并返回一个promise。React Query的变动也提供了副作用，如`onSuccess`和`onError`，这些可以在变动中使用。`onSuccess`用于定义一个回调函数，可以根据成功的变动响应执行任何必要的操作，例如更新UI或显示成功消息。`onError`用于指定一个回调函数，如果变动操作遇到错误，该函数将被执行。'
- en: 'Then, we can execute mutation in the following way:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以以下方式执行变动：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`QueryClient` provides an `invalidateQueries()` method that can be used to
    invalidate queries in the cache. If the query is invalidated in the cache, it
    will be fetched again. In the previous example, we used `useMutation` to add a
    new car to the server. If we have a query that fetches all cars and the query
    ID is `cars`, we can invalidate it in the following way after the new car has
    been added successfully:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryClient`提供了一个`invalidateQueries()`方法，可以用来使缓存中的查询失效。如果查询在缓存中失效，它将被重新获取。在之前的例子中，我们使用`useMutation`将新车添加到服务器。如果我们有一个获取所有汽车的查询，并且查询ID是`cars`，我们可以在新车添加成功后以下方式使其失效：'
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This means that the cars will be fetched again after a new car has been added
    to the server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在服务器添加了一辆新车之后，汽车将被重新获取。
- en: By using React Query, we have to write less code to get proper error handling,
    data caching, and so on, due to the built-in functionalities that it provides.
    Now that we have learned about networking with React, we can utilize these skills
    in our frontend implementation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React Query提供的内置功能，我们不得不编写更少的代码来获得适当的错误处理、数据缓存等功能。现在我们已经学习了使用React进行网络操作，我们可以在我们的前端实现中利用这些技能。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on networking with React. We started with promises,
    which make asynchronous network calls easier to implement. This is a cleaner way
    to handle calls, and it’s much better than using traditional callback functions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们专注于使用React进行网络操作。我们从promise开始，这使得异步网络调用更容易实现。这是一种更干净的方式来处理调用，比使用传统的回调函数要好得多。
- en: In this book, we are using the Axios and React Query libraries for networking
    in our frontend. We went through the basics of using these libraries. We implemented
    two React example apps using the `fetch` API and Axios to call REST APIs, and
    we presented the response data in the browser. We learned about race conditions
    and looked at how to fetch data using the React Query library.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用Axios和React Query库在我们的前端进行网络操作。我们学习了使用这些库的基础知识。我们实现了两个使用`fetch`API和Axios调用REST
    API的React示例应用，并在浏览器中展示了响应数据。我们学习了竞争条件，并探讨了如何使用React Query库获取数据。
- en: In the next chapter, we will look at some useful React components that we are
    going to use in our frontend.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些有用的React组件，我们将在我们的前端中使用它们。
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a promise?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是promise？
- en: What are `fetch` and `axios`?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fetch`和`axios`是什么？'
- en: What is React Query?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是React Query？
- en: What are the benefits of using a networking library?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络库的好处是什么？
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are other good resources available for learning about promises and asynchronous
    operations. A couple are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他一些很好的资源可以用来学习关于promises和异步操作的知识。以下是一些资源：
- en: '*Using promises*, by MDN web docs ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises))'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用promises*，由MDN网络文档([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises))'
- en: '*Fetch Standard* ([https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/))'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fetch标准* ([https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/))'
- en: Learn more on Discord
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code10796108009382640.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10796108009382640.png)'
