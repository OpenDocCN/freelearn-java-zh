- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Dealing with Exceptions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: Error handling is another fundamental concept of software development. An error
    happens when the program can’t or doesn’t know how to react to a certain situation.
    Error handling allows you to respond to unexpected events in your program gracefully.
    Without error handling, the application would crash and stop running when the
    error occurred.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是软件开发中的另一个基本概念。当程序无法或不知道如何对某种情况进行反应时，就会发生错误。错误处理允许你优雅地应对程序中的意外事件。如果没有错误处理，当错误发生时，应用程序会崩溃并停止运行。
- en: In Java, we have different types of errors. The type of error that we deal with
    most is called an **exception**. In Java terms that we’ll learn later, an Exception
    is not an Error. This is related to the class hierarchy. However, sticking to
    daily linguistics it is not weird to think of an exception as some sort of error.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们有不同类型的错误。我们处理最多的一种错误称为**异常**。在Java术语中，我们稍后会学到，异常并不是错误。这与类层次结构有关。然而，从日常语言学的角度来看，将异常视为某种错误并不奇怪。
- en: But, instead of talking about errors, we usually talk about exceptions. Errors
    occur as well, but errors are typically situations your application will not recover
    from. Your application should be capable of recovering from an exception.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们通常不谈论错误，而是谈论异常。错误也会发生，但错误通常是应用程序无法恢复的情况。你的应用程序应该能够从异常中恢复。
- en: Exception handling in Java allows you to manage problems and unexpected events
    in your programs. Mastering exception handling will not only improve the robustness
    of your code but also help you maintain and debug your applications more effectively.
    By understanding how exceptions work, you can write code that deals with unexpected
    situations without crashing or producing incorrect results.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的异常处理允许你管理程序中的问题和意外事件。掌握异常处理不仅会提高你代码的健壮性，还能帮助你更有效地维护和调试应用程序。通过理解异常的工作原理，你可以编写处理意外情况而不会崩溃或产生错误结果的代码。
- en: 'Making sure that you have the necessary skills to manage exceptions in your
    applications is exactly what we’re going to learn in this chapter. Here’s an overview
    of what we’ll cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你具备管理应用程序中异常的必要技能正是我们将在本章中学习的内容。以下是我们将涵盖的概述：
- en: Understanding exceptions and their purpose
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解异常及其目的
- en: Types of exceptions – checked and unchecked
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常类型 – 检查和不检查
- en: Basic I/O operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本I/O操作
- en: Throwing exceptions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Creating custom exceptions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义异常
- en: The catch or declare principle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抓捕或声明原则
- en: Using try-catch blocks, try-catch-finally, and try-with-resources
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用try-catch块、try-catch-finally和try-with-resources
- en: Working with inheritance and exception handling in method signatures
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法签名中处理继承和异常
- en: So, let’s dive in and explore the world of exceptions!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们深入探索异常的世界！
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch11](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch11).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch11](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch11)。
- en: Understanding exceptions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异常
- en: In everyday life, we have to execute a lot of processes. And all the time, we
    have little hiccups that happen, and these should not ruin our day. These hiccups
    are not considered the happy path of events, but they happen often, and we recover
    from them and continue business as usual.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常生活中，我们必须执行许多过程。而且，我们总是在发生一些小插曲，这些不应该破坏我们的日子。这些小插曲不被认为是事件中的快乐路径，但它们经常发生，我们从它们中恢复过来，继续正常工作。
- en: There are also more serious problems that can occur, for which we need to have
    a formal backup plan, such as evacuating a building in case of a fire.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些更严重的问题可能会发生，我们需要有正式的备份计划，比如在火灾中疏散建筑物。
- en: Exceptions in Java are like this. These are things that should not happen; sometimes,
    we are in control of them happening and sometimes, we are not. In some cases,
    we are obligated to specify a backup plan, and in other cases, we are not. First,
    let’s talk a bit more about what exceptions are.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的异常就像这样。这些是不应该发生的事情；有时，我们控制它们发生，有时，我们则不。在某些情况下，我们有义务指定一个备份计划，而在其他情况下，我们则没有。首先，让我们再谈谈什么是异常。
- en: What are exceptions?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常是什么？
- en: Exceptions are events that disrupt the normal flow of the program. They typically
    arise from errors or unexpected conditions that the program encounters while running.
    Exceptions in Java are objects. These exceptions are represented by instances
    of the `Exception` class or its subclasses. The `Exception` class is a subclass
    of the `Throwable` class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是中断程序正常流程的事件。它们通常由程序在运行过程中遇到的错误或意外条件引起。Java中的异常是对象。这些异常由`Exception`类或其子类的实例表示。`Exception`类是`Throwable`类的子类。
- en: When an exception occurs, the Java runtime system creates an exception object
    containing information about the error, such as its type and the state of the
    program when the error occurred. This process is known as *throwing an exception*.
    Dealing with an exception is called *catching* *an exception*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生异常时，Java运行时系统会创建一个包含错误信息的异常对象，例如错误的类型和错误发生时程序的状态。这个过程被称为*抛出异常*。处理异常被称为*捕获异常*。
- en: If the exception is not caught and handled by the program, the Java runtime
    system will terminate the program, usually displaying an error message and the
    stack trace. So, let’s talk about the need for exception handling.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序没有捕获并处理异常，Java运行时系统将终止程序，通常显示错误信息和堆栈跟踪。因此，让我们谈谈异常处理的需求。
- en: Stack trace
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: 'You might not know this term just yet, but you’re likely to have encountered
    one already. A stack trace shows up when an exception happens. It shows the “path”
    the code took to get to your error. Here’s an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还不知道这个术语，但你很可能已经遇到过。当异常发生时，会出现堆栈跟踪。它显示了代码到达错误所在的“路径”。以下是一个示例：
- en: '`Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index
    0 out of bounds for` `length 0`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index
    0 out of bounds for length 0`'
- en: '`at javabook.Example.printFirstValueArray(Example.java:21)`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`at javabook.Example.printFirstValueArray(Example.java:21)`'
- en: '`at javabook.Example.main(Example.java:8)`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`at javabook.Example.main(Example.java:8)`'
- en: As you can see in this example, the line that eventually triggered the exception
    is line 21 and the method name was `printFirstValueArray`. That method was called
    on line 8 in the `main` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本例中看到的，最终触发异常的行是第21行，方法名为`printFirstValueArray`。该方法在`main`方法的第8行被调用。
- en: Need for exception handling
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理的需求
- en: Since we don’t want our program to stop running every time it throws an exception,
    exception handling is a crucial aspect of programming. We typically separate the
    code logic from the exception-handling logic. This helps us create an application
    that is maintainable and resilient. When we have proper exception handling in
    place, our program can recover gracefully from unexpected situations. This is
    much more preferred than the program crashing and stopping, or even producing
    incorrect results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望每次程序抛出异常时都停止运行，因此异常处理是编程中的一个关键方面。我们通常将代码逻辑与异常处理逻辑分开。这有助于我们创建一个可维护和有弹性的应用程序。当我们设置了适当的异常处理时，我们的程序可以从意外情况中优雅地恢复。这比程序崩溃并停止，甚至产生错误的结果要更好。
- en: Since this is so common, Java provides a built-in exception handling mechanism
    that allows us to catch and handle exceptions. This way, we can recover from the
    exception and continue executing the program. This mechanism encourages (or even
    forces) us to think about possible exceptional conditions that the program might
    encounter and write code to handle these exceptions effectively. Let’s talk about
    some situations in which we need exception handling.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这非常常见，Java提供了一个内置的异常处理机制，允许我们捕获和处理异常。这样，我们可以从异常中恢复，并继续执行程序。这个机制鼓励（甚至强制）我们思考程序可能遇到的可能的异常条件，并编写代码来有效地处理这些异常。让我们谈谈需要异常处理的一些情况。
- en: Common situations that require exception handling
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要异常处理的常见情况
- en: There are many situations in which exceptions can occur. Some of these are within
    our control, but the most important ones where we absolutely must deal with the
    possibility of an exception are situations where we are not fully in control.
    We’ll address a few common situations before seeing the exception code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可能导致异常的情况。其中一些在我们控制范围内，但最重要的是，我们必须处理无法完全控制的情况下的异常可能性。在查看异常代码之前，我们将讨论一些常见的情况。
- en: File I/O operations
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件I/O操作
- en: A very common situation that requires exception handling is a piece of logic
    that deals with file I/O operations. When working with file I/O operations, exceptions
    can be used to handle situations where a file is not found or cannot be read or
    written. These are all situations that are not in the programmer’s control. Permissions
    for the program might not be right, a file may have been removed, or a file might
    already be in use – many other situations out of your control can also happen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 需要异常处理的一个非常常见的情况是处理文件 I/O 操作的逻辑。当处理文件 I/O 操作时，可以使用异常来处理文件找不到或无法读取或写入的情况。这些都是程序员无法控制的情况。程序可能没有正确的权限，文件可能已被删除，或者文件可能已经被使用——许多其他超出你控制的情况也可能发生。
- en: Java has specific subclasses to deal with these types of exceptions. The main
    subclass to deal with I/O operations is `IOException`. It has its own subclasses,
    such as `FileNotFoundException`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有特定的子类来处理这些类型的异常。处理 I/O 操作的主要子类是 `IOException`。它有自己的子类，例如 `FileNotFoundException`。
- en: Database operations
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库操作
- en: Another type of situation where we depend on an external part is all sorts of
    database operations. A database can be down or altered and that’s out of your
    control as a developer. So, we need to deal with exceptions that can occur while
    connecting to, querying, or updating a database. For instance, `SQLException`
    can be thrown when there are issues with a database connection or when an invalid
    SQL query is executed or when a database constraint (a database specific rule)
    is violated. Proper exception handling allows your program to recover from these
    issues, such as by re-establishing the connection or rolling back a transaction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖外部部分的另一种类型的情况是各种数据库操作。数据库可能会宕机或被修改，作为开发者，这超出了你的控制。因此，我们需要处理在连接到、查询或更新数据库时可能发生的异常。例如，当数据库连接有问题或执行了无效的
    SQL 查询，或者违反了数据库约束（数据库特定的规则）时，可能会抛出 `SQLException`。适当的异常处理允许你的程序从这些问题中恢复，例如通过重新建立连接或回滚事务。
- en: User input validation
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户输入验证
- en: When your application requires user input, exceptions can be used to handle
    cases where the input is invalid or does not meet the expected format. For example,
    `NumberFormatException` can be thrown when attempting to parse a non-numeric string
    as an integer. Handling this kind of exception well can help your application
    provide helpful feedback to users and ensure they enter valid data while keeping
    the core logic separated from error handling.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序需要用户输入时，可以使用异常来处理输入无效或不符合预期格式的情况。例如，在尝试将非数字字符串解析为整数时，可能会抛出 `NumberFormatException`。妥善处理这类异常可以帮助你的应用程序向用户提供有用的反馈，并确保他们输入有效数据，同时将核心逻辑与错误处理分离。
- en: Resource management
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源管理
- en: Your program depends on external resources, such as memory and system resources.
    These resources can also be third-party services, such as APIs. And in all these
    situations, exceptions can occur. We need to handle situations where these resources
    are unavailable or exhausted. For example, when the `OutOfMemoryError` will be
    thrown, and `InterruptedException` can be used to handle cases where a thread
    is interrupted while waiting for a resource. Proper handling in these scenarios
    can help your application recover or gracefully degrade its functionality.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序依赖于外部资源，如内存和系统资源。这些资源也可以是第三方服务，如 API。在这些所有情况下，都可能发生异常。我们需要处理这些资源不可用或耗尽的情况。例如，当抛出
    `OutOfMemoryError` 时，可以使用 `InterruptedException` 来处理在等待资源时线程被中断的情况。在这些场景中，适当的处理可以帮助你的应用程序恢复或优雅地降低其功能。
- en: What might be striking is that we have an *error* for out-of-memory situations,
    but so far, we have been talking about *exceptions* instead of errors. Let’s have
    a look at the hierarchy to understand what’s going on here.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能令人印象深刻的是，我们有一个用于处理内存不足情况的 *错误*，但到目前为止，我们一直在谈论 *异常* 而不是错误。让我们看看层次结构，以了解这里发生了什么。
- en: Understanding the exception hierarchy
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异常层次结构
- en: 'Java is an object-oriented language, and objects can form a hierarchy. In Java,
    all exceptions are subclasses of the `Throwable` class. Everything that can be
    thrown by the application in case of a problem is of the `Throwable` type. The
    `Throwable` class has two main subclasses: `Error` and `Exception`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种面向对象的语言，对象可以形成层次结构。在 Java 中，所有异常都是 `Throwable` 类的子类。在出现问题时，应用程序可以抛出的任何内容都是
    `Throwable` 类型。`Throwable` 类有两个主要的子类：`Error` 和 `Exception`。
- en: '*Errors* represent severe issues that occur during the runtime system’s operation,
    and they typically indicate critical problems with the JVM or the application
    environment. Examples include `OutOfMemoryError` and `StackOverflowError`. Errors
    are usually not recoverable, and it is *not* recommended to catch and handle them
    in your code.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*错误* 表示在运行时系统操作期间发生的严重问题，通常表明 JVM 或应用程序环境存在关键问题。例如包括 `OutOfMemoryError` 和 `StackOverflowError`。错误通常是不可恢复的，并且不建议在代码中捕获和处理它们。'
- en: 'On the other hand, the `Exception` class and its subclasses represent exceptional
    conditions that a program can handle. There are two main categories of exceptions:
    checked and unchecked exceptions.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Exception` 类及其子类代表程序可以处理的异常条件。异常主要有两大类：检查异常和未检查异常。
- en: Checked exceptions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查异常
- en: '`IOException`, `FileNotFoundException`, and `SQLException`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`IOException`、`FileNotFoundException` 和 `SQLException`。'
- en: Checked exceptions are subclasses of the `Exception` class, excluding `RuntimeException`
    and its subclasses.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 检查异常是 `Exception` 类的子类，但不包括 `RuntimeException` 及其子类。
- en: Unchecked exceptions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未检查异常
- en: '**Unchecked exceptions** represent programming errors that do not need to be
    explicitly dealt with. These exceptions are typically thrown because of programming
    errors or situations that are not expected to occur during normal program execution.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**未检查异常** 代表不需要显式处理的编程错误。这些异常通常是由于编程错误或正常程序执行期间预期不会发生的情况而抛出的。'
- en: Since unchecked exceptions usually indicate bugs in the code, the Java compiler
    assumes that your program should not need to catch or declare them explicitly.
    However, you can still choose to catch and handle unchecked exceptions. This can
    come in handy when you want to provide a more user-friendly error message or log
    the error for debugging purposes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未检查异常通常表明代码中的错误，Java 编译器假设你的程序不需要显式地捕获或声明它们。然而，你仍然可以选择捕获和处理未检查异常。当你想要提供更友好的错误消息或记录错误以供调试时，这可能会很有用。
- en: Examples of unchecked exceptions include `NullPointerException`, `IndexOutOfBoundsException`,
    and `IllegalArgumentException`. These unchecked exceptions are subclasses of `RuntimeException`.
    This class is a subclass of `Exception`. Unlike all the other subclasses of `Exception`,
    `RuntimeException` and its subclasses don’t need to be handled. (You can say it’s
    an… exception.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 未检查异常的例子包括 `NullPointerException`、`IndexOutOfBoundsException` 和 `IllegalArgumentException`。这些未检查异常是
    `RuntimeException` 的子类。这个类是 `Exception` 的子类。与 `Exception` 的所有其他子类不同，`RuntimeException`
    及其子类不需要被处理。（你可以说是…一个异常。）
- en: 'In *Figure 11**.1*, you can see this hierarchy in the form of a diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **图 11**.1 中，你可以以图表的形式看到这个层次结构：
- en: '![Figure 11.1 – Throwable hierarchy](img/B19793_11_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 可抛出类层次结构](img/B19793_11_01.jpg)'
- en: Figure 11.1 – Throwable hierarchy
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 可抛出类层次结构
- en: Understanding the exception hierarchy is essential for effectively handling
    exceptions. As you can see, there are different types of exceptions. Some of them
    (checked exceptions) need to be handled, while others do not (unchecked exceptions).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 理解异常层次结构对于有效地处理异常至关重要。正如你所见，存在不同类型的异常。其中一些（检查异常）需要处理，而另一些则不需要（未检查异常）。
- en: In this chapter, we’ll be using I/O operations to demonstrate exceptions. This
    is something that we haven’t seen yet. So, let’s introduce I/O operations first.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 I/O 操作来演示异常。这是我们之前没有见过的。所以，让我们首先介绍 I/O 操作。
- en: Working with basic I/O operations
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本 I/O 操作
- en: We’ll use I/O operations to illustrate how exceptions work. Therefore, before
    diving into exception handling, we’ll briefly introduce basic I/O operations.
    There are many ways to do this, but we’ll be using `FileReader` and `FileWriter
    - FileReader` and `FileWriter` are classes in the `java.io` package that allow
    you to read and write characters. We have chosen these two classes because they
    provide a simple way to work with text files in Java and are commonly used for
    file I/O operations in the real world as well. First things first, let’s read
    with `FileReader`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 I/O 操作来展示异常是如何工作的。因此，在深入异常处理之前，我们将简要介绍基本的 I/O 操作。有好多方法可以做到这一点，但我们将使用 `FileReader`
    和 `FileWriter` - `FileReader` 和 `FileWriter` 是 `java.io` 包中的类，允许你读取和写入字符。我们选择这两个类是因为它们提供了在
    Java 中处理文本文件的一种简单方法，并且在现实世界的文件 I/O 操作中也经常被使用。首先，让我们用 `FileReader` 来读取。
- en: Other classes for I/O operations
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 I/O 操作类
- en: It is common to use other classes for I/O operations in common situations. For
    example, if you’re going to read lines from files, you may want to work with `BufferedReader`
    instead. This is not the focus of this chapter. We just want to understand enough
    of I/O operations to demonstrate some real situations for exception handling.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见情况下，通常使用其他类进行I/O操作。例如，如果你要从文件中读取行，你可能想使用`BufferedReader`。这不是本章的重点。我们只想了解足够的I/O操作，以便演示一些异常处理的实际场景。
- en: Reading from a file using FileReader
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FileReader从文件中读取
- en: 'To read from a text file using `FileReader`, you first need to create a `FileReader`
    object and pass the file path as a parameter. You can then read characters from
    the file using the `read()` method. After using `FileReader`, you must close it
    to make sure you don’t lock the file and don’t use any unnecessary resources.
    Here’s an example of reading a file using `FileReader`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`FileReader`从文本文件中读取，你首先需要创建一个`FileReader`对象，并将文件路径作为参数传递。然后你可以使用`read()`方法从文件中读取字符。使用`FileReader`后，你必须关闭它，以确保你不锁定文件，并且不使用任何不必要的资源。下面是使用`FileReader`读取文件的示例：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code snippet is reading from a file called `input.txt`. The *try-catch*
    block is something we’ll see later in this chapter; it’s for exception handling
    and you don’t need to understand it just yet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是从名为`input.txt`的文件中读取的。*try-catch*块是我们将在本章后面看到的；它是用于异常处理的，你现在不需要理解它。
- en: 'We have created a new `FileReader` instance and passed it the path of our input
    file. For the read operation to work, `input.txt` has been placed in the project
    folder. For me, it looks like the structure shown in *Figure 11**.2*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`FileReader`实例，并传递了输入文件的路径。为了使读取操作生效，`input.txt`已经被放置在项目文件夹中。对我来说，它看起来就像*图11.2*所示的结构：
- en: '![Figure 11.2 – Location of input.txt in the project](img/B19793_11_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 项目中input.txt的位置](img/B19793_11_02.jpg)'
- en: Figure 11.2 – Location of input.txt in the project
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 项目中input.txt的位置
- en: 'The most complicated snippet of the code that reads the file is probably the
    following one:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件的最复杂的代码片段可能是以下这个：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`FileReader` is going to read the input file character by character. The `read()`
    method reads a character and moves the cursor. The cursor is the place where it
    starts reading next. So, we need to store the result of the reading in a variable
    to not lose the character. When the end of the file is reached, `read()` will
    return `-1`. This means we need to read until we reach `-1`. And that’s exactly
    what `while ((character = reader.read()) != -1)` is doing.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReader`将逐字符读取输入文件。`read()`方法读取一个字符并移动光标。光标是它开始读取下一个字符的位置。因此，我们需要将读取的结果存储在一个变量中，以免丢失字符。当达到文件末尾时，`read()`将返回`-1`。这意味着我们需要读取直到达到`-1`。这正是`while
    ((character = reader.read()) != -1)`所做的事情。'
- en: 'Our `input.txt` file is going to be printed in the output. Of course, we can
    do more interesting things with the content of the file, but that’s not the goal
    here. All we want to see is how to deal with exceptions. The code will not run
    when it’s just like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要打印的`input.txt`文件将显示在输出中。当然，我们可以用文件内容做更多有趣的事情，但这不是这里的重点。我们只想看到如何处理异常。如果代码只是这样，它将不会运行：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s how to read a file. Next up, we’ll learn how to write to a file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是读取文件的方法。接下来，我们将学习如何将内容写入文件。
- en: Writing to a file using FileWriter
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FileWriter写入文件
- en: 'This may sound quite predictable, but to write to a text file, we can use `FileWriter`.
    The steps are similar to using `FileReader`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能相当直观，但要将内容写入文本文件，我们可以使用`FileWriter`。步骤与使用`FileReader`类似：
- en: First, you need to create a `FileWriter` object and pass the file path as a
    parameter.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个`FileWriter`对象，并将文件路径作为参数传递。
- en: Next, you can write characters or strings to the file using the `write()` method.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以使用`write()`方法将字符或字符串写入文件。
- en: Finally, close `FileWriter`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，关闭`FileWriter`。
- en: 'Here’s an example of writing to a file using `FileWriter`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`FileWriter`写入文件的示例：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, first, we created an instance of `FileWriter`. Next, we created
    a variable of the `String` type called `content`. We wrote this variable to the
    `output.txt` file with the `write()` method. Again, ignore the try-catch part.
    We’ll get to that soon.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，首先，我们创建了一个`FileWriter`的实例。然后，我们创建了一个名为`content`的`String`类型变量。我们使用`write()`方法将这个变量写入`output.txt`文件。再次忽略try-catch部分。我们很快就会了解到这一点。
- en: Now that we’ve covered basic file I/O operations, we can proceed with exceptions
    and exception handling. We are going to use `FileReader` and `FileWriter` as real-world
    examples for handling various types of exceptions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基本的文件I/O操作，我们可以继续介绍异常和异常处理。我们将使用`FileReader`和`FileWriter`作为处理各种类型异常的现实世界示例。
- en: Throwing exceptions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'When something goes wrong, the program *throws an exception*. This is because
    someone that created Java or the library that you are using, at some point, coded
    it that way. A lot of the Java library is programmed to throw exceptions, such
    as in the following situations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，程序会*抛出异常*。这是因为创建Java或你正在使用的库的人，在某个时刻，这样编写了代码。Java库中的许多部分都是编程为抛出异常的，例如在以下情况下：
- en: When you try to access a field or method on a null instance, `NullPointerException`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你尝试访问null实例的字段或方法时，会抛出`NullPointerException`
- en: When you try to divide by 0, `ArithmethicException`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你尝试除以0时，会抛出`ArithmeticException`
- en: When you try to access an index in an array that is not part of the array, `ArrayIndexOutOfBoundsException`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你尝试访问数组中不属于数组范围的索引时，会抛出`ArrayIndexOutOfBoundsException`
- en: 'Here’s an example of the output of code that throws an exception:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是抛出异常的代码输出的示例：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see the name of the exception in the output (`java.lang.ArithmeticException`),
    as well as the message, stating `/` `by zero`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在输出中看到异常的名称（`java.lang.ArithmeticException`），以及消息，指出`/` `by zero`。
- en: Underneath the exception, we can see the *stack trace*. A stack trace is the
    application’s steps to get to the exception. The top of the stack trace shows
    the line that triggered the exception. This is a very tiny stack trace because
    it went wrong directly in the main method, so we only have one line in there.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常下面，我们可以看到*堆栈跟踪*。堆栈跟踪是应用程序到达异常的步骤。堆栈跟踪的顶部显示了触发异常的行。这是一个非常短的堆栈跟踪，因为它直接在主方法中出错，所以我们只有一行。
- en: A lot of the Java library throws exceptions when problematic situations happen.
    This is done with the `throw` keyword. In the next section, we’re going to see
    how we can use this `throw` keyword to throw exceptions ourselves.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，Java库会抛出异常。这是通过`throw`关键字实现的。在下一节中，我们将看到如何使用这个`throw`关键字来自己抛出异常。
- en: The throw keyword
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`throw`关键字'
- en: We can throw exceptions explicitly using the `throw` keyword. This is commonly
    used when your code detects an exceptional condition or when you want to enforce
    a specific constraint in your code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`throw`关键字显式地抛出异常。这通常用于当你的代码检测到异常条件或当你想在代码中强制执行特定约束时。
- en: 'Here is the syntax for throwing an exception:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是抛出异常的语法：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start with the `throw` keyword; after that, there’s an instance of `Throwable`.
    In this case, we throw a new `IllegalArgumentException` instance and specify in
    the message that age cannot be a negative value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`throw`关键字开始；之后，有一个`Throwable`实例。在这种情况下，我们抛出一个新的`IllegalArgumentException`实例，并在消息中指定年龄不能是负值。
- en: When an exception is thrown, the normal execution of the program is interrupted,
    and control goes to the nearest matching catch block. If none are present, the
    program stops and displays the exception and stack trace.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，程序的正常执行被中断，控制权转移到最近的匹配的catch块。如果没有，程序停止并显示异常和堆栈跟踪。
- en: Creating and throwing custom exceptions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和抛出自定义异常
- en: Java has a lot of built-in exceptions, but in some situations, you may need
    to have more specific exceptions. Great news – you can also create and throw your
    own custom exceptions! Custom exceptions are helpful when you want to provide
    more specific information about the problem that occurred, or when you want to
    handle certain types of exceptions differently in your catch blocks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Java有很多内置的异常，但在某些情况下，你可能需要更具体的异常。好消息是，你还可以创建和抛出你自己的自定义异常！自定义异常在你想提供有关发生问题的更具体信息时很有用，或者当你想在catch块中不同地处理某些类型的异常时。
- en: 'To create a custom exception, you need to define a new class that extends the
    `Exception` class or one of its subclasses. Here’s an example of a custom exception
    class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义异常，你需要定义一个新的类，该类扩展了`Exception`类或其子类。以下是一个自定义异常类的示例：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We overwrite the following three constructors. This is recommended to support
    conventions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了以下三个构造函数。这是推荐的做法以支持约定：
- en: The `no-args` constructor
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无参数`构造函数'
- en: The constructor that takes `String` containing a message
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含消息的`String`参数的构造函数
- en: The constructor that takes another exception
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受另一个异常的构造函数
- en: The `InvalidAgeException` custom class extends the `Exception` class. Therefore,
    `InvalidAgeException` is a checked exception that needs to be handled. If it extended
    `RuntimeException` or one of its subclasses, it was an unchecked exception and
    it didn’t need to be handled. Let’s talk about catching and handling exceptions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvalidAgeException` 自定义类扩展了 `Exception` 类。因此，`InvalidAgeException` 是一个需要处理的检查型异常。如果它扩展了
    `RuntimeException` 或其子类，它就是一个非检查型异常，不需要处理。让我们谈谈如何捕获和处理异常。'
- en: The catch or declare principle
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: catch 或 declare 原则
- en: The catch or declare principle states that when a method can throw a checked
    exception, the method must catch the exception with a try-catch statement or declare
    that it throws the exception in its method signature. This rule ensures that checked
    exceptions are properly handled or propagated up the call stack so that the calling
    method can handle them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: catch 或 declare 原则指出，当一个方法可以抛出检查型异常时，该方法必须使用 try-catch 语句捕获异常或在它的方法签名中声明它抛出异常。这个规则确保了检查型异常得到适当的处理或传播到调用栈，以便调用方法可以处理它们。
- en: Understanding the principle
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解原理
- en: The catch or declare principle holds for checked exceptions. If a checked exception
    is not declared or caught, the code won’t compile. For unchecked exceptions, the
    catch or declare rule does not apply. They are usually caused by programming errors
    or unexpected situations that cannot be predicted or anticipated. Unchecked exceptions
    can be caught and handled, but it is not mandatory. Let’s see how we can declare
    exceptions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检查型异常，catch 或 declare 原则适用。如果一个检查型异常没有被声明或捕获，代码将无法编译。对于非检查型异常，catch 或 declare
    规则不适用。它们通常由编程错误或无法预测或预料到的情况引起。非检查型异常可以被捕获和处理，但这不是强制性的。让我们看看我们如何声明异常。
- en: Now that we have seen how to declare exceptions, let’s have a look at how to
    deal with exceptions with the try-catch statement.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何声明异常，让我们看看如何使用 try-catch 语句处理异常。
- en: Declaring exceptions using throws
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 throws 声明异常
- en: The `throws` keyword is used to declare that a method may throw a certain exception.
    By using the `throws` keyword, you can indicate that a method may throw one or
    more checked exceptions. The method that calls the other method that declares
    the exception is responsible for handling them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`throws` 关键字用于声明一个方法可能会抛出某种异常。通过使用 `throws` 关键字，你可以表明一个方法可能会抛出一个或多个检查型异常。调用声明异常的其他方法的方法有责任处理它们。'
- en: 'Declaring an exception is not difficult. You can simply add `throws` to the
    method signature followed by the exception type. Here’s an example of a piece
    of code using `FileReader`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 声明异常并不困难。你只需在方法签名后简单添加 `throws` 并跟随着异常类型即可。以下是一个使用 `FileReader` 的代码示例：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the `read` method declares that it may throw `IOException`.
    When another method calls this method, it is responsible for handling the exception.
    When you know how you want to deal with an exception, you can handle it with the
    try-catch statement instead of declaring it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`read` 方法声明它可能会抛出 `IOException`。当另一个方法调用这个方法时，它有责任处理这个异常。当你知道你想要如何处理一个异常时，你可以使用
    try-catch 语句来处理它，而不是声明它。
- en: Handling exceptions with try-catch
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 try-catch 处理异常
- en: When a method declares a checked exception, the calling method is obligated
    to deal with it. This can be done by catching the exception or by declaring the
    exception in its own method signature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法声明了一个检查型异常时，调用该方法的方法有义务处理它。这可以通过捕获异常或在其自己的方法签名中声明异常来完成。
- en: Let’s have a look at how to deal with exceptions using a try-catch block. Try-catch
    blocks come in different forms, but we’ll start with the most basic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 try-catch 块处理异常。try-catch 块有多种形式，但我们将从最基本的形式开始。
- en: Basic try-catch block
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的 try-catch 块
- en: 'A try-catch block is used to handle exceptions that might be thrown during
    the execution of a specific block of code. The code that might throw an exception
    is placed inside the `try` block, and the code to handle the exception is placed
    inside the corresponding `catch` block. Here’s the syntax of a try-catch block:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: try-catch 块用于处理在执行特定代码块期间可能抛出的异常。可能抛出异常的代码放置在 `try` 块内，处理异常的代码放置在相应的 `catch`
    块内。以下是 try-catch 块的语法：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here’s an example of a basic try-catch block that actually has some code
    that might throw an exception and some basic handling. We saw this when we were
    learning about `FileReader`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个基本的try-catch块示例，其中包含可能抛出异常的代码和一些基本的处理。我们在学习`FileReader`时看到了这个例子：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this code, `FileReader` can throw multiple exceptions. For example, when
    the file does not exist, it will throw `FileNotFoundException`. This exception
    is an `IOException`, which, in turn, is an `Exception`. Therefore, `FileReader`
    might throw a checked exception. And checked exceptions need to be handled. Therefore,
    we must place the code that can throw the exception(s) in the try block. We handle
    `Exception` in the catch block by printing the stack trace. After handling the
    exception, the program’s execution continues normally.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`FileReader`可能会抛出多个异常。例如，当文件不存在时，它会抛出`FileNotFoundException`。这个异常是一个`IOException`，而`IOException`又是一个`Exception`。因此，`FileReader`可能会抛出一个检查型异常。检查型异常需要被处理。因此，我们必须将可能抛出异常（s）的代码放在`try`块中。我们通过打印堆栈跟踪在捕获块中处理`Exception`。处理完异常后，程序会继续正常执行。
- en: We can also specify multiple catch blocks if we need to specify specific handling
    for different kinds of exceptions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为不同类型的异常指定特定的处理，我们也可以指定多个捕获块。
- en: Multiple catch blocks
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个捕获块
- en: A block of code may throw multiple types of exceptions. We can handle different
    exceptions using *multiple catch blocks*. It’s important to have the most specific
    exception on top. If we were to start by catching `Exception`, for example, it
    would always go to that catch block. This is because all exceptions inherit from
    Exception and would be of type Exception. The `catch(Exception e)` would catch
    every possible exception, making the rest of the catch clauses unreachable. Therefore,
    it doesn’t compile if you try to do that.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一段代码可能会抛出多种类型的异常。我们可以使用*多个捕获块*来处理不同的异常。将最具体的异常放在最上面是很重要的。如果我们首先捕获`Exception`，例如，它总是会进入那个捕获块。这是因为所有异常都继承自`Exception`，并且会是`Exception`类型。`catch(Exception
    e)`会捕获所有可能的异常，使得其余的捕获子句不可达。因此，如果你尝试这样做，它将无法编译。
- en: 'Here’s an example of using multiple catch blocks:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用多个捕获块的例子：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we have two catch blocks – one for `FileNotFoundException`
    and one for `IOException`. If an exception is thrown, the appropriate catch block
    will be executed based on the exception type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个捕获块——一个用于`FileNotFoundException`，另一个用于`IOException`。如果抛出异常，将根据异常类型执行相应的捕获块。
- en: Sometimes, we want to clean up resources after the catch or perform other sorts
    of actions. We can do so with the `finally` block.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在捕获之后清理资源或执行其他类型的操作。我们可以通过`finally`块来实现这一点。
- en: Try-catch-finally
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: try-catch-finally
- en: The `finally` block is an optional block of code that follows a try-catch block.
    It is executed regardless of whether an exception is thrown or not. The `finally`
    block is typically used to clean up resources. These resources could be file streams
    or network connections that need closing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块是一个可选的代码块，它跟在try-catch块之后。它无论是否抛出异常都会被执行。`finally`块通常用于清理资源。这些资源可能是需要关闭的文件流或网络连接。'
- en: 'Here’s an example of using a `finally` block:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`finally`块的例子：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the `finally` block is executed after the `try-catch` block,
    regardless of whether an exception occurred. The only way to not execute the `finally`
    block is to stop the program completely before it completes the `try-catch` block.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`finally`块在`try-catch`块之后执行，无论是否发生异常。唯一不执行`finally`块的方法是在`try-catch`块完成之前完全停止程序。
- en: Use cases for the finally block
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`finally`块的使用场景'
- en: 'The `finally` block can be used to clean up resources. This ensures that they
    are properly released, even if an exception is thrown. Here’s an example of using
    a `finally` block to close the instance of `FileReader`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块可以用来清理资源。这确保了即使在抛出异常的情况下，它们也能被正确释放。以下是一个使用`finally`块关闭`FileReader`实例的例子：'
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This example is a little different. Let’s start with the most striking difference:
    we close the `readerin` the finally block now. This ensures that `readergets`
    closed, even if an exception occurs in the try block before it gets to that line.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有一点不同。让我们从最显著的不同之处开始：我们现在在`finally`块中关闭了`readerin`。这确保了`readergets`即使在`try`块中发生异常之前也会被关闭。
- en: 'For `reader` to be still in scope in the `finally` block, we have to declare
    it outside of the `try` block. That’s why we have this line on top of the `try`
    block:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `reader` 在 `finally` 块中仍然有效，我们必须在 `try` 块之外声明它。这就是为什么我们在 `try` 块上方有这一行：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can’t initialize it outside of the `try` block because that part needs to
    be in the `try` block since it may throw an exception.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在 `try` 块之外初始化它，因为那部分需要位于 `try` 块中，因为它可能会抛出异常。
- en: 'Here’s the flow of the code when no exception occurs:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有异常发生时，代码的流程如下：
- en: '`try`: Initialize `FileReader` and read the file.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`try`: 初始化 `FileReader` 并读取文件。'
- en: '`finally`: Close `reader`.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finally`: 关闭 `reader`.'
- en: Continue after the `finally` block with the rest of the code.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `finally` 块之后继续执行剩余的代码。
- en: 'And here’s the flow of the code when an exception occurs:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生异常时，代码的流程如下：
- en: '`try`: Initialize `FileReader` and read the file.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`try`: 初始化 `FileReader` 并读取文件。'
- en: '`catch`: Handle the exception.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`catch`: 处理异常。'
- en: '`finally`: close the reader.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finally`: 关闭 reader。'
- en: Continue after the `finally` block with the rest of the code.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `finally` 块之后继续执行剩余的代码。
- en: So, regardless of whether an exception is thrown, the `finally` block ensures
    `reader` is closed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否抛出异常，`finally` 块都确保 `reader` 被关闭。
- en: Closing `reader` might throw another exception, which is why we have another
    try-catch statement in the `finally` block. Arguably, this is not a very pretty
    syntax. A solution for many of these situations is using the **try-with-resources**
    statement instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭 `reader` 可能会抛出另一个异常，这就是为什么我们在 `finally` 块中又有一个 try-catch 语句。可以说，这不是一个非常漂亮的语法。对于许多这种情况的解决方案是使用
    **try-with-resources** 语句。
- en: Handling exceptions with try-with-resources
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 try-with-resources 处理异常
- en: Java 7 introduced the `finally` block for resource cleaning for many types of
    classes. The try-with-resources statement can be used without a catch or `finally`
    block. The normal `try` statement must have at least one of those.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 引入了 `finally` 块，用于清理许多类型的类。try-with-resources 语句可以在没有 catch 或 `finally`
    块的情况下使用。正常的 `try` 语句必须至少有一个这些块。
- en: What is try-with-resources?
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 try-with-resources？
- en: The try-with-resources statement takes care of resource management for you.
    A resource is a special Java object that opens a channel that needs to be closed
    in order for the resource to be marked for cleanup by Java. We have seen that
    the FileReader objects are examples of this.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: try-with-resources 语句为您处理资源管理。资源是一个特殊的 Java 对象，它打开一个需要关闭的通道，以便资源可以被 Java 标记为清理。我们已经看到，`FileReader`
    对象是这种资源的例子。
- en: The resources that are declared within the try-with-resources statement will
    be automatically closed when the `try` block completes. And of course, just like
    the `finally` block, it doesn’t matter whether or not an exception is thrown.
    The resources will be closed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 try-with-resources 语句中声明的资源将在 `try` 块完成后自动关闭。当然，就像 `finally` 块一样，无论是否抛出异常，资源都将被关闭。
- en: 'Here’s an example of using try-with-resources:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 try-with-resources 的例子：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The resources need to be opened between the parentheses following the `try`
    block. At the end of the `try` block, the resources will be closed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 资源需要在 `try` 块之后的括号内打开。在 `try` 块结束时，资源将被关闭。
- en: 'You can open multiple ones separated with a semicolon, like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用分号分隔打开多个资源，如下所示：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You don’t need to understand the details of the code in this example since we
    did not talk about `BufferedReader` and `BufferedWriter`. These classes are utility
    classes that provide buffering capabilities for reading and writing text files.
    With buffering, we can improve the performance of I/O operations by minimizing
    the number of system calls.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有讨论 `BufferedReader` 和 `BufferedWriter`，所以您不需要理解这个例子中代码的细节。这些类是提供缓冲功能的实用类，用于读写文本文件。通过缓冲，我们可以通过最小化系统调用的次数来提高
    I/O 操作的性能。
- en: The preceding code snippet uses `FileReader` and `BufferedReader` to read the
    contents of a file, while `FileWriter` and `BufferedWriter` are used to convert
    content (all uppercase) into `output.txt`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用 `FileReader` 和 `BufferedReader` 来读取文件内容，而 `FileWriter` 和 `BufferedWriter`
    用于将内容（全部大写）转换为 `output.txt`。
- en: The try-with-resources block ensures that all resources are automatically closed
    after their use. It does so in the opposite order of declaring them, so it starts
    by closing the last. This is important because, as you can see, we’re using `fileWriter`
    to create `bufferedWriter`. Closing them in a different order may cause issues.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: try-with-resources块确保在资源使用后自动关闭所有资源。它是按照与声明相反的顺序关闭的，所以它首先关闭最后一个。这很重要，因为正如你所看到的，我们正在使用`fileWriter`来创建`bufferedWriter`。以不同的顺序关闭它们可能会导致问题。
- en: Please don’t forget, not all classes can be automatically closed. For Java to
    be able to automatically close a class, the class needs to implement the `AutoCloseable`
    interface.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要忘记，并不是所有的类都可以自动关闭。为了让Java能够自动关闭一个类，这个类需要实现`AutoCloseable`接口。
- en: Implementing the AutoCloseable interface
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现`AutoCloseable`接口
- en: To be able to use a (custom) class with the try-with-resources statement, the
    class should implement the `AutoCloseable` interface and override the `close()`
    method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用一个（自定义）类与try-with-resources语句一起使用，这个类应该实现`AutoCloseable`接口并重写`close()`方法。
- en: 'We can create our own classes that can be automatically closed. Here’s an example
    of a custom resource that implements `AutoCloseable`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的类，这些类可以自动关闭。以下是一个实现`AutoCloseable`的自定义资源的示例：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This resource can now be used in a try-with-resources statement:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个资源现在可以在try-with-resources语句中使用：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code opens `SomeResource` in the try-with-resources statement. We then
    call the `doSomething()` method, which prints a line to the console. At the end
    of the block, the resource is closed. We print another line in the `close()` method
    that we had to implement for the `AutoCloseable` interface.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在try-with-resources语句中打开`SomeResource`。然后我们调用`doSomething()`方法，该方法向控制台打印一行。在代码块结束时，资源被关闭。我们在必须为`AutoCloseable`接口实现`close()`方法时打印另一行。
- en: 'This is the output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, it prints the line from the `doSomething()` method. The `close()`
    method also gets triggered. As we can see, the message that it prints in the output
    as well. We don’t trigger the `close()` method ourselves, this is done by the
    mechanism of the `try-with-resource` statement.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它打印了`doSomething()`方法的行。`close()`方法也被触发。正如我们所看到的，它在输出中打印的消息。我们不自己触发`close()`方法，这是由`try-with-resources`语句的机制完成的。
- en: 'That’s the basics of the try-with-resources statement so that you can start
    working with it. It’s now time for a topic that is often considered to be quite
    challenging: dealing with inheritance and exceptions.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是try-with-resources语句的基础，这样你就可以开始使用它了。现在是我们讨论一个通常被认为相当具有挑战性的主题的时候了：处理继承和异常。
- en: Working with inheritance and exceptions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承和异常处理
- en: When a class inherits from another class, it can override the methods in this
    other class. There are some special rules for dealing with the declared exceptions
    and overriding methods. It’s important to understand this to successfully override
    methods that declare exceptions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类继承自另一个类时，它可以重写这个其他类中的方法。处理声明的异常和重写方法有一些特殊的规则。理解这些规则对于成功重写声明异常的方法非常重要。
- en: Declaring exceptions in method signatures
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在方法签名中声明异常
- en: When a method can throw a checked exception that isn’t dealt with in that method
    by a try-catch, it is declared in the method’s signature. We have just learned
    that this is done with the `throws` keyword, followed by the exception type(s).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法可以抛出一个未被该方法中的try-catch处理的检查异常时，它会在方法签名中声明。我们刚刚学到，这是通过`throws`关键字后跟异常类型（s）来完成的。
- en: 'Here’s an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `readFile` method’s signature declares that it can throw `IOException`.
    When we extend the class that this method is in, we can override the `readFile`
    method. There are some important rules for how to deal with exceptions that are
    declared.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile`方法的签名声明它可以抛出`IOException`。当我们扩展这个方法所在的类时，我们可以重写`readFile`方法。处理声明的异常有一些重要的规则。'
- en: Overriding methods and exception handling
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写方法和异常处理
- en: 'Let’s step away from the code for a second here and think of this a little
    bit more abstractly and concretely at the same time. Let’s say you and I meet
    up next week to discuss a software application at your office, and I’m telling
    you I’ll have to bring my young kids due to daycare issues. You know that certain
    *exceptions* may occur: tantrums, fights between the kids, random food in your
    hair and on your clothes, and so on. However, you agree to meet me.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时放下代码，同时更抽象和具体地思考一下。假设你和我下周在你办公室见面讨论一个软件应用，我告诉你由于日托问题我必须带上我的小孩子。你知道可能会发生某些*异常*：孩子的闹脾气、孩子之间的争吵、头发和衣服上的食物，等等。然而，你同意和我见面。
- en: If I’m planning on also bringing my three rottweilers because my dog sitter
    cancels, I may want to inform you about this beforehand so you can decide whether
    it’s still okay for me to come over with these new conditions. You have incorporated
    the *kids exceptions* in your decision already, but you haven’t decided whether
    you are also okay with *dog exceptions* yet. This includes muddy paws, drool,
    dog hair, and potentially accidentally sharing your cookie with one of the gentle
    giants.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我计划也带来我的三只罗威纳犬，因为我的宠物看护者取消了，我可能想提前通知你，这样你可以决定是否仍然可以让我在这些新条件下过来。你已经在你做出的决定中包含了*孩子异常*，但你还没有决定你是否也接受*狗异常*。这包括泥泞的爪子、口水、狗毛，以及可能不小心和这些温柔的巨兽分享你的饼干。
- en: It’s probably considered polite to inform you about bringing the cuddly protectors
    over beforehand. However, if I end up having a babysitter and I come by myself,
    I probably don’t need to mention that in advance because it makes it more convenient.
    (No, I don’t hate my kids.)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前通知你带来可爱的保护者可能被认为是有礼貌的。然而，如果最终我有一个保姆并且我自己来，我可能不需要提前提这件事，因为这会使事情更加方便。（不，我不讨厌我的孩子。）
- en: Alright – keep this in mind while we make the transition back to Java.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧——在我们回到Java的过程中，请记住这一点。
- en: 'When you override a method in a subclass, the overriding method must follow
    certain rules regarding exceptions:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在子类中重写一个方法时，重写的方法必须遵循有关异常的某些规则：
- en: It cannot throw checked exceptions that weren’t declared in the signature of
    the method in the parent class. (We cannot bring the dogs without notice.)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能抛出在父类方法签名中未声明的已检查异常。（我们不能不通知就带来狗。）
- en: If the overridden method declares a checked exception, the overriding method
    can declare the same exceptions, a subclass of that exception, or a subset of
    the exceptions. (Bringing just one kid instead of two).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被重写的方法声明了一个已检查异常，重写的方法可以声明相同的异常、该异常的子类或异常的子集。（只带一个孩子而不是两个。）
- en: Nothing can also be considered a subset. So, we can also choose not to declare
    any exception in the child class that overrides the method. (Not bringing the
    kids.)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么也可以被认为是一个子集。因此，我们也可以选择不在重写方法的孩子类中声明任何异常。（不带孩子们。）
- en: 'Here’s an example of an override that declares a subclass:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个声明子类的重写示例：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Child` class overrides the `readStuff` method from the `Parent` class.
    Since the overridden method declares the `IOException`, the overriding method
    can declare the same exception or a subclass of it (for example, `FileNotFoundException`)
    or not declare any exception at all.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child`类重写了`Parent`类的`readStuff`方法。由于被重写的方法声明了`IOException`，重写的方法可以声明相同的异常或其子类（例如，`FileNotFoundException`）或者根本不声明任何异常。'
- en: Unchecked exceptions can always be added. They don’t have any consequences for
    the calling code. At the same time, declaring them, in general, doesn’t make a
    lot of sense, since it’s not obligated to deal with them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 未检查异常总是可以添加的。它们对调用代码没有任何影响。同时，通常声明它们也没有太多意义，因为它们没有义务处理它们。
- en: Exercises
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Let’s deal with some common unhappy path scenarios in our app. When these occur,
    we need our app to be able to recover from them:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理一些我们应用中常见的令人不快的路径场景。当这些发生时，我们需要我们的应用能够从中恢复：
- en: When reading and writing the dinosaur data, it is possible that the file cannot
    be opened due to different circumstances. Perhaps someone moved it, it’s in use,
    or something else. Your task is to simulate a situation where you’re trying to
    read from a file (that may not exist) and deal with the checked exception.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在读取和写入恐龙数据时，由于不同情况，文件可能无法打开。也许有人移动了它，它在使用中，或者发生了其他事情。你的任务是模拟一个尝试从文件（可能不存在）中读取并处理已检查异常的情况。
- en: While updating dinosaur data, invalid values could sometimes be provided. Write
    an `updateDinosaurWeight` method that takes a weight value and a `Dinosaur` object.
    If the weight value is less than zero, the method should throw `IllegalArgumentException`.
    Use a try-catch block to handle this exception. The handling can be a simple `System.out.println`
    for now.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新恐龙数据时，有时可能会提供无效的值。编写一个 `updateDinosaurWeight` 方法，该方法接受一个重量值和一个 `Dinosaur`
    对象。如果重量值小于零，该方法应抛出 `IllegalArgumentException`。使用 try-catch 块来处理这个异常。目前，处理可以是简单的
    `System.out.println`。
- en: Even in exceptional circumstances, certain operations should always execute.
    For example, a daily audit of dinosaurs’ health should happen, whether an exception
    occurs (for example due to the weight being too low) or not. Use a `finally` block
    in your program to demonstrate this. Code the logic so that even if there is an
    error in updating a dinosaur’s health record, a message about the daily audit
    completion should still be printed.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使在异常情况下，某些操作也应该始终执行。例如，无论是否发生异常（例如由于体重过低），都应该进行恐龙的健康每日审计。在你的程序中使用 `finally`
    块来演示这一点。编写逻辑，即使更新恐龙健康记录时出现错误，也应该打印出每日审计完成的消息。
- en: 'In our dinosaur park, data about dinosaurs’ diets is stored in external resources
    . In this case, that external resource is a file. Write a program where you use
    a try-with-resources block to read data from this file, ensuring the file is closed
    properly after use, even if an error occurs during data retrieval. Here’s a sample
    file called `DinoDiet.txt` that you can use:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的恐龙公园中，恐龙饮食数据存储在外部资源中。在这种情况下，外部资源是一个文件。编写一个程序，其中你使用 try-with-resources 块从该文件中读取数据，确保在使用后正确关闭文件，即使数据检索过程中发生错误。以下是一个名为
    `DinoDiet.txt` 的示例文件，你可以使用它：
- en: '[PRE22]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If a dinosaur’s health score falls below a certain critical value, the program
    should throw a custom exception, named `CriticalHealthException`. Create this
    custom exception and use it in your program to handle this specific problematic
    condition.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果恐龙的健康评分低于某个临界值，程序应抛出一个名为 `CriticalHealthException` 的自定义异常。创建这个自定义异常并在你的程序中使用它来处理这个特定的问题条件。
- en: Project – dinosaur care system
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 – 恐龙护理系统
- en: Running a dinosaur park is filled with unexpected situations. Some are minor,
    such as running out of cheese-flavored potato chips. Some are major, such as an
    escaped T-Rex. The happiness, health, and safety of our dinosaurs and visitors
    are important, so our system should be able to handle exceptional situations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 经营一个恐龙公园充满了意外情况。有些是小事，比如奶酪味薯片用完了。有些是大事，比如霸王龙逃跑了。我们恐龙和游客的幸福、健康和安全很重要，因此我们的系统应该能够处理异常情况。
- en: Design a “dinosaur care system” for Mesozoic Eden that handles exceptional situations
    such as a dinosaur falling ill, enclosure breaches, and so on. Use appropriate
    exceptions to represent various error conditions and handle them properly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为中生代伊甸园设计一个“恐龙护理系统”，该系统可以处理诸如恐龙生病、围栏被破坏等异常情况。使用适当的异常来表示各种错误条件，并正确处理它们。
- en: 'Here are the steps to do this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行这些步骤的方法：
- en: 'Set up your project:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的项目：
- en: Create a new Java project in your IDE of choice.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的 IDE 中创建一个新的 Java 项目。
- en: Create a new package named exception.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `exception` 的新包。
- en: 'Create custom exceptions:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建自定义异常：
- en: Create a new class called `DinosaurIllException` inside the exception package.
    This class should extend the `Exception` class and represent an error condition
    when a dinosaur falls ill.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在异常包中创建一个名为 `DinosaurIllException` 的新类。这个类应该扩展 `Exception` 类，并代表恐龙生病时的错误条件。
- en: Similarly, create `EnclosureBreachedException` for an error condition where
    an enclosure has been breached.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，为围栏被破坏的错误条件创建 `EnclosureBreachedException`。
- en: 'Create the dinosaur care system:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建恐龙护理系统：
- en: Create a new class called `DinosaurCareSystem`.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DinosaurCareSystem` 的新类。
- en: Inside this class, create a method called `handleDinosaurHealth()` that throws
    `DinosaurIllException`. You can simulate random health conditions for the dinosaur.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，创建一个名为 `handleDinosaurHealth()` 的方法，该方法抛出 `DinosaurIllException`。你可以模拟恐龙的随机健康状况。
- en: Similarly, create a method called `handleEnclosureSecurity()` that throws `EnclosureBreachedException`.
    Using this, you can simulate the random security status of dinosaur enclosures.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建一个名为 `handleEnclosureSecurity()` 的方法，该方法抛出 `EnclosureBreachedException`。使用这个方法，你可以模拟恐龙围栏的随机安全状态。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We’ve just explored the importance of exception handling. We now know how it
    allows us to separate the code logic from the error handling logic. We delved
    into the two main types of exceptions: checked and unchecked. Checked exceptions
    are exceptions that require explicit handling, whereas unchecked exceptions are
    usually caused by programming errors and do not need to be explicitly caught or
    declared.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚探讨了异常处理的重要性。我们现在知道它如何使我们能够将代码逻辑与错误处理逻辑分离。我们深入了解了两种主要的异常类型：检查异常和非检查异常。检查异常是需要显式处理的异常，而非检查异常通常由编程错误引起，不需要显式捕获或声明。
- en: We discussed the catch or declare principle, which requires checked exceptions
    to be caught in a try-catch block or declared in a method’s signature. The try-catch
    block allows us to handle exceptions by executing alternative code when an exception
    occurs. We also learned about using multiple catch blocks to handle different
    types.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了捕获或声明原则，该原则要求检查异常必须在try-catch块中捕获或在方法签名中声明。try-catch块允许我们在发生异常时执行替代代码来处理异常。我们还学习了如何使用多个catch块来处理不同类型。
- en: Next, we saw the `finally` block, which is executed regardless of whether an
    exception occurs. This block is useful for cleaning up resources and ensuring
    certain actions are always performed. This `finally` block is less common since
    Java 7 and try-with-resources is used whenever possible. This simplifies resource
    management by automatically closing resources when the `try` block finishes executing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了`finally`块，无论是否发生异常都会被执行。这个块用于清理资源并确保某些操作始终被执行。自从Java 7以来，`finally`块变得不那么常见，因为尽可能使用`try-with-resources`。这通过在`try`块执行完毕后自动关闭资源来简化资源管理。
- en: Finally, we examined method exception signatures and how they relate to inheritance
    while focusing on the rules for checked exceptions when overriding methods.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查了方法异常签名以及它们与继承的关系，同时关注了在覆盖方法时检查异常的规则。
- en: At this point, you should have a solid understanding of Java exception handling.
    Now, it’s time to learn a little more about the Java core API.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对Java异常处理有了稳固的理解。现在，是时候学习更多关于Java核心API的知识了。
