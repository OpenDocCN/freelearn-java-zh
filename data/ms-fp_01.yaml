- en: The Declarative Programming Style
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式编程风格
- en: Declarative programming is tightly connected to functional programming. Modern
    functional languages prefer to express programs as algebra and not as algorithms.
    This means that programs in functional languages are combinations of certain primitives
    with operators. The technique where you express your programs by specifying what
    to do, but not how to do it, is referred to as declarative programming. We will
    explore why declarative programming appeared and where it can be used.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程与函数式编程紧密相连。现代函数式语言更喜欢将程序表达为代数而不是算法。这意味着函数式语言中的程序是某些原语与运算符的组合。通过指定要做什么而不是如何做来表达程序的技术被称为声明式编程。我们将探讨为什么声明式编程出现以及它可以在哪里使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Principles of declarative programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式编程原理
- en: Declarative versus imperative collections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式与命令式集合的比较
- en: Declarative programming in other languages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他语言中的声明式编程
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run the examples in this book, you will need the following software, as
    well as basic understanding of how to use it:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本书中的示例，您需要以下软件以及对其基本使用方法的理解：
- en: Docker version 18.06 or higher: [https://www.docker.com/](https://www.docker.com/)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 版本 18.06 或更高：[https://www.docker.com/](https://www.docker.com/)
- en: Git version 2.18.0 or higher: [https://git-scm.com/](https://git-scm.com/)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 版本 2.18.0 或更高：[https://git-scm.com/](https://git-scm.com/)
- en: 'To run the samples:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例：
- en: Clone the [https://github.com/PacktPublishing/Mastering-Functional-Programming](https://github.com/PacktPublishing/Mastering-Functional-Programming)
    repository on your machine.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的机器上克隆 [https://github.com/PacktPublishing/Mastering-Functional-Programming](https://github.com/PacktPublishing/Mastering-Functional-Programming)
    仓库。
- en: From its root, compose and run the Docker set of images specified in `docker-compose.yml`.
    If you are on a Linux/Mac machine, you can run `./compose.sh` to complete this
    step. If you are on Windows, open `compose.sh` in text editor and run each command
    from your terminal manually.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其根目录开始，运行 `docker-compose.yml` 中指定的 Docker 镜像集。如果您在 Linux/Mac 机器上，可以运行 `./compose.sh`
    来完成此步骤。如果您在 Windows 上，请在文本编辑器中打开 `compose.sh` 并手动从终端运行每个命令。
- en: Run shell (Bash) on the Docker service called `mastering-functional-programming``_backend_1`.
    You can complete this step by running `./start.sh` on a Linux/Mac machine from
    a separate terminal window. If you are on a Windows machine, run `docker exec
    -ti mastering_backend bash`. Then `cd Chapter1` for Chapter 1 examples, or `cd
    ChapterN` for Chapter N examples.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `mastering-functional-programming_backend_1` 的 Docker 服务上运行 Shell（Bash）。您可以通过在
    Linux/Mac 机器上的单独终端窗口运行 `./start.sh` 来完成此步骤。如果您在 Windows 机器上，请运行 `docker exec -ti
    mastering_backend bash`。然后 `cd Chapter1` 以访问第 1 章的示例，或 `cd ChapterN` 以访问第 N 章的示例。
- en: The `cpp` folder contains C++ sources. You can run them with `./run.sh <name-of-the-source>` from
    that directory.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cpp` 文件夹包含 C++ 源代码。您可以从该目录使用 `./run.sh <源代码名称>` 来运行它们。'
- en: The `jvm` folder contains Java and Scala sources. You can run them by running
    `sbt run` from that directory.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jvm` 文件夹包含 Java 和 Scala 源代码。您可以从该目录运行 `sbt run` 来运行它们。'
- en: Note that it is necessary to run the examples under Docker. Some chapters run
    examples against a live database, which is managed by Docker, so make sure to
    get the above procedure working.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Docker 下运行示例是必要的。某些章节的示例会针对实时数据库运行，该数据库由 Docker 管理，因此请确保上述步骤正常工作。
- en: The codes presented in this book are available at: [https://github.com/PacktPublishing/Mastering-Functional-Programming](https://github.com/PacktPublishing/Mastering-Functional-Programming)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码可在以下网址找到：[https://github.com/PacktPublishing/Mastering-Functional-Programming](https://github.com/PacktPublishing/Mastering-Functional-Programming)
- en: Principles of declarative programming
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式编程原理
- en: Why declarative programming? How did it appear? To understand declarative programming,
    we need to first understand how it is different from imperative programming. For
    a long time, imperative programming has been a *de facto* industry standard. What
    motivated people to start switching to the functional style from the imperative
    style?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是声明式编程？它是如何出现的？要理解声明式编程，我们首先需要了解它与命令式编程的不同之处。长期以来，命令式编程一直是事实上的行业标准。是什么促使人们开始从命令式风格转向函数式风格？
- en: In imperative programming, you rely on a set of primitives that your language
    provides. You combine them in a certain way so as to achieve a functionality that
    you need. We can understand different things under primitives. For example, these
    can be loop control structures, or, in the case of collections, operations specific
    to collections, such as creating a collection and adding or removing elements
    from a collection.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，你依赖于语言提供的一组原语。你以某种方式将它们组合起来，以实现你需要的功能。我们可以在原语下理解不同的事物。例如，这些可以是循环控制结构，或者，在集合的情况下，特定的集合操作，如创建集合和向集合中添加或删除元素。
- en: In declarative programming, you also rely on primitives. You use them to express
    your program. Yet, in declarative programming, these primitives are much closer
    to your domain. They can be so close to your domain that the language itself can
    be regarded as a **domain-specific language** (**DSL**). With declarative programming,
    you are able to create primitives as you go.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式编程中，你也依赖于原语。你使用它们来表达你的程序。然而，在声明式编程中，这些原语与你的领域更接近。它们可以接近到语言本身可以被视为**领域特定语言**（**DSL**）。通过声明式编程，你可以在进行过程中创建原语。
- en: In imperative programming, you usually don't create new primitives, but rely
    on the ones the language provides you with. Let's go through some examples to
    understand the importance of declarative programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，你通常不会创建新的原语，而是依赖于语言为你提供的原语。让我们通过一些例子来了解声明式编程的重要性。
- en: Example – go-to versus loops
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 – `go-to`与循环的比较
- en: 'How imperative turns into declarative is best understood by means of an example.
    Most likely, you already know the `go-to` statement. You have heard that using
    the `go-to` statement is bad practice. Why? Consider an example of a loop. It
    is possible to express a loop using only the `go-to` statement:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过例子最好地理解命令式如何转变为声明式。你很可能已经知道`go-to`语句。你听说过使用`go-to`语句是不良的做法。为什么？考虑一个循环的例子。可以使用仅使用`go-to`语句来表达循环：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding example, imagine you need to express a `while` loop. You
    have the variable `x` and you need to increment it in a loop by one until it reaches
    `10`. In modern languages such as Java, you would be able to do this using the
    `while` loop, but it is also possible to do that using the `go-to` statement.
    For example, it is possible to have a label on the `increment` statement. A conditional
    statement after it will check whether the variable reached the necessary value.
    If it did not, we perform a `go-to` on the line of code to increment a variable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，想象你需要表达一个`while`循环。你有一个变量`x`，你需要通过循环每次增加一，直到它达到`10`。在现代语言如Java中，你将能够使用`while`循环来完成这个操作，但也可以使用`go-to`语句来完成。例如，可以在`increment`语句上有一个标签。在它之后的条件语句将检查变量是否达到了必要的值。如果没有，我们将执行`go-to`到增加变量的代码行。
- en: 'Why is `go-to` a bad style in this case? A loop is a pattern.  A pattern is
    an arrangement of two or more logical elements in your code that repeats in different
    places of your program. In our case, the pattern is the loop. Why is it a pattern?
    First, it consists of three parts:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在这种情况下`go-to`是不良风格？循环是一个模式。模式是在你的代码中重复出现在不同程序位置的逻辑元素的排列。在我们的情况下，模式是循环。为什么它是模式？首先，它由三个部分组成：
- en: The first part is the label that is the entry point to the body of the loop—the
    point where you jump from the end of the loop to reiterate the loop.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一部分是标签，它是循环体的入口点——你从循环的末尾跳转回来重复循环的点。
- en: The second part is the condition that must be true in order for the loop to
    reiterate.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二部分是循环必须满足的条件，以便循环可以重复执行。
- en: The third part is the statement to reiterate the fact that it is a loop. It
    is the end of the body of the loop.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三部分是重申这是一个循环的语句。它是循环体的结束。
- en: Besides being composed of three parts, it also describes an action that is ubiquitous
    in programming. The action is repeating a chunk of code more than once. The fact
    that loops are ubiquitous in programming needs no explanation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由三个部分组成之外，它还描述了编程中普遍存在的动作。这个动作是重复执行代码块多次。循环在编程中的普遍性无需解释。
- en: 'If you re-implement the loop pattern each time you need it, things can go wrong.
    As the pattern has more than one part to it, it can be corrupted by misusing one
    of the parts, or you could make a mistake when arranging the parts into a whole.
    It is possible to forget to name the label to which to jump, or to name it incorrectly.
    You may also forget to define the `predicate` statement that guards the jump to
    the beginning of the loop. Or, you could misspell the label to which to jump in
    the `q` statement itself. For example, in the following code, we forgot to specify
    the predicate guard:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每次需要循环模式时都重新实现它，事情可能会出错。由于这个模式由多个部分组成，它可能会因为误用其中一个部分而损坏，或者你可能在将部分组合成一个整体时出错。你可能会忘记命名要跳转的标签，或者错误地命名它。你也可能忘记定义保护跳转到循环开始处的`predicate`语句。或者，你可能在`q`语句本身中漏掉或拼写错误要跳转的标签。例如，在以下代码中，我们忘记了指定谓词保护：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example – nested loop
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 嵌套循环
- en: It's pretty hard to get such a simple example wrong, but consider a nested loop.
    For example, you have a matrix, and you want to output it to the console. This
    can be done with a `nested` loop. You have a loop to iterate on with every entry
    of the 2D array. Another loop nested in that loop examines the row the outer loop
    is currently working on. It iterates on every element of that row and prints it
    to the console.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这样一个简单的例子中出错是非常困难的，但考虑一个嵌套循环。例如，你有一个矩阵，你想要将其输出到控制台。这可以通过一个`嵌套`循环来完成。你有一个循环来遍历二维数组的每个条目。另一个嵌套在这个循环中的循环检查外层循环当前正在处理的行。它遍历该行的每个元素并将其打印到控制台。
- en: It is also possible to express these in terms of the `go-to` statement. So,
    you will have the first label to signify the entry point into the large loop,
    another label to signify the entry point to the small loop, and you will call
    the `go-to` statement at the end of each loop to jump to the beginning of the
    respective loop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也可以用`go-to`语句来表示。因此，你将有一个标签来表示大循环的入口点，另一个标签来表示小循环的入口点，你将在每个循环的末尾调用`go-to`语句以跳转到相应循环的开始。
- en: 'Let''s see how to do that. First, let''s define a 2D array as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点。首先，让我们定义一个二维数组如下：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can loop over it as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样遍历它：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can already see an increase in complexity here. For example, you can perform
    a `go-to` from the end of the inner loop to the beginning of the outer loop. This
    way, only the first item of each column receives output. The program becomes an
    infinite loop:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到复杂性在这里有所增加。例如，你可以从内循环的末尾跳转到外循环的开始。这样，只有每一列的第一个条目会收到输出。程序变成了一个无限循环：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't Repeat Yourself (DRY)
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要重复自己 (DRY)
- en: One of the fundamental rules of engineering is to create abstractions for logic
    that repeats. The pattern of the loop is ubiquitous. You can experience it in
    almost any program. Hence, it is reasonable to abstract away. This is why contemporary
    languages, such as Java or C++, have their own built-in mechanisms for loops.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 工程学的基本规则之一是为重复的逻辑创建抽象。循环的模式无处不在。你几乎可以在任何程序中体验到它。因此，进行抽象是合理的。这就是为什么当代语言，如Java或C++，都有自己的内置循环机制。
- en: 'The difference it makes is that, now, the entire pattern consists of one component
    only, that is, the keyword that must be used with a certain syntax:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它带来的不同之处在于，现在整个模式只由一个组件组成，即必须与特定语法一起使用的关键字：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What happened here is that we gave a name to the pattern. Every time we need
    this pattern, we do not implement it from scratch. We call the pattern by its
    name.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是我们给这个模式起了一个名字。每次我们需要这个模式时，我们不需要从头开始实现它。我们通过它的名字来调用这个模式。
- en: 'This calling by name is the main principle of declarative programming: implement
    patterns that repeat only once, give names to those patterns, and then refer to
    them by their name anywhere we need them.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通过名字调用是声明式编程的主要原则：实现只重复一次的模式，给这些模式命名，然后在我们需要的地方通过名字来引用它们。
- en: For example, `while` or `for` loops are patterns of loops. They are abstracted
    away and implemented on a language level. The programmer can refer to them by
    their names whenever they need a loop. Now, the chance of making an error is much
    less likely because the compiler is aware of the pattern. It will perform a compile-time
    check on whether you are using the pattern properly. For example, when you use
    the `while` statement, the compiler will check whether you have provided a proper
    condition. It will perform all the jump logic for you.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`while` 或 `for` 循环是循环的模式。它们被抽象出来，并在语言级别上实现。程序员可以在需要循环时通过它们的名称来引用它们。现在，犯错的几率大大降低，因为编译器知道这个模式。它将在编译时检查你是否正确地使用了这个模式。例如，当你使用
    `while` 语句时，编译器将检查你是否提供了一个合适的条件。它将为你执行所有的跳转逻辑。
- en: So, you do not need to worry whether you jumped to the correct label, or that
    you forgot to jump at all. Therefore, there is no chance of you jumping from the
    end of the inner loop to the start of the outer loop.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你无需担心是否跳到了正确的标签，或者是否完全忘记了跳转。因此，你不可能从内循环的末尾跳转到外循环的开始。
- en: What you have seen here is the transition from an imperative to a declarative
    style. The concept you need to understand here is that we made the programming
    language aware of a certain pattern. The compiler was forced to verify the correctness
    of the pattern at compile time. We specified the pattern once. We gave it a name.
    We made the programming language enforce certain constraints on the programmer
    that uses this name. At the same time, the programming language takes care of
    the implementation of the pattern, meaning that the programmer does not need to
    be concerned with all the algorithms that were used to implement the pattern.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是从命令式到声明式的转变。你需要理解的概念是，我们使编程语言意识到某个模式。编译器被迫在编译时验证模式的正确性。我们指定了一次模式。我们给它一个名字。我们使编程语言对使用这个名称的程序员施加某些约束。同时，编程语言负责模式的实现，这意味着程序员不需要关心实现模式所使用的所有算法。
- en: So, in declarative programming, we specify what needs to be done without specifying
    how to do it. We notice patterns and give them names. We implement these patterns
    once and call them by name afterward whenever we need to use them. In fact, modern
    languages, such as Java, Scala, Python, or Haskell do not have the support of
    the `go-to` statement. It seems that the vast majority of the programs expressed
    with the `go-to` statement can be translated into a set of patterns, such as loops,
    that abstract away `go-to` statements. Programmers are encouraged to use these
    higher-level patterns by name, rather than implementing the logic by themselves
    using lower-level `go-to` primitives. Next, let's see how this idea develops further
    using the example of declarative collections and how they differ from imperative
    ones.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在声明式编程中，我们指定需要做什么，而不指定如何做。我们注意到模式并给它们命名。我们实现这些模式一次，并在需要使用它们时通过名称调用它们。实际上，现代语言，如
    Java、Scala、Python 或 Haskell，都没有 `go-to` 语句的支持。看起来，用 `go-to` 语句表达的大多数程序都可以转换成一系列模式，如循环，这些模式抽象掉了
    `go-to` 语句。程序员被鼓励通过名称使用这些高级模式，而不是自己使用低级的 `go-to` 原语来实现逻辑。接下来，让我们通过声明式集合的例子来看这个想法是如何进一步发展的，以及它们与命令式集合有何不同。
- en: Declarative versus imperative collections
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式与命令式集合
- en: Another great illustration of how the declarative style works can be seen in
    collection frameworks. Let's compare the collection frameworks of an imperative
    and functional programming language, for example, Java (imperative) collections
    and Scala (functional) collections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式风格如何工作的另一个很好的例子可以在集合框架中看到。让我们比较命令式编程语言和函数式编程语言的集合框架，例如，Java（命令式）集合和 Scala（函数式）集合。
- en: Why a collection framework? Collections are ubiquitous in any programming project.
    When you are dealing with a database-powered application, you are using collections.
    When you are writing a web crawler, you are using collections. In fact, when you
    are dealing with simple strings of text, you are using collections. Most modern
    programming languages provide you with the implementation of collection frameworks
    as part of their core library. That is because you will need them for almost any
    project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要一个集合框架？在任何编程项目中，集合无处不在。当你处理一个由数据库支持的应用程序时，你正在使用集合。当你编写一个网络爬虫时，你正在使用集合。实际上，当你处理简单的文本字符串时，你也在使用集合。大多数现代编程语言都将集合框架的实现作为其核心库的一部分提供给你。这是因为你几乎需要它们来完成任何项目。
- en: We'll go into more depth about how imperative collections are different from
    declarative collections in the next chapter. However, for the purpose of an overview,
    let's briefly discuss one of the major differences between the imperative and
    declarative approaches to collections here. We can see such a difference using
    the example of filtering. Filtering is an ubiquitous operation that you most likely
    will find yourself doing pretty often, so let's see how it differs across the
    two approaches.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更深入地探讨命令式集合与声明式集合的不同之处。然而，为了概述的目的，让我们简要地讨论命令式和声明式集合方法之间的一项主要差异。我们可以通过过滤的例子看到这种差异。过滤是一个无处不在的操作，你很可能经常会这样做，所以让我们看看这两种方法之间的差异。
- en: Filtering
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: Java is a classic example of a very imperative approach to programming. And
    hence, in its collections, you will encounter operations that are typical of imperative
    programming. For example, consider that you have an array of strings. They are
    the names of the employees of your company. You want to create a separate collection
    with only those employees whose names start with the letter `'A'`. How do you
    do that in Java?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一个非常命令式编程方法的经典例子。因此，在其集合中，你会遇到典型的命令式编程操作。例如，假设你有一个字符串数组。它们是你公司员工的姓名。你想要创建一个单独的集合，只包含那些以字母
    `'A'` 开头的员工姓名。在 Java 中你该如何做？
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, you need to create a separate collection to store the result of your
    computation. So, we create a new `ArrayList` of strings. Afterward, you will need
    to check every employee's name to establish whether it starts with the letter
    `'A'`. If it does, add this name to the newly created array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个单独的集合来存储你的计算结果。因此，我们创建一个新的字符串 `ArrayList`。之后，你需要检查每个员工的姓名，以确定它是否以字母
    `'A'` 开头。如果是，将这个姓名添加到新创建的数组中。
- en: What could possibly go wrong? The first issue is the very collection where you
    want to store your results. You need to call `result.add()` on the collection
    – but what if you have several collections, and you add to the wrong one? You
    have the freedom to add to any collection at that line of code, so it is conceivable
    that you add to the wrong one – not the dedicated one you have created solely
    for the purpose of filtering the employees.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出什么问题？第一个问题是你要存储结果的集合。你需要调用 `result.add()` 来添加到集合中——但如果你有几个集合，你可能会添加到错误的集合中？在那个代码行，你可以自由地添加到任何集合，所以可以想象你会添加到错误的集合——而不是你专门为过滤员工而创建的集合。
- en: Another thing that can go wrong here is that you can forget to write the `if`
    statement in the large loop. Of course, it is not very likely in such a trivial
    example, but remember that large projects can bloat and code bases can become
    large. In our example, the body of the loop has fewer than 10 lines. But what
    if you have a code base where the `for` loop is up to 50 lines, for example? It
    is not as obvious there that you won't forget to write your predicate, or to add
    the string to any collection at all.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能出现的另一个问题是，你可能会忘记在大型循环中编写 `if` 语句。当然，在这样一个简单的例子中，这种情况不太可能发生，但请记住，大型项目可能会膨胀，代码库可能会变得很大。在我们的例子中，循环体少于
    10 行。但如果你有一个代码库，其中的 `for` 循环长达 50 行，例如？在那里，你不会忘记编写你的谓词，或者将字符串添加到任何集合中，这一点并不明显。
- en: The point here is that we have the same situation as in the `loop` versus `go-to`
    example. We have a pattern of an operation over a collection that might repeat
    itself in the code base. The pattern is something that is composed of more than
    one element, and it goes as follows. Firstly, we create a new collection to store
    the result of our computation. Secondly, we have the loop that iterates on every
    element of our collection. And finally, we have a predicate. If it is true, we
    save the current element into the result collection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是我们有与`loop`与`go-to`示例中相同的情况。我们在代码库中有一个在集合上执行的操作模式，这个模式可能会重复。模式是由多个元素组成的，其过程如下。首先，我们创建一个新的集合来存储我们计算的结果。其次，我们有一个循环，它遍历我们集合中的每个元素。最后，我们有一个谓词。如果它是真的，我们将当前元素保存到结果集合中。
- en: We can imagine the same logic executed in other contexts as well. For example,
    we can have a collection of numbers and want to take only those that are greater
    than `10`. Or, we can have a list of all our website users and want to take the
    age of those users visiting the site over a particular year.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象同样的逻辑也可以在其他上下文中执行。例如，我们可以有一个数字集合，并希望只取那些大于`10`的数字。或者，我们可以有一个包含我们网站所有用户的列表，并希望取那些在特定年份访问网站的用户的年龄。
- en: 'The particular pattern we were discussing is called the filter pattern. In
    Scala, every collection supports a method defined on it that abstracts away the
    filter pattern. This is done as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的特定模式被称为过滤模式。在Scala中，每个集合都支持一个定义在其上的方法，该方法抽象了过滤模式。这是通过以下方式实现的：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that the operation remains the same. We need to create a new collection,
    then incorporate the elements from the old collection into the new collection
    based on some predicate. Yet, in the case of the pure Java solution, we need to
    perform three separate actions to get the desired result. However, in the case
    of the Scala declarative style, we only need to specify a single action: the name
    of the pattern. The pattern is implemented in the language internals, and we do
    not need to worry about how it is done. We have a precise specification of how
    it works and of what it does, and we can rely on it.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，操作保持不变。我们需要创建一个新的集合，然后根据某些谓词将旧集合中的元素合并到新集合中。然而，在纯Java解决方案的情况下，我们需要执行三个单独的操作来得到期望的结果。然而，在Scala声明式风格的情况下，我们只需要指定一个动作：模式的名称。模式是在语言内部实现的，我们不需要担心它是如何实现的。我们有一个精确的关于它是如何工作以及它做了什么的说明，并且我们可以依赖它。
- en: The advantage here is not only that the code becomes easier to read, and thus
    easier to reason about. It also increases reliability and runtime performance.
    The reason is that the filter pattern here is a member of the core Scala library.
    This means that it is well tested. It was used in a large number of other projects
    before. The subtle bugs that could have existed in such a situation were likely
    caught and fixed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势不仅在于代码变得更易于阅读，因此也更容易推理。它还增加了可靠性和运行时性能。原因是这里的过滤模式是Scala核心库的一个成员。这意味着它经过了良好的测试。它已经在许多其他项目中使用过。在这种情况下可能存在的微妙错误很可能已经被捕捉并修复。
- en: Also observe that the notion of anonymous lambdas gets introduced here. We pass
    one as an argument to the `filter` method. They are functions that are defined
    inline, without the usual tedious method syntax. Anonymous lambdas are a common
    feature of functional languages, as they increase your flexibility for abstracting
    logic.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，匿名lambda的概念在这里被引入了。我们将一个lambda作为参数传递给`filter`方法。它们是内联定义的函数，没有通常繁琐的方法语法。匿名lambda是函数式语言的一个常见特性，因为它们增加了你抽象逻辑的灵活性。
- en: Declarative programming in other languages
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他语言中的声明式编程
- en: In other modern languages, such as Haskell or Python, a similar declarative
    functionality is also present out of the box. For example, you can perform filtering
    in Python—it is built into the language, and you have a special function in Haskell
    to perform the same filtering. Also, the functional nature of Python and Haskell
    makes it easy to implement the same control structure as filtering by yourself.
    Both Haskell and Python support the notion of the lambda function and higher-order
    functions, so they can be used to implement declarative control structures.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他现代语言中，如Haskell或Python，类似的声明式功能也是现成的。例如，你可以在Python中执行过滤操作——它是语言的一部分，并且在Haskell中有一个特殊的功能来执行相同的过滤操作。此外，Python和Haskell的函数式特性使得自己实现相同的控制结构（如过滤）变得容易。Haskell和Python都支持lambda函数和高阶函数的概念，因此它们可以用来实现声明式控制结构。
- en: In general, you can spot whether a language is declarative programming-friendly
    by looking at the capabilities it provides. Some of the features you can look
    for are anonymous functions, functions as first-class citizens, and custom operator
    specifications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过查看语言提供的功能来识别一个语言是否适合声明式编程。你可以寻找的一些特性包括匿名函数、函数作为一等公民和自定义操作符指定。
- en: Anonymous lambda gives you a great advantage because you can pass functions
    to other functions inline, without first defining them. This is particularly useful
    when specifying control structures. A function expressed in this way is, first
    and foremost, to specify a transformation that is supposed to transform an input
    into an output.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名lambda函数给你带来了很大的优势，因为你可以直接将函数传递给其他函数，而不必先定义它们。这在指定控制结构时尤其有用。以这种方式表达的功能，首先和最重要的是，用于指定一个将输入转换为输出的转换。
- en: Another feature that you can look for in programming languages is support for
    functions as first-class citizens. This means that you are able to assign a function
    to a variable, refer to the function by that variable's name, and pass that variable
    to other functions. Treating functions as if they are ordinary variables allows
    you to achieve a new level of abstraction. This is because functions are transformations;
    they map their input values to some output values. And, if the language does not
    allow you to pass transformations to other transformations, this is a limitation
    of flexibility.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在编程语言中寻找的另一个特性是支持函数作为一等公民。这意味着你能够将一个函数赋值给一个变量，通过该变量的名称引用函数，并将该变量传递给其他函数。将函数视为普通变量可以使你达到一个新的抽象层次。这是因为函数是转换；它们将输入值映射到某些输出值。而且，如果语言不允许你将转换传递给其他转换，这将是灵活性的限制。
- en: Another feature that you can expect from declarative languages is that they
    allow you to create custom operators; for example, the synthetic sugar available
    in Scala allows you to define new operators very easily, as methods in classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从声明式语言中期待的一个特性是，它们允许你创建自定义操作符；例如，Scala中可用的合成糖允许你非常容易地定义新的操作符，就像类中的方法一样。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The declarative style is a style of programming where you call the operations
    you want to perform by name, instead of describing how to execute them in an algorithmic
    fashion via lower-level primitives provided by the programming language. This
    naturally aligns with the DRY principle. If you have a repeating operation, you
    want to abstract it away, and then refer to it by name later on. In other words,
    you need to declare that the operation has a certain name. And, whenever you want
    to use it, you need to declare your intent, without specifying directly how it
    should be fulfilled.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式风格是一种编程风格，其中你通过名称调用你想要执行的操作，而不是通过编程语言提供的底层原语以算法方式描述如何执行它们。这自然符合DRY原则。如果你有一个重复的操作，你想要将其抽象化，然后在以后通过名称引用它。换句话说，你需要声明该操作有一个特定的名称。而且，每次你想使用它时，你都需要声明你的意图，而不直接指定它应该如何实现。
- en: Modern functional programming goes hand in hand with the declarative style.
    Functional programming provides you with a better level of abstraction, which
    can be used to abstract away the repeating operations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现代函数式编程与声明式风格相辅相成。函数式编程为你提供了一个更好的抽象层次，可以用来抽象化重复的操作。
- en: In the next chapter, we will see how first-class citizen support for functions
    can be useful for the declarative programming style.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到函数作为一等公民的支持如何对声明式编程风格有益。
- en: Questions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the principle behind declarative programming?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明式编程背后的原则是什么？
- en: What does DRY stand for?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRY代表什么？
- en: Why is using `go-to` bad style?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用`goto`是坏风格？
