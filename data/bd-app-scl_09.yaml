- en: Chapter 9. Design Your REST API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 设计你的REST API
- en: In the previous chapter, we added a new chat feature in our app using Akka.
    Our web application is close to the end. This chapter will add the REST API in
    our Play framework application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Akka在我们的应用程序中添加了一个新的聊天功能。我们的Web应用程序接近完成。本章将在我们的Play框架应用程序中添加REST API。
- en: We will also create a Scala client using the `ws` library from the Play framework
    in order to call our REST API. Later in this chapter, we will add Swagger support
    and embed the Swagger UI in our app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用Play框架中的`ws`库创建一个Scala客户端来调用我们的REST API。在本章的后面，我们将添加Swagger支持并将Swagger
    UI嵌入到我们的应用程序中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: REST and API design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST和API设计
- en: Creating our API with REST and JSON
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST和JSON创建我们的API
- en: Creating a Scala client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Scala客户端
- en: Adding validations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加验证
- en: Adding back pressure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加回压
- en: Adding Swagger support
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Swagger支持
- en: Introduction to REST
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST简介
- en: '**Representational State Transfer** (**REST**) is an architectural style. It
    was defined by Roy Fielding in his doctoral dissertation. REST happens over the
    HTTP 1.1 protocol using HTTP verbs, such as `GET`, `POST`, `DELETE`, `PUT`, and
    **Uniform Resource Identifier** (**URI**), for instance, `/users/profile/1` or
    `sales/cart/add/2`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）是一种架构风格。它由Roy Fielding在他的博士论文中定义。REST通过HTTP 1.1协议使用HTTP动词进行，例如`GET`、`POST`、`DELETE`、`PUT`和**统一资源标识符**（**URI**），例如`/users/profile/1`或`sales/cart/add/2`。'
- en: 'The REST architecture has the following properties:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构有以下属性：
- en: '**Simplicity**: Pretty much all languages have libraries to manipulate HTTP
    URIs.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：几乎所有的语言都有库来操作HTTP URI。'
- en: '**Interoperability**: REST is language, platform, and OS agnostic.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：REST是语言、平台和操作系统无关的。'
- en: '**Scalable and Reliable**: As REST is based on HTTP, you can use the HTTP server
    to scale up your application in conjunction with HTTP load balancer, the HTTP
    caches, and HTTP DNS.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展和可靠**：因为REST基于HTTP，你可以使用HTTP服务器与HTTP负载均衡器、HTTP缓存和HTTP DNS一起扩展你的应用程序。'
- en: '**Separation of Concerns** (**SOC**): As you have a URI, that''s your contract,
    not the code, underlying backend, or database. This means that you can change
    the database or language without affecting the code.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**（**SOC**）：因为你有一个URI，这是你的合同，而不是代码、底层后端或数据库。这意味着你可以更改数据库或语言，而不会影响代码。'
- en: '**Client**/**Server**: There is a server that provides the REST interface and
    the clients, which call the REST endpoints.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**/**服务器**：有一个提供REST接口的服务器，以及调用REST端点的客户端。'
- en: Web services that embrace the REST principles are often called RESTful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 采纳REST原则的Web服务通常被称为RESTful。
- en: REST API design
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API设计
- en: When you are working with REST, there are some principles that you should keep
    in mind, and these principles should provide guidance for your design choices
    when you are doing API design.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用REST时，有一些原则你应该记住，并且这些原则应该为你在进行API设计时的设计选择提供指导。
- en: HTTP verbs design
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP动词设计
- en: 'These are the following verbs found in HTTP:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是HTTP中找到的以下动词：
- en: '`GET`: This is often used to answer queries'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：这通常用于回答查询'
- en: '`PUT`: This is often used to insert data'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这通常用于插入数据'
- en: '`POST`: This is often used to update data'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：这通常用于更新数据'
- en: '`DELETE`: This is often used to remove data'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：这通常用于删除数据'
- en: Why do we keep saying often? Well, there are some exceptions in regards of size
    limitations. For instance, for the `GET` verb, we can't have a request bigger
    than 8192 bytes or 8 KB. If you need to send a bigger payload, we will need to
    use the `POST` verb.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们总是说“通常”？好吧，在大小限制方面有一些例外。例如，对于`GET`动词，我们无法有一个大于8192字节或8 KB的请求。如果你需要发送更大的有效负载，我们需要使用`POST`动词。
- en: Uniform API
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统一API
- en: 'REST uses a uniform API. For example, consider the following piece of code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: REST使用统一的API。例如，考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we change the resource from users to sales, the API would almost be the same.
    Retrieving data is done using `GET` and update is done via `POST`, so it's a uniform
    API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将资源从用户更改为销售，API几乎相同。数据检索使用`GET`进行，更新通过`POST`完成，因此这是一个统一的API。
- en: Response with HTTP status codes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有HTTP状态码的响应
- en: 'REST runs the error handler using the HTTP 1.1 status codes. For instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST使用HTTP 1.1状态码运行错误处理器。例如：
- en: '**200 -> OK**: This is often used with the `GET` verb'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200 -> OK**：这通常与`GET`动词一起使用'
- en: '**201 -> Created**: This is often used by the `PUT/POST` verbs'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**201 -> 已创建**：这通常由`PUT/POST`动词使用'
- en: '**204 -> No Content**: This is often for the `DELETE` verb'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**204 -> 无内容**：这通常用于`DELETE`动词'
- en: '**400 -> Invalid Request**: This often means an invalid request for the `POST/PUT`
    verbs'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**400 -> 无效请求**：这通常意味着对 `POST/PUT` 动词的无效请求'
- en: '**404 -> Not Found**: This is often used with the `GET` verb'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404 -> 未找到**：这通常与 `GET` 动词一起使用'
- en: '**500 -> Internal Server Error -** **Unexpected Server Error**: This is often
    used by all the verbs'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500 -> 内部服务器错误 -** **意外服务器错误**：这通常由所有动词使用'
- en: REST API patterns
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API 模式
- en: 'There are some commons patterns for good and clear REST API designs, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于良好的和清晰的 REST API 设计，有一些常见的模式，如下所示：
- en: '**Use nouns; do not use verbs**: Often, you can use standard URIs, such as
    `/cars/` or `/members/`. You should not use `/getCars/` or `getMembers/` because
    you are using the URI with a verb, and the verb already tells the actions.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用名词；不要使用动词**：通常，你可以使用标准的 URI，例如 `/cars/` 或 `/members/`。你不应该使用 `/getCars/`
    或 `getMembers/`，因为你在使用带有动词的 URI，而动词已经说明了动作。'
- en: '**GET method should not change state**: If you want to change the state of
    the server, you will need to use verbs such as `PUT`, `POST`, or `DELETE`. `GET`
    should not change the state of the server, so it should always be safe calling
    `GET` as many times as you want. This is called idempotent.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET 方法不应改变状态**：如果你想改变服务器的状态，你需要使用动词，如 `PUT`、`POST` 或 `DELETE`。`GET` 不应改变服务器的状态，因此可以安全地多次调用
    `GET`。这被称为幂等。'
- en: '**Prefer sub-resource relation**: Let''s say we have a resource called `/users/`,
    and a user has projects. It''s always a good idea to use sub-resources, such as
    `/users/1/projects/2`, because we have a relationship between users and projects.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先使用子资源关系**：假设我们有一个名为 `/users/` 的资源，一个用户有项目。始终使用子资源，如 `/users/1/projects/2`
    是一个好主意，因为我们有用户和项目之间的关系。'
- en: '**Use HTTP headers**: HTTP headers should be used for serialization, security,
    and all the kinds of metadata your application needs. The HTTP Headers are often
    used for content negotiation. For instance, you might do the following:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 HTTP 头部**：HTTP 头部应该用于序列化、安全性和应用程序需要的所有类型的元数据。HTTP 头部通常用于内容协商。例如，你可能做以下操作：'
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The URI is the same; however, based on the header type, it will return data
    in XML or JSON format.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI 是相同的；然而，根据头部类型，它将以 XML 或 JSON 格式返回数据。
- en: '**Filter, Sorting and Pagination**: Sometimes, your data may be big. It''s
    always a good idea to provide mechanisms to sort, filter, and paginate as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤、排序和分页**：有时，你的数据可能很大。提供排序、过滤和分页的机制总是一个好主意，如下所示：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: API versioning
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 版本化
- en: There are two ways to perform API versioning. First strategy is to version by
    the endpoint explicit such as `/v1/cars`. The second strategy is based on metadata
    such as `/cars/`, but then you will pass an HTTP HEADER version as v1.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种执行 API 版本化的方式。第一种策略是通过对端点进行显式版本化，例如 `/v1/cars`。第二种策略基于元数据，例如 `/cars/`，但此时你需要传递一个
    HTTP 头部版本作为 v1。
- en: Both strategies have pros and cons. Explicit versioning is more clear, and you
    can always create a new version and don't break your consumers. Header strategy
    is more elegant; however, it can get tricky to manage.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种策略都有优点和缺点。显式版本化更清晰，你总是可以创建一个新版本而不会破坏你的消费者。头部策略更优雅；然而，它可能会变得难以管理。
- en: Some anti-patterns to be avoided
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要避免的一些反模式
- en: 'There are several traps in the REST API design, but the following things need
    to be avoided:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST API 设计中存在一些陷阱，但以下事项需要避免：
- en: '`GET` verb for everything'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 动词用于所有事物'
- en: Ignoring HTTP headers such as MIME-types
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略 HTTP 头部，如 MIME 类型
- en: Returning 200 when an error happens
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生错误时返回 200
- en: Returning 500 for an invalid parameter or a missing parameter
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于无效参数或缺失参数返回 500
- en: Creating our API with REST and JSON
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REST 和 JSON 创建我们的 API
- en: Alright, now is the time to design a REST API for your Play framework application.
    We will create an API to export all data in the system. This API will be READ
    only; however, you can add write operations if you like.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候为你的 Play 框架应用程序设计一个 REST API 了。我们将创建一个 API 来导出系统中的所有数据。这个 API 将是只读的；然而，如果你愿意，可以添加写操作。
- en: Later on in this chapter, we will add some back pressure to limit the API REST
    rate for consumers and create a Scala client application for our REST API. So,
    first of all, let's get started with the Play framework (server) first.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将添加一些背压来限制消费者的 API REST 速率，并为我们的 REST API 创建一个 Scala 客户端应用程序。所以，首先，让我们从
    Play 框架（服务器）开始。
- en: We don't need any extra library in order to create a REST API in our Play framework
    application. We will just need a new controller and new routes. Additionally,
    we will leverage most of the code we made in the previous chapters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Play 框架应用程序中创建 REST API，我们不需要任何额外的库。我们只需要一个新的控制器和新的路由。此外，我们将利用前几章中编写的代码。
- en: RestApiContoller
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RestApiContoller
- en: Let's create a new controller located at `ReactiveWebStore/app/controllers`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `ReactiveWebStore/app/controllers` 中创建一个新的控制器。
- en: REST API Front Controller implementation
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REST API 前端控制器实现
- en: '`RestApiController.scala` file should look something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestApiController.scala` 文件应类似于以下内容：'
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Basically, we have three functions here. These functions list all products,
    images, and reviews. As you can see at the top of the controller, we are injecting
    the three services that we have for products, images, and reviews.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这里有三个函数。这些函数列出所有产品、图片和评论。如您在控制器顶部所见，我们正在注入用于产品、图片和评论的三个服务。
- en: The code is pretty much straightforward for all functions. First, we will call
    the proper service, and then we will wait for the result with the `await` object.
    Once we have the data, we will call a function to convert the data to JSON.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数的代码相当直接。首先，我们将调用适当的服务，然后使用 `await` 对象等待结果。一旦我们有了数据，我们将调用一个函数将数据转换为 JSON。
- en: Let's take a look at the JSON helpers objects that we used here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里使用的 JSON 辅助对象。
- en: JSON mapping
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 映射
- en: Our REST controller used JSON helper objects to map objects to JSON. First,
    we will start with the Products JSON helper.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 REST 控制器使用了 JSON 辅助对象将对象映射到 JSON。首先，我们将从 Products JSON 辅助对象开始。
- en: '`ProductsJson` is located at `ReactiveWebStore/app/controllers/Product.scala`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductsJson` 位于 `ReactiveWebStore/app/controllers/Product.scala`：'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Basically, there are three important concepts here. First, we have `productsWrites`
    , which maps from JSON to `model`, and `Product` for writes, which is also known
    as deserialization. We have another mapping for serialization called `productsReads`,
    which converts objects to JSON.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这里有三个重要的概念。首先，我们有 `productsWrites`，它将 JSON 映射到 `model`，以及用于写入的 `Product`，这同样也被称为反序列化。我们还有一个用于序列化的映射，称为
    `productsReads`，它将对象转换为 JSON。
- en: As you can see, we need to map all fields existing in our model, such as ID,
    name, details, and price. This mapping must match proper types as well. ID mapping
    uses `readNullable` because ID is optional.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要映射模型中存在的所有字段，例如 ID、名称、详情和价格。这种映射必须匹配适当的类型。ID 映射使用 `readNullable`，因为
    ID 是可选的。
- en: Finally, we have a function to convert from JSON to object, called `toJson`,
    which uses a generic Play framework library called JSON. Let's move for the next
    helper--the review.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个将 JSON 转换为对象的函数，称为 `toJson`，它使用一个名为 JSON 的通用 Play 框架库。让我们转到下一个辅助对象——评论。
- en: '`ReviewsJson` is located at `ReactiveWebStore/app/controllers/Review.scala` and
    should look something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReviewsJson` 位于 `ReactiveWebStore/app/controllers/Review.scala`，其结构应类似于以下内容：'
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have the same concepts that we saw earlier in the Products JSON helper.
    We have a mapping for reads and writes and a function which converts a `model.Review`
    to JSON. Let's move to the last helper, the `ImageJson`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了之前在 Products JSON 辅助对象中看到的相同概念。我们有一个用于读取和写入的映射，以及一个将 `model.Review`
    转换为 JSON 的函数。让我们转到最后的辅助对象，即 `ImageJson`。
- en: '`ImagesJson` is located at `ReactiveWebStore/app/controllers/Image.scala`,
    which should look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImagesJson` 位于 `ReactiveWebStore/app/controllers/Image.scala`，其结构应类似于以下内容：'
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just as with the other two mappers, we have reads, writes, mappings, and the
    `toJson` function. We are done with mappers, so now the next step is to create
    the new routes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他两个映射器一样，我们有读取、写入、映射和 `toJson` 函数。我们已经完成了映射器，所以下一步是创建新的路由。
- en: Configuring new routes
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置新路由
- en: 'We need to add the following three new routes for our REST API, which is located
    at `ReactiveWebStore/conf/routes`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的 REST API 添加以下三个新路由，该 API 位于 `ReactiveWebStore/conf/routes`：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we mapped all the list operations we just created.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已将刚刚创建的所有列表操作进行了映射。
- en: Testing the API using the browser
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浏览器测试 API
- en: Now we can run `$ activator run` and test our new REST API using our web browser.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `$ activator run` 并使用我们的网络浏览器测试新的 REST API。
- en: 'Go to `http://localhost:9000/REST/api/product/all`; you should see something
    similar to the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:9000/REST/api/product/all`；您应该会看到以下截图类似的内容：
- en: '![Testing the API using the browser](img/image00320.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用浏览器测试 API](img/image00320.jpeg)'
- en: Let's look at the review API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看评论 API。
- en: 'Go to `http://localhost:9000/REST/api/review/all`; you should see results similar
    to the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `http://localhost:9000/REST/api/review/all`；您应该看到类似于以下截图的结果：
- en: '![Testing the API using the browser](img/image00321.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用浏览器测试API](img/image00321.jpeg)'
- en: Finally, let's check out the image of REST API.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们查看REST API的图片。
- en: 'Go to `http://localhost:9000/REST/api/image/all`; you should see results similar
    to the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `http://localhost:9000/REST/api/image/all`；您应该看到类似于以下截图的结果：
- en: '![Testing the API using the browser](img/image00322.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![使用浏览器测试API](img/image00322.jpeg)'
- en: OK. Now we will continue to work with REST. We just finished the server; however,
    it is important to create a REST client to consume these REST APIs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们将继续使用REST。我们刚刚完成了服务器；然而，创建一个REST客户端来消费这些REST API是很重要的。
- en: Creating a Scala client
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Scala客户端
- en: 'First, you will need to create a new project. Go to your file system and create
    a folder called `rest-client`. Then, create another folder inside `rest-client`
    called `project`. Inside `project`, you will need to add the following two files:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要创建一个新的项目。进入您的文件系统，创建一个名为 `rest-client` 的文件夹。然后，在 `rest-client` 内创建另一个名为
    `project` 的文件夹。在 `project` 内，您需要添加以下两个文件：
- en: '`build.properties`: This contains an SBT configuration, such as version'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.properties`：此文件包含SBT配置，例如版本'
- en: '`Plugins.sbt`: This contains an SBT plugins configuration'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Plugins.sbt`：此文件包含SBT插件配置'
- en: 'Let''s start with `build.properties`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `build.properties` 开始：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see here, we are configuring this project to use SBT version 0.13.11\.
    Now, we can move to the plugins file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在配置此项目以使用SBT版本0.13.11。现在，我们可以转到插件文件。
- en: Configuring plugins.sbt
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置plugins.sbt
- en: 'Your `plugins.sbt` file should look something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `plugins.sbt` 文件应该看起来像这样：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are adding Eclipse and IntelliJ support. For this book, we are using
    Eclipse, but feel free to use anything you like.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了Eclipse和IntelliJ的支持。对于这本书，我们使用Eclipse，但请随意使用您喜欢的任何东西。
- en: Outside of the `project` folder, under `rest-client`, we will need to configure
    the `build.sbt` file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `project` 文件夹外部，在 `rest-client` 下，我们需要配置 `build.sbt` 文件。
- en: Configuring build.sbt
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置build.sbt
- en: 'Your `build.sbt` file should look something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `build.sbt` 文件应该看起来像这样：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So here, we are using Scala version 2.11.7, and we are declaring just two dependencies.
    One dependency is for tests, which is `scala-test`, and the other dependency is
    on the Play framework `ws` library, which we will use to call our REST APIs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里使用Scala版本2.11.7，并且我们只声明了两个依赖项。一个依赖项是用于测试的 `scala-test`，另一个依赖项是Play框架的
    `ws` 库，我们将使用它来调用我们的REST API。
- en: 'Let''s also create two source folders, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也创建两个源文件夹，如下所示：
- en: '`src/main/scala`: This is the Scala source code'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/scala`：这是Scala源代码'
- en: '`src/test/scala`: This is the Scala test source code'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/test/scala`：这是Scala测试源代码'
- en: OK. Now we can run `$ sbt clean compile eclipse` in order to download the dependencies
    from the web and create all the Eclipse project files that we need.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们可以运行 `$ sbt clean compile eclipse` 以从网络下载依赖项并创建我们需要的所有Eclipse项目文件。
- en: '![Configuring build.sbt](img/image00323.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![配置build.sbt](img/image00323.jpeg)'
- en: Now we can import this code in Eclipse and move on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将此代码导入Eclipse并继续下一步。
- en: Scala client code
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala客户端代码
- en: 'First of all, we will need to create a `Factory` to instantiate the `WS` Play
    framework library to call `webservices`. Under the `rest-client/src/main/scala`
    location, let''s create a package called `client` and add the following code under
    `WSFactory.scala`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个 `Factory` 来实例化 `WS` Play框架库以调用 `webservices`。在 `rest-client/src/main/scala`
    位置下，让我们创建一个名为 `client` 的包，并在 `WSFactory.scala` 下添加以下代码：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is just technical. These are the steps needed to instantiate
    the WSClient outside the Play framework. If this client was a web application
    using the Play framework, it would be way easier as we can just use Google Guice
    and inject what we need.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅是技术性的。这些是在Play框架外部实例化WSClient所需的步骤。如果这个客户端是一个使用Play框架的Web应用程序，那么会容易得多，因为我们可以直接使用Google
    Guice并注入所需的内容。
- en: The main idea you need to keep in mind is that you need to use Akka and ActorSystem
    in order to use this feature. As you can see, all this code is locked inside an
    object in a single function called `ws`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要记住的主要思想是，您需要使用Akka和ActorSystem来使用此功能。如您所见，所有这些代码都锁定在一个名为 `ws` 的单个函数中的对象内。
- en: 'We will need some utility class to work with futures. As we use `ws` library
    to call REST APIs, it returns Future. So, let''s create a new package called `utils`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个用于处理Future的实用类。因为我们使用`ws`库调用REST API，它返回Future。所以，让我们创建一个新的包叫做`utils`：
- en: 'Your `Awaits.scala` file should look like something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Awaits.scala`文件应该看起来像这样：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code is pretty simple. We used the `Await` object and then used
    a generic `T` in order to convert the result to a generic parameterized type.
    By using this parameter, we will also receive how many seconds we should wait
    before the timeout.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码相当简单。我们使用了`Await`对象，并使用了一个通用的`T`来将结果转换为泛型参数化类型。通过使用这个参数，我们还将接收到在超时前应该等待多少秒。
- en: Creating our REST client proxies
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的REST客户端代理
- en: 'We will now make REST calls; however, we will create a Scala API. So, the developers
    who use our `rest-client` won''t need to deal with REST and just execute the Scala
    code. This is good for many reasons, some of which are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将进行REST调用；然而，我们将创建一个Scala API。因此，使用我们的`rest-client`的开发者不需要处理REST，只需执行Scala代码。这有很多好处，其中一些如下：
- en: '**SOC**: We still have separation of concerns between the Play framework and
    the client application'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOC**：我们仍然在Play框架和客户端应用之间有职责分离'
- en: '**Isolation**: If the REST API changes, we will need to deal with it on the
    proxy layer'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：如果REST API发生变化，我们将在代理层处理它'
- en: '**Abstraction**: The rest of the client code just uses Scala and does not know
    anything about REST or HTTP calls'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：客户端代码的其余部分只使用Scala，并且不知道任何关于REST或HTTP调用的事情'
- en: These techniques are very common nowadays with microservices. These techniques
    can also be known as drivers or thick clients. Right now, we will need to create
    three proxies, one for each resource, that we have on the REST API. Let's create
    a new package called `proxy`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术现在在微服务中非常常见。这些技术也可以被称为驱动程序或厚客户端。现在，我们需要创建三个代理，每个REST API上的资源一个，让我们创建一个新的包叫做`proxy`。
- en: 'Your `ProductProxy.scala` file should look something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`ProductProxy.scala`文件应该看起来像这样：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have three big concepts in this code. First of all, we have a `case` class
    that represents the product. The preceding code is very similar to the code we
    have on the Play framework application. However, if you pay attention, you will
    see it is much cleaner because we don't have any metadata around persistence.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码中，我们有三个主要概念。首先，我们有一个表示产品的`case`类。前面的代码与我们在Play框架应用中的代码非常相似。然而，如果你仔细观察，你会发现它要干净得多，因为我们没有围绕持久性的任何元数据。
- en: You might think, this is duplicated code! It is, and it is 100% okay. Duplicate
    code is decoupled. Remember that we have a REST interface and also a proxy between
    the rest of the client code, so we have at least two layers of indirection that
    we can deal with changes. If these two code bases share the same class, we would
    have coupling and less space to accommodate changes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这是重复的代码！是的，这是完全正确的。重复的代码是解耦的。记住，我们有一个REST接口，还有一个在客户端代码其余部分的代理，因此我们至少有两层间接处理，可以应对变化。如果这两个代码库共享相同的类，我们就会有耦合，并且容纳变化的空间会减少。
- en: The second big concept here is mapping. We will receive JSON, and we will want
    to convert JSON to our case class, so we will have similar mapping that we did
    in the Play framework application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里第二个主要概念是映射。我们将接收JSON，并希望将其转换为我们的`case`类，因此我们将有与在Play框架应用中类似的映射。
- en: Finally, we have the proxy implementation. We will instantiate the Play framework
    `WS` library using our factory and call the `ws` function. Then, we will use the
    `url` function passing the REST API URI for products and define a header in order
    to accept JSON. We are also doing this using the HTTP verb, `GET`. The response
    is mapped with `Json.parse` passing `response.body`. Additionally, we will call
    the validate function to make sure this JSON matches our `case` class. This validation
    is important because then we can be sure that the format did not change, and that
    everything works fine. `WS` will return this as a Future, so we will use our `Awaits`
    helper to get the result.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有代理实现。我们将使用我们的工厂实例化Play框架的`WS`库，并调用`ws`函数。然后，我们将使用`url`函数传递产品的REST API
    URI，并定义一个头以接受JSON。我们也是使用HTTP动词`GET`来做这件事。响应通过`Json.parse`传递`response.body`进行映射。此外，我们将调用验证函数以确保这个JSON与我们的`case`类匹配。这种验证很重要，因为这样我们可以确保格式没有改变，并且一切正常。`WS`将返回这个作为Future，所以我们将使用我们的`Awaits`辅助函数来获取结果。
- en: Let's move to the next proxy, the review.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到下一个代理，即审查。
- en: 'Your `ReviewProxy.scala` file should look something like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ReviewProxy.scala` 文件应该看起来像这样：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have the same principles that we had on the product proxy, but this
    time for review. As you can see, we will call a different URI. Now, let's move
    to the last proxy--the `ImageProxy.scala` file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有与产品代理相同的原理，但这次是为了审查。正如您所看到的，我们将调用不同的 URI。现在，让我们转到最后一个代理--`ImageProxy.scala`
    文件。
- en: 'Your `ImageProxy.scala` file should look something like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ImageProxy.scala` 文件应该看起来像这样：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it. We have the same concepts as product and review. We have finished
    all our proxies. Now, it is time to test our proxy implementation. The best way
    to do this is via tests, so let's create Scala tests for these three implementations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们与产品和审查有相同的概念。我们已经完成了所有代理。现在，是时候测试我们的代理实现了。最好的方式是通过测试，所以让我们为这三个实现创建 Scala
    测试。
- en: Creating ScalaTest tests for the proxies
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为代理创建 ScalaTest 测试
- en: Under the `/src/test/scala` source folder, we will need to create a package
    called `proxy.test`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/src/test/scala` 源文件夹下，我们需要创建一个名为 `proxy.test` 的包。
- en: 'Your `ProductProxtTestSpec.scala` should look something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ProductProxtTestSpec.scala` 应该看起来像这样：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The test is quite simple; we will just have to call the `listAll` operation
    in our product proxy and then add some assertions to make sure the result is not
    null. We will also show all the products in the console.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试相当简单；我们只需在我们的产品代理中调用 `listAll` 操作，然后添加一些断言以确保结果不是 null。我们还会在控制台显示所有产品。
- en: Now, we will need to create tests for the review proxy, which will be similar
    to the product.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为审查代理创建测试，这将与产品类似。
- en: 'Your `ReviewProxyTestSpec.scala` file should look something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ReviewProxyTestSpec.scala` 文件应该看起来像这样：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we used the proxy ideas to test the review. We called the proxy using
    the `listAll` function to get all the reviews. Later, we will check to see if
    the review is not null. We will print all the reviews. Finally, it's time to move
    to the last proxy test--the image proxy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了代理思想来测试审查。我们使用 `listAll` 函数调用代理以获取所有审查。稍后，我们将检查审查是否不为 null。我们将打印所有审查。最后，是时候转到最后一个代理测试--图像代理。
- en: 'Your `ImageProxyTestSpec.scala` should look something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ImageProxyTestSpec.scala` 应该看起来像这样：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Same deal goes for the image proxy. We have all our tests; now, we can run the
    tests. You will need to make sure our `ReactiveWebStore` Play framework app is
    up and running.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像代理也是同样的情况。我们已经有所有测试；现在，我们可以运行测试。您需要确保我们的 `ReactiveWebStore` Play 框架应用正在运行。
- en: 'Let''s run this test with sbt:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 sbt 运行这个测试：
- en: open your console and type in `$ sbt test`
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的控制台，输入 `$ sbt test`
- en: '![Creating ScalaTest tests for the proxies](img/image00324.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![为代理创建 ScalaTest 测试](img/image00324.jpeg)'
- en: Alright, it all works! Our next step will be to add back pressure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一切正常！我们的下一步将是添加反压。
- en: Adding back pressure
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加反压
- en: Back pressure is a well-known concept in the automotive industry. Nowadays,
    this term is used in software engineering as well. Back pressure in the automotive
    world refers to the pressure opposed to the desired flow of gasses in a confined
    place, such as a pipe. For software engineering, it is often related to slowing
    down a producer, which can be an application, a stream processing engine, or even
    the user itself.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 反压是汽车行业中的一个众所周知的概念。如今，这个术语在软件工程中也被使用。在汽车世界中，反压是指在一个封闭空间（如管道）中与期望的气体流动方向相反的压力。对于软件工程，它通常与减缓生产者（可以是应用程序、流处理引擎，甚至是用户本身）有关。
- en: When we are executing REST, it's easy to reach a situation where the client
    can saturate the server. This can be a security breach too, which is also known
    as the **Denial Of Service** (**DOS**) attack.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 REST 时，很容易达到客户端可以饱和服务器的情况。这也可以是一种安全漏洞，也被称为**拒绝服务**（**DOS**）攻击。
- en: There are two architectural scenarios. In the first scenario, your REST API
    is internal, and you just have consumers in your company. In the second scenario,
    you are making the REST API a public API so that it will be open to the whole
    Internet. For this scenario, you really should have back pressure, also known
    as throttling.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种架构场景。在第一种场景中，您的 REST API 是内部的，您公司中只有消费者。在第二种场景中，您将 REST API 作为公共 API，使其对整个互联网开放。对于这种情况，您真的应该有反压，也称为节流。
- en: It's possible to scale our architecture in order to handle more users. We will
    discuss this, and the scalability techniques, in [Chapter 10](part0116.xhtml#aid-3EK181
    "Chapter 10.  Scaling up"), *Scaling Up*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展我们的架构以处理更多用户。我们将在第 10 章[扩展](part0116.xhtml#aid-3EK181 "第 10 章。扩展")中讨论这一点，以及可扩展性技术。
- en: Currently, there are several ways to apply back pressure. For instance, if our
    code is pure RxScala/RxJava, we can apply back pressure on observables. More details
    can be found at [https://github.com/ReactiveX/RxJava/wiki/Backpressure](https://github.com/ReactiveX/RxJava/wiki/Backpressure).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有几种方法可以应用背压。例如，如果我们的代码是纯 RxScala/RxJava，我们可以在可观察对象上应用背压。更多详情可以在[https://github.com/ReactiveX/RxJava/wiki/Backpressure](https://github.com/ReactiveX/RxJava/wiki/Backpressure)找到。
- en: As we are exposing a REST interface, we will add back pressure on the controller,
    so we will need to create a new class with the back pressure code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在公开 REST 接口，我们将在控制器上添加背压，因此我们需要创建一个新的类来包含背压代码。
- en: There are some algorithms for back pressure; we will use the leaky bucket algorithm.
    The algorithm itself is very simple--just 30 lines of Scala code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些算法用于背压；我们将使用漏桶算法。该算法本身非常简单——只有 30 行 Scala 代码。
- en: The leaky bucket algorithm
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漏桶算法
- en: 'The leaky bucket metaphor is pretty simple. Let''s take a look at it in the
    following diagram:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 漏桶的隐喻相当简单。让我们在下面的图中看看它：
- en: '![The leaky bucket algorithm](img/image00325.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![漏桶算法](img/image00325.jpeg)'
- en: The metaphor behind the algorithm is based around a bucket with holes. The water
    flows or drips into the bucket and leaks through the holes of the bucket. If there
    is too much water, and the bucket is full of water, the water will spill out of
    the bucket--in other words, it will be discarded.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法背后的隐喻是基于一个带孔的桶。水流入或滴入桶中，并通过桶的孔泄漏。如果水太多，桶满了，水就会从桶中溢出——换句话说，它将被丢弃。
- en: This algorithm is used in network programing, and also by the telecommunication
    industry. The API manager solutions are also use cases for this algorithm.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法用于网络编程，也被电信行业所采用。API 管理解决方案也是此算法的应用场景。
- en: This concept allows RATE limit constraints. We can express the back pressure
    rate limits in requests per time. Time, in this case, is often measured in seconds
    or minutes, so we have **Requests Per Second** (**RPS**) or **Requests Per Minute**
    (**RPM**).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此概念允许速率限制约束。我们可以用每时间请求的数量来表示背压速率限制。在这种情况下，时间通常以秒或分钟来衡量，因此我们有每秒请求数（**RPS**）或每分钟请求数（**RPM**）。
- en: You can implement this algorithm with a queue. However, in our implementation,
    we will not use a queue; we will use time in order to control the flow. Our implementation
    will also be lock free, or non-blocking, as we won't use threads or external resources.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用队列来实现这个算法。然而，在我们的实现中，我们不会使用队列；我们将使用时间来控制流量。我们的实现也将是无锁的，或非阻塞的，因为我们不会使用线程或外部资源。
- en: Now is the time to code a leaky bucket in Scala. First of all, we will create
    this code for the `ReactiveWebStore` application. We will need to create a new
    package located at `ReactiveWebStore/app`. The new package name will be `backpressure`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候用 Scala 编写漏桶算法了。首先，我们将为 `ReactiveWebStore` 应用程序创建此代码。我们需要在 `ReactiveWebStore/app`
    位置创建一个新的包。新包的名称将是 `backpressure`。
- en: Scala leaky bucket implementation
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Scala 漏桶实现
- en: 'Your `LeakyBucket.scala` file should have the following files:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `LeakyBucket.scala` 文件应该包含以下内容：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see here, we created a Scala class that receives two parameters:
    `rate` and `perDuration`. Rate is an integer, which shows how many requests we
    are able to handle before applying back pressure. `PerDuration` is a Scala `FiniteDuration`,
    which can be any measure of time, such as milliseconds, seconds, minutes, or hours.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个 Scala 类，它接收两个参数：`rate` 和 `perDuration`。速率是一个整数，表示在应用背压之前我们能处理多少个请求。"PerDuration"
    是 Scala 的 `FiniteDuration`，可以是任何时间度量，如毫秒、秒、分钟或小时。
- en: This algorithm keeps track of the time for the last drop in the bucket. As you
    can see, the code is synchronized, but it is fine because we won't call either
    external resources or threads.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法跟踪桶中最后滴水的时刻。如你所见，代码是同步的，但这是可以的，因为我们不会调用外部资源或线程。
- en: First, we will get the current time with new a `Date()`. The first time we run
    the algorithm, we will fail on the `else` statement, and we will get the current
    time as last leak.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `new Date()` 获取当前时间。第一次运行算法时，我们将在 `else` 语句上失败，并将当前时间作为最后泄漏的时间。
- en: The second time it runs, it will enter on the first `If` statement. Then, we
    will calculate the delta (diff) between the last leak and now. This delta will
    be divided by the time in milliseconds that you passed on `perDuration`. If the
    delta is greater than 0, then we leak; otherwise we drop. Then, we will capture
    the time again for the last leak.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次运行时，它将进入第一个 `If` 语句。然后，我们将计算上一次漏桶和现在之间的差值（diff）。这个差值将除以你在 `perDuration` 上传递的毫秒数。如果差值大于
    0，那么我们将泄漏；否则我们丢弃。然后，我们将再次捕获上一次泄漏的时间。
- en: Finally, we will check the drop rate. If the rate is smaller, we will increment
    and return true, which means the request can proceed; otherwise, we will return
    false, and the request should not proceed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将检查掉落率。如果速率较小，我们将增加并返回 true，这意味着请求可以继续进行；否则，我们将返回 false，请求不应继续。
- en: Now that we have this algorithm coded in Scala, we can call for one of our controllers.
    We will add this back pressure on the image REST API.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用 Scala 编码了这个算法，我们可以调用我们的一个控制器。我们将在这个图像 REST API 上添加这个背压。
- en: 'Your `RestApiController.scala` should look something like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `RestApiController.scala` 应该看起来像这样：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we will create a leaky bucket with five requests per minute. We have
    two functions: One to process images that will call the service and convert the
    objects to JSON, and the other to process failures. The `processFailure` method
    will just send a message saying that there are too many requests, and we can''t
    accept requests right now.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将创建一个每分钟五个请求的漏桶。我们有两个函数：一个用于处理调用服务并将对象转换为 JSON 的图像，另一个用于处理失败。`processFailure`
    方法将只发送一条消息，说明请求太多，我们现在无法接受请求。
- en: 'So, for the `listAllImages` function, we will just call the bucket trying to
    drop and use the Scala pattern matcher in order to process the proper response.
    If the response is true, we will return JSON with a 200 HTTP code. Otherwise,
    we will return a 500 internal error and deny that request. Here, we implemented
    a global RATE limiter; however, most of the time, people perform this operation
    per user. Now, let''s open the web browser and try more than five requests within
    a minute. You should see something like the following screenshot at `http://localhost:9000/REST/api/images/all`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于 `listAllImages` 函数，我们只需尝试调用漏桶并使用 Scala 模式匹配器来处理适当的响应。如果响应为 true，我们将返回带有
    200 HTTP 代码的 JSON。否则，我们将返回 500 内部错误并拒绝该请求。在这里，我们实现了一个全局速率限制器；然而，大多数时候，人们按用户执行此操作。现在，让我们打开网页浏览器并尝试在一分钟内发出超过五个请求。你应该会在
    `http://localhost:9000/REST/api/images/all` 看到以下截图：
- en: '![Scala leaky bucket implementation](img/image00326.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Scala 漏桶实现](img/image00326.jpeg)'
- en: Alright, it works! If you wait a minute and make requests again, you will see
    that the flow gets back to normal. The next step is to add a new client test,
    because we know that if we call an image too much in our REST API, we will be
    throttled.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它工作了！如果你等待一分钟再次发出请求，你会看到流量恢复正常。下一步是添加一个新的客户端测试，因为我们知道如果我们过多地调用我们的 REST API
    中的图像，我们将会被节流。
- en: We will need to add one more test in the `rest-client` Scala project. For that,
    we will need to change the `ImageProxyTestSpec`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `rest-client` Scala 项目中添加一个额外的测试。为此，我们需要更改 `ImageProxyTestSpec`。
- en: Testing back pressure
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试背压
- en: 'Your `ImageProxyTestSpec.scala` should look something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `ImageProxyTestSpec.scala` 应该看起来像这样：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, for this test, we will call `ImageProxy` ten times. We know that not all
    requests will be served as we have back pressure on the server. Here, we can call
    the proxy with a try...catch block and have an error counter. Each time it fails,
    we can increment it. So, here, we are expected to fail at least five times.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个测试，我们将调用 `ImageProxy` 十次。我们知道并非所有请求都会被服务，因为我们服务器上有背压。在这里，我们可以使用 try...catch
    块调用代理，并有一个错误计数器。每次失败，我们都可以增加它。所以，这里，我们预计至少会失败五次。
- en: We are creating the code with Features because we want the requests to happen
    at the same time. We will need to use `CountDownLatch` function, which is a Java
    utility class that lets us wait for all Futures to finish before moving on. This
    is done by the `countDown` function. Every time we execute `countdown`, we decrement
    the internal counter. As you can see, we created the `CountDownLatch` function
    with ten.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用特性创建代码，因为我们希望请求同时发生。我们需要使用 `CountDownLatch` 函数，这是一个 Java 工具类，它允许我们在所有 Future
    完成之前等待。这是通过 `countDown` 函数完成的。每次我们执行 `countdown`，我们都会减少内部计数器。正如你所看到的，我们用十创建了 `CountDownLatch`
    函数。
- en: Finally, we have a `while` block to wait for until the counter has pending Futures.
    Now we wait. Once it's all done, we can check the error count; it should be at
    least five. That's it. We have tested our back pressure mechanism and it all works!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`while`循环块来等待，直到计数器有挂起的Futures。现在我们等待。一旦所有操作都完成，我们可以检查错误计数；它应该至少是五个。就这样。我们已经测试了我们的背压机制，并且一切正常！
- en: 'Now, it is time to move to the next feature that we will implement in our application:
    Swagger--we will add Swagger support to our REST API.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们转向下一个将在我们的应用程序中实现的功能的时候了：Swagger--我们将为我们的REST API添加Swagger支持。
- en: Adding Swagger support
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Swagger支持
- en: Swagger ([http://swagger.io/](http://swagger.io/)) is a simple JSON and UI representation
    tool for REST APIs. It can generate code in several languages. It also creates
    a very nice documentation, which is also a runnable Swagger code that allows you
    to call REST web services from the documentation it generates. We will need to
    make some changes in our Play framework application in order to get Swagger up
    and running with the Play framework.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger ([http://swagger.io/](http://swagger.io/)) 是一个简单的JSON和UI表示工具，用于REST
    API。它可以在多种语言中生成代码。它还创建了一份非常棒的文档，这份文档也是一个可运行的Swagger代码，允许您从它生成的文档中调用REST网络服务。为了使Swagger在Play框架中运行，我们需要在我们的Play框架应用程序中进行一些更改。
- en: 'First of all, we will need to add the Swagger dependency to `build.sbt`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将Swagger依赖项添加到`build.sbt`中：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, we are using a Snapshot version. Why use Snapshot? Right now,
    it is not supported on a stable version. In order to resolve this dependency,
    we will need to use Git and clone another project. You can get more details at
    [https://github.com/CreditCardsCom/swagger-play](https://github.com/CreditCardsCom/swagger-play).
    Basically, you will need to write a command as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用快照版本。为什么使用快照版本？目前，它不支持在稳定版本上。为了解决这个依赖项，我们需要使用Git并克隆另一个项目。您可以在[https://github.com/CreditCardsCom/swagger-play](https://github.com/CreditCardsCom/swagger-play)获取更多详细信息。基本上，您需要编写如下命令：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, we will need to enable Swagger on `ReactiveWebStore/conf/application.conf`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`ReactiveWebStore/conf/application.conf`中启用Swagger。
- en: 'Your `application.conf` file should look something like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`application.conf`文件应该看起来像这样：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we can change our controller in order to add Swagger support. Swagger
    has annotation in order to map the REST operations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以更改我们的控制器以添加Swagger支持。Swagger有注解来映射REST操作。
- en: 'Your `RestAPIController.scala` file should look something like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`RestAPIController.scala`文件应该看起来像这样：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we have several annotations. First of all, we have an `@Api` annotation
    at the top of the class. With this annotation, we will define the root path of
    the REST API. Then, for each REST API operation, we have the `@ApiOperation` and
    `@ApiResponses` annotations. The `@ApiOperation` defines the REST API itself where
    you can define the parameters and the HTTP verb, and also put some notes (documentation).
    It's also possible to describe the result; in our case, it will be a JSON representation
    of the models.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有几个注解。首先，我们在类的顶部有一个`@Api`注解。通过这个注解，我们将定义REST API的根路径。然后，对于每个REST API操作，我们有`@ApiOperation`和`@ApiResponses`注解。`@ApiOperation`定义了REST
    API本身，您可以在其中定义参数和HTTP动词，还可以添加一些注释（文档）。它还可能描述结果；在我们的案例中，它将是模型的JSON表示。
- en: 'That''s it! We have the controller mapped to Swagger. The next step is to add
    a route for Swagger. This needs to be done by adding a new line as shown in the
    following piece of code which, is located at `ReactiveWebStore/conf/routes`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经将控制器映射到Swagger。下一步是添加Swagger的路由。这需要通过在`ReactiveWebStore/conf/routes`中添加新行来完成，如下所示：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Swagger UI
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swagger UI
- en: 'Swagger will generate a JSON response for our REST API. It''s possible to use
    the Swagger UI, which is very nice and gives lots of facilities to the developer.
    There are two ways we can work with the Swagger UI: We can use it as a standalone
    or we can embed the Swagger UI into our Play framework application.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger将为我们的REST API生成JSON响应。可以使用Swagger UI，它非常棒，为开发者提供了许多便利。我们可以以两种方式与Swagger
    UI一起工作：我们可以将其作为独立应用使用，或者将其嵌入到我们的Play框架应用程序中。
- en: The strategy we will pick here is embedding the Swagger UI in our application.
    If you have multiple REST APIs with multiple Play applications or microservices,
    it is a good idea to have the standalone installation of the swagger UI.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的策略是在我们的应用程序中嵌入Swagger UI。如果您有多个REST API和多个Play应用程序或微服务，拥有独立的swagger UI安装是一个好主意。
- en: 'In the previous steps, we enabled Swagger in our application. Open your browser
    and type `http://localhost:9000/swagger.json`. You can follow the instructions
    at [http://swagger.io/swagger-ui/](http://swagger.io/swagger-ui/). In summary,
    you will get the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的步骤中，我们在应用程序中启用了 Swagger。打开您的浏览器并输入 `http://localhost:9000/swagger.json`。您可以遵循
    [http://swagger.io/swagger-ui/](http://swagger.io/swagger-ui/) 上的说明。总之，您将得到以下输出：
- en: '![Swagger UI](img/image00327.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Swagger UI](img/image00327.jpeg)'
- en: Build and install Swagger Standalone
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 和 安装 Swagger Standalone
- en: 'Now we will download, build, and install Swagger Standalone. Let''s get started
    by writing the following lines of code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将下载、构建和安装 Swagger Standalone。让我们通过编写以下代码行开始：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once you start the Swagger UI, you can go to the browser, where you will see
    the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您启动 Swagger UI，您可以在浏览器中看到以下输出：
- en: '![Build and install Swagger Standalone](img/image00328.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![构建和安装 Swagger Standalone](img/image00328.jpeg)'
- en: Now, let's embed the Swagger UI into our Play framework application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 Swagger UI 集成到我们的 Play 框架应用程序中。
- en: We will need to copy the content from `/swagger-ui/dist/` into our Play framework
    application under `ReactiveWebStore/public`. Then, we will create a folder called
    `swaggerui`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `/swagger-ui/dist/` 中的内容复制到我们的 Play 框架应用程序的 `ReactiveWebStore/public`
    下。然后，我们将创建一个名为 `swaggerui` 的文件夹。
- en: 'We will need to edit one file in order to put our swagger JSON URI. Open `ReactiveWebStore/public/swaggerui/index.html`
    and change the 40 to the following code line:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编辑一个文件，以便将我们的 swagger JSON URI 放入其中。打开 `ReactiveWebStore/public/swaggerui/index.html`
    并将 40 改为以下代码行：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That's it. Now we will need to create a link from our application to embed the
    swagger UI. So, let's change `ReactiveWebStore/app/views/index.scala.html`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，我们需要从我们的应用程序中创建一个链接来嵌入 Swagger UI。所以，让我们更改 `ReactiveWebStore/app/views/index.scala.html`。
- en: 'Your `index.scala.html` file should look something like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `index.scala.html` 文件应该看起来像这样：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we can run our Play application with `$ activator run`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `$ activator run` 运行我们的 Play 应用程序。
- en: 'Open the browser and go to `http://localhost:9000/`. You will see the following
    screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问 `http://localhost:9000/`。您将看到以下截图：
- en: '![Build and install Swagger Standalone](img/image00329.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![构建和安装 Swagger Standalone](img/image00329.jpeg)'
- en: 'Now we can open the Swagger UI by clicking on the Swagger REST API link or
    by just going to `http://localhost:9000/assets/swaggerui/index.html`. It should
    look something like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过点击 Swagger REST API 链接或直接访问 `http://localhost:9000/assets/swaggerui/index.html`
    来打开 Swagger UI。它看起来应该像这样：
- en: '![Build and install Swagger Standalone](img/image00330.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![构建和安装 Swagger Standalone](img/image00330.jpeg)'
- en: 'As you can see, the Swagger UI is very nice. You can click on each operation
    and see more details on how they work, which HTTP verb they use, and what the
    URI is. There is a **Try it out!** button. Let''s click on the **Try it out!**
    button for products, which would look something like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Swagger UI 非常不错。您可以点击每个操作，并查看更多关于它们如何工作、它们使用的 HTTP 动词以及 URI 的详细信息。有一个 **试试看！**
    按钮。让我们点击 **试试看！** 按钮来查看产品，它看起来应该像这样：
- en: '![Build and install Swagger Standalone](img/image00331.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![构建和安装 Swagger Standalone](img/image00331.jpeg)'
- en: As you can see, we have our JSON result and also some CURL samples as well.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有我们的 JSON 结果，还有一些 CURL 示例。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to design a REST API and changed your Play
    framework application in order to have Swagger support. You created a Scala client
    library using proxy techniques, as well as Scala tests for the APIs. Additionally,
    you were introduced to back pressure using the leaky bucket algorithm.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何设计 REST API 并更改您的 Play 框架应用程序以支持 Swagger。您使用代理技术创建了一个 Scala 客户端库，以及用于
    API 的 Scala 测试。此外，您还介绍了使用漏桶算法的背压。
- en: In the next chapter, which will be the final chapter, you will learn about software
    architecture and scalability/resiliency techniques, such as discoverability, load
    balancers, caches, Akka Cluster, and the Amazon Cloud.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也就是最后一章，您将学习关于软件架构和可伸缩性/弹性技术，例如可发现性、负载均衡器、缓存、Akka Cluster 和亚马逊云。
