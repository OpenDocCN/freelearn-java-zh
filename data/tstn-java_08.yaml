- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Arrays, Collections, Generics, Functions, and Streams
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组、集合、泛型、函数和流
- en: Up until now, we have used variables to represent a single instance of a primitive
    data type and a reference data type. More frequently encountered in the real world,
    though, is the need to work with and process multiple data elements. In this chapter,
    we will look at the various options available for managing multiple elements.
    In examining the options in Java for this purpose, we will see how we can enhance
    type safety.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用变量来表示原始数据类型和引用数据类型的一个实例。然而，在现实世界中，更频繁的需求是处理和加工多个数据元素。在本章中，我们将探讨管理多个元素的各种选项。在检查Java中用于此目的的选项时，我们将看到我们如何提高类型安全性。
- en: To process multiple elements more efficiently, we will examine streams—a replacement
    for traditional loops when coupled with functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有效地处理多个元素，我们将检查流——当与函数结合使用时，它是传统循环的替代品。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding the array data structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数组数据结构
- en: Understanding the Collections Framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解集合框架
- en: Using sequential implementations and interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型实现和接口
- en: Understanding Generics in the Collections Framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解集合框架中的泛型
- en: Using sequential implementations and interfaces with Generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型实现和接口
- en: Understanding Collections Framework map structures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解集合框架的映射结构
- en: Understanding functions in Java
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Java中的函数
- en: Using streams in collections
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集合中使用流
- en: Upon completion of this chapter, you will be able to work with multiple instances
    of data as an array or collection and apply algorithms available in the `Stream`
    library.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够以数组或集合的形式处理多个数据实例，并应用`Stream`库中的算法。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行本章示例所需的工具：
- en: Java 17 installed
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Java 17
- en: Text editor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Maven 3.8.6或更高版本
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter08](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter08).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter08](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter08)找到。
- en: Understanding the array data structure
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数组数据结构
- en: 'As with most languages, Java has a built-in array data structure and does not
    require any imports or external libraries. As such, the array behaves as most
    arrays in other languages. The only difference is that to instantiate an array,
    you need the `new` keyword. Here are the two ways to declare an array of 10 elements
    of type `int`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，Java有一个内置的数组数据结构，不需要任何导入或外部库。因此，数组的行为与其他语言中的数组类似。唯一的区别是，要实例化一个数组，你需要`new`关键字。以下是声明一个包含10个`int`类型元素的数组的两种方式：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The difference is where the empty square brackets are placed on the left-hand
    side. Placing them after the type is considered the Java way. Placing it after
    the identifier is thought of as the C-language way. Either syntax is fine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于空方括号放置在左侧的位置。在类型之后放置它们被认为是Java的方式。在标识符之后放置被认为是C语言的方式。任何一种语法都是可以的。
- en: In most programming languages, numbers can be either ordinal or cardinal. The
    length of the array as declared when we instantiate it is a cardinal—or count—number.
    In the examples so far, the length has been 10\. An ordinal number represents
    the position in a structure such as in an array. Ordinals begin with zero in most
    programming languages. When we declare an array of cardinal length 10, the ordinal
    positions range from 0 to 9 and not 1 to 10.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，数字可以是序数或基数。当我们实例化时声明的数组长度是一个基数——或者说计数数字。在之前的例子中，长度一直是10。序数表示结构中的位置，如数组中的位置。在大多数编程语言中，序数从零开始。当我们声明长度为10的基数数组时，序数位置从0到9，而不是从1到10。
- en: Arrays are of a fixed length; they cannot be expanded or contracted. Each position
    in an array is ready for use. You can assign a value to the last position before
    assigning one to the first position.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数组长度固定；它们不能被扩展或收缩。数组中的每个位置都准备好使用。你可以在将值赋给第一个位置之前，先将其赋给最后一个位置。
- en: 'You can defer instantiating an array, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以延迟实例化数组，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Arrays store the values of an array in a contiguous block of memory. This tells
    us that the array will be 10 elements times 4 bytes per `int` to consume 40 bytes
    plus the necessary overhead for an object in Java. The length of the array is
    part of this overhead.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数组将数组的值存储在连续的内存块中。这告诉我们，数组将占用 10 个元素乘以每个 `int` 的 4 个字节，总共 40 个字节，以及 Java 中对象的必要开销。数组的长度是这部分开销的一部分。
- en: 'An array of objects consists of an array of references. For example, you could
    create an array of four strings, like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数组由引用数组组成。例如，你可以创建一个包含四个字符串的数组，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, the array will consume 4 bytes for the reference to each `String`
    object as well as the usual array object overhead. The strings themselves are
    stored in memory as the `null` until you assign a valid reference to the array:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数组将为每个 `String` 对象的引用占用 4 个字节，以及通常的数组对象开销。字符串本身在内存中以 `null` 的形式存储，直到你为数组分配一个有效的引用：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When using references in arrays, what we are storing in the data structure is
    the reference and not the object. Only primitives can be stored directly in an
    array.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数组中使用引用时，我们在数据结构中存储的是引用而不是对象。只有原始数据类型可以直接存储在数组中。
- en: 'From here, we read and write to the array using the subscript. To get the length
    of the array, we use the final constant variable, `length`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们使用索引来读取和写入数组。要获取数组的长度，我们使用最终的常量变量 `length`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To visit every element in an array with a `for` loop, you would use the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `for` 循环遍历数组中的每个元素，你会使用以下代码：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Java also has an enhanced `for` loop for visiting every element in an array.
    The subscript value is no longer available:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还有一个增强的 `for` 循环，用于访问数组中的每个元素。索引值不再可用：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One last thing to point out: Java has a library for performing a range of operations
    on an array, called the `Arrays` library. This class contains static methods for
    sorting and searching as well as creating a list, one of the collections, from
    an array. We will see an example of turning an array into a list in the later
    section, *Using streams* *in collections*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意的是：Java 有一个用于在数组上执行一系列操作的库，称为 `Arrays` 库。这个类包含用于排序、搜索以及从一个数组创建列表（集合之一）的静态方法。我们将在后面的部分看到将数组转换为列表的示例，*在集合中使用流*
    *。
- en: You should already be comfortable with working with an array. You can read and
    write to any valid subscripted element. If you use an invalid subscript that is
    out of range, Java will throw an `ArrayIndexOutOfBoundsException`. Now, let’s
    look at the Collections Framework.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉使用数组了。你可以读取和写入任何有效的索引元素。如果你使用一个超出范围的无效索引，Java 将会抛出 `ArrayIndexOutOfBoundsException`
    异常。现在，让我们来看看集合框架。
- en: Understanding the Collections Framework
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解集合框架
- en: 'Once an array is instantiated, it cannot have its length increased or decreased.
    This means that you must know the exact number of elements you will need before
    you instantiate the array. You can use a variable to declare the array but once
    created it cannot be resized. Have a look at the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了数组，它的长度就不能增加或减少。这意味着在实例化数组之前，你必须知道你需要的确切元素数量。你可以使用变量来声明数组，但一旦创建，它就不能调整大小。看看以下示例：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is where collections come in. These are dynamic data structures that can
    increase in size as elements are added. You can also remove elements, although
    reducing the size is not always available, and if it can be reduced, then you
    must call an appropriate method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是集合发挥作用的地方。这些是动态数据结构，可以随着元素的添加而增加大小。你也可以删除元素，尽管减少大小并不总是可用，如果可以减少，那么你必须调用适当的方法。
- en: The Collections Framework is divided into implementations and interfaces. An
    implementation may support more than one interface. While an implementation can
    have a large selection of methods, the use of an interface allows you to restrict
    what you can do with a collection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架分为实现和接口。一个实现可能支持多个接口。虽然实现可以有一系列丰富的方法，但使用接口可以让你限制对集合的操作。
- en: The Collections Framework classes fall into two categories. There are sequential
    collections that preserve the order in which elements are added. Then, there are
    map collections where elements are stored in pairs of data. The first is typically
    a field of an object called the key, while the second is a reference to the object
    itself called the value. These collections organize themselves based on the key.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架类分为两类。有顺序集合，它们保留元素添加的顺序。然后，有映射集合，其中元素以数据对的形式存储。第一个通常是对象的字段，称为键，而第二个是对对象本身的引用，称为值。这些集合根据键组织自己。
- en: The default data type that all members of these classes manage is `Object`.
    This means that you can store any object in a collection as all classes extend
    `Object`, and polymorphism allows you to use a subclass wherever a superclass
    is called for. The problem with this approach is that you can conceivably have
    a collection of apples and oranges. Until the introduction of Generics to the
    language, it was the responsibility of the developer to avoid mixing types.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的所有成员管理的数据类型默认为`Object`。这意味着你可以将任何对象存储在集合中，因为所有类都扩展了`Object`，多态性允许你在需要超类的地方使用子类。这种方法的缺点是，你可能会有一个包含苹果和橙子的集合。在语言中引入泛型之前，避免类型混合是开发者的责任。
- en: Let’s look more closely at sequential structures.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看顺序结构。
- en: Using sequential implementations and interfaces
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顺序实现和接口
- en: Let’s begin with the implementation. These are classes that manage the data
    in many ways. They are `ArrayList`, `LinkedList`, and `ArrayDeque`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现开始。这些是管理数据以多种方式进行的类。它们是`ArrayList`、`LinkedList`和`ArrayDeque`。
- en: ArrayList
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ArrayList
- en: This is a dynamic array-like structure. As a class, you must use methods rather
    than subscripts to access specific elements. You add elements at the end of the
    list. Once you add an element, you can read from it, write to it, search for a
    specific value, and remove elements from a specific position or that match a specific
    value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个动态的类似数组的结构。作为一个类，你必须使用方法而不是下标来访问特定元素。你将在列表的末尾添加元素。一旦添加了元素，你可以从中读取、写入、搜索特定值，以及从特定位置或匹配特定值的元素中删除元素。
- en: You can instantiate an `ArrayList` class with or without an initial capacity.
    If you do not specify a capacity, then it will default to a capacity of 10\. If
    you know in advance how many elements you will need, then include that value when
    you instantiate the `ArrayList` class. The auto-resizing of an `ArrayList` class
    entails overhead that you can avoid if you know the precise size. In either case,
    you cannot access elements until you first add an element. As you add elements,
    the size increases. You can access any element that you add but you cannot access
    any positions between the last element added and the unused capacity that follows
    it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以带或不带初始容量实例化`ArrayList`类。如果你没有指定容量，则默认为10。如果你事先知道你需要多少元素，那么在实例化`ArrayList`类时包含该值。`ArrayList`类的自动调整大小涉及开销，如果你知道确切的大小，则可以避免这种开销。在任何情况下，你都不能在添加元素之前访问元素。随着元素的添加，大小会增加。你可以访问你添加的任何元素，但你不能访问最后添加的元素和随后的未使用容量之间的任何位置。
- en: LinkedList
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LinkedList
- en: This structure stores data in node objects, with each node knowing what comes
    before and after it. On the surface, it would seem to be quite efficient as you
    create nodes as needed. The major drawback to a linked list is that it does not
    support random access. In `ArrayList`, you can access any element such as an array
    by using the integer that represents its position using a method rather than square
    brackets. This access is direct. In a `LinkedList` class, the only elements you
    can access directly are the first and last elements. To access any other element,
    you must start at the beginning or end and then follow the forward or backward
    references to the subsequent nodes. This makes access to elements far slower than
    in `ArrayList`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构在节点对象中存储数据，每个节点都知道它之前和之后的内容。从表面上看，这似乎非常高效，因为你需要时才创建节点。链表的缺点是它不支持随机访问。在`ArrayList`中，你可以通过使用表示其位置的整数来访问任何元素，就像数组一样，使用方法而不是方括号。这种访问是直接的。在`LinkedList`类中，你只能直接访问第一个和最后一个元素。要访问任何其他元素，你必须从开始或结束处开始，然后跟随前向或后向引用到后续节点。这使得访问元素的速度远慢于`ArrayList`。
- en: 'I instruct students about linked lists because they make for nice blackboard
    diagrams. The `Map` structures that we will look at shortly are based on variants
    of the linked list. Let me end with a tweet from Joshua Bloch concerning the Java
    `LinkedList` class he wrote:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我向学生讲解链表，因为它们非常适合黑板图。我们将很快查看的`Map`结构基于链表的变体。让我以Joshua Bloch关于他编写的Java `LinkedList`类的一条推文结束：
- en: '![Figure 8.1 – Famous LinkedList tweet](img/B19088_08_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 著名的LinkedList推文](img/B19088_08_01.jpg)'
- en: Figure 8.1 – Famous LinkedList tweet
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 著名的LinkedList推文
- en: ArrayDeque
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ArrayDeque
- en: The `ArrayDeque` class is like `ArrayList` in that it is a dynamic structure
    that stores elements in an array-like structure. Unlike `ArrayList`, it does not
    support direct access. Instead, it is optimized for inserting or removing elements
    at the beginning (`Deque`, `Queue`, and `Stack` interfaces. Prior to the introduction
    of the `ArrayDeque` class in Java 1.6, you used a `LinkedList` class as the implementation
    for these interfaces. The `ArrayDeque` class outperforms the `LinkedList` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayDeque`类与`ArrayList`类似，因为它是一个动态结构，以类似数组的方式存储元素。与`ArrayList`不同，它不支持直接访问。相反，它优化了在开始处插入或删除元素（`Deque`、`Queue`和`Stack`接口）。在Java
    1.6引入`ArrayDeque`类之前，你使用`LinkedList`类作为这些接口的实现。`ArrayDeque`类优于`LinkedList`类。'
- en: This is not a complete list. For example, there is a `Stack` class, but using
    the `ArrayDeque` class with a `Deque` interface will outperform the `Stack` class.
    A second issue relates to thread safety. These three implementations are not thread-safe.
    There are specialized versions of the implementations in the framework, specifically
    for when threads must share access to a data structure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完整的列表。例如，有一个`Stack`类，但使用带有`Deque`接口的`ArrayDeque`类将优于`Stack`类。第二个问题与线程安全相关。这三个实现都不是线程安全的。框架中有专门版本的实现，特别是当线程必须共享对数据结构的访问时。
- en: You can implement any of these classes, but it is considered a poor choice.
    Each of these implementations has numerous methods to support the use of the structure
    in numerous ways. When you use a Java collections class, you want to use the smallest
    interface for what you are trying to accomplish rather than allowing access to
    every method in the implementation. Let’s look at these interfaces.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现这些类中的任何一个，但被认为是一个糟糕的选择。每个实现都有许多方法来支持以多种方式使用结构。当你使用Java集合类时，你希望使用最小的接口来完成你的任务，而不是允许访问实现中的每个方法。让我们看看这些接口。
- en: The Collection interface
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合接口
- en: 'Here is a diagram of the most common interfaces:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个最常见的接口的图示：
- en: '![Figure 8.2 – The Collection interfaces](img/B19088_08_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 集合接口](img/B19088_08_02.jpg)'
- en: Figure 8.2 – The Collection interfaces
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 集合接口
- en: Each of the boxes represents an interface that a collection implementation may
    or may not support. `Collection` is the super interface. Any class that implements
    the interfaces below it must also implement `Collection`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框代表一个集合实现可能支持或不支持的接口。`Collection`是超接口。任何实现其下接口的类也必须实现`Collection`。
- en: The most common interface is `List`. This is the closest to an array. `Set`
    and `SortedSet` are interfaces that ensure that an element cannot appear more
    than once. `Queue` is a FIFO structure. You can only add elements to the end of
    the structure, and you can only remove them from the front of the structure. `Deque`
    is a structure that supports LIFO. What is unique about `Deque` is that you add
    or remove from either end. Neither `Queue` nor `Deque` permit access by subscript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的接口是`List`。这最接近数组。`Set`和`SortedSet`是确保元素不会出现多次的接口。`Queue`是一个FIFO结构。你只能向结构的末尾添加元素，也只能从结构的开头移除元素。`Deque`是一个支持LIFO的结构。`Deque`的独特之处在于你可以从两端添加或删除。`Queue`和`Deque`都不允许通过索引访问。
- en: How to declare a collection
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何声明一个集合
- en: 'As we have already discussed in [*Chapter 6*](B19088_06.xhtml#_idTextAnchor128),
    *Methods, Interfaces, Records, and Their Relationships*, you use an interface
    class to define which methods the class must implement. The most widely used interface
    for sequential collections is the `List`. We can now declare a data structure
    that can only use the methods shown in the `List` interface and no others:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已在[*第6章*](B19088_06.xhtml#_idTextAnchor128)中讨论的，“方法、接口、记录及其关系”，你使用接口类来定义类必须实现的方法。对于顺序集合最广泛使用的接口是`List`。我们现在可以声明一个只能使用`List`接口中显示的方法的数据结构，而不能使用其他方法：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we look at more interfaces, it is time to look at the concept of Generics
    and how they relate to the collections interface. We need to look at this now
    because while the previous line of code is executable, rarely will a Java developer
    write it this way.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看更多接口之前，是时候看看泛型的概念以及它们如何与集合接口相关联了。我们需要现在就看看这个问题，因为虽然前面的代码行是可执行的，但很少会有Java开发者这样写。
- en: Understanding Generics in the Collections Framework
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集合框架中理解泛型
- en: 'As pointed out, the default classes in the Collections framework were designed
    to manage only references to objects of type `Object`. Polymorphism then permitted
    the use of any subclass in an implementation of any of these classes. The problem
    with this approach is that it is not type-safe. Look at this code fragment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所指出的，集合框架中的默认类是为了仅管理类型为`Object`的对象的引用而设计的。多态允许在实现这些类中的任何类中使用任何子类。这种方法的缺点是不安全类型。看看这个代码片段：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code begins by declaring two variables. The first is an `int` type with
    the `numberOfApples` identifier. Collections cannot contain primitive data types,
    so an object of type `Integer` is required if the primitive is an `int` type.
    Java will perform this conversion from primitive to object for you. The second
    line creates a `String` object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先声明了两个变量。第一个是带有`numberOfApples`标识符的`int`类型。集合不能包含原始数据类型，所以如果原始数据类型是`int`类型，则需要一个`Integer`类型的对象。Java会为你执行从原始类型到对象的这种转换。第二行创建了一个`String`对象。
- en: Next is the instantiation of an object of type `ArrayList` but whose interface
    is restricted to just what the `List` interface class permits. Now, we can add
    the `Integer` and the `String` objects to the collection. The last line displays
    the contents of the `List` as its `toString()` method creates a `String` object
    of all members. This leads to the expression that you should not mix apples and
    oranges. Collections must be of a single type. While the default syntax for Collections
    does not restrict what can be added, the use of Generic notation will.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是创建一个类型为`ArrayList`的对象，但其接口仅限于`List`接口类允许的内容。现在，我们可以将`Integer`和`String`对象添加到集合中。最后一行显示了`List`的内容，因为它的`toString()`方法创建了一个包含所有成员的`String`对象。这导致了一个表达，即不要把苹果和橘子混在一起。集合必须为单一类型。虽然集合的默认语法不限制可以添加的内容，但使用泛型符号将这样做。
- en: 'Let’s look at a new variation of the previous code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前代码的一个新变体：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we kept our `int` type and then created two strings. The declaration
    of the `List` now includes angle brackets. Within the brackets is the class type
    you want to restrict the `List` to contain. In this example, the class is `String`.
    While we must show the class type on the left-hand side, we can just have empty
    angle brackets on the right side as there is never a situation where these two
    class types could be different.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们保留了`int`类型，然后创建了两个字符串。现在`List`的声明中包含了尖括号。括号内是你想要限制`List`包含的类类型。在这个例子中，类是`String`。虽然我们必须在左侧显示类类型，但右侧可以只保留空尖括号，因为这两种类类型永远不会不同。
- en: 'The next lines add the objects to the `List`. The first two will work, but
    the third, where we are trying to add an object of type `Integer`, will generate
    an exception:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行将对象添加到`List`中。前两个将正常工作，但第三个，当我们尝试添加一个`Integer`类型的对象时，将生成一个异常：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Java will no longer allow you to mix apples and oranges. This test for ensuring
    all objects added to a collection are the same type only occurs at compile time.
    This means it is possible to add a different object type if this operation only
    occurs at runtime. This can occur when multiple processes are running in the JVM,
    and one process calls a method in another process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java将不再允许你把苹果和橘子混在一起。这个确保添加到集合中的所有对象都是同一类型的测试只发生在编译时。这意味着如果这个操作只在运行时发生，则可以添加不同的对象类型。这可能会发生在多个进程在JVM中运行，并且一个进程调用另一个进程中的方法时。
- en: We will now return to the collections and only use Generic syntax from here
    on in.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将回到集合，并且只从现在开始使用泛型语法。
- en: Using sequential implementations and interfaces with Generics
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型实现和接口
- en: 'As we have just seen, the best practice for creating a `List` will be this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，创建`List`的最佳实践将是这个：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Any valid class type can be used. Once we have elements in our collection,
    we can access them with the `get` method and the subscript:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有效的类类型都可以使用。一旦我们在集合中有元素，我们就可以使用`get`方法和下标来访问它们：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the last two lines, we are referring to specific positions in the list.
    To change the object stored in a specific position, we use the `set` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两行中，我们正在引用列表中的特定位置。要更改特定位置存储的对象，我们使用`set`方法：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The interfaces and the implementation classes all support methods that allow
    you to determine if a specific object is contained in the collections. For this
    reason, you must override the `equals` method inherited from `Object`. Certain
    collection methods require the hash value, so your classes must have a `hashCode`
    method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和实现类都支持允许您确定特定对象是否包含在集合中的方法。因此，您必须重写从`Object`继承的`equals`方法。某些集合方法需要哈希值，因此您的类必须有一个`hashCode`方法。
- en: 'You can also sort collections. To do this, the class type of the objects you
    are storing must implement the `Comparable` interface. This interface requires
    you to write just one method named `compareTo` that returns a negative number,
    zero, or a positive number. Here is a fragment of a class that implements `compareTo`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以对集合进行排序。为此，您存储的对象的类类型必须实现`Comparable`接口。此接口要求您编写一个名为`compareTo`的方法，该方法返回一个负数、零或正数。以下是实现`compareTo`的类的片段：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class has only one field that is initialized by the constructor. It implements
    the `Comparable` interface using Generic notation to indicate that we can only
    compare this object to an object of the same class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此类只有一个字段，由构造函数初始化。它使用泛型表示法实现`Comparable`接口，表示我们只能将此对象与同一类的对象进行比较。
- en: 'The `compareTo` method, required because we are implementing the `Comparable`
    interface, must return:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在实现`Comparable`接口，因此必须返回`compareTo`方法的`compareTo`方法：
- en: A positive integer if the value of the current object we are comparing is greater
    than the value of the object that is being compared to
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前比较对象的值大于被比较对象的值，则返回一个正整数
- en: The value 0 if the value of the current object we are comparing is equal to
    the value of the object that is being compared to
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前比较对象的值等于被比较对象的值，则返回0
- en: A negative integer if the value of the current object we are comparing is less
    than the value of the object that is being compared to
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前比较对象的值小于被比较对象的值，则返回一个负整数
- en: 'You may wonder how we can access the value of `ComparableClass` that is passed
    to `compareTo` using dot notation when the field is private. This is possible
    because Java permits objects of the same class to access private members of another
    instance of this same class. Here is the class that tests this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道，当字段是私有的时，我们如何使用点符号访问传递给`compareTo`的`ComparableClass`的值。这是可能的，因为Java允许同一类的对象访问同一类的另一个实例的私有成员。以下是测试此功能的类：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `perform` method, we are displaying the result of calling the `compareTo`
    method. Let’s now create a `List` of objects and then sort the list. There is
    a small modification to `ComparableClass`. A method to return the value stored
    in the class has been added:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`perform`方法中，我们正在显示调用`compareTo`方法的结果。现在让我们创建一个对象`List`并对其进行排序。对`ComparableClass`进行了一些小的修改。已添加一个返回类中存储的值的方法：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we have a class that creates 10 objects of `ComparableClass`, places them
    in a `List`, and sorts the `List`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个创建10个`ComparableClass`对象、将它们放入`List`并排序的类：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the constructor that instantiates an object of type `ArrayList` that
    will be restricted to use only methods from the `List` interface:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建一个类型为`ArrayList`的对象的构造函数，该对象将仅限于使用`List`接口的方法：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the angle brackets after `ArrayList` are empty. When we declared `comparableClasses`,
    we declared the `List` as containing `ComparableClass` objects. There is no need
    to repeat this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ArrayList`后面的尖括号是空的。当我们声明`comparableClasses`时，我们将`List`声明为包含`ComparableClass`对象。没有必要重复此操作。
- en: 'This next method creates 10 instances of `ComparableClass`, initializing them
    with a random integer as they are added to the `List`. Each value is also displayed
    on the console so that we can see the original values as they are assigned:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法创建了10个`ComparableClass`实例，在将它们添加到`List`时，用随机整数初始化它们。每个值也会在控制台上显示，这样我们就可以看到分配时的原始值：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This method displays the values in each object in the `List`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法显示`List`中每个对象的值：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s fill the list, display it, sort it, and display it again:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们填充列表，显示它，对其进行排序，然后再显示一次：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Collections` class contains a family of static methods that can be applied
    to an object that implements the `Collection` interface. One is the `Collections.sort`
    method. It alters the input rather than returning a new value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类包含一系列静态方法，可以应用于实现`Collection`接口的对象。其中一个是`Collections.sort`方法。它改变输入而不是返回一个新值：'
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What we have seen so far is how sequential collections can be used. The need
    for special interfaces such as `Comparable` was also highlighted. Let’s now look
    at ordered collections.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止看到的是如何使用顺序集合。也需要特殊接口如`Comparable`的需求也得到了强调。现在让我们看看有序集合。
- en: Understanding Collections Framework map structures
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解集合框架的映射结构
- en: The second family of collections is the map family. A map is a data structure
    in which you add elements to a map with a pair of values. The first value is the
    key. This is a reference to an object that, depending on the type of map, either
    implements the `Comparable` interface—as we saw in the previous section—or overrides
    the `hashCode` and `equals` methods. If the key is a primitive, then we declare
    it as its wrapper class, and Java will manage the necessary conversion to and
    from the primitive. The second is the value—a reference to the object you are
    storing in the map. This class does not need to implement the `Comparable` interface.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组集合是映射集合。映射是一种数据结构，你可以通过一对值将元素添加到映射中。第一个值是键。这是一个对象的引用，根据映射的类型，它要么实现了`Comparable`接口——如我们在上一节中看到的，要么重写了`hashCode`和`equals`方法。如果键是原始类型，那么我们将其声明为其包装类，Java将管理必要的从原始类型到包装类型以及从包装类型到原始类型的转换。第二个是值——存储在映射中的对象的引用。这个类不需要实现`Comparable`接口。
- en: There are three map implementations in Java, which we will now cover.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Java中有三种映射实现，我们现在将介绍。
- en: HashMap
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HashMap
- en: Of all the data types available in Java and most other languages, the fastest
    performing is the integer. The size of an integer is the same as the word size
    of the CPU. The JVM is a 32-bit or 4-word machine. Even 64-bit Java is just modeling
    a 32-bit machine. This is where the hash code comes in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和大多数其他语言中可用的所有数据类型中，性能最快的是整数。整数的大小与CPU的字长相同。JVM是一个32位或4字节的机器。即使是64位的Java也只是在模拟32位机器。这就是哈希码的作用所在。
- en: As with all map structures, entries are comprised of two components. The first
    is the key and the second is the value. What makes `HashMap` special is that the
    hash code of the key value determines where it will store the pair. The underlying
    structure is an array, and each position in the array is a bucket. Using arithmetic
    operations such as modulus, the subscript in the array can be determined from
    the hash code of the key.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有映射结构一样，条目由两个组件组成。第一个是键，第二个是值。使`HashMap`特殊的是键值的哈希码决定了它将存储的位置。其底层结构是一个数组，数组的每个位置都是一个桶。通过使用如取模等算术运算，可以从键的哈希码中确定数组中的索引。
- en: A hash code is not unique. This means that two or more keys may generate the
    same hash code. In this case, they will also want to use the same subscript, and
    the bucket becomes a single linked list of buckets. If the number of keys becomes
    greater than eight, then the linked list is converted into a balance binary tree.
    When searching for a key in a list, the `equals` method is used to test each bucket
    to find the value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希码不是唯一的。这意味着两个或多个键可能生成相同的哈希码。在这种情况下，它们也将想要使用相同的索引，桶将变成一个桶的单链表。如果键的数量超过八个，那么链表将转换为平衡二叉树。在列表中搜索键时，使用`equals`方法测试每个桶以找到值。
- en: Use a hash map when you must collect data that you must be able to retrieve
    from the structure rapidly. There is no defined order. The first item you put
    in a hash map could be the seventh element in the array of buckets. This also
    means that the order of elements put into the structure cannot be determined.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须收集能够快速从结构中检索的数据时，请使用哈希表。没有定义的顺序。你放入哈希表中的第一个项目可能是桶数组中的第七个元素。这也意味着放入结构中的元素的顺序无法确定。
- en: To find a value in a `HashMap` object given a key, you can use the `get` method.
    This method takes the key as a parameter and returns the value if found or it
    returns `null` if not found. Let’s look at an example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要在一个给定的键的`HashMap`对象中查找值，你可以使用`get`方法。此方法将键作为参数，如果找到则返回值，如果没有找到则返回`null`。让我们看看一个例子。
- en: 'First, we create a `HashMap` object using the `Map` interface:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`Map`接口创建一个`HashMap`对象：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can put data into the `HashMap` object using the `put` method that
    takes two parameters. These are the key and the value:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用带有两个参数的`put`方法将数据放入`HashMap`对象中。这两个参数是键和值：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These next two lines will retrieve the value associated with the key if the
    key exists. Otherwise, `null` is returned:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两行将检索与键关联的值，如果键存在的话。否则，返回`null`：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is no entry in the `HashMap` object that uses the integer 1 as a key,
    so it will print out `null`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HashMap`对象中没有使用整数1作为键的条目，所以它将打印出`null`。
- en: 'To iterate or work with every element over the entire `HashMap` object, we
    need to first create a `Set` object from all the entries in the hash map:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代或处理整个`HashMap`对象中的每个元素，我们首先需要从哈希表中的所有条目创建一个`Set`对象：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From the `Set` object, we create an `Iterator` object. An iterator allows us
    to access every element in the set in the order determined by the keys:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Set`对象中，我们创建一个`Iterator`对象。迭代器允许我们按键的顺序访问集合中的每个元素：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Iterator` object’s `hasNext` method returns `true` if there is another
    element in the `Set` object; otherwise, it returns `false`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`对象的`hasNext`方法返回`true`，如果`Set`对象中还有另一个元素；否则，返回`false`：'
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Iterator` object’s `next` method returns the key/value pair:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`对象的`next`方法返回键/值对：'
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of this code will be this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出将是这样的：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that the order of keys is not the same as the order they were put into
    the hash map.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，键的顺序与它们放入哈希表的顺序不同。
- en: LinkedHashMap
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LinkedHashMap
- en: This structure is a variant of `HashMap`. Internally it operates just like `HashMap`
    but also includes a second data structure. This is a linked list that preserves
    the order in which data is put into `LinkedHashMap`. If the order of entry is
    not significant, use a `HashMap` structure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构是`HashMap`的一个变体。内部操作就像`HashMap`一样，但还包括第二个数据结构。这是一个链表，它保留了数据放入`LinkedHashMap`中的顺序。如果顺序不重要，请使用`HashMap`结构。
- en: 'If we used `LinkedHashMap` in the previous example code, the only change we
    would make would be to use `LinkedHashMap` instead of `HashMap`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前面的示例代码中使用了`LinkedHashMap`，我们唯一要做的改变就是使用`LinkedHashMap`而不是`HashMap`：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of this version will be this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的输出将是这样的：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is the same order that the key/value pairs were put into the map.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是键/值对放入映射中的相同顺序。
- en: TreeMap
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TreeMap
- en: 'Unlike `HashMap` and `LinkedHashMap`, the underlying structure of `TreeMap`
    is a red-black binary tree. The key value is used as is and must implement the
    `Comparable` interface. You do not need the `hashCode` and `equals` methods, but
    it is good practice to include them. Here is the same code using `TreeMap`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与`HashMap`和`LinkedHashMap`不同，`TreeMap`的底层结构是一个红黑二叉树。键值直接使用，并且必须实现`Comparable`接口。你不需要`hashCode`和`equals`方法，但包含它们是一个好习惯。以下是使用`TreeMap`的相同代码：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, the keys are not in any order. As integers, they do have a natural order
    that will determine where in the binary tree the key/value pairs are placed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，键没有特定的顺序。作为整数，它们确实有一个自然顺序，这将决定键/值对在二叉树中的位置：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we use the iterator to display all the key/value pairs, they will be in
    the order based on the key:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用迭代器显示所有键/值对时，它们将根据键的顺序排列：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output will be this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是这样的：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While an array is frequently the go-to structure when you need multiple elements,
    consider that its interface is quite limited. Collections have a rich set of methods
    that expand what you can do in your code. Before we move on to functions, keep
    in mind the following note.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组在需要多个元素时通常是首选的结构，但请考虑它的接口相当有限。集合有一系列丰富的方法，可以扩展你在代码中能做的事情。在我们继续到函数之前，请记住以下注意事项。
- en: Important note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: The Collections shown in this chapter are not thread-safe. There are variants
    of each collection that are thread-safe.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的集合不是线程安全的。每个集合都有线程安全的变体。
- en: Understanding functions in Java
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java中的函数
- en: In Java, we call units of code in a class a method. In C and C++, we call them
    functions. In JavaScript, we even use the `keyword` function. What sets Java apart
    from these other languages is that functions represent a different coding model
    than classes and their methods. There are functional rather than **object-oriented**
    (**OO**) languages, of which Haskell is one example. We are briefly examining
    functions because our next topic, streams, is based on the function rather than
    the class model.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们称一个类中的代码单元为方法。在C和C++中，我们称它们为函数。在JavaScript中，我们甚至使用`keyword`函数。Java与其他这些语言的不同之处在于，函数代表了一个与类及其方法不同的编码模型。有一些是函数式语言，其中Haskell是一个例子。我们简要地检查函数，因为我们的下一个主题，流，是基于函数而不是类模型。
- en: 'Let’s look at some code that attached an event handler to a button in JavaFX.
    We will be looking at JavaFX in [*Chapter 13*](B19088_13.xhtml#_idTextAnchor254),
    *Desktop Graphical User Interface Coding with Swing and JavaFX*. Let’s begin by
    looking at what a functional `EventHandler` interface is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些在JavaFX中为按钮附加事件处理器的代码。我们将在[*第13章*](B19088_13.xhtml#_idTextAnchor254)中查看JavaFX，*使用Swing和JavaFX进行桌面图形用户界面编码*。让我们首先看看一个功能性的`EventHandler`接口是什么：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is the interface class for `EventHandler` that is part of JavaFX. The
    `@FunctionalInterface` annotation is optional but adds clarity to the purpose
    behind this interface. Functional interfaces can only have one abstract method.
    There is no implementation of this interface in JavaFX. You must supply the code
    for the `handle` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaFX中`EventHandler`接口的接口类。`@FunctionalInterface`注解是可选的，但增加了对接口背后目的的清晰度。函数式接口只能有一个抽象方法。JavaFX中没有这个接口的实现。你必须为`handle`方法提供代码：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code registers an event handler for when a button is pressed. The handler
    must be an object of type `EventHandler` and must have a method named `handle`.
    The `handle` method is calling upon the `toString` method from `userBean` to return
    a string that will be assigned to a `Text` field named `actionTarget`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为按钮按下时注册了一个事件处理器。处理器必须是`EventHandler`类型，并且必须有一个名为`handle`的方法。`handle`方法调用`userBean`的`toString`方法来返回一个字符串，该字符串将被分配给名为`actionTarget`的`Text`字段。
- en: 'The first fragment demonstrates an anonymous inner class. It is anonymous because
    the reference is never assigned to an identifier. It can only be used in the method
    call. We do this in situations where the action to be performed is unique for
    just this button press. It cannot be reused elsewhere:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个片段演示了一个匿名内部类。它是匿名的，因为引用从未分配给一个标识符。它只能在方法调用中使用。我们在动作对仅此按钮按下是独特的情况下这样做。它不能在其他地方重用：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This second fragment uses lambda notation. There is only one method, `handle`,
    in `EventHandler`. Therefore, we do not require additional decorations. `(ActionEvent
    event)` is the parameter that the `handle` method must receive. Our lambda is
    providing the code for the `handle` method that will execute when the button is
    pressed. While there is no limit to the number of lines of code that can be in
    a lambda, the best practice is no more than three, while just one line is preferred.
    But what if multiple lines need to be executed? This leads us to the third syntax
    for using a function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个片段使用了lambda表达式。`EventHandler`中只有一个方法，`handle`。因此，我们不需要额外的装饰。`(ActionEvent
    event)`是`handle`方法必须接收的参数。我们的lambda提供了当按钮被按下时将执行的`handle`方法的代码。虽然lambda中的代码行数没有限制，但最佳实践是不超过三行，而一行是最理想的。但如果需要执行多行代码呢？这让我们来到了使用函数的第三种语法：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Functions in Java can be passed as a parameter to a method and can also be
    returned by a method. In this fragment, we are stating that the `signInButtonHandler`
    method will be invoked as if it were the `handle` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的函数可以作为方法的参数传递，也可以由方法返回。在这个片段中，我们声明`signInButtonHandler`方法将被调用，就像它是`handle`方法一样：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, this method is in the same file. Therefore, we are referring to it with
    `this` in `setOnAction`. It must have the same return value and parameters as
    the `handle` method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，这个方法在同一文件中。因此，我们在`setOnAction`中使用`this`来引用它。它必须与`handle`方法有相同的返回值和参数。
- en: Functional programming helps to simplify our code. In any situation where we
    need a method whose action must be defined where it will be used, then using functions
    is the best choice.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程有助于简化我们的代码。在任何需要定义其操作的地方的方法的情况下，使用函数是最好的选择。
- en: Using streams in collections
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集合中使用流
- en: Processing all data elements in a collection is a common action. Maybe you want
    to extract a subset of the collection based on a specific requirement. You might
    want to increase or decrease values or change the case of strings. This is where
    streams come in. All classes that implement the `Collection` interface have a
    stream method from which we can chain numerous stream methods. You cannot use
    streams directly on maps, but if you convert a map into a set, then you can use
    streams.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 处理集合中的所有数据元素是一个常见操作。也许你想根据特定要求提取集合的子集。你可能想增加或减少值或更改字符串的大小写。这就是流发挥作用的地方。所有实现
    `Collection` 接口的类都有一个流方法，我们可以从其中链式调用多个流方法。你不能直接在映射上使用流，但如果你将映射转换成集合，那么你可以使用流。
- en: 'One important characteristic of stream methods is that they operate as pure
    functions. A pure function does not change the state of any fields in the class
    or any of the parameters passed to it. A stream method always returns a new stream.
    The original stream has not changed. Let’s see how this works:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 流方法的一个重要特征是它们作为纯函数操作。纯函数不会改变类中任何字段的状态或传递给它的任何参数的状态。流方法始终返回一个新的流。原始流没有改变。让我们看看它是如何工作的：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we have a record that contains fields that represent information on an
    employee. Now, let’s create a `List` of six employees. This information should
    come from a database, but for our purposes, we will create the `List` in the constructor
    of the `StreamsExample.java` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含表示员工信息的字段的记录。现在，让我们在 `StreamsExample.java` 文件的构造函数中创建一个包含六个员工的 `List`。这些信息应该来自数据库，但出于我们的目的，我们将在
    `StreamsExample.java` 文件的构造函数中创建这个 `List`：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code demonstrates that an array, not a collection, can be created by listing
    the elements separated by commas when declared in a block. There are six `Employee`
    objects created, and by using the `Arrays` method `asList`, they are converted
    into a `List`-compatible structure. This is necessary as streams do not work on
    arrays. With our list complete, we can now apply the methods available to streams.
    Many of the stream methods behave in a similar manner to SQL actions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了在声明时通过逗号分隔元素可以创建一个数组，而不是集合。创建了六个 `Employee` 对象，并通过使用 `Arrays` 方法的 `asList`，它们被转换成与
    `List` 兼容的结构。这是必要的，因为流不作用于数组。随着我们的列表完成，我们现在可以应用流方法。许多流方法的行为与 SQL 操作类似。
- en: 'With the list in place, let’s use some of the stream methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表就绪后，让我们使用一些流方法：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After we call upon `stream()`, we can apply the stream methods. The first one
    is `filter`. It requires a function that can return `true` or `false` depending
    on the code in the function. The function is expressed as a lambda that will receive
    a record object of type `Employee`. The code in the lambda retrieves the `firstName`
    string from the record and applies the `startsWith` string method to find names
    that begin with `"J"`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `stream()` 之后，我们可以应用流方法。第一个是 `filter`。它需要一个函数，该函数根据函数中的代码返回 `true` 或 `false`。该函数以
    lambda 表达式的形式表达，将接收一个类型为 `Employee` 的记录对象。lambda 表达式中的代码从记录中检索 `firstName` 字符串，并应用
    `startsWith` 字符串方法以找到以 `"J"` 开头的名字。
- en: The result from `filter` is a new stream with only the objects that match the
    criteria. A stream must be converted back into a collection, and that is the role
    of the `collect` method. It takes as its argument the `Collectors.toList()` function
    from the `Collectors` class that will return a `List` object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数的结果是一个只包含符合条件对象的新流。必须将流转换回集合，这正是 `collect` 方法的角色。它接受 `Collectors.toList()`
    函数作为参数，该函数来自 `Collectors` 类，并将返回一个 `List` 对象。'
- en: 'One last example, and that is to print out the employee objects in order sorted
    by the `lastName` field:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，是要按 `lastName` 字段排序打印员工对象：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This line of code uses the `sorted` stream function. It requires a function
    that determines the order of two objects based on a field. The field chosen is
    a `String` object, so it already has a `compareTo` method; otherwise, you will
    need to write a `compareTo` method. The lambda expression takes two parameters
    that are defined as `String` objects from the `Record`. This will produce a stream
    in sorted order that is then used by the `forEach` function. Rather than return
    a new `List` object, the `forEach` function receives a stream and passes each
    member of it to the `println` method of `System.out`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用了`sorted`流函数。它需要一个基于字段的函数来确定两个对象之间的顺序。所选择的字段是一个`String`对象，因此它已经有一个`compareTo`方法；否则，您将需要编写一个`compareTo`方法。lambda表达式接受两个参数，这些参数被定义为来自`Record`的`String`对象。这将产生一个排序后的流，然后由`forEach`函数使用。`forEach`函数不是返回一个新的`List`对象，而是接收一个流，并将它的每个成员传递给`System.out`的`println`方法。
- en: Modern Java programs rely heavily on streams. The alternative is to use iterators
    or `for` loops to access all elements. If you need to process all elements in
    a collection, look at streams before anything else.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Java程序在很大程度上依赖于流。另一种选择是使用迭代器或`for`循环来访问所有元素。如果您需要处理集合中的所有元素，请在其他任何东西之前查看流。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While we appear to have covered a lot of topics in this chapter, you should
    recognize that they are all related. Whether you are retrieving records from a
    database or receiving user input from the keyboard, as soon as there is more than
    one item, you will need what has been presented here. We began with a basic array
    that is like a structure in other languages. From the array, we moved on to the
    Collections Framework. These are dynamic structures that can grow as needed. From
    the sequential to the map collections, Java provides us with a rich set of choices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们似乎在本章中涵盖了众多主题，但您应该认识到它们都是相关的。无论您是从数据库中检索记录还是从键盘接收用户输入，一旦有多个项目，您将需要这里所展示的内容。我们从类似于其他语言中的结构的基本数组开始。从数组，我们转向了集合框架。这些是动态结构，可以根据需要增长。从顺序集合到映射集合，Java为我们提供了一套丰富的选择。
- en: We looked at Generics next. Unlike an array that is declared as a specific type,
    raw collections can store any object without regard to what has already been stored.
    Using generic notation, we can tie a collection to a specific data type.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来探讨了泛型。与声明为特定类型的数组不同，原始集合可以存储任何对象，而不考虑已经存储的内容。使用泛型表示法，我们可以将一个集合绑定到特定的数据类型。
- en: Starting with Java 8, functions became part of the Java language. While ordinary
    methods in a class can be used as a function, the use of lambdas allows us to
    define specific actions for a particular problem. The Stream library, available
    in sequential collections, simplifies processing the elements of a collection.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 8开始，函数成为了Java语言的一部分。虽然类中的普通方法可以用作函数，但使用lambda表达式允许我们为特定问题定义特定的操作。在顺序集合中可用的Stream库简化了对集合元素的处理。
- en: Next up, we will examine how we can document our code and record information
    on the operation of our program in logs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何记录我们的代码，并在日志中记录程序的操作信息。
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Guide to the java.util.Arrays* *class*: [https://www.baeldung.com/java-util-arrays](https://www.baeldung.com/java-util-arrays)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*java.util.Arrays* *类指南*: [https://www.baeldung.com/java-util-arrays](https://www.baeldung.com/java-util-arrays)'
- en: '*Collections in* *Java*: [https://www.scaler.com/topics/java/collections-in-java/](https://www.scaler.com/topics/java/collections-in-java/)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java* *集合*: [https://www.scaler.com/topics/java/collections-in-java/](https://www.scaler.com/topics/java/collections-in-java/)'
- en: '*Functional Programming in* *Java*: [https://www.scaler.com/topics/java/functional-programming-in-java/](https://www.scaler.com/topics/java/functional-programming-in-java/)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java* *中的函数式编程*: [https://www.scaler.com/topics/java/functional-programming-in-java/](https://www.scaler.com/topics/java/functional-programming-in-java/)'
- en: '*Java* *Stream*: [https://zetcode.com/java/stream/](https://zetcode.com/java/stream/)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java* *Stream*: [https://zetcode.com/java/stream/](https://zetcode.com/java/stream/)'
