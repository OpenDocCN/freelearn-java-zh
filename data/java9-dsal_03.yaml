- en: Chapter 3. Protocols – Abstract Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。协议 - 抽象数据类型
- en: In the last chapter, we saw a few basic data structures and some algorithms
    to manipulate them. However, sometimes we may want to hide the implementation
    details of a data structure and only want to know how they interact with other
    algorithms. We may want to specify a few operations that they must allow and forget
    about how they are achieved. This is not very different from abstraction of a
    part of a program in any large software application. For example, in Java, we
    create interfaces that only define the methods of an object that its class must
    implement, and then we use this interface type, being confident that they will
    be implemented properly. We do not want to think about how an implementation class
    would provide their implementation. Such interfaces of data structure are called
    abstract data types. To put this another way, an **abstract data type** (**ADT**)
    is a description of what a data structure should do for its user. It is a list
    of operations that any implementation must support and the complete description
    of what these operations are supposed to do. A few of these have very frequent
    usage and have names given to them. We will discuss a few of these here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了一些基本的数据结构和一些操作它们的算法。然而，有时我们可能想要隐藏数据结构的实现细节，只想知道它们如何与其他算法交互。我们可能只想指定它们必须允许的一些操作，并忘记它们是如何实现的。这与任何大型软件应用中程序部分抽象并不太不同。例如，在Java中，我们创建接口，只定义一个对象类必须实现的方法，然后我们使用这种接口类型，有信心它们将被正确实现。我们不想考虑实现类会如何提供它们的实现。这种数据结构的接口被称为抽象数据类型。换句话说，一个**抽象数据类型**（ADT）是对数据结构应该为用户做什么的描述。它是一系列任何实现都必须支持的运算，以及这些运算的完整描述。其中一些使用非常频繁，并且被赋予了名称。我们将在下面讨论一些这些。
- en: 'In this chapter, you will learn about the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下概念：
- en: The definition of some common ADTs and their operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些常见ADT及其操作的定义
- en: How to implement these ADTs using both simple arrays and the data structures
    you learned in the last chapter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用简单的数组和上一章中学习的数据结构来实现这些ADT
- en: Stack
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: A **stack** is a very commonly used ADT. It is so named because it resembles
    a stack of plates used in a restaurant. In such a stack, a plate that has been
    washed and put last would stay on top. This would be the first plate to be picked
    up when a plate is needed. The plate that went in first would be at the bottom
    of the stack and would be picked last. So, the last plate to be placed in the
    stack is the first plate to get out, we can also call this **last in first out**
    (**LIFO**).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**是一个非常常用的抽象数据类型（ADT）。它之所以被这样命名，是因为它类似于餐厅里用来堆叠的盘子。在这样的堆叠中，最后被清洗并放置的盘子会保持在顶部。当需要盘子时，这个盘子将是第一个被取出的。最先放入的盘子将位于堆叠的底部，将是最后一个被取出的。因此，最后放入堆叠的盘子是第一个被取出的，我们也可以称之为**后进先出**（LIFO）。'
- en: 'Similarly, a stack ADT has a protocol where the last value that is put in it
    must be returned on the first attempt to get a value out, and the value that went
    in first must come out last. The following figure will make it more clear:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，栈ADT有一个协议，其中最后放入的值必须在第一次尝试获取值时返回，而最先放入的值必须最后出来。下面的图将使它更清晰：
- en: '![Stack](img/00018.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![栈](img/00018.jpeg)'
- en: The operation of putting a new value in a stack is called push, and the operation
    of retrieving a value from a stack is called pop. The element that was pushed
    last must be popped first. The operation that allows one to see what the next
    pop will return is called peek. The peek operation returns the top element without
    modifying the stack. We expect all stack implementations to have all operations
    implemented in the time complexity of *O(1)*. This is also part of our stack protocol.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将新值放入栈的操作称为push，从栈中检索值的操作称为pop。最后被推入的元素必须首先弹出。允许一个人看到下一个弹出将返回什么的操作称为peek。peek操作返回栈顶元素而不修改栈。我们期望所有栈实现都具有所有操作在时间复杂度为*O(1)*的情况下实现。这也是我们栈协议的一部分。
- en: 'The stack ADT has the following operations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 栈ADT有以下操作：
- en: '**Push**: This adds an element at the top of the stack'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Push**：这个操作在栈顶添加一个元素'
- en: '**Pop**: This removes the element at the top of the stack'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pop**：这个操作移除栈顶的元素'
- en: '**Peek**: This checks the next value to be popped'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Peek**：这个操作检查将要弹出的下一个值'
- en: 'Since we know that ADTs are to data structures what interfaces are to classes,
    we will code an ADT as an interface. The following is our interface for a stack:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道ADT是数据结构对类的作用，就像接口对类的作用一样，我们将用接口编写ADT。以下是我们为栈编写的接口：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, we will not leave it at this. We will see how a stack can actually
    be implemented. To this end, we will see both a fixed-sized stack using an array
    to store it's data, and a growing stack using a linked list for storing data.
    We will start with the first.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不会就此止步。我们将看到如何实际实现一个栈。为此，我们将看到使用数组存储数据的固定大小栈，以及使用链表存储数据的增长栈。我们首先从第一个开始。
- en: Fixed-sized stack using an array
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组的固定大小栈
- en: A fixed-sized stack uses a pre-allocated array to store values, that is when
    this stack has used up the entire array, it can no longer accept new values until
    the old ones are popped. This is not very different from an actual stack of plates,
    which most certainly has a maximum height that it can handle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小的栈使用预分配的数组来存储值，也就是说，当这个栈用完了整个数组，它就不能再接受新的值，直到旧的值被弹出。这与实际的盘子栈没有太大区别，盘子栈肯定有一个它能处理的最大高度。
- en: 'As always, we start with the basic structure of the class, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先从类的基本结构开始，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need an array to store the elements, and we need to remember where the top
    of the stack is in that array. The top always marks the index of the element that
    will be popped next. When there are no more elements to be popped, it is set to
    `-1`. Why `-1`? Because this is the natural choice as it does not require any
    special handling when the first element is inserted:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个数组来存储元素，并且我们需要记住栈顶在那个数组中的位置。栈顶总是标记下一个将被弹出的元素的索引。当没有更多元素要弹出时，它被设置为`-1`。为什么是`-1`？因为这是自然的选择，当第一个元素被插入时不需要任何特殊处理：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `push` operation in a stack can be to simply put the value in the array
    right next to the current `top` and then set the `top` to the new position, as
    illustrated in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 栈中的`push`操作可以是简单地将值放入数组中当前`top`旁边，然后将`top`设置为新的位置，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We first check whether the stack is already full or the current `top` is equal
    to the maximum index possible, like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查栈是否已经满了，或者当前的`top`是否等于可能的最大索引，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we set the `top` to the new position and put the value we need to store
    in there as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`top`设置为新的位置，并将我们需要存储的值放入其中，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The exception we used is a custom exception for this purpose. The code of the
    exception is simple as shown in the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的异常是为此目的定制的异常。异常的代码很简单，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `pop` operation is just the opposite. We need to first take the value of
    the current `top` and then update the `top` to the new position, which is one
    less than the current position, as shown in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop`操作正好相反。我们需要首先获取当前`top`的值，然后将`top`更新到新的位置，这个位置比当前的位置少一个，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We first check whether the stack is already empty, in which case we return
    a special value, `null`. This is shown in the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查栈是否已经为空，如果是，我们返回一个特殊值`null`。如下面的代码所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we update the `top` and return the value at the current `top` as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们更新`top`并返回当前`top`的值，如下所示：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `peek` operation does not change the state of the stack, and hence is even
    simpler:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek`操作不会改变栈的状态，因此它甚至更简单：'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just like the `pop` operation, we return `null` if the stack is empty:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`pop`操作一样，如果栈为空，我们返回`null`：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Otherwise, we return the `top` element, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们返回`top`元素，如下所示：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is in fact possible to have a stack without an upper limit backed up by an
    array. What we really need to do is that whenever we run out of space, we can
    resize the array. Array actually cannot be resized, so the operation would be
    to create a new array with a higher size (maybe twice as much as the original
    size), and copy all the old elements into this array. Since this involves copying
    all the *n* elements to the new array one by one, the complexity of this operation
    is *O(n)*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以有一个没有上限的栈，它由数组支持。我们真正需要做的是，每次我们用完空间时，我们可以调整数组的大小。实际上，数组是不能调整大小的，所以操作就是创建一个具有更高大小的新的数组（可能比原始大小大一倍），并将所有旧元素复制到这个数组中。由于这个操作涉及到将所有*n*个元素逐个复制到新数组中，这个操作的复杂度是*O(n)*。
- en: Variable-sized stack using a linked list
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链表的变长栈
- en: 'The problem with an array-based implementation is that since arrays are fixed
    in size, the stacks cannot grow beyond a fixed-size. To resolve this, we have
    to do what we did to fix the same problem for an array, that is, use a linked
    list instead. We start such an implementation with the following bare bone class.
    The linked list will store the values. Instead of assigning a new linked list
    to it, we do so using an overridable method `getNewLinkedList()`. This will be
    useful in the class that extends from this one:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数组的实现的问题在于，由于数组的大小是固定的，栈不能超过固定的大小。为了解决这个问题，我们必须做我们为解决数组相同问题所做的事情，即使用链表。我们从一个以下这样的裸骨类开始这样的实现。链表将存储值。我们不是给它分配一个新的链表，而是使用可重写的`getNewLinkedList()`方法来这样做。这将在从该类扩展的类中很有用：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To see which end of the linked list must be used as the top of the stack, we
    need to remember that our stack protocol expects the operations to be *O(1)*,
    so we must choose an end that allows both insertion and removal in *O(1)* time.
    That end is of course the front of the list as we saw in the last chapter. This
    makes the following code for the `push` operation self-explanatory:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到哪个链表端必须用作栈顶，我们需要记住我们的栈协议期望操作是*O(1)*，因此我们必须选择一个允许在*O(1)*时间内插入和删除的端。当然，这个端就是列表的前端，正如我们在上一章所看到的。这使得以下`push`操作的代码变得不言自明：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that this time, we did not check whether the stack is full because this
    implementation of the stack is never full, it grows as it needs and the underlying
    linked list takes care of that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次，我们没有检查栈是否已满，因为这种栈的实现永远不会满，它会根据需要增长，而底层的链表会处理这一点。
- en: 'The `pop` operation, however, does need to check whether the stack is empty
    and return `null` at that point. The following code for the `pop` operation is
    also quite self-explanatory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`pop`操作确实需要检查栈是否为空，并在该点返回`null`。以下`pop`操作的代码也是相当直观的：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `peek` operation is, of course, the same, except it does not remove the
    top element:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek`操作当然是一样的，只不过它不会移除顶部元素：'
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This concludes our linked list-based implementation of a stack. In the next
    section, we will check out another ADT called a **queue**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的基于链表的栈实现。在下一节，我们将检查另一个称为**队列**的ADT。
- en: Queue
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: 'What is the opposite of a stack? This may be a weird question. However, a stack
    follows LIFO, last in first out. The opposite of that is **first-in-first-out**
    (**FIFO**). So, in some sense, a FIFO ADT can be considered as the opposite of
    a stack. This is not very different from a queue of people waiting for a bus or
    at a doctor''s clinic. The first person to show up gets the first chance to get
    onto the bus or to get to see the doctor. The second person gets the second chance.
    No wonder, such an abstract data type is called a queue. Appending to the end
    of a queue is called **enqueuing** and removing from it is called **dequeuing**.
    The contract is, of course, that the first value that is enqueued would be the
    first to be dequeued. The following figure illustrates this operation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的反面是什么？这可能是一个奇怪的问题。然而，栈遵循LIFO（后进先出）。其对立面是**先进先出**（**FIFO**）。因此，在某种意义上，FIFO
    ADT可以被认为是栈的对立面。这与人们排队等公交车或医生诊所的情况没有太大区别。第一个到达的人将首先有机会上公交车或看医生。第二个人将获得第二个机会。难怪，这样一个抽象数据类型被称为队列。将元素添加到队列的末尾称为**入队**，从队列中移除称为**出队**。当然，合同是，首先入队的值将是第一个出队的值。以下图示说明了这个操作：
- en: '![Queue](img/00019.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![队列](img/00019.jpeg)'
- en: 'The queue ADT has the following operations:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 队列抽象数据类型（ADT）具有以下操作：
- en: '**Enqueue**: This adds an element at the back of the queue'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入队**: 这将在队列的末尾添加一个元素'
- en: '**Dequeue**: This removes an element from the front of the queue'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出队**: 这将从队列的前端移除一个元素'
- en: '**Peek**: This checks the element that would be dequeued next'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看**: 这将检查下一个出队的元素'
- en: 'The queue will be represented by the following interface:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 队列将由以下接口表示：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Fixed-sized queue using an array
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组实现的固定大小队列
- en: 'Just like the stack, we have an array-based implementation of a queue. However,
    since a queue receives new values and removes old values from opposite sides,
    the body of the queue moves as it does. The following figure will illustrate this
    point:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就像栈一样，我们有一个基于数组的队列实现。然而，由于队列从相对的两端接收新值和移除旧值，队列的主体也会移动。以下图示将说明这一点：
- en: '![Fixed-sized queue using an array](img/00020.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用数组实现的固定大小队列](img/00020.jpeg)'
- en: This means that after a sequence of a few such operations, the end of the queue
    will reach the end of the array, and there will be space left at the beginning
    of the array. At this point, we don't want to stop receiving new values as there
    is space left, so we roll over to the beginning of the array. That is to say,
    we continue adding the new values at the beginning of the array.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在一系列这样的操作之后，队列的末尾将到达数组的末尾，数组开头将留下空间。在这个时候，我们不想停止接收新值，因为还有空间，所以我们回滚到数组的开头。也就是说，我们继续在数组的开头添加新值。
- en: 'To do all these manipulations, we must have separate variables storing the
    indexes of the beginning and the end of the queue. Also, since due to roll over,
    sometimes the end is smaller than the beginning, we store the length separately
    to avoid confusion. We start with the bare bone implementation of the class just
    as before. The start represents the index of the element that would be dequeued
    next and the end represents the position of the next value that would be enqueued.
    This is illustrated in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行所有这些操作，我们必须有单独的变量来存储队列起始和结束的索引。此外，由于回滚，有时末尾的索引可能小于起始索引，因此我们单独存储长度以避免混淆。我们像之前一样从类的基本实现开始。起始表示下一个将被出队的元素的索引，而结束表示下一个将要入队的值的索引。这在下述代码中说明：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `enqueue` operation does not change the start position. The new value is
    put at the end position of the array and the end is incremented by one. The end,
    of course, needs to be rolled over in case it goes beyond the maximum index of
    the array, as shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue` 操作不会改变起始位置。新值被放置在数组的末尾，然后末尾增加一。当然，如果末尾超过了数组的最大索引，需要将其回滚，如下述代码所示：'
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The modulo operator will make sure that the index goes to the beginning of
    the array when it hits the `end` of the array, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算符将确保当索引到达数组的 `end` 时，它会回到数组的开头，如下所示：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `dequeue` operation does not change the end position. We read from the
    start index and then increment the start index with rollover, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue` 操作不会改变末尾位置。我们从起始索引读取，然后带回滚增加起始索引，如下所示：'
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `peek` operation lets us see the element that would be dequeued next, without
    removing it. It is, of course, simpler. We just return the next element to be
    dequeued. This is shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek` 操作允许我们查看下一个将被出队的元素，而不移除它。当然，这很简单。我们只需返回下一个将被出队的元素。这在下述代码中显示：'
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A queue backed up by an array can be resized in a similar manner as described
    for the case of a stack, and this too will be *O(n)*, since we must copy all the
    old elements to the newly allocated array one by one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由数组支持的队列可以以类似于描述栈的方式调整大小，这同样将是 *O(n)*，因为我们必须逐个将所有旧元素复制到新分配的数组中。
- en: Variable-sized queue using a linked list
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链表的变量大小队列
- en: Just like a stack, we want to implement a queue using a linked list. We need
    to remember that all operations must be *O(1)* in running time. If we enqueue
    by appending new elements at the beginning of the linked list, we will need to
    remove elements from the end of the list during dequeuing. This will not work
    as removal of an element from the end of a linked list is *O(n)*. But appending
    at the end of a linked list is *O(1)* and so is removing from the beginning of
    the list. Hence, the end of the queue, where new elements are enqueued, would
    be the end of the list. And the start of the queue, where the elements are dequeued
    from, would be the beginning of the linked list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像栈一样，我们希望使用链表来实现一个队列。我们需要记住，所有操作都必须在运行时达到 *O(1)*。如果我们通过在链表开头添加新元素来入队，那么在出队时我们需要从链表末尾移除元素。这行不通，因为从链表末尾移除元素是
    *O(n)*。但是，在链表末尾添加元素是 *O(1)*，同样从链表开头移除也是 *O(1)*。因此，队列的末尾，即新元素入队的地方，将是链表的末尾。而队列的起始处，即元素出队的地方，将是链表的开头。
- en: 'Given this, the implementation of a queue using a linked list is straightforward.
    Again, we create an instance of the list only using a `getNewLinkedList()` method,
    which can be overridden by a subclass to use a different linked list, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，使用链表实现队列的实现是直接的。再次强调，我们通过仅使用 `getNewLinkedList()` 方法创建列表的实例，这个方法可以被子类覆盖以使用不同的链表，如下所示：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `enqueue` operation simply appends at the end of the list as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue` 操作简单地如下在列表末尾添加元素：'
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `dequeue` operation first checks if the list is empty so it can return
    `null`, and then it simply removes the first element from the list. It must also
    return the element that it just removed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作首先检查列表是否为空，以便它可以返回`null`，然后它简单地从列表中移除第一个元素。它还必须返回它刚刚移除的元素：'
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just like the `dequeue` operation, the `peek` operation first needs to check
    whether the list is empty, in which case it has to return a `null` value, otherwise
    it simply returns the element at the beginning of the list that would be dequeued
    on the next `dequeue` operation, as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`dequeue`操作一样，`peek`操作首先需要检查列表是否为空，在这种情况下，它必须返回一个`null`值，否则它简单地返回列表中下一个`dequeue`操作将要出队的元素，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Double ended queue
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双端队列
- en: 'A double ended queue is a combination of a stack and a queue. The idea is that
    you are allowed to insert and remove elements at both ends of the queue. If you
    remove elements from the side you have inserted, it will behave like a stack.
    On the other hand, if you insert and remove on opposite ends, it will behave like
    a queue. You can mix these operations and use them in any order you like. The
    following figure shows a few operations to clarify this idea:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列是栈和队列的组合。想法是，你可以在队列的两端插入和移除元素。如果你从插入的一侧移除元素，它将表现得像栈。另一方面，如果你在相对的两端插入和移除，它将表现得像队列。你可以混合这些操作，并以你喜欢的任何顺序使用它们。以下图示显示了几个操作以阐明这个想法：
- en: '![Double ended queue](img/00021.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![双端队列](img/00021.jpeg)'
- en: 'A double ended queue has the following operations all with a complexity of
    *O(n)*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列有以下操作，所有操作的复杂度都是*O(n)*：
- en: '**Push**: This inserts an element at the beginning'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Push**：这从开始插入一个元素'
- en: '**Pop**: This removes an element from the beginning'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pop**：这从开始移除一个元素'
- en: '**Inject**: This inserts an element at the end'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Inject**：这在末尾插入一个元素'
- en: '**Eject**: This removes an element from the end'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eject**：这从末尾移除一个元素'
- en: '**Peek**: This checks the first element'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Peek**：这检查第一个元素'
- en: '**PeekLast**: This checks the last element'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PeekLast**：这检查最后一个元素'
- en: 'A double ended queue will be represented by the following interface:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列将由以下接口表示：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that since a double ended queue has `push` and `pop` operations just like
    a stack and it preserves the same meaning, we create this interface extending
    the `Stack` interface.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于双端队列具有与栈相同的`push`和`pop`操作，并且它保留了相同的意义，我们创建了这个接口，它扩展了`Stack`接口。
- en: Fixed-length double ended queue using an array
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组实现的固定长度双端队列
- en: 'Since we have created the double ended queue as an extension of a stack, one
    would expect its implementation to extend a stack implementation as well. However,
    remember that a double ended queue is both a stack and a queue. The array-based
    implementation for a queue was more complex than that for a stack due to rollover
    of the indexes. We don''t want to reprogram those, so we choose to extend a queue
    implementation instead of a stack implementation, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将双端队列视为栈的扩展，因此人们可能会预期其实现也会扩展栈的实现。然而，请记住，双端队列既是栈也是队列。由于索引的回滚，基于数组的队列实现比栈的实现更复杂。我们不希望重新编程这些，因此我们选择扩展队列实现而不是栈实现，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We initialize the queue to the fixed length, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将队列初始化为固定长度，如下所示：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is appended at the end of the double ended queue, which is the same as
    the `enqueue` operation of a queue:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这被添加到双端队列的末尾，这与队列的`enqueue`操作相同：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `eject` operation is the removal of an element from the end of the double
    ended queue. We don''t have an equivalent operation in a simple queue. So, we
    must code for it as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`eject`操作是从双端队列的末尾移除一个元素。在简单的队列中没有等效的操作。因此，我们必须像以下这样为其编写代码：'
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `end` has to decrement by one with a provision for rollover. But if the
    `end` is already at zero, it will become negative, which will not work well with
    the modulo operator, because it will return a negative value. To always keep it
    positive, we add the length of the array to it. Note that it does not change the
    remainder when divided by the length of the array. This is shown in the following
    code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`end`必须减一，并考虑到回滚。但是，如果`end`已经为零，它将变成负数，这不会很好地与模运算符一起工作，因为它将返回一个负值。为了始终保持其正值，我们将其添加到数组的长度。请注意，这不会改变除以数组长度时的余数。以下代码显示了这一点：'
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `peekLast` operation simply needs to return the element that would have
    been returned by the `eject` operation without modifying anything, as shown in
    the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: peekLast操作只需简单地返回eject操作将返回的元素，而不做任何修改，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `push` operation is the insertion of an element at the beginning of the
    double ended queue. There is no equivalent operation in a simple queue. Hence,
    we need to code for it as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: push操作是在双端队列的开头插入一个元素。在简单队列中没有等效的操作。因此，我们需要如下编写代码：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This operation is very similar to updating the end index `eject` operation,
    as shown in the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作与更新末尾索引的eject操作非常相似，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `pop` operation is the removal of the element at the beginning of the queue,
    which is the same as the `dequeue` operation of an ordinary queue. This is illustrated
    in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: pop操作是移除队列开头的元素，这与普通队列的dequeue操作相同。如下面的代码所示：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that we don't write any code for the peek operation, which should return
    the element at the beginning of the double ended queue, as it is the same as the
    peek operation for a simple queue.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为peek操作编写任何代码，因为这个操作应该返回双端队列开头的元素，因为它与简单队列的peek操作相同。
- en: The array-based implementation is, of course, fixed in size and cannot hold
    more elements than it's fixed size. Next, we develop a linked list-based implementation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数组的实现当然是固定大小的，不能容纳比其固定大小更多的元素。接下来，我们开发基于链表的实现。
- en: Variable-sized double ended queue using a linked list
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链表的变量大小双端队列
- en: We had earlier used a simple linked list to implement both a queue and a stack.
    However, remember again that all operations must be *O(1)*. Now, we must both
    add and remove elements at both ends of the underlying linked list. We know that
    removal from the end of a singly linked list is *O(n)* and we cannot use it. So,
    we must use a doubly linked list instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用简单的链表实现了队列和栈。然而，请再次记住，所有操作都必须是*O(1)*。现在，我们必须在底层链表的两侧添加和移除元素。我们知道从单链表的末尾移除是*O(n)*，我们不能使用它。因此，我们必须使用双链表。
- en: 'This time we do not have to worry about rollovers and so we will extend the
    linked list implementation of a stack, which is the natural choice. We will replace
    its singly linked list with a doubly linked list by overriding the `getLinkedList()`
    method, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不必担心回滚，因此我们将扩展栈的链表实现，这是自然的选择。我们将通过重写getLinkedList()方法将其单链表替换为双链表，如下所示：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `inject` operation inserts a new element at the end of the list as shown
    in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: inject操作将新元素插入到列表的末尾，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `eject` operation must remove and return the last element of the list.
    This is illustrated in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: eject操作必须移除并返回列表的最后一个元素。如下面的代码所示：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, the `peekLast()` method will just return the last element of the doubly
    linked list as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，peekLast()方法将简单地返回双链表的最后一个元素，如下所示：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We only had to implement the `inject()`, `eject()`, and `peekLast()` methods
    as the other methods are already implemented by the stack we extend.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要实现inject()、eject()和peekLast()方法，因为其他方法已经被我们扩展的栈实现了。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw that an abstract data type or ADT is an abstraction
    of a data structure. It is a contract that an underlying data structure is supposed
    to adhere to. The contract involves different operations on the data structure
    and their specific behavior. We then saw a few simple ADTs as examples. These
    ADTs are, however, extremely useful as we will see in the course of this book
    when we encounter other algorithms. Abstraction allows different implementations
    of the structures. We will also see more ADTs in the course of this book and their
    implementations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到抽象数据类型或ADT是数据结构的抽象。它是一个约定，即底层数据结构应该遵守的。该约定涉及数据结构上的不同操作及其特定行为。然后我们看到了几个简单的ADT作为示例。然而，这些ADT非常实用，正如我们在本书的其余部分遇到其他算法时将看到的那样。抽象允许不同的结构实现。我们还将在本书中看到更多的ADT及其实现。
- en: In the next chapter, we will take a detour into a new area of algorithms called
    **functional programming**. Remember that an algorithm is a sequence of steps
    that may be followed to achieve a desired processing; it turns out that there
    is another way of looking at it, which we will explore in the next chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向一个新的算法领域，称为**函数式编程**。请记住，算法是一系列可能遵循以实现所需处理的步骤；事实证明，还有另一种看待它的方式，我们将在下一章中探讨。
