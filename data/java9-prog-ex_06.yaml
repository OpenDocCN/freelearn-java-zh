- en: Making Our Game Professional - Do it as a Webapp
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们的游戏变得专业 - 以Web应用程序的形式来实现
- en: In this chapter, we will program a web application. We will build on what we
    have achieved already and create a web version of the Mastermind game. This time,
    it will not only run alone, guessing and answering the number of positions and
    matched colors, but also communicate with the user asking for the answers to the
    guesses. This will be a real game. Web programming is extremely important for
    Java programmers. Most of the programs are web applications. The universal client
    available on the Internet is the web browser. The thin-client, web browser-based
    architecture is widely accepted in enterprises as well. There are only some exceptions
    when the architecture has something else but the web client. If you want to become
    a professional Java developer, you must be familiar with web programming. And
    it is also fun!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个Web应用程序。我们将基于我们已经取得的成果，创建一个Mastermind游戏的Web版本。这次，它不仅会独立运行，猜测并回答位置数和匹配颜色，还会与用户沟通，请求猜测的答案。这将是一个真正的游戏。对于Java程序员来说，Web编程极其重要。大多数程序都是Web应用程序。互联网上可用的通用客户端是Web浏览器。基于瘦客户端、Web浏览器架构在企业中得到了广泛接受。只有当架构有其他东西而不是Web客户端时，才会有一些例外。如果你想成为一名专业的Java开发者，你必须熟悉Web编程。而且这也很有趣！
- en: 'There are a lot of technical topics that we will visit during the development.
    First of all, we will discuss networking and web architecture. This is the concrete
    base of the whole building. It is not too sexy, just like when you construct the
    building. You spend a lot of money and effort digging trenches, and then you bury
    the concrete and end up at the end of the phase with what you seemingly had before:
    flat ground. Except that there is the base. Building without this base, the house
    would either collapse soon after or during the process of building. Networking
    is just as important for web programming. There are a lot of topics that seemingly
    have nothing to do with programming. Still, it is the base of the building and
    when you program web applications, you will also find the fun part in it.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们将探讨许多技术主题。首先，我们将讨论网络和Web架构。这是整个建筑的具体基础。它并不太吸引人，就像你建造大楼时一样。你花费大量的金钱和努力挖掘沟渠，然后埋下混凝土，最终在阶段结束时得到你看似之前就有的平坦地面。只不过这次有了基础。没有这个基础，房子要么很快就会倒塌，要么在建造过程中倒塌。网络对于网络编程同样重要。有很多看似与编程无关的主题。尽管如此，它是建筑的基础，当你编写Web应用程序时，你也会在其中找到乐趣的部分。
- en: We will also talk a bit about HTML, CSS, and JavaScript, but not too much. We
    cannot avoid them because they are also important for web programming, but they
    are topics that you can learn from somewhere else as well. In case you are not
    an expert in some of these areas, there are usually other experts in enterprise
    project teams who can extend your knowledge. (In the case of networking, there
    is no mercy.) In addition to that, JavaScript is a topic so complex and huge that
    it deserves a whole book to start with it. There are only very few experts who
    deeply understand both Java and JavaScript. I understand the general structure
    of the language and the environment it runs in, but I cannot keep up with the
    new frameworks that are released every week these days, having my focus on other
    areas.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也会简单谈谈HTML、CSS和JavaScript，但不会过多。我们无法避免它们，因为它们对于网络编程同样重要，但它们也是你可以从其他地方学习的内容。如果你在这些领域不是专家，企业项目团队中通常有其他专家可以扩展你的知识。（在网络方面，没有宽容可言。）此外，JavaScript是一个如此复杂和庞大的主题，以至于它值得从一本整本书开始学习。只有极少数专家能够深入理解Java和JavaScript。我理解语言的总体结构和它运行的环境，但鉴于我专注于其他领域，我无法跟上每周发布的新的框架。
- en: You will learn how to create Java applications that run in an application server,
    this time in Jetty, and we will see what a servlet is. We will create a web *hello
    world* application to start up fast, and then we will create the servlet version
    of Mastermind. Note that we hardly ever program servlets directly without the
    aid of some framework that implements the code to handle parameters, authentication,
    and many other things that are not application-specific. We will still stick to
    a naked servlet in this chapter because it is not possible to effectively use
    frameworks, such as Spring, without first understanding what a servlet is. Spring
    will come in the next chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何创建在应用服务器上运行的 Java 应用程序，这次是在 Jetty 上，我们将了解什么是 servlet。我们将创建一个快速启动的 Web
    *hello world* 应用程序，然后我们将创建 Mastermind 的 servlet 版本。请注意，我们几乎从不直接编写 servlet，而不借助某些实现处理参数、认证以及许多其他非特定于应用程序的框架。在本章中，我们仍将坚持使用裸露的
    servlet，因为如果不首先了解什么是 servlet，就无法有效地使用框架，如 Spring。Spring 将在下一章中介绍。
- en: We will mention **Java Server Pages** (**JSP**) only because you may meet some
    legacy application, which was developed using that technology, but modern web
    applications do not use JSP. Still, JSP is a part of the servlet standard and
    is available for use. There are other technologies that were developed in the
    recent past but do not seem to be future-proof these days. They are still usable
    but appear only in legacy applications, and choosing them for a new project is
    fairly questionable. We will talk about these technologies shortly in a separate
    section.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提及 **Java 服务器页面**（**JSP**）仅因为你可能遇到一些使用该技术开发的遗留应用程序，但现代 Web 应用程序不使用 JSP。尽管如此，JSP
    是 servlet 标准的一部分，并且可供使用。还有一些最近开发的技术，但似乎在今天并不具备未来性。它们仍然可用，但只出现在遗留应用程序中，为新项目选择它们是相当可疑的。我们将在单独的部分中简要讨论这些技术。
- en: By the end of this chapter, you will understand how the basic web technology
    works and what the major architectural elements are, and you will be able to create
    simple web applications. This is not enough to be a professional Java web developer
    but will be a good grounding for the next chapter, where we will have a look at
    the professional frameworks used in today's enterprises for real application developments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解基本网络技术的工作原理以及主要架构元素是什么，你将能够创建简单的 Web 应用程序。这还不足以成为一名专业的 Java Web 开发者，但将为下一章打下良好的基础，在下一章中，我们将探讨当今企业在实际应用程序开发中使用的专业框架。
- en: Web and network
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和网络
- en: Programs run on computers, and computers are connected to the Internet. This
    network was developed in the last 60 years, first to provide military data communication
    that is resilient to rocket attack, then it was extended to be an academic network,
    and later it became a commercial network used by anyone and available almost ubiquitously
    all over the Earth.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在计算机上运行，计算机连接到互联网。这个网络在过去 60 年里发展起来，最初是为了提供对火箭攻击具有弹性的军事数据通信，然后它被扩展为一个学术网络，后来它成为任何人都可以使用的商业网络，几乎遍布地球的每个角落。
- en: The design of the network, and the research, started as a response to the flight
    of Gagarin over the Earth in the fifties. Sending Gagarin to space and travelling
    over the Earth was a demonstration that Russia could send a rocket anywhere on
    the globe, possibly with atomic explosives. It meant that any data network that
    needed some central control was not resilient to such an attack. It was not feasible
    to have a network with a central location as a single point of failure. Therefore,
    research was started to create a network that goes on working even if any part
    of it is brought down.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的设计和研究始于对五十年代加加林飞越地球的反应。将加加林送入太空并在地球上方飞行是俄罗斯能够将火箭发射到地球上任何地方的证明，可能带有原子弹。这意味着任何需要某种中央控制的数据网络都无法抵御这种攻击。拥有一个中心位置的单一故障点的网络是不可行的。因此，开始进行研究以创建即使任何部分被摧毁也能继续工作的网络。
- en: IP
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP
- en: The network delivers data packets between any two computers connected to it.
    The protocol used on the network is IP, which is simply an abbreviation of Internet
    Protocol. Using IP, a computer can send a data packet to another. The package
    contains a header and the data content. The header contains the Internet addresses
    of the sender and the target machine, other flags, and information about the package.
    Since the machines are not connected to each other directly, routers forward the
    packets. It is like post offices sending mails to each other till it gets into
    the hands of the postman you know, who can directly deliver it to your mailbox.
    To do that, the routers use the information in the header. The algorithm and organization
    of how the routers interact are complex and something we need not know to be Java
    professionals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络在连接到它的任意两台计算机之间传递数据包。网络使用的协议是IP，这只是一个互联网协议的缩写。使用IP，一台计算机可以向另一台发送数据包。数据包包含一个头部和数据内容。头部包含发送者和目标机器的互联网地址，其他标志和有关数据包的信息。由于机器之间不是直接连接的，因此路由器转发数据包。这就像邮局之间互相发送邮件，直到邮件落入你认识的邮递员手中，他可以直接将邮件送到你的邮箱。为了做到这一点，路由器使用头部中的信息。路由器交互的算法和组织结构很复杂，但我们不需要知道这些，因为我们不是Java专业人士。
- en: If you ever need to program in order to send IP packets directly, you should
    look at `java.net.DatagramPacket`, and the rest is implemented in the JDK, the
    operating system, and on the firmware of the network card. You can create a data
    packet; sending it and changing the modulated voltage on the network card or emitting
    photons to the fiber is not your headache. However, you will all know whether
    you really need to program datagrams directly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编程来直接发送IP数据包，你应该查看`java.net.DatagramPacket`，其余的由JDK、操作系统和网络卡的固件实现。你可以创建一个数据包；发送它并改变网络卡上的调制电压或发射光子不是你的头疼事。然而，你们都将知道是否真的需要直接编程数据包。
- en: IP has two versions. The old version still in use is IPv4\. The new version
    that coexists with the old one is IPv6 or IPng (*ng* stands for *new generation*).
    The major difference that may concern a Java developer is that version 4 uses
    32-bit addresses and version 6 uses 128-bit addresses. When you see a version-4
    address, you will see something like `192.168.1.110`, which contains the four
    bytes in a decimal format separated by dots. IPv6 addresses are expressed as `2001:db8:0:0:0:0:2:1`,
    as eight 16-bit numbers expressed in hexadecimal separated by colons.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: IP有两个版本。仍在使用的旧版本是IPv4。与旧版本共存的新版本是IPv6或IPng（*ng*代表*新一代*）。可能让Java开发者关心的主要区别是，版本4使用32位地址，而版本6使用128位地址。当你看到版本4的地址时，你会看到类似`192.168.1.110`的东西，它包含四个以点分隔的十进制格式的字节。IPv6地址表示为`2001:db8:0:0:0:0:2:1`，这是以十六进制表示的八个16位数字，以冒号分隔。
- en: The Web is a bit more complex than sending data packets. If sending a data packet
    is like sending a one-page letter, then a web page download is like discussing
    a contract in paper mail. There should be an agreement in the initial paper mail
    as to what to send, what to answer, and so on, until the contract is signed. On
    the Internet, that protocol is called **Transmission Control Protocol** (**TCP**).
    While it is highly unlikely (but possible) that you will meet IP routing issues,
    being a Java developer, you certainly may meet TCP programming. Therefore, we
    will cover shortly how the TCP works. Be aware that this is very brief. Really.
    You will not become a TCP expert reading the next section, but you will get a
    glimpse of the most important issues that affect web programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 网络比发送数据包要复杂一些。如果发送数据包就像发送一页信件，那么网页下载就像通过纸质邮件讨论合同。在最初的纸质邮件中应该有一个协议，说明要发送什么，要回答什么，等等，直到合同签署。在互联网上，这个协议被称为**传输控制协议**（**TCP**）。虽然遇到IP路由问题的可能性非常小（但有可能），但作为一个Java开发者，你肯定会遇到TCP编程。因此，我们将简要介绍TCP的工作原理。请注意，这非常简短。真的。阅读下一节后，你不会成为TCP专家，但你将了解影响网络编程的最重要问题。
- en: TCP/IP
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP
- en: The TCP protocol is implemented in the operating system and provides a higher
    level of interface than IP. When you program TCP, you do not deal with datagrams.
    Instead, you have a channel of byte streams where you can put bytes to be delivered
    to the other computer, and you can read bytes from the channel that were sent
    by the other computer, exactly in the order as they were sent. This is a kind
    of connection between two computers and, what's more, between two programs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TCP协议在操作系统中得到实现，并且提供了比IP协议更高层次的接口。当你编程TCP时，你不需要处理数据报。相反，你有一个字节流通道，你可以将字节放入要发送到另一台计算机的通道中，你也可以从通道中读取由另一台计算机发送的字节，顺序与发送时的顺序相同。这是一种在两台计算机之间，以及两个程序之间的连接。
- en: There are other protocols that are implemented over IP and which are not connection-oriented.
    One of them is **User Datagram Protocol** (**UDP**), used for services when there
    is no need for connections, when the data may be lost and it is more important
    that the data gets to the destination in a timely manner than losing some of the
    packets (video streaming, telephony). When the data amount is small and in case
    it is not delivered, it can be requested again; the cost of losing it is cheap
    (DNS request, see the next section).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他协议是在IP协议之上实现的，并且不是面向连接的。其中之一是**用户数据报协议**（**UDP**），用于不需要连接的服务，当数据可能丢失时，及时到达目的地比丢失一些数据包更重要（视频流、电话）。当数据量小且未送达时，可以再次请求；丢失它的成本很低（DNS请求，见下一节）。
- en: When a packet is lost on the network, or when it is sent twice, or when it is
    delivered sooner than a later package, it is handled by the TCP software layer
    implemented by the operating system. This layer is also popularly called the **TCP
    stack**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包在网络中丢失，或者发送了两次，或者比后续数据包先到达时，它将由操作系统实现的TCP软件层处理。这个层也通常被称为**TCP栈**。
- en: 'Since the TCP is a connected protocol, there is a need for something that tells
    the TCP stack which stream a datagram belongs to when it arrives. The stream is
    identified by two ports. A port is a 16-bit integer. One identifies the program
    that initiates the connection, called the source port. The other one identifies
    the target program: the destination port. These are contained in each and every
    TCP packet delivered. When a machine runs a **Secure Shell** (**SSH**) server
    and a web server, they use different ports, usually port 22 and 80\. When a package
    comes that contains the destination port number 22 in the TCP header, the TCP
    stack knows that the data in the packet belongs to the stream handled by the SSH
    server. Likewise, if the destination port is 80, then the data goes to the web
    server.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP是一个面向连接的协议，因此需要一个机制来告诉TCP栈当数据报到达时它属于哪个流。流通过两个端口号来识别。端口号是一个16位的整数。一个端口号用来标识发起连接的程序，称为源端口号。另一个端口号用来标识目标程序：目标端口号。这些信息包含在每个TCP数据包中。当一台机器运行一个**安全外壳**（**SSH**）服务器和一个Web服务器时，它们使用不同的端口号，通常是22号端口和80号端口。当一个包含目标端口号22的TCP头部的数据包到达时，TCP栈就知道数据包中的数据属于由SSH服务器处理的流。同样，如果目标端口号是80，那么数据就会发送到Web服务器。
- en: When we program a server, we usually have to define the port number; otherwise,
    there is no way the clients will find the server program. Web servers are usually
    listen on port 80, and clients try to connect to that port. The client port is
    usually not important and not specified; it is allocated by the TCP stack automatically.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编程服务器时，通常需要定义端口号；否则，客户端将无法找到服务器程序。Web服务器通常监听80号端口，客户端尝试连接到该端口。客户端端口号通常不重要且未指定；它由TCP栈自动分配。
- en: 'To connect from a client code to a server is easy: only a few lines of code.
    Sometimes, it is only one line of code. However, under the hood, there is a lot
    of work that the TCP stack does that we should care about—it takes time to build
    up a TCP connection.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端代码连接到服务器很简单：只需要几行代码。有时，可能只需要一行代码。然而，在底层，TCP栈做了很多工作，这是我们应当关注的——建立TCP连接需要时间。
- en: To have a connection, the TCP stack has to send a datagram to the destination
    to know that it exists. If there is no server listening on the port, sending the
    data over the network has no result, except for wasting the network bandwidth.
    For this reason, the client first sends an empty data packet called SYN. When
    the other side receives it, it sends back a similar package called SYN-ACK. Finally,
    the client sends a package called ACK. If the packets go through the Atlantic,
    this is approximately 45ms for each package, which is equivalent to 45 million
    seconds in bureaucrat time. This is almost one and a half years. We need three
    of those to set up the connection, and there is more.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立连接，TCP堆栈必须向目的地发送一个数据报以确认其存在。如果没有服务器在端口上监听，通过网络发送数据将没有任何结果，除了浪费网络带宽。因此，客户端首先发送一个名为SYN的空数据包。当另一端收到它时，它会发送一个类似的包，称为SYN-ACK。最后，客户端发送一个名为ACK的包。如果数据包穿越大西洋，每个包大约需要45ms，这在官僚时间中相当于4500万秒。这几乎是1年半的时间。我们需要三个这样的数据包来建立连接，而且还有更多。
- en: 'When a TCP connection starts, the client does not start to send the data without
    control. It sends some data packets and then it waits for the server to acknowledge
    their receipt. It would not only be useless, but also network wasting, to send
    data that the server is not prepared to accept and has to throw away. The TCP
    is designed to optimize the network usage. Therefore, the client sends some data,
    and then it waits for the acknowledgement. The TCP stack automatically manages
    this. If the acknowledgement arrives, it sends more packets, and if a carefully
    designed optimization algorithm, implemented in the TCP stack, believes that it
    is good to send more, it will send a bit more data than in the first step. If
    there are negative acknowledgements telling the client that the server could not
    accept some of the data and had to throw it away, then the client will lower the
    number of packets it sends without acknowledgement. But first it starts slow and
    cautious. This is called TCP slow start and we have to be aware of it. Although
    it is a low level networking feature it has consequences that we have to consider
    in our Java code: we use database connection pools instead of creating a new connection
    to the database each time there is a need for some data; we try to manage to have
    as few connections to web servers as possible using techniques such as *keep-alive*,
    *SPDY* protocol, or *http/2.0* (also replacing SPDY).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个TCP连接开始时，客户端在没有控制的情况下不会开始发送数据。它会发送一些数据包，然后等待服务器确认它们的接收。如果发送服务器尚未准备接受的数据，那么发送这些数据不仅毫无用处，而且还会造成网络资源的浪费。TCP被设计用来优化网络使用。因此，客户端发送一些数据后，它会等待确认。TCP堆栈会自动管理这个过程。如果收到确认，它会发送更多的数据包。如果TCP堆栈中实现的一个精心设计的优化算法认为发送更多数据是合适的，它将发送比第一步更多的数据。如果有负确认告诉客户端服务器无法接受某些数据并不得不丢弃它们，那么客户端将减少未确认发送的数据包数量。但首先它会开始得慢而谨慎。这被称为TCP慢启动，我们必须对此有所了解。尽管这是一个低级网络特性，但它对我们的Java代码有影响，我们必须考虑：我们使用数据库连接池而不是每次需要数据时都创建新的数据库连接；我们尝试通过使用诸如*keep-alive*、*SPDY*协议或*http/2.0*（也取代了SPDY）等技术来尽量减少与Web服务器的连接数。
- en: For a start, it is enough that TCP is connection-oriented where you build up
    a connection to a server, send and receive bytes, and finally close the connection.
    When you have a network performance problem, you have to look at the issues I
    listed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，只要TCP是面向连接的，你就可以建立一个与服务器的连接，发送和接收字节，最后关闭连接。当你遇到网络性能问题时，你必须查看我列出的那些问题。
- en: DNS
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS
- en: The TCP protocol creates a channel using the IP addresses of machines. When
    you type a URL in the browser, it usually does not contain IP numbers. It contains
    machine names. The name is converted to IP numbers using a distributed database
    called **Domain Name System** (**DNS**). This database is distributed, and when
    a program needs to convert a name to an address, it sends DNS request to one of
    the DNS servers it knows. These servers query each other or tell the client whom
    to ask, until the client knows the IP address assigned to the name. The servers
    and the client also cache the recently requested names, so answering is fast.
    On the other hand, when the IP address of a server changes this name, not all
    clients will immediately see the address assignment over the globe. The DNS lookup
    can be easily programmed, and there are classes and methods in JDK that support
    this, but usually we need not care about that; when we program, it is done automatically
    in web programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TCP协议使用机器的IP地址创建一个通道。当你在一个浏览器中输入一个URL时，它通常不包含IP号码。它包含机器名称。该名称通过一个称为**域名系统**（**DNS**）的分布式数据库转换为IP号码。这个数据库是分布式的，当一个程序需要将名称转换为地址时，它会向它所知道的DNS服务器之一发送DNS请求。这些服务器相互查询或告诉客户端向谁询问，直到客户端知道分配给该名称的IP地址。服务器和客户端还会缓存最近请求的名称，因此响应速度快。另一方面，当服务器的IP地址发生变化时，这个名称，全球上的所有客户端不会立即看到地址分配。DNS查找可以很容易地编程，JDK中有支持这一点的类和方法，但通常我们不需要关心这一点；当我们编程时，在Web编程中它是自动完成的。
- en: The HTTP protocol
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP协议
- en: The **Hypertext Transport Protocol** (**HTTP**) is built on top of the TCP.
    When you type a URL in a browser, the browser opens a TCP channel to the server
    (after DNS lookup, of course) and sends a HTTP request to the web server. The
    server, after receiving the request, produces a response and sends it to the client.
    After that, the TCP channel may be closed or kept alive for further HTTP request-response
    pairs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）建立在TCP之上。当你在一个浏览器中输入一个URL时，浏览器会打开一个TCP通道到服务器（当然是在DNS查找之后）并发送一个HTTP请求到Web服务器。服务器在收到请求后，生成一个响应并发送给客户端。之后，TCP通道可能会关闭或保持活跃以进行进一步的HTTP请求-响应对。'
- en: Both the request and the response contain a header and an optional (possibly
    zero-length) body. The header is in the text format, and it is separated from
    the body by an empty line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应都包含一个头部和一个可选的（可能为零长度）正文。头部是文本格式，并且通过一个空行与正文分隔。
- en: More precisely the header and the body are separated by four bytes: `0x0D`,
    `0x0A`, `0x0D`, and `0x0A`, which are two `CR`, `LF` line separators. The HTTP
    protocol uses carriage return and line feed to terminate lines in the header,
    and thus, an empty line is two `CRLF` following each other.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，标题和正文之间由四个字节分隔：`0x0D`，`0x0A`，`0x0D`和`0x0A`，这是两个`CR`，`LF`行分隔符。HTTP协议使用回车和换行符来终止标题中的行，因此，一个空行是两个`CRLF`连续出现。
- en: 'The start of the header is a status line plus header fields. The following
    is a sample HTTP request:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 头部的开始是一个状态行加上头部字段。以下是一个示例HTTP请求：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the response:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个响应：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The request does not contain a body. The status line is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请求不包含正文。状态行如下：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It contains the so-called method of the request, the object that is requested,
    and the protocol version used by the request. The rest of the request of the header
    contains header fields that have the format, `label : value`. Some of the lines
    are wrapped in the printed version, but there is no line break in a header line.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '它包含所谓的请求方法，请求的对象以及请求使用的协议版本。请求头部的其余部分包含格式为`label : value`的头部字段。在打印版本中，某些行被换行，但在头部行中没有换行符。'
- en: 'The response specifies the protocol it uses (usually the same as the request),
    the status code, and the message format of the status:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 响应指定了它使用的协议（通常与请求相同），状态码以及状态的消息格式：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After this, the response fields come with the same syntax as in the request.
    One important header is the content type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，响应字段以与请求相同的语法出现。一个重要的头部是内容类型：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It specifies that the response body (truncated in the printout) is HTML text.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它指定响应体（在打印输出中被截断）是HTML文本。
- en: 'The actual request was sent to the URL, [https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230),
    which is the standard that defines the 1.1 version of HTTP. You can easily look
    into the communication yourself, starting up the browser and opening the developer
    tools. Such a tool is built into every browser these days. You can use it to debug
    the program behavior on the network application level looking at the actual HTTP
    requests and responses on the byte level. The following screenshot shows how the
    developer tool shows this communication:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际请求被发送到了URL，[https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230)，这是定义HTTP
    1.1版本的规范。你可以轻松地自己查看通信，启动浏览器并打开开发者工具。如今，这样的工具已经内置在每一个浏览器中。你可以用它来在网络应用程序级别调试程序行为，查看实际的HTTP请求和响应的字节级信息。以下截图显示了开发者工具如何显示这种通信：
- en: '![](img/00045.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: HTTP methods
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP方法
- en: The method that is the first word in the status line of the request tells the
    server what to do with the request. The standard defines different methods, such
    as `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, and some others.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请求状态行中的第一个单词所表示的方法告诉服务器如何处理该请求。标准定义了不同的方法，例如`GET`、`HEAD`、`POST`、`PUT`、`DELETE`以及一些其他方法。
- en: The client uses the `GET` method when it wants to get the content of a resource.
    In the case of a `GET` request, the body of the request is empty. This is the
    method used by the browser when we download a web page. It is also, many times,
    the method used when some program implemented in JavaScript and running in the
    browser asks for some information from a web application, but it does not want
    to send much information to the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要获取资源的内 容时，它会使用`GET`方法。在`GET`请求的情况下，请求体是空的。这是浏览器在我们下载网页时使用的方法。它也是，很多时候，当在浏览器中运行的JavaScript程序请求一些信息时使用的方法，但它不想向服务器发送太多信息。
- en: When the client uses `POST`, the intention is usually to send some data to the
    server. The server does reply and, many times, there is also a body in the reply,
    but the main purpose of the request/reply communication is to send some information
    from the client to the server. This is the opposite of the `GET` method in some
    sense.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端使用`POST`时，通常的意图是向服务器发送一些数据。服务器确实会回复，很多时候，回复中也有一个体，但请求/回复通信的主要目的是从客户端向服务器发送一些信息。这在某种程度上与`GET`方法相反。
- en: The `GET` and `POST` methods are the most frequently used methods. Although
    there is a general guideline to use `GET` to retrieve data and `POST` to send
    data to the server, it is only a recommendation, and there is no clean separation
    of the two cases. Many times, `GET` is used to send some data to the server. After
    all, it is an HTTP request with a status line and header fields, and although
    there is no body in the request, the object (part of the URL) that follows the
    method in the status line is still able to deliver parameters. Many times, it
    is also easy to test a service that responds to a `GET` request because you only
    need a browser and to type in the URL with the parameters, and look at the response
    in the browser developer tools. You should not be surprised if you see an application
    that uses `GET` requests to execute operations that modify the state on a web
    server. However, not being surprised does not mean approval. You should be aware
    that in most cases, these are not good practices. When we send sensitive information
    using the `GET` request, the parameters in the URL are available to the client
    in the address line of the browser. When we send using `POST`, the parameters
    are still reachable by the client (after all, the information the client sends
    is generated by the client and, as such, cannot be unavailable), but not that
    easy for a simple security-unaware user to copy-paste the information and send,
    perhaps, to a malevolent third party. The decision between using `GET` and `POST`
    should always consider practicalities and security issues.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`和`POST`方法是使用最频繁的方法。尽管有一般性指南建议使用`GET`来检索数据，使用`POST`将数据发送到服务器，但这只是一个建议，两种情况之间没有清晰的分离。很多时候，`GET`也会用来向服务器发送一些数据。毕竟，它是一个带有状态行和头字段的HTTP请求，尽管请求中没有主体，但状态行中方法后面的对象（URL的一部分）仍然能够传递参数。很多时候，测试响应`GET`请求的服务也很容易，因为你只需要一个浏览器，输入带有参数的URL，然后在浏览器开发者工具中查看响应。如果你看到使用`GET`请求执行修改Web服务器状态的操作的程序，你不必感到惊讶。然而，不感到惊讶并不意味着认可。你应该意识到，在大多数情况下，这并不是好的做法。当我们使用`GET`请求发送敏感信息时，URL中的参数在浏览器的地址行中可供客户端访问。当我们使用`POST`发送时，参数仍然可以被客户端访问（毕竟，客户端发送的信息是由客户端生成的，因此不能不可用），但对于一个简单的、对安全性无知的用户来说，复制粘贴信息并发送给第三方并不那么容易。使用`GET`和`POST`的决定应始终考虑实际性和安全问题。'
- en: The `HEAD` method is identical to a `GET` request, but the response will not
    contain a body. This is used when the client is not interested in the actual response.
    It may happen that the client already has the object and wants to see if it was
    changed. The `Last-Modified` header will contain the time when the resource was
    last changed, and the client can decide if it has a newer one or needs to ask
    for the resource in a new request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEAD`方法与`GET`请求相同，但响应将不包含主体。当客户端对实际响应不感兴趣时，会使用这种方法。可能的情况是客户端已经拥有该对象，并想查看它是否已更改。`Last-Modified`头将包含资源最后更改的时间，客户端可以决定是否拥有更新的版本或需要在新请求中请求资源。'
- en: The `PUT` method is used when the client wants to store something on the server
    and `DELETE` when the client wants to erase some resource. These methods are used
    only by applications usually written in JavaScript and not directly by the browser.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要在服务器上存储某些内容时，使用`PUT`方法，而当客户端想要删除某些资源时，使用`DELETE`方法。这些方法通常只由用JavaScript编写的应用程序使用，而不是直接由浏览器使用。
- en: There are other methods defined in the standard, but these are the most important
    and frequently used ones.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标准中定义了其他方法，但这些都是最重要且最常使用的方法。
- en: Status codes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态码
- en: The response starts with the status code. These codes are also defined and there
    are a limited number of codes usable in a response. The most important is `200`,
    which says all is OK; the response contains what the request wanted. The codes
    are always in the range of `100` to `599`, contain three digits, and are grouped
    by the first digit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 响应以状态码开始。这些代码也是定义好的，响应中可用的代码数量有限。最重要的是`200`，表示一切正常；响应包含请求所需的内容。这些代码始终在`100`到`599`的范围内，包含三位数字，并按第一位数字分组。
- en: '`1xx`: These codes are information codes. They are rarely used but can be very
    important in some cases. For example, `100` means continue. A server can send
    this code when it gets a `POST` request and the server wants to signal the client
    to send the body of the request because it can process it. Using this code, and
    the client waiting for this code, may save a lot of bandwidth if properly implemented
    on the server and also on the client.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1xx`: 这些代码是信息代码。它们很少使用，但在某些情况下可能非常重要。例如，`100` 表示继续。当服务器收到 `POST` 请求并且服务器想要向客户端发出信号以发送请求体，因为它可以处理它时，可以发送此代码。如果服务器和客户端正确实现此代码，并且客户端等待此代码，可能会节省大量带宽。'
- en: '`2xx`: These codes mean success. The request is answered properly, or the requested
    service was done. There are codes, such as `200`, `201`, `202`, and so on, defined
    in the standard and there is a description about when to use one or the other.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2xx`: 这些代码表示成功。请求得到了适当的回答，或者请求的服务已经完成。标准中定义了诸如 `200`、`201`、`202` 等代码，并描述了何时使用其中一个或另一个。'
- en: '`3xx`: These codes mean redirection. One of these codes is sent when the server
    cannot directly service the request but knows the URL that can. The actual codes
    can distinguish between a permanent redirect (when it is known that all future
    requests should be sent to the new URL) and temporary redirect (when any later
    request should be sent here and possibly served or redirected), but the decision
    is kept on the server side.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3xx`: 这些代码表示重定向。当服务器无法直接服务请求但知道可以服务的 URL 时，会发送这些代码之一。实际的代码可以区分永久重定向（当已知所有未来的请求都应该发送到新的
    URL 时）和临时重定向（当任何后续请求都应该发送到这里，并且可能被服务或重定向时），但决定保留在服务器端。'
- en: '`4xx`: These are error codes. The most famous code is `404`, which means Not
    Found, that is, the server is not able to respond to the request because the resource
    is not found. `401` means that the resource to serve the request may be available
    but it requires authentication. `403` is a code that signals that the request
    was valid but is still refused to be served by the server.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4xx`: 这些是错误代码。最著名的代码是 `404`，表示未找到，即服务器无法响应请求，因为找不到资源。`401` 表示可能可以提供请求的资源，但它需要身份验证。`403`
    是一个表示请求有效但服务器仍然拒绝服务的代码。'
- en: '`5xx`: These codes are server error codes. When a response holds one of these
    error codes, the meaning is that there is some error on the server. This error
    can be temporary, for example, when the server is processing too many requests
    and cannot respond to a new request with a calculation-intensive response (this
    is usually signaled by error code `503`) or when the feature is not implemented
    (code `501`). The general error code `500` is interpreted as Internal Error, which
    means that no information, whatsoever, is available about what was going wrong
    on the server, but it was not going well and hence, no meaningful response.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5xx`: 这些代码是服务器错误代码。当响应包含这些错误代码之一时，其含义是服务器存在某些错误。这种错误可能是临时的，例如，当服务器正在处理过多的请求并且无法以计算密集型的响应响应新的请求（这通常由错误代码
    `503` 表示）或当功能未实现（代码 `501`）时。一般错误代码 `500` 被解释为内部错误，这意味着关于服务器上发生什么错误没有任何信息，但它并不好，因此没有有意义的响应。'
- en: HTTP/2.0
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2.0
- en: After almost 20 years since the last release of HTTP, the new version of HTTP
    was released in 2015\. This new version of the protocol has several enhancements
    over the previous versions. Some of these enhancements will also affect the way
    server applications will be developed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 自从上次 HTTP 发布以来近 20 年后，新的 HTTP 版本于 2015 年发布。这个新版本的协议在之前版本的基础上有几个增强。其中一些增强也将影响服务器应用程序的开发方式。
- en: The first and most important enhancement is that the new protocol will make
    it possible to send several resources parallelly in a single TCP connection. The
    keep-alive flag is available to avoid the recreation of the TCP channel, but it
    does not help when a response is created slowly. In the new protocol, other resources
    can also be delivered in the same TCP channel even before one request is fully
    served. This requires complex package handling in the protocol, but this is hidden
    from the server application programmer as well as the browser programmer. The
    application server, servlet container, and browser implement this transparently.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要和首次增强的是，新协议将使得在单个TCP连接中并行发送多个资源成为可能。保持连接的标志可用于避免TCP通道的重新创建，但当响应创建缓慢时，这并没有帮助。在新协议中，即使一个请求尚未完全服务，其他资源也可以在相同的TCP通道中传输。这需要在协议中处理复杂的包，但这一点对服务器应用程序程序员和浏览器程序员都是透明的。应用服务器、Servlet容器和浏览器都透明地实现了这一点。
- en: HTTP/2.0 will always be encrypted, therefore it will not be possible to use
    `http` as a protocol in the browser URL. It will always be `https`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0将始终是加密的，因此不可能在浏览器URL中使用`http`作为协议。它始终是`https`。
- en: The feature that will need changes in servlet programming to leverage the advantages
    of the new version of the protocol is server push. Version 4.0 of the servlet
    specification includes support for HTTP/2.0, and this version is still in draft.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Servlet编程中需要修改以利用新版本协议优势的功能是服务器推送。Servlet规范的第4.0版包括对HTTP/2.0的支持，而这个版本目前仍处于草案阶段。
- en: Server push is an HTTP response to a request that will come in the future. How
    can a server answer a request that is not even issued? Well, the server anticipates.
    For example, the application sends an HTML page that has references to many small
    pictures and icons. The client downloads the HTML page, builds the DOM structure,
    analyzes it, and realizes that the pictures are needed, and sends the request
    for the pictures. The application programmer knows what pictures are there and
    may code the server to send the pictures even before the browser requests for
    it. Every such response includes a URL that this response is for. When the browser
    wants the resource, it realizes that it is already there and does not issue a
    new request. In `HttpServlet`, the program should access `PushBuilder` via the
    request's new `getPushBuilder` method and use that to push down resources to the
    client.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器推送是对未来请求的HTTP响应。服务器如何回答一个尚未发出的请求呢？嗯，服务器是预测的。例如，应用程序发送一个包含许多小图片和图标的HTML页面。客户端下载HTML页面，构建DOM结构，分析它，并意识到需要这些图片，然后发送请求。应用程序程序员知道有哪些图片，并且可能编写代码让服务器在浏览器请求之前就发送图片。每个这样的响应都包含一个URL，即这个响应是为哪个URL准备的。当浏览器需要资源时，它会意识到资源已经存在，因此不会发出新的请求。在`HttpServlet`中，程序应通过请求的新`getPushBuilder`方法访问`PushBuilder`，并使用它将资源推送到客户端。
- en: Cookies
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cookies
- en: Cookies are maintained by the browser and are sent in the HTTP request header
    using the `Cookie` header field. Each cookie has a name, value, domain, path,
    expiration time, and some other parameters. When a request is sent to a URL that
    matches the domain, the path of a non-expired cookie, the client sends the cookie
    to the server. Cookies are usually stored in small files on the client by the
    browser or in a local database. The actual implementation is the business of the
    browser, and we need not worry about it. It is just the text information that
    is not executed by the client. It is only sent back to the server when some rules
    (mainly domain and path) match. Cookies are created by servers and are sent to
    the client in HTTP responses using the `Set-Cookie` header field. Thus, essentially
    the server tells the client, Hey, here is this cookie, whenever you come to me
    next time, show me this piece of information, so I will know it is you.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies由浏览器维护，并在HTTP请求头中使用`Cookie`头字段发送。每个cookie都有一个名称、值、域名、路径、过期时间和一些其他参数。当请求发送到与域名匹配的URL，且非过期的cookie路径时，客户端会将cookie发送到服务器。Cookies通常由浏览器存储在客户端的小文件中，或者存储在本地数据库中。实际的实现是浏览器的事务，我们无需担心。它只是客户端不执行的文字信息。只有当某些规则（主要是域名和路径）匹配时，它才会被发送回服务器。Cookies由服务器创建，并在HTTP响应中使用`Set-Cookie`头字段发送给客户端。因此，本质上服务器告诉客户端，嘿，这里有这个cookie，当你下次来的时候，给我展示这条信息，这样我就知道是你了。
- en: Cookies are usually to remember clients. Advertisers and online shops that need
    to remember who they are talking to heavily use it. But this is not the only use.
    These days, any application that maintains user sessions uses cookies to chain
    up the HTTP requests that come from the same user. When you log in to an application,
    the username and password you use to identify yourself are sent to the server
    only once, and in subsequent requests, only a special cookie is sent to the server
    used to identify the already logged in user. This use of cookies emphasizes why
    it is important to use cookie values that cannot be easily guessed. If the cookie
    used to identify a user is easily guessable, then an attacker could just create
    a cookie and send it to the server mimicking the other user. Cookie values, for
    the purpose, are usually long random strings.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies通常用于记住客户端。广告商和需要记住与谁交流的在线商店大量使用它。但这并不是唯一用途。如今，任何维护用户会话的应用程序都使用cookies来链接来自同一用户的HTTP请求。当你登录到应用程序时，你用来识别自己的用户名和密码只发送到服务器一次，在随后的请求中，只发送一个特殊的cookie到服务器，用于识别已经登录的用户。这种使用cookie的方式强调了为什么使用难以猜测的cookie值非常重要。如果用于识别用户的cookie容易被猜测，那么攻击者只需创建一个cookie并发送到服务器，模仿其他用户即可。出于这个目的，cookie值通常是长的随机字符串。
- en: Cookies are not always sent back to the server where they originate. When the
    cookie is set, the server specifies the domain of the URL where the cookie should
    be sent back. This is used when a different server from the one providing the
    services needing authentication does the user authentication.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies并不总是被发送回它们起源的服务器。当设置cookie时，服务器会指定一个URL域名，该域名用于将cookie发送回。这通常发生在需要认证的服务器之外的其他服务器执行用户认证时。
- en: Applications sometimes encode values into cookies. This is not necessarily bad,
    though in most actual cases, it is. When encoding something into a cookie, we
    should always consider the fact that the cookie travels through the network and
    can go huge as more and more data is encoded in it and can create unnecessary
    burden on the network. Usually, it is better to send only some unique, otherwise
    meaningless, random key, and store the values in some database, be it on disk
    or in the memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有时会将值编码到cookie中。这并不一定不好，尽管在大多数实际情况下是这样的。当将某些内容编码到cookie中时，我们应始终考虑这样一个事实：cookie会通过网络传输，并且随着越来越多的数据被编码其中，可能会变得非常大，从而给网络带来不必要的负担。通常，最好只发送一些独特的、否则无意义的随机密钥，并将值存储在数据库中，无论是磁盘上的还是内存中的。
- en: Client server and web architecture
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端服务器和Web架构
- en: The applications we developed so far were running on a single JVM. We already
    have some experience with concurrent programming and this is something that will
    come handy now. When we program a web application, a part of the code will run
    on the server and a part of the application logic will execute in the browser.
    The server part will be written in Java, the browser part will be implemented
    in HTML, CSS, and JavaScript. Since this is a Java book we will focus mainly on
    the server part, but we should still be aware of the fact that many of the functionalities
    can be and should be implemented to run in the browser. The two programs communicate
    with each other over the IP network, that is, the Internet, or in the case of
    an enterprise internal application, the network of the company.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止开发的应用程序都是在单个JVM上运行的。我们已经有了一些并发编程的经验，现在这将非常有用。当我们编写Web应用程序时，代码的一部分将在服务器上运行，而应用程序逻辑的一部分将在浏览器中执行。服务器部分将用Java编写，浏览器部分将用HTML、CSS和JavaScript实现。由于这是一本Java书，我们将主要关注服务器部分，但我们仍然应该意识到，许多功能可以也应该在浏览器中实现。这两个程序通过IP网络（即互联网）或企业内部应用程序的情况，即公司的网络相互通信。
- en: Today, a browser is capable of running very powerful applications, all implemented
    in JavaScript. A few years ago, such applications needed client application implemented
    in Delphi, C++, or Java, using the windowing capabilities of the client operating
    system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，浏览器能够运行非常强大的应用程序，所有这些应用程序都是用JavaScript实现的。几年前，这样的应用程序需要用Delphi、C++或Java编写的客户端应用程序，利用客户端操作系统的窗口功能。
- en: Originally, the client-server architecture meant that the functionality of the
    application was implemented on the client, and the program was using general services
    only from the server. The server provided database access and file storage but
    nothing more. Later, the three-tier architecture put the business functionality
    on the servers that used other servers for database and other general services,
    and the client application implemented the user interface and limited business
    functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，客户端-服务器架构意味着应用程序的功能是在客户端实现的，程序仅使用服务器的一般服务。服务器提供数据库访问和文件存储，但仅此而已。后来，三层架构将业务功能放在使用其他服务器进行数据库和其他一般服务的服务器上，客户端应用程序实现用户界面和有限业务功能。
- en: When the web technology started to penetrate enterprise computing, the web browser
    started to replace the client applications in many use cases. Previously, the
    browser could not run complex JavaScript applications. The application was executed
    on the web server and the client displayed the HTML that the server created as
    a part of the application logic. Every time something was changed on the user
    interface, the browser started a communication with the server, and in a HTTP
    request-response pair, the browser content was replaced. A web application was
    essentially a series of form filling and form data sending to the server, and
    the server responded with HTML-formatted pages, presumably containing new forms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络技术开始渗透企业计算时，网络浏览器开始取代许多用例中的客户端应用程序。在此之前，浏览器无法运行复杂的JavaScript应用程序。应用程序是在网络服务器上执行的，客户端显示服务器创建的HTML，作为应用程序逻辑的一部分。每当用户界面发生变化时，浏览器就会与服务器建立通信，并在HTTP请求-响应对中，浏览器内容被替换。一个网络应用程序本质上是一系列表单填写和向服务器发送表单数据，服务器则以HTML格式的页面响应，可能包含新的表单。
- en: JavaScript interpreters were developed and became more and more effective and
    standardized. Today, modern web applications contain HTML (which is a part of
    the client code and is not generated by the server on the fly), CSS, and JavaScript.
    When the code is downloaded from the web server, the JavaScript starts to execute
    and communicate with the server. It is still HTTP requests and responses, but
    the responses do not contain HTML code. It contains pure data, usually in the
    JSON format. This data is used by the JavaScript code and some of the data, if
    needed, is displayed on the web browser display also controlled by JavaScript.
    This is functionally equivalent to a three-tier architecture with some slight
    but very important differences.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开发了JavaScript解释器，并且变得越来越有效和标准化。今天，现代网络应用程序包含HTML（它是客户端代码的一部分，不是由服务器动态生成的）、CSS和JavaScript。当代码从网络服务器下载时，JavaScript开始执行并与服务器通信。它仍然是HTTP请求和响应，但响应不包含HTML代码。它包含纯数据，通常是JSON格式。这些数据被JavaScript代码使用，如果需要，一些数据也会在由JavaScript控制的网络浏览器显示上显示。这在功能上等同于三层架构，但有一些细微但非常重要的差异。
- en: The first difference is that the code is not installed on the client. The client
    downloads the application from a web server, and the only thing that is installed
    is the modern browser. This removes a lot of enterprise maintenance burden and
    cost.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不同之处在于代码没有安装在客户端。客户端从网络服务器下载应用程序，唯一安装的是现代浏览器。这减少了企业维护负担和成本。
- en: The second difference is that the client is not able, or is limited, to access
    the resources of the client machine. Thick client applications could save anything
    in a local file or access a local database. This is very limited, for security
    reasons, compared to a program running on the browser. At the same time this is
    a handy limitation because clients aren't and shouldn't be a trusted part of the
    architecture. The disk in the client computer is hard and expensive to back up.
    It can be stolen with a notebook, and encrypting it is costly. There are tools
    to protect client storage, but most of the time, storing the data on the server
    only is a more viable solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个不同之处在于客户端无法或受限地访问客户端机器的资源。厚客户端应用程序可以在本地文件中保存任何内容或访问本地数据库。与在浏览器上运行的程序相比，这非常有限，出于安全原因。同时，这也是一个方便的限制，因为客户端不应且不应该是架构中受信任的部分。客户端计算机的硬盘又硬又贵，备份成本高昂。它可以被笔记本偷走，加密它也很昂贵。有工具可以保护客户端存储，但大多数情况下，仅在服务器上存储数据是一个更可行的解决方案。
- en: It is also a common program design error to trust the client application. The
    client physically controls the client computer and although it can be made technically
    very difficult, the client can still overcome the security limitations of the
    client device and client code. If it is only the client application that checks
    the validity of some functionality or data, then the physical security provided
    by the physical control of the server is not used. Whenever data is sent from
    the client to the server, the data has to be checked in regards of validity, no
    matter what the client application is. Actually, since the client application
    can be changed, we just don't really know what the client application really is.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 信任客户端应用程序也是常见的程序设计错误。客户端实际上控制着客户端计算机，尽管在技术上可以使其变得非常困难，但客户端仍然可以克服客户端设备和客户端代码的安全限制。如果只有客户端应用程序检查某些功能或数据的有效性，那么服务器物理控制提供的物理安全就不会被利用。每当数据从客户端发送到服务器时，都必须检查数据的有效性，无论客户端应用程序是什么。实际上，由于客户端应用程序可以更改，我们实际上并不真正知道客户端应用程序是什么。
- en: In this chapter and, as a matter of fact, in the entire book, we focus on Java
    technologies; therefore the sample application will not contain almost any client
    technology. I could not help but create some CSS. On the other hand, I definitely
    avoided JavaScript. Therefore, I have to emphasize again that the example is to
    demonstrate the programming of the server side and still providing something that
    really works. A modern application would use REST and JSON communications and
    would not play around creating HTML on the fly on the server side. Originally,
    I wanted to create a JavaScript client and REST server application, but the focus
    was moved so much from server-side Java programming that I dropped this idea.
    On the other hand, you can extend the application to be one like that.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，实际上在整个书中，我们专注于Java技术；因此，示例应用程序将几乎不包含任何客户端技术。我忍不住创建了一些CSS。另一方面，我肯定避免了JavaScript。因此，我必须再次强调，示例是为了演示服务器端编程，并且仍然提供真正有效的东西。一个现代应用程序会使用REST和JSON通信，而不会在服务器端动态创建HTML。最初，我想创建一个JavaScript客户端和REST服务器应用程序，但由于服务器端Java编程的焦点转移得太多，我放弃了这个想法。另一方面，你可以扩展应用程序，使其类似于那样。
- en: Writing servlets
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Servlet
- en: Servlets are Java classes that are executed in a web server that implements
    the servlet container environment. The first web servers could only deliver static
    HTML files to the browsers. For each URL, there was an HTML page on the web server
    and the server delivered the content of this file, in response to a request sent
    by the browser. Very soon, there was a need to extend the web servers to be able
    to start some program that calculates the content of the response, on the fly,
    when the request is processed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet是Java类，在实现servlet容器环境的Web服务器中执行。最初的Web服务器只能向浏览器提供静态HTML文件。对于每个URL，在Web服务器上都有一个HTML页面，服务器在浏览器发送请求后，将文件的內容作为响应发送。很快，就有必要扩展Web服务器，使其能够在处理请求时动态启动一些程序来计算响应的内容。
- en: The first standard to do that defined CGI. It started a new process to respond
    to a request. The new process got the request on its standard input, and the standard
    output was sent back to the client. This approach wastes a lot of resources. Starting
    a new process, as you learned in the previous chapter, is way too costly just
    to respond to an HTTP request. Even starting a new thread seems to be unnecessary,
    but with that, we ran a bit ahead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实现这一功能的标准化方法是CGI。它启动了一个新的进程来响应请求。新的进程从其标准输入获取请求，并将标准输出发送回客户端。这种方法浪费了大量的资源。正如你在上一章中学到的，仅仅为了响应一个HTTP请求而启动一个新的进程是非常昂贵的。甚至启动一个新的线程似乎也是不必要的，但在这方面，我们已经走得很远了。
- en: The next approach was FastCGI, executing the external process continually and
    reusing it, and then came different other approaches. The approaches after
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是FastCGI，它持续执行外部进程并重用它，然后出现了不同的其他方法。在Servlet之后的方法是
- en: FastCGIall use in-process extensions. In these cases, the code calculating the
    response runs inside the same process as the web server. Such standards or extension
    interfaces were ISAPI for the Microsoft IIS server, NSASPI for the Netscape server,
    and the Apache module interface. Each of these made it possible to create a **dynamically
    loaded library** (**DLL** on Windows or SO files on Unix systems) to be loaded
    by the web server during
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: FastCGIall use in-process extensions. In these cases, the code calculating the
    response runs inside the same process as the web server. Such standards or extension
    interfaces were ISAPI for the Microsoft IIS server, NSASPI for the Netscape server,
    and the Apache module interface. Each of these made it possible to create a **dynamically
    loaded library** (**DLL** on Windows or SO files on Unix systems) to be loaded
    by the web server during
- en: startupand to map certain requests to be handled by the code implemented in
    these libraries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: startupand to map certain requests to be handled by the code implemented in
    these libraries.
- en: When somebody programs PHP, for example, the Apache module extension is the
    PHP interpreter that reads the PHP code and acts upon it. When somebody programs
    ASP pages for the Microsoft IIS, the ISAPI extension implementing the ASP page
    interpreter is executed (well, this is a bit sloppy and oversimplified to say
    but works as an example).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当某人编写PHP程序时，例如，Apache模块扩展是读取PHP代码并对其采取行动的PHP解释器。当某人编写用于Microsoft IIS的ASP页面时，执行ASP页面解释器的ISAPI扩展（好吧，这样说有点草率和简化，但可以作为例子）。
- en: To Java, the interface definition is a servlet defined in JSR340 as of version
    3.1.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java来说，接口定义是JSR340版本3.1中定义的servlet。
- en: JSR stands for Java Specification Request. These are requests for modification
    of the Java language, library interfaces, and other components. The requests go
    through an evaluation process, and when they are accepted, they become a standard.
    The process is defined by the Java Community Process (JCP). JCP is also documented
    and has versions. The current version is 2.10 and can be found at [https://jcp.org/en/procedures/overview](https://jcp.org/en/procedures/overview).
    The JSR340 standard can be found at [https://jcp.org/en/jsr/detail?id=340](https://jcp.org/en/jsr/detail?id=340).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JSR代表Java规范请求。这些是对Java语言、库接口和其他组件修改的请求。这些请求经过评估过程，当它们被接受时，它们成为标准。这个过程由Java社区进程（JCP）定义。JCP也有文档和版本。当前版本是2.10，可以在[https://jcp.org/en/procedures/overview](https://jcp.org/en/procedures/overview)找到。JSR340标准可以在[https://jcp.org/en/jsr/detail?id=340](https://jcp.org/en/jsr/detail?id=340)找到。
- en: A servlet program implements the servlet interface. Usually this is done via
    extending `HttpServlet`, the abstract implementation of the `Servlet` interface.
    This abstract class implements methods, such as `doGet`, `doPost`, `doPut`, `doDelete`,
    `doHead`, `doOption`, and `doTrace`, free to be overridden by the actual class
    extending it. If a servlet class does not override one of the these methods, sending
    the corresponding HTTP method, `GET`, `POST`, and so on, will return the `405``Not
    Allowed` status code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个servlet程序实现了servlet接口。通常这是通过扩展 `HttpServlet`，即 `Servlet` 接口的抽象实现来完成的。这个抽象类实现了方法，如
    `doGet`、`doPost`、`doPut`、`doDelete`、`doHead`、`doOption` 和 `doTrace`，这些方法可以由扩展它的实际类自由覆盖。如果一个servlet类没有覆盖这些方法之一，发送相应的HTTP方法，如
    `GET`、`POST` 等，将返回 `405 Not Allowed` 状态码。
- en: Hello world servlet
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello world servlet
- en: 'Before getting into the technical details, let''s create an extremely simple
    *hello world* servlet. To do it, we setup a Gradle project with the build file,
    `build.gradle`, the servlet class in the file, `src/main/java/packt/java9/by/example/mastermind/servlet/HelloWorld.java`,
    and last but not least, we have to create the file `src/main/webapp/WEB-INF/web.xml`.
    The `gradle.build` file will look the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入技术细节之前，让我们创建一个非常简单的 *hello world* servlet。为此，我们设置了一个Gradle项目，包括构建文件 `build.gradle`，在文件
    `src/main/java/packt/java9/by/example/mastermind/servlet/HelloWorld.java` 中的servlet类，最后但同样重要的是，我们必须创建文件
    `src/main/webapp/WEB-INF/web.xml`。`gradle.build` 文件将如下所示：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Gradle build file uses two plugins, `java` and `jetty`. We have already
    used the `java` plugin in the previous chapter. The `jetty` plugin adds tasks
    such as `jettyRun` that load the Jetty servlet container and start up the application.
    The `jetty` plugin is also an extension of the `war` plugin that compiles web
    applications into a **Web Archive** (**WAR**`)` packaging format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle构建文件使用了两个插件，`java` 和 `jetty`。我们已经在上一章中使用了 `java` 插件。`jetty` 插件添加了如 `jettyRun`
    这样的任务，这些任务加载Jetty servlet容器并启动应用程序。`jetty` 插件也是 `war` 插件的扩展，它将Web应用程序编译成 **Web
    Archive** (**WAR**`) 包装格式。
- en: The WAR packaging format is practically the same as JAR; it is a zip file and
    it contains a `lib` directory that contains all the JAR files that the web application
    depends on. The classes of the application are in the directory, `WEB-INF/classes`,
    and there is a `WEB-INF/web.xml` file that describes servlet URL mapping, which
    we will explore in detail soon.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: WAR打包格式实际上与JAR相同；它是一个zip文件，它包含一个`lib`目录，其中包含所有Web应用程序所依赖的JAR文件。应用程序的类位于`WEB-INF/classes`目录中，并且有一个`WEB-INF/web.xml`文件，该文件描述了servlet
    URL映射，我们将在不久的将来详细探讨。
- en: Since we want to develop an extremely simple servlet, we add the servlet API
    as a dependency to the project. This is, however, not a compile dependency. The
    API is available when the servlet runs in the container. Still, it has to be available
    when the compiler compiles our code; therefore, a *dummy* implementation is provided
    by the artifact specified as `providedCompile`. Because it is specified that way,
    the build process will not package the library into the generated WAR file. The
    generated file will contain nothing that is specific to Jetty or any other servlet
    container.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要开发一个非常简单的servlet，我们将servlet API作为依赖项添加到项目中。然而，这并不是一个编译依赖项。当servlet在容器中运行时，API是可用的。尽管如此，它必须在编译我们的代码时可用；因此，通过指定为`providedCompile`的工件提供了一个*虚拟*实现。因为是这样指定的，构建过程不会将库打包到生成的WAR文件中。生成的文件将不包含任何特定于Jetty或其他servlet容器的特定内容。
- en: The servlet container will provide the actual implementation of the servlet
    library. When the application is deployed and started in a Jetty, the Jetty-specific
    implementation of the servlet library will be available on the classpath. When
    the application is deployed to a Tomcat, the Tomcat specific implementation will
    be available.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: servlet容器将提供servlet库的实际实现。当应用程序在Jetty中部署并启动时，servlet库的Jetty特定实现将可在类路径上使用。当应用程序部署到Tomcat时，将可用Tomcat特定实现。
- en: 'We create a class in our project, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中创建一个类，如下所示：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the servlet is started, the `init` method is invoked. When it is put out
    of service, the `destroy` method is called. These methods can be overridden and
    provide a more fine-grained control than the constructor and other finalization
    possibilities. A servlet object may be put into service more than once, and after
    calling `destroy`, the servlet container may invoke `init` again; thus, this cycle
    is not strictly tied to the life cycle of the object. Usually, there is not much
    that we do in these methods, but sometimes, you may need some code in them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当servlet启动时，将调用`init`方法。当它被移出服务时，将调用`destroy`方法。这些方法可以被重写，并提供比构造函数和其他最终化可能性更细粒度的控制。servlet对象可以被多次放入服务，在调用`destroy`之后，servlet容器可能会再次调用`init`；因此，这个周期并不严格绑定到对象的生命周期。通常，在这些方法中我们不会做很多事情，但有时你可能需要在其中添加一些代码。
- en: Also, note that a single servlet object may be used to serve many requests,
    even at the same time; thus, the servlet classes and methods in it should be fairly
    thread-safe. The specification demands that a servlet container uses only one
    servlet instance in case the container runs in a non-distributed environment.
    In case the container runs on the same machine in several processes, each executing
    a JVM, or even on different machines, there can be many servlet instances that
    handle the requests. Generally, the servlet classes should be designed such that
    they do not assume that only one thread is executing them, but at the same time,
    they should also not assume that the instance is the same for different requests.
    We just cannot know.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，单个servlet对象可以用来处理多个请求，甚至可以同时处理；因此，其中的servlet类和方法应该是相当线程安全的。规范要求在容器在非分布式环境中运行时，servlet容器只使用一个servlet实例。如果容器在同一个机器上的多个进程中运行，每个进程执行一个JVM，或者甚至在不同的机器上运行，可能会有许多servlet实例来处理请求。通常，servlet类应该设计成它们不假设只有一个线程在执行它们，但同时也不能假设实例对不同的请求是相同的。我们根本无法知道。
- en: What does it mean in practice? You should not use instance fields that are specific
    to a certain request. In the example, the field initialized to hold the message
    holds the same value for each and every request; essentially, the variable is
    almost a final constant. It is used only to demonstrate some functionality for
    the `init` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实践中意味着什么？你不应该使用特定于某个请求的实例字段。在示例中，初始化以保存消息的字段对每个请求都保持相同的值；本质上，这个变量几乎是一个最终的常量。它仅用于演示`init`方法的一些功能。
- en: The `doGet` method is invoked when the servlet container gets an HTTP request
    with the `GET` method. The method has two arguments. The first one represents
    the request, and the second one represents the response. The `request` can be
    used to collect all information that comes in the request. In the preceding example,
    there is nothing like that. We do not use any of the inputs. If a request comes
    to our servlet, then we answer the `Hello, World` string, no matter what. Later,
    we will see examples when we read the parameters from the request. The `response`
    gives methods that can be used to handle the output. In the example, we fetch
    `PrintWriter`, which is to be used to send characters to the body of the HTTP
    response. This is the content that appears in the browser. The mime type we send
    is `text/html`, and this is set by calling the `setContentType` method. This will
    get into the HTTP header field, `Content-Type`. The standard and the JavaDoc documentation
    of the classes define all the methods that can be used, and also how these should
    be used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当Servlet容器接收到一个使用`GET`方法的HTTP请求时，会调用`doGet`方法。该方法有两个参数。第一个参数代表请求，第二个参数代表响应。可以使用`request`来收集请求中包含的所有信息。在先前的例子中，并没有这样的操作。我们并没有使用任何输入。如果有一个请求发送到我们的Servlet，那么无论什么情况，我们都将返回`Hello,
    World`字符串。稍后，我们将看到从请求中读取参数的例子。`response`提供了可以用来处理输出的方法。在例子中，我们获取了`PrintWriter`，它将被用来向HTTP响应的主体发送字符。这是在浏览器中显示的内容。我们发送的MIME类型是`text/html`，这是通过调用`setContentType`方法设置的。这将进入HTTP头字段`Content-Type`。类的标准文档和JavaDoc文档定义了所有可以使用的的方法，以及如何使用这些方法。
- en: 'Finally, we have a `web.xml` file that declares the servlets that are implemented
    in our code. This is, just as the name of the file indicates, an XML file. It
    declaratively defines all the servlets that are included in the archive and also
    other parameters. In the example, the parameters are not defined, only the servlet
    and the mapping to the URL. Since we have only one single servlet in this example,
    the WAR file, it is mapped to the root context. All and every `GET` request that
    arrives to the servlet container and to this archive will be served by this servlet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`web.xml`文件，它声明了我们代码中实现的Servlet。正如文件名所表明的，这是一个XML文件。它声明性地定义了存档中包含的所有Servlet以及其他参数。在例子中，参数没有被定义，只有Servlet和URL的映射。由于在这个例子中我们只有一个Servlet，所以WAR文件被映射到根上下文。所有到达Servlet容器和这个存档的`GET`请求都将由这个Servlet来处理：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Java Server Pages
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java服务器页面
- en: I promised you that I would not bore you with Java Server Pages because that
    is a technology of the past. Even though it is the past, it is still not history
    as there are many programs running that still use JSP and contain JSP code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我承诺过不会用Java服务器页面来让您感到无聊，因为那是一种过时的技术。尽管它是过时的，但它还没有成为历史，因为还有很多程序仍在使用JSP，并且包含JSP代码。
- en: JSP pages are web pages that contain HTML and Java code mixed. When an HTTP
    request is served by a JSP page, the servlet container reads the JSP page, executes
    the Java parts, takes the HTML parts as they are, and in this way, mixing the
    two together, creates an HTML page that is sent to the browser.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JSP页面是包含HTML和Java代码混合的网页。当一个HTTP请求由JSP页面服务时，Servlet容器读取JSP页面，执行Java部分，将HTML部分原样保留，以这种方式将两者混合在一起，创建一个发送到浏览器的HTML页面。
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding page will create an HTML page that contains the text `hallo` five
    times, each in a new line separated by the tag `br`. Behind the scenes, the servlet
    container converts the JSP page to a Java servlet, then compiles the servlet using
    the Java compiler, and then runs the servlet. It does it every time there is some
    change in the source JSP file; therefore, it is very easy to incrementally craft
    some simple code using JSP. The code that is generated from the preceding JSP
    file is 138 lines long (on the Tomcat 8.5.5 version), which is simply long and
    boring to list here, but the part that may help to understand how the Java file
    generation works is only a few lines.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前一页将创建一个包含`hallo`文本五次的HTML页面，每次都在新的行中，由`br`标签分隔。在幕后，Servlet容器将JSP页面转换为Java Servlet，然后使用Java编译器编译Servlet，然后运行Servlet。每次源JSP文件有变化时，它都会这样做；因此，使用JSP增量地编写一些简单的代码非常容易。从先前的JSP文件生成的代码有138行长（在Tomcat
    8.5.5版本上），这里简单地列出会非常冗长且无聊，但有助于理解Java文件生成过程的部分只有几行。
- en: If you want to see all the lines of the generated servlet class, you can deploy
    the application into a Tomcat server and look at the directory `work/Catalina/localhost/hello/org/apache/jsp/`.
    It is a rarely known fact among developers that this code is actually saved to
    disk and is available. Sometimes it helps when you need to debug some JSP pages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看生成的servlet类的所有行，可以将应用程序部署到Tomcat服务器，并查看目录`work/Catalina/localhost/hello/org/apache/jsp/`。这是一个很少为开发者所知的真相，即此代码实际上被保存到磁盘上，并且是可用的。有时当你需要调试一些JSP页面时，这很有帮助。
- en: 'Here are the few interesting lines generated from the preceding code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从前面的代码生成的几行有趣的内容：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The JSP compiler moves the inside of the JSP code out and the outside in. In
    the JSP code, Java is surrounded by HTML, and in the generated servlet Java source,
    the HTML is surrounded by Java. It is like when you want to mend clothes: the
    first thing is to turn the dress inside out.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JSP编译器将JSP代码的内部移到外部，外部移到内部。在JSP代码中，Java被HTML包围，而在生成的servlet Java源代码中，HTML被Java包围。这就像当你想修补衣服时：首先要做的就是将裙子翻过来。
- en: 'It is not only the Java code that you can mix into HTML in the JSP pages but
    also the so-called tags. Tags are collected into tag libraries, implemented in
    Java, and packaged into JAR files, and they should be available on the classpath
    to be used. The JSP page using the tags from some library should declare the use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以在JSP页面中将Java代码混合到HTML中，还可以混合所谓的标签。标签被收集到标签库中，用Java实现，并打包成JAR文件，它们应该在类路径上可用。使用某些库中标签的JSP页面应该声明使用：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The tags look like HTML tags, but they are processed by the JSP compiler and
    executed by the code implemented in the `taglib` library. JSP may also refer to
    the value of the Java objects that are available in the scope of the JSP. To do
    this inside the HTML page, the JSP expression language could be used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 标签看起来像HTML标签，但它们是由JSP编译器处理的，并由`taglib`库中实现的代码执行。JSP还可以引用JSP作用域内可用的Java对象值。要在HTML页面内完成此操作，可以使用JSP表达式语言。
- en: 'JSP was originally created to ease the development of a web application. The
    main advantage is the fast startup of development. There is no lengthy time for
    configuration, setup, and so on in the development, and when there is any change
    in the JSP page, there is no need to compile the whole application again: the
    servlet container generates the Java code, compiles it to class file, loads the
    code into memory, and executes. JSP was a competitor of Microsoft ASP pages, which
    mixed HTML with VisualBasic code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JSP最初是为了简化Web应用程序的开发而创建的。主要优势是快速启动开发。在开发过程中没有长时间的配置、设置等，当JSP页面有任何更改时，也不需要再次编译整个应用程序：servlet容器生成Java代码，将其编译成类文件，将其加载到内存中，并执行。JSP是Microsoft
    ASP页面的竞争对手，它们混合了HTML和VisualBasic代码。
- en: When the application starts to grow big, using the JSP technology causes more
    problems than are good. The code that mixes the business logic and the view of
    the application, how it is rendered in the browser, becomes messy. Developing
    JSP requires frontend technology knowledge. A Java developer is expected to know
    some frontend technology but is rarely a design expert and CSS guru. Modern code
    also contains JavaScript, many times embedded in the HTML page. After all, the
    big advantage of JSP is that it contains code that runs on the server as well
    as on the client-side code. The developers follow the paradigm many times, so
    do not be surprised to see some legacy code that contains Java, HTML, CSS, and
    JavaScript all mixed in a JSP file. Since Java and JavaScript are syntactically
    similar sometimes, it is not obvious to see what is executed on the server and
    what is executed on the client. I have even seen code that created JavaScript
    code from Java code in a JSP file. That is a total mix of different responsibilities
    and a mess that is nearly impossible to maintain. This led to the total deprecation
    of JSP as of today.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序开始变得庞大时，使用JSP技术会导致比好处更多的问题。混合业务逻辑和应用程序视图的代码，它在浏览器中的渲染变得混乱。开发JSP需要前端技术知识。Java开发者预期需要了解一些前端技术，但很少是设计专家和CSS大师。现代代码还包含JavaScript，很多时候嵌入在HTML页面中。毕竟，JSP的大优势是它包含在服务器端以及客户端运行的代码。开发者多次遵循这种模式，所以看到一些包含Java、HTML、CSS和JavaScript的遗留代码混合在一个JSP文件中并不奇怪。由于Java和JavaScript在某些情况下语法相似，很难看出在服务器上执行的是什么，在客户端执行的是什么。我甚至看到过在JSP文件中从Java代码创建JavaScript代码的代码。这是一个不同责任的完全混合，几乎无法维护的混乱。这导致了JSP今天被完全废弃。
- en: The deprecation of JSP is not official. It is my expert opinion. You may meet
    some experienced developers who are still in love with JSP, and you may find yourself
    in projects where you are required to develop programs in JSP. It is not shameful
    doing that. Some people do worse for money.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JSP的弃用并不是官方的。这是我的专业意见。你可能会遇到一些仍然热爱JSP的资深开发者，你也可能会发现自己身处需要用JSP开发程序的项目中。这样做并不丢人。有些人为了钱做得更糟。
- en: To mend the messy situation, there were technologies that advocated the separation
    of the server code and the client functionality more and more. These technologies
    include Wicket, Vaadin, JSF, and different Java templating engines, such as Freemarker,
    Apache Velocity, and Thymeleaf. These latter technologies can also be interesting
    when you generate textual output from Java even when the code is not web-related
    at all.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决混乱的局面，越来越多的技术倡导将服务器代码和客户端功能分离。这些技术包括Wicket、Vaadin、JSF以及不同的Java模板引擎，如Freemarker、Apache
    Velocity和Thymeleaf。这些后端技术在你从Java生成文本输出时也非常有趣，即使代码与Web无关。
- en: 'These technologies, with discipline, helped control the development and maintenance
    costs of moderate and large web projects, but the basic problem of the architecture
    was still there: no clear separation of concerns.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术，通过纪律性，有助于控制中等和大型Web项目的开发和维护成本，但架构的基本问题仍然存在：没有明确的关注点分离。
- en: 'Today, modern applications implement the code of a web application in separate
    projects: one for the client, using HTML, CSS and JavaScript, and a separate one
    to implement server functionality in Java (or in something else, but we focus
    here on Java). The communication between the two is the REST protocol, which we
    will cover in the subsequent chapters.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，现代应用程序在单独的项目中实现Web应用程序的代码：一个用于客户端，使用HTML、CSS和JavaScript，另一个用于在Java（或其它，但在此我们关注Java）中实现服务器功能。两者之间的通信是REST协议，我们将在后续章节中介绍。
- en: HTML, CSS, and JavaScript
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML、CSS和JavaScript
- en: HTML, CSS, and JavaScript are client-side technologies. These are extremely
    important for web applications, and a professional Java developer should have
    some knowledge about them. Nobody expects you to be an expert in Java and in web-client
    technologies at the same time, though this is not impossible. A certain understanding
    is desirable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: HTML、CSS和JavaScript是客户端技术。这些对于Web应用至关重要，一个专业的Java开发者应该对这些技术有所了解。虽然这并非不可能，但没有人期望你同时成为Java和Web客户端技术的专家。一定的理解是可取的。
- en: 'HTML is the textual representation of a structured text. The text is given
    as characters, as in any text file. Tags represent the structure. A start tag
    starts with a `<` character, then the name of the tag, then, optionally, `name="value"`
    attributes, and finally a closing `>` character. An end tag starts with `</`,
    then the name of the tag, and then `>`. Tags are enclosed into hierarchies; thus,
    you should not close a tag sooner than the one that was opened later. First, the
    tag that was opened last has to be closed, then the next, and so on. This way,
    any actual tag in the HTML has a level, and all tags that are between the start
    and end tags are *below* this tag. Some tags that cannot enclose other tags or
    text do not have end tags and stand on their own. Consider the following sample:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是有结构文本的文本表示。文本以字符形式给出，就像任何文本文件一样。标签代表结构。一个开始标签以`<`字符开始，然后是标签名，然后是可选的`name="value"`属性，最后是一个闭合的`>`字符。一个结束标签以`</`开始，然后是标签名，然后是`>`。标签被嵌套在层次结构中；因此，你不应该在打开的标签之前关闭一个标签。首先，最后打开的标签必须关闭，然后是下一个，依此类推。这样，HTML中的任何实际标签都有一个级别，并且所有在开始和结束标签之间的标签都位于此标签的*下方*。一些不能包含其他标签或文本的标签没有结束标签，它们独立存在。考虑以下示例：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The tag `head` is under `html`, and `title` is under `head`. This can be structured
    into a tree, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 标签`head`位于`html`之下，`title`位于`head`之下。这可以结构化为一个树，如下所示：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The browser stores the HTML text in a tree structure, and this tree is the object
    model of the web page document, thus the name, **Document Object Model** (**DOM**)
    tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器以树结构存储HTML文本，这个树是网页文档的对象模型，因此得名，**文档对象模型**（**DOM**）树。
- en: The original HTML concept mixed formatting and structure, and even with the
    current version of HTML5, we still have tags such as `b`, `i`, `tt` that suggest
    the browser to display the text between the start and end tags in bold, italics,
    and teletype, respectively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的HTML概念将格式和结构混合在一起，即使在当前的HTML5版本中，我们仍然有`b`、`i`、`tt`这样的标签，提示浏览器将开始和结束标签之间的文本以粗体、斜体和电传打字机字体显示。
- en: As the name HTML, standing for Hypertext Markup Language, suggests, the text
    can contain references to other web pages in the form of hyperlinks. These links
    are assigned to texts using the `a` tag (standing for anchor) or to some form
    that may consist of different fields, and when the submit button of the form is
    pressed, the content of the fields is sent to the server in a `POST` request.
    When the form is sent, the content of the fields is encoded in the so-called `application/x-www-form-urlencoded`
    form.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如HTML（超文本标记语言）这个名字所暗示的，文本可以包含以超链接形式指向其他网页的引用。这些链接使用`a`标签（代表锚点）或某些可能包含不同字段的形式分配，当表单的提交按钮被按下时，字段的内容以`POST`请求的形式发送到服务器。当表单被发送时，字段的内容被编码在所谓的`application/x-www-form-urlencoded`表单中。
- en: The HTML structure always tried to promote the separation of structure and formatting.
    To do so, formatting was moved to styles. Styles defined in **Cascading Style
    Sheets** (**CSS**) provide much more flexibility for formatting than HTML; the
    format of a CSS is more effective for formatting. The aim to create CSS was that
    the design can be decoupled from the structure of the text. If I had to choose
    one of the three, I would opt for CSS as the one that is least important for Java
    server-side web developers and, at the same time, the most important for the users
    (things should look nice).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: HTML结构总是试图促进结构和格式的分离。为此，格式被移动到样式。在**层叠样式表**（**CSS**）中定义的样式比HTML提供了更多的格式化灵活性；CSS的格式化效果更有效。创建CSS的目的是使设计可以从文本的结构中分离出来。如果我要在这三个中选择一个，我会选择CSS，因为它对于Java服务器端网络开发者来说最不重要，同时对于用户来说最重要（东西应该看起来很漂亮）。
- en: JavaScript is the third pillar of client-side technologies. JavaScript is a
    fully functional, interpreted programming language executed by the browser. It
    can access the DOM tree, and read and modify it. When the DOM tree is modified,
    the browser automatically displays the modified page. JavaScript functions can
    be scheduled and registered to be invoked when some event occurs. For example,
    you can register a function to be invoked when the document is fully loaded, when
    the user presses a button, clicks on a link, or just hovers the mouse over some
    section. Although JavaScript was first only used to create funny animations on
    the browser, today it is possible, and is a usual practice, to program fully functional
    clients using the capabilities of the browser. There are really powerful programs
    written in JavaScript, even such power-hungry applications as PC emulators.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是客户端技术的第三根支柱。JavaScript是一种由浏览器执行的完整功能、解释型编程语言。它可以访问DOM树，并读取和修改它。当DOM树被修改时，浏览器会自动显示修改后的页面。JavaScript函数可以被安排和注册，以便在某个事件发生时调用。例如，你可以注册一个函数，当文档完全加载、用户按下按钮、点击链接或鼠标悬停在某个部分上时调用该函数。尽管JavaScript最初仅用于在浏览器上创建有趣的动画，但如今，使用浏览器的功能来编写完全功能性的客户端是可能的，并且已经成为一种常见的做法。确实有一些用JavaScript编写的强大程序，甚至包括像PC模拟器这样耗能的应用程序。
- en: In this book, we focus on Java and use the client-side technologies as much
    as is needed for demonstration technologies. However, being a Java web developer
    professional, you have to learn these technologies as well, to some extent at
    least, to understand what a client can do and to be able to cooperate with the
    professionals responsible for frontend technologies.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们专注于Java，并在演示技术所需的最大程度上使用客户端技术。然而，作为一个Java网络开发者专业人士，你至少在一定程度上必须学习这些技术，以便理解客户端能做什么，并能与负责前端技术的专业人士合作。
- en: Mastermind servlet
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大脑.servlet
- en: Playing the Mastermind game via the Web is a bit different from what it used
    to be. Till now, we did not have any user interaction and our classes were designed
    accordingly. For example, we could add a new guess to the table, along with the
    partial and full matches calculated by the program. Now we have to separate the
    creation of a new guess, add it to the game, and set the full and partial matches.
    This time, we have to display the table first, and the user has to calculate and
    provide the number of matches.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络玩Mastermind游戏与过去有点不同。到目前为止，我们没有用户交互，我们的类也是相应设计的。例如，我们可以向表格添加一个新的猜测，包括程序计算出的部分和完全匹配。现在我们必须分离新猜测的创建、将其添加到游戏中以及设置完全和部分匹配。这次，我们必须首先显示表格，然后用户必须计算并提供匹配的数量。
- en: 'We have to modify some of the classes to be able to do that. We need to add
    a new method to `Game.java`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须修改一些类才能做到这一点。我们需要向`Game.java`添加一个新方法：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Till now, we had only one method that was adding a new guess, and since the
    program knew the secret, it was immediately calculating the value of `full` and
    `partial`. The name of the method could be `addNewGuess`, overloading the original
    method, but this time, the method is used not only to add a new guess but also
    to add old guesses to rebuild the table.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只有一个方法，那就是添加一个新的猜测，因为程序知道秘密，所以它立即计算出`full`和`partial`的值。这个方法的名字可以是`addNewGuess`，它覆盖了原始方法，但这次，这个方法不仅用于添加新的猜测，还用于添加旧的猜测以重建表格。
- en: When the program starts, there are no guesses. The program creates one, the
    first one. Later on, when the user tells the program the full and partial matches,
    the program needs the `Game` structure with `Table` and `Row` objects containing
    `Guess` objects and the `full` and `partial` match values. These were already
    available, but when the new HTTP hit comes in, we have to pull it from somewhere.
    Programming a servlet, we have to store the state of the game somewhere and restore
    it when a new HTTP request hits the server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，没有猜测。程序创建一个，第一个。后来，当用户告诉程序完整的和部分的匹配时，程序需要包含`Guess`对象以及`full`和`partial`匹配值的`Game`结构体和`Table`以及`Row`对象。这些已经可用，但当新的HTTP请求到来时，我们必须从某处获取它。在编写servlet时，我们必须将游戏状态存储在某处，并在新的HTTP请求击中服务器时恢复它。
- en: Storing state
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储状态
- en: Storing the state can be done in two places. One place, which we will first
    do in our code, is the client. When the program creates a new guess, it adds it
    to the table and sends an HTML page that contains not only the new guess but also
    all the previous guesses and the `full` and `partial` match values that the user
    gave for each of the rows. To send the data to the server, the values are stored
    in the fields of a form. When the form is submitted, the browser gathers the information
    in the fields, creates an encoded string from the content of the fields, and puts
    the content into the body of a `POST` request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的存储可以在两个地方进行。一个地方，我们将在我们的代码中首先做，是客户端。当程序创建一个新的猜测时，它将其添加到表格中，并发送一个包含不仅新的猜测，还包括所有之前的猜测以及用户为每一行提供的`full`和`partial`匹配值的HTML页面。为了将数据发送到服务器，这些值存储在表单的字段中。当表单提交时，浏览器收集字段中的信息，从字段内容创建一个编码字符串，并将内容放入`POST`请求的主体中。
- en: The other possibility for storing the actual state is in the server. The server
    can store the state of the game, and it can reconstruct the structure when it
    creates a new guess. The problem in this case is knowing which game to use. The
    server can and should store many games, one for each user, and users may use the
    application concurrently. It does not necessarily mean strong concurrency in the
    same meaning as we examined in the previous chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 存储实际状态的另一种可能性是在服务器上。服务器可以存储游戏状态，并在创建新的猜测时重建结构。在这种情况下的问题是我们知道使用哪个游戏。服务器可以也应该存储许多游戏，每个用户一个，用户可能并发使用应用程序。这并不一定意味着像我们在上一章中检查的那样强并发。
- en: Even if the users are not served at the same time in multiple threads, there
    can be games that are active. Imagine `cnn.com` telling you that you cannot read
    the news at the moment because somebody else is reading it. There can be multiple
    users playing multiple games, and while serving an HTTP request, we should know
    which user we are serving.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户不是在多个线程中同时被服务，也可能存在一些活跃的游戏。想象一下`cnn.com`告诉你现在不能阅读新闻，因为其他人正在阅读。可能有多个用户在玩多个游戏，而在处理HTTP请求时，我们应该知道我们正在为哪个用户服务。
- en: Servlets maintain sessions that can be used for this purpose as we will see
    in the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Servlets维护会话，我们将在下一节中看到，这些会话可以用于此目的。
- en: HTTP session
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP会话
- en: When a client sends requests from the same browser to the same servlet, the
    series of requests belong to one session. To know that the requests belong to
    the same session, the servlet container automatically sends a cookie named `JSESSIONID`
    to the client, and this cookie has a long, random, hard-to-guess value (`tkojxpz9qk9xo7124pvanc1z`
    as I run the application in Jetty). The servlet maintains a session store that
    contains the `HttpSession` instances. The key string that travels in the value
    of the `JSESSIONID` cookie identifies the instances. When an HTTP request arrives
    at the servlet, the container attaches the session to the request object from
    the store. If there is no session for the key, then one is created, and the code
    can access the session object by calling the `request.getSession()` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端从同一浏览器向同一Servlet发送请求时，一系列请求属于一个会话。为了知道请求属于同一个会话，Servlet容器会自动向客户端发送一个名为`JSESSIONID`的cookie，并且这个cookie有一个长、随机、难以猜测的值（例如，我在Jetty中运行应用程序时，值为`tkojxpz9qk9xo7124pvanc1z`）。Servlet维护一个包含`HttpSession`实例的会话存储。在`JSESSIONID`cookie的值中传递的键字符串标识了这些实例。当一个HTTP请求到达Servlet时，容器将存储中的会话附加到请求对象。如果没有为键创建会话，那么就会创建一个，代码可以通过调用`request.getSession()`方法来访问会话对象。
- en: A `HttpSession` object can store attributes. The program can call the `setAttribute(String,Object)`,
    `getAttribute(String)`, and `removeAttribute(String)` methods to store, retrieve,
    or delete an attribute object. Each attribute is assigned to a `String` and can
    be any `Object`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpSession`对象可以存储属性。程序可以通过调用`setAttribute(String,Object)`、`getAttribute(String)`和`removeAttribute(String)`方法来存储、检索或删除属性对象。每个属性都分配给一个`String`，可以是任何`Object`。'
- en: Although the session attribute store essentially looks as simple as a `Map<String,?>`
    object, it is not. The values stored in the session can be moved from one node
    to another when the servlet container runs in a clustered or other distributed
    environment. To do that, the values are serialized; therefore, the values stored
    in the session should be `Serializable`. Failing to do so is a very common novice
    error. During development, executing the code in a simple development Tomcat or
    Jetty container practically never serializes the session to disk and never loads
    it from the serialized form. This means that the values set using `setAttribute`
    will be available by calling `getAttribute`. We run into trouble the first time
    the application gets installed in a clustered environment. As soon as a HTTP request
    arrives on different nodes `getAttribute` may return `null`. The method `setAttribute`
    is called on one node and during the processing of the next request `getAttribute`
    on a different node cannot deserialize the attribute value from the disk shared
    among the nodes. This is usually, and sadly, the production environment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管会话属性存储在本质上看起来就像一个`Map<String,?>`对象一样简单，但实际上并非如此。当Servlet容器在集群或其他分布式环境中运行时，存储在会话中的值可以从一个节点移动到另一个节点。为了做到这一点，这些值会被序列化；因此，存储在会话中的值应该是`Serializable`。未能这样做是一个非常常见的初学者错误。在开发过程中，在简单的开发Tomcat或Jetty容器中执行代码几乎永远不会将会话序列化到磁盘，也永远不会从序列化形式加载它。这意味着使用`setAttribute`设置的值将通过调用`getAttribute`来可用。当应用程序第一次在集群环境中安装时，我们会遇到麻烦。一旦不同的节点上有HTTP请求到达，`getAttribute`可能会返回`null`。在第一个节点上调用`setAttribute`，而在处理下一个请求时，在另一个节点上的`getAttribute`无法从节点之间共享的磁盘上反序列化属性值。这通常，并且遗憾的是，是在生产环境中发生的。
- en: You, as a developer, should also be aware that serializing and de-serializing
    an object is a heavy operation that costs several CPU cycles. If the structure
    of the application uses only a part of the client state serving most of the HTTP
    requests, then this is a waste of CPU to create the whole state in memory from
    a serialized form and then serializing it again. In such cases, it is more advisable
    to store only a key in the session and use some database (SQL or NoSQL) or some
    other service to store the actual data referenced by the key. Enterprise applications
    almost exclusively use this structure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你应该知道序列化和反序列化对象是一项耗时的操作，它需要消耗几个CPU周期。如果应用程序的结构只使用客户端状态的一部分来服务大多数HTTP请求，那么从序列化形式在内存中创建整个状态然后再进行序列化是一种CPU资源的浪费。在这种情况下，更明智的做法是只在会话中存储一个键，并使用某些数据库（SQL或NoSQL）或其他服务来存储由键引用的实际数据。企业应用程序几乎完全使用这种结构。
- en: Storing state on the client
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端存储状态
- en: 'First, we will develop our code storing the state on the client. The form needed
    to send the user input and the number of new full and partial matches, also contains
    all the previous colors for all the guesses and answers given at that time by
    the user. To do so, we create a new helper class to format the HTML code. This
    is something that is done in a modern enterprise environment using templates,
    JSP files, or just totally avoided using pure REST and a one-page application
    in the enterprise environment. Nevertheless, here we will use the old technology
    in order to demonstrate the gears that rotate under the hood of modern engines:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开发我们的代码，将状态存储在客户端。所需的表单用于发送用户输入和新的完全匹配和部分匹配的数量，还包含用户在那时给出的所有猜测和答案的先前颜色。为此，我们创建了一个新的辅助类来格式化HTML代码。这是在现代企业环境中使用模板、JSP文件或完全避免使用纯REST和单页应用程序所做的事情。尽管如此，在这里我们将使用旧技术来演示现代引擎底下的齿轮：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Except the `@Inject` annotation, the rest of the code is simple and straightforward.
    We will focus on `@Inject` later but very soon. What we have to focus on is the
    HTML structure the code generates. The generated page will look something like
    this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`@Inject`注解之外，其余的代码简单直接。我们将在稍后专注于`@Inject`，但很快就会进行。我们必须关注的是代码生成的HTML结构。生成的页面将看起来像这样：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The form contains the colors in the form of DIV tags, and it also contains
    the "letter" of the color in hidden fields. These input fields are sent to the
    server when the form is submitted, just like any other field, but they do not
    appear on the screen and the user cannot edit them. The full and partial matches
    are displayed in the text input fields. Since it is not possible to display the
    `Color` objects in an HTML text, we use `LetteredColor` and `LetteredColorFactory`,
    which assign single letters to colors. The first 6 colors are simply numbered as
    `0`, `1`, `2`, `3`, `4` and `5`. A CSS file can control how the colors will look
    on the browser window. You may remember that we covered how and where to implement
    the display of individual colors. First, we created a special printing class that
    was assigning letters to already existing colors, but that was usable only in
    a very limited environment (unit tests mainly). Now, we have the issue again.
    We have the lettered color, but now we need real colors as this time we have a
    client display that is capable of displaying colors. The real power of modern
    web technology shines here. The content and the format can be separated from each
    other. The pegs of different colors are listed in HTML as `div` tags. They have
    a formatting class but the actual look is defined in a CSS file that is responsible
    for nothing else but the look:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表单包含以DIV标签形式呈现的颜色，并且它还包含颜色的“字母”在隐藏字段中。这些输入字段在表单提交时发送到服务器，就像任何其他字段一样，但它们不会出现在屏幕上，用户无法编辑它们。完全匹配和部分匹配显示在文本输入字段中。由于无法在HTML文本中显示`Color`对象，我们使用`LetteredColor`和`LetteredColorFactory`，它们将单个字母分配给颜色。前6种颜色简单地编号为`0`、`1`、`2`、`3`、`4`和`5`。CSS文件可以控制颜色在浏览器窗口中的外观。你可能还记得我们介绍了如何和在哪里实现单个颜色的显示。首先，我们创建了一个特殊的打印类，它将字母分配给已经存在的颜色，但只能在非常有限的环境中（主要是单元测试）使用。现在，我们再次遇到了这个问题。我们有字母颜色，但现在我们需要真正的颜色，因为这次我们有一个能够显示颜色的客户端显示。现代网络技术的真正力量在这里闪耀。内容和格式可以彼此分离。不同颜色的木桩在HTML中以`div`标签的形式列出。它们有一个格式化类，但实际的外观由负责外观的CSS文件定义：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Dependency injection with Guice
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Guice进行依赖注入
- en: 'The servlet class is very simple as shown in the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，servlet类非常简单：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because many threads use servlets concurrently, and thus we cannot use instance
    fields holding data for a single hit, the servlet class does nothing else but
    create a new instance of a `MastermindHandler` class and invoke its `handle` method.
    Since there is a new instance of `MastermindHandler` for each request, it can
    store objects in fields specific to the request. To create a handler, we use the
    Guice library created by Google.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多线程并发使用servlet，因此我们不能使用仅持有单个击中数据的实例字段，servlet类除了创建一个`MastermindHandler`类的新实例并调用其`handle`方法之外，不做其他任何事情。由于每个请求都有一个新的`MastermindHandler`实例，它可以在特定于请求的字段中存储对象。要创建处理器，我们使用由Google创建的Guice库。
- en: 'We have already talked about dependency injection. The handler needs a `Table`
    object to play, a `ColorManager` object to manage the colors, and a `Guesser`
    object to create a new guess, but creating these or fetching some prefabricated
    instances from somewhere is not the core functionality of the handler. The handler
    has to do one thing: handle the request; the instances needed to do this should
    be injected from outside. This is done by a `Guice` injector.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了依赖注入。处理程序需要一个 `Table` 对象来玩游戏，一个 `ColorManager` 对象来管理颜色，以及一个 `Guesser`
    对象来创建一个新的猜测，但创建这些或从某处获取预制的实例并不是处理程序的核心功能。处理程序必须做一件事：处理请求；完成此操作所需的所有实例应从外部注入。这是通过
    `Guice` 注入器完成的。
- en: 'To use Guice, we have to list the library among the dependencies in `build.gradle`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Guice，我们必须在 `build.gradle` 的依赖项中列出库：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we have to create an `injector` instance that will do the injection. The
    injector is created with the following line in the servlet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须创建一个 `injector` 实例，该实例将执行注入。在 servlet 中，通过以下行创建 injector：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The instance of `MastermindModule` specifies what to inject where. This is
    essentially a configuration file in the Java format. Other dependency injector
    frameworks used, and use, XML and annotations to describe the injection binding
    and what to inject where, but Guice solely uses Java code. The following is the
    DI configuration code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`MastermindModule` 的实例指定了在哪里注入什么。这本质上是一个 Java 格式的配置文件。其他使用的依赖注入器框架和它们使用 XML
    和注解来描述注入绑定以及在哪里注入什么，但 Guice 仅使用 Java 代码。以下是对 DI 配置代码的说明：'
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The methods used in the `configure` method are created in a fluent API manner
    so that the methods can be chained one after the other and that the code can be
    read almost like English sentences. A good introduction to fluent API can be found
    at [https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/).
    For example, the first configuration line could be read in English as
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `configure` 方法中使用的方法是以流畅 API 的方式创建的，以便方法可以一个接一个地链接，并且代码可以几乎像英语句子一样阅读。可以在 [https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/)
    找到流畅 API 的良好介绍。例如，第一配置行可以用英语这样阅读：
- en: '*Bind to the class* `int` *wherever it is annotated with the* `@Name` *annotation
    having value* `"nrColor"` *to the instance* `6`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*将类* `int` *绑定到任何带有* `@Name` *注解且值为* `"nrColor"` *的实例* `6`。'
- en: (Note that the `int` value `6` is autoboxed to an `Integer` instance.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，`int` 值 `6` 被自动装箱为 `Integer` 实例。）
- en: 'The `MastermindHandler` class contains fields annotated with `@Inject` annotation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`MastermindHandler` 类包含带有 `@Inject` 注解的字段：'
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This annotation is not Guice-specific. `@Inject` is a part of the `javax.inject`
    package and is a standard part of JDK. JDK does not provide the **dependency injector**
    (**DI**) framework but supports the different frameworks so that they can use
    standard JDK annotations, and in case the DI framework is replaced, the annotations
    may remain the same and not framework-specific.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解不是 Guice 特有的。`@Inject` 是 `javax.inject` 包的一部分，并且是 JDK 的标准部分。JDK 不提供 **依赖注入器**（**DI**）框架，但支持不同的框架，以便它们可以使用标准
    JDK 注解，并且如果 DI 框架被替换，注解可能保持不变，而不是框架特定的。
- en: When the injector is called to create an instance of `MastermindHandler`, it
    looks at the class and sees that it has an `int` field annotated with `@Inject`
    and `@Named("nrColors")`, and finds in the configuration that such a field should
    have the value 6\. It injects the value to the field before returning the `MastermindHandler`
    object. Similarly, it also injects the values into the other fields, and if it
    should create any of the objects to be injected, it does. If there are fields
    in these objects, then they are also created by injecting other objects and so
    on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当 injector 被调用以创建 `MastermindHandler` 的实例时，它会查看类，并看到它有一个带有 `@Inject` 和 `@Named("nrColors")`
    注解的 `int` 字段，并在配置中找到这样一个字段应该具有值 6。在返回 `MastermindHandler` 对象之前，它将值注入到字段中。同样，它也将值注入到其他字段中，如果它应该创建任何要注入的对象，它也会这样做。如果这些对象中有字段，那么它们也将通过注入其他对象来创建，依此类推。
- en: This way the DI framework removes the burden from the programmers' shoulder
    to create the instances. This is something fairly boring and is not the core feature
    of the classes anyway. Instead, it creates all the objects needed to have a functional
    `MastermindHandler` and links them together via the Java object references. This
    way, the dependencies of the different objects (`MastermindHandler` needs `Guesser`,
    `ColorManager`, and `Table`; `ColorManager` needs `ColorFactory`; and `Table`
    also needs `ColorManager`, and so on) become a declaration, specified using annotations
    on the fields. These declarations are inside the code of the classes, and it is
    the right place for them. Where else could we specify what the class needs to
    properly function than in the class itself?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，DI 框架从程序员肩上移除了创建实例的负担。这本来就是一个相当无聊的事情，而且这并不是类的核心功能。相反，它创建了所有需要的对象以使 `MastermindHandler`
    功能化，并通过 Java 对象引用将它们链接在一起。这样，不同对象之间的依赖关系（`MastermindHandler` 需要 `Guesser`、`ColorManager`
    和 `Table`；`ColorManager` 需要 `ColorFactory`；`Table` 也需要 `ColorManager`，等等）变成了一个声明，通过在字段上使用注解来指定。这些声明在类的代码内部，这是它们正确的位置。我们还能在哪里指定一个类需要什么才能正常工作，除了在类本身之外？
- en: The configuration in our example specifies that wherever there is a need for
    `ColorFactory`, we will use `LetteredColorFactory`, and that wherever we need
    `Guesser`, we will use `UniqueGuesser`. This is separated from the code and it
    has to be like that. If we want to change the guessing strategy, we replace the
    configuration and the code should work without modifying the classes that use
    the guesser.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的配置指定了，无论何时需要 `ColorFactory`，我们将使用 `LetteredColorFactory`，而无论何时需要 `Guesser`，我们将使用
    `UniqueGuesser`。这部分与代码分离，并且必须这样。如果我们想更改猜测策略，我们替换配置，代码应该可以在不修改使用猜测器的类的情况下正常工作。
- en: 'Guice is clever enough and you need not specify that wherever there is a need
    for `Table`, we will use `Table`: there is no `bind(Table.class).to(Table.class)`.
    First I created a line like that in the configuration, but Guice rewarded me with
    an error message, and now, writing it again in plain English, I feel really stupid.
    If I need a table I need a table. Really?'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Guice 足够聪明，你不需要指定无论何时需要 `Table`，我们将使用 `Table`：没有 `bind(Table.class).to(Table.class)`。最初我在配置中创建了一条这样的线，但
    Guice 给我返回了一个错误信息，现在，用普通的英语再次写它，我觉得自己真的很愚蠢。如果我需要一个表格，我就需要一个表格。真的吗？
- en: The MastermindHandler class
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MastermindHandler 类
- en: 'We have already started the listing of the `MastermindHandler` class, and since
    this class is more than a hundred lines, I will not include it here as a whole.
    The most important method of this class is `handle`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始了 `MastermindHandler` 类的列举，由于这个类有一百多行，所以我不会在这里全部列出。这个类最重要的方法是 `handle`：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We perform three steps. Step 1 is creating the table and we do it from the request.
    If this is not the start of the game, there is already a table and the HTML form
    contains all previous guess colors and the answers to those. Then, as the second
    step, we create a new guess based on that. Step 3 is to send the new HTML page
    to the client.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行三个步骤。第一步是创建表格，我们从请求中创建它。如果不是游戏的开始，已经有一个表格，HTML 表单包含了所有之前的猜测颜色和相应的答案。然后，作为第二步，我们根据这些创建一个新的猜测。第三步是将新的
    HTML 页面发送到客户端。
- en: Again, this is not a modern approach, creating HTML on the servlet code, but
    demonstrating pure servlet functionality with REST, JSON, and JavaScript with
    some framework would make this chapter alone a few hundred pages long, and it
    would definitely distract our focus from Java.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不是一个现代的方法，在 servlet 代码中创建 HTML，但仅用 REST、JSON 和 JavaScript 以及一些框架来展示纯
    servlet 功能，就会使这一章的内容达到几百页，这肯定会分散我们对 Java 的注意力。
- en: Printing HTML text to a `PrintWriter` is not something that should be new to
    you at this point in this book; therefore, we will not list that code here. You
    can download the working example on GitHub. The branch for this version of the
    code is `nosession`. Instead of printing, we will focus on the servlet parameter
    handling.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTML 文本打印到 `PrintWriter` 在这本书的这个阶段不应该对你来说是新事物；因此，我们这里不会列出那段代码。你可以在 GitHub
    上下载工作示例。这个代码版本的分支是 `nosession`。我们不会关注打印，而是将重点放在 servlet 参数处理上。
- en: The request parameters are available via the `getParameter` method, which returns
    the string value of a parameter. This method assumes that any parameter, be it
    `GET` or `POST`, appears only once in the request. In case there are parameters
    that appear multiple times, the value should have been a string array. In such
    a case, we should use `getParameterMap`, which returns the whole map with the
    `String` keys and `String[]` values. Even though we do not have multiple values
    for any key this time, and we also know the values of the keys coming as `POST`
    parameters, we will still use the latter method. The reason for this is that we
    will later use the session to store these values, and we want to have a method
    that is reusable in that case.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请求参数可以通过 `getParameter` 方法获得，该方法返回参数的字符串值。此方法假设任何参数，无论是 `GET` 还是 `POST`，在请求中只出现一次。如果存在多次出现的参数，其值应该是一个字符串数组。在这种情况下，我们应该使用
    `getParameterMap`，它返回包含 `String` 键和 `String[]` 值的整个映射。尽管这次我们没有任何键的多个值，我们也知道作为
    `POST` 参数传入的键的值，我们仍然会使用后者。这样做的原因是，我们稍后会将这些值存储在会话中，我们希望有一个在这种情况下可重用的方法。
- en: If you look at the earlier commits in the Git repository, you will see that
    the first version used `getParameter` and I refactored it only later when I created
    the second version of the program, which stores the state in a session. Never
    believe if anyone tells you that programs are created perfectly upfront without
    any refactoring during development. Do not feel ashamed to create foolish code
    and refactor it later. It is only shameful if you do not refactor it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 Git 仓库中的早期提交，你会看到第一个版本使用了 `getParameter`，而我只是在创建程序的第二个版本时对其进行了重构，该版本将状态存储在会话中。不要相信任何人告诉你程序在开发过程中一开始就完美无缺，没有任何重构。不要因为创建了愚蠢的代码而感到羞愧，稍后进行重构。如果你不重构，那才是可耻的。
- en: 'To get to that we convert the request''s `Map<String,String[]>` to `Map<String,String>`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们将请求的 `Map<String,String[]>` 转换为 `Map<String,String>`：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we use that map to re-create the game:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用那个映射来重新创建游戏：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The conversion from `String` to `int` is done via the method `parseInt`. This
    method throws `NumberFormatException` when the input is not a number. Try to run
    the game, use the browser, and see how Jetty handles the case when the servlet
    throws an exception. How much valuable information do you see in the browser that
    can be used by a potential hacker? Fix the code so that it asks the user again
    if any of the numbers are not well formatted!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `String` 转换为 `int` 是通过 `parseInt` 方法完成的。当输入不是数字时，此方法会抛出 `NumberFormatException`。尝试运行游戏，使用浏览器，看看
    Jetty 如何处理当 servlet 抛出异常的情况。浏览器中显示了多少有价值的信息，可以被潜在的黑客利用？修复代码，以便在数字格式不正确时再次询问用户！
- en: Storing state on the server
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上存储状态
- en: The application state should usually not be saved on the client. There may be
    some special case in addition to the one where you write educational code and
    want to demonstrate how to do it. Generally, the state of the application related
    to the actual use is stored in the session object or on some database. This is
    especially important when the application requests the user to enter a lot of
    data and does not want the user to lose the work if there is some hiccup in the
    client computer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的状态通常不应该保存在客户端。除了编写教育代码并演示如何操作的特殊情况外，可能还有一些特殊情况。通常，与实际使用相关的应用程序状态存储在会话对象或某些数据库中。这在应用程序请求用户输入大量数据且不希望用户在客户端计算机出现故障时丢失工作的情况下尤为重要。
- en: You spend a lot of time selecting the appropriate items in an online shop, choosing
    the appropriate items that work together, creating a configuration of your new
    model airplane, and all of a sudden, there is a blackout in your home. If the
    state were stored on the client you'd have had to start from scratch. If the state
    is stored on the server, the state is saved to disk; the servers are duplicated,
    fed by battery-backed power supplies, and when you reboot your client machine
    when the power comes back in your home, you log in, and miraculously, the items
    are all there in your shopping basket. Well, it is not a miracle; it is web programming.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你在在线商店中花费大量时间选择合适的商品，选择可以协同工作的商品，创建你新模型飞机的配置，突然，你家停电了。如果状态存储在客户端，你就不得不从头开始。如果状态存储在服务器上，状态会被保存到磁盘；服务器被复制，由电池供电，当你家恢复供电并重新启动客户端计算机时，你登录，奇迹般地，购物车里的商品都在那里。好吧，这不是奇迹；这是网络编程。
- en: In our case, the second version will store the state of the game in the session.
    This will let the user have the game restore so long as the session is there.
    If the user quits and restarts the browser, the session gets lost and a new game
    can start.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，第二个版本会将游戏状态存储在会话中。这样，只要会话存在，用户就可以恢复游戏。如果用户退出并重新启动浏览器，会话就会丢失，可以开始新的一局游戏。
- en: 'Since there is no need to send the actual colors and matching in hidden fields
    this time, the HTML generation is modified a bit, and the generated HTML will
    also be simpler:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这次不需要在隐藏字段中发送实际的颜色和匹配信息，HTML 生成器也做了一些修改，生成的 HTML 也会更简单：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The number of full and partially matching colors is displayed as a simple number,
    so this version does not allow *cheating* or changing previous results. (These
    are the numbers `0` and `2` after the `div` tags that have the CSS class `spacer`.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 完全匹配和部分匹配的颜色数量以简单的数字形式显示，因此这个版本不允许*作弊*或更改之前的结果。（这些数字是 `0` 和 `2`，位于具有 `spacer`
    CSS 类的 `div` 标签之后。）
- en: 'The `handle` method in `MastermindHandler` also changes, as shown in the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`MastermindHandler` 中的 `handle` 方法也发生了变化，如下所示：'
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This version of the class gets a `SessionSaver` object injected by the Guice
    injector. This is a class that we create. This class will convert the current
    Table into something that is stored in the session, and it also recreates the
    table from the data stored in the session. The `handle` method uses the `buildGameFromSessionAndRequest`
    method to restore the table and to add the full and partial match answers that
    the user just gave in the request. When the method creates a new guess and fills
    it in the table, and also sends it to the client in the response, it saves the
    state in the session by calling the `save` method via the `sessionSaver` object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的版本通过 Guice 注入器获取一个 `SessionSaver` 对象。这是一个我们创建的类。这个类将当前的表格转换为存储在会话中的内容，并且也可以从会话中存储的数据重新创建表格。`handle`
    方法使用 `buildGameFromSessionAndRequest` 方法来恢复表格，并添加用户在请求中刚刚给出的完整和部分匹配答案。当方法创建一个新的猜测并填写到表格中，并将其发送到客户端的响应中时，它通过
    `sessionSaver` 对象调用 `save` 方法来保存状态。
- en: 'The `buildGameFromSessionAndRequest` method replaces the other version, which
    we named `buildGameFromRequest`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildGameFromSessionAndRequest` 方法替换了另一个版本，我们将其命名为 `buildGameFromRequest`：'
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that this version has the same illness of using the `parseInt` method from
    the `Integer` class in JDK, which throws an exception.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个版本与使用 JDK 中 `Integer` 类的 `parseInt` 方法有相同的毛病，它会抛出异常。
- en: The GameSessionSaver class
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GameSessionSaver` 类'
- en: 'This class has three public methods:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有三个公共方法：
- en: '`save`: This saves a table to the user session'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save`：将表格保存到用户会话中'
- en: '`restore`: This gets a table from the user session'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restore`：从用户会话中获取表格'
- en: '`reset`: This deletes any table that may be in the session'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`：删除会话中可能存在的任何表格'
- en: 'The code of the class is the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 类的代码如下：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When we save the session and convert the table to a map, we use a `HashMap`.
    The implementation in this case is important. The `HashMap` class implements the
    `Serializable` interface; therefore, we can be safe putting it to the session.
    This alone does not guarantee that everything in `HashMap` is `Serializable`.
    The keys and the values in our case are Strings, and fortunately, the `String`
    class also implements the `Serializable` interface. This way, the converted `HashMap`
    object can be safely stored in the session.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存会话并将表格转换为映射时，我们使用 `HashMap`。在这个情况下，实现很重要。`HashMap` 类实现了 `Serializable`
    接口；因此，我们可以安全地将它放入会话中。这本身并不能保证 `HashMap` 中的所有内容都是 `Serializable`。在我们的案例中，键和值是字符串，幸运的是，`String`
    类也实现了 `Serializable` 接口。这样，转换后的 `HashMap` 对象就可以安全地存储在会话中。
- en: Also note that, although serialization can be slow, storing `HashMap` in a session
    is so frequent that it implements its own serialization mechanism. This implementation
    is optimized and avoids serialization being dependent on the internal structure
    of the map.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，尽管序列化可能会很慢，但将 `HashMap` 存储在会话中是如此频繁，以至于它实现了自己的序列化机制。这个实现是经过优化的，避免了序列化依赖于映射的内部结构。
- en: 'It is time to think about why we have the `convertTableToMap` method in this
    class and `buildGameFromMap` in `MastermindHandler`. Converting the game and the
    table in it to a `Map` and the other way round should be implemented together.
    They are just two directions of the same conversion. On the other hand, the implementation
    of the `Table` to `Map` direction should use a `Map` version that is `Serializable`.
    This is very much related to session handling. Converting a `Map` object, in general,
    to a `Table` object is one level higher, restoring the table from wherever it
    was stored: client, session, database, or in the moisture of the cloud. Session
    storage is only one possible implementation, and methods should be implemented
    in the class that meets the abstraction level.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候思考为什么我们在类中有`convertTableToMap`方法，而在`MastermindHandler`中有`buildGameFromMap`。将游戏及其中的表格转换为`Map`以及相反的操作应该一起实现。它们只是同一转换的两个方向。另一方面，`Table`到`Map`方向的实现应该使用一个`Serializable`版本的`Map`。这与会话处理有很大关系。通常，将`Map`对象转换为`Table`对象是更高一级的操作，从任何存储位置恢复表格：客户端、会话、数据库，或在云的湿度中。会话存储只是可能的实现之一，并且应该在满足抽象级别的类中实现这些方法。
- en: The best solution could be to implement these in a separate class. You have
    homework!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解决方案是在一个单独的类中实现这些功能。你有家庭作业！
- en: 'The `reset` method is not used from the handler. This is invoked from the `Mastermind`
    class, that is, the servlet class to reset the game when we start it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset`方法不是从处理器中使用的。它是从`Mastermind`类中调用的，即servlet类，在我们启动游戏时重置游戏：'
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Without this, playing the game against the machine once would just display the
    finished game every time we want to start it again, until we exit the browser
    and restart it or explicitly delete the `JSESSIONID` cookie somewhere in the advanced
    menu of the browser. Calling `reset` does not delete the session. The session
    remains the same, and thus the value of `JSESSIONID` too, but the game is deleted
    from the session object that the servlet container maintains.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个，与机器玩一次游戏就会在每次我们想要再次启动时显示完成的游戏，直到我们退出浏览器并重新启动它，或者明确地在浏览器的高级菜单中删除`JSESSIONID`cookie。调用`reset`不会删除会话。会话保持不变，因此`JSESSIONID`的值也保持不变，但游戏已从servlet容器维护的会话对象中删除。
- en: Running the Jetty web servlet
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Jetty网络servlet
- en: 'Since we have included the Jetty plugin into our Gradle build, the targets
    of the plugin are available. To start Jetty is as easy as typing the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将Jetty插件包含到我们的Gradle构建中，插件的目标现在是可用的。要启动Jetty，只需输入以下命令即可：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will compile the code, build the WAR file, and start the Jetty servlet
    container. To help us remember, it also prints the following on the command line:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译代码，构建WAR文件，并启动Jetty servlet容器。为了帮助我们记住，它还在命令行上打印以下内容：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can open this URL and see the opening screen of the game with the colors
    that the program created as a first guess:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开这个URL，查看游戏的开场屏幕，其中包含了程序作为第一次猜测所创建的颜色：
- en: '![](img/00046.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: 'Now it is time to have some fun and play with our game, giving answers to the
    program. Do not make it easy for the code! Refer to the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候享受一些乐趣，玩我们的游戏，向程序给出答案。不要让代码变得容易！参考以下截图：
- en: '![](img/00047.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: 'At the same time, if you look at the console where you have typed `gradle jettyRun`,
    you will see that the code is printing out log messages, as shown in the following
    screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果你查看你输入`gradle jettyRun`的终端，你会看到代码正在打印日志消息，如下面的截图所示：
- en: '![](img/00048.gif)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.gif)'
- en: These printouts come through the logger that we have in our code. In the previous
    chapters, we used the `System.out.println` method calls to send informational
    messages to the console. This is a practice that should not be followed in any
    program that is more complex than a *hello world*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些打印输出是通过我们代码中的记录器完成的。在前面的章节中，我们使用了`System.out.println`方法调用将信息消息发送到控制台。这种做法不应该在任何比“hello
    world”更复杂的程序中使用
- en: Logging
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录日志
- en: 'There are several logging frameworks available for Java and each has advantages
    and disadvantages. There is one built into JDK in the `java.util.logging` package
    and accessing the logger is supported by the `System.getLogger` method: the `System.Logger`
    and `System.LoggerFinder` classes. Even though `java.util.logging` has been available
    in Java since JDK 1.4, a lot of programs use other logging solutions. In addition
    to the built-in logging, we have to mention `log4j`, `slf4j` and Apache Commons
    Logging. Before getting into the details of the different frameworks, let''s discuss
    why it is important to use logging instead of just printing to the standard output.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，有几种日志框架可供选择，每种都有其优缺点。有一个内置在JDK的`java.util.logging`包中，通过`System.getLogger`方法支持访问记录器：`System.Logger`和`System.LoggerFinder`类。尽管`java.util.logging`自JDK
    1.4以来就可用，但许多程序使用其他日志解决方案。除了内置的日志记录外，我们还需要提及`log4j`、`slf4j`和Apache Commons Logging。在深入探讨不同框架的细节之前，让我们讨论一下为什么使用日志而不是仅仅打印到标准输出是很重要的。
- en: Configurability
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可配置性
- en: The most important reason is configurability and ease of use. We use logging
    to record information about the operation of code. This is not the core functionality
    of the application but is inevitable to have a program that can be operated. There
    are messages we print out to the log, which can be used by the operating personnel
    to identify environmental issues. For example, when an `IOException` is thrown
    and it gets logged, the operation may look at the logs and identify that the disk
    got full. They may delete files, or add a new disk and extend the partition. Without
    the logs, the only information would be that the program does not work.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的原因是可配置性和易用性。我们使用日志来记录代码运行的信息。这并不是应用程序的核心功能，但拥有一个可操作的程序是不可避免的。我们打印到日志的消息可以被操作人员用来识别环境问题。例如，当抛出`IOException`并被记录时，操作人员可能会查看日志并确定磁盘已满。他们可能会删除文件，或者添加新磁盘并扩展分区。没有日志，唯一的信息就是程序无法工作。
- en: The logs are also used many times to hunt down bugs. Some of the bugs do not
    manifest in the test environment and are very difficult to reproduce. In such
    a case, the logs that print out detailed information about the execution of the
    code are the only source of finding the root cause of some error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 日志也被多次用于查找错误。有些错误在测试环境中不会显现，并且很难重现。在这种情况下，打印出代码执行详细信息的日志是找到某些错误根本原因的唯一来源。
- en: Since logging needs CPU, IO bandwidth, and other resources, it should be carefully
    examined what and when to log. This examination and the decisions could be done
    during programming, and as a matter of fact, that is the only possibility if we
    used `System.out.println` for logging. If we need to find a bug, we should log
    a lot. If we log a lot, the performance of the system will go down. The conclusion
    is that we have to log only if it is needed. If there is a bug in the system that
    cannot be reproduced, the developers ask the operation to switch on debug logging
    for a short period. Switching on and off different parts of logging is not possible
    when `System.out.println` is used. When the debug level log is switched on, the
    performance may go down for a while, but at the same time, the logs become available
    for analysis. At the same time, the analysis is simpler when we have to find the
    log lines that are relevant (and you do not know beforehand which are relevant)
    if there is a small (a few hundred megabytes log file) rather than a lot of 2-GB
    compressed log files to find the lines in.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志记录需要CPU、IO带宽和其他资源，因此需要仔细考虑记录什么和何时记录。这项检查和决策可以在编程期间完成，实际上，如果我们使用`System.out.println`进行日志记录，那才是唯一可能的方式。如果我们需要查找错误，我们应该记录很多。如果我们记录很多，系统的性能将会下降。结论是我们只有在需要时才进行记录。如果系统中存在无法重现的错误，开发者会要求运维在短时间内开启调试日志。当使用`System.out.println`时，无法切换开启和关闭不同的日志部分。当开启调试级别的日志时，性能可能会暂时下降，但同时，日志将可用于分析。同时，当我们需要找到相关的日志行（而你事先并不知道哪些是相关的）时，分析会变得更加简单，尤其是当日志文件较小（几百兆字节）而不是大量2GB的压缩日志文件时，要找到这些行。
- en: Using a log framework, you can define loggers that identify the source of the
    log messages and log levels. A string usually identifies the logger, and it is
    a common practice to use the name of the class from which the log message is created.
    This is such a common practice that the different log frameworks provide factory
    classes that get the class itself, instead of its name, to get a logger.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志框架，你可以定义记录器来标识日志消息的来源和日志级别。一个字符串通常用来标识记录器，并且使用创建日志消息的类的名称作为记录器的名称是一种常见的做法。这是一个如此常见的做法，以至于不同的日志框架提供了工厂类，这些类获取类本身，而不是它的名称，以获取记录器。
- en: 'The possible logging levels may be slightly different in different logging
    frameworks, but the most important levels are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的日志框架中可能的日志级别可能略有不同，但最重要的级别如下：
- en: '`FATAL`: This is used when the log message is about some error that prevents
    the program from continuing its execution.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FATAL`：当日志消息是关于某些错误，阻止程序继续执行时使用。'
- en: '`ERROR`: This is used when there is some severe error, but the program can
    still go on functioning although, probably, in some limited manner.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR`：当存在某些严重错误时使用，尽管程序可能仍然可以继续运行，但可能是在某些有限的方式下。'
- en: '`WARNING`: This is used when there is some condition that is not a direct problem
    but may later lead to an error if not attended. For example, the program recognizes
    that a disk is near full, some database connections answer within limits but close
    to the timeout value, and similar situations.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING`：当存在某种条件不是直接问题，但如果不注意可能会后来导致错误时使用。例如，程序识别到磁盘快满了，一些数据库连接在限制内但接近超时值，以及类似的情况。'
- en: '`INFO`: This is used to create messages about normal operations that may be
    interesting to operate and are not an error or warning. These messages may help
    the operation to debug the operational environment settings.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO`：用于创建关于正常操作的消息，这些消息可能对操作有趣，但不是错误或警告。这些消息可能有助于调试操作环境设置。'
- en: '`DEBUG`: This is used to log information about the program that is detailed
    enough (hopefully) to find a bug in the code. The trick is that when we put the
    log statement into the code, we do not know what bug it could be. If we knew,
    we better fixed it.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG`：用于记录关于程序的详细信息，这些信息足够详细（希望如此），可以找到代码中的错误。技巧是，当我们将日志语句放入代码中时，我们不知道它可能是什么错误。如果我们知道了，我们最好修复它。'
- en: '`TRACE`: This is even more detailed information about the execution of the
    code.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`：这是关于代码执行的更详细的信息。'
- en: The log frameworks are usually configured using some configuration file. The
    configuration may limit the logging, switching off certain levels. In a normal
    operational environment, the first three levels are usually switched on, and `INFO`,
    `DEBUG`, and `TRACE` are switched on when really needed. It is also possible to
    switch on and off certain levels only for certain loggers. If we know that the
    error is certainly in the `GameSessionSaver` class, then we can switch on the `DEBUG`
    level only for that class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 日志框架通常使用一些配置文件进行配置。配置可能限制了日志记录，关闭某些级别。在正常操作环境中，通常前三个级别是开启的，当真正需要时，会开启`INFO`、`DEBUG`和`TRACE`级别。也有可能只为某些日志记录器开启或关闭特定级别。如果我们知道错误肯定在`GameSessionSaver`类中，那么我们只为该类开启`DEBUG`级别。
- en: 'Log files may also contain other information that we did not directly code
    and would be very cumbersome to print to the standard output. Usually, each log
    message contains the precise time when the message was created, the name of the
    logger, and, many times, the identifier of the thread. Imagine if you were forced
    to put all this to each and every `println` argument; you would probably soon
    write some extra class to do that. Don''t! It has already been done professionally:
    it is the logger framework.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件可能还包含我们没有直接编码的其他信息，直接打印到标准输出会非常繁琐。通常，每个日志消息都包含消息创建的确切时间、记录器的名称，以及很多时候线程的标识符。想象一下，如果你被迫将所有这些信息放入每个`println`参数中，你可能会很快编写一个额外的类来做这件事。不要这样做！这已经由专业人士完成了：这就是日志框架。
- en: Loggers can also be configured to send the message to different locations. Logging
    to the console is only one possibility. Logging frameworks are prepared to send
    messages to files, database, Windows Event Recorder, syslog service, or to any
    other target. This flexibility, which message to print, what extra information
    to print, and where to print is reached by separating the different tasks that
    the logger framework does into several classes following the single responsibility
    principle.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器也可以配置为将消息发送到不同的位置。将日志记录到控制台只是其中一种可能性。日志框架准备将消息发送到文件、数据库、Windows事件记录器、syslog服务或任何其他目标。这种灵活性，即打印什么消息，打印什么额外信息，以及打印在哪里，是通过将记录器框架执行的不同任务分离成几个类，遵循单一责任原则来实现的。
- en: The logger frameworks usually contain loggers that create the logs, formatters
    that format the message from the original log information, many times, adding
    information such as thread ID and time stamp, and appenders that append the formatted
    message to some destination. These classes implement interfaces defined in the
    logging framework and nothing but the size of the book stops us from creating
    our own formatters and appenders.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 日志框架通常包含创建日志的记录器，格式化原始日志信息的格式化器，很多时候还会添加线程ID和时间戳等信息，以及将格式化后的消息追加到某个目标位置的追加器。这些类实现了日志框架中定义的接口，而阻止我们创建自己的格式化和追加器的，仅仅是书籍的大小。
- en: When a log is configured, the appenders and formatters are configured, given
    the class that implements them. Therefore, when you want to send some logs to
    some special destination, you are not limited to the appenders that are provided
    by the authors of the framework. There are a lot of independent open-source projects
    for different logging frameworks providing appenders for different targets.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置日志时，会配置追加器和格式化器，给定实现它们的类。因此，当你想要将一些日志发送到某个特殊位置时，你不仅限于框架作者提供的追加器。有许多独立的开源项目为不同的日志框架提供针对不同目标的追加器。
- en: Performance
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: The second reason to use a logging framework is performance. Although it is
    not good to optimize for performance before we profile the code (premature optimization),
    using some methodology known to be slow and inserting several lines into our performance-critical
    code, invoking slow methods is not really professional either. Using a well-established,
    highly optimized framework in a way that is industry best practice should not
    be questionable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志框架的第二个原因是性能。尽管在分析代码之前优化性能（过早优化）并不好，但使用已知较慢的方法并在性能关键代码中插入几行，调用慢速方法也不是真正的专业做法。以行业最佳实践的方式使用经过良好建立、高度优化的框架，不应存在问题。
- en: 'Using `System.out.println` sends the message to a stream and returns only when
    the IO operation is done. Using real logging handles the information to the logger
    and lets the logger do the logging asynchronously, and it does not wait for completion.
    It is really a drawback that log information may be lost if there is some system
    failure, but this is usually not a serious issue considering how rarely that happens
    and what is on the other side of the wage: performance. What do we lose if there
    is a missing debug log line when the disk got full, anyway rendering the system
    unusable?'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `System.out.println` 将消息发送到流中，并且只有在IO操作完成后才返回。使用真正的日志处理会将信息传递给记录器，并让记录器异步进行日志记录，而不等待完成。如果发生系统故障，日志信息可能会丢失，但这通常不是一个严重的问题，考虑到这种情况发生的频率很低，以及权衡的另一面：性能。如果磁盘满了，丢失了调试日志行，我们到底失去了什么？这会导致系统无法使用。
- en: 'There is one exception to this: audit logging—when some log information about
    the transactions of the system has to be saved for legal reasons so that the operation
    and the actual transactions can be audited. In such a case, the log information
    is saved in a transactional manner, making the log part of the transaction. Because
    that is a totally different type of requirement, audit logging is not usually
    done with any of these frameworks.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例外：审计日志——当系统事务的某些日志信息必须保存以供法律原因审计操作和实际交易时。在这种情况下，日志信息以事务方式保存，使日志成为交易的一部分。因为这是一个完全不同的要求，审计日志通常不使用这些框架中的任何一个。
- en: Also, `System.out.println` is not synchronized and that way different threads
    may just garble the output. Log frameworks pay attention to this issue.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`System.out.println` 不是同步的，因此不同的线程可能会混乱输出。日志框架关注这个问题。
- en: Log frameworks
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志框架
- en: The most widely used logging framework is **Apache****log4j**. It currently
    has a second version that is a total rewrite of the first version. It is very
    versatile and has many appenders and formatters. The configuration of log4j can
    be in XML or properties file format, and it can also be configured through API.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的日志框架是**Apache**log4j。它目前有一个第二版，是对第一版的完全重写。它非常灵活，拥有许多附加器和格式化工具。log4j的配置可以是XML或属性文件格式，也可以通过API进行配置。
- en: 'The author of log4j version 1 created a new logging framework: **slf4j**. This
    logging library is essentially a façade that can be used together with any other
    logging framework. Thus, when you use slf4j in a library you develop, and your
    code is added to a program as a dependency that uses a different logging framework,
    it is easy to configure slf4j to send the logs to the loggers of the other framework.
    Thus, the logs will be handled together and not in separate file, which is desirable
    to decrease the cost of operation. When developing your library code or an application
    that uses slf4j, there is no need to select another log framework to slf4j. It
    has its own simple implementation called backlog.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: log4j版本1的作者创建了一个新的日志框架：**slf4j**。这个日志库本质上是一个外观，可以与任何其他日志框架一起使用。因此，当你在开发的库中使用slf4j，并且你的代码作为一个依赖项添加到使用不同日志框架的程序中时，很容易配置slf4j将日志发送到其他框架的日志记录器。这样，日志将一起处理，而不是分别存储在不同的文件中，这有助于降低运营成本。在开发你的库代码或使用slf4j的应用程序时，没有必要选择另一个日志框架来替代slf4j。它有一个名为backlog的简单实现。
- en: Apache Commons Logging is also a façade with its own logging implementation
    if nothing else fails. The major difference from slf4j is that it is more flexible
    in configuration and what underlying logging to use, and it implements a run-time
    algorithm to discover which logging framework is available and is to be used.
    The industry best practice shows that this flexibility, which also comes with
    higher complexity and cost, is not needed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他方法都失败，Apache Commons Logging也是一个具有自己日志实现的日志外观。与slf4j的主要区别在于它在配置和选择底层日志方面更加灵活，并实现了一个运行时算法来发现可用的日志框架以及要使用的框架。行业最佳实践表明，这种灵活性（同时也伴随着更高的复杂性和成本）并不是必需的。
- en: Java 9 logging
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9日志
- en: 'Java 9 includes a facade implementation for logging. The use is very simple
    and we can expect that logging frameworks will very soon start to support this
    façade. The fact that this façade is built into the JDK has two major advantage:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9包含一个日志外观的实现。使用非常简单，我们可以预期日志框架很快就会开始支持这个外观。这个外观内置在JDK中的事实有两个主要优势：
- en: The libraries that want to log do not need to have any dependency on any logging
    framework or logging façade any more. The only dependency is the JDK log façade
    that is there anyway.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要记录日志的库不再需要依赖任何日志框架或日志外观。唯一的依赖是JDK日志外观，它无论如何都是存在的。
- en: The JDK libraries that log themselves use this façade and thus they will log
    into the same log file as the application.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK中记录日志的库使用这个外观，因此它们将记录到与应用程序相同的日志文件中。
- en: 'If we use the JDK-provided logging façade the start of the `ColorManager` class
    will be changed to the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用JDK提供的日志外观，`ColorManager`类的开始将变为以下内容：
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this version we do not import the slf4j classes. Instead we import the `java.lang.System.Logger`
    class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们不导入slf4j类。相反，我们导入`java.lang.System.Logger`类。
- en: Note that we do not need to import the System class, because the classes from
    the `java.lang` package are automatically imported. This is not true for the classes
    that are nested classes in the `System` class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要导入System类，因为`java.lang`包中的类会自动导入。对于`System`类中的嵌套类，则不适用此规则。
- en: To get access to the logger the `System.getLogger` static method is called.
    This method finds the actual logger that is available and returns one for the
    name that we pass as argument. There is no version of the method `getLogger` that
    accepts the class as the argument. If we want to stick to the convention then
    we have to write `ColorManager.class.getName()` to get the name of the class or
    we can write there the name of the class as a string. The second approach has
    the drawback that it does not follow the change of the name of the class. Intelligent
    IDEs like IntelliJ, Eclipse, or Netbeans rename the references to classes automatically
    but they have a hard time when the name of the class is used in a string.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取访问日志记录器的权限，需要调用 `System.getLogger` 静态方法。此方法找到可用的实际日志记录器，并返回一个与作为参数传递的名称相对应的日志记录器。没有
    `getLogger` 方法的版本接受类作为参数。如果我们想坚持约定，那么我们必须编写 `ColorManager.class.getName()` 来获取类的名称，或者我们可以直接将类的名称作为字符串写入。第二种方法的缺点是它不会跟随类名称的变化。像
    IntelliJ、Eclipse 或 Netbeans 这样的智能 IDE 会自动重命名对类的引用，但当类名称被用作字符串时，它们会遇到困难。
- en: 'The interface `System.Logger` does not declare the convenience methods `error`,
    `debug`, `warning`, and so on, that are familiar from other logging frameworks
    and façade. There is only one method named `log` and the first argument of this
    method is the level of the actual log we issue. There are eight levels defined:
    `ALL`, `TRACE`, `DEBUG`, `INFO`, `WARNING`, `ERROR,` and `OFF`. When creating
    a log message we are supposed to use one of the middle six levels. `ALL` and `OFF`
    are meant to be passed to the `isLoggable` method. This method can be used to
    check if the actual logging level gets logged or not. For example, if the level
    is set to `INFO` then messages sent with `DEBUG` or `TRACE` will not be printed.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `System.Logger` 没有声明类似于其他日志框架和外观中常见的便利方法 `error`、`debug`、`warning` 等。这里只有一个名为
    `log` 的方法，该方法的第一个参数是我们实际发出的日志级别。定义了八个级别：`ALL`、`TRACE`、`DEBUG`、`INFO`、`WARNING`、`ERROR`
    和 `OFF`。在创建日志消息时，我们应该使用中间六个级别之一。`ALL` 和 `OFF` 是用来传递给 `isLoggable` 方法的。这个方法可以用来检查实际的日志级别是否会被记录。例如，如果级别设置为
    `INFO`，那么使用 `DEBUG` 或 `TRACE` 发送的消息将不会被打印。
- en: 'The actual implementation is located by the JDK using the service loader functionality.
    The log implementation has to be in a module that provides the interface `java.lang.System.LoggerFinder`
    via some implementation. In other words the module should have a class that implements
    the `LoggerFinder` interface and the `module-info.java` should declare which class
    it is using the code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 实际实现是通过 JDK 使用服务加载器功能定位的。日志实现必须在一个提供 `java.lang.System.LoggerFinder` 接口的模块中。换句话说，该模块应该有一个实现
    `LoggerFinder` 接口的类，并且 `module-info.java` 应该声明它使用的代码：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `MyLoggerFinder` class has to extend the `LoggerFinder` abstract class with
    the method `getLogger`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyLoggerFinder` 类必须扩展 `LoggerFinder` 抽象类，并实现 `getLogger` 方法。'
- en: Logging practice
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录实践
- en: The practice of logging is very simple. If you do not want to spend too much
    time experimenting with different logging solutions and you do not have some special
    requirement, then simply go with slf4j, add the JAR to the dependency list as
    a compile dependency, and start using logging in the source code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录实践非常简单。如果你不想花太多时间实验不同的日志解决方案，也没有特殊要求，那么只需使用 slf4j，将其 JAR 添加到依赖列表中作为编译依赖项，然后在源代码中开始使用日志记录。
- en: 'Since logging is not instance-specific, and loggers implement thread safety,
    the log objects that we usually use are stored in a `static` field, and since
    they are used as long as the class is used, the program running the field is also
    `final`. For example using the slf4j façade we can get a logger with the following
    command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志记录不是实例特定的，并且日志记录器实现了线程安全，我们通常使用的日志对象存储在 `static` 字段中，并且只要类被使用，它们就会被使用，因此运行字段的程序也是
    `final` 的。例如，使用 slf4j 外观，我们可以使用以下命令获取日志记录器：
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To get the logger, the logger factory is used, which just creates the logger
    or returns the one that is already available.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取日志记录器，使用日志记录器工厂，它只是创建日志记录器或返回已存在的日志记录器。
- en: The name of the variable is usually `log` or `logger,` but do not be surprised
    if you see `LOG` or `LOGGER`. The reason for uppercasing the name of the variable
    is that some static code analysis checkers treat `static final` variables as constants,
    as they really are, and the convention in the Java community is to use uppercase
    names for such variables. It is a matter of taste; many times `log` and `logger` are
    used in lowercase.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的名称通常是 `log` 或 `logger,` 但如果你看到 `LOG` 或 `LOGGER` 也不会感到惊讶。将变量名称大写的原因是，一些静态代码分析检查器将
    `static final` 变量视为常量，正如它们确实那样，Java 社区的惯例是使用大写名称来表示这类变量。这纯粹是个人喜好问题；很多时候 `log`
    和 `logger` 都使用小写。
- en: 'To create a log item the methods `trace`, `debug`, `info`, `warn`, and `error`
    create a message with the respective level as the name implies. For example, consider
    the following line:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建日志项，`trace`、`debug`、`info`、`warn` 和 `error` 方法会创建一个消息，其名称表示相应的级别。例如，考虑以下行：
- en: '[PRE35]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It creates a debug message. Slf4j has support for formatting using the `{}`
    literal inside strings. This way, there is no need to append the string from small
    parts, and in case the actual log item is not sent to the log destination, the
    formatting will not perform. If we use `String` concatenation in any form to pass
    a string as an argument, then the formatting will happen even if debug logging
    is not desired as per the example.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个调试消息。Slf4j 支持使用字符串中的 `{}` 文字符号进行格式化。这样，就没有必要将字符串从小的部分拼接起来，并且如果实际的日志项没有发送到日志目标，格式化将不会执行。如果我们以任何形式使用
    `String` 连接来传递字符串作为参数，那么即使不需要调试日志，格式化也会发生。
- en: 'The logging methods also have a version that gets only two arguments: a `String`
    message and `Throwable`. In this case, the logging framework will take care of
    the output of the exception and the stack trace along with it. If you log something
    in exception handling code, log the exception and let the logger format it.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 记录方法也有只接受两个参数的版本：一个 `String` 消息和一个 `Throwable`。在这种情况下，记录框架将负责输出异常及其堆栈跟踪。如果你在异常处理代码中记录某些内容，请记录异常并让记录器格式化它。
- en: Other technologies
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他技术
- en: We discussed the servlet technology, a bit of JavaScript, HTML, and CSS. When
    programming in a real professional environment, these technologies are generally
    used. The creation of the user interface of applications, however, was not always
    based on these technologies. Older operating system-native GUI applications as
    well as Swing, AWT, and SWT use a different approach to create UI. They build
    up the UI facing the user from program code, and the UI is built as a hierarchical
    structure of components. When web programming started, Java developers had experience
    with technologies like these and projects created frameworks that tried to hide
    the web technology layer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了 servlet 技术、一点 JavaScript、HTML 和 CSS。在实际的专业编程环境中，这些技术通常会被使用。然而，应用程序用户界面的创建并不总是基于这些技术。较老的操作系统原生
    GUI 应用程序以及 Swing、AWT 和 SWT 使用不同的方法来创建 UI。它们从程序代码中构建面向用户的 UI，UI 被构建为一个组件的分层结构。当网络编程开始时，Java
    开发者对这些技术有经验，并创建了尝试隐藏网络技术层的框架。
- en: One technology worth mentioning is Google Web Toolkit, which implements the
    server as well as the browser code in Java, but since there is no Java environment
    implemented in the browsers, it transpiles (converts) the client part of the code
    from Java to JavaScript. The last release of the toolkit was created two years
    ago in 2014 and since then Google has released other types of web programming
    toolkits that support native JavaScript, HTML, and CSS client development.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的一项技术是 Google Web Toolkit，它使用 Java 实现了服务器和浏览器代码，但由于浏览器中没有实现 Java 环境，它将客户端代码的部分从
    Java 转译（转换）为 JavaScript。该工具包的最后一个版本是在两年前的 2014 年创建的，从那时起，Google 已经发布了支持原生 JavaScript、HTML
    和 CSS 客户端开发的其它类型的网络编程工具包。
- en: '**Vaadin** is also a toolkit that you may come across. It lets you write GUI
    code on the server in Java. It is built on top of GWT and is commercially supported.
    It may be a good choice in case there are developers available who have experience
    with GUI development in Java but not in web native technologies, and the application
    does not require special usability tuning on the client side. A typical intranet
    corporate application can select it as a technology.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vaadin** 也是一个你可能遇到的工具包。它允许你在服务器上用 Java 编写 GUI 代码。它建立在 GWT 之上，并得到商业支持。如果有一些有
    Java GUI 开发经验的开发者，但不是在原生网络技术方面，并且应用程序不需要在客户端进行特殊可用性调整，那么它可能是一个不错的选择。一个典型的企业内部网络应用程序可以选择它作为技术。'
- en: '**Java Server Faces** (**JSF**) is a technology that tries to offload the client-side
    development of the application from the developers providing widgets ready to
    be used and the server side. It is a collection of several **Java Specification
    Requests** (**JSR**) and there are several implementations. The components and
    their relations are configured in XML files and the server creates the client
    native code. In this technology, there is no transpilation from Java to JavaScript.
    It is more like using a limited but huge set of widgets, limiting the use to those
    only, and giving up direct programming of the web browser. If one has the experience
    and knowledge, however, they can create new widgets in HTML, CSS, and JavaScript.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java服务器端面**（**JSF**）是一种试图将应用程序的客户端开发从提供现成小部件的开发者那里卸载下来的技术，同时也处理服务器端。它是一系列**Java规范请求**（**JSR**）的集合，并且有多个实现。组件及其关系在XML文件中配置，服务器创建客户端本地代码。在这个技术中，没有从Java到JavaScript的编译。它更像是使用一个有限但庞大的小部件集，限制使用仅限于这些小部件，并放弃直接编程Web浏览器的做法。然而，如果一个人有经验和知识，他们可以在HTML、CSS和JavaScript中创建新的小部件。'
- en: There are many other technologies that were developed to support web applications
    in Java. The modern approach advocated by most of the big players is to develop
    the server side and the client side using separate toolsets and methodologies, and
    connect the two using REST communication.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持Java中的Web应用程序，还开发了其他许多技术。大多数大型玩家提倡的现代方法是使用不同的工具集和方法来开发服务器端和客户端，并通过REST通信将两者连接起来。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learnt the structure of web programming. This was not possible
    without understanding the basics of TCP/IP networking, which is the protocol of
    the Internet. The application level protocol that is used over that is HTTP, currently
    in a very new version 2.0, which is still not supported by the servlet standard.
    We created a version of the Mastermind game that, this time, can really be played
    using the browser and we started it in a development environment using Jetty.
    We examined how to store the game state and implemented two versions. Finally,
    we learned the basics of logging and we looked at other technologies. At the same
    time, we also looked at the dependency injection implementation Guice from Google,
    and we studied how it works under the hood, and why and how to use it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Web编程的结构。没有理解TCP/IP网络的基础知识，这是互联网的协议，这是不可能的。在之上使用的应用层协议是HTTP，目前是全新的2.0版本，但Servlet标准仍然不支持它。我们创建了一个Mastermind游戏的版本，这次它真的可以通过浏览器来玩，我们使用Jetty在开发环境中启动了它。我们研究了如何存储游戏状态，并实现了两个版本。最后，我们学习了日志记录的基础知识，并探讨了其他技术。同时，我们还研究了Google的依赖注入实现Guice，并研究了它在内部是如何工作的，以及为什么以及如何使用它。
- en: After this chapter, you will be able to start the development of a web application
    in Java and will understand the architecture of such a program. You will understand
    what is under the hood when you start learning how to program web applications
    using the Spring framework, which hides many of the complexities of web programming.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将能够开始使用Java开发一个Web应用程序，并理解此类程序的结构。当你开始学习如何使用Spring框架编程Web应用程序时，你将了解其内部的工作原理，Spring框架隐藏了许多Web编程的复杂性。
