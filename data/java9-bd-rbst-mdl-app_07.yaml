- en: Experimenting with the Java Shell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Java Shell 中进行实验
- en: In the previous chapter, we explored how to migrate pre-Java 9 applications
    to the new Java platform. We examined several issues that might cause your current
    applications to have problems running on Java 9\. We started with a review of
    Project Jigsaw and then looked at how modules fit into the new Java platform.
    We provided you with insights and processes to get your Java 8 code working with
    Java 9\. Specifically, we provided tips for migration planning, shared advice
    from Oracle regarding migration, and shared tools that you can use to help you
    as you get started with Java 9.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何将 Java 9 之前的应用程序迁移到新的 Java 平台。我们检查了可能导致你的当前应用程序在 Java 9 上运行出现问题的几个问题。我们从
    Project Jigsaw 的回顾开始，然后探讨了模块如何适应新的 Java 平台。我们为你提供了使你的 Java 8 代码与 Java 9 一起工作的见解和流程。具体来说，我们提供了迁移规划的建议、分享了
    Oracle 关于迁移的建议，并分享了你可以使用的工具，以帮助你开始使用 Java 9。
- en: In this chapter, we will take our first look at the new command line, **read-eval-print
    loop** (also referred to as **REPL**) tool in Java 9, the **Java Shell** (**JShell**).
    We will start with introductory information regarding the tool, the read-eval-print
    loop concept, and move into the commands and command-line options for use with
    JShell. We will take a practitioner's approach to our review of the Java Shell
    and include examples you can try on your own.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首次了解 Java 9 中的新命令行工具，**读取-评估-打印循环**（也称为 **REPL**），即 **Java Shell**（**JShell**）。我们将从有关工具、读取-评估-打印循环概念的基础信息开始，然后进入用于
    JShell 的命令和命令行选项。我们将采用实践者的方法来审查 Java Shell，并包括你可以尝试的示例。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: What is JShell?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 JShell？
- en: Getting started with JShell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 JShell
- en: Practical uses of JShell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JShell 的实际用途
- en: Working with scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与脚本一起工作
- en: What is JShell?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 JShell？
- en: JShell is a new tool introduced with Java 9\. It is an interactive read-eval-print
    loop tool that is used to evaluate the following Java programming language components--declarations,
    statements, and expressions. It has its own API so that it can be used by external
    applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 是 Java 9 中引入的一个新工具。它是一个交互式的读取-评估-打印循环工具，用于评估以下 Java 编程语言组件——声明、语句和表达式。它拥有自己的
    API，因此可以被外部应用程序使用。
- en: Read-Eval-Print Loop is often referred to as REPL, taking the first letter from
    each word in the phrase. It is also knows language shell or interactive top-level.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 读取-评估-打印循环通常被称为 REPL，取自短语中每个单词的首字母。它也被称为语言壳或交互式顶层。
- en: 'The introduction of JShell was a result of **Java Enhancement Program** (**JEP**)
    222\. Here are the stated goals of this JEP in regards to the Java Shell command-line
    tool:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 的引入是 **Java Enhancement Program** （**JEP**） 222 的结果。以下是关于 Java Shell
    命令行工具的 JEP 的声明目标：
- en: Facilitate rapid investigation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进快速调查
- en: Facilitate rapid coding
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进快速编码
- en: Provide an edit history
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供编辑历史
- en: The rapid investigation and coding listed previously includes statements and
    expressions. Impressively, these statements and expressions do not need to be
    part of a method. Furthermore, variables and methods are not required to be part
    of a class, making this tool especially dynamic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列出的快速调查和编码包括语句和表达式。令人印象深刻的是，这些语句和表达式不需要是方法的一部分。此外，变量和方法不需要是类的一部分，这使得这个工具特别灵活。
- en: 'In addition, the following listed features were included to make JShell much
    easier to use and to make your time using JShell as time-efficient as possible:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下列出的功能被包括进来，使 JShell 更易于使用，并使你在使用 JShell 的时间尽可能高效：
- en: Tab-completion
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制表符自动完成
- en: Auto-completion for end-of-statement semicolons
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句末尾分号的自动完成
- en: Auto-completion for imports
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入的自动完成
- en: Auto-completion for definitions
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自动完成
- en: Getting Started with JShell
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 JShell
- en: 'JShell is a command-line tool that is located in the `/bin` folder. The syntax
    for this tool is `jshell <options> <load files>`. As you can see here, there are
    several options that can be used with this tool:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 是一个位于 `/bin` 文件夹中的命令行工具。此工具的语法是 `jshell <options> <load files>`。正如你所看到的，这个工具可以使用多个选项：
- en: '![](img/b2ef8526-1897-4cef-9f78-50c6ccfcdedb.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2ef8526-1897-4cef-9f78-50c6ccfcdedb.png)'
- en: You have already seen the `-h` option, that we executed with `jshell -h`. This
    provided the listing of JShell options.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `-h` 选项，我们通过 `jshell -h` 执行了它。这提供了 JShell 选项的列表。
- en: 'To log into your JShell, you simply use the `jshell` command. You will see
    that the prompt in the command window changes accordingly:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要登录JShell，您只需使用`jshell`命令。您会看到命令窗口中的提示符相应地改变：
- en: '![](img/7f5ddaac-4a99-48a4-98f4-a51c35d46e2d.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f5ddaac-4a99-48a4-98f4-a51c35d46e2d.png)'
- en: 'Exiting the shell is as easy as entering `/exit`. Once inside the JShell, you
    can enter any of the following commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 退出shell就像输入`/exit`一样简单。一旦进入JShell，您就可以输入以下任何命令：
- en: '| **Command** | **Functionality** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **功能** |'
- en: '| `/drop` | Use this command to delete a source entry that is referenced by
    `name` or `id`. Here is the syntax:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/drop` | 使用此命令通过`name`或`id`引用删除源条目。以下是语法：'
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/edit` | With this command, you can edit a source entry using a `name` or
    `id` reference. Here is the syntax:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/edit` | 使用此命令，您可以使用`name`或`id`引用编辑源条目。以下是语法：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/env` | This powerful command allows you to view or change the evaluation
    context. Here is the syntax:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/env` | 此强大命令允许您查看或更改评估上下文。以下是语法：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/exit` | This command is used to exit the JShell. The syntax is simply `/exit`
    without any options or parameters available. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `/exit` | 此命令用于退出JShell。语法很简单，即`/exit`，没有可用的选项或参数。|'
- en: '| `/history` | The history command provides a history of what you have typed.
    The syntax is simply `/history` without any options or parameters available. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `/history` | 历史命令提供了您输入的历史记录。语法很简单，即`/history`，没有可用的选项或参数。|'
- en: '| `/<id>` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `/<id>` |'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can also run a specific snippet by referencing the *n*^(th) previous snippet
    with `/-<n>`. |
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过引用第*n*个之前的代码片段来运行特定的代码片段，使用`/-<n>`。|
- en: '| `/imports` | You can use this command to list the imported items. The syntax
    is `/imports` and it does not accept any options or parameters. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `/imports` | 您可以使用此命令列出导入的项目。语法是`/imports`，它不接受任何选项或参数。|'
- en: '| `/list` | This command will list the source you typed. Here is the syntax:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/list` | 此命令将列出您输入的源。以下是语法：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/methods` | This command lists all declared methods as well as their signatures.
    Here is the syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/methods` | 此命令列出所有声明的方法以及它们的签名。以下是语法：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/open` | Using this command, you can open a file as source input. Here is
    the syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/open` | 使用此命令，您可以打开一个文件作为源输入。以下是语法：'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/reload` | The reload command gives you the ability to reset and replay
    relevant history. Here is the syntax:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/reload` | 重载命令允许您重置并重新播放相关历史记录。以下是语法：'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/reset` | This command resets the JShell. Here is the syntax:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/reset` | 此命令重置JShell。以下是语法：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/save` | This command saves the snippet source to a file specified by you.
    Here is the syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/save` | 此命令将代码片段源保存到您指定的文件中。以下是语法：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/set` | This command is used to set the JShell configuration information.
    Here is the syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/set` | 此命令用于设置JShell配置信息。以下是语法：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/types` | This command simply lists declared types. Here is the syntax:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/types` | 此命令简单地列出声明的类型。以下是语法：'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/vars` | This command lists all declared variables as well as their values.
    Here is the syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/vars` | 此命令列出所有声明的变量以及它们的值。以下是语法：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/!` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `/!` |'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Several of the previously listed commands use the term **snippet**. In the
    context of Java 9 and JShell, a snippet is one of the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的几个之前命令使用了术语**代码片段**。在Java 9和JShell的上下文中，代码片段是以下之一：
- en: '- ClassDeclaration'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类声明'
- en: '- Expression'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '- 表达式'
- en: '- FieldDeclaration'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '- 字段声明'
- en: '- ImportDeclaration'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '- 导入声明'
- en: '- InterfaceDeclaration'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '- 接口声明'
- en: '- MethodDeclaration'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '- 方法声明'
- en: 'Entering the `/help` or `/?` command in the JShell provides a complete list
    of commands and syntax that can be used in the shell. That list is provided as
    follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入`/help`或`/?`命令会提供可以在shell中使用的完整命令和语法列表。该列表如下所示：
- en: '![](img/084a5b98-bc86-4a0c-b134-a3fd11b3dc3e.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/084a5b98-bc86-4a0c-b134-a3fd11b3dc3e.png)'
- en: 'The `/help` command can be especially helpful if you are still new to JShell.
    As you can see in the following screenshot, we can obtain an introduction to JShell
    by simply entering the `/help intro` command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`/help`命令对于您刚开始使用JShell时特别有帮助。如您在以下屏幕截图中所见，只需输入`/help intro`命令，我们就可以获得JShell的介绍：'
- en: '![](img/07e9a5bb-32ba-4f1d-82b9-18e618f74b78.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07e9a5bb-32ba-4f1d-82b9-18e618f74b78.png)'
- en: 'If you find yourself using JShell often you might benefit from one or more
    of the following listed shortcuts. These can be listed at any time from within
    JShell by using the `/help shortcuts` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常使用JShell，您可能从以下列出的快捷键中受益。您可以在JShell中使用`/help shortcuts`命令随时列出这些快捷键：
- en: '![](img/98e2d38a-2dad-4a29-9d67-e22558cb2864.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98e2d38a-2dad-4a29-9d67-e22558cb2864.png)'
- en: 'Additional help can be obtained from within the JShell by using the `/help`
    command followed by the command you want additional help on. For example, entering
    `/help reload` provides detailed information regarding the `/reload` command.
    That information is provided as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在JShell中使用`/help`命令后跟您想要获取额外帮助的命令来从JShell内部获得更多帮助。例如，输入`/help reload`将提供关于`/reload`命令的详细信息。该信息如下：
- en: '![](img/18cb33e6-5645-4714-8ffc-5c51852194f8.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18cb33e6-5645-4714-8ffc-5c51852194f8.png)'
- en: Practical uses of JShell
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JShell的实际用途
- en: 'Whether you are a new or seasoned developer or just new to Java, you are bound
    to find the JShell very useful. In this section, we will look at some practical
    uses of JShell. Specifically, we will cover:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是新手开发者、经验丰富的开发者还是刚开始接触Java，您都可能会发现JShell非常有用。在本节中，我们将探讨一些JShell的实际用途。具体来说，我们将涵盖：
- en: Feedback modes
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反馈模式
- en: Listing your assets
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出您的资产
- en: Editing in the JShell
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JShell中编辑
- en: Feedback modes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反馈模式
- en: Command-line tools usually provide relatively sparse feedback in an effort to
    not overcrowd the screen or otherwise become a nuisance to developers. JShell
    has several feedback modes in addition to giving developers the ability to create
    their own custom modes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具通常提供相对稀疏的反馈，以避免屏幕过于拥挤或成为开发者的麻烦。JShell除了给开发者提供创建自定义模式的能力外，还有几种反馈模式。
- en: 'As you can see from the following screenshot, there are four feedback modes--`concise`,
    `normal`, `silent`, and `verbose`. Here, we entered the `/set feedback` command
    without any parameters to list the feedback modes as well as to identify what
    the current feedback mode is. The first line of output displays the command-line
    command and argument set that would be used to set the mode to the currently set
    mode. So, in the following screenshot, the current feedback mode is set to `verbose`
    and the other three modes are listed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下屏幕截图中所见，有四种反馈模式--`concise`、`normal`、`silent`和`verbose`。在这里，我们输入了`/set feedback`命令而没有任何参数，以列出反馈模式以及确定当前的反馈模式。输出第一行显示了将用于设置当前模式的命令行命令和参数集。因此，在以下屏幕截图中，当前的反馈模式设置为`verbose`，其他三种模式被列出：
- en: '![](img/e7db45aa-8043-4224-b6a2-ea6d0f3d5854.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7db45aa-8043-4224-b6a2-ea6d0f3d5854.png)'
- en: 'We can dictate which mode we want to enter when we first enter JShell by including
    an option when we launch JShell. Here are the command-line options:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在启动JShell时包含一个选项来指定我们第一次进入JShell时想要进入的模式。以下是命令行选项：
- en: '| **Command-line command and option** | **Feedback mode** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **命令行命令和选项** | **反馈模式** |'
- en: '| `jshell -q` | `concise` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `jshell -q` | `concise` |'
- en: '| `jshell -n` | `normal` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `jshell -n` | `normal` |'
- en: '| `jshell -s` | `silent` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `jshell -s` | `silent` |'
- en: '| `jshell -v` | `verbose` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `jshell -v` | `verbose` |'
- en: You will notice that we use `-q` for `concise` mode instead of `-c`. The `-c`
    option has the `-c<flag>` syntax and is used to pass `<flag>` to the compiler.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们使用`-q`来表示`concise`模式，而不是`-c`。`-c`选项具有`-c<flag>`语法，用于将`<flag>`传递给编译器。
- en: 'The best way to review the differences between the feedback modes is to use
    examples. Starting with the `normal` mode, we will execute command-line commands
    to accomplish the following ordered feedback demonstration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是通过使用示例来回顾不同反馈模式之间的差异。从`normal`模式开始，我们将执行命令行命令来完成以下顺序的反馈演示：
- en: Create a variable.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建变量。
- en: Update the variable's value.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新变量的值。
- en: Create a method.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建方法。
- en: Update the method.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新方法。
- en: Run the method.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行方法。
- en: 'To start our first test, we will execute the `/set feedback normal` command
    at the `jshell>` prompt, which sets the JShell feedback mode to `normal`. After
    entering the `normal` feedback mode, we will enter the necessary commands to run
    our demonstration:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的第一次测试，我们将在`jshell>`提示符下执行`/set feedback normal`命令，这将把JShell的反馈模式设置为`normal`。进入`normal`反馈模式后，我们将输入必要的命令来运行我们的演示：
- en: '![](img/63d1ae8e-71dc-4ada-a927-c924370ca0d4.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63d1ae8e-71dc-4ada-a927-c924370ca0d4.png)'
- en: After entering `normal` feedback mode, we entered `int myVar = 3` to and received
    `myVar ==> 3` as feedback. In our next command, we changed the value of the same
    variable and received the same output with the new value. Our next statement,
    `void quickMath() {System.out.println("Your result is " + (x*30 + 19));}`, used
    a variable that was not declared and you see the resulting two-part feedback--one
    part indicating that the method was created and the other to inform that the method
    cannot be invoked until the undeclared variable is declared. Next, we changed
    our method to include the `myVar` variable and the feedback reported that the
    method was modified. Our last step was to run the method using `quickMath();`
    and the results are as we expected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入`正常`反馈模式后，我们输入了`int myVar = 3`并收到了`myVar ==> 3`的反馈。在我们的下一个命令中，我们更改了相同变量的值，并收到了相同的新值输出。我们的下一个语句`void
    quickMath() {System.out.println("Your result is " + (x*30 + 19));}`使用了未声明的变量，您可以看到产生的两部分反馈——一部分指示方法已被创建，另一部分告知该方法在未声明的变量声明之前无法调用。接下来，我们将方法更改为包含`myVar`变量，反馈报告了方法的修改。我们的最后一步是使用`quickMath();`运行方法，结果正如我们所预期的。
- en: 'Let''s try this same feedback demonstration in `concise` mode:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`简洁`模式下尝试相同的反馈演示：
- en: '![](img/b8385029-96cc-422b-a751-d946f375d386.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/b8385029-96cc-422b-a751-d946f375d386.png)'
- en: As you can see from the preceding screenshot, the `concise` feedback mode provides
    us with much less feedback. We created and modified the variables and received
    no feedback. When we created the method with an undeclared variable, we received
    the same feedback that we did in `normal` mode. We updated the method without
    confirmation or other feedback.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的截图中所见，`简洁`反馈模式为我们提供的反馈信息要少得多。我们创建了并修改了变量，但没有收到任何反馈。当我们使用未声明的变量创建方法时，我们收到的反馈与`正常`模式下的反馈相同。我们更新了方法，但没有确认或其他反馈。
- en: 'Our next use of the feedback demonstration will be in `silent` mode:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一次使用反馈演示将在`静默`模式下：
- en: '![](img/a4ba1e21-1332-49e1-89f4-6a9e7f9d72d4.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a4ba1e21-1332-49e1-89f4-6a9e7f9d72d4.png)'
- en: When we entered `silent` feedback mode, as you can see in the preceding screenshot,
    the JShell prompt changed from `jshell>` to `->`. There was no feedback provided
    when we created the `myVar` variable, modified the `myVar` variable, or created
    the `quickMath()` method. We intentionally created the `quickMath()` method to
    use an undeclared variable. Because we were in `silent` feedback mode, we were
    not informed that the method had an undeclared variable. Based on this lack of
    feedback, we ran the method and were not provided any output or feedback. Next,
    we updated the method to include the `myVar` declared variable and then ran the
    method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入`静默`反馈模式时，如您在前面的截图中所见，JShell提示符从`jshell>`变为`->`。当我们创建`myVar`变量、修改`myVar`变量或创建`quickMath()`方法时，没有提供任何反馈。我们故意创建了一个使用未声明变量的`quickMath()`方法。因为我们处于`静默`反馈模式，所以我们没有被通知该方法有一个未声明的变量。基于这种缺乏反馈的情况，我们运行了方法，但没有提供任何输出或反馈。接下来，我们更新了方法以包含已声明的`myVar`变量，然后运行了该方法。
- en: The `silent` feedback mode might seem pointless as no feedback is provided,
    but there is a great utility with this mode. Using the `silent` mode might be
    appropriate for pipelining or simply when you want to minimize the amount of terminal
    output. You can include specific, conditional, outputs with implicit `System.out.println`
    commands, as an example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`静默`反馈模式可能看起来没有意义，因为没有提供任何反馈，但这个模式非常有用。使用`静默`模式可能适合管道操作，或者当你想要最小化终端输出量时。例如，你可以使用隐式的`System.out.println`命令包含特定的、条件性的输出。'
- en: 'Our last use of the feedback demonstration is in `verbose` feedback mode. This
    feedback mode, as you would assume from its name, provides the most amount of
    feedback. Here are our test results:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一次使用反馈演示是在`详细`反馈模式下。正如您从其名称所假设的，这种反馈模式提供了最多的反馈。以下是我们的测试结果：
- en: '![](img/7cea66a2-3673-40a7-8b2c-1482387f1eed.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/7cea66a2-3673-40a7-8b2c-1482387f1eed.png)'
- en: In our feedback demonstration, using `verbose` feedback mode, we receive a bit
    more feedback as well as a nicer format for the feedback.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的反馈演示中，使用`详细`反馈模式，我们收到了更多反馈以及更友好的反馈格式。
- en: Creating a custom feedback mode
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义反馈模式
- en: 'While the internal feedback modes (`normal`, `concise`, `silent`, and `verbose`)
    cannot be modified, you can create your own custom feedback mode. The first step
    in this process is to copy an existing mode. The following example demonstrates
    how to copy the `verbose` mode to a `myCustom` mode with the `/set mode myCustom
    verbose -command` command string:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然内部反馈模式（`normal`、`concise`、`silent` 和 `verbose`）不能修改，但您可以创建自己的自定义反馈模式。这个过程的第一步是复制一个现有模式。以下示例演示了如何使用
    `/set mode myCustom verbose -command` 命令字符串将 `verbose` 模式复制到 `myCustom` 模式：
- en: '![](img/43b7b0fb-3b5e-441b-b7e8-4897f1028fbc.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43b7b0fb-3b5e-441b-b7e8-4897f1028fbc.png)'
- en: 'We used the `-command` option to ensure we would receive the command feedback.
    You can make various changes to your feedback mode using the `/set` command along
    with one of the options listed in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `-command` 选项确保我们会收到命令反馈。您可以使用 `/set` 命令以及以下截图中的选项之一来对您的反馈模式进行各种更改：
- en: '![](img/4f11b5e1-9160-49b2-8c0a-91474807a6ca.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f11b5e1-9160-49b2-8c0a-91474807a6ca.png)'
- en: 'As an example, let''s walk through the truncation setting that mandates how
    many characters are displayed on each output line. Using the `/set truncation`
    command, as illustrated in the following screenshot, shows the current truncation
    settings:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们通过截断设置来了解它如何规定每行输出显示多少个字符。使用 `/set truncation` 命令，如下面的截图所示，显示了当前的截断设置：
- en: '![](img/e851d262-f81a-4394-bb30-20218c03d913.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e851d262-f81a-4394-bb30-20218c03d913.png)'
- en: 'As you can see, our `myCustom` feedback mode has a truncation of `80`. We will
    change that to `60` with the `/set truncation myCustom 60` command and then use
    the `/set truncation` command for verification:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 `myCustom` 反馈模式具有 `80` 的截断。我们将使用 `/set truncation myCustom 60` 命令将其更改为
    `60`，然后使用 `/set truncation` 命令进行验证：
- en: '![](img/a8610c05-d29c-4789-86d4-4b862961182d.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8610c05-d29c-4789-86d4-4b862961182d.png)'
- en: As you can see in the previous screenshot, the truncation for our `myCustom`
    feedback mode was successfully changed from the `80` inherited from the `verbose`
    mode to `60`, based on our use of the `/set truncation myCustom 60` JShell command.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们的 `myCustom` 反馈模式的截断已成功从继承自 `verbose` 模式的 `80` 更改为 `60`，这是基于我们使用
    `/set truncation myCustom 60` JShell 命令的结果。
- en: Listing your assets
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出您的资产
- en: 'There are a few JShell commands that are convenient for listing assets that
    you have created. Using the feedback demonstration from the previous section,
    we executed the `/vars,` `/methods`, and `/list` commands to provide a list of
    variables, methods, and all sources respectively:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个 JShell 命令方便列出您创建的资产。使用上一节中的反馈演示，我们执行了 `/vars,` `/methods` 和 `/list` 命令，分别提供变量、方法和所有源列表：
- en: '![](img/f8a80042-6a71-4988-b95d-d9c05939793c.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8a80042-6a71-4988-b95d-d9c05939793c.png)'
- en: 'We can also use the `/list -all` command and option combination to see what
    packages the JShell imported. As you can see in the following screenshot, JShell
    imported several packages that make our work within the shell more convenient,
    saving us time from having to import these standard packages in our methods:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `/list -all` 命令和选项组合来查看 JShell 导入了哪些包。如下面的截图所示，JShell 导入了几个使我们在 shell
    中工作更方便的包，节省了我们不得不在方法中导入这些标准包的时间：
- en: '![](img/1b2e25b3-844d-41a2-9a39-d86ca5e76349.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b2e25b3-844d-41a2-9a39-d86ca5e76349.png)'
- en: 'If you just want to list the startup imports, you can use the `/list -start`
    command and option combination. As you can see in the following screenshot, each
    start up import has an "`s`" prefix and is numerically ordered:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想列出启动导入，您可以使用 `/list -start` 命令和选项组合。如下面的截图所示，每个启动导入都有一个 "`s`" 前缀，并且是按数字顺序排列的：
- en: '![](img/aa2f8675-72c2-4d22-a98c-cb42c9afb393.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa2f8675-72c2-4d22-a98c-cb42c9afb393.png)'
- en: Editing in the JShell
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JShell 中编辑
- en: JShell is not a full-featured text editor, but there are several things you
    can do within the shell. This section provides you with the editing techniques
    grouped into modifying text, basic navigation, historical navigation, and advanced
    editing commands.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 不是一个功能齐全的文本编辑器，但在 shell 中您可以做几件事情。本节为您提供了编辑技巧，分为修改文本、基本导航、历史导航和高级编辑命令。
- en: Modifying text
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改文本
- en: 'The default text edit/entry mode is that the text you type will appear at the
    current cursor position. You have several options available to you when you want
    to delete text. Here is a complete list:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的文本编辑/输入模式是您输入的文本将出现在当前光标位置。当您想要删除文本时，您有几个选项可供选择。以下是一个完整的列表：
- en: '| **Delete action** | **PC keyboard combination** | **Mac keyboard combination**
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **删除动作** | **PC键盘组合** | **Mac键盘组合** |'
- en: '| Delete the character at the current cursor location | *Delete* | *Delete*
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 删除当前光标位置处的字符 | *Delete* | *Delete* |'
- en: '| Delete the character to the left of the cursor | *Backspace* | *Backspace*
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 删除光标左侧的字符 | *Backspace* | *Backspace* |'
- en: '| Delete the text from the cursor location to the end of the line | *Ctrl*
    + *K* | *Cmd* + *K* |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 从光标位置删除到行尾的文本 | *Ctrl* + *K* | *Cmd* + *K* |'
- en: '| Delete the text from the cursor location to the end of the current word |
    *Alt* + *D* | *Alt*/*Opt* + *D* |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 从光标位置删除到当前单词的末尾 | *Alt* + *D* | *Alt*/*Opt* + *D* |'
- en: '| Delete from the cursor location to the previous white space | *Ctrl* + *W*
    | *Cmd* + *W* |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 从光标位置删除到前一个空白字符 | *Ctrl* + *W* | *Cmd* + *W* |'
- en: '| Paste the most recently deleted text at the cursor location | *Ctrl* + *Y*
    | *Cmd* + *Y* |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 在光标位置粘贴最近删除的文本 | *Ctrl* + *Y* | *Cmd* + *Y* |'
- en: '| When the *Ctrl* + *Y* (or *Cmd* + *Y* on Mac) is used, you will be able to
    use the *Alt* + *Y* keyboard combination to cycle through previously deleted text
    | *Alt* + *Y* | *Alt*/*Opt* + *Y* |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 当使用*Ctrl* + *Y*（或在Mac上*c*md* - *E*）时，您可以使用*Alt* + *Y*键盘组合来循环浏览之前删除的文本 | *Alt*
    + *Y* | *Alt*/*Opt* + *Y* |'
- en: Basic navigation
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本导航
- en: 'While navigational control inside the JShell is similar to most command-line
    editors, it is helpful to have a list of basic navigational controls:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在JShell内部进行导航控制与大多数命令行编辑器相似，但列出基本导航控制列表是有帮助的：
- en: '| **Key/Key combination** | **Navigation action** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **键/键组合** | **导航动作** |'
- en: '| *Left arrow* | Move backward one character |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| *左箭头* | 向后移动一个字符 |'
- en: '| *Right arrow* | Move forward one character |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| *右箭头* | 向前移动一个字符 |'
- en: '| *Up arrow* | Move up one line through history |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| *上箭头* | 向上移动一行，通过历史记录 |'
- en: '| *Down arrow* | Move down one line forward through history |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| *下箭头* | 向下移动一行，通过历史记录 |'
- en: '| *Return* | Enter (submit) the current line |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| *Return* | 输入（提交）当前行 |'
- en: '| *Ctrl* + *A* (c*md* - *A* on Mac) | Jump to the beginning of the current
    line |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *A*（Mac上的*c*md* - *A*） | 跳到当前行的开头 |'
- en: '| *Ctrl* + *E* (c*md* - *E* on Mac) | Jump to the end of the current line |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *E*（Mac上的*c*md* - *E*） | 跳到当前行的末尾 |'
- en: '| *Alt* + *B* | Jump back one word |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| *Alt* + *B* | 跳回一个单词 |'
- en: '| *Alt* + *F* | Jump forward one word |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| *Alt* + *F* | 跳向前一个单词 |'
- en: Historical navigation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史导航
- en: JShell remembers the snippets and commands that you enter. It maintains this
    history so that you can reuse snippets and commands you already entered. To cycle
    through snippets and commands, you can hold down the *Ctrl* key (c*md* on Mac)
    and then use the up and down arrow keys until you see the snippet or command you
    want.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JShell会记住您输入的片段和命令。它维护这个历史记录，以便您可以重复使用已经输入的片段和命令。要循环浏览片段和命令，您可以按住*Ctrl*键（Mac上的*c*md*
    - *E*），然后使用上下箭头键，直到看到您想要的片段或命令。
- en: Advanced editing commands
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级编辑命令
- en: 'There are several more editing options to include search functionality, macros
    creation and use, and more. JShell''s editor is based on JLine2, a Java library
    for parsing console input and editing. You can learn more about JLine2 at this
    URL: [https://github.com/jline/jline2/wiki/JLine-2.x-Wiki](https://github.com/jline/jline2/wiki/JLine-2.x-Wiki).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多编辑选项，包括搜索功能、宏的创建和使用等。JShell的编辑器基于JLine2，这是一个用于解析控制台输入和编辑的Java库。您可以在以下网址了解更多关于JLine2的信息：[https://github.com/jline/jline2/wiki/JLine-2.x-Wiki](https://github.com/jline/jline2/wiki/JLine-2.x-Wiki)。
- en: Working with scripts
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本
- en: Up to this point, you have entered data directly into JShell from the keyboard.
    You also have the ability to work with JShell scripts which are a sequence of
    JShell commands and snippets. The format is the same as other scripting formats
    with one command per line.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经直接从键盘将数据输入到JShell中。您还有能力使用JShell脚本，这些脚本是一系列JShell命令和片段。其格式与其他脚本格式相同，每行一个命令。
- en: In this section, we will look at start up scripts, examine how to load scripts,
    how to save scripts, and then end with a look at advanced scripting with JShell.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨启动脚本，检查如何加载脚本，如何保存脚本，然后以JShell的高级脚本结束。
- en: Start up scripts
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动脚本
- en: Each time the JShell is launched, the start up scripts are loaded. This also
    occurs each time the `/reset`, `/reload`, and `/env` commands are used.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每次启动JShell时，都会加载启动脚本。这也发生在使用`/reset`、`/reload`和`/env`命令时。
- en: By default, the DEFAULT start up script is used by JShell. If you want to use
    a different start up script, you merely need to use the `/set start <script>`
    command. Here is an example--`/set start MyStartupScript.jsh`. Alternatively,
    you can use the `jshell --start MyStartupScript.jsh` command at the Command Prompt
    to launch JShell and load the `MyStartupScript.jsh` JShell start up script.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JShell使用DEFAULT启动脚本。如果你想使用不同的启动脚本，只需使用`/set start <script>`命令。以下是一个示例--`/set
    start MyStartupScript.jsh`。或者，你可以在命令提示符下使用`jshell --start MyStartupScript.jsh`命令来启动JShell并加载`MyStartupScript.jsh`
    JShell启动脚本。
- en: When you use the `/set start <script>` command with the `-retain` option, you
    are telling JShell to use the new start up script the next time you launch JShell.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用带有`-retain`选项的`/set start <script>`命令时，你是在告诉JShell，下次你启动JShell时使用新的启动脚本。
- en: Loading scripts
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载脚本
- en: 'Loading scripts in the JShell can be accomplished with one of the following
    methods:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中加载脚本可以通过以下方法之一完成：
- en: You can use the `/open` command along with the name of the script as a parameter.
    For example, if our script name is `MyScript`, we would use `/open MyScript`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`/open`命令以及脚本的名称作为参数。例如，如果我们的脚本名称是`MyScript`，我们会使用`/open MyScript`。
- en: A second option for loading scripts is to use the `jshell MyScript.jsh` at the
    Command Prompt. This will launch JShell and load the `MyScript.jsh` JShell script.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载脚本的第二种方法是使用命令提示符下的`jshell MyScript.jsh`。这将启动JShell并加载`MyScript.jsh` JShell脚本。
- en: Saving scripts
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存脚本
- en: 'In addition to creating JShell scripts in external editors, we can create them
    within the JShell environment as well. When taking this approach, you will need
    to use the `/save` command to save your scripts. As you can see in the following
    screenshot, the `/save` command requires, at a minimum, a file name argument:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在外部编辑器中创建JShell脚本，我们还可以在JShell环境中创建它们。采用这种方法时，你需要使用`/save`命令来保存你的脚本。正如以下截图所示，`/save`命令至少需要一个文件名参数：
- en: '![](img/3199707f-7588-4c98-8b49-35dc0acba62b.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3199707f-7588-4c98-8b49-35dc0acba62b.png)'
- en: 'There are three options available to you with the `/save` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`/save`命令提供了三种选项供你选择：'
- en: The `-all` option can be used to save the source of all snippets to the specified
    file.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-all`选项可以将所有代码片段的源代码保存到指定的文件中。'
- en: The `-history` option saves a sequential history of all commands and snippets
    you entered since JShell was launched. JShell's ability to perform this operation
    informs you that it maintains a history of everything you enter.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-history`选项保存自JShell启动以来输入的所有命令和代码片段的顺序历史。JShell能够执行此操作表明它维护了你输入的所有内容的记录。'
- en: The `-start` option saves the current start up definitions to the specified
    file.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-start`选项将当前启动定义保存到指定的文件中。'
- en: Advanced scripting with JShell
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JShell进行高级脚本编写
- en: What are the limits of JShell? There is so much you can do with this tool, and
    you are virtually only limited by your imagination and programming abilities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: JShell的局限性是什么？你可以用这个工具做很多事情，实际上你只受限于你的想象力和编程能力。
- en: 'Let''s look at an advanced code base that can be used to compile and run Java
    programs from a JShell script:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个可以用于从JShell脚本编译和运行Java程序的先进代码库：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see with this script, we created a `runSomeProcess()` method and
    can use it to explicitly compile and run external Java files.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个脚本所示，我们创建了一个`runSomeProcess()`方法，并可以使用它来显式编译和运行外部Java文件。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined JShell, Java 9's new read-eval-print loop command-line
    tool. We started with introductory information regarding the tool and looked closely
    at the read-eval-print loop concept. We spent considerable time reviewing JShell
    commands and command-line options. Our coverage included practical guides to feedback
    modes, asset listing, and editing in the shell. We also gained experience working
    with scripts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了JShell，Java 9的新读-求值-打印循环命令行工具。我们从有关该工具的简介开始，并仔细研究了读-求值-打印循环的概念。我们花了大量时间回顾JShell命令和命令行选项。我们的内容涵盖了反馈模式、资产列表和shell中的编辑的实际指南。我们还获得了使用脚本的经验。
- en: In the next chapter, we will look at Java 9's new default garbage collector.
    Specifically, we will look at the default garbage collection, depreciated garbage
    collection combinations, and examine garbage collection logging.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Java 9的新默认垃圾回收器。具体来说，我们将探讨默认垃圾回收、已弃用的垃圾回收组合，并检查垃圾回收日志。
