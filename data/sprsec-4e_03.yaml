- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Custom Authentication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义认证
- en: In [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with Spring
    Security*, we demonstrated how to use an in-memory datastore to authenticate the
    user. In this chapter, we’ll explore how to solve some common, real-world problems
    by extending Spring Security’s authentication support to use our existing set
    of APIs. Through this exploration, we’ll get an understanding of each of the building
    blocks that Spring Security uses in order to authenticate users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第2章*](B21757_02.xhtml#_idTextAnchor043) 中，*Spring Security入门*，我们展示了如何使用内存数据存储来认证用户。在本章中，我们将探讨通过扩展
    Spring Security 的认证支持来使用我们现有的 API 集合来解决一些常见、现实世界的问题。通过这次探索，我们将了解 Spring Security
    用于认证用户的每个构建块。
- en: 'During this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Leveraging Spring Security’s annotations and Java-based configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Spring Security 的注解和基于 Java 的配置
- en: Discovering how to obtain the details of the currently logged-in user
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现如何获取当前登录用户的详细信息
- en: Adding the ability to log in after creating a new account
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建新账户后添加登录功能
- en: Learning the simplest method for indicating to Spring Security that a user is
    authenticated
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习向 Spring Security 表明用户已认证的最简单方法
- en: Creating custom `UserDetailsService` and `AuthenticationProvider` implementations
    that properly decouple the rest of the application from Spring Security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义的 `UserDetailsService` 和 `AuthenticationProvider` 实现，以正确地将应用程序的其余部分与 Spring
    Security 解耦
- en: Adding domain-based authentication to demonstrate how to authenticate with more
    than just a username and password
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加基于域的认证以展示如何使用不仅仅是用户名和密码进行认证
- en: 'This chapter’s code in action link is here: [https://packt.link/5tPFD](https://packt.link/5tPFD).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例链接在此：[https://packt.link/5tPFD](https://packt.link/5tPFD)。
- en: Authentication architecture in Spring Security
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 的认证架构
- en: 'The realm of application security essentially involves addressing two largely
    independent issues: authentication (identifying *who you are*) and authorization
    (determining *what you are allowed* *to do*).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序安全领域基本上涉及解决两个在很大程度上独立的问题：认证（识别 *你是谁*）和授权（确定 *你被允许做什么*）。
- en: Occasionally, individuals may use the term *access control* interchangeably
    with *authorization*, adding a layer of potential confusion.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，个人可能会将术语 *访问控制* 与 *授权* 互换使用，增加了一层潜在的混淆。
- en: However, framing it as *access control* can offer clarity, considering the multifaceted
    use of the term *authorization* elsewhere.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将其视为 *访问控制* 可以提供清晰度，考虑到在其他地方术语 *授权* 的多方面使用。
- en: Spring Security adopts an architecture deliberately crafted to segregate authentication
    from authorization, providing distinct strategies and extension points for each.
    We will uncover in this section the main architectural components of Spring Security
    used for authentication.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 采用了一种故意设计的架构，将认证与授权分离，为每个提供不同的策略和扩展点。在本节中，我们将揭示 Spring Security
    用于认证的主要架构组件。
- en: The SecurityContextHolder class
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SecurityContextHolder` 类'
- en: At the heart of Spring Security’s authentication model is the `SecurityContextHolder`.
    It contains the `SecurityContext`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 的认证模型的核心是 `SecurityContextHolder`。它包含 `SecurityContext`。
- en: '![Figure 3.1 – Spring Security’s SecurityContextHolder](img/B21757_03_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Spring Security的SecurityContextHolder](img/B21757_03_1.jpg)'
- en: Figure 3.1 – Spring Security’s SecurityContextHolder
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Spring Security的SecurityContextHolder
- en: The SecurityContext interface
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SecurityContext` 接口'
- en: '`SecurityContextHolder` is where Spring Security stores the details of who
    is authenticated. Spring Security does not care how `SecurityContextHolder` is
    populated. If it contains a value, it is used as the currently authenticated user.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityContextHolder` 是 Spring Security 存储谁已认证的细节的地方。Spring Security 不关心
    `SecurityContextHolder` 如何被填充。如果它包含一个值，它就被用作当前已认证的用户。'
- en: The Authentication interface
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Authentication` 接口'
- en: 'The **Authentication** interface in Spring Security serves dual purposes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 中的 `Authentication` 接口具有双重用途：
- en: It acts as input for `AuthenticationManager`, supplying the user’s provided
    credentials for authentication. In this context, the method `isAuthenticated()`
    returns false.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为 `AuthenticationManager` 的输入，为认证提供用户提供的凭据。在这个上下文中，`isAuthenticated()` 方法返回
    false。
- en: It serves as a representation of the presently authenticated user, retrievable
    from the `SecurityContext`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为当前已认证用户的表示，可以从 `SecurityContext` 中检索。
- en: 'Key components within the **Authentication** interface include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证**接口中的关键组件包括以下内容：'
- en: '`UserDetails`, especially in username/password authentication.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserDetails`，尤其是在用户名/密码认证中。'
- en: '**Credentials**: This typically encompasses a password. In many instances,
    this information is cleared post-authentication to prevent inadvertent leakage.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭证**：这通常包括密码。在许多情况下，认证后清除这些信息以防止意外泄露。'
- en: '`GrantedAuthority` instances denoting high-level permissions granted to the
    user. Examples include roles and scopes.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示授予用户高级权限的`GrantedAuthority`实例。例如包括角色和范围。
- en: The AuthenticationManager interface
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AuthenticationManager`接口'
- en: '`AuthenticationManager` serves as the API specifying how authentication is
    conducted by Spring Security’s Filters. The resulting authentication is subsequently
    established on `SecurityContextHolder` by the invoking controller (i.e., Spring
    Security’s `Filters` instances).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthenticationManager`充当API，指定Spring Security的过滤器如何执行认证。随后，由调用控制器（即Spring
    Security的`Filters`实例）在`SecurityContextHolder`上建立认证结果。'
- en: If you’re not integrating with Spring Security’s `Filters` instances, you have
    the option to directly set `SecurityContextHolder` without the need for `AuthenticationManager`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有与Spring Security的`Filters`实例集成，你可以直接设置`SecurityContextHolder`，无需`AuthenticationManager`。
- en: Although the `AuthenticationManager`’s implementation can vary, the prevalent
    choice is often `ProviderManager`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`AuthenticationManager`的实现可以不同，但常见的选择通常是`ProviderManager`。
- en: The ProviderManager class
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ProviderManager`类'
- en: '`ProviderManager` stands out as the frequently employed realization of `AuthenticationManager`.
    It delegates responsibilities to a list of `AuthenticationProvider` instances.
    Each `AuthenticationProvider` possesses the capability to express whether authentication
    should succeed, fail, or delegate the decision-making to a subsequent `AuthenticationProvider`.
    In the event that none of the configured `AuthenticationProvider` instances can
    authenticate, the authentication process results in a `ProviderNotFoundException`.
    This particular `AuthenticationException` signifies that the `ProviderManager`
    lacked configuration to support the specific **authentication** type provided
    to it.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProviderManager`是`AuthenticationManager`经常使用的实现方式。它将责任委托给一系列`AuthenticationProvider`实例。每个`AuthenticationProvider`都有能力表达认证是否成功、失败或委托决策给后续的`AuthenticationProvider`。如果配置的任何`AuthenticationProvider`实例都无法进行认证，认证过程将导致`ProviderNotFoundException`。这种特定的`AuthenticationException`表示`ProviderManager`缺乏配置以支持其提供的特定**认证**类型。'
- en: '![Figure 3.2 – Spring Security SecurityContextHolder](img/B21757_03_2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Spring Security SecurityContextHolder](img/B21757_03_2.jpg)'
- en: Figure 3.2 – Spring Security SecurityContextHolder
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Spring Security SecurityContextHolder
- en: In practical terms, every `AuthenticationProvider` is equipped to carry out
    a distinct authentication method. For instance, one `AuthenticationProvider` may
    validate a username/password, while another is capable of authenticating a `SAML
    Assertion`. This setup empowers each `AuthenticationProvider` to handle a specialized
    form of authentication, accommodating various authentication types and presenting
    only a singular `AuthenticationManager` bean.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，每个`AuthenticationProvider`都配备有执行特定认证方法的能力。例如，一个`AuthenticationProvider`可能用于验证用户名/密码，而另一个则能够认证`SAML
    Assertion`。这种设置使得每个`AuthenticationProvider`能够处理特定形式的认证，适应各种认证类型，并只提供一个单一的`AuthenticationManager`
    bean。
- en: '![Figure 3.3 – Spring Security SecurityContextHolder](img/B21757_03_3.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – Spring Security SecurityContextHolder](img/B21757_03_3.jpg)'
- en: Figure 3.3 – Spring Security SecurityContextHolder
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – Spring Security SecurityContextHolder
- en: Additionally, `ProviderManager` enables the configuration of an optional parent
    `AuthenticationManager`. This parent `AuthenticationManager` is consulted when
    no `AuthenticationProvider` is able to execute authentication. The parent can
    take on any form of `AuthenticationManager`, with `ProviderManager` frequently
    being the chosen type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ProviderManager`允许配置一个可选的父`AuthenticationManager`。当没有`AuthenticationProvider`能够执行认证时，将咨询这个父`AuthenticationManager`。父`AuthenticationManager`可以采取任何形式的`AuthenticationManager`，其中`ProviderManager`通常是选择类型。
- en: Multiple instances of `ProviderManager` can have a shared parent `AuthenticationManager`.
    This occurrence is quite typical in situations where multiple `SecurityFilterChain`
    instances share a common authentication process (represented by the shared parent
    `AuthenticationManager`). However, these instances may also employ different authentication
    mechanisms, each managed by distinct `ProviderManager` instances.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 多个 `ProviderManager` 实例可以共享一个父级 `AuthenticationManager`。这种情况在多个 `SecurityFilterChain`
    实例共享一个共同的认证过程（由共享的父级 `AuthenticationManager` 表示）时相当典型。然而，这些实例也可能采用不同的认证机制，每个机制由不同的
    `ProviderManager` 实例管理。
- en: '![Figure 3.4 – Spring Security’s SecurityContextHolder](img/B21757_03_4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Spring Security 的 `SecurityContextHolder`](img/B21757_03_4.jpg)'
- en: Figure 3.4 – Spring Security’s SecurityContextHolder
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Spring Security 的 `SecurityContextHolder`
- en: By default, `ProviderManager` attempts to remove any sensitive credential information
    from the `Authentication` object returned upon a successful authentication request.
    This precautionary measure ensures that sensitive details, such as passwords,
    are not stored in the `HttpSession` for longer than necessary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ProviderManager` 会尝试在成功认证请求返回的 `Authentication` 对象中移除任何敏感凭证信息。这种预防措施确保敏感细节，如密码，不会在
    `HttpSession` 中存储超过必要的时间。
- en: The AuthenticationProvider interface
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AuthenticationProvider` 接口'
- en: It is possible to inject multiple instances of `AuthenticationProviders` into
    `ProviderManager`. Each `AuthenticationProvider` is responsible for a specific
    form of authentication. For instance, `DaoAuthenticationProvider` is designed
    for username/password-based authentication, while `JwtAuthenticationProvider`
    specializes in authenticating JSON Web Tokens.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将多个 `AuthenticationProviders` 实例注入到 `ProviderManager` 中。每个 `AuthenticationProvider`
    负责一种特定的认证形式。例如，`DaoAuthenticationProvider` 设计用于基于用户名/密码的认证，而 `JwtAuthenticationProvider`
    专门用于认证 JSON Web Tokens。
- en: Exploring the JBCP calendar architecture
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 JBCP 日历架构
- en: We will start this chapter by analyzing the domain model within the **JBPC**
    **Calendar** architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，分析 JBPC **日历**架构中的领域模型。
- en: In [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy of an Unsafe Application*,
    and [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with Spring
    Security*, we used the Spring **Bill Of Materials** (**BOM**) to assist in dependency
    management, but the rest of the code in the projects used the core Spring Framework
    and required manual configuration. Starting with this chapter, we will be using
    Spring Boot for the rest of the applications, to simplify the application configuration
    process. The Spring Security configuration we will be creating will be the same
    for both a Spring Boot and a non-Boot application. We will cover more details
    on Spring IO and Spring Boot in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional* *Reference Material*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [*第 1 章*](B21757_01.xhtml#_idTextAnchor015)，“不安全应用程序的解剖”和 [*第 2 章*](B21757_02.xhtml#_idTextAnchor043)，“Spring
    Security 入门”中，我们使用了 Spring **物料清单**（**BOM**）来帮助依赖关系管理，但项目中的其余代码使用了核心 Spring 框架，并需要手动配置。从本章开始，我们将使用
    Spring Boot 来简化应用程序配置过程。我们将为 Spring Boot 和非 Boot 应用程序创建相同的 Spring Security 配置。我们将在
    [*附录*](B21757_20.xhtml#_idTextAnchor642)，“附加参考材料”中详细介绍 Spring IO 和 Spring Boot。 '
- en: In the upcoming sections, we will delve into the domain model of the JBCP calendar
    application. We aim to gain insights into the process of incorporating Spring
    Security with personalized user configurations and APIs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入研究 JBCP 日历应用程序的领域模型。我们的目标是了解将 Spring Security 与个性化用户配置和 API 集成的过程。
- en: The CalendarUser object
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CalendarUser` 对象'
- en: 'Our calendar application uses a domain object named `CalendarUser`, which contains
    information about our users, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日历应用程序使用一个名为 `CalendarUser` 的领域对象，其中包含有关用户的信息，如下所示：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Event object
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Event` 对象'
- en: 'Our application has an `Event` object that contains information about each
    event, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有一个包含每个事件信息的 `Event` 对象，如下所示：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The CalendarService interface
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CalendarService` 接口'
- en: 'Our application contains a `CalendarService` interface that can be used to
    access and store our domain objects. The code for `CalendarService` is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序包含一个 `CalendarService` 接口，可以用来访问和存储我们的领域对象。`CalendarService` 的代码如下：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We won’t go over the methods used in `CalendarService`, but they should be fairly
    straightforward. If you would like details about what each method does, please
    consult the Javadoc in the sample code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍`CalendarService`中使用的函数，但它们应该是相当直接的。如果您想了解每个函数的作用，请参阅示例代码中的Javadoc。
- en: The UserContext interface
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserContext接口
- en: 'Like most applications, our application requires us to interact with the currently
    logged-in user. We have created a very simple interface called `UserContext` to
    manage the currently logged-in user, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数应用程序一样，我们的应用程序需要我们与当前登录的用户进行交互。我们创建了一个非常简单的界面，称为`UserContext`，用于管理当前登录的用户，如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that our application can call `UserContext.getCurrentUser()` to obtain
    the details of the currently logged-in user. It can also call `UserContext.setCurrentUser(CalendarUser)`
    to specify which user is logged in. Later in this chapter, we will explore how
    we can write an implementation of this interface that uses Spring Security to
    access our current user and obtain their details using `SecurityContextHolder`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的应用程序可以调用`UserContext.getCurrentUser()`来获取当前登录用户的详细信息。它还可以调用`UserContext.setCurrentUser(CalendarUser)`来指定哪个用户已登录。在本章的后面部分，我们将探讨如何编写一个使用Spring
    Security访问我们的当前用户并使用`SecurityContextHolder`获取其详细信息的接口实现。
- en: 'Spring Security provides quite a few different methods for authenticating a
    user. However, the net result is that Spring Security will populate `o.s.s.core.context.SecurityContext
    with o.s.s.core.Authentication`. The `Authentication` object represents all the
    information we gathered at the time of authentication (username, password, roles,
    and so on). The `SecurityContext` interface is then set on the `o.s.s.core.context.SecurityContextHolder`
    interface. This means that Spring Security and developers can use `SecurityContextHolder`
    to obtain information about the currently logged-in user. An example of obtaining
    the current username is illustrated as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了多种不同的方法来验证用户。然而，最终结果是Spring Security将`o.s.s.core.context.SecurityContext`填充为`o.s.s.core.Authentication`。`Authentication`对象代表我们在认证时收集的所有信息（用户名、密码、角色等）。然后，`SecurityContext`接口被设置在`o.s.s.core.context.SecurityContextHolder`接口上。这意味着Spring
    Security和开发人员可以使用`SecurityContextHolder`来获取当前登录用户的信息。以下是如何获取当前用户名的示例：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Important note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It should be noted that `null` checks should always be done on the `Authentication`
    object, as this could be `null` if the user is not logged in.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在`Authentication`对象上始终应该进行`null`检查，因为如果用户未登录，它可能是`null`。
- en: The SpringSecurityUserContext interface
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpringSecurityUserContext接口
- en: The current `UserContext` implementation, `UserContextStub`, is a stub that
    always returns the same user. This means that the **My Events** page will always
    display the same user no matter who is logged in. Let’s update our application
    to utilize the current Spring Security user’s username, to determine which events
    to display on the **My** **Events** page.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当前`UserContext`实现`UserContextStub`是一个存根，总是返回相同的用户。这意味着无论谁登录，**我的事件**页面都会显示相同的用户。让我们更新我们的应用程序，以便利用当前的Spring
    Security用户名，以确定在**我的****事件**页面上显示哪些事件。
- en: Important note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should be starting with the sample code in `chapter03.00- calendar`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter03.00- calendar`中的示例代码开始。
- en: 'Take a look at the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下步骤：
- en: The first step is to comment out the `@Component` attribute on `UserContextStub`,
    so that our application no longer uses our scanned results.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是注释掉`UserContextStub`上的`@Component`属性，这样我们的应用程序就不再使用我们的扫描结果。
- en: Important note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `@Component` annotation is used in conjunction with the `@Configuration`
    annotation found in `com/packtpub/springsecurity/web/configuration/WebMvcConfi
    g.java,` to automatically create a Spring bean rather than creating an explicit
    XML or Java configuration for each bean. You can learn more about the classpath
    of Spring scanning at [https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.xhtml](https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.xhtml).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`注解与在`com/packtpub/springsecurity/web/configuration/WebMvcConfi
    g.java`中找到的`@Configuration`注解一起使用，用于自动创建Spring bean，而不是为每个bean创建显式的XML或Java配置。您可以在[https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.xhtml](https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.xhtml)了解更多关于Spring扫描类路径的信息。'
- en: 'Take a look at the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码片段：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next step is to utilize `SecurityContext` to obtain the currently logged-in
    user. We have included `SpringSecurityUserContext` within this chapter’s code,
    which is wired up with the necessary dependencies but contains no actual functionality.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是利用`SecurityContext`来获取当前登录的用户。我们已经在本章的代码中包含了`SpringSecurityUserContext`，它与必要的依赖项连接，但没有任何实际的功能。
- en: 'Open the `SpringSecurityUserContext.java` file and add the `@Component` annotation.
    Next, replace the `getCurrentUser` implementation, as illustrated in the following
    code snippet:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SpringSecurityUserContext.java`文件，并添加`@Component`注解。接下来，替换`getCurrentUser`实现，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our code obtains the username from the current Spring Security `Authentication`
    object and utilizes that to look up the current `CalendarUser` object by email
    address. Since our Spring Security username is an email address, we can use the
    email address to link `CalendarUser` with the Spring Security user. Note that
    if we were to link accounts, we would normally want to do this with a key that
    we generated rather than something that may change (that is, an email address).
    We follow the good practice of returning only our domain object to the application.
    This ensures that our application is only aware of our `CalendarUser` object and
    thus is not coupled to Spring Security.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的代码从当前的Spring Security `Authentication`对象中获取用户名，并利用它通过电子邮件地址查找当前的`CalendarUser`对象。由于我们的Spring
    Security用户名是电子邮件地址，我们可以使用电子邮件地址将`CalendarUser`与Spring Security用户关联起来。请注意，如果我们要将账户关联起来，我们通常会希望使用我们生成的键来完成，而不是可能发生变化的东西（即电子邮件地址）。我们遵循良好的实践，只将我们的域对象返回给应用程序。这确保了我们的应用程序只知道我们的`CalendarUser`对象，因此不会与Spring
    Security耦合。
- en: This code may seem eerily similar to when we used the `sec:authorize=` **"isAuthenticated()"**
    tag attribute in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started
    with Spring Security*, to display the current user’s username. In fact, the Spring
    Security tag library uses `SecurityContextHolder` in the same manner as we have
    done here. We could use our `UserContext` interface to place the current user
    on `HttpServletRequest` and thus remove our dependency on the Spring Security
    tag library.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码看起来可能与我们在[*第2章*](B21757_02.xhtml#_idTextAnchor043)“Spring Security入门”中使用的`sec:authorize=`
    **"isAuthenticated()"** 标签属性时非常相似。实际上，Spring Security标签库以与我们这里相同的方式使用`SecurityContextHolder`。我们可以使用我们的`UserContext`接口将当前用户放置在`HttpServletRequest`上，从而消除对Spring
    Security标签库的依赖。
- en: Start up the application, visit `http://localhost:8080/`, and log in with `admin1@example.com`
    as the username and `admin1` as the password.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序，访问`http://localhost:8080/`，并使用`admin1@example.com`作为用户名和`admin1`作为密码进行登录。
- en: Visit the **My Events** page and you will see that only the events for that
    current user, who is the owner or the attendee, are displayed.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问**我的事件**页面，您将看到只显示当前用户的事件，该用户是事件的所有者或参与者。
- en: Try creating a new event; you will observe that the owner of the event is now
    associated with the logged-in user.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试创建一个新事件；您将观察到事件的所有者现在与登录用户相关联。
- en: Log out of the application and repeat these steps with `user1@example.com` as
    the username and `user1` as the password.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序中注销，并使用`user1@example.com`作为用户名和`user1`作为密码重复这些步骤。
- en: Important note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter03.01-calendar`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter03.01-calendar`。
- en: In this section, we have covered the JBCP calendar architecture. In the next
    session, we will see how to manage new users using `SecurityContextHolder`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了JBCP日历架构。在下一节中，我们将看到如何使用`SecurityContextHolder`来管理新用户。
- en: Logging in new users using SecurityContextHolder
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SecurityContextHolder登录新用户
- en: A common requirement is to allow users to create a new account and then automatically
    log them into the application. In this section, we’ll describe the simplest method
    for indicating that a user is authenticated, by utilizing `SecurityContextHolder`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是允许用户创建新账户，然后自动将其登录到应用程序。在本节中，我们将描述利用`SecurityContextHolder`来指示用户已认证的最简单方法。
- en: Managing users in Spring Security
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Spring Security中管理用户
- en: The application provided in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015),
    *Anatomy of an Unsafe Application*, provides a mechanism for creating a new `CalendarUser`
    object, so it should be fairly easy to create our `CalendarUser` object after
    a user signs up. However, Spring Security has no knowledge of `CalendarUser`.
    This means that we will need to add a new user in Spring Security, too. Don’t
    worry, we will remove the need for the dual maintenance of users later in this
    chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B21757_01.xhtml#_idTextAnchor015)，*不安全应用程序的解剖* 中提供的应用程序提供了一个创建新的
    `CalendarUser` 对象的机制，因此用户注册后创建我们的 `CalendarUser` 对象应该相当简单。然而，Spring Security 对
    `CalendarUser` 一无所知。这意味着我们还需要在 Spring Security 中添加新用户。不用担心，我们将在本章的后面部分消除对用户的双重维护需求。
- en: Spring Security provides an `o.s.s.provisioning.UserDetailsManager` interface
    for managing users. Remember our in-memory Spring Security configuration?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 提供了一个 `o.s.s.provisioning.UserDetailsManager` 接口用于管理用户。还记得我们之前的内存中
    Spring Security 配置吗？
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `SecurityConfig.userDetailsService()` method creates an in-memory implementation
    of `UserDetailsManager`, named `o.s.s.provisioning.InMemoryUserDetailsManager`,
    which can be used to create a new Spring Security user.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityConfig.userDetailsService()` 方法创建了一个内存中的 `UserDetailsManager` 实现，名为
    `o.s.s.provisioning.InMemoryUserDetailsManager`，它可以用来创建新的 Spring Security 用户。'
- en: 'Let’s see how we can manage users in Spring Security by performing the following
    steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来了解如何在 Spring Security 中管理用户：
- en: 'To expose `UserDetailsManager` using a Java-based configuration, we need to
    create `InMemoryUserDetailsManager`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用基于 Java 的配置来暴露 `UserDetailsManager`，我们需要创建 `InMemoryUserDetailsManager`：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we have an exposed `UserDetailsManager` interface in our Spring configuration,
    all we need to do is update our existing `CalendarService` implementation, `DefaultCalendarService`,
    to add a user in Spring Security. Make the following updates to the `DefaultCalendarService.java`
    file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在 Spring 配置中暴露了 `UserDetailsManager` 接口，我们只需要更新现有的 `CalendarService` 实现，即
    `DefaultCalendarService`，以在 Spring Security 中添加用户。对 `DefaultCalendarService.java`
    文件进行以下更新：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To leverage `UserDetailsManager`, we first convert `CalendarUser` into the `UserDetails`
    object of Spring Security.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要利用 `UserDetailsManager`，我们首先将 `CalendarUser` 转换为 Spring Security 的 `UserDetails`
    对象。
- en: Later, we use `UserDetailsManager` to save the `UserDetails` object. The conversion
    is necessary because Spring Security has no understanding of how to save our custom
    `CalendarUser` object, so we must map `CalendarUser` to an object Spring Security
    understands. You will notice that the `GrantedAuthority` object corresponds to
    the `authorities` attribute of our `SecurityConfig` file. We hardcode this for
    simplicity and because there is no concept of roles in our existing system.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们使用 `UserDetailsManager` 来保存 `UserDetails` 对象。这种转换是必要的，因为 Spring Security
    不了解如何保存我们的自定义 `CalendarUser` 对象，因此我们必须将 `CalendarUser` 映射到 Spring Security 理解的对象。您将注意到
    `GrantedAuthority` 对象对应于我们的 `SecurityConfig` 文件的 `authorities` 属性。我们为了简单起见并因为我们的现有系统中没有角色的概念而将其硬编码。
- en: Logging in a new user to an application
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用程序中登录新用户
- en: 'Now that we can add new users to the system, we need to indicate that the user
    is authenticated. Update `SpringSecurityUserContext` to set the current user on
    the `SecurityContextHolder` object of Spring Security, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够向系统中添加新用户，我们需要表明该用户已认证。更新 `SpringSecurityUserContext` 以在 Spring Security
    的 `SecurityContextHolder` 对象上设置当前用户，如下所示：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first step we perform is to convert our `CalendarUser` object into the `UserDetails`
    object of Spring Security. This is necessary because, just as Spring Security
    didn’t know how to save our custom `CalendarUser` object, Spring Security also
    does not understand how to make security decisions with our custom `CalendarUser`
    object. We use Spring Security’s `o.s.s.core.userdetails.UserDetailsService` interface
    to obtain the same `UserDetails` object we saved with `UserDetailsManager`. The
    `UserDetailsService` interface provides a subset of the functionality provided
    by Spring Security’s `UserDetailsManager` object that we have already seen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的第一步是将我们的 `CalendarUser` 对象转换为 Spring Security 的 `UserDetails` 对象。这是必要的，因为正如
    Spring Security 不知道如何保存我们的自定义 `CalendarUser` 对象一样，Spring Security 也不理解如何使用我们的自定义
    `CalendarUser` 对象进行安全决策。我们使用 Spring Security 的 `o.s.s.core.userdetails.UserDetailsService`
    接口来获取与 `UserDetailsManager` 保存的相同的 `UserDetails` 对象。`UserDetailsService` 接口提供了
    Spring Security 的 `UserDetailsManager` 对象所提供功能的一个子集，我们之前已经见过。
- en: Next, we create a `UsernamePasswordAuthenticationToken` object and place `UserDetails`,
    the password, and `GrantedAuthority` in it. Lastly, we set the authentication
    on `SecurityContextHolder`. In a web application, Spring Security will automatically
    associate the `SecurityContext` object in `SecurityContextHolder` to our HTTP
    session for us.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`UsernamePasswordAuthenticationToken`对象，并将`UserDetails`、密码和`GrantedAuthority`放入其中。最后，我们在`SecurityContextHolder`上设置认证。在Web应用程序中，Spring
    Security会自动将`SecurityContextHolder`中的`SecurityContext`对象与我们HTTP会话关联起来。
- en: Important note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is important that Spring Security must not be instructed to ignore a URL
    (that is, using the `permitAll()` method), as discussed in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*, in which `SecurityContextHolder` is accessed
    or set. This is because Spring Security will ignore the request and thus not persist
    `SecurityContext` for subsequent requests. The session management support is composed
    of a few components that work together to provide the functionality, so we used
    `securityContext.requireExplicitSave(false)` to persist the session.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是Spring Security不能被指示忽略一个URL（即使用`permitAll()`方法），如在第[*2章*](B21757_02.xhtml#_idTextAnchor043)“使用Spring
    Security入门”中讨论的那样，其中访问或设置了`SecurityContextHolder`。这是因为Spring Security将忽略请求，因此不会为后续请求持久化`SecurityContext`。会话管理支持由几个协同工作的组件组成，以提供功能，因此我们使用了`securityContext.requireExplicitSave(false)`来持久化会话。
- en: The advantage of this approach is that there is no need to hit the datastore
    again. In our case, the datastore is an in-memory datastore, but this could be
    backed by a database, which could have some security implications. The disadvantage
    of this approach is that we do not get to reuse the code much. Since this method
    is invoked infrequently, we opt for reusing the code. In general, it is best to
    evaluate each situation separately to determine which approach makes the most
    sense.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是无需再次击中数据存储。在我们的情况下，数据存储是一个内存数据存储，但它可以由数据库支持，这可能会带来一些安全影响。这种方法的缺点是我们无法大量重用代码。由于此方法调用不频繁，我们选择重用代码。一般来说，最好单独评估每种情况，以确定哪种方法最有意义。
- en: Updating SignupController
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新`SignupController`
- en: 'The application has a `SignupController` object, which is what processes the
    HTTP request to create a new `CalendarUser` object. The last step is to update
    `SignupController` to create our user and then indicate that they are logged in.
    Make the following updates to `SignupController`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有一个`SignupController`对象，它处理创建新的`CalendarUser`对象的HTTP请求。最后一步是更新`SignupController`以创建我们的用户并指示他们已登录。对`SignupController`进行以下更新：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you have not done so already, restart the application, visit `http://localhost:8080/`,
    create a new user, and you can see that the new user is automatically logged in.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请重新启动应用程序，访问`http://localhost:8080/`，创建一个新用户，您将看到新用户会自动登录。
- en: Important note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter03.02-calendar`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter03.02-calendar`。
- en: In this section, we have covered the new user signup workflow. In the next section,
    we will create a custom `UserDetailsService` object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了新用户注册工作流程。在下一节中，我们将创建一个自定义的`UserDetailsService`对象。
- en: Creating a custom UserDetailsService object
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义`UserDetailsService`对象
- en: While we can link our domain model (`CalendarUser`) with Spring Security’s domain
    model (`UserDetails`), we have to maintain multiple representations of the user.
    To resolve this dual maintenance, we can implement a custom `UserDetailsService`
    object to translate our existing `CalendarUser` domain model into an implementation
    of Spring Security’s `UserDetails` interface. By translating our `CalendarUser`
    object into `UserDetails`, Spring Security can make security decisions using our
    custom domain model. This means that we will no longer need to manage two different
    representations of a user.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将我们的领域模型（`CalendarUser`）与Spring Security的领域模型（`UserDetails`）关联起来，但我们必须维护用户的多个表示形式。为了解决这种双重维护问题，我们可以实现一个自定义的`UserDetailsService`对象，将我们的现有`CalendarUser`领域模型转换为Spring
    Security的`UserDetails`接口的实现。通过将我们的`CalendarUser`对象转换为`UserDetails`，Spring Security可以使用我们的自定义领域模型进行安全决策。这意味着我们不再需要管理用户的两种不同表示形式。
- en: The CalendarUserDetailsService class
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CalendarUserDetailsService`类'
- en: 'Up to this point, we have needed two different representations of users: one
    for Spring Security to make security decisions, and one for our application to
    associate our domain objects to. Create a new class named `CalendarUserDetailsService`
    that will make Spring Security aware of our `CalendarUser` object. This will ensure
    that Spring Security can make decisions based on our domain model. Create a new
    file named `CalendarUserDetailsService.java`, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要为用户提供两种不同的表示形式：一个用于Spring Security进行安全决策，另一个用于我们的应用程序将域对象与之关联。创建一个名为`CalendarUserDetailsService`的新类，以便Spring
    Security了解我们的`CalendarUser`对象。这将确保Spring Security可以根据我们的域模型做出决策。创建一个名为`CalendarUserDetailsService.java`的新文件，如下所示：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we utilize `CalendarUserDao` to obtain `CalendarUser` by using the email
    address. We take care not to return a null value; instead, a `UsernameNotFoundException`
    exception should be thrown, as returning `null` breaks the `UserDetailsService`
    interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用`CalendarUserDao`通过电子邮件地址获取`CalendarUser`。我们注意不要返回null值；相反，应该抛出`UsernameNotFoundException`异常，因为返回`null`会破坏`UserDetailsService`接口。
- en: We then convert `CalendarUser` into `UserDetails`, implemented by the user,
    as we did in the previous sections.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`CalendarUser`转换为`UserDetails`，由用户实现，就像我们在前面的章节中所做的那样。
- en: We now utilize a utility class named `CalendarUserAuthorityUtils` that we provided
    in the sample code. This will create `GrantedAuthority` based on the email address
    so that we can support users and administrators. If the email starts with `admin`,
    the user is treated as `ROLE_ADMIN` and `ROLE_USER`. Otherwise, the user is treated
    as `ROLE_USER`. Of course, we would not do this in a real application, but it’s
    this simplicity that allows us to focus on this lesson.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在利用一个名为`CalendarUserAuthorityUtils`的实用工具类，我们在示例代码中提供了它。这将根据电子邮件地址创建`GrantedAuthority`，以便我们可以支持用户和管理员。如果电子邮件以`admin`开头，则用户被视为`ROLE_ADMIN`和`ROLE_USER`。否则，用户被视为`ROLE_USER`。当然，我们不会在真实的应用程序中这样做，但正是这种简单性使我们能够专注于这个课程。
- en: Configuring UserDetailsService
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置UserDetailsService
- en: Now that we have a new `UserDetailsService` object, let’s update the Spring
    Security configuration to utilize it. Our `CalendarUserDetailsService` class is
    added to our Spring configuration automatically since we leverage `classpath`
    scanning and the `@Component` annotation. This means we only need to update Spring
    Security to refer to the `CalendarUserDetailsService` class we just created. `userDetailsService()`
    methods, Spring Security’s in-memory implementation of `UserDetailsService` since
    we are now providing our own `UserDetailsService` implementation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新的`UserDetailsService`对象，让我们更新Spring Security配置以利用它。由于我们利用了`classpath`扫描和`@Component`注解，我们的`CalendarUserDetailsService`类会自动添加到Spring配置中。这意味着我们只需要更新Spring
    Security以引用我们刚刚创建的`CalendarUserDetailsService`类。`userDetailsService()`方法，Spring
    Security的`UserDetailsService`内存实现，因为我们现在提供了自己的`UserDetailsService`实现。
- en: 'Update the `SecurityConfig.java` file, as follows to declare a `DelegatingPasswordEncoder`
    with default mappings. Additional mappings may be added and the encoding will
    be updated to conform with best practices. However, due to the nature of `DelegatingPasswordEncoder`,
    the updates should not impact users:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`SecurityConfig.java`文件，如下所示以声明一个具有默认映射的`DelegatingPasswordEncoder`。可以添加额外的映射，并且编码将更新以符合最佳实践。然而，由于`DelegatingPasswordEncoder`的性质，更新不应影响用户：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Removing references to UserDetailsManager
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除对UserDetailsManager的引用
- en: 'We need to remove the code we added in `DefaultCalendarService` that used `UserDetailsManager`
    to synchronize the Spring Security `o.s.s.core.userdetails.User` interface and
    `CalendarUser`. First, the code is not necessary since Spring Security now refers
    to `CalendarUserDetailsService`. Second, since we removed the `inMemoryAuthentication()`
    method, there is no `UserDetailsManager` object defined in our Spring configuration.
    Go ahead and remove all references to `UserDetailsManager` found in `DefaultCalendarService`.
    The updates will look similar to the following sample snippets:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要移除在`DefaultCalendarService`中添加的代码，该代码使用`UserDetailsManager`来同步Spring Security的`o.s.s.core.userdetails.User`接口和`CalendarUser`。首先，由于Spring
    Security现在引用了`CalendarUserDetailsService`，这段代码不再必要。其次，由于我们移除了`inMemoryAuthentication()`方法，我们的Spring配置中没有定义`UserDetailsManager`对象。继续移除`DefaultCalendarService`中找到的所有`UserDetailsManager`引用。更新将类似于以下示例片段：
- en: Start up the application and see that Spring Security’s in-memory `UserDetailsManager`
    object is no longer necessary (we removed it from our `SecurityConfig.java` file).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并查看 Spring Security 的内存 `UserDetailsManager` 对象现在不再必要（我们已从 `SecurityConfig.java`
    文件中删除它）。
- en: Important note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter03.03-calendar`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像 `chapter03.03-calendar`。
- en: The CalendarUserDetails object
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CalendarUserDetails 对象
- en: 'We have successfully eliminated the need to manage both Spring Security users
    and our `CalendarUser` objects. However, it is still cumbersome for us to continually
    need to translate between the two objects. Instead, we will create a `CalendarUserDetails`
    object, which can be referred to as both `UserDetails` and `CalendarUser`. Update
    `CalendarUserDetailsService` to use `CalendarUserDetails`, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功消除了同时管理 Spring Security 用户和我们的 `CalendarUser` 对象的需求。然而，对于我们来说，仍然需要不断地在这两个对象之间进行转换仍然很麻烦。因此，我们将创建一个
    `CalendarUserDetails` 对象，它可以被称作 `UserDetails` 和 `CalendarUser`。将 `CalendarUserDetailsService`
    更新为使用 `CalendarUserDetails`，如下所示：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, we will see that our application can now refer to the principal
    authentication on the current `CalendarUser` object. However, Spring Security
    can continue to treat `CalendarUserDetails` as a `UserDetails` object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到我们的应用程序现在可以引用当前 `CalendarUser` 对象上的主体认证。然而，Spring Security 可以继续将
    `CalendarUserDetails` 作为 `UserDetails` 对象处理。
- en: The SpringSecurityUserContext simplifications
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpringSecurityUserContext 简化
- en: 'We have updated `CalendarUserDetailsService` to return a `UserDetails` object
    that extends `CalendarUser` and implements `UserDetails`. This means that, rather
    than having to translate between the two objects, we can simply refer to a `CalendarUser`
    object. Update `SpringSecurityUserContext` as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `CalendarUserDetailsService` 更新为返回一个扩展 `CalendarUser` 并实现 `UserDetails`
    的 `UserDetails` 对象。这意味着，我们不再需要在两个对象之间进行转换，我们可以简单地引用 `CalendarUser` 对象。按照以下方式更新
    `SpringSecurityUserContext`：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The updates no longer require the use of `CalendarUserDao` or Spring Security’s
    `UserDetailsService` interface. Remember our `loadUserByUsername` method from
    the previous section? The result of this method call becomes the principal of
    the authentication. Since our updated `loadUserByUsername` method returns an object
    that extends `CalendarUser`, we can safely cast the principal of the `Authentication`
    object to `CalendarUser`. We can pass a `CalendarUser` object as the principal
    into the constructor for `UsernamePasswordAuthenticationToken` when invoking the
    `setCurrentUser` method. This allows us to still cast the principal to a `CalendarUser`
    object when invoking the `getCurrentUser` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更新不再需要使用 `CalendarUserDao` 或 Spring Security 的 `UserDetailsService` 接口。还记得我们之前章节中的
    `loadUserByUsername` 方法吗？这个方法调用的结果成为认证的主体。由于我们更新的 `loadUserByUsername` 方法返回一个扩展
    `CalendarUser` 的对象，我们可以安全地将 `Authentication` 对象的主体强制转换为 `CalendarUser`。在调用 `setCurrentUser`
    方法时，我们可以将 `CalendarUser` 对象作为主体传递给 `UsernamePasswordAuthenticationToken` 构造函数。这允许我们在调用
    `getCurrentUser` 方法时仍然将主体强制转换为 `CalendarUser` 对象。
- en: Displaying custom user attributes
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显示自定义用户属性
- en: 'Now that `CalendarUser` is populated into Spring Security’s authentication,
    we can update our UI to display the name of the current user rather than the email
    address. Update the `header.xhtml` file with the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于 `CalendarUser` 已填充到 Spring Security 的认证中，我们可以更新我们的 UI 以显示当前用户的姓名而不是电子邮件地址。使用以下代码更新
    `header.xhtml` 文件：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Internally, the `"${#authentication.getPrincipal().getName()}"` tag attribute
    executes the following code. Observe that the highlighted values correlate to
    the `property` attribute of the `authentication` tag we specified in the `header.xhtml`
    file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`"${#authentication.getPrincipal().getName()}"` 标签属性执行以下代码。注意，高亮显示的值与我们在
    `header.xhtml` 文件中指定的 `authentication` 标签的 `property` 属性相关联：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Restart the application, visit `http://localhost:8080/`, and log in to view
    the updates. Instead of seeing the current user’s email, you should now see their
    first and last names.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序，访问 `http://localhost:8080/` 并登录以查看更新。现在您应该看到的是用户的首字母和姓氏，而不是当前用户的电子邮件地址。
- en: Important note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter03.04-calendar`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像 `chapter03.04-calendar`。
- en: After configuring the `CalendarUserDetailsService` and `UserDetailsService`
    in the section and simplifying `SpringSecurityUserContext` to display custom user
    attributes, in the next section, we will explore how to create a custom `AuthenticationProvider`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中配置 `CalendarUserDetailsService` 和 `UserDetailsService` 并简化 `SpringSecurityUserContext`
    以显示自定义用户属性后，在下一节中，我们将探讨如何创建自定义的 `AuthenticationProvider`。
- en: Creating a custom AuthenticationProvider object
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义AuthenticationProvider对象
- en: Spring Security delegates to an `AuthenticationProvider` object to determine
    whether a user is authenticated or not. This means we can write custom `AuthenticationProvider`
    implementations to inform Spring Security how to authenticate in different ways.
    The good news is that Spring Security provides quite a few `AuthenticationProvider`
    objects, so more often than not you will not need to create one. In fact, up until
    this point, we have been utilizing Spring Security’s `o.s.s.authentication.dao.DaoAuthenticationProvider`
    object, which compares the username and password returned by `UserDetailsService`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security将委托给一个`AuthenticationProvider`对象来确定用户是否已认证。这意味着我们可以编写自定义的`AuthenticationProvider`实现来告知Spring
    Security如何以不同的方式认证。好消息是，Spring Security提供了相当多的`AuthenticationProvider`对象，所以大多数情况下您不需要创建一个。事实上，直到这一点，我们一直在使用Spring
    Security的`o.s.s.authentication.dao.DaoAuthenticationProvider`对象，该对象比较`UserDetailsService`返回的用户名和密码。
- en: Creating CalendarUserAuthenticationProvider
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建CalendarUserAuthenticationProvider
- en: Throughout the rest of this section, we are going to create a custom `AuthenticationProvider`
    object named `CalendarUserAuthenticationProvider` that will replace `CalendarUserDetailsService`.
    Then, we will use `CalendarUserAuthenticationProvider` to consider an additional
    parameter to support authenticating users from multiple domains.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将创建一个名为`CalendarUserAuthenticationProvider`的自定义`AuthenticationProvider`对象，它将替换`CalendarUserDetailsService`。然后，我们将使用`CalendarUserAuthenticationProvider`来考虑一个额外的参数，以支持从多个域验证用户。
- en: Important note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We must use an `AuthenticationProvider` object rather than `UserDetailsService`
    because the `UserDetails` interface has no concept of a domain parameter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`AuthenticationProvider`对象而不是`UserDetailsService`，因为`UserDetails`接口没有域参数的概念。
- en: 'Create a new class named `CalendarUserAuthenticationProvider`, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CalendarUserAuthenticationProvider`的新类，如下所示：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Important note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that you can use your `chapter03.05-calendar`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以使用您的`chapter03.05-calendar`。
- en: Before Spring Security can invoke the `authenticate` method, the `supports`
    method must return `true` for the `Authentication` class that will be passed in.
    In this case, `AuthenticationProvider` can authenticate a username and password.
    We do not accept subclasses of `UsernamePasswordAuthenticationToken` since there
    may be additional fields that we do not know how to validate.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security可以调用`authenticate`方法之前，必须确保将要传入的`Authentication`类的`supports`方法返回`true`。在这种情况下，`AuthenticationProvider`可以验证用户名和密码。我们不接受`UsernamePasswordAuthenticationToken`的子类，因为可能存在我们不知道如何验证的额外字段。
- en: The `authenticate` method accepts an `Authentication` object as an argument
    that represents an authentication request. In practical terms, it is the input
    from the user that we need to attempt to validate. If authentication fails, the
    method should throw an `o.s.s.core.AuthenticationException` exception. If authentication
    succeeds, it should return an `Authentication` object that contains the proper
    `GrantedAuthority` objects for the user. The returned `Authentication` object
    will be set on `SecurityContextHolder`. If authentication cannot be determined,
    the method should return `null`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate`方法接受一个表示认证请求的`Authentication`对象作为参数。在实践中，这是我们需要尝试验证的用户输入。如果认证失败，该方法应抛出`o.s.s.core.AuthenticationException`异常。如果认证成功，它应返回一个包含用户适当`GrantedAuthority`对象的`Authentication`对象。返回的`Authentication`对象将被设置在`SecurityContextHolder`中。如果无法确定认证，该方法应返回`null`。'
- en: The first step in authenticating the request is to extract the information from
    the `Authentication` object that we need to authenticate the user. In our case,
    we extract the username and lookup `CalendarUser` by email address, just as `CalendarUserDetailsService`
    did. If the provided username and password match `CalendarUser`, we will return
    a `UsernamePasswordAuthenticationToken` object with proper `GrantedAuthority`.
    Otherwise, we will throw an `AuthenticationException` exception.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 验证请求的第一步是从`Authentication`对象中提取我们需要用于验证用户的信息。在我们的例子中，我们提取用户名并通过电子邮件地址查找`CalendarUser`，就像`CalendarUserDetailsService`所做的那样。如果提供的用户名和密码与`CalendarUser`匹配，我们将返回一个包含适当`GrantedAuthority`的`UsernamePasswordAuthenticationToken`对象。否则，我们将抛出`AuthenticationException`异常。
- en: Remember how the login page leveraged `SPRING_SECURITY_LAST_EXCEPTION` to explain
    why the login failed? The message for the `AuthenticationException` exception
    thrown in `AuthenticationProvider` is the last `AuthenticationException` exception
    and will be displayed on our login page in the event of a failed login.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记得登录页面是如何利用`SPRING_SECURITY_LAST_EXCEPTION`来解释登录失败的原因吗？在`AuthenticationProvider`中抛出的`AuthenticationException`异常消息是最后一个`AuthenticationException`异常，并在登录失败的情况下显示在我们的登录页面上。
- en: Configuring the CalendarUserAuthenticationProvider object
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置`CalendarUserAuthenticationProvider`对象
- en: 'Let’s perform the following steps to configure `CalendarUserAuthenticationProvider`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来配置`CalendarUserAuthenticationProvider`：
- en: 'Update the `SecurityConfig.java` file to refer to our newly created `CalendarUserAuthenticationProvider`
    object, and remove the reference to `CalendarUserDetailsService`, as shown in
    the following code snippet:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`SecurityConfig.java`文件以引用我们新创建的`CalendarUserAuthenticationProvider`对象，并移除对`CalendarUserDetailsService`的引用，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Update the `SecurityConfig.java` file, as follows, by removing the `PasswordEncoder`
    bean:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`SecurityConfig.java`文件，如下所示，通过移除`PasswordEncoder`bean：
- en: '[PRE20]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Restart the application and ensure everything is still working. As a user, we
    do not notice anything different. However, as a developer, we know that `CalendarUserDetails`
    is no longer required; we are still able to display the current user’s first and
    last names, and Spring Security is still able to leverage `CalendarUser` for authentication.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用程序并确保一切仍然正常工作。作为一个用户，我们不会注意到任何不同。然而，作为一个开发者，我们知道`CalendarUserDetails`不再需要；我们仍然能够显示当前用户的姓名和姓氏，Spring
    Security仍然能够利用`CalendarUser`进行认证。
- en: Important note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter03.05-calendar`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter03.05-calendar`。
- en: Authenticating with different parameters
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不同参数进行认证
- en: One of the strengths of `AuthenticationProvider` is that it can authenticate
    with any parameters you wish. For example, maybe your application uses a random
    identifier for authentication, or perhaps it is a multitenant application and
    requires a username, password, and domain. In the following section, we will update
    `CalendarUserAuthenticationProvider` to support multiple domains.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthenticationProvider`的一个优点是它可以使用您想要的任何参数进行认证。例如，也许您的应用程序使用随机标识符进行认证，或者它可能是一个多租户应用程序，需要用户名、密码和域。在下一节中，我们将更新`CalendarUserAuthenticationProvider`以支持多个域。'
- en: Important note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A domain is a way to scope our users. For example, if we deploy our application
    once but have multiple clients using the same deployment, each client may want
    a user with the username `admin`. By adding a domain to our user object, we can
    ensure that each user is distinct and still supports this requirement.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 域是我们用户范围的一种方式。例如，如果我们只部署一次应用程序，但有多个客户端使用相同的部署，每个客户端可能希望有一个用户名为`admin`的用户。通过向我们的用户对象添加域，我们可以确保每个用户都是唯一的，并且仍然支持这一要求。
- en: The DomainUsernamePasswordAuthenticationToken class
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`DomainUsernamePasswordAuthenticationToken`类'
- en: 'When a user authenticates, Spring Security submits an `Authentication` object
    to `AuthenticationProvider` with the information provided by the user. The current
    `UsernamePasswordAuthentication` object only contains a username and password
    field. Create a `DomainUsernamePasswordAuthenticationToken` object that contains
    a `domain` field, as shown in the following code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进行认证时，Spring Security会将用户提供的信息提交给`AuthenticationProvider`的`Authentication`对象。当前的`UsernamePasswordAuthentication`对象仅包含用户名和密码字段。创建一个包含`domain`字段的`DomainUsernamePasswordAuthenticationToken`对象，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Updating CalendarUserAuthenticationProvider
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新`CalendarUserAuthenticationProvider`
- en: 'Let’s take a look at the following steps for updating the `CalendarUserAuthenticationProvider.java`
    file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更新`CalendarUserAuthenticationProvider.java`文件的以下步骤：
- en: 'Now, we need to update `CalendarUserAuthenticationProvider` to utilize the
    domain field, as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`CalendarUserAuthenticationProvider`以利用域字段，如下所示：
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We first update the support method so that Spring Security will pass `DomainUsername`
    **PasswordAuthenticationToken** into our `authenticate` method.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先更新支持方法，以便Spring Security将`DomainUsername`**PasswordAuthenticationToken**传递到我们的`authenticate`方法中。
- en: We then use the domain information to create our email address and authenticate,
    as we had previously done. Admittedly, this example is contrived. However, the
    example can illustrate how to authenticate with an additional parameter.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用域信息来创建我们的电子邮件地址并进行认证，就像我们之前做的那样。诚然，这个例子是人为设计的。然而，这个例子可以说明如何使用额外的参数进行认证。
- en: The `CalendarUserAuthenticationProvider` interface can now use the new domain
    field. However, there is no way for a user to specify the domain. For this, we
    must update our `login.xhtml` file.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CalendarUserAuthenticationProvider`接口现在可以使用新的域名字段。然而，用户无法指定域名。为此，我们必须更新我们的`login.xhtml`文件。'
- en: Adding domain to the login page
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将域名添加到登录页面
- en: 'Open up the `login.xhtml` file and add a new input named `domain`, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`login.xhtml`文件并添加一个名为`domain`的新输入，如下所示：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, a domain will be submitted when users attempt to log in. However, Spring
    Security is unaware of how to use that domain to create a `DomainUsernamePasswordAuthenticationToken`
    object and pass it into `AuthenticationProvider`. To fix this, we will need to
    create `DomainUsernamePasswordAuthenticationFilter`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户尝试登录时，将提交一个域名。然而，Spring Security不知道如何使用该域名来创建`DomainUsernamePasswordAuthenticationToken`对象并将其传递给`AuthenticationProvider`。为了解决这个问题，我们需要创建`DomainUsernamePasswordAuthenticationFilter`。
- en: The DomainUsernamePasswordAuthenticationFilter class
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`DomainUsernamePasswordAuthenticationFilter`类'
- en: 'Spring Security provides a number of `Servlet Filters` that act as controllers
    for authenticating users. The filters are invoked as one of the delegates of the
    `FilterChainProxy` object that we discussed in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. Previously, the `formLogin()` method instructed
    Spring Security to use `o.s.s.web.authentication.UsernamePasswordAuthenticationFilter`
    to act as a login controller. The filter’s job is to perform the following tasks:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了一些`Servlet Filters`，这些过滤器充当认证用户的控制器。这些过滤器作为我们在[*第2章*](B21757_02.xhtml#_idTextAnchor043)，“Spring
    Security入门”中讨论的`FilterChainProxy`对象的一个代表被调用。之前，`formLogin()`方法指示Spring Security使用`o.s.s.web.authentication.UsernamePasswordAuthenticationFilter`作为登录控制器。该过滤器的任务是执行以下任务：
- en: Obtain a username and password from the HTTP request.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从HTTP请求中获取用户名和密码。
- en: Create a `UsernamePasswordAuthenticationToken` object with the information obtained
    from the HTTP request.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从HTTP请求中获得的信息创建一个`UsernamePasswordAuthenticationToken`对象。
- en: Request that Spring Security validates `UsernamePasswordAuthenticationToken`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求Spring Security验证`UsernamePasswordAuthenticationToken`。
- en: If the token is validated, it will set the authentication returned to it on
    `SecurityContext` **Holder**, just as we did when a new user signed up for an
    account. We will need to extend `UsernamePasswordAuthenticationFilter` to leverage
    our newly created `DoainUsernamePasswordAuthenticationToken` object.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果令牌被验证，它将在`SecurityContext` **持有者**上设置返回的认证，就像我们在新用户注册账户时所做的。我们需要扩展`UsernamePasswordAuthenticationFilter`以利用我们新创建的`DoainUsernamePasswordAuthenticationToken`对象。
- en: 'Create a `DomainUsernamePasswordAuthenticationFilter` object, as follows:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`DomainUsernamePasswordAuthenticationFilter`对象，如下所示：
- en: '[PRE24]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The new `DomainUsernamePasswordAuthenticationFilter` object will perform the
    following tasks:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`DomainUsernamePasswordAuthenticationFilter`对象将执行以下任务：
- en: Obtain a username, password, and domain from the `HttpServletRequest` method.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`HttpServletRequest`方法中获取用户名、密码和域名。
- en: Create our `DomainUsernamePasswordAuthenticationToken` object with information
    obtained from the HTTP request.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从HTTP请求中获得的信息创建我们的`DomainUsernamePasswordAuthenticationToken`对象。
- en: Request that Spring Security validates `DomainUsernamePasswordAuthenticationToken`.
    The work is delegated to `CalendarUserAuthenticationProvider`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求Spring Security验证`DomainUsernamePasswordAuthenticationToken`。这项工作委托给了`CalendarUserAuthenticationProvider`。
- en: If the token is validated, its superclass will set the authentication returned
    by `CalendarUserAuthenticationProvider` on `SecurityContextHolder`, just as we
    did to authenticate a user after they created a new account.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果令牌被验证，其超类将在`SecurityContextHolder`上设置由`CalendarUserAuthenticationProvider`返回的认证，就像我们在用户创建新账户后进行认证时所做的。
- en: Updating our configuration
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新我们的配置
- en: 'Now that we have created all the code required for an additional parameter,
    we need to configure Spring Security to be aware of it. The following code snippet
    includes the required updates to our `SecurityConfig.java` file to support our
    additional parameter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所需的所有代码，我们需要配置Spring Security以了解它。以下代码片段包括对`SecurityConfig.java`文件的必要更新，以支持我们的附加参数：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following are a few highlights from the configuration updates:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是配置更新的一些亮点：
- en: We overrode `defaultAuthenticationEntryPoint` and added a reference to `o.s.s.web.authentication.LoginUrlAuthenticationEntryPoint`,
    which determines what happens when a request for a protected resource occurs and
    the user is not authenticated. In our case, we are redirected to a login page.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们覆盖了 `defaultAuthenticationEntryPoint` 并添加了对 `o.s.s.web.authentication.LoginUrlAuthenticationEntryPoint`
    的引用，该引用确定当请求受保护资源且用户未认证时会发生什么。在我们的情况下，我们将被重定向到登录页面。
- en: We removed the `formLogin()` method and used a `.addFilterAt()` method to insert
    our custom filter into `FilterChainProxy`. The position indicates the order in
    which the delegates of `FilterChain` are considered and cannot overlap with another
    filter, but can replace the filter at the current position. We replaced `UsernamePasswordAuthenticationFilter`
    with our custom filter.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们移除了 `formLogin()` 方法，并使用 `.addFilterAt()` 方法将我们的自定义过滤器插入到 `FilterChainProxy`
    中。位置指示了 `FilterChain` 代理者被考虑的顺序，不能与其他过滤器重叠，但可以替换当前位置的过滤器。我们将 `UsernamePasswordAuthenticationFilter`
    替换为我们的自定义过滤器。
- en: 'Take a look at the following diagram for your reference:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参考以下图表以供参考：
- en: '![Figure 3.5 – Custom Authentication implementation](img/B21757_03_5.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 自定义身份验证实现](img/B21757_03_5.jpg)'
- en: Figure 3.5 – Custom Authentication implementation
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 自定义身份验证实现
- en: 'You can now restart the application and try the following steps, depicted in
    the preceding diagram, to understand how all the pieces fit together:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以重新启动应用程序并尝试以下步骤，如前图所示，以了解所有部件是如何结合在一起的：
- en: Visit `http://localhost:8080/events`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:8080/events`。
- en: Spring Security will intercept the secured URL and use the `LoginUrlAuthentication`
    **EntryPoint** object to process it.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security 将拦截受保护的 URL 并使用 `LoginUrlAuthentication` **EntryPoint** 对象来处理它。
- en: The `LoginUrlAuthenticationEntryPoint` object will send the user to the login
    page. Enter `admin1` as the username, `example.com` as the domain, and `admin1`
    as the password.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoginUrlAuthenticationEntryPoint` 对象将用户发送到登录页面。将 `admin1` 作为用户名，`example.com`
    作为域，`admin1` 作为密码。'
- en: The `DomainUsernamePasswordAuthenticationFilter` object will intercept the process
    of the login request. It will then obtain the username, domain, and password from
    the HTTP request and create a `DomainUsernamePasswordAuthenticationToken` object.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DomainUsernamePasswordAuthenticationFilter` 对象将拦截登录请求的过程。然后，它将从 HTTP 请求中获取用户名、域和密码，并创建一个
    `DomainUsernamePasswordAuthenticationToken` 对象。'
- en: The `DomainUsernamePasswordAuthenticationFilter` object submits `DomainUsernamePasswordAuthenticationToken`
    to `CalendarUser``AuthenticationProvider`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DomainUsernamePasswordAuthenticationFilter` 对象将 `DomainUsernamePasswordAuthenticationToken`
    提交到 `CalendarUser` `AuthenticationProvider`。'
- en: The `CalendarUserAuthenticationProvider` interface validates `DomainUsername`
    **PasswordAuthenticationToken** and then returns an authenticated `DomainUsername`
    **PasswordAuthenticationToken** object (that is, `isAuthenticated()` returns `true`).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CalendarUserAuthenticationProvider` 接口验证 `DomainUsername` **PasswordAuthenticationToken**，然后返回一个已认证的
    `DomainUsername` **PasswordAuthenticationToken** 对象（即 `isAuthenticated()` 返回 `true`）。'
- en: The `DomainUserPasswordAuthenticationFilter` object updates `SecurityContext`
    with `DomainUsernamePasswordAuthenticationToken` and places it on `SecurityContextHolder`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DomainUserPasswordAuthenticationFilter` 对象使用 `DomainUsernamePasswordAuthenticationToken`
    更新 `SecurityContext` 并将其放置在 `SecurityContextHolder` 中。'
- en: Important note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter03.06-calendar`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像 `chapter03.06-calendar`。
- en: Now that we have covered the users sign-up workflow and how to create custom
    `UserDetailsService` and `AuthenticationProvider` objects, we will discuss in
    the next section which authentication method should be used.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了用户注册工作流程以及如何创建自定义 `UserDetailsService` 和 `AuthenticationProvider` 对象，我们将在下一节讨论应该使用哪种身份验证方法。
- en: Which authentication method should you use?
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应该使用哪种身份验证方法？
- en: 'We have covered the three main methods of authenticating, so, which one is
    the best? Like all solutions, each comes with its pros and cons. You can find
    a summary of when to use a specific type of authentication by referring to the
    following list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了三种主要的身份验证方法，那么哪一种是最好的呢？像所有解决方案一样，每种方法都有其优缺点。您可以通过参考以下列表来找到何时使用特定类型身份验证的总结：
- en: '`SecurityContextHolder`: Interacting directly with `SecurityContextHolder`
    is certainly the easiest way of authenticating a user. It works well when you
    are authenticating a newly created user or authenticating unconventionally. By
    using `SecurityContextHolder` directly, we do not have to interact with so many
    Spring Security layers. The downside is that we do not get some of the more advanced
    features that Spring Security provides automatically. For example, if we want
    to send the user to the previously requested page after logging in, we will have
    to manually integrate that into our controller.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecurityContextHolder`: 直接与 `SecurityContextHolder` 交互无疑是验证用户的最简单方式。当你需要验证新创建的用户或以非传统方式验证时，它工作得很好。通过直接使用
    `SecurityContextHolder`，我们无需与那么多 Spring Security 层进行交互。缺点是，我们无法获得 Spring Security
    自动提供的一些更高级功能。例如，如果我们想在登录后发送用户到之前请求的页面，我们必须手动将其集成到我们的控制器中。'
- en: '`UserDetailsService`: Creating a custom `UserDetailsService` object is an easy
    mechanism that allows Spring Security to make security decisions based on our
    custom domain model. It also provides a mechanism to hook into other Spring Security
    features. For example, Spring Security requires `UserDetailsService` to use the
    built-in remember-me support covered in [*Chapter 7*](B21757_07.xhtml#_idTextAnchor220),
    *Remember-me Services*. The `UserDetailsService` object does not work when authentication
    is not based on a username and password.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserDetailsService`: 创建自定义的 `UserDetailsService` 对象是一种简单的机制，它允许 Spring Security
    根据我们的自定义域模型做出安全决策。它还提供了一种机制来挂钩到其他 Spring Security 功能。例如，Spring Security 需要 `UserDetailsService`
    使用在 [*第 7 章*](B21757_07.xhtml#_idTextAnchor220) 中介绍的内置记住我（remember-me）支持，*记住我服务*。当验证不是基于用户名和密码时，`UserDetailsService`
    对象不起作用。'
- en: '`AuthenticationProvider`: This is the most flexible method for extending Spring
    Security. It allows a user to authenticate with any parameters that they wish.
    However, if we wish to leverage features such as Spring Security’s remember-me,
    we will still need `UserDetailsService`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationProvider`: 这是扩展 Spring Security 的最灵活方法。它允许用户使用他们想要的任何参数进行验证。然而，如果我们想利用像
    Spring Security 的记住我（remember-me）这样的功能，我们仍然需要 `UserDetailsService`。'
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has used real-world problems to introduce the basic building blocks
    used in Spring Security. It also demonstrates to us how we can make Spring Security
    authenticate against our custom domain objects by extending those basic building
    blocks. In short, we have learned that the `SecurityContextHolder` interface is
    the central location for determining the current user. Not only can it be used
    by developers to access the current user, but also to set the currently logged-in
    user.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了现实世界的问题来介绍 Spring Security 中使用的基本构建块。它还向我们展示了我们如何通过扩展这些基本构建块来使 Spring Security
    对我们的自定义域对象进行验证。简而言之，我们了解到 `SecurityContextHolder` 接口是确定当前用户的中心位置。它不仅可以被开发者用来访问当前用户，还可以用来设置当前登录用户。
- en: We also explored how to create custom `UserDetailsService` and `AuthenticationProvider`
    objects and how to perform authentication with more than just a username and password.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何创建自定义的 `UserDetailsService` 和 `AuthenticationProvider` 对象，以及如何使用不仅仅是用户名和密码进行验证。
- en: In the next chapter, we will explore some of the built-in support for **Java
    Database Connectivity** (**JDBC**)-based authentication.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索基于 **Java 数据库连接**（**JDBC**）的内置验证支持。
- en: 'Part 2: Authentication Techniques'
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：验证技术
- en: In this part, we explore various authentication methods and services provided
    by Spring Security. First, we delve into authenticating users against a database
    using Spring Security’s JDBC support. Additionally, we discuss securing passwords
    with Spring Security’s cryptography module to enhance security.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们探讨了 Spring Security 提供的各种验证方法和服务。首先，我们深入探讨了使用 Spring Security 的 JDBC
    支持对数据库中的用户进行验证。此外，我们还讨论了使用 Spring Security 的加密模块来保护密码以增强安全性。
- en: Moving on, we will explore the integration of Spring Data with Spring Security,
    utilizing JPA to authenticate against relational databases and MongoDB for document
    databases.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索 Spring Data 与 Spring Security 的集成，利用 JPA 对关系型数据库进行验证，并使用 MongoDB 对文档数据库进行验证。
- en: Next, we will introduce the **Lightweight Directory Access Protocol** (**LDAP**)
    and its integration with Spring Security. We explore how LDAP can provide authentication,
    authorization, and user information services within a Spring Security-enabled
    application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍**轻量级目录访问协议**（**LDAP**）及其与Spring Security的集成。我们将探讨LDAP如何在启用Spring Security的应用程序中提供身份验证、授权和用户信息服务。
- en: Then, we uncover the functionality of the remember-me feature in Spring Security
    and its configuration. Additionally, we address considerations when implementing
    the remember-me functionality, enabling applications to remember users even after
    session expiration and browser closure.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将揭示Spring Security中记住我功能的特性和其配置。此外，我们还将讨论实现记住我功能时的注意事项，使应用程序能够在会话过期和浏览器关闭后仍然记住用户。
- en: Lastly, we will explore alternative authentication methods that are available
    to accommodate various credential types. We transcend traditional form-based authentication
    to delve into the realm of authentication using trusted client-side certificates.
    Spring Security provides robust support for these diverse authentication requirements,
    offering a framework to implement and manage authentication using client-side
    certificates, thus enhancing security measures within applications.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨可用的替代身份验证方法，以适应各种凭证类型。我们将超越传统的基于表单的身份验证，深入到使用受信任的客户端证书进行身份验证的领域。Spring
    Security为这些多样化的身份验证需求提供了强大的支持，提供了一个框架来实施和管理使用客户端证书的身份验证，从而增强了应用程序中的安全措施。
- en: 'This part has the following chapters:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B21757_04.xhtml#_idTextAnchor106), *JDBC-**based* *Authentication*'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B21757_04.xhtml#_idTextAnchor106)，*基于JDBC的* *身份验证*'
- en: '[*Chapter 5*](B21757_05.xhtml#_idTextAnchor150), *Authentication with Spring
    Data*'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21757_05.xhtml#_idTextAnchor150)，*使用Spring Data进行身份验证*'
- en: '[*Chapter 6*](B21757_06.xhtml#_idTextAnchor180), *LDAP Directory Services*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21757_06.xhtml#_idTextAnchor180)，*LDAP目录服务*'
- en: '[*Chapter 7*](B21757_07.xhtml#_idTextAnchor220), *Remember-**me* *Services*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21757_07.xhtml#_idTextAnchor220)，*记住我* *服务*'
- en: '[*Chapter 8*](B21757_08.xhtml#_idTextAnchor261), *Client Certificate Authentication
    with TLS*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21757_08.xhtml#_idTextAnchor261)，*使用TLS的客户端证书身份验证*'
