- en: Local Variable Syntax for Lambda Parameters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda参数的局部变量语法
- en: Java is enhancing its language by extending the use of the reserved type `var` for
    lambda parameters. The sole purpose of this enhancement is to align the syntax
    of lambda parameters with the syntax of declaring local variables with `var`.
    The parameters of implicitly-typed lambda expressions have been inferred by the
    compiler since lambdas were introduced, in Java 8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java通过扩展保留类型`var`在lambda参数中的使用来增强其语言。这种增强的唯一目的是使lambda参数的语法与使用`var`声明局部变量的语法保持一致。自lambda引入以来，Java
    8的编译器已经推断出隐式类型化lambda表达式的参数类型。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implicitly and explicitly-typed lambda parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式和显式类型化的lambda参数
- en: How to use `var` with lambda parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`var`与lambda参数一起使用
- en: Using annotations with lambda parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda参数的注解
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To execute the code in this chapter, you must install JDK 11 (or a later version)
    on your system. All of the code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)[.](https://github.com/PacktPublishing/Java-11-and-12-New-Features)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章中的代码，你必须在你的系统上安装JDK 11（或更高版本）。本章中的所有代码都可以在[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)找到[。](https://github.com/PacktPublishing/Java-11-and-12-New-Features)
- en: Lambda expressions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: A **lambda expression** is an anonymous function that can accept input parameters
    and return a value. A lambda expression can specify the types of all (or none)
    of its input parameters; lambda expressions can be explicitly-typed or implicitly-typed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**lambda表达式**是一个匿名函数，可以接受输入参数并返回一个值。lambda表达式可以指定所有（或没有）输入参数的类型；lambda表达式可以是显式类型化的或隐式类型化的。'
- en: Explicitly-typed lambda expressions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式类型化的lambda表达式
- en: 'A lambda expression that explicitly specifies the type of all of its input
    parameters is referred to as an explicitly-typed lambda expression. The following
    code illustrates a few examples (with the input parameters in bold):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 明确指定所有输入参数类型的lambda表达式被称为显式类型化的lambda表达式。以下代码展示了几个示例（输入参数以粗体显示）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code in all of the preceding examples explicitly defines the types of all
    of the parameters that are being passed to it. If a lambda expression doesn't
    accept any parameter, it uses a pair of empty round braces (`()`).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的示例中，代码明确地定义了传递给它的所有参数的类型。如果一个lambda表达式不接受任何参数，它使用一对空圆括号（`()`）。
- en: 'If this makes you wonder the types of the variables to which the lambda expressions
    will be assigned, here''s the complete code for your reference:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这让你想知道lambda表达式将被分配给哪些变量的类型，以下是完整的代码供你参考：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implicitly-typed lambda expressions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式类型化的lambda表达式
- en: A lambda expression that doesn't specify the types of any of its input parameters
    is referred to as an **implicitly-typed** lambda expression. In this case, the
    compiler infers the type of the method parameters and adds it to the bytecode.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 没有指定任何输入参数类型的lambda表达式被称为**隐式类型化的lambda表达式**。在这种情况下，编译器推断方法参数的类型并将其添加到字节码中。
- en: 'Let''s modify the lambda expression from the preceding section, dropping the
    types of the input parameters (the modified code is in bold):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一节中的lambda表达式，去掉输入参数的类型（修改后的代码以粗体显示）：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can''t mix implicitly-typed and explicitly-typed parameters in lambda expressions.
    For instance, the following code won''t compile because it explicitly specifies
    type of `x`, but not for `y`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在lambda表达式中混合隐式类型化和显式类型化的参数。例如，以下代码无法编译，因为它明确指定了`x`的类型，但没有指定`y`的类型：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lambda parameters and type inference with var
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda参数和var的类型推断
- en: In JDK 11, you'll be able to use `var` with lambda parameters. However, this
    is just syntactic sugar. The reserved type name, `var`, was introduced in JDK
    10, to enable developers to declare local variables without using an explicit
    data type (to let the compiler infer the data type during compilation). But implicitly-typed
    lambda expressions were already doing this by using only the variable name for
    their parameters, without their types (examples are included in the preceding
    section).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '在 JDK 11 中，你将能够使用 `var` 与 lambda 参数一起使用。然而，这仅仅是一种语法糖。保留类型名 `var` 在 JDK 10 中被引入，以便开发者可以在不使用显式数据类型的情况下声明局部变量（让编译器在编译期间推断数据类型）。但是，隐式类型
    lambda 表达式已经通过仅使用变量名作为它们的参数（而不使用它们的类型）来实现这一点（示例包括在上一节中）。 '
- en: Adding var to lambda parameters
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 lambda 参数添加 var
- en: Java allows for the use of the reserved word `var` with lambda parameters, to
    align its syntax with the declaration of local variables, which can now use `var`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java 允许使用保留词 `var` 与 lambda 参数一起使用，以使其语法与局部变量的声明对齐，现在这些局部变量可以使用 `var`。
- en: 'Let''s modify the examples from the preceding section, adding `var` to the
    lambda parameters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一节中的示例，向 lambda 参数添加 `var`：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The main reason for allowing the addition of `var` to lambda parameters is to
    align the usage with the syntax of the local parameters declared using `var`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 允许将 `var` 添加到 lambda 参数中的主要原因是为了使其使用与使用 `var` 声明的局部变量的语法对齐。
- en: 'If you are using `var` with lambda parameters, you must use it with all of
    the lambda parameters. You can''t mix implicitly-typed or explicitly-typed parameters
    with the parameters that use `var`. The following code example won''t compile:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `var` 与 lambda 参数，你必须与所有 lambda 参数一起使用它。你不能将隐式类型或显式类型参数与使用 `var` 的参数混合。以下代码示例无法编译：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You cannot enclose the parameters of a lambda expression using round brackets (`()`)
    if you are using just one method parameter. But, you can''t drop `()` if you are
    using `var` with your lambda parameters. Here is some sample code to illustrate
    this further:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用一个方法参数，你不能使用圆括号（`()`）来包围 lambda 表达式的参数。但是，如果你在 lambda 参数中使用 `var`，你不能省略
    `()`。以下是一些示例代码，以进一步说明这一点：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can't mix implicitly-typed or explicitly-typed lambda parameters with the
    parameters that use `var`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将隐式类型或显式类型 lambda 参数与使用 `var` 的参数混合。
- en: Adding annotations to lambda parameters
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 lambda 参数添加注解
- en: 'You can use annotations with lambda parameters if you define them with either
    explicit data types or by using the reserved type `var`. Annotations could be
    used to mark null or non-null lambda parameters. Here''s an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用显式数据类型或使用保留类型 `var` 定义 lambda 参数，你可以使用注解。注解可以用来标记 null 或非 null 的 lambda
    参数。以下是一个示例：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Summary
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered using the reserved type `var` with implicitly-typed
    lambda expressions. We started by identifying the syntax differences in explicitly-typed
    and implicitly-typed lambda expressions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用保留类型 `var` 与隐式类型 lambda 表达式。我们首先确定了显式类型和隐式类型 lambda 表达式的语法差异。
- en: Through examples, you saw how adding `var` to lambda parameters is just syntactic
    sugar, since you have been able to use type inference with implicitly-typed lambda
    parameters ever since they were introduced in Java 8\. Using `var` with lambda
    parameters aligns their syntax with the local variables defined using `var`. Using `var`
    also enables developers to use annotations with lambda parameters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例，你看到了如何将 `var` 添加到 lambda 参数中只是语法糖，因为自从它们在 Java 8 中引入以来，你一直能够使用类型推断来使用隐式类型
    lambda 参数。使用 `var` 与 lambda 参数使它们的语法与使用 `var` 声明的局部变量对齐。使用 `var` 还使开发者能够使用注解与
    lambda 参数。
- en: In the next chapter, we'll work with the HTTP Client API, which will be added
    to Java 11 as one of its core APIs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理 HTTP 客户端 API，该 API 将作为 Java 11 的核心 API 之一被添加。
