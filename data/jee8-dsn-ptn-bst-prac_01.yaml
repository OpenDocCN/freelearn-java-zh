- en: Introduction to Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式简介
- en: This chapter will introduce design patterns, looking at reasons to use them,
    how they differ from enterprise patterns, and how they behave in the real world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍设计模式，探讨使用它们的原因，它们与业务模式的不同，以及它们在现实世界中的表现。
- en: 'Since we assume that you are already familiar with the Java programming language
    and Java EE, our goal is not to teach Java EE, but to demonstrate its most common
    design patterns. We will also demonstrate examples of the implementation of design
    patterns using Java EE 8\. Furthermore, we will demonstrate the best way to implement
    design patterns and discuss the benefits of using design patterns and enterprise
    patterns. If you do not know about design patterns and enterprise patterns, then
    this book will be a great tool for learning about the concepts and implementations
    of design patterns and enterprise patterns. If you already know about design patterns
    and enterprise patterns, then this book will be a great point of reference to
    address when implementing them. We''ll cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们假设你已经熟悉Java编程语言和Java EE，我们的目标不是教授Java EE，而是展示其最常见的设计模式。我们还将演示使用Java EE 8实现设计模式的示例。此外，我们将展示实现设计模式的最优方法，并讨论使用设计模式和业务模式的好处。如果你不了解设计模式和业务模式，那么这本书将是一个学习设计模式和业务模式概念及其实现的大好工具。如果你已经了解设计模式和业务模式，那么这本书将是一个在实现它们时参考的绝佳点。在本章中，我们将涵盖以下主题：
- en: Understanding design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式
- en: Understanding the advantages of design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式的优势
- en: Defining the basic design patterns of the Java world
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义Java世界的基本设计模式
- en: Explaining enterprise patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释业务模式
- en: Explaining the difference between design patterns and enterprise patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释设计模式与业务模式之间的区别
- en: Explaining design patterns
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释设计模式
- en: Design patterns are sets of solutions to common design problems that occur over
    and over in development. They work as a solution template in which an abstract
    solution for a common problem is described and the user then applies it, adapting
    it to their problem. In object-oriented programming, the design pattern provides
    a way to design reusable classes and objects for a specific problem as well as
    defining the relationship between objects and classes. In addition, design patterns
    provide a common idiom among programming languages that allows architects and
    software developers to communicate about a common and recurring problem regardless
    of the programming language they are using. With this, we are able to identify
    a problem and its solution by the name of the pattern and thinking about a solution
    by a model point of view in a high abstraction level of language programming details.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是一系列针对在开发中反复出现的常见设计问题的解决方案。它们作为一个解决方案模板，其中描述了一个常见问题的抽象解决方案，然后用户应用它，根据他们的问题进行适配。在面向对象编程中，设计模式提供了一种为特定问题设计可重用类和对象的方法，以及定义对象和类之间的关系。此外，设计模式在编程语言中提供了一种共同的表达方式，使得架构师和软件开发者能够在使用不同编程语言的情况下就共同和反复出现的问题进行沟通。有了这个，我们能够通过模式名称识别问题和解决方案，并通过在语言编程细节的高抽象层次上从模型角度思考解决方案。
- en: 'The design patterns theme gained strength in 1994 after the *Gang of Four*
    (formed by Rich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) wrote *Design
    Patterns*: *Elements of Reusable Object‐Oriented Software*. Here, they described
    23 design patterns that were later known as GoF design patterns and are still
    used today.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式主题在1994年得到了加强，当时“四人帮”（由Rich Gamma、Richard Helm、Ralph Johnson和John Vlissides组成）撰写了《设计模式：可复用面向对象软件元素》。在这里，他们描述了后来被称为GoF设计模式的23个设计模式，这些模式至今仍在使用。
- en: Explaining the Gang of Four design patterns
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释四人帮设计模式
- en: The **Gang of Four** (**GoF**) design patterns are 23 patterns that are classified
    as creational patterns, structural patterns, and behavioral patterns. The creational
    patterns control the creation and initialization of the object and class selection;
    the structural patterns define the relationship between classes and objects, and
    the behavioral patterns control the communication and interaction between objects. As
    well as this, the GoF design patterns have two types of scope which define the
    focus of solutions. These scopes are *object scope,* which resolves problems about
    object relations, and *class scope, *which resolves problems about class relations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**GoF**（四人帮）设计模式是23种模式，分为创建型模式、结构型模式和行怍型模式。创建型模式控制对象的创建和初始化以及类选择；结构型模式定义类和对象之间的关系，行怍型模式控制对象之间的通信和交互。此外，GoF设计模式有两种类型的范围，定义了解决方案的重点。这些范围是*对象范围*，解决关于对象关系的问题，以及*类范围*，解决关于类关系的问题。'
- en: The *object scope* works with composition and the behavior changes are done
    in a runtime. Thus, the object can have a dynamic behavior. The class scope works
    with inheritance and its behavior is static-fixed at compile-time way. Then, to
    change the behavior of a class-scope pattern, we need to change the class and
    recompile.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象范围*与组合一起工作，行为变化在运行时完成。因此，对象可以具有动态行为。类范围与继承一起工作，其行为在编译时是静态固定的。然后，要改变类范围模式的行怍，我们需要更改类并重新编译。'
- en: Patterns classified as class scope solve problems about the relationship between
    classes and are static (fixed at compile time and cannot be changed once compiled).
    However, patterns classified under the object scope solve problems about the relationship
    between objects and can be changed at runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 被归类为类范围的模式解决关于类之间关系的问题，并且是静态的（在编译时固定，一旦编译后就不能更改）。然而，归类于对象范围的模式解决关于对象之间关系的问题，并且可以在运行时更改。
- en: 'The following diagram shows us the three classifications, as well as their
    patterns and scope:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了三种分类，以及它们的模式和范围：
- en: '![](img/8cc41ee8-491b-4867-9682-d8663b902064.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cc41ee8-491b-4867-9682-d8663b902064.png)'
- en: In the preceding diagram, we can see the **Factory Method** pattern on the **Class** section and
    the **Abstract Factory** pattern on the **Object** section. This occurs because
    the **Factory Method** works with inheritance and the abstract method pattern
    works with composition. Then, the Factory Method is static-fixed at compile time
    and cannot be changed after compilation. However, the **Abstract Factory** is
    dynamic and can be changed at runtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到**工厂方法**模式位于**类**部分，而**抽象工厂**模式位于**对象**部分。这是因为**工厂方法**与继承一起工作，而抽象方法模式与组合一起工作。然后，工厂方法在编译时是静态固定的，编译后不能更改。然而，**抽象工厂**是动态的，可以在运行时更改。
- en: GoF design patterns are generally described using a graphical notation such
    as a use case diagram, and an example of the implementation's code. The used notation
    must be able to describe the classes and objects as well as the relationship between
    these classes and objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GoF设计模式通常使用图形符号，如用例图和实现代码的示例来描述。所使用的符号必须能够描述类和对象，以及这些类和对象之间的关系。
- en: The pattern's name is an important part of the design patterns. This is because
    it is what the developer uses to quickly identify the problem related to the pattern
    and to understand how the pattern will solve it. The name of the pattern must
    be brief and refer to the problem and its solution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的名称是设计模式的重要组成部分。这是因为开发者用它来快速识别与模式相关的问题，并理解模式将如何解决它。模式的名称必须简短，并指代问题和解决方案。
- en: A design pattern is a great tool for designing software development, but its
    use needs to be analyzed to determine if the design pattern is really required
    in order to solve the problem.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是软件开发设计的一个伟大工具，但它的使用需要分析，以确定设计模式是否真正需要来解决该问题。
- en: The catalog of Gang of Four design patterns
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GoF设计模式目录
- en: Names of design patterns need be succinct, making them easy to identify. This
    is because design patterns create a vocabulary for communicating between developers
    independent of programming language, permitting developers to identify problems
    and solutions only by name of a design pattern.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的名称需要简洁，以便于识别。这是因为设计模式为开发者创造了一种与编程语言无关的交流词汇，允许开发者仅通过设计模式的名称来识别问题和解决方案。
- en: In design patterns, a catalog is a set of pattern names which are designed to
    permit a better communication between developers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模式中，目录是一组模式名称，旨在允许开发者之间更好的沟通。
- en: 'The catalog of GoF''s design patterns has 23 patterns, as shown in the preceding
    diagram. Here is a description of these patterns:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: GoF（ Gang of Four）的设计模式目录有23个模式，如前图所示。以下是这些模式的描述：
- en: '**Abstract Factory**: This provides an interface to create objects without
    specifying their concrete class, making it possible to decouple the business logic
    and the object creation logic. With this, we can update the object creation logic
    in an easy way.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂（Abstract Factory）**: 这提供了一个创建对象的接口，而不指定它们的具体类，使得业务逻辑和对象创建逻辑解耦成为可能。通过这种方式，我们可以轻松地更新对象创建逻辑。'
- en: '**Adapter**: This provides an interface that makes it possible for two incompatible
    interfaces to work together. The adapter pattern works as a bridge between interfaces,
    adapting these interfaces to work together. Furthermore, the adapter can adopt
    a class or objects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器（Adapter）**: 这提供了一个接口，使得两个不兼容的接口能够一起工作。适配器模式作为接口之间的桥梁，将这些接口适配以协同工作。此外，适配器可以采用一个类或对象。'
- en: '**Bridge**: This patterndecouples an abstraction from its implementation, making
    them vary independently. With this, we can modify the implementations without
    impacting the abstractions and we can also modify the abstractions without impacting
    the implementations. The class of abstraction hides implementations and its complexity.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接（Bridge）**: 这种模式解耦了抽象与其实现，使它们可以独立变化。通过这种方式，我们可以修改实现而不影响抽象，也可以修改抽象而不影响实现。抽象类的类隐藏了实现及其复杂性。'
- en: '**Builder**: This pattern separates the construction of a complex object from
    its representation. With this, we can construct the objects of several representations
    using the same process to that. Thus, we create a standard process of construction
    of objects that have a complex process to construct.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建造者（Builder）**: 这种模式将复杂对象的构建与其表示分离。通过这种方式，我们可以使用相同的过程构建具有复杂构建过程的多个表示的对象。因此，我们创建了一个具有复杂构建过程的对象的标准化构建过程。'
- en: '**Chain of responsibility**: This pattern avoids coupling the sender and receiver
    of a request creating some objects that have a chance to treat the requests. These
    objects create a chain of receiver objects for a sender''s request. Each object
    of this chain receives the request and verifies whether or not it will treat this
    request.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**责任链（Chain of responsibility）**: 这种模式避免了请求发送者和接收者之间的耦合，创建了一些有机会处理请求的对象。这些对象为发送者的请求创建了一个接收者对象链。链中的每个对象都接收请求并验证是否处理此请求。'
- en: '**Command**: This pattern encapsulates a request for an object and creates
    a wrapper of requests containing their information about the request. With this,
    we can do a request to some object sending parameters without knowing about this
    operation. Furthermore, the command permits us to execute an `undo` operation.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令（Command）**: 这种模式封装了对对象的请求，并创建了一个包含请求信息的请求包装器。通过这种方式，我们可以向某个对象发送参数请求，而无需了解此操作。此外，命令允许我们执行`撤销`操作。'
- en: '**Composite**: This pattern composes objects into a tree structure, which represents
    a part-whole hierarchy. It permits you to treat a group of objects as a single
    object.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合（Composite）**: 这种模式将对象组合成树状结构，表示部分-整体层次结构。它允许你将一组对象视为单个对象。'
- en: '**Decorator**: This pattern permit extends a functionality of a class with
    flexibility, without use subclass. It allows you to dynamically attach a new responsibility
    to an object.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器（Decorator）**: 这种模式允许以灵活的方式扩展类的功能，而不需要使用子类。它允许你动态地为对象附加新的职责。'
- en: '**Facade**: This hides the complexity of the system, applying a unified interface
    to a set of interfaces on a subsystem. This makes the subsystem easy to use.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观（Facade）**: 这隐藏了系统的复杂性，为子系统上的多个接口提供了一个统一的接口。这使得子系统易于使用。'
- en: '**Factory Method**: This defines an interface for creating an object, and the
    subclass states which class to initiate.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法（Factory Method）**: 这定义了一个创建对象的接口，子类指定要初始化的类。'
- en: '**Flyweight**: This uses sharing to efficiently support a large number of fine-grained
    objects. This pattern reduces the number of objects created.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**享元（Flyweight）**: 这通过共享有效地支持大量细粒度对象。这种模式减少了创建的对象数量。'
- en: '**Interpreter**: This pattern represents language grammar and uses it to interpret
    them as sentences of a language.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释器（Interpreter）**: 这种模式表示语言语法，并使用它来解释它们作为语言的句子。'
- en: '**Iterator**: This pattern provides a way to sequentially access the elements of
    a set of objects without knowing its underlying representation.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器（Iterator）**: 这个模式提供了一种按顺序访问一组对象元素的方法，而无需知道其底层表示。'
- en: '**Mediator**: This reduces the complexity of communication by creating an object
    that encapsulates all the communication and interaction between objects.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中介者（Mediator）**: 通过创建一个封装所有对象之间通信和交互的对象来减少通信的复杂性。'
- en: '**Memento**: This pattern captures the object''s internal states without hurting
    encapsulated concepts, with this, the state of the object can be restored by the
    object. This pattern works as a backup that maintains the current state of an
    object.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录（Memento）**: 这个模式在不损害封装概念的情况下捕获对象的内部状态，通过这个，对象的状态可以通过对象本身恢复。这个模式作为一个备份，维护对象的当前状态。'
- en: '**Observer**: This defines a one-to-many dependency between objects. This means
    that if one object is modified, all of its dependents are automatically notified
    and updated.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者（Observer）**: 这定义了对象之间的一对多依赖关系。这意味着如果一个对象被修改，所有依赖它的对象都会自动收到通知并更新。'
- en: '**Prototype**: This pattern permits us to create a new object using an object
    or instance as a prototype. This pattern creates a copy of an object, creating
    a new object with the same state of the object used as a prototype.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型（Prototype）**: 这个模式允许我们使用对象或实例作为原型来创建一个新的对象。这个模式创建了一个对象的副本，创建了一个具有作为原型使用的对象相同状态的新对象。'
- en: '**Proxy**: This pattern creates a surrogate object (proxy object) for another
    object (original object) in order to control the access to the original object.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理（Proxy）**: 这个模式为另一个对象（原始对象）创建一个代理对象（代理对象），以便控制对原始对象的访问。'
- en: '**State:** This permits an object to alter its behavior when its internal state
    changes.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态（State）**: 这允许对象在内部状态改变时改变其行为。'
- en: '**Singleton**: This ensures that a class has only one instance in the entire
    project, and the same instance of the object is returned every time the creation
    process is performed/run.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例（Singleton）**: 这确保在整个项目中一个类只有一个实例，每次执行创建过程时都返回相同的对象实例。'
- en: '**Strategy**: This creates a family of algorithms, encapsulating each one and
    making them interchangeable. This pattern permits you to change the algorithm
    at runtime.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略（Strategy）**: 这创建了一个算法族，封装每个算法并使它们可互换。这个模式允许你在运行时更改算法。'
- en: '**Template method**: This defines a skeleton for an algorithm in an operation,
    and the subclass defines some steps to the algorithm. This pattern algorithm structure
    and the subclass redefine some steps of this algorithm without modifying its structure.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板方法（Template Method）**: 这在操作中定义了一个算法的骨架，子类定义了算法的一些步骤。这个模式算法结构和子类重新定义了此算法的一些步骤，而不修改其结构。'
- en: '**Visitor**: This represents an operation to be performed on an object structure.
    This pattern permits us to add new operations to an element without modifying
    its class.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问者（Visitor）**: 这代表对对象结构执行的操作。这个模式允许我们在不修改其类的情况下向元素添加新的操作。'
- en: Understanding the advantages of design patterns
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设计模式的优点
- en: Creating an object-oriented design is a tough task. This is because we have several
    important elements to think about with regard to the scenario that we'll work
    in and the problem we'll solve. This includes defining the appropriate objects that we
    need to create in order to reach the solution; defining the granularity of objects
    and looking at what interfaces we need to create. These tasks need to be addressed
    during the creation process in design. Objects can be created to represent a real-world
    object or to represent a process with its algorithms and responsibilities. Furthermore,
    we even need to consider the number of objects, their size, and the interface
    we need to access.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建面向对象的设计是一项艰巨的任务。这是因为我们需要考虑我们将在其中工作的场景和我们将解决的问题的几个重要元素。这包括定义我们需要创建以达成解决方案的适当对象；定义对象的粒度并查看我们需要创建哪些接口。这些任务需要在设计过程中解决。可以创建对象来表示现实世界中的对象，或者表示具有其算法和责任的过程。此外，我们甚至需要考虑对象的数量、大小以及我们需要访问的接口。
- en: Design patterns are great tools for helping us to identify classes and objects
    that don't represent real-world objects and objects that are less-obvious abstractions.
    Moreover, design patterns help us to apply the finest granularity to objects and
    they also allow us to analyze a problem and solution as a model. Design patterns
    make the design flexible, providing a decoupling between classes and objects.
    They also provide the ability to organize solutions, allowing delegate responsibilities
    to classes with the best way.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '设计模式是帮助我们识别不表示现实世界对象和不太明显的抽象对象的伟大工具。此外，设计模式帮助我们以最细粒度应用对象，并允许我们将问题和解决方案作为一个模型来分析和应用。设计模式使设计灵活，提供类和对象之间的解耦。它们还提供了组织解决方案的能力，允许将责任委托给以最佳方式实现这些解决方案的类。 '
- en: Building software is an expensive process for companies because it requires
    capable professionals and infrastructure to build and maintain the software. Design
    patterns, with their flexibility and decoupled design, make maintenance easy and
    therefore decrease its cost.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于公司来说，构建软件是一个昂贵的流程，因为它需要能够构建和维护软件的专业人才和基础设施。设计模式，凭借其灵活性和解耦设计，使得维护变得容易，从而降低了成本。
- en: Understanding the basic design patterns of the Java world
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java世界的经典设计模式
- en: All GoF patterns have a good purpose and solve major problems of object-oriented
    design, but some patterns are most commonly used in the Java and Java EE ecosystem.
    In this book, these patterns are treated as basic design patterns because they
    are most commonly used to implement solutions on Java's APIs, frameworks, and
    algorithms. Consequently, understanding these patterns will help us to understand
    these APIs, frameworks, and algorithms, and we'll, in turn, be able to create
    a better solution using Java. These patterns are Singleton, Abstract Factory,
    Facade, Iterator, and Proxy.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有GoF模式都有良好的目的，解决了面向对象设计中的主要问题，但有些模式在Java和Java EE生态系统中最常使用。在这本书中，这些模式被视为基本设计模式，因为它们最常用于在Java的API、框架和算法上实现解决方案。因此，理解这些模式将帮助我们理解这些API、框架和算法，反过来，我们也能使用Java创建更好的解决方案。这些模式包括Singleton、Abstract
    Factory、Facade、Iterator和Proxy。
- en: Explaining Singleton
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释Singleton
- en: 'In a software project, in some solutions, we may want to ensure that a class
    has only one instance of an object throughout the project and that this object
    is accessible at any point in the project. Creating a global instance or static
    instance will not ensure that this class will not be used at another point in
    another instance. The best way to solve this is by using the Singleton pattern,
    which ensures that there is only one instance of a class in the entire project.
    In the following diagram, we are showing the structure of Singleton and how it
    is designed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个软件项目中，在某些解决方案中，我们可能希望确保在整个项目中一个类只有一个对象实例，并且这个对象在任何时候都可以访问。创建一个全局实例或静态实例并不能保证这个类在另一个实例的另一个点不会被使用。解决这个问题的最佳方式是使用Singleton模式，它确保在整个项目中只有一个类的实例。在下面的图中，我们展示了Singleton的结构及其设计方式：
- en: '![](img/b845e3ba-cca7-4b81-95d9-ef5b8e714936.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b845e3ba-cca7-4b81-95d9-ef5b8e714936.png)'
- en: Here, we have one class called **Singleton** which has a `private` constructor,
    as well as a reference variable of Singleton and a method for returning its unique
    instance. A good example of an application is a situation in which we want to
    create a class responsible for application configurations (paths to some resource,
    parameters to access filesystems, behaviors of the environment). Often, the application
    has some configurations and we need a class to represent these application configurations.
    Thus, this class of application configuration doesn't need various instances,
    but only one instance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为**Singleton**的类，它有一个`private`构造函数，以及一个Singleton引用变量和一个返回其唯一实例的方法。一个很好的应用例子是，当我们想要创建一个负责应用程序配置（一些资源的路径、访问文件系统的参数、环境的操作行为）的类时。通常，应用程序有一些配置，我们需要一个类来表示这些应用程序配置。因此，这个应用程序配置类不需要多个实例，只需要一个实例。
- en: Another application of Singleton is when we want to create an Abstract Factory
    that will be explained in the following subsection. Generally, we will have only
    one Abstract Factory throughout the application. With this, we can use a Singleton
    to guarantee that we will have only one instance of Abstract Factory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton的另一个应用场景是当我们想要创建一个将在下一个小节中解释的Abstract Factory时。通常，在整个应用程序中我们只有一个Abstract
    Factory。通过这种方式，我们可以使用Singleton来保证我们只有一个Abstract Factory的实例。
- en: This pattern is often used in frameworks and APIs, but it is common for this
    pattern to be found in the code of projects, mainly on Java EE.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常用于框架和API中，但这种情况在Java EE项目的代码中也很常见。
- en: The use of the Singleton pattern can be a good practice depending on the scenario,
    but depending on the scenario the use of Singleton can be a bad practice. The
    Singleton should not be used when the object is stateful and maintain a state,
    because with Singleton the same instance of the object is shared by all processes
    of application and if some process updates a state of this object all processes
    of application will be impacted by this update. Furthermore, we can have a problem
    with the concurrent update of the state of a Singleton.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的使用取决于场景，但根据场景的不同，单例的使用可能是一个好的实践，也可能是一个坏的做法。当对象是状态性的并且保持状态时，不应该使用单例，因为单例意味着同一个对象实例被应用程序的所有进程共享，如果某个进程更新了这个对象的状态，那么应用程序的所有进程都将受到这个更新的影响。此外，我们可能会遇到单例状态并发更新的问题。
- en: Explaining Abstract Factory
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释抽象工厂
- en: Sometimes, we need to create a family of objects in a project. Imagine that
    we have an e-commerce and we have various kinds of products such as cell phones,
    notebooks, and tablets. These products are objects of the same family. If we create
    objects throughout a software, we will face problems if we then need to modify
    the initialization process of this object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在项目中我们需要创建一系列的对象。想象一下，我们有一个电子商务网站，我们有各种产品，如手机、笔记本电脑和平板电脑。这些产品属于同一系列。如果我们在一个软件中创建了这些对象，当我们需要修改这个对象的初始化过程时，我们将会遇到问题。
- en: Using Abstract Factory will help us to solve problems including a system which
    should be independent of how its products are created, a system that should use
    one of the multiple families of products, and a system that should work with objects
    which are designed to be used together. Using this pattern will be beneficial
    as it isolates concrete classes. This means that with this pattern, we can control
    which class of objects that can be initiated on software. Furthermore, it permits
    the exchange of products easily and provides consistency among products.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象工厂可以帮助我们解决包括一个应该独立于其产品创建方式而存在的系统、一个应该使用多个产品系列之一的系统，以及一个应该与设计用来一起使用的对象一起工作的系统在内的问题。使用这种模式将有益，因为它隔离了具体类。这意味着，使用这种模式，我们可以控制在软件中可以初始化哪些类对象。此外，它还允许轻松地交换产品，并在产品之间提供一致性。
- en: 'The Abstract Factory pattern creates a single point of creation for objects
    and if we need to change the algorithm of object creation, we need only modify
    the concrete factory. In the following diagram, you can see the structure of Abstract
    Factory and how it is designed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式为对象创建提供了一个单一的创作点，如果我们需要更改对象创建的算法，我们只需要修改具体工厂。在下面的图中，你可以看到抽象工厂的结构以及它的设计方式：
- en: '![](img/338bd53e-8bd1-4a15-871f-2f2cc94ffd83.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/338bd53e-8bd1-4a15-871f-2f2cc94ffd83.png)'
- en: In our example, the Abstract Factory's structure has three main classes—`AbstractFactory`,
    `Product`, and `Sale`. The concrete classes of `AbstractFactory` are `CellPhoneFactory`,
    `NotebookFactory`, and `TabletFactory`. `CellPhoneFactory` is a concrete class
    responsible for creating the concrete classes `CellphoneProduct` and `CellphoneSale`,
    `NotebookFactory` is a concrete class responsible for creating the concrete classes
    `NotebookProduct` and `NotebookSale`, and the `TabletFactory` is a concrete class
    responsible for creating the concrete classes `TabletProduct` and `TabletSale`.
    A `Client` is a class responsible for using `AbstractFactory` to create `AbstractProduct`
    and `AbstractSale`. The concrete factory is created at runtime and it then creates
    the concrete product and sale.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，抽象工厂的结构有三个主要类——`AbstractFactory`、`Product`和`Sale`。`AbstractFactory`的具体类是`CellPhoneFactory`、`NotebookFactory`和`TabletFactory`。`CellPhoneFactory`是一个具体类，负责创建具体类`CellphoneProduct`和`CellphoneSale`，`NotebookFactory`是一个具体类，负责创建具体类`NotebookProduct`和`NotebookSale`，而`TabletFactory`是一个具体类，负责创建具体类`TabletProduct`和`TabletSale`。`Client`是一个负责使用`AbstractFactory`来创建`AbstractProduct`和`AbstractSale`的类。具体工厂在运行时创建，然后创建具体的产品和销售。
- en: The Abstract Factory pattern is sometimes used with another pattern such as
    Singleton, which we described earlier. Abstract Factory is a single point of creation,
    and often we need only one instance of it in an entire system. With this, using
    a Singleton pattern can help us create a design better and more efficiently.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式有时会与之前描述的单例模式等其他模式一起使用。抽象工厂是一个创建点，通常在整个系统中只需要一个实例。有了这个，使用单例模式可以帮助我们创建更好的设计，并更高效。
- en: This pattern is often used in frameworks and APIs that have a difficult creation
    process for an object, such as connections or sessions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常用于具有复杂创建过程的框架和API，例如连接或会话。
- en: Explaining Facade
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释外观
- en: Projects can sometimes turn out to be very complex and big, making them difficult
    to design and organize. To solve this, a great solution is to break a system into
    subsystems (divide and conquer) and make them less complex and better organized.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 项目有时可能会变得非常复杂和庞大，这使得它们难以设计和组织。为了解决这个问题，一个很好的解决方案是将系统分解为子系统（分而治之），使它们更简单且更有组织。
- en: 'The Facade pattern creates a higher-level interface to hide a complexity of
    a set of interfaces in a subsystem. This pattern reduces the complexity and coupling,
    minimizing communication and dependencies between subsystems. In the following
    diagram, you can see the structure of **Facade** and how it is designed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式创建了一个更高层次的接口，以隐藏子系统内一组接口的复杂性。这种模式减少了复杂性耦合，最小化了子系统之间的通信和依赖。在下面的图中，你可以看到外观（**Facade**）的结构及其设计方式：
- en: '![](img/13464b99-60bf-42ba-8557-25d1193fd008.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13464b99-60bf-42ba-8557-25d1193fd008.png)'
- en: In the preceding diagram, we can see the **Facade** pattern encapsulating all
    of the calls to subsystems and hiding these calls from the client. The system
    has one interface, Facade, and the client calls this interface in order to call
    subsystems. Thus, clients does not call the subsystems directly. With this solution,
    the client doesn't need to know about the subsystem and its complexity.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到**外观**模式封装了所有对子系统的调用，并隐藏了这些调用对客户端的可见性。系统有一个接口，即外观（Facade），客户端通过调用这个接口来调用子系统。因此，客户端不会直接调用子系统。使用这种解决方案，客户端不需要了解子系统及其复杂性。
- en: This pattern is often used in projects and systems that have high complexity
    and need to be broken down into subsystems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常用于具有高复杂性的项目和系统，需要将它们分解为子系统。
- en: Explaining Iterator
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释迭代器
- en: Imagine that we want a way to access elements of an aggregate object sequentially
    without exposing its internal structure. The Iterator pattern does just that.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要一种方法来按顺序访问聚合对象的元素，而不暴露其内部结构。迭代器模式正是这样做的。
- en: 'The Iterator pattern is responsible for sequentially accessing the aggregate
    object and defining an interface to access the elements without exposing the internal
    structure. This interface doesn''t put a new element on the aggregate object,
    but simply reads elements to it. In the following diagram, you can see the structure
    of an **Iterator** and how it is designed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式负责按顺序访问聚合对象，并定义一个接口来访问元素，而不暴露其内部结构。这个接口不会在聚合对象上放置新元素，而只是读取元素到它。在下面的图中，你可以看到迭代器（**Iterator**）的结构及其设计方式：
- en: '![](img/d661cc1e-2e1e-4662-8d77-7110231045b4.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d661cc1e-2e1e-4662-8d77-7110231045b4.png)'
- en: In the preceding diagram, we can see the **Aggregate** and **Iterator **interfaces with
    their concrete subclasses. The client is the class that uses the **Iterator**
    to access elements of **Aggregate**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到**聚合**和**迭代器**接口及其具体的子类。客户端是使用**迭代器**来访问**聚合**元素的那个类。
- en: This pattern is used on Java collections such as list, deque, and set. Understanding
    this pattern will help you to understand Java collections.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在Java集合如列表、双端队列和集合中使用。理解这种模式将有助于你理解Java集合。
- en: Explaining Proxy
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释代理
- en: Sometimes, creating a new object can be a big process and several rules can
    be involved in creating this object. Imagine that we want to create a list of
    objects, and these objects represent telecommunication equipment, which has a
    lot of calculus to generate the information of each object. As well as this, these
    objects will not be accessed at the same time but will be accessed on demand.
    A good strategy is to create each object when it is accessed, thereby minimizing the
    cost and time it takes to create all objects and only access some. The Proxy can
    help us to solve this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，创建一个新的对象可能是一个大过程，并且创建此对象可能涉及多个规则。想象一下，我们想要创建一个对象列表，这些对象代表电信设备，它们需要大量的计算来生成每个对象的信息。此外，这些对象不会同时被访问，而是按需访问。一个好的策略是在访问对象时创建每个对象，从而最小化创建所有对象所需的时间和成本，并且只访问一些。代理可以帮我们解决这个问题。
- en: 'The Proxy pattern is a pattern that surrogates an object instance (original
    object) to another object instance (Proxy object) that permitting access control
    to the original object. In the following diagram, you can see the structure of
    **Proxy** and how it is designed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式是一种代理对象实例（原始对象）到另一个对象实例（代理对象）的模式，允许对原始对象进行访问控制。在下面的图中，你可以看到 **代理** 的结构和它的设计方式：
- en: '![](img/029d3aca-04db-4bb9-b452-d94796b46a09.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/029d3aca-04db-4bb9-b452-d94796b46a09.png)'
- en: From the preceding diagram, we can see a structure of the **Proxy** pattern.
    If **Subject** is an interface that clients use to access object operations, then
    **RealSubject** is the class of the original object and **Proxy** is the class
    that works as a **Proxy**. Then, when the client accesses the object, they will
    access the **Proxy** object, and the **Proxy** object will then access the **RealSubject**
    object and return this object to the client.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以看到 **代理** 模式的结构。如果 **Subject** 是客户端用来访问对象操作的接口，那么 **RealSubject**
    是原始对象的类，而 **Proxy** 是充当 **代理** 的类。然后，当客户端访问对象时，他们将访问 **代理** 对象，而 **代理** 对象将访问
    **RealSubject** 对象，并将此对象返回给客户端。
- en: This pattern is used in frameworks and APIs that implement JPA specification
    and **object relational mapping** (**ORM**).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式用于实现 JPA 规范和 **对象关系映射**（**ORM**）的框架和 API 中。
- en: Explaining enterprise patterns
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释企业模式
- en: Over time, technology has evolved and new tools have emerged and helped to change
    some areas. Seeing the potential of these technologies, organizations increasingly
    began to use and invest in these tools to automate their processes and optimize
    their costs. These tools then began to be referred to as enterprise software.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，技术不断发展，新的工具不断涌现并帮助改变了一些领域。看到这些技术的潜力，组织越来越多地开始使用并投资这些工具来自动化他们的流程并优化他们的成本。这些工具随后开始被称为企业软件。
- en: Enterprise software is a type of software widely used in organizations, companies,
    or governments that provide a service to make their processes better and optimize
    the cost and efficiency. Over time, the complexity of this software increased
    as they began to provide a lot of services. As different services demanded more
    communication, scalability became increasingly important. With this, some problems
    surfaced.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 企业软件是一种在组织、公司或政府中广泛使用的软件类型，它提供了一种服务，以改善其流程并优化成本和效率。随着时间的推移，这种软件的复杂性不断增加，因为它们开始提供许多服务。随着不同服务对更多通信的需求，可扩展性变得越来越重要。因此，一些问题出现了。
- en: 'Enterprise patterns is a set of solutions for common problems that appear in
    enterprise software as a result of the complexity of enterprise environments.
    Many enterprise patterns are based on GoF patterns and differ only in the way
    in which we implement them. On Java EE, enterprise patterns are divided into three
    groups: presentation patterns, business patterns, and integration patterns. These
    patterns act on the presentation tier, business tier, and integration patterns,
    and we''ll cover their details in [Chapter 2](7db5fa69-8dea-4753-80f4-5ca2e8feab28.xhtml),
    *Presentation Patterns*, which covers presentation patterns, [Chapter 3](2e0b5048-f52a-4868-b5d4-b7e8f7f3c6b3.xhtml), *Business
    Patterns*, which covers business patterns, and [Chapter 4](4d4d0c00-31ce-4d19-8547-b95d92500f8c.xhtml),* Integration
    Patterns*, which covers integration patterns.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 企业模式是一套针对在企业软件中由于企业环境复杂性而产生的常见问题的解决方案。许多企业模式基于GoF模式，只是在实现方式上有所不同。在Java EE中，企业模式分为三组：表现层模式、业务层模式和集成层模式。这些模式作用于表现层、业务层和集成层，我们将在[第2章](7db5fa69-8dea-4753-80f4-5ca2e8feab28.xhtml)“表现层模式”中详细讨论，该章节涵盖了表现层模式，[第3章](2e0b5048-f52a-4868-b5d4-b7e8f7f3c6b3.xhtml)“业务层模式”，该章节涵盖了业务层模式，以及[第4章](4d4d0c00-31ce-4d19-8547-b95d92500f8c.xhtml)“集成层模式”，该章节涵盖了集成层模式。
- en: Enterprise patterns are very important for professionals who create software,
    because bad practices in the creation of software could inflate the cost and risks
    involved in the projects. Because of the complexity of the enterprise software,
    an error could propagate along the time and environment, making the enterprise
    environment unsustainable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 企业模式对于创建软件的专业人士来说非常重要，因为软件创建中的不良实践可能会增加项目涉及的成本和风险。由于企业软件的复杂性，错误可能会随着时间的推移和环境的变化而传播，使得企业环境难以持续。
- en: Defining the difference between design patterns and enterprise patterns
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义设计模式与企业模式之间的区别
- en: 'Comparing design patterns with enterprise patterns is not an easy task, because
    some behaviors are similar. Design patterns were the first subject that arrived,
    and this was covered in *Design Patterns: Elements of Reusable Object*-*Oriented
    Software*, written by Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides.
    These design patterns were also the base to other patterns. Enterprise patterns
    became necessities that design patterns cannot resolve. This is because the design
    patterns describe solutions for of classes and objects relationships, but the
    enterprise environments have other necessities such as integrations between systems
    and software relations. However, enterprise patterns use some design patterns
    to solve problems.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将设计模式与企业模式进行比较并非易事，因为某些行为是相似的。设计模式是首先出现的主题，这在Erich Gamma、Richard Helm、Ralph
    Johnson和John Vlissides合著的《设计模式：可复用面向对象软件元素》一书中有所涉及。这些设计模式也是其他模式的基础。企业模式成为设计模式无法解决的问题。这是因为设计模式描述了类和对象之间关系的解决方案，但企业环境有其他需求，如系统之间的集成和软件关系。然而，企业模式使用一些设计模式来解决问题。
- en: The principal difference between design patterns and enterprise patterns is
    the aim; design patterns aim to organize and optimize the object-oriented design,
    and enterprise patterns focus on improving the use of Java EE tools as well as
    making communications between Java EE components better. Design patterns are focused
    on object-oriented and class and object relations, whereas enterprise patterns
    are focused on communication between Java EE components.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式与企业模式之间的主要区别在于目标；设计模式旨在组织和优化面向对象设计，而企业模式则侧重于提高Java EE工具的使用效率以及改善Java EE组件之间的通信。设计模式关注面向对象和类与对象的关系，而企业模式关注Java
    EE组件之间的通信。
- en: The use of design patterns makes it possible to reuse algorithms and also makes
    the design flexible; enterprise design patterns promote an abstraction of the
    complexity of Java EE tools and make it easier for the architecture to make changes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的使用使得算法的重用成为可能，同时也使得设计更加灵活；企业设计模式促进了Java EE工具复杂性的抽象，使得架构变更更加容易。
- en: Because of the complexity of architecture, the minimal use of enterprise patterns
    tends to be worse than the minimal use of design patterns. This is because, with
    the lack of use of enterprise patterns, the professional will always work with
    Java EE's complexity, increasing the probability of error.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于架构的复杂性，企业模式的最小使用往往比设计模式的最小使用更差。这是因为，在没有使用企业模式的情况下，专业人士将始终与Java EE的复杂性打交道，增加了出错的可能性。
- en: Some implementations of Java EE patterns are already present in Java EE tools,
    and this makes them easy to use. In the next chapters, we will describe some of
    these patterns and their implementation using Java EE tools and see how these
    patterns will favor the design and architecture of your project.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Java EE模式的实现已经存在于Java EE工具中，这使得它们易于使用。在接下来的章节中，我们将描述这些模式及其使用Java EE工具的实现，并看看这些模式将如何有利于您项目的架构和设计。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced you to design patterns, explaining the GoF design
    patterns and their catalog. We covered the basic design patterns of the Java world
    with a brief introduction to Singleton, Abstract Factory, Facade, Iterator, and
    Proxy. As well as this, we looked at enterprise patterns and the difference between
    them and design patterns.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了设计模式，解释了GoF设计模式和它们的目录。我们简要介绍了Java世界的基本设计模式，包括Singleton、Abstract
    Factory、Facade、Iterator和Proxy。此外，我们还探讨了企业模式和它们与设计模式之间的区别。
- en: In the next chapter, we will explain presentation patterns, including their
    concepts and implementation. We will also demonstrate the concepts of presentation
    patterns and how they help us to write better software. We will then show examples
    of the implementation of presentation patterns, using real-world problems as an
    example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解释展示模式，包括它们的概念和实现。我们还将展示展示模式的概念以及它们如何帮助我们编写更好的软件。然后，我们将通过现实世界的问题展示展示模式的实现示例。
