- en: Chapter 5. Publishing to a Maven Repository
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：发布到Maven仓库
- en: In the previous chapter, you learned how to use the `Upload` task to publish
    your project artifacts. In this chapter, you will learn more about the new and
    still-developing feature of publishing your artifacts to a Maven repository.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用`Upload`任务发布你的项目工件。在本章中，你将了解更多关于将工件发布到Maven仓库的新功能和仍在开发中的特性。
- en: You will learn about the new publishing mechanism in Gradle. This feature is
    currently still under development, and that means the implementation might change
    in the future. But for now, this way of publishing artifacts will be the default.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解Gradle中的新发布机制。这个特性目前仍在开发中，这意味着实现可能会在未来发生变化。但到目前为止，这种发布工件的方式将是默认的。
- en: Defining publication
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义发布
- en: We must add the `maven-publish` plugin to our project to add the new publication
    feature of Gradle. The plugin allows us to define and deploy our project artifacts
    in the Maven format. This means our deployed project can be used by other developers
    and projects that support the Maven format. For example, other projects could
    use Gradle or Maven and define a dependency to our published artifacts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将`maven-publish`插件添加到我们的项目中，以添加Gradle的新发布功能。该插件允许我们定义和部署我们的项目工件以Maven格式。这意味着我们的部署项目可以被支持Maven格式的其他开发者和项目使用。例如，其他项目可以使用Gradle或Maven并定义一个对我们发布的工件依赖。
- en: The `maven-publish` plugin is based on a general `publishing` plugin. The `publishing`
    plugin adds a new `publishing` extension to our project. We can use a `publications`
    configuration block in our build script to configure the artifacts we want to
    publish and the repositories we want to deploy to. The `publications` extension
    has the `PublishingExtension` type in the `org.gradle.api.publish` package. The
    plugin also adds the general life cycle `publish` task to the project. Other tasks
    can be added as task dependencies to this task; thus, with a single `publish`
    task, all the publications in the project can be published.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`maven-publish`插件基于一个通用的`publishing`插件。`publishing`插件为我们项目添加了一个新的`publishing`扩展。我们可以在构建脚本中使用`publications`配置块来配置我们想要发布的工件和想要部署到的仓库。`publications`扩展在`org.gradle.api.publish`包中有`PublishingExtension`类型。该插件还向项目中添加了通用的生命周期`publish`任务。其他任务可以作为任务依赖添加到这个任务中；因此，通过单个`publish`任务，可以发布项目中的所有发布。'
- en: The `maven-publish` plugins also add extra task rules to the project. There
    is a task to generate a Maven POM file for each publication in the project. The
    plugins also add a new task rule to publish each publication to the local Maven
    repository. Finally, a task rule is added based on a combination of the publication
    and the repository, to publish a publication to the specified repository.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`maven-publish`插件还向项目中添加了额外的任务规则。有一个任务用于为项目中的每个发布生成Maven POM文件。插件还添加了一个新的任务规则，用于将每个发布发布到本地Maven仓库。最后，基于发布和仓库的组合添加了一个任务规则，用于将发布发布到指定的仓库。'
- en: 'Let''s create an example build file and apply the `maven-publish` plugin to
    see the new task:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例构建文件，并应用`maven-publish`插件来查看新任务：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will invoke the `tasks` task from the command line:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从命令行调用`tasks`任务：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see the `publish` and `publishToMavenLocal` tasks in the output. The
    dynamic task rules for publishing single publications to repositories are not
    shown.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输出中看到`publish`和`publishToMavenLocal`任务。用于将单个发布发布到仓库的动态任务规则没有显示。
- en: To configure our publications, we must first add a `publishing` configuration
    block. Inside the block, we define the `publications` configuration block. In
    this block, we define a publication. A publication defines what needs to be published.
    The `maven-publish` plugin expects a publication to have the `MavenPublication`
    type found in the `org.gradle.api.publish.maven` package. Besides the artifacts
    that need to be published, we can also define details for the generated POM file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的发布，我们必须首先添加一个`publishing`配置块。在块内部，我们定义`publications`配置块。在这个块中，我们定义一个发布。发布定义了需要发布的内容。`maven-publish`插件期望发布具有在`org.gradle.api.publish.maven`包中找到的`MavenPublication`类型。除了需要发布的工件之外，我们还可以定义生成POM文件的详细信息。
- en: Defining publication artifacts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义发布工件
- en: Any publication we define must have a unique name in our project. We can add
    multiple publications with their own names inside a `publications` configuration
    block. To add an artifact, we can use the `artifact` method in the publication
    definition. We can also use the `artifacts` property to directly set all artifacts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的任何出版物都必须在我们的项目中具有唯一的名称。我们可以在`publications`配置块内添加多个具有自己名称的出版物。要添加工件，我们可以在出版物定义中使用`artifact`方法。我们还可以使用`artifacts`属性直接设置所有工件。
- en: 'We can define artifacts with the `artifact` method in the following ways:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式使用`artifact`方法定义工件：
- en: '| Type | Description |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AbstractArchiveTask` | The information for the artifact is extracted from
    the archive task. The artifact is an instance of `PublishArtifact` in the `org.gradle.api.artifacts`
    package. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `AbstractArchiveTask` | 从归档任务中提取了工件的信息。工件是`org.gradle.api.artifacts`包中`PublishArtifact`的一个实例。|'
- en: '| `File` | The information for the artifact is extracted from the filename.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `File` | 工件的信息是从文件名中提取的。|'
- en: '| `Map` | This is another way to define artifacts. The map must contain a `source`
    key referencing a file or archive task. The other properties we can use to further
    configure the artifact are `classifier` and `extension`. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | 这是定义工件的另一种方式。该映射必须包含一个`source`键，它引用一个文件或归档任务。我们可以使用其他属性来进一步配置工件，例如`classifier`和`extension`。|'
- en: Using archive task artifacts
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用归档任务工件
- en: 'In the following example build file, we define a new publication with the name
    `publishJar`, and we define the output of the `jar` archive task as an artifact:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例构建文件中，我们定义了一个名为`publishJar`的新出版物，并将`jar`归档任务的输出定义为工件：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will run the `tasks` task and, in the output, we will be able to see
    newly generated tasks for publishing this publication:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行`tasks`任务，在输出中，我们将能够看到为发布此出版物而新生成的任务：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the two extra tasks, `generatePomFileForPublishJarPublication` and `publishPublishJarPublicationToMavenLocal`.
    The name of the publication, `publishJar`, is used for the two tasks. Gradle uses
    the `generatePomFileFor<publicationName>Publication` pattern for a task to generate
    a POM for a publication. The task pattern to publish a publication to the local
    Maven repository is `publish<publicationName>PublicationToMavenLocal`. Later in
    this chapter, we will see how we can add other repositories. We cannot yet invoke
    the tasks because we also need to set the `group` and `version` project properties,
    but we will cover this in the section about generating a POM file. We can now
    focus on defining the artifacts for a publication in this section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到两个额外的任务，`generatePomFileForPublishJarPublication`和`publishPublishJarPublicationToMavenLocal`。出版物的名称`publishJar`用于这两个任务。Gradle使用`generatePomFileFor<publicationName>Publication`模式为出版物生成POM。将出版物发布到本地Maven仓库的任务模式是`publish<publicationName>PublicationToMavenLocal`。在本章的后面部分，我们将看到如何添加其他仓库。我们目前还不能调用这些任务，因为我们还需要设置`group`和`version`项目属性，但我们将在这部分关于生成POM文件的章节中介绍。现在我们可以专注于在本节中定义出版物的工件。
- en: We are not restricted to one artifact for a publication; we can add more by
    invoking the `artifact` method multiple times. Or, we can use the `artifacts`
    property to assign multiple artifacts. It is important that each artifact should
    have unique `classifier` and `extension` property values for a single publication.
    Gradle will check this before we can invoke any tasks, so we immediately get an
    error message when the artifacts don't have a unique combination of `classifier`
    and `extensions` property values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个出版物，我们不仅限于一个工件；我们可以通过多次调用`artifact`方法来添加更多工件。或者，我们可以使用`artifacts`属性分配多个工件。对于单个出版物，每个工件都应该具有唯一的`classifier`和`extension`属性值。在我们可以调用任何任务之前，Gradle将检查这一点，因此当工件没有唯一的`classifier`和`extensions`属性值的组合时，我们会立即收到错误消息。
- en: 'In the following example build file, we add two extra artifacts to our publication
    with the `artifact` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例构建文件中，我们使用`artifact`方法向我们的出版物添加了两个额外的工件：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of using the `artifact` method, we can also use the `artifacts` property
    and assign multiple artifacts. Each of the artifacts we assign must have a unique
    combination of `classifier` and `extension` property values. In the next example
    build file, we will use the same artifacts as in the previous example but, this
    time, we will assign them to the `artifacts` property:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`artifact`方法外，我们还可以使用`artifacts`属性并分配多个工件。我们分配的每个工件都必须具有唯一的`classifier`和`extension`属性值的组合。在下一个示例构建文件中，我们将使用与上一个示例相同的工件，但这次我们将它们分配给`artifacts`属性：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using file artifacts
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件工件
- en: Instead of an archive task, we can also use a file as an artifact. Gradle tries
    to extract the `extension` and `classifier` properties from the filename. We can
    also configure these properties ourselves when we add the file as a publication
    artifact.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存档任务外，我们还可以使用文件作为工件。Gradle尝试从文件名中提取`extension`和`classifier`属性。我们也可以在我们将文件添加为发布工件时自行配置这些属性。
- en: 'In the following example build file, we use the `src/files/README` and `src/files/COPYRIGHT`
    files as publication artifacts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的构建文件示例中，我们使用`src/files/README`和`src/files/COPYRIGHT`文件作为发布工件：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using software components
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用软件组件
- en: Besides the `artifact` method and the `artifacts` property, we can also use
    the `from` method inside a `publications` configuration block. We specify `SoftwareComponent`
    for Gradle as an argument to the `from` method. The `java` plugin adds `SoftwareComponent`
    with the name `java`, and it includes the `jar` artifact and all runtime dependencies.
    The `war` plugin adds the `war` artifact as `SoftwareComponent`. `SoftwareComponent`
    is a part of the Gradle build model that defines a piece of code that depends
    on other code or is a dependency for other code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`artifact`方法和`artifacts`属性外，我们还可以在`publications`配置块内部使用`from`方法。我们将`SoftwareComponent`指定为Gradle的`from`方法的参数。`java`插件添加了名为`java`的`SoftwareComponent`，它包括`jar`工件和所有运行时依赖项。`war`插件添加了作为`SoftwareComponent`的`war`工件。`SoftwareComponent`是Gradle构建模型的一部分，它定义了一个依赖于其他代码或作为其他代码依赖项的代码片段。
- en: 'In the next example build file, we will apply the `war` plugin to our project,
    which will implicitly add the `java` plugin. We also define two publications,
    each using `SoftwareComponent` from both plugins. The following code shows this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将应用`war`插件到我们的项目中，这将隐式添加`java`插件。我们还定义了两个发布，每个都使用来自两个插件的`SoftwareComponent`。以下代码展示了这一点：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Generating POM files
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成POM文件
- en: An important part of a Maven publication is the POM file. We already saw that
    Gradle added a `generatePom<publicationName>` task to our project. Furthermore,
    we can define some properties of the POM file inside a publication configuration.
    Gradle also offers a hook to customize the generated POM file even further.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Maven发布的一个重要部分是POM文件。我们已经看到Gradle为我们项目添加了`generatePom<publicationName>`任务。此外，我们可以在发布配置内部定义POM文件的一些属性。Gradle还提供了一个钩子来进一步自定义生成的POM文件。
- en: 'Gradle uses the project''s `version`, `group`, and `name` properties in the
    generated POM file. We create a new example build file where we define the project
    properties so that they are included in the POM file. The following code shows
    this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle在生成的POM文件中使用项目的`version`、`group`和`name`属性。我们创建一个新的示例构建文件，在其中定义项目属性，以便它们包含在POM文件中。以下代码展示了这一点：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we execute the `generatePomFileForSamplePublication` task. The `pom-default.xml`
    file is created in the `build/publications/sample` directory. If we open the file,
    we can see that the `groupId`, `artifactId`, and `version` elements are filled
    with the values from our Gradle build file. This is shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们执行`generatePomFileForSamplePublication`任务。`pom-default.xml`文件在`build/publications/sample`目录下创建。如果我们打开该文件，我们可以看到`groupId`、`artifactId`和`version`元素填充了从我们的Gradle构建文件中获取的值。以下代码展示了这一点：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can override the values for `groupId`, `artifactId`, and `version` inside
    a publication configuration. We use the `groupId`, `artifactId`, and `version`
    properties to set values other than the default values taken from the project
    properties. In the next example build file, we will use these methods to set the
    values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在发布配置内部覆盖`groupId`、`artifactId`和`version`的值。我们使用`groupId`、`artifactId`和`version`属性设置不同于从项目属性中获取的默认值。在下一个示例构建文件中，我们将使用这些方法来设置值：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Upon executing the `generatePomFileForSamplePublication` task again, we can
    see the new values in the generated POM file. The following code shows this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行`generatePomFileForSamplePublication`任务后，我们可以在生成的POM文件中看到新值。以下代码展示了这一点：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may already have noticed that the `generatePomFile<publicationName>Publication`
    task also added a `dependencies` element in the generated POM file. The dependencies
    of our project are added as runtime dependencies in the POM file. This happens
    because we use the `from` method with the `components.java` value inside our publication
    configuration. The Java software component not only adds the `jar` archive tasks
    as an artifact, but also turns the project dependencies in to Maven runtime dependencies.
    If we use an archive task to define an artifact, the `dependencies` element is
    not added to the POM file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`generatePomFile<publicationName>Publication` 任务还向生成的 POM 文件中添加了一个
    `dependencies` 元素。我们的项目依赖项被添加到 POM 文件中作为运行时依赖项。这是因为我们在发布配置中使用 `from` 方法并指定 `components.java`
    值。Java 软件组件不仅将 `jar` 存档任务作为一个工件，还将项目依赖项转换为 Maven 运行时依赖项。如果我们使用存档任务来定义工件，则不会将 `dependencies`
    元素添加到 POM 文件中。
- en: 'In the following example build file, we use the `artifact` method to define
    the publication:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例构建文件中，我们使用 `artifact` 方法来定义发布：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run the `generatePomFileForSamplePublication` task from the command
    line, the POM file is generated. The contents of the POM file are now as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行运行 `generatePomFileForSamplePublication` 任务时，会生成 POM 文件。现在 POM 文件的内容如下：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, we will learn how we can customize the POM file using a
    hook. We can then, for example, also change the Maven dependency scope for our
    project dependencies.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用钩子自定义 POM 文件。然后，例如，我们还可以更改项目依赖项的 Maven 依赖项作用域。
- en: Customizing the POM file
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 POM 文件
- en: To add some extra elements to the generated POM file, we must use the `pom`
    property that is a part of `MavenPublication`. This returns a `MavenPom` object,
    and we can invoke the `withXml` method from this object to add extra elements
    to the POM file. We will use a closure with the `withXml` method to access an
    `XmlProvider` object. With the `XmlProvider` object, we can get a reference to
    a DOM element with the `asElement` method, a Groovy node object with the `asNode`
    method, or the `StringBuilder` object with the `asString` method to extend the
    POM XML.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要向生成的 POM 文件添加一些额外元素，我们必须使用 `pom` 属性，它是 `MavenPublication` 的一部分。这返回一个 `MavenPom`
    对象，我们可以从这个对象调用 `withXml` 方法来向 POM 文件添加额外元素。我们将使用 `withXml` 方法的闭包来访问 `XmlProvider`
    对象。使用 `XmlProvider` 对象，我们可以通过 `asElement` 方法获取 DOM 元素的引用，通过 `asNode` 方法获取 Groovy
    节点对象，或者通过 `asString` 方法获取 `StringBuilder` 对象来扩展 POM XML。
- en: 'In the following example build file, we add the `organization` and `issueMangement`
    elements to the generated POM file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例构建文件中，我们将 `organization` 和 `issueManagement` 元素添加到生成的 POM 文件中：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we generate the POM file, we can see our newly created elements in the XML
    version. This is shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们生成 POM 文件，我们可以在 XML 版本中看到我们新创建的元素。这在上面的代码中显示如下：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous section, we already learned that, if we use the `from` method
    with the `components.java` value, all project dependencies are added as runtime
    dependencies in the generated POM file. This might always not be what we want.
    Using the `withXml` method, not only can we add new elements, we can also change
    values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经了解到，如果我们使用 `from` 方法并指定 `components.java` 值，所有项目依赖项都会被添加到生成的 POM 文件中作为运行时依赖项。这不一定总是我们想要的。使用
    `withXml` 方法，我们不仅可以添加新元素，还可以更改值。
- en: 'Let''s add a hook where we change the runtime scope for dependencies to compile
    the scope. In the next build file, we will implement this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在其中添加一个钩子，将依赖项的运行时作用域更改为编译作用域。在下一个构建文件中，我们将实现这一点：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The generated POM file now has the following contents:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 POM 文件现在具有以下内容：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Another solution would be to configure the publication, not with the `from`
    method but with the `artifact` method. Then, `dependencies` is not added to the
    POM file because Gradle cannot determine the dependencies for an artifact. Using
    the `withXml` method, we can add it ourselves based on the project dependencies.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用 `artifact` 方法而不是 `from` 方法来配置发布。这样，`dependencies` 不会添加到 POM 文件中，因为
    Gradle 无法确定工件的依赖项。使用 `withXml` 方法，我们可以根据项目依赖项自行添加它。
- en: 'In the following example build file, this solution is implemented:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例构建文件中，此解决方案得到实现：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we invoke the `generatePomFileForSamplePublication` task, we get the following
    POM file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `generatePomFileForSamplePublication` 任务时，我们得到以下 POM 文件：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Defining repositories
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义仓库
- en: We must configure a Maven repository to publish our configured publication.
    We can choose a local directory or a repository manager, such as Artifactory or
    Nexus. Gradle also adds support installing the publication to our local Maven
    repository.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须配置一个Maven仓库来发布我们的配置发布。我们可以选择本地目录或仓库管理器，如Artifactory或Nexus。Gradle还添加了对将发布安装到我们的本地Maven仓库的支持。
- en: Publishing to the local Maven repository
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到本地Maven仓库
- en: Gradle already adds our local Maven repository as a destination for our publications.
    For each named publication, there is a `publish<publicationName>ToMavenLocal`
    task. Gradle also creates the `publishToMavenLocal` task, which will publish all
    publications to the local Maven repository.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle已经将我们的本地Maven仓库作为发布的目的地。对于每个命名的发布，都有一个`publish<publicationName>ToMavenLocal`任务。Gradle还创建了`publishToMavenLocal`任务，该任务将所有发布发布到本地Maven仓库。
- en: 'We have the following example build file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下示例构建文件：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From the command line, we will run the `publishToMavenLocal` task and see which
    tasks are executed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，我们将运行`publishToMavenLocal`任务，并查看哪些任务被执行：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may have noticed that first the publication artifact is created with the
    `jar` task and its task dependencies. Also, the POM file is generated, and our
    publication is copied to the local Maven repository via the `publishPublishJarPublicationToMavenLocal`
    task, which is a task dependency for `publishToMavenLocal`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，首先使用`jar`任务及其任务依赖项创建了发布工件。然后生成POM文件，我们的发布通过`publishPublishJarPublicationToMavenLocal`任务复制到本地Maven仓库，该任务是`publishToMavenLocal`的任务依赖项。
- en: 'When we look at the local Maven repository directory, we see that our project
    artifact is published:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看本地Maven仓库目录时，我们看到我们的项目工件已发布：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Publishing to the Maven repository
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到Maven仓库
- en: If we have our own company's Maven repository or a directory where we want to
    publish our publications, then we must add it to the `publishing` configuration
    block. Inside the block, we can add the `repositories` configuration block containing
    one or more named repositories. For the combination of each publication and repository,
    Gradle creates a task with the `publish<publicationName>To<repositoryName>Repository`
    name pattern.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有我们自己的公司Maven仓库或我们想要发布发布的目录，那么我们必须将其添加到`publishing`配置块中。在块内部，我们可以添加包含一个或多个命名仓库的`repositories`配置块。对于每个发布和仓库的组合，Gradle创建一个具有`publish<publicationName>To<repositoryName>Repository`名称模式的任务。
- en: 'Next, we will define a simple directory repository in the next example build
    file with the name `localRepo`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将定义一个名为`localRepo`的简单目录仓库：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'First, we will run the `tasks` task to see which task is added to the `Publishing
    tasks` group:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将运行`tasks`任务，以查看哪个任务被添加到`Publishing tasks`组：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To publish our project''s artifact, we can execute the `publishPublishJarPublicationToLocalRepoRepository`
    or `publish` task. The following output shows the tasks that are executed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布我们的项目工件，我们可以执行`publishPublishJarPublicationToLocalRepoRepository`或`publish`任务。以下输出显示了执行的任务：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the task is performed, we get the following files in the `build/localRepo`
    directory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行任务，我们将在`build/localRepo`目录中获得以下文件：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Publishing to Artifactory
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到Artifactory
- en: To publish our publications to an Artifactory repository with a Maven layout,
    we only have to configure the repository in the `publications.repositories` configuration
    block. We can set the `url` property, a `name`, and optional security credentials.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的发布发布到具有Maven布局的Artifactory仓库，我们只需在`publications.repositories`配置块中配置仓库。我们可以设置`url`属性、一个`name`和可选的安全凭据。
- en: 'In the next example build file, we use an Artifactory repository to which we
    publish the publication:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们使用一个Artifactory仓库来发布发布：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Gradle creates a new `publishPublishJarPublicationToArtifactoryRepository`
    task based on the publication name and the repository name. When we invoke the
    task, we can see that the publication is deployed to the Artifactory repository.
    The following code shows this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle根据发布名称和仓库名称创建一个新的`publishPublishJarPublicationToArtifactoryRepository`任务。当我们调用任务时，我们可以看到发布已部署到Artifactory仓库。以下代码显示了这一点：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we open the Artifactory web application in a web browser, we can see that
    our project is now part of the repository, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在网页浏览器中打开Artifactory网络应用程序时，我们可以看到我们的项目现在是仓库的一部分，如下面的截图所示：
- en: '![Publishing to Artifactory](img/image00131.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![发布到Artifactory](img/image00131.jpeg)'
- en: Publishing to Nexus
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到Nexus
- en: Another repository manager is Nexus. Publishing to a Nexus repository manager
    is not much different than publishing to Artifactory or a local directory. We
    only have to change the `url` property to reference the repository and set the
    optional security credentials.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个仓库管理器是 Nexus。将发布物发布到 Nexus 仓库管理器与发布到 Artifactory 或本地目录并没有太大的区别。我们只需要更改 `url`
    属性以引用仓库，并设置可选的安全凭据。
- en: 'In the following example build file, we use a Nexus repository manager:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们使用 Nexus 仓库管理器：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time, the `publishPublishJarPublicationToNexusRepository` task is created.
    The task is also added as a task dependency to the `publish` task. To accomplish
    this, use the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，创建了 `publishPublishJarPublicationToNexusRepository` 任务。该任务也被添加为 `publish`
    任务的依赖任务。为了完成这个任务，请使用以下代码：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we take a look with the Nexus web application inside the repository, we
    can see that our project is added to the repository, as shown in the following
    screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在仓库内部查看 Nexus 网络应用程序时，我们可以看到我们的项目被添加到了仓库中，如下面的截图所示：
- en: '![Publishing to Nexus](img/image00132.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![发布到 Nexus](img/image00132.jpeg)'
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use the new and developing `maven-publish`
    plugin. You saw how you can declare your publications with the `publications`
    configuration block. Gradle will automatically create new tasks based on what
    you declared as publications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用新的和正在发展的 `maven-publish` 插件。你看到了如何使用 `publications` 配置块声明你的发布物。Gradle
    将会根据你声明的发布物自动创建新的任务。
- en: You also learned how to customize the POM file that is generated by the Gradle
    publishing tasks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何自定义 Gradle 发布任务生成的 POM 文件。
- en: Finally, you saw how you can configure Maven repositories so you can deploy
    your publications to them. We configured a local directory, which could also be
    a network share, and showed you how to configure an Artifactory or Nexus repository
    manager.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你看到了如何配置 Maven 仓库，以便你可以将你的发布物部署到它们。我们配置了一个本地目录，这也可以是一个网络共享，并展示了如何配置 Artifactory
    或 Nexus 仓库管理器。
- en: In the next chapter, you will see how you can upload to Bintray.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将看到如何上传到 Bintray。
