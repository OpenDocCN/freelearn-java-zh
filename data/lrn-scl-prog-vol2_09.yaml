- en: Advanced Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级函数式编程
- en: '"Like punning, programming is a play on words."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “就像双关语一样，编程是一种文字游戏。”
- en: – Alan Peris
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 艾伦·佩里斯
- en: 'You''re a developer, right? Think of a scenario where you''re asked to write
    some software that has certain entities. Take a look at the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你是开发者，对吧？想象一下，有人要求你编写一些具有某些实体的软件。看看以下内容：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have the `Animal` and `Food` entities. We''re working on an automated system
    that serves food to animals in a zoo. Suppose we''re going to write a function
    which lets two animals share their food. It expects two animal objects, food,
    and then does the job. The function looks like this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`Animal`和`Food`实体。我们正在开发一个自动化的系统，为动物园中的动物提供食物。假设我们要编写一个函数，允许两个动物共享它们的食物。它期望两个动物对象、食物，然后完成工作。这个函数看起来是这样的：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far, everything's fine, right? Let's introduce two animals now. We have two
    animal subclasses named `Lion` and `Deer`. Our simple function takes two `animal`
    instances and shares the `meal` instance among them. Now, you might wonder what
    happens when we pass instances of `Lion` and `Deer`; what might be the consequences?
    Hence, we promote strictly typed programs, which can fail at compile time. This
    means we can write our programs in such a way that the Scala compiler won't allow
    us to write such programs. You're able to see how types can save lives. Great,
    so this is the agenda here.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利，对吧？现在让我们引入两种动物。我们有两种动物子类名为`Lion`和`Deer`。我们的简单函数接受两个`animal`实例并在它们之间共享`meal`实例。现在，你可能会想知道当我们传递`Lion`和`Deer`的实例时会发生什么；可能会有什么后果？因此，我们提倡严格类型化的程序，这些程序可能在编译时失败。这意味着我们可以以这种方式编写我们的程序，以至于Scala编译器不会允许我们编写这样的程序。你能够看到类型如何救命。太好了，所以这就是这里的议程。
- en: 'We''ll be talking about types and parameterizing our types. We introduced type
    parameterization in the previous chapter, so we''ll take our journey further and
    learn more about type parameterization, abstract types, and a lot more. Let''s
    take a look at what''s coming:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论类型以及参数化我们的类型。我们在上一章中介绍了类型参数化，所以我们将继续我们的旅程，并学习更多关于类型参数化、抽象类型以及更多内容。让我们看看接下来会发生什么：
- en: Genericity/type parameterization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型/类型参数化
- en: Parameterized types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化类型
- en: Variance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性
- en: Abstract types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类型
- en: Bounds
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界限
- en: Abstract versus parameterized types
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类型与参数化类型
- en: Type classes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类
- en: Let me tell you, this chapter's going to be another interesting one. We'll be
    using constructs that we've already used to make our code more meaningful. But
    before we dive in to learn about parameterized types in detail, let's talk about
    why there's so much hype about types.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我告诉你，这一章将会是另一个有趣的章节。我们将使用我们已经使用过的结构来使我们的代码更有意义。但在我们深入学习参数化类型之前，让我们谈谈为什么类型如此备受关注。
- en: Why so serious about types?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么对类型如此认真？
- en: 'We''ve seen that knowing what we''re doing can save life. But joking aside,
    if we really think before writing our applications, it can really help. Our programs
    consist of two ingredients:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，了解我们在做什么可以救命。但开个玩笑，如果我们真的在编写应用程序之前思考，这真的有帮助。我们的程序由两个成分组成：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can perform operations on the data available. At the same time, not all operations
    can be performed on all sorts of data. That's what difference types make. You
    don't want to perform an addition operation between an Integer and a String literal.
    That's why the compiler does not allow us to do that. Even if it assumes you're
    trying to concatenate the string with the literal, it's not going to give you
    a result that's not meaningful. That's why defining types make sense.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对可用的数据进行操作。同时，并不是所有操作都可以在所有类型的数据上执行。这就是类型差异所在。你不会想在整数和字符串字面量之间执行加法操作。这就是为什么编译器不允许我们这样做。即使它假设你试图将字符串与字面量连接起来，它也不会给出一个有意义的成果。这就是为什么定义类型是有意义的。
- en: 'Let''s discuss a few terms that we just mentioned. It''s really good that Scala
    is a statically typed language because it provides us compile time type safety.
    The code that we write is less prone to runtime errors, because we were so smart
    and we wrote it that way (we''ll learn about this in this chapter). Our beloved
    Scala compiler performs a compile time type check on the program we wrote and
    throws an error at compile time if we try to be too smart. The following diagram
    may clear your doubts:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们刚才提到的几个术语。Scala是一个静态类型语言真是太好了，因为它为我们提供了编译时类型安全。我们编写的代码不太可能发生运行时错误，因为我们非常聪明，我们就是这样编写的（我们将在本章中学习这一点）。我们心爱的Scala编译器会对我们编写的程序进行编译时类型检查，并在编译时抛出错误，如果我们试图过于聪明。以下图表可能会消除你的疑虑：
- en: '![](img/00035.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: 'You see? The preceding picture depicts that if your program is working, that''s
    not enough, eventually you may find some corner cases that will cause them to
    fail. So, we better choose a language that helps you cover that section more,
    so that your program lives in a happy world:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你看？前面的图片描绘了，如果你的程序正在运行，那还不够，最终你可能会发现一些边缘情况会导致它们失败。所以，我们最好选择一种可以帮助你更好地覆盖这一部分的编程语言，这样你的程序就能在一个快乐的世界中生存：
- en: '![](img/00036.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00036.jpeg)'
- en: This is essential for us to understand why we're supporting a system where using
    *types* is encouraged.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们理解为什么我们支持一个鼓励使用*类型*的系统至关重要。
- en: 'We began to understand the importance of types in programming, and as we approached
    writing optimized and well structured code, we found something called type genericity.
    We began to write types which can be specified later on. And this gave rise to
    the notion of type constructors. Now, we can write types that take parameters.
    For example, think of a type `constructorList[T]`*.* Here, our known `List[T]`
    expects you to provide a type. You can also think of it as a function on a type,
    you provide a parameter while constructing. In our example, if we choose to provide
    a string, our list will then be called a `List[String]`*,* that''s an applied
    version of `List[T]` with the `String` type. This concept is called **parametric
    polymorphism** where we say that our `List[T]` uses a type parameter `T` to abstract
    over the type of its elements. Let''s try out the stuff we talked about in Scala
    REPL:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始理解类型在编程中的重要性，当我们接近编写优化和结构良好的代码时，我们发现了一种叫做类型泛型性的东西。我们开始编写可以在以后指定的类型。这导致了类型构造函数的概念的出现。现在，我们可以编写接受参数的类型。例如，考虑一个类型`constructorList[T]`*.*
    在这里，我们已知的`List[T]`期望你提供一个类型。你也可以把它看作是一个类型上的函数，你在构造时提供参数。在我们的例子中，如果我们选择提供一个字符串，那么我们的列表将被称为`List[String]`*，*这是`List[T]`的`String`类型的应用版本。这个概念被称为**参数多态**，我们说我们的`List[T]`使用类型参数`T`来抽象其元素的类型。让我们在Scala
    REPL中尝试一下我们讨论的内容：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous snippet also failed with an error because we knew that we should
    provide a type parameter but we supplied some element that itself isn''t a type.
    So what should we do now? Let''s try the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段也因为错误而失败了，因为我们知道我们应该提供一个类型参数，但我们提供了一些本身就不是类型的元素。那么我们现在应该怎么做？让我们尝试以下方法：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This time it worked for us: we provided a type `String` to our type constructor
    and it worked for us. So I believe we can differentiate between a type constructor
    and a type. Now that you''ve insights into why we''re doing this, let''s dive
    in and learn about parameterized types.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这次对我们来说成功了：我们向我们的类型构造函数提供了一个类型`String`，并且它对我们来说工作得很好。所以我相信我们可以区分类型构造函数和类型。既然你已经了解了我们为什么要这样做，那么让我们深入探讨一下参数化类型。
- en: Here comes type parameterization
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是类型参数化
- en: Think of the same scenario. You were asked to write a program that contains
    some different entities, for example, humans and animals. Now, both require food
    to stay alive. Our colleagues are aware of this and have written code that takes
    care of the way food is served to humans as well as animals.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下相同的场景。你被要求编写一个包含一些不同实体的程序，例如，人类和动物。现在，两者都需要食物来维持生命。我们的同事已经意识到了这一点，并编写了处理人类和动物食物供应方式的代码。
- en: 'They have written the code and provided it as a library (we can access those
    functions by importing the packages they wrote). Our colleagues were ahead of
    time and wrote a function that looked like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 他们已经编写了代码，并将其作为库提供（我们可以通过导入他们编写的包来访问这些函数）。我们的同事提前编写了一个看起来像以下这样的函数：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We were told the function will work, we just have to provide who to serve the
    food to as the first parameter and an optional food item as a meal. The rest will
    be taken care of by the logic they''ve put. We tried a couple of ways and wrote
    a few applications of this as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被告知这个函数会工作，我们只需要提供第一个参数是谁来提供食物，以及一个可选的餐点作为食物。其余的将由他们放置的逻辑来处理。我们尝试了几种方法，并按照以下方式编写了一些应用：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And somehow, it works as expected. But wait, this is really cool, we were exposed
    to only one function and everything seemed to work as expected. They didn't want
    us to specifically call `serveMealToHumans` or `serveNonVegMealToAnimals` functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，它以预期的方式工作。但是等等，这真的很酷，我们只接触到了一个函数，而且一切似乎都按预期工作。他们不希望我们特别调用`serveMealToHumans`或`serveNonVegMealToAnimals`函数。
- en: 'This really helped us write better code at our end. We were both intelligent
    teams and we separated our concerns. You know, their concern was to take care
    of the ways of serving food to all, our concern was to ensure each of our entities
    are getting food they''re supposed to get. The job''s done. Let''s talk about
    why we chose this example. To understand that, take a look at the function signature
    they wrote:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的帮助我们编写了更好的代码。我们都是聪明的团队，我们分离了我们的关注点。你知道，他们的关注点是照顾所有人提供食物的方式，我们的关注点是确保我们的每个实体都能得到它们应该得到的食物。工作完成了。让我们谈谈为什么我们选择了这个例子。为了理解这一点，看看他们写的函数签名：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We see the `def` keyword, then the name of the function, but after that they
    wrote letters `A` and `B`*,* what are these? To learn more, let''s go ahead and
    read out the whole signature. There''s a parameter that we were supposed to serve,
    the type was named *A,* and the food option was given a type named `B` *(*option
    `B`*).* Well, these are type parameters. The function itself is an example of
    *parametric polymorphism.* We know that it means *having multiple forms.* The
    same goes here. Our function can have multiple parameter types. To better understand,
    take a look at this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`def`关键字，然后是函数名，但之后他们写了字母`A`和`B`*，*这是什么？为了了解更多，让我们继续阅读整个签名。有一个参数是我们应该提供的，类型被命名为*A*，食物选项被赋予了一个名为`B`的类型`(*option
    `B`*)*。嗯，这些都是类型参数。这个函数本身是*参数多态*的一个例子。我们知道这意味着*有多种形式*。这里也是一样。我们的函数可以有多个参数类型。为了更好地理解，看看这个：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here in the function calls, we specified the types of our parameters. From the
    signature of our function it is clear that we can give whichever type we want
    and the `serveMeal` function takes care of the rest of the logic. So, the take
    away is that these `A` and `B` parameters are called type parameters. The whole
    concept can be termed type parameterization. We cannot just write generic methods,
    but also generic classes and traits*.* Let's check them out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，我们指定了参数的类型。从函数的签名中可以清楚地看出，我们可以给出我们想要的任何类型，而`serveMeal`函数会处理其余的逻辑。所以，我们可以得出结论，这些`A`和`B`参数被称为类型参数。整个概念可以称为类型参数化。我们不仅可以编写泛型方法，还可以编写泛型类和特性*.*
    让我们来了解一下。
- en: Another way around - generic classes and traits
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一种方法 - 泛型类和特性
- en: 'We just saw the effect of *genericity* and it solved more than one problem,
    we wrote less code and achieved more. The `serveMeal` function was a generic one
    because it takes type parameters, in our case `A` and `B`*.* It performs the intended
    logic, great! Let''s talk about *parameterized types.* You know the type `List`*,*
    right? Let''s take a look at its declaration in the Scala standard library:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了*泛型*的效果，它解决了不止一个问题，我们写了更少的代码，实现了更多。`serveMeal`函数是一个泛型函数，因为它接受类型参数，在我们的例子中是`A`和`B`*。*它执行了预期的逻辑，太棒了！让我们谈谈*参数化类型*。你知道`List`*这个类型吗？让我们看看它在Scala标准库中的声明：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Okay, the declaration seems far too complex, doesn't it? No, wait, we know what
    sealed means, we know why we used an abstract class, then the name `List`*,* and
    then a few more declarations for showing inheritance relationships. But there's
    this thing called `[+A]` in our declaration. Our job is to find out what this
    is and why we used it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，声明看起来过于复杂，不是吗？不，等等，我们知道`sealed`的意思，我们知道为什么我们使用抽象类，然后是`List`*，*这个名字，然后是一些显示继承关系的声明。但是在我们的声明中有一个叫做`[+A]`的东西。我们的任务是找出这是什么，以及为什么我们使用了它。
- en: From the previous few topics, we gained an idea of this notion of *type constructors.*
    So, let's call this `List[+A]` a type constructor. We know that if we provide
    it a concrete type, List will make a meaningful type. We've tried this before
    so we won't be creating another list of strings. We'll try to learn the significance
    of this + sign in the next few topics. It shows a *variance* relationship. Let's
    look at the previous declaration first.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的几个主题中，我们得到了对这个概念*类型构造函数*的想法。所以，让我们把`List[+A]`称为类型构造函数。我们知道如果我们提供一个具体的类型，List将创建一个有意义的类型。我们之前已经尝试过，所以不会创建另一个字符串列表。我们将在接下来的几个主题中学习这个加号的含义。它表示一个*变异性*关系。让我们先看看之前的声明。
- en: Type parameter names
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数名称
- en: 'Here, in the declaration of the `List[+T]` type constructor (we can use the
    names parameterized types or type constructors interchangeably), we used the parameter
    name, `T`, it''s a convention to use such names in generic programming. The names *`T`,*
    `A`*,* `B`*,* or `C` have nothing to do with the initializer type you''re going
    to provide when you initiate a list instance. For example, when you give a `String`
    typefor the previously mentioned type parameter when you instantiate `List[String]`,
    it really doesn''t matter if the declaration has `List[T]` or `List[A]`. What
    we mean is the following two declarations are equivalent:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 `List[+T]` 类型构造器的声明中（我们可以互换使用参数化类型或类型构造器的名称），我们使用了参数名称 `T`，在泛型编程中使用这样的名称是一种惯例。名称
    *`T`*、* `A`*、* `B`* 或 *`C`* 与你初始化列表实例时提供的初始化器类型无关。例如，当你为之前提到的类型参数提供 `String` 类型以实例化
    `List[String]` 时，声明是 `List[T]` 还是 `List[A]` 实际上并不重要。我们的意思是以下两个声明是等价的：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Container types
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器类型
- en: 'We''ve seen Scala''s class hierarchy, hence we are aware of many collection
    types such as `List`, `Set`, and `Map`. What''s different about these types along
    with types such as `Option` and `Either`*,* is that they all expect you to provide
    a type and then instantiate. We call `List` as a container type because it works
    that way. We use a list to contain elements of a certain data type. Similarly,
    we can think of an `Option` as a binary containerized type, as `Option` can be
    some value or `None`*.* The `Either` type goes the same way. In Scala, when we
    create such container types*,* we tend to use a type parameter to declare and
    provide a concrete type, such as `String`*,* `Int`*,* Boolean*,* and so on when
    we instantiate. Take a look how `Option` is declared in Scala (more on `Option`
    and `Either` types in the next chapter):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Scala 的类层次结构，因此我们了解了许多集合类型，例如 `List`、`Set` 和 `Map`。这些类型以及如 `Option`
    和 `Either`** 的类型的不同之处在于，它们都要求你提供一个类型然后实例化。我们将 `List` 称为容器类型，因为它就是这样工作的。我们使用列表来包含特定数据类型的元素。同样，我们可以将
    `Option` 视为一个二进制容器化类型，因为 `Option` 可以是某个值或 `None`*.* `Either` 类型也是同样的道理。在 Scala
    中，当我们创建这样的容器类型** 时，我们倾向于使用类型参数来声明并提供一个具体类型，例如在实例化时提供 `String`*、* `Int`*、* `Boolean`*
    等等。看看 `Option` 在 Scala 中的声明（关于 `Option` 和 `Either` 类型的更多内容将在下一章中介绍）：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It takes a type parameter `A`*.* It''s possible to provide more than one type
    parameter if your type expects more than one type to get instantiated. An example
    of such a type is `Either`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个类型参数 `A`*.* 如果你的类型期望提供多个类型以进行实例化，则可以提供多个类型参数。这样的类型的一个例子是 `Either`：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As shown previously, our type `Either` takes two types, `A` and `B`*.* But
    when I tried the following snippet it didn''t work as expected:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的 `Either` 类型接受两种类型，`A` 和 `B`*.* 但当我尝试以下代码片段时，它并没有按预期工作：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You see? We created two lists, first of strings and the other list of numbers.
    Then, a function named `listOf` that's a generic function simply to take a list
    and tell the type of list it is. We performed a pattern match to check the type
    of list passed to the function and print it. But it didn't work out for us (and
    might not for anyone). Also, it threw a few warnings telling us there was unreachable
    code for the second case expression. Let's talk about why!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你看？我们创建了两个列表，一个是字符串列表，另一个是数字列表。然后，一个名为 `listOf` 的泛型函数，它简单地接受一个列表并告诉列表的类型。我们执行了模式匹配来检查传递给函数的列表类型并打印它。但它并没有按预期工作（可能对任何人都不行）。此外，它还抛出了一些警告，告诉我们第二个情况表达式的代码不可达。让我们来谈谈原因！
- en: Type erasure
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型擦除
- en: 'When the Scala compiler compiles the previous code, it erases the parameterized
    type information from the previous code and so it doesn''t have the necessary
    knowledge at runtime; the list we passed does not take any further information
    about itself. In other words, all type information for generic types is discarded
    by the time the code compiled. This phenomenon is termed **type erasure***.* This
    is the reason our function `listOf` didn''t work as we expected or, let''s say,
    assumed. That''s the same reason you got a warning of unreachable code, because
    our statically typed language was able to know that the second case will never
    be executed, and the first case is a kind of catch all in this pattern match.
    Let''s explain this a bit better. Take a look at a few cases where type erasure
    will be applicable. Imagine you have a trait named `Tfoo`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Scala 编译器编译前面的代码时，它会从之前的代码中擦除参数化类型信息，因此在运行时没有必要的知识；我们传递的列表不会携带任何关于自身的进一步信息。换句话说，在代码编译完成时，所有泛型类型的类型信息都被丢弃。这种现象被称为
    **类型擦除**.* 这也是我们的 `listOf` 函数没有按预期或假设的方式工作或导致收到不可达代码警告的原因。这是因为我们的静态类型语言能够知道第二个情况永远不会被执行，第一个情况是这个模式匹配中的通配符。让我们更好地解释一下。看看一些类型擦除将适用的案例。想象你有一个名为
    `Tfoo` 的特质：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After the process of compilation, the generic type gets converted to object
    and becomes like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程之后，泛型类型被转换为对象，并变成如下所示：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Variance under inheritance
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承下的协变
- en: 'One of the ways we can learn about a concept is to ask questions that lead
    you to the concept. So let''s ask a question ourselves. Given that a `Cat` class
    type extends the `Animal`class, is it okay to treat a list of *cats* as a list
    of *animals*? Programmatically, see the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个概念的一种方式是提出引导你到该概念的问题。所以，让我们自己提出一个问题。鉴于 `Cat` 类类型扩展了 `Animal` 类，将一群猫视为一群动物是否合适？从程序的角度来看，请看以下内容：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If it''s possible, the statement that `List[Cat]` is a subtype of `List[Animal]`
    makes sense. Also, the concept is called **covariance**. Hence, we say `List`
    is covariant in its type parameter `T`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，`List[Cat]` 是 `List[Animal]` 的子类型这一说法是有意义的。这个概念被称为 **协变**。因此，我们说 `List`
    在其类型参数 `T` 上是协变的：
- en: '![](img/00037.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: If you take a look at the preceding image, the direction of the inheritance
    relationship between two concrete classes, namely `*Cat*` and `Animal`, and their
    parameterized versions, namely `List[Cat]` and `List[Animal]` types, are the same.
    But it's not the case every time. There might be cases where you have a container
    type for which the variance relationship works the opposite way.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看前面的图像，两个具体类（即 `*Cat*` 和 `Animal`）及其参数化版本（即 `List[Cat]` 和 `List[Animal]`
    类型）之间的继承关系方向是相同的。但并非总是如此。可能会有一些情况，其中容器类型的协变关系是相反的。
- en: 'Think about it this way: given two types `A` and `B`, where `A` is a super
    type of `B`, and some container type `Foo[T]`*,* so the relationship where `Foo[A]`
    is a subtype of `Foo[B]` is called contravariance in `T`, and represented by `Foo[-T]`*.* Here
    the `-` sign represents contravariance.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想：给定两个类型 `A` 和 `B`，其中 `A` 是 `B` 的超类型，以及某个容器类型 `Foo[T]`，那么 `Foo[A]` 是 `Foo[B]`
    的子类型的关系称为 `T` 上的逆协变，表示为 `Foo[-T]`。在这里，`-` 符号代表逆协变。
- en: 'If you''re thinking this is too theoretical, some code examples may make the
    concept clearer. Let''s take a look at a scenario. Nowadays, enterprises like
    to provide all sorts of arrangements for their employees from food and insurance
    to their travel needs. It''s not a big deal if some corporation decides to work
    with an airline company to provide corporate bookings for their employees. Airline
    companies, in order to support such bookings, can support schemes where they book
    seats for corporate passengers, executive passengers, and regular passengers.
    So, imagine in our program that books seats in an aircraft, we represent each
    seat as an aircraft seat. Programmatically, we can represent it as a class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这太理论化了，一些代码示例可能会使这个概念更清晰。让我们看看一个场景。如今，企业喜欢为员工提供各种各样的安排，从食物和保险到他们的旅行需求。如果某个公司决定与航空公司合作，为员工提供企业预订，这并不是什么大问题。为了支持这样的预订，航空公司可以支持为商务旅客、行政旅客和普通旅客预订座位的方案。所以，想象在我们的程序中预订飞机座位，我们代表每个座位为一个飞机座位。从程序的角度来看，我们可以将其表示为一个类：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we have a few passengers represented by the `Passenger` class. There are
    a few subtypes of Passenger such as `CorporatePassenger`, `ExecutivePassenger`*,*
    and `RegularPassenger`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有几个由 `Passenger` 类表示的乘客。有几个 `Passenger` 的子类型，如 `CorporatePassenger`、`ExecutivePassenger`*
    和 `RegularPassenger`。
- en: 'The relationship between them is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的关系如下：
- en: '![](img/00038.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: 'As shown, `CorporatePassengers` and `RegularPassengers` inherit from the `Passengers` class,
    so there''s an inheritance relationship between these types. This can be represented
    by the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，`CorporatePassengers` 和 `RegularPassengers` 继承自 `Passengers` 类，因此这些类型之间存在继承关系。这可以表示如下：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if you have a function that reserves seats for the corporate employees,
    its signature may look like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你有一个为公司员工预订座位的函数，其签名可能看起来像以下这样：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous function expects you to provide an `AircraftSeat[CorporatePassengers]`,
    and does its job. If we try writing the whole of this in a Scala application,
    it''ll look like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的函数期望你提供一个 `AircraftSeat[CorporatePassengers]`，并完成其任务。如果我们尝试在一个 Scala 应用程序中写出整个函数，它看起来会像以下这样：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, take a moment, and go through the preceding code. We''ll talk about a
    few points and try to play with annotations and inheritance:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，花一点时间，回顾一下前面的代码。我们将讨论几个要点，并尝试玩转注解和继承：
- en: '`AircraftSeat[-T]` is a container type in our case that uses contravariance
    annotation, that is, a `-` sign for its type parameter.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的情况下，`AircraftSeat[-T]` 是一个使用逆变注解的容器类型，即其类型参数前有一个 `-` 符号。
- en: 'The `reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers])`
    function takes `AircraftSeat` of type `CorporatePassengers` or its super type
    such as `Passengers`, because of the contravariance relationship in its type parameters.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers])`
    函数接受 `AircraftSeat` 类型的 `CorporatePassengers` 或其超类型，如 `Passengers`，这是因为其类型参数中的逆变关系。'
- en: The function call to `reserveSeatForCorporatePassengers(new AircraftSeat[CorporatePassengers])`
    and `reserveSeatForCorporatePassengers(new AircraftSeat[Passengers])` works because
    of contravariance in the parameterized type, `AircraftSeat`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于参数化类型 `AircraftSeat` 中的逆变，`reserveSeatForCorporatePassengers(new AircraftSeat[CorporatePassengers])`
    和 `reserveSeatForCorporatePassengers(new AircraftSeat[Passengers])` 的函数调用是有效的。
- en: In the previous code, try changing the type constructor `AircraftSeat[-T]` to
    `AircraftSeat[+T]`. You'll be greeted with a compilation error saying type mismatch
    because the parameterized type gets changed to covariant in `T`, and because of
    that the `Passengers` super type is no longer valid in place of `Aircraft[CorporatePassengers]`*.*
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的代码中，尝试将类型构造器 `AircraftSeat[-T]` 改为 `AircraftSeat[+T]`。你会遇到一个编译错误，说类型不匹配，因为参数化类型在
    `T` 中变成了协变，因此 `Passengers` 超类型不再适用于 `Aircraft[CorporatePassengers]`**。
- en: 'Similarly, if we try to make a function call to the `reserveSeatForCorporatePassengers`
    function with `RegularPassengers`, it won''t work and will throw a compilation
    error about type mismatch. The reason is the same: our parameterized type being
    contravariant in `T`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样地，如果我们尝试用 `RegularPassengers` 调用 `reserveSeatForCorporatePassengers` 函数，它将不会工作并抛出一个关于类型不匹配的编译错误。原因是相同的：我们的参数化类型在
    `T` 中是逆变。
- en: 'The previous example and experiments clear up what covariance and contravariance
    are and what the differences are between them. See the following image:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子和实验澄清了协变和逆变是什么，以及它们之间的区别。请看以下图像：
- en: '![](img/00039.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: The preceding image explains the inheritance relation between the concrete types
    `Passengers`*,* `CorporatePassengers`, and parameterized types `AircraftSeat[Passengers]`,
    and `AircraftSeat[CorporatePassengers]`*.* You may have noticed that the inheritance
    direction for contravariance is in the opposite direction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像解释了具体类型 `Passengers`*、`CorporatePassengers` 和参数化类型 `AircraftSeat[Passengers]`、`AircraftSeat[CorporatePassengers]`*
    之间的继承关系。你可能已经注意到，逆变的方向与继承方向相反。
- en: With this, we've understood two types of variance relationship within the parameterized
    types. First is covariance and then contravariance. Now, there's another type
    of variance relation that's possible and that's called invariant relationship
    in `T`. We don't use any signs to show that invariance relationship. We simply
    use the container type along with a type parameter name as in `Foo[T]`, the type
    is invariant in `T`. Hence, if you want to consume an instance of type `Foo[T]`,
    you must provide an instance of `Foo[T]`, any super type or sub type of T will
    not work for that.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们已经理解了参数化类型内部两种类型的方差关系。首先是协方差，然后是反协方差。现在，还有一种可能的方差关系，称为`T`中的不变关系。我们不需要任何符号来表示这种不变关系。我们只需使用容器类型和类型参数名称，例如`Foo[T]`，在`T`中的类型是不变的。因此，如果你想消费`Foo[T]`类型的实例，你必须提供一个`Foo[T]`实例，任何T的超类型或子类型都不会起作用。
- en: Variance is quite an important concept in functional programming. Hence, you
    may find many examples of it in Scala. We've already seen examples, such as `List[+T]`
    and `option[+T]`*,* which are covariant in T.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 方差是函数式编程中一个非常重要的概念。因此，你可能会在Scala中找到许多关于它的例子。我们已经看到了一些例子，例如`List[+T]`和`option[+T]`*，它们在T中是协变的。
- en: 'Another popular example for such variance relationships is the `Function` trait:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个这样的方差关系的流行例子是`Function`特质：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we declare something like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明如下：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, Scala converts it into an instance of these `Function` traits and this
    becomes the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Scala将其转换为这些`Function`特质的实例，这变成了以下：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, this trait as shown in the signature consumes the type `T` and produces
    `R`. We've put variance annotations in front of `T` and `R`, where `Function1`
    is contravariant in `[-T]`, the consumable type and covariant in `[+R]` the producible
    type. I hope this clears up the variance relationship. Let's look at when to use
    covariance and contravariance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这个特质，如签名所示，消费类型`T`并产生`R`。我们在`T`和`R`前面放置了方差注释，其中`Function1`在`[-T]`中是反协变的，可消费类型，在`[+R]`中是协变的，可生产类型。我希望这澄清了方差关系。让我们看看何时使用协方差和反协方差。
- en: When to use what type of variance relation
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用哪种类型的方差关系
- en: It's clear that variance is useful for telling the compiler when it's okay to
    bind an instance of one parameterized type to a reference of the same parameterized
    type with a different type parameter. The way we did for `List[Animal]` and `List[Cat]`*.*
    But the question arises, whether to use covariance or use contravariance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，方差对于告诉编译器何时可以将一个参数化类型的实例绑定到具有不同类型参数的相同参数化类型的引用非常有用。就像我们在`List[Animal]`和`List[Cat]`*中所做的那样。但是，问题出现了，是使用协方差还是反协方差。
- en: In the last example, we saw the `Function1` trait from Scala's standard library.
    The input/consumable type was contravariant and the output/producible type was
    covariant. It gives us a sense that when we are about to consume some type, it's
    okay to use contravariance. (Why? We'll get to that shortly.)  When we are about
    to produce some results we should go for covariance. The idea here is that as
    a `consumer` you can consume a variety of types or, in other words, you're allowed
    to consume more general (contravariant) stuff, and at the same time as a `producer`,
    you are allowed to produce more specific (covariant) stuff. You get the point,
    right?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，我们看到了Scala标准库中的`Function1`特质。输入/可消费类型是反协变的，输出/可生产类型是协变的。这让我们有一种感觉，当我们即将消费某种类型时，使用反协方差是可以的。（为什么？我们很快就会了解到。）当我们即将产生一些结果时，我们应该选择协方差。这里的想法是，作为一个`消费者`，你可以消费各种类型，换句话说，你被允许消费更一般的（反协变的）东西，同时作为一个`生产者`，你被允许生产更具体（协变的）东西。你明白这个意思，对吧？
- en: So you remember, we talked about our programs made of two entities: *data* and
    *operations.* We also said not all operations can be performed on all data. Hence,
    we had the concept of types. Now, our lives are much more exciting because of
    type parameterization, but we should take care when we declare our parameterized
    types because there may be some operations that are not defined for all types
    under T in Foo[T]. For this, we have a thing called *Type Bounds.* Using type
    bounds we can specify for which types we want to perform the operations. Well,
    we'll talk about *bounds* too, but before that I want to talk about another way
    of achieving abstraction in our programs and that's through *abstract types.*
    Let's go through and try to understand a concept people find difficult when they
    start using Scala (you won't, we'll make it clear!).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你记得，我们谈论了由两个实体组成的程序：*数据* 和 *操作*。我们也说过，并非所有操作都可以在所有数据上执行。因此，我们有了类型的概念。现在，由于类型参数化，我们的生活变得更加有趣，但我们在声明参数化类型时应该小心，因为对于
    Foo[T] 下的所有类型，可能有一些操作是没有定义的。为此，我们有一个叫做 *类型边界* 的东西。使用类型边界，我们可以指定我们想要对哪些类型执行操作。嗯，我们也会谈到
    *边界*，但在那之前，我想谈谈另一种在我们的程序中实现抽象的方法，那就是通过 *抽象类型*。让我们来探讨并尝试理解当人们开始使用 Scala 时觉得困难的一个概念（你不会，我们会让它变得清晰！）。
- en: Abstract types
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类型
- en: 'Okay, first things first. We tried to achieve *abstraction *when we introduced
    *type parameterizing.* We will do the same thing using *abstract type members.*
    But what''s an *abstract type member*? How do we write them, how can we use them,
    and why do we even need them when we already have *parameterized types?* These
    are a few questions. We''ll try answering them. So let''s start with the first
    question. How do we write an abstract type. This is done as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，首先，当我们引入 *类型参数化* 时，我们试图实现 *抽象*。我们将使用 *抽象类型成员* 来做同样的事情。但什么是 *抽象类型成员*？我们如何编写它们，我们如何使用它们，以及为什么我们甚至需要它们，因为我们已经有了
    *参数化类型*？这些问题有几个。我们将尝试回答它们。所以让我们从第一个问题开始。我们如何编写一个抽象类型。这是按照以下方式完成的：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Okay, we just wrote a trait named `ThinkingInTermsOfT` and it has an abstract
    type member. So, to declare an abstract type member we use the keyword `type`
    along with the parameter name that in our case is `T`. From our elementary Scala
    introduction or, let''s say, from previous chapters, we know how we can instantiate
    a trait*.* So when we instantiate our trait, we''ll give a type to our abstract
    member. That''s going to be a concrete type:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们刚刚写了一个名为 `ThinkingInTermsOfT` 的特质，并且它有一个抽象类型成员。因此，要声明一个抽象类型成员，我们使用关键字 `type`
    以及参数名称，在我们的例子中是 `T`。从我们的基础 Scala 介绍，或者说，从之前的章节中，我们知道如何实例化一个特质。所以当我们实例化我们的特质时，我们会给我们的抽象成员赋予一个类型。这将是一个具体类型：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we instantiated the trait with a `new` keyword and then, while defining
    the trait implementation, we gave the `Int` type to our abstract type member `T`.
    This allows us to use `T` type at the declaration side trait without caring about
    what the type''s going to be. And when we instantiate, we assign a concrete type,
    just like we did here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `new` 关键字实例化了特质，然后在定义特质实现时，我们将 `Int` 类型赋予我们的抽象类型成员 `T`。这允许我们在声明侧的特质中不关心类型的具体是什么就使用
    `T` 类型。当我们实例化时，我们分配一个具体类型，就像我们在这里做的那样：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You now have some idea of how to perform these kinds of operations and why
    we used this *type T* declaration: so that we can write our behavior methods such
    as `doX` and return `T`, or `doY(t: T)` using type `T` and return something. Abstract
    members give us the flexibility to write code without worrying about the type
    at the time of writing. Our functions/methods are fine to work with whatever type
    we define when we instantiate the trait/class.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '你现在对如何执行这些类型的操作以及为什么我们使用这种 *类型 T* 声明有了一些了解：这样我们就可以编写我们的行为方法，如 `doX` 并返回 `T`，或者使用类型
    `T` 的 `doY(t: T)` 并返回一些东西。抽象成员给我们提供了编写代码时的灵活性，无需担心类型。我们的函数/方法可以与我们在实例化特质/类时定义的任何类型一起工作。'
- en: 'Let''s take an example to compare how and what we achieved using type members:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子来比较我们使用类型成员实现了什么以及如何实现的：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example is easy to understand. We have both our parameterized version and
    the current one, a trait with an abstract type. So take a look at the parameterized
    version. We have specified that our `traitColumnParameterized[T]` is a parameterized
    type with parameter `T`. We're comfortable with this kind of syntax, right? We've
    just gone through it, it's simple and easy to understand. Now, the latter declaration,
    trait `ColumnAbstract` has a type member, we declared it using the `type`keyword.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很容易理解。我们既有参数化版本，也有当前版本，一个具有抽象类型的特质。所以看看参数化版本。我们指定了我们的`traitColumnParameterized[T]`是一个带有参数`T`的参数化类型。我们对这种语法很舒服，对吧？我们刚刚已经看过了，它简单易懂。现在，后者的声明，特质`ColumnAbstract`有一个类型成员，我们使用`type`关键字声明的。
- en: Now take a look at the implementation. For parameterized types we knew what
    we had to do and we instantiated the trait (you know what's happening with these
    curly braces at the time of instantiation, right?). Similarly, we instantiated
    the trait with the abstract member and overrode the definition with a `val`*,*
    that's possible, you know that already.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看实现。对于参数化类型，我们知道我们必须做什么，并实例化了特质（你知道在实例化时这些花括号发生了什么，对吧？）。同样，我们实例化了具有抽象成员的特质，并使用`val`**
    覆盖了定义，这是可能的，你知道这一点。
- en: 'And that''s why we were able to call both of these and get the values out of
    them. Now, if you try to assign the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为如此，我们才能调用这两个并从中获取它们的值。现在，如果你尝试分配以下内容：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we use the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了以下内容：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we get an error, an error saying incompatible types. We know the reason:
    because an integer cannot satisfy the signature, the signature expects the type
    to be `T`, and `T` is `String`*.* So, you''re trying to do the wrong thing; the
    compiler won''t let you pass through. I would suggest you try out these two concepts
    of parameterized types and abstract types. The more you use them and write them,
    the more comfortable you will get. Remember, these abstract members expect you
    to provide types and in Scala, a function is also a type. So, you can go deeper
    by thinking in terms of generating functions dynamically using a trait.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们遇到了错误，一个不兼容类型的错误。我们知道原因：因为整数无法满足签名，签名期望的类型是`T`，而`T`是`String`*.* 所以，你正在尝试做错事；编译器不会让你通过。我建议你尝试这些参数化类型和抽象类型的两个概念。你用得越多，写得越多，就会越舒服。记住，这些抽象成员期望你提供类型，在Scala中，函数也是一种类型。所以，你可以通过动态生成函数来深入思考，使用特质。
- en: 'Let''s take a moment and think. Suppose you want to form a mechanism for performing
    an action/operation. The code for such an action generator may look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间思考一下。假设你想形成一个执行动作/操作的机制。这样一个动作生成器的代码可能看起来像这样：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, this looks cool: we''ve used a parameterized type and also an abstract
    type member. Also, our type `Out` member can be a function type. Think of it as
    a rule or pattern. It can be as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来很酷：我们使用了一个参数化类型和一个抽象类型成员。此外，我们的类型`Out`成员可以是一个函数类型。把它想象成一个规则或模式。它可以如下所示：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To get more insight, let's think of a scenario where you want to provide a mechanism
    to generate a rating between 1 to 5 from a list of comments you received on your
    blog post. Now, different people have different ways of appreciating (or not appreciating)
    so some people were good enough to give you a rating of 4 or 5\. Some people,
    out of the blue, wrote, `Awesome`, `Nice`, or `Worst ever`. You have to generate
    a rating for your blog from all these comments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更多见解，让我们考虑一个场景，你想要提供一个机制，从你在博客文章上收到的评论列表中生成1到5的评分。现在，不同的人有不同的欣赏（或不欣赏）方式，所以有些人足够好，给你评了4或5分。有些人突然写道，“太棒了”，“很好”，或者“史上最差”。你必须从所有这些评论中为你的博客生成评分。
- en: 'Now, from the scenario, it might seem cool to write a rule, which, based on
    the comments, can generate the rating. Look closely: *generate the rating* is
    an action/operation. We''ll abstract this and we''ll write the generate the rating
    generator, we mean `ActionGenerator`. It could look as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从场景来看，编写一个规则可能看起来很酷，这个规则基于注释可以生成评分。仔细看看：*生成评分*是一个动作/操作。我们将抽象化这个，并编写生成评分生成器，我们指的是`ActionGenerator`。它可能看起来如下：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, `simpleRatingGenerator` is the `ActionGenerator`*.* A few takeaway points
    from the implementation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`simpleRatingGenerator`是`ActionGenerator`*.* 从实现中我们可以得到以下几点启示：
- en: Syntax, like `type Rating = Int`, is just to make code more readable. It enables
    the reader to think of `Rating` as a type that internally accepts *integers.*
    This is merely type declaration.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法，如`type Rating = Int`，只是为了使代码更易读。它使读者可以将`Rating`视为一个内部接受*整数*的类型。这仅仅是一个类型声明。
- en: Our `simpleRatingGenerator` specifies from its definition that it can accept
    a `NumericString` and give a function that is of type `NumericString => Rating`*.*
    We can view it as if `simpleRatingGenerator` is an `ActionGenerator` that provides
    a mechanism to generate a rating from `NumericString`*.*
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`simpleRatingGenerator`从其定义中指定它可以接受一个`NumericString`并给出一个类型为`NumericString
    => Rating`的函数*.* 我们可以将其视为如果`simpleRatingGenerator`是一个`ActionGenerator`，它提供了一个从`NumericString`生成评分的机制*.*
- en: 'Now, the way we can use such an action generator is to get the mechanism and
    pass a numeric string value to it to get the rating. That''s how we do it:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这种动作生成器的方式是获取机制并将一个数值字符串值传递给它以获取评分。这就是我们这样做的方式：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also create another rating generator that takes comments such as `Awesome`*,*
    `Good`*,* `Nice`*, *and so on*.* Here is an example of how to create an `AlphanumericRatingGenerator`
    that can provide a mechanism to generate rating from `AlphanumericString`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建另一个评分生成器，它接受诸如`Awesome`*、* `Good`*、* `Nice`*、等等这样的评论.* 下面是一个创建`AlphanumericRatingGenerator`的例子，它可以提供一个从`AlphanumericString`生成评分的机制：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The way we can use this is the same way we used `simpleRatingGenerator`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用它的方式与使用`simpleRatingGenerator`的方式相同：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So these ways can come in handy when we try to provide a simple interface to
    a consumer of our functionality. For example, if a person wants to see the rating
    based on the comments, he may not be interested in the complexity and only like
    to call a particular function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我们尝试为我们的功能提供简单的接口时，这些方法可能会很有用。例如，如果一个人想根据评论查看评分，他可能对复杂性不感兴趣，只想调用特定的函数。
- en: 'Why you would want to try out stuff with these concepts such as type parameters
    and abstract types now makes more sense: to create abstractions such as `ActionGenerator`*.*
    Life''s easier when you have a set of rules already defined and you only have
    to code them. So with this, let''s go ahead and try to make rules that are more
    precise. In other words, let''s take a look at how we can define limits for using
    our parameterized type.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你现在想尝试使用这些概念，比如类型参数和抽象类型，现在更有意义：为了创建抽象，比如`ActionGenerator`*.* 当你有一套已经定义好的规则时，生活会更简单，你只需要编码它们。所以，让我们继续尝试制定更精确的规则。换句话说，让我们看看我们如何定义参数化类型的限制。
- en: Type bounds
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型界限
- en: 'We''ve seen an example where we were allowed to create `AircraftSeat` for passengers.
    The example looked like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个例子，我们被允许为乘客创建`AircraftSeat`。例子看起来如下：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From what we know so far, `Aircraft` is contravariant in its type parameter
    `T`. But the thing is, when it comes to creating instances of `AircraftSeat`*,*
    it can be created for any type of `T`. What's expected is that this type parameter
    can only be of the `Passengers` type or it's subtype. So to achieve that we can
    introduce a type bound, in our case we'll use an upper-type bound. The reason
    for this is because we want to specify the type that's on the top of the inheritance
    hierarchy, in our case it's `Passengers`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们目前所知，`Aircraft`在其类型参数`T`上是协变的。但是，当涉及到创建`AircraftSeat`*、*实例时，它可以创建任何类型的`T`。预期的是，这个类型参数只能为`Passengers`类型或其子类型。因此，为了实现这一点，我们可以引入类型界限，在我们的情况下，我们将使用上界。这样做的原因是我们想指定继承层次结构顶部的类型，在我们的例子中是`Passengers`。
- en: 'It''ll look as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来如下：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, the notation `*<:*` specifies its *upper bound.* What does this do? Let''s
    check out an example to understand it better:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，符号`*<:*`指定了它的*上限*。这会做什么？让我们通过一个例子来更好地理解它：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we have the same example we used earlier; the only thing different is
    that now we can only create `AircraftSeat` for the `Passengers` type. The code
    will work fine. But we would like to see the behavior for when we try to create
    an `AircraftSeat` instance with a type that''s not a subtype of `Passengers`*.*
    For that, let''s create another class and try to create an `AircraftSeat` instance
    out of it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有之前用过的相同例子；唯一不同的是现在我们只能为`Passengers`类型创建`AircraftSeat`。代码将正常工作。但我们想看看当我们尝试用不是`Passengers`子类型的类型创建`AircraftSeat`实例时的行为。为此，让我们创建另一个类并尝试从中创建一个`AircraftSeat`实例：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you try to compile code with this instance, the Scala compiler will throw
    an error at compile time. It says the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用此实例编译代码，Scala 编译器将在编译时抛出一个错误。它显示以下内容：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: From the error shown previously, it's clear that the compiler was able to understand
    what we specified and is not ready to take anything else other than `Passengers`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前显示的错误中，很明显，编译器能够理解我们所指定的内容，并且除了 `Passengers` 之外，不准备接受任何其他内容。
- en: 'Similarly, it''s possible to specify a lower bound for our type parameters.
    We can use the sign `>:` to specify lower bounds. It looks as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以为我们的类型参数指定下边界。我们可以使用符号 `>:` 来指定下边界。它看起来如下：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we specified a `ListLikeStructure` for any reference types. It''s special
    in the sense that it only takes `Any`, `AnyRef`*,* or equivalent types in hierarchy*.*
    So let''s try creating an instance of the same for `Any` and `AnyRef`. The Scala
    compiler will not complain about the code and will work fine for the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为任何引用类型指定了一个 `ListLikeStructure`。它在某种程度上是特殊的，因为它只接受 `Any`、`AnyRef`* 或等价类型在层次结构中*.*
    因此，让我们尝试为 `Any` 和 `AnyRef` 创建相同的实例。Scala 编译器不会对代码提出任何异议，并且对于以下内容将正常工作：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When we try to create the same instance with a different type to `Any` or `AnyRef`, the
    Scala compiler will give an error as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用不同于 `Any` 或 `AnyRef` 的不同类型创建相同的实例时，Scala 编译器将给出以下错误：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: From this error, it's clear that the signature with a lower bound specified
    will not let you provide a type that comes lower in the type hierarchy. That's
    why we got an error for the `String` type. These are the ways we can provide lower
    and upper bounds in Scala. There's another way we can use both the bounds together
    to specify a specific range of types in the hierarchy.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个错误中，很明显，指定了下边界的签名不会让你提供在类型层次结构中更低级别的类型。这就是为什么我们为 `String` 类型得到了错误。这些是我们可以在
    Scala 中提供上下边界的途径。还有一种方法可以同时使用两者来指定层次结构中的特定类型范围。
- en: 'Think of a class inheritance hierarchy as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个类继承层次结构如下：
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For such a structure, a `ListLikeStructure` can be declared in the following
    way:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类结构，可以以下述方式声明 `ListLikeStructure`：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It specifies you can only provide a type between `Two` and `Four`, so it''s
    possible to create structures with the following types:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它指定你只能提供介于 `Two` 和 `Four` 之间的类型，因此可以创建以下类型的结构：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'But once you try passing a type that''s not in the bounds, the Scala compiler
    greets you with a compile time error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦你尝试传递不在边界内的类型，Scala 编译器将向你显示编译时错误：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As the error indicates, this instantiation does not satisfy the bounds. So
    now you are aware of the bounds for type parameters. In the same way, we can put
    bounds to abstract types as well:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如错误所指示的，这个实例化不满足边界条件。因此，你现在应该了解类型参数的边界。同样，我们也可以将边界应用于抽象类型：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, as shown in the previous declaration, our type `T` can be instantiated
    with only types for which `Two` is the upper bound.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正如前一个声明所示，我们的类型 `T` 只能使用 `Two` 作为上边界的类型进行实例化。
- en: With the discussion of bounds and variance, the difference and the use cases
    of both are clear. It's good to point out again, that variance is merely the rules
    for inheritance relationships between parameterized/container types. Bounds only
    write a rule that states a certain range of types can be used to instantiate a
    type that is parameterized or contains an abstract member.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于边界的讨论和变异性，两者之间的差异和用例都很清楚。再次指出，变异性仅仅是参数化/容器类型之间继承关系的规则。边界仅写一条规则，说明可以使用一定范围内的类型来实例化一个参数化或包含抽象成员的类型。
- en: Now that we have an idea about parameterized types, abstract types, and ways
    to define them, we should also try and find out why we choose abstract types rather
    than parameterized types or vice versa.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了参数化类型、抽象类型以及定义它们的方法，我们也应该尝试找出为什么我们选择抽象类型而不是参数化类型，或者反之亦然。
- en: Abstract versus parameterized types
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类型与参数化类型
- en: 'Both are forms of providing polymorphic abstractions in Scala. Mostly, it''s
    a design choice whether you prefer one over the other. Talking about design choices,
    let''s have a closer look. For that we''ll take an example where we have two class
    hierarchies as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种都是 Scala 中提供多态抽象的形式。大多数情况下，是否更喜欢其中一种是一个设计选择。谈到设计选择，让我们更仔细地看看。为此，我们将举一个有两个类层次结构的例子如下：
- en: '[PRE55]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'From the knowledge about abstract types and upper bounds we can say `Animal`
    is an abstract class, which has an abstract type member named `SuitableFood`,
    which expects only the `Food` type. If we declare two subtypes of `Animal` class
    namely `Cow` and `Lion` it could look like a cow can eat `Grass` as well as `Meat`
    because both are subclasses of `Food`. But this isn''t the desired behavior. To
    resolve the issue, we can declare `Cow` like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从关于抽象类型和上界的知识中，我们可以说`Animal`是一个抽象类，它有一个名为`SuitableFood`的抽象类型成员，该成员只期望`Food`类型。如果我们声明`Animal`类的两个子类型，即`Cow`和`Lion`，那么看起来一头牛可以吃`Grass`和`Meat`，因为它们都是`Food`的子类。但这不是我们想要的行为。为了解决这个问题，我们可以这样声明`Cow`：
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We have put a bound on the abstract type member `SuitableFood`*.* Now, for
    any cow (instance), the type that we provide has to be of type `Grass` *(*and
    yes, we were allowed to put *Grass* only because it''s a subtype of `Food`*).*
    We can do the same for the `Lion` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对抽象类型成员`SuitableFood`设置了一个限制*.* 现在，对于任何牛（实例），我们提供的类型必须是`Grass`类型（*是的，我们之所以可以只使用*`Grass`*，是因为它是`Food`的子类型*）。我们可以对`Lion`类做同样的处理：
- en: '[PRE57]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When we try using these classes, we''ll have to provide the intended concrete
    types. Let''s take a look at the app:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用这些类时，我们必须提供预期的具体类型。让我们看看这个应用：
- en: '[PRE58]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The result is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So, as shown, we can create a cow instance by providing a type that satisfies
    the bounds specified. These kinds of requirements are best written using abstract
    types. When you need to provide a type with a parameter, just for instantiation,
    examples are `List[String]` or similar types. When using the same type to evolve
    as you write/define members of your class/trait, it's better to consider abstract
    types.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如所示，我们可以通过提供一个满足指定边界的类型来创建一个牛的实例。这类要求最好使用抽象类型来编写。当你需要提供一个带有参数的类型，仅用于实例化时，例如`List[String]`或类似类型。当使用相同的类型来随着你编写/定义你的类/特质的成员时，考虑抽象类型会更好。
- en: Now that we've discussed *abstract versus parameterized types*, let's talk about
    one more concept that you will encounter often when working with Scala. We'll
    talk a bit about type-classes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了*抽象类型与参数化类型*的区别，让我们再谈谈一个你在使用Scala时经常会遇到的概念。我们将简要介绍类型类。
- en: Type-classes
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类
- en: Why would someone need a concept such as a type-class? To answer this, we'll
    first have to understand what a type-class exactly is. As they say, "*Type-classes
    allow us to generalize over a set of types in order to define and execute a standard
    set of features for those types."* Let's try to understand this.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有人需要像类型类这样的概念呢？为了回答这个问题，我们首先必须理解类型类究竟是什么。正如他们所说，“*类型类允许我们对一组类型进行泛化，以便为这些类型定义和执行一组标准特性。*”让我们试着理解这一点。
- en: 'I believe you''re aware of the notion of encoding and decoding. Let''s think
    of encoding as applying a certain rule to convert A into a specific pattern. Now,
    after you encode something, it''s in that specific pattern. Decoding is the exact
    opposite of what we just did: it''s changing your type A from the pattern we just
    created to its original shape. For example, **comma-separated values** (**CSV**)
    can be considered an encoded pattern. Hence, there''s a scheme that converts words
    from a source to CSV format:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你熟悉编码和解码的概念。让我们把编码想象成应用一定的规则将A转换为特定的模式。现在，在你编码了某物之后，它就在那个特定的模式中。解码是我们刚才所做事情的相反：它将你的类型A从我们刚才创建的模式中转换回其原始形状。例如，**逗号分隔值**（**CSV**）可以被认为是一个编码模式。因此，有一个方案将单词从源转换为CSV格式：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We've written a *trait* named `CSVEncoder[T]`. It's time to rephrase what we
    said for type-classes. `CSVEncoder` allows us to generalize over type `T` in order
    to provide an encoding mechanism for the same type. This means that we can use
    `CSVEncoder` for all the types we want and use them whenever there's a need. This
    is the implementation of a type-class. We'll go through the overall type-class
    implementation in the next chapter after the discussion of implicits. For now,
    it's good to know what a concept such as type-class does.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个名为`CSVEncoder[T]`的特质。现在是时候重新表述我们关于类型类的说法了。`CSVEncoder`允许我们对类型`T`进行泛化，以便为相同类型提供编码机制。这意味着我们可以为所有我们想要的类型使用`CSVEncoder`，并在需要时使用它们。这是类型类的一个实现。在讨论隐式之后，我们将在下一章中详细介绍整体类型类的实现。现在，了解类型类这样的概念是很好的。
- en: With the conception of type-classes, it's time to summarize what we have learned
    in this chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型类的概念下，是时候总结一下我们在本章中学到的内容了。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: From understanding the basic need of types to understanding what a type-class
    is, we've gone through it all. Along the way, we discussed parametric polymorphism
    using parametric types and abstract types. With the concept of variance, as well
    as bounds, we've gone through it all and now it's a bit clearer. For more insights,
    practice is a must. We can think of scenarios to learn about the concepts. We
    tried to go through the concepts as they were and look at a few examples, but
    it'll definitely be fun if you try out some of these on your own. This chapter
    was the formation or the basis of real Scala programming. Concepts such as type-classes
    come in very handy when writing effective programs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从理解类型的基本需求到理解什么是类型类，我们已经经历了一切。在这个过程中，我们讨论了使用参数类型和抽象类型的参数多态。随着可变性概念以及边界的引入，我们已经全部经历，现在它变得稍微清晰一些了。要获得更多见解，实践是必不可少的。我们可以设想一些场景来学习这些概念。我们试图按照它们本来的样子来理解这些概念，并查看一些例子，但如果你自己尝试其中的一些，那一定会很有趣。这一章是真实Scala编程的基础或形成。
- en: In the next chapter, we'll go through concepts such as *implicits* and the ways
    we can do exception handling in Scala. And of course, we'll play with type-classes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论诸如*隐式*等概念以及我们在Scala中如何进行异常处理。当然，我们还会玩转类型类。
