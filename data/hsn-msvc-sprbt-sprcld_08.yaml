- en: Developing Reactive Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发反应式微服务
- en: In this chapter, we will learn how to develop reactive microservices, that is,
    how to develop non-blocking synchronous REST APIs and asynchronous event-driven
    services using Spring. We will also learn about how to choose between these two
    alternatives. Finally, we will see how to create and run manual and automated
    tests of a reactive microservice landscape.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何开发反应式微服务，即如何使用Spring开发非阻塞同步REST API和基于事件的异步服务。我们还将学习如何在这两种替代方案之间进行选择。最后，我们将了解如何创建和运行反应式微服务架构的手动和自动化测试。
- en: As already described in the *Reactive microservices* section in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, the foundations for reactive systems is that
    they are message-driven—they use asynchronous communication. This enables them
    to be elastic, that is, scalable and resilient, meaning that they will be tolerant
    to failures. Elasticity and resilience together will enable a reactive system
    to be responsive; they will be able to respond in a timely fashion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)的*响应式微服务*部分所描述的，反应式系统的基础是它们是消息驱动的——它们使用异步通信。这使得它们具有弹性，即可伸缩和有韧性，意味着它们将能够忍受失败。弹性和韧性相结合将使反应式系统能够变得*响应性*；它们将能够及时做出反应。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Choosing between non-blocking synchronous APIs and event-driven asynchronous
    services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非阻塞同步API和基于事件的异步服务之间进行选择
- en: Developing non-blocking synchronous REST APIs using Spring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring开发非阻塞同步REST API
- en: Developing event-driven asynchronous services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发基于事件驱动的异步服务
- en: Running manual tests of the reactive microservice landscape
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式微服务架构的手动测试
- en: Running automated tests of the reactive microservice landscape
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式微服务架构的自动化测试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands described in this book are run on a MacBook Pro using macOS
    Mojave but should be straightforward to modify so that they can run on another
    platform such as Linux or Windows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在MacBook Pro上使用macOS Mojave运行的，但应该很容易修改，以便它们可以在其他平台如Linux或Windows上运行。
- en: No new tools need to be installed in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中不需要安装任何新工具。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter07)。
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. Some sample commands are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行书中描述的命令，将源代码下载到一个文件夹中，并设置一个环境变量`$BOOK_HOME`，使其指向该文件夹。一些示例命令如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0 (also known as the **Greenwich** release), Spring Boot
    2.1.2, and Spring 5.1.4, which are the latest available versions of the Spring
    components at the time of writing this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用Spring Cloud 2.1.0（也称为**Greenwich**版本），Spring
    Boot 2.1.2和Spring 5.1.4，这些是编写本章时可用的Spring组件的最新版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter07`,
    but are edited in many cases in order to remove irrelevant parts of the source
    code, such as comments and import and log statements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例均来自`$BOOK_HOME/Chapter07`的源代码，但在许多情况下进行了编辑，以删除源代码中不相关的内容，例如注释和`import`以及日志语句。
- en: In this chapter*,* you can take a look at the changes that ware applied to the
    source code and what it took to make the microservices reactive. This code can
    be compared to the source code for [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*. You can use your favorite `diff`-tool and compare the two
    folders – `$BOOK_HOME/Chapter06` and `$BOOK_HOME/Chapter07`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章*中，*您可以查看已对源代码所做的更改以及使微服务变得响应式所需的努力。此代码可与[第6章](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml)的*添加持久化*源代码进行比较。您可以使用您喜欢的`diff`工具并比较两个文件夹—`$BOOK_HOME/Chapter06`和`$BOOK_HOME/Chapter07`。
- en: Choosing between non-blocking synchronous APIs and event-driven asynchronous
    services
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在非阻塞的同步API和事件驱动的异步服务之间进行选择
- en: When developing reactive microservices, it is not always obvious when to use
    non-blocking synchronous APIs and when to use event-driven asynchronous services.
    In general, to make a microservice robust and scalable, it is important to make
    it as autonomous as possible, for example, minimizing its runtime dependencies.
    This is also known as **loose** **coupling**. Therefore, asynchronous message
    passing of events, is preferable over synchronous APIs. This is because the microservice
    will only depend on access to the messaging system at runtime instead of being
    dependent on synchronous access to a number of other microservices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发响应式微服务时，并不总是明显何时使用非阻塞的同步API，何时使用事件驱动的异步服务。通常，为了使微服务具有鲁棒性和可伸缩性，使其尽可能自治是很重要的，例如，最小化其运行时依赖。这也被称为**松耦合**。因此，异步消息传递事件优于同步API。这是因为微服务仅在运行时依赖于对消息系统的访问，而不是依赖于对多个其他微服务的同步访问。
- en: 'There are, however, a number of cases where non-blocking synchronous APIs could
    be favorable to use, for example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多情况下使用非阻塞的同步API可能是合适的，例如：
- en: For read operations where an end user is waiting for a response
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于读操作，用户端正在等待响应
- en: Where the client platforms are more suitable for consuming synchronous APIs,
    for example, mobile apps or SPA web applications
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端平台更适合消耗同步API，例如，移动应用或SPA网络应用
- en: Where the clients will connect to the service from other organizations—where
    it might be hard to agree over a common messaging system to use across organizations
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端将连接到来自其他组织的服务—在这些情况下，可能很难就跨组织使用的共同消息系统达成一致
- en: 'For the system landscape used in this book, we will use the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中使用的系统架构，我们将使用以下内容：
- en: The create, read, and delete services exposed by the product composite microservice
    will be based on synchronous APIs. The composite microservice is assumed to have
    clients on both web and mobile platforms, as well as clients coming from other
    organizations rather than the ones that operate the system landscape. Therefore,
    synchronous APIs seem like a natural match.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品组合微服务暴露的创建、读取和删除服务将基于同步API。组合微服务假定具有web和移动平台以及来自其他组织（而非操作系统架构的组织）的客户端。因此，同步API似乎是一个自然的匹配。
- en: The read services provided by the core microservices will also be developed
    as non-blocking synchronous APIs since there is an end user waiting for their
    responses.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心微服务提供的读取服务也将开发为非阻塞的同步API，因为有一个终端用户在等待它们的响应。
- en: The create and delete services provided by the core microservices will be developed
    as event-driven asynchronous services. The synchronous APIs provided by the composite
    microservices to create and delete aggregated product information will simply
    publish, create, and delete events on the topics that the core services listen
    on and then return with a 200 (OK) response.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心微服务提供的创建和删除服务将开发为事件驱动的异步服务。组合微服务提供的创建和删除聚合产品信息的同步API将简单地在核心服务监听的主题上发布、创建和删除事件，然后返回200（OK）响应。
- en: 'This is illustrated by the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这一点：
- en: '![](img/a8f1c5bd-e29b-4f4d-a527-a0f86fd863b1.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8f1c5bd-e29b-4f4d-a527-a0f86fd863b1.png)'
- en: First, let's learn how we can develop non-blocking synchronous REST APIs, and
    thereafter, we will look at how to develop event-driven asynchronous services.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何开发非阻塞的同步REST API，之后，我们将查看如何开发事件驱动的异步服务。
- en: Developing non-blocking synchronous REST APIs using Spring
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring开发非阻塞的同步REST API
- en: 'In this section, we will learn how to develop non-blocking versions of the
    read APIs. The composite service will make reactive, that is, non-blocking, calls
    in parallel to the three core services. When the composite service has received
    responses from the core services, it will create a composite response and send
    it back to the caller. This is illustrated in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何开发读取 API 的非阻塞版本。复合服务将对三个核心服务并行地做出反应性的，即非阻塞的调用。当复合服务从核心服务收到响应后，它将创建一个复合响应并将其发送回调用者。以下图示说明了这一点：
- en: '![](img/676c4d79-653b-438c-b8ff-7ffe0477644d.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/676c4d79-653b-438c-b8ff-7ffe0477644d.png)'
- en: 'We will cover the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍以下内容：
- en: An introduction to Spring Reactor
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Spring Reactor
- en: Non-blocking persistence using Spring Data for MongoDB
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Data for MongoDB 进行非阻塞持久化
- en: Non-blocking REST APIs in the core services, including how to handle blocking
    code for the JPA-based persistence layer
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心服务中的非阻塞 REST API，包括如何处理基于 JPA 的持久化层的阻塞代码
- en: Non-blocking REST APIs in the composite service
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞 REST API 在复合服务中
- en: An introduction to Spring Reactor
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Spring Reactor
- en: As we mentioned in the *Beginning with Spring WebFlux* section in [Chapter 2](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Boot*, the reactive support in Spring 5 is based on **Project
    Reactor** ([https://projectreactor.io](https://projectreactor.io)).  Project Reactor
    is based on the *Reactive Streams specification* ([http://www.reactive-streams.org](http://www.reactive-streams.org)),
    a standard for building reactive applications. Spring Reactor is fundamental and
    it is what Spring WebFlux, Spring WebClient, and Spring Data rely on to provide
    their reactive and non-blocking features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 2 章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)《Spring Boot 入门》中的 *Beginning
    with Spring WebFlux* 部分提到的，Spring 5 中的反应式支持基于 **Project Reactor** ([https://projectreactor.io](https://projectreactor.io))。
    Project Reactor 基于 *Reactive Streams 规范* ([http://www.reactive-streams.org](http://www.reactive-streams.org))，用于构建反应式应用程序的标准。
    Spring Reactor 是基础，它是 Spring WebFlux、Spring WebClient 和 Spring Data 提供其反应性和非阻塞特性的依赖。
- en: 'The programming model is based on processing streams of data, and the core
    data types in Project Reactor are `Flux` and `Mono`. A `Flux` object is used to
    process a stream of *0*...*n* elements and a `Mono` object is used to process
    *0*...*1* elements. We will see numerous examples of its usage in this chapter.
    As a short introduction, let''s look at the following test:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 编程模型基于处理数据流，Project Reactor 的核心数据类型是 `Flux` 和 `Mono`。`Flux` 对象用于处理一个元素流 *0*...*n*，而
    `Mono` 对象用于处理 *0*...*1* 个元素。在本章中我们将看到许多使用它们的示例。作为一个简短的介绍，让我们看看下面的测试：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: We initiate the stream with the integers `1`, `2`, `3`, and `4`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用整数 `1`、`2`、`3` 和 `4` 初始化流。
- en: Next, we `filter` out the odd numbers—we only allow even numbers to proceed
    through the stream—in this test, these are `2` and `4`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们 `filter` 掉奇数——我们只允许偶数通过流继续进行——在这个测试中，这些是 `2` 和 `4`。
- en: Next, we transform (or `map`) the values in the stream by multiplying them by
    `2`, that is, to `4` and `8`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过乘以 `2` 对流中的值进行转换，即得到 `4` 和 `8`。
- en: Then, we `log` the data that flows through the stream after the `map` operation.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 `map` 操作后的流中 `log` 数据。
- en: So far, we have only declared the processing of a stream. To actually get the
    stream processed, we need someone to subscribe to it. The final call to the `subscribe`
    method will register a subscriber and the subscriber will apply the lambda function
    specified in the call to the `subscribe` method on each element it gets from the
    stream. Thereafter, it will add them to the `list` element.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是声明了数据流 processing。要实际处理数据流，我们需要有人来订阅它。`subscribe` 方法的最终调用将注册一个订阅者，订阅者将对从流中获取的每个元素应用
    `subscribe` 方法中的 lambda 函数。此后，它将把它们添加到 `list` 元素。
- en: Finally, we can assert that `list` after the processing of the stream contains
    the expected result—the integers `4` and `8`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以断言，在数据流处理后 `list` 包含期望的结果——整数 `4` 和 `8`。
- en: 'The log output will look like the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 日志输出将如下代码所示：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: The processing of the stream is started by a subscriber that subscribes to the
    stream and requests its content.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据流的 processing 是由一个订阅者启动的，该订阅者订阅流并请求其内容。
- en: Next, the integers `4` and `8` pass through the `log` operation.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，整数 `4` 和 `8` 通过了 `log` 操作。
- en: The processing concludes with a call to the `onComplete` method on the subscriber,
    notifying it that the stream has come to an end.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理以调用订阅者的`onComplete`方法结束，通知它流已经结束。
- en: For the full source code, see the `se.magnus.util.reactor.ReactorTests` test
    class in the `util` project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码请参阅`util`项目中的`se.magnus.util.reactor.ReactorTests`测试类。
- en: Normally, we don't initiate the processing of the stream. Instead, we will only
    define how it shall be processed, and it will be the responsibility of an infrastructure
    component, such as Spring WebFlux, to initiate the processing, for example, as
    a response to an incoming HTTP request. An exception to this rule of thumb is
    the case where blocking code needs a response from the reactive stream. In these
    cases, the blocking code can call the `block()` method on the `Flux` or `Mono`
    object to get the response from the `Flux` or `Mono` object in a blocking way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会初始化流的处理。相反，我们只定义它应该如何被处理，而发起处理的职责将留给一个基础架构组件，比如Spring WebFlux，例如，作为对传入HTTP请求的响应。这个规则的一个例外是阻塞代码需要从反应式流中获取响应的情况。在这些情况下，阻塞代码可以调用`Flux`或`Mono`对象上的`block()`方法，以阻塞方式从`Flux`或`Mono`对象获取响应。
- en: Non-blocking persistence using Spring Data for MongoDB
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞式持久化使用Spring Data for MongoDB
- en: 'Making the MongoDB-based repositories for the `product` and `recommendation`
    services reactive is very simple:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将基于MongoDB的`product`和`recommendation`服务的存储库变为反应式非常简单：
- en: Change to the `ReactiveCrudRepository` base class for the repositories
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ReactiveCrudRepository`基类更改为存储库
- en: Change the custom finder methods to return a `Mono` or `Flux` object
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自定义查找方法更改为返回一个`Mono`或`Flux`对象
- en: 'The `ProductRepository` and `RecommendationRepository` look like the following
    after the change:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更改后的`ProductRepository`和`RecommendationRepository`看起来像这样：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: No changes are applied to the persistence code for the `review` service, it
    will remain blocking using the JPA repository!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`review`服务的持久化代码没有进行任何更改，它将保持使用JPA存储库的阻塞式！
- en: 'For the full source code, take a look at the following classes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码请参考以下类：
- en: '`se.magnus.microservices.core.product.persistence.ProductRepository` in the `product` project.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.persistence.ProductRepository`在`product`项目中。'
- en: '`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository`
    in the `recommendation` project.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository`在`recommendation`项目中。'
- en: Changes in the test code
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码的变化
- en: When it comes to testing the persistence layer, we have to make some changes.
    Since our persistence methods now return a `Mono` or `Flux` object, the test methods
    have to wait for the response to be available in the returned reactive objects.
    The test methods can either use an explicit call to the `block()` method on the
    `Mono`/`Flux` object to wait until a response is available or use the `StepVerifier` helper
    class from Project Reactor to declare a verifiable sequence of asynchronous events.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试持久层时，我们必须做一些改变。由于我们现在的持久化方法返回了一个`Mono`或`Flux`对象，测试方法必须等待响应在返回的反应式对象中可用。测试方法可以调用`Mono`/`Flux`对象的`block()`方法来等待响应可用，或者使用来自Project
    Reactor的`StepVerifier`帮助类来声明一个可验证的异步事件序列。
- en: 'The following example shows how to change the test code to work for the reactive
    version of the repository:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了如何更改测试代码以适应存储库的反应式版本：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use the `block()` method on the `Mono` object returned by the `repository.findById()`
    method and keep the imperative programming style, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`repository.findById()`方法返回的`Mono`对象上调用`block()`方法，并保持命令式编程风格，如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, we can use the `StepVerifier` class to set up a sequence of
    processing steps that both execute the repository find operation and also verifies
    the result. The sequence is initialized by the final call to the `verifyComplete()`
    method like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用`StepVerifier`类来设置一个处理步骤序列，既执行存储库查找操作，又验证结果。该序列通过最终调用`verifyComplete()`方法来初始化，如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For examples of using the `StepVerifier` class to write tests, see the `se.magnus.microservices.core.product.PersistenceTests` test
    class in the `product` project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`StepVerifier`类编写测试的示例，请参阅`product`项目中的`se.magnus.microservices.core.product.PersistenceTests`测试类。
- en: For corresponding examples of using the `block()` method to write tests, see
    the `se.magnus.microservice.core.recommendation.PersistenceTests` test class in
    the `recommendation` project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`block()`方法编写测试的相应示例，请参阅`recommendation`项目中的`se.magnus.microservice.core.recommendation.PersistenceTests`测试类。
- en: Non-blocking REST APIs in the core services
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心服务的非阻塞REST API
- en: 'With a non-blocking persistence layer in place, it''s time to make the APIs
    in the core services non-blocking as well. We need to make the following changes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在非阻塞持久层就位之后，是时候也让核心服务的API变为非阻塞式的了。我们需要进行以下更改：
- en: Change the APIs so that they only return reactive data types
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改API，使它们只返回反应式数据类型
- en: Change the service implementations so they don't contain any blocking code
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改服务实现，使它们不包含任何阻塞代码
- en: Change our tests so that they can test the reactive services
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改我们的测试，使它们能够测试反应式服务
- en: Deal with blocking code—isolate the code that still needs to be blocking from
    the non-blocking code
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理阻塞代码—将仍需阻塞的代码与非阻塞代码隔离
- en: Changes in the APIs
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API的变化
- en: To make the APIs of the core services reactive, we need to update their methods
    so that they return either a `Mono` or `Flux` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使核心服务的API变为反应式的，我们需要更新它们的方法，使它们返回一个`Mono`或`Flux`对象。
- en: 'For example, `getProduct()` in the `product` service now returns `Mono<Product>`
    instead of a `Product` object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`product`服务中的`getProduct()`现在返回`Mono<Product>`而不是一个`Product`对象：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the full source code, take a look at the following classes in the `api`
    project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码请参阅`api`项目中的以下类：
- en: '`se.magnus.api.core.product.ProductService`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.product.ProductService`'
- en: '`se.magnus.api.core.recommendation.RecommendationService`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.recommendation.RecommendationService`'
- en: '`se.magnus.api.core.review.ReviewService`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.review.ReviewService`'
- en: Changes in the service implementations
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现的变化
- en: 'For the implementations of the services in the `product` and `recommendation`
    services that use a reactive persistence layer, we can use the fluent API in Project
    Reactor. For example, the implementation of the `getProduct()` method looks like
    the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在`product`和`recommendation`服务中使用反应式持久层的服务实现，我们可以使用Project Reactor中的流式API。例如，`getProduct()`方法的实现如下所示：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述源代码的解释：
- en: The method will return a `Mono` object; the processing here is declared, not
    triggered. It is triggered by the web framework, `WebFlux`, once it receives a
    request to this service!
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法将返回一个`Mono`对象；这里的处理是声明式的，而不是触发式的。一旦`WebFlux`接收到对此服务的请求，它就会被触发！
- en: A product will be retrieved using its `productId` from the underlying database
    using the `findByProductId()` method in the persistence repository.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用其`productId`从底层数据库中检索产品，使用持久性仓库中的`findByProductId()`方法。
- en: If no product is found for the given `productId`, `NotFoundException` will be
    thrown.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果为给定的`productId`找不到产品，将抛出`NotFoundException`。
- en: The `log` method will produce log output.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log`方法将产生日志输出。'
- en: The `mapper.entityToApi()` method will be called to transform the returned entity
    from the persistence layer to an API model object.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调用`mapper.entityToApi()`方法将来自持久层返回的实体转换为API模型对象。
- en: The final `map` method will set the DNS name and IP address of the microservices
    that processed the request in the `serviceAddress` field of the model object.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的`map`方法将在模型对象的`serviceAddress`字段中设置处理请求的微服务的DNS名称和IP地址。
- en: 'Some sample log output for successful processing is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 成功处理的一些示例日志输出如下：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is a sample of failed processing (throwing a not found exception):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理失败的一个示例（抛出一个未找到异常）：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the full source code, see the following classes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码请参阅以下类：
- en: '`se.magnus.microservices.core.product.services.ProductServiceImpl` in the `product`
    project'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`项目中的`se.magnus.microservices.core.product.services.ProductServiceImpl`'
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` in
    the `recommendation` project'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl`'
- en: Changes in the test code
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码的变化
- en: The test code for service implementations has been changed in the same way as
    the tests for the persistence layer we described previously. To handle the asynchronous
    behavior of the reactive return types, `Mono` and `Flux`, the tests use a mix
    of calling the `block()` method and using the `StepVerifier` helper class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实现测试代码已经按照我们之前描述的持久层测试进行了更改。为了处理反应式返回类型的异步行为，`Mono` 和 `Flux`，测试中混合了调用`block()`方法和使用`StepVerifier` 助手类。
- en: 'For the full source code, see the following test classes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在以下测试类中找到：
- en: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` in the `product` project'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` 在 `product` 项目中'
- en: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` in
    the `recommendation` project'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` 在 `recommendation` 项目中'
- en: Dealing with blocking code
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理阻塞代码
- en: In the case of the `review` service, which uses JPA to access its data in a
    relational database, we don't have support for a non-blocking programming model.
    Instead, we can run the blocking code using `Scheduler`, which is capable of running
    the blocking code on a thread from a dedicated thread pool with a limited number
    of threads. Using a thread pool for the blocking code avoids draining the available
    threads in the microservice (avoids affecting the non-blocking processing in the
    microservice).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用JPA在其关系型数据库中访问数据的`review` 服务，我们不支持非阻塞编程模型。相反，我们可以使用`Scheduler`来运行阻塞代码，它能够在有限线程数的专用线程池中运行线程。使用线程池来运行阻塞代码，避免了耗尽微服务中可用的线程（避免了影响微服务中的非阻塞处理）。
- en: 'Let''s see how this process works, as laid out in the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个过程是如何按照以下步骤展开的：
- en: 'Firstly, we configure the thread pool in the `main` `ReviewServiceApplication` class,
    as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在`main` `ReviewServiceApplication` 类中配置线程池，如下所示：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can configure the size of the thread pool using the `spring.datasource.maximum-pool-size` parameter.
    If it is not set, it will default to 10 threads. For the full source code, see
    the `se.magnus.microservices.core.review.ReviewServiceApplication` class in the `review`
    project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`spring.datasource.maximum-pool-size` 参数配置线程池的大小。如果没有设置，它将默认为10个线程。完整的源代码可以在`se.magnus.microservices.core.review.ReviewServiceApplication` 类中找到，该类在`review` 项目中。
- en: 'Next, we inject the scheduler into the `review` service implementation class,
    as shown here:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将调度器注入到`review` 服务实现类中，如下所示：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we use the thread pool in the reactive implementation of the `getReviews()`
    method, like so:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在反应式实现中的`getReviews()` 方法中使用线程池，如下所示：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is an explanation of the preceding code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的解释：
- en: The blocking code is placed in the `getByProductId()` method
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞代码放在了`getByProductId()` 方法中
- en: The `getReviews()` method uses the `asyncFlux()` method to run the blocking
    code in a thread from the thread pool
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getReviews()` 方法使用`asyncFlux()` 方法在线程池中运行阻塞代码'
- en: For the full source code, see the `se.magnus.microservices.core.review.services.ReviewServiceImpl` class in
    the `review` project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`se.magnus.microservices.core.review.services.ReviewServiceImpl` 类中找到，该类在`review` 项目中。
- en: Non-blocking REST APIs in the composite services
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合服务中的非阻塞REST API
- en: 'To make our REST API in the composite service non-blocking, we need to do the
    following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使复合服务中的REST API非阻塞，我们需要做以下工作：
- en: Change the APIs so that they only return reactive datatypes
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改API，使其只返回反应式数据类型
- en: Change the integration layer so it uses a non-blocking HTTP client
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改集成层，使其使用非阻塞HTTP客户端
- en: Change the service implementation so it calls the core services APIs in parallel
    and non-blocking
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改服务实现，使其以并行和非阻塞的方式调用核心服务API
- en: Change our tests so that they can test the reactive service
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改我们的测试，以便它们可以测试反应式服务
- en: Changes in the API
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API的更改
- en: To make the API of the composite service reactive, we need to apply the same
    type of change that we applied for the APIs of the core services we described
    previously. This means that the return type of the `getCompositeProduct` method,
    `ProductAggregate`, needs to be replaced with `Mono<ProductAggregate>`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使复合服务的API反应式，我们需要应用与之前描述的核心服务API相同的更改。这意味着`getCompositeProduct` 方法的返回类型`ProductAggregate`需要替换为`Mono<ProductAggregate>`。
- en: For the full source code, see the `se.magnus.api.composite.product.ProductCompositeService` class
    in the `api` project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`se.magnus.api.composite.product.ProductCompositeService` 类中找到，该类在`api` 项目中。
- en: Changes in the integration layer
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成层的变更
- en: In the `ProductCompositeIntegration` integration class, we have replaced the
    `RestTemplate` blocking HTTP client with the `WebClient` non-blocking HTTP client that
    comes with Spring 5.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductCompositeIntegration`集成类中，我们将`RestTemplate`阻塞式HTTP客户端替换为Spring 5提供的`WebClient`非阻塞式HTTP客户端。
- en: 'A builder for the `WebClient` is auto-injected in to the constructor. If customization
    is required, for example, in setting up common headers or filters, it can be done
    in the constructor. For the available configuration options, see [https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder).
    Please have a look at the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebClient`的构建器自动注入到构造函数中。如果需要自定义，例如设置公共头或过滤器，可以在构造函数中完成。有关可用的配置选项，请参阅[https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder)。请查看以下步骤：'
- en: 'Here, we simply build the `WebClient` instance that we will use in our integration
    class, without any configuration:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们简单地构建了将在集成类中使用的`WebClient`实例，而不进行任何配置：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we use the `webClient` instance to make our non-blocking requests for
    calling the `product` service:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`webClient`实例来调用`product`服务的非阻塞请求：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the API call to the `product` service fails, the whole request will fail.
    The `WebClient onErrorMap()` method will call our `handleException(ex)` method,
    which maps the exceptions thrown previously by the HTTP layer to our own exceptions,
    for example, `NotFoundException` and `InvalidInputException`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对`product`服务的API调用失败，整个请求将会失败。`WebClient onErrorMap()`方法将调用我们的`handleException(ex)`方法，该方法将之前由HTTP层抛出的异常映射到我们自己的异常，例如`NotFoundException`和`InvalidInputException`。
- en: 'However, if calls to the `product` service succeed but the call to either the recommendation
    or review API fails, we don''t want to let the whole request fail. Instead, we
    want to return as much information that is available, back to the caller. Therefore,
    instead of propagating an exception in these cases, we will instead return an
    empty list of recommendations or reviews using the `WebClient onErrorResume(error
    -> empty())` method. For this, consider the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果对`product`服务的调用成功，但对推荐或评论API的调用失败，我们不希望让整个请求失败。相反，我们希望能够返回尽可能多的可用信息给调用者。因此，在这些情况下，我们不会传播异常，而是使用`WebClient
    onErrorResume(error -> empty())`方法返回推荐或评论的空列表。考虑以下代码：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class in
    the `product-composite` project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类。
- en: Changes in the service implementation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现变更
- en: 'To be able to call the three APIs in parallel, the service implementation uses
    the static `zip()`  method on the `Mono` class. The `zip` method is capable of
    handling a number of parallel requests and zipping them together once they all
    are complete. The code looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够并行调用三个API，服务实现使用了`Mono`类上的静态`zip()`方法。`zip`方法能够处理多个并行请求，并在它们都完成后将它们组合在一起。代码如下：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是先前源代码的解释：
- en: The first parameter of the `zip` method is a lambda function that will receive
    the responses in an array. The actual aggregation of the responses from the three
    API calls is handled by the same helper method as before, `createProductAggregate`,
    without any changes.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zip`方法的第一参数是一个lambda函数，该函数将接收响应数组。三个API调用响应的实际聚合由之前的同一个助手方法处理，即`createProductAggregate`，没有进行任何更改。'
- en: The parameters after the lambda function are a list of the requests that the
    `zip` method will call in parallel, one `Mono` object per request. In our case,
    we send in three `Mono` objects that were created by the methods in the integration
    class, one for each request that's sent to each core microservice.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在lambda函数后面的参数是一个请求列表，`zip`方法将并行调用这些请求，每个请求对应一个`Mono`对象。在我们这个案例中，我们发送了三个由集成类方法创建的`Mono`对象，每个对象对应发送到每个核心微服务的每个请求。
- en: For the full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class
    in the `product-composite` project.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl`类。
- en: Changes in the test code
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码中的更改
- en: 'The only change that''s required in the test classes is to update the setup
    of the mock of the integration class so that the `Mono` and `Flux` objects are
    returned using the  `Mono.just()` helper methods and `Flux.fromIterable()`, as
    shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类中唯一需要更改的是更新集成类的mock设置，以便使用`Mono.just()`帮助方法和`Flux.fromIterable()`返回`Mono`和`Flux`对象，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the full source code, see the `se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests` test
    class in the `product-composite` project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码，请参阅`product-composite`项目中的`se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests`测试类。
- en: Now that we have developed non-blocking REST APIs with Spring, it is time to
    develop an event-driven synchronous service.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Spring开发了非阻塞REST API，是时候开发一个基于事件的同步服务了。
- en: Developing event-driven asynchronous services
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基于事件的异步服务
- en: 'In this section, we will learn how to develop event-driven and asynchronous
    versions of the create and delete services. The composite service will publish create
    and delete events on each core service topic and then return a OK response back
    to the caller without waiting for processing to take place in the core services.
    This is illustrated in the following diagram:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何开发基于事件的异步创建和删除服务版本。组合服务将在每个核心服务主题上发布创建和删除事件，然后不等待核心服务中的处理，向调用者返回一个OK响应。以下图表说明了这一点：
- en: '![](img/6a55381b-4a64-4aa4-84fb-02f258aca361.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a55381b-4a64-4aa4-84fb-02f258aca361.png)'
- en: 'We will cover the following topics:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Configuring Spring Cloud Stream to handle challenges with messaging
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Cloud Stream以处理消息传递挑战
- en: Defining topics and events
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义主题和事件
- en: Changes in Gradle build files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle构建文件中的更改
- en: Publishing events in the composite service
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组合服务中发布事件
- en: Consuming events in the core services
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在核心服务中消费事件
- en: Configuring Spring Cloud Stream to handle challenges with messaging
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring Cloud Stream以处理消息传递挑战
- en: To implement the event-driven create and delete services, we will use Spring
    Cloud Stream. In [Chapter 2](9878a36a-5760-41a4-a132-1a2387b61037.xhtml), *Introduction
    to Spring Boot*, in the *Spring Cloud Stream* section, we have already seen how
    easy it is to publish and consume messages on a topic using Spring Cloud Stream.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现基于事件创建和删除服务，我们将使用Spring Cloud Stream。在[第2章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)，《Spring
    Boot入门》中的*Spring Cloud Stream*部分，我们已经看到了使用Spring Cloud Stream在主题上发布和消费消息是多么简单。
- en: 'For example, to publish a message on a topic defined by `mysource`, we only
    have to write the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要发布一个由`mysource`定义的主题上的消息，我们只需要写以下内容：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For consuming a message, we write the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消费消息，我们编写以下代码：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This programming model can be used independently of the messaging system used,
    for example, RabbitMQ or Apache Kafka!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程模型可以独立于使用的消息系统，例如，RabbitMQ或Apache Kafka！
- en: 'Even though sending asynchronous messages is preferred over synchronous API
    calls, it comes with challenges. We will see how we can use Spring Cloud Stream
    to handle some of them. The following features in Spring Cloud Stream will be
    covered:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管异步消息传递优先于同步API调用，但它带来了挑战。我们将了解如何使用Spring Cloud Stream来处理其中一些问题。以下Spring Cloud
    Stream功能将得到覆盖：
- en: Consumer groups
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者群体
- en: Retries and dead-letter queues
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试和死信队列
- en: Guaranteed orders and partitions
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证顺序和分区
- en: We'll study each of these in the following sections.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中研究每个这些内容。
- en: Consumer groups
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费者群体
- en: 'The problem here is, if we scale up the number of instances of a message consumer,
    for example, start two instances of the product microservice, both instances of
    the product microservice will consume the same messages, as illustrated by the
    following diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于，如果我们增加消息消费者的实例数量，例如，启动产品微服务的两个实例，两个产品微服务实例都将消费相同的消息，如下面的图表所示：
- en: '![](img/37c34a80-a777-4301-b2dd-c36e1ac8b50d.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37c34a80-a777-4301-b2dd-c36e1ac8b50d.png)'
- en: 'The solution to this is that we only want one instance per consumer to process
    each message. This can be solved by introducing a *consumer group*, as illustrated
    by the following diagram:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是我们只希望每个消费者实例处理每条消息。这可以通过引入一个*消费者组*来解决，如下面的图表所示：
- en: '![](img/e4713a81-9342-4fa1-a32d-ea3f544a7596.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4713a81-9342-4fa1-a32d-ea3f544a7596.png)'
- en: 'In Spring Cloud Stream, a consumer group can be configured on the consumer
    side, for example, for the product microservice, as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Stream中，消费者组可以在消费者端进行配置，例如，对于产品微服务，如下所示：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding configuration, Spring Cloud Stream will use the value of the `group`
    field to add instances of the `product` microservice to the consumer group called `productsGroup`.
    This means that messages sent to the `products` topic will only be delivered by
    Spring Cloud Stream to one of the instances of the product microservice.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，Spring Cloud Stream将使用`group`字段的值将`product`微服务的实例添加到名为`productsGroup`的消费者组中。这意味着发送到`products`主题的消息将只由Spring
    Cloud Stream交付给产品微服务的一个实例。
- en: Retries and dead-letter queues
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试和死信队列
- en: In this section, we will learn how retries and dead-letter queues are used by
    message consumers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习消息消费者如何使用重试和死信队列。
- en: If a consumer fails to process a message, it may lost or be requeued for the
    failing consumer until it is successfully processed. If the content of the message
    is invalid, also known as a **poisoned message**, it will block the consumer from
    processing other messages until it is manually removed. If the failure is due
    to a temporary problem, for example, the database can't be reached due to a temporary
    network error, the processing will probably succeed after a number of retries.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消费者未能处理消息，它可能会丢失或被重新排队，直到失败消费者成功处理。如果消息内容无效，也称为**毒消息**，它将阻塞消费者处理其他消息，直到手动移除。如果失败是由于临时问题，例如，由于临时网络错误无法访问数据库，经过多次重试后处理可能会成功。
- en: It must be possible to specify the number of retries until a message is moved
    to another storage for fault analysis and correction. A failing message is typically
    moved to a dedicated queue called a dead-letter queue. To avoid overloading the
    infrastructure during temporary failure, for example, a network error, it must
    be possible to configure how often retries are performed and preferably with increasing
    time between each retry.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 必须能够指定重试次数，直到消息被移动到另一个存储进行故障分析和修正。失败的消息通常会被移动到一个专门的队列，称为死信队列。为了避免在临时故障时，例如网络错误，过度负载基础架构，必须能够配置重试的频率，最好每次重试之间的时间逐渐增加。
- en: 'In Spring Cloud Stream, this can be configured on the consumer side, for example,
    for the product microservice, as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Stream中，这可以在消费者端进行配置，例如，对于产品微服务，如下所示：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we specify that Spring Cloud Stream shall perform
    `3` retries before placing a message on the dead-letter queue. The first retry
    shall be attempted after `500` ms and the two other attempts after `1000` ms.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们指定Spring Cloud Stream在将消息放置到死信队列之前应执行`3`次重试。第一次重试将在`500`毫秒后尝试，其余两次尝试将在`1000`毫秒后进行。
- en: Enabling the use of dead-letter queues is binding-specific; therefore, we have
    one configuration for RabbitMQ and one for Kafka.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 启用死信队列的使用是与绑定特定的；因此，我们有针对RabbitMQ和Kafka各一个配置。
- en: Guaranteed order and partitions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保证顺序和分区
- en: We can use partitions to ensure that messages are delivered in the same order
    as they were sent but without losing performance and scalability.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用分区来确保消息按发送顺序交付，同时不失去性能和可扩展性。
- en: If the business logic requires that messages are consumed and processed in the
    same order as they were sent, we cannot use multiple instances per consumer to
    increase processing performance; for example, we cannot use consumer groups. This
    might, in some cases, lead to an unacceptable latency in the processing of incoming
    messages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果业务逻辑要求消息按发送顺序被消费和处理，我们不能为了提高处理性能而使用每个消费者多个实例；例如，我们不能使用消费者组。在某些情况下，这可能导致处理传入消息时出现不可接受的延迟。
- en: In most cases, strict order in the processing of messages is only required for
    messages that affect the same business entities, for example, products.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，消息处理中的严格顺序仅对影响相同业务实体的消息 required，例如，产品。
- en: For example, messages affecting the product with product ID `1` can, in many
    cases, be processed independently of messages that affect the product with product
    ID `2`. This means that the order only needs to be guaranteed for messages that
    have the same product ID.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，影响产品ID为`1`的消息在很多情况下可以独立于影响产品ID为`2`的消息进行处理。这意味着只需要为具有相同产品ID的消息保证顺序。
- en: 'The solution to this is to make it possible to specify a key for each message
    that the messaging system can use in order to guarantee that the order is kept
    between messages with the same key. This can be solved by introducing sub-topics,
    also known as **partitions**, in a topic. The messaging system places messages
    in a specific partition based on its key. Messages with the same key are always
    placed in the same partition. The messaging system only needs to guarantee the
    delivery order for messages in one and the same partition. To ensure the order
    of the messages, we configure one consumer instance per partition within a consumer
    group. By increasing the number of partitions, we can allow a consumer to increase
    its number of instances. This increases its processing message performance without
    losing the delivery order. This is illustrated in the following  diagram:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决办法是，使其能够为每个消息指定一个键，消息传递系统可以使用该键来保证具有相同键的消息之间的顺序。这可以通过在主题中引入子主题（也称为**分区**）来解决。消息传递系统根据其键将消息放置在特定的分区中。具有相同键的消息总是放置在同一个分区中。消息传递系统只需要保证同一分区的消息的交付顺序。为了确保消息的顺序，我们在消费者组内的每个分区配置一个消费者实例。通过增加分区数，我们可以允许消费者增加其实例数。这在不失去交付顺序的情况下增加了其处理消息的性能。这在下面的图中说明：
- en: '![](img/2962fb3e-d606-4550-8328-c846114f8965.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2962fb3e-d606-4550-8328-c846114f8965.png)'
- en: 'In Spring Cloud Stream, this needs to be configured on both the publisher and
    consumer side. On the publisher side, the key and number of partitions must be
    specified. For example, for the `product-composite` service, we have the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Stream中，这需要在发布者和消费者双方进行配置。在发布者方面，必须指定键和分区数。例如，对于`product-composite`服务，我们有以下内容：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding configuration means that the key will be taken from the payload
    in the message using a field named `key` and that two partitions will be used.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置意味着将使用名为`key`的字段从消息负载中获取键，并使用两个分区。
- en: 'Each consumer can specify which partition it wants to consume messages from. For
    example, for the `product` microservice, we have the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消费者可以指定它想要接收消息的分区。例如，对于`product`微服务，我们有以下内容：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding configuration tells Spring Cloud Stream that this consumer will
    only consume messages from partition number `0`, that is, the first partition.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置告诉Spring Cloud Stream这个消费者只将接收来自分区编号`0`的消息，即第一个分区。
- en: Defining topics and events
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义主题和事件
- en: As we already mentioned in the *Spring Cloud Stream* section in [Chapter 2](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml),
    *Introduction to Spring Boot*, Spring Cloud Stream is based on the publishing
    and subscribe pattern, where a publisher publishes messages to topics and subscribers
    subscribe to topics they are interested in to receive messages.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml)的*Spring Cloud Stream*部分提到的，*Spring
    Boot入门*，Spring Cloud Stream基于发布和订阅模式，发布者将消息发布到主题，订阅者订阅他们感兴趣的主题以接收消息。
- en: We will use one **topic** per type of entity: `products`, `recommendations`, and `reviews`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每种类型的实体使用一个**主题**：`products`、`recommendations`和`reviews`。
- en: Messaging systems handle **messages** that typically consist of headers and
    a body. An **event** is a message that describes something that has happened.
    For events, the message body can be used to describe the type of event, the event
    data, and a timestamp for when the event occurred.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递系统处理**消息**，这些消息通常由标题和正文组成。**事件**是描述已经发生的事情的消息。对于事件，消息正文可以用来描述事件类型、事件数据以及事件发生的日期时间戳。
- en: 'An event is, for the scope of this book, defined by the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在本书的范围内由以下内容定义：
- en: The **type** of event, for example, create or delete an event
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件**类型**，例如，创建或删除事件
- en: A **key**, that identifies the data, for example, a product ID
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**键**，用于标识数据，例如，产品ID
- en: A **data** element, that is, the actual data in the event
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**数据**元素，即事件中的实际数据
- en: A **timestamp**, which describes when the event occurred
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**时间戳**，描述事件发生的时间
- en: 'The event class we will use looks as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的事件类如下所示：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s explain the preceding source code in detail:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释一下前面的源代码：
- en: The `Event` class is a generic class parameterized over the types of its `key`
    and `data` field, `K` and `T`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Event`类是一个泛型类，其`key`和`data`字段类型为`K`和`T`。'
- en: The event type is declared as an enumerator with the allowed values, that is, `CREATE`
    and `DELETE`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件类型被声明为一个枚举器，其允许的值是，即`CREATE`和`DELETE`。
- en: The class defines two constructors, one empty and one that can be used to initialize
    the type, key, and value members.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类定义了两个构造函数，一个空构造函数和一个可以用来初始化类型、键和值成员的构造函数。
- en: Finally, the class defines getter methods for its member variables.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这个类为其成员变量定义了getter方法。
- en: For the full source code, see the `se.magnus.api.event.Event` class in the `api`
    project.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅`api`项目中的`se.magnus.api.event.Event`类。
- en: Changes in the Gradle build files
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Gradle构建文件中的更改
- en: 'To bring in Spring Cloud Stream and its binders for RabbitMQ and Kafka, we
    need to add the two starter dependencies known as `spring-cloud-starter-stream-rabbit`
    and `spring-cloud-starter-stream-kafka`. We also need a test dependency, `spring-cloud-stream-test-support`,
    to bring in the test support. The following code shows this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入Spring Cloud Stream及其对RabbitMQ和Kafka的绑定器，我们需要添加两个启动依赖项，分别称为`spring-cloud-starter-stream-rabbit`和`spring-cloud-starter-stream-kafka`。我们还需要一个测试依赖项，`spring-cloud-stream-test-support`，以引入测试支持。下面的代码展示了这一点：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To specify what version of Spring Cloud that we want to use, we first declare
    a variable for the version:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定我们想要使用的Spring Cloud版本，我们首先声明一个版本变量的变量：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To wrap up setting up dependency management for that version, we use the following
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成那个版本的依赖管理设置，我们使用了以下代码：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the full source code, see the `build.gradle` build file in the `product-composite`
    project.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅`product-composite`项目中的`build.gradle`构建文件。
- en: Publishing events in the composite service
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在复合服务中发布事件
- en: 'When the composite service receives requests for the creation or deletion of
    products, it shall publish the corresponding events to the core services on their
    topics. To be able to publish events in the composite service, we need to perform
    the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当复合服务接收到创建或删除产品的请求时，它应将相应的事件发布到核心服务的主题上。为了能够在复合服务中发布事件，我们需要执行以下步骤：
- en: Declare message sources and publish events in the integration layer.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集成层声明消息源并发布事件。
- en: Add configuration for publishing events.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加发布事件的配置。
- en: Change our tests so that they can test the publishing of events.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们的测试，以便它们可以测试事件的发布。
- en: No changes are required in the composite service implementation class!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 复合服务实现类中不需要进行任何更改！
- en: Declaring message sources and publishing events in the integration layer
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集成层声明消息源并发布事件。
- en: 'To be able to publish events to different topics, we need to declare one `MessageChannel` per
    topic in a Java interface and also declare that we want to use it with an `EnableBinding` annotation.
    Let''s us see how to do this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将事件发布到不同的主题，我们需要在Java接口中声明一个`MessageChannel` per topic，并声明我们想要使用它与`EnableBinding`
    annotation。让我们看看如何做到这一点：
- en: 'We declare our message channels in the `MessageSources` interface in the `ProductCompositeIntegration` class
    and ask Spring to inject an instance of it in the constructor, as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`ProductCompositeIntegration`类中的`MessageSources`接口中声明我们的消息通道，并请求Spring在构造函数中注入它的一个实例，如下所示：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we want to publish an event on a topic, we use the injected `messageSources` object.
    For example, to send a delete event for a product, we can use the `outputProducts()` method
    to get a message channel for the product's topic and then use its `send()` method
    to publish an event.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在某个主题上发表一个事件时，我们会使用注入的`messageSources`对象。例如，要为一个产品发送一个删除事件，我们可以使用`outputProducts()`方法获取产品的主题的消息通道，然后使用其`send()`方法发布一个事件。
- en: 'To create the message that contains the event, we can use the built-in `MessageBuilder` class,
    as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建包含事件的消息，我们可以使用内置的`MessageBuilder`类，如下所示：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For the full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class
    in the `product-composite` project.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类。
- en: Adding configuration for publishing events
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加发布事件的配置
- en: 'We also need to set up a configuration for the messaging system to be able
    to publish events. To do this, we need to complete the following steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为消息系统设置一个配置，以便能够发布事件。为此，我们需要完成以下步骤：
- en: 'We declare that RabbitMQ is the default messaging system and that the default
    content type is JSON:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明RabbitMQ是默认的消息系统，默认的内容类型是JSON：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we bind our output channels to specific topic names, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的输出通道绑定到特定的主题名称，如下所示：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we declare connectivity information for both Kafka and RabbitMQ:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们声明了Kafka和RabbitMQ的连接信息：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the default Spring profile, we specify hostnames to be used when we run our
    system landscape without Docker on `localhost` with the IP address `127.0.0.1`.
    In the `docker` Spring profile, we specify the hostnames we will use when running
    in Docker and using Docker Compose, that is, `rabbitmq` and `kafka`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的Spring配置文件中，我们指定了当不使用Docker在`localhost`上运行我们的系统景观时使用的主机名，IP地址为`127.0.0.1`。在`docker`Spring配置文件中，我们指定了在Docker和Docker
    Compose中运行时将使用的主机名，即`rabbitmq`和`kafka`。
- en: For the full source code, see the `src/main/resources/application.yml` configuration
    file in the `product-composite` project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看完整的源代码，请查看`product-composite`项目中的`src/main/resources/application.yml`配置文件。
- en: Changes in the test code
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码的变化
- en: Testing asynchronous event-driven microservices is, by their nature, difficult.
    Tests typically need to synchronize on the asynchronous background processing
    in some way to be able to verify its result. Spring Cloud Stream comes with support,
    in terms of `TestSupportBinder`, for verifying what messages have been sent without
    using any messaging system during the tests!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异步事件驱动的微服务，按其性质来说，是困难的。测试通常需要以某种方式同步异步后台处理，以能够验证其结果。Spring Cloud Stream提供了支持，通过`TestSupportBinder`，在测试中不使用任何消息系统就可以验证发送了哪些消息！
- en: 'The test support includes a  `MessageCollector` helper class that can be used
    to get all the messages that were sent during a test. To see how it is done, check
    out these steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 测试支持包括一个`MessageCollector`助手类，可以用来获取测试期间发送的所有消息。要了解如何做到这一点，请查看以下步骤：
- en: 'In the `MessagingTests` test class, we set up a queue that can be used to inspect
    the messages that are sent to each topic, as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MessagingTests`测试类中，我们设置了一个队列，可以用来检查发送到每个主题的消息，如下所示：
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An actual test can verify the content in the queue like the following test
    can for the creation of a product:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个实际的测试可以验证队列中的内容，如下面的测试可以验证产品的创建：
- en: '[PRE35]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `receivesPayloadThat()` method is a static method in another test support
    class in Spring Cloud Stream, `MessageQueueMatcher`. This class contains a set
    of methods that simplify the verification of messages in a queue.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`receivesPayloadThat()`方法是Spring Cloud Stream中另一个测试支持类`MessageQueueMatcher`的静态方法。这个类包含了一组方法，可以简化队列中消息的验证。'
- en: The `sameEventExceptCreatedAt()` method is a static method in the `IsSameEvent`
    class that compares `Event` objects and treats them as equal if all the fields
    are equal, except for the `eventCreatedAt` field.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`sameEventExceptCreatedAt()`方法是`IsSameEvent`类中的一个静态方法，它比较`Event`对象，如果所有字段都相等，除了`eventCreatedAt`字段，则认为它们相等。'
- en: 'For the full source code, see the following test classes in the `product-composite`
    project:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看完整的源代码，请查看`product-composite`项目中的以下测试类：
- en: '`se.magnus.microservices.composite.product.MessagingTests`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.composite.product.MessagingTests`'
- en: '`se.magnus.microservices.composite.product.IsSameEvent`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.composite.product.IsSameEvent`'
- en: Consuming events in the core services
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在核心服务中消费事件
- en: 'To be able to consume events in the core services, we need to do the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在核心服务中消费事件，我们需要做以下事情：
- en: Declare message processors that listen for events on its topic.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明监听其主题上事件的消息处理器。
- en: Change our service implementations so it uses the reactive persistence layer
    correctly.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们的服务实现，使其正确使用反应式持久层。
- en: Add configuration for consuming events.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于消费事件的配置。
- en: Change our tests so that they can test the asynchronous processing of the events.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们的测试，使它们可以测试事件的异步处理。
- en: Declaring message processors
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明消息处理器
- en: 'The REST APIs for creating and deleting entities have been replaced with a
    message processor in each core microservice that listens for creating and deleting
    events on each entity''s topic. To be able to consume messages that have been
    published to a topic, we need to bind to `SubscribableChannel`, similar to how
    we bind to `MessageChannel` when we want to publish messages. Since each message
    processor only listens to one topic, we can use the built-in `Sink` interface
    to bind to that topic. We use the `EnableBinding` annotation to declare the use
    of the `Sink` interface, as shown in the following source code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和删除实体的REST API已经被每个核心微服务中的消息处理器所取代，该处理器监听每个实体主题上的创建和删除事件。为了能够消费已经发布到主题的消息，我们需要绑定到`SubscribableChannel`，这与我们想要发布消息时绑定到`MessageChannel`类似。由于每个消息处理器只监听一个主题，我们可以使用内置的`Sink`接口来绑定该主题。我们使用`EnableBinding`注解来声明使用`Sink`接口，如下所示：
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To actually consume and process messages, we can annotate a method with the
    `StreamListener` annotation, where we specify what channel we shall listen to:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际消费和处理消息，我们可以用`StreamListener` 注解标注一个方法，其中我们指定我们要监听哪个通道：
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The implementation of the `process()` method uses a `switch` statement to call
    the create method in the service component for creating events and the delete
    method for deleting events. The source code looks as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()`方法的实现使用一个`switch`语句来调用服务组件中的创建方法以创建事件和删除方法以删除事件。源代码如下所示：'
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s explain the preceding source code in detail:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释一下前面的源代码：
- en: The `switch` statement expects an event type that is either a `CREATE` or a
    `DELETE` event.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`语句期望一个事件类型，该事件类型是一个`CREATE`或`DELETE`事件。'
- en: The `productService.createProduct()` method is called for create events.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`productService.createProduct()` 方法用于创建事件。'
- en: The `productService.deleteProduct()` method is called for delete events.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`productService.deleteProduct()` 方法用于删除事件。'
- en: If the event type is neither a  `CREATE` or a `DELETE` event; an exception of
    the `EventProcessingException` type is thrown.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果事件类型既不是`CREATE`也不是`DELETE`事件；将抛出`EventProcessingException`类型的异常。
- en: 'The service component is injected as usual using constructor injection, as
    shown here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 服务组件像往常一样通过构造函数注入，如下所示：
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the full source code, see the following classes:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请查看以下类：
- en: '`se.magnus.microservices.core.product.services.MessageProcessor` in the `product`
    project'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.services.MessageProcessor` 在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.services.MessageProcessor` in
    the `recommendation` project'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.services.MessageProcessor` 在`recommendation`项目中'
- en: '`se.magnus.microservices.core.review.services.MessageProcessor` in the `review`
    project'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.services.MessageProcessor` 在`review`项目中'
- en: Changes in the service implementations
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现中的更改
- en: 'The service implementations of the create and delete methods for the `product`
    and `recommendation` service have been rewritten to use the non-blocking reactive
    persistence layer for MongoDB. For example, creating product entities is done
    as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`和`recommendation`服务的创建和删除方法的实现已重写，以使用非阻塞的反应式MongoDB持久层。例如，创建产品实体的操作如下所示：'
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `onErrorMap()` method is used to map the `DuplicateKeyException` persistence
    exception to our own `InvalidInputException` exception.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`onErrorMap()` 方法用于将`DuplicateKeyException` 持久化异常映射到我们自己的`InvalidInputException` 异常。'
- en: Since our message processor is based on a blocking programming model, we need
    to call the `block()` method on the returned `Mono` object from the persistence
    layer before we return it to the message processor. If we don't call the `block()` method,
    we won't be able to trigger the error handling in the messaging system if the
    processing in the service implementation fails; the event will not be requeued,
    and eventually, it will be moved to the dead-letter queue, as expected.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的消息处理程序基于阻塞编程模型，因此在我们将其返回给消息处理程序之前，需要在持久层返回的`Mono`对象上调用`block()`方法。如果我们不调用`block()`方法，如果在服务实现中处理失败，我们将无法触发消息系统中的错误处理；事件将不会重新入队，最终，它将被移动到死信队列中，如预期的那样。
- en: The `review` service that uses the blocking persistence layer for JPA, as before,
    does not need to be updated.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阻塞持久层`JPA`的`review`服务，如前所述，不需要更新。
- en: 'For the full source code, see the following classes:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请查看以下类：
- en: '`se.magnus.microservices.core.product.services.ProductServiceImpl` in the `product`
    project'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.services.ProductServiceImpl` 在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` in
    the `recommendation` project'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` 在`recommendation`项目中'
- en: Adding configuration for consuming events
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用于消费事件的配置
- en: We also need to set up the configuration for the messaging system, to be able
    to consume events; this is similar to what we did for the publisher. Declaring
    RabbitMQ as the default messaging system, JSON as the default content type, and
    Kafka and RabbitMQ for connectivity information is the same as for the publisher.
    Added to the common parts, the consumer configuration specifies consumer groups;
    retry handling and dead-letter queues are as they were described earlier in the
    *Configuring Spring Cloud Stream to handle challenges with messaging* section.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为消息系统设置配置，以便能够消费事件；这类似于我们对发布者所做的工作。将RabbitMQ声明为默认的消息系统，JSON作为默认内容类型，以及Kafka和RabbitMQ的连接信息与发布者相同。除了公共部分，消费者配置还指定了消费者组；重试处理和死信队列与之前在*配置Spring
    Cloud Stream以处理消息挑战*部分中描述的一致。
- en: 'For the full source code, see the following configuration files:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请查看以下配置文件：
- en: '`src/main/resources/application.yml` in the `product` project'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/resources/application.yml` 在`product`项目中'
- en: '`src/main/resources/application.yml` in the `recommendation` project'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/resources/application.yml` 在`recommendation`项目中'
- en: '`src/main/resources/application.yml` in the `review` project'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/resources/application.yml` 在`review`项目中'
- en: Changes in the test code
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码中的更改
- en: 'Since the core services now receive events for creating and deleting their
    entities, the tests need to be updated so that they send events instead of calling
    REST APIs, like they did previously. In the following source code, we can see
    how the `send()` method on the `input` method channel is used to send an event:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于核心服务现在接收创建和删除实体的事件，测试需要更新，以便它们发送事件而不是像以前那样调用REST API。在下面的源代码中，我们可以看到如何使用`input`方法通道的`send()`方法发送一个事件：
- en: '[PRE41]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `input` channel is set up by the test class before any tests are run. It
    is based on the same built-in `Sink` interface that the message processor uses.
    In the following source code, we can see how the `input` channel is created in
    the `setupDb()` method. Since the `setupDb()` method is annotated with `@Before`,
    it will run before any tests are executed:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`通道由测试类在运行任何测试之前设置。它基于与消息处理器使用的相同内置`Sink`接口。在下面的源代码中，我们可以看到`input`通道是在`setupDb()`方法中创建的。由于`setupDb()`方法用`@Before`注解，所以它将在执行任何测试之前运行：'
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This construction shortcuts the messaging system and the call to the `send()`
    method in the `input` channel will be processed synchronously by the message processor,
    that is, like a normal method call its `process()` method. This means that the
    test code doesn't need to implement any synchronization or *wait logic* for the
    asynchronous processing of an event. Instead, the test code can apply validation
    logic directly after calls to the `sendCreateProductEvent` and `sendDeleteProductEvent` send
    helper methods return.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造绕过了消息系统，`input`通道上的`send()`方法的调用将由消息处理器同步处理，也就是说，它的`process()`方法就像一个普通的方法调用。这意味着测试代码不需要为事件的异步处理实现任何同步或*等待逻辑*。相反，测试代码可以在调用`sendCreateProductEvent`和`sendDeleteProductEvent`发送助手方法返回后直接应用验证逻辑。
- en: 'For the full source code, see the following test classes:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请查看以下测试类：
- en: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` in the `product`
    project'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` 在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` in
    the `recommendation` project'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` 在`recommendation`项目中'
- en: '`se.magnus.microservices.core.review.ReviewServiceApplicationTests` in the `review`
    project'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.ReviewServiceApplicationTests` 在`review`项目中'
- en: Running manual tests of the reactive microservice landscape
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动测试反应式微服务架构
- en: Now, we have fully reactive microservices, both in terms of non-blocking synchronous
    REST APIs and event-driven asynchronous services. Let's try them out!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有完全反应式的微服务，无论是在非阻塞同步REST API还是在事件驱动的异步服务方面。让我们尝试一下它们！
- en: 'Three different configurations are prepared as follows, each in a separate
    Docker Compose file:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 准备了三种不同的配置，每个都在一个单独的Docker Compose文件中：
- en: Using RabbitMQ without the use of partitions
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不使用分区的RabbitMQ
- en: Using RabbitMQ with two partitions per topic
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用每个主题两个分区的RabbitMQ
- en: Using Kafka with two partitions per topic
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用每个主题两个分区的Kafka
- en: However, before testing these three configurations, we first need to simplify
    testing of the reactive microservice landscape. Once simplified, we can proceed
    with testing the microservices.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在测试这三个配置之前，我们首先需要简化对响应式微服务架构的测试。简化后，我们可以继续测试微服务。
- en: 'So accordingly, the following two features need to be checked:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要检查以下两个功能：
- en: Saving events for later inspection when using RabbitMQ
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RabbitMQ保存事件以供稍后检查。
- en: A health API that can be used to monitor the state of the landscape
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以用来监控景观状态的健康API。
- en: Saving events
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存事件。
- en: After running some tests on event-driven asynchronous services, it might be
    of interest to see what event was actually sent. When using Spring Cloud Stream
    with Kafka, events are retained in the topics, even after consumers have processed
    them. However, when using Spring Cloud Stream with RabbitMQ, the events are removed
    after they have been processed successfully.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在对事件驱动的异步服务进行一些测试后，可能会有兴趣查看实际发送了哪个事件。当使用Spring Cloud Stream和Kafka时，事件即使在消费者处理后也会保留在主题中。然而，当使用Spring
    Cloud Stream和RabbitMQ时，事件在成功处理后被移除。
- en: 'To be able to see what events have been published on each topic, Spring Cloud
    Stream is configured to save published events in a separate `auditGroup` consumer
    group per topic. For the `products` topic, the configuration looks like the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够查看每个主题上已经发布的事件，Spring Cloud Stream被配置为在每个主题上保存发布的事件到一个单独的`auditGroup`消费者组中。对于`products`主题，配置如下所示：
- en: '[PRE43]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When using RabbitMQ, this will result in extra queues being created where the
    events are stored for later inspection.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用RabbitMQ时，这将导致创建额外的队列，以便将事件存储以供稍后检查。
- en: For the full source code, see the `src/main/resources/application.yml` configuration
    file in the `product-composite` project.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅`product-composite`项目中的`src/main/resources/application.yml`配置文件。
- en: Adding a health API
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加健康API。
- en: Testing a system landscape of microservices that use a combination of synchronous
    APIs and asynchronous messaging is challenging. For example, how do we know when
    a newly started landscape of microservices, together with their databases and
    messaging system, are ready to process requests and messages?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用同步API和异步消息传递的微服务系统架构是具有挑战性的。例如，我们如何知道一个新启动的微服务架构（及其数据库和消息系统）是否准备好处理请求和消息？
- en: To make it easier to know when all the microservices are ready to process requests
    and messages, we have added a health API in all the microservices. They are based
    on the support for health endpoints that comes with the Spring Boot module known
    as the Actuator. By default, a `health` endpoint based on the Actuator answers
    `UP` (and gives 200 as the HTTP return status) if the microservice itself and
    all the dependencies Spring Boot knows about are available, for example, dependencies
    to databases and messaging systems; otherwise, the health endpoint answers `DOWN` (and
    returns 500 as the HTTP return status).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地知道所有微服务是否准备好处理请求和消息，我们在所有微服务中添加了一个健康API。它们基于Spring Boot模块中名为Actuator的支持健康端点的支持。默认情况下，基于Actuator的健康端点回答`UP`（并给出200作为HTTP返回状态）如果微服务本身以及Spring
    Boot知道的所有的依赖项都可用，例如，对数据库和消息系统的依赖；否则，健康端点回答`DOWN`（并返回500作为HTTP返回状态）。
- en: We can also extend the `health` endpoint to cover dependencies that Spring Boot
    is not aware of. We will use this feature to extend to the product composite's
    `health` endpoint, which will also include the health of the three core services.
    This means that the product composite `health` endpoint will only respond with
    `UP` if itself and the three core microservices are healthy. This can be used
    either manually or automatically by the `test-em-all.bash` script to find out
    when all the microservices and their dependencies are up and running.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展`health`端点以覆盖Spring Boot不知道的依赖项。我们将使用这个特性来扩展产品组合的`health`端点，这也将包括三个核心服务的健康状况。这意味着产品组合的`health`端点只会在自身和三个核心微服务都健康的情况下回答`UP`。这可以手动或自动地由`test-em-all.bash`脚本来使用，以找出所有微服务及其依赖项是否都已启动并运行。
- en: 'In the `ProductCompositeIntegration` integration class, we have added helper
    methods for checking the health of the three core microservices, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductCompositeIntegration`集成类中，我们添加了用于检查三个核心微服务健康状况的帮助方法，如下所示：
- en: '[PRE44]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code is similar to the code we used previously to call the core services
    to read APIs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前用于调用核心服务以读取API的代码相似。
- en: For the full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class
    in the `product-composite` project.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整源代码，请参阅 `product-composite` 项目中的 `se.magnus.microservices.composite.product.services.ProductCompositeIntegration`
    类。
- en: 'In the main `ProductCompositeServiceApplication` application class, we use
    these helper methods to register three health checks, one for each core microservice:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 `ProductCompositeServiceApplication` 应用程序类中，我们使用这些辅助方法注册三个健康检查，每个核心微服务一个：
- en: '[PRE45]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For the full source code, see the `se.magnus.microservices.composite.product.ProductCompositeServiceApplication` class
    in the `product-composite` project.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整源代码，请参阅 `product-composite` 项目中的 `se.magnus.microservices.composite.product.ProductCompositeServiceApplication`
    类。
- en: 'Finally, in the `application.yml` file of all four microservices, we configure
    the Spring Boot Actuator so that it does the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在所有四个微服务的 `application.yml` 文件中，我们配置了 Spring Boot Actuator，使其执行以下操作：
- en: Show details about the state of health, which not only includes `UP` or `DOWN`,
    but also information about its dependencies
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示有关健康状态的详细信息，这不仅包括 `UP` 或 `DOWN`，还包括有关其依赖项的信息：
- en: Expose all its endpoints over HTTP
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 HTTP 暴露其所有端点：
- en: 'The configuration for these two settings looks as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个设置的配置如下所示：
- en: '[PRE46]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For an example of the full source code, see the `src/main/resources/application.yml` configuration
    file in the `product-composite` project.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整源代码的示例，请参阅 `product-composite` 项目中的 `src/main/resources/application.yml`
    配置文件。
- en: '**WARNING**: These configuration settings are good during development, but
    it can be a security issue to reveal too much information in actuator endpoints
    in production systems. Therefore, plan for minimizing the information exposed
    by the actuator endpoints in production!'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：这些配置设置在开发过程中很好，但在生产系统中暴露太多信息在 actuator 端点上可能是一个安全问题。因此，计划最小化在生产中 actuator
    端点暴露的信息！'
- en: 'For details regarding the endpoints that are exposed by Spring Boot Actuator,
    see [https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有关由 Spring Boot Actuator 暴露的端点的详细信息，请参阅 [https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html)：
- en: 'Try it out (when you have all the microservices up and running using Docker
    Compose, as described in the next section):'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一下（当你使用 Docker Compose 启动所有微服务时，如下一节所述）：
- en: '[PRE47]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will result in the following response:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将导致以下响应：
- en: '![](img/2ae85fa6-c021-4370-9850-fb6daec78d0c.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ae85fa6-c021-4370-9850-fb6daec78d0c.png)'
- en: In the preceding output, we can see that the composite service reports that
    it is healthy, that is, its status is `UP`. At the end of the response, we can
    see that all three core microservices are also reported as healthy.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到复合服务报告它是健康的，即它的状态是 `UP`。在响应的末尾，我们可以看到三个核心微服务也被报告为健康。
- en: With a health API in place, we are ready to test our reactive microservices.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有了健康 API，我们就准备好测试我们的反应式微服务了。
- en: Using RabbitMQ without using partitions
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不使用分区来使用 RabbitMQ：
- en: In this section, we will test the reactive microservices together with RabbitMQ
    but without using partitions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试与 RabbitMQ 一起使用的反应式微服务，但不用分区。
- en: 'The default `docker-compose.yml` Docker Compose file is used in this configuration.
    The following changes have been applied to the file:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中使用默认的 `docker-compose.yml` Docker Compose 文件。已对文件应用了以下更改：
- en: 'RabbitMQ has been added, as shown here:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RabbitMQ** 已经被添加，如图所示：'
- en: '[PRE48]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The microservices now have a dependency declared to the RabbitMQ service. This
    means that Docker will not start the microservice containers until the RabbitMQ
    service is reported to be healthy:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务现在对 RabbitMQ 服务有了依赖声明。这意味着 Docker 不会启动微服务容器，直到 RabbitMQ 服务被报告为健康：
- en: '[PRE49]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To run our tests, perform the following steps:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的测试，请执行以下步骤：
- en: 'Build and start the system landscape with the following commands:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建并启动系统架构：
- en: '[PRE50]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we have to wait for the microservice landscape to be up and running.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须等待微服务架构运行起来。
- en: 'Try running the following command a few times:'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试运行以下命令几次：
- en: '[PRE51]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When it returns `UP`, we are ready to run our tests!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当它返回 `UP` 时，我们就准备好运行我们的测试了！
- en: 'First, create a composite product with the following commands:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令创建一个复合产品：
- en: '[PRE52]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When using Spring Cloud Stream together with RabbitMQ, it will create one RabbitMQ
    exchange per topic and a set of queues, depending on our configuration.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring Cloud Stream与RabbitMQ一起使用时，它将根据我们的配置为每个主题创建一个RabbitMQ交换和一个队列集。
- en: Let's see what queues that Spring Cloud Stream has created for us!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 看看Spring Cloud Stream为我们创建了哪些队列吧！
- en: 'Open the following URL in a web browser: `http://localhost:15672/#/queues`.
    You should see the following queues:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开以下URL：`http://localhost:15672/#/queues`。你应该看到以下队列：
- en: '![](img/00372e65-3efd-4733-8c3a-773b383cde7e.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00372e65-3efd-4733-8c3a-773b383cde7e.png)'
- en: For each topic, we can see one queue for auditGroup, one for the consumer group
    that's used by the corresponding core microservice, and one dead-letter queue.
    We can also see that the auditGroup queues contain messages, as expected!
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个主题，我们可以看到一个auditGroup队列，一个由相应核心微服务使用的消费者组队列，以及一个死信队列。我们还可以看到auditGroup队列中包含消息，正如我们所期望的那样！
- en: 'Click on the products.auditGroup queue and scroll down to Get Message(s), expand
    it, and click on the button named Get Message(s) to see the message in the queue:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`products.auditGroup`队列，向下滚动到Get Message(s)，展开它，然后点击名为Get Message(s)的按钮查看队列中的消息：
- en: '![](img/1ce813e3-39eb-4b9a-a69e-b2d4f0a6be85.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ce813e3-39eb-4b9a-a69e-b2d4f0a6be85.png)'
- en: 'Next, try to get the product composite using the following code:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试使用以下代码获取产品组合：
- en: '[PRE53]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, delete it, like so:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，像这样删除它：
- en: '[PRE54]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Trying to get the deleted product again should result in a `404 - "NotFound"`
    response!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 试图再次获取已删除的产品应该会导致一个`404 - "NotFound"`的响应！
- en: If you look in the RabbitMQ audit queues again, you should be able to find new
    messages containing delete events.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看RabbitMQ审计队列，你应该能够找到包含删除事件的新消息。
- en: 'Wrap up the test by bringing down the microservice landscape with the following
    command:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令结束测试，关闭微服务架构：
- en: '[PRE55]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This completes the tests where we use RabbitMQ without partitions. Now, let's
    move on and test RabbitMQ with partitions.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们使用没有分区的RabbitMQ的测试。现在，让我们继续测试带有分区的RabbitMQ。
- en: Using RabbitMQ with two partitions per topic
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用每个主题两个分区的RabbitMQ
- en: Now, let's try out the partitioning support in Spring Cloud Stream!
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一下Spring Cloud Stream中的分区支持！
- en: 'We have a separate Docker Compose file prepared for using RabbitMQ with two
    partitions per topic: `docker-compose-partitions.yml`. It will also start two
    instances per core microservice, one for each partition. For example, a second
    `product` instance is configured as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为使用每个主题两个分区的RabbitMQ准备了一个单独的Docker Compose文件：`docker-compose-partitions.yml`。它还将为每个核心微服务启动两个实例，每个分区一个。例如，第二个`product`实例的配置如下：
- en: '[PRE56]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述源代码的解释：
- en: We use the same source code and Dockerfile that we did for the first `product`
    instance but configure them differently.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用与第一个`product`实例相同的源代码和Dockerfile，但它们进行了不同的配置。
- en: Specifically, we assign the two `product` instances to different partitions
    using the `instance-index` property we described earlier in this chapter.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体来说，我们将两个`product`实例分配到不同的分区，使用的是我们本章前面描述的`instance-index`属性。
- en: When using system environment variables to specify Spring properties, we must
    use an uppercase format where dots are replaced with underscores.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用系统环境变量来指定Spring属性时，我们必须使用大写字母格式，其中点被下划线替换。
- en: This `product` instance will only process asynchronous events; it will not respond
    to API calls. Since it has a different name, `product-p1` (also used as its DNS
    name), it will not respond to calls to a URL starting with `http://product:8080`.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个`product`实例只处理异步事件；它不会响应API调用。由于它的名称不同，`product-p1`（也用作其DNS名称），所以它不会响应以`http://product:8080`开头的URL调用。
- en: 'Start up the microservice landscape with the following command:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动`microservice landscape`：
- en: '[PRE57]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Repeat the tests from the previous section but also create a product with the
    product ID set to `2`. If you take a look into the queues set up by Spring Cloud
    Stream, you will see one queue per partition and that the product audit queues
    now contain one message each, that is, the event for product ID `1` was placed
    in one partition and the event for product ID `2` was placed in the other partition.
    If you go back to `http://localhost:15672/#/queues` in your web browser, you should
    see something like the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 重复前一部分的测试，但也要创建一个产品ID设置为`2`的产品。如果你查看Spring Cloud Stream设置的队列，你会看到每个分区有一个队列，并且产品审计队列现在每个都包含一个消息，即产品ID
    `1`的事件放在一个分区的，而产品ID `2`的事件放在另一个分区的。如果你回到浏览器中的`http://localhost:15672/#/queues`，你应该会看到类似以下的内容：
- en: '![](img/4d333160-75e8-4a56-87f6-aeee8765402e.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d333160-75e8-4a56-87f6-aeee8765402e.png)'
- en: 'To end the test with RabbitMQ using partitions, bring down the microservice
    landscape with the following command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束使用分区的RabbitMQ测试，请使用以下命令关闭微服务架构：
- en: '[PRE58]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are now done with tests using RabbitMQ, both with and without partitions.
    The final test configuration we shall try out is testing the microservices together
    with Kafka.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了使用RabbitMQ的测试，包括有分区和没有分区的情况。我们将尝试的最后一种测试配置是同时测试微服务与Kafka。
- en: Using Netflix Eureka as a discovery service
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netflix Eureka作为发现服务
- en: A discovery service is probably the most important support function required
    to make a landscape of cooperating microservices production-ready. As we already
    described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, in the *Service discovery* section, a discovery service can
    be used to keep track of existing microservices and their instances. The first discovery
    service that Spring Cloud supported was *Netflix Eureka***.**
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 发现服务可能是使一组合作的微服务生产就绪所需的最重要的支持功能。正如我们在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)、*微服务介绍*中的*服务发现*部分已经描述的，服务发现服务可以用来跟踪现有的微服务和它们实例。Spring
    Cloud支持的第一个发现服务是*Netflix Eureka*。
- en: We will use this in [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml),
    *Adding Service Discovery Using Netflix Eureka and Ribbon**,* along with aload
    balancer and the new Spring Cloud load balancer.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)、*使用Netflix Eureka和Ribbon添加服务发现*中使用这个，以及负载均衡器和新的Spring
    Cloud负载均衡器。
- en: We will see how easy it is to register microservices with Netflix Eureka when
    using Spring Cloud, and as a client sends HTTP requests such as a call to a RESTful
    API to one of the instances registered in Netflix Eureka. We will also see how
    to scale up the number of instances of a microservice, and how requests to a microservice
    will be load-balanced over its available instances (based on, by default, round-robin
    scheduling).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到在使用Spring Cloud时注册微服务有多么简单，以及当客户端发送HTTP请求（例如对注册在Netflix Eureka中的一个实例的RESTful
    API的调用）时会发生什么。我们还将了解如何扩展微服务的实例数量，以及如何将请求负载均衡到微服务的可用实例上（基于，默认情况下，轮询调度）。
- en: 'The following screenshot demonstrates the web UI from Eureka, where we can
    see what microservices we have registered:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕快照展示了Eureka的网页用户界面，我们可以看到我们已经注册了哪些微服务：
- en: '![](img/9d6bf02d-f466-40cf-9bf1-140cbf7d1766.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d6bf02d-f466-40cf-9bf1-140cbf7d1766.png)'
- en: The review service has three instances available, while the other two services
    only have one instance each.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 评论服务有三个实例可用，而其他两个服务只有一个实例。
- en: With Netflix Eureka introduced, let's introduce how to use Spring Cloud Gateway
    as an edge server.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Netflix Eureka的引入，让我们介绍一下如何使用Spring Cloud Gateway作为边缘服务器。
- en: Using Kafka with two partitions per topic
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用每个主题两个分区的Kafka
- en: 'Now, we shall try out a very cool feature of Spring Cloud Stream: changing
    the messaging system from RabbitMQ to Apache Kafka!'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试Spring Cloud Stream的一个非常酷的功能：将消息系统从RabbitMQ更改为Apache Kafka！
- en: 'This can be done simply by changing the value of the `spring.cloud.stream.defaultBinder` property
    from `rabbit` to `kafka`. This is handled by the `docker-compose-kafka.yml` Docker
    Compose file that has also replaced RabbitMQ with Kafka and Zookeeper. The configuration
    of Kafka and Zookeeper looks as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将`spring.cloud.stream.defaultBinder`属性的值从`rabbit`更改为`kafka`来简单实现。这由`docker-compose-kafka.yml`Docker
    Compose文件处理，该文件也将RabbitMQ替换为Kafka和Zookeeper。Kafka和Zookeeper的配置如下所示：
- en: '[PRE59]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Kafka is also configured to use two partitions per topic, and like before, we
    start up two instances per core microservice, one for each partition. See the
    Docker Compose file, `docker-compose-kafka.yml`, for details!
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka还配置为每个主题使用两个分区，像以前一样，我们为每个核心微服务启动两个实例，每个分区一个。详情请查看Docker Compose文件`docker-compose-kafka.yml`！
- en: 'Start up the microservice landscape with the following command:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动微服务架构：
- en: '[PRE60]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Repeat the tests from the previous section, for example, create two products,
    one with the product ID set to `1`, and one with the product ID set to `2`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 重复上一节的测试，例如，创建两个产品，一个产品ID设置为`1`，另一个产品ID设置为`2`。
- en: Unfortunately, Kafka doesn't come with any graphical tools that can be used
    to inspect topics, partitions, and the messages that are placed within them. Instead,
    we can run CLI commands in the Kafka Docker container.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Kafka没有附带任何可以用来检查主题、分区以及其中的消息的图形工具。相反，我们可以在Kafka Docker容器中运行CLI命令。
- en: 'To see a list of topics, run the following command:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看主题列表，请运行以下命令：
- en: '[PRE61]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Expect an output like the one shown here:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '![](img/824bee38-2547-4e15-9c1f-d4a7550eb6a0.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/824bee38-2547-4e15-9c1f-d4a7550eb6a0.png)'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面源代码的解释：
- en: The topics prefixed with `error` are the topics corresponding to dead-letter
    queues.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀为`error`的主题是对应于死信队列的主题。
- en: You will not find any `auditGroup` in the case of RabbitMQ; instead, all messages
    the are available in the topics for any consumer to process.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RabbitMQ的情况下，你找不到`auditGroup`；相反，所有消息都可供任何消费者处理。
- en: 'To see the partitions in a specific topic, for example, the `products` topic,
    run the following command:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看特定主题的分区，例如`products`主题，请运行以下命令：
- en: '[PRE62]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Expect an output like the one shown here:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '![](img/0ba3ea90-0eb6-49b9-94f2-71b377357e60.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ba3ea90-0eb6-49b9-94f2-71b377357e60.png)'
- en: 'To see all the messages in a specific topic, for example, the `products` topic, run
    the following command:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看特定主题的所有消息，例如`products`主题，请运行以下命令：
- en: '[PRE63]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Expect an output like the one shown here:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '![](img/7570391d-189e-4c89-b544-547f054cfc71.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7570391d-189e-4c89-b544-547f054cfc71.png)'
- en: 'To see all the messages in a specific partition, for example, partition `1`
    in the `products` topic, run the following command:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看特定分区的所有消息，例如`products`主题中的分区`1`，请运行以下命令：
- en: '[PRE64]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Expect an output like the one shown here:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '![](img/9dd71100-be1f-4d1c-b3aa-06094d47fe58.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dd71100-be1f-4d1c-b3aa-06094d47fe58.png)'
- en: The output will end with a timeout exception since we stop the command by specifying
    a timeout for the command of `1000` ms.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将以超时异常结束，因为我们通过指定`1000`毫秒的命令超时来停止命令。
- en: 'Bring down the microservice landscape with the following command:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令关闭微服务架构：
- en: '[PRE65]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, we have learned how Spring Cloud Stream can be used to switch a message
    broker from RabbitMQ to Kafka without requiring any changes in the source code.
    It just requires a few changes in the Docker Compose file.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解到如何使用Spring Cloud Stream将消息代理从RabbitMQ切换到Kafka，而无需更改源代码。它只需要在Docker
    Compose文件中进行一些更改。
- en: Running automated tests of the reactive microservice landscape
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式微服务架构的自动化测试
- en: 'To be able to run tests of the reactive microservice landscape automatically
    instead of manually, the automated `test-em-all.bash` test script has been enhanced.
    The most important changes are as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够自动运行反应式微服务架构的测试，而不是手动运行，自动`test-em-all.bash`测试脚本已经得到增强。最重要的变化如下：
- en: 'The script uses the new `health` endpoint to know when the microservice landscape
    is operational, as shown here:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本使用新的`health`端点来了解微服务架构何时运行正常，如下所示：
- en: '[PRE66]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The script has a new `waitForMessageProcessing()` function, which is called
    after the test data is set up. Its purpose is simply to wait for the creation
    of the test data to be completed by the asynchronous create services.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本有一个新的`waitForMessageProcessing()`函数，它在测试数据设置后调用。它的目的是简单地等待异步创建服务完成测试数据的创建。
- en: 'To use the test script to automatically run the tests with RabbitMQ and Kafka,
    perform the following steps:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用测试脚本自动运行与RabbitMQ和Kafka相关的测试，请执行以下步骤：
- en: 'Run the tests using the default Docker Compose file, that is, with RabbitMQ
    without partitions, with the following commands:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认的Docker Compose文件运行测试，即不使用RabbitMQ分区，使用以下命令：
- en: '[PRE67]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the tests for RabbitMQ with two partitions per topic using the Docker Compose `docker-compose-partitions.yml` file
    with the following commands:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行带有两个分区的RabbitMQ测试：
- en: '[PRE68]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, run the tests with Kafka and two partitions per topic using the Docker
    Compose `docker-compose-kafka.yml` file with the following commands:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令运行带有Kafka和每个主题两个分区的测试：
- en: '[PRE69]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this section, we have learned how to use the `test-em-all.bash` test script
    to automatically run tests of the reactive microservice landscape that have been
    either configured to use RabbitMQ or Kafka as its message broker.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用`test-em-all.bash`测试脚本自动运行使用RabbitMQ或Kafka作为消息代理配置的反应式微服务架构的测试。
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how we can develop reactive microservices!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了我们如何可以开发反应式微服务！
- en: Using Spring WebFlux and Spring WebClient, we can develop non-blocking synchronous
    APIs that can handle incoming HTTP requests and send outgoing HTTP requests without
    blocking any threads. Using Spring Data's reactive support for MongoDB, we can
    also access MongoDB databases in a non-blocking way, that is, without blocking
    any threads while waiting for responses from the database. Spring WebFlux, Spring
    WebClient, and Spring Data rely on Spring Reactor to provide their reactive and
    non-blocking features. When we must use blocking code, for example, when using
    Spring Data for JPA, we can encapsulate the processing of the blocking code by
    scheduling the processing of it in a dedicated thread pool.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring WebFlux和Spring WebClient，我们可以开发非阻塞同步API，这些API可以处理传入的HTTP请求并发送非阻塞线程的出站HTTP请求。利用Spring
    Data对MongoDB的反应式支持，我们还可以以非阻塞方式访问MongoDB数据库，即在等待数据库响应时不会阻塞任何线程。Spring WebFlux、Spring
    WebClient和Spring Data依赖于Spring Reactor提供它们的反应式和非阻塞特性。当我们必须使用阻塞代码时，例如在使用Spring
    Data for JPA时，我们可以通过在专用线程池中安排处理来封装阻塞代码的处理。
- en: We have also seen how Spring Data Stream can be used to develop event-driven
    asynchronous services that work on both RabbitMQ and Kafka as messing systems
    without requiring any changes in the code. By doing some configuration, we can
    use features in Spring Cloud Stream such as consumer groups, retries, dead-letter
    queues, and partitions to handle the various challenges of asynchronous messaging.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了Spring Data Stream如何用于开发既适用于RabbitMQ又适用于Kafka作为消息系统的基于事件的异步服务，而无需更改代码。通过进行一些配置，我们可以使用Spring
    Cloud Stream中的特性，如消费者组、重试、死信队列和分区，以处理异步消息的各种挑战。
- en: We have also learned how to manually and automatically test a system landscape
    consisting of reactive microservices.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何手动和自动测试由反应式微服务组成的系统架构。
- en: This was the final chapter on how to use fundamental features in Spring Boot
    and Spring Framework.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于如何在Spring Boot和Spring Framework中使用基本特性的最后一章。
- en: Next up is an introduction to Spring Cloud and how it can be used to make our
    services production-ready, scalable, robust, configurable, secure, and resilient!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将介绍Spring Cloud以及如何使用它来使我们的服务达到生产级、可扩展、健壮、可配置、安全和有弹性！
- en: Questions
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it important to know how to develop reactive microservices?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么知道如何开发反应式微服务很重要？
- en: How do you choose between non-blocking synchronous APIs and event/message-driven
    asynchronous services?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何选择非阻塞同步API和事件/消息驱动的异步服务？
- en: What makes a message different from an event?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息与事件有什么不同？
- en: Name some challenges with message-driven asynchronous services. How do we handle
    them?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出一些消息驱动异步服务的挑战。我们如何处理它们？
- en: Why is the following test failing?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下测试失败？
- en: '[PRE70]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: What are the challenges of writing tests with reactive code using JUnit, and
    how can we handle them?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JUnit编写反应式代码的测试时面临哪些挑战，我们该如何应对？
