- en: Connecting to SQL Databases Using JDBC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JDBC 连接到 SQL 数据库
- en: Managing information means performing operations such as storing, modifying,
    removing, sorting, arranging, linking, and matching data in a data store. Database
    management systems provide the means to perform these operations and relational
    databases are the most common type of data store used with web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 管理信息意味着在数据存储中执行诸如存储、修改、删除、排序、排列、链接和匹配数据等操作。数据库管理系统提供了执行这些操作的手段，而关系数据库是用于 Web
    应用程序的最常见的数据存储类型。
- en: This chapter starts by briefly discussing the fundamental Java technology for
    persistence, **Java Database Connectivity** (**JDBC**). We will learn how to connect
    and how to consume data from a relational database using connection pools and
    SQL queries. We will also describe the concept of a *data repository*, a way of
    encapsulating persistence implementation details.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先简要讨论了持久化的基本 Java 技术，**Java 数据库连接**（**JDBC**）。我们将学习如何连接以及如何使用连接池和 SQL 查询从关系数据库中获取数据。我们还将描述
    *数据存储库* 的概念，这是一种封装持久化实现细节的方法。
- en: We will develop a very simple web UI that lists data from a database. The purpose
    of the example is to show you the very fundamentals of database connectivity.
    [Chapter 6](9a3c93d4-374e-4324-9201-1d446093fef3.xhtml), *Connecting to SQL Databases
    Using ORM Frameworks*, will focus on more advanced database operations with basic
    data binding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个非常简单的 Web UI，列出数据库中的数据。这个示例的目的是向您展示数据库连接的基本原理。[第 6 章](9a3c93d4-374e-4324-9201-1d446093fef3.xhtml)，*使用
    ORM 框架连接 SQL 数据库*，将专注于更高级的数据库操作和基本数据绑定。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: JDBC technology
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC 技术
- en: JDBC drivers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC 驱动程序
- en: Connection pools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池
- en: SQL query execution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 查询执行
- en: Data repositories
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储库
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要拥有 Java SE 开发工具包和 Java EE SDK 版本 8 或更高版本。你还需要 Maven 版本 3 或更高版本。建议使用具有 Maven
    支持的 Java IDE，例如 IntelliJ IDEA、Eclipse 或 NetBeans。最后，为了使用本书的 Git 仓库，你需要安装 Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-05](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-05)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-05](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-05)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[https://goo.gl/7VonXg](https://goo.gl/7VonXg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/7VonXg](https://goo.gl/7VonXg)'
- en: Introduction to JDBC
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDBC 简介
- en: If you have developed *business applications* with Java, you have most likely
    used JDBC directly or indirectly(through an object-relational mapping framework)
    to connect and use relational databases. A *relational database* is a system for
    storing information in a tabular form; that is, in tables. There are many vendors
    offering free and commercial **relational database management systems** (**RDBMS**).
    Two of the most popular open source RDBMS are *PostgreSQL* and *MySQL*, while
    *Oracle Database* and *Microsoft SQL Server* are well-known options among the
    commercial ones. These systems understand the **Structured Query Language** (**SQL**),
    a *declarative language* used to perform tasks such as adding or deleting rows
    in a table.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Java 开发了 *商业应用程序*，你很可能直接或间接（通过对象关系映射框架）使用了 JDBC 来连接和使用关系数据库。*关系数据库* 是一种以表格形式存储信息的系统；也就是说，在表格中。有许多供应商提供免费和商业的
    **关系数据库管理系统**（**RDBMS**）。最受欢迎的两个开源 RDBMS 是 *PostgreSQL* 和 *MySQL*，而 *Oracle 数据库*
    和 *Microsoft SQL Server* 在商业产品中是知名的选择。这些系统理解 **结构化查询语言**（**SQL**），这是一种用于执行诸如在表中添加或删除行等任务的
    *声明性语言*。
- en: When using a **declarative language**, you specify *what* you want the program
    to do. In contrast, when using an **imperative language**, such as the Java programming
    language, you specify *how* to do it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 **声明性语言** 时，你指定程序需要做什么。相比之下，当使用 **命令性语言**，例如 Java 编程语言时，你指定如何做。
- en: 'Before we get started with the actual code, try compiling and running the example
    application located in the `Data-centric-Applications-with-Vaadin-8/chapter-05`
    Maven module. Follow these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际代码之前，尝试编译并运行位于`Data-centric-Applications-with-Vaadin-8/chapter-05` Maven模块中的示例应用程序。按照以下步骤操作：
- en: If you haven't done so, import the `Data-centric-Applications-with-Vaadin-8`
    Maven project into your IDE.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，将`Data-centric-Applications-with-Vaadin-8` Maven项目导入到您的IDE中。
- en: 'Create a *running configuration* for the `packt.vaadin.datacentric.chapter05.jdbc.H2Server`
    class and run it. This is your database server. It runs in a separate process
    in your computer. Alternatively, you can run the H2 server with Maven from the
    `chapter-05` directory: `mvn test exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.H2Server"`.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`packt.vaadin.datacentric.chapter05.jdbc.H2Server`类创建一个运行配置并运行它。这是您的数据库服务器。它在您的计算机上的一个单独进程中运行。或者，您可以从`chapter-05`目录使用Maven运行H2服务器：`mvn
    test exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.H2Server"`。
- en: 'Create a running configuration for the `packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization`
    class and run it. You should see an initialization succeeded message in the log.
    This initialization creates a new table (`messages`) in the database, and adds
    some demo rows to it. Alternatively, you can run the initialization application
    with Maven: `mvn exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization"`.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization`类创建一个运行配置并运行它。您应该在日志中看到一个初始化成功的消息。此初始化在数据库中创建了一个新的表（`messages`），并向其中添加了一些演示行。或者，您可以使用Maven运行初始化应用程序：`mvn
    exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization"`。
- en: Create a running configuration for the Jetty Maven Plugin in the `chapter-05`
    module.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter-05`模块中为Jetty Maven插件创建一个运行配置。
- en: Point your browser to `http://localhost:8080`. You should see some demo data
    rendered by a Vaadin application.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的浏览器指向`http://localhost:8080`。您应该会看到由Vaadin应用程序渲染的一些演示数据。
- en: 'The H2 server we started in step 2 starts also a web application you can use
    to run SQL queries. Let''s try it! Point your browser to `http://localhost:8082`
    and connect using the following configuration:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤2中启动的H2服务器还启动了一个您可以使用它来运行SQL查询的Web应用程序。让我们试试！将您的浏览器指向`http://localhost:8082`并使用以下配置进行连接：
- en: '![](img/0900594a-2c00-49a9-977a-176d67fc9eb3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0900594a-2c00-49a9-977a-176d67fc9eb3.png)'
- en: 'Insert a new row into the `messages` table by executing the following SQL statement:
    `INSERT INTO messages VALUES(''Welcome to JDBC!'')`.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下SQL语句将新行插入到`messages`表中：`INSERT INTO messages VALUES('Welcome to JDBC!')`。
- en: 'Point your browser to (or reload) the Vaadin application. You should see the
    new message listed there:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的浏览器指向（或重新加载）Vaadin应用程序。您应该会看到那里列出了新消息：
- en: '![](img/e8dbea3b-1e2c-420d-a407-f06490e4d521.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8dbea3b-1e2c-420d-a407-f06490e4d521.png)'
- en: If you want to, you can stop the Vaadin application and the H2 server, and run
    them again. You should see all the same data as before, including the newly inserted
    row. Just keep in mind that you need to run the H2 server first!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以停止Vaadin应用程序和H2服务器，然后再次运行它们。您应该看到与之前相同的所有数据，包括新插入的行。只需记住，您需要首先运行H2服务器！
- en: If you are curious, the location of the actual H2 database file is `<home-directory>/h2-databases/demo.mv.db`.
    You can delete this file and run the `DatabaseInitialization` application again
    if you want to recreate the initial state of the database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，实际的H2数据库文件位置是`<home-directory>/h2-databases/demo.mv.db`。如果您想重新创建数据库的初始状态，可以删除此文件并再次运行`DatabaseInitialization`应用程序。
- en: The **Java Database Connectivity** (**JDBC**) **API** enables your applications
    to connect to an RDBMS and make SQL calls to it. Other technologies for SQL persistence
    are usually implemented on top of the JDBC. Understanding the key aspects of JDBC
    will make your life easier even if you are planning (or if you are already using)
    other persistence technologies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java数据库连接**（**JDBC**）**API**使您的应用程序能够连接到关系型数据库管理系统（RDBMS）并向其发出SQL调用。其他SQL持久化技术通常是在JDBC之上实现的。了解JDBC的关键方面将使您在使用其他持久化技术（即使您计划使用或已经使用）时生活更加轻松。'
- en: 'Typically, your application should perform five steps in order to use a database
    with the JDBC API:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您的应用程序应该按照以下五个步骤来使用JDBC API与数据库进行交互：
- en: Add a **JDBC driver** for your database.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的数据库添加一个**JDBC驱动**。
- en: Establish a **connection** to the database.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立与数据库的**连接**。
- en: Create a **statement** to **execute** an SQL query.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**语句**来**执行**一个SQL查询。
- en: Get and process the **result set.**
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取并处理**结果集**。
- en: '**Close** the connection.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭**连接。'
- en: Adding a JDBC driver for your database
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的数据库添加 JDBC 驱动
- en: Connecting to an RDBMS from a Java application is done through a *JDBC driver*.
    Most (if not all) database vendors include JDBC drivers for their RDBMS. A JDBC
    driver, in practice, is just a Java dependency (a JAR) in your project. If, for
    example, you need to connect your application to a PostgreSQL database, you will
    need to add the `postgresql-x.x.x.jar` file to your classpath. This, of course,
    can also be done with Maven. It's through this JDBC driver that your Java application
    communicates with the RDBMS, and it does so by establishing connections and executing
    SQL statements to retrieve data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 应用程序连接到 RDBMS 是通过 *JDBC 驱动* 实现的。大多数（如果不是所有）数据库供应商都为其 RDBMS 提供了 JDBC 驱动。在实践中，JDBC
    驱动只是你项目中的一个 Java 依赖项（一个 JAR 文件）。例如，如果你需要将应用程序连接到 PostgreSQL 数据库，你需要将 `postgresql-x.x.x.jar`
    文件添加到你的类路径中。当然，这也可以使用 Maven 完成。正是通过这个 JDBC 驱动，你的 Java 应用程序与 RDBMS 进行通信，它通过建立连接并执行
    SQL 语句来检索数据。
- en: We are not covering the details about RDBMS and SQL in this book. These topics
    are complex enough by themselves to deserve a complete book about them. There
    are plenty of good bibliographic and online resources you can consult to learn
    more about these topics.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及 RDBMS 和 SQL 的细节。这些主题本身就足够复杂，值得有一本完整的书来介绍。有许多优秀的参考文献和在线资源，你可以查阅以了解更多关于这些主题的信息。
- en: In this book, we are going to use an H2 database. H2 is a popular open source
    database engine that doesn't require you to install anything on your computer.
    All the concepts apply to other RDBMS as well, and we'll include snippets or commented
    sections in the accompanying code that show the specifics for MySQL and PostgreSQL,
    in case you want to experiment with these databases by yourself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 H2 数据库。H2 是一个流行的开源数据库引擎，它不需要你在电脑上安装任何东西。所有这些概念也适用于其他 RDBMS，我们将在配套代码中包含片段或注释部分，展示
    MySQL 和 PostgreSQL 的具体细节，以便你可以在自己尝试这些数据库时参考。
- en: 'Adding a JDBC driver is as simple as including the right dependency in your
    project. For example, to include the H2 JDBC driver, add the following dependency
    to your `pom.xml` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 JDBC 驱动就像在你的项目中包含正确的依赖项一样简单。例如，要包含 H2 JDBC 驱动，将以下依赖项添加到你的 `pom.xml` 文件中：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or if you want to use MySQL or PostgreSQL, add the following dependencies:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想使用 MySQL 或 PostgreSQL，添加以下依赖项：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: JDBC was designed to support not only relational databases, but also any kind
    of data source, including file systems or object-oriented systems. Keep this in
    mind when you need to connect your application to any kind of data source; there
    might be a JDBC driver for it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 被设计为不仅支持关系型数据库，还支持任何类型的数据源，包括文件系统或面向对象系统。当你需要将应用程序连接到任何类型的数据源时，请记住这一点；可能存在一个
    JDBC 驱动程序可以用于它。
- en: You can, of course, include several JDBC drivers in the same project. The `chapter-05`
    application includes all of the previous drivers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以在同一个项目中包含多个 JDBC 驱动。`chapter-05` 应用程序包含了所有之前的驱动。
- en: In old versions of JDBC, you had to manually load the JDBC driver class using
    the `Class.forName` method. This is no longer required in JDBC 4.0\. Any JDBC
    4.0 driver in the classpath is automatically loaded.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDBC 的旧版本中，你必须手动使用 `Class.forName` 方法加载 JDBC 驱动类。在 JDBC 4.0 中，这不再需要了。类路径中的任何
    JDBC 4.0 驱动都会自动加载。
- en: Establishing a database connection through a connection pool
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过连接池建立数据库连接
- en: One of the most common pitfalls when developing web applications with Vaadin
    is to forget that what you are developing is actually a web application! Since
    the API resembles that of desktop-like UI frameworks, it's easy to forget that
    a Vaadin application is most likely going to be used by several users at the same
    time. You need to keep the multi user nature of a Vaadin application in mind when
    establishing connections to a database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Vaadin 开发 Web 应用程序时，最常见的陷阱之一就是忘记你所开发的是一个实际的 Web 应用程序！由于 API 类似于桌面型 UI 框架，很容易忘记
    Vaadin 应用程序很可能是同时被多个用户使用的。在建立数据库连接时，你需要牢记 Vaadin 应用的多用户特性。
- en: A desktop application you run locally on your machine might be able to work
    perfectly with a single connection to the database during its execution time (depending
    on the complexity of the application, of course). This is due to the single-user
    nature of the application; you know there's only one user per instance. On the
    other hand, a single instance of a web application is used by many users at the
    same time. It requires multiple connections to work properly. You don't want to
    have users *A, B, C..., X* waiting for the connection to be released by greedy
    user *Z*, right? However, establishing connections is expensive! Opening and closing
    a connection every time a new user requests the application is not an option,
    since your app could reach a big number of concurrent users, and hence connections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本地机器上运行的桌面应用程序可能在其执行时间内能够与数据库的单个连接完美工作（当然，这取决于应用程序的复杂性）。这是因为应用程序的单用户性质；你知道每个实例只有一个用户。另一方面，一个网络应用程序的单个实例同时被许多用户使用。它需要多个连接才能正常工作。你不想让用户
    *A、B、C...、X* 等待贪婪的用户 *Z* 释放连接，对吧？然而，建立连接是昂贵的！每次新用户请求应用程序时都打开和关闭连接不是一种选择，因为你的应用程序可能达到大量的并发用户，以及相应的连接。
- en: This is where a *connection pool* comes in handy. A connection pool is a class
    that maintains several connections to the database, like a *cache* of connections,
    if you wish. The connection pool keeps all its connections open so that they can
    be reused by client classes when they need it. Without a connection pool, any
    time your app needs to perform a database operation, it has to create a new connection,
    execute the query, and close the connection. As mentioned previously, this is
    expensive and wastes resources. Instead, a connection pool creates a set of connections
    and "lends" them to client classes. Once the connection is used, it's not closed,
    but returned to the pool and used again.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是连接池派上用场的地方。连接池是一个类，它维护到数据库的多个连接，如果你愿意，就像一个连接的*缓存*。连接池保持所有连接都打开，以便客户端类在需要时可以重用它们。没有连接池，每次你的应用程序需要执行数据库操作时，它都必须创建一个新的连接，执行查询，然后关闭连接。如前所述，这是昂贵的，并且浪费资源。相反，连接池创建一组连接，并将它们“借”给客户端类。一旦连接被使用，它不会被关闭，而是返回到池中并再次使用。
- en: As you can guess, connection pools are such a well-known pattern that many implementations
    exist. Let's see how to use one of them, `BoneCP`, a free open source JDBC connection
    pool implementation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，连接池是一个如此知名的模式，以至于存在许多实现。让我们看看如何使用其中之一，`BoneCP`，这是一个免费的开放源代码 JDBC 连接池实现。
- en: Other popular connection pool implementations are *C3P0* and *Apache DBCP*.
    Moreover, application servers and servlet containers offer the possibility to
    define pooled data sources (see Java's `DataSource` interface documentation) as
    part of their configuration. This decouples the data source configuration from
    your running environment while offering connection pooling mechanisms for free.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的连接池实现包括 *C3P0* 和 *Apache DBCP*。此外，应用程序服务器和Servlet容器提供定义池化数据源的可能性（请参阅Java的`DataSource`接口文档），作为它们配置的一部分。这将数据源配置与你的运行环境解耦，同时免费提供连接池机制。
- en: 'First of all, here are the dependencies you need to add:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里是你需要添加的依赖项：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`BoneCP` requires SLF4J, a logging library that offers a *facade* over several
    logging frameworks. This is needed in order to see logs by `BoneCP` in the console
    or web server log.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoneCP` 需要 SLF4J，这是一个提供多个日志框架的*外观*的日志库。这是为了能够在控制台或Web服务器日志中看到`BoneCP`的日志。'
- en: There should be one instance of the connection pool per instance of the web
    application. We used a static Java block in the previous chapter to initialize
    application-level resources. This works in small applications where these resources
    don't depend on others. In more complex applications, your initialization code
    might depend on other services (such as *dependency injection*) in order to work,
    so let's use a more realistic approach this time and use a `ServletContextListener`
    to `init` the connection pool. A `ServletContextListener` allows your application
    to react to events in the *servlet context lifecycle*; in particular, the initialization
    of a servlet context and its destruction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web应用程序实例应该有一个连接池实例。在前一章中，我们使用了一个静态Java块来初始化应用程序级别的资源。这在资源不依赖于其他资源的简单应用程序中是有效的。在更复杂的应用程序中，你的初始化代码可能依赖于其他服务（例如*依赖注入*）才能工作，所以这次让我们使用一个更实际的方法，并使用`ServletContextListener`来`init`连接池。`ServletContextListener`允许你的应用程序对`servlet上下文生命周期`中的事件做出反应；特别是，初始化servlet上下文及其销毁。
- en: 'As with previous examples, the `chapter-05` Vaadin application includes a `WebConfig`
    class that defines <q>everything web</q>; that is, servlets and event listeners.
    Besides the `VaadinServlet`, we can include a `ServletContextListener` that initializes
    the database when the servlet context is created (that is when the web application
    starts... sort of):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，`chapter-05` Vaadin应用程序包含一个`WebConfig`类，它定义了<q>所有Web相关的内容</q>；也就是说，servlet和事件监听器。除了`VaadinServlet`之外，我们还可以包括一个`ServletContextListener`，它在创建servlet上下文时初始化数据库（即当Web应用程序启动时...
    sort of）：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Thanks to the `@WebListener` annotation, this class is going to be discovered
    by the servlet container and registered with the servlet context automatically.
    Inside the `contextInitialized` method, we can add the code to initialize the
    connection pool; in this case, by delegating to the custom `DatabaseService` class
    we'll implement next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`@WebListener`注解，这个类将被servlet容器发现并自动注册到servlet上下文中。在`contextInitialized`方法中，我们可以添加初始化连接池的代码；在这种情况下，通过委托给我们将要实现的自定义`DatabaseService`类。
- en: 'The infrastructure code is ready; now it''s time for the actual `BoneCp` connection
    pool. Let''s start with the `init` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施代码已经准备好了；现在是我们实际使用`BoneCp`连接池的时候了。让我们从`init`方法开始：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This implementation defines a static (only one instance per application) `BoneCP`
    field, `pool`, the actual connection pool. The `pool` field is initialized in
    the `init` method, which is called when the application starts (see the `JdbcExampleContextListener`
    class).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现定义了一个静态（每个应用程序只有一个实例）的`BoneCP`字段，`pool`，这是实际的连接池。`pool`字段在`init`方法中初始化，该方法在应用程序启动时被调用（参见`JdbcExampleContextListener`类）。
- en: 'There are three things you need to specify when connecting to a database with
    JDBC:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JDBC连接数据库时，你需要指定三件事情：
- en: '**The connection URL**: With JDBC, a database is represented by a connection
    URL. JDBC uses this URL to get the information about where and how to connect
    to the database. In the previous example, we can see that the string contains
    the name of the database (`h2`), a host (`localhost`), and a database name (`~/h2-databases/demo`).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接URL**：在JDBC中，数据库由一个连接URL表示。JDBC使用这个URL来获取有关如何连接数据库的信息。在之前的示例中，我们可以看到字符串包含数据库的名称（`h2`）、主机（`localhost`）和数据库名称（`~/h2-databases/demo`）。'
- en: '**The username**: Databases allow you to define a set of users, roles, and
    permissions. The username is an identifier that the database can check in order
    to grant permissions on the data. By default, the H2 database defines the username
    `sa`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**：数据库允许你定义一组用户、角色和权限。用户名是数据库可以检查的标识符，以便在数据上授予权限。默认情况下，H2数据库定义了用户名`sa`。'
- en: '**The password**: As you can guess, this is what allows the database engine
    to run the authentication check. By default, H2 uses an empty password for the
    default `sa` user.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：正如你所猜到的，这是允许数据库引擎运行身份验证检查的东西。默认情况下，H2为默认的`sa`用户使用空密码。'
- en: 'What if you wanted to use MySQL or PostgreSQL now? you would have to change
    the `String` literals in this class, recompile, and redeploy. A much better approach
    is to externalize this `String`. One approach is to use the standard Java `Properties`
    class to load *key/value* pairs with the connection URL, username, and password.
    For example, the `chapter-05` application includes a `datasource.properties` file
    in the `/src/main/resources` directory:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在想使用MySQL或PostgreSQL，您将不得不更改此类中的`String`文本，重新编译和重新部署。一个更好的方法是外部化这个`String`。一种方法是用标准的Java
    `Properties`类加载带有连接URL、用户名和密码的*键/值*对。例如，`chapter-05`应用程序在`/src/main/resources`目录中包含一个`datasource.properties`文件：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With MySQL databases, use: `datasource.url=jdbc:mysql://localhost/demo`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MySQL数据库，使用：`datasource.url=jdbc:mysql://localhost/demo`
- en: 'With PostgreSQL databases, use: `datasource.url=jdbc:postgresql://localhost:5432/demo`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PostgreSQL数据库，使用：`datasource.url=jdbc:postgresql://localhost:5432/demo`
- en: 'The `DatabaseService` class can now use these properties (`datasource.*`) instead
    of the *hard-coded* literals:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatabaseService`类现在可以使用这些属性（`datasource.*`）而不是*硬编码*的文本：'
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The connection properties (`url`, `username`, and `password`) are now static
    fields in the class populated from the `datasource.properties` file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 连接属性（`url`、`username`和`password`）现在是类中的静态字段，由`datasource.properties`文件填充。
- en: 'A way of making your web application configuration independent of the running
    environment is to use the operating system''s *environment variables*. For example,
    let''s say you define a `MY-WEBAPP-CONF-DIRECTORY` environment variable in your
    computer, and set its value to `~/my-webapp-conf`. Inside this directory, you
    can put all the `.properties` files that make up the configuration for example,
    the `datasource.properties` file. The web application can read the environment
    variable like this: `String confDirectory = System.getenv("MY-WEBAPP-CONF-DIRECTORY")`,
    and read any files inside this directory in order to configure the application
    accordingly. With this technique, each developer in the team can define their
    own local configuration. Moreover, you can easily configure *test* and *production*
    environments by defining the environment variable and placing the corresponding
    configuration files – no need to worry about replacing files when you deploy to
    these environments besides checking that all configuration properties are in place.
    Make sure you show good error or warning messages when a property doesn''t exist.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的Web应用程序配置独立于运行环境，可以使用操作系统的*环境变量*。例如，假设您在计算机上定义了一个名为`MY-WEBAPP-CONF-DIRECTORY`的环境变量，并将其值设置为`~/my-webapp-conf`。在这个目录内，您可以放置所有构成配置的`.properties`文件，例如，`datasource.properties`文件。Web应用程序可以像这样读取环境变量：`String
    confDirectory = System.getenv("MY-WEBAPP-CONF-DIRECTORY")`，并读取此目录内的任何文件以相应地配置应用程序。使用这种技术，团队中的每个开发者都可以定义他们自己的本地配置。此外，您可以通过定义环境变量并将相应的配置文件放置在对应的环境中轻松地配置*测试*和*生产*环境——除了检查所有配置属性是否就绪外，无需担心在部署到这些环境时替换文件。确保当属性不存在时显示良好的错误或警告信息。
- en: 'Now that we have a connection pool ready, we can get actual connections to
    the database. Here is how:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了连接池，我们可以获取到数据库的实际连接。以下是方法：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `Connection` represents a session with the database. This interface contains
    a number of methods to get information about the capabilities of the database
    and the state of the connection, but the most important part allows you to create
    `Statements` objects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`连接`代表与数据库的会话。此接口包含许多方法，用于获取有关数据库功能和连接状态的信息，但最重要的部分允许您创建`语句`对象。
- en: Connection pool implementations offer good configurations for development or
    testing environments. This is most likely not optimal for a production environment.
    Consult the documentation of the implementation, and tune the configuration accordingly
    when deploying to production environments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池实现为开发或测试环境提供了良好的配置。这很可能不适合生产环境。请查阅实现文档，并在部署到生产环境时相应地调整配置。
- en: Creating a statement and executing an SQL query
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建语句并执行SQL查询
- en: 'A `Statement` object is used to invoke SQL statements in the database. The
    following snippet of code shows how to retrieve a `Connection` object from the
    connection pool. This object is used to create a new `Statement`, which, in turn,
    is used to execute an SQL statement:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`语句`对象用于在数据库中调用SQL语句。以下代码片段展示了如何从连接池中检索`连接`对象。此对象用于创建一个新的`语句`，然后用于执行SQL语句：'
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this chapter, we are using the `Statement` interface and its `createStatement`
    counterpart method. In more critical applications, you should use the `PreparedStatement`
    interface and the `prepareStatement` method in order to increase performance and
    prevent SQL injection attacks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 `Statement` 接口及其 `createStatement` 对应方法。在更关键的应用中，你应该使用 `PreparedStatement`
    接口和 `prepareStatement` 方法以提高性能并防止 SQL 注入攻击。
- en: Getting and processing a result set
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和处理结果集
- en: 'As you can see, the `execute` method of the `Statement` class returns a `ResultSet`
    object. A `ResultSet` object represents data from the database. It works like
    a cursor pointing to the rows in the data. First, the cursor is placed before
    the first row. You can use the `next` method to iterate through the rows as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Statement` 类的 `execute` 方法返回一个 `ResultSet` 对象。`ResultSet` 对象表示数据库中的数据。它就像一个指向数据行中的游标。首先，游标放置在第一行之前。你可以使用
    `next` 方法如下迭代行：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous example, we are using the `getString` method to get the value
    that corresponds to the `content` column. There are methods for various data types:
    for example, the `getInt` method returns the value in the specified column as
    a Java `int`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 `getString` 方法来获取与 `content` 列相对应的值。有各种数据类型的方法：例如，`getInt` 方法将指定列的值作为
    Java `int` 返回。
- en: Closing a database connection
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭数据库连接
- en: 'When using a connection pool, the pool implementation takes care of closing
    the JDBC connections. Depending on the specific implementation, you might have
    to invoke this process. Usually, you want the pool to be active during the lifetime
    of your web application. Remember the `ServletContextListener` implementation
    we used to initialize the connection pool? Well, we can use it to shut the pool
    down. All we need to do is to implement the `contextDestroyed` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用连接池时，连接池的实现会负责关闭 JDBC 连接。根据具体实现，你可能需要调用此过程。通常，你希望连接池在 Web 应用程序的生命周期内保持活跃。还记得我们用来初始化连接池的
    `ServletContextListener` 实现吗？嗯，我们可以用它来关闭池。我们只需要实现 `contextDestroyed` 方法：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the `shutdown` method is implemented as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`shutdown` 方法实现如下：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, it''s a good time for you to play with the `chapter-05` demo application
    again. Have a close look at the `DatabaseService` class and how it is used in
    the `VaadinUI` class. The `findAllMessages` method is pretty interesting in particular,
    as it acts as the main communication point between the Vaadin application and
    the UI:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是你再次尝试 `chapter-05` 演示应用程序的好时机。仔细看看 `DatabaseService` 类以及它在 `VaadinUI` 类中的使用。特别是
    `findAllMessages` 方法非常有趣，因为它作为 Vaadin 应用程序和 UI 之间的主要通信点：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See how the SQL queries are defined in `String` constants. Can you think of
    a better way of doing this? In a more complex application, you might end up having
    hundreds of SQL queries. A better practice in these scenarios is to externalize
    the SQL code. Properties files might help, but defining SQL queries in a single
    line could be a challenge, to say the least. A better approach is XML, a format
    that allows you to use multiple lines to define values. We'll see how MyBatis
    promotes this approach in [Chapter 6](9a3c93d4-374e-4324-9201-1d446093fef3.xhtml),
    *Connecting to SQL Databases Using ORM Frameworks*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 SQL 查询是如何在 `String` 常量中定义的。你能想到更好的方法来做这件事吗？在一个更复杂的应用中，你可能会有成百上千个 SQL 查询。在这些情况下，一个更好的做法是将
    SQL 代码外部化。属性文件可能会有所帮助，但至少可以说，在单行中定义 SQL 查询可能是一个挑战。一个更好的方法是使用 XML，这种格式允许你使用多行来定义值。我们将在
    [第 6 章](9a3c93d4-374e-4324-9201-1d446093fef3.xhtml) 中看到 MyBatis 如何推广这种方法，*使用 ORM
    框架连接 SQL 数据库*。
- en: Another interesting detail in the `findAllMessages` method is the return type.
    Why not return a `ResultSet` object? We do this to avoid coupling the presentation
    layer with persistence implementation details. This is what we are going to explore
    in the following section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `findAllMessages` 方法中，另一个有趣的细节是返回类型。为什么不返回一个 `ResultSet` 对象呢？我们这样做是为了避免将表示层与持久化实现细节耦合。这就是我们将在下一节中要探讨的内容。
- en: You might have noticed that the `findAllMessages` method can throw an `SQLException`.
    This makes clients of this method aware of implementation details at some level.
    Although the name of the exception class implies SQL is being used, according
    to the API documentation, an `SQLException` is "<q>an exception that provides
    information on a database access error or other errors</q>". This exception is
    used even in drivers for *NoSQL* databases.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`findAllMessages`方法可能会抛出`SQLException`。这使得此方法的使用者对某些层面的实现细节有所了解。尽管异常类名暗示正在使用SQL，但根据API文档，`SQLException`是"<q>一个提供数据库访问错误或其他错误信息的异常</q>"。这个异常在*NoSQL*数据库的驱动程序中也被使用。
- en: Implementing data repositories
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据存储库
- en: A *repository*, for the purposes of this book, is a class that includes all
    or some of the **CRUD** operations (**Create, Read, Update, and Delete**). Repositories
    encapsulate persistence details in an application. A repository holds the means
    to the domain model (or entities).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的目的下，*存储库*是一个包含所有或部分**CRUD**操作（**创建、读取、更新和删除**）的类。存储库封装了应用程序的持久性细节。存储库持有领域模型（或实体）的手段。
- en: More precisely, a domain model includes not only data, but also behavior. Another
    term used widely is **data transfer object** (**DTO**). Although the original
    definition of DTO was intended to describe a way to transport data between processes,
    many architectures (inaccurately) define DTO as an object that carries data between
    software components in the same process. To complicate things even more, there
    are *value objects* (objects that are equal if their properties are equal), and
    *entities* (objects that are equal based on their identity, which can be defined
    by a single property). When documenting and designing your software, spend some
    time investigating the terms, and try to choose the one that best matches your
    design.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，领域模型不仅包括数据，还包括行为。另一个广泛使用的术语是**数据传输对象**（**DTO**）。尽管DTO的原始定义是为了描述在进程之间传输数据的方式，但许多架构（不准确）将DTO定义为在相同进程中的软件组件之间携带数据的对象。更复杂的是，还有*值对象*（如果它们的属性相等，则相等的对象）和*实体*（基于其身份相等的对象，这可以由单个属性定义）。在记录和设计你的软件时，花些时间研究这些术语，并尝试选择最适合你设计的一个。
- en: Defining a domain model
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义领域模型
- en: 'Let''s study this with an example. Suppose you are implementing a simple e-commerce
    application. You are in charge of the *orders module,* and have to provide access
    to the data related to this module through a web UI. After reading the specification,
    you designed a simple domain model formed by the following classes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来学习这个。假设你正在实现一个简单的电子商务应用程序。你负责的模块是*订单模块*，需要通过Web UI提供与此模块相关的数据访问。在阅读了规范后，你设计了一个简单的领域模型，由以下类组成：
- en: '![](img/5e32ca64-5673-45f9-aa28-4c1398348e8b.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e32ca64-5673-45f9-aa28-4c1398348e8b.jpg)'
- en: 'This is pretty straightforward: an `Order` has one or more `Product` objects
    and one `Customer`. You want to use the hypothetical *Technology X* to persist
    data (it doesn''t matter which one for this example), and you want your Vaadin
    `UI` implementation to be able to directly use the domain class; however, you
    don''t want to couple your UI implementation with Technology X. Moreover, you
    have to expose orders and product data through a web service for an external accounting
    system. You decided, then, to implement three repositories, one for each domain
    class: `ProductRepository`, `OrderRepository`, and `CustomerRepository`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接：一个`Order`对象有一个或多个`Product`对象和一个`Customer`对象。你希望使用假设的*技术X*来持久化数据（在这个例子中，哪个技术不重要），并且你希望你的Vaadin
    `UI`实现能够直接使用领域类；然而，你不想将你的UI实现与Technology X耦合。此外，你必须通过Web服务公开订单和产品数据，以便外部会计系统使用。因此，你决定实现三个存储库，每个领域类一个：`ProductRepository`、`OrderRepository`和`CustomerRepository`。
- en: Implementing repositories and services
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现存储库和服务
- en: 'At this point, you started implementing the Vaadin UI, and had a clear understanding
    of the methods that the repositories should expose. You then implemented these
    methods in the respective repository classes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你开始实现Vaadin UI，并对存储库应该公开的方法有了清晰的理解。然后你在相应的存储库类中实现了这些方法：
- en: '![](img/8a3386ea-77a5-4a66-9d54-43e4174a9f7a.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a3386ea-77a5-4a66-9d54-43e4174a9f7a.jpg)'
- en: Let's take a closer look at the methods in the repository classes. As you can
    see, all method names start with `find` or `get`. This is a well-known convention
    in the industry, and it's used by libraries such as **Spring Data** or **Apache
    DeltaSpike**. Methods starting with `find` return a collection of objects, while
    methods starting with `get` return single, ready-to-use values (such as a domain
    instance, or one of its properties).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看仓库类中的方法。正如你所看到的，所有方法名都以 `find` 或 `get` 开头。这是行业中的一个众所周知的标准，并被诸如 **Spring
    Data** 或 **Apache DeltaSpike** 这样的库所使用。以 `find` 开头的方法返回对象集合，而以 `get` 开头的方法返回单个、可直接使用的值（例如领域实例或其属性之一）。
- en: 'Notice how each repository has a private `persistence` field that represents
    the entry point to use Technology X, we will see concrete examples of this later
    in this chapter. If, for some reason, you had to change the persistence technology
    to something else, client classes wouldn''t be affected. Moreover, you can use
    different persistence technologies for different repositories without having client
    classes to deal with different APIs. The following code will give you a clear
    idea of how these repositories can be implemented:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个仓库都有一个代表使用技术 X 的入口点的私有 `persistence` 字段，我们将在本章后面看到具体的例子。如果由于某种原因，你必须将持久化技术更改为其他技术，客户端类不会受到影响。此外，你可以为不同的仓库使用不同的持久化技术，而无需客户端类处理不同的
    API。以下代码将清楚地说明这些仓库可以如何实现：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All the implementation details regarding how to get the data are encapsulated
    in the repository class. Now, let's move on and see how this can be used from
    a Vaadin application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于如何获取数据的实现细节都被封装在仓库类中。现在，让我们继续看看如何从 Vaadin 应用程序中使用它。
- en: 'While doing *pair programming*, your colleague suggested you should use service
    classes to abstract away the concept of *repository* from the Vaadin UI. She argued
    that there should be one `service` class for each repository: `ProductService`,
    `OrderService`, and `CustomerService`. It seemed like a good idea to you too;
    however, she immediately noticed that the service classes would be simple *facades*
    for their repository counterparts, and wouldn''t include any extra logic. You
    pointed out that the application had to expose data through a web service consumed
    by the accounting system, and that the service classes might be used for that.
    After you and your colleague investigated the precise data the web service had
    to expose, you both decided to *Fight for Simplicity,* and not to implement one
    `service` class per `repository` class.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行*结对编程*时，你的同事建议你应该使用服务类来从 Vaadin UI 中抽象出 *仓库* 的概念。她认为应该为每个仓库有一个 `service`
    类：`ProductService`、`OrderService` 和 `CustomerService`。这个想法在你看来也很不错；然而，她立刻注意到这些服务类将只是其仓库对应类的简单
    *门面*，并且不会包含任何额外的逻辑。你指出应用程序必须通过会计系统使用的网络服务来公开数据，并且服务类可能被用于此目的。在你和你的同事调查了网络服务必须公开的确切数据后，你们俩决定
    *追求简洁*，而不是为每个 `repository` 类实现一个 `service` 类。
- en: Instead, the Vaadin UI would be allowed to have references to the repository
    classes. You also decided to implement a separate `AccountingWebService` class
    to expose the data for the accounting system, so that you could know and control
    what this system is "seeing" in the future. As with the Vaadin UI classes, the
    web service implementation would use the repository classes to fetch data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Vaadin UI 将被允许引用仓库类。你还决定实现一个单独的 `AccountingWebService` 类来公开会计系统的数据，这样你就可以知道并控制这个系统未来“看到”的内容。与
    Vaadin UI 类一样，网络服务实现将使用仓库类来获取数据。
- en: The previous hypothetical example doesn't imply that you shouldn't enforce a
    repository/service pairing kind of design in your projects. Always stop and think
    before making this kind of decision. The situation in the example shows how the
    developers considered alternatives, investigated the requirements more deeply,
    and then took an informed decision. Keep the developers, who will maintain your
    code in the future in mind. Keep your legacy in mind.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的假设例子并不意味着你不应该在项目中强制实施仓库/服务配对的设计。在做出此类决定之前，总是要停下来思考。例子中的情况显示了开发者如何考虑替代方案，更深入地调查需求，然后做出明智的决定。考虑到将来会维护你代码的开发者。记住你的遗产。
- en: The active record pattern
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动记录模式
- en: 'There are many architectural patterns that may or may not help in your projects;
    in particular, regarding domain models and persistence. You might want to have
    a look at the *active record pattern*. An active record class encapsulates not
    only the data, but also its persistence operations. For example, the `Order` class
    of the previous example would look like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中，可能有许多架构模式可能会或可能不会有所帮助；特别是关于领域模型和持久化。你可能想了解一下*活动记录模式*。活动记录类不仅封装了数据，还封装了其持久化操作。例如，前一个示例中的`Order`类看起来如下：
- en: '![](img/29eb1f9e-ff9d-4527-a8fc-213b44ac9bea.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29eb1f9e-ff9d-4527-a8fc-213b44ac9bea.jpg)'
- en: Notice how the CRUD operations are implemented in the domain class alongside
    with the methods previously implemented in the `repository` class. Although being
    an alternative to keep in mind, we won't further cover or use the active record
    pattern in this book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意CRUD操作是如何在领域类中实现的，这些操作与之前在`repository`类中实现的方法并列。虽然这是一个值得考虑的替代方案，但在这本书中，我们不会进一步介绍或使用活动记录模式。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter served as the fundamentals of database connectivity with Java.
    We learned concepts such as JDBC drivers (that allow applications to connect to
    specific relational database engines) and connection pools (to better use connection
    resources). We learned how to use a `ContextServletListener` to initialize connection
    pools or database-related services. We saw an example of a simple domain model,
    and how repository classes allow us to encapsulate access to data represented
    in this model.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用Java进行数据库连接的基础知识。我们学习了诸如JDBC驱动程序（允许应用程序连接到特定的关系型数据库引擎）和连接池（以更好地使用连接资源）等概念。我们学习了如何使用`ContextServletListener`来初始化连接池或数据库相关服务。我们看到了一个简单的领域模型示例，以及如何通过仓库类来封装对在此模型中表示的数据的访问。
- en: In the next chapter, we are going to learn about several persistence technologies,
    and how to integrate them with the Vaadin Framework.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习几种持久化技术，以及如何将它们与Vaadin框架集成。
