- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Federated and Scalable DaaS with GraphQL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦和可扩展的 GraphQL 数据即服务（DaaS）
- en: In the previous chapter, we discussed how to publish ingested data in a format
    that is platform- and language-agnostic using the REST API. We also learned how
    to design and develop a **Data as a Service** (**DaaS**) layer using the REST
    API, as well as how to containerize and deploy the application on AWS ECS. Then,
    we learned what an API management system is and how it can help monitor and manage
    APIs more efficiently. Finally, we learned how to create an API management layer
    on top of our REST DaaS application using Amazon API Gateway.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何使用 REST API 以平台和语言无关的格式发布摄取的数据。我们还学习了如何使用 REST API 设计和开发 **数据即服务（DaaS**）层，以及如何将应用程序容器化并在
    AWS ECS 上部署。然后，我们学习了什么是 API 管理系统以及它如何帮助更有效地监控和管理 API。最后，我们学习了如何在我们基于 REST 的 DaaS
    应用程序之上创建一个 API 管理层，使用 Amazon API Gateway。
- en: In this chapter, we will learn how to implement DaaS using GraphQL instead of
    REST. To do so, we will learn what GraphQL is, and why and when it should be used.
    We will explore the benefits and shortcomings that GraphQL has concerning REST
    while discussing the various architectural patterns available for GraphQL-based
    solutions. Finally, we will learn about the power of federation in the GraphQL
    layer. By the end of this chapter, you should know about the basic concepts surrounding
    GraphQL and when to use this tool in data engineering solutions. You will also
    know how to design, implement, and test a GraphQL solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 GraphQL 而不是 REST 来实现 DaaS。为此，我们将学习 GraphQL 是什么，以及为什么和何时应该使用它。我们将探讨
    GraphQL 相对于 REST 的优点和缺点，同时讨论适用于基于 GraphQL 解决方案的各种架构模式。最后，我们将了解 GraphQL 层中联邦的力量。到本章结束时，你应该了解围绕
    GraphQL 的基本概念以及何时在数据工程解决方案中使用此工具。你还将了解如何设计、实现和测试一个 GraphQL 解决方案。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing GraphQL – what, when, and why
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 GraphQL - 什么是 GraphQL，何时使用，为什么使用
- en: Core architectural patterns of GraphQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 的核心架构模式
- en: A practical use case – exposing federated data models using GraphQL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实际用例 - 使用 GraphQL 暴露联邦数据模型
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: Prior knowledge of Java
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要具备 Java 的先验知识
- en: OpenJDK-1.11 installed on your local system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJDK-1.11 已安装在本地的系统上
- en: Maven installed on your local system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 已安装在本地的系统上
- en: GraphQL Playground installed on your local system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL Playground 已安装在本地的系统上
- en: IntelliJ Idea community or ultimate edition installed on your local system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ Idea 社区版或终极版已安装在本地的系统上
- en: 'The code for this chapter can be downloaded from this book’s GitHub repository:
    [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter10](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter10).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以从本书的 GitHub 仓库下载：[https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter10](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter10)。
- en: Introducing GraphQL – what, when, and why
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 GraphQL - 什么是 GraphQL，何时使用，为什么使用
- en: In this section, we will explore what GraphQL is. According to [graphql.org](http://graphql.org),
    the official definition of GraphQL is that “*GraphQL is a query language for APIs
    and a runtime for fulfilling those queries with your existing data.*” Let’s dive
    a bit deeper to understand GraphQL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 GraphQL 是什么。根据 [graphql.org](http://graphql.org)，GraphQL 的官方定义是：“*GraphQL
    是一种用于 API 的查询语言，以及用于使用现有数据满足这些查询的运行时。*”让我们深入一点，了解 GraphQL。
- en: '**Representational State Transfer** (**REST**) has been the standard way of
    publishing data across systems, which is platform, device, and tool/language-agnostic.
    However, there are two major bottlenecks with REST:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示状态转移（REST**）一直是跨系统发布数据的标准方式，它是平台、设备和工具/语言无关的。然而，REST 存在两个主要瓶颈：'
- en: For fetching different related entities, we need multiple REST requests. We
    must also be mindful of different versions of the API. Having different endpoints
    and their versions for each entity of functionality is a maintenance headache.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获取不同的相关实体，我们需要多个 REST 请求。我们还必须注意 API 的不同版本。为每个实体或功能的不同端点和版本维护是一个头疼的问题。
- en: The request and response parameters are always fixed in REST. For example, there
    is a REST API that returns 100 fields. Suppose there is a consumer who only needs
    10 fields. However, since responses are fixed, a REST request will always calculate
    and send all 100 fields. This, in turn, affects performance as it takes more time
    to form the response, as well as consumes more bandwidth to transfer a bigger
    payload.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 REST 中，请求和响应参数始终是固定的。例如，有一个 REST API 返回 100 个字段。假设有一个消费者只需要 10 个字段。然而，由于响应是固定的，REST
    请求将始终计算并发送所有 100 个字段。这反过来会影响性能，因为形成响应需要更多时间，以及传输更大的负载需要更多的带宽。
- en: 'GraphQL is the answer to overcome these challenges. GraphQL is an open standard
    or specification created by Facebook. It is a query language for APIs, where the
    client can query multiple entities and the desired fields from those entities
    while making the GraphQL request. The following diagram describes how GraphQL
    operates:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是克服这些挑战的答案。GraphQL 是由 Facebook 创建的一个开放标准或规范。它是一种用于 API 的查询语言，客户端可以在发送
    GraphQL 请求时查询多个实体及其所需的字段。以下图表描述了 GraphQL 的工作方式：
- en: '![Figure 10.1 – How GraphQL operates ](img/B17084_10_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – GraphQL 的工作方式](img/B17084_10_001.jpg)'
- en: Figure 10.1 – How GraphQL operates
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – GraphQL 的工作方式
- en: As shown in the preceding diagram, in GraphQL, it is the GraphQL client that
    defines what data it needs, while the GraphQL server publishes what data is available.
    So, essentially, GraphQL is a declarative way of fetching and updating data over
    APIs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在 GraphQL 中，是 GraphQL 客户端定义它需要什么数据，而 GraphQL 服务器发布可用的数据。因此，本质上，GraphQL
    是一种通过 API 获取和更新数据的声明式方法。
- en: 'Let’s try to understand this with an example. Since GraphQL was created by
    Facebook, we will take an example from a social networking use case. Let’s suppose
    that we want to fetch users, their posts, and the comments related to that post.
    The following diagram shows how this can be designed using REST:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来尝试理解这一点。由于 GraphQL 是由 Facebook 创建的，我们将从一个社交网络用例中取一个例子。假设我们想要获取用户、他们的帖子以及与该帖子相关的评论。以下图表显示了如何使用
    REST 来设计这一点：
- en: '![Figure 10.2 – A REST-based design requires three separate endpoints ](img/B17084_10_002.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 基于REST的设计需要三个单独的端点](img/B17084_10_002.jpg)'
- en: Figure 10.2 – A REST-based design requires three separate endpoints
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 基于REST的设计需要三个单独的端点
- en: 'As we can see, REST will have three endpoints – one for users, one for posts,
    and one for comments. To fetch a user’s posts and comments on those posts, REST
    will require one call for users, one call for the posts, and one call per post
    for the comments. This is shown in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，REST 将有三个端点 – 一个用于用户，一个用于帖子，一个用于评论。要获取用户的帖子及其评论，REST 将需要一次用户调用，一次帖子调用，以及每个帖子一次评论调用。以下图表显示了这一点：
- en: '![Figure 10.3 – Three separate calls are needed when using REST ](img/B17084_10_003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 使用 REST 时需要三个单独的调用](img/B17084_10_003.jpg)'
- en: Figure 10.3 – Three separate calls are needed when using REST
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 使用 REST 时需要三个单独的调用
- en: 'As we can see, there are at least three REST calls (provided that the user
    has only one post) required for this use case to fetch data. Think of the number
    of calls required for a real user on a social platform. If the user has posted
    *n* number of posts, then the number of calls required to fetch this information
    will be *n+2*. That would seriously affect the UI experience and the performance
    of the website. However, in GraphQL, it only takes one call to fetch this information.
    The following diagram shows what a GraphQL request would look like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这个用例中，至少需要三个 REST 调用来获取数据（假设用户只有一个帖子）。想想一个真实社交平台上的用户需要多少次调用。如果用户发布了 *n*
    个帖子，那么获取这些信息的调用次数将是 *n+2*。这会严重影响用户体验和网站性能。然而，在 GraphQL 中，只需要一次调用就可以获取这些信息。以下图表显示了
    GraphQL 请求的外观：
- en: '![Figure 10.4 – A single GraphQL call can fetch all the required data ](img/B17084_10_004.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 单个 GraphQL 调用可以获取所有所需数据](img/B17084_10_004.jpg)'
- en: Figure 10.4 – A single GraphQL call can fetch all the required data
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 单个 GraphQL 调用可以获取所有所需数据
- en: As you can see, the request payload of GraphQL declares the entities and fields
    that it needs to fetch. Therefore, the GraphQL client determines what data it
    needs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，GraphQL 的请求负载声明了它需要获取的实体和字段。因此，GraphQL 客户端确定它需要什么数据。
- en: Operation types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作类型
- en: 'Now that we understand what GraphQL is, let’s try to understand the various
    types of operations that GraphQL supports, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是GraphQL，让我们尝试了解GraphQL支持的各种操作类型，如下所示：
- en: '**Queries**: These help query the API and only support data read operations.
    A sample query is as follows:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：这些有助于查询API，并且仅支持数据读取操作。以下是一个示例查询：'
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As shown in the preceding payload, you can optionally use a keyword query followed
    by the name that you want to assign to the query (here, it is `myquery`). `byApplicationId`
    is a query in GraphQL (like an endpoint in REST) that takes request arguments
    as parameters. Here, the `byApplicationId` query takes an argument called `applicationId`.
    Also, as you can see, the request contains the names of the fields that it wants
    to have returned, such as `applicationId`, `id`, and `riskscore`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个有效载荷所示，你可以选择性地使用一个关键字查询，后跟你想分配给查询的名称（在这里，它是`myquery`）。`byApplicationId`是GraphQL中的一个查询（类似于REST中的端点），它将请求参数作为参数。在这里，`byApplicationId`查询接受一个名为`applicationId`的参数。此外，正如你所看到的，请求包含了它希望返回的字段名称，例如`applicationId`、`id`和`riskscore`。
- en: '**Mutations**: Mutations support both read and write operations. A sample query
    is as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突变**：突变支持读取和写入操作。以下是一个示例查询：'
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As shown in the preceding code, a mutation can be labeled with a mutation name
    using the `mutation` keyword. Here, it updates the application status in the database.
    So, it is used to write data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，可以使用`mutation`关键字对突变进行标记。这里，它更新数据库中的应用程序状态。因此，它用于写入数据。
- en: '**Subscriptions**: In addition to queries and mutations, GraphQL also supports
    subscriptions. Like queries, they are used to fetch data, but they use long-lasting
    connections, which can change their result over time. This enables an event notification
    pattern, by which the server can push changes to the client. The following code
    shows what a subscription query looks like:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅**：除了查询和突变之外，GraphQL还支持订阅。与查询类似，它们用于获取数据，但它们使用长期连接，其结果会随时间变化。这允许通过服务器向客户端推送更改的事件通知模式。以下代码展示了订阅查询的示例：'
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are subscribing to the comments written for the post with a `postId`.
    Hence, a long-lasting connection is established between the client and the GraphQL
    server. The GraphQL server pushes any changes that are made on the comments to
    the client automatically.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过`postId`订阅了帖子的评论。因此，客户端和GraphQL服务器之间建立了一个长期连接。GraphQL服务器会自动将评论上的任何更改推送到客户端。
- en: 'Now, let’s discuss the GraphQL schema. A GraphQL schema is a contract between
    the client and the server. It declares what operations and fields are available
    in GraphQL. It is strongly typed and is written using a standard **Schema Definition
    Language** (**SDL**). The following code block shows an example of a GraphQL schema:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论GraphQL模式。GraphQL模式是客户端和服务器之间的一个合约。它声明了在GraphQL中可用的操作和字段。它是强类型的，并使用标准的**模式定义语言**（**SDL**）编写。以下代码块展示了GraphQL模式的一个示例：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code block, the `applicationId` field is of the `ID` data type,
    `genderCode` is of the `String` data type. and so on. In SDL, data types of GraphQL
    schemas are also known as scalars; the inbuilt data types are denoted as inbuilt
    scalars and customized data types are referred to as custom scalars. The exclamation
    mark after `ID` while defining `applicationId` denotes that it is a mandatory
    field. Similarly, `cars` is defined as a list since its data type is wrapped with
    `[]` (square brackets).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`applicationId`字段是`ID`数据类型，`genderCode`是`String`数据类型，等等。在SDL中，GraphQL模式的数据类型也称为标量；内置的数据类型表示为内置标量，自定义数据类型称为自定义标量。在定义`applicationId`时`ID`后面的感叹号表示它是一个必填字段。同样，由于其数据类型被`[]`（方括号）包裹，`cars`被定义为列表。
- en: Now that we have internalized the basic concepts of GraphQL, we will explore
    why and when to use GraphQL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经内化了GraphQL的基本概念，我们将探讨为什么以及何时使用GraphQL。
- en: Why use GraphQL?
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用GraphQL？
- en: 'In this section, we will explore the various benefits of GraphQL that make
    it a great solution. The advantages of GraphQL are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨GraphQL的各种优势，这些优势使其成为一个优秀的解决方案。GraphQL的优势如下：
- en: '**Strongly typed schema for a platform-independent API**: Usually, in the SOAP
    and REST APIs, our response is a platform-independent structure such as XML or
    JSON. However, neither of these formats is strongly typed. In GraphQL, each field
    in a schema must have a scalar type (it can either be an inbuilt scalar type or
    a customized one). This ensures GraphQL is less error-prone, more validated, and
    provides easy auto-completion capabilities for editors such as GraphQL Playground.
    The following screenshot shows the auto-completion suggestion provided by GraphQL
    Playground:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为平台无关的 API 创建强类型模式**：通常，在 SOAP 和 REST API 中，我们的响应是一个平台无关的结构，如 XML 或 JSON。然而，这些格式都不是强类型的。在
    GraphQL 中，模式中的每个字段都必须有一个标量类型（它可以是内置的标量类型或自定义的）。这确保了 GraphQL 更少出错，更经过验证，并为像 GraphQL
    Playground 这样的编辑器提供了易于自动补全的功能。以下截图显示了 GraphQL Playground 提供的自动补全建议：'
- en: '![Figure 10.5 – Auto-completion feature in GraphQL Playground ](img/B17084_10_005.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – GraphQL Playground 中的自动补全功能](img/B17084_10_005.jpg)'
- en: Figure 10.5 – Auto-completion feature in GraphQL Playground
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – GraphQL Playground 中的自动补全功能
- en: '**No over-fetching or under-fetching**: In GraphQL, the client can only fetch
    the data that it requires. For example, if a GraphQL API supports hundreds of
    fields in its API response, the client doesn’t need to fetch all those fields.
    If a client only needs 10 fields, the client can request the GraphQL API to send
    only those fields. However, if the same API is written in REST, even though the
    client requires only 10 fields, the response will return all the fields.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无过度获取或未充分获取**：在 GraphQL 中，客户端只能获取它需要的数据。例如，如果一个 GraphQL API 在其 API 响应中支持数百个字段，客户端不需要获取所有这些字段。如果客户端只需要
    10 个字段，客户端可以请求 GraphQL API 仅发送这些字段。然而，如果相同的 API 用 REST 编写，即使客户端只需要 10 个字段，响应也会返回所有字段。'
- en: 'Over-fetching is a common problem in REST, where, irrespective of the number
    of fields a client requires, it always fetches all the fields defined in the response
    body. For example, for a social networking site such as LinkedIn, a person’s profile
    contains a huge number of columns, including demographic columns, skill set columns,
    awards and certification columns, and so on. A REST-based solution to solve this
    problem can be designed in two ways:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 中，过度获取是一个常见问题，无论客户端需要多少字段，它总是获取响应体中定义的所有字段。例如，对于像 LinkedIn 这样的社交网络网站，一个人的个人资料包含大量列，包括人口统计列、技能集列、奖项和认证列等。可以设计两种基于
    REST 的解决方案来解决这个问题：
- en: '**Create a single API with all columns**: If we use this approach, a client
    requiring only demographic information will encounter an over-fetching problem.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建包含所有列的单个 API**：如果我们使用这种方法，只需要人口统计信息的客户端会遇到过度获取的问题。'
- en: '**Create separate APIs for demographics, skill sets, awards and certifications,
    and so on**: Let’s look at a scenario where the client needs all the information
    available. Multiple calls are required to fetch the data if we use this approach.
    This leads to under-fetching.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为人口统计、技能集、奖项和认证等创建单独的 API**：让我们看看一个客户端需要所有可用信息的场景。如果我们使用这种方法，需要多次调用才能获取数据。这会导致数据未充分获取。'
- en: So, we need a single solution that can solve these issues for both types of
    client requests. GraphQL solves this problem by allowing the client to choose
    which fields it wants to fetch.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个单一解决方案来解决这两种类型客户端请求的问题。GraphQL 通过允许客户端选择它想要获取的字段来解决此问题。
- en: '**Saves time and bandwidth**: GraphQL allows you to make multiple resource
    requests in a single GraphQL call, which saves a lot of time and bandwidth by
    reducing the number of network round trips to the GraphQL server. This is especially
    useful for improving the user experience and speed of fetching data on a client
    application.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节省时间和带宽**：GraphQL 允许你在单个 GraphQL 调用中发出多个资源请求，通过减少到 GraphQL 服务器的网络往返次数，节省了大量时间和带宽。这对于提高客户端应用程序的数据获取体验和速度特别有用。'
- en: '**No need for versioning**: In REST, when adding a new field or deleting an
    old field, this needs to be published as a new version to support consumer compatibility.
    With GraphQL, versioning is no longer required – one, because GraphQL supports
    partial data fetching from the response structure, and two, it supports publishing
    depreciation warnings to a depreciated field for the GraphQL client.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需版本控制**：在 REST 中，当添加新字段或删除旧字段时，需要发布为新版本以支持消费者兼容性。在 GraphQL 中，版本控制不再需要——一方面，因为
    GraphQL 支持从响应结构中获取部分数据，另一方面，它支持向 GraphQL 客户端发布关于已弃用字段的降级警告。'
- en: '**Schema stitching or combining multiple GraphQL schema**: GraphQL provides
    multiple ways to combine different GraphQL schemas and APIs into a single endpoint
    without much coding or implementation hassle. This feature helps develop a single,
    centralized GraphQL gateway. A GraphQL gateway enables multiple GraphQL APIs to
    be consumed from a single endpoint. It also enables the dynamic addition of newer
    GraphQL APIs in the future seamlessly. This makes GraphQL federated and scalable.
    Combining schemas can be achieved by technologies such as Apollo GraphQL Federation
    and Atlassian GraphQL Braids.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式拼接或组合多个 GraphQL 模式**：GraphQL 提供了多种方法将不同的 GraphQL 模式和 API 组合到单个端点，而无需大量编码或实现上的麻烦。此功能有助于开发一个单一、集中的
    GraphQL 网关。一个 GraphQL 网关允许从单个端点消费多个 GraphQL API。它还允许未来无缝地动态添加新的 GraphQL API。这使得
    GraphQL 兼容和可扩展。通过 Apollo GraphQL Federation 和 Atlassian GraphQL Braids 等技术可以实现模式组合。'
- en: Now, let’s see when we should use GraphQL.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看何时应该使用 GraphQL。
- en: When to use GraphQL
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用 GraphQL
- en: 'The following are a few scenarios where the GraphQL API is a better solution
    than the REST API:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 GraphQL API 比 REST API 更好的场景：
- en: Apps where bandwidth usage matters, such as mobile apps or IoT device apps.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽使用量重要的应用程序，例如移动应用程序或物联网设备应用程序。
- en: Applications where there is a need for nested data to be fetched. GraphQL saves
    a lot of time and bandwidth, thus enabling better performance for GraphQL clients.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要获取嵌套数据的应用程序。GraphQL 可以节省大量时间和带宽，从而提高 GraphQL 客户端的性能。
- en: Applications that publish DaaS. Here, this DaaS is consumed by multiple downstream
    teams with different data fetch requirements.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布 DaaS 的应用程序。在这里，这个 DaaS 被多个下游团队消费，他们有不同的数据获取需求。
- en: When enabling GraphQL capabilities such as partial data fetching of the response
    and exposing a single endpoint by composing multiple APIs to improve the consumer
    experience for legacy REST-based applications.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启用 GraphQL 功能，如响应的部分数据获取，通过组合多个 API 来暴露单个端点，以改善基于遗留 REST 的应用程序的消费者体验时。
- en: In this section, we learned what GraphQL is and looked at typical use cases
    when GraphQL is used. In the next section, we will discuss the most popular GraphQL
    patterns that are used in the industry.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 GraphQL 是什么，并探讨了 GraphQL 常用的典型用例。在下一节中，我们将讨论在行业中广泛使用的最流行的 GraphQL
    模式。
- en: Core architectural patterns of GraphQL
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL 的核心架构模式
- en: 'In this section, we will discuss the various architectural patterns that are
    used for GraphQL. These patterns are independent of the technology used to implement
    it or the platform where it is deployed and executed. There are five different
    GraphQL patterns, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论用于 GraphQL 的各种架构模式。这些模式与实现它的技术或部署和执行的平台无关。以下是五种不同的 GraphQL 模式：
- en: '**DaaS pattern**: Here, GraphQL server is used to expose the database layer.
    It can expose three operations – queries, mutations, and subscriptions (please
    refer to the *Operation types* section of this chapter). Using these operations,
    it can achieve **Create, Read, Update and Delete** (**CRUD**) operations like
    REST but also supports subscriptions on top of it. The following diagram shows
    this pattern:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DaaS 模式**：在这里，GraphQL 服务器用于暴露数据库层。它可以暴露三种操作——查询、突变和订阅（请参阅本章的 *操作类型* 部分）。使用这些操作，它可以实现
    **创建、读取、更新和删除**（**CRUD**）操作，就像 REST 一样，但还支持在其之上进行订阅。以下图表展示了此模式：'
- en: '![Figure 10.6 – DaaS pattern ](img/B17084_10_006.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – DaaS 模式](img/B17084_10_006.jpg)'
- en: Figure 10.6 – DaaS pattern
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – DaaS 模式
- en: As we can see, GraphQL exposes its queries and operations using the HTTP protocol.
    GraphQL provides server libraries in multiple languages, using which teams can
    build and run GraphQL Server applications. Also, GraphQL supports a variety of
    GraphQL client libraries in different languages. A list of supported languages
    is available at [https://graphql.org/code/](https://graphql.org/code/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，GraphQL 使用 HTTP 协议公开其查询和操作。GraphQL 在多种语言中提供服务器库，使用这些库，团队可以构建和运行 GraphQL
    服务器应用程序。此外，GraphQL 还支持多种不同语言的 GraphQL 客户端库。支持的语言列表可在 [https://graphql.org/code/](https://graphql.org/code/)
    查找。
- en: '**Integration layer pattern**: Here, GraphQL Server caters to data to provide
    access to multiple data sources in one go. This enables GraphQL to act like a
    data integration hub. The following diagram depicts how the integration layer
    pattern works:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成层模式**：在这里，GraphQL 服务器提供数据，一次提供对多个数据源的访问。这使得 GraphQL 能够像一个数据集成中心。以下图表描述了集成层模式的工作原理：'
- en: '![Figure 10.7 – Integration layer pattern ](img/B17084_10_007.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 集成层模式](img/B17084_10_007.jpg)'
- en: Figure 10.7 – Integration layer pattern
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 集成层模式
- en: As we can see, GraphQL server is acting as an integration hub. It enables clients
    to make a single call, but the GraphQL server is fetching that data from different
    ecosystems such as microservices, legacy apps, and cloud APIs and sending a unified
    response to the client. This automatically reduces the complexity and number of
    calls that a GraphQL client must make.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，GraphQL 服务器正在充当集成中心。它使客户端能够进行单个调用，但 GraphQL 服务器从不同的生态系统（如微服务、遗留应用程序和云
    API）中获取数据，并向客户端发送统一的响应。这自动减少了 GraphQL 客户端必须进行的复杂性和调用次数。
- en: '**Hybrid pattern**: The third GraphQL pattern is called the hybrid pattern
    because it explores a hybrid approach to the first two patterns. Here, GraphQL
    Server not only needs to be connected to microservices legacy systems, but also
    databases. The following diagram shows this pattern:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合模式**：第三个 GraphQL 模式被称为混合模式，因为它探索了前两种模式的混合方法。在这里，GraphQL 服务器不仅需要连接到微服务和遗留系统，还需要连接到数据库。以下图显示了此模式：'
- en: '![Figure 10.8 – Hybrid pattern ](img/B17084_10_008.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 混合模式](img/B17084_10_008.jpg)'
- en: Figure 10.8 – Hybrid pattern
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 混合模式
- en: As we can see, GraphQL Server has its own database apart from the connections
    to different apps such as microservices and legacy systems. Therefore, GraphQL
    provides unified access to its client for different kinds of data sources when
    this pattern is used.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，GraphQL 服务器除了连接到不同的应用程序（如微服务和遗留系统）之外，还有自己的数据库。因此，当使用此模式时，GraphQL 为其客户端提供了对不同数据源的统一访问。
- en: '**GraphQL with managed API**: To expose GraphQL APIs in an enterprise, it is
    necessary to have security and monitoring enabled. In this pattern, API Gateway
    provides monitoring, security, and throttling on GraphQL Server. The following
    diagram shows this pattern:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有管理 API 的 GraphQL**：为了在企业中公开 GraphQL API，必须启用安全和监控。在此模式中，API 网关为 GraphQL
    服务器提供监控、安全和节流。以下图显示了此模式：'
- en: '![Figure 10.9 – GraphQL with managed API ](img/B17084_10_009.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 带有管理 API 的 GraphQL](img/B17084_10_009.jpg)'
- en: Figure 10.9 – GraphQL with managed API
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 带有管理 API 的 GraphQL
- en: '**Federated GraphQL pattern**: Here, a centralized GraphQL braid or federated
    GraphQL server is created. Other GraphQL nodes are connected to this GraphQL braid.
    Each of these nodes, in turn, fetches data from either a database, micro-service,
    or legacy app. The following diagram shows the federated GraphQL pattern:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联邦 GraphQL 模式**：在这里，创建了一个集中的 GraphQL 编织或联邦 GraphQL 服务器。其他 GraphQL 节点连接到这个
    GraphQL 编织。这些节点中的每一个，反过来，从数据库、微服务或遗留应用程序中获取数据。以下图显示了联邦 GraphQL 模式：'
- en: '![Figure 10.10 – Federated GraphQL pattern ](img/B17084_10_010.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 联邦 GraphQL 模式](img/B17084_10_010.jpg)'
- en: Figure 10.10 – Federated GraphQL pattern
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 联邦 GraphQL 模式
- en: The real power of this pattern is its amazing scalability and data federation.
    Newer nodes can be seamlessly added at any time to the GraphQL braid, without
    any application downtime.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的真正力量在于其惊人的可扩展性和数据联邦。可以在任何时间无缝地将新节点添加到 GraphQL 编织中，而无需任何应用程序停机时间。
- en: In this section, we learned about the various core GraphQL patterns, how they
    operate, and when they are useful. In the next section, we will learn how to develop
    a GraphQL server application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了各种核心 GraphQL 模式，它们的操作方式以及何时使用它们。在下一节中，我们将学习如何开发 GraphQL 服务器应用程序。
- en: A practical use case – exposing federated data models using GraphQL
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实际用例 – 使用 GraphQL 暴露联邦数据模型
- en: In this section, we will learn how to develop DaaS using GraphQL in Java. To
    implement the solution, we will publish the same set of APIs that we published
    earlier using REST, but this time, we will implement the solution using GraphQL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Java 开发 DaaS（数据即服务）使用 GraphQL。为了实现解决方案，我们将发布与之前使用 REST 发布的相同的一组
    API，但这次我们将使用 GraphQL 来实现解决方案。
- en: Before we start implementing GraphQL, it is important to design the GraphQL
    schema for our use case. In our use case, we need to read credit card applications
    from MongoDB using either the application ID or consumer ID. This was why we needed
    two separate endpoints in the REST-based solution (please refer to [*Chapter 9*](B17084_09.xhtml#_idTextAnchor144),
    *Exposing MongoDB Data as a Service*, for the REST-based DaaS solution).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现 GraphQL 之前，设计适合我们用例的 GraphQL 模式非常重要。在我们的用例中，我们需要使用应用程序 ID 或消费者 ID 从
    MongoDB 读取信用卡申请。这就是为什么在基于 REST 的解决方案中需要两个单独的端点（请参阅 [*第 9 章*](B17084_09.xhtml#_idTextAnchor144)，*将
    MongoDB 数据作为服务公开*，有关基于 REST 的 DaaS 解决方案）。
- en: 'Let’s analyze the requirements from a different perspective – that is, while
    considering the GraphQL-based solution. The biggest difference that GraphQL makes
    is that it reduces the number of endpoints, as well as the number of calls. So,
    for our use case, we will have a single endpoint. Also, according to our use case,
    we are only interested in fetching data. Hence, we will only be using the `Query`
    type of operation. To support multiple functionalities in GraphQL, we must have
    multiple such fields in the query that can take arguments such as the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从不同的角度分析需求 – 即，在考虑基于 GraphQL 的解决方案的同时。GraphQL 带来的最大不同之处在于它减少了端点数量以及调用次数。因此，对于我们的用例，我们将只有一个端点。此外，根据我们的用例，我们只对获取数据感兴趣。因此，我们只会使用
    `Query` 类型的操作。为了支持 GraphQL 中的多个功能，我们必须在查询中有多个这样的字段，这些字段可以接受如下参数：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our case, we need two such fields – `byApplicationId` and `byCustomerId`
    – both of which should return a custom type called `Application`. The following
    code snippet shows part of our GraphQL schema:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要两个这样的字段 – `byApplicationId` 和 `byCustomerId`，它们都应该返回一个名为 `Application`
    的自定义类型。以下代码片段显示了我们的 GraphQL 模式的一部分：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As shown in the preceding code block, `byApplicationId` always returns only
    one `Application`, as `applicationId` is a primary key. Therefore, `byApplicationId`
    is of the `Application` type. However, since there can be multiple applications
    for the same customer, `byCustomerId` is of the `[Application]` type, which denotes
    a list of `Application`. Now, let’s define the type – `Application` – in the GraphQL
    schema. The following code block shows the SDL for the `Application` type:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码块所示，`byApplicationId` 总是只返回一个 `Application`，因为 `applicationId` 是主键。因此，`byApplicationId`
    是 `Application` 类型。然而，由于同一个客户可能有多个应用程序，`byCustomerId` 是 `[Application]` 类型，表示
    `Application` 的列表。现在，让我们在 GraphQL 模式中定义类型 – `Application`。以下代码块显示了 `Application`
    类型的 SDL：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, in the SDL for the `Application` type, `applicationId` is of the `ID`
    type, which denotes that it is the unique key for the `Application` type. Also,
    the exclamation mark (`!`) seen in the `applicationId` and `id` fields denotes
    that those fields are non-nullable. The complete schema is available at [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter10/sourcecode/GraphQLDaas/src/main/resources/schema.graphqls](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter10/sourcecode/GraphQLDaas/src/main/resources/schema.graphqls).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，在 `Application` 类型的 SDL 中，`applicationId` 是 `ID` 类型，表示它是 `Application` 类型的唯一键。此外，在
    `applicationId` 和 `id` 字段中看到的感叹号（`!`）表示这些字段是非可空的。完整的模式可在 [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter10/sourcecode/GraphQLDaas/src/main/resources/schema.graphqls](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter10/sourcecode/GraphQLDaas/src/main/resources/schema.graphqls)
    找到。
- en: 'To create a Spring Boot Maven project and add the required Maven dependencies,
    the following Maven dependencies should be added in the `pom.xml` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Spring Boot Maven 项目并添加所需的 Maven 依赖项，应在 `pom.xml` 文件中添加以下 Maven 依赖项：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Apart from this, the following dependencies should be added to support MongoDB-related
    dependencies, as well as QueryDSL-related dependencies, in the Spring Boot application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，还应该在 Spring Boot 应用程序中添加以下依赖项以支持 MongoDB 相关依赖项以及 QueryDSL 相关依赖项：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Apart from these dependencies, we need to add build-plugins in the `pom.xml`
    file. These plugins help generate Q classes dynamically, which are required for
    QueryDSL to work properly. The following plugins need to be added:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些依赖项之外，我们还需要在 `pom.xml` 文件中添加构建插件。这些插件有助于动态生成 Q 类，这对于 QueryDSL 正常工作来说是必需的。以下插件需要添加：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'GraphQL-related dependencies also need to be added to the POM file of the project.
    The following GraphQL dependencies need to be added:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在项目的 POM 文件中添加 GraphQL 相关依赖项。以下 GraphQL 依赖项需要添加：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As shown in the preceding code block, to implement GraphQL server in Java, we
    need to import the `graphql-java` dependencies and the Spring Boot starter for
    GraphQL JAR file called `graphql-java-spring-boot-starter-webmvc`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码块所示，要在 Java 中实现 GraphQL 服务器，我们需要导入 `graphql-java` 依赖项和名为 `graphql-java-spring-boot-starter-webmvc`
    的 GraphQL Spring Boot Starter JAR 文件。
- en: 'Now that we have added all the necessary dependencies, we will create the entry
    point, or the `Main` class, of our Spring Boot application, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所有必要的依赖项，我们将创建 Spring Boot 应用程序的入口点，即 `Main` 类，如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, we will create the `MongoConfig` class, which creates two Mongo Spring
    beans of the `MongoClient` and `MongoTemplate` type, as shown in the following
    code block:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 `MongoConfig` 类，它创建两个 `MongoClient` 和 `MongoTemplate` 类型的 Mongo Spring
    Bean，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will create a POJO class called `Application`, which represents the
    data model. It should be annotated by `org.springframework.data.mongodb.core.mapping.Document
    annotation` and `com.querydsl.core.annotations.QueryEntity annotation`. The following
    code denotes the `Application` bean:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为 `Application` 的 POJO 类，它代表数据模型。它应该由 `org.springframework.data.mongodb.core.mapping.Document`
    注解和 `com.querydsl.core.annotations.QueryEntity` 注解标注。以下代码表示 `Application` 实例：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `@Document` denotes that the POJO is a bean that is mapped to a document
    in MongoDB, while `@QueryEntity` is required to enable QueryDSL’s querying capabilities
    over the `Application` bean.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@Document` 表示 POJO 是一个映射到 MongoDB 文档的 Bean，而 `@QueryEntity` 是必需的，以启用 QueryDSL
    在 `Application` Bean 上的查询功能。
- en: 'Now, just like the REST-based solution discussed in [*Chapter 9*](B17084_09.xhtml#_idTextAnchor144),
    *Exposing MongoDB Data as a Service*, we must create an `ApplicationRepository`
    interface that extends the `MongoRepository` and `QuerydslPredicateExecutor` interfaces.
    Using this class, we will define two methods to fetch application data from MongoDB
    using QueryDSL. The following code snippet is for the `ApplicationRepository`
    class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像在[*第9章*](B17084_09.xhtml#_idTextAnchor144)中讨论的基于 REST 的解决方案一样，*将 MongoDB
    数据作为服务公开*，我们必须创建一个 `ApplicationRepository` 接口，它扩展了 `MongoRepository` 和 `QuerydslPredicateExecutor`
    接口。使用这个类，我们将定义两个方法，使用 QueryDSL 从 MongoDB 获取应用程序数据。以下代码片段是 `ApplicationRepository`
    类的：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will skip explaining this repository interface as it is identical to the
    interface we created in the previous chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过解释这个仓库接口，因为它与我们之前在第十章创建的接口相同。
- en: 'Now that we have finished developing the DAO layer, let’s create a package
    called `helper`. In a GraphQL Java application, we need two kinds of classes –
    one should be the GraphQL provider and the other should be the GraphQL data fetcher.
    Here, we will start by writing the provider class under the `helper` package.
    In the `GraphQLProvider` class, first, we will define a property of the `graphql.GraphQL`
    type and initialize it as soon as the `GraphQLProvider` bean is initialized by
    Spring Boot. The code snippet for this is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 DAO 层的开发，让我们创建一个名为 `helper` 的包。在 GraphQL Java 应用程序中，我们需要两种类型的类——一个是
    GraphQL 提供者，另一个是 GraphQL 数据获取器。在这里，我们将从 `helper` 包开始编写提供者类。在 `GraphQLProvider`
    类中，首先，我们将定义一个 `graphql.GraphQL` 类型的属性，并在 `GraphQLProvider` Bean 由 Spring Boot
    初始化时立即初始化它。以下是这个的代码片段：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A GraphQL server should have a strongly typed well-defined schema (please refer
    to the earlier discussion about the GraphQL schema). Here, in the `init` method,
    we load the GraphQL schema from the resources. The GraphQL schema definition is
    read and stored in the string `object named sdl` using the utility methods of
    `com.google.common.io.Resources`. Then, the `GraphQLSchema` object is derived
    from the `sdl` object, which is built using the `buildSchema` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 GraphQL 服务器应该有一个强类型、定义良好的模式（请参阅关于 GraphQL 模式的早期讨论）。在这里，在 `init` 方法中，我们从资源中加载
    GraphQL 模式。使用 `com.google.common.io.Resources` 的实用方法读取并存储 GraphQL 模式定义在名为 `sdl`
    的字符串中。然后，从 `sdl` 对象中派生出 `GraphQLSchema` 对象，该对象使用 `buildSchema` 方法构建。
- en: In the `buildSchema` method, the `sdl` object is parsed using `SchemaParser`
    and converted into the `TypeDefinitionRegistry` object. Runtime wiring is the
    process of attaching data fetchers, type resolvers, and custom scalars. First,
    we build the wiring required to complete the GraphQL schema using the `buildWiring`
    method. Then, using `SchemaGenerator.makeExecutableSchema`, we create a `GraphQLSchema`
    object with the required `runtimeWiring`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `buildSchema` 方法中，使用 `SchemaParser` 解析 `sdl` 对象并将其转换为 `TypeDefinitionRegistry`
    对象。运行时连接是将数据获取器、类型解析器和自定义标量连接起来的过程。首先，我们使用 `buildWiring` 方法构建完成 GraphQL 模式所需的连接。然后，使用
    `SchemaGenerator.makeExecutableSchema`，我们创建一个具有所需 `runtimeWiring` 的 `GraphQLSchema`
    对象。
- en: Necessary reference
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的参考资料
- en: 'Usually, to completely create an executable GraphQL schema, three kinds of
    bindings might be required. They are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了完全创建一个可执行的 GraphQL 模式，可能需要三种类型的绑定。它们如下所示：
- en: '- **Data fetchers**, which are interfaces that help fetch data for a GraphQL
    schema.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '- **数据获取器**，是帮助为 GraphQL 模式获取数据的接口。'
- en: '- Type resolvers, which are custom methods that resolve the value of a GraphQL
    field.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型解析器，是自定义方法，用于解析 GraphQL 字段的值。'
- en: '- Custom scalars, which refer to any customized data types. Data types in GraphQL
    are known as **scalars**.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '- 自定义标量，指的是任何自定义的数据类型。在 GraphQL 中，数据类型被称为 **标量**。'
- en: Now, let’s discuss the implementation of the `buildWiring` method. This method
    creates a new `Runtimewiring` by attaching GraphQL data fetchers to the two different
    fields (`byApplicationId` and `byCustomerId`) in the GraphQL schema (the GraphQL
    schema for this use case was discussed earlier in this chapter).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 `buildWiring` 方法的实现。此方法通过将 GraphQL 数据获取器附加到 GraphQL 模式中的两个不同字段（`byApplicationId`
    和 `byCustomerId`）来创建一个新的 `Runtimewiring`（在本章中之前讨论了此用例的 GraphQL 模式）。
- en: 'Finally, using this `GraphQLSchema`, we build and instantiate the GraphQL property.
    Now, we can expose a bean called `GraphQL` by returning this GraphQL object, as
    shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用此 `GraphQLSchema`，我们构建并实例化 GraphQL 属性。现在，我们可以通过返回此 GraphQL 对象来公开一个名为 `GraphQL`
    的 Bean，如下所示：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While implementing the `buildWiring` method, two methods from the `GraphQLDataFetcher`
    class called `getApplicationbyApplicationIdDataFetcher` and `getApplicationsbyCustomerIdDataFetcher`
    are called. So, let’s discuss how the `GraphQLDatafetcher` class is implemented.
    All the data fetcher methods must return an object of the `graphql.schema.DataFetcher`
    type. The definition of the `DataFetcher` interface looks as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `buildWiring` 方法时，调用了 `GraphQLDataFetcher` 类中的两个方法 `getApplicationbyApplicationIdDataFetcher`
    和 `getApplicationsbyCustomerIdDataFetcher`。因此，让我们讨论一下 `GraphQLDatafetcher` 类是如何实现的。所有数据获取器方法都必须返回一个
    `graphql.schema.DataFetcher` 类型的对象。`DataFetcher` 接口的定义如下：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As shown in the preceding code block, the `DataFetcher` interface has only
    one method, which takes an argument of the `graphql.schema.DataFetchingEnvironment`
    type. So, we can implement this interface as a Lambda function in Java. In our
    case, we call the `applicationRepository` class to fetch the data required for
    populating the `Application` object(s) we are publishing. The following code shows
    the implementation of `getApplicationbyApplicationIdDataFetcher`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码块所示，`DataFetcher` 接口只有一个方法，该方法接受一个 `graphql.schema.DataFetchingEnvironment`
    类型的参数。因此，我们可以在 Java 中将其实现为一个 Lambda 函数。在我们的案例中，我们调用 `applicationRepository` 类来获取用于填充我们发布的
    `Application` 对象所需的数据。以下代码展示了 `getApplicationbyApplicationIdDataFetcher` 的实现：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While implementing the `getApplicationbyApplicationIdDataFetcher` method, we
    are returning the Lambda function, which takes the `dataFetchingEnvironment` argument.
    All the arguments of the field that a data fetcher is written for can be accessed
    by the `getArgument` method of the `DataFetchingEnvironment` class. In this scenario,
    it is fetching the `applicationId` argument. Finally, as evident from the code
    snippet, we use `applicationRepository` to fetch data from MongoDB. Similar logic
    is used for writing the `getApplicationsbyCustomerIdDataFetcher` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `getApplicationbyApplicationIdDataFetcher` 方法时，我们返回一个 Lambda 函数，该函数接受 `dataFetchingEnvironment`
    参数。数据获取器为字段编写的所有参数都可以通过 `DataFetchingEnvironment` 类的 `getArgument` 方法访问。在这种情况下，它正在获取
    `applicationId` 参数。最后，如代码片段所示，我们使用 `applicationRepository` 从 MongoDB 获取数据。类似的逻辑用于编写
    `getApplicationsbyCustomerIdDataFetcher` 方法。
- en: Now, we need to keep the `schema.graphqls` file, which contains the GraphQL
    schema, in the `resource` folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将包含 GraphQL 模式的 `schema.graphqls` 文件保存在 `resource` 文件夹中。
- en: 'Finally, we need to define the `application.yaml` file to run the Spring Boot
    application. The `application.yaml` file looks as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义 `application.yaml` 文件来运行 Spring Boot 应用程序。`application.yaml` 文件如下所示：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have developed the GraphQL Server application, let’s explore how
    can we test it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开发出了 GraphQL 服务器应用程序，让我们探索如何测试它。
- en: 'First, run the application by running the `Main` class, as shown in the following
    screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过运行 `Main` 类来启动应用程序，如下截图所示：
- en: '![Figure 10.11 – Running the GraphQL server application ](img/B17084_10_011.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 运行 GraphQL 服务器应用程序](img/B17084_10_011.jpg)'
- en: Figure 10.11 – Running the GraphQL server application
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 运行 GraphQL 服务器应用程序
- en: 'Now, to test the application, open GraphQL Playground and enter the DaaS endpoint.
    The DaaS endpoint should look as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试应用程序，请打开 GraphQL Playground 并输入 DaaS 端点。DaaS 端点应如下所示：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you hit this URL on GraphQL Playground and enter a proper `graphql` request
    payload, you will get the result in GraphQL Playground, as shown in the following
    screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 GraphQL Playground 上点击此 URL 并输入适当的 `graphql` 请求有效负载，你将在 GraphQL Playground
    中获得结果，如下截图所示：
- en: '![Figure 10.12 – Testing the GraphQL DaaS using GraphQL Playground ](img/B17084_10_012.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 使用 GraphQL Playground 测试 GraphQL DaaS](img/B17084_10_012.jpg)'
- en: Figure 10.12 – Testing the GraphQL DaaS using GraphQL Playground
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 使用 GraphQL Playground 测试 GraphQL DaaS
- en: As we can see, while calling the GraphQL Service application, the client sends
    the list of fields it wants to fetch. As shown in the request payload, although
    the GraphQL Server application supports many more fields, in this example, the
    client has only requested four fields – that is, `applicationId`, `genderCode`,
    `id`, and `riskScore`. Hence, GraphQL resolves and sends only those four fields
    back to the consumer. This feature of GraphQL helps overcome the problem of over-fetching
    or under-fetching (typically seen in REST-based DaaS).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在调用 GraphQL 服务应用程序时，客户端发送它想要获取的字段列表。正如请求有效负载所示，尽管 GraphQL 服务器应用程序支持更多的字段，但在本例中，客户端只请求了四个字段
    – 即 `applicationId`、`genderCode`、`id` 和 `riskScore`。因此，GraphQL 仅解析并发送这四个字段回消费者。GraphQL
    的这一特性有助于克服过度获取或不足获取的问题（通常在基于 REST 的 DaaS 中看到）。
- en: 'Also, GraphQL supports multiple functionalities in a single call. In our use
    case, we have two functions – fetch application by `applicationId` and fetch all
    the applications for a customer using `customerid`. Both can be achieved in a
    single call using GraphQL. The following screenshot shows an example of this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，GraphQL 支持在单个调用中执行多个功能。在我们的用例中，我们有两个功能 – 通过 `applicationId` 获取应用程序和通过 `customerid`
    获取客户的全部应用程序。这两个功能都可以使用 GraphQL 在单个调用中实现。以下截图展示了这一示例：
- en: '![Figure 10.13 – Supporting multiple business operations in a single GraphQL
    call ](img/B17084_10_013.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 在单个 GraphQL 调用中支持多个业务操作](img/B17084_10_013.jpg)'
- en: Figure 10.13 – Supporting multiple business operations in a single GraphQL call
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 在单个 GraphQL 调用中支持多个业务操作
- en: As we can see, both fields – `byApplicationId` and `byCustomerId` – can be requested
    in a single GraphQL call that fetches data for both fields in a single GraphQL
    response. This reduces the number of hits to the GraphQL service and clients can
    improve their application performance by making fewer calls to the GraphQL Server
    application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两个字段 – `byApplicationId` 和 `byCustomerId` – 都可以在单个 GraphQL 调用中请求，该调用在单个
    GraphQL 响应中获取这两个字段的数据。这减少了 GraphQL 服务的调用次数，客户端可以通过减少对 GraphQL 服务器应用程序的调用来提高其应用程序的性能。
- en: 'Apart from these two advantages, GraphQL also enables easy schema and document
    sharing. As shown in the preceding screenshot, there are two sidewise tabs called
    **DOCS** and **SCHEMA** to the extreme right. **SCHEMA** can show us the supported
    GraphQL schema from the server. It tells us what data points are available as
    a part of this GraphQL API. The following screenshot shows how a client can see
    the schema of a GraphQL service:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个优点之外，GraphQL 还使得架构和文档的共享变得容易。如图所示，在最右侧有两个侧边标签，分别称为 **DOCS** 和 **SCHEMA**。**SCHEMA**
    可以显示服务器支持的 GraphQL 架构。它告诉我们哪些数据点可以作为此 GraphQL API 的一部分。以下截图显示了客户端如何查看 GraphQL
    服务的架构：
- en: '![Figure 10.14 – Checking the GraphQL schema from GraphQL Playground ](img/B17084_10_014.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 从 GraphQL Playground 检查 GraphQL 架构](img/B17084_10_014.jpg)'
- en: Figure 10.14 – Checking the GraphQL schema from GraphQL Playground
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 从 GraphQL Playground 检查 GraphQL 架构
- en: 'Apart from this, documentation is another cool feature that GraphQL provides.
    In the world of REST, sharing the API with the client is not sufficient. Therefore,
    we need to build and maintain the documentation separately (either using Swagger
    or otherwise) and share it. However, GraphQL allows you to easily maintain and
    publish documents, as shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，文档是 GraphQL 提供的另一个酷炫功能。在 REST 世界中，仅与客户端共享 API 是不够的。因此，我们需要单独构建和维护文档（无论是使用
    Swagger 还是其他方式）并共享它。然而，GraphQL 允许你轻松维护和发布文档，如下面的截图所示：
- en: '![Figure 10.15 – Easily sharing GraphQL documentation ](img/B17084_10_015.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 简单分享 GraphQL 文档](img/B17084_10_015.jpg)'
- en: Figure 10.15 – Easily sharing GraphQL documentation
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 简单分享 GraphQL 文档
- en: 'What’s more interesting about GraphQL documentation is that it is very easy
    to configure and maintain. All we need to do is add a documentation comment above
    each field and query it to support the documentation. For example, the documentation
    of the `applicationId` field can easily be incorporated into the GraphQL Schema
    SDL, as shown in the following code block:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，GraphQL 文档的配置和维护非常简单。我们只需在每个字段上方添加一个文档注释，并查询它以支持文档。例如，`applicationId`
    字段的文档可以轻松地集成到 GraphQL Schema SDL 中，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, all the documentation is written inside a documentation comment,
    which starts with three double quotes (`""`) and ends with three double quotes
    (`""`). GraphQL automatically uses the schema SDL to publish the documentation,
    hence making maintenance and publishing documentation super simple and easy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，所有文档都写在文档注释中，注释以三个双引号（`""`）开始，以三个双引号（`""`）结束。GraphQL 自动使用 schema SDL 发布文档，因此维护和发布文档变得超级简单和容易。
- en: In this section, we learned how to develop a GraphQL server application using
    Java. We also learned about GraphQL DSL for developing GraphQL schemas. Finally,
    we learned how to effectively test and verify the GraphQL DaaS API using GraphQL
    Playground. Now, let’s summarize what we learned in this chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 Java 开发 GraphQL 服务器应用程序。我们还了解了用于开发 GraphQL 模式的 GraphQL DSL。最后，我们学习了如何有效地使用
    GraphQL Playground 测试和验证 GraphQL DaaS API。现在，让我们总结一下本章所学的内容。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the basic concepts of GraphQL. First, we learned
    how GraphQL can overcome the pitfalls of REST-based DaaS and the benefits it provides.
    Then, we discussed when to choose GraphQL as a preferred solution. Finally, we
    learned how to develop a GraphQL server application using Java and how to test
    that application using GraphQL Playground.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 GraphQL 的基本概念。首先，我们了解了 GraphQL 如何克服基于 REST 的 DaaS 的陷阱以及它提供的优势。然后，我们讨论了何时选择
    GraphQL 作为首选解决方案。最后，我们学习了如何使用 Java 开发 GraphQL 服务器应用程序以及如何使用 GraphQL Playground
    测试该应用程序。
- en: Now that we have learned how to design and develop data engineering solutions
    for both data ingestion scenarios and data publication scenarios, in the next
    chapter, we will discuss performance engineering and learn how to use a data-driven
    approach to make architectural decisions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何为数据摄取场景和数据发布场景设计和发展数据工程解决方案，在下一章中，我们将讨论性能工程并学习如何使用数据驱动的方法来做出架构决策。
- en: Section 4 – Choosing Suitable Data Architecture
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 节 – 选择合适的数据架构
- en: In the final section of the book, you will learn how to measure a solution and
    determine the efficiency of a solution. You will also learn how to communicate
    and present their solution to leadership/clients who may not be very technical.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一节，你将学习如何衡量解决方案并确定解决方案的效率。你还将学习如何向可能不太懂技术的领导/客户沟通和展示他们的解决方案。
- en: 'This section comprises the following chapters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 11*](B17084_11.xhtml#_idTextAnchor168)*, Measuring Performance and
    Benchmarking Your Applications*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 11 章*](B17084_11.xhtml#_idTextAnchor168)*，衡量性能和基准测试你的应用程序*'
- en: '[*Chapter 12*](B17084_12.xhtml#_idTextAnchor180)*, Evaluating, Recommending,
    and Presenting Your Solutions*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 12 章*](B17084_12.xhtml#_idTextAnchor180)*，评估、推荐和展示你的解决方案*'
