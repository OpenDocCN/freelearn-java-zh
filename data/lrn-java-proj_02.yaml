- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Variables and Primitive Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和原始数据类型
- en: In [*Chapter 1*](B19793_01.xhtml#_idTextAnchor018), we introduced the compiler
    and the JVM. We learned how to use both of them from the command line when we
    wrote our first Java program, *HelloWorld*. We also introduced **IntelliJ**, a
    powerful and friendly IDE, and we ran *HelloWorld* from there as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B19793_01.xhtml#_idTextAnchor018)中，我们介绍了编译器和JVM。当我们编写第一个Java程序*HelloWorld*时，我们学习了如何从命令行使用它们。我们还介绍了**IntelliJ**，一个强大且友好的IDE，并且也从那里运行了*HelloWorld*。
- en: All programming languages require variables and provide in-built primitive data
    types. They are essential for the operation of even the simplest programs. By
    the end of this chapter, you will be able to declare variables using Java’s primitive
    types. In addition, you will understand the differences between the various primitive
    data types and which ones to use in a given situation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言都需要变量并提供内置的原始数据类型。它们是甚至最简单程序操作的基础。在本章结束时，你将能够使用Java的原始数据类型声明变量。此外，你将了解不同原始数据类型之间的区别以及在特定情况下应使用哪些类型。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding and declaring variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和声明变量
- en: Exploring Java’s primitive data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Java的原始数据类型
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch2](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch2).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch2](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch2)。
- en: Understanding and declaring variables
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和声明变量
- en: If you want to store a value for later use, you need a variable. Therefore,
    every programming language provides this feature via variables. In this section,
    we will learn what a variable is and how to declare one. The area in your code
    where you can use a particular variable is known as the variable’s *scope*. This
    is a very important concept and will be covered in detail in [*Chapter 4*](B19793_04.xhtml#_idTextAnchor087).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要存储一个用于以后使用的值，你需要一个变量。因此，每种编程语言都通过变量提供这个功能。在本节中，我们将学习什么是变量以及如何声明它。你可以在代码中使用的特定变量的区域称为变量的*作用域*。这是一个非常重要的概念，将在[*第4章*](B19793_04.xhtml#_idTextAnchor087)中详细讨论。
- en: What is a variable?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是变量？
- en: Variables are locations in memory that have a *name* (called an identifier)
    and a *type*. They resemble named pigeonholes or post office boxes (see *Figure
    2**.1*). The variable’s name is required so that we can refer to the variable
    and distinguish it from other variables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是内存中的位置，具有一个*名称*（称为标识符）和一个*类型*。它们类似于带名称的鸽巢或邮政信箱（参见*图2.1*）。变量的名称是必需的，这样我们才能引用变量并将其与其他变量区分开来。
- en: A variable’s *type* specifies the sort of values it can store/hold. For example,
    is the variable to be used for storing whole numbers such as 4 or decimal numbers
    such as 2.98? The answer to that question determines the variable’s *type*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的*类型*指定它可以存储/保留的值的类型。例如，变量是用来存储像4这样的整数还是像2.98这样的十进制数？对这个问题的回答决定了变量的*类型*。
- en: Declaring a variable
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: Let’s suppose we want to store the number 25 in a variable. We will assume that
    this number represents a person’s age, so we will use the `age` identifier to
    refer to it. Introducing a variable for the first time is known as “declaring”
    the variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将数字25存储在一个变量中。我们将假设这个数字代表一个人的年龄，因此我们将使用`age`标识符来引用它。第一次引入变量被称为“声明”变量。
- en: A whole number (positive or negative) is an integer and Java provides an in-built
    primitive type especially for integers called `int`. We will discuss primitive
    data types in more detail in the next section. When declaring a variable in Java,
    we must specify the variables type. This is because Java is known as a *strongly
    typed* language, which means you must specify the variable’s type immediately
    upon declaring it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整数（正数或负数）是一个整数，Java提供了一个专门用于整数的内置原始类型，称为`int`。我们将在下一节中更详细地讨论原始数据类型。在Java中声明变量时，我们必须指定变量的类型。这是因为Java被称为*强类型*语言，这意味着你必须立即在声明变量时指定它的类型。
- en: 'Let’s declare a variable, give it a type, and initialize it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个变量，给它一个类型，并初始化它：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line declares `age` as an `int` and the second line assigns it a value
    of `25`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将`age`声明为`int`，第二行将其赋值为`25`。
- en: Note that the semi-colons (`;`) at the end of the lines are delimiters that
    tell the compiler where a Java statement ends. The `=` sign is the assignment
    operator and will be covered in [*Chapter 3*](B19793_03.xhtml#_idTextAnchor067).
    For now, just realize that `25` is “assigned into” the `age` variable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，行尾的分号（`;`）是分隔符，告诉编译器Java语句在哪里结束。等号（`=`）是赋值运算符，将在[*第3章*](B19793_03.xhtml#_idTextAnchor067)中介绍。现在，只需明白`25`被“赋值给”`age`变量。
- en: Assignment operator
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: The `=` sign in Java is not the same as the equals sign, =, in mathematics.
    Java uses the `==` sign for equals, which is called equivalence.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的`=`符号与数学中的等于符号（=）不同。Java使用`==`符号表示等于，这被称为等价。
- en: 'We can write the previous two lines of code in one line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的两行代码写在一行中：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Figure 2**.1* shows the in-memory representation of both code segments:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.1*显示了这两个代码段的内存表示：'
- en: '![Figure 2.1 – An integer variable named age with a value of 25](img/B19793_02_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 命名为age的整型变量，其值为25](img/B19793_02_01.jpg)'
- en: Figure 2.1 – An integer variable named age with a value of 25
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 命名为age的整型变量，其值为25
- en: As can be seen in *Figure 2**.1*, **age** is the name of the variable and **25**
    is the integer value stored in the variable’s *location*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图2**.1*所示，**age**是变量的名称，**25**是存储在变量*位置*中的整数值。
- en: Naming a variable
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量命名
- en: An identifier is simply a name that you give to the Java construct you are coding;
    for example, identifiers (names) are required for naming variables, methods, classes,
    and so forth.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符只是你给正在编写的Java结构起的名字；例如，命名变量、方法、类等都需要标识符（名称）。
- en: Identifiers
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符
- en: An identifier consists of letters, digits, underscores, and currency symbols.
    Identifiers cannot begin with a number and cannot contain whitespace (spaces,
    tabs, and newlines). In the following examples, the commas separate the various
    identifiers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符由字母、数字、下划线和货币符号组成。标识符不能以数字开头，也不能包含空白（空格、制表符和换行符）。在以下示例中，逗号分隔了不同的标识符。
- en: Examples of unusual but *valid* identifiers are `a£€_23`, `_29`, `Z`, `thisIsAnExampleOfAVeryLongVariableName`,
    `€2_`, and `$``4 ;`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些不寻常但*有效*的标识符示例有 `a£€_23`, `_29`, `Z`, `thisIsAnExampleOfAVeryLongVariableName`,
    `€2_`, 和 `$``4 ;`.
- en: Examples of *invalid* identifiers are `9age` and `abc def;`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*无效*的标识符示例有`9age`和`abc def;`.'
- en: 'Name your variables carefully. This helps make code more readable, which results
    in fewer bugs and easier maintenance. *Camel case* is a very popular technique
    in this regard. Concerning variable names, camel case means that *all* of the
    first word is lowercase. In addition, the first letter in each subsequent word
    in the variable name starts with an uppercase letter. Here’s an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细命名你的变量。这有助于使代码更易读，从而减少错误并便于维护。*驼峰式命名法*在这方面非常流行。关于变量名，驼峰式命名法意味着*所有*第一个单词都是小写。此外，变量名中每个后续单词的第一个字母都是大写字母。以下是一个例子：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code segment, we have two integer variables whose names/identifiers
    follow camel casing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码段中，我们有两个整数变量，它们的名称/标识符遵循驼峰式命名法。
- en: Accessing a variable
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问变量
- en: 'To access a variable’s value, just type in the variable’s name. When we type
    in a variable’s name in Java, the compiler will first ensure that a variable with
    that name exists. Assuming there is, the JVM will, at runtime, return the *value
    inside* that variable’s pigeonhole. Therefore, the following code will output
    `25` to the screen:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问变量的值，只需输入变量的名称。当我们输入Java中的变量名称时，编译器将首先确保存在具有该名称的变量。假设存在，JVM将在运行时返回该变量的*内部值*。因此，以下代码将在屏幕上输出`25`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line declares the `age` variable and initializes it to `25`. The second
    line accesses the variable’s location and outputs its value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了`age`变量并将其初始化为`25`。第二行访问变量的位置并输出其值。
- en: System.out.println()
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println()
- en: '`System.out.println()` displays whatever is inside the round brackets, `()`,
    on the screen.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println()`在屏幕上显示括号`()`内的任何内容。'
- en: Accessing a variable that you have not declared
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问未声明的变量
- en: 'As stated previously, Java is known as a *strongly typed* language. This means
    that you have to specify the variable’s type immediately upon declaring it. If
    the compiler comes across a variable and does not know its type, it generates
    an error. For example, consider the following line of code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Java是一种*强类型*语言。这意味着你必须在声明变量时立即指定其类型。如果编译器遇到一个变量而不知道其类型，它将生成错误。例如，考虑以下代码行：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Assuming no other code declares `age`, the compiler generates an error stating
    `cannot resolve symbol 'age'`. This is because the compiler is looking for the
    *type* to associate with *age* and it cannot find it (as we did not specify the
    type).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设没有其他代码声明 `age`，编译器将生成一个错误，指出 `cannot resolve symbol 'age'`。这是因为编译器正在寻找与 `age`
    关联的 *类型*，但它找不到它（因为我们没有指定类型）。
- en: 'Here is a slightly different example. In this example, we are attempting to
    output the `age` variable to the screen:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个稍微不同的例子。在这个例子中，我们试图将 `age` 变量输出到屏幕上：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we have declared a variable named `length` and thus, there
    is no declaration of `age`. When we attempt to access the `age` variable in `System.out.println()`,
    the compiler goes looking for `age`. The compiler cannot find `age` and generates
    an error stating `cannot resolve symbol 'age'`. In effect, what the compiler is
    saying is that we have attempted to use a variable named `age` that the compiler
    cannot find. This is because we did not even declare the variable, not to mention
    specify its type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明了一个名为 `length` 的变量，因此没有声明 `age`。当我们尝试在 `System.out.println()` 中访问
    `age` 变量时，编译器会寻找 `age`。编译器找不到 `age` 并生成一个错误，指出 `cannot resolve symbol 'age'`。实际上，编译器所说的是我们尝试使用编译器找不到的名为
    `age` 的变量。这是因为我们甚至没有声明该变量，更不用说指定其类型了。
- en: Comments
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Comments are very useful as they help us explain what is happening in the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注释非常有用，因为它们帮助我们解释代码中的内容。
- en: '`//` is a single-line comment. When the compiler sees `//`, it ignores the
    rest of the line.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`//` 是单行注释。当编译器看到 `//` 时，它会忽略该行剩余的部分。'
- en: .`/* some text */` is a multi-line comment. Anything between the opening `/*`
    and the closing `*/` is ignored. This format saves inserting `//` at the start
    of each line.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: .`/* some text */` 是多行注释。在 `/*` 开头和 `*/` 结尾之间的任何内容都被忽略。这种格式可以节省在每个行首插入 `//`。
- en: 'Here are some examples:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '`int age; // from here to the rest of the line` `is ignored`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`int age; // from here to the rest of the line` `is ignored`'
- en: '`// this whole line` `is ignored`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`// this whole line` `is ignored`'
- en: '`/*` `all`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`/*` `all`'
- en: '`of`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`of`'
- en: '`these lines`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`these lines`'
- en: '`are`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`are`'
- en: '`ignored */`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignored */`'
- en: Given that Java, as a strongly typed language, requires all variables to have
    a data type, we will now discuss Java’s support for primitive data types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 作为一种强类型语言，要求所有变量都有数据类型，我们将现在讨论 Java 对原始数据类型的支持。
- en: Understanding Java’s primitive data types
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Java 的原始数据类型
- en: Java provides eight in-built data types. In-built means that these data types
    come with the language. These primitive data types are the topic of this section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了八个内置数据类型。内置意味着这些数据类型与语言一起提供。这些原始数据类型是本节的主题。
- en: Java’s primitive data types
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 的原始数据类型
- en: All of the primitive data types are named using lowercase letters only; for
    example, `int` and `double`. When we create our own data types later on, namely
    classes, records, and interfaces, we will follow a different naming convention.
    For example, we may have a class named `Person` or `Cat`. This is simply a widely
    adopted coding convention and the compiler does not distinguish between naming
    conventions. However, it is very easy to recognize any of the primitive data types
    as they are always in lowercase letters only. Before we discuss the primitive
    data types themselves, there are a few important points to make.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的原始数据类型都只使用小写字母命名；例如，`int` 和 `double`。当我们稍后创建自己的数据类型，即类、记录和接口时，我们将遵循不同的命名约定。例如，我们可能有一个名为
    `Person` 或 `Cat` 的类。这只是一个广泛采用的编码约定，编译器不会区分命名约定。然而，很容易识别任何原始数据类型，因为它们总是只使用小写字母。在我们讨论原始数据类型本身之前，有一些重要的事项需要说明。
- en: Numeric primitive data types are signed
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字原始数据类型是有符号的
- en: In Java, all numeric primitive data types are represented as a series of bits.
    In addition, they are also signed. The most significant bit (leftmost bit) is
    used for the sign; 1 means negative and 0 means positive.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，所有数字原始数据类型都表示为一系列位。此外，它们也是有符号的。最高有效位（最左边的位）用于表示符号；1 表示负数，0 表示正数。
- en: Integer literals
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量
- en: 'A literal value is one that’s typed in at the keyboard (as opposed to a computed
    value). An integer literal can be expressed in various numbering systems: decimal
    (base 10), hexadecimal (base 16), octal (base 8), and binary (base 2). However,
    it is no surprise that decimal is by far the most commonly used representation.
    For information purposes, all of the following declarations represent the decimal
    number 10:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文字值是在键盘上键入的值（与计算值相对）。整数文字可以用不同的数制表示：十进制（基数 10）、十六进制（基数 16）、八进制（基数 8）和二进制（基数
    2）。然而，十进制是使用最广泛的表示方式并不令人惊讶。为了信息目的，以下所有声明都表示十进制数字 10：
- en: '`int a = 10; // decimal,` `the default`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`int a = 10; // 十进制，默认`'
- en: '`int b = 0b1010; // binary, prefixed by 0b` `or 0B`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`int b = 0b1010; // 二进制，以 0b 或 0B 开头`'
- en: '`int c = 012; // octal, prefixed` `by 0`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`int c = 012; // 八进制，以 0 开头`'
- en: '`int d = 0xa; // hexadecimal, prefixed by 0x` `or 0X`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`int d = 0xa; // 十六进制，以 0x 或 0X 开头`'
- en: The sign bit affects the range
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号位影响范围
- en: The presence of the sign bit means that `byte` has a range of -27 to 27-1 (-128
    to +127 inclusive). The -1 in the positive range is to allow for the fact that,
    in Java, 0 is considered a positive number. There is *not* one less positive number
    in any of the ranges. For example, with `byte`, you have 128 negative numbers
    (-1 to -128) and 128 positive numbers (0 to +127), resulting in 256 representations
    (28). To reinforce this point with a simple example, -1 to -8 is 8 numbers and
    0 to 7 (inclusive) is 8 numbers also.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 符号位的存在意味着 `byte` 的范围是 -27 到 27-1（-128 到 +127，包括 +127）。正数范围内的 -1 是为了允许在 Java
    中 0 被视为正数的事实。在任何范围内都没有一个更少的正数。例如，对于 `byte`，你有 128 个负数（-1 到 -128）和 128 个正数（0 到
    +127），结果有 256 种表示（2^8）。为了通过一个简单的例子来强调这一点，-1 到 -8 是 8 个数字，0 到 7（包括 0）也是 8 个数字。
- en: 'With these points discussed, let’s look at the various primitive types. *Table
    2.1* lists the eight primitive data types, their byte sizes, and their ranges
    (all of which are inclusive):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了这些观点后，让我们来看看各种原始类型。*表 2.1* 列出了八个原始数据类型、它们的字节大小和它们的范围（所有这些都是包括在内的）：
- en: '![](img/B19793_02_Table_01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19793_02_Table_01.jpg)'
- en: Table 2.1 – Java’s primitive types
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – Java 的原始类型
- en: 'Here are some interesting points from the preceding table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从前面表格中的一些有趣的观点：
- en: '`byte`, `short`, `char`, `int`, and `long` are known as *integral* types as
    they have integer values (whole numbers, positive or negative). For example, -8,
    17, and 625 are all integer numbers.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`、`short`、`char`、`int` 和 `long` 被称为 *整型* 类型，因为它们具有整数值（整数，正数或负数）。例如，-8、17
    和 625 都是整数。'
- en: '`char` is used for characters – for example ‘a’, ‘b’, ‘?’ and ‘+’. Note that
    single quotes surround the character. In code, `char c = ''a'';` means that the
    variable `c` represents the letter `a`. As computers ultimately store all characters
    (on the keyboard) as numbers internally (binary), we need an encoding system to
    map the characters to numbers and vice versa. Java uses the Unicode encoding standard,
    which ensures a unique number for every character, regardless of platform, language,
    script, and so on. This is why `char` uses 2 bytes as opposed to 1\. In fact,
    from the computer’s perspective, `char c = ''a''`; is the same as `char c = 97;`
    where 97 is the decimal value for ‘a’ in Unicode. Obviously, we as humans prefer
    the letter representation.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 用于字符 – 例如 ‘a’，‘b’，‘？’ 和 ‘+’。注意字符被单引号包围。在代码中，`char c = ''a'';` 表示变量 `c`
    代表字母 `a`。由于计算机最终将所有字符（在键盘上）作为内部数字（二进制）存储，我们需要一个编码系统来将字符映射到数字，反之亦然。Java 使用 Unicode
    编码标准，它确保每个字符都有一个唯一的数字，无论平台、语言、脚本等。这就是为什么 `char` 使用 2 个字节而不是 1 个。实际上，从计算机的角度来看，`char
    c = ''a''`; 与 `char c = 97;` 是相同的，其中 97 是 Unicode 中 ‘a’ 的十进制值。显然，我们作为人类更喜欢字母表示法。'
- en: '`short` and `char` both require 2 bytes but have different ranges. Note that
    `short` can represent negative numbers, whereas `char` cannot. In contrast, `char`
    can store numbers such as 65,000, whereas `short` cannot.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short` 和 `char` 都需要 2 个字节，但范围不同。注意 `short` 可以表示负数，而 `char` 不能。相比之下，`char`
    可以存储如 65,000 这样的数字，而 `short` 不能。'
- en: '`float` and `double` are for floating-point numbers – in other words, numbers
    that have decimal places, such as 23.78 and -98.453\. These floating-point numbers
    can use scientific notation – for example, 130000.0 can be expressed as `double
    d1=1.3e+5;`, and 0.13 can be expressed as `double d2=1.3e-1;`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 和 `double` 用于浮点数 – 换句话说，有小数位的数字，例如 23.78 和 -98.453。这些浮点数可以使用科学记数法 –
    例如，130000.0 可以表示为 `double d1=1.3e+5;`，而 0.13 可以表示为 `double d2=1.3e-1;`。'
- en: Representation of the various types
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 各种类型的表示
- en: 'Expanding from the previous callout, we can express integer literals using
    the following numbering systems:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个调用中扩展，我们可以使用以下数制表示整数字面量：
- en: '`Decimal`: Base 10; numbers 0..9\. This is the default.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`十进制`：基数为 10；数字 0..9。这是默认值。'
- en: '`Hexadecimal`: Base 16; numbers 0..9 and letters a..f (or A..F). Prefix the
    literal with *0x* or *0X* to indicate that this is a hexadecimal literal.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`十六进制`：基数为 16；数字 0..9 和字母 a..f（或 A..F）。在字面量前加上 *0x* 或 *0X* 以指示这是一个十六进制字面量。'
- en: '`binary`: Base 2; numbers 0..1\. Prefix the literal with *0b* or *0B* to indicate
    that this is a binary literal.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`二进制`：基数为 2；数字 0..1。在字面量前加上 *0b* 或 *0B* 以指示这是一个二进制字面量。'
- en: 'Here are some sample code fragments that initialize `int` variables to 30 using
    the various numbering systems. Firstly, decimal is used; then hexadecimal, and
    finally, binary:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例代码片段，使用不同的数制初始化 `int` 变量为 30。首先使用十进制，然后是十六进制，最后是二进制：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although there are several ways to initialize an `int`, using decimal is by
    far the most common.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几种初始化 `int` 的方法，但使用十进制是最常见的。
- en: 'A literal number, such as 22, is considered an `int` by default. If you want
    to have 22 treated as `long` (instead of `int`), you must suffix either an uppercase
    or lowercase *L* to the literal. Here’s an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，字面量数字，如 22，被视为 `int`。如果你想让 22 被视为 `long`（而不是 `int`），必须在字面量后加上大写或小写 *L*。以下是一个示例：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As per *Table 2.1*, using a `long` as opposed to an `int`, gives you access
    to much bigger and much smaller numbers. Use of uppercase `L` as opposed to lowercase
    `l` to signify `long` is preferred, as the lowercase `l` is similar to the number
    1 (one).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *表 2.1*，使用 `long` 而不是 `int`，可以访问更大和更小的数字。为了表示 `long`，建议使用大写 `L` 而不是小写 `l`，因为小写
    `l` 与数字 1（one）相似。
- en: 'Floating-point numbers behave similarly. A decimal number is, by default, `double`.
    To have any decimal number treated as `float` (as opposed to `double`), you must
    suffix the literal with either an uppercase or lowercase `F`. Assuming range is
    not an issue then one reason for using `float` as opposed to `double` is memory
    conservation (as `float` requires 4 bytes whereas `double` requires 8 bytes).
    Here’s an example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数的行为类似。默认情况下，十进制数字是 `double`。要将任何十进制数字视为 `float`（而不是 `double`），必须在字面量后加上大写或小写
    `F`。假设范围不是问题，那么使用 `float` 而不是 `double` 的一个原因是为了节省内存（因为 `float` 需要 4 个字节，而 `double`
    需要 8 个字节）。以下是一个示例：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Variables of the `char` type are initialized with single quotes around the
    literal. Here’s an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 类型的变量用单引号括起来的字面量初始化。以下是一个示例：'
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Variables of the `boolean` type can store only `true` or `false`. These `boolean`
    literals are in lowercase only as they are reserved words in Java, and Java is
    case-sensitive:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 类型的变量只能存储 `true` 或 `false`。这些 `boolean` 字面量仅使用小写，因为它们是 Java 中的保留字，Java
    是区分大小写的：'
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That concludes this section on Java’s primitive type system, where we examined
    the various types, their sizes/ranges, and some code segments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于 Java 原始类型系统的内容到此结束，我们考察了各种类型、它们的尺寸/范围以及一些代码片段。
- en: Now, let’s put the theory of variables and primitive types into practice! But
    before that, here’s a bit of a cheat code to help you with the exercises.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将变量和原始类型理论付诸实践！但在那之前，这里有一些作弊代码可以帮助你完成练习。
- en: Screen output
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕输出
- en: 'As we know, `System.out.println()` outputs what is inside the `()`. To do the
    exercises, we want to expand on that. Firstly, here’s some code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，`System.out.println()` 输出括号内的内容。为了进行练习，我们想要在此基础上进行扩展。首先，这里有一些代码：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Line 1 declares a string literal `"James"` and initializes the `name` variable
    with it. A string literal is a sequence of characters (including numbers), enclosed
    in double quotes. We will discuss the `String` class in detail in [*Chapter 12*](B19793_12.xhtml#_idTextAnchor293).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 行声明了一个字符串字面量 `"James"` 并用它初始化了 `name` 变量。字符串字面量是一系列字符（包括数字），用双引号括起来。我们将在
    [*第 12 章*](B19793_12.xhtml#_idTextAnchor293) 中详细讨论 `String` 类。
- en: Lines 2 and 3 should be fine. We are declaring an `int` type called `age` and
    a `double` type called `salary` and using literal values to initialize them. The
    underscore used in line 3, enables us to make large numbers easier to read.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 行和第 3 行应该没问题。我们声明了一个名为 `age` 的 `int` 类型和一个名为 `salary` 的 `double` 类型，并使用字面量初始化它们。第
    3 行中使用的下划线使我们能够使大数字更容易阅读。
- en: Line 4 builds the string to be output, namely `out`. We want to output the variables
    values, along with some helpful text to explain the output. Java builds the string
    from left to right.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 行构建要输出的字符串，即 `out`。我们想要输出变量的值，以及一些有用的文本来解释输出。Java 从左到右构建字符串。
- en: Here, `+` is not the regular mathematical addition. We will discuss this in
    detail in [*Chapter 3*](B19793_03.xhtml#_idTextAnchor067), but for the moment,
    realize that when you have a string variable or literal on the left or the right
    of `+`, the operation becomes a `String` append (as opposed to mathematical addition).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`+` 不是常规的数学加法。我们将在 [*第 3 章*](B19793_03.xhtml#_idTextAnchor067) 中详细讨论这个问题，但暂时明白，当你有一个字符串变量或字面量位于
    `+` 的左边或右边时，操作就变成了字符串连接（而不是数学加法）。
- en: One property this append shares with addition is that both sides of `+` must
    be of the same type. Since not all the variables in this example are string variables
    (or literals), Java has some work to do in the background (to get them all to
    the same type). Java copies the numeric variable values into new string locations
    to use them in building the string. For example, there is a location somewhere
    in memory that’s been created for a string literal, “23” (in addition to the `int`
    location for `age`). This also happens for the `double` type’s `salary` variable.
    Now, Java is ready to construct the string and assign it to `out` (line 4).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 append 属性与加法有一个共同点，即 `+` 的两边必须是同一类型。由于本例中并非所有变量都是字符串变量（或字面量），Java 在后台需要做一些工作（将它们都转换为同一类型）。Java
    将数值变量的值复制到新的字符串位置，以便在构建字符串时使用。例如，内存中某个位置已经创建了一个字符串字面量“23”（除了 `int` 类型的 `age` 位置）。对于
    `double` 类型的 `salary` 变量也是如此。现在，Java 准备构建字符串并将其分配给 `out`（第 4 行）。
- en: 'In the background, Java performs the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，Java 执行以下操作：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, `"Details: James, 23, 50000.0"` is used to initialize `out`, which is what
    is displayed on the screen when executing line 5.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，`"Details: James, 23, 50000.0"` 用于初始化 `out`，这是执行第 5 行时屏幕上显示的内容。'
- en: Exercises
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'All is going great in our lovely dinosaur park. However, we do need to do some
    administrative tasks:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可爱的恐龙公园里，一切都很顺利。然而，我们确实需要做一些行政工作：
- en: We need to keep track of the dinosaurs in the park. Declare variables to represent
    the breed, height, length, and weight of one dinosaur in the main method. Give
    the variables a value and print them.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要跟踪公园中的恐龙。在主方法中声明变量来表示一只恐龙的品种、身高、长度和体重。给这些变量赋值并打印它们。
- en: Now, we want to do something similar to the program of exercise 1 and print
    the dinosaur’s age, name, and whether it’s a carnivore or not. This needs to happen
    in the main method. Give the variables a value and print them.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要做与练习 1 类似的事情，并打印恐龙的年龄、姓名以及它是否是肉食性动物。这需要在主方法中完成。给这些变量赋值并打印它们。
- en: 'Our park is doing great! But it gets a bit too busy at times. The fire department
    advised us to introduce a maximum number of visitors that are allowed at any given
    time. Declare a variable to represent the maximum number of visitors allowed in
    the park per day. You can choose a reasonable value for the variable. Then, print
    it in the sentence: “There’s a maximum of [x] people allowed in Mesozoic Eden.”'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的公园运营得很好！但有时会变得有点拥挤。消防部门建议我们引入在任何给定时间内允许的最大游客数量。声明一个变量来表示公园每天允许的最大游客数量。你可以为该变量选择一个合理的值。然后，在句子“Mesozoic
    Eden 允许的最大人数为 [x] 人。”中打印它。
- en: Our team is an integral part of Mesozoic Eden. Let’s create a profile for an
    employee. Declare variables to represent the name and age of a Mesozoic Eden employee.
    Assign values and print them.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的团队是 Mesozoic Eden 不可或缺的一部分。让我们为一名员工创建一个档案。声明变量来表示 Mesozoic Eden 员工的姓名和年龄。赋值并打印它们。
- en: We would like to know how many dinosaurs we have at any time. Declare a variable
    to represent the number of dinosaurs in the park. Assign it a value and print
    it.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想知道在任何时候我们有多少只恐龙。声明一个变量来表示公园中的恐龙数量。给它赋值并打印它。
- en: Safety is our priority. We maintain a safety rating scale to ensure our standards.
    Declare a variable to represent the park’s safety rating on a scale from 1 to
    10\. Assign a value to it and print it.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全是我们的首要任务。我们维护一个安全评级量表以确保我们的标准。声明一个变量来表示公园的安全评级，范围从 1 到 10。给它赋值并打印它。
- en: Now, let’s bring together some dinosaur information in one statement. Create
    a program that uses string concatenation to print out a dinosaur’s name, age,
    and diet (a string with a value of `carnivore` or `herbivore`).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在一个语句中汇总一些恐龙信息。创建一个程序，使用字符串连接来打印出恐龙的名字、年龄和食性（值为`carnivore`或`herbivore`的字符串）。
- en: Each dinosaur species has a unique name. For a quick referencing system, we
    use the first letter of a dinosaur species. Declare a character variable that
    represents the first letter of a dinosaur species, assign a value, and print it.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每种恐龙物种都有一个独特的名字。为了快速参考系统，我们使用恐龙物种的首字母。声明一个代表恐龙物种首字母的字符变量，赋值并打印它。
- en: Project – dinosaur profile generator
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 – 恐龙档案生成器
- en: 'As part of your responsibilities in Mesozoic Eden, you are tasked with creating
    an extensive database of all the dinosaurs living in the park. For now, you only
    need to complete the first step: a profile generator. These profiles will not
    only help in keeping track of our prehistoric residents but also provide essential
    data for scientific study, healthcare, diet management, and visitor engagement.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你在中生代伊甸园责任的一部分，你被要求创建一个包含公园内所有恐龙的详尽数据库。目前，你只需要完成第一步：档案生成器。这些档案不仅有助于跟踪我们的史前居民，还为科学研究、医疗保健、饮食管理和游客互动提供了必要的数据。
- en: In this project, we will focus on developing a program that can model an individual
    dinosaur’s profile.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将专注于开发一个可以模拟单个恐龙档案的程序。
- en: 'The profile should include the following characteristics:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 档案应包括以下特征：
- en: Name
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字
- en: Age
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄
- en: Species
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物种
- en: Diet (carnivore or herbivore)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食性（肉食性或草食性）
- en: Weight
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量
- en: Each characteristic should be stored as a variable within the program. Here’s
    your chance to get creative and think about the kind of dinosaur you want to describe.
    Is it a towering T-Rex or a friendly Stegosaurus? Maybe it’s a swift, scary Velociraptor
    or a mighty Triceratops?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特征都应该作为程序中的一个变量来存储。这是你发挥创意和思考你想要描述的恐龙类型的机会。是高耸的霸王龙，还是友好的甲龙？也许它是一只敏捷、可怕的迅猛龙，或者是一头强大的三角龙？
- en: Once you have declared and assigned values to these variables, the program should
    print out a complete profile of the dinosaur. The output can be something like
    `"Meet [Name], a [Age]-year-old [Species]. As a [Diet], it has a robust weight
    of [``Weight] kilograms."`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你声明并给这些变量赋值，程序应该打印出恐龙的完整档案。输出可以是类似这样的内容："遇见[名字]，一只[年龄]岁的[物种]。作为一种[食性]，它拥有健壮的体重[重量]千克。"
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that a variable is simply a memory location with
    a name and a value. To utilize variables, we have to know how to declare and access
    them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到变量只是一个带有名称和值的内存位置。为了利用变量，我们必须知道如何声明和访问它们。
- en: To declare a variable, we specify the variable’s name and its type – for example,
    `int countOfTitles=5;`. This line of code declares an `int` variable named `countOfTitles`
    with a value of `5`. Naming them properly using camel case, is a great aid in
    making your code more readable and maintainable. To access the variable, we just
    specify the variable’s name – for example, `System.out.println(countOfTitles);`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量时，我们指定变量的名称和类型——例如，`int countOfTitles=5;`。这一行代码声明了一个名为`countOfTitles`的`int`变量，其值为`5`。使用驼峰命名法正确命名它们，对于使代码更易于阅读和维护大有裨益。要访问变量，我们只需指定变量的名称——例如，`System.out.println(countOfTitles);`。
- en: As Java is a strongly typed language, we have to specify a variables' type when
    we declare it. Java provides eight in-built primitive data types for our use.
    They are easily recognizable due to their lowercase letters. In the preceding
    line of code, `int` is the primitive data type for the `countOfTitles` variable.
    We saw the sizes in bytes of the primitive types, which determines their range
    of values. All numeric types are signed, with the most significant bit being used
    for the sign. The `char` type is unsigned and is 2 bytes in size so that Java
    can support any character in any language anywhere in the world. Using code snippets,
    we saw variables of the different types in use.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java是一种强类型语言，我们在声明变量时必须指定其类型。Java为我们提供了八个内置的基本数据类型供我们使用。它们由于使用小写字母而易于识别。在上面的代码行中，`int`是`countOfTitles`变量的基本数据类型。我们看到了原始数据类型的大小（以字节为单位），这决定了它们的值域。所有数值类型都是有符号的，最高位用于表示符号。`char`类型是无符号的，大小为2字节，这样Java就可以支持世界上任何语言的任何字符。通过使用代码片段，我们看到了不同类型变量在实际中的应用。
- en: Now that we know how to declare and use variables, let’s move on to operators
    that enable us to combine variables.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何声明和使用变量，接下来让我们继续学习那些能够让我们组合变量的运算符。
