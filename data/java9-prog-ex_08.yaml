- en: Extending Our E-Commerce Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展我们的电子商务应用
- en: In the last chapter, we started developing an e-commerce application and we
    created the functionality to look up products based on their ID and, also, by
    some parameters. In this chapter, we will extend the functionality so that we
    can also order the products we selected. While doing so, we will learn new technologies,
    focusing on functional programming in Java and on some other language features,
    such as reflection and annotation handling during runtime, and scripting interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始开发一个电子商务应用，并创建了根据产品ID和一些参数查找产品的功能。在本章中，我们将扩展功能，以便我们还可以订购我们选择的产品。在这个过程中，我们将学习新技术，重点关注Java中的函数式编程以及一些其他语言特性，如运行时反射和注解处理，以及脚本接口。
- en: As we did in the previous chapters, we will develop the application step by
    step. As we discover the newly learnt technologies, we will refactor the code
    to enroll the new tools and methods to produce more readable and effective code.
    We will also mimic the development of real-life projects in the sense that at
    the start, we will have simple requirements, and later, new requirements will
    be set as our imagined business develops and sells more and more products. We
    will become imagined millionaires.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所做的那样，我们将逐步开发应用。当我们发现新学的技术时，我们将重构代码，以引入新的工具和方法，以产生更易读和有效的代码。我们还将模仿真实项目的开发，即在开始时，我们将有简单的需求，而后来，随着我们想象中的业务发展和销售更多产品，新的需求将被设定。我们将成为想象中的百万富翁。
- en: 'We will use the code base of the previous chapter, and we will develop it further,
    though, in a new project. We will use Spring, Gradle, Tomcat, and soapUI, which
    are not new after we got acquainted with these in the previous chapter. In this
    chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一章的代码库，并将在此基础上进一步开发，尽管如此，我们将在一个新的项目中这样做。我们将使用Spring、Gradle、Tomcat和soapUI，这些在上一章中我们已经熟悉了。在本章中，你将学习以下主题：
- en: Annotation processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解处理
- en: Using reflection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反射
- en: 'Functional programming in Java using:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下方式在Java中进行函数式编程：
- en: Lambda expressions
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Streams
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流
- en: Invoking scripts from Java
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java调用脚本
- en: The MyBusiness ordering
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyBusiness订购
- en: The ordering process is a little bit more complicated than just looking up products.
    The order form itself lists products and amounts, and identifies who the customer
    for that order is. Identifiers give the products. All that we have to do is check
    that the products are available in our store, and we can deliver them to the given
    customer. This is the simplest approach; however, with some products, there are
    more restrictions. For example, when somebody orders a desk-side lamp, we deliver
    the power cord separately. The reason for this is that the power cord is specific
    to the country. We deliver different power cords to the United Kingdom and to
    Germany. One possible approach could be to identify the country of the customer.
    But this approach does not take into account that our customers are resellers.
    All customers could be located in the United Kingdom, and at the same time they
    may want to deliver the lamp with the power cable to Germany. To avoid such situations
    and ambiguity, it would be  apt that our customers order the desk-side lamp and
    the power cord as separate items in the same order. In some cases, we deliver
    the desk-side lamp without the power cord, but this is a special case. We need
    some logic to identify these special cases. Therefore, we have to implement logic
    to see if there is a power cord for a desk-side lamp and if there is no automatic
    handling of the order, it is refused. It does not mean that we will not deliver
    the product. We will only put the order in a queue and some operator will have
    to look at it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 订单过程比仅仅查找产品要复杂一些。订单表单本身列出了产品和数量，并确定了该订单的客户是谁。标识符提供了产品信息。我们只需要检查这些产品是否在我们的商店中有货，并且我们可以将它们交付给指定的客户。这是最简单的方法；然而，对于某些产品，存在更多的限制。例如，当有人订购桌面台灯时，我们会单独交付电源线。这是因为电源线是特定于国家的。我们向英国和德国交付不同的电源线。一种可能的方法是识别客户的国籍。但这种方法没有考虑到我们的客户是转售商。所有客户可能都位于英国，同时他们可能希望将台灯和电源线一起运往德国。为了避免这种情况和歧义，我们的客户最好将桌面台灯和电源线作为同一订单中的单独项目订购。在某些情况下，我们不附带电源线交付桌面台灯，但这是一种特殊情况。我们需要一些逻辑来识别这些特殊情况。因此，我们必须实现逻辑来查看是否存在桌面台灯的电源线，如果没有自动处理订单，则拒绝订单。这并不意味着我们不会交付产品。我们只会将订单放入队列，然后某个操作员需要查看它。
- en: The problem with this approach is that the desk-side lamp is only one product
    that needs configuration support. The more products we have, the more specialities
    they may have, and the piece of code that checks the consistency of an order becomes
    more and more complex until it reaches a level of complexity that is not manageable.
    When a class or method becomes too complex, the programmers refactor it, splitting
    up the method or class into smaller pieces. We have to do the same with the product
    checking. We shouldn't try to create one huge class that checks for the product
    and all the possible order constellations, but rather we should have many smaller
    checks so that each checks only one small set.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于，桌面台灯只是需要配置支持的一个产品。我们拥有的产品越多，它们可能具有的专长就越多，检查订单一致性的代码变得越来越复杂，直到达到无法管理的复杂程度。当一个类或方法变得过于复杂时，程序员会对其进行重构，将方法或类拆分成更小的部分。我们必须对产品检查做同样的事情。我们不应该试图创建一个巨大的类来检查产品和所有可能的订单组合，而应该有许多较小的检查，以便每个检查只针对一个小集合。
- en: 'Checking for consistency is simpler in some cases. Checking whether the lamp
    has a power cord has a complexity any novice programmer can program. We use this
    example in our code because we want to focus on the actual structure of the code,
    and not on the complex nature of the check itself. In real life, however, the
    checks can be fairly complex. Imagine a shop that sells computers. It puts a configuration
    together: power supply, graphic cards, and motherboard, the appropriate CPU, and
    the memory. There are many choices and some of them may not work together. In
    a real-life situation, we need to check that the motherboard is compatible with
    the memory selected, that it has as many banks as are in the order, that they
    are appropriately paired (some memories can only be installed in pairs), that
    there is a compatible slot for the graphics card, and that the power has enough
    watts to reliably run the whole configuration. This is very complex and is better
    not mixed up with the code that checks if there is a power cord for a lamp.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，检查一致性更简单。检查灯具是否有电源线，其复杂度任何新手程序员都可以编写。我们在代码中使用这个例子，因为我们想关注代码的实际结构，而不是检查本身的复杂性质。然而，在现实生活中，检查可能相当复杂。想象一下一家销售电脑的商店。它组装一个配置：电源供应、显卡和主板，适当的CPU和内存。有许多选择，其中一些可能无法一起工作。在现实情况下，我们需要检查主板与所选内存兼容，主板有与订单中相同数量的存储器组，它们被适当配对（一些内存只能成对安装），有一个兼容的插槽用于显卡，以及电源有足够的瓦特数来可靠地运行整个配置。这是非常复杂的，最好不要与检查灯具是否有电源线的代码混淆。
- en: Setting up the project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Since we are still using Spring boot, the build file does not need any modification;
    we will use it as we will use the same file as in the last chapter. The package
    structure, however, is a bit different. This time, we do something more complicated
    than getting a request and responding to whatever the backend services deliver
    to us. Now, we have to implement complex business logic that, as we will see,
    needs many classes. When we have more than 10 classes, give or take, in a certain
    package, it is time to think about putting them into separate packages. The classes
    that are related to each other and have a similar functionality should be put
    into one package. This way, we will have a package for the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍在使用Spring Boot，构建文件不需要任何修改；我们将像使用上一章的文件一样使用它。然而，包结构略有不同。这次，我们要做比仅仅获取请求并响应后端服务提供的内容更复杂的事情。现在，我们必须实现复杂的企业逻辑，正如我们将看到的，这需要许多类。当我们在一个包中有10多个类时，是时候考虑将它们放入单独的包中。相互关联并具有相似功能的类应该放在一个包中。这样，我们将有一个包用于以下内容：
- en: The controllers (though we have only one in this example, but usually there
    are more)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器（尽管在这个例子中我们只有一个，但通常会有更多）
- en: Data storing beans that have no more functionality than storing data, thus,
    fields, setters, and getters
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只具有存储数据功能的数据存储bean，因此，字段、setter和getter
- en: Checkers that will help us check power cords when a desk-side lamp is ordered
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当订购台式灯时帮助我们检查电源线的检查器
- en: Services that perform different services for the controller
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为控制器执行不同服务的服务
- en: The main package for our program that contains the `Application` class, `SpringConfiguration`,
    and some interfaces
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`Application`类、`SpringConfiguration`和一些接口的我们程序的主要包
- en: Order controller and DTOs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单控制器和DTOs
- en: 'When a request comes to the server to order a bunch of products, it comes in
    an HTTPS `POST` request. The body of the request is encoded in JSON. Till now,
    we had controllers that were handling `GET` parameters, but handling `POST` requests
    is not much more difficult when we can rely on the data marshalling of Spring.
    The controller code itself is simple:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到一个请求来订购一系列产品时，它以HTTPS `POST`请求的形式到来。请求体以JSON编码。到目前为止，我们已经有处理`GET`参数的控制器，但当我们能够依赖Spring的数据绑定时，处理`POST`请求并不比这更困难。控制器代码本身很简单：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is only one request that we handle in this controller: `order`. This
    is mapped to the URL, `/order`. The order is automatically converted from JSON
    to an order object from the request body. This is what the `@RequestBody` annotation
    asks Spring to do for us. The functionality of the controller simply checks the
    consistency of the order. If the order is consistent, then we accept the order;
    otherwise, we refuse it. The real-life example will also check that the order
    is not only consistent but also comes from a customer who is eligible for buying
    those products and that the products are available in the warehouse or, at least,
    can be delivered, based on the promises and lead time from the producers.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器中，我们只处理一个请求：`order`。这映射到 URL `/order`。订单会自动从请求体中转换为 JSON 格式的订单对象。这就是 `@RequestBody`
    注解要求 Spring 为我们做的事情。控制器的功能仅仅是检查订单的一致性。如果订单是一致的，那么我们接受订单；否则，我们拒绝它。现实生活中的例子也会检查订单不仅是一致的，而且来自有资格购买这些产品的客户，并且这些产品在仓库中有货，或者至少根据生产者的承诺和交货期可以交付。
- en: To check the consistency of the order, we need something that does this job
    for us. As we know that we have to modularize the code and not implement too many
    things in a single class, we need a checker object. This is provided automatically
    based on the annotation on the class and also on the constructor of the controller
    by `@Autowired`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查订单的一致性，我们需要一个为我们做这项工作的东西。正如我们所知，我们必须模块化代码，不要在单个类中实现太多东西，因此我们需要一个检查对象。这是根据类的注解和控制器构造函数的
    `@Autowired` 自动提供的。
- en: 'The `Order` class is a simple bean, simply listing the items:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order` 类是一个简单的 JavaBean，仅列出项目：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The name of the package is `dtos`, which stands for the plural of **Data Transfer
    Object** (**DTO**). DTOs are objects that are used to transfer data between different
    components, usually over the network. Since the other side can be implemented
    in any language, the marshaling can be JSON, XML, or some other format that is
    capable of delivering nothing but data. These classes do not have real methods.
    DTOs usually have only fields, setters, and getters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 包的名称是 `dtos`，代表 **数据传输对象**（DTO）的复数形式。DTOs 是用于在不同组件之间传输数据（通常通过网络）的对象。由于另一端可以用任何语言实现，序列化可以是
    JSON、XML 或其他仅能传输数据的格式。这些类没有实际的方法。DTOs 通常只有字段、设置器和获取器。
- en: 'The following is the class that contains one item in an order:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含订单中一个项目的类：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The order confirmation is also in this package, and though this is also a true
    DTO, it has some simple auxiliary methods:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 订单确认也在此包中，尽管这也是一个真正的 DTO，但它有一些简单的辅助方法：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We provide two factory methods for the class. This is a little violation of
    the single responsibility principle that purists hate. Most of the time, when
    the code becomes more complex, such short cuts bite back, and the code has to
    be refactored to be cleaner. The purist solution would be to create a separate
    factory class. The use of the factory methods either from this class or from a
    separated class makes the code of the controller more readable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为该类提供了两个工厂方法。这有点违反了单一职责原则，这是纯粹主义者所厌恶的。大多数时候，当代码变得更加复杂，这样的捷径会反过来咬人，代码不得不重构以变得更加简洁。纯粹主义的解决方案是创建一个单独的工厂类。使用这个类或分离的类的工厂方法可以使控制器的代码更易于阅读。
- en: The major task we have is the consistency check. The code, till this point,
    is almost trivial.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要任务是进行一致性检查。到目前为止，代码几乎是微不足道的。
- en: Consistency checker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性检查器
- en: We have a consistency checker class, and an instance of it is injected into
    the controller. This class is used to check the consistency, but it does not actually
    perform the check itself. It only controls the different checkers that we provide
    and invokes them one by one to do the real work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个一致性检查器类，并且它的一个实例被注入到控制器中。这个类用于检查一致性，但它本身并不执行检查。它只控制我们提供的不同检查器，并依次调用它们来完成实际工作。
- en: 'We require that a consistency checker, such as the one that checks whether
    the order contains a power cord when a desk-side lamp is ordered, implements the
    `ConsistencyChecker` interface:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求一致性检查器，例如当订购台灯时检查订单是否包含电源线的一致性检查器，实现 `ConsistencyChecker` 接口：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method `isInconsistent` should return `true` if the order is inconsistent.
    It returns `false` if it does not know whether the order is inconsistent or not,
    but from the aspect that the actual checker examines the order, there is no inconsistency.
    Having several `ConsistencyChecker` classes, we have to invoke one after the other
    until one returns `true` or we are out of them. If none of them returns `true`,
    then we can safely assume, at least from the automated checkers' point of view,
    that the order is consistent.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInconsistent`方法应该在订单不一致时返回`true`。如果它不知道订单是否不一致，则返回`false`，但从实际检查器检查订单的角度来看，没有不一致性。由于有多个`ConsistencyChecker`类，我们必须一个接一个地调用，直到其中一个返回`true`或者我们用完它们。如果没有一个返回`true`，那么至少从自动化检查器的角度来看，我们可以安全地假设订单是一致的。'
- en: We know at the start of the development that we will really have a lot of consistency
    checkers and not all are relevant for all of the orders. We want to avoid the
    invocation of each checker for each order. To do so, we implement some filtering.
    We let products specify what type of checks they need. This is a piece of product
    information, such as the size or the description. To accommodate this, we need
    to extend the `ProductInformation` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发初期，我们就知道我们将会真正拥有很多一致性检查器，并不是所有检查器都对所有订单都相关。我们希望避免为每个订单调用每个检查器。为了做到这一点，我们实现了一些过滤。我们让产品指定它们需要哪种类型的检查。这是一些产品信息，比如大小或描述。为了适应这一点，我们需要扩展`ProductInformation`类。
- en: We will create each `ConsistencyChecker` interface, implementing the class to
    be a Spring bean (annotated with the `@Component` annotation), and at the same
    time, we will annotate them with an annotation that specifies what type of checks
    they implement. At the same time, `ProductInformation` is extended, containing
    a set of `Annotation` class objects that specify which checkers to invoke. We
    could simply list the checker classes instead of the annotations, but this gives
    us some extra freedom in configuring the mapping between the products and the
    annotations. The annotation specifies the type of the products, and the checker
    classes are annotated. The desk-side lamp has the `PoweredDevice` type, and the
    checker class, `NeedPowercord`, is annotated with the `@PoweredDevice` annotation.
    If there is any other type of products that also needs a power cord, then the
    annotation of that type should be added to the `NeedPowercord` class, and our
    code will work. Since we start diving deep into annotations and annotation handling,
    we have to first learn what annotations really are. We have already used annotations
    since [Chapter 3](part0076.html), *Optimizing the Sort, Making Code Professional*
    but all we knew was how to use them, and that is usually dangerous without understanding
    what we did.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建每个`ConsistencyChecker`接口，实现类作为Spring bean（使用`@Component`注解标注），同时，我们将使用一个注解来指定它们实现哪种类型的检查。同时，`ProductInformation`被扩展，包含一组`Annotation`类对象，这些对象指定了要调用哪些检查器。我们本可以简单地列出检查器类而不是注解，但这给了我们在配置产品与注解之间的映射时一些额外的自由度。注解指定了产品的类型，检查器类被注解。台灯有`PoweredDevice`类型，检查器类`NeedPowercord`被`@PoweredDevice`注解标注。如果有其他类型的需要电源线的产品，那么该类型的注解应该添加到`NeedPowercord`类中，我们的代码就能工作。由于我们开始深入研究注解和注解处理，我们首先必须了解注解到底是什么。自从[第3章](part0076.html)，*优化排序，使代码专业*以来，我们已经使用了注解，但我们只知道如何使用它们，而且如果不理解我们所做的，这通常是危险的。
- en: Annotations
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解
- en: Annotations are used with the `@` character in front of them and can be attached
    to packages, classes, interfaces, fields, methods, method parameters, generic
    type declaration and use, and, finally, to annotations. Annotations can be used
    almost everywhere and they are used to describe some program meta information.
    For example, the `@RestController` annotation does not directly alter the behavior
    of the `OrderController` class. The behavior of the class is described by the
    Java code that is inside. The annotation helps Spring to understand what the class
    is and how it can and should be used. When Spring scans all the packages and classes
    to discover the different Spring beans, it sees the annotation on the class and
    takes it into account. There can be other annotations on the class that Spring
    does not understand. They may be used by some other framework or program code.
    Spring ignores them as any well-behaving framework. For example, as we will see
    later, we have in our code base, the `NeedPowercord` class , which is a Spring
    bean and, as such, annotated with the `@Component` annotation. At the same time,
    it is also annotated with the `@PoweredDevice` annotation. Spring has no idea
    about what a powered device is. This is something that we define and use. Spring
    ignores this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注解使用前面的`@`字符，可以附加到包、类、接口、字段、方法、方法参数、泛型类型声明和使用，以及最后，附加到注解上。注解几乎可以用于任何地方，它们用于描述一些程序元信息。例如，`@RestController`注解不会直接改变`OrderController`类的行为。类的行为由内部的Java代码描述。注解帮助Spring理解类是什么以及它应该如何以及如何使用。当Spring扫描所有包和类以发现不同的Spring
    beans时，它看到类上的注解并将其考虑在内。类上可能有Spring不理解的其它注解。它们可能被某些其他框架或程序代码使用。Spring像任何良好行为的框架一样忽略它们。例如，正如我们稍后将要看到的，在我们的代码库中，有一个名为`NeedPowercord`的类，它是一个Spring
    bean，因此被`@Component`注解标注。同时，它还被`@PoweredDevice`注解标注。Spring对什么是带电设备一无所知。这是我们定义和使用的。Spring忽略它。
- en: Packages, classes, interfaces, fields, and so on, can have many annotations
    attached to them. These annotations should simply be written in front of the declaration
    of the syntactical unit they are attached to.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 包、类、接口、字段等都可以附加许多注解。这些注解应该简单地写在它们所附加的语法单元声明之前。
- en: In the case of packages, the annotation has to be written in front of the package
    name in the `package-info.java` file. This file can be placed in the directory
    of the package and can be used to edit the *JavaDoc* for the package and also
    to add an annotation to the package. This file cannot contain any Java class since
    the name, `package-info`, is not a valid identifier.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在包的情况下，注解必须写在`package-info.java`文件中的包名之前。此文件可以放置在包的目录中，可以用来编辑包的*JavaDoc*，也可以用来向包添加注解。此文件不能包含任何Java类，因为`package-info`名称不是一个有效的标识符。
- en: 'We cannot just write anything in front of anything as an annotation. Annotations
    should be declared. They are in the runtime of Java special interfaces. The Java
    file that declares the `@PoweredDevice` annotation, for example, looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能随意在任意位置写任何内容作为注解。注解应该被声明。它们位于Java运行时的特殊接口中。例如，声明`@PoweredDevice`注解的Java文件看起来像这样：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `@` character in front of the `interface` keyword shows us that this is
    a special one: an annotation type. There are some special rules; for example,
    an annotation interface should not extend any other interface, not even an annotation
    one. On the other hand, the compiler automatically makes the annotation interface
    so that it extends the JDK interface, `java.lang.annotation.Annotation`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface`关键字前面的`@`字符表明这是一个特殊类型：注解类型。有一些特殊规则；例如，注解接口不应扩展任何其他接口，甚至不是注解接口。另一方面，编译器自动使注解接口扩展JDK接口`java.lang.annotation.Annotation`。'
- en: Annotations are in the source code, and thus, they are available during the
    compilation process. They can also be retained by the compiler and put into the
    generated class files, and when the class loader loads the class file, they may
    also be available during runtime. The default behavior is that the compiler stores
    the annotation along with the annotated element in the class file, but the class
    loader does not keep it available for runtime.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注解位于源代码中，因此，它们在编译过程中是可用的。编译器还可以保留这些注解并将它们放入生成的类文件中，当类加载器加载类文件时，它们也可能在运行时可用。默认行为是编译器将注解与其注解的元素一起存储在类文件中，但类加载器不会在运行时保持它们可用。
- en: To handle annotations during the compilation process, the Java compiler has
    to be extended using annotation processors. This is a fairly advanced topic and
    there are only a few examples you can meet while working with Java. An annotation
    processor is a Java class that implements a special interface and is invoked by
    the compiler when it processes an annotation in the source file that the processor
    is declared to have an interest in.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编译过程中处理注解，必须使用注解处理器扩展Java编译器。这是一个相当高级的话题，在处理Java时你只能遇到少数几个例子。注解处理器是一个实现了特殊接口的Java类，当编译器处理注解处理器声明的源文件中的注解时，会调用它。
- en: Annotation retention
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解保留
- en: Spring and other frameworks usually handle annotations during runtime. The compiler
    and the class loader have to be instructed that the annotation is to be kept available
    during runtime. To do so, the annotation interface itself has to be annotated
    using the `@Retention` annotation. This annotation has one parameter of the `RetentionPolicy`
    type, which is an `enum`. We will soon discuss how annotation parameters should
    be defined.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring和其他框架通常在运行时处理注解。编译器和类加载器必须被指示注解在运行时应该保持可用。为此，必须使用`@Retention`注解来注解注解接口本身。这个注解有一个`RetentionPolicy`类型的参数，它是一个枚举。我们很快就会讨论注解参数应该如何定义。
- en: It is interesting to note that the `@Retention` annotation on the annotation
    interface has to be available in the class file; otherwise, the class loaders
    would not know how to treat an annotation. How do we signal that an annotation
    is to be kept by the compiler after the compilation process? We annotate the annotation
    interface declaration. Thus, the declaration of `@Retention` is annotated by itself
    and it is declared to be available in runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是要注意，注解接口上的`@Retention`注解必须在类文件中可用；否则，类加载器将不知道如何处理注解。我们如何通知编译器在编译过程结束后保留注解？我们注解注解接口声明。因此，`@Retention`的声明被自己注解，并声明为在运行时可用。
- en: The annotation declaration can be annotated using `@Retention(RetentionPolicy.SOURCE)`,
    `@Retention(RetentionPolicy.CLASS)`, or `@Retention(RetentionPolicy.RUNTIME)`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注解声明可以使用`@Retention(RetentionPolicy.SOURCE)`、`@Retention(RetentionPolicy.CLASS)`或`@Retention(RetentionPolicy.RUNTIME)`进行注解。
- en: Annotation target
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解目标
- en: The last retention type will be the most frequent used. There are also other
    annotations that can be used on annotation declarations. The `@Target` annotation
    can be used to restrict the use of the annotation to certain locations. The argument
    to this annotation is either a single `java.lang.annotation.ElementType` value
    or an array of these values. There is a good reason to restrict the use of annotations.
    It is much better to get a compilation time error when we place an annotation
    in the wrong place than hunting during runtime why the framework ignores our annotation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的保留类型将是使用最频繁的。还有其他可以在注解声明上使用的注解。`@Target`注解可以用来限制注解的使用范围。这个注解的参数是一个`java.lang.annotation.ElementType`的值或这些值的数组。限制注解的使用有一个很好的理由。当我们将注解放置在错误的位置时，得到编译时错误要比在运行时寻找框架为什么忽略我们的注解要好得多。
- en: Annotation parameters
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解参数
- en: Annotations, as we saw, can have parameters. To declare these parameters in
    the `@interface` declaration of the annotation, we use methods. These methods
    have a name and a return value, but they should not have an argument. You may
    try to declare some parameters, but the Java compiler will be strict and will
    not compile your code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，注解可以有参数。为了在注解的`@interface`声明中声明这些参数，我们使用方法。这些方法有一个名称和返回值，但它们不应该有参数。你可以尝试声明一些参数，但Java编译器将会非常严格，不会编译你的代码。
- en: 'The values can be defined at the place where the annotation is used, using
    the name of the method and with the `=` character, assigning to them some value
    that is compatible with the type of the method. For example, let''s suppose that
    we modify the declaration of the annotation `PoweredDevice` to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可以在使用注解的地方定义，使用方法名称和`=`字符，将一些与方法的类型兼容的值赋给它们。例如，假设我们修改注解`PoweredDevice`的声明如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In such a case, at the use of the annotation, we should specify some value
    for the parameter, such as the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在使用注解时，我们应该为参数指定一些值，例如以下内容：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the name of the parameter is a value and at the place of use of the annotation
    there is no other parameter defined, then the name, "value", may be skipped. For
    example, modifying the code as follows is a handy shorthand when we have only
    one parameter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数的名称是一个值，并且在注解的使用位置没有定义其他参数，那么名称“value”可以被省略。例如，当我们只有一个参数时，按照以下方式修改代码是一个方便的缩写：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can define optional parameters also using the `default` keyword following
    the method declaration. In this case, we have to define a default value for the
    parameter. Modifying the sample annotation we have further, we still can, but
    need not, specify the value. In the latter case, it will be an empty string:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`default`关键字在方法声明后定义可选参数。在这种情况下，我们必须为参数定义一个默认值。进一步修改我们已有的示例注解，我们仍然可以，但不必指定值。在后一种情况下，它将是一个空字符串：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since the value we specify should be constant and calculable during compile
    time, there is not much use of complex types. Annotation parameters are usually
    strings, integers, and sometimes, doubles, or other primitive types. The exact
    list of the types given by the language specification is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定的值应该在编译时是常量和可计算的，因此复杂类型并没有太大的用途。注解参数通常是字符串、整数，有时是双精度浮点数或其他原始类型。语言规范提供的类型列表如下：
- en: Primitive (`double`, `int`, and so on)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型（`double`、`int`等）
- en: String
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Class
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: An enum
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Another annotation
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个注解
- en: An array of any of the aforementioned types
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述任何类型的数组
- en: We have seen examples of `String` and also that `enum`:`Retention` and `Target`
    both have `enum` parameters. The interesting part we want to focus on is the last
    two items of the preceding list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`String`的例子，也看到了`enum`:`Retention`和`Target`都有`enum`参数。我们想要关注的有意思的部分是上述列表的最后两项。
- en: 'When the value of the parameter is an array, the value can be specified as
    comma-separated values between the `{` and`}` characters. For example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数的值是一个数组时，值可以在`{`和`}`字符之间指定为逗号分隔的值。例如：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This can then be added to the `@interface` annotation we can write:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其添加到我们可以编写的`@interface`注解中：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, in case there is only one value we want to pass as the parameter value,
    we can still use the format:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只想传递一个值作为参数值，我们仍然可以使用以下格式：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the value of the attribute will be an array of length `1`. When
    the value of an annotation is an array of annotation types, things get a bit more
    complex. We create an `@interface` annotation (note the plural in the name):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，属性的值将是一个长度为`1`的数组。当注解的值是一个注解类型的数组时，事情会变得稍微复杂一些。我们创建一个`@interface`注解（注意名字中的复数形式）：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The use of this annotation could be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解的使用可以如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that this is not the same as having the `ParameteredPoweredDevice` annotation
    with three parameters. This is an annotation that has two parameters. Each parameter
    is an annotation. The first has one string parameter and the second has two.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不等同于拥有三个参数的`ParameteredPoweredDevice`注解。这是一个有两个参数的注解。每个参数都是一个注解。第一个有一个字符串参数，第二个有两个。
- en: As you can see, annotations can be fairly complex, and some of the frameworks
    (or rather the programmers who created them) ran amok using them. Before you start
    writing a framework, research to see whether there is already a framework that
    you can use. Also, check whether there is some other way to solve your problem.
    99% of annotation handling code could be avoided and made simpler. The less code
    we write for the same functionality, the happier we are. We programmers are the
    lazy types and this is the way it has to be.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，注解可以相当复杂，一些框架（或者更确切地说，创建它们的程序员）在使用它们时有些失控。在您开始编写框架之前，研究一下是否已经存在您可以使用的一个框架。同时，检查是否有其他方法可以解决您的问题。99%的注解处理代码可以避免，并变得简单。我们编写的代码越少，对于相同的功能就越满意。我们程序员是懒惰的类型，这就是必须这样做的原因。
- en: The last example, where the parameter of the annotation is an array of annotations,
    is important to understand how we can create repeatable annotations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，其中注解的参数是一个注解数组，理解我们如何创建可重复的注解是很重要的。
- en: Repeatable annotations
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重复注解
- en: 'Annotate the declaration of the annotation with `@Repeatable` to denote that
    the annotation can be applied multiple times at one place. The parameter to this
    annotation is an annotation type that should have a parameter of type, which is
    an array of this annotation. Don''t try to understand! I''ll give an example instead.
    I already have, in fact: we have `@PoweredDevices`. It has an argument that is
    an array of `@ParameteredPoweredDevice`. Consider that we now annotate this `@interface`
    as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Repeatable`注解注解注解的声明，以表示该注解可以在一个地方多次应用。这个注解的参数是一个注解类型，它应该有一个类型为该注解数组的参数。不要试图理解！我将给出一个例子。实际上，我已经有了：我们有`@PoweredDevices`。它有一个参数是一个`@ParameteredPoweredDevice`的数组。考虑我们现在将这个`@interface`注解如下：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we can simplify the use of `@ParameteredPoweredDevice`. We can repeat
    the annotation multiple times and the Java runtime will automatically enclose
    it in the wrapping class, which, in this case, is `@PoweredDevices`. In this case,
    the following two will be equivalent:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简化`@ParameteredPoweredDevice`的使用。我们可以多次重复注解，Java运行时会自动将其封装在包装类中，在这种情况下是`@PoweredDevices`。在这种情况下，以下两个将是等效的：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The reason for this complex approach is again an example of backward compatibility
    that Java strictly follows. Annotations were introduced in Java 1.5 and repeatable
    annotations have been available only since version 1.8\. We will soon talk about
    the reflection API that we use to handle the annotations during runtime. This
    API in the `java.lang.reflect.AnnotatedElement` interface has a `getAnnotation(annotationClass)`
    method, which returns an annotation. If a single annotation can appear more than
    once on a class, method, and so on, then there is no way of calling this method
    to get all the different instances with all the different parameters. Backward
    compatibility was ensured by introducing the containing type that wraps the multiple
    annotations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂方法的理由再次是Java严格遵循的后向兼容性的一个例子。注解是在Java 1.5中引入的，而可重复注解则只从版本1.8开始可用。我们很快就会谈到我们用来在运行时处理注解的反射API。这个API在`java.lang.reflect.AnnotatedElement`接口中有一个`getAnnotation(annotationClass)`方法，它返回一个注解。如果一个注解可以在类、方法等上出现多次，那么就没有办法调用这个方法来获取所有不同参数的不同实例。通过引入包含类型来包装多个注解，确保了后向兼容性。
- en: Annotation inheritance
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解继承
- en: Annotations, just like methods or fields, can be inherited between class hierarchies.
    If an annotation declaration is marked with `@Inherited`, then a class that extends
    another class with this annotation can inherit it. The annotation can be overridden
    in case the child class has the annotation. Because there is no multiple inheritance
    in Java, annotations on interfaces cannot be inherited. Even when the annotation
    is inherited, the application code that retrieves the annotation of a certain
    element can distinguish between the annotations that are inherited and those that
    are declared on the entity itself. There are methods to get the annotations and
    separate methods to get the declared annotations that are declared on the actual
    element, and not inherited.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注解，就像方法或字段一样，可以在类层次结构之间继承。如果一个注解声明被标记为`@Inherited`，那么扩展了具有此注解的另一个类的类可以继承它。如果子类有注解，则可以覆盖注解。因为Java中没有多重继承，所以接口上的注解不能继承。即使注解被继承，检索特定元素注解的应用程序代码也可以区分继承的注解和实体本身声明的注解。有方法可以获取注解，还有单独的方法可以获取实际元素上声明的注解，而不是继承的。
- en: '@Documented annotations'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Documented`注解'
- en: The `@Documented` annotation expresses the intent that the annotation is part
    of the contract of the entity and, this way, it has to get into the documentation.
    This is an annotation that the *JavaDoc* generator looks at when creating the
    documentation for an element that references the `@Documented` annotation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Documented`注解表达了这样的意图：注解是实体契约的一部分，因此它必须包含在文档中。这是一个*JavaDoc*生成器在创建引用`@Documented`注解的元素的文档时查看的注解。'
- en: JDK annotations
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK注解
- en: There are other annotations defined in the JDK in addition to those that are
    to be used to define annotations. We have already seen some of these. The most
    frequently used is the `@Override` annotation. When the compiler sees this annotation,
    it checks that the method really overrides some inherited method. Failing to do
    so will result in an error, saving us from miserable runtime debugging.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于定义注解的注解之外，JDK中还定义了其他一些注解。我们已经看到了其中的一些。最常用的是`@Override`注解。当编译器看到这个注解时，它会检查该方法是否真正覆盖了某个继承的方法。如果没有这样做，将会导致错误，从而避免我们在运行时调试中的痛苦。
- en: The `@Deprecated` annotation signals in the documentation of a method, class,
    or some other element that the element is not to be used. It is still there in
    the code, because some users may still use it, but in the case of a new development
    that depends on the library containing the element, the newly developed code should
    not use it. The annotation has two parameters. One parameter is `since`, which
    can have a string value and may deliver version information about how long or
    since which version of the method, or class is deprecated. The other parameter
    is `forRemoval`, which should be `true` if the element will not appear in the
    future versions of the library. Some methods may be deprecated because there are
    better alternatives but the developers do not intend to remove the method from
    the library. In such a case, the `forRemoval` can be set to `false`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Deprecated`注解在方法、类或其他元素的文档中表示该元素不应使用。它仍然存在于代码中，因为一些用户可能仍然会使用它，但在依赖于包含该元素库的新开发中，新开发的代码不应使用它。该注解有两个参数。一个参数是`since`，它可以有一个字符串值，可以提供关于方法或类何时或从哪个版本开始被弃用的版本信息。另一个参数是`forRemoval`，如果该元素将不会出现在库的未来版本中，则应设置为`true`。某些方法可能因为存在更好的替代方案而被弃用，但开发者并不打算从库中删除该方法。在这种情况下，`forRemoval`可以设置为`false`。'
- en: The `@SuppressWarning` annotation is also a frequently used one, though its
    use is questionable. It can be used to suppress some of the warnings of the compiler.
    It is recommended to write code, if possible, which can be compiled without any
    warning.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SuppressWarning`注解也是一个常用的注解，尽管其使用是有疑问的。它可以用来抑制编译器的一些警告。如果可能，建议编写没有警告的代码。'
- en: The `@FunctionalInterface` annotation declares that an interface intends to
    have only one method. Such interfaces can be implemented as lambda expressions.
    You will learn about lambda expressions later in this chapter. When this annotation
    is applied on an interface and there is more than one method declared in the interface,
    the compiler will signal compilation error. This will prevent any developer early
    on from adding another method to an interface intended to be used together with
    functional programming and lambda expressions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FunctionalInterface`注解声明一个接口只打算有一个方法。这样的接口可以作为lambda表达式实现。你将在本章后面学习关于lambda表达式的内容。当这个注解应用于一个接口，并且接口中声明了多个方法时，编译器将发出编译错误。这将防止任何开发者早期向一个打算与函数式编程和lambda表达式一起使用的接口中添加另一个方法。'
- en: Using reflection
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反射
- en: Now that you have learnt how to declare annotations and how to attach them to
    classes and methods, we can return to our `ProductInformation` class. Recall that
    we wanted to specify the type of products in this class and that each product
    type is represented by an `@interface` annotation. We have already listed it in
    the previous few pages, the one we will implement in our  `@PoweredDevice` example.
    We will develop the code assuming that later there will be many such annotations,
    product types, and consistency checkers that are annotated with `@Component` and
    with one or more of our annotations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何声明注解以及如何将它们附加到类和方法上，我们可以回到我们的`ProductInformation`类。回想一下，我们想要指定这个类中的产品类型，并且每种产品类型都由一个`@interface`注解表示。我们已经在之前的几页中列出了它，即我们将在`@PoweredDevice`示例中实现的一个。我们将假设将来会有许多这样的注解、产品类型和带有`@Component`以及一个或多个我们注解的一致性检查器。
- en: Getting annotations
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取注解
- en: 'We will extend the `ProductInformation` class with the following field:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下字段扩展`ProductInformation`类：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since this is a DTO, and Spring needs the setters and getters, we will also
    add a new getter and setter to it. This field will contain the list of classes
    that each class implement one of our annotations and also the built-in JDK interface,
    `Annotation`, because that is the way the Java compiler generates them. At this
    point, this may be a bit murky but I promise that the dawn will break and there
    will be light as we go on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 DTO，Spring 需要设置器和获取器，因此我们也将添加一个新的获取器和设置器。这个字段将包含每个类实现的我们的一些注解以及内置的 JDK
    接口 `Annotation`，因为这就是 Java 编译器生成它们的方式。在这个阶段，这可能会有些模糊，但我保证随着我们的继续前进，曙光将破晓，光明将到来。
- en: To get the product information, we have to look it up by ID. This is the interface
    and service that we developed in the last chapter, except, this time, we have
    another new field. This is, in fact, a significant difference although the `ProductLookup`
    interface did not change at all. In the last chapter, we developed two versions.
    One of the versions was reading the data from a properties file, the other one
    was connecting to a REST service.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取产品信息，我们必须通过 ID 查找它。这是我们在上一章中开发的接口和服务，除了这次我们有一个新的字段。实际上，这是一个重大的区别，尽管 `ProductLookup`
    接口完全没有变化。在上一章中，我们开发了两个版本。其中一个版本是从属性文件中读取数据，另一个版本是连接到 REST 服务。
- en: Properties files are ugly and old technology but a must if ever you intend to
    pass a Java interview or work on enterprise applications developed at the start
    of the 21^(st) century. I had to include it in the last chapter. It was my own
    urge to include it in the book. At the same time, while coding for this chapter,
    I did not have the stomach to keep using it. I also wanted to show you that the
    same content could be managed in a JSON format.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件很丑陋，是过时的技术，但如果你打算通过 Java 面试或在 21 世纪初开发的企业应用程序中工作，则是必须的。我不得不将其包含在最后一章中。这是我自己强烈希望在书中包含它的愿望。同时，在编写这一章的代码时，我没有勇气继续使用它。我还想向你展示相同的内容可以用
    JSON 格式管理。
- en: 'Now, we will extend the implementation of `ResourceBasedProductLookup` to read
    the product information from JSON formatted resource files. Most of the code remains
    the same in the class; therefore, we only list the difference here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将扩展 `ResourceBasedProductLookup` 的实现，以从 JSON 格式的资源文件中读取产品信息。在类中，大部分代码保持不变；因此，我们只列出这里的不同之处：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `project resources/products` directory we have a few JSON files. One
    of them contains the desk lamp product information:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `project resources/products` 目录中，我们有一些 JSON 文件。其中之一包含台灯产品的信息：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The type of product is specified in a JSON array. In this example, this array
    has only one element and that element is the fully qualified name of the annotation
    interface that represents the type of product. When the JSON marshaller converts
    the JSON to a Java object, it recognizes that the field that needs this information
    is a `List`, so it converts the array to a list and, also, the elements from `String`
    to `Class` objects representing the annotation interface.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 产品类型在 JSON 数组中指定。在这个例子中，这个数组只有一个元素，而这个元素是表示产品类型的注解接口的完全限定名称。当 JSON 序列化器将 JSON
    转换为 Java 对象时，它会识别出需要此信息的字段是一个 `List`，因此它将数组转换为列表，并将元素从 `String` 转换为表示注解接口的 `Class`
    对象。
- en: 'Now that we have the resources loaded from JSON formatted resources and we
    saw how easy it is to read JSON data when using Spring, we can get back to the
    order consistency check. The `Checker` class implements the logic to collect the
    pluggable checkers and to invoke them. It also implements the annotation-based
    screening so as not to invoke the checkers we don''t really need for the actual
    products in the actual order:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从 JSON 格式的资源中加载了资源，并看到了使用 Spring 读取 JSON 数据是多么容易，我们可以回到订单一致性检查。`Checker`
    类实现了收集可插拔检查器并调用它们的逻辑。它还实现了基于注解的筛选，以便不调用我们实际上不需要用于实际产品实际订单的检查器：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One of the interesting things to mention is that the Spring auto-wiring is very
    clever. We have a field with the `Collection<ConsistencyChecker>` type. Usually,
    auto-wiring works if there is exactly one class that has the same type as the
    resources to wire. In our case, we do not have any such candidate since this is
    a collection, but we have many `ConsistencyChecker` classes. All our checkers
    implement this interface and Spring recognizes it, instantiates them all, magically
    creates a collection of them, and injects the collection into this field.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有趣的事情要提一下，那就是Spring的自动装配非常聪明。我们有一个`Collection<ConsistencyChecker>`类型的字段。通常，如果有一个恰好与要连接的资源类型相同的类，自动装配就会工作。在我们的情况下，我们没有这样的候选者，因为这是一个集合，但我们有多个`ConsistencyChecker`类。我们所有的检查器都实现了这个接口，Spring能够识别它们，实例化它们，神奇地创建一个它们的集合，并将这个集合注入到这个字段中。
- en: Usually a good framework works logically. I was not aware of this feature of
    Spring, but I thought that this would be logical and, magically, it worked. If
    things are logical and just work, you do not need to read and remember the documentation.
    A bit of caution does not harm however. After I experienced that this functionality
    works this way, I looked it up in the documentation to see that this is really
    a guaranteed feature of Spring and not something that just happens to work but
    may change in future versions without notice. Using only guaranteed features is
    extremely important but is neglected many times in our industry.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常一个好的框架在逻辑上是合理的。我之前并不了解Spring的这个特性，但我想这应该是合理的，神奇的是，它真的工作了。如果事情是合理的并且顺利运行，你就不需要阅读和记住文档。然而，一点谨慎并不会有害。在我体验过这个功能是这样工作的之后，我在文档中查看了这个功能，发现这确实是Spring的一个保证特性，而不是仅仅偶然工作，可能在未来的版本中未经通知而改变。只使用保证的特性非常重要，但我们的行业中经常被忽视。
- en: When the `isConsistent` method is invoked, it first collects the product information
    into `HashMap`, assigning a `ProductInformation` instance to each `OrderItem`.
    This is done in a separate class. After this, `ProductsCheckerCollector` collects
    the `ConsistencyChecker` instances needed by one or more product items. When we
    have this set, we need to invoke only those checkers that are annotated with one
    of the annotations that are in this set. We do that in a loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当`isConsistent`方法被调用时，它首先将产品信息收集到`HashMap`中，为每个`OrderItem`分配一个`ProductInformation`实例。这是在一个单独的类中完成的。之后，`ProductsCheckerCollector`收集一个或多个产品项需要的`ConsistencyChecker`实例。当我们有了这个集合后，我们只需要调用那些带有这个集合中注解之一的检查器。我们在循环中这样做。
- en: In this code, we use reflection. We loop over the annotations that each checker
    has. To get the collection of annotations, we invoke `checker.getClass().getAnnotations()`.
    This invocation returns a collection of objects. Each object is an instance of
    some JDK runtime generated class that implements the interface we declared as
    an annotation in its own source file. There is no guarantee, though, that the
    dynamically created class implements only our `@interface` and not some other
    interfaces. Therefore, to get the actual annotation class, we have to invoke the
    `annotationType` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用反射。我们遍历每个检查器拥有的注解。为了获取注解集合，我们调用`checker.getClass().getAnnotations()`。这个调用返回一个对象集合。每个对象都是实现我们自己在源文件中声明的注解接口的JDK运行时生成的类的实例。然而，没有保证动态创建的类只实现了我们的`@interface`而没有实现其他接口。因此，为了获取实际的注解类，我们必须调用`annotationType`方法。
- en: The `ProductCheckerCollector` and `ProductInformationCollector` classes are
    very simple, and we will discuss them later when we learn about streams. They
    will serve as a good example at that place, when we implement them using loops
    and, right after that, using streams.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductCheckerCollector`和`ProductInformationCollector`类非常简单，我们将在学习流时再讨论它们。它们将在那个地方作为一个很好的例子，当我们使用循环实现它们，然后立即使用流来实现。'
- en: 'Having them all, we can finally create our actual checker classes. The one
    that helps us see that there is a power cord ordered for our lamp is the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有它们之后，我们最终可以创建我们的实际检查器类。帮助我们看到我们的台灯订购了电源线的那个类如下：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The helper class contains simple methods that will be needed by many of the
    checkers, for example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助类包含许多检查器需要的简单方法，例如：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Invoking methods
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用方法
- en: In this example, we used only one single reflection call to get the annotations
    attached to a class. Reflection can do many more things. Handling annotations
    is the most important use for these calls since annotations do not have their
    own functionality and cannot be handled in any other way during runtime. Reflection,
    however, does not stop telling us what annotations a class or any other annotable
    element has. Reflection can be used to get a list of the methods of a class, the
    name of the methods as strings, the implemented interfaces of a class, the parent
    class it extends, the fields, the types of fields, and so on. Reflection generally
    provides methods and classes to walk through the actual code structure down to
    the method level, programmatically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只使用了一个单独的反射调用来获取附加到类上的注解。反射可以做更多的事情。处理注解是这些调用最重要的用途，因为注解没有自己的功能，并且在运行时无法以任何其他方式处理。然而，反射并没有停止告诉我们一个类或任何其他可注解元素有哪些注解。反射可以用来获取类的列表、方法名称作为字符串、类的实现接口、它扩展的父类、字段、字段类型等等。反射通常提供方法和类来遍历实际的代码结构，直到方法级别，以编程方式。
- en: This walkthrough does not only allow reading types and code structure but also
    makes it possible to set field values and call methods without knowing the methods'
    name at compile time. We can even set fields that are `private` and are not generally
    accessible by the outside world. It is also to note that accessing the methods
    and fields through reflection is usually slower than through compiled code because
    it always involves lookup by the name of the element in the code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历不仅允许读取类型和代码结构，而且还使得在编译时不知道方法名称的情况下设置字段值和调用方法成为可能。我们甚至可以设置那些是`private`且通常无法由外界访问的字段。还值得注意的是，通过反射访问方法和字段通常比通过编译代码慢，因为它总是涉及到在代码中通过元素名称进行查找。
- en: The rule of thumb is that if you see that you have to create code using reflection,
    then realize that you are probably creating a framework (or writing a book about
    Java that details reflection). Does it sound familiar?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则表明，如果你发现必须使用反射来创建代码，那么意识到你可能正在创建一个框架（或者正在编写一本关于Java的书籍，详细介绍了反射）。这听起来熟悉吗？
- en: Spring also uses reflection to discover the classes, methods, and fields, and
    also to inject an object. It uses the URL class loader to list all the JAR files
    and directories that are on the class path, loads them, and examines the classes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Spring也使用反射来发现类、方法和字段，以及注入对象。它使用URL类加载器列出类路径上所有的JAR文件和目录，加载它们，并检查类。
- en: For a contrived example, for the sake of demonstration, let's assume that the
    `ConsistencyChecker` implementations were written by many external software vendors,
    and the architect who originally designed the program structure just forgot to
    include the `isConsistent` method in the interface. (At the same time, to save
    our mental health, we can also imagine that this person is not working anymore
    in the company for doing so.) As a consequence, the different vendors delivered
    Java classes that "implement" this interface but we cannot invoke the method,
    not only because we do not have a common parent interface that has this method
    but also because the vendors just happened to use different names for their methods.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，为了演示目的，让我们假设`ConsistencyChecker`的实现是由许多外部软件供应商编写的，而最初设计程序结构的架构师恰好忘记在接口中包含`isConsistent`方法。（同时，为了保护我们的心理健康，我们也可以想象这个人因为这样做而不再在公司工作。）结果，不同的供应商提供了“实现”这个接口的Java类，但我们无法调用该方法，不仅因为我们没有具有此方法的公共父接口，而且因为供应商恰好使用了不同的方法名称。
- en: What can we do in this situation? Business-wise, asking all the vendors to rewrite
    their checkers is ruled out because them knowing we are in trouble attaches a
    hefty price tag to the task. Our managers want to avoid that cost and we developers
    also want to show that we can mend the situation and do miracles. (Later, I will
    have a comment on that.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下我们能做什么呢？从业务角度来看，要求所有供应商重写他们的检查器是不被允许的，因为他们知道我们遇到麻烦，这给任务贴上了高昂的标签。我们的经理们希望避免这种成本，我们开发者也希望表明我们可以修复这种情况并创造奇迹。（稍后，我会对此发表评论。）
- en: We could just have a class that knows every checker and how to invoke each of
    them in many different ways. This would require us to maintain the said class
    whenever a new checker is introduced to the system, and we want to avoid that.
    The whole plugin architecture we are using was invented for this very purpose
    in the first place.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个类，它知道每个校验器以及如何以多种不同的方式调用它们。这要求我们每次向系统中引入新的校验器时都要维护这个类，而我们希望避免这样做。我们最初发明整个插件架构正是为了这个目的。
- en: 'How can we invoke a method on an object that we know has only one declared
    method, which accepts an order as a parameter? That is where reflection comes
    into the picture. Instead of calling `checker.isInconsistent(order)`, we implement
    a small `private` method, `isInconsistent`, which calls the method, whatever its
    name is, via reflection:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何调用一个对象上的方法，我们知道这个对象只有一个声明的方法，它接受一个订单作为参数？这就是反射发挥作用的地方。我们不是调用`checker.isInconsistent(order)`，而是实现一个小的`private`方法`isInconsistent`，它通过反射调用该方法，无论其名称是什么：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can get the class of the object by calling the `getClass` method, and on
    the object that represents the class itself, we can call `getDeclaredMethods`.
    Fortunately, the checker classes are not littered by many methods, so we check
    that there is only one method declared in the checker class. Note that there is
    also a `getMethods` method in the reflection library but it always will return
    more than one method. It returns the declared and the inherited methods. Because
    each and every class inherits from `java.lang.Object`, at least the methods of
    the `Object` class will be there.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`getClass`方法来获取对象的类，对于代表类的对象本身，我们可以调用`getDeclaredMethods`。幸运的是，校验器类并没有被许多方法所充斥，因此我们检查校验器类中只声明了一个方法。请注意，反射库中还有一个`getMethods`方法，但它总是会返回多个方法。它返回声明和继承的方法。因为每个类都继承自`java.lang.Object`，至少`Object`类的那些方法都会存在。
- en: After this, we try to invoke the class using the `Method` object that represents
    the method in the reflection class. Note that this `Method` object is not directly
    attached to an instance. We retrieved the method from the class, and thus, when
    we invoke it, we should pass the object it should work on as a first parameter.
    This way, `x.y(z)`, becomes `method.invoke(x,z)`. The last parameter of invoke
    is a variable number of arguments that are passed as an `Object` array. In most
    cases, when we invoke a method, we know the arguments in our code even if we do
    not know the name of the method and have to use reflection. When even the arguments
    are not known but are available as a matter of calculation, then we have to pass
    them as an `Object` array.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们尝试使用代表反射类中方法的`Method`对象来调用类。请注意，这个`Method`对象并不是直接附加到一个实例上的。我们是从类中检索到这个方法的，因此当我们调用它时，我们应该将作为第一个参数传递给它应该工作的对象。这样，`x.y(z)`就变成了`method.invoke(x,z)`。`invoke`方法的最后一个参数是一个可变数量的参数，它们作为`Object`数组传递。在大多数情况下，当我们调用一个方法时，即使我们不知道方法的名称，也必须使用反射，我们也会知道我们的代码中的参数。当即使参数也不为人所知但可以通过计算获得时，我们必须将它们作为`Object`数组传递。
- en: Invoking a method via reflection is a risky call. If we try to call a method
    the normal way, which is `private`, then the compiler will signal an error. If
    the number of arguments or types are not appropriate, the compiler will again
    will give us an error. If the returned value is not `boolean`, or there is no
    return value at all, then we again get a compiler error. In the case of reflection,
    the compiler is clueless. It does not know what method we will invoke when the
    code is executing. The `invoke` method, on the other hand, can and will notice
    all these failures when it is invoked. If any of the aforementioned problems occur,
    then we will get exceptions. If the `invoke` method itself sees that it cannot
    perform what we ask of it, then it will throw `InvocationTargetException` or `IllegalAccessException`.
    If the conversion from the actual return value to `boolean` is not possible, then
    we will get `ClassCastException`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反射调用方法是一个风险很大的调用。如果我们尝试以正常的方式调用一个方法，比如`private`，编译器将会报错。如果参数的数量或类型不合适，编译器会再次给我们报错。如果返回值不是`boolean`，或者根本没有返回值，那么我们再次得到编译器错误。在反射的情况下，编译器是无知的。它不知道代码执行时将调用哪个方法。另一方面，`invoke`方法在调用时可以并会注意到所有这些失败。如果上述任何问题发生，我们将会得到异常。如果`invoke`方法本身看到它无法执行我们所要求的事情，那么它将抛出`InvocationTargetException`或`IllegalAccessException`。如果从实际返回值到`boolean`的转换不可能，那么我们将得到`ClassCastException`。
- en: About doing magic, it is a natural urge that we feel like making something extraordinary,
    something outstanding. This is okay when we are experimenting with something,
    doing a hobby job. On the other hand, this is strongly not okay when we are working
    on a professional job. Average programmers, who do not understand your brilliant
    solution, will maintain the code in an enterprise environment. They will turn
    your nicely combed code into haystack while fixing some bugs or implementing some
    minor new features. Even if you are the Mozart of programming, they will be, at
    best, no-name singers. A brilliant code in an enterprise environment can be a
    requiem, with all the implications of that metaphor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于做魔术，这是一种自然的冲动，我们想要创造出非凡的、杰出的事物。当我们进行实验或从事爱好工作时，这是可以接受的。另一方面，当我们从事专业工作时，这却绝对是不妥的。那些不理解你聪明解决方案的普通程序员，会在企业环境中维护代码。他们会将你精心整理的代码变成一堆乱麻，在修复一些错误或实现一些小的新功能时。即使你是编程界的莫扎特，他们充其量也只是不知名的歌手。在企业环境中，一段精彩的代码可能就像一首挽歌，带有所有这个比喻的含义。
- en: Last but not least, the sad reality is that we are usually not the Mozarts of
    programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，一个令人悲伤的现实是，我们通常不是编程界的莫扎特。
- en: Note that in case the return value of the original value is primitive, then
    it will be converted to an object by reflection, and then we will convert it back
    to the primitive value. If the method does not have a return value, in other words,
    if it is `void`, then the reflection will return a `java.lang.Void` object. The
    `Void` object is only a placeholder. We cannot convert it to any primitive value
    or any other type of objects. It is needed because Java is strict and `invoke`
    has to return an `Object`, so the runtime needs something that it can return.
    All we can do is check that the returned value class is really `Void`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果原始值的返回值是原始类型，那么它将通过反射转换为对象，然后我们将其转换回原始值。如果没有返回值，换句话说，如果它是`void`，那么反射将返回一个`java.lang.Void`对象。`Void`对象只是一个占位符。我们不能将其转换为任何原始值或任何其他类型的对象。这是必需的，因为Java是严格的，`invoke`必须返回一个`Object`，所以运行时需要一些可以返回的东西。我们所能做的就是检查返回值的类是否确实是`Void`。
- en: 'Let''s go on with the storyline and our solution. We submitted the code and
    it works in production for a while till a new update from a software vendor breaks
    it. We debug the code in the test environment and see that the class now contains
    more than one method. Our documentation clearly states that they should only have
    one `public` method, and they provided a code that has...hmm...we realize that
    the other methods are `private`. They are right; they can have `private` methods
    according to the contract, so we have to amend the code. We replace the lines
    that look up the one and only method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续故事情节和我们的解决方案。我们提交了代码，它在生产环境中运行了一段时间，直到软件供应商的新更新将其破坏。我们在测试环境中调试代码，看到现在这个类包含多个方法。我们的文档明确指出，它们应该只有一个`public`方法，他们提供了一个有...嗯...我们意识到其他方法都是`private`的。他们是正确的；根据合同，他们可以有`private`方法，所以我们必须修改代码。我们替换了查找唯一方法的行：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The new code will be as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码如下：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The new method we write to look up the one and only `public` method is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的新方法来查找唯一的`public`方法如下：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To check whether the method is `public` or not, we use a `static` method from
    the `Modifier` class. There are methods to check all possible modifiers. The value
    that the `getModifiers` method returns is an `int` bit field. Different bits have
    different modifiers and there are constants that define these. This simplification
    leads to inconsistency, which you can check if a method is an interface or volatile,
    that is, actually nonsense. The fact is that bits that can only be used for other
    types of reflection objects will never be set.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查方法是否是`public`的，我们使用`Modifier`类的一个`static`方法。有方法可以检查所有可能的修饰符。`getModifiers`方法返回的值是一个`int`位字段。不同的位有不同的修饰符，有一些常量定义了这些。这种简化导致了不一致性，你可以检查一个方法是否是接口或易失性的，实际上这是荒谬的。事实是，只能用于其他类型反射对象的位永远不会被设置。
- en: 'There is one exception, which is `volatile`. This bit is reused to signal bridge
    methods. Bridge methods are created by the compiler automatically and can have
    deep and complex issues that we do not discuss in this book. The reuse of the
    same bit does not cause confusion because a field can be `volatile`, but as a
    field, it cannot be a bridge method. Obviously, a field is a field and not a method.
    In the same way, a method cannot be a `volatile` field. The general rule is: do
    not use methods on reflection objects where they do not have a meaning; or else,
    know what you do.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个例外，就是`volatile`。这个位被重新用于表示桥接方法。桥接方法是由编译器自动创建的，可能存在深奥和复杂的问题，我们在这本书中不讨论。由于重用了相同的位，所以不会引起混淆，因为字段可以是`volatile`的，但作为一个字段，它不能是桥接方法。显然，字段就是字段，而不是方法。同样，方法不能是`volatile`字段。一般规则是：不要在反射对象上使用没有意义的方法；否则，了解你在做什么。
- en: Making the storyline even more intricate, a new version of a checker accidentally
    implements the checking method as a package `private`. The programmer simply forgot
    to use the `public` keyword. For the sake of simplicity, let's assume that the
    classes declare only one method again, but it is not public. How do we solve this
    problem using reflection?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使故事线更加复杂，一个检查器的版本意外地将检查方法实现为包`private`。程序员只是忘记使用`public`关键字。为了简化，让我们再次假设类只声明了一个方法，但这个方法不是公开的。我们如何使用反射来解决这个问题？
- en: 'Obviously, the simplest solution is to ask the vendors to fix the problem:
    it is their fault. In some cases, however, we must create a workaround over some
    problems. There is another solution: creating a class with a `public` method in
    the same package, invoking the package `private` methods from the other class,
    thus relaying the other class. As a matter of fact, this solution, as a workaround
    for such a bug, seems to be more logical and cleaner, but this time, we want to
    use reflection.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最简单的解决方案是要求供应商修复问题：这是他们的责任。然而，在某些情况下，我们必须在某个问题上创建一个解决方案。另一个解决方案是创建一个具有相同包中`public`方法的类，从其他类中调用包`private`方法，从而传递其他类。实际上，这个解决方案，作为此类错误的解决方案，似乎更加合理和干净，但这次，我们想使用反射。
- en: 'To avoid `java.lang.IllegalAccessException`, we have to set the `method` object
    as accessible. To do so, we have to insert the following line in front of the
    invocation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免`java.lang.IllegalAccessException`，我们必须将`method`对象设置为可访问。为此，我们必须在调用之前插入以下行：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that this will not change the method to `public`. It will only make the
    method accessible for invocation through the very instance of the `method` object
    that we set as accessible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不会将方法改为`public`。它只会使方法对于通过我们设置为可访问的`method`对象实例的可访问。
- en: I have seen code that checks whether a method is accessible or not by calling
    the `isAccessible` method and saves this information; it sets the method as accessible
    if it was not accessible and restores the original accessibility after the invocation.
    This is totally useless. As soon as the `method` variable goes out of scope, and
    there is no reference to the object we set the accessibility flag to, the effect
    of the setting wears off. Also, there is no penalty for setting the accessibility
    of a `public` or an otherwise callable method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过一些代码通过调用`isAccessible`方法来检查一个方法是否可访问，并将此信息保存下来；如果方法原本不可访问，则将其设置为可访问，并在调用后恢复原始的可访问性。这完全是多余的。一旦`method`变量超出作用域，并且没有引用我们设置可访问性标志的对象，设置的效果就会消失。此外，设置`public`或可调用的方法的可访问性没有惩罚。
- en: Setting fields
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置字段
- en: 'We can also call `setAccessible` on `Field` objects and then we can even set
    the value of private fields using reflection. Without further fake stories, just
    for the sake of the example, let''s make a `ConsistencyChecker` named `SettableChecker`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`Field`对象上调用`setAccessible`，然后我们可以甚至使用反射设置私有字段的值。不进一步编造故事，只是为了举例，让我们创建一个名为`ConsistencyChecker`的`SettableChecker`：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This checker will return `false`, unless we set the field to `true` using reflection.
    We do set it as such. We create a method in the `Checker` class and invoke it
    from the checking process for each checker:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查器将返回`false`，除非我们使用反射将字段设置为`true`。我们确实这样做了。我们在`Checker`类中创建了一个方法，并在检查过程中的每个检查器中调用它：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method goes through all the declared fields and if the name is `setValue`
    and the type is `boolean`, then it sets it to `true`. This will essentially render
    all orders that contain a powered device as rejected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法遍历所有声明的字段，如果名称是`setValue`且类型是`boolean`，则将其设置为`true`。这将本质上使所有包含有源设备的订单被拒绝。
- en: Note that although `boolean` is a built-in language primitive, which is not
    a class by any means, it still has a class so that reflection can compare the
    type of the field gainst he class that `boolean` artificially has. Now `boolean.class`
    is a class literal in the language, and for each primitive, a similar constant
    can be used. The compiler identifies these as class literals and creates the appropriate
    pseudo class references in the byte code so that primitives can also be checked
    in this way, as demonstrated in the sample code of the `setValueInChecker` method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管`boolean`是一个内置的语言原语，它绝对不是一个类，但它仍然有一个类，以便反射可以比较字段的类型与`boolean`人为具有的类。现在`boolean.class`是语言中的一个类字面量，对于每个原语，都可以使用类似的常量。编译器将这些识别为类字面量，并在字节码中创建适当的伪类引用，以便原语也可以以这种方式进行检查，正如在`setValueInChecker`方法的示例代码中所展示的。
- en: We checked that the field has the appropriate type, and we also called the `setAccessible`
    method on the field. Even though the compiler does not know that we really did
    everything to avoid `IllegalAccessException`, it still believes that calling `set`
    on `field` can throw such an exception, as it is declared. However, we know that
    it should not happen. (Famous last words of a programmer?) To handle this situation,
    we surround the method call with a `try` block, and in the `catch` branch, we
    log the exception.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查了字段是否具有适当的类型，并且我们还对该字段调用了`setAccessible`方法。尽管编译器不知道我们确实已经做了所有事情来避免`IllegalAccessException`，但它仍然认为在`field`上调用`set`可能会抛出这样的异常，因为它被声明了。然而，我们知道这种情况不应该发生。（这是程序员的著名最后遗言吗？）为了处理这种情况，我们在方法调用周围包围了一个`try`块，并在`catch`分支中记录了异常。
- en: Functional programming in Java
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的函数式编程
- en: Since we have created a lot of code in our example for this chapter, we will
    look at the functional programming features of Java, which will help us delete
    many lines from our code. The less code we have, the easier it is to maintain
    the application; thus, programmers love functional programming. But this is not
    the only reason why functional programming is so popular. It is also an excellent
    way to describe certain algorithms in a more readable and less error prone manner
    than conventional loops.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章的示例中创建了大量的代码，我们将查看Java的函数式编程功能，这将帮助我们从我们的代码中删除许多行。我们拥有的代码越少，维护应用程序就越容易；因此，程序员喜欢函数式编程。但这并不是函数式编程如此受欢迎的唯一原因。它也是以更可读和更不易出错的方式描述某些算法的绝佳方式，比传统的循环更好。
- en: Functional programming is not a new thing. The mathematical background was developed
    for it in the 1930s. One of the first (if not the first) functional programming
    languages is LISP. It was developed in the 1950s and it is still in use, so much
    that there is a version of the language implemented on the JVM (Clojure).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程不是新事物。它在20世纪30年代为其开发了数学背景。第一个（如果不是第一个）函数式编程语言是LISP。它在20世纪50年代开发，至今仍在使用，以至于有该语言在JVM上的一个版本（Clojure）。
- en: Functional programming, in short, means that we express the program structure
    in terms of functions. In this meaning, we should think of functions as in mathematics
    and not as the term is used in programming languages such as C. In Java, we have
    methods, and when we are following the functional programming paradigm, we create
    and use methods that behave like mathematical functions. A method is functional
    if it gives the same result no matter how many times we invoke it, just as *sin(0)*
    is always zero. Functional programming avoids changing the state of objects, and
    because the state is not changing, the results are always the same. This also
    eases debugging.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，函数式编程意味着我们用函数来表示程序结构。在这个意义上，我们应该将函数视为数学中的函数，而不是像C等编程语言中使用的术语。在Java中，我们有方法，当我们遵循函数式编程范式时，我们创建并使用像数学函数一样行为的方法。一个方法是函数式的，如果无论我们调用多少次它都给出相同的结果，就像*sin(0)*总是零一样。函数式编程避免了改变对象的状态，因为状态没有改变，结果总是相同的。这也简化了调试。
- en: If a function has once returned a certain value for the given arguments, it
    will always return the same value. We can also read the code as a declaration
    of the calculation more than as commands that are executed one after the other.
    If the execution order is not important, then the readability of the code may
    also increase.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数对于给定的参数已经返回了一个特定的值，它将始终返回相同的值。我们也可以将代码读作是对计算的声明，而不是依次执行的命令。如果执行顺序不重要，那么代码的可读性也可能提高。
- en: Java helps functional programming style with lambda expressions and streams.
    Note that these streams are not I/O streams and do not really have any relation
    to those.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Java通过lambda表达式和流操作帮助实现函数式编程风格。请注意，这些流不是I/O流，实际上与那些流没有真正的关联。
- en: We will first take a short look at lambda expressions and what streams are,
    and then, we will convert some parts of our program to use these programming constructs.
    We will also see how much more readable these codes become.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先简要了解lambda表达式和流操作是什么，然后，我们将将程序的一些部分转换为使用这些编程结构。我们还将看到这些代码的可读性提高了多少。
- en: Readability is a debatable topic. A code may be readable to one developer and
    may be less readable to another. It very much depends on what they got used to.
    I experience many times that developers get distracted with streams. When developers
    first meet streams, the way to think about them and how they look is just strange.
    But this is the same as starting to learn using a bicycle. While you are still
    learning its use and you fall more than you roll, it is definitely slower than
    walking. On the other hand, once you have learnt how to ride a bike...
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性是一个有争议的话题。一段代码可能对一个开发者来说是可读的，而对另一个开发者来说可能不太可读。这很大程度上取决于他们习惯了什么。我多次经历过开发者被流操作分散注意力。当开发者第一次遇到流操作时，他们思考流的方式以及流的外观都是陌生的。但这就像刚开始学习骑自行车一样。当你还在学习如何使用它并且摔倒的次数比滚动次数多时，它肯定比走路慢。另一方面，一旦你学会了如何骑自行车...
- en: Lambda
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda
- en: 'We have already used lambda expressions in [Chapter 3](part0076.html), *Optimizing
    the Sort - Making Code Professional* when we wrote the exception-throwing test.
    In that code, we set the comparator to a special value that was throwing `RuntimeException`
    at each invocation:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章](part0076.html)，*优化排序 - 使代码专业化*中使用了lambda表达式，当时我们编写了异常抛出测试。在那段代码中，我们将比较器设置为在每次调用时抛出`RuntimeException`的特殊值：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The argument type is `Comparator`; therefore, what we have to set there should
    be an instance of a class that implements the `java.util.Comparator` interface.
    That interface defines only one method that implementations have to define: `compare.`
    Thus, we can define it as a lambda expression. Without lambda, if we need an instance,
    we have to type a lot. We have to create a class, name it, declare the `compare`
    method in it, and write the body of the method, as shown in the following code
    segment:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 参数类型是`Comparator`；因此，我们必须要设置的是一个实现了`java.util.Comparator`接口的类的实例。该接口只定义了一个实现必须定义的方法：`compare`。因此，我们可以将其定义为lambda表达式。如果没有lambda，如果我们需要一个实例，我们必须输入很多。我们必须创建一个类，给它命名，在其中声明`compare`方法，并编写方法的主体，如下面的代码段所示：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At the location of use, we should instantiate the class and pass it as an argument:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用位置，我们应该实例化类并将其作为参数传递：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We may save a few characters if we define the class as an anonymous class but
    the overhead is still there. What we really need is the body of the one and single
    method that we have to define. This is where lambda comes into the picture.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将类定义为匿名类，我们可以节省一些字符，但开销仍然存在。我们真正需要的是必须定义的那个单一方法的主体。这就是lambda出现的地方。
- en: We can use a lambda expression in any place where we would otherwise need an
    instance of a class that has to define only one method. The methods that are defined
    and inherited from `Object` do not count, and we also do not care about the methods
    that are defined as `default` methods in the interface. They are there. Lambda
    defines the one that is not yet defined. In other words, lambda clearly depicts,
    with much less overhead as an anonymous class, that the value is a functionality
    that we pass as a parameter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何需要定义只有一个方法的类的实例的地方使用lambda表达式。从`Object`继承的方法不算，我们也不关心接口中定义的作为`default`方法的方法。它们就在那里。Lambda定义了尚未定义的那个。换句话说，lambda以比匿名类更少的开销清晰地描述了值是一个作为参数传递的功能。
- en: 'The simple form of a lambda expression is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式的简单形式如下：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The parameters can be enclosed between parentheses or can only stand without.
    The body similarly can be enclosed between the `{` and`}` characters or it can
    be a simple expression. This way a lambda expression can reduce the overhead to
    a minimum, using the parentheses only where they are really needed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以放在括号内，也可以不放在括号内。同样，主体可以放在 `{` 和 `}` 字符之间，也可以是一个简单的表达式。这样，lambda表达式可以将开销降到最低，只在真正需要的地方使用括号。
- en: 'It is also an extremely useful feature of lambda expressions that we do not
    need to specify the types of the parameters in case it is obvious from the context
    where we use the expression. Thus, the preceding code segment can even be shorter,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式还有一个极其有用的特性，即如果我们使用的表达式上下文已经很明显，我们不需要指定参数的类型。因此，前面的代码段甚至可以更短，如下所示：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The parameters, `a` and `b`, will have the type as needed. To make it even simpler,
    we can also omit the `(` and`)` characters around the parameters in case there
    is only one.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `a` 和 `b` 将具有所需的类型。为了使其更加简单，如果只有一个参数，我们甚至可以省略参数周围的 `(` 和 `)` 字符。
- en: 'The parentheses are not optional if there is more than one parameter. This
    is to avoid ambiguity in some situations. For example, the method call, `f(x,y->x+y)`
    could have been a method with two arguments: `x` and a lambda expression that
    has one parameter, `y`. At the same time, it could also be a method call with
    a lambda expression that has two parameters, `x` and `y`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个参数，括号不是可选的。这是为了避免在某些情况下产生歧义。例如，方法调用 `f(x,y->x+y)` 可能是一个有两个参数的方法：`x` 和一个只有一个参数的lambda表达式
    `y`。同时，它也可能是一个有两个参数的lambda表达式的方法调用，参数分别是 `x` 和 `y`。
- en: Lambda expressions are very handy when we want to pass functionality as an argument.
    The declaration of the type of argument at the place of the method declaration
    should be a functional interface type. These interfaces can optionally be annotated
    using `@FunctionalInterface`. The Java runtime has many such interfaces defined
    in the `java.util.function` package. We will discuss some of them in the next
    section along with their use in streams. For the rest, the standard Java documentation
    is available from Oracle.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将功能作为参数传递时，lambda表达式非常方便。在方法声明的地方声明参数类型应该是函数式接口类型。这些接口可以选择性地使用 `@FunctionalInterface`
    进行注解。Java运行时在 `java.util.function` 包中定义了许多这样的接口。我们将在下一节讨论其中的一些，以及它们在流中的使用。其余的，可以通过Oracle的标准Java文档获取。
- en: Streams
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流（Streams）
- en: Streams were also new in Java 8, just like lambda expressions. They work together
    very strongly, so their appearance at the same time is not a surprise. Lambda
    expressions as well as streams support the functional programming style.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 流（Streams）也是Java 8的新特性，就像lambda表达式一样。它们之间有着非常紧密的协作，因此它们同时出现并不令人惊讶。lambda表达式和流都支持函数式编程风格。
- en: The very first thing to clarify is that streams do not have anything to do with
    input and output streams, except the name. They are totally different things.
    Streams are more like collections with some significant differences. (If there
    were no differences, they would just have been collections.) Streams are essentially
    pipelines of operations that can run sequentially or in parallel. They obtain
    their data from collections or other sources, including data that is manufactured
    on-the-fly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要明确的是，流与输入输出流没有任何关系，除了名称。它们是完全不同的东西。流更像是集合，但有一些显著的不同。（如果没有差异，它们就只是集合。）流本质上是一系列可以顺序或并行运行的运算管道。它们从集合或其他来源获取数据，包括即时生成的数据。
- en: Streams support the execution of the same calculation on multiple data. This
    structure is referred to as **Single Instruction Multiple Data** (**SIMD**). Don't
    be afraid of the expression. This is a very simple thing. We have already done
    that many times in this book. Loops are also kind of SIMD structures. When we
    loop through the checker classes to see whether any of those opposes the order,
    we perform the same instruction for each and every checker. Multiple checkers
    are multiple data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 流支持对多个数据执行相同的计算。这种结构被称为**单指令多数据**（**SIMD**）。不要害怕这个表达式。这实际上是一个非常简单的事情。我们在这本书中已经多次这样做过了。循环也是一种SIMD结构。当我们遍历检查类以查看是否有任何反对顺序的检查时，我们对每个检查执行相同的指令。多个检查器就是多个数据。
- en: One problem with loops is that we define the order of execution when it is not
    needed. In the case of checkers, we do not really care what order the checkers
    are executed in. All we care about is that all are okay with the order. We still
    specify some order when we program the loop. This comes from the nature of loops,
    and there is no way we could change that. That is how they work. However, it would
    be nice if we could just, somehow, say *"do this and that for each and every checker"*.
    This is one point where streams come into the picture.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的一个问题是，我们在不需要时定义了执行顺序。在棋盘游戏的情况下，我们并不关心棋子执行的顺序。我们只关心所有棋子都按照顺序执行。我们仍然在编写循环时指定了某些顺序。这是循环的本质，我们无法改变这一点。这就是它们的工作方式。然而，如果我们能够以某种方式简单地表示“对每个棋子执行这个和那个”，那将是非常好的。这是流出现的一个地方。
- en: Another point is that code that uses loops is more imperative rather than descriptive.
    When we read the program of a loop construct, we focus on the individual steps.
    We first see what the commands in the loop do. These commands work on the individual
    elements of the data and not on the whole collection or array.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点是，使用循环的代码更偏向于命令式而不是描述性。当我们阅读循环结构的程序时，我们关注的是各个步骤。我们首先看到循环中的命令做了什么。这些命令作用于数据中的单个元素，而不是整个集合或数组。
- en: Later putting the individual steps together in our brain we realize what the
    big picture is, what the loop is for. In the case of streams, the description
    of operations is a level higher. Once we learn the stream methods, it is easier
    to read them. Stream methods work on the whole stream and not on the individual
    elements, and thus are more descriptive.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的大脑中将各个步骤组合起来后，我们意识到整体图景是什么，循环的目的何在。在流的情况下，操作的描述是一个更高的层次。一旦我们学会了流方法，阅读它们就更容易了。流方法作用于整个流而不是单个元素，因此更具描述性。
- en: '`java.lang.Stream` is an interface. An object with a type implementing this
    interface represents many objects and provides methods that can be used to perform
    instructions on these objects. The objects may or may not be available when we
    start the operation on one of them, or may just be created when needed. This is
    up to the actual implementation of the `Stream` interface. For example, suppose
    we generate a stream that contains `int` values using the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Stream` 是一个接口。实现此接口的类型对象代表许多对象，并提供可以用于对这些对象执行指令的方法。当我们对其中一个对象开始操作时，这些对象可能可用，也可能不可用，或者可能仅在需要时创建。这取决于
    `Stream` 接口的实际实现。例如，假设我们使用以下代码生成包含 `int` 值的流：'
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code snippet, all the elements cannot be generated because
    the stream contains an infinite number of elements. This example will return the
    numbers 0, 1, 2, and so on until further stream operations, which are not listed
    here, terminate the calculation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，由于流包含无限数量的元素，因此无法生成所有元素。此示例将返回数字 0、1、2 等等，直到进一步的非列表流操作终止计算。
- en: When we program `Stream`, we usually create a stream from a `Collection`—not
    always, but many times. The `Collection` interface was extended in Java 8 to provide
    the `stream` and `parallelStream` methods. Both of them return stream objects
    that represent the elements of the collection. While `stream` returns the elements
    in the same order as they are in the collection in case there is a natural order,
    the `parallelStream` creates a stream that may be worked on in a parallel manner.
    In this case, if some of the methods that we use on the stream are implemented
    in that way, the code can use the multiple processors available in the computer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编程 `Stream` 时，我们通常从一个 `Collection` 创建一个流——不是总是这样，但很多时候。Java 8 中扩展了 `Collection`
    接口以提供 `stream` 和 `parallelStream` 方法。这两个方法都返回代表集合元素的流对象。当存在自然顺序时，`stream` 返回与集合中相同的顺序的元素，而
    `parallelStream` 创建一个可以并行处理的流。在这种情况下，如果我们使用的某些流方法是以这种方式实现的，代码就可以利用计算机中可用的多个处理器。
- en: As soon as we have a stream, we can use the methods that the `Stream` interface
    defines. The one to start with is `forEach`. This method has one argument, which
    is usually provided as a lambda expression and will execute the lambda expression
    for each element of the stream.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了流，我们就可以使用 `Stream` 接口定义的方法。首先开始的是 `forEach` 方法。此方法有一个参数，通常作为 lambda 表达式提供，并将对流的每个元素执行
    lambda 表达式。
- en: 'In the `Checker` class, we have the `isConsistent` method. In this method,
    there is a loop that goes through the annotations of the checker class. If we
    wanted to log the interfaces that the annotation in the loop implements, we could
    add the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Checker`类中，我们有`isConsistent`方法。在这个方法中，有一个遍历checker类注解的循环。如果我们想记录循环中注解实现的接口，我们可以添加以下内容：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, we create a stream from an array using the factory method from
    the `Arrays` class. The array contains the interfaces returned by the reflection
    method, `getInterfaces`. The lambda expression has only one parameter; thus, we
    do not need to use parentheses around it. The body of the expression is a method
    call that returns no value; thus, we also omit the `{` and `}` characters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`Arrays`类的工厂方法从一个数组创建一个流。该数组包含由反射方法`getInterfaces`返回的接口。lambda表达式只有一个参数；因此，我们不需要在它周围使用括号。表达式的主体是一个返回无值的调用；因此，我们也省略了`{`和`}`字符。
- en: Why all this hassle? What is the gain? Why couldn't we just write a simple loop
    that logs the elements of the array?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有这么多麻烦？有什么好处？为什么我们不能只写一个简单的循环来记录数组的元素？
- en: The gains are readability and maintainability. When we create a program, we
    have to focus on *what* the program should do and not on *how* it should do it.
    In an ideal world, a specification would just be executable. We may actually get
    there in the future when programming work will be replaced by artificial intelligence.
    (Not the programmers, though.) We are not there, yet. We have to tell the computers
    how to do what we want to achieve. We used to have to enter binary codes on the
    console of PDP-11 to get machine code deployed into the memory to have it executed.
    Later, we had assemblers; still later, we had FORTRAN and other high-level programming
    languages that have replaced much of the programming work as it was 40 years ago.
    All these developments in programming shift the direction from *how* towards *what*.
    Today, we program in Java 9, and the road still has miles to go.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 获益在于可读性和可维护性。当我们创建一个程序时，我们必须关注程序应该做什么，而不是它应该如何做。在一个理想的世界里，规范应该只是可执行的。我们可能在将来实现这一点，那时编程工作将由人工智能取代。（当然不是程序员。）我们还没有达到那里。我们必须告诉计算机如何完成我们想要实现的事情。我们过去不得不在PDP-11的控制台上输入二进制代码，以便将机器代码部署到内存中执行。后来，我们有了汇编器；再后来，我们有了FORTRAN和其他高级编程语言，它们取代了40年前的大部分编程工作。所有这些编程发展都使方向从“怎么做”转向了“做什么”。今天，我们使用Java
    9编程，这条路还有很长的路要走。
- en: The more we can express what to do instead of how to do, the shorter and more
    understandable our programs will be. It will contain the essence and not some
    artificial litter that is needed by the machines to just do what we want.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能更多地表达“做什么”而不是“怎么做”，我们的程序就会越短、越容易理解。它将包含本质，而不是一些机器为了仅仅完成我们想要的事情而需要的人工垃圾。
- en: When I see a loop in a code I have to maintain, I assume that there is some
    importance of the order in which the loop is executed. There may be no importance
    at all. It may be obvious after a few seconds. It may need minutes or more to
    realize that the ordering is not important. This time is wasted and can be saved
    with programming constructs that better express the *what to do* part instead
    of the *how to do*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我看到我需要维护的代码中的一个循环时，我假设循环执行的顺序很重要。可能根本不重要。几秒钟后可能就显而易见了。可能需要几分钟甚至更长时间才能意识到顺序并不重要。这种时间是浪费的，可以通过更好的表达“做什么”的编程结构来节省，而不是“怎么做”。
- en: Functional interfaces
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式接口
- en: The argument to the method should be `java.util.function.Consumer`. This is
    an interface that requires the `accept` method to be defined, and this method
    is `void`. The lambda expression or a class that implements this interface will
    *consume* the argument of the `accept` method and does not produce anything.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的参数应该是`java.util.function.Consumer`。这是一个需要定义`accept`方法的接口，该方法返回`void`。lambda表达式或实现此接口的类将“消费”`accept`方法的参数，不产生任何内容。
- en: There are several other interfaces defined in that package, each serving as
    a functional interface used to describe some method arguments that can be given
    as lambda expressions in the actual parameters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个包中定义了几个其他接口，每个接口都作为功能接口使用，用于描述可以作为实际参数给出的lambda表达式的方法参数。
- en: For example, the opposite of `Consumer` is `Supplier`. This interface has a
    method named `get` that does not need any argument but gives some `Object` as
    a return value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Consumer`的对立面是`Supplier`。这个接口有一个名为`get`的方法，它不需要任何参数，但会返回一些`Object`作为返回值。
- en: If there is an argument and also a returned value, the interface is called `Function`.
    If the returned value has to be the same type as the argument, then the `UnaryOperator`
    interface is our friend. Similarly, there is a `BinaryOperator` interface, which
    returns an object of the same type as the arguments. Just as we got from `Function`
    to `UnaryOperator`, we can see that in the other direction, there is also `BiFunction`
    in case the arguments and the return values do not share the type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个参数和一个返回值，那么这个接口就被称为`Function`。如果返回值必须与参数具有相同的类型，那么`UnaryOperator`接口就是我们的朋友。同样，还有一个`BinaryOperator`接口，它返回与参数相同类型的对象。正如我们从`Function`到`UnaryOperator`所看到的那样，在另一个方向上，如果参数和返回值不共享类型，也存在`BiFunction`。
- en: These interfaces are not defined independently of each other. If a method requires
    `Function` and we have `UnaryOperator` to pass, it should not be a problem. `UnaryOperator`
    is nothing else but `Function` that has the same type of arguments. A method that
    can work with `Function`, which accepts an object and returns an object, should
    not have a problem if they have the same type. Those can be, but need not be,
    different.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口并不是相互独立定义的。如果一个方法需要`Function`，而我们手头有`UnaryOperator`可以传递，那么这不应该是个问题。`UnaryOperator`实际上就是具有相同类型参数的`Function`。一个可以与`Function`一起工作，接受一个对象并返回一个对象的方法，如果它们具有相同的类型，那么应该不会有问题。这些可以是，但不必是，不同的。
- en: To let that happen, the `UnaryOperator` interface extends `Function` and thus
    can be used in the place of `Function`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这种情况发生，`UnaryOperator`接口扩展了`Function`，因此可以在`Function`的位置使用。
- en: The interfaces in this class we met so far are defined using generics. Because
    generic types cannot be primitives, the interfaces that operate on primitive values
    should be defined separately. `Predicate`, for example, is an interface that defines
    `booleantest(T t)`. It is a function that returns a `boolean` value and is used
    many times in stream methods.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类中遇到的接口是使用泛型定义的。因为泛型类型不能是原始类型，所以操作原始值的接口应该单独定义。例如，`Predicate`是一个定义`booleantest(T
    t)`的接口。它是一个返回`boolean`值的函数，在流方法中被多次使用。
- en: There are also interfaces, such as `BooleanSupplier`, `DoubleConsumer`, `DoubleToIntFunction`,
    and more, that work with primitive `boolean`, `double`, and `int`. The number
    of possible combinations of the different argument types and return values is
    infinite... almost.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些接口，例如`BooleanSupplier`、`DoubleConsumer`、`DoubleToIntFunction`等，它们与原始的`boolean`、`double`和`int`类型一起工作。不同参数类型和返回值的可能组合数量是无限的……几乎如此。
- en: '**Fun fact**: To be very precise, it is not infinite. A method can have at
    most 254 arguments. This limit is specified in the JVM and not in the Java language
    specification. Of course, one is useless without the other. There are 8 primitive
    types (plus `Object`, plus the possibility that there are less than 254 arguments),
    which means that the total number of possible functional interfaces is 10^(254),
    give or take, a few magnitudes. Practically, infinite!'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**有趣的事实**：非常精确地说，它并不是无限的。一个方法最多可以有254个参数。这个限制是在JVM中指定的，而不是在Java语言规范中。当然，没有一个是无用的。有8种原始类型（加上`Object`，加上可能少于254个参数的可能性），这意味着可能的函数式接口总数是10^(254)，上下几个数量级。实际上，是无限的！'
- en: We should not expect to have all the possible interfaces defined in the JDK
    in this package. These are only those interfaces that are the most useful. There
    is no interface, for example, that uses `short` or `char`. If we need anything
    like that, then we can define the `interface` in our code. Or just think hard
    and find out how to use an already defined one. (I have never used the `short`
    type during my professional carrier. It was never needed.)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该期望在这个包中定义所有可能的接口。这里只包含那些最有用的接口。例如，没有使用`short`或`char`的接口。如果我们需要类似的东西，我们可以在我们的代码中定义这个`interface`。或者，仔细思考并找出如何使用已经定义好的一个。
    （在我的职业生涯中，我从未使用过`short`类型。它从未被需要过。）
- en: How are these functional interfaces used in streams? The `Stream` interface
    defines the methods that have some functional interface types as arguments. For
    example, the `allMatch` method has a `Predicate` argument and returns a `Boolean`
    value, which is `true` if all the elements in the stream match `Predicate`. In
    other words, this method returns `true` if and only if `Predicate`, supplied as
    an argument, returns `true` for each and every element of the stream.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能接口在流中是如何使用的？`Stream`接口定义了具有某些功能接口类型作为参数的方法。例如，`allMatch`方法有一个`Predicate`参数，并返回一个`Boolean`值，如果流中的所有元素都匹配`Predicate`，则返回`true`。换句话说，此方法仅在`Predicate`作为参数返回`true`对于流中的每个元素时才返回`true`。
- en: 'In the following code, we will rewrite some of the methods that we implemented
    in our sample code using loops to use streams, and through these examples, we
    will discuss the most important methods that streams provide. We saved up two
    classes, `ProductsCheckerCollector` and `ProductInformationCollector`, to demonstrate
    the stream usage. We can start with these. `ProductsCheckerCollector` goes through
    all the products that are contained in the `Order` and collects the annotations
    that are listed in the products. Each product may contain zero, one, or many annotations.
    These are available in a list. The same annotation may be referenced multiple
    times. To avoid duplicates, we use `HashSet`, which will contain only one instance
    of the elements even if there are multiple instances in the products:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将使用流重写我们在示例代码中使用循环实现的一些方法，并通过这些示例，我们将讨论流提供的重要方法。我们保存了两个类，`ProductsCheckerCollector`和`ProductInformationCollector`，以展示流的使用。我们可以从这里开始。`ProductsCheckerCollector`遍历`Order`中包含的所有产品，并收集产品中列出的注释。每个产品可能包含零个、一个或多个注释。这些都在列表中。相同的注释可能被引用多次。为了避免重复，我们使用`HashSet`，即使产品中有多个实例，它也只包含元素的一个实例：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s see how this method looks when we recode it using streams:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们使用流重新编写此方法时，它看起来如何：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The major work of the method gets into a single, though huge, stream expression.
    We will cover the elements of the expression in the coming pages. `List` returned
    by `order.getItems` is converted calling the `stream` method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的主要工作被包含在一个单一、尽管庞大的流表达式中。我们将在接下来的几页中介绍表达式的元素。`order.getItems`返回的`List`通过调用`stream`方法进行转换：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we have already mentioned it briefly, the `stream` method is part of the
    `Collection` interface. Any class that implements the `Collection` interface will
    have this method, even those that were implemented before streams were introduced
    in Java 8\. This is because the `stream` method is implemented in the interface
    as a `default` method. This way, if we happen to implement a class implementing
    this interface, even if we do not need streams, we get it for free as an extra.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前简要提到的，`stream`方法是`Collection`接口的一部分。任何实现`Collection`接口的类都将拥有此方法，即使是在Java
    8引入流之前实现的类也是如此。这是因为`stream`方法在接口中作为`default`方法实现。这样，如果我们偶然实现了一个实现此接口的类，即使我们不需要流，我们也会免费获得它作为额外的功能。
- en: The `default` methods in Java 8 were introduced to support backward compatibility
    of interfaces. Some of the interfaces of the JDK were to be modified to support
    lambda and functional programming. One example is the `stream` method. With the
    pre-Java 8 feature set, the classes implementing some of the modified interfaces
    should have been modified. They would have been required to implement the new
    method. Such a change is not backward compatible, and Java as a language and JDK
    was paying keen attention to be backward compatible. Thus, `default` methods were
    introduced. These let a developer extend an interface and still keep it backward
    compatible, providing a default implementation for the methods, which are new.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8中的`default`方法是为了支持接口的后向兼容性。JDK的一些接口需要修改以支持lambda和函数式编程。一个例子是`stream`方法。在Java
    8之前的特性集中，实现一些修改后接口的类应该被修改。它们将需要实现新方法。这种更改不是向后兼容的，Java作为一种语言和JDK非常关注向后兼容性。因此，引入了`default`方法。这些方法允许开发者扩展接口并保持向后兼容性，为新的方法提供默认实现。
- en: Contrary to this philosophy, brand new functional interfaces of Java 8 JDK also
    have `default` methods, though, having no prior version in the JDK, they have
    nothing to be compatible with. In Java 9, interfaces were also extended and now
    they can contain not only `default` and `static` methods but also `private` methods.
    This way, interfaces became kind of equivalent to abstract classes, though there
    are no fields in an interface except constant `static` fields. This interface
    functionality open up is a much criticized feature, which just poses the programming
    style and structural issues that other languages allowing multiple class inheritance
    face. Java was avoiding this till Java 8 and Java 9.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，Java 8 JDK中的全新函数式接口也有`default`方法，尽管它们在JDK中没有先前的版本，因此没有兼容性问题。在Java 9中，接口也得到了扩展，现在它们不仅可以包含`default`和`static`方法，还可以包含`private`方法。这样，接口就变成了类似于抽象类的东西，尽管接口中没有字段，除了常量`static`字段。这种接口功能开放是一个备受批评的特性，它仅仅提出了其他允许多重类继承的语言所面临的编程风格和结构问题。Java一直避免这种情况，直到Java
    8和Java 9。
- en: What is the take-away from this? Be careful with `default` methods and also
    with `private` methods in interfaces. Use them wisely if at all.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们能学到什么？要小心使用`default`方法和接口中的`private`方法。如果确实需要使用，请明智地使用它们。
- en: The elements of this stream are `OrderItem` objects. We need `ProductInformation`
    for each `OrderItem`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流中的元素是`OrderItem`对象。我们需要为每个`OrderItem`提供`ProductInformation`。
- en: Method references
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法引用
- en: 'Lucky that we have `Map`, which pairs order items with product information, so
    we can invoke `get` on `Map`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们拥有`Map`，它将订单项与产品信息配对，因此我们可以对`Map`调用`get`方法：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `map` method is again something that has the same name as something else
    in Java and should not be confused. While the `Map` class is a data structure,
    the `map` method in the `Stream` interface performs mapping of the stream elements.
    The argument of the method is a `Function` (recall that this is a functional interface
    we recently discussed). This function converts a value, `T`, which is available
    as the element of the original stream (`Stream<T>`) to a value, `R`, and the return
    value of the `map` method is `Stream<R>`. The `map` method converts `Stream<T>`
    to `Stream<R>` using the given `Function<T,R>`, calling it for each element of
    the original stream and creating a new stream from the converted elements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法在Java中与另一个具有相同名称的元素相关联，不应混淆。虽然`Map`类是一个数据结构，但`Stream`接口中的`map`方法执行流元素的映射。该方法的一个参数是`Function`（回想一下，这是一个我们最近讨论过的函数式接口）。这个函数将一个值`T`转换为另一个值`R`，这个值作为原始流（`Stream<T>`）的元素可用，`map`方法的返回值是`Stream<R>`。`map`方法使用给定的`Function<T,R>`将`Stream<T>`转换为`Stream<R>`，为原始流的每个元素调用它，并从转换后的元素创建一个新的流。'
- en: We can say that the `Map` interface maps keys to values in a data structure
    in a static way, and the `Stream` method, `map`, maps one type of values to another
    (or the same) type of values dynamically.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，`Map`接口以静态方式在数据结构中将键映射到值，而`Stream`方法`map`则动态地将一种类型的值映射到另一种（或相同的）类型的值。
- en: 'We have already seen that we can provide an instance of a functional interface
    in the form of a lambda expression. This argument is not a lambda expression.
    This is a method reference. It says that the `map` method should invoke the `get`
    method on `Map piMap` using the actual stream element as an argument. We are lucky
    that `get` also needs one argument, aren''t we? We could also write as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以以lambda表达式的形式提供一个函数式接口的实例。这个参数不是lambda表达式。这是一个方法引用。它表示`map`方法应该使用实际的流元素作为参数，在`Map
    piMap`上调用`get`方法。我们很幸运，`get`也需要一个参数，不是吗？我们也可以这样写：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, this would have been exactly the same as `piMap::get`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将与`piMap::get`完全相同。
- en: This way, we can reference an instance method that works on a certain instance.
    In our example, the instance is the one referenced by the `piMap` variable. It
    is also possible to reference `static` methods. In this case, the name of the
    class should be written in front of the `::` characters. We will soon see an example
    of this when we will use the `static` method, `nonNull`, from the `Objects` class
    (note that the class name is in plural, and it is in the `java.util` package and
    not `java.lang`).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以引用一个在特定实例上工作的实例方法。在我们的例子中，这个实例是由`piMap`变量引用的。也可以引用`static`方法。在这种情况下，类名应写在`::`字符之前。当我们使用`Objects`类的`static`方法`nonNull`时，我们将很快看到这个例子（注意，类名是复数形式，它位于`java.util`包中，而不是`java.lang`包）。
- en: It is also possible to reference an instance method without giving the reference
    on which it should be invoked. This can be used in places where the functional
    interface method has an extra first parameter, which will be used as the instance.
    We have already used this in [Chapter 3](part0076.html), *Optimizing the Sort
    - Making Code Professional*, when we passed `String::compareTo`, when the expected
    argument was a `Comparator`. The `compareTo` method expects one argument, but
    the `compare` method in the `Comparator` interface needs two. In such a situation,
    the first argument will be used as the instance on which `compare` has to be invoked
    and the second argument is passed to `compare`. In this case, `String::compareTo`
    is the same as writing the lambda expression `(String a, String b) -> a.compareTo(b)`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能引用一个实例方法，而不给出它应该调用的引用。这可以在功能接口方法有一个额外的第一个参数的地方使用，该参数将用作实例。我们已经在[第3章](part0076.html)，“优化排序
    - 使代码专业化”中使用了这种方法，当时我们传递了`String::compareTo`，当期望的参数是一个`Comparator`时。`compareTo`方法期望一个参数，但`Comparator`接口中的`compare`方法需要两个参数。在这种情况下，第一个参数将用作`compare`必须调用的实例，第二个参数传递给`compare`。在这种情况下，`String::compareTo`与编写lambda表达式`(String
    a, String b) -> a.compareTo(b)`相同。
- en: Last but not least, we can use method references to constructors. When we need
    a `Supplier` of (let's be simple) `Object`, we can write `Object::new`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们可以使用构造函数引用。当我们需要一个（让我们简单一点）`Object`的`Supplier`时，我们可以写`Object::new`。
- en: 'The next step is to filter out the `null` elements from the stream. Note that,
    at this point, the stream has `ProductInformation` elements:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从流中过滤掉`null`元素。注意，在这个阶段，流中包含`ProductInformation`元素：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `filter` method uses `Predicate` and creates a stream that contains only
    the elements that match the predicate. In this case, we used the reference to
    a `static` method. The `filter` method does not change the type of stream. It
    only filters out the elements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法使用`Predicate`并创建一个只包含匹配谓词的元素的流。在这种情况下，我们使用了`static`方法的引用。`filter`方法不会改变流的类型。它只过滤掉元素。'
- en: The next method we apply is a bit anti-functional. Pure functional stream methods
    do not alter the state of any object. They create new objects that they return
    but, other than that, there is no side effect. `peek` itself is no different because
    it only returns a stream of the same elements as the one it is applied on. However,
    this *no-operation* feature lures the novice programmer to do something non-functional
    and write code with side-effects. After all, why use it if there is no (side)
    effect in calling it?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来应用的方法有点反函数式。纯函数式流方法不会改变任何对象的任何状态。它们创建并返回新的对象，但除此之外，没有副作用。`peek`本身也没有不同，因为它只返回一个与它应用在上的相同元素的流。然而，这个“无操作”特性诱使新手程序员做一些非函数式的事情，并编写带有副作用的代码。毕竟，如果没有（副作用）在调用它时，为什么还要使用它呢？
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'While the  `peek` method itself does not have any side effects, the execution
    of the lambda expression may have. However, this is also true for any of the other
    methods. It is just the fact that, in this case, it is more tempting to do something
    inadequate. Don''t. We are disciplined adults. As the name of the method suggests,
    we may peek into the stream but we are not supposed to do anything else. With
    programming being a particular activity, in this case, peeking, is adequate. And
    that is what we actually do in our code: we log something.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`peek`方法本身没有副作用，但lambda表达式的执行可能会有。然而，这同样适用于任何其他方法。只是在这种情况下，做一些不恰当的事情更有诱惑力。不要这样做。我们是守纪律的成年人。正如方法名所暗示的，我们可能可以窥视流，但我们不应该做其他任何事情。在这种情况下，编程是一种特定的活动，窥视是恰当的。这正是我们在代码中实际做的事情：我们记录了一些信息。
- en: 'After this, we get rid of the elements that have no `ProductInformation`; we
    also want to get rid of the elements that have, but there is no checker defined:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们去除没有`ProductInformation`的元素；我们还想去除那些有，但没有定义检查器的元素：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this case, we cannot use method references. Instead, we use a lambda expression.
    As an alternative solution, we may create a `boolean hasCheck` method in `ProductInformation`,
    which returns `true` if the `private` field check is not `null`. This would then
    read as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不能使用方法引用。相反，我们使用lambda表达式。作为另一种解决方案，我们可以在`ProductInformation`中创建一个`boolean
    hasCheck`方法，当`private`字段检查不是`null`时返回`true`。这将如下所示：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is totally valid and works, although the class does not implement any functional
    interface and has many methods, not only this one. However, the method reference
    is explicit and specifies which method to invoke.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全有效且可行，尽管该类没有实现任何函数式接口并且有很多方法，不仅仅是这个方法。然而，方法引用是明确的，并指定了要调用的方法。
- en: 'After this second filter, we log the elements again:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个过滤器之后，我们再次记录元素：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next method is `flatMap` and this is something special and not easy to
    comprehend. At least for me, it was a bit more difficult than understanding `map`
    and `filter` when I learned functional programming:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是`flatMap`，这是一个特别且不易理解的东西。至少对我来说，它比学习函数式编程时的`map`和`filter`要困难一些：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This method expects that the lambda, method reference, or whatever is passed
    to it as an argument, creates a whole new stream of objects for each element of
    the original stream the method is invoked on. The result is, however, not a stream
    of streams, which also could be possible, but rather the returned streams are
    concatenated into one huge stream.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法期望传入的lambda表达式、方法引用或其他作为参数传递的内容，为原始流中每个元素创建一个新的对象流。然而，结果并不是流中的流，尽管这也是可能的，而是返回的流被连接成一个巨大的流。
- en: If the stream we apply it to is a stream of integer numbers, such as 1, 2, 3,
    ..., and the function for each number *n* returns a stream of three elements *n*,
    *n+1*, and *n+2*, then the resulting stream, `flatMap`, produces a stream containing
    1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, and so on.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用此流的流是整数流，例如1，2，3，...，并且每个数字*n*的函数返回一个包含三个元素*n*，*n+1*和*n+2*的流，那么`flatMap`产生的流将包含1，2，3，2，3，4，3，4，5，4，5，6，等等。
- en: 'Finally, the stream we have should be collected to a `Set`. This is done by
    calling the `collector` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该将流收集到一个`Set`中。这是通过调用`collector`方法来完成的：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The argument to the `collector` method is (again a name overuse) `Collector`.
    It can be used to collect the elements of the stream into some collection. Note
    that `Collector` is *not* a functional interface. You cannot just collect something
    using a lambda or a simple method. To collect the elements, we definitely need
    some place where the elements are collected as the ever-newer elements come from
    the stream. The `Collector` interface is not simple. Fortunately, the `java.util.streams.Collectors`
    class (again note the plural) has a lot of `static` methods that create and return
    `Object` that create and return `Collector` objects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`collector`方法的参数是（再次是名称滥用）`Collector`。它可以用来收集流中的元素到某个集合中。请注意，`Collector`不是一个函数式接口。您不能仅仅使用lambda表达式或简单的方法来收集某些内容。为了收集元素，我们确实需要一个地方来收集元素，因为随着从流中来的新元素，元素会被收集。`Collector`接口并不简单。幸运的是，`java.util.streams.Collectors`类（再次注意复数形式）有很多`static`方法，这些方法创建并返回创建并返回`Collector`对象的`Object`。'
- en: One of these is `toSet`, which returns a `Collector` that helps collect the
    elements of the stream into a `Set`. The `collect` method will return the `Set`
    when all the elements are there. There are other methods that help collect the
    stream elements by summing up the elements, calculating the average, or to a `List`,
    `Collection`, or to a `Map`. Collecting elements to a `Map` is a special thing,
    since each element of a `Map` is actually a key-value pair. We will see the example
    for that when we look at `ProductInformationCollector`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是`toSet`，它返回一个`Collector`，帮助将流中的元素收集到一个`Set`中。当所有元素都到达时，`collect`方法将返回`Set`。还有其他方法可以帮助通过求和元素、计算平均值或将元素收集到`List`、`Collection`或`Map`中。将元素收集到`Map`中是一件事，因为`Map`的每个元素实际上是一个键值对。当我们查看`ProductInformationCollector`时，我们将看到这个示例。
- en: 'The `ProductInformationCollector` class code contains the `collectProductInformation`
    method, which we will use from the `Checker` class as well as from the `ProductsCheckerCollector`
    class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductInformationCollector`类代码中包含`collectProductInformation`方法，我们将从`Checker`类以及`ProductsCheckerCollector`类中使用该方法：'
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The simple trick is to store the collected value in `Map`, and if that is not
    `null`, then just return the already calculated value, which may save a lot of
    service calls in case this method is called more than once handling the same HTTP
    request.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的技巧是将收集的值存储在`Map`中，如果该值不是`null`，则只需返回已计算出的值，这可能在处理相同的HTTP请求时多次调用此方法时节省大量的服务调用。
- en: There are two ways of coding such a structure. One is checking the non-nullity
    of the `Map` and returning if the `Map` is already there. This pattern is widely
    used and has a name. This is called guarding *if*. In this case, there is more
    than one return statement in the method, which may be seen as a weakness or anti-pattern.
    On the other hand, the tabulation of the method is one tab shallower.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式来编码这样的结构。一种是通过检查`Map`的非空性，如果`Map`已经存在则返回。这种模式被广泛使用，并且有一个名字。这被称为保护`if`。在这种情况下，方法中有多于一个的返回语句，这可能会被视为一种弱点或反模式。另一方面，方法的缩进应该比之前浅一个制表符。
- en: It is a matter of taste and in case you find yourself in the middle of a debate
    about one or the other solution, just do yourself a favor and let your peer win
    on this topic and save your stamina for more important issues, for example, whether
    you should use streams or just plain old loops.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这纯粹是个人喜好问题。如果你发现自己正处于关于一个或另一个解决方案的辩论中，就请自己行个方便，让你的同伴在这件事上获胜，并为你节省精力，用于更重要的问题，例如，你是否应该使用流还是仅仅使用普通的循环。
- en: 'Now, let''s see how we can convert this solution into a functional style:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将这个解决方案转换为函数式风格：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We use a helper class, `Tuple`, which is nothing but two `Object` instances
    named `r` and `s`. We will list the code for this class later. It is very simple.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个辅助类`Tuple`，它只是两个名为`r`和`s`的`Object`实例。我们稍后会列出这个类的代码。它非常简单。
- en: In the streams expression, we first create the stream from the collection, and
    then we map the `OrderItem` elements to a stream of `OrderItem` and `productId`
    tuples. Then we map these tuples to tuples that now contain `OrderItem` and `ProductInformation`.
    These two mappings could be done in one mapping call, which would perform the
    two steps only in one. I decided to create the two to have simpler steps in each
    line in a vain hope that the resulting code will be easier to comprehend.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在流表达式，我们首先从集合中创建流，然后将`OrderItem`元素映射到`OrderItem`和`productId`元组的流。然后我们将这些元组映射到现在包含`OrderItem`和`ProductInformation`的元组。这两个映射可以在一个映射调用中完成，这将只执行这两个步骤。我决定创建两个，希望这样可以使每行的步骤更简单，从而使得生成的代码更容易理解。
- en: The filter step is also nothing new. It just filters out invalid product information
    elements. There should actually be none. It happens if the order contains an order
    ID to a non-existent product. This is checked in the next statement when we look
    at the number of collected product information elements to see that all the items
    have proper information.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤步骤也并非什么新鲜事物。它只是过滤掉无效的产品信息元素。实际上，不应该有任何。如果订单包含一个指向不存在产品的订单ID，就会发生这种情况。在下一个语句中，我们会检查收集到的产品信息元素的数量，以确保所有项目都有适当的信息。
- en: The interesting code is how we collect the elements of the stream into a `Map`.
    To do so, we again use the `collect` method and also the `Collectors` class. This
    time, the `toMap` method creates the `Collector`. This needs two `Function` resulting
    expressions. The first one should convert the element of the stream to the key
    and the second should result in the value to be used in the `Map`. Because the
    actual type of the key and the value is calculated from the result of the passed
    lambda expressions, we explicitly have to cast the fields of the tuple to the
    needed types.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的代码是如何将流元素收集到一个`Map`中。为了做到这一点，我们再次使用`collect`方法和`Collectors`类。这次，`toMap`方法创建了一个`Collector`。这需要两个`Function`结果表达式。第一个应该将流元素转换为键，第二个应该产生用于`Map`中的值。因为键和值的实际类型是从传递的lambda表达式的结果计算出来的，所以我们必须显式地将元组的字段转换为所需类型。
- en: 'Finally, the simple `Tuple` class is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，简单的`Tuple`类如下：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There are still some classes in our code that deserve to be converted to functional
    style. These are the `Checker` and `CheckerHelper` classes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，还有一些类值得转换为函数式风格。这些是`Checker`和`CheckerHelper`类。
- en: 'In the `Checker` class, we can rewrite the `isConsistent` method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Checker`类中，我们可以重写`isConsistent`方法：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since you have already learnt most of the important stream methods, there is
    hardly any new issue here. We can mention the `anyMatch` method, which will return
    `true` if there is at least one element so that the `Predicate` parameter passed
    to `anyMatch` is `true`. It may also need some accommodation so that we could
    use a stream inside another stream. It very well may be an example when a stream
    expression is overcomplicated and needs to split up into smaller pieces using
    local variables.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经学会了大多数重要的流方法，这里几乎没有什么新问题。我们可以提到`anyMatch`方法，如果至少有一个元素使得传递给`anyMatch`的`Predicate`参数为`true`，则它将返回`true`。它可能还需要一些调整，以便我们可以在另一个流中使用流。这很可能是一个流表达式过于复杂，需要使用局部变量将其拆分成更小部分的例子。
- en: 'Finally, before we leave the functional style, we rewrite the `containsOneOf`
    method in the `CheckHelper` class. This contains no new elements and will help
    you check what you have learned about `map`, `filter`, `flatMap`, and `Collector`.
    Note that this method, as we discussed, returns `true` if `order` contains at
    least one of the order IDs given as strings:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们离开函数式风格之前，我们重新编写了`CheckHelper`类中的`containsOneOf`方法。这个方法没有引入新元素，将帮助你检查关于`map`、`filter`、`flatMap`和`Collector`所学的知识。请注意，正如我们讨论的那样，如果`order`包含至少一个作为字符串给出的订单ID，则此方法返回`true`。
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We create the stream of the `OrderItem` objects, and then we map it to a stream
    of the IDs of the products contained in the stream. Then we create another stream
    for each of the IDs with the elements of the ID and one of the string IDs given
    as the argument. Then, we flatten these substreams into one stream. This stream
    will contain `order.getItems().size()` times `ids.length` elements: all possible
    pairs. We will filter out those pairs that contain the same ID twice, and finally,
    we will count the number of elements in the stream.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`OrderItem`对象的流，并将其映射到包含在该流中的产品ID的流。然后，我们为每个ID创建另一个流，包含ID的元素和作为参数给出的一个字符串ID。接着，我们将这些子流展平成一个流。这个流将包含`order.getItems().size()`乘以`ids.length`个元素：所有可能的配对。我们将过滤掉包含相同ID两次的配对，最后，我们将计算流中元素的数量。
- en: Scripting in Java 9
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9中的脚本
- en: We are almost ready with our sample program for this chapter. There is one issue,
    though it is not professional. When we have a new product that needs a new checker,
    we have to create a new release of the code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了本章的示例程序。不过有一个问题，尽管它不是专业的。当我们有一个需要新检查器的新产品时，我们必须创建代码的新版本。
- en: Programs in professional environments have releases. When the code is modified,
    bugs are fixed, or a new function is implemented, there are numerous steps that
    the organization requires before the application can go into production. These
    steps compose the release process. Some environments have lightweight release
    processes; others require rigorous and expensive checks. It is not because of
    the taste of the people in the organization, though. When the cost of a non-working
    production code is low and it does not matter if there is an outage or wrong functioning
    in the program, then the release process can be simple. This way, releases get
    out faster and cheaper. An example can be some chat program that is used for fun
    by the users. In such a situation, it may be more important to release new fancy
    features than ensuring bug-free working. On the other end of the palette, if you
    create code that controls an atomic power plant, the cost of failure can be pretty
    high. Serious testing and careful checking of all the features, even after the
    smallest change, can pay off.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业环境中，程序有发布。当代码被修改、错误被修复或实现了一个新功能时，组织在应用程序可以投入生产之前需要执行许多步骤。这些步骤构成了发布过程。一些环境有轻量级的发布流程；而另一些则需要严格且昂贵的检查。这并不是因为组织内部人员的口味。当非工作生产代码的成本很低，程序出现故障或功能错误并不重要时，发布流程可以很简单。这样，发布可以更快、更便宜地完成。例如，一些用户用于娱乐的聊天程序。在这种情况下，发布新功能可能比确保无错误运行更重要。在另一端，如果你创建的代码控制着核电站，失败的成本可能相当高。即使是微小的更改，也要进行严肃的测试和仔细检查所有功能，这可能会带来回报。
- en: In our example, simple checkers may be an area that is not likely to induce
    serious bugs. It is not impossible but the code is so simple...Yes, I know that
    such an argument is a bit fishy, but let's assume that these small routines could
    be changed with less testing and in an easier way than the other parts of the
    code. How to separate the code for these little scripts, then, so that they do
    not require a technical release, a new version of the application, and not even
    restarting the application? We have a new product that needs a new check and we
    want to have some way to inject this check into the application environment without
    any service disruption.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，简单的检查器可能是一个不太可能引起严重错误的问题领域。虽然并非不可能，但代码如此简单……是的，我知道这样的论点有点牵强，但让我们假设这些小例程可以通过比代码的其他部分更少的测试和更简单的方式进行更改。那么，如何将这些小脚本的代码分离出来，以便它们不需要技术发布、应用程序的新版本，甚至不需要重新启动应用程序？我们有一个新产品需要新的检查，我们希望有一种方法可以将这个检查注入到应用程序环境中，而不会造成任何服务中断。
- en: 'The solution we choose is scripting. Java programs can execute scripts written
    in *JavaScript*, *Groovy*, *Jython* (which is the *JVM* version of the language
    *Python*), and many other languages. Except *JavaScript*, the language interpreters
    of these languages are not a part of the JDK, but they all provide a standard
    interface, which is defined in the JDK. The consequence is that we can implement
    script execution in our code and the developers, who provide the scripts, are
    free to choose any of the available languages; we do not need to care to execute
    a *JavaScript* code. We will use the same API as to execute *Groovy* or *Jython*.
    The only thing we should know is what language the script is in. This is usually
    simple: we can guess that from the file extension, and if guessing is not enough,
    we can demand that the script developers put *JavaScript* into files with the
    `.js` extension, *Jython* into files with `.jy` or `.py`, *Groovy* into files
    with `.groovy`, and so on. It is also important to note that if we want our program
    to execute one of these languages, we should make sure that the interpreter is
    on the classpath. In the case of *JavaScript*, this is given; therefore, as a
    demonstration in this chapter, we will write our scripts in *JavaScript*. There
    will not be a lot; this is a Java book and not a *JavaScript* book after all.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的解决方案是脚本。Java程序可以执行用*JavaScript*、*Groovy*、*Jython*（这是*Python*语言的*JVM*版本）和许多其他语言编写的脚本。除了*JavaScript*之外，这些语言的解释器不是JDK的一部分，但它们都提供了一个标准接口，该接口在JDK中定义。结果是，我们可以在我们的代码中实现脚本执行，提供脚本的开发者可以自由选择任何可用的语言；我们不需要关心执行*JavaScript*代码。我们将使用与执行*Groovy*或*Jython*相同的API。我们唯一需要知道的是脚本使用的语言。这通常很简单：我们可以从文件扩展名中猜测，如果猜测不够，我们可以要求脚本开发者将*JavaScript*放入以`.js`扩展名命名的文件中，*Jython*放入以`.jy`或`.py`扩展名命名的文件中，*Groovy*放入以`.groovy`扩展名命名的文件中，依此类推。同样重要的是要注意，如果我们想让我们的程序执行这些语言之一，我们应该确保解释器在类路径上。在*JavaScript*的情况下，这是既定的；因此，在本章的演示中，我们将用*JavaScript*编写我们的脚本。不会有太多；毕竟，这是一本Java书，而不是*JavaScript*书。
- en: Scripting is usually a good choice when we want to pass the ability of programmatically
    configuring or extending our application. This is our case now.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通常是我们想要通过编程方式配置或扩展应用程序功能时的一个不错的选择。这正是我们现在的情形。
- en: 'The first thing we have to do is to extend the production information. In case
    there is a script that checks the consistency of an order that a product is in,
    we need a field where we can specify the name of the script:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是扩展生产信息。如果有脚本检查产品中订单的一致性，我们需要一个字段来指定脚本的名称：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We do not want to specify more than one script per product; therefore, we do
    not need a list of script names. We have only one script specified by the name.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望每个产品指定多个脚本；因此，我们不需要脚本名称列表。我们只指定了一个名为的脚本。
- en: To be honest, the data structure for the checker classes and the annotations,
    allowing multiple annotations per product and also per checker class, was too
    complicated. We could not avoid that, though, to have a complex enough structure
    that could demonstrate the power and capability of stream expressions. Now that
    we are over that subject, we can go on using simpler data structures focusing
    on script execution.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，检查器类和注释的数据结构太复杂了，允许每个产品以及每个检查器类有多个注释。我们虽然无法避免这一点，但需要足够复杂的结构来展示流表达式的强大功能和能力。现在我们已经过了这个主题，我们可以继续使用更简单的数据结构，专注于脚本执行。
- en: We also have to modify the `Checker` class to not only use the checker classes
    but also the scripts. We cannot throw away the checker classes because, by the
    time we realize that we better need scripts for the purpose, we already have a
    lot of checker classes and we have no financing to rewrite them to be scripts.
    Well yes, we are in a book and not in real life, but in an enterprise, that would
    be the case. That is why you should be very careful while designing solutions
    for a corporate. The structures and the solutions will be there for a long time
    and it is not easy to throw a piece of code out just because it is technically
    not the best. If it works and is already there, the business will be extremely
    reluctant to spend money on code maintenance and refactoring.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须修改`Checker`类，使其不仅使用检查器类，还使用脚本。我们不能丢弃检查器类，因为当我们意识到我们最好需要脚本时，我们已经有大量的检查器类，我们没有资金将它们重写为脚本。是的，我们是在书中，而不是现实生活中，但在企业中，情况就是这样。这就是为什么在设计企业解决方案时你应该非常小心。结构和解决方案将长期存在，而且很难仅仅因为技术上不是最好的就丢弃一段代码。如果它有效并且已经存在，业务将非常不愿意在代码维护和重构上花钱。
- en: 'Summary: we modify the `Checker` class. We need a new class that can execute
    our scripts; thus, the constructor is modified:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要：我们修改了`Checker`类。我们需要一个新的类来执行我们的脚本；因此，构造函数被修改：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We also have to use this `executor` in the `isConsistent` method`:`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`isConsistent`方法中使用这个`executor`：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that in this code, we use parallel streams because, why not? Whenever it
    is possible, we can use parallel streams, even unordered, to tell the underlying
    system and also to the programmer fellows maintaining the code that order is not
    important.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中，我们使用并行流，因为为什么不呢？只要可能，我们都可以使用并行流，即使是无序的，以告知底层系统以及维护代码的程序员同行，顺序并不重要。
- en: 'We also modify one of our product JSON files to reference a script instead
    of a checker class through some annotation:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还修改了我们产品的一个JSON文件，通过一些注释来引用脚本而不是检查器类：
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Even JSON is simpler. Note that as we decided to use JavaScript, we do not need
    to specify the file name extension when we name the script.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是JSON也更为简单。请注意，由于我们决定使用JavaScript，在命名脚本时我们不需要指定文件名扩展名。
- en: We may later consider further development when we will allow the product checker
    script maintainers to use different scripting languages. In such a case, we may
    still require that they specify the extension, and in case there is no extension,
    it will be added by our program as `.js`. In our current solution, we do not check
    that, but we may devote a few seconds to think about it to be sure that the solution
    can be further developed. It is important that we do not develop extra code for
    the sake of further development. Developers are not fortunetellers and cannot
    tell reliably what the future needs will be. That is the task of the business
    people.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能稍后考虑进一步的开发，届时我们将允许产品检查脚本维护者使用不同的脚本语言。在这种情况下，我们可能仍然要求他们指定扩展名，如果没有扩展名，我们的程序将自动添加为`.js`。在我们的当前解决方案中，我们没有检查这一点，但我们可能会花几秒钟时间思考，以确保解决方案可以进一步开发。重要的是，我们不要为了进一步开发而开发额外的代码。开发者不是算命先生，无法可靠地预测未来的需求。这是业务人员的任务。
- en: 'We put the script into the `resource` directory of our project under the `scripts`
    directory. The name of the file has to be `powered_device.js` because this is
    the name we specified in the JSON file:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将脚本放入我们项目的`scripts`目录下的`resource`目录中。文件名必须是`powered_device.js`，因为这是我们已在JSON文件中指定的名称：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is an extremely simple JavaScript program. As a side note, when you iterate
    over a list or an array in JavaScript, the loop variable will iterate over the
    indexes of the collection or the array. Since I rarely program in JavaScript,
    I fell into this trap and it took me more than half an hour to debug the error
    I made.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其简单的JavaScript程序。作为旁注，当你使用JavaScript遍历列表或数组时，循环变量将遍历集合或数组的索引。由于我很少在JavaScript中编程，我陷入了这个陷阱，调试我犯的错误花了我超过半小时的时间。
- en: We have prepared everything we need to call the script. We still have to invoke
    it. To do so, we use the JDK scripting API. First, we need a `ScriptEngineManager`.
    This manager is used to get access to the JavaScript engine. Although the JavaScript
    interpreter has been a part of the JDK since Java 7, it is still managed in an
    abstract way. It is one of the many possible interpreters that a Java program
    can use to execute script. It just happens to be there in the JDK, so we do not
    need to add the interpreter JAR to the classpath. `ScriptEngineManager` discovers
    all the interpreters that are on the classpath and registers them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了调用脚本所需的一切。我们仍然需要调用它。为此，我们使用JDK脚本API。首先，我们需要一个`ScriptEngineManager`。这个管理器用于获取访问JavaScript引擎的权限。尽管JavaScript解释器自Java
    7以来一直是JDK的一部分，但它仍然以抽象的方式管理。它是Java程序可以使用的许多可能的解释器之一，用于执行脚本。它恰好存在于JDK中，所以我们不需要将解释器JAR添加到类路径中。`ScriptEngineManager`发现类路径上的所有解释器并将它们注册。
- en: It does so using the Service Provider specification, which has been a part of
    the JDK for a long time, and by Java 9, it also got extra support in module handling.
    This requires the script interpreters to implement the `ScriptEngineFactory` interface
    and also to list the class that does it in the `META-INF/services/javax.script.ScriptEngineFactory`
    file. These files, from all the JAR files that are part of the classpath, are
    read as resources by `ScriptEngineManager`, and through this, it knows which classes
    implement script interpreters. The `ScriptEngineFactory` interface requires that
    the interpreters provide methods such as `getNames`, `getExtensions`, and `getMimeTypes`.
    The manager calls these methods to collect the information about the interpreters.
    When we ask a JavaScript interpreter, the manager will return the one created
    by the factory that said that one of its names is `JavaScript`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用服务提供者规范来实现这一点，这个规范已经很长时间是JDK的一部分，到了Java 9，它在模块处理方面也得到了额外的支持。这要求脚本解释器实现`ScriptEngineFactory`接口，并在`META-INF/services/javax.script.ScriptEngineFactory`文件中列出实现它的类。这些文件，从所有构成类路径的JAR文件中，都被`ScriptEngineManager`作为资源读取，通过这种方式，它知道哪些类实现了脚本解释器。`ScriptEngineFactory`接口要求解释器提供诸如`getNames`、`getExtensions`和`getMimeTypes`等方法。管理器调用这些方法来收集关于解释器的信息。当我们询问JavaScript解释器时，管理器将返回由工厂创建的，并声称其名称之一是`JavaScript`的解释器。
- en: To get access to the interpreters through the name, file name extension or mime-type
    is only one of the functions of `ScriptEngineManager`. The other one is to manage
    `Bindings`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称、文件名扩展名或MIME类型来访问解释器只是`ScriptEngineManager`的功能之一。另一个功能是管理`Bindings`。
- en: When we execute a script from within the Java code, we don't do it because we
    want to increase our dopamine levels. In the case of scripts, it does not happen.
    We want some results. We want to pass parameters and after the execution of the
    script, we want values back from the script that we can use in the Java code.
    This can happen in two ways. One is by passing parameters to a method or function
    implemented in the script and getting the return value from the script. This usually
    works, but it may even happen that some scripting language does not even have
    the notion of the function or method. In such a case, it is not a possibility.
    What is possible is to pass some environment to the script and read values from
    the environment after the script is executed. This environment is represented
    by `Bindings`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从Java代码内部执行脚本时，我们并不是因为我们想增加我们的多巴胺水平。在脚本的情况下，这种情况不会发生。我们想要一些结果。我们想要传递参数，并在脚本执行后，我们想要从脚本中获取我们可以用于Java代码的值。这可以通过两种方式发生。一种是通过将参数传递给脚本中实现的方法或函数，并从脚本中获取返回值。这通常有效，但甚至可能发生某些脚本语言甚至没有函数或方法的观念。在这种情况下，这不是一个可能性。可能的是，将一些环境传递给脚本，并在脚本执行后从环境中读取值。这个环境由`Bindings`表示。
- en: '`Bindings` is a map that has `String` keys and `Object` values.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bindings`是一个具有`String`键和`Object`值的映射。'
- en: 'In the case of most scripting languages, for example, in JavaScript, `Bindings`
    is connected to global variables in the script we execute. In other words, if
    we execute the following command in our Java program before invoking the script,
    then the JavaScript global variable, `globalVariable`, will reference the `myObject`
    object:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数脚本语言的情况下，例如在JavaScript中，`Bindings`与我们在执行的脚本中的全局变量连接。换句话说，如果我们在我们Java程序中在调用脚本之前执行以下命令，那么JavaScript全局变量`globalVariable`将引用`myObject`对象：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can create `Bindings` and pass it to `ScriptEngineManager` but just as well
    we can use the one that it creates automatically, and we can call the `put` method
    on the engine object directly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建`绑定`并将其传递给`ScriptEngineManager`，同样我们也可以使用它自动创建的那个，并且我们可以直接在引擎对象上调用`put`方法。
- en: There are two `Bindings` when we execute scripts. One is set on the `ScriptEngineManager`
    level. This is named global binding. There is also one managed by `ScriptEngine`
    itself. This is the local `Bindings`. From the script point of view, there is
    no difference. From the embedding side, there is some difference. In case we use
    the same `ScriptEngineManager` to create multiple `ScriptEngine` instances, then
    the global bindings are shared by them. If one gets a value, all of them see the
    same value; if one sets a value, all others will later see that changed value.
    The local binding is specific to the engine it is managed by. Since we only introduce
    Java scripting API in this book, we do not get into more details and we will not
    use `Bindings`. We are good with invoking a JavaScript function and to get the
    result from it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行脚本时，有两种`绑定`。一种是设置在`ScriptEngineManager`级别上的。这被称为全局绑定。还有一个由`ScriptEngine`本身管理的。这是局部`绑定`。从脚本的角度来看，没有区别。从嵌入的角度来看，有一些区别。如果我们使用同一个`ScriptEngineManager`来创建多个`ScriptEngine`实例，那么全局绑定将由它们共享。如果一个获取了值，所有其他实例都将看到相同的值；如果一个设置了值，所有其他实例稍后都将看到这个改变后的值。局部绑定特定于它所管理的引擎。由于我们在这本书中只介绍了Java脚本API，所以我们不会深入探讨，并且我们不会使用`绑定`。我们只需要调用JavaScript函数并从中获取结果即可。
- en: 'The class that implements the script invocation is `CheckerScriptExecutor`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 实现脚本调用的类是`CheckerScriptExecutor`：
- en: '[PRE60]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The only `public` method, `notConsistent`, gets the name of the script to execute
    and also `order`. The latter has to be passed to the script. First it gets `Reader`,
    which can read the script text, evaluates it, and finally returns the result in
    case it is `boolean` or can at least be converted to `boolean`. If any of the
    methods invoked from here that we implemented in this class is erroneous, it will
    throw an exception, but only after appropriately logging it. In such cases, the
    safe way is to refuse an order.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的`public`方法`notConsistent`获取要执行的脚本的名称以及`order`。后者必须传递给脚本。首先它获取`Reader`，可以读取脚本文本，评估它，并在结果是`boolean`或至少可以转换为`boolean`的情况下最终返回结果。如果我们在这个类中实现并调用的任何方法出现错误，它将抛出异常，但只有在适当记录之后才会这样做。在这种情况下，安全的方式是拒绝订单。
- en: Actually, this is something that the business should decide. If there is a check
    script that cannot be executed, it is clearly an erroneous situation. In this
    case, accepting an order and later handling the problems manually has certain
    costs. Refusing an order or confirmation because of some internal bug is also
    not a happy path of the order process. We have to check which approach causes
    the least damage to the company. It is certainly not the duty of the programmer.
    In our situation, we are in an easy situation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是业务应该决定的事情。如果有一个无法执行的检查脚本，这显然是一个错误的情况。在这种情况下，接受订单并在之后手动处理问题是有一定成本的。由于某些内部错误而拒绝订单或确认也不是订单流程中的愉快路径。我们必须检查哪种方法对公司的损害最小。这当然不是程序员的职责。在我们的情况下，我们处于一个简单的情况。
- en: We assume that the business representatives said that the order in such a situation
    should be refused. In real life, similar decisions are many times refused by the
    business representatives saying that it just should not happen and the IT department
    has to ensure that the program and the whole operation is totally bug free. There
    is a psychological reason for such a response, but this really leads us extremely
    far from Java programming.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设业务代表说在这种情况下应该拒绝订单。在现实生活中，类似的决策很多时候是由业务代表拒绝的，他们说这根本不应该发生，IT部门必须确保程序和整个操作完全无错误。这种反应有一个心理原因，但这确实让我们离Java编程非常远。
- en: 'Engines can execute a script passed through `Reader` or as `String`. Because
    now we have the script code in a resource file, it seems to be a better idea to
    let the engine read the resource instead of reading it to a `String`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎可以通过`Reader`或作为`String`执行传递给它的脚本。因为现在我们的脚本代码在资源文件中，似乎让引擎读取资源而不是将其读取到`String`中是一个更好的主意：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To read the script from a resource file, we use the Spring `ClassPathResource`
    class. The name of the script is prepended with the `scripts` directory and appended
    by the`.js` extension. The rest is fairly standard and nothing we have not seen
    in this book. The next method that evaluates the script is more interesting:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要从资源文件中读取脚本，我们使用Spring的`ClassPathResource`类。脚本的名称在`scripts`目录前缀，以`.js`扩展名后缀。其余部分相当标准，我们在这本书中已经见过。下一个评估脚本的方程序更有趣：
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To execute the method in the script, first of all, we need a script engine that
    is capable of handling **JavaScript**. We get the engine from the manager by its
    name. If it is not **JavaScript**, we should check that the returned `engine`
    is not `null`. In the case of **JavaScript**, the interpreter is part of the **JDK**
    and checking that the **JDK** conforms to the standard would be paranoid.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行脚本中的方法，首先我们需要一个能够处理**JavaScript**的脚本引擎。我们通过名称从管理器获取引擎。如果不是**JavaScript**，我们应该检查返回的`engine`不是`null`。在**JavaScript**的情况下，解释器是**JDK**的一部分，检查**JDK**是否符合标准可能会有些过度谨慎。
- en: If ever we want to extend this class to handle not only **JavaScript** but also
    other types of scripts, this check has to be done, and also the script engine
    should probably be requested from the manager by the file name extension, which
    we do not have access to in this `private` method. But that is future development,
    not in this book.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要扩展这个类来处理不仅**JavaScript**，还要处理其他类型的脚本，这个检查必须进行，并且脚本引擎可能需要通过文件名扩展从管理器请求，而我们在这个`private`方法中无法访问这个扩展。但这将是未来的开发，而不是这本书的内容。
- en: When we have the engine, we have to evaluate the script. This will define the
    function in the script so that we can invoke it afterwards. To invoke it, we need
    some `Invocable` object. In the case of **JavaScript**, the engine also implements
    an `Invocable` interface. Not all script engines implement this interface. Some
    scripts do not have functions or methods, and there is nothing to invoke in them.
    Again, this is something to do later, when we want to allow not only **JavaScript**
    scripting but also other types of scripting.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有引擎时，我们必须评估脚本。这将定义脚本中的函数，以便我们之后可以调用它。为了调用它，我们需要一个`Invocable`对象。在**JavaScript**的情况下，引擎也实现了`Invocable`接口。并非所有脚本引擎都实现了这个接口。有些脚本没有函数或方法，其中没有可以调用的内容。同样，这也是我们稍后要做的事情，当我们想要允许不仅**JavaScript**脚本，还要允许其他类型的脚本时。
- en: 'To invoke the function, we pass its name to the `invokeFunction` method and
    also the arguments that we want to pass on. In this case, this is the `order`.
    In the case of **JavaScript**, the integration between the two languages is fairly
    developed. As in our example, we can access the field and the methods of the Java
    objects that are passed as arguments and the returned JavaScript `true` or `false`
    value is also converted to `Boolean` magically. There are some situations when
    the access is not that simple though:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用函数，我们将它的名称传递给`invokeFunction`方法，并传递我们想要传递的参数。在这种情况下，这是`order`。在**JavaScript**的情况下，两种语言之间的集成相当成熟。正如我们的示例所示，我们可以访问作为参数传递的Java对象的字段和方法，并且返回的JavaScript
    `true`或`false`值也会神奇地转换为`Boolean`。尽管有些情况下访问并不那么简单：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The last method of the class checks that the returned value, which can be anything
    since this is a script engine, is convertible to `boolean`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 类的最后一个方法检查返回的值，由于这是一个脚本引擎，它可以是一切，确保它可以转换为`boolean`。
- en: It is important to note that the fact that some of the functionality is implemented
    in script does not guarantee that the application works seamlessly. There may
    be several issues and scripts may affect the inner working of the entire application.
    Some scripting engines provide special ways to protect the application from bad
    scripts, others do not. The fact that we do not pass but order to the script does
    not guarantee that a script cannot access other objects. Using reflection, `static`
    methods, and other techniques there can be ways to access just anything inside
    our Java program. We may be a bit easier with the testing cycle when only a script
    changes in our code base, but it does not mean that we should blindly trust any
    script.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，虽然一些功能是用脚本实现的，但这并不能保证应用程序能够无缝运行。可能会有多个问题，脚本可能会影响整个应用程序的内部工作。一些脚本引擎提供了特殊的方法来保护应用程序免受恶意脚本的影响，而其他则没有。我们不对脚本进行传递，而是进行命令，但这并不能保证脚本不能访问其他对象。使用反射、`static`方法和其他技术，我们可以在Java程序内部访问任何东西。当我们的代码库中只有脚本发生变化时，我们可能会在测试周期中更容易一些，但这并不意味着我们应该盲目地信任任何脚本。
- en: In our example, it probably would be a very bad idea to let the producers of
    the products upload scripts to our system. They may provide their check scripts,
    but these scripts have to be reviewed from the security point of view before being
    deployed into the system. If this is properly done, then scripting is an extremely
    powerful extension to the Java ecosystem, giving great flexibility to our programs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，让产品的制作者上传脚本到我们的系统可能是一个非常糟糕的主意。他们可能会提供他们的检查脚本，但这些脚本在部署到系统中之前必须从安全角度进行审查。如果这样做得当，那么脚本就是Java生态系统的一个极其强大的扩展，为我们的程序提供了极大的灵活性。
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have developed the ordering system of our enterprise application.
    Along with the development of the code, we met many new things. You learned about
    annotations and how they can be handled by reflections. Although not strongly
    related, you learned how to use lambda expressions and streams to express some
    programming constructs simpler than conventional loops. In the last part of the
    chapter, we extended the application using scripting, by invoking JavaScript functions
    from Java and also by invoking Java methods from JavaScript.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了企业应用程序的排序系统。随着代码的开发，我们遇到了许多新事物。你学习了关于注解以及它们如何通过反射来处理的知识。尽管它们之间没有很强的关联，但你学习了如何使用lambda表达式和流来表示比传统循环更简单的编程结构。在章节的最后部分，我们通过从Java调用JavaScript函数以及从JavaScript调用Java方法，使用脚本扩展了应用程序。
- en: In fact, with all this knowledge, we matured to a Java level that is needed
    for enterprise programming. The rest of the topics the book covers are for the
    aces. But you want to be one, don't you? This is why I wrote the rest of the chapters.
    Read on!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，凭借所有这些知识，我们成熟到了企业编程所需的Java水平。书中涵盖的其他主题则是为高手准备的。但你想成为其中的一员，不是吗？这就是我写下其余章节的原因。继续阅读吧！
