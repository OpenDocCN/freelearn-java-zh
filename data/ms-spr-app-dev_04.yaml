- en: Chapter 4. Jobs with Spring Batch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Spring Batch的作业
- en: Enterprise applications often have requirements for processing bulk information
    by applying complex business rules. Some applications require automated jobs to
    run and provide large chunks of data as input for further processing. Such functions
    are always time-based jobs, which don't require any user intervention. Batch processing
    is widely used in banking and insurance domains where large sets of data are processed
    at scheduled times. A **job** is a process while a **batch job** implies a set
    of processes that run to perform a task at a scheduled time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序通常需要通过应用复杂的业务规则来处理大量信息。一些应用程序需要自动运行作业并提供大量数据作为进一步处理的输入。这些功能总是基于时间的作业，不需要任何用户干预。批处理广泛应用于银行和保险领域，在那里大量数据在预定时间进行处理。一个**作业**是一个过程，而**批处理作业**意味着一组进程，它们在预定时间运行以执行任务。
- en: Introduction to Spring Batch
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Batch简介
- en: Spring Batch is itself a batch framework that is used to develop applications
    to do batch jobs. It supports batch optimization and job partitioning and is highly
    scalable, which provokes us to consider it in the development of batch applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch本身是一个用于开发批处理作业的批处理框架。它支持批处理优化和作业分区，并且具有高度可扩展性，这促使我们在批处理应用程序的开发中考虑它。
- en: Use cases for using Spring Batch
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring Batch的用例
- en: 'Let us list a few use cases where we can use Spring batch in the application:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列举一些可以在应用程序中使用Spring批处理的用例：
- en: To send bulk mails to the user at a scheduled time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在预定时间向用户发送批量邮件
- en: To read messages from the queue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从队列中读取消息
- en: To update transactions at a given time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定时间更新交易
- en: To process all the received files from the user at a given time
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定时间处理用户接收到的所有文件
- en: Goals of batch processing
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批处理处理的目标
- en: 'The batch processing key goal is to fulfill the following set of steps in order
    to complete the batch job:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理的主要目标是按顺序完成以下一系列步骤以完成批处理作业：
- en: Locating a job.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找作业。
- en: Identifying the input.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别输入。
- en: Scheduling the job.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度作业。
- en: Starting the job.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动作业。
- en: Processing the job.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理作业。
- en: Go to step 2 (for fresh input).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到第2步（获取新输入）。
- en: Architecture of a batch job
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批处理作业的架构
- en: 'Let''s depict the basic architecture of a batch processor; we can also see
    the components involved in the batch processing. From the following diagram you
    can figure out the main components of Spring Batch:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下批处理处理器的基本架构；我们还可以看到批处理处理中涉及的组件。从下图中，您可以找出Spring Batch的主要组件：
- en: '![Architecture of a batch job](img/7320OS_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![批处理作业的架构](img/7320OS_04_01.jpg)'
- en: Let's now have a look at the components individually.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐个查看组件。
- en: '`JobRepository`: This container is where we need to register our jobs or processes.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JobRepository`：这个容器是我们需要注册作业或进程的地方。'
- en: '`JobOperator`: This is the one that triggers the registered job. It also provides
    APIs for accessing the register. It is an interface.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JobOperator`：这是触发已注册作业的对象。它还提供了访问注册的API。这是一个接口。'
- en: '`Job`: It is a process or task in the `jobRepository`. This consists of one
    more step.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Job`：它是`jobRepository`中的一个进程或任务。这包括一个以上的步骤。'
- en: '`Step`: This actually contains the logic that needs to be executed. Each step
    consists of an `ItemReader`, `ItemProcessor`, and `ItemWriter` interface. First,
    the `ItemReader` interface reads one step at a time in a job and gives it to `ItemProcessor`
    which processes the job. For example, it might collect some data required. Then,
    the `ItemWriter` interface writes the data to the database or it might execute
    a transaction or log a message. There are two kinds of steps:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Step`：实际上包含需要执行的逻辑。每个步骤包括一个`ItemReader`，`ItemProcessor`和`ItemWriter`接口。首先，`ItemReader`接口一次读取一个步骤的作业并将其传递给`ItemProcessor`进行处理。例如，它可能收集一些所需的数据。然后，`ItemWriter`接口将数据写入数据库，或者执行事务或记录消息。有两种类型的步骤：'
- en: '`ChunkStyle`: A `ChunkStyle` step has exactly one `ItemReader`, one `ItemProcessor`,
    and one `ItemWriter`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChunkStyle`：`ChunkStyle`步骤具有一个`ItemReader`，一个`ItemProcessor`和一个`ItemWriter`。'
- en: '`BatchLet`: In Spring, `BatchLet` is called `TaskLetStep`. `BatchLet` is a
    custom-made step that can be used for sending bulk mails or text messages.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BatchLet`：在Spring中，`BatchLet`被称为`TaskLetStep`。`BatchLet`是一个自定义步骤，可用于发送批量邮件或短信。'
- en: Now that we know the basics of a batch, in the next section we shall see how
    to implement or use a batch.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了批处理的基础知识，在下一节中我们将看到如何实现或使用批处理。
- en: Using an enterprise batch
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用企业批处理
- en: 'We have the following two options for implementing a batch:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下两种实现批处理的选项：
- en: Using JVM and starting JVM for each job run
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JVM并为每个作业运行启动JVM
- en: Deploying a batch job management application in a J2EE container
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在J2EE容器中部署批处理作业管理应用程序
- en: JSR-352 is the standard specification available for implementing batch processing.
    The Spring framework supports this specification to a great extent. Most JEE containers,
    such as **Glassfish**, **Jboss- JMX**, and Web Sphere are bound to support the
    JSR-352 specifications. As a developer, we can choose the Spring framework and
    deploy the batch on a J2EE container.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JSR-352是可用于实现批处理的标准规范。Spring框架在很大程度上支持这个规范。大多数JEE容器，如**Glassfish**，**Jboss-
    JMX**和Web Sphere都支持JSR-352规范。作为开发人员，我们可以选择Spring框架并在J2EE容器上部署批处理。
- en: You can also use restful APIs to pool the data into and out of the batch application.
    In the next section, let's use the Spring Batch framework to create a job. We
    shall first look at the dependency.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用restful API将数据池化到批处理应用程序中并从中取出。在下一节中，让我们使用Spring Batch框架创建一个作业。我们首先来看一下依赖关系。
- en: Dependency for Spring Batch
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Batch的依赖项
- en: 'To get started with Spring Batch, we need to look at the dependencies. Assuming
    that the user is familiar with the Maven application, we can look at the following
    dependencies that need to be added to the `pom.xml` file to use Spring Batch:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Spring Batch，我们需要查看依赖关系。假设用户熟悉Maven应用程序，我们可以查看需要添加到`pom.xml`文件中以使用Spring
    Batch的以下依赖项：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Key components of Spring Batch
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Batch的关键组件
- en: You can see that the key components of Spring Batch are very similar to the
    JSR specification for batch processing in Java.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，Spring Batch的关键组件与Java中的批处理的JSR规范非常相似。
- en: '`JobRepository`: This is again a repository for jobs. But, in the Spring Batch
    framework, the core API has `JobRepository`. It provides the `create`, `update`,
    `read`, and `delete` methods for `JobLauncher`, `JobReader`, `ItemProcessor`,
    and `ItemWriter`. The class responsible for `JobRepository` in the Spring framework
    is `SimpleJobRepository`. There are two ways of storing the jobs: one in the database
    and another in memory (which will have to make use of `HashMaps`).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JobRepository`：这又是一个作业的存储库。但是，在Spring Batch框架中，核心API有`JobRepository`。它为`JobLauncher`、`JobReader`、`ItemProcessor`和`ItemWriter`提供`create`、`update`、`read`和`delete`方法。在Spring框架中负责`JobRepository`的类是`SimpleJobRepository`。有两种存储作业的方式：一种是在数据库中，另一种是在内存中（这将不得不使用`HashMaps`）。'
- en: '`SimpleJobRepositoryConstructor` looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleJobRepositoryConstructor`看起来像这样：'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`JobLauncher`: `JobLauncher` is just a simple interface used for launching
    jobs. Jobs are registered at the `jobRepository`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JobLauncher`：`JobLauncher`只是一个用于启动作业的简单接口。作业在`jobRepository`中注册。'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A `SimpleJobLauncher` class implements the `JobLauncher` interface. This class
    has a `setJobRepository` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleJobLauncher`类实现了`JobLauncher`接口。这个类有一个`setJobRepository`方法。'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`ItemReader`: It is an interface in `org.springframework.batch.item package`.
    ItemReader is used for providing data. The data can be from a database, XML, or
    from a flat file.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemReader`：它是`org.springframework.batch.item`包中的一个接口。ItemReader用于提供数据。数据可以来自数据库、XML或平面文件。'
- en: Implementation classes are expected to be stateful and will be called multiple
    times for each batch, with each call to `read()` returning a different value and
    finally returning null when all input data is exhausted. Implementation classes
    need not be thread-safe, and clients of an `ItemReader` interface need to be aware
    that this is the case.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类预计是有状态的，并且将在每个批次中被多次调用，每次调用`read()`都会返回一个不同的值，最终在所有输入数据耗尽时返回null。实现类不需要是线程安全的，`ItemReader`接口的客户端需要意识到这一点。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`ItemProcessor`: This is an interface that can be used for processing data
    and does the intermediate processing of data. Before it is given to `ItemWriter`,
    `ItemProcessor` can be used for implementing certain business logic.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemProcessor`：这是一个用于处理数据并进行中间处理的接口。在交给`ItemWriter`之前，`ItemProcessor`可以用于实现某些业务逻辑。'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Assume that an `ItemReader` interface provides a class of type `ProductBean`
    and this class needs to be converted to type `RelatedProductsBea`n before being
    written out. An `ItemProcessor` can be written to perform the conversion. In this
    very simple example, there is a class `ProductBean`, a class `RelatedProductsBean`,
    and a class `ProductBeanProcessor` that adhere to the `ItemProcessor` interface.
    The transformation is simple, but any type of transformation could be done here.
    The `RelatedProductsBean` writer will be used to write out `RelatedProductsBean`
    objects, throwing an exception if any other type is provided. Similarly, `ProductBeanProcessor`
    will throw an exception if anything but `ProductBean` is provided.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`ItemReader`接口提供了一个类型为`ProductBean`的类，这个类需要在写出之前转换为类型`RelatedProductsBean`。可以编写一个`ItemProcessor`来执行转换。在这个非常简单的例子中，有一个`ProductBean`类，一个`RelatedProductsBean`类，以及一个符合`ItemProcessor`接口的`ProductBeanProcessor`类。转换很简单，但任何类型的转换都可以在这里完成。`RelatedProductsBean`写入程序将用于写出`RelatedProductsBean`对象，如果提供了任何其他类型的对象，则会抛出异常。同样，如果提供的不是`ProductBean`，`ProductBeanProcessor`也会抛出异常。
- en: '`ProductBeanProcessor` can then be injected into a step:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductBeanProcessor`然后可以被注入到一个步骤中：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Item Writer`: This is an interface and here are its frequently used implementation
    classes.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Item Writer`：这是一个接口，这里是它经常使用的实现类。'
- en: The `write` method defines the most essential contract of the ItemWriter interface.
    It will attempt to write out the list of items passed in as long as it is open.
    As it is expected that items will be batched together into a chunk and then the
    output given, the interface accepts a list of items rather than an item by itself.
    Once the items are written out, any flushing that may be necessary can be performed
    before returning from the `write` method. For example, if writing to a Hibernate
    DAO, multiple calls to `write` can be made, one for each item.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`方法定义了`ItemWriter`接口的最基本契约。只要它是打开的，它将尝试写出传入的项目列表。由于预期项目将被批处理到一起形成一个块，然后给出输出，接口接受项目列表而不是单独的项目。一旦项目被写出，可以在从`write`方法返回之前执行任何必要的刷新。例如，如果写入到Hibernate
    DAO，可以进行多次对`write`的调用，每次对应一个项目。'
- en: The writer can then call close on the hibernate session before returning.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后写入程序可以在返回之前关闭hibernate会话。
- en: 'Here is a frequently used implementation of `ItemWriter`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ItemWriter`的一个经常使用的实现：
- en: '`FlatFileItemWriter`: This writes data to a file or stream. It uses a buffered
    writer to improve performance.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlatFileItemWriter`：这将数据写入文件或流。它使用缓冲写入程序来提高性能。'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Developing a sample batch application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个样本批处理应用
- en: Now that we have covered the basics of batch processing and the components of
    Spring Batch, let's develop a simple example in which names starting with `$$`
    are recognized as nonvegetarian food items and names starting with `##` are vegetarian.
    Names that do not start with either of these characters need to be ignored. Our
    job must generate an HTML string with the font color red for nonvegetarian recipes
    and a green font color for vegetarian recipes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了批处理的基础知识和Spring Batch的组件，让我们开发一个简单的例子，在这个例子中，以`$$`开头的名称被识别为非素食食品，以`##`开头的名称被识别为素食食品。不以这两个字符开头的名称需要被忽略。我们的作业必须生成一个HTML字符串，对于非素食食谱使用红色字体颜色，对于素食食谱使用绿色字体颜色。
- en: You need to create a Maven project named `recipeMarker` with the previously
    mentioned dependency. Also add all the Spring Framework core dependencies. We
    shall work on the `context.xml` file. We need to configure the job repository
    and job launcher.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个名为`recipeMarker`的Maven项目，并添加先前提到的依赖项。还要添加所有Spring Framework核心依赖项。我们将在`context.xml`文件上工作。我们需要配置作业存储库和作业启动器。
- en: 'Look at the `applicationContext.xml` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`applicationContext.xml`文件：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that we have used `MapJobRepositoryFactoryBean` to create a job
    repository. It's a `FactoryBean` that automates the creation of `SimpleJobRepository`
    using nonpersistent, in-memory **data access object** (**DAO**) implementations.
    This repository is only really intended for use in testing and rapid prototyping.
    In such settings, you might find that `ResourcelessTransactionManager` is useful
    (as long as your business logic does not use a relational database). It is not
    suited for use in multi-threaded jobs with splits, although it should be safe
    to use in a multi-threaded step.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们使用`MapJobRepositoryFactoryBean`来创建作业存储库。它是一个`FactoryBean`，可以使用非持久性的内存中的**数据访问对象**（**DAO**）实现自动创建`SimpleJobRepository`。该存储库实际上仅用于测试和快速原型设计。在这种设置中，您可能会发现`ResourcelessTransactionManager`很有用（只要您的业务逻辑不使用关系数据库）。它不适用于具有拆分的多线程作业，尽管在多线程步骤中使用应该是安全的。
- en: Next, we shall create implementation classes using the `ItemReader` and `ItemWriter`
    interfaces.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`ItemReader`和`ItemWriter`接口创建实现类。
- en: The following is the `ItemReader` implementation class. It reads the data in
    the overridden `read()` method which returns an object.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是`ItemReader`实现类。它在重写的`read()`方法中读取数据，该方法返回一个对象。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we have `ItemProcessor`. It applies the logic of marking the recipe list
    with red and green colors.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里我们有`ItemProcessor`。它应用了将食谱列表标记为红色和绿色的逻辑。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lastly, let's write the implementation class for reading the modified data from
    the `ItemProcessor` and write it.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们编写实现类，从`ItemProcessor`中读取修改后的数据并写入。
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the next step, we shall combine `ItemReader`, `ItemProcessor`, and `ItemWriter`
    into a job.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将`ItemReader`，`ItemProcessor`和`ItemWriter`组合成一个作业。
- en: Let us create an `itemreaderprocessorwriter.xml` file. We shall pass the list
    of recipes in the XML file. We have included the `applicationContext.xml` file.
    A commit interval has been defined to say that the writer should commit after
    it writes two elements at a time. You can also observe that the step consists
    of `reader`, `writer`, and `jobRepository`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`itemreaderprocessorwriter.xml`文件。我们将在XML文件中传递食谱列表。我们已经包含了`applicationContext.xml`文件。已定义提交间隔，以表示写入两个元素后写入器应该提交。您还可以观察到步骤包括`reader`，`writer`和`jobRepository`。
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next step is to launch the job using a command-line interface provided by
    the Spring Batch framework.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用Spring Batch框架提供的命令行界面启动作业。
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let us create a file named `itemreaderprocessorwriter.xml`. We shall pass the
    list of recipes in the XML file. We have included the `applicationContext.xml`
    file. A commit interval has been defined to say that the writer should commit
    after it writes two elements at a time. You can also observe that the step consists
    of `reader`, `writer`, and `jobRepository`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`itemreaderprocessorwriter.xml`的文件。我们将在XML文件中传递食谱列表。我们已经包含了`applicationContext.xml`文件。已定义提交间隔，以表示写入两个元素后写入器应该提交。您还可以观察到步骤包括`reader`，`writer`和`jobRepository`。
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating a sample batch application using the Tasklet interface
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tasklet接口创建示例批处理应用程序
- en: 'Let''s create another batch application that runs on the command line. This
    batch application prints the message. We have already spoken about Tasklet in
    the beginning of the chapter. A job compromises of steps and a step can be one
    of two types: chunk style step and Tasklet.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个在命令行上运行的批处理应用程序。该批处理应用程序打印消息。我们已经在本章开头讨论了Tasklet。作业由步骤组成，步骤可以是两种类型之一：块样式步骤和Tasklet。
- en: We are using the `Tasklet` interface in this example. In Spring Batch, `Tasklet`
    is an interface called to perform a single task, like to clean or set up resources
    before or after a step execution. This interface comes with a method called `executeStatus`,
    which should be overridden by the class that implements it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们使用`Tasklet`接口。在Spring Batch中，`Tasklet`是一个接口，用于执行单个任务，例如在步骤执行之前或之后清理或设置资源。该接口带有一个名为`executeStatus`的方法，应该由实现它的类重写。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the following example, `TaskLetImpl` implements the `Tasklet` interface.
    We have also used the `TaskLetStep` class for configuring the `JobRepository`
    in the configuration file. The public class `TaskletStep` extends `AbstractStep`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`TaskLetImpl`实现了`Tasklet`接口。我们还在配置文件中使用了`TaskLetStep`类来配置`JobRepository`。公共类`TaskletStep`扩展了`AbstractStep`。
- en: '`TaskletStep` is a simple implementation of executing the step as a call to
    `Tasklet`, possibly repeated, and each call is surrounded by a transaction. The
    structure is therefore that of a loop with a transaction boundary inside the loop.
    The loop is controlled by the step operations (`setStepOperations(RepeatOperations)`).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskletStep`是执行步骤的`Tasklet`的简单实现，可能是重复的，并且每次调用都被事务包围。因此，结构是一个循环，循环内有事务边界。循环由步骤操作（`setStepOperations(RepeatOperations)`）控制。'
- en: Clients can use interceptors in the step operations to intercept or listen to
    the iteration on a step-wide basis—for instance, to get a callback when the step
    is complete. Those that want callbacks at the level of an individual task can
    specify interceptors for the chunk operations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以在步骤操作中使用拦截器来拦截或监听步骤范围的迭代，例如在步骤完成时获取回调。那些希望在单个任务级别获得回调的人可以为块操作指定拦截器。
- en: 'Let''s understand the flow through the following diagram:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图表了解流程：
- en: '![Creating a sample batch application using the Tasklet interface](img/7320OS_04_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用Tasklet接口创建示例批处理应用程序](img/7320OS_04_02.jpg)'
- en: Let's create a simple Java batch application project named `Chapter4-SpringBatchCommandLine`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Chapter4-SpringBatchCommandLine`的简单Java批处理应用程序项目
- en: 'Create a Maven folder structure for `Chapter4-SpringBatchCommandLine`, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Chapter4-SpringBatchCommandLine`创建一个Maven文件夹结构，如下所示：
- en: '`src`/`main`/`java`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`/`main`/`java`'
- en: '`src`/`main`/`resources`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`/`main`/`resources`'
- en: '`src`/`pom.xml`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`/`pom.xml`'
- en: Create a package called `com.packt.example`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`com.packt.example`的包。
- en: Create a class called `TaskletImpl`. This class implements the `Tasklet` interface
    and overrides the `execute()` method.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TaskletImpl`的类。这个类实现了`Tasklet`接口并重写了`execute()`方法。
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Configure the `simpleJob.xml` file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`simpleJob.xml`文件。
- en: Place this file in the `resources` folder.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件放入`resources`文件夹中。
- en: 'You can see that we have created three instances of the `TaskletImpl` class:
    `object1`, `object2`, and `object3`.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到我们创建了`TaskletImpl`类的三个实例：`object1`，`object2`和`object3`。
- en: In each instance, we are setting the message property. We are passing the object
    instance to `TaskletStep`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个实例中，我们设置了消息属性。我们将对象实例传递给`TaskletStep`。
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Configure `jobLauncher` and `JobRepository`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`jobLauncher`和`JobRepository`。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can run the project with MVN Compile, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用MVN Compile运行项目，如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using Spring Batch to read a CSV file
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring Batch读取CSV文件
- en: Let us create another batch application that reads a CSV file from a directory
    and uses `commandlinerunner` to run the job. The output is again a CSV file that
    will be available in the `output` folder.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个批处理应用程序，从目录中读取CSV文件，并使用`commandlinerunner`运行作业。输出再次是一个CSV文件，将在`output`文件夹中可用。
- en: This example is about showing the various options of the `ItemWriter` and `ItemReader`
    implementations available in the Spring Batch framework. We have used `flatFileItemReader`
    and `flatFileItemWriter` implementations available in the Spring Framework here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是关于展示Spring Batch框架中可用的`ItemWriter`和`ItemReader`实现的各种选项。我们在这里使用了Spring Framework中可用的`flatFileItemReader`和`flatFileItemWriter`实现。
- en: We shall begin with application development and check out how these `ItemReader`
    implementation classes are used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从应用程序开发开始，看看这些`ItemReader`实现类是如何使用的。
- en: Create a Spring Java application using Maven and name it `SpringBatchCommandLine-Chapter4Example2`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Maven创建一个名为`SpringBatchCommandLine-Chapter4Example2`的Spring Java应用程序。
- en: 'Create a domain class `Employee` with two instance variables, `empId` and `name`,
    with getters and setters:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个领域类`Employee`，具有两个实例变量`empId`和`name`，以及getter和setter：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Use the `ItemWriter` interface and implement a `CustomeItemWriter` class. This
    class overrides the `write` method, which is defined in the `ItemWriter` interface.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ItemWriter`接口并实现一个`CustomeItemWriter`类。这个类重写了`ItemWriter`接口中定义的`write`方法。
- en: You will observe that the `write` method accepts `List` as input. In the `write`
    method, we are just parsing the list and typecasting the list index value to the
    `Employee` object and printing it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将观察到`write`方法接受`List`作为输入。在`write`方法中，我们只是解析列表并将列表索引值强制转换为`Employee`对象并打印它。
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a `Main` class with `public static void main()` with a `jobrun()` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`public static void main()`和`jobrun()`方法的`Main`类：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let us set the `bean id` to `JobRepository` in the `context.xml` file:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`context.xml`文件中将`bean id`设置为`JobRepository`：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Job Read files.xml` file is present in the resource folder `*/Job Read
    files.xml`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Job Read files.xml`文件位于资源文件夹`*/Job Read files.xml`中。'
- en: We have used `flatfileItemReader` and `FlatFileItemWriter`. These classes read
    the input and recreate the files in the `output` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`flatfileItemReader`和`FlatFileItemWriter`。这些类读取输入并在`output`文件夹中重新创建文件。
- en: 'Let''s look at a prototype of `FlatFileItemReader` and learn what it does in
    the application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`FlatFileItemReader`的原型，并了解它在应用程序中的作用：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Restartable `ItemReader` reads lines from input `setResource(Resource)`. A line
    is defined by `setRecordSeparatorPolicy(RecordSeparatorPolicy)` and mapped to
    an item using `setLineMapper(LineMapper)`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可重新启动的`ItemReader`从输入`setResource(Resource)`中读取行。一行由`setRecordSeparatorPolicy(RecordSeparatorPolicy)`定义，并使用`setLineMapper(LineMapper)`映射到一个项目。
- en: If an exception is thrown during line mapping, it is rethrown as `FlatFileParseException`,
    adding information about the problematic line and its line number.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在行映射期间抛出异常，则将其作为`FlatFileParseException`重新抛出，并添加有关有问题的行及其行号的信息。
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This class is an item writer that writes data to a file or stream. The writer
    also provides a restart. The location of the output file is defined by a resource
    and must represent a writable file and use buffered writer to improve performance.
    The implementation is not thread-safe.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是一个将数据写入文件或流的项目写入器。写入器还提供了重新启动。输出文件的位置由资源定义，并且必须表示可写文件，并使用缓冲写入器以提高性能。该实现不是线程安全的。
- en: 'In the file we have done the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，我们做了以下事情：
- en: We have configured the job with the name `readMultiFileJob`
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经配置了名为`readMultiFileJob`的作业
- en: We must observe that `tasklet` has a step which is configured with the `ItemReader`
    and `ItemWriter` classes
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须观察到`tasklet`有一个步骤，该步骤配置了`ItemReader`和`ItemWriter`类
- en: We have again used `tasklet`, but we have used step as a chunk reader that accepts
    `MultiResourceReader`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们再次使用了`tasklet`，但我们使用了步骤作为一个接受`MultiResourceReader`的`chunk`读取器
- en: 'To understand `MultiResourceReader`, we shall look at the prototype:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解`MultiResourceReader`，我们将看一下原型：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`MultiResourceReader` reads items from multiple resources sequentially. The
    resource list is given by `setResources(Resource[])`, and the actual reading is
    delegated to `setDelegate(ResourceAwareItemReaderItemStream)`. Input resources
    are ordered using `setComparator(Comparator)` to make sure that resource ordering
    is preserved between job runs in a restart scenario.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiResourceReader`从多个资源中顺序读取项目。资源列表由`setResources(Resource[])`给出，实际读取委托给`setDelegate(ResourceAwareItemReaderItemStream)`。输入资源使用`setComparator(Comparator)`进行排序，以确保在重新启动场景中作业运行之间保留资源排序。'
- en: Now, let's see what step of the type chunk is about. In a chunk, a reader and
    a writer are mandatory! However, the `ItemProcessor` is optional.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`chunk`类型的步骤是什么。在一个`chunk`中，读取器和写入器是必需的！但是，`ItemProcessor`是可选的。
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a few CSV files with the name `employee*.csv`, replacing the `*` with
    a different number for each file. Each file will have two values: `employeeId`
    and `name`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建几个名为`employee*.csv`的CSV文件，用不同的数字替换`*`。每个文件将有两个值：`employeeId`和`name`。
- en: 'The delimiter in the CSV file can also be configured in the XML, as shown in
    the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件中的分隔符也可以在XML中进行配置，如下所示：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The values will be mapped with a **plain old java object** (**Pojo**), `Employee.java`,
    and the output is processed. The file location is passed as input to the `MultiResourceItemReader`
    class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值将与**普通的Java对象**（**Pojo**）`Employee.java`进行映射，并且输出将被处理。文件位置作为输入传递给`MultiResourceItemReader`类。
- en: In the next section, we shall see how we can schedule a batch job in Spring.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何在Spring中安排批处理作业。
- en: Spring Batch with a Spring scheduler
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring调度程序的Spring Batch
- en: In this section, let's see how we can schedule a batch in Spring Batch framework.
    We shall see how we can configure the scheduler. This is a sample `jobproduct.xml`
    file that needs to be available in the classpath. If you are working on a Maven
    project, place it in the resource folder. You need to inject `joblauncher` with
    the intervals and method name `run()` to run the job at the scheduled time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看如何在Spring Batch框架中安排批处理。我们将看到如何配置调度程序。这是一个示例的`jobproduct.xml`文件，需要在类路径中可用。如果您正在使用Maven项目，请将其放在资源文件夹中。您需要使用间隔和方法名`run()`来注入`joblauncher`以在预定时间运行作业。
- en: To use the scheduler, we need to configure the `job-product.xml` file. This
    file is also used in the next section to configure the external scheduler with
    the scheduler details.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用调度程序，我们需要配置`job-product.xml`文件。该文件也用于在下一节中配置外部调度程序的调度程序详细信息。
- en: 'To schedule running the task every 600 second interval:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 安排每600秒间隔运行任务：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's use the `@Component` and `@Autowired` annotations with `MyJobScheduler.class`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`MyJobScheduler.class`中使用`@Component`和`@Autowired`注解。
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Configuring Spring Batch with Quartz scheduler
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Quartz调度程序配置Spring Batch
- en: The Spring Batch framework provides an option to configure an external scheduler
    into the application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch框架提供了将外部调度程序配置到应用程序中的选项。
- en: Let us integrate Quartz Scheduler with the Spring Batch application. Quartz
    is an open source Java-based scheduler. We shall make this application to read
    a file, but we shall integrate the Quartz scheduler to do the scheduling.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将Quartz调度程序集成到Spring Batch应用程序中。Quartz是一个开源的基于Java的调度程序。我们将使该应用程序读取一个文件，但我们将集成Quartz调度程序来进行调度。
- en: Create a simple Maven application with the name `SpringBatchQuartzExample`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SpringBatchQuartzExample`的简单Maven应用程序。
- en: Use the same `pom.xml` file as in the previous application.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与之前应用程序相同的`pom.xml`文件。
- en: Add the Quartz JAR file to the dependencies in the `pom.xml` file.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件的依赖项中添加Quartz JAR文件。
- en: 'Add these properties:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这些属性：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, add these dependencies:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加这些依赖项：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s create a file called `quartz-job.xml`. This should be present in the
    resource folder of the Maven project. To configure the batch to run every minute,
    use the following configuration in the code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`quartz-job.xml`的文件。这应该存在于Maven项目的资源文件夹中。要配置批处理每分钟运行一次，使用以下代码中的配置：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To integrate Spring Batch with Quartz Scheduler, use the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Spring Batch与Quartz调度程序集成，使用以下代码：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`JobQuartzLauncherDetails` is a bean that extends `QuartzJobBean`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobQuartzLauncherDetails`是一个扩展`QuartzJobBean`的bean。'
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`QuartzJobBean` is available in the package and can be found at `org.springframework.scheduling.quartz.QuartzJobBean`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuartzJobBean`位于`org.springframework.scheduling.quartz.QuartzJobBean`包中。'
- en: 'The class has setters for `JobLauncher` and `JobLocator`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该类具有`JobLauncher`和`JobLocator`的setter：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To read the `JobMapDetails` from the configuration, we have created another
    method as shown in the following code. We can see that different data types are
    handled here based on the values read from the map, and `JobParametersBuilder`
    is created.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从配置中读取`JobMapDetails`，我们创建了另一个方法，如下所示。我们可以看到，基于从地图中读取的值，这里处理了不同的数据类型，并创建了`JobParametersBuilder`。
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we know, `JobName` and `JobParamters` are required input for `JobLauncher`
    to run the job. In the preceding code snippet, we have got `JobParameters`. Next,
    we shall get `JobName` with the following code snippet using `JobExecutionContext`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，`JobName`和`JobParamters`是`JobLauncher`运行作业所需的输入。在前面的代码片段中，我们已经得到了`JobParameters`。接下来，我们将使用以下代码片段使用`JobExecutionContext`获取`JobName`：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`Product.java` is a domain class that gets mapped to the values in the `.csv`
    file.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product.java`是一个领域类，将其映射到`.csv`文件中的值。'
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The following is the code for `CustomeItemWriter`, which writes the product
    Pojo object values.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomeItemWriter`的代码如下，用于写入产品Pojo对象的值。'
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, let's create the `Main` class to load the `job-quartz.xml` file and run
    the batch job every 60 seconds to read the CSV file and write using `CustomItemWriter`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`Main`类来加载`job-quartz.xml`文件，并且每60秒运行一次批处理作业，以使用`CustomItemWriter`读取CSV文件并写入。
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The Spring Batch framework uses Quartz Scheduler to run the batch job of reading
    a file, mapping the CSV values to product Pojo, and writing it using `CustomeItemWriter`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch框架使用Quartz调度程序来运行批处理作业，读取文件，将CSV值映射到产品Pojo，并使用`CustomeItemWriter`进行写入。
- en: In the next section, let's create a batch that reads a file and updates a database.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们创建一个批处理作业，读取一个文件并更新数据库。
- en: Using Spring Batch to read a file and update a MongoDB database
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring Batch读取文件并更新MongoDB数据库
- en: In this section, let's create a batch job that reads an XML file and writes
    to a MongoDB database. Think of a scenario where we keep getting an XML file from
    a source and that this file needs to be read and updated to a database.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，让我们创建一个批处理作业，读取一个XML文件并将其写入MongoDB数据库。想象一种情况，我们不断从一个来源获取一个XML文件，并且需要将该文件读取并更新到数据库中。
- en: 'The XML file structure is as shown here:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XML文件结构如下所示：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create a Maven Java-based project. In the `com.packt.model` package, add the
    corresponding product Pojo.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于Maven的Java项目。在`com.packt.model`包中，添加相应的产品Pojo。
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Add the same dependencies as the ones shown in the previous section.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加与上一节中显示的相同的依赖项。
- en: Update the `pom.xml` file.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pom.xml`文件。
- en: 'Add the ORM and MongoDB database dependencies:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加ORM和MongoDB数据库依赖项：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a file named `mongodatabase.xml` and add the following configurations
    to it:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mongodatabase.xml`的文件，并向其中添加以下配置：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Add the following configuration to the `job-product.xml` file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下配置添加到`job-product.xml`文件中。
- en: '`StaxEventItemReader`: This is a class that reads the `products.xml` file.
    We need to provide the `rootElemenent` name to this class.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StaxEventItemReader`：这是一个读取`products.xml`文件的类。我们需要为这个类提供`rootElemenent`名称。'
- en: '`fragmentRootElementName`: This property accepts the string parameter which
    is the root element in the provided XML file.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fragmentRootElementName`：此属性接受提供的XML文件中的根元素的字符串参数。'
- en: We also need to provide the XML file name as a value to the resource property.
    The third property that needs to be passed is the `unmarshaller` reference. This
    class is available in the Spring OXM framework used for marshalling and unmarshalling
    the XML file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将XML文件名作为值提供给资源属性。需要传递的第三个属性是`unmarshaller`引用。这个类在Spring OXM框架中可用于对XML文件进行编组和取消编组。
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `XstreamMarshaller` accepts three properties to perform the unmarshalling
    process. It accepts a map with entry key and product Pojo as values, so that in
    the XML each product record is converted as a `Product` object and is stored in
    the map. The second property is again a bean created to convert the XML to POJO.
    This is named `ProductXMLConverter`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`XstreamMarshaller`接受三个属性来执行取消编组过程。它接受一个带有条目键和产品Pojo作为值的映射，以便在XML中，每个产品记录都被转换为`Product`对象并存储在映射中。第二个属性再次是一个创建的bean，用于将XML转换为POJO。这个名字叫`ProductXMLConverter`。'
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s look at the `ProductXMLConverter` class. This class implements the `converter`
    interface which is available in the `com.thoughtworks.xstream.converters.converter`
    package. The class overrides three methods defined in the interface:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ProductXMLConverter`类。这个类实现了`converter`接口，该接口位于`com.thoughtworks.xstream.converters.converter`包中。该类覆盖了接口中定义的三个方法：
- en: '`public boolean canConvert(Class type)`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean canConvert(Class type)`'
- en: '`public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext
    context)`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext
    context)`'
- en: '`public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext
    context)`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext
    context)`'
- en: Since we shall be doing unmarshalling here, we shall clearly implement the `unmarshall`
    method.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在这里执行取消编组，因此我们将清楚地实现`unmarshall`方法。
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Configure `MongoDBItemWriter` to write to the Pojo object in the MongoDB database
    in `job-product.xml`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`job-product.xml`中配置`MongoDBItemWriter`以将Pojo对象写入MongoDB数据库：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Configure the batch job in the `job-product.xml` file:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`job-product.xml`文件中配置批处理作业：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Write the `Main` class to run the batch job.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`Main`类来运行批处理作业。
- en: 'Load all the configuration files in the `Main` class:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`类中加载所有配置文件：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So, when we run the `Main` class, the job gets instantiated and will run every
    60 seconds. The job will read the XML and convert it into the Pojo `product.java`
    and will then insert it into the MongoDB database. The configurations are given
    in the MongoDB database XML file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们运行`Main`类时，作业将被实例化，并且每60秒运行一次。作业将读取XML并将其转换为Pojo `product.java`，然后将其插入到MongoDB数据库中。配置在MongoDB数据库XML文件中给出。
- en: In the next section, we shall see how we can create a multithreaded environment
    to process multiple jobs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何创建一个多线程环境来处理多个作业。
- en: Using Spring Batch with threads to partition jobs
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring Batch和线程来分区作业
- en: In a Spring batch process, a single thread processes the requests sequentially.
    If we want to execute the batch job in parallel, we go in for a multithreaded
    environment.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring批处理过程中，一个线程按顺序处理请求。如果我们想要并行执行批处理作业，我们可以选择多线程环境。
- en: Think of scenario where we are processing 1000 records in an employee table
    that is mapped with the `Employee` Pojo. We need to read 1000 records at a time
    and write to a CSV file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情景，我们正在处理与`Employee` Pojo映射的员工表中的1000条记录。我们需要一次读取1000条记录并写入CSV文件。
- en: A job is actually portioned into multiple subjobs, and a separate thread is
    assigned to process each subjob. So, if you have 1000 records to be read, this
    will take more time when done using a single thread. When we partition 1000 records
    into 100 subrecords, we can process them using 10 different threads running at
    the same time.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 作业实际上被分成多个子作业，并且分配了一个单独的线程来处理每个子作业。因此，如果您有1000条记录需要读取，使用单个线程会花费更多时间。当我们将1000条记录分成100个子记录时，我们可以使用同时运行的10个不同线程来处理它们。
- en: We can create a simple partitioner class by implementing the `Partitioner` interface.
    This partitioner will partition 1000 jobs into 100 subjobs. You will observe that
    we provided `start_range` and `end_range` variables in the partition range.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现`Partitioner`接口来创建一个简单的分区器类。这个分区器将1000个作业分成100个子作业。您将观察到我们在分区范围中提供了`start_range`和`end_range`变量。
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `ExecutionContext` object used in the `Partitioner` class works with `ItemStream`
    and acts like a wrapper around the map. We can get two kinds of execution context
    objects in Spring Batch. One execution object works at the job level and another
    works at the step level. The job level execution context is used to share data
    or information among steps.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Partitioner`类中使用的`ExecutionContext`对象与`ItemStream`一起工作，并充当映射的包装器。在Spring Batch中，我们可以获得两种类型的执行上下文对象。一个执行对象在作业级别工作，另一个在步骤级别工作。作业级别执行上下文用于在步骤之间共享数据或信息。
- en: Let's implement an `ItemProcess` class that processes the partitioned records.
    Also observe that we are using the step execution context in the following code.
    The class overrides the `process` method.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个处理分区记录的`ItemProcess`类。还要注意，我们在下面的代码中使用了步骤执行上下文。该类覆盖了`process`方法。
- en: This class is used for chunk processing the data.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类用于分块处理数据。
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's configure the `job-partioner.xml` file.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们配置`job-partioner.xml`文件。
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next, let's configure `pagingItemReader`, which acts in the same way as pagination.
    It fetches 100 records per page; this also connects with the data source using
    the JDBC information provided and executes a query to fetch a range of records,
    as specified. It will also sort the data based on the `emp_id` column.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置`pagingItemReader`，它的作用与分页相同。它每页获取100条记录；它还使用提供的JDBC信息连接到数据源，并执行查询以获取指定范围的记录。它还将根据`emp_id`列对数据进行排序。
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Let's write the `Main` class, which will load the configuration files, and then
    run the job.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写`Main`类，它将加载配置文件，然后运行作业。
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So, with the preceding configuration and classes, multiple threads get created
    to process 100 records per thread. The records are read from the database and
    are written to the CSV file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过前面的配置和类，将创建多个线程来处理每个线程的100条记录。记录从数据库中读取并写入CSV文件。
- en: In the next section, we shall use event listeners with Spring Batch.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Spring Batch的事件监听器。
- en: Intercepting a Spring Batch job with listeners
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用监听器拦截Spring Batch作业
- en: 'Spring Batch comes with listeners. They intercept the job execution to perform
    certain tasks. `StepListener` is a `super` class for the following mentioned listeners:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch带有监听器。它们拦截作业执行以执行某些任务。`StepListener`是以下提到的监听器的`super`类：
- en: '`SkipListener`: One of the most common use cases for `SkipListener` is to log
    out a skipped item so that another batch process, or even human process, can be
    used to evaluate and fix the issue leading to the skip. Because there are many
    cases in which the original transaction may be rolled back, Spring Batch makes
    two guarantees:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipListener`：`SkipListener`最常见的用例之一是记录跳过的项目，以便可以使用另一个批处理过程或甚至人工过程来评估和修复导致跳过的问题。因为有许多情况下原始事务可能被回滚，Spring
    Batch提供了两个保证：'
- en: The appropriate `skip` method (depending on when the error happened) will only
    be called once per item.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的`skip`方法（取决于错误发生的时间）每个项目只会被调用一次。
- en: The `SkipListener` will always be called just before the transaction is committed.
    This is to ensure that any transactional resources called by the listener are
    not rolled back by a failure within `ItemWriter`.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipListener`将在事务提交之前始终被调用。这是为了确保监听器调用的任何事务资源不会因`ItemWriter`内部的失败而被回滚。'
- en: '`ChunkListener`: These listeners can be configured with a step, and if the
    step is of the type chunk-styled step, this will have both `ItemReader` and `ItemWriter`.
    The listener will intimate `ItemWriter` when `ItemReader` has completed its reading
    task.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChunkListener`：这些监听器可以配置一个步骤，如果步骤是分块式步骤类型，它将同时具有`ItemReader`和`ItemWriter`。当`ItemReader`完成其读取任务时，监听器将通知`ItemWriter`。'
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`ItemWriterListener`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemWriterListener`'
- en: '`ItemReaderListener`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemReaderListener`'
- en: '`ItemProcessListener`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemProcessListener`'
- en: '`StepExecutionListener`: It represents the most generic listener for step execution.
    It allows for notification before a step is started and after it has ended, whether
    it ended normally or failed.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StepExecutionListener`：它代表步骤执行的最通用的监听器。它允许在步骤开始之前和结束之后通知，无论它是正常结束还是失败结束。'
- en: You will observe that there is listener configured for each of the `ItemReader`,
    `ItemWriter`, `ItemProcess`, and `StepExecution` interfaces and classes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到为`ItemReader`、`ItemWriter`、`ItemProcess`和`StepExecution`接口和类配置了监听器。
- en: 'Now we can have a look at how to configure listeners in the spring `batch.xml`
    file. Please have a look:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看如何在spring `batch.xml`文件中配置监听器。请看：
- en: Create classes that implement the listeners and override their methods.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实现监听器并覆盖其方法的类。
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s see the `PacktItemReaderListener` and `PacktItemWriterListner` listeners.
    The `IteamReadListener` interface comes with three methods to be implemented:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`PacktItemReaderListener`和`PacktItemWriterListner`监听器。`IteamReadListener`接口带有三个要实现的方法：
- en: '`beforeRead()`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeRead()`'
- en: '`afterRead()`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterRead()`'
- en: '`onReadError()`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onReadError()`'
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let us next look at `PackItemWriterListener`. The `ItemWriter` interface comes
    with three `abstract` methods:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来让我们看看`PackItemWriterListener`。`ItemWriter`接口带有三个`abstract`方法：
- en: '`beforeWrite`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeWrite`'
- en: '`afterWrite`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterWrite`'
- en: '`onWriteError`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onWriteError`'
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So far, we have seen how to create custom listeners and listener configuration
    in `spring-job` file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在`spring-job`文件中创建自定义监听器和监听器配置。
- en: Now, let's try to integrate this with a scenario where we are reading multiple
    files in a directory and deleting the files.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将其与读取目录中的多个文件并删除文件的情景集成。
- en: We shall again consider product Pojo, with `id` and `name` as the instance variables
    with getters and setters.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次考虑产品Pojo，带有`id`和`name`作为实例变量，并带有getter和setter。
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We need to define the Pojo in the XML as a bean.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在XML中将Pojo定义为一个bean。
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Next is the file deleting task class file. After the files are read, they need
    to be deleted from the directory.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是文件删除任务类文件。在读取文件后，需要从目录中删除它们。
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Let's look at the `FileDeletingTasklet` class. This class implements the `TaskLet`
    interface. This will delete the files as per the specified directory.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看一下`FileDeletingTasklet`类。这个类实现了`TaskLet`接口。这将根据指定的目录删除文件。
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The bean properties need to be set in the job configuration file created.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要在创建的作业配置文件中设置bean属性。
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The next task would be to read the multiple files available in the directory.
    Since there are multiple resources that need to be read, we shall use a `MultiResourceReader`
    configuration in the bean.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务将是读取目录中可用的多个文件。由于有多个需要读取的资源，我们将在bean中使用`MultiResourceReader`配置。
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `flatfileItemReader` maps the CSV values to the product Pojo. So, provide
    the following configuration to the `jobs.xml` file:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatfileItemReader`将CSV值映射到产品Pojo。因此，请在`jobs.xml`文件中提供以下配置：'
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Then, after reading the CSV values and mapping them to Pojo from different CSV
    files, we can add the `writterListener` if we need to merge into a single CSV
    file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在读取CSV值并将它们从不同的CSV文件映射到Pojo之后，如果需要合并到单个CSV文件，我们可以添加`writterListener`。
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'On running the `Main` class, all the beans configured in the XML file get instantiated
    for the batch job to run. The job does a chunk execution with `ItemReader` and
    `Writer`, as shown in the configuration of the `Main` class here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `Main` 类时，XML 文件中配置的所有 bean 都会被实例化，以便批处理作业运行。作业在这里的 `Main` 类的配置中执行了块执行，使用了
    `ItemReader` 和 `Writer`。
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this section, we have learned about listeners and configuring listeners with
    the job.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了有关监听器的知识，并配置了监听器与作业。
- en: In the next section, we shall see how we can do some unit testing on Spring
    Batch applications.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何对 Spring Batch 应用程序进行一些单元测试。
- en: Unit testing Spring Batch applications
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Batch 应用程序的单元测试
- en: 'Let''s demonstrate writing a test case for Spring Batch applications:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示为 Spring Batch 应用程序编写测试用例：
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s create a simple `Test` class called `mport static org.junit.Assert.assertEquals`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `Test` 类的简单的 `Test` 类，称为 `mport static org.junit.Assert.assertEquals`：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We have to create a file called `text-context.xml` to be available in the batch
    and configure the `JobLauncher` to be available in the XML file, and for the test
    package. In the `Test` class, use the `@Test annotation` method and call the `JobLauncher`
    to execute a step. We need to use `assertEquals` to check the status of the batch
    job against the `jobExecution` status.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建一个名为 `text-context.xml` 的文件，以便在批处理中可用，并配置 `JobLauncher` 以便在 XML 文件和测试包中可用。在
    `Test` 类中，使用 `@Test 注释` 方法并调用 `JobLauncher` 执行一个步骤。我们需要使用 `assertEquals` 来检查批处理作业的状态与
    `jobExecution` 状态是否一致。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the chapter, we learned how to create Spring-based batch applications to
    read CSV files. We have also illustrated how Spring Batch can be used to read
    XML files. The most advanced topic was to partition the jobs and run the jobs
    into separate threads. We have also integrated Spring Batch with Quartz Scheduler.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建基于 Spring 的批处理应用程序来读取 CSV 文件。我们还阐明了 Spring Batch 如何用于读取 XML 文件。最高级的主题是将作业分区并将作业运行到单独的线程中。我们还将
    Spring Batch 与 Quartz Scheduler 集成。
- en: We have demonstrated writing simple test cases using Spring Batch. We also used
    listeners to intercept a job defined to perform certain operations and have demonstrated
    certain configurations.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经演示了使用 Spring Batch 编写简单测试用例。我们还使用监听器拦截了一个定义的作业来执行某些操作，并演示了某些配置。
