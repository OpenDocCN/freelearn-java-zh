- en: A Look at Monad Transformers and Free Monad
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Monad转换器和自由Monads
- en: In [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In
    Effects*, we looked at standard effects and promised to reveal the truth about
    the concepts underlying them; we also discussed the topic of combining them. Since
    then, we have discussed algebraic structures, such as monoids and groups, functors,
    applicatives, and monads, delivering on our first promise. But the composition
    topic has remained uncovered all this time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)，“探索内置效果”中，我们研究了标准效果，并承诺揭示它们背后的概念真相；我们还讨论了组合它们的话题。从那时起，我们已经讨论了代数结构，如幺半群和群，函子，applicatives和Monads，履行了我们的第一个承诺。但组合主题一直未被揭露。
- en: In [Chapter 8](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml), *Dealing with Effects*,
    we implemented a general way to compose applicatives—which is very useful on its
    own, but can't help us with combining the standard effects of a monadic nature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml)，“处理效果”中，我们实现了一种通用方法来组合applicatives——这本身非常有用，但无法帮助我们组合具有Monadic性质的标准化效果。
- en: 'In this chapter, we will finally take on and keep our second promise by discussing
    some ways to bring different monadic effects together. We will look at the complications
    related to that and some of the solutions used in the Scala community to deal
    with these obstacles, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将最终履行我们的第二个承诺，通过讨论一些将不同的Monadic效果结合起来的方法。我们将探讨相关的复杂性以及Scala社区用来处理这些障碍的一些解决方案，包括：
- en: Monad transformers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monad转换器
- en: Monad transformer stacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monad转换器堆栈
- en: Free monads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由Monads
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你已经安装了以下内容：
- en: JDK 1.8+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+
- en: SBT 1.2+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter10)找到。
- en: Combining monads
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合Monads
- en: In [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In
    Effects*, we talked about standard effects such as `Option`, `Try`, `Either`,
    and `Future`. In [Chapter 9](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml), *Familiarizing
    Yourself with Basic Monads*, we moved on and implemented monads for all of them.
    In our examples, we demonstrated how Scala provides nice syntax for the code formulated
    in monadic terms by having for-comprehension, which is a syntactic sugar for the
    combination of `map`, `flatMap`, and possibly `filter` methods. In all our examples,
    we used for-comprehension to define a sequence of steps which constitute some
    process where the result of the previous computation is consumed by the next step.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)，“探索内置效果”中，我们讨论了标准效果，如`Option`、`Try`、`Either`和`Future`。在[第9章](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml)，“熟悉基本Monads”中，我们继续前进，并为它们都实现了Monads。在我们的例子中，我们展示了Scala如何通过for-comprehension提供良好的语法，for-comprehension是`map`、`flatMap`和可能的`filter`方法的组合的语法糖。在我们的所有例子中，我们使用for-comprehension来定义一系列步骤，这些步骤构成了某个过程，其中前一步的计算结果被下一步消耗。
- en: 'For an instance, this is the way we defined the process of fishing in terms
    of `Option` in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)，“探索内置效果”中用`Option`定义的钓鱼过程的定义方式：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With our new obtained knowledge about monads, we could make this implementation
    effect-agnostic:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对Monads的新知识，我们可以使这个实现不受效果影响：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One thing we can't do with this approach is to use the `orElse` method specific
    to `Option` to define the unhappy path for bait-acquiring.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种方法无法做到的是使用`Option`特有的`orElse`方法来定义诱饵获取的不愉快路径。
- en: 'Another simplification we''re making here is pretending that all our actions
    can be described by the same effect. In reality, this will almost definitely not
    be the case. To be more specific, obtaining the bait and waiting to hook the fish
    will probably take much longer than casting the line. Thus, we probably would
    like to represent these actions with `Future` instead of `Option`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里进行的另一个简化是假设我们所有的行为都可以用相同的效果来描述。实际上，这几乎肯定不是情况。更具体地说，获取诱饵并等待钓鱼可能比抛线要花更长的时间。因此，我们可能希望用`Future`而不是`Option`来表示这些行为：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, in generic terms, we would have the type of effect `N` instead of `M`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，用通用术语来说，我们会有`N`类型的effect而不是`M`：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But, unfortunately, this won''t compile anymore. Let''s consider a simpler
    example to understand why:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，这不再能编译了。让我们考虑一个更简单的例子来理解为什么：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The compiler ceases to accept `Future` instead of the `Option`. Let''s desugar
    our for-comprehension to see what is going on:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不再接受`Future`而不是`Option`。让我们将我们的for-comprehension去糖化，看看发生了什么：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now the problem lies on the surface—the `Option.flatMap` expects some function
    returning an `Option` as an effect (this is using the definition of `Option.flatMap[B](f:
    A => Option[B]): Option[B]` in particular, and `Monad.flatMap` in general). But
    the value we return is wrapped in `Future`, as a result of applying the `map`
    function of the `Future`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '现在问题浮出水面——`Option.flatMap`期望一个返回`Option`的函数作为效果（这特别使用了`Option.flatMap[B](f:
    A => Option[B]): Option[B]`的定义，以及一般意义上的`Monad.flatMap`）。但我们的返回值被`Future`包裹，这是应用`Future`的`map`函数的结果。'
- en: Generalising this reasoning, we can conclude that it is only possible to use
    effects of the same type in the single for-comprehension.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个推理推广，我们可以得出结论，在单个for-comprehension中，只能使用相同类型的effect。
- en: 'Because of this, it looks like we have two possibilities to combine desired
    effects:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们似乎有两种方法来组合所需的效果：
- en: Put them in separate for-comprehensions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们放入单独的for-comprehensions
- en: Lift different effects to some kind of common denominator type
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不同的effect提升到某种公共分母类型
- en: 'We can compare both approaches using our fishing example as the playground.
    The variation of separate for-comprehensions would look like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的钓鱼示例作为游乐场来比较这两种方法。单独的for-comprehensions的变化将如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This looks slightly worse than the original version but is still quite nice,
    apart from the fact that the type of the result has changed from `N[Fish]` to
    the `M[N[M[N[Fish]]]]`. In the specific cases of `Future` and `Option`, it would
    be `Option[Future[Option[Future[Fish]]]]` and there is no easy way to extract
    the result other than going through all of the layers one by one. This is not
    a very nice thing to do and we'll leave it as an exercise for the scrupulous reader.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来比原始版本略差，但除了结果类型从`N[Fish]`变为`M[N[M[N[Fish]]]]`之外，仍然相当不错。在`Future`和`Option`的具体情况下，它将是`Option[Future[Option[Future[Fish]]]]`，没有简单的方法可以提取结果，除非逐层通过。这不是一件好事，我们将把它留给谨慎的读者作为练习。
- en: 'Another option would be to abandon the generosity of our implementation and
    make it nonpolymorphic as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是放弃我们实现的慷慨，使其非多态，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Besides losing general applicability, this implementation has the obvious disadvantage
    of being much less readable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了失去通用适用性之外，这种实现显然的缺点是可读性大大降低。
- en: Let's hope that the second approach, the common denominator for the effect type,
    will bear more fruit than the first one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们希望第二种方法，即效果类型的公共分母，比第一种方法更有成效。
- en: First, we need to decide how we want to compose the two effects we currently
    have. There are two choices: `Future[Option[?]]` and `Option[Future[?]]`. Semantically,
    having an optional result at some point later feels better than optionally having
    an operation which will complete in the future, hence we will continue with the
    first alternative.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定我们想要如何组合我们目前拥有的两个effect。有两种选择：`Future[Option[?]]`和`Option[Future[?]]`。从语义上看，在某个时间点有一个可选的结果感觉比有一个将来完成的操作更合适，所以我们将继续使用第一种选择。
- en: 'With this fixed new type, the functions we have became invalid—they all now
    have the wrong type of result. Conversion to the proper type just involves juggling
    the types and we can do this on the spot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新的固定类型，我们拥有的函数现在都无效了——它们现在都有错误的结果类型。转换为正确的类型只需调整类型，我们可以在现场完成：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All we need to do is to wrap `Option` into the `Future` or `Future` into the
    `Option`, depending on the return type of the original function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是将`Option`包裹进`Future`或`Future`包裹进`Option`，具体取决于原始函数的返回类型。
- en: 'To keep everything consistent, we''ll also change the type of the argument
    and return type of the `goFishing` function in the same way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一切一致，我们也将`goFishing`函数的参数类型和返回类型以相同的方式更改：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we strive to formulate the logic itself as a for-comprehension, it is reasonable
    to try to draw it up it in terms of the `flatMap`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们努力将逻辑本身作为for-comprehension来表述，合理地尝试用`flatMap`来表述它是合理的：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As an argument to `flatMap`, we have to provide some function which takes an
    `Option[String]` and returns `Future[Option[Fish]]`. But our functions expect
    "real" input, not optional. We can''t `flatMap` over the `Option` as discussed
    before and we can''t just use `Option.map` because it will wrap our result type
    in an additional layer of optionality. What we can use is a pattern match to extract
    the value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对 `flatMap` 的一个论证，我们必须提供一个函数，该函数接受一个 `Option[String]` 并返回 `Future[Option[Fish]]`。但我们的函数期望“真实”的输入，而不是可选的。我们不能像之前讨论的那样在
    `Option` 上使用 `flatMap`，也不能简单地使用 `Option.map`，因为它将我们的结果类型包裹在额外的可选性层中。我们可以使用模式匹配来提取值：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the case of `None`, we just shortcut the process and return the result.
    In that case, we indeed have a `name`; we can call a corresponding function, passing
    this `name` as an argument. The question is, how do we proceed further? If we
    look carefully at the return type of `buyBaitFO(name)`, we will see that this
    is the same as we had for the initial argument—`Future[Option[?]]`. Hence, we
    can try to reuse the approach with flatmapping and pattern matching again, which after
    all its iterations gives us the following implementation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `None` 的情况下，我们只需简化流程并返回结果。在这种情况下，我们确实有一个 `name`；我们可以调用一个相应的函数，并将这个 `name`
    作为参数传递。问题是，我们如何进一步操作？如果我们仔细观察 `buyBaitFO(name)` 的返回类型，我们会看到它与初始参数相同——`Future[Option[?]]`。因此，我们可以尝试再次使用
    flatmapping 和模式匹配的方法，经过多次迭代后给出以下实现：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is a lot of duplication in this snippet, but it already looks somehow
    structured. It is possible to improve its readability by extracting the repetitive
    code fragments. First, we can make the case of *no result* polymorphic as shown
    below:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段中有许多重复，但它看起来已经有些结构了。通过提取重复的代码片段，我们可以提高其可读性。首先，我们可以将 *无结果* 的情况做成多态，如下所示：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Second, we might capture our reasoning about `flatMap` and pattern match as
    a standalone polymorphic function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可能将关于 `flatMap` 和模式匹配的推理作为一个独立的、多态的函数捕捉：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With these changes, our last attempt starts to look more concise:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些修改，我们最后的尝试开始看起来更加简洁：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is arguably something that is already quite good, and we could stop at
    this moment, but there is one aspect we might improve further on. The `continue`
    function calls are nested. This makes it nontrivial to formulate the business
    logic flow. It might be beneficial if we could have a kind of fluent interface
    instead and we would be able to chain the `continue` calls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以说是相当好的，我们可以在这一刻停止，但还有一个方面我们可以进一步改进。`continue` 函数调用是嵌套的。这使得业务逻辑流程的制定变得复杂。如果我们能够有一种流畅的接口，并且能够链式调用
    `continue` 调用，可能会更有益：
- en: 'It is easily achieved by capturing the first argument of `continue` as a value
    of some class. This will change our implementation to the following form:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易通过将 `continue` 的第一个参数捕捉为某个类的值来实现。这将改变我们的实现形式如下：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are two ways to improve this further. First, the signature of `continue`
    reveals that it is a Kleisli arrow, which we introduced in the previous chapter.
    Second, in this form, we will need to wrap the `value` in `FutureOption` manually
    each time we need to call the `continue` method. This will make the code unnecessarily
    verbose and we can enhance our implementation by making it an `implicit` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以进一步改进。首先，`continue` 的签名表明它是一个 Kleisli 箭头，这是我们之前章节中介绍的。其次，以这种形式，每次我们需要调用
    `continue` 方法时，都需要手动将 `value` 包装在 `FutureOption` 中。这将使代码变得冗长，我们可以通过将其作为一个 `implicit`
    类来增强我们的实现：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take a look at what our main flow looks like with these changes incorporated:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在引入这些更改后，我们的主要流程看起来像什么：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Wonderful! Can you spot further possibility for improvement? If we scrutinise
    the type signature of the `FutureOption`, we''ll see that everything we''re doing
    with the wrapped `value` is calling a `flatMap` method which is defined on `Future`.
    But we already know the proper abstraction for that—this is a monad. Utilizing
    this knowledge will allow us to make our class polymorphic and possibly reuse
    it for other types of effects, if needed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你能发现进一步改进的可能性吗？如果我们仔细审查 `FutureOption` 的类型签名，我们会看到我们对包裹的 `value` 所做的一切都是调用在
    `Future` 上定义的 `flatMap` 方法。但我们已经知道适当的抽象——这是一个 monad。利用这一知识将允许我们使我们的类多态，并在需要的情况下可能将其用于其他类型的效应：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To demonstrate that the polymorphic nature of the new implementation won't harm
    our flexibility to define helper functions as needed, we've also added a method
    to check that the composition of monads we have is empty.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明新实现的多态性质不会损害我们根据需要定义辅助函数的灵活性，我们还添加了一个方法来检查我们拥有的monad组合是否为空。
- en: Unfortunately, if we'll try to make this implementation polymorphic in the type
    of the second effect, we'll see that it is impossible—we need to decompose it
    as explained previously, and for this we need to know the specifics of the effect's
    implementation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们尝试使这种实现对第二个效果的类型多态，我们会发现这是不可能的——我们需要像之前解释的那样将其分解，为此我们需要了解效果实现的细节。
- en: 'At this point, an astute reader will remember that all monads we developed
    in the previous chapter were implemented in terms of `compose` function, which
    had the same signature. Could we try to do the same trick again and implement
    a monad for the `FutureOption` type? Readers familiar with the previous chapter
    will know that this is almost a mechanical task of delegating to the implementation
    we just came up with:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，一个敏锐的读者会记得，我们在上一章中开发的所有的monad都是基于具有相同签名的`compose`函数实现的。我们能再次尝试同样的技巧，为`FutureOption`类型实现一个monad吗？熟悉上一章的读者会知道，这几乎是一个机械的任务，即委托给我们刚刚提出的实现：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we also need to change the return type of the original functions to be
    a `FOption[Future, ?]` to match the type signature of our new monad. We don''t
    need to touch the implementation—the compiler will wrap `implicit FOption` around
    the result automatically:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要将原始函数的返回类型更改为`FOption[Future, ?]`，以匹配我们新monad的类型签名。我们不需要接触实现——编译器会自动将`implicit
    FOption`包装在结果周围：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can formulate our logic once again, this time in terms of for-comprehension:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次可以制定我们的逻辑，这次是使用for-comprehension：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, this is nice and clean! The final touch would be to do something with
    the adhoc name of `FOption`. What the type does is *transform* an `Option` into
    something monadic of higher order, by wrapping an `Option` into a monadic effect
    of our choice. We could rename it into `OptionTransformer` or `OptionT` for short.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这既简洁又清晰！最后的润色将是处理`FOption`这个临时的名称。这个类型的作用是将`Option`转换成我们选择的更高阶的monadic效果，通过将一个`Option`包装成我们选择的monadic效果。我们可以将其重命名为`OptionTransformer`或简称`OptionT`。
- en: Congratulations! We just implemented a monad transformer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们刚刚实现了一个monad转换器。
- en: Monad transformers
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monad转换器
- en: Let's hold on for a second and recap what we just did.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍作停顿，回顾一下我们刚才做了什么。
- en: We made a small sacrifice and increased the complexity of the return type of
    our original functions to some "common denominator" type. This sacrifice is rather
    small because in our example, as well as in real life, this is usually done by
    just lifting the original functions into their proper context.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出了一些小的牺牲，增加了我们原始函数返回类型的复杂性，使其成为某种“公因数”类型。这种牺牲相当小，因为在我们的示例以及现实生活中，这通常只是通过将原始函数提升到它们适当的环境中来实现。
- en: 'The signatures we came up with look a little awkward, but this is partly because
    we started to develop them as concrete implementations. In fact, the user-facing
    API of our fishing component should be similar to the following snippet straight
    from the beginning, if implemented in a more abstract way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出的签名看起来有点尴尬，但这部分是因为我们开始将它们作为具体的实现来开发。实际上，如果我们以更抽象的方式实现，我们的钓鱼组件的用户界面API从一开始就应该类似于以下片段：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This approach abstracts over the type of effect, giving more flexibility to
    us as library authors and more structure to the user of our API.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法抽象化了效果类型，为我们作为库作者提供了更多的灵活性，并为API的用户提供了更多的结构。
- en: 'This API can be used with any effect with a monad. This is an example of how
    it can be implemented utilizing functions we currently have—returning mixed `Future`
    and `Optional` results:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API可以与任何monad一起使用。这是一个示例，说明我们可以如何利用我们目前拥有的函数来实现它——返回混合的`Future`和`Optional`结果：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Exactly as before, we implemented facades for our original functions, doing
    nothing more than routine lifting of them into the appropriate effect. And the
    `goFishing` method can be used as is—the compiler takes only a monad for the `OptoinT[Future]`
    available to make it happen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前一样，我们为原始函数实现了门面，所做的只是将它们提升到适当的效果中。而`goFishing`方法可以像以前一样使用——编译器只需要一个monad来使它发生，即`OptoinT[Future]`可用的monad：
- en: 'For instance, at some point the implementor of the underlying functions can
    decide that they should return `Try` instead of the future now. This is OK because
    requirements change and we can incorporate this change in our logic quite easily:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在某个时候，底层函数的实现者可以决定它们应该返回 `Try` 而不是现在的 future。这是可以的，因为要求会变化，我们可以在我们的逻辑中相当容易地纳入这个变化：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Assuming that the change in the library is given, the only things we need to
    alter on our side are:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设库中的变化是既定的，我们这边唯一需要改变的是：
- en: The lifting approach for the `castLine` function; it changes from `Future.success`
    to `Try.apply`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`castLine` 函数的提升方法；它从 `Future.success` 变为 `Try.apply`'
- en: The type parameter we're passing over for the wrapper for the initial argument
    of the `goFishing` function
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们传递给 `goFishing` 函数初始参数包装器的类型参数
- en: And we're done. We don't need to touch our fishing "business" logic at all!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。我们根本不需要触及我们的钓鱼“业务”逻辑！
- en: The monad transformer in a sense "flattens" both monads, such that it is possible
    to cut through all layers at once when calling the `map` and `flatMap` methods—and
    thus also in for-comprehension.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，monad transformer “扁平化”了两个 monad，这样在调用 `map` 和 `flatMap` 方法时就可以一次性穿透所有层——因此也在
    for-comprehension 中。
- en: 'Currently, it is not possible to change the type of the "inner" effect though—
    we only have an `OptionT` monad transformer available. But this is just a matter
    of implementing another transformer once, entirely like we did with monads. To
    be more specific, let''s see the effect of altering the return type of the basic
    functions to `Either` instead of `Option`. Supposing it is expected that the new
    version uses `String` as a description of the unhappy case; we would have the
    following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们无法更改“内部”效果的类型——我们只有可用的 `OptionT` monad transformer。但这只是实施另一个 transformer
    一次的问题，就像我们处理 monads 一样。更具体地说，让我们看看将基本函数的返回类型从 `Option` 更改为 `Either` 的效果。假设新版本期望使用
    `String` 作为不愉快情况的描述；我们会有以下代码：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The return type of `castLineImpl` is now `Either[String, Line]` as new requirements
    dictate. The lifting we are doing is slightly convoluted, just because we need
    to convey the types of both the left and right side of `Either` to the compiler.
    The rest of the implementation is the same as before.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`castLineImpl` 的返回类型现在是 `Either[String, Line]`，因为新的要求规定。我们正在进行的提升稍微复杂一些，因为我们需要将
    `Either` 的左右两侧的类型传达给编译器。其余的实现与之前相同。'
- en: 'And it relies on the fact that we have an instance of `EitherT` and a corresponding
    monad available. We already know how to implement monad transformers and can come
    up with the code in no time. First, the `EitherT` class, which resembles an `OptionT`
    almost identically, with respect to the need to carry the type of the left side
    of `Either` around as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于我们有一个 `EitherT` 的实例和相应的 monad。我们已经知道如何实现 monad transformer，并且可以立即想出代码。首先，`EitherT`
    类，与 `OptionT` 几乎完全相同，需要携带 `Either` 左侧的类型如下：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Instead of pattern matching on `None` and `Some`, we pattern-match on the `Left`
    and `Right` sides of `Either`. We also replace the helper method `isEmpty` with
    the more suitable `isRight`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再在 `None` 和 `Some` 上进行模式匹配，而是在 `Either` 的 `Left` 和 `Right` 两侧进行模式匹配。我们还用更合适的
    `isRight` 替换了辅助方法 `isEmpty`。
- en: 'The lifting function and the implementation of the monad are also considerably
    similar—just boilerplate, if you will:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提升函数和 monad 的实现也有相当大的相似性——如果你愿意，就是一些样板代码：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Incredible! We now have two monad transformers in our toolbox and the previously
    broken definition of `Ch10EitherTFutureFishing` has started to compile and run!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在有两个 monad transformer 在我们的工具箱中，之前损坏的 `Ch10EitherTFutureFishing` 定义已经开始编译和运行了！
- en: Eager to implement `TryT` to cement this newly gained knowledge? We're happy
    to leave this as an exercise for you.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 急切地想要实现 `TryT` 来巩固新获得的知识？我们很高兴把这个练习留给你。
- en: Monad transformers stacks
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: monad transformer 堆栈
- en: 'In the meantime, we''ll entertain ourselves with the following ideas:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们将用以下想法自娱自乐：
- en: Monad transformers require an instance of a monad for the outer layer
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monad transformers 需要一个 monad 的实例作为外层
- en: A monad transformer itself has a monad
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monad transformer 本身有一个 monad
- en: Will something bad happen if we use a monad transformer as an instance of a
    monad for another monad transformer?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将 monad transformer 作为另一个 monad transformer 的 monad 实例使用，会发生什么不好的事情吗？
- en: 'Let''s try it out. We''ve already implemented two monad transformers so let''s
    bring them together. To start, we''ll define the type of stack. It will be `EitherT`
    wrapped in `OptionT`. This will give us an unwrapped type of the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。我们已经实现了两个单子转换器，所以让我们将它们放在一起。首先，我们将定义堆栈的类型。它将是`EitherT`包裹在`OptionT`中。这将给我们以下代码的未包装类型：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This can be interpreted as an operation which takes time and might return an
    error in the case of nontechnical failure and needs to have an explanation (technical
    failures are denoted by failed `Futures`). An `Option` represents an operation
    which can return no result in a natural way that requires no further explanation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以解释为一个耗时操作，可能会在非技术故障的情况下返回错误，并且需要有一个解释（技术故障由失败的`Futures`表示）。`Option`表示一个可以以自然方式返回无结果的操作，无需进一步解释。
- en: 'With type aliases, we can represent the type of the inner transformer, fixing
    `String` as the type of the left side, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型别名，我们可以表示内部转换器的类型，将`String`固定为左侧的类型，如下所示：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The outer transformer in the stack is even simpler. In contrast to the inner
    type, where we fixed the type of effect to be `Future`, it takes a type constructor
    for an effect as the type parameter, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈中的外层转换器甚至更简单。与内部类型不同，我们固定了效果类型为`Future`，它将一个效果类型构造函数作为类型参数，如下所示：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now use these aliases to define the whole stack as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些别名来定义整个堆栈，如下所示：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make the situation realistic, we''ll just take the last version of our original
    fishing functions—the one with `castLineImpl` returns `Either[String, Line]`.
    We need to decorate all original functions so that the result type matches the
    type of the stack we now have. This is where it starts to become unwieldy. The
    compiler is not allowed to apply two implicit conversions in a row, so therefore
    we have to apply one of them by hand. For the two functions returning `Future[?]`,
    we also need to envelop the bottom layer into the `Option`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使情况更现实，我们将只取我们原始钓鱼函数的最后一个版本——即`castLineImpl`返回`Either[String, Line]`的那个版本。我们需要装饰所有原始函数，以便结果类型与我们现在拥有的堆栈类型相匹配。这就是事情开始变得难以控制的地方。编译器不允许连续应用两次隐式转换，因此我们必须手动应用其中之一。对于返回`Future[?]`的两个函数，我们还需要将底层包裹进`Option`中：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now the compiler will be able to apply implicit conversion to the `OptionT`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器将能够对`OptionT`应用隐式转换。
- en: 'Likewise, the function returning `Either[String, Line]` needs to be converted
    to `EitherT` on the outer side as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，返回`Either[String, Line]`的函数需要在外部转换为`EitherT`，如下所示：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Internally, we have to `map` the contents of `Either` into an `Option` and apply
    `Future` to the whole result.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，我们必须将`Either`的内容`map`到一个`Option`中，并将`Future`应用于整个结果。
- en: 'The compiler can help us to create an input of the proper type by applying
    implicit conversions as required—we won''t see a lot of changes on this side,
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以帮助我们通过应用所需的隐式转换来创建适当类型的输入——在这边我们不会看到很多变化，如下所示：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A small tweak is needed at the moment as we''re calling our business logic
    with this transformer stack—now we have two layers of transformation, so we need
    to call `value` two times to extract the result, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们需要进行一个小调整，因为我们正在使用这个转换器堆栈调用我们的业务逻辑——现在我们有两层转换，所以我们需要调用`value`两次来提取结果，如下所示：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It can become tedious quite quickly to turn to the `value` method repeatedly
    on each of the monad transformers that constitute the stack. Why do we need to?
    Because returning the result with the type of specific transformer can pollute
    the client''s code quite quickly. Hence, there are usually a couple of suggestions
    related to the monad transformers and monad transformer stacks worth considering,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个构成堆栈的单子转换器上反复转向`value`方法可能会很快变得令人厌烦。我们为什么需要这样做呢？因为用特定转换器的类型返回结果可能会很快污染客户端代码。因此，通常有一些关于单子和单子转换器堆栈的建议值得考虑，如下所示：
- en: Stacking monads and especially monad transformers adds performance and garbage
    collection overhead. It is essential to carefully consider the necessity of adding
    every additional layer of effects to the existing type.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆叠单子和特别是单子转换器会增加性能和垃圾收集开销。仔细考虑向现有类型添加每个额外效果层的必要性是至关重要的。
- en: It is also arguable that more layers in the stack add mental overhead and clutter
    the code. The approach is the same as with the first suggestion—don't do this
    unless absolutely needed.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也有争议说，堆栈中更多的层会增加心理负担并使代码杂乱。这种方法与第一个建议相同——除非绝对需要，否则不要这样做。
- en: Clients usually do not operate in terms of monad transformers, therefore they
    (transformers) should be considered to be an implementation detail. The API should
    be defined in generic terms. If it needs to be specific, prefer effect types over
    transformer types. In our example, it is better to return the result of the type
    `Future[Option[?]]` compared to `OptionT[Future, ?]`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户通常不根据单调转换器操作，因此它们（转换器）应被视为实现细节。API 应以通用术语定义。如果需要具体化，则优先考虑效果类型而不是转换器类型。在我们的例子中，返回类型
    `Future[Option[?]]` 比返回 `OptionT[Future, ?]` 更好。
- en: Given all these considerations, are monad transformers really useful in real
    life? Surely they are! Nevertheless, as always there are alternatives, for example
    the free monad.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些因素，单调转换器在现实生活中真的有用吗？当然有！然而，就像往常一样，总有一些替代方案，例如自由单调。
- en: Free monads
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自由单调
- en: In this chapter and the previous chapters, we represented sequenced computations
    with monads. The `flatMap` method of the monad describes how the computation steps
    should be joined and the function given to it as an argument—the computation step
    itself. The free monad elevates the concept of sequenced computations to the next
    level.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和前几章中，我们使用单调表示了顺序计算。单调的 `flatMap` 方法描述了计算步骤应该如何连接，以及作为参数给出的函数——计算步骤本身。自由单调将顺序计算的概念提升到下一个层次。
- en: First, we start to represent the computation steps as instances of some **ADT**
    (**algebraic data type**) of our choice. Second, we represent the monadic concept
    with instances of another ADT.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始将计算步骤表示为我们选择的某些 **ADT（代数数据类型**） 的实例。其次，我们使用另一个 ADT 的实例表示单调概念。
- en: To substantiate this approach, we can turn to the fishing example once again.
    Earlier, we had three actions we encoded as functions. These actions will be represented
    as value classes now. We also need to give specific meaning to the type aliases
    we've used before to be able to run examples later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证实这种方法，我们可以再次回到钓鱼的例子。早些时候，我们有三个动作，我们将它们编码为函数。现在，这些动作将被表示为值类。我们还需要给之前使用的类型别名赋予特定的含义，以便以后能够运行示例。
- en: 'Here is the definition of the fishing model and corresponding ADT as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是钓鱼模型及其相应的 ADT（代数数据类型）的定义如下：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the model, we represent some properties of the bait, line, and a fish so
    that we can make use of them later.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型中，我们表示了诱饵、钓线和鱼的一些属性，以便我们以后可以利用它们。
- en: The `Action` type has a few aspects worth discussing. First of all, the instances
    of `Action` reflect that the functions we had before take a single parameter by
    declaring this parameter as a field of the class. Second, all actions are typed
    by the *type of the next action* and this next action is captured as another field
    of the class, in the form of a function which expects the result of the wrapping
    action to be an argument. This second field is how we encode the sequencing of
    actions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action` 类型有几个值得讨论的方面。首先，`Action` 的实例反映了我们之前的功能通过将此参数声明为类的字段来接受单个参数。其次，所有动作都由
    *下一个动作的类型* 类型化，并且这个下一个动作被捕获为类的另一个字段，形式为一个函数，该函数期望包装动作的结果作为参数。第二个字段是我们编码动作顺序的方式。'
- en: Now we need to represent the monadic methods as classes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将单调方法表示为类。
- en: '`Done` assembles an instance of `Free` from a value the same way as `Monad.unit`
    does:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Done` 以与 `Monad.unit` 相同的方式从值组装 `Free` 实例：'
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `F[_]` refers to the type of actions to wrap and `A` is the type of the
    result. `F` needs to have a `Functor`; we will see why in a moment.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`F[_]` 指的是要包装的动作的类型，`A` 是结果类型。`F` 需要有一个 `Functor`；我们将在稍后看到原因。'
- en: 'The `Join` constructs a representation of `flatMap`—it should do so by applying
    the `F` to the previous instance of `Free`. This gives us the following type of `action`
    parameter as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join` 构建了 `flatMap` 的表示——它应该通过将 `F` 应用到 `Free` 的前一个实例来实现这一点。这给我们以下类型的 `action`
    参数如下：'
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, as we said, this is a monad, so we need to provide an implementation of
    `flatMap`. We''ll do this on the `Free` so that it is possible to use both instances
    of `Done` and `Join` in for-comprehensions as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们所说的，这是一个单调，因此我们需要提供一个 `flatMap` 的实现。我们将在 `Free` 上这样做，以便可以在 for-comprehensions
    中使用 `Done` 和 `Join` 的实例，如下所示：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `flatMap` naturally takes the Kleisli arrow as an argument. Similar to the
    definitions of `flatMap` on other monads, for example, an `Option`, we distinguish
    between shortcutting and exiting and continuing the computation chain. In the
    former case, we can just apply the given function; in the latter case we have
    to build up the sequence. This is where we're using the `Functor[F]` to get inside
    the `F` and apply the `flatMap` on the wrapped `Free[F, A]`, basically doing the
    sequencing in a good, old monadic way.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`自然接受Kleisli箭头作为参数。类似于其他单子上的`flatMap`定义，例如`Option`，我们区分了短路和退出以及继续计算链。在前一种情况下，我们可以直接应用给定的函数；在后一种情况下，我们必须构建序列。这就是我们使用`Functor[F]`进入`F`并在包装的`Free[F,
    A]`上应用`flatMap`的地方，基本上是以古老的单子方式执行序列化。'
- en: 'The fact that the functor is here to give us the possibility to succeed in
    computations dictates how the functor for our actions should be implemented —the
    given function should be called on the result of the next action. Our actions
    might have quite a different structure, hence the easiest way to describe this
    approach is pattern matching, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函子在这里提供给我们成功进行计算的可能性，这决定了我们的操作函子应该如何实现——给定的函数应该在下一个操作的结果上被调用。我们的操作可能有相当不同的结构，因此描述这种方法的最简单方式是模式匹配，如下所示：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Values of our ADT are structured similarly and this is the reason why the tranformations
    look alike for all actions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们ADT的值以类似的结构组织，这也是为什么所有操作看起来相似的原因。
- en: 'The last preparation step we need is to have a user-friendly way to create
    instances of the free monad for each of the actions. Let''s create helper methods
    for that in the following manner:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个准备步骤是有一个用户友好的方式来为每个操作创建自由单子的实例。让我们以下面的方式创建辅助方法：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Each of these methods creates a free monad instance which describes a computation
    consisting of a single action; the `Done(...)` encodes the fact that we are, well,
    done, and have some result.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都创建了一个自由单子实例，它描述了一个由单个操作组成的计算；`Done(...)`编码了我们已经完成，并且有一些结果的事实。
- en: 'Now we can use these helper functions to build a computation chain like we
    did before. But this time the computation won''t be something callable—it is just
    a sequence of instances of the free monad captured as a single instance of `Free`,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些辅助函数来构建一个计算链，就像我们之前做的那样。但这次的计算不会是一个可调用的东西——它只是将自由单子的实例作为单个`Free`实例捕获的实例序列，如下所示：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This single instance we have incorporates all of the steps in the form of `Free`
    containing actions. Represented as pseudo-code, the result of calling this method
    would look like a nested structure, as given below:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一的实例包含了所有步骤，以`Free`包含操作的形式。以伪代码的形式表示，调用此方法的结果将看起来像嵌套结构，如下所示：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'At this moment, we have created the computation sequence, but this sequence
    is useless because it''s just a data structure. We need a way to make it useful—we
    have to create an interpreter for it. And this is where the free monad really
    starts to shine—it is up to us how we will render this data. We can create as
    many interpreters as we wish, for example, one for testing purposes and another
    for production use. For instance, for testing, it might be useful just to collect
    all of the actions which should happen in some journal—in an event-sourced way
    (we''ll look at event sourcing in detail later in this book). As we''re just testing,
    our journal does not need to be persistent—hence, we can just use some kind of
    collection; for example, a `List` would do, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们已经创建了计算序列，但这个序列是无用的，因为它只是一个数据结构。我们需要一种方法让它变得有用——我们必须为它创建一个解释器。这正是自由单子真正开始发光的地方——如何呈现这些数据取决于我们。我们可以创建尽可能多的解释器，例如，一个用于测试目的，另一个用于生产使用。例如，对于测试，仅仅收集应该在某个日志中发生的所有操作可能是有用的——以事件源的方式（我们将在本书的后面详细探讨事件源）。因为我们只是在测试，所以我们的日志不需要持久化——因此，我们可以使用某种类型的集合；例如，一个`List`就足够了，如下所示：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding snippet is indeed an interpreter for the program which is built
    in terms of the actions wrapped in `Free`. The logic is repetitive—we're producing
    the result of the action and calling this action recursively, passing the log
    with the added entry as a parameter. In the case of `Done`, we're ignoring the
    result; our goal is the log, and we return it in reversed form by calling `.reverse` to
    compensate for building it up in the opposite direction.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段确实是一个程序的解释器，该程序是用`Free`中封装的操作构建的。逻辑是重复的——我们产生操作的结果，并递归地调用这个操作，将带有新增条目的日志作为参数传递。在`Done`的情况下，我们忽略结果；我们的目标是日志，我们通过调用`.reverse`来以相反的方向构建它，并返回反转的形式。
- en: 'The result of the execution looks like the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的结果看起来如下所示：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For production, we can do something else, such as collecting the executed actions.
    We will model this side-effecting by writing to the console, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，我们可以做些其他事情，例如收集执行的动作。我们将通过写入控制台来模拟这种副作用，如下所示：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The structure of this interpreter is naturally the same as before. The result
    type of the computation is `Unit`—everything we do is side-effecting, so there
    is no need to pass anything around. Instead of accumulating actions into the log
    we are just writing a report directly to the console. The case of `Done` is also
    little different—we're returning the `fish`, the result of the performed combined
    action.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释器的结构自然与之前相同。计算的输出类型是`Unit`——我们做的所有事情都有副作用，所以没有必要传递任何东西。我们不是将操作累积到日志中，而是直接将报告写入控制台。`Done`的情况也略有不同——我们返回`fish`，即执行组合操作的结果。
- en: 'The result of the execution changes as expected, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的结果如预期的那样发生变化，如下所示：
- en: '[PRE48]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We managed to implement a very basic version of the free monad along with a
    small fishing language and two different interpreters. It is quite a bit of code
    so it''s time to answer an obvious question: for what purpose do we invest this
    additional effort?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功实现了一个非常基本的自由monad版本，以及一个小型的钓鱼语言和两个不同的解释器。代码量相当大，所以是时候回答一个明显的问题了：我们为什么投入额外的努力？
- en: 'The free monad has obvious advantages; we touched upon these, and they are
    as as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 自由monad具有明显的优势；我们提到了这些，它们如下：
- en: Gluing the computations together as classes happens in a heap and saves stack
    memory.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将计算作为类粘合在一起发生在堆上，并节省了栈内存。
- en: It is possible to pass the computation over to different parts of the code and
    the side-effects will be deferred until it is explicitly run.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将计算传递到代码的不同部分，并且副作用将延迟到显式运行时。
- en: Having multiple interpreters allows for different behaviour in different circumstances.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多个解释器允许在不同情况下有不同的行为。
- en: This chapter's scope has not allowed us to show how different "languages" (ADTs)
    can be composed into one algebraic structure, which then can be used to define
    the logic using both languages at the same time. This possibility offers an alternative
    to the monad transformers and monad transformer stacks, for example, a language
    that combines business terms and persistence terms.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的范围没有允许我们展示不同的“语言”（ADTs）如何组合成一个代数结构，然后可以使用这个结构同时使用两种语言来定义逻辑。这种可能性为monad变换和monad变换堆栈提供了替代方案，例如，一种结合业务术语和持久性术语的语言。
- en: The disadvantages lie in the same plane as they do for monads. These include
    additional initial implementation effort, runtime overhead for the garbage collector,
    and processing additional instructions and mental overhead for developers new
    to the concept.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的缺点与monads的缺点处于同一层面。这包括额外的初始实现工作量、垃圾收集器的运行时开销，以及对于新接触这个概念的开发者来说，处理额外的指令和心理负担。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Monads are arguably the most ubiquitous abstraction in functional programming.
    Unfortunately they cannot be composed in general—in contrast to functions and
    applicatives.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Monads可以说是函数式编程中最普遍的抽象。不幸的是，它们在一般情况下不能组合——与函数和应用不同。
- en: Monad transformers provide a way to work around this limitation by specifying
    a set of overarching structures to represent combinations of monads, each combination
    being specific to a single internal effect type. Monad transformers compose monads
    in a way that it is possible to cross both effects with a single call of the `flatMap`
    or `map`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Monad变换提供了一种绕过这种限制的方法，通过指定一组总体结构来表示monads的组合，每个组合都针对单个内部效应类型。Monad变换以这种方式组合monads，使得可以通过一次`flatMap`或`map`调用同时跨越两种效应。
- en: Monad transformer stacks lift the concept of monad transformers one level higher,
    utilizing the fact that each monad transformer is also a monad. By stacking monad
    transformers, it is possible to work with virtually any number of effects combined
    together in a single pile the same way we would do with a single monad.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Monad transformer stacks 将 monad transformer 的概念提升了一个层次，利用了每个 monad transformer
    同时也是一个 monad 的这一事实。通过堆叠 monad transformer，我们可以像处理单个 monad 一样，以相同的方式在单个堆栈中组合几乎任何数量的效果。
- en: Monad transformers are not without disadvantages. The list includes increased
    garbage collection footprint and processor utilization because of the need to
    unpack and repack  effects in the stack. The same reasoning applies to the mental
    model developers needed to build and maintain in their head while working with
    the code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Monad transformer 并非没有缺点。该列表包括由于需要在堆栈中解包和重新打包效果而增加的垃圾收集足迹和处理器利用率。同样的推理也适用于开发者在编写和维护代码时需要在脑海中构建和维护的心理模型。
- en: The free monad provides a reasonable alternative by clearly separating structure
    and interpretation of the computations. It does so by representing business logic
    as a sequence of steps encoded as data by some ADT and executing these steps with
    suitable interpreter(s).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Free monad 通过明确分离计算的结构和解释，提供了一个合理的替代方案。它是通过将业务逻辑表示为某些 ADT 编码的步骤序列来实现的，并使用合适的解释器执行这些步骤。
- en: This chapter concludes the second part of the book. In this part and the first
    part, we refrained from using third-party libraries and focused on giving readers
    a deep understanding of the language features and underlying theoretical concepts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了本书的第二部分。在本部分和第一部分中，我们避免使用第三方库，专注于向读者传授对语言特性和底层理论概念的深入理解。
- en: Needless to say, the code examples in this part were decidedly simplistic and
    only suitable for learning purposes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，本部分中的代码示例无疑是简化的，仅适用于学习目的。
- en: 'Specifically to the functional programming aspects, there are two exceptionally
    good libraries, worth mentioning one more time and available for Scala: Cats ([https://typelevel.org/cats/](https://typelevel.org/cats/))
    and Scalaz ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz)).
    If we managed to ignite your interest in programming Scala using the functional
    style shown in this part of the book, we highly recommend taking a look at both
    of them. Besides offering production-ready implementation for the concepts we
    studied, they also contain lots of abstractions we weren''t able to discuss.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 特别针对函数式编程方面，有两个特别好的库值得再次提及，并且可用于 Scala：Cats ([https://typelevel.org/cats/](https://typelevel.org/cats/))
    和 Scalaz ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz))。如果我们成功地激发了您使用本书本部分展示的函数式风格编程
    Scala 的兴趣，我们强烈推荐您查看这两个库。除了提供我们研究的概念的生产就绪实现外，它们还包含了许多我们没有讨论的抽象。
- en: In the third part of the book we will relax our self-imposed constraint about
    third-party dependencies and dedicate it to the topic of reactive programming
    in Scala using different Akka libraries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第三部分，我们将放宽对第三方依赖的自我施加的限制，并将其致力于使用不同的 Akka 库在 Scala 中进行响应式编程的主题。
- en: Questions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why does the type of monad transformer reflect the type of the stack "upside-down"
    with its name referring to the type of innermost monad?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 monad transformer 的类型反映了堆栈类型的“倒置”，其名称指的是最内层 monad 的类型？
- en: Why is it possible to reuse existing monads for the top layer of the stack?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么可以在堆栈的顶层重用现有的 monad？
- en: Why is it impossible to reuse existing monads for the bottom layer of the stack?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不能在堆栈的底层重用现有的 monad？
- en: Implement a `TryT` monad transformer.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `TryT` monad transformer。
- en: Use the `TryT` monad transformer instead of `EitherT` with the example functions
    from the chapter.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章的示例函数中使用 `TryT` monad transformer 而不是 `EitherT`。
- en: 'Implement another take on the monad transformer stack, this time with the layers
    placed upside-down: `EitherT[OptionT[Future, A], String, A]`.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现另一种 monad transformer stack 的实现，这次将层放置在上方：`EitherT[OptionT[Future, A], String,
    A]`。
- en: Add an action to release the caught fish in the free monad example we developed
    in the chapter.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章开发的 free monad 示例中添加一个释放捕获的鱼的动作。
- en: Further reading
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Anatolii Kmetiuk, *Mastering Functional Programming*: Learn how functional
    programming can help you in deploying web servers and working with databases in
    a declarative and pure way'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Anatolii Kmetiuk，*精通函数式编程*：学习函数式编程如何帮助你以声明性和纯方式部署网络服务器和与数据库交互。
- en: Atul S. Khot, *Scala Functional Programming Patterns*: Grok and perform effective
    functional programming in Scala
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Atul S. Khot，《Scala 函数式编程模式》：掌握并执行有效的 Scala 函数式编程
- en: Ivan Nikolov, *Scala Design Patterns* - Second Edition: Learn how to write efficient,
    clean, and reusable code with Scala
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Ivan Nikolov，《Scala 设计模式》—— 第二版：学习如何使用 Scala 编写高效、简洁且可重用的代码
