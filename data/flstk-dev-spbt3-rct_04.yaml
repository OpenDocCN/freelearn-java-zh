- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Using JPA to Create and Access a Database
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JPA 创建和访问数据库
- en: This chapter covers how to use **Jakarta Persistence API** (**JPA**) with Spring
    Boot and how to define a database by using entity classes. In the first phase,
    we will be using the **H2** database. H2 is an in-memory SQL database that is
    good for fast development or demonstration purposes. In the second phase, we will
    move from H2 to **MariaDB**. This chapter also describes the creation of CRUD
    repositories and a one-to-many connection between database tables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用 **Jakarta Persistence API**（**JPA**）与 Spring Boot 一起工作，以及如何使用实体类定义数据库。在第一阶段，我们将使用
    **H2** 数据库。H2 是一个内存 SQL 数据库，适用于快速开发或演示目的。在第二阶段，我们将从 H2 迁移到 **MariaDB**。本章还描述了
    CRUD 仓库的创建以及数据库表之间的一对多连接。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basics of ORM, JPA, and Hibernate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM、JPA 和 Hibernate 的基础知识
- en: Creating the entity classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建实体类
- en: Creating CRUD repositories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 CRUD 仓库
- en: Adding relationships between tables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表之间添加关系
- en: Setting up the MariaDB database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 MariaDB 数据库
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Spring Boot application we created in previous chapters is required.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中创建的 Spring Boot 应用程序是必需的。
- en: 'A MariaDB installation is necessary to create the database application: [https://downloads.mariadb.org/](https://downloads.mariadb.org/).
    We went through the installation steps in *Chapter 1*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据库应用程序需要安装 MariaDB：[https://downloads.mariadb.org/](https://downloads.mariadb.org/)。我们已经在
    *第一章* 中介绍了安装步骤。
- en: 'The code for this chapter can be found at the following GitHub link: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter03).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下 GitHub 链接中找到：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter03).
- en: Basics of ORM, JPA, and Hibernate
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORM、JPA 和 Hibernate 的基础知识
- en: 'ORM and JPA are widely used techniques in software development for handling
    relational databases. You don’t have to write complex SQL queries; instead, you
    can work with objects, which is more natural for Java developers. In this way,
    ORM and JPA can speed up your development process by reducing the time you spend
    writing and debugging SQL code. Many JPA implementations can also generate a database
    schema automatically based on your Java entity classes. In brief:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 和 JPA 是软件开发中广泛使用的处理关系数据库的技术。您不必编写复杂的 SQL 查询；相反，您可以与对象一起工作，这对于 Java 开发者来说更自然。通过这种方式，ORM
    和 JPA 可以通过减少编写和调试 SQL 代码的时间来加快您的开发过程。许多 JPA 实现还可以根据您的 Java 实体类自动生成数据库模式。简要来说：
- en: '**Object-Relational Mapping** (**ORM**) is a technique that allows you to fetch
    from and manipulate a database by using an object-oriented programming paradigm.
    ORM is really good for programmers because it relies on object-oriented concepts
    rather than database structures. It also makes development much faster and reduces
    the amount of source code. ORM is mostly independent of databases, and developers
    don’t have to worry about vendor-specific SQL statements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）是一种技术，允许您通过使用面向对象编程范式从数据库中检索和操作数据。ORM 对于程序员来说非常好，因为它依赖于面向对象的概念，而不是数据库结构。它还使开发过程更快，并减少了源代码的数量。ORM
    主要独立于数据库，开发者不必担心供应商特定的 SQL 语句。'
- en: '**Jakarta Persistence API** (**JPA**, formerly **Java Persistence API**) provides
    object-relational mapping for Java developers. The JPA entity is a Java class
    that represents the structure of a database table. The fields of an entity class
    represent the columns of the database tables.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jakarta Persistence API**（**JPA**，以前称为 **Java Persistence API**）为 Java 开发者提供了对象关系映射。JPA
    实体是一个代表数据库表结构的 Java 类。实体类的字段代表数据库表的列。'
- en: '**Hibernate** is the most popular Java-based JPA implementation and is used
    in Spring Boot by default. Hibernate is a mature product and is widely used in
    large-scale applications.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hibernate** 是最流行的基于 Java 的 JPA 实现，并且默认用于 Spring Boot。Hibernate 是一个成熟的产品，在大型应用程序中得到广泛使用。'
- en: Next, we will start to implement our first entity class using the H2 database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始使用 H2 数据库实现我们的第一个实体类。
- en: Creating the entity classes
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实体类
- en: An **entity class** is a simple Java class that is annotated with JPA’s `@Entity`
    annotation. Entity classes use the standard JavaBean naming convention and have
    proper getter and setter methods. The class fields have private visibility.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体类**是一个简单的Java类，它被JPA的`@Entity`注解所标注。实体类使用标准的JavaBean命名约定，并具有适当的getter和setter方法。类字段具有私有可见性。'
- en: JPA creates a database table with the same name as the class when the application
    is initialized. If you want to use some other name for the database table, you
    can use the `@Table` annotation in your entity class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序初始化时，JPA会创建一个与类名相同的数据库表。如果您想为数据库表使用其他名称，您可以在实体类中使用`@Table`注解。
- en: 'At the beginning of this chapter, we will use the H2 database (https://www.h2database.com/),
    which is an embedded in-memory database. To be able to use JPA and the H2 database,
    we have to add the following dependencies to the `build.gradle` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们将使用H2数据库（https://www.h2database.com/），这是一个嵌入式的内存数据库。为了能够使用JPA和H2数据库，我们必须将以下依赖项添加到`build.gradle`文件中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you have updated the `build.gradle` file, you should update your dependencies
    by selecting the project in Eclipse’s **Project Explorer** and right-clicking
    to open the context menu. Then, select **Gradle | Refresh Gradle Project**, as
    shown in the next screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在您更新了`build.gradle`文件之后，您应该通过在Eclipse的**项目资源管理器**中选择项目并右键单击以打开上下文菜单来更新您的依赖项。然后，选择**Gradle
    | 刷新Gradle项目**，如下一截图所示：
- en: '![](img/B19818_03_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_01.png)'
- en: 'Figure 3.1: Refresh Gradle Project'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：刷新Gradle项目
- en: 'You can also enable automatic project refresh by opening the **Window | Preferences**
    menu. Go to the **Gradle** settings and there is an **Automatic Project Synchronization**
    checkbox that you can check. Then, your project will be synchronized automatically
    if you make changes to your build script file. This is recommended and means you
    don’t have to manually refresh the project when you update your build script:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过打开**窗口 | 首选项**菜单来启用自动项目刷新。转到**Gradle**设置，那里有一个**自动项目同步**复选框，您可以勾选它。然后，如果您更改了构建脚本文件，您的项目将自动同步。这是推荐的，意味着您在更新构建脚本时不需要手动刷新项目：
- en: '![](img/B19818_03_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_02.png)'
- en: 'Figure 3.2: Gradle wrapper settings'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：Gradle包装器设置
- en: 'You can find the project dependencies from the **Project and External Dependencies**
    folder in the Eclipse **Project** **Explorer**. Now, you should find `spring-boot-starter-data-jpa`
    and h2 dependencies there:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Eclipse的**项目资源管理器**中的**项目和外部依赖**文件夹中找到项目依赖项。现在，您应该在那里找到`spring-boot-starter-data-jpa`和h2依赖项：
- en: '![](img/B19818_03_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_03.png)'
- en: 'Figure 3.3: Project dependencies'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：项目依赖项
- en: 'Let’s look at the following steps to create entity classes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤来创建实体类：
- en: To create an entity class in Spring Boot, we must create a package for entities.
    The package should be created under the root package. To begin this process, activate
    the root package in Eclipse’s **Project Explorer** and right-click to make a context
    menu appear.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Spring Boot中创建实体类，我们必须为实体创建一个包。这个包应该创建在根包下。为了开始这个过程，在Eclipse的**项目资源管理器**中激活根包，并右键单击以出现上下文菜单。
- en: 'From this menu, select **New | Package**. The following screenshot shows how
    to create a package for entity classes:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此菜单中选择**新建 | 包**。以下截图显示了如何为实体类创建一个包：
- en: '![](img/B19818_03_04.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_04.png)'
- en: 'Figure 3.4: New package'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：新包
- en: 'We will name our package `com.packt.cardatabase.domain`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将命名我们的包为`com.packt.cardatabase.domain`：
- en: '![](img/B19818_03_05.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_05.png)'
- en: 'Figure 3.5: New Java package'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：新Java包
- en: Next, we will create our entity class. Activate the new `com.packt.cardatabase.domain`
    package, right-click it, and select **New | Class** from the menu.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的实体类。在Eclipse的**项目资源管理器**中激活新的`com.packt.cardatabase.domain`包，右键单击它，并从菜单中选择**新建
    | 类**。
- en: 'Because we are going to create a car database, the name of the entity class
    will be `Car`. Type `Car` into the **Name** field and then press the **Finish**
    button, as shown in the following screenshot:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将创建一个汽车数据库，实体类的名称将是`Car`。在**名称**字段中输入`Car`，然后按**完成**按钮，如以下截图所示：
- en: '![](img/B19818_03_06.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_06.png)'
- en: 'Figure 3.6: New Java class'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：新Java类
- en: 'Open the `Car` class file in the editor by double-clicking it in the **Project
    Explorer**. First, we must annotate the class with the `@Entity` annotation. The
    `@Entity` annotation is imported from the `jakarta.persistence` package:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**项目资源管理器**中双击它来在编辑器中打开`Car`类文件。首先，我们必须使用`@Entity`注解注解该类。`@Entity`注解是从`jakarta.persistence`包导入的：
- en: '[PRE1]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use the *Ctrl* + *Shift* + *O* shortcut in the Eclipse IDE to import
    missing packages automatically. In some cases, there might be multiple packages
    that contain the same identifier, so you have to be careful to select the correct
    import. For example, in the next step, `Id` can be found in multiple packages,
    but you should select `jakarta.persistence.Id`.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在Eclipse IDE中使用*Ctrl* + *Shift* + *O*快捷键自动导入缺失的包。在某些情况下，可能存在包含相同标识符的多个包，因此你必须小心选择正确的导入。例如，在下一步中，`Id`可以在多个包中找到，但你应该选择`jakarta.persistence.Id`。
- en: 'Next, we must add some fields to our class. The entity class fields are mapped
    to database table columns. The entity class must also contain a unique ID that
    is used as a primary key in the database:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须在我们的类中添加一些字段。实体类字段映射到数据库表列。实体类还必须包含一个唯一ID，该ID在数据库中用作主键：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The primary key is defined by using the `@Id` annotation. The `@GeneratedValue`
    annotation defines that the ID is automatically generated by the database. We
    can also define our key generation strategy; the `AUTO` type means that the JPA
    provider selects the best strategy for a particular database and it is also the
    default generation type. You can create a composite primary key by annotating
    multiple attributes with the `@Id` annotation.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主键是通过使用`@Id`注解定义的。`@GeneratedValue`注解定义了ID将由数据库自动生成。我们还可以定义自己的键生成策略；`AUTO`类型表示JPA提供者会选择特定数据库的最佳策略，这也是默认的生成类型。你可以通过在多个属性上注解`@Id`来创建一个复合主键。
- en: 'The database columns are named according to class field naming conventions
    by default. If you want to use some other naming convention, you can use the `@Column`
    annotation. With the `@Column` annotation, you can define the column’s length
    and whether the column is `nullable`. The following code shows an example of using
    the `@Column` annotation. With this definition, the column’s name in the database
    is `explanation`, the length of the column is `512`, and it is not `nullable`:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，数据库列的命名遵循类字段命名约定。如果你想使用其他命名约定，可以使用`@Column`注解。使用`@Column`注解，你可以定义列的长度以及列是否为`nullable`。以下代码展示了使用`@Column`注解的示例。根据此定义，数据库中列的名称为`explanation`，列的长度为`512`，且不可为空：
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we must add getters, setters, a default constructor, and constructors
    with attributes to the entity class. We don’t need an ID field in our constructor
    due to automatic ID generation. The source code of the `Car` entity class constructors
    is as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须向实体类添加getter、setter、默认构造函数和带属性的构造函数。由于自动ID生成，我们不需要在构造函数中添加ID字段。`Car`实体类构造函数的源代码如下：
- en: Eclipse provides the automatic addition of getters, setters, and constructors.
    Activate your cursor in the place where you want to add the code and right-click.
    From the menu, select **Source | Generate Getters and Setters...** or **Source
    | Generate Constructor using Fields...**.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Eclipse提供了自动添加getter、setter和构造函数的功能。将光标置于你想要添加代码的位置，然后右键单击。从菜单中选择**源 | 生成getter和setter...**或**源
    | 使用字段生成构造函数...**。
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the source code for the `Car` entity class’s getters and setters:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是为`Car`实体类编写的getter和setter的源代码：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also have to add new properties to the `application.properties` file. This
    allows us to log the SQL statements to the console. We also have to define the
    data source URL. Open the `application.properties` file and add the following
    two lines to the file:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须在`application.properties`文件中添加新的属性。这允许我们将SQL语句记录到控制台。我们还需要定义数据源URL。打开`application.properties`文件，并在文件中添加以下两行：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you are editing the `application.properties` file, you have to make sure
    that there are no extra spaces at the end of the lines. Otherwise, the settings
    won’t work. This might happen when you copy/paste settings.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你正在编辑`application.properties`文件时，你必须确保行尾没有多余的空格。否则，设置将不会生效。这可能会发生在你复制/粘贴设置时。
- en: Now, the `car` table will be created in the database when we run the application.
    At this point, we can see the table creation statements in the console:![](img/B19818_03_07.png)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当运行应用程序时，数据库将创建`car`表。在此阶段，我们可以在控制台中看到表创建语句：![](img/B19818_03_07.png)
- en: 'Figure 3.7: Car table SQL statements'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.7：汽车表SQL语句
- en: If `spring.datasource.url` is not defined in the `application.properties` file,
    Spring Boot creates a random data source URL that can be seen in the console when
    you run the application; for example, `H2 console available at '/h2-console'.
    Database available at 'jdbc:h2:mem:b92ad05e-8af4-4c33-b22d-ccbf9ffe491e'`.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在`application.properties`文件中没有定义`spring.datasource.url`，Spring Boot将创建一个随机数据源URL，当您运行应用程序时可以在控制台中看到，例如，`H2控制台在'/h2-console'可用。数据库在'jdbc:h2:mem:b92ad05e-8af4-4c33-b22d-ccbf9ffe491e'可用`。
- en: 'The H2 database provides a web-based console that can be used to explore a
    database and execute SQL statements. To enable the console, we have to add the
    following lines to the `application.properties` file. The first setting enables
    the H2 console, while the second defines its path:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: H2数据库提供了一个基于Web的控制台，可以用来探索数据库并执行SQL语句。要启用控制台，我们必须在`application.properties`文件中添加以下行。第一个设置启用了H2控制台，而第二个定义了其路径：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can access the H2 console by starting your application and navigating to
    `localhost:8080/h2-console` using your web browser. Use `jdbc:h2:mem:testdb` as
    the **JDBC URL** and leave the **Password** field empty in the **Login** window.
    Press the **Connect** button to log in to the console, as shown in the following
    screenshot:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过启动应用程序并使用Web浏览器导航到`localhost:8080/h2-console`来访问H2控制台。使用`jdbc:h2:mem:testdb`作为**JDBC
    URL**，并在**登录**窗口的**密码**字段中留空。按下**连接**按钮登录到控制台，如图下所示：
- en: '![](img/B19818_03_08.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_03_08.png)'
- en: 'Figure 3.8: H2 console login'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：H2控制台登录
- en: 'You can also change the H2 database username and password by using the following
    settings in the `application.properties` file: `spring.datasource.username` and
    `spring.datasource.password`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在`application.properties`文件中使用以下设置来更改H2数据库的用户名和密码：`spring.datasource.username`和`spring.datasource.password`。
- en: 'Now, you can see our `CAR` table in the database. You may notice that the registration
    number and model year have an underscore between the words. The reason for the
    underscore is the camel case naming of the attribute (`registrationNumber`):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在数据库中看到我们的`CAR`表。您可能会注意到注册号和型号年份之间有一个下划线。下划线的原因是属性的驼峰命名（`registrationNumber`）：
- en: '![](img/B19818_03_09.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_03_09.png)'
- en: 'Figure 3.9: H2 console'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：H2控制台
- en: Now, we have created our first entity class and learned how JPA generates a
    database table from the entity class. Next, we will create a repository class
    that provides CRUD operations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了我们的第一个实体类，并学习了JPA如何从实体类生成数据库表。接下来，我们将创建一个提供CRUD操作的存储库类。
- en: Creating CRUD repositories
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CRUD存储库
- en: The Spring Boot Data JPA provides a `CrudRepository` interface for **Create**,
    **Read**, **Update**, and **Delete** (**CRUD**) operations. It provides CRUD functionalities
    to our entity class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Data JPA提供了一个`CrudRepository`接口用于**创建**、**读取**、**更新**和**删除**（**CRUD**）操作。它为我们提供了实体类的CRUD功能。
- en: 'Let’s create our repository in the `domain` package, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`domain`包中创建我们的存储库，如下所示：
- en: 'Create a new interface called `CarRepository` in the `com.packt.cardatabase.domain`
    package and modify the file according to the following code snippet:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.cardatabase.domain`包中创建一个新的接口`CarRepository`，并根据以下代码片段修改文件：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`CarRepository` now extends the Spring Boot JPA `CrudRepository` interface.
    The `<Car, Long>` type arguments define that this is the repository for the `Car`
    entity class and that the type of the ID field is `Long`.'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CarRepository`现在扩展了Spring Boot JPA的`CrudRepository`接口。类型参数`<Car, Long>`定义了这是一个`Car`实体类的存储库，并且ID字段的类型是`Long`。'
- en: 'The `CrudRepository` interface provides multiple CRUD methods that we can now
    start to use. The following table lists the most commonly used methods:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CrudRepository`接口提供了多个CRUD方法，我们现在可以开始使用了。以下表格列出了最常用的方法：'
- en: '| **Method** | **Description** |'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `long count()` | Returns the number of entities |'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `long count()` | 返回实体数量 |'
- en: '| `Iterable<T> findAll()` | Returns all items of a given type |'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Iterable<T> findAll()` | 返回给定类型的所有项 |'
- en: '| `Optional<T> findById(ID Id)` | Returns one item by ID |'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Optional<T> findById(ID Id)` | 通过ID返回一个项 |'
- en: '| `void delete(T entity)` | Deletes an entity |'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `void delete(T entity)` | 删除一个实体 |'
- en: '| `void deleteAll()` | Deletes all the entities in the repository |'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `void deleteAll()` | 删除存储库中的所有实体 |'
- en: '| `<S extends T> save(S entity)` | Saves an entity |'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `<S extends T> save(S entity)` | 保存一个实体 |'
- en: '| `List<S> saveAll(Iterable<S> entities)` | Saves multiple entities |'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `List<S> saveAll(Iterable<S> entities)` | 保存多个实体 |'
- en: 'Table 3.1: CRUD methods'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表 3.1：CRUD 方法
- en: If the method returns only one item, `Optional<T>` is returned instead of `T`.
    The `Optional` class was introduced in Java 8 SE and is a type of single-value
    container that either contains a value or doesn’t. If there is a value, the `isPresent()`
    method returns `true` and you can get it by using the `get()` method; otherwise,
    it returns `false`. By using `Optional`, we can prevent **null pointer exceptions**.
    Null pointers can lead to unexpected and often undesirable behavior in Java programs.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果方法只返回一个项目，则返回 `Optional<T>` 而不是 `T`。`Optional` 类是在 Java 8 SE 中引入的，它是一种单值容器，要么包含一个值，要么不包含。如果有值，`isPresent()`
    方法返回 `true`，并且您可以通过使用 `get()` 方法获取它；否则，它返回 `false`。通过使用 `Optional`，我们可以防止 **空指针异常**。空指针可能导致
    Java 程序中出现意外和通常不希望的行为。
- en: 'After adding the `CarRepository` class, your project structure should look
    as follows:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在添加 `CarRepository` 类后，您的项目结构应该如下所示：
- en: '![](img/B19818_03_10.png)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B19818_03_10.png)'
- en: 'Figure 3.10: Project structure'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.10：项目结构
- en: 'Now, we are ready to add some demonstration data to our H2 database. For that,
    we will use the Spring Boot `CommandLineRunner` interface. The `CommandLineRunner`
    interface allows us to execute additional code before the application has fully
    started. Therefore, it is a good point to add demo data to your database. Your
    Spring Boot application’s `main` class implements the `CommandLineRunner` interface.
    Therefore, we should implement the `run` method, as shown in the following `CardatabaseApplication.java`
    code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备向我们的 H2 数据库添加一些演示数据。为此，我们将使用 Spring Boot 的 `CommandLineRunner` 接口。`CommandLineRunner`
    接口允许我们在应用程序完全启动之前执行额外的代码。因此，这是一个向数据库添加演示数据的好时机。您的 Spring Boot 应用程序的 `main` 类实现了
    `CommandLineRunner` 接口。因此，我们应该实现 `run` 方法，如下面的 `CardatabaseApplication.java` 代码所示：
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we have to inject our car repository into the main class to be able to
    save new car objects to the database. We use constructor injection to inject `CarRepository`.
    We will also add a logger to our `main` class (the code for which we saw in *Chapter
    1*):'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须将我们的汽车存储库注入到主类中，以便能够将新的汽车对象保存到数据库中。我们使用构造函数注入来注入 `CarRepository`。我们还将向我们的
    `main` 类添加一个记录器（我们之前在 *第 1 章* 中看到了它的代码）：
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have injected the repository class, we can use the CRUD methods it
    provides in the `run` method. The following sample code shows how to insert a
    few cars into the database using the `save` method. We will also use the repository’s
    `findAll()` method to fetch all the cars from the database and print them to the
    console using the logger:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们注入了存储库类，我们就可以在 `run` 方法中使用它提供的 CRUD 方法。以下示例代码展示了如何使用 `save` 方法将几辆汽车插入到数据库中。我们还将使用存储库的
    `findAll()` 方法从数据库中检索所有汽车，并使用记录器将它们打印到控制台：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `insert` statements and cars we logged can be seen in the Eclipse console
    once the application has been executed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序执行完毕，您可以在 Eclipse 控制台中看到 `insert` 语句和记录的汽车：
- en: '![](img/B19818_03_11.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_03_11.png)'
- en: 'Figure 3.11: Insert statements'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11：插入语句
- en: 'You can now use the H2 console to fetch cars from the database, as shown in
    the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 H2 控制台从数据库中检索汽车，如下面的屏幕截图所示：
- en: '![](img/B19818_03_12.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_03_12.png)'
- en: 'Figure 3.12: H2 console: Select cars'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：H2 控制台：选择汽车
- en: 'You can define queries in the Spring Data repositories. A query must start
    with a prefix, for example, `findBy`. After the prefix, you must define the entity
    class fields that are used in the query. The following is some sample code for
    three simple queries:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Spring Data 存储库中定义查询。查询必须以一个前缀开始，例如，`findBy`。在前面缀之后，您必须定义在查询中使用的实体类字段。以下是一些三个简单查询的示例代码：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There can be multiple fields after the `By` keyword, concatenated with the
    `And` and `Or` keywords:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `By` 关键字之后可以有多个字段，通过 `And` 和 `Or` 关键字连接：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Queries can be sorted by using the `OrderBy` keyword in the query method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在查询方法中使用 `OrderBy` 关键字来对查询进行排序：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also create queries by using SQL statements via the `@Query` annotation.
    The following example shows the usage of a SQL query in `CrudRepository`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过使用 `@Query` 注解来通过 SQL 语句创建查询。以下示例展示了在 `CrudRepository` 中使用 SQL 查询的用法：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the `@Query` annotation, you can use more advanced expressions, such as
    `like`. The following example shows the usage of the `like` query in `CrudRepository`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Query`注解，你可以使用更高级的表达式，例如`like`。以下示例展示了在`CrudRepository`中使用`like`查询的用法：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you use the `@Query` annotation and write SQL queries in your code, your
    application might be less portable across different database systems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`@Query`注解并在代码中编写SQL查询，你的应用程序可能在不同数据库系统之间的可移植性会降低。
- en: 'Spring Data JPA also provides `PagingAndSortingRepository`, which extends `CrudRepository`.
    This offers methods to fetch entities using pagination and sorting. This is a
    good option if you are dealing with larger amounts of data because you don’t have
    to return everything from a large result set. You can also sort your data into
    some meaningful order. `PagingAndSortingRepository` can be created in a similar
    way to how we created `CrudRepository`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA还提供了`PagingAndSortingRepository`，它扩展了`CrudRepository`。这提供了使用分页和排序获取实体的方法。如果你处理大量数据，这是一个很好的选择，因为你不需要从大型结果集中返回所有内容。你还可以将数据排序成有意义的顺序。`PagingAndSortingRepository`可以以与创建`CrudRepository`类似的方式创建：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case, you now have the two new additional methods that the repository
    provides:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你现在有了仓库提供的两个新方法：
- en: '| **Method** | **Description** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Iterable<T> findAll(Sort sort)` | Returns all entities sorted by the given
    options |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Iterable<T> findAll(Sort sort)` | 根据给定的选项返回所有已排序的实体 |'
- en: '| `Page<T> findAll(Pageable pageable)` | Returns all entities according to
    the given paging options |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `Page<T> findAll(Pageable pageable)` | 根据给定的分页选项返回所有实体 |'
- en: 'Table 3.2: PagingAndSortingRepository methods'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2：PagingAndSortingRepository方法
- en: At this point, we have completed our first database table and we are ready to
    add relationships between the database tables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了第一个数据库表的创建，我们现在准备在数据库表之间添加关系。
- en: Adding relationships between tables
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加表之间的关系
- en: We will create a new table called `owner` that has a one-to-many relationship
    with the `car` table. In this case, a one-to-many relationship means that the
    owner can own multiple cars, but a car can only have one owner.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的表名为`owner`，它与`car`表有一个一对多关系。在这种情况下，一对多关系意味着所有者可以拥有多辆车，但一辆车只能有一个所有者。
- en: 'The following **Unified Modeling Language** (**UML**) diagram shows the relationship
    between the tables:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下**统一建模语言**（**UML**）图显示了表之间的关系：
- en: '![](img/B19818_03_13.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_03_13.png)'
- en: 'Figure 3.13: One-to-many relationship'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：一对多关系
- en: 'The following are the steps to create a new table:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新表的步骤如下：
- en: First, we must create the `Owner` entity and repository classes in the `com.packt.cardatabase.domain`
    package. The `Owner` entity and repository are created in a similar way to the
    `Car` class.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须在`com.packt.cardatabase.domain`包中创建`Owner`实体和仓库类。`Owner`实体和仓库的创建方式与`Car`类类似。
- en: 'The following is the source code for the `Owner` entity class:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为`Owner`实体类的源代码：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the source code for `OwnerRepository`:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为`OwnerRepository`的源代码：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we should check that everything is working. Run the project and check that
    both database tables have been created and that there are no errors in the console.
    The following screenshot shows the console messages when the tables are created:![](img/B19818_03_14.png)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该检查一切是否正常工作。运行项目并检查是否已创建两个数据库表，并且控制台没有错误。以下截图显示了创建表时的控制台消息！[](img/B19818_03_14.png)
- en: 'Figure 3.14: The car and owner tables'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.14：汽车和所有者表
- en: 'Now, our domain package contains two entity classes and repositories:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们的领域包包含两个实体类和仓库：
- en: '![](img/B19818_03_15.png)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B19818_03_15.png)'
- en: 'Figure 3.15: The Project Explorer'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.15：项目资源管理器
- en: 'The one-to-many relationship can be added by using the `@ManyToOne` and `@OneToMany`
    annotations (`jakarta.persistence`). In the car entity class, which contains a
    foreign key, you must define the relationship with the `@ManyToOne` annotation.
    You should also add the getter and setter for the owner field. It is recommended
    that you use `FetchType.LAZY` for all associations. For the `toMany` relationships,
    that is the default value, but for the `toOne` relationships, you should define
    it. `FetchType` defines the strategy for fetching data from the database. The
    value can be either `EAGER` or `LAZY`. In our case, the `LAZY` strategy means
    that when the owner is fetched from the database, the cars associated with the
    owner will be fetched *when needed*. `EAGER` means that the cars will be fetched
    immediately by the owner. The following source code shows how to define a one-to-many
    relationship in the `Car` class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一对多关系可以通过使用`@ManyToOne`和`@OneToMany`注解（`jakarta.persistence`）来添加。在包含外键的汽车实体类中，你必须使用`@ManyToOne`注解来定义关系。你还应该为所有者字段添加getter和setter。建议你为所有关联使用`FetchType.LAZY`。对于`toMany`关系，这是默认值，但对于`toOne`关系，你应该定义它。`FetchType`定义了从数据库获取数据的策略。值可以是`EAGER`或`LAZY`。在我们的情况下，`LAZY`策略意味着当所有者从数据库中检索时，与其关联的汽车将在需要时被检索。`EAGER`意味着汽车将立即由所有者检索。以下源代码显示了如何在`Car`类中定义一对多关系：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the owner entity site, the relationship is defined with the `@OneToMany`
    annotation. The type of field is `List<Car>` because an owner may have multiple
    cars. Add the getter and setter for this, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有者实体上，关系是通过`@OneToMany`注解定义的。字段的类型是`List<Car>`，因为一个所有者可能有多个汽车。添加相应的getter和setter，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `@OneToMany` annotation has two attributes that we are using. The `cascade`
    attribute defines how cascading affects the entities in the case of deletions
    or updates. The `ALL` attribute setting means that all operations are cascaded.
    For example, if the owner is deleted, the cars that are linked to that owner are
    deleted as well. The `mappedBy="owner"` attribute setting tells us that the `Car`
    class has the `owner` field, which is the foreign key for this relationship.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@OneToMany`注解有两个我们正在使用的属性。`cascade`属性定义了在删除或更新时级联如何影响实体。`ALL`属性设置意味着所有操作都会级联。例如，如果删除所有者，与该所有者关联的汽车也会被删除。`mappedBy="owner"`属性设置告诉我们`Car`类有一个`owner`字段，这是此关系的键。'
- en: 'When you run the project, by looking in the console, you will see that the
    relationship has been created:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你运行项目时，通过查看控制台，你会看到已经创建了关系：
- en: '![](img/B19818_03_16.png)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B19818_03_16.png)'
- en: 'Figure 3.16: Console'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.16：控制台
- en: 'Now, we can add some owners to the database with `CommandLineRunner`. Let’s
    also modify the `Car` entity class constructor and add an `owner` object there:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`CommandLineRunner`向数据库添加一些所有者。让我们也修改`Car`实体类构造函数，并在其中添加一个`owner`对象：
- en: '[PRE22]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we will create two owner objects and save these to the database using
    the repository’s `saveAll` method, which we can use to save multiple entities
    at once. To save the owners, we have to inject `OwnerRepository` into the main
    class. Then, we must connect the owners to the cars by using the `Car` constructor.
    First, let’s modify the `CardatabaseApplication` class by adding the following
    imports:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建两个所有者对象，并使用仓库的`saveAll`方法将它们保存到数据库中，我们可以使用该方法一次性保存多个实体。为了保存所有者，我们必须将`OwnerRepository`注入到主类中。然后，我们必须使用`Car`构造函数将所有者与汽车连接起来。首先，让我们通过添加以下导入来修改`CardatabaseApplication`类：
- en: '[PRE23]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let’s also inject `OwnerRepository` into the `CardatabaseApplication`
    class using constructor injection:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们也使用构造函数注入将`OwnerRepository`注入到`CardatabaseApplication`类中：
- en: '[PRE24]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, we must modify the `run` method to save owners and link owners
    and cars:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须修改`run`方法以保存所有者和将所有者与汽车关联：
- en: '[PRE25]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, if you run the application and fetch cars from the database, you will
    see that the owners are now linked to the cars:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你运行应用程序并从数据库中检索汽车，你会看到所有者现在与汽车关联了：
- en: '![](img/B19818_03_17.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_03_17.png)'
- en: 'Figure 3.17: OneToMany relationship'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17：OneToMany关系
- en: If you want to create a many-to-many relationship instead, which means, in practice,
    that an owner can have multiple cars and a car can have multiple owners, you should
    use the `@ManyToMany` annotation. In our example application, we will use a one-to-many
    relationship. The code that you have completed here will be needed in the next
    chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个多对多关系，这意味着在实践中，一个所有者可以有多个汽车，一辆汽车可以有多个所有者，你应该使用`@ManyToMany`注解。在我们的示例应用程序中，我们将使用一对多关系。你在这里完成的代码将在下一章中需要。
- en: 'Next, you will learn how to change the relationship to many-to-many. In a many-to-many
    relationship, it is recommended that you use `Set` instead of `List` with Hibernate:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何将关系更改为多对多。在多对多关系中，建议你使用`Set`而不是`List`与Hibernate一起使用：
- en: 'In the `Car` entity class’s many-to-many relationship, define the getters and
    setters in the following way:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Car`实体类的多对多关系中，定义getter和setter的方式如下：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `Owner` entity class, the many-to-many relationship is defined as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Owner`实体类中，多对多关系定义如下：
- en: '[PRE27]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, if you run the application, there will be a new **join table** called `car_owner`
    that is created between the car and owner tables. The join table is a special
    kind of table that manages the many-to-many relationship between two tables.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你运行应用程序，将在汽车和所有者表之间创建一个新的**连接表**，称为`car_owner`。连接表是一种特殊的表，用于管理两个表之间的多对多关系。
- en: 'The join table is defined by using the `@JoinTable` annotation. With this annotation,
    we can set the name of the join table and join columns. The following screenshot
    shows the database structure when using a many-to-many relationship:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接表是通过使用`@JoinTable`注解定义的。使用这个注解，我们可以设置连接表和连接列的名称。以下截图显示了使用多对多关系时的数据库结构：
- en: '![](img/B19818_03_18.png)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_18.png)'
- en: 'Figure 3.18: Many-to-many relationship'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.18：多对多关系
- en: 'Now, the database UML diagram looks as follows:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，数据库UML图如下所示：
- en: '![](img/B19818_03_19.png)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_19.png)'
- en: 'Figure 3.19: Many-to-many relationship'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.19：多对多关系
- en: We have used an in-memory H2 database in the chapter so far. In the next section,
    we will be using a one-to-many relationship, so *change your code back if you
    followed the previous many-to-many example*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在章节中使用了内存中的H2数据库。在下一节中，我们将使用一对多关系，所以如果你遵循了之前的多对多示例，*请将你的代码改回一对多关系*。
- en: Next, we are going to look at how to use a MariaDB database instead.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用MariaDB数据库。
- en: Setting up a MariaDB database
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置MariaDB数据库
- en: Now, we will switch the database we are using from H2 to MariaDB. H2 is a good
    database for test and demonstration purposes, but MariaDB is a better option for
    a proper production database when applications require performance, reliability,
    and scalability.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把正在使用的数据库从H2切换到MariaDB。H2是一个用于测试和演示的好数据库，但MariaDB在应用程序需要性能、可靠性和可伸缩性时，是一个更好的生产数据库选项。
- en: In this book, we are using MariaDB version 10\. The database tables are still
    created automatically by JPA. However, before we run our application, we have
    to create a database for it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用的是MariaDB版本10。数据库表仍然由JPA自动创建。然而，在我们运行应用程序之前，我们必须为它创建一个数据库。
- en: In this section, we will be using the one-to-many relationship from the previous
    section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用上一节中的一对多关系。
- en: 'The database can be created using HeidiSQL (or DBeaver, if you are using Linux
    or macOS). Open HeidiSQL and follow these steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库可以使用HeidiSQL（或如果你使用Linux或macOS，则使用DBeaver）创建。打开HeidiSQL并按照以下步骤操作：
- en: Activate the top database connection name (**Unnamed**) and right-click it.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活顶部的数据库连接名称（**未命名**）并右键单击。
- en: 'Then, select **Create new | Database**:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**创建新 | 数据库**：
- en: '![](img/B19818_03_20.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_20.png)'
- en: 'Figure 3.20: Create new database'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20：创建新数据库
- en: 'Let’s name our database `cardb`. After clicking **OK**, you should see the
    new `cardb` database in the database list:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们的数据库命名为`cardb`。点击**确定**后，你应该在数据库列表中看到新的`cardb`数据库：
- en: '![](img/B19818_03_21.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_21.png)'
- en: 'Figure 3.21: The cardb database'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21：cardb数据库
- en: 'In Spring Boot, add a MariaDB Java client dependency to the `build.gradle`
    file and remove the H2 dependency since we don’t need it anymore. Remember to
    refresh your Gradle project after you have modified your `build.gradle` file:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spring Boot中，将MariaDB Java客户端依赖项添加到`build.gradle`文件中，并删除H2依赖项，因为我们不再需要它了。记得在修改了`build.gradle`文件后刷新你的Gradle项目：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `application.properties` file, you must define the database connection
    for MariaDB. In this phase, you should remove the old H2 database settings. First,
    you must define the database’s URL, username, password (defined in *Chapter 1*),
    and database driver class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `application.properties` 文件中，你必须定义 MariaDB 的数据库连接。在这个阶段，你应该删除旧的 H2 数据库设置。首先，你必须定义数据库的
    URL、用户名、密码（在 *第一章* 中定义）和数据库驱动类：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we are using the database root user, but in production, you
    should create a user for your database that doesn’t have all root database rights.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用的是数据库 root 用户，但在生产环境中，你应该为你的数据库创建一个没有所有 root 数据库权限的用户。
- en: 'Add the `spring.jpa.generate-ddl` setting, which defines whether JPA should
    initialize the database (`true`/`false`). Also add the `spring.jpa.hibernate.ddl-auto`
    setting, which defines the behavior of the database initialization:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `spring.jpa.generate-ddl` 设置，它定义了 JPA 是否应该初始化数据库（`true`/`false`）。还要添加 `spring.jpa.hibernate.ddl-auto`
    设置，它定义了数据库初始化的行为：
- en: '[PRE30]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The possible values for `spring.jpa.hibernate.ddl-auto` are `none`, `validate`,
    `update`, `create`, and `create-drop`. The default value depends on your database.
    If you are using an embedded database such as H2, the default value is `create-drop`;
    otherwise, the default value is `none`. `create-drop` means that the database
    is created when an application starts, and it is dropped when the application
    is stopped. The `create` value only creates the database when the application
    is started. The `update` value creates the database and updates the schema if
    it has changed.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`spring.jpa.hibernate.ddl-auto` 的可能值有 `none`、`validate`、`update`、`create` 和
    `create-drop`。默认值取决于你的数据库。如果你使用的是嵌入式数据库，如 H2，则默认值为 `create-drop`；否则，默认值为 `none`。`create-drop`
    表示数据库在应用程序启动时创建，在应用程序停止时删除。`create` 值仅在应用程序启动时创建数据库。`update` 值在创建数据库的同时，如果模式已更改，则更新模式。'
- en: 'Check that the MariaDB database server is running and restart your Spring Boot
    application. After running the application, you should see the tables in MariaDB.
    You might have to refresh the database tree in HeidiSQL first by pressing the
    *F5* key. The following screenshot shows the HeidiSQL user interface once the
    database has been created:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 MariaDB 数据库服务器是否正在运行，并重新启动你的 Spring Boot 应用程序。运行应用程序后，你应该能在 MariaDB 中看到表格。你可能需要先通过按
    *F5* 键刷新 HeidiSQL 的数据库树。以下截图显示了创建数据库后的 HeidiSQL 用户界面：
- en: '![](img/B19818_03_22.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_03_22.png)'
- en: 'Figure 3.22: MariaDB cardb You can also run SQL queries in HeidiSQL.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22：MariaDB cardb 你也可以在 HeidiSQL 中运行 SQL 查询。
- en: Now, your application is ready to use with MariaDB.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的应用程序已经准备好与 MariaDB 一起使用了。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used JPA to create our Spring Boot application database.
    First, we created entity classes, which are mapped to database tables.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 JPA 创建了我们的 Spring Boot 应用程序数据库。首先，我们创建了实体类，它们映射到数据库表。
- en: Then, we created a `CrudRepository` for our entity class, which provides CRUD
    operations for the entity. After that, we managed to add some demo data to our
    database by using `CommandLineRunner`. We also created one-to-many relationships
    between two entities. At the beginning of this chapter, we used the H2 in-memory
    database, and we switched the database to MariaDB at the end.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们的实体类创建了一个 `CrudRepository`，它为实体提供了 CRUD 操作。之后，我们通过使用 `CommandLineRunner`
    成功地向我们的数据库添加了一些示例数据。我们还创建了两个实体之间的一对多关系。在本章的开始，我们使用了 H2 内存数据库，并在本章的结尾将数据库切换到了 MariaDB。
- en: In the next chapter, we will create a RESTful web service for our backend. We
    will also look at testing the RESTful web service with the cURL command-line tool
    and the Postman GUI.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的后端创建一个 RESTful Web 服务。我们还将探讨使用 cURL 命令行工具和 Postman 图形用户界面测试 RESTful
    Web 服务。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are ORM, JPA, and Hibernate?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ORM、JPA 和 Hibernate 是什么？
- en: How can you create an entity class?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个实体类？
- en: How can you create a `CrudRepository`?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个 `CrudRepository`？
- en: What does a `CrudRepository` provide for your application?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CrudRepository` 为你的应用程序提供了什么？'
- en: How can you create a one-to-many relationship between tables?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在一对多关系之间创建表？
- en: How can you add demo data to a database with Spring Boot?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 Spring Boot 向数据库添加示例数据？
- en: How can you access the H2 console?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何访问 H2 控制台？
- en: How can you connect your Spring Boot application to MariaDB?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何将你的 Spring Boot 应用程序连接到 MariaDB？
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Packt has other resources for learning more about MariaDB, Hibernate, and JPA:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Packt 提供了其他关于 MariaDB、Hibernate 和 JPA 的学习资源：
- en: '*Getting Started with MariaDB*, by Daniel Bartholomew ([https://www.packtpub.com/product/getting-started-with-mariadb/9781785284120](https://www.packtpub.com/product/getting-started-with-mariadb/9781785284120))'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*从入门到精通 MariaDB*》，作者 Daniel Bartholomew ([https://www.packtpub.com/product/getting-started-with-mariadb/9781785284120](https://www.packtpub.com/product/getting-started-with-mariadb/9781785284120))
- en: '*Master Hibernate and JPA with Spring Boot in 100 Steps [Video]*, by In28Minutes
    Official ([https://www.packtpub.com/product/master-hibernate-and-jpa-with-spring-boot-in-100-steps-video/9781788995320](https://www.packtpub.com/product/master-hibernate-and-jpa-with-spring-boot-in-100-steps-video/9781788995320))'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*100 步掌握 Spring Boot 中的 Hibernate 和 JPA [视频]*》，作者 In28Minutes Official ([https://www.packtpub.com/product/master-hibernate-and-jpa-with-spring-boot-in-100-steps-video/9781788995320](https://www.packtpub.com/product/master-hibernate-and-jpa-with-spring-boot-in-100-steps-video/9781788995320))
- en: Learn more on Discord
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code107961080093826401.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code107961080093826401.png)'
