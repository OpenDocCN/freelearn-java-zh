- en: Profiling and Logging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析和日志记录
- en: In the previous chapter, we dove into the details of multithreading and concurrent
    programming. We looked at the `java.util.concurrent` package API. The chapter
    covered thread pooling for asynchronous programming, Spring task execution, scheduling,
    and Spring Async API. In the latter part of the chapter, we compared Spring Async
    with `CompletableFuture`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入研究了多线程和并发编程的细节。我们查看了`java.util.concurrent`包的API。本章涵盖了用于异步编程的线程池、Spring任务执行、调度和Spring
    Async API。在本章的后半部分，我们将Spring Async与`CompletableFuture`进行了比较。
- en: Along similar lines, this chapter will focus on profiling and logging. This
    chapter starts by defining profiling and logging, and how they are useful for
    assessing application performance. In the latter part of the chapter, the focus
    will be on learning about software tools that can be used to study application
    performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，本章将重点关注分析和日志记录。本章首先定义了分析和日志记录，以及它们如何有助于评估应用程序性能。在本章的后半部分，重点将放在学习可以用来研究应用程序性能的软件工具上。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Performance profiling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Application logging and monitoring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序日志记录和监控
- en: Profiling tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析工具
- en: Performance profiling
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: 'This section will focus on performance and application profiling for performance
    measurement. Profiling is an important step in any application development and
    deployment life cycle. It helps us to perform the following two things:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点关注性能和应用程序性能分析。分析是应用程序开发和部署生命周期中的重要步骤。它帮助我们执行以下两件事：
- en: Defining a benchmark for expected performance outcomes
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义预期性能结果的基准
- en: Measuring and comparing the current performance outcome against benchmarks
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 衡量并比较当前性能结果与基准
- en: The second step defines further actions to be taken, in order to take performance
    to the benchmark level.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步定义了进一步的行动，以将性能提升到基准水平。
- en: Application performance
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序性能
- en: Performance means different things to different people when used in terms of
    software applications. It must have some context for better understanding. Application
    performance is measured against two sets of performance metrics. The actual performance
    observed or experienced by the application users remains one of the most important
    metrics for measuring application performance. It includes the average response
    time during peak and normal loads. Measurements related to average response time
    include the time taken by the application to respond to a user's action, such
    as a page refresh, navigation, or a button click. They also include the time taken
    to perform certain operations, such as sorting, searching for, or loading data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 性能在软件应用程序方面对不同的人有不同的含义。它必须有一些上下文才能更好地理解。应用程序性能根据两组性能指标进行衡量。应用程序用户实际观察或体验到的性能仍然是衡量应用程序性能的最重要指标之一。这包括在高峰和正常负载期间的平均响应时间。与平均响应时间相关的测量包括应用程序响应用户操作（例如页面刷新、导航或按钮点击）所需的时间。它们还包括执行某些操作（例如排序、搜索或加载数据）所需的时间。
- en: This section is meant to provide technical teams a perspective on some of the
    aspects of configurations and internals that can be set or altered to optimize
    effects, in order to improve the performance of the application. In usual cases,
    technical teams never keep an eye on the memory that the application uses or the
    CPU utilization unless they are stuck with a performance issue. Application transactions
    include requests received by the application per second, database transactions
    per second, and pages served per second. The load on the system is usually measured
    in terms of volume of transactions that the application processes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在为技术团队提供一些配置和内部方面的视角，这些配置和内部方面可以进行设置或更改，以优化效果，从而提高应用程序的性能。通常情况下，技术团队在没有遇到性能问题时很少关注应用程序使用的内存或CPU利用率。应用程序事务包括应用程序每秒接收的请求、每秒数据库事务和每秒提供的页面。系统的负载通常是以应用程序处理的交易量来衡量的。
- en: There is another set of measurements that involves measuring the computational
    resources utilized by the application while performing operations. It is a very
    good way of identifying whether the application has enough resources to sustain
    the given load. It also helps in identifying whether the application utilizes
    more resources than it is expected to. If so, it can be concluded that the application
    is not optimized on the performance side. Cloud-hosted applications are popular
    these days. In this era, it is important for users to have the same experiences
    on applications deployed over the cloud or a non-cloud infrastructure, and on
    the local environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一组测量，涉及测量应用程序在执行操作时所利用的计算资源。这是一个很好的方法，可以确定应用程序是否有足够的资源来承受给定的负载。它还有助于确定应用程序是否利用的资源超出了预期。如果是这样，可以得出结论应用程序在性能方面没有进行优化。云托管应用程序如今很受欢迎。在这个时代，用户在云端部署的应用程序、非云基础设施上以及本地环境上应该有相同的体验是很重要的。
- en: Application performance monitoring and improvements may not be necessary for
    an application, as long as it performs per expectations. However, as part of the
    application development life cycle, new requirements come up, new features are
    added, and the application becomes more complex by the day. This starts impacting
    the application's performance, as the main focus is kept on new feature development.
    A time will come when the performance is not up to marks, because no one actually
    works on application performance enhancement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 只要应用程序按预期运行，应用程序性能监控和改进可能并不是必要的。然而，在应用程序开发生命周期的一部分，会出现新的需求，添加新功能，并且应用程序变得日益复杂。这开始影响应用程序的性能，因为主要关注点放在了新功能开发上。当性能达不到标准时，因为没有人真正致力于应用程序性能的提升。
- en: Application logging and monitoring
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序日志记录和监控
- en: This section focuses on logging important information while the application
    is running. It helps to debug the application from various aspects, which we will
    look at in detail. Another important aspect covered in this section is application
    monitoring. In some cases, application monitoring is considered no different from
    application profiling; these are certainly different aspects in application performance
    measurement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点关注应用程序运行时记录重要信息。它有助于从各个方面调试应用程序，我们将详细了解。本节涵盖的另一个重要方面是应用程序监控。在某些情况下，应用程序监控被认为与应用程序性能分析没有区别；这些在应用程序性能测量中肯定是不同的方面。
- en: Application logging
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序日志
- en: Before we dive into the details of Java application logging, it is mandatory
    to understand what logs and logging are. A **log** is a statement that displays
    information to help us understand the state of the application. Log statements
    are written in the log files, in an application-specific format. The log statements
    may include information such as the date and time of execution of a particular
    statement, the values of various variables, and the states of the objects. The
    process of writing log statements to log files is known as **logging**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解Java应用程序日志的细节之前，了解日志和记录是强制性的。**日志**是显示信息以帮助我们了解应用程序状态的语句。日志语句以应用程序特定的格式写入日志文件。日志语句可能包括诸如特定语句执行的日期和时间、各种变量的值以及对象的状态等信息。将日志语句写入日志文件的过程称为**记录**。
- en: Every application produces logs for various purposes. Applications produce logs
    to keep track of application events, including access-related events, login and
    logout events, events when errors occur in an application, and system configuration
    modifications. Operating systems also produce log files. Log files can be processed
    to bifurcate required information. Logging is one of the most fundamental parts
    of software applications. A well-written log and well-designed logging mechanism
    become a huge utility for developers and administrators. It is most useful to
    teams working on application support activities. Well, designed logging saves
    a lot of time for development and support teams. As the frontend programs are
    executed, the system builds log files in an invisible manner.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都会出于各种目的生成日志。应用程序生成日志以跟踪应用程序事件，包括与访问相关的事件、登录和注销事件、应用程序发生错误时的事件以及系统配置修改。操作系统也会生成日志文件。日志文件可以被处理以分离所需的信息。**记录**是软件应用程序中最基本的部分之一。良好编写的日志和良好设计的记录机制对开发人员和管理员来说是巨大的实用工具。对于从事应用程序支持活动的团队来说，这是非常有用的。良好设计的记录可以为开发和支持团队节省大量时间。随着前端程序的执行，系统以一种隐形的方式构建日志文件。
- en: 'The following are common log files, usually generated in applications:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通常在应用程序中生成的常见日志文件：
- en: '**Error/Exception logs**: Any unexpected situation in an application flow is
    termed as an **error**. Errors may occur for different reasons. Errors are categorized
    based on severity and impact on the application. If the user cannot proceed further
    in the application, such an error is categorized as a **blocker**. If the web
    page does not have an appropriate label, it is categorized as a low severity issue.
    An error log is a recording of critical errors that have occurred while the application
    is executing. An application without errors virtually doesn''t exist. In Java,
    it is not required to log all exceptions. Java supports managed exceptions, which
    can be taken care of and thrown as a warning or error message to the user. This
    could be a validation error or a user input error, which can be thrown using managed
    exceptions.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误/异常日志**：应用程序流程中的任何意外情况都被称为**错误**。错误可能出现的原因各不相同。错误根据严重性和对应用程序的影响进行分类。如果用户无法在应用程序中继续操作，这样的错误被归类为**阻塞**。如果网页没有适当的标签，它被归类为低严重性问题。错误日志是应用程序执行时发生的关键错误的记录。几乎不存在没有错误的应用程序。在Java中，不需要记录所有异常。Java支持受控异常，可以加以处理并作为警告或错误消息抛出给用户。这可能是验证错误或用户输入错误，可以使用受控异常抛出。'
- en: '**Access logs**: At an abstract level, any request that comes to a web application
    can be considered a request to access a resource on the web application server.
    The resource could be a web page, a PDF file on the server, an image file, or
    a report from the data in the database. From a security point of view, every resource
    must be protected by access rights. Access rights define who can access the resource
    from the web application. Access logs are written information on who tried to
    access which resource. They may also include information about the location from
    which the resource was accessed. Access logs write access information for every
    request coming into the web application. Access logs can also be used to find
    information about the number of visitors, the number of visitors accessing the
    application for the first time, the number of visitors from a specific location,
    the number of requests for a particular page, and the application usage patterns.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问日志**：在抽象层面上，任何发送到Web应用程序的请求都可以被视为对Web应用程序服务器上资源的请求。资源可以是Web页面、服务器上的PDF文件、图像文件或数据库中数据的报告。从安全性的角度来看，每个资源都必须受到访问权限的保护。访问权限定义了谁可以从Web应用程序访问资源。访问日志是关于谁尝试访问哪个资源的书面信息。它们还可能包括有关访问资源的位置的信息。访问日志为进入Web应用程序的每个请求写入访问信息。访问日志还可以用于查找有关访问者数量、首次访问应用程序的访问者数量、特定位置的访问者数量、特定页面的请求数量以及应用程序使用模式的信息。'
- en: '**Transaction logs**: Transactions are related to databases. A sequence of
    database commands or statements executed in order to maintain atomicity and database
    integrity is known as a **transaction**. Transactions are maintained to guarantee
    protection over crashes or failures. A **transaction log** is a file where all
    such transactions are recorded or written. At a particular time, if the database
    is found to be inconsistent, then transaction logs become helpful in debugging
    the issue. Transaction logs can also be used to record any rollback operations
    performed. Usually, transaction logs also record the time of database statements
    to execute, along with passed in parameters. This information is very helpful
    in profiling database performance issues.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务日志**：事务与数据库相关。为了保持原子性和数据库完整性而执行的一系列数据库命令或语句被称为**事务**。事务用于保证在崩溃或故障时的保护。**事务日志**是记录或写入所有这些事务的文件。在特定时间，如果发现数据库不一致，那么事务日志在调试问题时会有所帮助。事务日志还可以用于记录执行的任何回滚操作。通常，事务日志还记录数据库语句的执行时间以及传递的参数。这些信息对于分析数据库性能问题非常有帮助。'
- en: '**Audit logs**: **Auditing** is the process of inspecting how the application
    is used. It inspects the application resources being used, the users who access
    or use application resources, and the authentication and authorization information
    for the users. The **audit log** records every event that the application passes
    through, along with the previously mentioned details.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计日志**：**审计**是检查应用程序的使用情况的过程。它检查正在使用的应用程序资源，访问或使用应用程序资源的用户以及用户的身份验证和授权信息。**审计日志**记录应用程序通过的每个事件，以及前面提到的详细信息。'
- en: Logging best practices
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录最佳实践
- en: 'Having described what should be logged and common logging information, this
    section details the best practices for logging:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了应该记录的内容和常见的日志信息之后，本节详细介绍了日志记录的最佳实践：
- en: It is very important to assign appropriate log levels to each of the log statements.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个日志语句分配适当的日志级别非常重要。
- en: Logging should also be considered in a cluster environment. We can use the same
    type of log files, with the cluster node name as a suffix to the filename. This
    will prevent the log entries from being overwritten or wrongly considered when
    analyzing logs.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集群环境中也应考虑日志记录。我们可以使用相同类型的日志文件，文件名后缀为集群节点名称。这将防止在分析日志时覆盖或错误地考虑日志条目。
- en: Building log files impacts the application's performance. If an application
    starts logging every minor piece of information, the application's performance
    will be slow. We must ensure that the size of the log files and frequency of writing
    log entries are low.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建日志文件会影响应用程序的性能。如果应用程序开始记录每个细小的信息，应用程序的性能将变慢。我们必须确保日志文件的大小和写入日志条目的频率较低。
- en: All exceptions, except for validations and input errors, must be logged. The
    exception messages must be logged in a way that highlights the problems clearly.
    The best practice is to let the framework log all of the exceptions.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了验证和输入错误之外，所有异常都必须记录。异常消息必须以清晰地突出问题的方式记录。最佳实践是让框架记录所有异常。
- en: Logs must be user-friendly and easily parsed. Logs can be used in two ways.
    One way is that the users read the logs to build understanding. Another way is
    that the utility programs parse the application logs, based on the log formats,
    to filter out unimportant information.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志必须用户友好且易于解析。日志可以以两种方式使用。一种方式是用户阅读日志以建立理解。另一种方式是实用程序根据日志格式解析应用程序日志，以过滤掉不重要的信息。
- en: Every log entry must be different from other log entries, though they represent
    the same information. Every log entry can have a unique identifier, most often
    based on the timestamp, which can be used to differentiate it from other logs.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个日志条目必须与其他日志条目不同，尽管它们代表相同的信息。每个日志条目都可以有一个唯一的标识符，通常基于时间戳，可以用来区分它与其他日志。
- en: Sensitive information must not be logged in log files. Passwords, credentials,
    and authentication keys are a few examples.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应在日志文件中记录敏感信息。密码、凭据和身份验证密钥是一些例子。
- en: In most cases, best practices work as general guidelines and can be followed
    in a customized manner, based on the project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最佳实践作为一般指导方针，并可以根据项目以定制化的方式进行遵循。
- en: Logging tools
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录工具
- en: In the preceding sections of this chapter, we learned about the importance of
    logging. We also learned logging best practices. Now is the time to add logging
    tools to our skill sets. This section focuses on logging tools. Logging tools
    are helpful because of the features they provide. In the past, log files consisted
    of log statements, written in a plain text format. Plain text log files are still
    useful in specific situations, like analyzing infrastructure data, but they are
    no longer sufficient in logging information for an application. Java has built-in
    support for standard logging in the `java.util.logging` API. Log4j is another
    well-known and widely used logging tool in the Java community.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们了解了日志记录的重要性。我们还学习了日志记录的最佳实践。现在是时候将日志记录工具添加到我们的技能集中了。本节重点介绍日志记录工具。日志记录工具很有帮助，因为它们提供了各种功能。在过去，日志文件由以纯文本格式编写的日志语句组成。纯文本日志文件在特定情况下仍然有用，比如分析基础设施数据，但它们已经不再足以记录应用程序的信息。Java内置支持`java.util.logging`
    API的标准日志记录。Log4j是Java社区中另一个知名且广泛使用的日志记录工具。
- en: 'Before we jump into the details of logging tools, it is important to understand
    the key elements of the logging mechanism. The following are key logging components:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解日志工具的细节之前，了解日志机制的关键要素是很重要的。以下是关键的日志记录组件：
- en: '**Log Level**: The Java logging levels are used to control the logging output.
    They provide flexibility in enabling or disabling the various logging levels.
    This makes it possible to choose which logs will be displayed in the log files.
    With this, it is possible that the application running on the production has a
    different logging level than the same application running on the staging environment.
    Enabling one level of logging will make all higher-level logs enabled for printing
    in the log files. The following are the log levels and effective logging levels
    for the Java logging API:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志级别：** Java日志级别用于控制日志输出。它们提供了在启用或禁用各种日志级别方面的灵活性。这使得可以选择在日志文件中显示哪些日志。通过这种方式，可能在生产环境中运行的应用程序与在暂存环境中运行的相同应用程序具有不同的日志级别。启用一个级别的日志将使所有更高级别的日志在日志文件中打印。以下是Java日志记录API的日志级别和有效日志级别：'
- en: '| **Request level** | **Effective logging level** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **请求级别** | **有效日志级别** |'
- en: '| `SEVERE` | `WARNING` | `INFO` | `CONFIG` | `FINE` | `FINER` | `FINEST` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `SEVERE` | `WARNING` | `INFO` | `CONFIG` | `FINE` | `FINER` | `FINEST` |'
- en: '| `SEVERE` | Yes | Yes | Yes | Yes | Yes | Yes | Yes |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `SEVERE` | 是 | 是 | 是 | 是 | 是 | 是 | 是 |'
- en: '| `WARNING` | No | Yes | Yes | Yes | Yes | Yes | Yes |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `WARNING` | 否 | 是 | 是 | 是 | 是 | 是 | 是 |'
- en: '| `INFO` | No | No | Yes | Yes | Yes | Yes | Yes |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | 否 | 否 | 是 | 是 | 是 | 是 | 是 |'
- en: '| `CONFIG` | No | No | No | Yes | Yes | Yes | Yes |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `CONFIG` | 否 | 否 | 否 | 是 | 是 | 是 | 是 |'
- en: '| `FINE` | No | No | No | No | Yes | Yes | Yes |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `FINE` | 否 | 否 | 否 | 否 | 是 | 是 | 是 |'
- en: '| `FINER` | No | No | No | No | No | Yes | Yes |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `FINER` | 否 | 否 | 否 | 否 | 否 | 是 | 是 |'
- en: '| FINEST | No | No | No | No | No | No | Yes |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| FINEST | 否 | 否 | 否 | 否 | 否 | 否 | 是 |'
- en: '**Logger**: The job of the `Logger` object is to log application messages.
    The application can create anonymous loggers, which are stored differently than
    in the `Logger` namespace. The application must be sure to keep a reference to
    the `Logger` object, as the `Logger` may get garbage collected at any point in
    time. The `Logger` object is associated with a parent `Logger` object, which is
    the nearest ancestor in `Logger` namespace. During the logging process, log messages
    are sent to `Handler` objects. The `Handler` objects forward the log messages
    to files, logs, or consoles. Every `Logger` object has a log level associated
    with it. It indicates the minimum level `Logger` will print logs for.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Logger：** `Logger`对象的工作是记录应用程序消息。应用程序可以创建匿名记录器，这些记录器与`Logger`命名空间中的记录器存储方式不同。应用程序必须确保保留对`Logger`对象的引用，因为`Logger`可能随时被垃圾回收。`Logger`对象与父`Logger`对象相关联，父对象是`Logger`命名空间中最近的祖先。在记录过程中，日志消息被发送到`Handler`对象。`Handler`对象将日志消息转发到文件、日志或控制台。每个`Logger`对象都有与之关联的日志级别。它指示`Logger`将为其打印日志的最低级别。'
- en: '**Handler**: The responsibility of a `Handler` object is to get log messages
    from `Logger` objects, and send those log messages for printing to the appropriate
    destination. Examples include writing the log messages on the console, writing
    the log messages into a file, or writing the log messages to a network logging
    service. It is possible to enable or disable a `Handler`, which, in essence, stops
    printing those logs on the output medium.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理程序：** `Handler`对象的责任是从`Logger`对象获取日志消息，并将这些日志消息发送到适当的目的地进行打印。例如，将日志消息写入控制台、将日志消息写入文件或将日志消息写入网络日志记录服务。可以启用或禁用`Handler`，从本质上讲，这会停止在输出介质上打印这些日志。'
- en: '**Formatter:** The log `Formatter` formats the log messages before writing
    them to the output medium. Java supports two types of `Formatter` objects: `SimpleFormatter`
    and `XMLFormatter`. The `XMLFormatter` object is required to include a head and
    tail around formatted records. It is also possible to create custom `Formatter`
    objects.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式化程序：** 日志`Formatter`在将日志消息写入输出介质之前对其进行格式化。Java支持两种类型的`Formatter`对象：`SimpleFormatter`和`XMLFormatter`。`XMLFormatter`对象需要在格式化记录周围包含头和尾。还可以创建自定义的`Formatter`对象。'
- en: '**LogManager:** `LogManager` is a singleton object, used to maintain a shared
    state of loggers and log services. Apart from this, the `LogManager` object manages
    logging properties and the `Logger` namespace. The `LogManager` object is instantiated
    while class initialization takes place. The object cannot be subsequently changed. `LogManager`
    reads the initial configuration from the `lib/logging.properties` file by default,
    which can be modified.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogManager：** `LogManager`是一个单例对象，用于维护日志记录器和日志服务的共享状态。除此之外，`LogManager`对象还管理日志记录属性和`Logger`命名空间。`LogManager`对象在类初始化时被实例化。对象不能随后更改。`LogManager`默认从`lib/logging.properties`文件中读取初始配置，该文件可以进行修改。'
- en: 'The following diagram shows the logging process with one `Handler`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了具有一个`Handler`的日志记录过程：
- en: '![](img/e1514066-4a73-4e46-a089-666099b86b62.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1514066-4a73-4e46-a089-666099b86b62.jpg)'
- en: 'The following diagram shows the logging process with multiple handlers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了具有多个处理程序的日志记录过程：
- en: '![](img/7f4ab92e-aa5a-4dd1-a80e-423270789732.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f4ab92e-aa5a-4dd1-a80e-423270789732.jpg)'
- en: Java standard logging
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java标准日志记录
- en: This section explains Java's built-in logging mechanism. The Java logging API
    is comprised of the `java.util.logging` package. The core package includes support
    for writing plain text or XML log entries to output streams, files, memory, the
    console, or sockets. The logging API is also capable of interacting with already
    existing logging services on the operating system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了Java的内置日志记录机制。Java日志记录API由`java.util.logging`包组成。核心包包括支持将纯文本或XML日志条目写入输出流、文件、内存、控制台或套接字。日志API还能够与操作系统上已存在的日志记录服务进行交互。
- en: 'The following code example is used for printing log messages using the standard
    logging API:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例用于使用标准日志记录API打印日志消息：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is an example of the `logging.properties` file referenced in
    the preceding code example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面示例中引用的`logging.properties`文件的示例：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output after executing the preceding example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面示例后的输出如下：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The benefit of using Java standard logging is that you don''t need separate
    JAR dependencies to be installed in the project. Though logging is related to
    troubleshooting issues that we come across on servers, we also have to make sure
    that logging does not impact the application performance in a negative way. The
    following points must be taken care of to make sure that logging does not impact
    application performance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java标准日志记录的好处是，您不需要安装项目中的单独的JAR依赖项。尽管日志记录与我们在服务器上遇到的故障排除问题有关，但我们还必须确保日志记录不会以负面方式影响应用程序性能。必须注意以下几点，以确保日志记录不会影响应用程序性能：
- en: '`Logger.log` methods are used to print log records on the output medium via
    a `Handler`. We can use `Logger.isLoggable` to ensure that `Logger` is enabled
    for the log level. If we pass a custom object as an argument to the `Logger.log`
    method, the `toString` method of the custom object is called from deep inside
    of the library classes. So, if we want to perform heavy operations in order to
    prepare an object for logging, we should do that from either within the block
    which checks `Logger.isLoggable`, or from within the object''s `toString` method.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logger.log`方法用于通过`Handler`在输出介质上打印日志记录。我们可以使用`Logger.isLoggable`来确保`Logger`已启用日志级别。如果我们将自定义对象作为参数传递给`Logger.log`方法，则将从库类的深处调用自定义对象的`toString`方法。因此，如果我们想要执行繁重的操作以准备对象进行日志记录，我们应该在检查`Logger.isLoggable`的块内部，或者在对象的`toString`方法内部执行。'
- en: We must not call the `toString` method on any object to get the log message
    contents. We must not pass the `toString` method call as an argument to `Logger.log`,
    either. The `Logger` object and logging framework take care of calling the `toString`
    method on a custom object.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得调用任何对象的`toString`方法以获取日志消息内容。我们也不得将`toString`方法调用作为参数传递给`Logger.log`。`Logger`对象和日志记录框架负责调用自定义对象的`toString`方法。
- en: The mixing of format string concatenation and log arguments must be avoided.
    It is possible for an application user with wrong intentions to break the log
    and access data that is not permitted to the user using a malicious concatenated
    string.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须避免格式字符串连接和日志参数的混合。应用程序用户可能会以错误的意图破坏日志并访问用户未被允许访问的数据，使用恶意连接的字符串是可能的。
- en: One of the major drawbacks of Java standard logging is comparative performance.
    Standard logging takes more time as compared to other Java-based logging frameworks,
    like Apache Log4j 2, commons logging, or **Simple Logging Facade for Java** (**SLF4J**).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Java标准日志记录的一个主要缺点是性能比较低。标准日志记录所需的时间比其他基于Java的日志记录框架（如Apache Log4j 2、commons
    logging或**Simple Logging Facade for Java**（**SLF4J**））更长。
- en: Apache Log4j 2
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Log4j 2
- en: Apache Log4j is one of the most widely used logging frameworks in the Java community.
    It is written in Java and distributed under the Apache software license. Apache
    Log4j 2 is the revision of an earlier version. The most notable features include
    thread safety, performance optimization, a named logger hierarchy, and internationalization
    support.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Log4j是Java社区中最广泛使用的日志记录框架之一。它是用Java编写的，并在Apache软件许可下分发。Apache Log4j 2是早期版本的修订版。最显著的功能包括线程安全性、性能优化、命名记录器层次结构和国际化支持。
- en: 'In order to set up Log4j 2, the following Maven dependencies must be added
    in the Maven `pom.xml` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置Log4j 2，必须在Maven `pom.xml`文件中添加以下Maven依赖项：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In order to gain access to the context rule that is required for testing of
    the named configuration files, we must include the `test` JAR, along with the
    main `log4j-core` package.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得测试命名配置文件所需的上下文规则，我们必须在Maven `pom.xml`文件中包含`test` JAR，以及主要的`log4j-core`包。
- en: 'Log4j 2 has three major logging components:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Log4j 2有三个主要的日志记录组件：
- en: '`Loggers`**:** The `Loggers` are responsible for capturing logging information.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Loggers`**：**`Loggers`负责捕获日志信息。'
- en: '`Appenders`**:** These are similar to that of the `Handler` objects in Java
    standard logging. `Appenders` are responsible for broadcasting logging information
    or messages to configured output mediums.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Appenders`**：**这些与Java标准日志记录中的`Handler`对象类似。`Appenders`负责将日志信息或消息广播到配置的输出介质。'
- en: '`Layouts`**:** The `Layouts` are responsible for formatting the log messages
    into configured styles.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Layouts`**：**`Layouts`负责将日志消息格式化为配置的样式。'
- en: 'The following is an example of the `log4j2.xml` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`log4j2.xml`文件的示例：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is an example of Log4j 2 Java code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Log4j 2 Java代码示例：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we execute the preceding example, the following output is produced:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述示例时，将产生以下输出：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Apache Log4j 2 has additional log levels, beyond common log levels. These are
    `ALL` and `OFF` levels. The `ALL` log level is used when we want to enable logs
    at `ALL` log levels. If the `ALL` log level is configured, while the levels are
    not considered. The `OFF` log level is the opposite of the `ALL` log level. It
    disables all logging.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Log4j 2具有超出常见日志级别的额外日志级别。这些是`ALL`和`OFF`级别。当我们想要启用`ALL`日志级别时，使用`ALL`日志级别。如果配置了`ALL`日志级别，则不考虑级别。`OFF`日志级别是`ALL`日志级别的相反。它禁用所有日志记录。
- en: Application monitoring
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序监控
- en: As discussed earlier, application performance is considered one of the most
    important milestones in any software application life cycle. It is also required
    that the application performs well consistently. This is one of the ways that
    we can ensure that application users will have the best experience with the application.
    It also means that the application is up and running well. An application performance
    monitoring tool tracks every request and response coming in and out of the application,
    processes information from the requests, and responds and displays in a graphical
    user interface. It means monitoring tools provide the administrators with the
    data necessary for quickly discovering, isolating, and solving problems impacting
    the performance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序性能被认为是任何软件应用程序生命周期中最重要的里程碑之一。还需要应用程序能够持续良好地运行。这是我们确保应用程序用户将获得最佳体验的一种方式。这也意味着应用程序正常运行。应用程序性能监控工具跟踪应用程序中进出的每个请求和响应，处理来自请求的信息，并在图形用户界面中响应和显示。这意味着监控工具为管理员提供了快速发现、隔离和解决影响性能的问题所需的数据。
- en: The monitoring tools usually collect data about CPU utilization, memory requirements,
    bandwidth, and throughput. It is possible to have multiple monitoring systems
    for disparate monitoring. One of the important aspects of any application performance
    monitoring is to combine data from such monitoring systems into a statistical
    analysis engine and display it on a dashboard. The dashboard makes it easy to
    read the data logs for analysis. Application monitoring tools help administrators
    monitor application servers in order to comply with **service level agreements**
    (**SLA**). Business rules are set to send administrators an alert in the event
    of a problem. This ensures that business-critical features and applications are
    considered with higher priority. With the fast changing environments, it has become
    very important to have rapid deployments in production systems. Rapid deployments
    mean more chances to introduce errors impacting system architecture or to slow
    the system down.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 监控工具通常收集有关CPU利用率、内存需求、带宽和吞吐量的数据。可以为不同的监控系统设置多个监控系统。任何应用程序性能监控的重要方面之一是将这些监控系统的数据合并到统计分析引擎中，并在仪表板上显示。仪表板使数据日志易于阅读和分析。应用程序监控工具帮助管理员监控应用程序服务器，以便遵守**服务级别协议**（**SLA**）。设置业务规则以在出现问题时向管理员发送警报。这确保了业务关键功能和应用程序被视为更高优先级。在快速变化的环境中，快速部署在生产系统中变得非常重要。快速部署意味着引入影响系统架构的错误或减慢系统运行的机会更多。
- en: Many implementations and tools are available based on these basic concepts.
    There is a huge and crowded market for application monitoring tools, including
    industry-leading and well-known tools like AppDynamics, New Relic, and Dynatrace.
    Apart from these known tools, there also exist open source application monitoring
    tools. The open source tools include Stagemonitor, Pinpoint, MoSKito, Glowroot,
    Kamon, and many more. We will look at each of these tools in detail in the following
    sections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些基本概念，有许多实现和工具可用。应用程序监控工具市场庞大而拥挤，包括行业领先和知名工具，如AppDynamics、New Relic和Dynatrace。除了这些知名工具，还存在开源应用程序监控工具。开源工具包括Stagemonitor、Pinpoint、MoSKito、Glowroot、Kamon等。我们将在以下部分详细介绍这些工具。
- en: Stagemonitor
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stagemonitor
- en: Stagemonitor has a monitoring agent built with support for clustered application
    stacks. The purpose of the tool is to monitor applications running on a number
    of servers, which is a usual production scenario. Stagemonitor is optimized for
    integration with time series databases. It is optimized for time series data management,
    which includes arrays of numbers, indexed by time. Such databases include elasticsearch,
    graphite, and InfluxDB. Stagemonitor can also be set up in private networks. It
    uses the open tracking API to correlate requests in distributed systems. It features
    defining thresholds for the metrics. Stagemonitor also supports creating new plugins
    and integrating third-party plugins.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Stagemonitor具有支持集群应用程序堆栈的监控代理。该工具的目的是监控在多台服务器上运行的应用程序，这是一个常见的生产场景。Stagemonitor经过优化，可与时间序列数据库集成。它经过优化，用于时间序列数据管理，包括按时间索引的数字数组。这些数据库包括elasticsearch、graphite和InfluxDB。Stagemonitor也可以在私有网络中设置。它使用开放跟踪API来关联分布式系统中的请求。它具有定义指标阈值的功能。Stagemonitor还支持创建新插件和集成第三方插件。
- en: Stagemonitor contains a Java-based agent. The agent sits in the Java application.
    The agent connects to the central database and sends metrics and request traces
    and statistics. Stagemonitor requires one instance for monitoring all applications,
    instances, and hosts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Stagemonitor包含一个基于Java的代理。代理位于Java应用程序中。代理连接到中央数据库，并发送指标、请求跟踪和统计信息。Stagemonitor需要一个实例来监控所有应用程序、实例和主机。
- en: In the browser, on the monitoring side, we can see historical or current data
    from the cluster. We can also create custom alerts. It is also possible to define
    a threshold for each metric. Stagemonitor has a dashboard. The dashboard is utilized
    for visualizing and analyzing different metrics and requests of interest. Stagemonitor
    supports creating custom dashboards, writing custom plugins, and using third-party
    plugins. It has in-browser widget support, as well. The widget does not require
    a backend and is injected automatically into the monitored web page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，在监控端，我们可以看到集群的历史或当前数据。我们还可以创建自定义警报。还可以为每个指标定义阈值。Stagemonitor有一个仪表板。该仪表板用于可视化和分析不同的感兴趣的指标和请求。Stagemonitor支持创建自定义仪表板、编写自定义插件和使用第三方插件。它还支持浏览器小部件，而无需后端，并自动注入到受监视的网页中。
- en: 'Following is the screenshot of Stagemonitor dashboard for reference:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Stagemonitor仪表板的屏幕截图供参考：
- en: '![](img/d0794e01-e0a1-4ea6-960f-75e0265f5883.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0794e01-e0a1-4ea6-960f-75e0265f5883.jpg)'
- en: 'The Stagemonitor dashboard view (source: http://www.stagemonitor.org/)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Stagemonitor仪表板视图（来源：http://www.stagemonitor.org/）
- en: Pinpoint
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pinpoint
- en: Pinpoint is different from Stagemonitor, in that it was developed with large-scale
    applications in mind. It was developed after Dapper (a distributed systems tracing
    infrastructure developed by Google) in order to provide developers with more information
    about how complex distributed systems behave.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Pinpoint与Stagemonitor不同之处在于，它是针对大规模应用程序开发的。它是在Dapper（由Google开发的分布式系统跟踪基础设施）之后开发的，旨在为开发人员提供有关复杂分布式系统行为的更多信息。
- en: Pinpoint helps in analyzing the overall system structure and how different components
    of the system are interconnected. Pinpoint does this by tracing transactions across
    distributed applications. It is aimed at explaining how each transaction is executed,
    tracing the flow between components and potential bottlenecks and problematic
    areas.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Pinpoint有助于分析整个系统结构以及系统不同组件之间的相互关系。Pinpoint通过跟踪分布式应用程序中的事务来实现这一点。它旨在解释每个事务的执行方式，跟踪组件之间的流动以及潜在的瓶颈和问题区域。
- en: Pinpoint, similar to Stagemonitor, has a dashboard for visualization. The dashboard
    helps in visualizing the interconnection between components. The dashboard also
    lets users monitor active threads in the applications at particular points in
    time. Pinpoint features a tracing request count and response patterns. This helps
    in identifying potential problems. It provides support for viewing critical information,
    including CPU utilization, memory utilization, garbage collection, and JVM arguments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Pinpoint类似于Stagemonitor，具有用于可视化的仪表板。该仪表板有助于可视化组件之间的相互关系。该仪表板还允许用户在特定时间点监视应用程序中的活动线程。Pinpoint具有跟踪请求计数和响应模式的功能。这有助于识别潜在问题。它支持查看关键信息，包括CPU利用率、内存利用率、垃圾收集和JVM参数。
- en: Pinpoint consists of four components, named Collector, Web, Sample TestApp,
    and HBase. We can run an instance by executing a script for each of the components
    separately.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Pinpoint由四个组件组成，分别是Collector、Web、Sample TestApp和HBase。我们可以通过分别为每个组件执行脚本来运行一个实例。
- en: 'Following is the Pinpoint dashboard for reference:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是参考的Pinpoint仪表板：
- en: '![](img/3f5c17c7-6333-4d01-95c2-9d8112fb6d06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f5c17c7-6333-4d01-95c2-9d8112fb6d06.jpg)'
- en: The Pinpoint dashboard reference view (source: http://www.testingtoolsguide.net/tools/pinpoint-apm/)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pinpoint仪表板参考视图（来源：http://www.testingtoolsguide.net/tools/pinpoint-apm/）
- en: MoSKito
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MoSKito
- en: 'MoSKito is a group of three tools:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: MoSKito是三个工具的组合：
- en: '**MoSKito-Essential**: This standalone project is the core of MoSKito. It makes
    it possible to monitor the application.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MoSKito-Essential**：这个独立项目是MoSKito的核心。它使监视应用程序成为可能。'
- en: '**MoSKito-Central**: This works as a centralized storage server. It stores
    all of the performance-related information.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MoSKito-Central**：这是一个集中式存储服务器。它存储所有与性能相关的信息。'
- en: '**MoSKito-Control**: This tool works for multi-node web applications. It provides
    support for monitoring multi-node web applications.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MoSKito-Control**：这个工具适用于多节点Web应用程序。它提供了对多节点Web应用程序的监视支持。'
- en: In order to set up MoSKito, we need to install a JAR file in the application's
    `WEB-INF/lib` directory, which is a common folder for keeping API libraries. It
    can also be set up by adding a new section in the `web.xml` file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置MoSKito，我们需要在应用程序的`WEB-INF/lib`目录中安装一个JAR文件，这是一个常用的存放API库的文件夹。也可以通过在`web.xml`文件中添加一个新的部分来设置。
- en: The tool is capable of collecting all of the application performance metrics,
    including memory, threads, storage, caches, registrations, payments, conversions,
    SQL, services, load distribution, and many more. It does not require users to
    make any code changes in the application. It supports all major application servers,
    including Tomcat, Jetty, JBoss, and Weblogic. It stores the data locally.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具能够收集所有应用程序性能指标，包括内存、线程、存储、缓存、注册、付款、转换、SQL、服务、负载分布等等。它不需要用户在应用程序中进行任何代码更改。它支持所有主要的应用服务器，包括Tomcat、Jetty、JBoss和Weblogic。它将数据存储在本地。
- en: MoSKito also has a notification feature to broadcast an alert when a threshold
    is met. It also records a user's actions, which might be of interest for monitoring
    purposes. MoSKito offers a mobile application for monitoring the application on
    the go. It also has web-based dashboards.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: MoSKito还具有通知功能，当达到阈值时会广播警报。它还记录用户的操作，这可能对监视目的有所帮助。MoSKito提供了一个用于在移动设备上监视应用程序的移动应用程序。它还具有基于Web的仪表板。
- en: One of the distinguishing points for MoSKito is that it is very stable and well-known
    in the Java community. It is supported by the community and team, which includes
    paid support, as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: MoSKito的一个显著特点是它在Java社区中非常稳定和知名。它得到了社区和团队的支持，包括付费支持。
- en: 'Following is the MoSKito dashboard for reference:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MoSKito仪表板的参考：
- en: '![](img/e8b1aab2-b6ba-4033-a50e-c379a733b6fd.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8b1aab2-b6ba-4033-a50e-c379a733b6fd.jpg)'
- en: The MoSKito dashboard view (source: https://confluence.opensource.anotheria.net/display/MSK/Javaagent+light+and+multiple+java+processes)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MoSKito仪表板视图（来源：https://confluence.opensource.anotheria.net/display/MSK/Javaagent+light+and+multiple+java+processes）
- en: Glowroot
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Glowroot
- en: One of the fast, clean, and simple application performance monitoring tools
    is Glowroot. It has a feature which allows tracing for slow requests and errors.
    With Glowroot, it is also possible to log the time taken for each user action.
    Glowroot supports SQL capture and aggregation. Historical rollup of the data with
    retention configuration is one of the additional features that Glowroot provides.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Glowroot是一种快速、干净、简单的应用程序性能监控工具。它具有一个功能，允许跟踪慢请求和错误。使用Glowroot，还可以记录每个用户操作所花费的时间。Glowroot支持SQL捕获和聚合。Glowroot提供的历史数据滚动和保留配置是其提供的附加功能之一。
- en: Glowroot provides support for visualizing response time breakdown and response
    time percentiles in charts. It has a responsive user interface, which allows one
    to monitor the application using mobile devices, as well as from desktop systems,
    without any additional installations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Glowroot支持在图表中可视化响应时间的分解和响应时间百分位数。它具有响应灵敏的用户界面，允许用户使用移动设备以及桌面系统监视应用程序，无需进行任何额外的安装。
- en: Glowroot comes in a ZIP file bundle. In order to get started with Glowroot,
    we have to download and unzip the ZIP file bundle. Glowroot requires changes in
    the JVM parameters of the application. We have to add `-javaagent:<path to glowroot.jar>`
    in the JVM arguments for the application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Glowroot以ZIP文件捆绑提供。要开始使用Glowroot，我们必须下载并解压ZIP文件捆绑。Glowroot需要更改应用程序的JVM参数。我们必须在应用程序的JVM参数中添加`-javaagent:<path
    to glowroot.jar>`。
- en: Glowroot provides continuous profiling with filtering once it is set up and
    running. We can also set up alerts for response time percentiles and MBean attributes.
    Asynchronous requests spanning multiple threads are also supported by Glowroot.
    In terms of application servers, Glowroot supports Tomcat, Jetty, JBoss, Wildfly,
    and Glassfish.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Glowroot一旦设置并运行，就提供了带有过滤的持续性能分析。我们还可以设置响应时间百分位数和MBean属性的警报。Glowroot还支持跨多个线程的异步请求。在应用服务器方面，Glowroot支持Tomcat、Jetty、JBoss、Wildfly和Glassfish。
- en: 'Following is the Glowroot JVM dashboard for reference:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Glowroot JVM仪表板供参考：
- en: '![](img/97ae8f5c-5592-4717-9892-d546f6a56d44.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97ae8f5c-5592-4717-9892-d546f6a56d44.png)'
- en: The Glowroot JVM dashboard view (source: https://demo.glowroot.org)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Glowroot JVM仪表板视图（来源：https://demo.glowroot.org）
- en: New Relic
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: New Relic
- en: New Relic is another widely used application performance monitoring tool in
    the Java community. New Relic provides grouped views for application and network
    performance statistics. This helps in the quick diagnosis of domain level problems.
    It also provides features for drilling down into specific requests for viewing
    performance metrics by response time, data transfer size, and throughput.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: New Relic是Java社区中另一个广泛使用的应用程序性能监控工具。New Relic为应用程序和网络性能统计提供了分组视图。这有助于快速诊断域级问题。它还提供了针对特定请求的深入功能，以查看响应时间、数据传输大小和吞吐量的性能指标。
- en: 'New Relic supports applications developed in Java, Scala, Ruby, Python, PHP,
    .NET, and Node.js. New Relic offers four different approaches for backend monitoring:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: New Relic支持使用Java、Scala、Ruby、Python、PHP、.NET和Node.js开发的应用程序。New Relic提供了四种不同的后端监控方法：
- en: '**Application performance management**: In application performance management,
    New Relic features high-level metrics with the ability to drill down to the code
    level to see how the application is performing. On the dashboard, New Relic displays
    a response time graph. New Relic uses the Apdex index score method to distill
    metrics into performance indicators. New Relic requires the user to manually set
    the threshold values.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序性能管理**：在应用程序性能管理中，New Relic提供高级指标，并能够深入到代码级别，以查看应用程序的性能。在仪表板上，New Relic显示响应时间图表。New
    Relic使用Apdex指数评分方法将指标转化为性能指标。New Relic要求用户手动设置阈值。'
- en: '**Server monitoring**: New Relic focuses on the hardware the application servers
    are running on. The measurements include CPU usage, memory utilization, disk I/O,
    and network I/O. New Relic provides brief details on the heap memory and garbage
    collection attributes.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器监控**：New Relic关注应用程序服务器运行的硬件。测量包括CPU使用率、内存利用率、磁盘I/O和网络I/O。New Relic提供了堆内存和垃圾回收属性的简要详情。'
- en: '**Database monitoring**: In New Relic, the dashboard for the database is a
    part of the application performance management dashboard. It is possible to view
    database monitoring metrics through plugins.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库监控**：在New Relic中，数据库仪表板是应用程序性能管理仪表板的一部分。可以通过插件查看数据库监控指标。'
- en: '**Insights and analytics**: New Relic has a built-in, opt-in database, which
    stores statistics and enables querying the database.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**洞察和分析**：New Relic具有内置的、可选择的数据库，用于存储统计数据并实现对数据库的查询。'
- en: 'Following is the New Relic dashboard for reference:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是New Relic仪表板供参考：
- en: '![](img/a9255a23-618e-4fb8-828c-4b5007fcd6c5.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9255a23-618e-4fb8-828c-4b5007fcd6c5.jpg)'
- en: The New Relic dashboard view (source: https://newrelic.com/)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: New Relic仪表板视图（来源：https://newrelic.com/）
- en: Profiling tools
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析工具
- en: Profiling tools, or profilers, are software tools used by application developers
    to investigate and identify characteristics of and issues in the code. Profiling
    tools are also useful in identifying performance problems. Profiling tools answer
    questions like what JVM parameters are set, what the status of the heap memory
    is, what the generation-based classification of memory utilization is, which threads
    are active, and so on. Some profilers also track methods in the code to understand
    how frequently SQL statements are called, or how frequently web services are called.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析工具，或者分析器，是应用程序开发人员用来调查和识别代码特征和问题的软件工具。性能分析工具还有助于识别性能问题。性能分析工具回答问题，比如JVM参数设置是什么，堆内存的状态如何，基于代的内存利用情况如何，哪些线程是活跃的等等。一些分析器还跟踪代码中的方法，以了解SQL语句调用的频率，或者Web服务调用的频率。
- en: Similar to application performance monitoring tools, many profiling tools are
    available on the market. VisualVM, JConsole, and HeapAnalyzer are a few of them.
    We will discuss each of the profiling tools in detail in the following sections.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序性能监控工具类似，市场上有许多性能分析工具。VisualVM、JConsole和HeapAnalyzer是其中的几个。我们将在接下来的部分详细讨论每个性能分析工具。
- en: VisualVM
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VisualVM
- en: 'VisualVM is a Java profiling and performance analysis tool. It has a visual
    interface to analyze detailed information for Java applications running in local
    and remote environments on JVMs. It integrates and utilizes JDK provided command-line
    tools like `jstack`, `jconsole`, `jmap`, `jstat`, and `jinfo`. These tools are
    part of the standard JDK distribution. VisualVM is instrumental in solving runtime
    problems, with features such as heap dump and thread analysis. It helps in identifying
    application performance and where it stands against the benchmark. It also helps
    in ensuring optimal memory usage. It further helps in monitoring the garbage collector,
    profiling CPU usage, analyzing heap data, and tracking memory leaks. The following
    are the purposes of each of the command-line tools used by VisualVM:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM是一个Java性能分析和性能分析工具。它具有可视化界面，用于分析在本地和远程环境中在JVM上运行的Java应用程序的详细信息。它集成并利用了JDK提供的命令行工具，如`jstack`，`jconsole`，`jmap`，`jstat`和`jinfo`。这些工具是标准JDK分发的一部分。VisualVM在解决运行时问题方面非常重要，具有堆转储和线程分析等功能。它有助于识别应用程序性能以及其与基准的比较情况。它还有助于确保最佳的内存使用。它进一步有助于监视垃圾收集器，分析CPU使用情况，分析堆数据和跟踪内存泄漏。以下是VisualVM使用的每个命令行工具的目的：
- en: '`jstack`**:** This tool is used to capture the thread dumps of a Java application'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jstack`**：**这个工具用于捕获Java应用程序的线程转储'
- en: '`jmap`**:** This tool prints shared object memory maps and heap memory details
    for a given process'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jmap`**：**这个工具打印给定进程的共享对象内存映射和堆内存详细信息'
- en: '`jstat`**:** This tool displays performance statistics for JVMs running the
    application'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jstat`**：**这个工具显示运行应用程序的JVM的性能统计信息'
- en: '`jinfo`**:** This tool prints Java configuration information'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jinfo`**：**这个工具打印Java配置信息'
- en: 'VisualVM is part of the standard JDK bundle. It was first bundled with the
    JDK platform in JDK version 6, update 7\. It can also be installed separately.
    Let''s look at each section in detail:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM是标准JDK捆绑包的一部分。它首次与JDK平台捆绑在JDK版本6，更新7中。它也可以单独安装。让我们详细看看每个部分：
- en: '![](img/000eb193-e61d-4572-89d6-df59d25a9cc2.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/000eb193-e61d-4572-89d6-df59d25a9cc2.png)'
- en: The Applications window view of VisualVM
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM的应用程序窗口视图
- en: As can be seen in the preceding screenshot, on the left-side of the window,
    there is an Applications window. The Applications window has nodes and subnodes.
    The nodes and subnodes can be expanded in order to view configured applications
    and saved files. We can view additional information or perform actions by right-clicking
    the nodes and choosing items from the pop-up menus that appear. The pop-up menu
    options vary, depending on the selected node.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，在窗口的左侧有一个应用程序窗口。应用程序窗口具有节点和子节点。可以展开节点和子节点以查看配置的应用程序和保存的文件。通过右键单击节点并从弹出菜单中选择项目，可以查看其他信息或执行操作。弹出菜单选项因所选节点而异。
- en: Inside of the Applications window, we can see a menu for Local nodes. A local
    node displays information about the name of the process and process identifier
    for the Java processes running on the same machine as VisualVM. After launching
    VisualVM, the local nodes are automatically populated when the Local root node
    is expanded. VisualVM is always loaded as one of the local nodes. The nodes automatically
    disappear when the service is terminated. If we take thread dumps and heap dumps
    of an application, those are displayed like subnodes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序窗口内，我们可以看到一个本地节点的菜单。本地节点显示有关在与VisualVM相同的计算机上运行的Java进程的进程名称和进程标识符的信息。启动VisualVM后，当展开本地根节点时，本地节点会自动填充。VisualVM始终加载为本地节点之一。服务终止时，节点会自动消失。如果我们对应用程序进行线程转储和堆转储，这些将显示为子节点。
- en: It is possible to connect to JVM running on a remote machine using VisualVM.
    All such running processes or applications are displayed under the Remote node.
    After a connection is established with the remote node, we can expand the Remote
    node to see all Java applications running on the remote machine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用VisualVM连接到在远程计算机上运行的JVM。所有这些运行的进程或应用程序都显示在远程节点下。与远程节点建立连接后，可以展开远程节点以查看在远程计算机上运行的所有Java应用程序。
- en: The VM Coredumps node is only visible if the application is running on Linux
    or Solaris operating systems. When a core dump file is opened in VisualVM, the
    VM Coredumps node shows the open core dump file. It is a binary file containing
    information about the runtime status of the machine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序在Linux或Solaris操作系统上运行，则VM Coredumps节点仅可见。在VisualVM中打开核心转储文件时，VM Coredumps节点显示打开的核心转储文件。这是一个包含有关机器运行时状态的二进制文件。
- en: The last section in the Applications window is labeled Snapshots. The Snapshots
    section displays all of the saved snapshots taken while the application is running.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序窗口中的最后一个部分标有快照。快照部分显示在应用程序运行时拍摄的所有保存的快照。
- en: The data for local or remote applications is presented in tabs in VisualVM.
    The Overview tab is opened by default when viewing application data. The Overview
    tab displays information including the process ID, the location of the system,
    the main class for the application, the path to the Java installation, JVM arguments
    passed, JVM flags, and system properties.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM中的本地或远程应用程序的数据以选项卡的形式呈现。在查看应用程序数据时，默认情况下打开概述选项卡。概述选项卡显示的信息包括进程ID，系统位置，应用程序的主类，Java安装路径，传递的JVM参数，JVM标志和系统属性。
- en: The next tab in the list is the Monitor tab. The Monitor tab can be used to
    view real-time information about heap memory, permanent generation heap memory,
    and the number of classes and threads. The classes here indicate classes loaded
    into the virtual machine. The application monitoring process puts on low overhead.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个选项卡是监视选项卡。监视选项卡可用于查看有关堆内存，永久代堆内存以及类和线程数量的实时信息。这里的类表示加载到虚拟机中的类。应用程序监视过程的开销较低。
- en: The heap graph on the Monitor tab displays the total heap size and currently
    used heap size. The changes in the permanent generation area over a period of
    time are displayed in the PermGen graph. The classes graph displays the total
    number of loaded and shared classes. The number of live and daemon threads information
    is displayed in the Threads section. VisualVM can be used to take a thread dump,
    which shows exact information on threads at a specific time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 监视选项卡上的堆图显示了总堆大小和当前使用的堆大小。在PermGen图中显示了永久代区域随时间的变化。类图显示了加载和共享类的总数。线程部分显示了活动线程和守护线程的数量信息。VisualVM可以用于获取线程转储，显示特定时间的线程的确切信息。
- en: 'From within the Monitor tab, we can forcefully perform garbage collection.
    The action will immediately run garbage collection. It is also possible to capture
    a heap dump from the Monitor tab:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在监视选项卡中，我们可以强制执行垃圾回收。该操作将立即运行垃圾回收。还可以从监视选项卡中捕获堆转储：
- en: '![](img/60038421-778a-43a9-8075-aa2b08bb0880.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60038421-778a-43a9-8075-aa2b08bb0880.png)'
- en: VisualVM displays real-time thread activity in the Threads tab. As a default,
    the Threads tab shows the timeline of current thread activity. By clicking on
    a particular thread, we can view details about that particular thread in the Details
    tab.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM在线程选项卡中显示实时线程活动。默认情况下，线程选项卡显示当前线程活动的时间轴。通过单击特定线程，可以在详细信息选项卡中查看有关该特定线程的详细信息。
- en: The Timeline section shows a timeline with real-time thread states. We can filter
    the types of threads displayed by choosing the appropriate values in the drop-down
    menu. In the preceding screenshot, it shows the Live threads timeline. We can
    also view all of the threads, or finished threads, by selecting this from the
    drop-down menu.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴部分显示了带有实时线程状态的时间轴。我们可以通过选择下拉菜单中的适当值来过滤显示的线程类型。在上述屏幕截图中，显示了活动线程的时间轴。我们还可以通过从下拉菜单中选择来查看所有线程或已完成线程。
- en: We can choose to take a thread dump of the application while the application
    is running. The thread dump, when printed, shows a thread stack that includes
    thread states for Java applications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序运行时，我们可以选择获取应用程序的线程转储。打印线程转储时，会显示包括Java应用程序的线程状态的线程堆栈。
- en: The Profiler tab makes it possible to start and stop the profiling sessions
    of an application. The results are displayed in the Profiler tab itself. Profiling
    can be done for CPU profiling or memory profiling. Upon starting the profiling
    session, VisualVM connects to the application to start collecting the profiling
    data. Once the results are available, they are displayed in the Profiler tab automatically.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器选项卡使得可以启动和停止应用程序的分析会话。结果显示在分析器选项卡中。可以进行CPU分析或内存分析。启动分析会话后，VisualVM连接到应用程序开始收集分析数据。一旦结果可用，它们将自动显示在分析器选项卡中。
- en: JConsole
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JConsole
- en: JConsole is another Java profiling tool. It compiles to **Java Management Extension**
    (**JMX**) specifications. JConsole extensively uses instrumentation in JVM to
    collect and display information about the performance and resource consumption
    of applications running on the Java platform. JConsole is updated to a GNOME and
    Windows look and feel in Java SE 6.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: JConsole是另一个Java分析工具。它符合**Java管理扩展**（**JMX**）规范。JConsole广泛使用JVM中的仪器来收集和显示运行在Java平台上的应用程序的性能和资源消耗的信息。JConsole在Java
    SE 6中更新为GNOME和Windows外观。
- en: 'Similar to VisualVM, JConsole comes bundled with the Java development kit.
    The executable file for JConsole can be found in the `JDK_HOME/bin` directory.
    JConsole can be started from the Command Prompt or console window with the following
    command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与VisualVM类似，JConsole与Java开发工具包捆绑在一起。JConsole的可执行文件可以在`JDK_HOME/bin`目录中找到。可以使用以下命令从命令提示符或控制台窗口启动JConsole：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Upon executing the preceding command, JConsole presents the user with a choice
    of all of the Java applications running on the system. We can choose to connect
    to any running application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，JConsole会向用户显示系统上运行的所有Java应用程序的选择。我们可以选择连接到任何正在运行的应用程序。
- en: 'It is also possible to supply the process ID, if we know the process ID of
    the Java application that we want JConsole to connect to. The following is the
    command to boot JConsole up, with a connection to a specific Java application
    identified by its process ID:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道要连接到的Java应用程序的进程ID，也可以提供进程ID。以下是启动JConsole并连接到特定Java应用程序的命令：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following command can be used to connect to a Java application running
    on a remote machine:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令连接到在远程计算机上运行的Java应用程序：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'JConsole presents information in the following tabs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JConsole在以下选项卡中显示信息：
- en: 'Overview: This tab displays information about the JVM and values to be monitored.
    It presents the information in a graphical monitoring format. The information
    contains overview details on CPU usage, memory usage, thread counts, and the number
    of classes loaded in JVM.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述：此选项卡显示有关JVM和要监视的值的信息。它以图形监视格式呈现信息。信息包括有关CPU使用情况、内存使用情况、线程计数以及JVM中加载的类数量的概述细节。
- en: 'Memory: This tab displays information about memory consumption and usage. The
    memory tab contains a Perform GC button, which can be clicked to activate immediate
    garbage collection. For the HotSpot Java VM, the memory pools are Eden Space,
    Survivor Space, Tenured Generation, Permanent Generation, and Code Cache. It is
    possible to display various charts for depicting the consumption of memory pools.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存：此选项卡显示有关内存消耗和使用情况的信息。内存选项卡包含一个执行GC按钮，可以单击以立即启动垃圾回收。对于HotSpot Java VM，内存池包括伊甸园空间、幸存者空间、老年代、永久代和代码缓存。可以显示各种图表来描述内存池的消耗情况。
- en: 'Threads: This tab displays information about thread usage. The threads include
    active threads, Live threads, and all threads. The chart''s representation shows
    the peak number of threads and the number of live threads on two different lines.
    MXBean provides other information not covered by the Threads tab. With MXBean,
    it is possible to detect deadlocked threads.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程：此选项卡显示有关线程使用情况的信息。线程包括活动线程、活动线程和所有线程。图表的表示显示了线程的峰值数量和两条不同线上的活动线程数量。MXBean提供了线程选项卡未涵盖的其他信息。使用MXBean，可以检测到死锁线程。
- en: 'Classes: This tab displays information about classes loaded in the Java virtual
    machine. The class information includes the total number of classes loaded so
    far, including those which are unloaded later on and the current number of classes
    loaded.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类：此选项卡显示了Java虚拟机中加载的类的信息。类信息包括迄今为止加载的类的总数，包括后来卸载的类以及当前加载的类的数量。
- en: 'VM: This tab displays statistical information about the Java virtual machine.
    The summary includes uptime, indicating the amount of time since the JVM started;
    the process CPU time, indicating the amount of CPU time that JVM has consumed
    since it started; and the total compile time, indicating the time spent on the
    compilation process.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VM：此选项卡显示有关Java虚拟机的统计信息。摘要包括正常运行时间，表示JVM启动以来的时间量；进程CPU时间，表示JVM自启动以来消耗的CPU时间量；以及总编译时间，表示用于编译过程的时间。
- en: 'MBeans: This tab displays information about MBeans. The MBeans include those
    currently running. We can get `MBeanInfo` descriptor information by selecting
    the MBean.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MBeans：此选项卡显示有关MBeans的信息。MBeans包括当前正在运行的MBeans。我们可以通过选择MBean来获取`MBeanInfo`描述符信息。
- en: 'Following screenshot shows how the JConsole dashboard looks like:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了JConsole仪表板的外观：
- en: '![](img/43734b6d-8df0-4662-be7d-258c92879688.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43734b6d-8df0-4662-be7d-258c92879688.jpg)'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was full of information on application performance measurement
    techniques. The chapter is useful for development teams working on application
    performance enhancement tasks. At the same time, it can be referred to by technical
    teams setting up their application logging mechanisms.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章充满了有关应用程序性能测量技术的信息。本章对于致力于应用程序性能增强任务的开发团队非常有用。同时，技术团队在设置其应用程序日志记录机制时也可以参考本章。
- en: The chapter started with introductory details on performance profiling and logging.
    Moving ahead, we learned about specific application performance monitoring and
    application logging. We learned what the key elements of logging are. We also
    looked into logging tools, like standard Java logging and Log4j. In the latter
    part of the chapter, we learned about VisualVM as a performance profiling tool.
    VisualVM is one of the most widely used Java-based performance profiling tools,
    available as a standard Java distribution package. That was it for this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从性能分析和日志记录的简介细节开始。继续前进，我们了解了特定应用程序性能监控和应用程序日志记录。我们了解了日志记录的关键要素是什么。我们还研究了日志记录工具，如标准Java日志记录和Log4j。在本章的后半部分，我们了解了VisualVM作为性能分析工具。VisualVM是最广泛使用的基于Java的性能分析工具之一，作为标准Java分发包提供。就是这样了。
- en: The next chapter will focus on optimizing application performance. One can leverage
    the knowledge and information provided in this chapter in the next chapter while
    working on performance optimization. This chapter provides a base for the next
    chapter. The next chapter covers details for identifying the symptoms of performance
    issues, the performance tuning life cycle, and JMX support in Spring. Pretty exciting
    stuff, isn't it?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点关注优化应用程序性能。在进行性能优化时，可以利用本章提供的知识和信息。本章为下一章提供了基础。下一章涵盖了识别性能问题症状、性能调优生命周期和Spring中的JMX支持的详细信息。非常令人兴奋，不是吗？
