- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Scaling and Performance Optimization Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展和性能优化技术
- en: '[*Chapter 9*](B21843_09.xhtml#_idTextAnchor240) introduced skills such as quantitative
    measurements to observe how a system connected via APIs behaves at runtime.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第9章*](B21843_09.xhtml#_idTextAnchor240)介绍了如定量测量等技能，以观察通过API连接的系统在运行时的行为。'
- en: That chapter provides a good basis for this chapter on **performance** and **scalability**
    , two non-functional requirements that are strongly concerned with time, size,
    and other quantitative aspects of software systems and the data they process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那一章为本章关于**性能**和**可伸缩性**提供了良好的基础，这两个非功能性需求与时间、大小以及软件系统和它们处理的数据的其他定量方面密切相关。
- en: We will start by explaining what developers need to know about performance and
    scalability in general. Then, we will dive into specifics, describing the most
    common strategies and techniques for improving performance and scalability. We
    will demonstrate some of these techniques using our Product and Order Management
    APIs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释开发者需要了解的性能和可伸缩性的一般知识。然后，我们将深入具体细节，描述提高性能和可伸缩性的最常见策略和技术。我们将使用我们的商品和订单管理API演示一些这些技术。
- en: We highlight the potential of Java **virtual threads** for increasing application
    throughput by improving CPU usage efficiency in the context of API development.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调Java **虚拟线程**在API开发环境中提高应用吞吐量、改善CPU使用效率的潜力。
- en: We also show that to support performance and scalability, your API should be
    prepared to work with specialized infrastructure components.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还表明，为了支持性能和可伸缩性，您的API应该准备好与专门的基础设施组件一起工作。
- en: Lastly, we will show how load testing helps you avoid unpleasant surprises once
    your application starts to receive the production load. Using performance testing,
    developers can get information that is vital to target their optimization efforts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示如何通过负载测试帮助您避免在应用程序开始接收生产负载时出现不愉快的惊喜。通过性能测试，开发者可以获取对针对优化努力至关重要的信息。
- en: By the end of this chapter, you will know how to prevent performance and scalability
    issues starting from the analysis phase, through appropriate API design, to subsequent
    optimizations triggered by the findings from load tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何从分析阶段开始，通过适当的API设计，到由负载测试发现触发的后续优化，来防止性能和可伸缩性问题。
- en: 'The following topics are covered in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding performance and scalability in API development
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解API开发中的性能和可伸缩性
- en: Applying performance optimization strategies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用性能优化策略
- en: Increasing the throughput with virtual threads
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟线程提高吞吐量
- en: Using infrastructure support
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基础设施支持
- en: Designing and executing effective load tests
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和执行有效的负载测试
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To demonstrate some of the techniques described in this chapter, we will use
    the example code of the Product and Order Management APIs that were developed
    in previous chapters. The changes that we will make to the code for this chapter
    can be found in the repository at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter10](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter10)
    .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示本章中描述的一些技术，我们将使用前几章中开发的商品和订单管理API的示例代码。本章对代码所做的更改可以在以下存储库中找到：[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter10](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter10)。
- en: Understanding performance and scalability in API development
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解API开发中的性能和可伸缩性
- en: 'Performance in computing refers to how efficiently a system or application
    executes tasks under a given workload. Efficiency has two aspects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中的性能指的是系统或应用程序在给定工作负载下执行任务的效率。效率有两个方面：
- en: '**Speed of processing** : This is measured mostly in terms of response time
    (latency) and throughput (how many operations or how much data the system can
    handle per unit of time).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理速度**：这主要是在响应时间（延迟）和吞吐量（系统在单位时间内可以处理多少操作或数据）的术语下进行衡量的。'
- en: '**Consumption of resources** : This refers to the amount of resources required,
    such as CPU, memory, and network bandwidth utilization, to do the work.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源消耗**：这指的是完成工作所需资源的数量，例如CPU、内存和网络带宽利用率。'
- en: Statistics are an integral part of performance measurement because it makes
    sense to measure performance when the system processes a large number of different
    requests involving different amounts of data. Therefore, the time and other resources
    required to fulfill a request inevitably fluctuate and depend on a number of factors,
    making the actual measured values of the performance characteristics virtually
    random in nature.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学是性能测量的一个重要组成部分，因为在系统处理大量不同请求时，涉及不同数据量的情况下，测量性能是有意义的。因此，满足一个请求所需的时间和资源不可避免地会波动，并取决于许多因素，使得性能特性的实际测量值在本质上几乎是随机的。
- en: It is usually sufficient to use average values to calculate throughput. For
    response times, the average value is less useful because it does not capture well
    how the speed of response is perceived by users. The maximum value is often of
    particular interest because it can indicate potential issues, such as the occurrence
    of timeout errors. Moreover, response times exceeding a reasonable limit discourage
    human users from continuing to use the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用平均值来计算吞吐量是足够的。对于响应时间，平均值不太有用，因为它不能很好地捕捉用户对响应速度的感知。最大值通常特别有趣，因为它可以指示潜在问题，例如超时错误的发生。此外，超过合理限制的响应时间会阻碍用户继续使用应用程序。
- en: Even more useful than the extreme values that occur very rarely are the percentile
    values. If we rank all response times from shortest to longest, then, for example,
    the 95th percentile is the time at which 95% of the measured times are shorter.
    In other words, there is only a 5% probability that a randomly selected request
    will take longer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 比极值更有用的是百分位数。如果我们按最短到最长的顺序对所有响应时间进行排名，那么例如，95百分位数是95%的测量时间都更短的时间点。换句话说，随机选择的一个请求耗时更长的概率只有5%。
- en: Scalability refers to the ability of a system to handle an increasing load (increased
    number of users, higher data volumes, or additional transactions) while maintaining
    the performance within the limits expected by users. You can see that we cannot
    speak about scalability without considering performance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性指的是系统在保持用户期望的性能限制内处理不断增加的负载（用户数量增加、数据量更高或额外的事务）的能力。你可以看到，如果不考虑性能，我们无法谈论可扩展性。
- en: Scalability is one of the main motivating factors behind moving from monoliths
    to distributed (microservices) architectures. We can assume that our example Product
    API will need to handle significantly more requests than the Order Management
    API because not every product being browsed will be bought. We can scale the deployment
    of the Product API to use more instances of the service than the Order Management
    API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是推动从单体架构迁移到分布式（微服务）架构的主要动机之一。我们可以假设我们的示例产品API将需要处理比订单管理API显著更多的请求，因为不是浏览的每个产品都会被购买。我们可以扩展产品API的部署，使用比订单管理API更多的服务实例。
- en: 'With RESTful APIs, the tasks whose response time and throughput we are interested
    in are the HTTP requests. The time and computing resources needed to execute an
    HTTP request are composed of two parts:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在RESTful API中，我们感兴趣的任务是HTTP请求的响应时间和吞吐量。执行HTTP请求所需的时间和计算资源由两部分组成：
- en: The processing needed by the API technology itself, such as serialization and
    deserialization of the data, network transmission, and protocol overhead
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API技术本身所需的处理，例如数据的序列化和反序列化、网络传输和协议开销
- en: The processing inside the service providing the API (such as executing algorithms,
    accessing databases, and downstream API calls), which is often influenced by the
    API request and response payload design, such as the amount of data processed
    in one request, the possibility of performing concurrent processing and data streaming,
    and the cacheability of the responses.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供API的服务内部的处理（例如执行算法、访问数据库和下游API调用），这通常受API请求和响应负载设计的影响，例如一个请求中处理的数据量、执行并发处理和数据流的可能性以及响应的可缓存性。
- en: When designing APIs, you usually focus on the functional requirements because
    what the application should do is at the front of the users’ minds. How the application
    is expected to perform and cope with increasing traffic is often considered obvious
    or implied.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计API时，你通常关注功能需求，因为应用程序应该做什么是用户心中的首要任务。应用程序预期如何表现和应对增加的流量通常被认为是显而易见或隐含的。
- en: It is also hard to predict the actual load, the load progression over time,
    and which parts of the system will be the most impacted. Donald Knuth’s famous
    saying “ *Premature optimization is the root of all evil* ” warns us that we should
    not try to optimize everything.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 预测实际负载、负载随时间的变化以及系统哪些部分会受到最大影响也很困难。唐纳德·克努特（Donald Knuth）著名的说法“*过早优化是万恶之源*”警告我们，我们不应该试图优化一切。
- en: On the other hand, performance and scalability considerations should be part
    of the design process, and you often can prevent a lot of problems with just a
    few simple adjustments to the APIs. Ideally, you should design the APIs to be
    as simple as possible to fulfill the functional requirements, while keeping the
    options open for future extensions and optimizations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，性能和可扩展性考虑应该是设计过程的一部分，你通常可以通过对 API 进行一些简单的调整来预防很多问题。理想情况下，你应该设计 API 以尽可能简单的方式满足功能需求，同时为未来的扩展和优化留出空间。
- en: 'When in doubt, let the REST principles guide you towards a more flexible and
    standard solution that will likely support the performance and scalability requirements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，让 REST 原则引导你走向更灵活和标准的解决方案，这可能会支持性能和可扩展性要求：
- en: Using URLs based on a resource structure reflecting the business domain
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于反映业务域的资源结构的 URL
- en: Using correct HTTP methods and providing respective idempotency support for
    `GET` , `PUT` , and `DELETE`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的 HTTP 方法，并为 `GET`、`PUT` 和 `DELETE` 提供相应的幂等性支持
- en: Using correct HTTP headers and status codes
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的 HTTP 头部和状态码
- en: Using clearly defined parameters to let the client choose what data and operations
    are really needed
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用清晰定义的参数，让客户端选择真正需要的数据和操作
- en: Using appropriate `Content-Type` and `Content-Encoding` for the data (especially
    with large binary documents)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为数据使用适当的 `Content-Type` 和 `Content-Encoding`（特别是对于大型二进制文档）
- en: Having explained what performance and scalability mean for API development in
    general, we can move on to describe the strategies that, when applied appropriately,
    can have the greatest impact on the performance and scalability of your applications
    integrated using APIs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解释了性能和可扩展性在 API 开发中的含义后，我们可以继续描述那些当适当应用时，可以对使用 API 集成的应用程序的性能和可扩展性产生最大影响的策略。
- en: Applying performance optimization and scalability improvement strategies
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用性能优化和可扩展性改进策略
- en: If you detect an existing or imminent performance or scalability problem with
    your API, you should be armed with the tools to solve it. Let’s take a closer
    look at some of the strategies and techniques for optimizing performance in the
    following sections.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检测到你的 API 存在或即将出现性能或可扩展性问题，你应该具备解决问题的工具。让我们在接下来的部分中更详细地看看一些优化性能的策略和技术。
- en: Knowing the performance requirements
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解性能要求
- en: As mentioned in the previous section, the performance requirements are often
    implied and not clearly specified by users and customers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，性能要求通常是由用户和客户隐含的，而不是明确指定的。
- en: For some applications, performance may not be critical, but if we take the example
    of most e-commerce sites, an application with a response time reaching a few seconds
    is equivalent to an application that does not work at all because it immediately
    discourages potential customers from buying.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，性能可能不是关键因素，但如果我们以大多数电子商务网站为例，响应时间达到几秒的应用程序相当于根本不起作用的应用程序，因为它会立即阻止潜在客户购买。
- en: It is therefore necessary to include at least some rough performance expectations
    for the system to be developed. If you can be more rigorous, you should ask the
    customer to define **service-level agreements** ( **SLAs** ) specifying maximum
    response times or the number of requests processed for each operation. The SLAs
    may vary for peak and off-peak times. Remember to capture size limits for large
    data objects, large numbers of concurrent users, and their geographical distribution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有必要至少包括一些关于要开发的系统的粗略性能预期。如果你可以更加严格，你应该要求客户定义**服务级别协议**（**SLAs**），指定每个操作的最多响应时间或请求处理的数量。SLAs
    可能会因高峰时段和非高峰时段而有所不同。请记住，要记录大型数据对象的大小限制、大量并发用户及其地理分布。
- en: The collected performance requirements can be used to design load tests. The
    load tests will show whether the system can handle the expected load and, if not,
    which parts are the bottlenecks. Information about the geographical distribution
    of users and the quality of their network connections should be used to add simulated
    network latencies in the load test environment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 收集的性能需求可以用来设计负载测试。负载测试将显示系统是否能够处理预期的负载，如果不能，哪些部分是瓶颈。关于用户地理位置分布和他们网络连接质量的信息应被用来在负载测试环境中添加模拟的网络延迟。
- en: To design the system correctly, it is important to know whether the system should
    be optimized for response time (systems with human interaction) or throughput
    (batch processing). To achieve better (perceived) response times, it may make
    sense to split the API requests so that a request performs the essential operation
    only, delivering the essential data only. This way the user experience is improved,
    while the non-essential request(s) can start later and/or take longer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设计系统，了解系统是否应该优化响应时间（具有人类交互的系统）或吞吐量（批量处理）非常重要。为了实现更好的（感知）响应时间，可能有必要拆分API请求，使得一个请求只执行基本操作，只传递基本数据。这样，用户体验得到改善，而那些非基本请求可以稍后开始，或者运行更长的时间。
- en: In contrast to that, grouping multiple operations or data items in one request
    may improve the throughput by reducing the API overhead. However, you must ensure
    that a request does not become so big that it fails due to a timeout.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，将多个操作或数据项组合在一个请求中可能会通过减少API开销来提高吞吐量。然而，你必须确保请求不会变得太大，以至于因为超时而失败。
- en: In many cases, you cannot estimate or simulate the load and environment attributes
    precisely enough, so you must react to performance problems that start occurring
    in production. To support that, your APIs should be ready to evolve without breaking
    the existing clients, which is the topic of [*Chapter 5*](B21843_05.xhtml#_idTextAnchor116)
    .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你无法精确地估计或模拟负载和环境属性，因此你必须对生产中开始出现的性能问题做出反应。为了支持这一点，你的API应该准备好在不破坏现有客户端的情况下进行演变，这是[第5章](B21843_05.xhtml#_idTextAnchor116)的主题。
- en: Providing only what is really needed
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只提供真正需要的内容
- en: Security, another non-functional requirement, is often regarded as going against
    performance, but in many instances, their solutions can in fact overlap. Limiting
    the data that we transfer in APIs is good for security and can be good for performance,
    too, because time and resources are not wasted on items that the API client does
    not need.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性，另一个非功能性需求，通常被认为与性能相冲突，但在许多情况下，它们的解决方案实际上可以重叠。限制我们在API中传输的数据量对安全性有益，也可能对性能有益，因为时间和资源不会浪费在API客户端不需要的项目上。
- en: 'You should identify expensive items that are large or take a long time to get.
    If an expensive item is not used by all requests, you can do either of the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该识别那些大或需要很长时间才能获取的昂贵项目。如果一个昂贵项目不是所有请求都使用，你可以做以下任何一项：
- en: Add a parameter to the API endpoint to only return the expensive item when the
    client asks for it
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向API端点添加一个参数，仅在客户端请求时才返回昂贵项目
- en: Create a separate endpoint (resource) for the expensive item
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为昂贵项目创建一个单独的端点（资源）
- en: For example, if our Product API stored photos of the product, we would not have
    to return the photos in every request for a product. Instead, we can return a
    list of image IDs and define a sub-resource of the product resource, returning
    an image by its image ID.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的产品API存储产品的照片，我们就不需要在每个产品请求中返回照片。相反，我们可以返回一个图像ID列表，并为产品资源定义一个子资源，通过图像ID返回图像。
- en: A common mistake is to design API resources to be a copy of the database entities.
    Some developers might even be tempted to use the clear antipattern of using the
    JPA entity classes in APIs directly without defining separate API DTOs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是将API资源设计成数据库实体的副本。一些开发者甚至可能被诱惑直接在API中使用JPA实体类，而不定义单独的API DTOs，这是一种明显的反模式。
- en: Special attention should be paid to fields that define relationships between
    JPA entities. Exposing the whole graphs of objects resulting from following the
    relationships without due justification often leads to bloated APIs, creating
    a ticking time bomb with performance (besides security and maintainability) problems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应特别关注定义JPA实体之间关系的字段。在没有充分理由的情况下暴露由跟随关系产生的整个对象图，通常会导致API膨胀，并带来性能（除了安全和可维护性）问题。
- en: For example, suppose that at some point we extend the database schema of our
    Product API service with additional database tables and JPA entities containing
    information about stock availability, location, historical prices, and so on.
    These additional database tables could be linked to the product table using foreign
    keys, and the JPA model could include relationships that would map to the respective
    SQL joins. It would be a mistake to include all the additional information automatically
    in the Product API resource JSON representation, except in the unlikely scenario
    where business analysis confirms that all possible use cases for reading a product
    will always need the full set of detailed data. Instead, to support the use cases
    that require access to the related entities, the API could send the extra data
    only when a parameter is set or via a separate endpoint.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在某个时刻，我们扩展了我们的Product API服务的数据库模式，增加了包含有关库存可用性、位置、历史价格等信息的外部数据库表和JPA实体。这些额外的数据库表可以通过外键与产品表相关联，JPA模型可以包含映射到相应SQL连接的关系。将所有额外信息自动包含在Product
    API资源的JSON表示中是错误的，除非在业务分析确认所有可能的读取产品的用例都将始终需要完整的数据集的情况下。相反，为了支持需要访问相关实体的用例，API仅在设置参数或通过单独的端点时才发送额外的数据。
- en: Maintaining statelessness
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护无状态
- en: Statelessness (as explained in [*Chapter 1*](B21843_01.xhtml#_idTextAnchor015)
    ) is one of the key principles of REST architecture. All the input data needed
    to perform an operation should be in the URL path and the request body. The request
    processing must not depend on some implicit session data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态（如[*第一章*](B21843_01.xhtml#_idTextAnchor015)所述）是REST架构的关键原则之一。执行操作所需的所有输入数据都应该包含在URL路径和请求体中。请求处理不应依赖于某些隐含的会话数据。
- en: Statelessness is important for performance and scalability because it allows
    horizontal scaling of the service providing the API. A load balancer (briefly
    explained in the upcoming section on infrastructure components) can route any
    request to be processed by any of the service instances because the instance does
    not have to remember the session state (history of the previous requests belonging
    to the same user journey). Avoiding the session state can also help in reducing
    memory consumption.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态对于性能和可扩展性很重要，因为它允许API提供服务的服务进行水平扩展。负载均衡器（在即将到来的关于基础设施组件的部分中简要介绍）可以将任何请求路由到任何服务实例进行处理，因为实例不需要记住会话状态（属于同一用户旅程的先前请求的历史）。避免会话状态还可以帮助减少内存消耗。
- en: 'Of course, the application may need to support a session-like user experience.
    For example, you may want to let the user create an order product by product,
    so the application needs to remember an incomplete order, commonly represented
    by a shopping cart on most e-commerce sites. To fulfill this requirement, you
    have two main options:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，应用程序可能需要支持类似会话的用户体验。例如，你可能希望让用户逐个创建订单产品，因此应用程序需要记住一个不完整的订单，这在大多数电子商务网站上通常表示为购物车。为了满足这一要求，你有两个主要选项：
- en: Maintain the session state on the client (web browser) using JavaScript code,
    local storage, and so on.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript代码、本地存储等在客户端（网页浏览器）上维护会话状态。
- en: Define the shopping cart as a first-class entity of the backend service. This
    means creating a RESTful resource identified by URL for the new entity and using
    standard HTTP methods to manipulate it. This makes the data stored in the backend
    explicit, as opposed to an implicit session without a clear structure that would
    be harder to manage.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将购物车定义为后端服务的一等实体。这意味着为新的实体创建一个由URL标识的RESTful资源，并使用标准的HTTP方法来操作它。这使得存储在后端的数据是显式的，而不是一个没有明确结构且难以管理的隐含会话。
- en: Limiting large collections
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制大型集合
- en: When your API transfers a collection of items (usually represented by a JSON
    list), you should try to find out the expected number of items in the collection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的API传输一个项目集合（通常表示为JSON列表）时，你应该尝试找出集合中预期的项目数量。
- en: If the number of items frequently exceeds a reasonable limit, you should consider
    implementing a pagination solution for the collection (see [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135)
    ). The number of items in a collection and the number of items per page that calls
    for the introduction of pagination depend on how expensive the API operation is.
    For small items that are quick to retrieve, the number could be higher.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目的数量经常超过合理的限制，您应该考虑为集合实现分页解决方案（参见[*第6章*](B21843_06.xhtml#_idTextAnchor135)）。集合中的项目数量和每页需要引入分页的项目数量取决于API操作的成本。对于快速检索的小项目，数量可以更高。
- en: You should also think about how large a set it makes sense to work with on the
    client side at the same time. If the items are displayed on a screen, the user
    can usually not see more than a few items at the same time. You can base your
    pagination policy on that number.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该考虑在客户端同时处理多大的集合是有意义的。如果项目在屏幕上显示，用户通常一次只能看到几个项目。您可以将您的分页策略基于这个数字。
- en: Besides pagination, you can limit the number of items returned by ensuring that
    queries are sufficiently specific. For instance, in a substring-based search,
    you can enforce a rule that the search string must have a minimum length of three
    characters, which helps narrow down the results and improve efficiency.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分页之外，您还可以通过确保查询足够具体来限制返回的项目数量。例如，在基于子串的搜索中，您可以强制执行一个规则，即搜索字符串必须至少有三个字符长，这有助于缩小结果并提高效率。
- en: Or, before the full data retrieval, you can first execute a cheaper database
    query returning only the count of the matching items, and if it exceeds a certain
    limit, you can stop there and return a response asking the client to provide a
    more specific query. Cheaper in the context of performance optimization means
    taking less time and fewer resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在完整数据检索之前，您可以先执行一个更便宜的数据库查询，只返回匹配项的数量，如果它超过一定限制，您就可以停止并返回一个请求，要求客户端提供更具体的查询。在性能优化的背景下，更便宜意味着花费更少的时间和资源。
- en: When deciding about the collection size limits, you should also think about
    the nature of the data sources your API operation needs to access. In distributed
    (microservices) architectures, you usually need to call another API to fulfill
    an API request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定集合大小限制时，您还应该考虑API操作需要访问的数据源的性质。在分布式（微服务）架构中，您通常需要调用另一个API来满足API请求。
- en: If you need to make separate API calls to get some details for each item of
    a collection, you can try to shorten the response time by making several such
    API calls in parallel. However, you should limit the number of parallel API invocations
    to avoid overwhelming the API. The *Increasing the throughput with virtual threads*
    section later in this chapter may be useful for implementing concurrent API calls.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要通过单独的API调用获取集合中每个项目的某些详细信息，您可以通过并行执行多个此类API调用来尝试缩短响应时间。但是，您应该限制并行API调用的数量，以避免压倒API。本章后面的“*使用虚拟线程提高吞吐量*”部分可能有助于实现并发API调用。
- en: Another option is to check whether the API your service needs to call supports
    (or can be made to support) bulk operations, such as getting details for a list
    of IDs in one request. But you must be reasonable about the size of the request
    because requests that are too large may take too long and hit timeouts at various
    points along their path from the client to the server and back.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是检查您服务需要调用的API是否支持（或可以被修改为支持）批量操作，例如在一次请求中获取一系列ID的详细信息。但您必须对请求的大小保持合理，因为过大的请求可能会花费太长时间，并在客户端到服务器以及返回的路径上的各个点遇到超时。
- en: For example, the Order Management API calls the Product API for each product
    to get its price. We could optimize this integration so that the Product API provides
    a bulk “get multiple products” endpoint. The API would take a list of product
    IDs as its input and return the prices for all the products at once.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，订单管理API为每个产品调用产品API以获取其价格。我们可以优化这个集成，使产品API提供一个批量“获取多个产品”端点。该API将产品ID列表作为其输入，并一次性返回所有产品的价格。
- en: Optimizing large objects
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化大型对象
- en: We have already mentioned that it is not wise to try to optimize everything.
    The Pareto principle says that the vast majority (around 80%) of (performance)
    problems are caused by a small minority (around 20%) of the items comprising your
    API.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，试图优化一切并不明智。帕累托法则表明，大多数（大约80%）的性能问题是由API组成中的少数（大约20%）的项目引起的。
- en: A relatively common case where a small part of an API is responsible for most
    of the bytes transferred and time spent is when you want to transfer large blocks
    of data whose internal structure is not important to the API, such as photos,
    videos, or documents, which are usually encoded using binary formats. These items
    have a significant impact on the network transfer volume, memory consumption,
    and response times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相对常见的情况是，API的一个小部分负责大部分的字节传输和时间消耗，当你想要传输内部结构对API不重要的大型数据块时，这种情况尤为明显，例如照片、视频或文档，这些通常使用二进制格式编码。这些项目对网络传输量、内存消耗和响应时间有显著影响。
- en: 'It is a good practice to avoid including large (binary) objects in structured
    (JSON) payloads. Instead, you can define separate resources (endpoints) for the
    large objects. This has the following advantages:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在结构化（JSON）有效载荷中包含大型（二进制）对象是一种良好的做法。相反，你可以为大型对象定义单独的资源（端点）。这有以下优点：
- en: The payload can use an encoding that is suitable for the large object format.
    Trying to embed binary data in JSON usually leads to the use of inefficient encodings
    such as BASE64.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效载荷可以使用适合大型对象格式的编码。尝试在JSON中嵌入二进制数据通常会导致使用效率低下的编码，如BASE64。
- en: If the text-based encoding of large data objects cannot be avoided, the efficiency
    of the network transfer can be improved by combining it with compression, such
    as gzip.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法避免大型数据对象的基于文本的编码，可以通过结合压缩（如gzip）来提高网络传输的效率。
- en: Large objects can be cached independently of other data. This makes sense given
    the size of the objects and because it is likely that the large objects change
    less frequently than the structured data.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型对象可以独立于其他数据进行缓存。考虑到对象的大小，以及大型对象可能比结构化数据更改频率低，这是有意义的。
- en: Where possible, you should also try to limit the size of large objects. When
    displaying images on a client device, the performance can be improved by scaling
    down the images to a lower resolution on the server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，你也应该尝试限制大型对象的大小。当在客户端设备上显示图像时，通过在服务器上将图像缩放到较低的分辨率可以提高性能。
- en: You can limit the size of large objects at the very beginning. If your application
    allows users to upload files, you should consider constraining the uploaded file
    size.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一开始就限制大型对象的大小。如果你的应用程序允许用户上传文件，你应该考虑限制上传文件的大小。
- en: We have implemented a separate endpoint for product photos in our example Product
    API in the *Uploading and downloading files via the REST API* section in [*Chapter
    6*](B21843_06.xhtml#_idTextAnchor135) .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例产品API中，我们在[*第6章*](B21843_06.xhtml#_idTextAnchor135)的“通过REST API上传和下载文件”部分实现了一个单独的端点用于产品图片。
- en: In that example code, we used a method of the `MultipartFile` class to get the
    file content as a byte array. We also return a byte array in the method used to
    download the file. This approach allows our code to stay simple, but it has the
    drawback that the whole file is stored in the heap memory at once, although we
    do not do any processing that requires having the whole file in memory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个示例代码中，我们使用`MultipartFile`类的方法来获取文件内容作为字节数组。我们还在用于下载文件的方法中返回字节数组。这种方法允许我们的代码保持简单，但缺点是整个文件一次性存储在堆内存中，尽管我们没有进行需要整个文件在内存中的处理。
- en: We could optimize the memory usage by using `InputStream` / `OutputStream` instead
    of the byte array. Or we could use a reactive framework such as WebFlux (more
    on that in [*Chapter 11*](B21843_11.xhtml#_idTextAnchor310) ). However, we would
    have to go all the way, that is, also persisting the content using methods supporting
    streaming access.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`InputStream` / `OutputStream`而不是字节数组来优化内存使用。或者我们可以使用像WebFlux这样的响应式框架（更多内容请参阅[*第11章*](B21843_11.xhtml#_idTextAnchor310)）。然而，我们必须走到底，也就是说，也要使用支持流式访问的方法来持久化内容。
- en: Caching
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching may be the most popular performance improvement strategy. However, caching
    is not a silver bullet, and designing a correct caching setup is not easy, so
    before adopting this strategy, you should make sure you have considered the option
    of improving performance by applying a proper API design, as described in the
    previous sections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可能是最受欢迎的性能改进策略。然而，缓存并非万能，设计正确的缓存设置并不容易，因此在采用此策略之前，你应该确保你已经考虑了通过应用适当的API设计来提高性能的选项，如前几节所述。
- en: 'Caching involves a trade-off: it provides shorter response times at the cost
    of additional memory to store cached data and the risk of potential inconsistency
    if the cached data becomes stale.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存涉及权衡：它以额外的内存来存储缓存数据以及缓存数据过时可能导致的潜在不一致性的风险为代价，提供了更短的响应时间。
- en: 'Caching is closely tied to the challenge of cache invalidation—determining
    when data items in the cache should be removed. This may occur either because
    the cached data has become stale or to free up memory when it is unlikely that
    the cached items will be accessed again. Cache invalidation is considered one
    of the hardest problems in computing. The two most common ways to detect items
    that need to be removed from the cache are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存与缓存失效的挑战紧密相关——确定缓存中数据项何时应该被移除。这可能是因为缓存的数据已经过时，或者为了在不太可能再次访问缓存项时释放内存。缓存失效被认为是计算中最难的问题之一。检测需要从缓存中移除的项目最常见的两种方法如下：
- en: '*Least recently used* , based on the assumption that a resource that was last
    used a long time ago is unlikely to be used again'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最近最少使用*，基于假设最近长时间未使用的资源不太可能再次被使用'
- en: '*Least frequently used* , based on the assumption that resources that have
    been used frequently are likely to be used again'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最少使用*，基于假设经常使用的资源可能会再次被使用'
- en: To speed up the operations of an API, we can consider caching on the consumer
    (client) side of the API (caching the HTTP responses) and on the provider (server)
    side of the API (caching data needed to perform the operation and return a result).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快API的操作，我们可以考虑在API的消费者（客户端）端（缓存HTTP响应）和提供者（服务器）端（缓存执行操作和返回结果所需的数据）进行缓存。
- en: 'Caching on the provider (server) side can take many forms: it can be data from
    a database, results of expensive computations, or semi-processed results of downstream
    API calls. Caching on the service provider side is not specific to just API implementations,
    and therefore, it is beyond the scope of this book. For detailed guidance, you
    can refer to Mastering Spring Boot 3.0 by Ahmet Meric which covers broader caching
    strategies within Spring-based applications. For database access using JPA/Hibernate,
    it is advisable to understand the concept of first- and second-level cache. For
    general caching at the Spring component level, you should know about Spring Cache
    ( [https://docs.spring.io/spring-boot/reference/io/caching.html](https://docs.spring.io/spring-boot/reference/io/caching.html)
    ) and the `@Cacheable` annotation.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供者（服务器）端进行缓存可以采取多种形式：可以是数据库中的数据，昂贵的计算结果，或者下游API调用的半处理结果。在服务提供者端进行缓存并不仅限于API实现，因此，它超出了本书的范围。对于详细指导，您可以参考Ahmet
    Meric的《精通Spring Boot 3.0》，它涵盖了基于Spring的应用程序中的更广泛的缓存策略。对于使用JPA/Hibernate的数据库访问，建议了解一级和二级缓存的概念。对于Spring组件级别的通用缓存，您应该了解Spring
    Cache（[https://docs.spring.io/spring-boot/reference/io/caching.html](https://docs.spring.io/spring-boot/reference/io/caching.html)）和`@Cacheable`注解。
- en: To support the cacheability of data, the operations producing the data should
    be stateless, meaning we should get the same output data if the inputs are the
    same. This allows us to share the cached data across multiple instances of a service
    or multiple services using distributed caches such as Hazelcast or Redis. This
    way, data put in the cache by one instance of a service can be reused by another
    instance needing the same data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持数据的缓存能力，产生数据的操作应该是无状态的，这意味着如果输入相同，我们应该得到相同的数据输出。这使我们能够在多个服务实例或使用分布式缓存（如Hazelcast或Redis）的多个服务之间共享缓存数据。这样，一个服务实例放入缓存中的数据可以被需要相同数据的另一个实例重用。
- en: Caching on the client side
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端缓存
- en: Now, let’s focus on the caching on the client side. As the client does not have
    access to the implementation details of the service, it must use some hints to
    decide for which API responses and for how long a cached response can be used
    instead of calling the API again. Remember that client-side caching need not be
    done in the end client; it can also be done by a proxy server sitting between
    the server and the end client.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于客户端缓存。由于客户端无法访问服务的实现细节，它必须使用一些提示来决定对于哪些API响应以及缓存响应可以使用多长时间，而不是再次调用API。记住，客户端缓存不必在最终客户端完成；它也可以由位于服务器和最终客户端之间的代理服务器完成。
- en: Before we get into the details of cache control, it is important to verify the
    structure and granularity of the resources (endpoints) the API consists of. Consider
    placing data items that rarely change (they are good candidates for caching) in
    a separate resource from that of other items that change frequently. Only then
    can the caching be aligned well with the modification patterns of the data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解缓存控制之前，验证API所包含的资源（端点）的结构和粒度非常重要。考虑将很少更改的数据项（它们是缓存的好候选）放置在与经常更改的其他项目分开的资源中。只有这样，缓存才能与数据的修改模式很好地对齐。
- en: Requests using the `GET` method are considered cacheable by default. This rule
    is used by most web browsers; therefore, users sometimes need to force the browser
    to reload the web page (e.g., pressing *Ctrl* + *F5* on the Windows operating
    system) in case the page content has changed faster than the browser expected.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GET` 方法的请求默认被认为是可缓存的。这个规则被大多数网络浏览器所使用；因此，当页面内容变化速度超过浏览器预期时，用户有时需要强制浏览器重新加载网页（例如，在Windows操作系统上按
    *Ctrl* + *F5*）。
- en: Conversely, the `PUT` , `PATCH` , and `DELETE` methods used to modify data on
    the server cannot be implemented without contacting the server, so they are not
    suitable for caching.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，用于在服务器上修改数据的 `PUT`、`PATCH` 和 `DELETE` 方法，如果没有联系服务器就无法实现，因此它们不适合缓存。
- en: The `POST` method can be used to modify data on the server, such as creating
    a new order in our example Order Management API. It can also be used for read-only
    operations, usually for complex queries when you want to use a request body instead
    of putting the operation inputs in the URL or request headers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法可以用来修改服务器上的数据，例如在我们的示例订单管理API中创建新的订单。它也可以用于只读操作，通常用于复杂的查询，当你想使用请求体而不是将操作输入放在URL或请求标头中时。'
- en: 'A more detailed caching control, irrespective of the HTTP method used, can
    be achieved with standard HTTP response headers:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不论使用哪种HTTP方法，都可以通过标准HTTP响应标头来实现更详细的缓存控制：
- en: '`Cache-Control` : Supports a detailed specification of who (proxies or the
    end client) can cache the response with the same URL and when (for how long, based
    on a validation request)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cache-Control`：支持对谁（代理或终端客户端）可以缓存带有相同URL的响应以及何时（基于验证请求，持续多长时间）的详细指定。'
- en: '`ETag` : Short for “entity tag,” a value that can be used to check whether
    a resource has changed or not (in combination with the `If-None-Match` request
    header in the subsequent request to the same URL)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ETag`：简称为“实体标签”，一个可以用来检查资源是否已更改的值（与后续对同一URL的请求中的 `If-None-Match` 请求标头结合使用）。'
- en: Old headers ( `Expires` , `Last-Modified` , `Pragma` ), still supported for
    backward compatibility, are already superseded by the `Cache-Control` header.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 旧标头（`Expires`、`Last-Modified`、`Pragma`），尽管为了向后兼容仍然得到支持，但已被 `Cache-Control` 标头取代。
- en: Example – caching product photos
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 - 缓存产品照片
- en: We will demonstrate client-side caching using the standard HTTP headers on the
    product photo download endpoint created in [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135)
    .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在[*第6章*](B21843_06.xhtml#_idTextAnchor135)中创建的产品照片下载端点上的标准HTTP标头来演示客户端缓存。
- en: Photos are relatively large data objects that are not expected to change very
    frequently, hence, they are a good candidate for caching.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 照片是相对较大的数据对象，预计不会非常频繁地更改，因此它们是缓存的好候选。
- en: 'First, we will use the `Cache-Control` header to specify the time the client
    can store the photo in the cache. Inside the `ProductsApiController` class, we
    will change the `downloadProductPhoto` method body to include the header, specifying
    20 seconds as the time to cache the image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `Cache-Control` 标头来指定客户端可以在缓存中存储照片的时间。在 `ProductsApiController` 类中，我们将修改
    `downloadProductPhoto` 方法体以包含该标头，指定20秒作为缓存图像的时间：
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can start the Product API application and add a test product and its
    image by calling the `PUT` endpoints:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动产品API应用程序，通过调用 `PUT` 端点来添加一个测试产品和其图像：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Please note that the caching header tells the client it can store the resource
    in its cache, but the client is not required to do so. Simple clients may ignore
    the caching headers completely.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，缓存标头告诉客户端它可以将其资源存储在缓存中，但客户端不需要这样做。简单的客户端可能会完全忽略缓存标头。
- en: 'We will use a web browser because it understands and supports the caching headers;
    however, it does not load the `main` resource (the one whose URL is entered in
    the address bar) from the cache. This is why we will create an HTML file named
    `refer_img.html` that we will use as the `main` resource, and inside the HTML
    file we will refer to the image we want to download or cache:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用网络浏览器，因为它理解并支持缓存头；然而，它不会从缓存中加载`main`资源（在地址栏中输入的URL对应的资源）。这就是为什么我们将创建一个名为`refer_img.html`的HTML文件，并将其用作`main`资源，在HTML文件中我们将引用我们想要下载或缓存的图片：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we can open a new browser tab and turn on the developer tools (by pressing
    *F12* on Windows/Linux or *Option* + *⌘* + *I* on Mac). Within the developer tools,
    we switch to the **Network** tab.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开一个新的浏览器标签页并打开开发者工具（在Windows/Linux上按*F12*或在Mac上按*Option* + *⌘* + *I*）。在开发者工具中，我们切换到**网络**标签。
- en: 'We will open the `refer_img.html` file in the browser by dragging and dropping
    the file in the browser window. When the HTML file is opened for the first time,
    the browser must make the HTTP request to download the image:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在浏览器窗口中拖放文件来打开`refer_img.html`文件。当HTML文件首次打开时，浏览器必须发出HTTP请求以下载图片：
- en: '![Figure 10.1 – Downloading a new resource that is not available in the cache
    yet](img/B21843_10_01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 下载缓存中尚不可用的新资源](img/B21843_10_01.png)'
- en: Figure 10.1 – Downloading a new resource that is not available in the cache
    yet
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 下载缓存中尚不可用的新资源
- en: We can see the response headers, including **Cache-Control:** **max-age=20**
    .
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到响应头，包括**Cache-Control:** **max-age=20**。
- en: 'If we reload the page within 20 seconds, we should see the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在20秒内重新加载页面，我们应该看到以下内容：
- en: '![Figure 10.2 – Browser using the cached resource](img/B21843_10_02.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 浏览器使用缓存资源](img/B21843_10_02.png)'
- en: Figure 10.2 – Browser using the cached resource
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 浏览器使用缓存资源
- en: The text next to **Status Code** and the warning in the **Request Headers**
    section indicate that this time, no real network transmission has been done, and
    the cached image is displayed instead. In the **Response Headers** section, we
    can see that the access time (the **Date** header) is the same as before because
    the headers are cached as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态码**旁边的文本和在**请求头**部分的警告表明这次没有进行真正的网络传输，而是显示了缓存的图片。在**响应头**部分，我们可以看到访问时间（**Date**头）与之前相同，因为头部也被缓存了。'
- en: If we reload the page after more than 20 seconds, the image is freshly downloaded
    from the server, and we will see a new time as the value of the **Date** header.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在20秒后重新加载页面，图片将新鲜地从服务器下载，并且我们会看到**Date**头部的值是一个新的时间。
- en: 'Let’s make the caching more sophisticated with the `ETag` header. To make the
    value of the header change if and only if the image changes, we will compute the
    entity tag as a hash of the image bytes. The following method computes the hash
    using the SHA-1 algorithm and converts it to a printable string using Base64 encoding:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`ETag`头使缓存更复杂。为了使头部的值仅在图片更改时改变，我们将计算实体标签作为图片字节的哈希值。以下方法使用SHA-1算法计算哈希，并使用Base64编码将其转换为可打印的字符串：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can change the controller method to use the `ETag` header:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将控制器方法更改为使用`ETag`头：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After restarting the application, we can start testing again. The first load
    of the page will download the image normally:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新启动应用程序后，我们可以再次开始测试。页面的第一次加载将正常下载图片：
- en: '![Figure 10.3 – Browser downloading the resource with a new ETag](img/B21843_10_03.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 浏览器下载带有新ETag的资源](img/B21843_10_03.png)'
- en: Figure 10.3 – Browser downloading the resource with a new ETag
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 浏览器下载带有新ETag的资源
- en: The **Response Headers** section contains the **Etag** header with the computed
    hash string.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应头**部分包含计算出的哈希字符串的**Etag**头。'
- en: 'After that, no matter how long we wait, when reloading the page we will see
    the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，无论我们等待多久，当我们重新加载页面时，我们会看到以下内容：
- en: '![Figure 10.4 – Server responding with “304 Not Modified” when the ETag value
    is matched](img/B21843_10_04.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 当ETag值匹配时，服务器响应“304 Not Modified”](img/B21843_10_04.png)'
- en: Figure 10.4 – Server responding with “304 Not Modified” when the ETag value
    is matched
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 当ETag值匹配时，服务器响应“304 Not Modified”
- en: The **Date** header is fresh, meaning the browser did send a real request to
    the server. However, the **Status code** is **304 – Not Modified** , and no content
    is sent back.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**Date**头部是新鲜的，这意味着浏览器确实向服务器发送了真实请求。然而，**状态码**是**304 – Not Modified**，没有内容被发送回来。'
- en: '![Figure 10.5 – No content is returned with the “304 Not Modified” response](img/B21843_10_05.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – “304 Not Modified”响应不返回任何内容](img/B21843_10_05.png)'
- en: Figure 10.5 – No content is returned with the “304 Not Modified” response
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – “304 Not Modified”响应不返回任何内容
- en: This is because the browser, when making the request, sent the `If-None-Match`
    request header containing the `ETag` value it got in the previous request. Spring
    Framework automatically compares the value with the newly computed one, and if
    they match, it returns the `304` status in the response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当浏览器发出请求时，它发送了包含之前请求中得到的`ETag`值的`If-None-Match`请求头。Spring框架自动将值与新计算出的值进行比较，如果它们匹配，则在响应中返回`304`状态码。
- en: 'Let’s check what happens when we upload a new image:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查当我们上传新图像时会发生什么：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On the next reload of the page, we get this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面下次重新加载时，我们得到以下内容：
- en: '![Figure 10.6 – Server responding with “200 OK” and the full content when ETag
    not matched](img/B21843_10_06.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 当ETag不匹配时，服务器返回“200 OK”和完整内容](img/B21843_10_06.png)'
- en: Figure 10.6 – Server responding with “200 OK” and the full content when ETag
    not matched
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 当ETag不匹配时，服务器返回“200 OK”和完整内容
- en: As the **Etag** value has changed, the full content is returned, and the status
    code is **200 OK** .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**Etag**值已更改，返回了完整内容，状态码为**200 OK**。
- en: Command Query Responsibility Segregation (CQRS)
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）
- en: The **Command Query Responsibility Segregation** ( **CQRS** ) pattern is designed
    to separate read and write operations, improving performance and scalability in
    applications. By separating data modification (commands) from data retrieval (queries),
    each operation can be optimized independently. This separation is particularly
    useful in applications where read and write operations require different scalability
    strategies.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令查询责任分离**（**CQRS**）模式旨在分离读和写操作，提高应用程序的性能和可伸缩性。通过将数据修改（命令）与数据检索（查询）分离，每个操作都可以独立优化。这种分离在需要不同可伸缩策略的读和写操作的应用程序中特别有用。'
- en: 'For instance, an application with high read traffic can scale read operations
    without affecting write performance. This prevents slowdowns during read operations
    when resource-intensive write processes occur. In our example from [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    , we applied CQRS principles in a single application, but in practice, CQRS typically
    involves deploying two separate applications: one handling reads and the other
    handling writes.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个高读流量的应用程序可以在不影响写性能的情况下扩展读操作。这防止了在资源密集型的写过程发生时读操作变慢。在我们的例子中，[*第2章*](B21843_02.xhtml#_idTextAnchor050)
    ，我们在单个应用程序中应用了CQRS原则，但在实践中，CQRS通常涉及部署两个独立的应用程序：一个处理读操作，另一个处理写操作。
- en: By segregating read and write responsibilities, CQRS improves application performance
    by eliminating dependency between these operations, enabling independent scaling.
    To ensure both applications share the same API endpoint, a gateway can be used
    to redirect traffic to the correct application based on the operation being performed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离读和写责任，CQRS通过消除这些操作之间的依赖关系，实现独立扩展，从而提高应用程序的性能。为了确保两个应用程序共享相同的API端点，可以使用网关根据正在执行的操作将流量重定向到正确的应用程序。
- en: Echoing request data is not required
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不需要回显请求数据
- en: 'When implementing a POST or PUT endpoint, a commonly used convention is to
    return the created or updated entity in the HTTP response body. We even use this
    pattern in the design and code examples in our book. This pattern is usually connected
    to the reuse of data models: we already have a model for the entity that is used
    in the request and in the GET response, so why not use it also for the POST and
    PUT responses?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现POST或PUT端点时，常用的约定是在HTTP响应体中返回创建或更新的实体。我们甚至在我们的书中使用这个模式。这个模式通常与数据模型的复用相关：我们已经有了一个用于请求和GET响应中的实体的模型，为什么不用它来处理POST和PUT响应呢？
- en: 'There is nothing in the HTTP protocol or REST architecture telling us to echo
    back what we got in a POST or PUT request. On the contrary, there are some arguments
    against it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议或REST架构中没有告诉我们需要在POST或PUT请求中回显我们得到的内容。相反，有一些反对它的论点：
- en: Waste of network bandwidth and an increase in response time, especially for
    large entities.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浪费网络带宽并增加响应时间，尤其是对于大型实体。
- en: The client already has the data because it has just sent them in the request.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端已经有了数据，因为它刚刚在请求中发送了它们。
- en: It can lead to incorrect assumptions on the client side that the returned data
    are always up to date, but that might not be true if some other request on the
    same entity is performed in parallel.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能导致客户端产生错误假设，即返回的数据总是最新的，但如果在并行执行对同一实体的其他请求，这可能并不成立。
- en: 'Even if there is some additional information generated on the server, why do
    we automatically assume that the client needs the modified parts or the whole
    entity data? It breaks the single responsibility principle: a POST or PUT is expected
    to do a create/update. If the client needs to read the data, it can send a GET
    request. Different models for the read and write operations are also a natural
    consequence of applying the CQRS principle explained earlier in this chapter.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 即使服务器上生成了一些额外的信息，为什么我们会自动假设客户端需要修改的部分或整个实体数据？这违反了单一职责原则：POST或PUT操作预期执行创建/更新。如果客户端需要读取数据，它可以发送GET请求。读取和写入操作的不同模型也是应用本章先前解释的CQRS原则的自然结果。
- en: Asynchronous processing
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步处理
- en: HTTP, the heart of RESTful web services, is built around the synchronous request-response
    style of communication, making it easy to understand and implement. When talking
    about asynchronous APIs, we usually think of systems based on message brokers
    using protocols other than HTTP. Messaging-based communication is one of the main
    alternatives to RESTful web services mentioned in [*Chapter 1*](B21843_01.xhtml#_idTextAnchor015)
    . However, HTTP can also support asynchronous processing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP，RESTful Web服务的核心，围绕同步请求-响应通信风格构建，使其易于理解和实现。当谈论异步API时，我们通常想到基于消息代理的系统，使用除HTTP之外的协议。基于消息的通信是本章第1节中提到的RESTful
    Web服务的主要替代方案之一。然而，HTTP也可以支持异步处理。
- en: If the operation to be exposed via a REST API involves processing that takes
    a long time, waiting for the processing to finish before returning a response
    blocks the API client makes the API seem unresponsive and may lead to time-outs.
    The responsiveness of such an API can be improved by returning a response immediately
    after reading the request and saving the input data from it in reliable storage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要通过REST API公开的操作涉及耗时较长的处理，在返回响应之前等待处理完成会阻塞API客户端，使API看起来无响应，并可能导致超时。可以通过在读取请求后立即返回响应并将输入数据保存到可靠存储中，来提高此类API的响应性。
- en: The standard response status code in this case is `202 - Accepted` . The long-running
    processing can continue asynchronously without blocking the client. A separate
    API endpoint can be provided for the client to poll the status of the processing
    and receive its results when finished.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，标准的响应状态码是`202 - 已接受`。长时间运行的处理可以异步继续，而不会阻塞客户端。可以提供一个单独的API端点供客户端轮询处理状态，并在完成后接收其结果。
- en: For example, suppose we wanted to improve the photo upload endpoint of our example
    Product API so that it scales the photo to standard dimensions or performs other
    graphics enhancements on it. This kind of processing can be time-consuming. In
    such cases, we can decide to change the upload endpoint to an asynchronous one.
    We would store the unprocessed photo and return a `202` status code. The photo
    enhancement would be done asynchronously and a `GET` endpoint would be available
    for checking whether the photo is ready for use.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要改进示例产品API的图片上传端点，使其将图片缩放到标准尺寸或对其进行其他图形增强。这种处理可能耗时较长。在这种情况下，我们可以决定将上传端点更改为异步端点。我们将存储未处理的图片并返回`202`状态码。图片增强将异步完成，并提供一个`GET`端点以检查图片是否已准备好使用。
- en: After explaining how to ensure performance and scalability using general approaches
    at the level of analysis, design, and the HTTP standard, in the next section,
    we will move more to the level of implementation and focus on one feature of current
    versions of the Java platform that is particularly relevant to the performance
    and scalability of applications communicating using APIs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了如何通过分析、设计和HTTP标准层面的通用方法确保性能和可伸缩性之后，在下一节中，我们将更多地转向实现层面，并关注Java平台当前版本的一个特别相关的特性，即与使用API进行通信的应用程序的性能和可伸缩性。
- en: Increasing the throughput with virtual threads
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚拟线程提高吞吐量
- en: Virtual threads are a Java feature (final since Java 21) related to the performance
    of concurrent processing, a topic highly relevant to API implementation. All server-side
    applications are concurrent because they must handle concurrent incoming requests.
    However, with Java server-side frameworks such as Spring Boot, the code can focus
    on just one request using the so-called thread-per-request model. More advanced
    applications may need multiple threads per request. We will explore both usages
    of concurrency in the following subsections.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程是Java的一个特性（自Java 21起为final），与并发处理性能相关，这是一个与API实现高度相关的主题。所有服务器端应用都是并发的，因为它们必须处理并发传入的请求。然而，在使用Spring
    Boot等Java服务器端框架的情况下，代码可以仅关注一个请求，使用所谓的“每个请求一个线程”模型。更高级的应用可能需要每个请求多个线程。我们将在以下小节中探讨这两种并发用法。
- en: Garbage collector for threads
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程垃圾收集器
- en: Before going into more exact and detailed descriptions, let’s use a simple metaphor
    to explain the point of virtual threads even to developers who may find threads
    and concurrency difficult to understand. All Java developers must understand the
    concept of garbage collection, which is an abstraction that the Java Virtual Machine
    provides to liberate developers from the responsibility for allocating and freeing
    memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更精确和详细的描述之前，让我们用一个简单的比喻来解释虚拟线程的概念，即使对于可能觉得线程和并发难以理解的开发者来说也是如此。所有Java开发者都必须理解垃圾收集的概念，这是Java虚拟机提供的一种抽象，可以解放开发者从分配和释放内存的责任。
- en: Of course, you can still get an `OutOfMemoryError` , but if your application
    uses the objects in a typical way, at some point objects that are not used anymore
    are not referenced from any other object, so the runtime can detect those objects
    automatically, and thus the memory they occupy can be freed and reused. This abstraction,
    used by programmers since the very first version of Java, simplifies the code
    and prevents many hard-to-detect errors related to direct memory access and allocation
    known from programming in C or other languages without a garbage collector.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你仍然可能会遇到`OutOfMemoryError`，但如果你的应用以典型方式使用对象，那么在某个时刻，不再使用的对象不会被任何其他对象引用，因此运行时可以自动检测这些对象，从而释放并重用它们所占据的内存。这种抽象自Java的第一个版本以来就被程序员使用，简化了代码，并防止了许多与直接内存访问和分配相关的难以检测的错误，这些错误在C或其他没有垃圾收集器的语言编程中是众所周知的。
- en: Similarly to what a garbage collector does with memory, virtual threads provide
    the illusion of an (almost) infinite number of threads. What really happens is,
    in a typical application using one thread per incoming network request (more on
    that in the next section), the JVM, together with the standard libraries, can
    automatically detect when the platform thread would be blocked due to waiting
    (e.g., for I/O). To prevent this, the virtual thread state is moved to the heap,
    and the platform thread is reused to work on some other request.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于垃圾收集器对内存的处理，虚拟线程提供了（几乎）无限数量的线程的错觉。实际上发生的情况是，在一个典型的应用中，每个传入的网络请求使用一个线程（更多内容将在下一节中介绍），JVM与标准库一起可以自动检测平台线程会因为等待（例如，I/O）而被阻塞。为了防止这种情况，虚拟线程的状态被移动到堆中，平台线程被重用来处理其他请求。
- en: For most applications, relying on virtual threads to efficiently utilize platform
    threads, rather than using platform threads directly, will likely depend on the
    garbage collector to clean up memory objects at the end of each request.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用来说，依赖虚拟线程来高效利用平台线程，而不是直接使用平台线程，很可能会依赖于垃圾收集器在每个请求结束时清理内存对象。
- en: '![Figure 10.7 – Illustration of how virtual threads work, split into layers](img/B21843_10_07.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 虚拟线程工作原理的说明，分为层](img/B21843_10_07.png)'
- en: Figure 10.7 – Illustration of how virtual threads work, split into layers
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 虚拟线程工作原理的说明，分为层
- en: Thread-per-request model
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个请求一个线程模型
- en: Our example APIs are implemented using Spring Web, a framework using the thread-per-request
    model. This means that for every HTTP request, the web server used by the framework
    takes a dedicated Java thread and, within that thread, it invokes the controller
    method matching the request path and method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例API使用Spring Web实现，这是一个采用“每个请求一个线程”模型的框架。这意味着对于每个HTTP请求，框架所使用的Web服务器都会分配一个专用的Java线程，并在该线程中调用与请求路径和方法匹配的控制方法。
- en: The advantage of the thread-per-request model is that it allows the classic
    imperative programming style with code blocks containing statements executed in
    the order they appear in the source code. This code style is easy to read and
    understand. It is also easy to debug because when the execution stays within one
    thread, the call stack displayed in debugging tools is complete, letting the developer
    track the method invocations n icely at all code levels.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 线程每请求模型的优势在于它允许使用经典的命令式编程风格，其中包含按照源代码中出现的顺序执行的代码块。这种代码风格易于阅读和理解。它也易于调试，因为当执行保持在单个线程内时，调试工具中显示的调用栈是完整的，让开发者能够很好地跟踪所有代码级别的函数调用。
- en: Unfortunately, the thread-per-request model without virtual threads has limited
    scalability because the threads provided by the operating system (so-called platform
    threads) are an expensive resource. Every platform thread occupies a considerable
    amount of memory, so the number of platform threads a JVM can use is limited.
    Web servers using platform threads must take a thread that is needed to handle
    an incoming request from a limited thread pool. If there are no threads left in
    the pool, the request waits until a thread is available.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有虚拟线程的线程每请求模型的可扩展性有限，因为操作系统提供的线程（所谓的平台线程）是一种昂贵的资源。每个平台线程都占用相当大的内存，因此JVM可以使用的平台线程数量是有限的。使用平台线程的Web服务器必须从有限的线程池中获取一个线程来处理传入的请求。如果池中没有剩余的线程，请求将等待直到有线程可用。
- en: The controller method and any methods invoked from the controller method (let’s
    call it handling code) hold the dedicated thread until the controller method returns
    or throws, transferring the execution back to the Spring Web framework. It is
    quite common that the handling code contains blocking operations. A blocking operation
    prevents the CPU from performing useful work because it halts execution while
    waiting for required data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器方法和从控制器方法调用的任何方法（让我们称其为处理代码）会保留专用线程，直到控制器方法返回或抛出异常，将执行权交回Spring Web框架。处理代码中包含阻塞操作是很常见的情况。阻塞操作阻止CPU执行有用的工作，因为它在等待所需数据时停止执行。
- en: To illustrate this, let’s look at the execution of the “create order” operation
    of the Order Management API.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看看订单管理API的“创建订单”操作的执行。
- en: 'Let’s first look at `OrderManagementApiController.java` :'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '首先让我们看看 `OrderManagementApiController.java` :'
- en: '[PRE6]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let’s see `OrdersCommandUseCaseImpl.java` :'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，让我们看看 `OrdersCommandUseCaseImpl.java` :'
- en: '[PRE7]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Blocking operations (commonly caused by the need for network I/O communication)
    can have a disastrous performance impact because, in many applications, they take
    orders of magnitude longer than the surrounding non-blocking (CPU-heavy) operations.
    Communication is an essential part of the processing within distributed applications
    (microservices). It is important to understand that the time spent waiting for
    data to be transferred over a remote API (or from a complex database query) is
    typically hundreds of milliseconds to seconds. In contrast, the CPU processing
    time needed to perform the business logic of most enterprise applications once
    all the data is available (even if we consider more complex operations such as
    JSON parsing and serialization) is orders of magnitude shorter – it is counted
    in microseconds.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞操作（通常由网络I/O通信的需求引起）可能会对性能产生灾难性的影响，因为在许多应用程序中，它们比周围的非阻塞（CPU密集型）操作慢几个数量级。通信是分布式应用程序（微服务）处理过程中的一个基本部分。重要的是要理解，在远程API（或从复杂的数据库查询）传输数据所需的时间通常是数百毫秒到数秒。相比之下，一旦所有数据都可用，执行大多数企业应用程序的业务逻辑所需的CPU处理时间要短得多——即使我们考虑更复杂的操作，如JSON解析和序列化——它以微秒计。
- en: This means that with a thread-per-request model, the CPU that is blocked by
    the input/output operations cannot be used to serve other requests; in a service
    under heavy load, more than 99% of the time, the CPU will be idle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在线程每请求模型下，被输入/输出操作阻塞的CPU无法用于服务其他请求；在一个负载很重的服务中，超过99%的时间CPU将是空闲的。
- en: 'One way to address this problem is to use a reactive programming framework
    (more on that in [*Chapter 11*](B21843_11.xhtml#_idTextAnchor310) ), but that
    means abandoning the thread-per-request model with its advantages described previously:
    code that is easy to understand and debug.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用响应式编程框架（关于这一点将在[*第11章*](B21843_11.xhtml#_idTextAnchor310)中详细介绍），但这意味着放弃之前描述的具有优势的线程每请求模型：易于理解和调试的代码。
- en: Virtual threads are clever because they let developers keep the thread-per-request
    model while allowing efficient use of the platform threads. When a virtual thread
    needs to use the CPU, it is mounted on a platform thread (also called a *carrier
    thread* ). When a virtual thread hits a blocking operation, its state of execution
    is stored in the heap memory and its carrier thread is released so that it can
    be used to execute a different virtual thread. When the blocking operation finishes,
    the virtual thread can mount any free carrier thread (that can be different from
    the one it used before getting blocked), restore its state from the heap, and
    continue its execution.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程很聪明，因为它们允许开发者保持按请求分配线程的模型，同时允许高效地使用平台线程。当一个虚拟线程需要使用 CPU 时，它会被挂载到一个平台线程（也称为
    *载体线程*）上。当一个虚拟线程遇到阻塞操作时，其执行状态会被存储在堆内存中，其载体线程被释放，以便它可以用来执行另一个虚拟线程。当阻塞操作完成时，虚拟线程可以挂载任何可用的载体线程（可能不同于它之前阻塞时使用的那个），从堆中恢复其状态，并继续执行。
- en: Virtual threads, in contrast to platform threads, are cheap, so an application
    can use millions of them. An HTTP server and an application framework can provide
    a new virtual thread for every incoming request, no matter how many requests are
    already waiting for an I/O operation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与平台线程相比，虚拟线程成本低廉，因此应用程序可以使用数百万个虚拟线程。一个 HTTP 服务器和应用框架可以为每个传入请求提供一个新的虚拟线程，无论有多少请求正在等待
    I/O 操作。
- en: 'To use virtual threads to process incoming requests, you just need to configure
    the framework to turn on the feature. With Spring Boot 3.2 or later and Java 21
    or later, you can use the following configuration property:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用虚拟线程来处理传入请求，你只需要配置框架以启用该功能。在 Spring Boot 3.2 或更高版本和 Java 21 或更高版本中，你可以使用以下配置属性：
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can continue using the code style containing the blocking operations, knowing
    that the blocked threads will be virtual ones, and the CPU will be used efficiently.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续使用包含阻塞操作的代码风格，知道阻塞的线程将是虚拟线程，CPU 将会被高效地使用。
- en: Besides handling many incoming requests using the thread-per-request model,
    an application may need to explicitly perform multiple operations in parallel
    to handle just one incoming request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用按请求分配线程的模型来处理许多传入请求外，一个应用程序可能需要显式地并行执行多个操作来处理单个传入请求。
- en: Parallel processing within one request
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个请求内的并行处理
- en: In the context of integration-heavy applications, a common case is optimizing
    the latency when handling the request requires multiple independent remote APIs
    to be called.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成密集型应用程序的上下文中，一个常见的情况是在处理请求时需要调用多个独立的远程 API 来优化延迟。
- en: Imagine a price quote API that calls the APIs of multiple vendors, compares
    their prices, and responds with the best one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个报价 API，它调用多个供应商的 API，比较他们的价格，并返回最佳报价。
- en: Java provides a useful abstraction in the form of the `ExecutorService` class.
    Each operation that should be executed in parallel is a task that you submit to
    `ExecutorService` .
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了 `ExecutorService` 类这样的有用抽象。每个应该并行执行的操作都是一个提交给 `ExecutorService` 的任务。
- en: When the `ExecutorService` class is created, you specify a strategy it should
    use to manage the threads that execute the tasks. Without virtual threads, the
    typical strategy would be to use a thread pool of a fixed size. The thread pool
    allows a certain number of parallel tasks, but the number is limited because the
    number of platform threads is limited.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `ExecutorService` 类时，你指定它应该使用什么策略来管理执行任务的线程。如果没有虚拟线程，典型的策略将是使用固定大小的线程池。线程池允许一定数量的并行任务，但数量是有限的，因为平台线程的数量是有限的。
- en: 'With virtual threads, we can let `ExecutorService` use a new virtual thread
    for every task without a thread pool and without having to specify the size of
    that pool:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟线程，我们可以让 `ExecutorService` 为每个任务使用一个新的虚拟线程，而不需要线程池，也不需要指定该池的大小：
- en: '[PRE9]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have briefly explained that, in a nutshell, virtual threads enhance CPU efficiency
    by minimizing idle threads and ensuring more time is spent performing useful operations.
    The immediate effect of that is an increase in throughput (the amount of work
    done per unit of time). However, throughput and response time are usually connected.
    The increased throughput means that a given CPU power can handle a higher load
    without some of the requests having to wait for a thread to become available.
    Consequently, the response time can be improved as well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要解释了，简而言之，虚拟线程通过最小化空闲线程并确保更多时间用于执行有用操作来提高CPU效率。这种直接效果是吞吐量的增加（单位时间内完成的工作量）。然而，吞吐量和响应时间通常是相关的。增加的吞吐量意味着给定的CPU功率可以处理更高的负载，而无需某些请求等待线程变得可用。因此，响应时间也可以得到改善。
- en: So far, we have discussed ways to improve performance and scalability that can
    be applied mostly within individual services. However, the infrastructure components
    that reside between the individual components connected by APIs are usually also
    involved in achieving satisfactory performance and scalability of the entire distributed
    system (the application). The following section will briefly introduce you to
    these infrastructure components.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了可以在单个服务内应用的方式来提高性能和可伸缩性。然而，位于通过API连接的各个组件之间的基础设施组件通常也参与实现整个分布式系统（应用程序）的满意性能和可伸缩性。下一节将简要介绍这些基础设施组件。
- en: Virtual thread pinning
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟线程固定
- en: There are situations when a virtual thread performing a blocking operation cannot
    release the platform thread for other virtual threads. Using the official terminology
    for this situation, we say that the virtual thread cannot unmount from its carrier
    because the virtual thread is pinned to the carrier thread.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，执行阻塞操作的虚拟线程无法释放平台线程以供其他虚拟线程使用。使用官方术语描述这种情况，我们说虚拟线程无法从其载体卸载，因为虚拟线程被固定在载体线程上。
- en: As of Java 21, thread pinning can occur in two cases.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Java 21，线程固定可以发生在两种情况下。
- en: The first case of thread pinning is when the virtual thread is performing a
    native code. This is inevitable because the JVM cannot take away the platform
    thread from the non-Java code safely.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程固定的第一个情况是当虚拟线程正在执行本地代码。这是不可避免的，因为JVM无法安全地从非Java代码中移除平台线程。
- en: The second case is when the virtual thread runs code inside a synchronized block
    or method. This is a limitation of the implementation of the support for virtual
    threads within JVM. If your application code or the code of some of its dependencies
    (web server or libraries) uses Java synchronized constructs, it may limit the
    performance of virtual threads compared to the expectation. In some cases, it
    can even lead to deadlocks where all the available platform threads are blocked
    by pinned threads waiting on a synchronized lock.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是当虚拟线程在同步块或方法内运行代码。这是JVM内部对虚拟线程支持实现的一个限制。如果你的应用程序代码或其依赖项（如Web服务器或库）使用Java同步结构，这可能会限制虚拟线程的性能，与预期相比。在某些情况下，甚至可能导致死锁，其中所有可用的平台线程都被固定线程阻塞，等待同步锁。
- en: This means you should not turn on virtual threads blindly. It is recommended
    to run performance tests on your application with and without virtual threads.
    You should be aware of your application dependencies and try to use the latest
    versions of them. Remember that Spring Boot uses the embedded Tomcat as the web
    server (servlet container) by default, but it also supports switching to other
    web servers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不应该盲目地开启虚拟线程。建议你在应用程序中启用和禁用虚拟线程的情况下进行性能测试。你应该了解你的应用程序依赖项，并尝试使用它们的最新版本。记住，Spring
    Boot默认使用嵌入式Tomcat作为Web服务器（servlet容器），但它也支持切换到其他Web服务器。
- en: The pinning of virtual threads caused by the synchronized constructs is eliminated
    in Java 24. So, even if the Java version you use supports all the features your
    application needs, it is always a good idea to upgrade to a new Java version as
    soon as possible to get fixes and improvements to the implementation of the Java
    features you use. New versions of Java/OpenJDK also come with improvements in
    tooling that can help to diagnose and fix various performance problems, possibly
    including virtual thread pinning.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同步结构引起的虚拟线程的固定问题在Java 24中已被消除。因此，即使你使用的Java版本支持你应用程序需要的所有功能，尽快升级到新版本的Java也是一个好主意，以获取对使用的Java功能的实现进行的修复和改进。Java/OpenJDK的新版本还带来了工具改进，可以帮助诊断和修复各种性能问题，可能包括虚拟线程固定问题。
- en: Using infrastructure support
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基础设施支持
- en: Ideally, you want to design and implement your APIs so they can work well without
    depending on a specific infrastructure setup. However, software developers should
    be aware that components external to the services they develop can be used to
    enhance the performance and scalability of the system.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你希望设计和实现你的API，以便它们可以在不依赖于特定基础设施设置的情况下良好工作。然而，软件开发者应该意识到，他们开发的服务之外的外部组件可以用来增强系统的性能和可伸缩性。
- en: 'There are several types of infrastructure components:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种类型的基础设施组件：
- en: '**Load balancer** : A component distributes the requests among multiple service
    instances providing the same API. A load balancer is inevitable for horizontal
    scaling.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡器**：一个组件将请求分配给多个提供相同API的服务实例。负载均衡器对于水平扩展是不可避免的。'
- en: '**Proxy** : A component that is an HTTP server and client at the same time.
    It receives a request and fulfills it by making another request to the actual
    service providing the API. Proxies let us add various functionalities between
    the client and the server, of which caching is the most important one for performance:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：一个同时是HTTP服务器和客户端的组件。它接收一个请求，通过向实际提供API的服务发送另一个请求来满足它。代理允许我们在客户端和服务器之间添加各种功能，其中缓存对于性能来说是最重要的：'
- en: A proxy that receives requests with public URLs and turns them into requests
    within a private network is called a **reverse proxy** .
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接收带有公共URL的请求并将其转换为私有网络内的请求的代理被称为**反向代理**。
- en: Proxies combining different functionalities supporting APIs are also called
    **API gateways** .
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合不同功能支持API的代理也被称为**API网关**。
- en: '**Content delivery network (CDN)** : This is a network of proxies that are
    geographically distributed so that a client can access a URL via a nearby proxy,
    shortening the response times.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容分发网络（CDN）**：这是一个地理分布的代理网络，客户端可以通过附近的代理访问URL，从而缩短响应时间。'
- en: The components mentioned here often combine performance and security concerns.
    One problem where the overlap is obvious is the deflecting of **denial of service**
    ( **DoS** ) and **distributed denial of service** ( **DDoS** ) attacks. It involves
    throttling, which is limiting excessive traffic from one source to ensure that
    the service remains available to all its clients.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的组件通常结合性能和安全问题。一个重叠明显的例子是防御**拒绝服务**（**DoS**）和**分布式拒绝服务**（**DDoS**）攻击。这涉及到限制来自单一来源的过多流量，以确保服务对所有客户端都可用。
- en: It follows from this that the architecture in which an API-providing service
    is embedded may contain multiple components that are often beyond the control
    of the API developers. This is another reason the best possible approach to API
    design is to adhere to the standards defined by HTTP and other internet standards
    (RFCs). This will ensure that your API works well with the surrounding infrastructure.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个意义上说，嵌入API提供服务的架构可能包含多个组件，这些组件通常超出了API开发者的控制。这也是为什么API设计的最佳方法是要遵循HTTP和其他互联网标准（RFCs）定义的标准。这将确保你的API与周围的基础设施良好工作。
- en: We have gone through several possible performance and scalability issues, along
    with ways to address them. However, in the last section of this chapter, it is
    essential to show how to examine the performance of a particular service under
    a particular workload, because only in this way can the real problems be detected
    and targeted for resolution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了几个可能出现的性能和可伸缩性问题，以及解决它们的方法。然而，在本章的最后部分，展示如何检查特定服务在特定负载下的性能是至关重要的，因为只有通过这种方式，才能检测并针对实际问题进行解决。
- en: Designing and executing effective load tests
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和执行有效的负载测试
- en: '[*Chapter 8*](B21843_08.xhtml#_idTextAnchor223) explained various the tests
    that can be used to ensure the correctness of APIs, meaning that these tests check
    that the APIs and services behind them process the input data as `expected` and
    respond with the expected output data. They focus on the exact values of the detailed
    attributes of the input and output data and their semantics to verify the functional
    requirements of the application. To do so, they try different test data combinations
    to cover the most common use cases as well as negative scenarios and edge cases.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第8章*](B21843_08.xhtml#_idTextAnchor223) 解释了各种可以用来确保API正确性的测试，这意味着这些测试检查API及其背后的服务是否按照`预期`处理输入数据，并以预期的输出数据响应。它们关注输入和输出数据的详细属性的确切值及其语义，以验证应用程序的功能需求。为此，它们尝试不同的测试数据组合，以覆盖最常见的用例以及负面场景和边缘情况。'
- en: In the context of performance and scalability, we test the application from
    a different angle. Instead of categorizing test cases by functional requirements
    and checking the exact data values, we usually try a smaller set of use cases
    characterized by the expected load they put on the application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能和可扩展性的背景下，我们从不同的角度测试应用程序。而不是按功能需求对测试用例进行分类并检查确切的数据值，我们通常尝试一组较小的用例，这些用例以它们对应用程序施加的预期负载为特征。
- en: However, the number of repetitions of identical or very similar requests sent
    to the application will be significantly higher. The timing aspect is very important,
    so the requests are made at a frequency that simulates real traffic, including
    load fluctuations. Multiple simultaneous requests are sent to simulate many users
    using the application at the same time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，发送到应用程序的相同或非常相似的请求的重复次数将显著增加。时间方面非常重要，因此请求的频率模拟了真实流量，包括负载波动。发送多个并发请求以模拟许多用户同时使用应用程序。
- en: These differences in load testing in comparison to the other types of test imply
    that although it is possible to use the same tools for both, doing load testing
    using tools that specialize in it is easier, more resource-efficient, and provides
    results that are more accurate and presented in an appropriate form.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的测试相比，负载测试中的这些差异意味着尽管可以使用相同的工具进行两者，但使用专门从事负载测试的工具进行负载测试更容易、更高效，并且提供更准确的结果，并以适当的形式呈现。
- en: Example – load-testing the Order Management API
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 对订单管理API进行负载测试
- en: We will load-test our example Order Management API using the tool called Gatling
    (its documentation is available at [https://docs.gatling.io/](https://docs.gatling.io/)
    ). Gatling integrates with Java very well, so we can include the load test in
    our Java source code and run it using a Maven plugin without having to install
    a separate program.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用名为Gatling的工具（其文档可在[https://docs.gatling.io/](https://docs.gatling.io/)
    获取）对我们的示例订单管理API进行负载测试。Gatling与Java集成得很好，因此我们可以将负载测试包含在我们的Java源代码中，并通过Maven插件运行它，而无需安装单独的程序。
- en: 'First, we will add the Gatling dependencies (with the `test` scope) to the
    `pom.xml` file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加Gatling依赖项（带有`test`范围）到`pom.xml`文件中：
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we can start writing the test class, also known as a Gatling simulation.
    Our simulation will try to create many new orders via the Order Management API:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始编写测试类，也称为Gatling模拟。我们的模拟将尝试通过订单管理API创建许多新订单：
- en: '`public class CreateOrderSimulation extends Simulation {`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`public class CreateOrderSimulation extends Simulation {`'
- en: 'The top level of the test is in the class constructor:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最高级别位于类构造函数中：
- en: '[PRE11]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code refers to the `HTTP_PROTOCOL_BUILDER` and `POST_SCENARIO_BUILDER`
    constants, which describe the requests that should be sent to the tested API.
    The `injectOpen` method specifies the timing and parallelization of the requests:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 代码引用了`HTTP_PROTOCOL_BUILDER`和`POST_SCENARIO_BUILDER`常量，这些常量描述了应该发送到测试API的请求。`injectOpen`方法指定了请求的时机和并行化：
- en: During the first 10 seconds of the simulation, the rate of users (requests)
    grows from 10 per second to 300 per second.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟的前10秒内，用户（请求）的速率从每秒10个增长到每秒300个。
- en: During the following 80 seconds, the rate of requests is constant at 300 per
    second.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接下来的80秒内，请求的速率保持恒定，每秒300个。
- en: At the end, we can see the test assertions that expect the maximum response
    time of 5,000 milliseconds and that more than 90% of the requests should be successful.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到测试断言，预期最大响应时间为5,000毫秒，并且超过90%的请求应该成功。
- en: 'To make the performance differences more visible, we will modify the code of
    the Product API (the API the Order Management API depends on), adding an artificial
    delay of 1 second in the `getProductById` method of the `ProductsQueryUseCaseImpl`
    class:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使性能差异更明显，我们将修改产品API（订单管理API所依赖的API）的代码，在`ProductsQueryUseCaseImpl`类的`getProductById`方法中添加1秒的人工延迟：
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can start the Product API application. Our test orders contain the
    product ID AK21101, so we need to create it using the Product API. We can use
    the Swagger UI, the `curl` command, or, if we use IntelliJ IDEA, we can use a
    simple text file with the `.http` extension to send an HTTP request:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动产品API应用程序。我们的测试订单包含产品ID AK21101，因此我们需要使用产品API来创建它。我们可以使用Swagger UI，`curl`命令，或者如果我们使用IntelliJ
    IDEA，我们可以使用一个简单的文本文件，具有`.http`扩展名来发送HTTP请求：
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we start the Product Management API with these two configuration properties
    disabled by commenting them out using the `#` character:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们禁用这两个配置属性并使用`#`字符注释掉它们来启动产品管理API：
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The load test is started by running the following Maven command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下Maven命令启动负载测试：
- en: '[PRE15]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As the test is running, we can observe that after the load reaches a certain
    point, many requests fail (the count of `KO` , meaning `not OK` , is growing).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试运行过程中，我们可以观察到当负载达到一定点后，许多请求失败（`KO`计数，表示`not OK`，正在增长）。
- en: The whole test fails because neither the response time nor the percentage of
    successful requests is fulfilled.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 整个测试失败，因为响应时间和成功请求的百分比都没有满足。
- en: 'The detailed graphical visualization of the test can be found in the `target/gatling`
    directory:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的详细图形可视化可以在`target/gatling`目录中找到：
- en: '![Figure 10.8 – Most of the requests failed as the service was not able to
    cope with the load](img/B21843_10_08.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 由于服务无法处理负载，大多数请求失败](img/B21843_10_08.png)'
- en: Figure 10.8 – Most of the requests failed as the service was not able to cope
    with the load
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 由于服务无法处理负载，大多数请求失败
- en: 'Now, let’s try to improve the performance by enabling virtual threads in the
    Order Management API:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过在订单管理API中启用虚拟线程来提高性能：
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After restarting the application and the Gatling test, we get different results.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新启动应用程序和Gatling测试后，我们得到了不同的结果。
- en: '![Figure 10.9 – Enabling virtual threads revealed a bottleneck in the database
    connection pool](img/B21843_10_09.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 启用虚拟线程揭示了数据库连接池的瓶颈](img/B21843_10_09.png)'
- en: Figure 10.9 – Enabling virtual threads revealed a bottleneck in the database
    connection pool
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 启用虚拟线程揭示了数据库连接池的瓶颈
- en: The number of successful responses increased slightly, but still, most of them
    failed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 成功响应的数量略有增加，但仍然，大多数都失败了。
- en: 'Looking at the console log output of the Order Management API application,
    we find many repetitions of the following error:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 查看订单管理API应用程序的控制台日志输出，我们发现许多以下错误的重复：
- en: '[PRE17]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By enabling virtual threads, we removed the limiting caused by a thread pool
    on the number of requests our application was able to process in parallel. However,
    another part of the application has now become the bottleneck, namely the database
    connection pool.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用虚拟线程，我们消除了线程池对应用程序能够并行处理请求数量的限制。然而，应用程序的另一个部分现在已成为瓶颈，即数据库连接池。
- en: 'The default limit for the Hikari connection pool is 10 database connections,
    and that is exhausted very quickly given the 1-second delay of the Product API.
    The Order Management API must wait until it can finish the database transaction
    and release the connection. To get rid of the bottleneck, we set the maximum number
    of connections to `500` :'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Hikari连接池的默认限制是10个数据库连接，考虑到产品API的1秒延迟，这很快就会被耗尽。订单管理API必须等待直到它可以完成数据库事务并释放连接。为了消除瓶颈，我们将最大连接数设置为`500`：
- en: '[PRE18]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that this is just a simple example to make the impact of virtual threads
    very visible. In a real application, such a high number of connections could cause
    a problem with the database, and we would probably have to use a different solution,
    such as starting the transaction only after we get the price from the Product
    API or fixing the long response time of the Product API.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只是一个简单的例子，目的是使虚拟线程的影响非常明显。在实际应用程序中，如此高的连接数可能会引起数据库问题，我们可能不得不使用不同的解决方案，例如只在从产品API获取价格后开始事务，或者修复产品API的长时间响应。
- en: After this change, we can restart the Order Management API and the Gatling test
    again.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更改之后，我们可以重新启动订单管理API和Gatling测试。
- en: 'Now, finally, our test passes, and the results are very satisfactory:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最终，我们的测试通过了，结果非常令人满意：
- en: '![Figure 10.10 – Service using virtual threads can handle the high frequency
    of requests](img/B21843_10_10.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 使用虚拟线程的服务可以处理高频率的请求](img/B21843_10_10.png)'
- en: Figure 10.10 – Service using virtual threads can handle the high frequency of
    requests
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 使用虚拟线程的服务可以处理高频率的请求
- en: All requests were OK, and all the response times were very close to 1 second
    from the Product API.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求都正常，所有从产品API返回的响应时间都非常接近1秒。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the specifics of performance and scalability in
    the context of RESTful APIs. We explored various design approaches and techniques
    to improve the two non-functional requirements. We saw an example of using caching
    headers to reduce the volume of network traffic between the client and the server.
    We delved deeper into virtual threads, a highly performance-relevant feature of
    new Java versions. Finally, we verified the achievement of the expected performance
    improvements using a load test. In the next chapter, we will show how the principles
    described in this book can be applied to back-end Java frameworks beyond Spring
    Boot, and how you can make your application more future-proof and vendor-neutral
    by using community-driven standards.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在RESTful API的背景下性能和可扩展性的具体细节。我们探讨了各种设计方法和技巧来提高这两个非功能性要求。我们看到了一个使用缓存头来减少客户端和服务器之间网络流量体积的例子。我们深入探讨了虚拟线程，这是新Java版本中高度相关的性能特性。最后，我们通过负载测试验证了预期性能改进的实现。在下一章中，我们将展示本书中描述的原则如何应用于Spring
    Boot之外的Java后端框架，以及如何通过使用社区驱动的标准来使你的应用更具未来性和供应商中立性。
