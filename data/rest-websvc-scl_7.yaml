- en: Chapter 7. JSON, HATEOAS, and Documentation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章 JSON、HATEOAS 和文档
- en: In this last chapter, we're going to look a bit deeper into a couple of important
    parts of REST. We'll start with a more in-depth explanation of the different JSON
    libraries that are available, and after that, we'll explore the HATEOAS concept
    and explain how you can apply that principle to the frameworks explained in this
    book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将更深入地探讨 REST 的一些重要部分。我们将从对可用的不同 JSON 库的更深入解释开始，然后我们将探索 HATEOAS 概念，并解释您如何将这一原则应用于本书中解释的框架。
- en: Let's start with JSON.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 JSON 开始。
- en: Working with JSON
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作与 JSON
- en: 'There are many different JSON frameworks available for Scala. In this chapter,
    we''ll look at four of the most important and most used frameworks. The following
    table gives a short introduction to the frameworks that we''ll use:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala，有许多不同的 JSON 框架可供选择。在本章中，我们将探讨四个最重要和最常用的框架。以下表格简要介绍了我们将使用的框架：
- en: '| Framework | Description |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 描述 |'
- en: '| --- | --- |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Argonaut | Argonaut is an extensive JSON library that offers a functional
    approach to working with JSON. It has a very extensive JSON traversal and search
    functionality. You can find out more about it at [http://argonaut.io](http://argonaut.io).
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| Argonaut | Argonaut 是一个功能丰富的 JSON 库，它提供了以函数式方法处理 JSON 的方法。它具有非常广泛的 JSON 遍历和搜索功能。您可以在[http://argonaut.io](http://argonaut.io)了解更多信息。|'
- en: '| Json4s | Json4s is a library that provides a standard way of parsing and
    rendering JSON. It provides a standardized interface on top of the existing libraries,
    such as lift-json and Jackson. You can find out more about it at [http://json4s.org/](http://json4s.org/).
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| Json4s | Json4s 是一个提供标准方式解析和渲染 JSON 的库。它在上面的库（如 lift-json 和 Jackson）之上提供了一个标准化的接口。您可以在[http://json4s.org/](http://json4s.org/)了解更多信息。|'
- en: '| Play JSON | Play JSON provides JSON support for the Play 2 framework. This
    library, however, can also be used in a standalone manner, and provides a very
    easy to use way of working with JSON. You can find out more about it at [https://www.playframework.com/documentation/2.4.x/ScalaJson](https://www.playframework.com/documentation/2.4.x/ScalaJson).
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| Play JSON | Play JSON 为 Play 2 框架提供了 JSON 支持。然而，这个库也可以独立使用，并提供了一种非常易于使用的方式来处理
    JSON。您可以在[https://www.playframework.com/documentation/2.4.x/ScalaJson](https://www.playframework.com/documentation/2.4.x/ScalaJson)了解更多信息。|'
- en: '| spray-json | spray-json is a lightweight JSON framework, which provides some
    basic functions for processing JSON. It was part of the Spray framework, but can
    also be used as a standalone. You can find out more about it at [https://github.com/spray/spray-json](https://github.com/spray/spray-json).
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| spray-json | spray-json 是一个轻量级的 JSON 框架，它提供了一些处理 JSON 的基本功能。它是 Spray 框架的一部分，但也可以独立使用。您可以在[https://github.com/spray/spray-json](https://github.com/spray/spray-json)了解更多信息。|'
- en: 'For each framework, we will look at how you can accomplish the following steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个框架，我们将探讨如何完成以下步骤：
- en: '**Parse from string to JSON object**: The input for this step is a string.
    We''ll show you how you can use the JSON frameworks to convert this string into
    a JSON object.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从字符串解析为 JSON 对象**：这一步的输入是一个字符串。我们将向您展示如何使用 JSON 框架将这个字符串转换为 JSON 对象。'
- en: '**Output JSON object as a string**: When you''ve got a JSON object, a common
    requirement is to print it as a string. All the frameworks provide support for
    this functionality.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 JSON 对象输出为字符串**：当您拥有一个 JSON 对象时，一个常见的需求是将它打印为字符串。所有框架都提供了对这个功能的支持。'
- en: '**Create a JSON object by hand**: Sometimes, you want to create a JSON object
    by hand (for example, when serializing part of a complex object). In this step,
    we''ll explain how to do this.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动创建 JSON 对象**：有时，您可能需要手动创建一个 JSON 对象（例如，在序列化复杂对象的一部分时）。在这个步骤中，我们将解释如何做到这一点。'
- en: '**Query a JSON object**: After converting a string in to a JSON object, a common
    requirement is to get specific values out of the JSON string. In this step, we''ll
    show you the different ways in which this is supported.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 JSON 对象**：在将字符串转换为 JSON 对象后，一个常见的需求是从 JSON 字符串中获取特定值。在这个步骤中，我们将向您展示支持这一功能的多种方式。'
- en: '**Converting to and from a case class**: In the previous chapters, we already
    saw how case classes can be converted to and from JSON. All the frameworks provide
    explicit support for this functionality, and we''ll explore how this works in
    this step.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将数据转换为和从 case 类**：在前面的章节中，我们已经看到了如何将 case 类转换为 JSON 以及从 JSON 转换为 case 类。所有框架都提供了对这个功能的具体支持，我们将在这一步中探讨它是如何工作的。'
- en: 'Before we look at the code, we first have to make sure we have all the required
    libraries. Each of the JSON libraries can be added just by including a single
    SBT dependency. The following set of dependencies adds all the libraries:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码之前，我们首先必须确保我们拥有所有必需的库。每个JSON库都可以通过添加单个SBT依赖项来添加。以下依赖项集添加了所有库：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first step we explain for each of the frameworks is how to convert a string
    to a JSON object. For each of the frameworks, we''ll use the following input string:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个框架解释的第一个步骤是如何将字符串转换为JSON对象。对于每个框架，我们将使用以下输入字符串：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also directly run the code from the various libraries. You can find
    the sources in the `chapter7` folder and run the examples by running SBT. From
    SBT, run the following commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接从各种库中运行代码。您可以在`chapter7`文件夹中找到源代码，并通过运行SBT来运行示例。从SBT运行以下命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now let's look at the first JSON library, Json4s.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第一个JSON库，Json4s。
- en: Working with Json4s
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Json4s
- en: 'First, we''ll show how to parse the string value we just saw:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将展示如何解析我们刚才看到的字符串值：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All you have to do is call the `parse` function on the string and the result
    is a `JValue` object. If the string can''t be parsed, a `ParseException` will
    be thrown. The result, when printed, looks similar to this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您所需要做的就是调用字符串上的`parse`函数，结果是一个`JValue`对象。如果字符串无法解析，将抛出`ParseException`。打印的结果看起来类似于以下内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, the string is parsed into a set of Json4s-specific classes.
    Now that we have got a `JValue` object, we can also convert it back to a string
    again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，字符串被解析为一系列Json4s特定的类。现在我们已经得到了一个`JValue`对象，我们也可以将其再次转换为字符串：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By calling `pretty(render(parsedJson)`, you get a `pretty` printed string value.
    If you want a compact string, you can call `compact(render(parsedJson))` instead.
    The result of the `pretty` function is shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`pretty(render(parsedJson))`，您将得到一个`pretty`打印的字符串值。如果您想要一个紧凑的字符串，您可以调用`compact(render(parsedJson))`代替。`pretty`函数的结果如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next step is creating a JSON object (a `JValue` object) by hand. Json4s
    provides a very convenient way to do this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是手动创建一个JSON对象（一个`JValue`对象）。Json4s提供了一个非常方便的方式来做到这一点：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, you only need to specify the key and provide a value; Json4s
    will automatically create the corresponding JSON objects. And when we print it,
    this time using the `compact` function, we will see the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您只需指定键并提供一个值；Json4s将自动创建相应的JSON对象。当我们打印它时，这次使用`compact`函数，我们将看到以下内容：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To query a JSON object, Json4s provides two approaches. You can use an XPath-like
    expression, as we have in the following code fragment, or you can use a comprehension
    (more info on that can be found at the Json4s website):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询JSON对象，Json4s提供了两种方法。您可以使用类似于XPath的表达式，就像我们在以下代码片段中所做的那样，或者您可以使用一个理解（更多关于这个的信息可以在Json4s网站上找到）：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this code fragment, we use the `\` and `\\` operators to search through
    the JSON object. With the `\` operator, we select a single node, and with the
    `\\` operator, we search through all the children. The result of the previous
    `println` statement is this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们使用`\`和`\\`运算符来遍历JSON对象。使用`\`运算符，我们可以选择单个节点，而使用`\\`运算符，我们可以遍历所有子节点。上一个`println`语句的结果如下：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Besides these operators, Json4s also provides a number of functions to search
    through a JSON object. You can see the available functions by looking at the `MonadicJValue`
    class. The final feature we look at is how to convert case classes to and from
    JSON. If we''ve already got a Json4s JSON object, we can use the extract function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些运算符之外，Json4s还提供了一些函数来遍历JSON对象。您可以通过查看`MonadicJValue`类来查看可用的函数。我们接下来要查看的最后一个功能是如何将case类转换为JSON以及从JSON转换回来。如果我们已经有了Json4s
    JSON对象，我们可以使用extract函数：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result of this is a `Task` instance. You can also serialize it directly
    to and from a string value:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这的结果是一个`Task`实例。您也可以直接将其序列化为字符串值：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using Json4s is really very straightforward. It provides the core functionality
    to easily create, query, and serialize JSON. Next up is Argonaut.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Json4s非常简单。它提供了易于创建、查询和序列化JSON的核心功能。接下来是Argonaut。
- en: Working with Argonaut
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Argonaut
- en: 'Argonaut follows a more functional approach to create and parse JSON as you''ll
    see in the following examples. We start again by converting a string object in
    to a JSON object:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Argonaut采用更函数式的方法来创建和解析JSON，您将在以下示例中看到。我们再次开始，将一个字符串对象转换为JSON对象：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Argonaut extends the string object with a `parse` function. The result of this
    function is a `\/` instance:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Argonaut 通过一个 `parse` 函数扩展了字符串对象。这个函数的结果是一个 `\/` 实例：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is similar to an `Either` object, but where an `Either` object isn't right
    or left-biased, the `\/` instance is right-biased (which means you can also easily
    use it in `for` comprehensions). To get the value out of the `\/` instance, we
    use the `|` operator.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `Either` 对象类似，但 `Either` 对象不是偏向右侧或左侧的，而 `\/` 实例是偏向右侧的（这意味着你还可以轻松地在 `for`
    语句中使用它）。要从 `\/` 实例中获取值，我们使用 `|` 操作符。
- en: 'Once we have a JSON value, we can easily convert it in to a string:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 JSON 值，我们就可以轻松地将其转换为字符串：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This results in the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For output that is more compact, you can also use `spaces2` or `nospaces`.
    Argonout also provides a flexible way of creating JSON objects manually:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更紧凑的输出，你也可以使用 `spaces2` 或 `nospaces`。Argonout 还提供了一种灵活的方式来手动创建 JSON 对象：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Argonaut provides a number of operators you can use to build a JSON object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Argonaut 提供了一些操作符，你可以使用它们来构建 JSON 对象：
- en: '| Operator | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `->:` | This prepends the given value to a JSON object. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `->:` | 如果设置了，这个操作符会将给定的值添加到 JSON 对象中。|'
- en: '| `->?` | This prepends the given optional value to a JSON object if it is
    set. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `->?` | 如果设置了，这个操作符会将给定的可选值添加到 JSON 对象中。|'
- en: '| `-->>:` | This prepends the given value to a JSON array. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `-->>:` | 这个操作符会将给定的值添加到 JSON 数组中。|'
- en: '| `-->>:?` | This prepends the given optional value to a JSON array if it is
    set. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `-->>:?` | 如果设置了，这个操作符会将给定的可选值添加到 JSON 数组中。|'
- en: On the Argonaut website, a couple of alternative ways of creating JSON objects
    can also be found.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Argonaut 网站上，还可以找到创建 JSON 对象的几种替代方法。
- en: 'Querying objects with Argonaut can also be done in a couple of different ways.
    For our example, we''ll query using a lens:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Argonaut 查询对象也可以有几种不同的方式。在我们的例子中，我们将使用透镜进行查询：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this piece of code, we have defined a lens that matches a specific element
    in a JSON object. We always start with a `jObjectPL` function, which selects the
    root node of a JSON object. Next, we use the `jsonObjectPL("notes")` function
    to select the value of the `"notes"` key. By using `jArrayPL`, we convert the
    value to an array and use `jsonArrayPL(0)` to select the first element of the
    array. Finally, we use `JObjectPL` again to convert it in to an object, on which
    we query the `"id"` key and finally, convert it in to a string. Now that we have
    a lens, we can use it on a specific JSON object to extract the value (as an `Option[String]`
    instance):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们定义了一个匹配 JSON 对象中特定元素的透镜。我们始终从一个 `jObjectPL` 函数开始，它选择 JSON 对象的根节点。接下来，我们使用
    `jsonObjectPL("notes")` 函数来选择 `"notes"` 键的值。通过使用 `jArrayPL`，我们将该值转换为数组，并使用 `jsonArrayPL(0)`
    来选择数组的第一个元素。最后，我们再次使用 `JObjectPL` 来将其转换为对象，然后查询 `"id"` 键，并将其最终转换为字符串。现在我们有了透镜，我们可以在特定的
    JSON 对象上使用它来提取值（作为一个 `Option[String]` 实例）：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Argonaut, of course, also supports converting to and from case classes. The
    first thing we have to do is define a codec. A codec defines how a case class
    maps to the keys of a JSON object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Argonaut 也支持将数据转换为和从案例类中转换。我们首先必须定义一个编解码器。编解码器定义了案例类如何映射到 JSON 对象的键：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that we make the codecs implicit. This way, Argonaut will pick them up
    when it needs to convert a string in to a case class and back again:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使编解码器成为隐式的。这样，当 Argonaut 需要将字符串转换为案例类或反向转换时，它会自动找到它们：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you've defined a codec for a specific case class, you can just call the
    `asJson` function to convert the case class in to a `Json` object. To convert
    from a JSON string to a case class we can use the `Parse.decodeOption` function
    (Argonaut also provide a `decodeEither` function, a `decodeValidation` and a `decodeOr`
    if you want other wrappers instead of `Option`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为特定的案例类定义了编解码器后，只需调用 `asJson` 函数即可将案例类转换为 `Json` 对象。要将 JSON 字符串转换为案例类，我们可以使用
    `Parse.decodeOption` 函数（如果想要其他包装器而不是 `Option`，Argonaut 还提供了 `decodeEither` 函数、`decodeValidation`
    和 `decodeOr`）。
- en: In the chapter on Akka HTTP, we already mentioned that, for JSON support, we
    use the spray-json library. In the following section, we'll dive a bit deeper
    into this library.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Akka HTTP 的章节中，我们已经提到，为了支持 JSON，我们使用 spray-json 库。在接下来的部分，我们将更深入地探讨这个库。
- en: Working with spray-json
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 spray-json
- en: spray-json provides a very easy way to work with JSON strings. To parse a string
    to a JSON object you can just call `parseJson` on the string value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: spray-json 提供了一种非常简单的方式来处理 JSON 字符串。要将字符串解析为 JSON 对象，只需在字符串值上调用 `parseJson`
    即可。
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result, when printed, looks similar to this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印时，结果看起来类似于这个：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Of course, we can also convert a JSON object back to a string by using either
    the `prettyPrint` or `compactPrint` functions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以通过使用`prettyPrint`或`compactPrint`函数将JSON对象转换回字符串：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result from `prettyPrint` looks similar to this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`prettyPrint`的结果看起来类似于这个：'
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you want to create a JSON object by hand, spray-json provides a number
    of basic classes you can use for that (`JsObject`, `JsString`, `JsNumber`, and
    `JsArray`):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想手动创建一个JSON对象时，spray-json为您提供了许多基本类，您可以使用这些类来完成这个任务（`JsObject`、`JsString`、`JsNumber`和`JsArray`）：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result is pretty much the same object we saw in the first example of the
    section:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 结果几乎与我们在本节第一例中看到的是同一个对象：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next step we''ll look at is how we can query a JSON object for a specific
    field. This is something for which spray-json doesn''t provide specific functions
    or operators. The only way to access a specific field or value is by using the
    `getFields` or `fields` functions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的下一步是如何查询一个JSON对象以获取特定的字段。这是spray-json没有提供特定函数或操作符的事情。访问特定字段或值的唯一方法是通过使用`getFields`或`fields`函数：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `getFields` function returns a `Vector` object, containing all the fields
    on the current object that match this name. The fields function returns a `Map`
    object of all the fields.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFields`函数返回一个包含当前对象上所有匹配此名称的字段的`Vector`对象。字段函数返回所有字段的`Map`对象。'
- en: 'The last feature we look at in each of the frameworks is how we can use it
    to convert from case classes to JSON and back again. In the chapter on Akka HTTP,
    we already showed you how to do this with spray-json:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个框架中最后要查看的功能是如何使用它将case类转换为JSON以及再次转换回来。在Akka HTTP章节中，我们已经向您展示了如何使用spray-json来完成这个操作：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What we do is extend the `DefaultJsonProtocol` and define, for each of our case
    classes, how they should be mapped through and from JSON. spray-json provides
    us with a very convenient helper function called `jsonFormat#(object)`, where
    the `#` corresponds to the number of arguments of the case class. With this function,
    we can define the default marshalling for our case classes, like we did in the
    preceding example. To use these implicit conversions, all we have to do is bring
    them in scope, and we can use the `toJson` function on our case classes to serialize
    them to `Json`, and use `convertTo` to convert JSON back to our case class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是扩展`DefaultJsonProtocol`并为我们的每个case类定义它们应该如何通过JSON进行映射。spray-json为我们提供了一个非常方便的辅助函数，称为`jsonFormat#(object)`，其中`#`对应于case类的参数数量。使用这个函数，我们可以为我们的case类定义默认的序列化，就像我们在前面的例子中所做的那样。要使用这些隐式转换，我们只需要将它们引入作用域，然后我们就可以在我们的case类上使用`toJson`函数将它们序列化为`Json`，并使用`convertTo`将JSON转换回我们的case类。
- en: Working with Play JSON
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Play JSON
- en: 'The final JSON library is also one we have touched upon in the previous chapters—Play
    JSON. As you''ll see in the code, the way this library works closely resembles
    the spray-json library. Let''s start by looking at converting from a string into
    a JSON object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个JSON库也是我们在前面的章节中提到过的——Play JSON。正如您将在代码中看到的那样，这个库的工作方式与spray-json库非常相似。让我们首先看看如何将字符串转换为JSON对象：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Very simple, just call the `parse` function and provide the JSON, and the result
    is the following JSON object (when printed):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，只需调用`parse`函数并提供JSON，结果就是以下JSON对象（当打印时）：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To convert the JSON object to a string, we can either call the `stringify`
    function directly on the JSON object or use the `Json.prettyPrint` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要将JSON对象转换为字符串，我们可以直接在JSON对象上调用`stringify`函数，或者使用`Json.prettyPrint`函数：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `prettyPrint` function returns the following result:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`prettyPrint`函数返回以下结果：'
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Nothing too special so far. The same goes for creating JSON objects manually.
    Just like spray-json, Play JSON provides you with a set of base classes (`JsObject`,
    `JsNumber`, `JsString`, `JsObject`, and `JsArray`) that you can use to create
    your JSON object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止没有什么特别的。创建JSON对象的手动方式也是如此。就像spray-json一样，Play JSON为您提供了一个可以用来创建JSON对象的基类集合（`JsObject`、`JsNumber`、`JsString`、`JsObject`和`JsArray`）：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s go to querying. This is where Play JSON provides us with a couple
    of very useful operators:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向查询。这是Play JSON为我们提供了一些非常实用的操作符的地方：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With the `\\` operator, we look for all the fields in the complete tree matching
    the field and return that as a `List` object, and with the single `\` operator,
    we look for a field in the current object. What makes this very easy to use is
    that these operators can easily be nested as you can see from the previous code
    fragment. When we look at the output, we see the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`\\`运算符，我们查找完整树中匹配的字段，并将其作为`List`对象返回，而使用单个`\`运算符，我们查找当前对象中的字段。这使得这些运算符非常易于使用，因为你可以从之前的代码片段中看到，这些运算符可以轻松嵌套。当我们查看输出时，我们看到以下内容：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Converting to and from case classes is also very straightforward with this
    library. We first define a set of implicit conversions, simply by calling `Json.format[T]`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个库将案例类转换为JSON以及从JSON转换回来也非常直接。我们首先定义一组隐式转换，只需调用`Json.format[T]`即可：
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And with these implicit conversions defined, we can use the `toJson` and `fromJson[T]`
    functions to convert our case classes to and from JSON:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些隐式转换之后，我们可以使用`toJson`和`fromJson[T]`函数将我们的案例类转换为JSON，并从JSON转换回来：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's quickly recap the frameworks before we move on to the next subject.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，让我们快速回顾一下这些框架。
- en: JSON frameworks summary
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON框架概述
- en: So, which JSON framework is the best? Well, the general answer, of course, is
    it depends. All the frameworks have their advantages and disadvantages. If I do
    have to make a choice, I'd say that for simple JSON needs, Json4s is a really
    great choice. It provides a very easy way to create JSON objects from scratch,
    has an intuitive way of querying data, and allows you to easily convert to and
    from case classes. If you have more complex requirements, Argonaut is a very interesting
    choice. It provides a very functional way of JSON processing and has a number
    of interesting features for creating new JSON objects and querying the existing
    ones.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪个JSON框架是最好的呢？当然，一般的回答是这取决于。所有框架都有它们的优缺点。如果我真的必须做出选择，我会说对于简单的JSON需求，Json4s是一个非常好的选择。它提供了一种非常简单的方法从头创建JSON对象，有直观的数据查询方式，并允许你轻松地将数据转换为案例类。如果你有更复杂的需求，Argonaut是一个非常有意思的选择。它提供了一种非常功能化的JSON处理方式，并为创建新的JSON对象和查询现有的JSON对象提供了一些有趣的功能。
- en: HATEOAS
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HATEOAS
- en: 'In the first chapter, we looked at the definition of what a RESTful service
    is. Part of that definition is that a REST service should use HATEOAS, which is
    an acronym for Hypertext As The Engine Of Application State. What this means is
    that to be truly RESTful, our services doesn''t just need to provide more information
    than simply the JSON representation of a resource, but it should also provide
    information about the state of the application. When we talk about HATEOAS, we
    have to deal with the following two main principles:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们探讨了RESTful服务的定义。该定义的一部分是，REST服务应该使用HATEOAS，即“作为应用状态引擎的超文本”的缩写。这意味着要真正实现RESTful，我们的服务不仅需要提供比资源JSON表示更多的信息，还应该提供有关应用程序状态的信息。当我们谈论HATEOAS时，我们必须处理以下两个主要原则：
- en: '**Hypermedia/mime-types/media-types/content-types**: The hypermedia of a resource
    describes the current state of a resource. You can look at this as a sort of contract
    that describes the resource we''re working with. So, instead of setting the type
    of a resource to `application/json`, you define a custom content-type like `application/vnd.restwithscala.task+json`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体/mime类型/媒体类型/内容类型**：资源的超媒体描述了资源当前的状态。你可以将其视为一种合同，描述了我们正在处理的资源。因此，我们不是将资源的类型设置为`application/json`，而是定义一个自定义的内容类型，如`application/vnd.restwithscala.task+json`。'
- en: '**Links**: The second part of HATEOAS is that a resource representation needs
    to have links to other states of the resource and actions that can be executed
    on that resource.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：HATEOAS的第二部分是，资源表示需要包含指向资源其他状态和在该资源上可以执行的操作的链接。'
- en: 'For instance, the following code provides information about the current response
    through the `self` link and uses media-types to indicate what to expect from these
    links:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码通过`self`链接提供有关当前响应的信息，并使用媒体类型来指示从这些链接可以期待什么：
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since media-types are an important part of the resource, we don't just need
    to be able to set the media-type on the response, but also filter based on the
    incoming media-type, since a different media-type on a specific endpoint can have
    a different meaning.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于媒体类型是资源的一个重要部分，我们不仅需要能够在响应上设置媒体类型，还需要根据传入的媒体类型进行过滤，因为特定端点的不同媒体类型可以有不同的含义。
- en: Handling media-types
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理媒体类型
- en: 'Now let us walk through the frameworks discussed in this book and see how they
    handle media-types. You can, of course, run all these examples from the code provided
    with this book. You can use the following commands to start the various servers:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下本书中讨论的框架，看看它们是如何处理媒体类型的。当然，您可以从本书提供的代码中运行所有这些示例。您可以使用以下命令来启动各种服务器：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have also provided a number of requests in Postman that you can use to test
    whether media handling works. You can find these in the **Chapter 07** collection:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一些 Postman 请求，您可以使用这些请求来测试媒体处理是否正常工作。您可以在**第 07 章**集合中找到这些请求：
- en: '![Handling media-types](img/00057.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![处理媒体类型](img/00057.jpeg)'
- en: The first framework we'll explore is Finch.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一个框架是 Finch。
- en: Handling media-types with Finch
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Finch 处理媒体类型
- en: 'To handle media-types with Finch, we''re going to create a filter. This filter,
    and the code to glue everything together, is shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理 Finch 的媒体类型，我们将创建一个过滤器。这个过滤器以及将一切粘合在一起的代码如下所示：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can create a filter by extending the `SimpleFilter` class. This filter provides
    access to the incoming `HttpRequest` instance and the outgoing `HttpResponse`
    instance. In this filter, we check whether the media-type is the correct one,
    and if this is the case, we process the request. If not, we return a `BadRequest`
    response. To give the client an indication of the type of response they are dealing
    with, we also set the media-type on the response object. With the filter defined,
    we create our route and invoke the `createNewTaskFilter` instance, which first
    calls the `filter` instance and then the `createTask` service. Now whenever a
    request with the correct media-type comes in, it is processed in the correct manner.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过扩展 `SimpleFilter` 类来创建一个过滤器。这个过滤器提供了对传入的 `HttpRequest` 实例和传出的 `HttpResponse`
    实例的访问。在这个过滤器中，我们检查媒体类型是否正确，如果是这样，我们处理请求。如果不正确，我们返回一个 `BadRequest` 响应。为了给客户端一个关于他们正在处理的响应类型的指示，我们还设置了响应对象上的媒体类型。在定义了过滤器之后，我们创建我们的路由并调用
    `createNewTaskFilter` 实例，它首先调用 `filter` 实例，然后调用 `createTask` 服务。现在每当收到正确媒体类型的请求时，它都会以正确的方式进行处理。
- en: Handling media-types with Unfiltered
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Unfiltered 处理媒体类型
- en: 'Filtering on media-types is very easy to do in Unfiltered. We use some basic
    Scala pattern matching to check whether the `POST` on a specific path contains
    the correct media-type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unfiltered 中对媒体类型进行过滤非常容易。我们使用一些基本的 Scala 模式匹配来检查特定路径上的 `POST` 是否包含正确的媒体类型：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, all we do is pattern match two request properties, the verb
    (`POST`) and the content-type of the request; when those match, we process the
    request, and set the correct header on the response.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们所做的只是匹配两个请求属性，即动词（`POST`）和请求的内容类型；当它们匹配时，我们处理请求，并在响应上设置正确的头信息。
- en: Handling media-types with Scalatra
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Scalatra 处理媒体类型
- en: 'The next one to discuss on the list of frameworks is Scalatra. As we have seen
    when discussing Scalatra, it provides a way to define a `before` function and
    an `after` function for a specific path. We use that functionality to check in
    the `before` function whether the media-type matches, and in the `after` function,
    we update the content-type:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架列表中接下来要讨论的是 Scalatra。正如我们在讨论 Scalatra 时所看到的，它提供了一种定义特定路径的 `before` 函数和 `after`
    函数的方法。我们使用这个功能在 `before` 函数中检查媒体类型是否匹配，并在 `after` 函数中更新内容类型：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, we use pattern matching to match a specific verb and content-type.
    This means that if we have a `POST` verb and the correct content-type, we execute
    the request. If the verb matches but the content-type doesn't, we respond with
    a bad request and if the verb doesn't match, we just process it normally.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用模式匹配来匹配特定的动词和内容类型。这意味着如果我们有一个 `POST` 动词和正确的内容类型，我们将执行请求。如果动词匹配但内容类型不匹配，我们返回一个错误请求，如果动词不匹配，我们则正常处理它。
- en: Handling media-types with Akka HTTP
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Akka HTTP 处理媒体类型
- en: 'Using media-types with Akka HTTP takes a bit more work. The reason is that
    Akka HTTP extracts the content-type out of the headers and adds it to the entity.
    This means we have to check the entity for the existence of a specific content-type
    instead of just checking a header. The first thing we do is define the content-type
    we''re looking for, and a function, which we can use to transform the response
    object and set the correct type on the response:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Akka HTTP的媒体类型需要做更多的工作。原因是Akka HTTP会从头部提取内容类型并将其添加到实体中。这意味着我们必须检查实体中是否存在特定的内容类型，而不仅仅是检查头部。我们首先定义我们正在寻找的内容类型，以及一个函数，我们可以使用它来转换响应对象并在响应上设置正确的类型：
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, the `mapEntity` function takes a `ResponseEntity` instance
    as its parameters, and returns a new one with the correct content-type. In the
    next code fragment, we''ll show how you can check the incoming request for the
    correct content-type and use the previously-defined function to set the response:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`mapEntity`函数接受一个`ResponseEntity`实例作为其参数，并返回一个新的具有正确内容类型的实例。在下一个代码片段中，我们将展示如何检查传入请求的正确内容类型并使用先前定义的函数设置响应：
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A lot is happening here, so let''s look at the directives we use here and why:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以让我们看看我们在这里使用的指令以及为什么：
- en: First, we extract the request and the entity of the request (the body and content-type)
    with the `entity` and `extractRequest` directives.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`entity`和`extractRequest`指令提取请求和请求的实体（主体和内容类型）。
- en: Next, we match the `request.entity.contentType` property of the entity, and
    if it matches, we create a new entity with the `application/json` content-type.
    We do this so that the standard JSON-to-case-class mapping of Akka HTTP still
    works.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们匹配实体的`request.entity.contentType`属性，如果匹配，我们创建一个新的实体，其内容类型为`application/json`。我们这样做是为了确保Akka
    HTTP的标准JSON到案例类的映射仍然有效。
- en: Next, we convert the entity in to a `Task` instance, call the service, and create
    a response.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实体转换为`Task`实例，调用服务，并创建响应。
- en: Before the response is returned, the `mapResponseEntity` function is called,
    which sets the content-type to our original value.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在响应返回之前，会调用`mapResponseEntity`函数，该函数将内容类型设置为我们的原始值。
- en: Note that instead of an approach using directives, we could also have redefined
    the required implicits to make the JSON conversion work with our own custom content-type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了使用指令的方法之外，我们还可以重新定义所需的隐式转换，以便JSON转换可以与我们的自定义内容类型一起工作。
- en: Handling media-types with Play 2
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Play 2处理媒体类型
- en: 'To implement custom media-types in Play 2, we''ll use an `ActionBuilder` approach.
    With an `ActionBuilder` approach, we can change the way an action is invoked.
    The following code shows what the `ActionBuilder` approach of this example looks
    like:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Play 2中实现自定义媒体类型，我们将使用`ActionBuilder`方法。使用`ActionBuilder`方法，我们可以改变调用动作的方式。以下代码显示了此示例的`ActionBuilder`方法：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we define a new type of action, called a `MediaTypeAction`. When we use
    this action instead of the normal `Action` class, first the content-type of the
    incoming message is checked; if it matches, the request is processed; if not,
    the request is ignored and a `BadRequest` response is generated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一种新的动作类型，称为`MediaTypeAction`。当我们使用此动作而不是正常的`Action`类时，首先检查传入消息的内容类型；如果匹配，则处理请求；如果不匹配，则忽略请求并生成`BadRequest`响应。
- en: 'We can use this new `MediaTypeAction` in the following manner:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种新的`MediaTypeAction`以以下方式：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, we just replace the `Action` with `MediaTypeAction` and that's
    it. When this action is called, first the code from `MediaTypeAction` is executed,
    then the code is provided to the `Action`. To properly convert the incoming data
    to a JSON object, we need to make some small changes to the way we handle JSON.
    We use an explicit body parser (`parse.tolerantJson`) to parse the incoming JSON.
    With the function, we don't check whether the provided content-type is `application/json`,
    but just convert the body.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是用`MediaTypeAction`替换了`Action`，就是这样。当这个动作被调用时，首先执行`MediaTypeAction`中的代码，然后提供代码给`Action`。为了正确地将传入数据转换为JSON对象，我们需要对我们处理JSON的方式做一些小的修改。我们使用显式的主体解析器（`parse.tolerantJson`）来解析传入的JSON。使用这个函数，我们不检查提供的内容类型是否为`application/json`，只是转换主体。
- en: 'In the beginning of this section, we explained two important parts of HATEOAS:
    media-type handling and supporting links. In the next section, we''ll show a way
    you can add links to your case classes easily.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始部分，我们解释了HATEOAS的两个重要部分：媒体类型处理和支持链接。在下一节中，我们将展示一种你可以轻松地向你的案例类添加链接的方法。
- en: Using links
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链接
- en: 'For the links, we''re going to create a very simple extension to our model.
    Instead of just sending the case class serialized to JSON, we''re adding a `_links`
    object. This object can contain different links. For instance, it can not only
    define a link to the resource itself, but also can contain links to actions that
    can be executed on this resource. The final JSON we''re aiming for looks similar
    to this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链接，我们将在我们的模型中创建一个非常简单的扩展。我们不仅将序列化的案例类发送到JSON，还在其中添加了一个`_links`对象。这个对象可以包含不同的链接。例如，它不仅可以定义对资源的链接，还可以包含可以在此资源上执行的操作的链接。我们最终希望得到的JSON看起来类似于以下内容：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As an example, we''ll use Play JSON, but pretty much the same approach can
    be used with the other JSON libraries explored in this chapter. The first thing
    we do is define what the links will look like. For this, we define a trait and
    a case class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将使用Play JSON，但基本上可以以本章探索的其他JSON库中使用相同的方法。我们首先做的是定义链接的外观。为此，我们定义了一个特性和一个案例类：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we create a new `Task`, we can extend from this trait to add links. As
    we have explained before, Play JSON uses implicit values to determine how to serialize
    a specific class to JSON. For this scenario, we define the following implicit
    values:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的`Task`时，我们可以从这个特质扩展以添加链接。正如我们之前解释的，Play JSON使用隐式值来确定如何将特定类序列化为JSON。对于这个场景，我们定义以下隐式值：
- en: '[PRE50]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: What happens here is that we define the standard implicits for the various parts
    of our model, including our new `HasLinks` trait. Besides that, we also define
    a very specific implicit that matches `Tasks` that extend the `HasLinks` trait.
    So, when we call the `toJson` function on a `Task` that extends `HasLinks`, the
    `taskWithLinksWrites` will match. In the `writes` function, we first convert the
    `Links` object and combine this with the converted `Task`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，我们定义了我们模型各个部分的标准化隐式值，包括我们新的`HasLinks`特质。除此之外，我们还定义了一个非常具体的隐式值，用于匹配扩展了`HasLinks`特质的`Tasks`。因此，当我们对一个扩展了`HasLinks`的`Task`调用`toJson`函数时，`taskWithLinksWrites`将匹配。在`writes`函数中，我们首先转换`Links`对象，并将其与转换后的`Task`组合。
- en: 'To use this, all we have to do is define a new `Task` and use with `HasLinks`
    to add any links we have:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个功能，我们只需要定义一个新的`Task`并使用`HasLinks`来添加我们拥有的任何链接：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, after importing the correct implicits, we can convert the `Task` with `HasLinks`
    to JSON, just like we do other objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在导入正确的隐式值之后，我们可以将带有`HasLinks`的`Task`转换为JSON，就像我们转换其他对象一样。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we looked at a couple of important aspects of REST. We
    explored the various JSON libraries that can be used in your REST services for
    converting objects to and from JSON. Besides that, we looked at a very important
    aspect of REST called HATEOAS. The most important aspect of HATEOAS is the ability
    to detect and filter on media-type (content-type) and to add links to your resources
    to create self-describing APIs. We saw how to detect and work with media-types
    in the frameworks discussed in this book, and how to add links with one of the
    JSON frameworks explored in this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后，我们探讨了REST的一些重要方面。我们探讨了可以在您的REST服务中使用的各种JSON库，用于将对象转换为JSON以及从JSON转换。除此之外，我们还探讨了REST的一个非常重要的方面，即HATEOAS。HATEOAS最重要的方面是检测和过滤媒体类型（内容类型）以及向资源添加链接以创建自描述API的能力。我们看到了如何在本书讨论的框架中检测和处理媒体类型，以及如何使用本章探索的JSON框架之一添加链接。
- en: With this last section on adding links to a JSON response, we have reached the
    end of this book. In the various chapters, we explored the most important features
    of a number of REST frameworks that are available in the Scala ecosystem.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了向JSON响应添加链接，这标志着本书的结束。在各个章节中，我们探讨了Scala生态系统中的多个REST框架的最重要功能。
- en: In the previous chapters, we tried to show you the most important features of
    these frameworks and explain how to use these features to create scalable, asynchronous,
    and maintainable REST services. Please keep in mind that each of these frameworks
    has many more features than we could explore in this book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们试图向您展示这些框架的最重要功能，并解释如何使用这些功能来创建可扩展的、异步的和可维护的REST服务。请记住，这些框架中的每一个都有比我们在这本书中能探索的更多功能。
- en: I hope you have had fun reading the book and experimenting with the examples.
    If you like them, feel free to use them, expand them, and share the results!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在阅读这本书并尝试示例时玩得开心。如果你喜欢它们，请随意使用、扩展并分享结果！
