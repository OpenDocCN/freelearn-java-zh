- en: Chapter 6. Emerging Standards and the Future of REST
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。新兴标准和REST的未来
- en: This chapter covers the emerging and evolving technologies that will augment
    the functionality of RESTful services and provide some perspective on the future
    of REST as well as other real-time API supporters. We will cover some of the real-time
    APIs and see how they can help with respect to older ways such as polling. Given
    the ubiquitous popularity of platforms such as Twitter, Facebook, and Stripe,
    it is no surprise that they have adopted a paradigm shift and thus provide real-time
    APIs to give information to the client as and when an event occurs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了新兴和发展中的技术，将增强RESTful服务的功能，并提供对REST的未来以及其他实时API支持者的一些看法。我们将涵盖一些实时API，并看看它们如何帮助解决轮询等旧方式的问题。鉴于Twitter、Facebook和Stripe等平台的普遍流行，它们采用了一种范式转变，因此提供了实时API，以在事件发生时向客户端提供信息，这并不奇怪。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Real-time APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时API
- en: Polling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询
- en: WebHooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebHooks
- en: WebSockets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSockets
- en: 'Additional real-time API supporters, which include the following:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的实时API支持者，包括以下内容：
- en: PubSubHubbub
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PubSubHubbub
- en: Server-sent events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器发送事件
- en: XMPP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XMPP
- en: BOSH over XMPP
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XMPP上的BOSH
- en: Case studies on companies using WebHooks and WebSockets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebHooks和WebSockets的公司案例
- en: Comparison between WebHooks and WebSockets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebHooks和WebSockets的比较
- en: REST and Micro Services
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST和微服务
- en: We will start with defining what a real-time API refers to, and then, we will
    cover polling and its disadvantages. Next, we will walk through the different
    models that are widely used for asynchronous real-time communication. Finally,
    we will elaborate the pragmatic approaches to WebHooks and WebSockets in detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义实时API的含义开始，然后讨论轮询及其缺点。接下来，我们将详细介绍广泛用于异步实时通信的不同模型。最后，我们将详细阐述WebHooks和WebSockets的务实方法。
- en: Real-time APIs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时API
- en: In our context, a real-time API helps the API consumer receive the events that
    they are interested in, as they occur. An example of a real-time update is when
    someone posts a link on Facebook or someone you follow on Twitter tweets about
    a topic. Another example of a real-time API is to receive the feed of stock price
    changes as they occur.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情境中，实时API帮助API消费者在事件发生时接收他们感兴趣的事件。实时更新的一个例子是当有人在Facebook上发布链接，或者你在Twitter上关注的人发表关于某个话题的推文。另一个实时API的例子是在股价变化发生时接收股价变化的信息。
- en: Polling
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询
- en: 'Polling is the most traditional way to get data from a data source that produces
    the stream of events and updates. The client makes requests periodically, and
    the server sends data if there is a response. In case there is no data to be sent
    by the server, an empty response is returned. The following diagram shows how
    continuous polling works:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询是从产生事件和更新流的数据源获取数据的最传统方式。客户端定期发出请求，如果有响应，服务器就会发送数据。如果服务器没有要发送的数据，就会返回空响应。以下图表显示了连续轮询的工作原理：
- en: '![Polling](img/7963OS_06_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![轮询](img/7963OS_06_01.jpg)'
- en: Polling comes with multiple drawbacks such as empty responses for requests made
    when there is no update on the server; this results in waste of bandwidth and
    processing time. Polling with lower frequencies will result in the client missing
    the updates close to the time the updates happen, and polling too frequently results
    in waste of resources as well as facing the rate limitation imposed by the server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询带来了诸多缺点，比如在服务器没有更新时对请求返回空响应，这导致了带宽和处理时间的浪费。低频率的轮询会导致客户端错过接近更新发生时间的更新，而过于频繁的轮询也会导致资源浪费，同时还会面临服务器施加的速率限制。
- en: 'To eliminate these drawbacks of polling, we will cover the following topics:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除轮询的这些缺点，我们将涵盖以下主题：
- en: The PuSH model—PubSubHubbub
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PuSH模型-PubSubHubbub
- en: The streaming model
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流模型
- en: The PuSH model – PubSubHubbub
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PuSH模型-PubSubHubbub
- en: PuSH is a simple topic based on the publish/subscribe protocol, which is based
    on ATOM/RSS. Its goal is to convert atom feeds to real-time data and eliminate
    the polling that affects the consumers of the feeds. The subscribers register
    their interests in a topic, and the original publisher tells the interested subscribers
    that there is something new that interests them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PuSH是基于发布/订阅协议的简单主题，基于ATOM/RSS。它的目标是将原子源转换为实时数据，并消除影响源的消费者的轮询。订阅者在主题上注册他们的兴趣，原始发布者告诉感兴趣的订阅者有新的内容。
- en: 'To distribute the tasks of publishing and content distributing, there is a
    notion of the **Hub**, which can be delegated to send the content to the subscribers.
    The following diagram depicts the PubSubHubbub model:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分发发布和内容分发的任务，有一个**Hub**的概念，可以委托发送内容给订阅者。以下图表描述了PubSubHubbub模型：
- en: '![The PuSH model – PubSubHubbub](img/7963OS_06_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![PuSH模型-PubSubHubbub](img/7963OS_06_02.jpg)'
- en: 'Let''s look at how this model works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个模型是如何工作的：
- en: The **Subscriber** discovers the **Hub** by fetching the feed from the **Publisher**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Subscriber**通过从**Publisher**获取feed来发现**Hub**。'
- en: Once the **Hub** is discovered, the **Subscriber** subscribes to the **Hub**
    with the feed URI it is interested in.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦**Hub**被发现，**Subscriber**就会订阅**Hub**感兴趣的feed URI。
- en: Now, when the **Publisher** has updates to send, it will let the **Hub** get
    the updates.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当**Publisher**有更新要发送时，它会让**Hub**获取更新。
- en: The **Hub** then sends the updates to all the publishers.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Hub**然后将更新发送给所有发布者。'
- en: The advantage of this model is that the publisher does not have to be concerned
    with sending updates to all the subscribers. Also, on the other end, the subscribers
    have an advantage as they get the updates from the hub as and when they occur,
    without continuously polling the publisher.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的优势在于，发布者不必担心向所有订阅者发送更新。另一方面，订阅者有一个优势，即他们可以在事件发生时从hub获取更新，而无需不断地轮询发布者。
- en: The **WebHooks** paradigm, discussed in the subsequent sections, uses this protocol.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中讨论的**WebHooks**范例使用了这个协议。
- en: The streaming model
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流模型
- en: The streaming model for asynchronous communication involves keeping a channel
    open and sending the data as it occurs. In this case, a socket connection needs
    to be kept open.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通信的流模型涉及保持通道打开并在数据发生时发送数据。在这种情况下，需要保持套接字连接打开。
- en: Server-sent events
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器发送事件
- en: '**Server-sent events** (**SSE**) is a technology based on the streaming model,
    where a browser gets automatic updates from a server via an HTTP connection. The
    W3C has standardized the Server-Sent Events EventSource API as part of HTML5.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器发送事件**（**SSE**）是基于流模型的技术，其中浏览器通过HTTP连接自动从服务器获取更新。W3C已将服务器发送事件EventSource
    API作为HTML5的一部分进行了标准化。'
- en: With SSEs, the client initiates a request to the server using the `"text/eventstream"`
    MimeType. Once the initial handshake has taken place, the server can keep sending
    events to the client as and when they occur. The events are plain text messages
    sent from the server to the clients. They can be data that can be consumed in
    the client side by the event listener, and the event listener can interpret and
    react to the received event.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSE，客户端使用`"text/eventstream"` MimeType向服务器发起请求。一旦进行了初始握手，服务器可以在事件发生时不断向客户端发送事件。这些事件是从服务器发送到客户端的纯文本消息。它们可以是客户端侧的事件监听器可以消耗的数据，事件监听器可以解释并对接收到的事件做出反应。
- en: 'SSEs define a message format for the events that are sent from the server to
    the clients. The message format is composed of plain text line separated by a
    stream of characters. Lines that carry the message body or data start with `data:`
    and end with `\n\n`, as shown in the following snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SSE定义了从服务器发送到客户端的事件的消息格式。消息格式由一系列以换行符分隔的纯文本行组成。携带消息主体或数据的行以`data:`开头，以`\n\n`结尾，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Lines that carry some **Quality of Service** (**QoS**) directives (for example,
    `retry` and `id`) start with the QoS attribute name, followed by `:`, and then
    the QoS attribute's value. The standard format makes it possible to develop generic
    libraries around SSE to make software development easier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 携带一些**服务质量**（**QoS**）指令的行（例如`retry`和`id`）以QoS属性名称开头，后跟`:`，然后是QoS属性的值。标准格式使得可以开发围绕SSE的通用库，以使软件开发更加容易。
- en: 'The following diagram shows how SSEs work:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了SSE的工作原理：
- en: '![Server-sent events](img/7963OS_06_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![服务器发送事件](img/7963OS_06_03.jpg)'
- en: As shown in the diagram, the client subscribes to an event source. The server
    keeps sending updates as and when they occur.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，客户端订阅了一个事件源。服务器会在事件发生时不断发送更新。
- en: 'Additionally, the server can associate and send IDs along with the whole message,
    as shown in the following code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，服务器可以将ID与整个消息关联并发送，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding snippet shows how multiline messages with event IDs and data can
    be sent, with the last line that terminates with two `\n\n` characters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了如何发送带有事件ID和数据的多行消息，最后一行以两个`\n\n`字符结尾。
- en: Setting an ID lets the client keep track of the last event fired so that if
    the connection to the server is dropped, a special HTTP header (`Last-Event-ID`)
    is set with the new request sent by the client.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个ID让客户端能够跟踪最后触发的事件，这样如果与服务器的连接断开，客户端发送的新请求中会设置一个特殊的HTTP头(`Last-Event-ID`)。
- en: The upcoming sections cover how to associate IDs with SSEs, how SSE works with
    connection loss and retries, and how to associate event names with SSEs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将介绍如何将ID与SSE关联，SSE在连接丢失和重试时的工作原理，以及如何将事件名称与SSE关联。
- en: Associating an ID with an event
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将ID与事件关联
- en: Each SSE message can have a message identifier, which can be used for a variety
    of purposes, for example, to keep track of the messages that the client has received
    and also to keep a checkpoint for it. When the message ID is used in SSE, the
    client can supply the last message ID as one of the connection parameters to instruct
    the server to resume from a specific message onwards. Of course, the server-side
    code should implement a proper procedure to resume a communication from the message
    ID as requested by the client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SSE消息都可以有一个消息标识符，可以用于各种目的，例如跟踪客户端接收到的消息，并为其保留一个检查点。当消息ID在SSE中使用时，客户端可以将最后的消息ID作为连接参数之一提供，以指示服务器从特定消息开始恢复。当然，服务器端代码应该实现一个适当的过程，以从客户端请求的消息ID恢复通信。
- en: 'An example of the SSE message with the ID is shown in the following snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了带有ID的SSE消息的示例：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Retrying in case of connection failures
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在连接失败的情况下重试
- en: 'Firefox, Chrome, Opera, and Safari support server-sent events. In case there
    is a connection loss between the browser and server, the browser can try reconnecting
    to the server. There is a retry directive, which can be configured by the server
    to enable the retries from a client. The default value for the retry interval
    is 3 seconds. To increase the retry interval to 5 seconds, the server can send
    a retry event as shown:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox、Chrome、Opera和Safari支持服务器发送事件。如果浏览器和服务器之间出现连接丢失，浏览器可以尝试重新连接到服务器。服务器可以配置一个重试指令，以允许客户端进行重试。重试间隔的默认值为3秒。服务器可以发送一个重试事件来增加重试间隔到5秒，如下所示：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Associating event names with events
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将事件名称与事件关联
- en: 'Another SSE directive is the event name. Each event source can generate more
    than one type of event, and a client can decide how to consume each event type
    based on what event type it subscribes for. The following code snippet shows how
    the `name` event directive incorporates into the message:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个SSE指令是事件名称。每个事件源可以生成多种类型的事件，客户端可以根据订阅的事件类型决定如何消费每种事件类型。以下代码片段显示了`name`事件指令如何融入消息中：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Server-sent events and JavaScript
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器发送事件和JavaScript
- en: 'The API that is considered the foundation of SSE in the client side for JavaScript
    developers is the `EventSource` interface. The `EventSource` interface contains
    a fair number of functions and attributes, but the most important ones are listed
    in the following table:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是JavaScript开发人员在客户端中SSE的基础API是`EventSource`接口。`EventSource`接口包含相当多的函数和属性，但最重要的函数列在下表中：
- en: '| Function name | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 函数名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `addEventListener` | This function adds an event listener to handle the incoming
    events based on the event type. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `addEventListener` | 此函数添加事件监听器，以处理基于事件类型的传入事件。 |'
- en: '| `removeEventListener` | This function removes an already registered listener.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `removeEventListener` | 此函数移除已注册的监听器。 |'
- en: '| `onmessage` | This function is invoked on message arrival. There is no custom
    event handling available when using the `onmessage` method. Listeners manage the
    custom event handling. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `onmessage` | 当消息到达时调用此函数。使用`onmessage`方法时，没有自定义事件处理可用。监听器管理自定义事件处理。 |'
- en: '| `onerror` | This function is invoked when something goes wrong with the connection.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `onerror` | 当连接出现问题时调用此函数。 |'
- en: '| `onopen` | This function is invoked when a connection is opened. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `onopen` | 当连接打开时调用此函数。 |'
- en: '| `onclose` | This function is invoked when a connection is closed. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `onclose` | 当连接关闭时调用此函数。 |'
- en: The following snippet shows how to subscribe for different event types omitted
    by one source. The snippet assumes that the incoming messages are JSON-formatted
    messages. For example, there is an application that can stream updates to users
    as and when new books are available in some storage. The `'bookavailable'` listener
    uses a simple JSON parser to parse the incoming JSON.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何订阅一个来源省略的不同事件类型。代码片段假定传入的消息是JSON格式的消息。例如，有一个应用程序可以在某个存储中有新书可用时向用户流式传输更新。`'bookavailable'`监听器使用简单的JSON解析器来解析传入的JSON。
- en: Then, it will use this to update the GUI, while the `'newbookadded'` listener
    uses the reviver function to filter out and selectively process the JSON pairs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将用此来更新GUI，而`'newbookadded'`监听器使用恢复函数来过滤并选择性处理JSON对。
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Server-sent events and Jersey
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器发送事件和Jersey
- en: SSEs are not part of the standard JAX-RS specification. However, they are supported
    in the Jersey implementation of JAX-RS. For more details, check out [https://jersey.java.net/documentation/latest/sse.html](https://jersey.java.net/documentation/latest/sse.html).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SSE不是标准JAX-RS规范的一部分。然而，在JAX-RS的Jersey实现中支持它们。更多细节请查看[https://jersey.java.net/documentation/latest/sse.html](https://jersey.java.net/documentation/latest/sse.html)。
- en: WebHooks
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebHooks
- en: '**WebHooks** are a form of user-defined custom HTTP callbacks. With the WebHook
    model, a client provides the event producer with an endpoint to which the event
    producer can *post* the events. When an event is posted to the endpoint, the client
    application that is interested in such events can take appropriate actions. An
    example of WebHooks is triggering an event such as a Hudson job using a GIT post-receive
    hook.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebHooks**是一种用户定义的自定义HTTP回调形式。在WebHook模型中，客户端提供事件生成器的端点，事件生成器可以向其*发布*事件。当事件发布到端点时，对此类事件感兴趣的客户端应用程序可以采取适当的操作。WebHooks的一个例子是使用GIT
    post-receive hook触发Hudson作业等事件。'
- en: To acknowledge that the subscriber received the WebHook without any problem,
    the subscriber's endpoint should return a `200 OK HTTP` status code. The event
    producer will ignore the request body and any other request header, other than
    the status. Any response code outside the 200 ranges, including 3xx codes, will
    indicate that they did not receive the WebHook, and the API might retry sending
    the HTTP `POST` request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认订阅者正常接收到WebHook，订阅者的端点应返回`200 OK HTTP`状态码。事件生成器将忽略请求正文和除状态外的任何其他请求标头。任何200范围之外的响应代码，包括3xx代码，都将表示他们未收到WebHook，并且API可能会重试发送HTTP
    `POST`请求。
- en: WebHooks events generated by GitHub deliver a payload of information about activity
    in a repository. WebHooks can trigger across several different actions. For example,
    a consumer might request for a payload of information any time a commit is made,
    a repository is forked, or an issue is created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub生成的WebHooks事件传递了有关存储库中活动的信息负载。WebHooks可以触发多种不同的操作。例如，消费者可能在进行提交时、复制存储库时或创建问题时请求信息负载。
- en: 'The following diagram depicts how WebHooks work with GitHub or GitLab:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了WebHooks如何与GitHub或GitLab一起工作：
- en: '![WebHooks](img/7963OS_06_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![WebHooks](img/7963OS_06_04.jpg)'
- en: 'Let''s look at how WebHooks work:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看WebHooks是如何工作的：
- en: The user makes a **Git** push.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户进行**Git**推送。
- en: There is a custom WebHook URL to post the event object registered by the consumer
    with GitHub. When an event occurs, for example, when a commit is made, the GitHub
    service will send the payload of information regarding the commit, using a **POST**
    message to the endpoint provided by the consumer.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者与GitHub注册的事件对象有一个自定义的WebHook URL。例如，当发生事件时，比如进行提交时，GitHub服务将使用**POST**消息将有关提交的信息负载发送到消费者提供的端点。
- en: The consumer application can then store data in the **dB** or take some other
    action such as triggering a continuous integration build.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，消费应用程序可以将数据存储在**dB**中，或者执行其他操作，比如触发持续集成构建。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Some of the popular WebHooks case studies**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的WebHooks案例研究
- en: Twilio uses WebHooks to send SMS messages. GitHub uses WebHooks to send repository
    change notification and, optionally, some payloads.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Twilio使用WebHooks发送短信。GitHub使用WebHooks发送存储库更改通知，以及可选的一些负载。
- en: PayPal uses **Instant Payment Notification** (**IPN**), a message service that
    automatically notifies merchants of events related to PayPal transactions, and
    it is based on WebHooks.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: PayPal使用**即时付款通知**（**IPN**），这是一种自动通知商家与PayPal交易相关事件的消息服务，它基于WebHooks。
- en: Facebook's real-time API uses WebHooks and is based on **PubSubHubbub** (**PuSH**).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook的实时API使用WebHooks，并基于**PubSubHubbub**（**PuSH**）。
- en: As mentioned earlier, if an API does not offer a form of WebHooks for notification,
    its consumers will have to keep polling for data, which is not only inefficient
    but also not real time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果一个API没有提供WebHooks形式的通知，其消费者将不得不不断轮询数据，这不仅效率低下，而且不是实时的。
- en: WebSockets
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSockets
- en: The WebSocket protocol is a protocol that provides full-duplex communication
    channels over a single TCP connection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议是一种在单个TCP连接上提供全双工通信通道的协议。
- en: The WebSocket protocol is an independent TCP-based protocol, and its only relationship
    to HTTP is that the handshake to switch over to WebSockets is interpreted by HTTP
    servers as an `Upgrade` request.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议是一种独立的基于TCP的协议，它与HTTP的唯一关系是，切换到WebSockets的握手被HTTP服务器解释为`Upgrade`请求。
- en: It provides the option to have full-duplex, real-time communication between
    clients (for example, a web browser) and an endpoint without the constant cost
    of establishing a connection or polling resource intensively. WebSockets are extensively
    used in social feeds, multiplayer games, collaborative editing, and so on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了在客户端（例如Web浏览器）和端点之间进行全双工、实时通信的选项，而无需不断建立连接或密集轮询资源。WebSockets广泛用于社交动态、多人游戏、协作编辑等领域。
- en: 'The following lines show a WebSocket Protocol handshake, which starts with
    an `Upgrade` request:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了WebSocket协议握手的示例，从`Upgrade`请求开始：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following diagram shows an example of a handshake with the `HTTP/1.1 Upgrade`
    request and `HTPP/1.1 Switching Protocols` response:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个握手的示例，使用了`HTTP/1.1 Upgrade`请求和`HTTP/1.1 Switching Protocols`响应：
- en: '![WebSockets](img/7963OS_06_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![WebSockets](img/7963OS_06_05.jpg)'
- en: Once the connection has been established between the client and the server with
    the `Upgrade` request and `HTTP/1.1` response, WebSocket data frames, binary or
    text, can be sent back and forth between the client and server from both directions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端和服务器之间建立了连接，使用`Upgrade`请求和`HTTP/1.1`响应，WebSocket数据帧（二进制或文本）可以在客户端和服务器之间双向发送。
- en: WebSockets data is minimally framed between 2 bytes; this dramatically reduces
    the overhead compared to what HTTP headers would transfer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets数据最小帧为2字节；与HTTP头部传输相比，这大大减少了开销。
- en: 'A very basic example of using the JavaScript WebSockets API is shown as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用JavaScript WebSockets API的一个非常基本的示例：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following table will describe the WebSockets functionality and various
    functions in detail:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格将详细描述WebSockets功能和各种函数：
- en: '| Function name | Description |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 函数名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `send` | This function can be used to send a message to the server''s specified
    URL. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `send` | 这个函数可以用来向服务器指定的URL发送消息。 |'
- en: '| `onopen` | This function is invoked when the connection is created. The `onopen`
    function handles the `open` event type. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `onopen` | 当连接创建时，将调用此函数。`onopen`函数处理`open`事件类型。 |'
- en: '| `onmessage` | When a new message arrives, the `onmessage` function is invoked
    to handle the `message` event. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `onmessage` | 当新消息到达时，将调用`onmessage`函数来处理`message`事件。 |'
- en: '| `onclose` | This function is invoked when the connection is being closed.
    The `onclose` method handles the `close` event type. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `onclose` | 当连接被关闭时，将调用此函数。`onclose`方法处理`close`事件类型。 |'
- en: '| `onerror` | This function is invoked to handle the `error` event when an
    error occurs in the communication channel. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `onerror` | 当通信通道发生错误时，将调用此函数来处理`error`事件。 |'
- en: '| `close` | This function is used to close the communication socket and end
    the interaction between the client and server. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 这个函数用于关闭通信套接字并结束客户端和服务器之间的交互。 |'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Popular WebSockets Case Studies**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**流行的WebSockets案例研究**'
- en: Zynga Poker is one of the first games to utilize WebSockets connections on a
    massive scale. Using WebSockets in Zynga Poker HTML5 delivers a smooth, high-speed
    gameplay that allows for a synchronous experience on the mobile web. It varies
    based on connections, but the game loads and refreshes almost immediately.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 德州扑克是最早大规模利用WebSockets连接的游戏之一。在德州扑克HTML5中使用WebSockets可以提供流畅、高速的游戏体验，允许在移动网络上实现同步体验。根据连接的不同，游戏加载和刷新几乎立即完成。
- en: Additional real-time API supporters
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的实时API支持者
- en: There are some more commonly used real-time or near real-time communication
    protocols and APIs that are mostly used outside of the browser. Some of these
    protocols and APIs are described in the subsequent sections.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些常用的实时或几乎实时通信协议和API，它们大多数在浏览器之外使用。其中一些协议和API将在接下来的部分中描述。
- en: XMPP
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XMPP
- en: The XMPP protocol was developed to address the requirements of text messaging
    and Internet-chat-oriented solutions. XMPP's basic model of communication is client
    to server, server to server, server to client. In support of this, it defines
    a client to server protocol and a server to server protocol based on XML messages
    encoded and transmitted directly over TCP.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: XMPP协议是为满足文本消息和互联网聊天导向解决方案的要求而开发的。XMPP的基本通信模型是客户端到服务器、服务器到服务器、服务器到客户端。为了支持这一点，它定义了基于XML消息的客户端到服务器协议和服务器到服务器协议，直接通过TCP编码和传输。
- en: XMPP is a mature protocol with many implementations in different languages and
    platforms. The main drawback associated with XMPP is the long polling and open
    sockets to handle the inbound and outbound communications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: XMPP是一种成熟的协议，在不同语言和平台上有许多实现。与XMPP相关的主要缺点是长轮询和开放套接字来处理入站和出站通信。
- en: BOSH over XMPP
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XMPP上的BOSH
- en: '**Bidirectional streams Over Synchronous HTTP** (**BOSH**) specified in XEP-0124
    is the standardized way to do XMPP over HTTP. For the client-initiated protocol,
    the client simply sends XMPP packets on HTTP, and for the server-initiated protocol,
    the server uses long polling with the connection open for a prespecified period
    of time.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步HTTP上的双向流**（**BOSH**）在XEP-0124中规定了在HTTP上进行XMPP的标准方式。对于客户端发起的协议，客户端简单地在HTTP上发送XMPP数据包，对于服务器发起的协议，服务器使用长轮询，连接在预定的时间内保持打开状态。'
- en: The main advantage of BOSH is the possibility that it provides to use a web
    browser as an XMPP client by taking advantage of any of the JavaScript implementations
    of BOSH. Emite, JSJaC, and xmpp4js are some of the libraries that support BOSH.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: BOSH的主要优势在于它提供了使用Web浏览器作为XMPP客户端的可能性，利用了BOSH的任何JavaScript实现。Emite、JSJaC和xmpp4js是一些支持BOSH的库。
- en: Comparisons between WebHooks, WebSockets, and server-sent events
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebHooks、WebSockets和服务器发送事件之间的比较
- en: SSEs are sent over HTTP unlike WebSockets. SSEs offer only one-way communication
    of events from the server to the client and do not support a full-duplex communication
    as WebSockets do. SSEs have the ability to automatically retry a connection; they
    also have event IDs that can be associated with messages to provide **Quality
    of Service** (**QoS**) features. The WebSockets specification does not support
    these features.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与WebSockets不同，SSE是通过HTTP发送的。SSE仅提供了从服务器到客户端的事件单向通信，并不像WebSockets那样支持全双工通信。SSE具有自动重试连接的能力；它们还具有可以与消息关联的事件ID，以提供**服务质量**（**QoS**）功能。WebSockets规范不支持这些功能。
- en: On the other hand, WebSockets support full-duplex communication, and reduce
    the latency and help improve throughput, as there is an initial handshake over
    HTTP, but then, the messages are transferred between endpoints over TCP.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，WebSockets支持全双工通信，减少了延迟并有助于提高吞吐量，因为它们在HTTP上进行了初始握手，然后消息在端点之间通过TCP传输。
- en: In comparison to the two protocols mentioned earlier, WebHooks has a lower barrier
    to entry and offers an easy way for applications and services to integrate with
    one another. This enables the capability of having an interconnected and interchangeable
    set of loosely coupled cloud services talking to each other via HTTP requests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面提到的两种协议相比，WebHooks的准入门槛较低，并为应用程序和服务提供了一种简单的集成方式。这使得能够通过HTTP请求使一组松散耦合的云服务相互连接和交换。
- en: 'The following table compares and contrasts WebHooks, WebSockets, and SSEs in
    different areas:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下表比较和对比了WebHooks、WebSockets和SSE在不同领域的情况：
- en: '| Criteria | WebHooks | WebSockets | Server-sent events |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 标准 | WebHooks | WebSockets | 服务器发送事件 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Asynchronous real-time communication support | Yes | Yes | Yes |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 异步实时通信支持 | 是 | 是 | 是 |'
- en: '| Callback URL registered | Yes | No | No |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 回调URL注册 | 是 | 否 | 否 |'
- en: '| Long-lived open connection | No | Yes | Yes |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 长期开放连接 | 否 | 是 | 是 |'
- en: '| Bidirectional | No | Yes | No |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 双向 | 否 | 是 | 否 |'
- en: '| Error handling | No | Yes | Yes |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 错误处理 | 否 | 是 | 是 |'
- en: '| Easy to support and implement | Yes | Needs browsers and proxy server support
    | Yes |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 易于支持和实现 | 是 | 需要浏览器和代理服务器支持 | 是 |'
- en: '| Needs fallback to polling | No | Yes | No |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 需要回退到轮询 | 否 | 是 | 否 |'
- en: The next section will cover how highly available cloud applications are moving
    toward the Micro Services-based architecture.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将介绍高可用云应用程序如何向基于微服务的架构迈进。
- en: REST and Micro Services
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST和微服务
- en: The dream of SOA has become a reality with the emergence of Micro Services architecture,
    which comprises breaking a monolithic application into sets of fine-grained services.
    We will now look at the different advantages of Micro Services as compared to
    monolithic services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务架构的出现，SOA的梦想已经成为现实，微服务架构将单片应用程序分解为一组细粒度服务。我们现在将看一下微服务相对于单片服务的不同优势。
- en: Simplicity
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单性
- en: Instead of using the more complicated traditional enterprise, many developers
    are ﬁnding that building the same application using lightweight API services proves
    to be more resilient, scalable, and maintainable. This style is the Micro Services-based
    architecture. This is in contrast with approaches such as the legacy RPC approaches
    of CORBA and RMI, or the bulky Web Services protocols such as SOAP.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员发现，与使用更复杂的传统企业相比，使用轻量级API服务构建相同的应用程序更具弹性、可扩展性和可维护性。这种风格就是基于微服务的架构。这与诸如CORBA和RMI的传统RPC方法或SOAP等庞大的Web服务协议的方法形成对比。
- en: Isolation of problems
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题的隔离
- en: In the monolithic applications, all the components of a service are loaded in
    a single application artifact (a WAR, EAR, or JAR file), which is deployed on
    a single JVM. This implies that if the application or the application server goes
    down, it would mean a failure of all the services.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在单片应用程序中，服务的所有组件都加载在单个应用程序构件（WAR、EAR或JAR文件）中，该构件部署在单个JVM上。这意味着如果应用程序或应用程序服务器崩溃，将导致所有服务的失败。
- en: However, with the Micro Services architecture, the services can be independent
    WAR/EAR files. The services can communicate with one another with REST and JSON,
    or XML. Another way to communicate between services in the Micro Services architecture
    is to use a messaging protocol such as AMQP/Rabbit MQ.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用微服务架构，服务可以是独立的WAR/EAR文件。服务可以通过REST和JSON或XML相互通信。在微服务架构中，另一种服务之间通信的方式是使用AMQP/Rabbit
    MQ等消息协议。
- en: Scale up and scale down
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和缩减
- en: With monolithic services, not all services in the deployed application's file
    might need to be scaled, but they all are forced to follow the same scale-up and
    scale-down rules laid down at deployment level.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单片服务，部署的应用程序文件中并非所有服务都需要进行扩展，但它们都被迫遵循在部署级别制定的相同扩展和缩减规则。
- en: With the Micro Services architecture, applications can be built by smaller services
    that can be deployed and scaled independently. This results in an architecture
    that is resilient to failures, scalable and agile, for developing, building, and
    deploying services quickly from the feature definition phase to production phase.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构，可以通过较小的服务构建应用程序，这些服务可以独立部署和扩展。这导致了一种对故障具有弹性、可扩展和灵活的架构，可以从特性定义阶段快速开发、构建和部署服务，直到生产阶段。
- en: Clear separation of capabilities
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 能力的清晰分离
- en: In the Micro Services architecture, these services can be organized based on
    business capabilities. For example, an inventory service can be separated from
    a billing service, which can be separate from a shipping service. In case one
    of the services fails, the others can still continue serving requests as mentioned
    in the *Isolation of Problems* section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，这些服务可以根据业务能力进行组织。例如，库存服务可以与计费服务分开，而计费服务可以与运输服务分开。如果其中一个服务失败，其他服务仍然可以继续提供请求，正如*问题隔离*部分所述。
- en: Language independence
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言独立性
- en: Another advantage of the Micro Services architecture is that the services are
    built with a simple and easy-to-consume REST/JSON-based API that can be easily
    consumed by other languages or frameworks such as PHP, Ruby-On-Rails, Python,
    and node.js.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的另一个优势是，这些服务是使用简单易用的REST/JSON API构建的，可以轻松被其他语言或框架（如PHP、Ruby-On-Rails、Python和node.js）消费。
- en: Amazon and Netflix are some of the pioneers in the Micro Services architecture.
    eBay has open sourced Turmeric, a comprehensive, policy-driven SOA platform that
    can be used to develop, deploy, secure, run, and monitor SOA services and consumers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊和Netflix是微服务架构的先驱之一。eBay开源了Turmeric，这是一个全面的、基于策略驱动的SOA平台，可用于开发、部署、保护、运行和监控SOA服务和消费者。
- en: Recommended reading
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐阅读
- en: 'The following are the links to additional resources that interested readers
    can take a look at to get a more complete picture of use cases mentioned in this
    chapter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些额外资源的链接，感兴趣的读者可以查看，以更全面地了解本章提到的用例：
- en: '[https://stripe.com/docs/webhooks](https://stripe.com/docs/webhooks): WebHooks
    support'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://stripe.com/docs/webhooks](https://stripe.com/docs/webhooks)：WebHooks支持'
- en: '[https://github.com/sockjs](https://github.com/sockjs): GitHub SockJs'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/sockjs](https://github.com/sockjs)：GitHub SockJs'
- en: '[https://developer.github.com/webhooks/testing/](https://developer.github.com/webhooks/testing/):
    GitHub WebHooks'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.github.com/webhooks/testing/](https://developer.github.com/webhooks/testing/)：GitHub
    WebHooks'
- en: '[http://www.twilio.com/platform/webhooks](http://www.twilio.com/platform/webhooks):
    Twilio WebHooks'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.twilio.com/platform/webhooks](http://www.twilio.com/platform/webhooks)：Twilio
    WebHooks'
- en: '[http://xmpp4js.sourceforge.net/](http://xmpp4js.sourceforge.net/): XMPP4JS
    BOSH library'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://xmpp4js.sourceforge.net/](http://xmpp4js.sourceforge.net/)：XMPP4JS
    BOSH库'
- en: '[https://code.google.com/p/emite/](https://code.google.com/p/emite/): Emite
    BOSH library'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://code.google.com/p/emite/](https://code.google.com/p/emite/)：Emite
    BOSH库'
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we covered advanced topics such as WebHooks, SSEs, WebSockets,
    and where and how they are being used in this chapter. One of the primary takeaways
    from this chapter was to understand how important it is to provide real-time APIs
    to avoid inefficiencies related to repeated polling. We saw case studies of companies
    using both WebHooks and WebSockets in their solutions. We saw different best practices
    and design principles sprinkled throughout the various chapters in the book; this
    chapter, as a finale, provided a substantial introduction to the future of REST
    and asynchronous communication. The proliferation of social data has the potential
    to be a great catalyst for the development of a semantic web that will enable
    agents to make nontrivial actions on our behalf and get real-time updates using
    the various patterns we discussed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了WebHooks、SSEs、WebSockets等高级主题，以及它们在本章中的使用场景和方式。本章的主要收获之一是要理解提供实时API的重要性，以避免与重复轮询相关的低效。我们看到了一些公司在其解决方案中同时使用WebHooks和WebSockets的案例研究。我们在整本书的各个章节中看到了不同的最佳实践和设计原则；作为总结，本章对REST和异步通信的未来提供了实质性的介绍。社交数据的大量增加有可能成为发展语义网络的重要推动力，这将使代理能够代表我们执行非平凡的操作，并使用我们讨论过的各种模式进行实时更新。
- en: Also, we saw how highly available cloud applications tend to move to a networked
    component model where applications are decomposed into *micro* services, which
    can be deployed and scaled independently using the Micro Services architecture.
    For more detailed information on building RESTful services, check out the book
    *Developing RESTful Services with JAX-RS2.0, WebSockets, and JSON*, *Bhakti Mehta
    and Masoud Kalali*, *Packt Publishing*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们看到高可用云应用程序往往会转向网络化组件模型，应用程序会被分解为可以使用微服务架构独立部署和扩展的*微*服务。要了解更多关于构建RESTful服务的详细信息，请查看书籍*Developing
    RESTful Services with JAX-RS2.0, WebSockets, and JSON*，作者Bhakti Mehta和Masoud Kalali，出版社Packt
    Publishing。
