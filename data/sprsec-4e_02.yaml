- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Getting Started with Spring Security
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security入门
- en: In this chapter, we’ll apply a minimal Spring Security configuration to start
    addressing our first finding—inadvertent privilege escalation due to a lack of
    URL protection and general authentication from the security audit discussed in
    [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy of an Unsafe Application*.
    We will then build on the basic configuration to provide a customized experience
    for our users. This chapter is intended to get you up and running with Spring
    Security and to provide a foundation for any other security-related tasks you
    will need to perform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将应用最小的Spring Security配置来开始解决我们的第一个发现——由于缺乏URL保护和一般认证，导致意外权限提升，这是在[*第1章*](B21757_01.xhtml#_idTextAnchor015)，“不安全应用程序的解剖”中讨论的安全审计。然后，我们将在此基础上构建基本配置，为我们的用户提供定制体验。本章旨在让您开始使用Spring
    Security，并为任何其他您需要执行的安全相关任务提供基础。
- en: 'During the course of this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的讨论过程中，我们将涵盖以下主题：
- en: Implementing a basic level of security on the **JBCP Calendar** application,
    using the automatic configuration option in Spring Security
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**JBCP日历**应用程序上实现基本的安全级别，使用Spring Security中的自动配置选项
- en: Learning how to customize both the login and logout experience
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何自定义登录和注销体验
- en: Configuring Spring Security to restrict access differently, depending on the
    URL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Security以根据URL限制不同的访问
- en: Leveraging the expression-based access controls of Spring Security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用基于表达式的Spring Security访问控制
- en: Conditionally displaying basic information about the logged-in user using the
    **JavaServer Pages** (**JSP**) library in Spring Security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**JavaServer Pages**（**JSP**）库在Spring Security中条件性地显示有关登录用户的基本信息
- en: Determining the user’s default location after login, based on their role
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户的角色确定登录后的默认位置
- en: In each chapter of the book, you are instructed to begin their exploration from
    a designated project `chapterX.00-calendar`, where `X` denotes the chapter number.
    During this chapter, the focus is on using an application built on Spring Security
    within the Spring Framework, excluding the use of Spring Boot.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的每一章中，您都会被指导从一个指定的项目`chapterX.00-calendar`开始探索，其中`X`表示章节编号。在本章中，重点是使用Spring框架中基于Spring
    Security的应用程序，不包括使用Spring Boot。
- en: The primary goal is to help readers become acquainted with the integration of
    Spring Security in the context of the Spring Framework.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是帮助读者熟悉Spring Framework环境下Spring Security的集成。
- en: From [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*
    onwards, the book shifts its emphasis to delve deeper into Spring Security, particularly
    in conjunction with the Spring Boot framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第3章*](B21757_03.xhtml#_idTextAnchor068)，“自定义认证”开始，本书将重点深入探讨Spring Security，特别是与Spring
    Boot框架结合使用。
- en: 'This chapter’s code in action link is here: [https://packt.link/fZ96T](https://packt.link/fZ96T).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码操作链接在此：[https://packt.link/fZ96T](https://packt.link/fZ96T)。
- en: Hello Spring Security
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security你好
- en: Although Spring Security can be extremely difficult to configure, the creators
    of the product have been thoughtful and have provided us with a very simple mechanism
    to enable much of the software’s functionality with a strong baseline. From this
    baseline, additional configuration will allow for a fine level of detailed control
    over the security behavior of the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Spring Security的配置可能非常困难，但产品的创造者已经深思熟虑，并为我们提供了一个非常简单的机制，通过这个机制，我们可以使用强大的基线启用软件的大部分功能。从这个基线开始，额外的配置将允许对应用程序的安全行为进行精细的控制。
- en: We’ll start with our unsecured calendar application from [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015),
    *Anatomy of an Unsafe Application*, and turn it into a site that’s secured with
    a rudimentary username and password authentication. This authentication serves
    merely to illustrate the steps involved in enabling Spring Security for our web
    application; you’ll see that there are some obvious flaws in this approach that
    will lead us to make further configuration refinements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从[*第1章*](B21757_01.xhtml#_idTextAnchor015)，“不安全应用程序的解剖”，我们的未加密日历应用程序开始，将其转变为一个使用基本的用户名和密码认证的受保护网站。这种认证仅仅是为了说明启用Spring
    Security为我们网络应用程序所涉及的步骤；你会发现这种方法存在一些明显的缺陷，这将引导我们进行进一步的配置优化。
- en: Importing the sample application
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入示例应用程序
- en: We encourage you to import the `chapter02.00-calendar` project into your **Integrated
    Development Environments** (**IDEs**) and follow along by obtaining the source
    code from this chapter, as described in the *Getting started with JBCP calendar
    sample code* section in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional*
    *Reference Material*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您将`chapter02.00-calendar`项目导入到您的**集成开发环境**（**IDEs**）中，并按照本章节中描述的从本章获取源代码，正如在[*附录*](B21757_20.xhtml#_idTextAnchor642)的*使用JBCP日历示例代码入门*部分所述，*附加参考材料*。
- en: For each chapter, you will find multiple revisions of the code that represent
    checkpoints within the book. This makes it easy to compare your work to the correct
    answers as you go. At the beginning of each chapter, we will import the first
    revision of that chapter as a starting point. For example, in this chapter, we
    start with `chapter02.00-calendar`, and the first checkpoint will be `chapter02.01-calendar`.
    In [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*, we
    will start with `chapter03.00-calendar`, and the first checkpoint will be `chapter03.01-calendar`.
    There are additional details in the *Getting started with JBCP calendar sample
    code* section in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional
    Reference Material*, so be sure to refer to it for details.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一章，您将找到多个代码修订版本，这些修订版本代表了书中的检查点。这使得您在前进过程中轻松地将您的工作与正确答案进行比较。在每一章的开始，我们将导入该章节的第一个修订版本作为起点。例如，在本章中，我们从`chapter02.00-calendar`开始，第一个检查点将是`chapter02.01-calendar`。在[*第3章*](B21757_03.xhtml#_idTextAnchor068)的*自定义身份验证*中，我们将从`chapter03.00-calendar`开始，第一个检查点将是`chapter03.01-calendar`。在[*附录*](B21757_20.xhtml#_idTextAnchor642)的*附加参考材料*部分的*使用JBCP日历示例代码入门*部分有更多详细信息，请务必查阅。
- en: Updating your dependencies
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新依赖项
- en: The first step is to update the project’s dependencies to include the necessary
    Spring Security JAR files. Update the `build.gradle` Gradle file (from the sample
    application you imported previously) to include the Spring Security JAR files
    that we will use in the following few sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更新项目的依赖项，包括必要的Spring Security JAR文件。更新之前导入的示例应用程序中的`build.gradle` Gradle文件，以包含我们在接下来的几节中将要使用的Spring
    Security JAR文件。
- en: Important note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Throughout the book, we will be demonstrating how to provide the required dependencies
    using Gradle. The `build.gradle` file is located in the root of the project and
    represents all that is needed to build the project (including the project’s dependencies).
    Remember that Gradle will download the transitive dependencies for each listed
    dependency. So, if you are using another mechanism to manage dependencies, ensure
    that you also include the transitive dependencies. When managing the dependencies
    manually, it is useful to know that the Spring Security reference includes a list
    of its transitive dependencies. A link to the Spring Security reference can be
    found in the *Supplementary materials* section in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional* *Reference Material*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将演示如何使用Gradle提供所需的依赖项。`build.gradle`文件位于项目的根目录中，代表构建项目所需的所有内容（包括项目的依赖项）。请记住，Gradle将为每个列出的依赖项下载传递依赖项。因此，如果您使用其他机制来管理依赖项，请确保您也包括传递依赖项。在手动管理依赖项时，了解Spring
    Security参考中包含其传递依赖项的列表是有用的。Spring Security参考的链接可以在[*附录*](B21757_20.xhtml#_idTextAnchor642)的*附加参考材料*部分的*补充材料*部分找到。
- en: 'Let’s take a look at the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code provides the necessary dependencies for basic Spring Security features
    in a Spring Framework project. However, depending on your specific requirements,
    you might need to add additional configurations as we will explore in the upcoming
    sections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码为Spring Framework项目中的基本Spring Security功能提供了必要的依赖项。然而，根据您的具体需求，您可能需要添加额外的配置，我们将在接下来的章节中探讨。
- en: Using Spring 6 and Spring Security 6
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Spring 6和Spring Security 6
- en: Spring 6 is used consistently. Our sample applications provide an example of
    the former option, which means that no additional work is required by you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 6被一致使用。我们的示例应用程序提供了一个前一个选项的例子，这意味着您不需要做额外的工作。
- en: 'In the following code, we present an example fragment of what is added to the
    `build.gradle` Gradle file to utilize the dependency management feature of Gradle;
    this ensures that the correct Spring version is used throughout the entire application.
    We are going to leverage the Spring **Bill Of Materials** (**BOM**) dependency,
    which will ensure that all the dependency versions imported by the BOM will work
    together correctly:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们展示了添加到 `build.gradle` Gradle 文件中的示例片段，以利用 Gradle 的依赖项管理功能；这确保了在整个应用程序中使用正确的
    Spring 版本。我们将利用 Spring **物料清单**（**BOM**）依赖项，这将确保所有由 BOM 导入的依赖项版本都能正确地一起工作：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using IntelliJ IDEA, any time you update the `build.gradle` file,
    ensure you right-click on the project, navigate to **Gradle** | **Reload Gradle
    Project…**, and select **OK** to update all the dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 IntelliJ IDEA，每次更新 `build.gradle` 文件时，请确保你右键单击项目，导航到 **Gradle** | **重新加载
    Gradle 项目…**，然后选择 **确定** 以更新所有依赖项。
- en: For more information about how Gradle handles transitive dependencies, as well
    as the BOM, refer to the Gradle documentation, which is listed in the *Supplementary
    materials* section, in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional*
    *Reference Material*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Gradle 如何处理传递依赖项以及 BOM 的更多信息，请参阅 *补充材料* 部分的 Gradle 文档，该文档列在 [*附录*](B21757_20.xhtml#_idTextAnchor642)
    的 *附加* *参考资料* 中。
- en: Implementing a Spring Security configuration
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Spring Security配置
- en: The next step in the configuration process is to create a Java configuration
    file representing all of the Spring Security components that are required to cover
    standard web requests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 配置过程的下一步是创建一个 Java 配置文件，代表所有需要覆盖标准 Web 请求的 Spring Security 组件。
- en: 'Create a new Java file in the `src/main/java/com/packtpub/springsecurity/configuration/`
    directory with the name `SecurityConfig.java`, and the following content. Among
    other things, the following file demonstrates user login requirements for every
    page in our application, provides a login page, authenticates the user, and requires
    the logged-in user to be associated with a role called `USER` for every URL element:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/main/java/com/packtpub/springsecurity/configuration/` 目录下创建一个新的 Java
    文件，文件名为 `SecurityConfig.java`，并包含以下内容。该文件展示了我们应用程序中每个页面的用户登录要求，提供了一个登录页面，验证了用户，并要求登录用户与名为
    `USER` 的角色相关联，以覆盖每个 URL 元素：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using IntelliJ IDEA, you can easily review `SecurityFilterChain`
    by pressing *F3*. Remember that the next checkpoint (`chapter02.01-calendar`)
    has a working solution, so the file can be copied from there as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 IntelliJ IDEA，你可以通过按 *F3* 键轻松地审查 `SecurityFilterChain`。请记住，下一个检查点（`chapter02.01-calendar`）有一个工作解决方案，因此文件也可以从那里复制。
- en: This is the only Spring Security configuration required to get our web application
    secured with a minimal standard configuration. This style of configuration, using
    a Spring-security-specific Java configuration, is known as **Java Configuration**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获取我们的 Web 应用程序以最小标准配置安全所需的唯一 Spring Security 配置。这种使用特定于 Spring-security 的
    Java 配置的配置风格被称为 **Java 配置**。
- en: Let’s take a minute to break this configuration apart so we can get a high-level
    idea of what is happening. In the `filterChain (HttpSecurity)` method, the `HttpSecurity`
    object creates a `Servlet Filter`, which ensures that the currently logged-in
    user is associated with the appropriate role. In this instance, the filter will
    ensure that the user is associated with `ROLE_USER`. It is important to understand
    that the name of the role is arbitrary. Later, we will create a user with `ROLE_ADMIN`
    and will allow this user to have access to additional URLs that our current user
    does not have access to.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间分解这个配置，以便我们可以获得一个高级的概念了解正在发生的事情。在 `filterChain (HttpSecurity)` 方法中，`HttpSecurity`
    对象创建了一个 `Servlet Filter`，这确保了当前登录的用户与适当的角色相关联。在这个例子中，过滤器将确保用户与 `ROLE_USER` 相关联。重要的是要理解角色的名称是任意的。稍后，我们将创建一个具有
    `ROLE_ADMIN` 的用户，并允许这个用户访问当前用户无法访问的额外 URL。
- en: In the `userDetailsService ()` method, the `InMemoryUserDetailsManager` object
    is how Spring Security authenticates the user. In this instance, we utilize an
    in-memory data store to compare a username and password.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `userDetailsService ()` 方法中，`InMemoryUserDetailsManager` 对象是 Spring Security
    验证用户的方式。在这个例子中，我们使用内存数据存储来比较用户名和密码。
- en: Our example and explanation of what is happening are a bit contrived. An in-memory
    authentication store would not work in a production environment. However, it allows
    us to get things up and running quickly. We will incrementally improve our understanding
    of Spring Security as we update our application to use production quality security
    throughout this book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例和解释所描述的情况有些牵强。在生产环境中，内存中的身份验证存储不会工作。然而，它使我们能够快速启动和运行。随着我们更新应用程序以使用整个书籍中的生产质量安全，我们将逐步提高我们对
    Spring Security 的理解。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: General support for **Java Configuration** was added to Spring Framework in
    Spring 3.1\. Since Spring Security 3.2 release, there has been Spring Security
    Java Configuration support, which enables users to easily configure Spring Security
    without the use of any XML. If you are familiar with [*Chapter 6*](B21757_06.xhtml#_idTextAnchor180),
    *LDAP Directory Services*, and the Spring Security documentation, then you should
    find quite a few similarities between it and Security **Java** **Configuration**
    support.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 3.1 中，Spring 框架增加了对 **Java 配置** 的一般支持。自 Spring Security 3.2 版本发布以来，已经提供了
    Spring Security Java 配置支持，使用户能够轻松配置 Spring Security 而不使用任何 XML。如果您熟悉 [*第 6 章*](B21757_06.xhtml#_idTextAnchor180)
    *LDAP 目录服务* 和 Spring Security 文档，那么您应该会发现它与 Security **Java** **配置** 支持之间有许多相似之处。
- en: Updating your web configuration
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新您的 Web 配置
- en: The next steps involve a series of updates to the `WebAppInitializer.java` file.
    Some of the steps have already been performed because the application was already
    using **Spring MVC**. However, we will go over these requirements to ensure that
    more fundamental Spring requirements are understood, if you are using Spring Security
    in an application that is not Spring-enabled.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及对 `WebAppInitializer.java` 文件的一系列更新。由于应用程序已经使用 **Spring MVC**，因此其中一些步骤已经执行。然而，我们将回顾这些要求，以确保更基本的
    Spring 要求得到理解，如果您在未启用 Spring 的应用程序中使用 Spring Security。
- en: The ContextLoaderListener class
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ContextLoaderListener 类
- en: 'The first step of updating the `WebAppInitializer.java` file is to use `jakarta.servlet.ServletContainerInitializer`,
    which is the preferred approach to Servlet 4.0+ initialization. Spring MVC provides
    the `o.s.w.WebApplicationInitializer` interface, which leverages this mechanism.
    In Spring MVC, the preferred approach is to extend `o.s.w.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer`.
    The `WebApplicationInitializer` class is polymorphically `o.s.w.context.AbstractContext`
    **LoaderInitializer** and uses the abstract `createRootApplicationContext()` method
    to create a root `ApplicationContext`, then delegates it to `ContextLoaderListener`,
    which is registered in the `ServletContext` instance, as shown in the following
    code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `WebAppInitializer.java` 文件的第一个步骤是使用 `jakarta.servlet.ServletContainerInitializer`，这是
    Servlet 4.0+ 初始化的首选方法。Spring MVC 提供了 `o.s.w.WebApplicationInitializer` 接口，该接口利用了这一机制。在
    Spring MVC 中，首选的方法是扩展 `o.s.w.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer`。`WebApplicationInitializer`
    类是多态的 `o.s.w.context.AbstractContext` **LoaderInitializer**，它使用抽象的 `createRootApplicationContext()`
    方法创建一个根 `ApplicationContext`，然后将其委托给注册在 `ServletContext` 实例中的 `ContextLoaderListener`，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The updated configuration will now load `the SecurityConfig.class` from the
    `classpath` of the `WAR` file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的配置现在将从 `WAR` 文件的 `classpath` 中加载 `the SecurityConfig.class`。
- en: ContextLoaderListener versus DispatcherServlet
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ContextLoaderListener 与 DispatcherServlet 的比较
- en: 'The `o.s.web.servlet.DispatcherServlet` interface specifies configuration classes
    to be loaded on their own using the `getServletConfigClasses()` method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.web.servlet.DispatcherServlet` 接口指定了使用 `getServletConfigClasses()` 方法独立加载的配置类：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `DispatcherServlet` class generates an `o.s.context.ApplicationContext`
    within the Spring framework, functioning as a child of the root `ApplicationContext`
    interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet` 类在 Spring 框架内生成一个 `o.s.context.ApplicationContext`，作为根
    `ApplicationContext` 接口的一个子接口。'
- en: Generally, components specific to Spring MVC are initialized within the `ApplicationContext`
    interface of `DispatcherServlet`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，特定于 Spring MVC 的组件在 `DispatcherServlet` 的 `ApplicationContext` 接口中初始化。
- en: On the other hand, the remaining components are loaded through `ContextLoaderListener`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，其余组件通过 `ContextLoaderListener` 加载。
- en: It’s crucial to understand that beans in a child `ApplicationContext`, like
    the ones generated by `DispatcherServlet`, can reference beans from the parent
    `ApplicationContext`, established by `ContextLoaderListener`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点至关重要，即子`ApplicationContext`中的Bean，如由`DispatcherServlet`生成的Bean，可以引用由`ContextLoaderListener`建立的父`ApplicationContext`中的Bean。
- en: However, the parent `ApplicationContext` interface cannot make references to
    beans within the child `ApplicationContext`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，父`ApplicationContext`接口不能引用子`ApplicationContext`中的Bean。
- en: 'This is illustrated in the following diagram, in which **Child Beans** can
    refer to **Root Beans**, but **Root Beans** cannot refer to **Child Beans**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下图中得到了说明，其中**子Bean**可以引用**根Bean**，但**根Bean**不能引用**子Bean**：
- en: '![Figure 2.1 – ContextLoaderListener and DispatcherServlet relationships](img/B21757_02_1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – ContextLoaderListener和DispatcherServlet的关系](img/B21757_02_1.jpg)'
- en: Figure 2.1 – ContextLoaderListener and DispatcherServlet relationships
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – ContextLoaderListener和DispatcherServlet的关系
- en: As in most use cases of Spring Security, we do not need Spring Security to refer
    to any of the MVC-declared beans. Therefore, we have decided to have `ContextLoaderListener`
    initialize all configurations of Spring Security.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数Spring Security的使用案例一样，我们不需要Spring Security引用任何由MVC声明的Bean。因此，我们决定让`ContextLoaderListener`初始化所有Spring
    Security的配置。
- en: The springSecurityFilterChain filter
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: springSecurityFilterChain过滤器
- en: The next step is to configure `springSecurityFilterChain` to intercept all requests
    by creating an implementation of `AbstractSecurityWebApplicationInitializer`.
    It is critical for `springSecurityFilterChain` to be declared first, to ensure
    the request is secured before any other logic is invoked.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置`springSecurityFilterChain`以通过创建`AbstractSecurityWebApplicationInitializer`的实现来拦截所有请求。确保在调用任何其他逻辑之前请求被安全处理是至关重要的。
- en: 'The following diagram shows the role of `SecurityFilterChain`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了`SecurityFilterChain`的作用：
- en: '![Figure 2.2 – Role of SecurityFilterChain](img/B21757_02_2.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – SecurityFilterChain的角色](img/B21757_02_2.jpg)'
- en: Figure 2.2 – Role of SecurityFilterChain
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – SecurityFilterChain的角色
- en: 'To ensure `springSecurityFilterChain` gets loaded first, we can use `@Order(1)`,
    as shown in the following configuration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`springSecurityFilterChain`首先加载，我们可以使用`@Order(1)`，如下面的配置所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `SecurityWebAppInitializer` class will automatically register the `springSecurityFilterChain`
    filter for every URL in your application and will add `ContextLoaderListener`,
    which loads `SecurityConfig`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityWebAppInitializer`类将自动为应用程序中的每个URL注册`springSecurityFilterChain`过滤器，并将添加`ContextLoaderListener`，该监听器加载`SecurityConfig`。'
- en: The DelegatingFilterProxy class
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DelegatingFilterProxy类
- en: The `o.s.web.filter.DelegatingFilterProxy` class is a `Servlet Filter` provided
    by Spring Web that will delegate all work to a Spring bean from the `ApplicationContext`
    root, which must implement `jakarta.servlet.Filter`. Since, by default, the bean
    is looked up by name, using the `<filter-name>` value, we must ensure we use `springSecurityFilterChain`
    as the value of `<filter-name>`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.web.filter.DelegatingFilterProxy`类是由Spring Web提供的`Servlet Filter`，它将所有工作委托给`ApplicationContext`根中的一个Spring
    Bean，该Bean必须实现`jakarta.servlet.Filter`接口。由于默认情况下，Bean是通过名称查找的，使用`<filter-name>`值，我们必须确保我们使用`springSecurityFilterChain`作为`<filter-name>`的值。'
- en: Here is a diagram of how `DelegatingFilterProxy` fits into the `Filter` instances
    and the `FilterChain`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`DelegatingFilterProxy`如何适应`Filter`实例和`FilterChain`的示意图。
- en: '![Figure 2.3 – Role of DelegatingFilterProxy](img/B21757_02_3.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – DelegatingFilterProxy的角色](img/B21757_02_3.jpg)'
- en: Figure 2.3 – Role of DelegatingFilterProxy
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – DelegatingFilterProxy的角色
- en: 'The pseudocode for how `o.s.web.filter.DelegatingFilterProxy` works for our
    `web.xml` file can be found in the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.web.filter.DelegatingFilterProxy`如何为我们的`web.xml`文件工作，其伪代码可以在以下代码片段中找到：'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code showcases the interaction of the Spring Security `DelegatingFilterProxy`
    within a **Servlet**-based application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了Spring Security `DelegatingFilterProxy`在基于**Servlet**的应用程序中的交互。
- en: The FilterChainProxy class
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FilterChainProxy类
- en: When working in conjunction with Spring Security, `o.s.web.filter.DelegatingFilterProxy`
    will delegate to the `o.s.s.web.FilterChainProxy` interface of Spring Security.
    The `FilterChainProxy` class allows Spring Security to conditionally apply any
    number of `Servlet Filters` to the `Servlet Request`. We will learn more about
    each of the Spring Security filters, and their roles in ensuring that our application
    is properly secured, throughout the rest of the book.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Spring Security一起工作时，`o.s.web.filter.DelegatingFilterProxy`将委托给Spring Security的`o.s.s.web.FilterChainProxy`接口。`FilterChainProxy`类允许Spring
    Security有条件地将任意数量的`Servlet Filters`应用到`Servlet 请求`上。我们将在本书的其余部分学习每个Spring Security过滤器及其在确保我们的应用程序得到适当保护中的作用。
- en: 'The following diagram shows the role of `FilterChainProxy`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了`FilterChainProxy`的作用：
- en: '![Figure 2.4 – Role of DelegatingFilterProxy](img/B21757_02_4.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – DelegatingFilterProxy的作用](img/B21757_02_4.jpg)'
- en: Figure 2.4 – Role of DelegatingFilterProxy
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – DelegatingFilterProxy的作用
- en: 'The pseudocode for how `FilterChainProxy` works is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterChainProxy`的工作伪代码如下：'
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Due to the fact that both `DelegatingFilterProxy` and `FilterChainProxy` are
    the front doors to Spring Security when used in a web application, you would add
    a debug point when trying to figure out what is happening.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`DelegatingFilterProxy`和`FilterChainProxy`在Web应用程序中使用时都是Spring Security的前门，所以在尝试找出发生了什么时，你会添加一个调试点。
- en: Running a secured application
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行受保护的应用程序
- en: 'If you have not already done so, restart the application and visit `http://localhost:8080/`.
    You will be presented with the following screen:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请重新启动应用程序并访问`http://localhost:8080/`。你将看到以下屏幕：
- en: '![Figure 2.5 – Login page](img/B21757_02_5.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 登录页面](img/B21757_02_5.jpg)'
- en: Figure 2.5 – Login page
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 登录页面
- en: Great job! We’ve implemented a basic layer of security in our application using
    Spring Security. At this point, you should be able to log in using `user1@example.com`
    as `user1` as **Password**. You’ll see the calendar welcome page, which describes
    at a high level what to expect from the application in terms of security.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们已经在应用程序中使用了Spring Security实现了基本的安全层。到现在为止，你应该能够使用`user1@example.com`作为`user1`的**密码**登录。你会看到日历欢迎页面，它从高层次上描述了从应用程序中可以期待的安全功能。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter02.01-calendar`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter02.01-calendar`。
- en: Common problems
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见问题
- en: 'Many users have trouble with the initial implementation of Spring Security
    in their applications. A few common issues and suggestions are listed next. We
    want to ensure that you can run the example application and follow along:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户在应用程序中Spring Security的初始实现上遇到了麻烦。以下是一些常见问题和建议。我们希望确保你可以运行示例应用程序并跟随操作：
- en: Make sure you can build and deploy the application before putting Spring Security
    in place.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将Spring Security应用到应用程序之前，请确保你可以构建和部署应用程序。
- en: Review some introductory samples and documentation on your servlet container
    if needed.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，请查看你的servlet容器的入门示例和文档。
- en: It’s usually easiest to use an IDE, such as IntelliJ IDEA, to run your servlet
    container. Not only is deployment typically seamless, but the console log is also
    readily available to review for errors. You can also set breakpoints at strategic
    locations to be triggered by exceptions to better diagnose errors.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，使用IDE，如IntelliJ IDEA，来运行你的servlet容器是最容易的。不仅部署通常是无缝的，而且控制台日志也便于查看错误。你还可以在关键位置设置断点，以便在异常触发时更好地诊断错误。
- en: Make sure the versions of Spring and Spring Security that you’re using match
    and that there aren’t any unexpected Spring JAR files remaining as part of your
    application. As previously mentioned, when using Gradle, it can be a good idea
    to declare the Spring dependencies in the dependency management section.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你使用的Spring和Spring Security版本匹配，并且应用程序中没有遗留任何意外的Spring JAR文件。如前所述，当使用Gradle时，在依赖管理部分声明Spring依赖项是一个好主意。
- en: In this section, we’ve established a Hello Spring Security application. We initiated
    the process by importing a sample application, subsequently updating dependencies,
    configuring Spring Security, managing web configurations, and finally, tackling
    common problems that may arise.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们建立了一个Hello Spring Security应用程序。我们通过导入示例应用程序、更新依赖项、配置Spring Security、管理Web配置以及最终解决可能出现的常见问题来启动这个过程。
- en: Moving forward, the following section will delve into the customization of the
    user experience post-login.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入探讨登录后的用户体验定制。
- en: A little bit of polish
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点点的润色
- en: Stop at this point and think about what we’ve just built. You may have noticed
    some obvious issues that will require some additional work and knowledge of the
    Spring Security product before our application is production ready. Try to make
    a list of the changes that you think are required before this security implementation
    is ready to roll out on the public-facing website.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个点上停下来，思考我们刚刚构建的内容。你可能已经注意到了一些明显的问题，这些问题需要我们在应用程序准备好投入生产之前做一些额外的工作，并了解Spring
    Security产品。尝试列出你认为在安全实现准备在公共网站推出之前所需的更改列表。
- en: 'Applying the Hello World Spring Security implementation was blindingly fast
    and has provided us with a login page, username, and password-based authentication,
    as well as the automatic interception of URLs in our calendar application. However,
    there are gaps between what the automatic configuration setup provides and what
    our end goal is, which are listed as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 应用Hello World Spring Security实现非常快，并为我们提供了一个登录页面、基于用户名和密码的认证，以及自动拦截我们的日历应用程序中的URL。然而，自动配置设置提供的内容和我们的最终目标之间存在差距，如下列所示：
- en: While the login page is helpful, it’s completely generic and doesn’t look like
    the rest of our JBCP calendar application. We should add a login form that’s integrated
    with our application’s look and feel.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然登录页面很有帮助，但它完全是一般性的，看起来不像我们的JBCP日历应用程序的其他部分。我们应该添加一个与我们的应用程序外观和感觉集成的登录表单。
- en: There is no obvious way for a user to log out. We’ve locked down all pages in
    the application, including the `Welcome` page, which a potential user may want
    to browse anonymously. We’ll need to redefine the roles required to accommodate
    anonymous, authenticated, and administrative users.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户没有明显的注销方式。我们锁定了应用程序中的所有页面，包括`Welcome`页面，潜在的浏览者可能希望匿名浏览。我们需要重新定义角色以适应匿名用户、认证用户和管理员用户。
- en: We do not display any contextual information to indicate to the user that they
    are authenticated. It would be nice to display a greeting similar to “welcome
    `user1@example.com`.”
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有显示任何上下文信息来告知用户他们已经认证。显示一个类似于“欢迎`user1@example.com`”的问候语会很好。
- en: 'We’ve had to hardcode the username, password, and role information of the user
    in the `SecurityConfig` configuration file. Recall this section of the `userDetailsService()`
    method we added:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不在`SecurityConfig`配置文件中硬编码用户的用户名、密码和角色信息。回想一下我们添加的`userDetailsService()`方法的这一部分：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the username and password are right there in the file. It’s
    unlikely that we’d want to add a new declaration to the file for every user of
    the system! To address this, we’ll need to update the configuration with another
    type of authentication.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以看到用户名和密码就在文件中。我们不太可能希望为系统中的每个用户都在文件中添加一个新的声明！为了解决这个问题，我们需要使用另一种类型的身份验证来更新配置。
- en: We’ll explore different authentication options throughout the first half of
    the book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的前半部分探索不同的认证选项。
- en: Customizing login
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义登录
- en: We’ve seen how Spring Security makes it very easy to get started. Now, let’s
    see how we can customize the login experience. In the following code snippet,
    we demonstrate the usage of some of the more common ways to customize login, but
    we encourage you to refer to the reference documentation of Spring Security, which
    includes the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional Reference
    Material*, with all of the supported attributes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Spring Security如何使开始变得非常容易。现在，让我们看看我们如何可以自定义登录体验。在下面的代码片段中，我们展示了自定义登录的一些更常见方式的用法，但我们鼓励你参考Spring
    Security的参考文档，其中包括[*附录*](B21757_20.xhtml#_idTextAnchor642)，*附加参考资料*，其中包含了所有支持的属性。
- en: 'Let’s take a look at the following steps to customize login:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤来自定义登录：
- en: 'First, update your `SecurityConfig.java` file as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照以下方式更新你的`SecurityConfig.java`文件：
- en: '[PRE9]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s take a look at the following methods depicted in the preceding code snippet:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段中描述的以下方法：
- en: The `loginPage()` method specifies where Spring Security will redirect the browser
    if a protected page is accessed and the user is not authenticated. If a login
    page is not specified, Spring Security will redirect the user to `/spring_security_login`.
    Then, `o.s.s.web.filter.FilterChainProxy` will choose `o.s.s.web.authentication.ui.DefaultLoginPageGeneratingFilter`,
    which renders the default login page as one of the delegates, since `DefaultLoginPageGeneratingFilter`
    is configured to process `/spring_security_login` by default. Since we have chosen
    to override the default URL, we are in charge of rendering the login page when
    the `/login/form` URL is requested.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginPage()`方法指定了当访问受保护的页面且用户未认证时，Spring Security将重定向浏览器到的位置。如果没有指定登录页面，Spring
    Security将重定向用户到`/spring_security_login`。然后，`o.s.s.web.filter.FilterChainProxy`将选择`o.s.s.web.authentication.ui.DefaultLoginPageGeneratingFilter`，作为代表之一渲染默认登录页面，因为`DefaultLoginPageGeneratingFilter`默认配置为处理`/spring_security_login`。由于我们选择覆盖默认URL，当请求`/login/form`
    URL时，我们将负责渲染登录页面。'
- en: The `loginProcessingUrl()` method defaults to `/j_spring_security_check` and
    specifies the URL that the login form (which should include the username and password)
    should be submitted to, using an HTTP post. When Spring Security processes this
    request, it will attempt to authenticate the user.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginProcessingUrl()`方法默认为`/j_spring_security_check`，并指定登录表单（应包括用户名和密码）应通过HTTP
    post提交到的URL。当Spring Security处理此请求时，它将尝试验证用户。'
- en: The `failureUrl()` method specifies the page that Spring Security will redirect
    to if the username and password submitted to `loginProcessingUrl()` are invalid.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureUrl()`方法指定了Spring Security在将无效的用户名和密码提交到`loginProcessingUrl()`时将重定向到的页面。'
- en: The `usernameParameter()` and `passwordParameter()` methods default to `j_username`
    and `j_password` respectively, and specify the HTTP parameters that Spring Security
    will use to authenticate the user when processing the `loginProcessingUrl()` method.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usernameParameter()`和`passwordParameter()`方法默认为`j_username`和`j_password`，并指定Spring
    Security在处理`loginProcessingUrl()`方法时将使用的HTTP参数。'
- en: Important note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It may be obvious, but if we only wanted to add a custom login page, we would
    only need to specify the `loginPage()` method. We would then create our login
    form using the default values for the remaining attributes. However, it is often
    good practice to override the values of anything visible to users, to prevent
    exposing that we are using Spring Security. Revealing what frameworks we are using
    is a type of information leakage, making it easier for attackers to determine
    potential holes in our security.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能很明显，但如果我们只想添加自定义登录页面，我们只需要指定`loginPage()`方法。然后，我们将使用剩余属性的默认值创建我们的登录表单。然而，通常一个好的做法是覆盖任何用户可见的值，以防止暴露我们正在使用Spring
    Security。透露我们使用的框架是一种信息泄露，这使得攻击者更容易确定我们安全中的潜在漏洞。
- en: 'The next step is to create a login page. We can use any technology we want
    to render the login page, as long as the login form produces the HTTP request
    that we specified with our Spring Security configuration when submitted. By ensuring
    the HTTP request conforms to our configuration, Spring Security can authenticate
    the request for us. Create the `login.xhtml` file, as shown in the following code
    snippet:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建登录页面。我们可以使用任何我们想要的技術来渲染登录页面，只要登录表单在提交时产生我们使用Spring Security配置指定的HTTP请求。通过确保HTTP请求符合我们的配置，Spring
    Security可以为我们验证请求。创建`login.xhtml`文件，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that if you are having problems typing anything in the book, you can
    refer to the solution at the next checkpoint (`chapter02.02- calendar`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你在书中输入任何内容时遇到问题，你可以参考下一个检查点（`chapter02.02- calendar`）中的解决方案。
- en: 'The following number of items are worth highlighting in the preceding `login.xhtml`
    file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`login.xhtml`文件中，以下数量的事项值得突出：
- en: The form action should be `/login`, to match the value provided for the `loginProcessingUrl()`
    method we specified. For security reasons, Spring Security only attempts to authenticate
    when using `POST` by default.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单操作应该设置为`/login`，以匹配我们指定的`loginProcessingUrl()`方法的值。出于安全考虑，Spring Security默认只尝试在`POST`请求时进行身份验证。
- en: We can use `param.error` to see whether there was a problem logging in, since
    the value of our `failureUrl()` method, `/login/form?error`, contains the `HTTP`
    parameter error.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`param.error`来查看登录过程中是否出现了问题，因为我们的`failureUrl()`方法返回的值`/login/form?error`包含了`HTTP`参数错误。
- en: The session attribute, `SPRING_SECURITY_LAST_EXCEPTION`, contains the last `o.s.s.core.AuthenticationException`
    exception, which can be used to display the reason for a failed login. The error
    messages can be customized by leveraging Spring’s internationalization support.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话属性 `SPRING_SECURITY_LAST_EXCEPTION` 包含最后一个 `o.s.s.core.AuthenticationException`
    异常，该异常可以用来显示登录失败的原因。可以通过利用Spring的国际化支持来自定义错误消息。
- en: The input names for the `username` and `password` inputs are chosen to correspond
    to the values we specified for the `usernameParameter()` and `passwordParameter()`
    methods in our `SecurityConfig.java` configuration.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username` 和 `password` 输入的输入名称被选择与我们为 `usernameParameter()` 和 `passwordParameter()`
    方法在 `SecurityConfig.java` 配置中指定的值相对应。'
- en: '3. The last step is to make Spring MVC aware of our new URL. This can be done
    by adding the following method to `WebMvcConfig`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 最后一步是让Spring MVC知道我们新的URL。这可以通过向 `WebMvcConfig` 添加以下方法来完成：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code adds the custom `login.xhtml` login page and the related controller
    request mapping URL: `/login/form`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了自定义的 `login.xhtml` 登录页面和相关控制器请求映射URL：`/login/form`。
- en: Configuring logout
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置注销
- en: 'The `HttpSecurity` configuration of Spring Security automatically adds support
    for logging the user out. All that is needed is to create a link that points to
    `/j_spring_security_logout`. However, we will demonstrate how to customize the
    URL used to log the user out by performing the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security的 `HttpSecurity` 配置自动添加了对用户注销的支持。所需做的只是创建一个指向 `/j_spring_security_logout`
    的链接。然而，我们将通过以下步骤演示如何通过以下步骤自定义用于注销用户的URL：
- en: 'Update the Spring Security configuration as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新Spring Security配置：
- en: '[PRE12]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You have to provide a link for the user to click on that will log them out.
    We will update the `header.xhtml` file so that the `Logout` link appears on every
    page:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须提供一个链接，用户点击后可以注销。我们将更新 `header.xhtml` 文件，以便 `注销` 链接出现在每个页面上：
- en: '[PRE13]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last step is to update the `login.xhtml` file to display a message indicating
    logout was successful when the `logout` parameter is present:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是更新 `login.xhtml` 文件，以便在存在 `logout` 参数时显示注销成功的消息：
- en: '[PRE14]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Important note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter02.02-calendar`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像 `chapter02.02-calendar`。
- en: The page isn’t redirecting properly
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面没有正确重定向
- en: 'If you have not already, restart the application and visit `http://localhost:8080`;
    you will see an error, as shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请重新启动应用程序并访问 `http://localhost:8080`；您将看到一个错误，如下面的截图所示：
- en: '![Figure 2.6 – Page not redirecting properly](img/B21757_02_6.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 页面未正确重定向](img/B21757_02_6.jpg)'
- en: Figure 2.6 – Page not redirecting properly
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 页面未正确重定向
- en: 'What went wrong? The problem is, since Spring Security is no longer rendering
    the login page, we must allow everyone (not just the `USER` role) to access the
    **Login** page. Without granting access to the **Login** page, the following happens:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么问题？问题是，由于Spring Security不再渲染登录页面，我们必须允许每个人（而不仅仅是 `USER` 角色访问 **登录** 页面）。如果不授予对
    **登录** 页面的访问权限，就会发生以下情况：
- en: We request the **Welcome** page in the browser.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在浏览器中请求 **欢迎** 页面。
- en: Spring Security sees that the `USER` role and that we are not authenticated,
    so it redirects the browser to the **Login** page.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security 检测到 `USER` 角色并且我们没有认证，因此它将浏览器重定向到 **登录** 页面。
- en: The browser requests the **Login** page.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器请求 **登录** 页面。
- en: Spring Security sees that the `USER` role and that we are still not authenticated,
    so it redirects the browser to the **Login** page again.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security 检测到 `USER` 角色并且我们尚未认证，因此它再次将浏览器重定向到 **登录** 页面。
- en: The browser requests the **Login** page again.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器再次请求 **登录** 页面。
- en: 'Spring Security sees that the `USER` role, as shown in the following diagram:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security 检测到 `USER` 角色如下所示：
- en: '![Figure 2.7 – Login process with Spring Security](img/B21757_02_7.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 使用Spring Security的登录过程](img/B21757_02_7.jpg)'
- en: Figure 2.7 – Login process with Spring Security
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 使用Spring Security的登录过程
- en: The process could just keep repeating indefinitely. Fortunately for us, Firefox
    realizes that there are too many redirects occurring, stops performing the redirect,
    and displays a very informative error message. In the next section, we will learn
    how to fix this error by configuring URLs differently, depending on the access
    that they require.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程可能会无限期地重复。幸运的是，对于Firefox来说，它意识到发生了太多的重定向，停止执行重定向，并显示一个非常有用的错误信息。在下一节中，我们将学习如何通过根据它们所需访问权限的不同来配置URL来修复此错误。
- en: Basic role-based authorization
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于角色的基本授权
- en: 'We can expand on the Spring Security configuration from Hello Spring Security
    to vary the access controls by URL. In this section, you will find a configuration
    that allows more granular control over how resources can be accessed. In the configuration,
    Spring Security does the following tasks:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Hello Spring Security 的 Spring Security 配置基础上进行扩展，通过 URL 变更访问控制。在本节中，您将找到一个配置，它允许对资源如何被访问有更细粒度的控制。在配置中，Spring
    Security 执行以下任务：
- en: It completely ignores any request that starts with `/resources/`. This is beneficial
    since our images, CSS, and JavaScript do not need to use Spring Security.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完全忽略了以 `/resources/` 开头的任何请求。这很有益处，因为我们的图片、CSS 和 JavaScript 不需要使用 Spring Security。
- en: It allows anonymous users to access the **Welcome**, **Login**, and **Logout**
    pages. It only allows administrators access to the **All** **Events** page.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许匿名用户访问 **欢迎**、**登录** 和 **注销** 页面。它只允许管理员访问 **所有事件** 页面。
- en: It adds an administrator that can access the **All** **Events** page.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它添加了一个可以访问 **所有事件** 页面的管理员。
- en: 'Take a look at the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码片段：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice that we do not include the application’s context root, in the Spring
    Security configuration, because Spring Security takes care of the context root
    transparently for us. In this way, we do not need to update our configuration
    if we decide to deploy it to a different context root.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 Spring Security 配置中不包括应用程序的上下文根，因为 Spring Security 会为我们透明地处理上下文根。这样，如果我们决定将其部署到不同的上下文根，我们不需要更新我们的配置。
- en: 'In Spring Security 6, you can specify multiple `requestMatchers` entries using
    a builder pattern that allows you to have greater control over how security is
    applied to different portions of your application. The first `RequestMatcher`
    object states that Spring Security should ignore any URL that starts with `/resources/`,
    and the second `RequestMatcher` object states that any other request will be processed
    by it. There are a few important things to note about using multiple `requestMatchers`
    methods, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Security 6 中，您可以使用构建器模式指定多个 `requestMatchers` 条目，这允许您对如何将安全性应用于应用程序的不同部分有更大的控制权。第一个
    `RequestMatcher` 对象声明 Spring Security 应忽略任何以 `/resources/` 开头的 URL，第二个 `RequestMatcher`
    对象声明任何其他请求将由它处理。关于使用多个 `requestMatchers` 方法，有以下几点需要注意：
- en: If no path attribute is specified, it is the equivalent of using a path of `/**`,
    which matches all requests.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未指定路径属性，则相当于使用 `/**` 路径，它匹配所有请求。
- en: 'Each `requestMatchers()` method is considered in order, and only the first
    match is applied. So, the order in which they appear in your configuration file
    is important. The implication is that only the last `requestMatchers()` method
    can use a path that matches every request. If you do not follow this rule, Spring
    Security will produce an error. The following is invalid because the first matcher
    matches every request and will never get to the second mapping:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `requestMatchers()` 方法按顺序考虑，并且只应用第一个匹配项。因此，它们在配置文件中出现的顺序很重要。这意味着只有最后一个 `requestMatchers()`
    方法可以使用匹配每个请求的路径。如果不遵循此规则，Spring Security 将产生错误。以下是不合法的，因为第一个匹配器匹配所有请求，永远不会到达第二个映射：
- en: '[PRE16]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The default pattern is backed by `o.s.s.web.util.AntPathRequestMatcher`, which
    will compare the specified pattern to an `servletPath` and `pathInfo` methods
    of `HttpServletRequest`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认模式由 `o.s.s.web.util.AntPathRequestMatcher` 支持，它将比较指定的模式与 `HttpServletRequest`
    的 `servletPath` 和 `pathInfo` 方法。
- en: The `RequestMatcher` interface is used to determine whether a request matches
    a given rule. We use `securityMatchers` to determine whether `a given HttpSecurity`
    should be applied to a given request. In the same way, we can use `requestMatchers`
    to determine the authorization rules that we should apply to a given request.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestMatcher` 接口用于确定请求是否匹配给定的规则。我们使用 `securityMatchers` 来确定是否应该将 `给定 HttpSecurity`
    应用到给定的请求。同样，我们可以使用 `requestMatchers` 来确定我们应该应用到给定请求的授权规则。'
- en: 'The path attribute on the `requestMatchers()` method further refines the filtering
    of the request and allows access control to be applied. You can see that the updated
    configuration allows different types of access, depending on the URL pattern.
    The `ANONYMOUS` role is of particular interest since we have not defined it anywhere
    in `SecurityConfig.java`. This is the default authority assigned to a user that
    is not logged in. The following line, from the updates to our `SecurityConfig.java`
    file, is what allows anonymous (unauthenticated) users and users with the `USER`
    role authority to access the **Login** page. We will cover access control options
    in more detail in the second half of the book:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`requestMatchers()`方法的路径属性上进一步细化了请求的过滤，并允许应用访问控制。你可以看到更新后的配置允许根据URL模式应用不同类型的访问。`ANONYMOUS`角色特别引人关注，因为我们没有在`SecurityConfig.java`中定义它。这是分配给未登录用户的默认权限。以下是从我们的`SecurityConfig.java`文件更新中允许匿名（未认证）用户和具有`USER`角色权限的用户访问**登录**页面的那一行。我们将在本书的第二部分更详细地介绍访问控制选项：
- en: '[PRE17]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When defining the `requestMatchers()` methods, there are several things to
    keep in mind, including the following:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在定义`requestMatchers()`方法时，有几个需要注意的事项，包括以下内容：
- en: 'Just as each `requestMatchers()` methods. This means it is important to specify
    the most specific elements first. The following example illustrates a configuration
    that does not specify the more specific pattern first, which will result in warnings
    from Spring Security at startup:'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像每个`requestMatchers()`方法一样。这意味着首先指定最具体的元素非常重要。以下示例说明了没有首先指定更具体模式的配置，这将导致Spring
    Security在启动时发出警告：
- en: '[PRE18]'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is important to note that if `http.authorizeHttpRequests()` can have `anyRequest()`,
    there should be no child `requestMatchers()` method defined. This is because `anyRequest()`
    will match all requests that match this `http.authorizeHttpRequests()` tag. Defining
    a `requestMatchers()` child method with `anyRequest()` contradicts the `requestMatchers()`
    declaration. An example is as follows:'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要注意的是，如果`http.authorizeHttpRequests()`可以使用`anyRequest()`，则不应定义任何子`requestMatchers()`方法。这是因为`anyRequest()`将匹配所有与这个`http.authorizeHttpRequests()`标签匹配的请求。定义一个带有`anyRequest()`的`requestMatchers()`子方法与`requestMatchers()`声明相矛盾。以下是一个示例：
- en: '[PRE19]'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The path attribute of the `requestMatchers()` element is independent and is
    not aware of the `anyRequest()` method.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestMatchers()`元素的路径属性是独立的，并且不知道`anyRequest()`方法。'
- en: 'If you have not done so already, restart the application and visit `http://localhost:8080`.
    Experiment with the application to see all the updates you have made, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请重新启动应用程序并访问`http://localhost:8080`。通过以下方式实验应用程序，以查看你已做的所有更新：
- en: Select a link that requires authentication and observes the new login page.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个需要认证的链接，并观察新的登录页面。
- en: Try typing an invalid `username`/`password` and view the error message.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试输入无效的`用户名`/`密码`并查看错误消息。
- en: Try logging in as an admin (`admin1@example.com/admin1`), and view all of the
    events. Note that we are able to view all the events.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试以管理员身份（`admin1@example.com/admin1`）登录，并查看所有事件。请注意，我们能够查看所有事件。
- en: Try logging out and view the logout success message.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试注销并查看注销成功消息。
- en: Try logging in as a regular user (`user1@example.com/user1`), and view all of
    the events. Note that we get an **Access** **Denied** page.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试以普通用户身份（`user1@example.com/user1`）登录，并查看所有事件。请注意，我们得到一个**访问** **被拒绝**页面。
- en: Important note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter02.03-calendar`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter02.03-calendar`。
- en: Expression-based authorization
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于表达式的授权
- en: You may have noticed that granting access to everyone was not nearly as concise
    as we may have liked. Fortunately, Spring Security can leverage **Spring Expression
    Language** (**SpEL**) to determine whether a user has authorization. In the following
    code snippet, you can see the updates when using **SpEL** with Spring Security.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，授予所有人访问权限并不像我们可能希望的那样简洁。幸运的是，Spring Security可以利用**Spring表达式语言**（**SpEL**）来确定用户是否有权限。在以下代码片段中，你可以看到使用**SpEL**与Spring
    Security一起使用时的更新。
- en: 'For Java configuration, `WebExpressionAuthorizationManager` is available to
    help use legacy SpEL:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java配置，`WebExpressionAuthorizationManager`可用于帮助使用传统的SpEL：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Important note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may notice that the `/events/` security constraint is brittle. For example,
    the `/events` URL is not protected by Spring Security to restrict the `ADMIN`
    role. This demonstrates the need to ensure that we provide multiple layers of
    security. We will exploit this sort of weakness in [*Chapter 11*](B21757_11.xhtml#_idTextAnchor332),
    *Fine-Grained* *Access Control*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到`/events/`安全约束是脆弱的。例如，`/events` URL没有被Spring Security保护以限制`ADMIN`角色。这证明了我们需要确保提供多层安全。我们将在[*第11章*](B21757_11.xhtml#_idTextAnchor332)，*细粒度访问控制*中利用这种类型的弱点。
- en: Changing the `access` attribute from `hasAnyRole('ANONYMOUS', 'USER')` to `permitAll()`
    might not seem like much, but this only scratches the surface of the power of
    Spring Security’s expressions. We will go into much greater detail about access
    control and Spring expressions in the second half of the book. Go ahead and verify
    that the updates work by running the application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将`access`属性从`hasAnyRole('ANONYMOUS', 'USER')`更改为`permitAll()`可能看起来并不起眼，但这只是Spring
    Security表达式强大功能的一小部分。我们将在本书的后半部分更详细地介绍访问控制和Spring表达式。请运行应用程序以验证更新是否生效。
- en: Important note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is recommended that you use type-safe authorization managers instead of SpEL.
    Your code should now look like `chapter02.04-calendar`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用类型安全的授权管理器而不是SpEL。您的代码现在应该看起来像`chapter02.04-calendar`。
- en: Conditionally displaying authentication information
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件显示认证信息
- en: 'Currently, our application does not indicate whether we are logged in or not.
    It appears as though we are always logged in since the **Logout** link is always
    displayed. In this section, we will demonstrate how to display the authenticated
    user’s username and conditionally display portions of the page using **Thymeleaf**’s
    Spring Security tag library. We do so by performing the following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序没有指示我们是否已登录。看起来我们总是登录，因为**注销**链接总是显示。在本节中，我们将演示如何使用**Thymeleaf**的Spring
    Security标签库显示已认证用户的用户名，并条件性地显示页面的一部分。我们通过以下步骤来完成：
- en: 'Update your dependencies to include the `thymeleaf-extras- springsecurity6`
    JAR file. Since we are using Gradle, we will add a new dependency declaration
    in our `build.gradle` file, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的依赖项以包含`thymeleaf-extras-springsecurity6` JAR文件。由于我们使用Gradle，我们将在`build.gradle`文件中添加一个新的依赖项声明，如下所示：
- en: '[PRE21]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we need to add `SpringSecurityDialect` to the Thymeleaf engine as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`SpringSecurityDialect`添加到Thymeleaf引擎中，如下所示：
- en: '[PRE22]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `sec:authorize` attribute determines whether the user is authenticated with
    the `isAuthenticated()` value, displays the HTML node if the user is authenticated,
    and hides the node in the event that the user is not authenticated. The `access`
    attribute should be rather familiar from the `requestMatchers().access()` element.
    In fact, both components leverage the same SpEL support.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sec:authorize`属性确定用户是否通过`isAuthenticated()`值进行认证，如果用户已认证，则显示HTML节点，如果用户未认证，则隐藏该节点。`access`属性应该与`requestMatchers().access()`元素中的`access`属性相当熟悉。实际上，这两个组件都利用了相同的SpEL支持。'
- en: There are attributes in the `sec:authentication` attribute will look up the
    current `o.s.s.core.Authentication` object. The `property` attribute will find
    the principal attribute of the `o.s.s.core.Authentication` object, which in this
    case is `o.s.s.core.userdetails.UserDetails`. It then obtains the `UserDetails`
    username property and renders it to the page. Don’t worry if the details of this
    are confusing. We are going to go over this in more detail in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068),
    *Custom Authentication*.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`sec:authentication`属性中存在一些属性，它们将查找当前的`o.s.s.core.Authentication`对象。`property`属性将找到`o.s.s.core.Authentication`对象的主属性，在这个例子中是`o.s.s.core.userdetails.UserDetails`。然后它获取`UserDetails`的username属性并将其渲染到页面上。如果这个细节让你感到困惑，请不要担心。我们将在[*第3章*](B21757_03.xhtml#_idTextAnchor068)，*自定义认证*中更详细地讲解这一点。
- en: 'Update the `header.xhtml` file to leverage the Spring Security tag library.
    You can find the updates as follows:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新`header.xhtml`文件以利用Spring Security标签库。您可以通过以下方式找到更新：
- en: '[PRE23]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**If you haven’t done so already, restart the application to see the updates
    we have made. At this point, you may realize that we are still displaying links
    we do not have access to. For example, `user1@example.com` should not see a link
    to the **All Events** page. Rest assured, we’ll fix this when we cover the tags
    in greater detail in [*Chapter 11*](B21757_11.xhtml#_idTextAnchor332), *Fine-Grained*
    *Access Control*.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您还没有这样做，请重新启动应用程序以查看我们所做的更新。在此阶段，您可能会意识到我们仍在显示我们没有访问权限的链接。例如，`user1@example.com`
    不应该看到“所有事件”页面的链接。请放心，当我们在第 11 章[*细粒度访问控制*](B21757_11.xhtml#_idTextAnchor332)中更详细地介绍标签时，我们会解决这个问题**。'
- en: Important note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `chapter02.05-calendar`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`chapter02.05-calendar`。
- en: Customizing behavior after login
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录后的行为定制
- en: We have already discussed how to customize a user’s experience during login,
    but sometimes it is necessary to customize the behavior after login. In this section,
    we will discuss how Spring Security behaves after login and will provide a simple
    mechanism to customize this behavior.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何在登录期间定制用户体验，但有时有必要在登录后定制行为。在本节中，我们将讨论 Spring Security 在登录后的行为，并提供一个简单的机制来自定义此行为。
- en: In the default configuration, Spring Security has two different flows after
    successful authentication. The first scenario occurs if a user never visits a
    resource that requires authentication. In this instance, after a successful login
    attempt, the user will be sent to the `defaultSuccessUrl()` method chained to
    the `formLogin()` method. If left undefined, `defaultSuccessUrl()` will be the
    context root of the application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置下，Spring Security 在成功认证后有两个不同的流程。第一种情况是如果用户从未访问过需要认证的资源。在这种情况下，在成功登录尝试后，用户将被发送到与
    `formLogin()` 方法链接的 `defaultSuccessUrl()` 方法。如果未定义，`defaultSuccessUrl()` 将是应用程序的上下文根。
- en: If a user requests a protected page before being authenticated, Spring Security
    will remember the last protected page that was accessed before authenticating,
    using o.s.s.web.savedrequest.RequestCache. Upon successful authentication, Spring
    Security will send the user to the last protected page that was accessed before
    authentication. For example, if an unauthenticated user requests the My Events
    page, they will be sent to the Login page.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在认证之前请求受保护的页面，Spring Security 将使用 o.s.s.web.savedrequest.RequestCache 记住认证之前访问的最后受保护的页面。在成功认证后，Spring
    Security 将将用户发送到认证之前访问的最后受保护的页面。例如，如果一个未认证的用户请求“我的事件”页面，他们将被发送到登录页面。
- en: After successful authentication, they will be sent to the previously requested
    **My** **Events** page.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功认证后，他们将被发送到之前请求的 **我的** **事件** 页面。
- en: 'A common requirement is to customize Spring Security to send the user to a
    different `defaultSuccessUrl()` method, depending on the user’s role. Let’s take
    a look at how this can be accomplished by performing the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是根据用户的角色自定义 Spring Security，以便将用户发送到不同的 `defaultSuccessUrl()` 方法。让我们看看如何通过执行以下步骤来实现这一点：
- en: 'The first step is to configure the `defaultSuccessUrl()` method chained after
    the `formLogin()` method. Go ahead and update `SecurityConfig.java`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是配置在 `formLogin()` 方法之后链接的 `defaultSuccessUrl()` 方法。请更新 `SecurityConfig.java`
    文件：
- en: '[PRE24]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is to create a controller that processes `/default`. In the following
    code, you will find a sample Spring MVC controller, `DefaultController`, which
    demonstrates how to redirect administrators to the **All Events** page and other
    users to the **Welcome** page. Create a new file in the following location:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个处理 `/default` 的控制器。在以下代码中，您将找到一个示例 Spring MVC 控制器 `DefaultController`，它演示了如何将管理员重定向到
    **所有事件** 页面，以及其他用户重定向到 **欢迎** 页面。在以下位置创建一个新文件：
- en: '[PRE25]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In IntelliJ IDEA, you can press *Alt* + *Enter* to automatically add the missing
    imports.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IntelliJ IDEA 中，您可以按 *Alt* + *Enter* 自动添加缺失的导入。
- en: There are a few things to point out about `DefaultController` and how it works.
    The first is that Spring Security makes the `HttpServletRequest` parameter aware
    of the currently logged-in user. In this instance, we can inspect which role the
    user belongs to without relying on any of Spring Security’s APIs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `DefaultController` 和其工作方式，有一些事情需要指出。首先，Spring Security 使得 `HttpServletRequest`
    参数对当前登录用户知情。在这种情况下，我们可以检查用户属于哪个角色，而无需依赖 Spring Security 的任何 API。
- en: This is good because if Spring Security’s APIs change or we decide we want to
    switch our security implementation, we have less code that needs to be updated.
    It should also be noted that while we implement this controller with a Spring
    MVC controller, our `defaultSuccessUrl()` method can be handled by any controller
    implementation (for example, Struts, a standard servlet, and so on) if we desire.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为如果Spring Security的API发生变化，或者我们决定想要切换我们的安全实现，我们需要更新的代码会更少。还应注意的是，虽然我们使用Spring
    MVC控制器来实现这个控制器，但如果我们愿意，我们的`defaultSuccessUrl()`方法可以被任何控制器实现（例如，Struts、标准servlet等）处理。
- en: 'If you wish to always go to the `defaultSuccessUrl()` method, you can leverage
    the second parameter to the `defaultSuccessUrl()` method, which is a `Boolean`
    for always use. We will not do this in our configuration, but you can see an example
    of it as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望始终跳转到`defaultSuccessUrl()`方法，你可以利用`defaultSuccessUrl()`方法的第二个参数，该参数是一个用于始终使用的`Boolean`类型。在我们的配置中我们不会这样做，但你可以在以下示例中看到它：
- en: '[PRE26]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You are now ready to give it a try. Restart the application and go directly
    to the **My Events** page, then log in; you will see that you are on the **My**
    **Events** page.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以尝试一下。重新启动应用程序，直接转到**我的事件**页面，然后登录；你会看到你已经在**我的****事件**页面上了。
- en: Next, log out and try logging in as `user1@example.com`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，注销并尝试以`user1@example.com`登录。
- en: You should be on the `admin1@example.com`, and you will be sent to the **All**
    **Events** page.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用`admin1@example.com`，你将被发送到**所有****事件**页面。
- en: Important note
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter02.06-calendar`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter02.06-calendar`。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have applied a very basic Spring Security configuration.
    The main objective was to outline the steps and key concepts involved in implementing
    Spring Security in Spring 6 applications. To achieve this goal, we started by
    importing the sample application, then updating dependencies, configuring Spring
    Security, and managing web configurations, and in the end, we addressed common
    issues.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们应用了一个非常基本的Spring Security配置。主要目标是概述在Spring 6应用程序中实现Spring Security所需的步骤和关键概念。为了实现这一目标，我们首先导入示例应用程序，然后更新依赖项，配置Spring
    Security，管理Web配置，最后解决常见问题。
- en: Additionally, we explained how to customize the user’s login and logout experience
    and demonstrated how to display basic information based on roles and SpEL. We
    finished this chapter by customizing behavior after login.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们解释了如何自定义用户的登录和注销体验，并演示了如何根据角色和SpEL显示基本信息。我们通过在登录后自定义行为来结束这一章。
- en: In the next chapter, we will discuss how authentication in Spring Security works
    and how we can customize it to our needs.**
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Spring Security中的认证工作原理以及我们如何根据需要对其进行自定义。**
