- en: Chapter 4. JSON and Asynchronous Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 JSON和异步处理
- en: 'This chapter covers a brand new JSR, The JSR 353: Java API for JSON Processing
    [http://jcp.org/en/jsr/detail?id=353](http://jcp.org/en/jsr/detail?id=353), and
    related APIs along with some updates in different services and components in Java
    EE that provide better support for asynchronous interaction between different
    components of a system. The following list shows an itemized list of topics that
    are covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了全新的JSR，JSR 353：Java API for JSON Processing [http://jcp.org/en/jsr/detail?id=353](http://jcp.org/en/jsr/detail?id=353)，以及与Java
    EE中不同服务和组件相关的API更新，这些更新为系统不同组件之间的异步交互提供了更好的支持。以下列表显示了本章涵盖的主题列表：
- en: Producing, parsing and manipulating JSON data using Java
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java生成、解析和操作JSON数据
- en: Introducing NIO API in Servlet 3.1
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Servlet 3.1中引入NIO API
- en: New features in JAX-RS 2.0
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 2.0的新特性
- en: Producing and parsing JSON documents
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成和解析JSON文档
- en: JSON format was introduced as a replacement for the XML format when the extensibility
    and verbosity of XML were not required and thus to lift the resource consumption
    of complex XML processing to let smaller devices consume streams of data or data
    packets produced by different services they needed to interact with.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JSON格式被引入作为XML格式的替代品，当不需要XML的可扩展性和冗长性时，从而减轻复杂XML处理对资源的消耗，让较小的设备能够消费它们需要与之交互的不同服务产生的数据流或数据包。
- en: Before the Java EE 7 specification there was no standard API to process JSON
    documents in Java but rather there were some open source projects such as **google-gson**,
    [https://code.google.com/p/google-gson](https://code.google.com/p/google-gson
    ) and **Jackson**, [http://jackson.codehaus.org](http://jackson.codehaus.org)
    to manipulate JSON documents. With Java EE 7 and the addition of JSON-P to the
    arsenal, a standard API is added to Java EE to let the developers manipulate JSON
    documents in a standard fashion similar to XML processing of APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE 7规范之前，Java中没有标准API来处理JSON文档，而是有一些开源项目，如**google-gson**，[https://code.google.com/p/google-gson](https://code.google.com/p/google-gson)
    和 **Jackson**，[http://jackson.codehaus.org](http://jackson.codehaus.org)，用于操作JSON文档。随着Java
    EE 7的发布以及JSON-P的加入，Java EE中添加了一个标准API，允许开发者以类似于XML处理API的方式标准地操作JSON文档。
- en: The JSON-P API provides two parsing methods to parse JSON documents, the same
    two models that are available for parsing XML documents. The streaming event-based
    parsing and the object model tree parsing which are explained in the next two
    sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P API提供了两种解析JSON文档的方法，与解析XML文档可用的相同两种模型。下一节将解释的基于流的基于事件的解析和基于对象模型树的解析。
- en: An overview of JSON API
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON API概述
- en: The following table shows the important API segments of JSON-P along with a
    brief description of each class. The JSON API-related classes are placed under
    the `javax.json` package. The follow-up sections cover how each one of these can
    be used.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了JSON-P的重要API段以及每个类的简要描述。与JSON API相关的类位于`javax.json`包下。后续章节将介绍如何使用这些类。
- en: '| Class | Description and use |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 描述和使用 |'
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `JsonParser` | A Pull parser to parse JSON objects using event model. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `JsonParser` | 一个使用事件模型的拉式解析器，用于解析JSON对象。 |'
- en: '| `JsonGenerator` | A JSON stream writer to write JSON objects to an output
    source such as `OutputStream` and `Writ` `er` in a streaming manner. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `JsonGenerator` | 一个JSON流写入器，以流式方式将JSON对象写入输出源，如`OutputStream`和`Writer`。
    |'
- en: '| `JsonBuilder` | Builds `JsonObject` and `JsonArray` Programmatically |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `JsonBuilder` | 以编程方式构建`JsonObject`和`JsonArray` |'
- en: '| `JsonReader` | Reads `JsonObject` and `JsonArray` from input source |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `JsonReader` | 从输入源读取`JsonObject`和`JsonArray` |'
- en: '| `JsonWriter` | Writes `JsonObject` and `JsonArray` to output source |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `JsonWriter` | 将`JsonObject`和`JsonArray`写入输出源 |'
- en: '| `JsonObject and JsonArray` | To store `JSONObject` and array structure |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `JsonObject`和`JsonArray` | 用于存储`JSONObject`和数组结构 |'
- en: '| `JsonString and JsonNumber` | To store string and numerical values |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `JsonString`和`JsonNumber` | 用于存储字符串和数值 |'
- en: The `JSONObject` is the entry point to the entire JSON API arsenal. For each
    one of the following objects JSON API provides a factory method as well as a creator
    to create them. For example, `Json.createParser` and `Json.createParserFactory`
    can be used to create a JSON parser. The factory can be configured to produce
    customized parsers or, when more than one parser is required, to reduce the performance
    overhead of creating the parsers while the `createParser` overloads can be used
    to create a JSON parser with a default configuration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONObject` 是整个 JSON API 工具箱的入口点。对于以下每个对象，JSON API 都提供了一个工厂方法以及一个创建器来创建它们。例如，`Json.createParser`
    和 `Json.createParserFactory` 可以用来创建一个 JSON 解析器。工厂可以被配置为生成定制的解析器，或者当需要多个解析器时，以减少创建解析器的性能开销，而
    `createParser` 重载可以用来创建具有默认配置的 JSON 解析器。'
- en: Manipulating JSON documents using the event-based API
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于事件的 API 操作 JSON 文档
- en: The event-based API is best used when a one way, going forward, parsing or producing
    of JSON documents is required. The event-based API works similar to **StAX** parsing
    of XML documents but in a much simpler (due to the JSON format being much simpler)
    fashion.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要单方向、向前解析或生成 JSON 文档时，最好使用基于事件的 API。基于事件的 API 的工作方式类似于 XML 文档的 **StAX** 解析，但方式更为简单（因为
    JSON 格式更为简单）。
- en: Producing JSON documents
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 JSON 文档
- en: Producing JSON documents using the event-based API is most suitable when a stream
    of events is arriving and they require transforming to JSON format for another
    processor that consumes JSON format.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一系列事件到达，并且需要将它们转换为 JSON 格式供其他消费 JSON 格式的处理器使用时，使用基于事件的 API 来生成 JSON 文档是最合适的。
- en: 'The following sample code shows how to generate JSON output using `JsonGenerator`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了如何使用 `JsonGenerator` 生成 JSON 输出：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Executing the preceding code produces the following content in the standard
    output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会在标准输出中产生以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the beginning of the code, the properties object that is created can be used
    to add directives on what behaviors are expected from the `JsonGenerator` object.
    The directives that can be specified differ from implementation to implementation
    but here the `JsonGenerator.PRETTY_PRINTING` is used to ensure that the resulting
    JSON document is formatted and human-readable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开始部分，创建的属性对象可以用来向 `JsonGenerator` 对象添加预期的行为指令。可以指定的指令因实现而异，但在这里使用 `JsonGenerator.PRETTY_PRINTING`
    确保生成的 JSON 文档格式化且易于阅读。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `JsonParser`, `JsonGenerator`, `JsonReader`, `JsonWriter` can be used in
    Automatic Resource Management blocks, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonParser`、`JsonGenerator`、`JsonReader`、`JsonWriter` 可以在自动资源管理块中使用，例如：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Parsing JSON documents
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 JSON 文档
- en: Assuming that the result of the previous sample is saved to a file named `output.json`,
    the following snippet can be used to parse the `output.json` using stream parser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前一个示例的结果已保存到名为 `output.json` 的文件中，以下代码片段可以用来使用流解析器解析 `output.json`。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The event types that should be processed when parsing a JSON document are listed
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 JSON 文档时应处理的的事件类型如下列出：
- en: '`START_ARRAY`: Indicating start of an array in the JSON document'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_ARRAY`：指示 JSON 文档中的数组开始'
- en: '`START_OBJECT`: Indicating start of an object'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_OBJECT`：指示对象的开始'
- en: '`KEY_NAME`: Name of the key'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY_NAME`：键的名称'
- en: '`VALUE_STRING`: When the key''s value is string'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VALUE_STRING`：当键的值是字符串时'
- en: '`VALUE_NUMBER`: When the value is number'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VALUE_NUMBER`：当值是数字时'
- en: '`VALUE_NULL`: If the value is null'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VALUE_NULL`：如果值是 null'
- en: '`VALUE_FALSE`: If value is Boolean false'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VALUE_FALSE`：如果值是布尔值 false'
- en: '`VALUE_TRUE`: If value is Boolean true'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VALUE_TRUE`：如果值是布尔值 true'
- en: '`END_OBJECT`: End of an object is reached'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`END_OBJECT`：到达对象的末尾'
- en: '`END_ARRAY`: End of an array is reached'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`END_ARRAY`：到达数组的末尾'
- en: Manipulating JSON documents using the JSON object model
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON 对象模型操作 JSON 文档
- en: The document object model for parsing JSON provides the same flexibilities and
    limitation that XML DOM parsing provides. The list of flexibilities includes but
    not limited to, forward and backward traversing and manipulating the DOM tree;
    the disadvantages or the tradeoff are on the parser speed and memory requirement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 JSON 的文档对象模型提供了与 XML DOM 解析相同的灵活性和限制。灵活性的列表包括但不限于，向前和向后遍历和操作 DOM 树；缺点或权衡在于解析速度和内存需求。
- en: Generating JSON documents
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成 JSON 文档
- en: 'The following sample code shows how to generate JSON documents using the builder
    API and later on writing the produced object to standard output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了如何使用构建器 API 生成 JSON 文档，然后将其产生的对象写入标准输出：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note the use of configuration properties passed when the `JsonBuilderFactory`
    is created. Depending on the JSON API implementation, different configuration
    parameters can be passed to the factory to produce customized `JsonBuilder` objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在创建 `JsonBuilderFactory` 时传递的配置属性。根据 JSON API 实现，可以向工厂传递不同的配置参数以生成定制的 `JsonBuilder`
    对象。
- en: 'The resulting JSON output looks like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 JSON 输出看起来如下：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Parsing JSON documents
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析 JSON 文档
- en: Parsing a `JSONObject` using the object model is straightforward and starts
    with creating a reader object and reading the input file/document into a `JSONObject`.
    After having access to the `JSONObject`, it is possible to traverse over the primitive
    and array attributes of the `JSONObject`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象模型解析 `JSONObject` 是直接的，从创建读取器对象并将输入文件/文档读取到 `JSONObject` 开始。在访问 `JSONObject`
    后，可以遍历其原始和数组属性。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the sample code shows, reading each attribute of the `JSONObject`is performed
    through typed getters; for example `getString`, `getInt`, `getNull`, `getBoolean`,
    and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例代码所示，读取 `JSONObject` 的每个属性是通过类型化的getter完成的；例如 `getString`、`getInt`、`getNull`、`getBoolean`
    等等。
- en: When to use the streaming versus the object API
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用流式API与对象API
- en: The streaming event based API is useful when you are manipulating large JSON
    documents, which you do not want to store in memory. The object model API is useful
    in the case when you have navigated between different nodes of the JSON document.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在操作大型 JSON 文档，且不希望将其存储在内存中时，基于流的事件驱动 API 是有用的。在你在 JSON 文档的不同节点之间导航的情况下，对象模型
    API 是有用的。
- en: Introducing Servlet 3.1
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Servlet 3.1
- en: 'The Java EE 7 specification brings along an updated specification for Servlet
    API, which addresses some of the community-requested and industry-required changes
    including but not limited to the following list of changes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 7 规范带来了 Servlet API 的更新规范，该规范解决了社区请求和行业需求的一些变化，包括但不限于以下列表中的变化：
- en: Addition of the NIO API to servlet specification
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 NIO API 添加到 servlet 规范中
- en: Adding new protocol upgrading support for WebSockets, and so on
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的 WebSocket 协议升级支持等
- en: The next two sections cover the details of these changes and how they can be
    used.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个部分将详细介绍这些变化及其使用方法。
- en: NIO API and Servlet 3.1
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NIO API 和 Servlet 3.1
- en: Servlet 3 introduced async processing of incoming requests in which a request
    could be placed in a processing queue without a thread being bound to the request
    until the request processing is finished. In Servlet 3.1, another forward step
    made forward in which receiving the request data writing back the response can
    be done in a non-blocking, callback-oriented manner.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 3 引入了异步处理传入请求的功能，其中请求可以在请求处理完成之前被放置在处理队列中，而不需要将线程绑定到请求。在 Servlet 3.1
    中，又向前迈出一步，接收请求数据并写入响应可以以非阻塞、回调为导向的方式进行。
- en: Introducing ReadListener and WriteListener
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 ReadListener 和 WriteListener
- en: The two listeners are introduced to allow developers to basically receive notification
    when there is incoming data available to read rather than blocking until the data
    arrives and to be receiving notification when it is possible to write output without
    being blocked.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 引入两个监听器，允许开发者在有可读数据传入时基本接收通知，而不是阻塞直到数据到达，并在可以写入输出而不被阻塞时接收通知。
- en: The `ReadListener` interface, which provides callback notification on availability
    of data in request's `InputStream` code, is shown in the following listing, a
    simple interface with three methods, which are described after the code snippet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadListener` 接口，它提供在请求的 `InputStream` 中数据可用时的回调通知，如下所示，一个具有三个方法的简单接口，这些方法在代码片段之后进行描述。'
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`onDataAvailable`: Invoked when all data for the current request has been read.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDataAvailable`：在读取当前请求的所有数据后被调用。'
- en: '`onAllDataRead`: Invoked by the container the first time it is possible to
    read data.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAllDataRead`：由容器在第一次可能读取数据时调用。'
- en: 'The `onError`: Invoked when an error occurs processing the request.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：在处理请求时发生错误时调用。'
- en: The `WriteListener`, which provides callback notification when it is possible
    to write data in the Servlet's `OutputStream`, is a simple two methods interface
    that is shown in the following snippet and described afterward.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Servlet的 `OutputStream` 中可能写入数据时，`WriteListener` 会提供回调通知，这是一个简单的两个方法接口，如下所示，并在之后进行描述。
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The container invokes the `onWritePossible` method when it is possible to write
    in the Servlet's `OutputStream`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Servlet的 `OutputStream` 中可能写入时，容器会调用 `onWritePossible` 方法。
- en: The `onError` is invoked when writing in the Servlet's `OutputStream` encounters
    an exception`.`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Servlet的 `OutputStream` 中写入时遇到异常时，会调用 `onError`。
- en: The sample code on how these two listeners can be used is included at the end
    of Servlet 3.1 introduction section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用这两个监听器的示例代码包含在Servlet 3.1介绍部分的末尾。
- en: Changes in the Servlet API interfaces
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Servlet API接口的更改
- en: 'There are some changes in the Servlet API to make it possible to use the newly
    introduced interfaces. These changes are as follow:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用新引入的接口，Servlet API进行了一些更改。这些更改如下：
- en: 'In the `ServletOutputStream` interface:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ServletOutputStream` 接口中：
- en: '`isReady`: This method can be used to determine if data can be written without
    blocking'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isReady`: 该方法可用于确定是否可以无阻塞地写入数据'
- en: '`setWriteListener`: Instructs the `ServletOutputStream` to invoke the provided
    `WriteListener` when it is possible to write'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setWriteListener`: 指示 `ServletOutputStream` 在可能写入时调用提供的 `WriteListener`'
- en: In the `ServletInputStream` interface
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ServletInputStream` 接口中
- en: '`isFinished`: Returns true when all the data from the stream has been read
    else it returns false'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFinished`: 当从流中读取所有数据时返回 true，否则返回 false'
- en: '`isReady`: Returns true if data can be read without blocking else returns false'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isReady`: 如果可以无阻塞地读取数据，则返回 true，否则返回 false'
- en: '`setReadListener`: Instructs the `ServletInputStream` to invoke the provided
    `ReadListener` when it is possible to read'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setReadListener`: 指示 `ServletInputStream` 在可能读取时调用提供的 `ReadListener`'
- en: 'Now it is time to see how the non-blocking Servlet 3.1 API works. The following
    snippet shows an Async Servlet, which uses the non-blocking APIs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看非阻塞的Servlet 3.1 API是如何工作的了。以下代码片段显示了一个使用非阻塞API的异步Servlet：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code starts with declaring the Servlet and enabling asynchronous support
    by specifying the `asyncSupported=true`in the `@WebServlet` annotation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从声明Servlet并启用异步支持开始，通过在 `@WebServlet` 注解中指定 `asyncSupported=true` 来实现。
- en: The next step is to set the `AsyncListener` to handle the `AsyncEvent`s. Invoking
    one of the `AsyncContext` sets the `AsyncListener` for `AsyncContext#addListner`
    overloads. The listener will receive the `AsyncEvents` when an asynchronous invocation
    of the Servlet is completed successfully or ended with timeout or error. Multiple
    listeners can be registered and listeners receive the events in the same order
    they are registered.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置 `AsyncListener` 以处理 `AsyncEvent`s。调用 `AsyncContext` 之一将 `AsyncListener`
    设置为 `AsyncContext#addListner` 重载。当Servlet的异步调用成功完成或因超时或错误结束时会接收 `AsyncEvents`。可以注册多个监听器，并且监听器会按照它们注册的顺序接收事件。
- en: The last part of the code sets the `readListener` for the servlet to a `ReadListener`
    implementation included below. When the `ReadListener`is set, reading the incoming
    requests is delegated to the `ReservationRequestReadListener`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分将servlet的 `readListener` 设置为下面的 `ReadListener` 实现。当设置 `ReadListener`
    时，读取传入请求的操作委托给 `ReservationRequestReadListener`。
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ReservationRequestReadListener.onDataAvailable` is invoked by the container
    when there is data to read and when reading the data is finished the `onAllDataRead`
    is invoked. The `onAllDataRead` performs the business operation on the available
    data and the set the `ResponseWriteListener`, which writes the data, is stored
    in the queue back to the client. The `ResponseWriteListener` is shown in the following
    listing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器有数据可读并且读取数据完成后，会调用 `ReservationRequestReadListener.onDataAvailable`。`onAllDataRead`
    在可用的数据上执行业务操作，并将写入数据的 `ResponseWriteListener` 存储在队列中，然后发送回客户端。`ResponseWriteListener`
    如下所示：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the writing operation is finished either normally or fatally, the context
    needs to be closed for this operation using the `context.complete()` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当写入操作正常或致命地完成时，需要使用 `context.complete()` 方法关闭上下文以执行此操作。
- en: More changes in Servlet 3.1
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Servlet 3.1的更多更改
- en: In addition to non-blocking IO inclusion, Servlet 3.1 brings in support for
    protocol upgrade in order to support the new WebSockets API. The addition of the
    `upgrade` method to `HttpServletRequest` allows developers to upgrade the communication
    protocol to other protocols, if supported by the container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非阻塞 IO 包含之外，Servlet 3.1 还引入了对协议升级的支持，以支持新的 WebSockets API。将 `upgrade` 方法添加到
    `HttpServletRequest` 允许开发者在容器支持的情况下将通信协议升级到其他协议。
- en: When an upgrade request is sent, the application decides to perform the upgrader,
    the `HttpServletRequest#upgrade(ProtocolHandler)` is invoked, and application
    prepares and sends an appropriate response to the client as usual. At this point
    the web container unwinds all the servlet filters and marks the connection to
    be handled by the protocol handler.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送升级请求时，应用程序决定执行升级操作，调用 `HttpServletRequest#upgrade(ProtocolHandler)`，然后应用程序像往常一样准备并发送适当的响应给客户端。此时，Web
    容器将回滚所有 servlet 过滤器，并标记连接由协议处理器处理。
- en: New features in JAX-RS 2.0
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX-RS 2.0 的新特性
- en: 'JAX-RS 2.0 brings in several new features aligned with other lightweight and
    async processing features provided in other components. The new features include
    the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.0 引入了几项新特性，这些特性与其他组件中提供的轻量级和异步处理特性保持一致。新特性包括以下内容：
- en: Client API
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端 API
- en: Common configuration
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规配置
- en: Asynchronous processing
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理
- en: Filters/interceptors
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器/拦截器
- en: Hypermedia support
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超媒体支持
- en: Server-side content negotiation
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端内容协商
- en: From this list of features, this section covers asynchronous processing and
    also the relevance of asynchronous processing to filters/interceptors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个特性列表中，本节涵盖了异步处理，以及异步处理与过滤器/拦截器的相关性。
- en: Asynchronous request and response processing
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步请求和响应处理
- en: 'Asynchronous processing is included in both client and server side APIs of
    JAX-RS 2.0 to facilitate asynchronous interaction between client and server components.
    The following list shows the new interfaces and classes added to support this
    feature:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 异步处理包含在 JAX-RS 2.0 的客户端和服务器端 API 中，以促进客户端和服务器组件之间的异步交互。以下列表显示了为支持此功能添加的新接口和类：
- en: 'Server side:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端：
- en: '`AsyncResponse`:An injectable JAX-RS asynchronous response that provides the
    means for asynchronous server side response processing.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncResponse`：一个可注入的 JAX-RS 异步响应，提供了异步服务器端响应处理的手段。'
- en: '`@Suspended`: `@Suspended` instructs the container that the HTTP request processing
    should happen in a secondary thread.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Suspended`：`@Suspended` 指示容器 HTTP 请求处理应在副线程中发生。'
- en: '`CompletionCallback`: A request processing callback that receives request processing
    completion events.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionCallback`：一个请求处理回调，接收请求处理完成事件。'
- en: '`ConnectionCallback`: Asynchronous request processing lifecycle callback that
    receives connection-related asynchronous response lifecycle events.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionCallback`：异步请求处理生命周期回调，接收与连接相关的异步响应生命周期事件。'
- en: 'Client side:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端：
- en: '`InvocationCallback`: Callback that can be implemented to receive the asynchronous
    processing events from the invocation processing'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvocationCallback`：可以实现的回调，用于接收调用处理的异步处理事件。'
- en: '`Future`: Allows the client to poll for completion of the asynchronous operation
    or to block and wait for it'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`：允许客户端轮询异步操作的完成情况，或者阻塞并等待它'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Future` interface introduced in Java SE 5 provides two different mechanism
    to get the result of an asynchronous operation: first by invoking the `Future.get(…)`
    variants, which block until the result is available or a timeout occurs; the second
    way is to check for the completion by invoking the `isDone()` and `isCancelled()`,
    which are Boolean methods returning the current status of the Future.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 5 中引入的 `Future` 接口提供了两种不同的机制来获取异步操作的结果：首先是通过调用 `Future.get(…)` 变体，这将在结果可用或发生超时之前阻塞；第二种方式是通过调用
    `isDone()` 和 `isCancelled()` 来检查完成情况，这两个布尔方法返回 Future 的当前状态。
- en: 'The following sample code shows how an asynchronous resource can be developed
    using JAX-RS 2 API:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了如何使用 JAX-RS 2 API 开发异步资源：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`BookResource` is a stateless session bean which has a method `borrow()`. This
    method is annotated with `@Asynchronous` annotation, which will work in the fire-and-forget
    manner. When the resource is requested through the `borrow()` method''s resource
    path, a new thread is spawned to work on preparing the request''s response. The
    thread is submitted to the executor for execution and the thread processing the
    client request is released (via `ctx.suspend`) to process other incoming requests.
    When the worker thread, created to prepare the response, is done with preparing
    the response, it invokes the`ctx.resume`, which lets the container know the response
    is ready to be sent back to the client. If the`ctx.resume` is invoked before the
    `ctx.suspend` (the worker thread has prepared the result before the execution
    reaching the `ctx.suspend`) the suspension is ignored and the result will be sent
    to the client.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookResource`是一个无状态会话bean，它有一个`borrow()`方法。此方法使用`@Asynchronous`注解，将以“发射后不管”的方式工作。当通过`borrow()`方法的资源路径请求资源时，会启动一个新线程来处理请求的响应准备。该线程被提交给执行器执行，处理客户端请求的线程通过`ctx.suspend`释放以处理其他传入请求。当用于准备响应的工作线程完成准备响应后，它调用`ctx.resume`，让容器知道响应已准备好发送回客户端。如果在`ctx.suspend`之前调用`ctx.resume`（工作线程在执行达到`ctx.suspend`之前已准备好结果），则挂起将被忽略，并将结果发送给客户端。'
- en: 'Same functionality can be achieved using the `@Suspended` annotation that is
    shown in the following snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下片段中显示的`@Suspended`注解实现相同的功能：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using `@Suspended` is cleaner as it does not involve use of `ExecutionContext`
    method to instruct container to suspend and then resume the communication thread
    when the worker thread, aka the `prepareResponse()` method in this case, is finished.
    The client code to consume the asynchronous resource can use the callback mechanism
    or polling at the code level. The following code shows how to use polling via
    `Future` interface:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Suspended`更为简洁，因为它不涉及使用`ExecutionContext`方法来指示容器在工作线程（在这种情况下是`prepareResponse()`方法）完成时挂起和恢复通信线程。消费异步资源的客户端代码可以使用回调机制或代码级别的轮询。以下代码展示了如何通过`Future`接口进行轮询：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code begins with forming the request to the book resource and then the `Future.get(…)`
    blocks until the response is back from the server or the 30 seconds timeout reaches.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从向图书资源发送请求开始，然后`Future.get(…)`阻塞，直到从服务器返回响应或30秒超时。
- en: Another API for the asynchronous client is to use the `InvocationCallback`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 异步客户端的另一个API是使用`InvocationCallback`。
- en: Filters and interceptors
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器和拦截器
- en: The filters and interceptors are two new concepts added to JAX-RS 2.0 that allow
    developers to intercept incoming and outgoing requests and responses as well as
    operating at stream level on the incoming and outgoing payloads.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器和拦截器是JAX-RS 2.0中添加的两个新概念，允许开发者在请求和响应的入出之间进行拦截，以及在入出有效载荷的流级别上进行操作。
- en: The filters work the same way as Servlet filters work and provide access to
    inbound and outbound messages for tasks such as authentication/logging, auditing,
    etc. while interceptors can be used to perform dumb operations on payload such
    as compressing/decompressing the outgoing responses and incoming requests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的工作方式与Servlet过滤器相同，并提供对入站和出站消息的访问，用于诸如身份验证/日志记录、审计等任务，而拦截器可以用于在有效载荷上执行诸如压缩/解压缩出站响应和入站请求等简单操作。
- en: Filters and interceptors are asynchronous-aware, meaning that they can handle
    both synchronous and asynchronous communications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器和拦截器是异步感知的，这意味着它们可以处理同步和异步通信。
- en: Asynchronous processing in EJB 3.1 and 3.2
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB 3.1和3.2中的异步处理
- en: Before Java EE 6 the only asynchronous processing facility in Java EE was **JMS**
    (**Java Message Service**) and **MDBs** (**Message Driven Beans**) in which a
    session bean method could send a JMS message to describe a request and then let
    an MDB process the request in an asynchronous manner. Using the JMS and MDBs the
    session bean method could return immediately and the client could check for the
    request completion using the reference returned by the method for the long running
    operation being handled by some MDBs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE 6之前，Java EE中唯一的异步处理设施是**JMS**（**Java消息服务**）和**MDBs**（**消息驱动Bean**），其中会话bean方法可以发送JMS消息来描述请求，然后让MDB以异步方式处理请求。使用JMS和MDBs，会话bean方法可以立即返回，客户端可以使用方法返回的引用检查请求的完成情况，该引用用于处理某些MDBs的长时间运行操作。
- en: The above solution works well, as it has worked for a decade now, but it is
    not easy to use and that was the reason for Java EE 6 to introduce the `@Asynchronous`
    annotation to annotate a method in a session bean or the whole session bean class
    as asynchronous. The `@Asynchronous` can be placed on a class to mark all the
    methods in that class as asynchronous or on a method to mark that particular method
    as asynchronous.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述解决方案效果良好，因为它已经工作了十年，但它并不容易使用，这也是 Java EE 6 引入 `@Asynchronous` 注解来注解会话 Bean
    中的方法或整个会话 Bean 类作为异步的原因。`@Asynchronous` 可以放在类上，以标记该类中的所有方法为异步，也可以放在方法上，以标记特定方法为异步。
- en: 'There are two types of asynchronous EJB invocation which are explained as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的异步 EJB 调用，如下所述：
- en: In the first model the method returns `void` and there is no container-provided
    standard mechanism to check the result of the method invocation. This is referred
    to as a **fire-and-forget** mechanism.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个模型中，方法返回 `void`，并且没有容器提供的标准机制来检查方法调用的结果。这被称为**触发并忘记**机制。
- en: In the second model, the container provides a mechanism to check back the result
    of the invocation using a `Future<?>` object returned from the method invocation.
    This mechanism is referred to as **invoke-and-check-later**. Note that `Future`
    is part of the Java SE concurrency package. Having the Future object returned
    from the method, the client can check the result of invocation by using different
    Future methods such as `isDone()` and `get(…)`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个模型中，容器通过方法调用返回的 `Future<?>` 对象提供了一个机制来检查调用的结果。这个机制被称为**调用后检查**。请注意，`Future`
    是 Java SE 并发包的一部分。有了从方法返回的 Future 对象，客户端可以使用不同的 Future 方法（如 `isDone()` 和 `get(…)`)来检查调用的结果。
- en: Before we dive down into sample codes or use the `@Asynchronous` it is worth
    mentioning that, in Java EE 6, the `@Asynchronous` was only available in full
    profile while in Java EE 7 the annotation is added to the web profile as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入示例代码或使用 `@Asynchronous` 之前，值得提一下，在 Java EE 6 中，`@Asynchronous` 只在完整配置文件中可用，而在
    Java EE 7 中，该注解也被添加到 Web 配置文件中。
- en: Developing an asynchronous session bean
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发异步会话 Bean
- en: 'The following listing shows how to use the invoke-and-check-later asynchronous
    EJB methods:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用调用后检查异步 EJB 方法：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`@Stateless` and `@LocalBean` are self-explanatory; they mark this class as
    a stateless session bean with a local interface.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Stateless` 和 `@LocalBean` 是自解释的；它们将这个类标记为具有本地接口的无状态会话 Bean。'
- en: The `search` method is annotated with `@Asynchronous` and this tells the container
    that the method invocation should happen in a separate detached thread; when the
    result is available the returned Future object's `isDone()` returns true.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`search` 方法被注解为 `@Asynchronous`，这告诉容器方法调用应该在单独的分离线程中发生；当结果可用时，返回的 Future 对象的
    `isDone()` 返回 true。'
- en: The `search` itself invokes a presumably long running method, `performSearch`,
    to get the result of the long running search operation the client has requested.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`search` 本身调用一个可能运行时间较长的 `performSearch` 方法，以获取客户端请求的长时间运行搜索操作的结果。'
- en: Developing a client servlet for the async session bean
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发异步会话 Bean 的客户端 Servlet
- en: 'Now that the stateless session bean is developed it is time to develop a client
    that accesses the session bean''s business method. In this case the client is
    a Servlet, which is included in the following code without some of the boilerplate
    codes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在无状态会话 Bean 已经开发完成，是时候开发一个客户端来访问会话 Bean 的业务方法了。在这种情况下，客户端是一个 Servlet，以下代码中包含了部分样板代码：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Starting from the top, we have the servlet declaration annotations, injection
    of the stateless EJB, and the `get` method's implementation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们有 Servlet 声明注解、无状态 EJB 的注入以及 `get` 方法的实现。
- en: The get in the `get` method's implementation invokes the EJB's `search` method
    while passing two different `dummyTime` to simulate the wait. Between invocations
    of the `search` method till the Future object's `isDone` returns true, the client
    code can perform other required operations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get` 方法的实现中，调用 EJB 的 `search` 方法时传递了两个不同的 `dummyTime` 来模拟等待。在 `search` 方法的调用之间，直到
    Future 对象的 `isDone` 返回 true，客户端代码可以执行其他所需的操作。
- en: Now that the invoke-and-check-later model is described we can discuss the other
    Asynchronous EJB invocation model in which the EJB business methods return `void`
    and there is no container-provided way to check the result. We usually use these
    methods to trigger a long-running task that the current thread does not need to
    wait for it to be finished.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经描述了调用并稍后检查的模式，我们可以讨论另一种异步EJB调用模式，其中EJB业务方法返回`void`，并且没有容器提供的检查结果的方式。我们通常使用这些方法来触发一个长时间运行的任务，当前线程不需要等待它完成。
- en: An example of this case is when a new e-book is added to the library and the
    full text search index needs to be updated to include the new book. In such a
    case the procedure that adds the book can invoke a `@Asynchronous` EJB method
    to index the book during the book's registration and after it is uploaded to the
    server's repository. In this way the registration process does not need to wait
    for the FTS indexing to complete while the FTS indexing starts right after the
    book is added to the library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的例子是当图书馆新增一本电子书，全文搜索索引需要更新以包含新书时。在这种情况下，添加书籍的流程可以调用一个`@Asynchronous` EJB方法在书籍注册期间以及上传到服务器仓库后对书籍进行索引。这样，注册过程就不需要等待全文搜索索引完成，而全文搜索索引则是在书籍添加到图书馆后立即开始。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter, the final chapter before showing you some real-world examples,
    discusses JSON processing, Asynchronous JAX-RS resources, which can produce or
    consume JSON data along with discussing the new NIO support in the Servlet 3.1\.
    As `@Asynchronous` EJB is now included in Java EE 7's Web profile we discussed
    that feature along with other new features that are introduced in Java EE7\. The
    next chapter shows real-world examples on how these technologies and APIs can
    be used together to form a solution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，在展示一些真实世界示例之前的最后一章，讨论了JSON处理、异步JAX-RS资源，这些资源可以生成或消费JSON数据，同时讨论了Servlet 3.1中的新NIO支持。由于`@Asynchronous`
    EJB现在包含在Java EE 7的Web配置文件中，我们讨论了该特性以及Java EE7中引入的其他新特性。下一章将展示如何将这些技术和API结合起来形成解决方案的真实世界示例。
